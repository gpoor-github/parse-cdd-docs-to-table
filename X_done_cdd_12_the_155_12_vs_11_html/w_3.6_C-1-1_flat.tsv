"Section"	"section_id"	"req_id"	"full_key"	"key_as_number"	"requirement"	"Test Availability"	"search_roots"	"search_terms"	"manual_search_terms"	"not_search_terms"	"not_files"	"max_matches"	"class_defs"	"methods"	"modules"	"protected"	"class_def"	"method"	"module"	"file_name"	"matched_files"	"methods_string"	"urls"	"method_text"	"matched_terms"	"qualified_method"	"Annotation?"	"New Req for S?"	"New CTS for S?"	"Comment(internal) e.g. why a test is not possible"	"CTS Bug Id"	"CDD Bug Id"	"Area"	"Shortened"	"Test Level"
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"com.android.cts.authboundkey.AuthBoundKeyAppTest"	"testGenerateAuthBoundKey"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/AuthBoundKeyApp/src/com/android/cts/authboundkey/AuthBoundKeyAppTest.java"	""	"public void testGenerateAuthBoundKey() throws Exception {
        KeyStore keyStore = KeyStore.getInstance(KEYSTORE);
        keyStore.load(null);
        KeyGenerator keyGenerator = KeyGenerator.getInstance(
                KeyProperties.KEY_ALGORITHM_AES, KEYSTORE);
        KeyGenParameterSpec spec = new KeyGenParameterSpec.Builder(
                        KEY_NAME, KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT)
                        .setBlockModes(KeyProperties.BLOCK_MODE_CBC)
                        .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_PKCS7)
                        .setUserAuthenticationRequired(true)
                        .setUserAuthenticationParameters(0, KeyProperties.AUTH_DEVICE_CREDENTIAL)
                        .build();
        assertEquals(spec.getUserAuthenticationType(), KeyProperties.AUTH_DEVICE_CREDENTIAL);
        keyGenerator.init(spec);
        SecretKey key = keyGenerator.generateKey();
        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(key.getAlgorithm(),
                                                                   ""AndroidKeyStore"");
        KeyInfo info = (KeyInfo) keyFactory.getKeySpec(key, KeyInfo.class);
        assertEquals(0, info.getUserAuthenticationValidityDurationSeconds());
        assertEquals(KeyProperties.AUTH_DEVICE_CREDENTIAL, info.getUserAuthenticationType());
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.extractnativelibs.cts.CtsExtractNativeLibsHostTestBase"	"isIncrementalInstallSupported"	"CtsExtractNativeLibsHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/packagemanager/extractnativelibs/src/android/extractnativelibs/cts/CtsExtractNativeLibsHostTestBase.java"	""	"public void test/*
 *.
 */
package android.extractnativelibs.cts;

import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

import com.android.compatibility.common.tradefed.build.CompatibilityBuildHelper;
import com.android.tradefed.device.DeviceNotAvailableException;
import com.android.tradefed.targetprep.BuildError;
import com.android.tradefed.targetprep.TargetSetupError;
import com.android.tradefed.targetprep.suite.SuiteApkInstaller;
import com.android.tradefed.testtype.junit4.BaseHostJUnit4Test;
import com.android.tradefed.util.AbiUtils;
import com.android.tradefed.util.FileUtil;

import org.junit.After;
import org.junit.Before;

import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

/**
 * TODO(b/147496159): add more tests.
 */
public class CtsExtractNativeLibsHostTestBase extends BaseHostJUnit4Test {
    static final String TEST_REMOTE_DIR = ""/data/local/tmp/extract_native_libs_test"";
    static final String TEST_APK_RESOURCE_PREFIX = ""/prebuilt/"";
    static final String TEST_HOST_TMP_DIR_PREFIX = ""cts_extract_native_libs_host_test"";

    static final String TEST_APK_NAME_BASE = ""CtsExtractNativeLibsApp"";
    static final String TEST_PKG_NAME_BASE = ""com.android.cts.extractnativelibs.app"";
    static final String TEST_NO_EXTRACT_PKG = TEST_PKG_NAME_BASE + "".noextract"";
    static final String TEST_NO_EXTRACT_CLASS =
            TEST_NO_EXTRACT_PKG + "".ExtractNativeLibsFalseDeviceTest"";
    static final String TEST_NO_EXTRACT_TEST = ""testNativeLibsNotExtracted"";

    static final String TEST_EXTRACT_PKG = TEST_PKG_NAME_BASE + "".extract"";
    static final String TEST_EXTRACT_CLASS =
            TEST_EXTRACT_PKG + "".ExtractNativeLibsTrueDeviceTest"";
    static final String TEST_EXTRACT_TEST = ""testNativeLibsExtracted"";

    static final String TEST_NATIVE_LIB_LOADED_TEST = ""testNativeLibsLoaded"";
    static final String IDSIG_SUFFIX = "".idsig"";

    /** Setup test dir. */
    @Before
    public void setUp() throws Exception {
        getDevice().executeShellCommand(""mkdir "" + TEST_REMOTE_DIR);
    }

    /** Uninstall apps after tests. */
    @After
    public void cleanUp() throws Exception {
        uninstallPackage(getDevice(), TEST_NO_EXTRACT_PKG);
        uninstallPackage(getDevice(), TEST_EXTRACT_PKG);
        getDevice().executeShellCommand(""rm -r "" + TEST_REMOTE_DIR);
    }

    boolean isIncrementalInstallSupported() throws Exception {
        return ""true\n"".equals(getDevice().executeShellCommand(
                ""pm has-feature android.software.incremental_delivery""));
    }

    static String getTestApkName(boolean isExtractNativeLibs, String abiSuffix) {
        return TEST_APK_NAME_BASE + (isExtractNativeLibs ? ""True"" : ""False"") + abiSuffix + "".apk"";
    }

    static String getTestPackageName(boolean isExtractNativeLibs) {
        return isExtractNativeLibs ? TEST_EXTRACT_PKG : TEST_NO_EXTRACT_PKG;
    }

    static String getTestClassName(boolean isExtractNativeLibs) {
        return isExtractNativeLibs ? TEST_EXTRACT_CLASS : TEST_NO_EXTRACT_CLASS;
    }

    final void installPackage(boolean isIncremental, String apkName) throws Exception {
        installPackage(isIncremental, apkName, """");
    }

    final void installPackage(boolean isIncremental, String apkName, String abi) throws Exception {
        if (isIncremental) {
            installPackageIncremental(apkName, abi);
        } else {
            installPackageLegacy(apkName, abi);
        }
    }

    final boolean checkNativeLibDir(boolean isExtractNativeLibs, String abi) throws Exception {
        if (isExtractNativeLibs) {
            return checkExtractedNativeLibDirForAbi(abi);
        } else {
            return runDeviceTests(
                    TEST_NO_EXTRACT_PKG, TEST_NO_EXTRACT_CLASS, TEST_NO_EXTRACT_TEST);
        }
    }

    File getFileFromResource(String filenameInResources) throws Exception {
        String fullResourceName = TEST_APK_RESOURCE_PREFIX + filenameInResources;
        File tempDir = FileUtil.createTempDir(TEST_HOST_TMP_DIR_PREFIX);
        File file = new File(tempDir, filenameInResources);
        InputStream in = getClass().getResourceAsStream(fullResourceName);
        if (in == null) {
            throw new IllegalArgumentException(""Resource not found: "" + fullResourceName);
        }
        OutputStream out = new BufferedOutputStream(new FileOutputStream(file));
        byte[] buf = new byte[65536];
        int chunkSize;
        while ((chunkSize = in.read(buf)) != -1) {
            out.write(buf, 0, chunkSize);
        }
        out.close();
        return file;
    }

    private boolean runDeviceTestsWithArgs(String pkgName, String testClassName,
            String testMethodName, Map<String, String> testArgs) throws Exception {
        final String testRunner = ""androidx.test.runner.AndroidJUnitRunner"";
        final long defaultTestTimeoutMs = 60 * 1000L;
        final long defaultMaxTimeoutToOutputMs = 60 * 1000L; // 1min
        return runDeviceTests(getDevice(), testRunner, pkgName, testClassName, testMethodName,
                null, defaultTestTimeoutMs, defaultMaxTimeoutToOutputMs,
                0L, true, false, testArgs);
    }

    private void installPackageLegacy(String apkFileName, String abi)
            throws DeviceNotAvailableException, TargetSetupError {
        SuiteApkInstaller installer = new SuiteApkInstaller();
        installer.addTestFileName(apkFileName);
        final String abiFlag = createAbiFlag(abi);
        if (!abiFlag.isEmpty()) {
            installer.addInstallArg(abiFlag);
        }
        try {
            installer.setUp(getTestInformation());
        } catch (BuildError e) {
            throw new TargetSetupError(e.getMessage(), e, getDevice().getDeviceDescriptor());
        }
    }

    private boolean checkExtractedNativeLibDirForAbi(String abiSuffix) throws Exception {
        final String libAbi = getExpectedLibAbi(abiSuffix);
        assertNotNull(libAbi);
        final String expectedSubDirArg = ""expectedSubDir"";
        final String expectedNativeLibSubDir = AbiUtils.getArchForAbi(libAbi);
        final Map<String, String> testArgs = new HashMap<>();
        testArgs.put(expectedSubDirArg, expectedNativeLibSubDir);
        return runDeviceTestsWithArgs(TEST_EXTRACT_PKG, TEST_EXTRACT_CLASS, TEST_EXTRACT_TEST,
                testArgs);
    }

    /** Given the abi included in the APK, predict which abi libs will be installed
     * @param abiSuffix ""64"" means the APK contains only 64-bit native libs
     *                  ""32"" means the APK contains only 32-bit native libs
     *                  ""Both"" means the APK contains both 32-bit and 64-bit native libs
     * @return an ABI string from AbiUtils.ABI_*
     * @return an ABI string from AbiUtils.ABI_*
     */
    final String getExpectedLibAbi(String abiSuffix) {
        final String testAbi = getAbi().getName();
        final String testBitness = AbiUtils.getBitness(testAbi);
        final String libBitness;
        // Use 32-bit native libs if test only supports 32-bit or APK only has 32-libs native libs
        if (abiSuffix.equals(""32"") || testBitness.equals(""32"")) {
            libBitness = ""32"";
        } else {
            libBitness = ""64"";
        }
        final Set<String> libAbis = AbiUtils.getAbisForArch(AbiUtils.getBaseArchForAbi(testAbi));
        for (String libAbi : libAbis) {
            if (AbiUtils.getBitness(libAbi).equals(libBitness)) {
                return libAbi;
            }
        }
        return null;
    }

    /**
     * Get ABIs supported by the test APKs. For example, if the test ABI is ""armeabi-v7a"", the test
     * APKs should include native libs for ""armeabi-v7a"" and/or ""arm64-v8a"".
     */
    final Set<String> getApkAbis() throws Exception {
        String testApkBaseArch = AbiUtils.getArchForAbi(getAbi().getName());
        return AbiUtils.getAbisForArch(testApkBaseArch);
    }

    final String getDeviceAbi() throws Exception {
        return getDevice().getProperty(""ro.product.cpu.abi"");
    }

    /**
     * Device ABIs might includes native bridge ABIs that are different from base arch (e.g.,
     * emulators with NDK translations).
     */
    final Set<String> getDeviceAbis() throws Exception {
        String[] deviceAbis = getDevice().getProperty(""ro.product.cpu.abilist"").split("","");
        return new HashSet<>(Arrays.asList(deviceAbis));
    }

    final Set<String> getDeviceAbiSuffixes() throws Exception {
        HashSet<String> abiSuffixes = new HashSet<String>();
        for (String abi : getDeviceAbis()) {
            abiSuffixes.add(AbiUtils.getBitness(abi));
        }
        return abiSuffixes;
    }

    private void installPackageIncremental(String apkName, String abi) throws Exception {
        CompatibilityBuildHelper buildHelper = new CompatibilityBuildHelper(getBuild());
        final File apk = buildHelper.getTestFile(apkName);
        assertNotNull(apk);
        final File v4Signature = buildHelper.getTestFile(apkName + IDSIG_SUFFIX);
        assertNotNull(v4Signature);
        installPackageIncrementalFromFiles(apk, v4Signature, abi);
    }

    private String installPackageIncrementalFromFiles(File apk, File v4Signature, String abi)
            throws Exception {
        final String remoteApkPath = TEST_REMOTE_DIR + ""/"" + apk.getName();
        final String remoteIdsigPath = remoteApkPath + IDSIG_SUFFIX;
        assertTrue(getDevice().pushFile(apk, remoteApkPath));
        assertTrue(getDevice().pushFile(v4Signature, remoteIdsigPath));
        return getDevice().executeShellCommand(""pm install-incremental ""
                + createAbiFlag(abi)
                + "" -t -g "" + remoteApkPath);
    }

    private String createAbiFlag(String abi) {
        return abi.isEmpty() ? """" : (""--abi "" + abi);
    }

    final String installIncrementalPackageFromResource(String apkFilenameInRes)
            throws Exception {
        final File apkFile = getFileFromResource(apkFilenameInRes);
        final File v4SignatureFile = getFileFromResource(
                apkFilenameInRes + IDSIG_SUFFIX);
        return installPackageIncrementalFromFiles(apkFile, v4SignatureFile, """");
    }
}"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.jobscheduler.cts.ConnectivityConstraintTest"	"testCellularConstraintExecutedAndStopped_Foreground"	"CtsJobSchedulerTestCases"	"/home/gpoor/cts-12-source/cts/tests/JobScheduler/src/android/jobscheduler/cts/ConnectivityConstraintTest.java"	""	"public void testCellularConstraintExecutedAndStopped_Foreground() throws Exception {
        if (mHasWifi) {
            setWifiMeteredState(true);
        } else if (checkDeviceSupportsMobileData()) {
            disconnectWifiToConnectToMobile();
        } else {
            // No mobile or wifi.
            return;
        }

        mTestAppInterface = new TestAppInterface(mContext, CONNECTIVITY_JOB_ID);
        mTestAppInterface.startAndKeepTestActivity();
        toggleScreenOn(true);

        mTestAppInterface.scheduleJob(false,  JobInfo.NETWORK_TYPE_ANY, false);

        mTestAppInterface.runSatisfiedJob();
        assertTrue(""Job with metered connectivity constraint did not fire on a metered network."",
                mTestAppInterface.awaitJobStart(30_000));

        setDataSaverEnabled(true);
        assertFalse(
                ""Job with metered connectivity constraint for foreground app was stopped when""
                        + "" Data Saver was turned on."",
                mTestAppInterface.awaitJobStop(30_000));
    }

    /**
     * Schedule an expedited job that requires a network connection, and verify that it runs even
     * when if an app is idle.
     */"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.jobscheduler.cts.ConnectivityConstraintTest"	"testFgExpeditedJobBypassesDataSaver"	"CtsJobSchedulerTestCases"	"/home/gpoor/cts-12-source/cts/tests/JobScheduler/src/android/jobscheduler/cts/ConnectivityConstraintTest.java"	""	"public void testFgExpeditedJobBypassesDataSaver() throws Exception {
        if (mHasWifi) {
            setWifiMeteredState(true);
        } else if (checkDeviceSupportsMobileData()) {
            disconnectWifiToConnectToMobile();
        } else {
            Log.d(TAG, ""Skipping test that requires a metered network."");
            return;
        }
        setDataSaverEnabled(true);

        mTestAppInterface = new TestAppInterface(mContext, CONNECTIVITY_JOB_ID);
        mTestAppInterface.startAndKeepTestActivity();

        mTestAppInterface.scheduleJob(false,  JobInfo.NETWORK_TYPE_ANY, true);
        mTestAppInterface.runSatisfiedJob();

        assertTrue(
                ""FG expedited job requiring metered connectivity did not fire with Data Saver on."",
                mTestAppInterface.awaitJobStart(DEFAULT_TIMEOUT_MILLIS));
    }

    /**
     * Schedule an expedited job that requires a network connection, and verify that it runs even
     * when multiple firewalls are active.
     */"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.widget.cts.TextViewTest"	"testAccessMovementMethod"	"CtsWidgetTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	"public void testAccessMovementMethod() throws Throwable {
        final CharSequence LONG_TEXT = ""Scrolls the specified widget to the specified ""
                + ""coordinates, except constrains the X scrolling position to the horizontal ""
                + ""regions of the text that will be visible after scrolling to ""
                + ""the specified Y position."";
        final int selectionStart = 10;
        final int selectionEnd = LONG_TEXT.length();
        final MovementMethod movementMethod = ArrowKeyMovementMethod.getInstance();
        mActivityRule.runOnUiThread(() -> {
            mTextView = findTextView(R.id.textview_text);
            mTextView.setMovementMethod(movementMethod);
            mTextView.setText(LONG_TEXT, BufferType.EDITABLE);
            Selection.setSelection((Editable) mTextView.getText(),
                    selectionStart, selectionEnd);
            mTextView.requestFocus();
        });
        mInstrumentation.waitForIdleSync();

        assertSame(movementMethod, mTextView.getMovementMethod());
        assertEquals(selectionStart, Selection.getSelectionStart(mTextView.getText()));
        assertEquals(selectionEnd, Selection.getSelectionEnd(mTextView.getText()));
        CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, KeyEvent.KEYCODE_SHIFT_LEFT,
                KeyEvent.KEYCODE_ALT_LEFT, KeyEvent.KEYCODE_DPAD_UP);
        // the selection has been removed.
        assertEquals(selectionStart, Selection.getSelectionStart(mTextView.getText()));
        assertEquals(selectionStart, Selection.getSelectionEnd(mTextView.getText()));

        mActivityRule.runOnUiThread(() -> {
            mTextView.setMovementMethod(null);
            Selection.setSelection((Editable) mTextView.getText(),
                    selectionStart, selectionEnd);
            mTextView.requestFocus();
        });
        mInstrumentation.waitForIdleSync();

        assertNull(mTextView.getMovementMethod());
        assertEquals(selectionStart, Selection.getSelectionStart(mTextView.getText()));
        assertEquals(selectionEnd, Selection.getSelectionEnd(mTextView.getText()));
        CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, KeyEvent.KEYCODE_SHIFT_LEFT,
                KeyEvent.KEYCODE_ALT_LEFT, KeyEvent.KEYCODE_DPAD_UP);
        // the selection will not be changed.
        assertEquals(selectionStart, Selection.getSelectionStart(mTextView.getText()));
        assertEquals(selectionEnd, Selection.getSelectionEnd(mTextView.getText()));
    }

    @UiThreadTest"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.widget.cts.TextViewTest"	"testUndo_delete"	"CtsWidgetTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	"public void testUndo_delete() throws Throwable {
        initTextViewForTypingOnUiThread();

        // Simulate deleting text and undoing it.
        CtsKeyEventUtil.sendString(mInstrumentation, mTextView, ""xyz"");
        CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, KeyEvent.KEYCODE_DEL,
                KeyEvent.KEYCODE_DEL, KeyEvent.KEYCODE_DEL);
        mActivityRule.runOnUiThread(() -> {
            // Precondition: The text was actually deleted.
            assertEquals("""", mTextView.getText().toString());
            assertEquals(0, mTextView.getSelectionStart());

            // Undo restores the typed string and cursor position in one step.
            mTextView.onTextContextMenuItem(android.R.id.undo);
            assertEquals(""xyz"", mTextView.getText().toString());
            assertEquals(3, mTextView.getSelectionStart());

            // Redo removes the text in one step.
            mTextView.onTextContextMenuItem(android.R.id.redo);
            assertEquals("""", mTextView.getText().toString());
            assertEquals(0, mTextView.getSelectionStart());

            // Undoing the redo restores the text again.
            mTextView.onTextContextMenuItem(android.R.id.undo);
            assertEquals(""xyz"", mTextView.getText().toString());
            assertEquals(3, mTextView.getSelectionStart());

            // Undoing again undoes the original typing.
            mTextView.onTextContextMenuItem(android.R.id.undo);
            assertEquals("""", mTextView.getText().toString());
            assertEquals(0, mTextView.getSelectionStart());
        });
        mInstrumentation.waitForIdleSync();
    }

    // Initialize the text view for simulated IME typing. Must be called on UI thread.
    private InputConnection initTextViewForSimulatedIme() {
        mTextView = findTextView(R.id.textview_text);
        return initTextViewForSimulatedIme(mTextView);
    }

    private InputConnection initTextViewForSimulatedIme(TextView textView) {
        textView.setKeyListener(QwertyKeyListener.getInstance(false, Capitalize.NONE));
        textView.setText("""", BufferType.EDITABLE);
        return textView.onCreateInputConnection(new EditorInfo());
    }

    // Simulates IME composing text behavior.
    private void setComposingTextInBatch(InputConnection input, CharSequence text) {
        input.beginBatchEdit();
        input.setComposingText(text, 1);  // Leave cursor at end.
        input.endBatchEdit();
    }

    @UiThreadTest"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.widget.cts.TextViewTest"	"testUndo_setText"	"CtsWidgetTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	"public void testUndo_setText() throws Throwable {
        initTextViewForTypingOnUiThread();

        // Create two undo operations, an insert and a delete.
        CtsKeyEventUtil.sendString(mInstrumentation, mTextView, ""xyz"");
        CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, KeyEvent.KEYCODE_DEL,
                KeyEvent.KEYCODE_DEL, KeyEvent.KEYCODE_DEL);
        mActivityRule.runOnUiThread(() -> {
            // Calling setText() clears both undo operations, so undo doesn't happen.
            mTextView.setText(""Hello"", BufferType.EDITABLE);
            mTextView.onTextContextMenuItem(android.R.id.undo);
            assertEquals(""Hello"", mTextView.getText().toString());

            // Clearing text programmatically does not undo either.
            mTextView.setText("""", BufferType.EDITABLE);
            mTextView.onTextContextMenuItem(android.R.id.undo);
            assertEquals("""", mTextView.getText().toString());
        });
        mInstrumentation.waitForIdleSync();
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.widget.cts.TextViewTest"	"testUndo_saveInstanceState"	"CtsWidgetTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	"public void testUndo_saveInstanceState() throws Throwable {
        initTextViewForTypingOnUiThread();

        // Type some text to create an undo operation.
        CtsKeyEventUtil.sendString(mInstrumentation, mTextView, ""abc"");
        mActivityRule.runOnUiThread(() -> {
            // Parcel and unparcel the TextView.
            Parcelable state = mTextView.onSaveInstanceState();
            mTextView.onRestoreInstanceState(state);
        });
        mInstrumentation.waitForIdleSync();

        // Delete a character to create a new undo operation.
        CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, KeyEvent.KEYCODE_DEL);
        mActivityRule.runOnUiThread(() -> {
            assertEquals(""ab"", mTextView.getText().toString());

            // Undo the delete.
            mTextView.onTextContextMenuItem(android.R.id.undo);
            assertEquals(""abc"", mTextView.getText().toString());

            // Undo the typing, which verifies that the original undo operation was parceled
            // correctly.
            mTextView.onTextContextMenuItem(android.R.id.undo);
            assertEquals("""", mTextView.getText().toString());

            // Parcel and unparcel the undo stack (which is empty but has been used and may
            // contain other state).
            Parcelable state = mTextView.onSaveInstanceState();
            mTextView.onRestoreInstanceState(state);
        });
        mInstrumentation.waitForIdleSync();
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.widget.cts.TextViewTest"	"testUndo_saveInstanceStateEmpty"	"CtsWidgetTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	"public void testUndo_saveInstanceStateEmpty() throws Throwable {
        initTextViewForTypingOnUiThread();

        // Type and delete to create two new undo operations.
        CtsKeyEventUtil.sendString(mInstrumentation, mTextView, ""a"");
        CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, KeyEvent.KEYCODE_DEL);
        mActivityRule.runOnUiThread(() -> {
            // Empty the undo stack then parcel and unparcel the TextView. While the undo
            // stack contains no operations it may contain other state.
            mTextView.onTextContextMenuItem(android.R.id.undo);
            mTextView.onTextContextMenuItem(android.R.id.undo);
            Parcelable state = mTextView.onSaveInstanceState();
            mTextView.onRestoreInstanceState(state);
        });
        mInstrumentation.waitForIdleSync();

        // Create two more undo operations.
        CtsKeyEventUtil.sendString(mInstrumentation, mTextView, ""b"");
        CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, KeyEvent.KEYCODE_DEL);
        mActivityRule.runOnUiThread(() -> {
            // Verify undo still works.
            mTextView.onTextContextMenuItem(android.R.id.undo);
            assertEquals(""b"", mTextView.getText().toString());
            mTextView.onTextContextMenuItem(android.R.id.undo);
            assertEquals("""", mTextView.getText().toString());
        });
        mInstrumentation.waitForIdleSync();
    }

    @UiThreadTest"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.widget.cts.TextViewTest"	"testCopyAndPaste_byKey"	"CtsWidgetTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	"public void testCopyAndPaste_byKey() throws Throwable {
        initTextViewForTypingOnUiThread();

        // Type ""abc"".
        CtsKeyEventUtil.sendString(mInstrumentation, mTextView, ""abc"");
        mActivityRule.runOnUiThread(() -> {
            // Select ""bc""
            Selection.setSelection((Spannable) mTextView.getText(), 1, 3);
        });
        mInstrumentation.waitForIdleSync();
        // Copy ""bc""
        CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, KeyEvent.KEYCODE_COPY);

        mActivityRule.runOnUiThread(() -> {
            // Set cursor between 'b' and 'c'.
            Selection.setSelection((Spannable) mTextView.getText(), 2, 2);
        });
        mInstrumentation.waitForIdleSync();
        // Paste ""bc""
        CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, KeyEvent.KEYCODE_PASTE);
        assertEquals(""abbcc"", mTextView.getText().toString());

        mActivityRule.runOnUiThread(() -> {
            Selection.selectAll((Spannable) mTextView.getText());
            KeyEvent copyWithMeta = new KeyEvent(0, 0, KeyEvent.ACTION_DOWN,
                    KeyEvent.KEYCODE_COPY, 0, KeyEvent.META_SHIFT_LEFT_ON);
            // Shift + copy doesn't perform copy.
            mTextView.onKeyDown(KeyEvent.KEYCODE_COPY, copyWithMeta);
            Selection.setSelection((Spannable) mTextView.getText(), 0, 0);
            mTextView.onTextContextMenuItem(android.R.id.paste);
            assertEquals(""bcabbcc"", mTextView.getText().toString());

            Selection.selectAll((Spannable) mTextView.getText());
            copyWithMeta = new KeyEvent(0, 0, KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_COPY, 0,
                    KeyEvent.META_CTRL_LEFT_ON);
            // Control + copy doesn't perform copy.
            mTextView.onKeyDown(KeyEvent.KEYCODE_COPY, copyWithMeta);
            Selection.setSelection((Spannable) mTextView.getText(), 0, 0);
            mTextView.onTextContextMenuItem(android.R.id.paste);
            assertEquals(""bcbcabbcc"", mTextView.getText().toString());

            Selection.selectAll((Spannable) mTextView.getText());
            copyWithMeta = new KeyEvent(0, 0, KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_COPY, 0,
                    KeyEvent.META_SHIFT_LEFT_ON | KeyEvent.META_CTRL_LEFT_ON);
            // Control + Shift + copy doesn't perform copy.
            mTextView.onKeyDown(KeyEvent.KEYCODE_COPY, copyWithMeta);
            Selection.setSelection((Spannable) mTextView.getText(), 0, 0);
            mTextView.onTextContextMenuItem(android.R.id.paste);
            assertEquals(""bcbcbcabbcc"", mTextView.getText().toString());
        });
        mInstrumentation.waitForIdleSync();
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.widget.cts.TextViewTest"	"testCopyAndPaste_byCtrlInsert"	"CtsWidgetTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	"public void testCopyAndPaste_byCtrlInsert() throws Throwable {
        // Test copy-and-paste by Ctrl-Insert and Shift-Insert.
        initTextViewForTypingOnUiThread();

        // Type ""abc""
        CtsKeyEventUtil.sendString(mInstrumentation, mTextView, ""abc"");
        mActivityRule.runOnUiThread(() -> {
            // Select ""bc""
            Selection.setSelection((Spannable) mTextView.getText(), 1, 3);
        });
        mInstrumentation.waitForIdleSync();

        // Copy ""bc""
        CtsKeyEventUtil.sendKeyWhileHoldingModifier(mInstrumentation, mTextView,
                KeyEvent.KEYCODE_INSERT, KeyEvent.KEYCODE_CTRL_LEFT);
        mActivityRule.runOnUiThread(() -> {
            // Set cursor between 'b' and 'c'
            Selection.setSelection((Spannable) mTextView.getText(), 2, 2);
        });
        mInstrumentation.waitForIdleSync();

        // Paste ""bc""
        CtsKeyEventUtil.sendKeyWhileHoldingModifier(mInstrumentation, mTextView,
                KeyEvent.KEYCODE_INSERT, KeyEvent.KEYCODE_SHIFT_LEFT);
        assertEquals(""abbcc"", mTextView.getText().toString());
    }

    @UiThreadTest"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.widget.cts.TextViewTest"	"testCutAndPaste_byKey"	"CtsWidgetTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	"public void testCutAndPaste_byKey() throws Throwable {
        initTextViewForTypingOnUiThread();

        // Type ""abc"".
        CtsKeyEventUtil.sendString(mInstrumentation, mTextView, ""abc"");
        mActivityRule.runOnUiThread(() -> {
            // Select ""bc""
            Selection.setSelection((Spannable) mTextView.getText(), 1, 3);
        });
        mInstrumentation.waitForIdleSync();
        // Cut ""bc""
        CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, KeyEvent.KEYCODE_CUT);

        mActivityRule.runOnUiThread(() -> {
            assertEquals(""a"", mTextView.getText().toString());
            // Move cursor to the head
            Selection.setSelection((Spannable) mTextView.getText(), 0, 0);
        });
        mInstrumentation.waitForIdleSync();
        // Paste ""bc""
        CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, KeyEvent.KEYCODE_PASTE);
        assertEquals(""bca"", mTextView.getText().toString());

        mActivityRule.runOnUiThread(() -> {
            Selection.selectAll((Spannable) mTextView.getText());
            KeyEvent cutWithMeta = new KeyEvent(0, 0, KeyEvent.ACTION_DOWN,
                    KeyEvent.KEYCODE_CUT, 0, KeyEvent.META_SHIFT_LEFT_ON);
            // Shift + cut doesn't perform cut.
            mTextView.onKeyDown(KeyEvent.KEYCODE_CUT, cutWithMeta);
            assertEquals(""bca"", mTextView.getText().toString());

            cutWithMeta = new KeyEvent(0, 0, KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_CUT, 0,
                    KeyEvent.META_CTRL_LEFT_ON);
            // Control + cut doesn't perform cut.
            mTextView.onKeyDown(KeyEvent.KEYCODE_CUT, cutWithMeta);
            assertEquals(""bca"", mTextView.getText().toString());

            cutWithMeta = new KeyEvent(0, 0, KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_CUT, 0,
                    KeyEvent.META_SHIFT_LEFT_ON | KeyEvent.META_CTRL_LEFT_ON);
            // Control + Shift + cut doesn't perform cut.
            mTextView.onKeyDown(KeyEvent.KEYCODE_CUT, cutWithMeta);
            assertEquals(""bca"", mTextView.getText().toString());
        });
        mInstrumentation.waitForIdleSync();
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.widget.cts.TextViewTest"	"testCutAndPaste_byShiftDelete"	"CtsWidgetTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	"public void testCutAndPaste_byShiftDelete() throws Throwable {
        // Test cut and paste by Shift-Delete and Shift-Insert
        initTextViewForTypingOnUiThread();

        // Type ""abc"".
        CtsKeyEventUtil.sendString(mInstrumentation, mTextView, ""abc"");
        mActivityRule.runOnUiThread(() -> {
            // Select ""bc""
            Selection.setSelection((Spannable) mTextView.getText(), 1, 3);
        });
        mInstrumentation.waitForIdleSync();

        // Cut ""bc""
        CtsKeyEventUtil.sendKeyWhileHoldingModifier(mInstrumentation, mTextView,
                KeyEvent.KEYCODE_FORWARD_DEL, KeyEvent.KEYCODE_SHIFT_LEFT);
        mActivityRule.runOnUiThread(() -> {
            assertEquals(""a"", mTextView.getText().toString());
            // Move cursor to the head
            Selection.setSelection((Spannable) mTextView.getText(), 0, 0);
        });
        mInstrumentation.waitForIdleSync();

        // Paste ""bc""
        CtsKeyEventUtil.sendKeyWhileHoldingModifier(mInstrumentation, mTextView,
                KeyEvent.KEYCODE_INSERT, KeyEvent.KEYCODE_SHIFT_LEFT);
        assertEquals(""bca"", mTextView.getText().toString());
    }

    private static boolean hasSpansAtMiddleOfText(final TextView textView, final Class<?> type) {
        final Spannable spannable = (Spannable)textView.getText();
        final int at = spannable.length() / 2;
        return spannable.getSpans(at, at, type).length > 0;
    }

    @UiThreadTest"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.widget.cts.TextViewTest"	"testPressKey"	"CtsWidgetTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	"public void testPressKey() throws Throwable {
        initTextViewForTypingOnUiThread();

        CtsKeyEventUtil.sendString(mInstrumentation, mTextView, ""a"");
        assertEquals(""a"", mTextView.getText().toString());
        CtsKeyEventUtil.sendString(mInstrumentation, mTextView, ""b"");
        assertEquals(""ab"", mTextView.getText().toString());
        CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, KeyEvent.KEYCODE_DEL);
        assertEquals(""a"", mTextView.getText().toString());
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.widget.cts.TextViewTest"	"testKeyNavigation"	"CtsWidgetTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	"public void testKeyNavigation() throws Throwable {
        initTextViewForTypingOnUiThread();
        mActivityRule.runOnUiThread(() -> {
            mActivity.findViewById(R.id.textview_singleLine).setFocusableInTouchMode(true);
            mActivity.findViewById(R.id.textview_text_two_lines).setFocusableInTouchMode(true);
            mTextView.setMovementMethod(ArrowKeyMovementMethod.getInstance());
            mTextView.setText(""abc"");
            mTextView.setFocusableInTouchMode(true);
        });

        mTextView.requestFocus();
        mInstrumentation.waitForIdleSync();
        assertTrue(mTextView.isFocused());

        // Pure-keyboard arrows should not cause focus to leave the textfield
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTextView, KeyEvent.KEYCODE_DPAD_UP);
        mInstrumentation.waitForIdleSync();
        assertTrue(mTextView.isFocused());

        // Non-pure-keyboard arrows, however, should.
        int dpadRemote = InputDevice.SOURCE_DPAD | InputDevice.SOURCE_KEYBOARD;
        sendSourceKeyDownUp(mInstrumentation, mTextView, KeyEvent.KEYCODE_DPAD_UP, dpadRemote);
        mInstrumentation.waitForIdleSync();
        assertFalse(mTextView.isFocused());

        sendSourceKeyDownUp(mInstrumentation, mTextView, KeyEvent.KEYCODE_DPAD_DOWN, dpadRemote);
        mInstrumentation.waitForIdleSync();
        assertTrue(mTextView.isFocused());

        // Tab should
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTextView, KeyEvent.KEYCODE_TAB);
        mInstrumentation.waitForIdleSync();
        assertFalse(mTextView.isFocused());
    }

    private void sendSourceKeyDownUp(Instrumentation instrumentation, View targetView, int key,
            int source) {
        KeyEvent event = new KeyEvent(KeyEvent.ACTION_DOWN, key);
        event.setSource(source);
        CtsKeyEventUtil.sendKey(instrumentation, targetView, event);
        event = new KeyEvent(KeyEvent.ACTION_UP, key);
        event.setSource(source);
        CtsKeyEventUtil.sendKey(instrumentation, targetView, event);
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.widget.cts.TextViewTest"	"testAccessTransformationMethod"	"CtsWidgetTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	"public void testAccessTransformationMethod() throws Throwable {
        // check the password attribute in xml
        mTextView = findTextView(R.id.textview_password);
        assertNotNull(mTextView);
        assertSame(PasswordTransformationMethod.getInstance(),
                mTextView.getTransformationMethod());

        // check the singleLine attribute in xml
        mTextView = findTextView(R.id.textview_singleLine);
        assertNotNull(mTextView);
        assertSame(SingleLineTransformationMethod.getInstance(),
                mTextView.getTransformationMethod());

        final QwertyKeyListener qwertyKeyListener = QwertyKeyListener.getInstance(false,
                Capitalize.NONE);
        final TransformationMethod method = PasswordTransformationMethod.getInstance();
        // change transformation method by function
        mActivityRule.runOnUiThread(() -> {
            mTextView.setKeyListener(qwertyKeyListener);
            mTextView.setTransformationMethod(method);
            mTransformedText = method.getTransformation(mTextView.getText(), mTextView);

            mTextView.requestFocus();
        });
        mInstrumentation.waitForIdleSync();
        assertSame(PasswordTransformationMethod.getInstance(),
                mTextView.getTransformationMethod());

        CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, ""H E 2*L O"");
        mActivityRule.runOnUiThread(() -> mTextView.append("" ""));
        mInstrumentation.waitForIdleSync();

        // It will get transformed after a while
        // We're waiting for transformation to ""******""
        PollingCheck.waitFor(TIMEOUT, () -> mTransformedText.toString()
                .equals(""\u2022\u2022\u2022\u2022\u2022\u2022""));

        // set null
        mActivityRule.runOnUiThread(() -> mTextView.setTransformationMethod(null));
        mInstrumentation.waitForIdleSync();
        assertNull(mTextView.getTransformationMethod());
    }

    @UiThreadTest"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.media.cts.EncodeDecodeTest"	"testEncodeDecodeVideoFromSurfaceToSurface720pNdk"	"CtsMediaTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/EncodeDecodeTest.java"	""	"public void testEncodeDecodeVideoFromSurfaceToSurface720pNdk() throws Throwable {
        setParameters(1280, 720, 6000000, MIME_TYPE_AVC, true, false);
        SurfaceToSurfaceWrapper.runTest(this, false, USE_NDK);
    }

    /**
     * Tests streaming of AVC video through the encoder and decoder.  Data is provided through
     * a PersistentSurface and decoded onto a Surface.  The output is checked for validity.
     */"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.media.cts.EncodeDecodeTest"	"testEncodeDecodeVideoFromPersistentSurfaceToSurface720pNdk"	"CtsMediaTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/EncodeDecodeTest.java"	""	"public void testEncodeDecodeVideoFromPersistentSurfaceToSurface720pNdk() throws Throwable {
        setParameters(1280, 720, 6000000, MIME_TYPE_AVC, true, false);
        SurfaceToSurfaceWrapper.runTest(this, true, USE_NDK);
    }

    /**
     * Tests streaming of VP8 video through the encoder and decoder.  Data is provided through
     * a Surface and decoded onto a Surface.  The output is checked for validity.
     */"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.media.cts.EncodeDecodeTest"	"testVP8EncodeDecodeVideoFromSurfaceToSurface720pNdk"	"CtsMediaTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/EncodeDecodeTest.java"	""	"public void testVP8EncodeDecodeVideoFromSurfaceToSurface720pNdk() throws Throwable {
        setParameters(1280, 720, 6000000, MIME_TYPE_VP8, true, false);
        SurfaceToSurfaceWrapper.runTest(this, false, USE_NDK);
    }

    /**
     * Tests streaming of VP8 video through the encoder and decoder.  Data is provided through
     * a PersistentSurface and decoded onto a Surface.  The output is checked for validity.
     */"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.media.cts.EncodeDecodeTest"	"testVP8EncodeDecodeVideoFromPersistentSurfaceToSurface720pNdk"	"CtsMediaTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/EncodeDecodeTest.java"	""	"public void testVP8EncodeDecodeVideoFromPersistentSurfaceToSurface720pNdk() throws Throwable {
        setParameters(1280, 720, 6000000, MIME_TYPE_VP8, true, false);
        SurfaceToSurfaceWrapper.runTest(this, true, USE_NDK);
    }

    /** Wraps testEncodeDecodeVideoFromSurfaceToSurface() */
    private static class SurfaceToSurfaceWrapper implements Runnable {
        private Throwable mThrowable;
        private EncodeDecodeTest mTest;
        private boolean mUsePersistentInput;
        private boolean mUseNdk;

        private SurfaceToSurfaceWrapper(EncodeDecodeTest test, boolean persistent, boolean useNdk) {
            mTest = test;
            mUsePersistentInput = persistent;
            mUseNdk = useNdk;
        }

        @Override
        public void run() {
            if (mTest.shouldSkip()) {
                return;
            }

            InputSurfaceInterface inputSurface = null;
            try {
                if (!mUsePersistentInput) {
                    mTest.encodeDecodeVideoFromSurfaceToSurface(null, mUseNdk);
                } else {
                    Log.d(TAG, ""creating persistent surface"");
                    if (mUseNdk) {
                        inputSurface = NdkMediaCodec.createPersistentInputSurface();
                    } else {
                        inputSurface = new InputSurface(MediaCodec.createPersistentInputSurface());
                    }

                    for (int i = 0; i < 3; i++) {
                        Log.d(TAG, ""test persistent surface - round "" + i);
                        mTest.encodeDecodeVideoFromSurfaceToSurface(inputSurface, mUseNdk);
                    }
                }
            } catch (Throwable th) {
                mThrowable = th;
            } finally {
                if (inputSurface != null) {
                    inputSurface.release();
                }
            }
        }

        /**
         * Entry point.
         */
        public static void runTest(EncodeDecodeTest obj, boolean persisent, boolean useNdk)
                throws Throwable {
            SurfaceToSurfaceWrapper wrapper =
                    new SurfaceToSurfaceWrapper(obj, persisent, useNdk);
            Thread th = new Thread(wrapper, ""codec test"");
            th.start();
            th.join();
            if (wrapper.mThrowable != null) {
                throw wrapper.mThrowable;
            }
        }
    }

    /**
     * Sets the desired frame size and bit rate.
     */
    protected void setParameters(int width, int height, int bitRate, String mimeType,
         boolean allowBT601, boolean allowBT709) {
        if ((width % 16) != 0 || (height % 16) != 0) {
            Log.w(TAG, ""WARNING: width or height not multiple of 16"");
        }
        mWidth = width;
        mHeight = height;
        mBitRate = bitRate;
        mMimeType = mimeType;
        mAllowBT601 = allowBT601;
        mAllowBT709 = allowBT709;
    }

    private boolean shouldSkip() {
        if (!MediaUtils.hasEncoder(mMimeType)) {
            return true;
        }

        MediaFormat format = MediaFormat.createVideoFormat(mMimeType, mWidth, mHeight);
        format.setInteger(MediaFormat.KEY_BIT_RATE, mBitRate);
        format.setInteger(MediaFormat.KEY_FRAME_RATE, FRAME_RATE);
        format.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, IFRAME_INTERVAL);
        if (!MediaUtils.checkEncoderForFormat(format)) {
            return true;
        }

        return false;
    }

    /**
     * Tests encoding and subsequently decoding video from frames generated into a buffer.
     * <p>
     * We encode several frames of a video test pattern using MediaCodec, then decode the
     * output with MediaCodec and do some simple checks.
     * <p>
     * See http://b.android.com/37769 for a discussion of input format pitfalls.
     */
    private void encodeDecodeVideoFromBuffer(boolean toSurface) throws Exception {
        if (shouldSkip()) {
            return;
        }

        MediaCodec encoder = null;
        MediaCodec decoder = null;

        mLargestColorDelta = -1;

        try {
            // We avoid the device-specific limitations on width and height by using values that
            // are multiples of 16, which all tested devices seem to be able to handle.
            MediaFormat format = MediaFormat.createVideoFormat(mMimeType, mWidth, mHeight);
            MediaCodecList mcl = new MediaCodecList(MediaCodecList.REGULAR_CODECS);
            String codec = mcl.findEncoderForFormat(format);
            if (codec == null) {
                // Don't fail CTS if they don't have an AVC codec (not here, anyway).
                Log.e(TAG, ""Unable to find an appropriate codec for "" + format);
                return;
            }
            if (VERBOSE) Log.d(TAG, ""found codec: "" + codec);

            String codec_decoder = mcl.findDecoderForFormat(format);
            if (codec_decoder == null) {
                Log.e(TAG, ""Unable to find an appropriate codec for "" + format);
                return;
            }

            // Create a MediaCodec for the desired codec, then configure it as an encoder with
            // our desired properties.
            encoder = MediaCodec.createByCodecName(codec);

            int colorFormat = selectColorFormat(encoder.getCodecInfo(), mMimeType);
            if (VERBOSE) Log.d(TAG, ""found colorFormat: "" + colorFormat);

            // Set some properties.  Failing to specify some of these can cause the MediaCodec
            // configure() call to throw an unhelpful exception.
            format.setInteger(MediaFormat.KEY_COLOR_FORMAT, colorFormat);
            format.setInteger(MediaFormat.KEY_BIT_RATE, mBitRate);
            format.setInteger(MediaFormat.KEY_FRAME_RATE, FRAME_RATE);
            format.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, IFRAME_INTERVAL);
            if (VERBOSE) Log.d(TAG, ""format: "" + format);

            encoder.configure(format, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE);
            encoder.start();

            // Create a MediaCodec for the decoder, just based on the MIME type.  The various
            // format details will be passed through the csd-0 meta-data later on.
            decoder = MediaCodec.createByCodecName(codec_decoder);
            if (VERBOSE) Log.d(TAG, ""got decoder: "" + decoder.getName());

            doEncodeDecodeVideoFromBuffer(encoder, colorFormat, decoder, toSurface);
        } finally {
            if (VERBOSE) Log.d(TAG, ""releasing codecs"");
            if (encoder != null) {
                encoder.stop();
                encoder.release();
            }
            if (decoder != null) {
                decoder.stop();
                decoder.release();
            }

            Log.i(TAG, ""Largest color delta: "" + mLargestColorDelta);
        }
    }

    /**
     * Tests encoding and subsequently decoding video from frames generated into a buffer.
     * <p>
     * We encode several frames of a video test pattern using MediaCodec, then decode the
     * output with MediaCodec and do some simple checks.
     */
    private void encodeDecodeVideoFromSurfaceToSurface(InputSurfaceInterface inSurf, boolean useNdk) throws Exception {
        MediaCodecWrapper encoder = null;
        MediaCodec decoder = null;
        InputSurfaceInterface inputSurface = inSurf;
        OutputSurface outputSurface = null;

        mLargestColorDelta = -1;

        try {
            // We avoid the device-specific limitations on width and height by using values that
            // are multiples of 16, which all tested devices seem to be able to handle.
            MediaFormat format = MediaFormat.createVideoFormat(mMimeType, mWidth, mHeight);
            MediaCodecList mcl = new MediaCodecList(MediaCodecList.REGULAR_CODECS);
            String codec = mcl.findEncoderForFormat(format);
            if (codec == null) {
                // Don't fail CTS if they don't have an AVC codec (not here, anyway).
                Log.e(TAG, ""Unable to find an appropriate codec for "" + format);
                return;
            }
            if (VERBOSE) Log.d(TAG, ""found codec: "" + codec);

            int colorFormat = MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface;

            // Set some properties.  Failing to specify some of these can cause the MediaCodec
            // configure() call to throw an unhelpful exception.
            format.setInteger(MediaFormat.KEY_COLOR_FORMAT, colorFormat);
            format.setInteger(MediaFormat.KEY_BIT_RATE, mBitRate);
            format.setInteger(MediaFormat.KEY_FRAME_RATE, FRAME_RATE);
            format.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, IFRAME_INTERVAL);

            // Set color parameters
            format.setInteger(MediaFormat.KEY_COLOR_RANGE, MediaFormat.COLOR_RANGE_LIMITED);
            format.setInteger(MediaFormat.KEY_COLOR_STANDARD, MediaFormat.COLOR_STANDARD_BT601_PAL);
            format.setInteger(MediaFormat.KEY_COLOR_TRANSFER, MediaFormat.COLOR_TRANSFER_SDR_VIDEO);

            if (VERBOSE) Log.d(TAG, ""format: "" + format);

            // Create the output surface.
            outputSurface = new OutputSurface(mWidth, mHeight);

            // Create a MediaCodec for the decoder, just based on the MIME type.  The various
            // format details will be passed through the csd-0 meta-data later on.
            String codec_decoder = mcl.findDecoderForFormat(format);
            if (codec_decoder == null) {
                Log.e(TAG, ""Unable to find an appropriate codec for "" + format);
                return;
            }
            decoder = MediaCodec.createByCodecName(codec_decoder);
            if (VERBOSE) Log.d(TAG, ""got decoder: "" + decoder.getName());
            decoder.configure(format, outputSurface.getSurface(), null, 0);
            decoder.start();

            // Create a MediaCodec for the desired codec, then configure it as an encoder with
            // our desired properties.  Request a Surface to use for input.
            if (useNdk) {
                encoder = new NdkMediaCodec(codec);
            }else {
                encoder = new SdkMediaCodec(MediaCodec.createByCodecName(codec));
            }
            encoder.configure(format, MediaCodec.CONFIGURE_FLAG_ENCODE);
            if (inSurf != null) {
                Log.d(TAG, ""using persistent surface"");
                encoder.setInputSurface(inputSurface);
                inputSurface.updateSize(mWidth, mHeight);
            } else {
                inputSurface = encoder.createInputSurface();
            }
            encoder.start();

            doEncodeDecodeVideoFromSurfaceToSurface(encoder, inputSurface, decoder, outputSurface);
        } finally {
            if (VERBOSE) Log.d(TAG, ""releasing codecs"");
            if (inSurf == null && inputSurface != null) {
                inputSurface.release();
            }
            if (outputSurface != null) {
                outputSurface.release();
            }
            if (encoder != null) {
                encoder.stop();
                encoder.release();
            }
            if (decoder != null) {
                decoder.stop();
                decoder.release();
            }

            Log.i(TAG, ""Largest color delta: "" + mLargestColorDelta);
        }
    }

    /**
     * Returns a color format that is supported by the codec and by this test code.  If no
     * match is found, this throws a test failure -- the set of formats known to the test
     * should be expanded for new platforms.
     */
    private static int selectColorFormat(MediaCodecInfo codecInfo, String mimeType) {
        MediaCodecInfo.CodecCapabilities capabilities = codecInfo.getCapabilitiesForType(mimeType);
        for (int i = 0; i < capabilities.colorFormats.length; i++) {
            int colorFormat = capabilities.colorFormats[i];
            if (isRecognizedFormat(colorFormat)) {
                return colorFormat;
            }
        }
        fail(""couldn't find a good color format for "" + codecInfo.getName() + "" / "" + mimeType);
        return 0;   // not reached
    }

    /**
     * Returns true if this is a color format that this test code understands (i.e. we know how
     * to read and generate frames in this format).
     */
    private static boolean isRecognizedFormat(int colorFormat) {
        switch (colorFormat) {
            // these are the formats we know how to handle for this test
            case MediaCodecInfo.CodecCapabilities.COLOR_FormatYUV420Planar:
            case MediaCodecInfo.CodecCapabilities.COLOR_FormatYUV420PackedPlanar:
            case MediaCodecInfo.CodecCapabilities.COLOR_FormatYUV420SemiPlanar:
            case MediaCodecInfo.CodecCapabilities.COLOR_FormatYUV420PackedSemiPlanar:
            case MediaCodecInfo.CodecCapabilities.COLOR_TI_FormatYUV420PackedSemiPlanar:
                return true;
            default:
                return false;
        }
    }

    /**
     * Returns true if the specified color format is semi-planar YUV.  Throws an exception
     * if the color format is not recognized (e.g. not YUV).
     */
    private static boolean isSemiPlanarYUV(int colorFormat) {
        switch (colorFormat) {
            case MediaCodecInfo.CodecCapabilities.COLOR_FormatYUV420Planar:
            case MediaCodecInfo.CodecCapabilities.COLOR_FormatYUV420PackedPlanar:
                return false;
            case MediaCodecInfo.CodecCapabilities.COLOR_FormatYUV420SemiPlanar:
            case MediaCodecInfo.CodecCapabilities.COLOR_FormatYUV420PackedSemiPlanar:
            case MediaCodecInfo.CodecCapabilities.COLOR_TI_FormatYUV420PackedSemiPlanar:
                return true;
            default:
                throw new RuntimeException(""unknown format "" + colorFormat);
        }
    }

    /**
     * Does the actual work for encoding frames from buffers of byte[].
     */
    private void doEncodeDecodeVideoFromBuffer(MediaCodec encoder, int encoderColorFormat,
            MediaCodec decoder, boolean toSurface) {
        final int TIMEOUT_USEC = 10000;
        ByteBuffer[] encoderInputBuffers = encoder.getInputBuffers();
        ByteBuffer[] encoderOutputBuffers = encoder.getOutputBuffers();
        ByteBuffer[] decoderInputBuffers = null;
        ByteBuffer[] decoderOutputBuffers = null;
        MediaCodec.BufferInfo decoderInfo = new MediaCodec.BufferInfo();
        MediaCodec.BufferInfo encoderInfo = new MediaCodec.BufferInfo();
        MediaFormat decoderOutputFormat = null;
        int generateIndex = 0;
        int checkIndex = 0;
        int badFrames = 0;
        boolean decoderConfigured = false;
        OutputSurface outputSurface = null;

        // The size of a frame of video data, in the formats we handle, is stride*sliceHeight
        // for Y, and (stride/2)*(sliceHeight/2) for each of the Cb and Cr channels.  Application
        // of algebra and assuming that stride==width and sliceHeight==height yields:
        byte[] frameData = new byte[mWidth * mHeight * 3 / 2];

        // Just out of curiosity.
        long rawSize = 0;
        long encodedSize = 0;

        // Save a copy to disk.  Useful for debugging the test.  Note this is a raw elementary
        // stream, not a .mp4 file, so not all players will know what to do with it.
        FileOutputStream outputStream = null;
        if (DEBUG_SAVE_FILE) {
            String fileName = DEBUG_FILE_NAME_BASE + mWidth + ""x"" + mHeight + "".mp4"";
            try {
                outputStream = new FileOutputStream(fileName);
                Log.d(TAG, ""encoded output will be saved as "" + fileName);
            } catch (IOException ioe) {
                Log.w(TAG, ""Unable to create debug output file "" + fileName);
                throw new RuntimeException(ioe);
            }
        }

        if (toSurface) {
            outputSurface = new OutputSurface(mWidth, mHeight);
        }

        // Loop until the output side is done.
        boolean inputDone = false;
        boolean encoderDone = false;
        boolean outputDone = false;
        int encoderStatus = -1;
        while (!outputDone) {
            if (VERBOSE) Log.d(TAG, ""loop"");


            // If we're not done submitting frames, generate a new one and submit it.  By
            // doing this on every loop we're working to ensure that the encoder always has
            // work to do.
            //
            // We don't really want a timeout here, but sometimes there's a delay opening
            // the encoder device, so a short timeout can keep us from spinning hard.
            if (!inputDone) {
                int inputBufIndex = encoder.dequeueInputBuffer(TIMEOUT_USEC);
                if (VERBOSE) Log.d(TAG, ""inputBufIndex="" + inputBufIndex);
                if (inputBufIndex >= 0) {
                    long ptsUsec = computePresentationTime(generateIndex);
                    if (generateIndex == NUM_FRAMES) {
                        // Send an empty frame with the end-of-stream flag set.  If we set EOS
                        // on a frame with data, that frame data will be ignored, and the
                        // output will be short one frame.
                        encoder.queueInputBuffer(inputBufIndex, 0, 0, ptsUsec,
                                MediaCodec.BUFFER_FLAG_END_OF_STREAM);
                        inputDone = true;
                        if (VERBOSE) Log.d(TAG, ""sent input EOS (with zero-length frame)"");
                    } else {
                        generateFrame(generateIndex, encoderColorFormat, frameData);

                        ByteBuffer inputBuf = encoder.getInputBuffer(inputBufIndex);
                        // the buffer should be sized to hold one full frame
                        assertTrue(inputBuf.capacity() >= frameData.length);
                        inputBuf.clear();
                        inputBuf.put(frameData);

                        encoder.queueInputBuffer(inputBufIndex, 0, frameData.length, ptsUsec, 0);
                        if (VERBOSE) Log.d(TAG, ""submitted frame "" + generateIndex + "" to enc"");
                    }
                    generateIndex++;
                } else {
                    // either all in use, or we timed out during initial setup
                    if (VERBOSE) Log.d(TAG, ""input buffer not available"");
                }
            }

            // Check for output from the encoder.  If there's no output yet, we either need to
            // provide more input, or we need to wait for the encoder to work its magic.  We
            // can't actually tell which is the case, so if we can't get an output buffer right
            // away we loop around and see if it wants more input.
            //
            // Once we get EOS from the encoder, we don't need to do this anymore.
            if (!encoderDone) {
                MediaCodec.BufferInfo info = encoderInfo;
                if (encoderStatus < 0) {
                    encoderStatus = encoder.dequeueOutputBuffer(info, TIMEOUT_USEC);
                }
                if (encoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {
                    // no output available yet
                    if (VERBOSE) Log.d(TAG, ""no output from encoder available"");
                } else if (encoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {
                    // not expected for an encoder
                    encoderOutputBuffers = encoder.getOutputBuffers();
                    if (VERBOSE) Log.d(TAG, ""encoder output buffers changed"");
                } else if (encoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {
                    // expected on API 18+
                    MediaFormat newFormat = encoder.getOutputFormat();
                    if (VERBOSE) Log.d(TAG, ""encoder output format changed: "" + newFormat);
                } else if (encoderStatus < 0) {
                    fail(""unexpected result from encoder.dequeueOutputBuffer: "" + encoderStatus);
                } else { // encoderStatus >= 0
                    ByteBuffer encodedData = encoder.getOutputBuffer(encoderStatus);
                    if (encodedData == null) {
                        fail(""encoderOutputBuffer "" + encoderStatus + "" was null"");
                    }

                    // It's usually necessary to adjust the ByteBuffer values to match BufferInfo.
                    encodedData.position(info.offset);
                    encodedData.limit(info.offset + info.size);

                    boolean releaseBuffer = false;
                    if (!decoderConfigured) {
                        // Codec config info.  Only expected on first packet.  One way to
                        // handle this is to manually stuff the data into the MediaFormat
                        // and pass that to configure().  We do that here to exercise the API.
                        // For codecs that don't have codec config data (such as VP8),
                        // initialize the decoder before trying to decode the first packet.
                        assertTrue((info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) != 0 ||
                                   mMimeType.equals(MIME_TYPE_VP8));
                        MediaFormat format =
                                MediaFormat.createVideoFormat(mMimeType, mWidth, mHeight);
                        if ((info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) != 0)
                            format.setByteBuffer(""csd-0"", encodedData);
                        decoder.configure(format, toSurface ? outputSurface.getSurface() : null,
                                null, 0);
                        decoder.start();
                        decoderInputBuffers = decoder.getInputBuffers();
                        decoderOutputBuffers = decoder.getOutputBuffers();
                        decoderConfigured = true;
                        if (VERBOSE) Log.d(TAG, ""decoder configured ("" + info.size + "" bytes)"");
                    }
                    if ((info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) == 0) {
                        // Get a decoder input buffer
                        assertTrue(decoderConfigured);
                        int inputBufIndex = decoder.dequeueInputBuffer(TIMEOUT_USEC);
                        if (inputBufIndex >= 0) {
                            ByteBuffer inputBuf = decoderInputBuffers[inputBufIndex];
                            inputBuf.clear();
                            inputBuf.put(encodedData);
                            decoder.queueInputBuffer(inputBufIndex, 0, info.size,
                                    info.presentationTimeUs, info.flags);

                            encoderDone = (info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;
                            if (VERBOSE) Log.d(TAG, ""passed "" + info.size + "" bytes to decoder""
                                    + (encoderDone ? "" (EOS)"" : """"));
                            releaseBuffer = true;
                        }
                    } else {
                        releaseBuffer = true;
                    }
                    if (releaseBuffer) {
                        encodedSize += info.size;
                        if (outputStream != null) {
                            byte[] data = new byte[info.size];
                            encodedData.position(info.offset);
                            encodedData.get(data);
                            try {
                                outputStream.write(data);
                            } catch (IOException ioe) {
                                Log.w(TAG, ""failed writing debug data to file"");
                                throw new RuntimeException(ioe);
                            }
                        }
                        encoder.releaseOutputBuffer(encoderStatus, false);
                        encoderStatus = -1;
                    }

                }
            }

            // Check for output from the decoder.  We want to do this on every loop to avoid
            // the possibility of stalling the pipeline.  We use a short timeout to avoid
            // burning CPU if the decoder is hard at work but the next frame isn't quite ready.
            //
            // If we're decoding to a Surface, we'll get notified here as usual but the
            // ByteBuffer references will be null.  The data is sent to Surface instead.
            if (decoderConfigured) {
                MediaCodec.BufferInfo info = decoderInfo;
                int decoderStatus = decoder.dequeueOutputBuffer(info, TIMEOUT_USEC);
                if (decoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {
                    // no output available yet
                    if (VERBOSE) Log.d(TAG, ""no output from decoder available"");
                } else if (decoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {
                    // The storage associated with the direct ByteBuffer may already be unmapped,
                    // so attempting to access data through the old output buffer array could
                    // lead to a native crash.
                    if (VERBOSE) Log.d(TAG, ""decoder output buffers changed"");
                    decoderOutputBuffers = decoder.getOutputBuffers();
                } else if (decoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {
                    // this happens before the first frame is returned
                    decoderOutputFormat = decoder.getOutputFormat();
                    if (VERBOSE) Log.d(TAG, ""decoder output format changed: "" +
                            decoderOutputFormat);
                } else if (decoderStatus < 0) {
                    fail(""unexpected result from deocder.dequeueOutputBuffer: "" + decoderStatus);
                } else {  // decoderStatus >= 0
                    if (!toSurface) {
                        ByteBuffer outputFrame = decoderOutputBuffers[decoderStatus];
                        Image outputImage = (checkIndex % 2 == 0) ? null : decoder.getOutputImage(decoderStatus);

                        outputFrame.position(info.offset);
                        outputFrame.limit(info.offset + info.size);

                        rawSize += info.size;
                        if (info.size == 0) {
                            if (VERBOSE) Log.d(TAG, ""got empty frame"");
                        } else {
                            if (VERBOSE) Log.d(TAG, ""decoded, checking frame "" + checkIndex);
                            assertEquals(""Wrong time stamp"", computePresentationTime(checkIndex),
                                    info.presentationTimeUs);
                            if (!checkFrame(checkIndex++, decoderOutputFormat, outputFrame, outputImage)) {
                                badFrames++;
                            }
                        }
                        if (outputImage != null) {
                            outputImage.close();
                        }

                        if ((info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {
                            if (VERBOSE) Log.d(TAG, ""output EOS"");
                            outputDone = true;
                        }
                        decoder.releaseOutputBuffer(decoderStatus, false /*render*/);
                    } else {
                        if (VERBOSE) Log.d(TAG, ""surface decoder given buffer "" + decoderStatus +
                                "" (size="" + info.size + "")"");
                        rawSize += info.size;
                        if ((info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {
                            if (VERBOSE) Log.d(TAG, ""output EOS"");
                            outputDone = true;
                        }

                        boolean doRender = (info.size != 0);

                        // As soon as we call releaseOutputBuffer, the buffer will be forwarded
                        // to SurfaceTexture to convert to a texture.  The API doesn't guarantee
                        // that the texture will be available before the call returns, so we
                        // need to wait for the onFrameAvailable callback to fire.
                        decoder.releaseOutputBuffer(decoderStatus, doRender);
                        if (doRender) {
                            if (VERBOSE) Log.d(TAG, ""awaiting frame "" + checkIndex);
                            assertEquals(""Wrong time stamp"", computePresentationTime(checkIndex),
                                    info.presentationTimeUs);
                            outputSurface.awaitNewImage();
                            outputSurface.drawImage();
                            if (!checkSurfaceFrame(checkIndex++)) {
                                badFrames++;
                            }
                        }
                    }
                }
            }
        }

        if (VERBOSE) Log.d(TAG, ""decoded "" + checkIndex + "" frames at ""
                + mWidth + ""x"" + mHeight + "": raw="" + rawSize + "", enc="" + encodedSize);
        if (outputStream != null) {
            try {
                outputStream.close();
            } catch (IOException ioe) {
                Log.w(TAG, ""failed closing debug file"");
                throw new RuntimeException(ioe);
            }
        }

        if (outputSurface != null) {
            outputSurface.release();
        }

        if (checkIndex != NUM_FRAMES) {
            fail(""expected "" + NUM_FRAMES + "" frames, only decoded "" + checkIndex);
        }
        if (badFrames != 0) {
            fail(""Found "" + badFrames + "" bad frames"");
        }
    }

    /**
     * Does the actual work for encoding and decoding from Surface to Surface.
     */
    private void doEncodeDecodeVideoFromSurfaceToSurface(MediaCodecWrapper encoder,
            InputSurfaceInterface inputSurface, MediaCodec decoder,
            OutputSurface outputSurface) {
        final int TIMEOUT_USEC = 10000;
        ByteBuffer[] encoderOutputBuffers = encoder.getOutputBuffers();
        ByteBuffer[] decoderInputBuffers = decoder.getInputBuffers();
        MediaCodec.BufferInfo info = new MediaCodec.BufferInfo();
        int generateIndex = 0;
        int checkIndex = 0;
        int badFrames = 0;

        // Save a copy to disk.  Useful for debugging the test.  Note this is a raw elementary
        // stream, not a .mp4 file, so not all players will know what to do with it.
        FileOutputStream outputStream = null;
        if (DEBUG_SAVE_FILE) {
            String fileName = DEBUG_FILE_NAME_BASE + mWidth + ""x"" + mHeight + "".mp4"";
            try {
                outputStream = new FileOutputStream(fileName);
                Log.d(TAG, ""encoded output will be saved as "" + fileName);
            } catch (IOException ioe) {
                Log.w(TAG, ""Unable to create debug output file "" + fileName);
                throw new RuntimeException(ioe);
            }
        }

        // Loop until the output side is done.
        boolean inputDone = false;
        boolean encoderDone = false;
        boolean outputDone = false;
        while (!outputDone) {
            if (VERBOSE) Log.d(TAG, ""loop"");

            // If we're not done submitting frames, generate a new one and submit it.  The
            // eglSwapBuffers call will block if the input is full.
            if (!inputDone) {
                if (generateIndex == NUM_FRAMES) {
                    // Send an empty frame with the end-of-stream flag set.
                    if (VERBOSE) Log.d(TAG, ""signaling input EOS"");
                    encoder.signalEndOfInputStream();
                    inputDone = true;
                } else {
                    inputSurface.makeCurrent();
                    generateSurfaceFrame(generateIndex);
                    inputSurface.setPresentationTime(computePresentationTime(generateIndex) * 1000);
                    if (VERBOSE) Log.d(TAG, ""inputSurface swapBuffers"");
                    inputSurface.swapBuffers();
                }
                generateIndex++;
            }

            // Assume output is available.  Loop until both assumptions are false.
            boolean decoderOutputAvailable = true;
            boolean encoderOutputAvailable = !encoderDone;
            while (decoderOutputAvailable || encoderOutputAvailable) {
                // Start by draining any pending output from the decoder.  It's important to
                // do this before we try to stuff any more data in.
                int decoderStatus = decoder.dequeueOutputBuffer(info, TIMEOUT_USEC);
                if (decoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {
                    // no output available yet
                    if (VERBOSE) Log.d(TAG, ""no output from decoder available"");
                    decoderOutputAvailable = false;
                } else if (decoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {
                    if (VERBOSE) Log.d(TAG, ""decoder output buffers changed (but we don't care)"");
                } else if (decoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {
                    // this happens before the first frame is returned
                    MediaFormat decoderOutputFormat = decoder.getOutputFormat();
                    if (VERBOSE) Log.d(TAG, ""decoder output format changed: "" +
                            decoderOutputFormat);
                } else if (decoderStatus < 0) {
                    fail(""unexpected result from deocder.dequeueOutputBuffer: "" + decoderStatus);
                } else {  // decoderStatus >= 0
                    if (VERBOSE) Log.d(TAG, ""surface decoder given buffer "" + decoderStatus +
                            "" (size="" + info.size + "")"");
                    if ((info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {
                        if (VERBOSE) Log.d(TAG, ""output EOS"");
                        outputDone = true;
                    }

                    // The ByteBuffers are null references, but we still get a nonzero size for
                    // the decoded data.
                    boolean doRender = (info.size != 0);

                    // As soon as we call releaseOutputBuffer, the buffer will be forwarded
                    // to SurfaceTexture to convert to a texture.  The API doesn't guarantee
                    // that the texture will be available before the call returns, so we
                    // need to wait for the onFrameAvailable callback to fire.  If we don't
                    // wait, we risk dropping frames.
                    outputSurface.makeCurrent();
                    decoder.releaseOutputBuffer(decoderStatus, doRender);
                    if (doRender) {
                        assertEquals(""Wrong time stamp"", computePresentationTime(checkIndex),
                                info.presentationTimeUs);
                        if (VERBOSE) Log.d(TAG, ""awaiting frame "" + checkIndex);
                        outputSurface.awaitNewImage();
                        outputSurface.drawImage();
                        if (!checkSurfaceFrame(checkIndex++)) {
                            badFrames++;
                        }
                    }
                }
                if (decoderStatus != MediaCodec.INFO_TRY_AGAIN_LATER) {
                    // Continue attempts to drain output.
                    continue;
                }

                // Decoder is drained, check to see if we've got a new buffer of output from
                // the encoder.
                if (!encoderDone) {
                    int encoderStatus = encoder.dequeueOutputBuffer(info, TIMEOUT_USEC);
                    if (encoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {
                        // no output available yet
                        if (VERBOSE) Log.d(TAG, ""no output from encoder available"");
                        encoderOutputAvailable = false;
                    } else if (encoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {
                        // not expected for an encoder
                        encoderOutputBuffers = encoder.getOutputBuffers();
                        if (VERBOSE) Log.d(TAG, ""encoder output buffers changed"");
                    } else if (encoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {
                        // expected on API 18+
                        String newFormat = encoder.getOutputFormatString();
                        if (VERBOSE) Log.d(TAG, ""encoder output format changed: "" + newFormat);
                    } else if (encoderStatus < 0) {
                        fail(""unexpected result from encoder.dequeueOutputBuffer: "" + encoderStatus);
                    } else { // encoderStatus >= 0
                        ByteBuffer encodedData = encoder.getOutputBuffer(encoderStatus);
                        if (encodedData == null) {
                            fail(""encoderOutputBuffer "" + encoderStatus + "" was null"");
                        }

                        // It's usually necessary to adjust the ByteBuffer values to match BufferInfo.
                        encodedData.position(info.offset);
                        encodedData.limit(info.offset + info.size);

                        if (outputStream != null) {
                            byte[] data = new byte[info.size];
                            encodedData.get(data);
                            encodedData.position(info.offset);
                            try {
                                outputStream.write(data);
                            } catch (IOException ioe) {
                                Log.w(TAG, ""failed writing debug data to file"");
                                throw new RuntimeException(ioe);
                            }
                        }

                        // Get a decoder input buffer, blocking until it's available.  We just
                        // drained the decoder output, so we expect there to be a free input
                        // buffer now or in the near future (i.e. this should never deadlock
                        // if the codec is meeting requirements).
                        //
                        // The first buffer of data we get will have the BUFFER_FLAG_CODEC_CONFIG
                        // flag set; the decoder will see this and finish configuring itself.
                        int inputBufIndex = decoder.dequeueInputBuffer(-1);
                        ByteBuffer inputBuf = decoderInputBuffers[inputBufIndex];
                        inputBuf.clear();
                        inputBuf.put(encodedData);
                        decoder.queueInputBuffer(inputBufIndex, 0, info.size,
                                info.presentationTimeUs, info.flags);

                        // If everything from the encoder has been passed to the decoder, we
                        // can stop polling the encoder output.  (This just an optimization.)
                        if ((info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {
                            encoderDone = true;
                            encoderOutputAvailable = false;
                        }
                        if (VERBOSE) Log.d(TAG, ""passed "" + info.size + "" bytes to decoder""
                                + (encoderDone ? "" (EOS)"" : """"));

                        encoder.releaseOutputBuffer(encoderStatus, false);
                    }
                }
            }
        }

        if (outputStream != null) {
            try {
                outputStream.close();
            } catch (IOException ioe) {
                Log.w(TAG, ""failed closing debug file"");
                throw new RuntimeException(ioe);
            }
        }

        if (checkIndex != NUM_FRAMES) {
            fail(""expected "" + NUM_FRAMES + "" frames, only decoded "" + checkIndex);
        }
        if (badFrames != 0) {
            fail(""Found "" + badFrames + "" bad frames"");
        }
    }


    /**
     * Generates data for frame N into the supplied buffer.  We have an 8-frame animation
     * sequence that wraps around.  It looks like this:
     * <pre>
     *   0 1 2 3
     *   7 6 5 4
     * </pre>
     * We draw one of the eight rectangles and leave the rest set to the zero-fill color.
     */
    private void generateFrame(int frameIndex, int colorFormat, byte[] frameData) {
        final int HALF_WIDTH = mWidth / 2;
        boolean semiPlanar = isSemiPlanarYUV(colorFormat);

        // Set to zero.  In YUV this is a dull green.
        Arrays.fill(frameData, (byte) 0);

        int startX, startY;

        frameIndex %= 8;
        //frameIndex = (frameIndex / 8) % 8;    // use this instead for debug -- easier to see
        if (frameIndex < 4) {
            startX = frameIndex * (mWidth / 4);
            startY = 0;
        } else {
            startX = (7 - frameIndex) * (mWidth / 4);
            startY = mHeight / 2;
        }

        for (int y = startY + (mHeight/2) - 1; y >= startY; --y) {
            for (int x = startX + (mWidth/4) - 1; x >= startX; --x) {
                if (semiPlanar) {
                    // full-size Y, followed by UV pairs at half resolution
                    // e.g. Nexus 4 OMX.qcom.video.encoder.avc COLOR_FormatYUV420SemiPlanar
                    // e.g. Galaxy Nexus OMX.TI.DUCATI1.VIDEO.H264E
                    //        OMX_TI_COLOR_FormatYUV420PackedSemiPlanar
                    frameData[y * mWidth + x] = (byte) TEST_Y;
                    if ((x & 0x01) == 0 && (y & 0x01) == 0) {
                        frameData[mWidth*mHeight + y * HALF_WIDTH + x] = (byte) TEST_U;
                        frameData[mWidth*mHeight + y * HALF_WIDTH + x + 1] = (byte) TEST_V;
                    }
                } else {
                    // full-size Y, followed by quarter-size U and quarter-size V
                    // e.g. Nexus 10 OMX.Exynos.AVC.Encoder COLOR_FormatYUV420Planar
                    // e.g. Nexus 7 OMX.Nvidia.h264.encoder COLOR_FormatYUV420Planar
                    frameData[y * mWidth + x] = (byte) TEST_Y;
                    if ((x & 0x01) == 0 && (y & 0x01) == 0) {
                        frameData[mWidth*mHeight + (y/2) * HALF_WIDTH + (x/2)] = (byte) TEST_U;
                        frameData[mWidth*mHeight + HALF_WIDTH * (mHeight / 2) +
                                  (y/2) * HALF_WIDTH + (x/2)] = (byte) TEST_V;
                    }
                }
            }
        }
    }

    /**
     * Performs a simple check to see if the frame is more or less right.
     * <p>
     * See {@link #generateFrame} for a description of the layout.  The idea is to sample
     * one pixel from the middle of the 8 regions, and verify that the correct one has
     * the non-background color.  We can't know exactly what the video encoder has done
     * with our frames, so we just check to see if it looks like more or less the right thing.
     *
     * @return true if the frame looks good
     */
    private boolean checkFrame(int frameIndex, MediaFormat format, ByteBuffer frameData, Image image) {
        // Check for color formats we don't understand.  There is no requirement for video
        // decoders to use a ""mundane"" format, so we just give a pass on proprietary formats.
        // e.g. Nexus 4 0x7FA30C03 OMX_QCOM_COLOR_FormatYUV420PackedSemiPlanar64x32Tile2m8ka
        int colorFormat = format.getInteger(MediaFormat.KEY_COLOR_FORMAT);
        if (!isRecognizedFormat(colorFormat)) {
            Log.d(TAG, ""unable to check frame contents for colorFormat="" +
                    Integer.toHexString(colorFormat));
            return true;
        }

        boolean frameFailed = false;
        boolean semiPlanar = isSemiPlanarYUV(colorFormat);
        int width = format.getInteger(MediaFormat.KEY_STRIDE,
                format.getInteger(MediaFormat.KEY_WIDTH));
        int height = format.getInteger(MediaFormat.KEY_SLICE_HEIGHT,
                format.getInteger(MediaFormat.KEY_HEIGHT));
        int halfWidth = width / 2;
        int cropLeft = format.getInteger(""crop-left"");
        int cropRight = format.getInteger(""crop-right"");
        int cropTop = format.getInteger(""crop-top"");
        int cropBottom = format.getInteger(""crop-bottom"");
        if (image != null) {
            cropLeft = image.getCropRect().left;
            cropRight = image.getCropRect().right - 1;
            cropTop = image.getCropRect().top;
            cropBottom = image.getCropRect().bottom - 1;
        }
        int cropWidth = cropRight - cropLeft + 1;
        int cropHeight = cropBottom - cropTop + 1;

        assertEquals(mWidth, cropWidth);
        assertEquals(mHeight, cropHeight);

        for (int i = 0; i < 8; i++) {
            int x, y;
            if (i < 4) {
                x = i * (mWidth / 4) + (mWidth / 8);
                y = mHeight / 4;
            } else {
                x = (7 - i) * (mWidth / 4) + (mWidth / 8);
                y = (mHeight * 3) / 4;
            }

            y += cropTop;
            x += cropLeft;

            int testY, testU, testV;
            if (image != null) {
                Image.Plane[] planes = image.getPlanes();
                if (planes.length == 3 && image.getFormat() == ImageFormat.YUV_420_888) {
                    testY = planes[0].getBuffer().get(y * planes[0].getRowStride() + x * planes[0].getPixelStride()) & 0xff;
                    testU = planes[1].getBuffer().get((y/2) * planes[1].getRowStride() + (x/2) * planes[1].getPixelStride()) & 0xff;
                    testV = planes[2].getBuffer().get((y/2) * planes[2].getRowStride() + (x/2) * planes[2].getPixelStride()) & 0xff;
                } else {
                    testY = testU = testV = 0;
                }
            } else {
                int off = frameData.position();
                if (semiPlanar) {
                    // Galaxy Nexus uses OMX_TI_COLOR_FormatYUV420PackedSemiPlanar
                    testY = frameData.get(off + y * width + x) & 0xff;
                    testU = frameData.get(off + width*height + 2*(y/2) * halfWidth + 2*(x/2)) & 0xff;
                    testV = frameData.get(off + width*height + 2*(y/2) * halfWidth + 2*(x/2) + 1) & 0xff;
                } else {
                    // Nexus 10, Nexus 7 use COLOR_FormatYUV420Planar
                    testY = frameData.get(off + y * width + x) & 0xff;
                    testU = frameData.get(off + width*height + (y/2) * halfWidth + (x/2)) & 0xff;
                    testV = frameData.get(off + width*height + halfWidth * (height / 2) +
                            (y/2) * halfWidth + (x/2)) & 0xff;
                }
            }

            int expY, expU, expV;
            if (i == frameIndex % 8) {
                // colored rect
                expY = TEST_Y;
                expU = TEST_U;
                expV = TEST_V;
            } else {
                // should be our zeroed-out buffer
                expY = expU = expV = 0;
            }
            if (!isColorClose(testY, expY) ||
                    !isColorClose(testU, expU) ||
                    !isColorClose(testV, expV)) {
                Log.w(TAG, ""Bad frame "" + frameIndex + "" (rect="" + i + "": yuv="" + testY +
                        "","" + testU + "","" + testV + "" vs. expected "" + expY + "","" + expU +
                        "","" + expV + "")"");
                frameFailed = true;
            }
        }

        return !frameFailed;
    }

    /**
     * Generates a frame of data using GL commands.
     */
    private void generateSurfaceFrame(int frameIndex) {
        frameIndex %= 8;

        int startX, startY;
        if (frameIndex < 4) {
            // (0,0) is bottom-left in GL
            startX = frameIndex * (mWidth / 4);
            startY = mHeight / 2;
        } else {
            startX = (7 - frameIndex) * (mWidth / 4);
            startY = 0;
        }

        GLES20.glDisable(GLES20.GL_SCISSOR_TEST);
        GLES20.glClearColor(TEST_R0 / 255.0f, TEST_G0 / 255.0f, TEST_B0 / 255.0f, 1.0f);
        GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT);
        GLES20.glEnable(GLES20.GL_SCISSOR_TEST);
        GLES20.glScissor(startX, startY, mWidth / 4, mHeight / 2);
        GLES20.glClearColor(TEST_R1 / 255.0f, TEST_G1 / 255.0f, TEST_B1 / 255.0f, 1.0f);
        GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT);
    }

    /**
     * Checks the frame for correctness.  Similar to {@link #checkFrame}, but uses GL to
     * read pixels from the current surface.
     *
     * @return true if the frame looks good
     */
    private boolean checkSurfaceFrame(int frameIndex) {
        ByteBuffer pixelBuf = ByteBuffer.allocateDirect(4); // TODO - reuse this
        boolean frameFailed = false;

        for (int i = 0; i < 8; i++) {
            // Note the coordinates are inverted on the Y-axis in GL.
            int x, y;
            if (i < 4) {
                x = i * (mWidth / 4) + (mWidth / 8);
                y = (mHeight * 3) / 4;
            } else {
                x = (7 - i) * (mWidth / 4) + (mWidth / 8);
                y = mHeight / 4;
            }

            GLES20.glReadPixels(x, y, 1, 1, GL10.GL_RGBA, GL10.GL_UNSIGNED_BYTE, pixelBuf);
            int r = pixelBuf.get(0) & 0xff;
            int g = pixelBuf.get(1) & 0xff;
            int b = pixelBuf.get(2) & 0xff;
            //Log.d(TAG, ""GOT("" + frameIndex + ""/"" + i + ""): r="" + r + "" g="" + g + "" b="" + b);

            int expR, expG, expB, expR_bt709, expG_bt709, expB_bt709;
            if (i == frameIndex % 8) {
                // colored rect
                expR = TEST_R1;
                expG = TEST_G1;
                expB = TEST_B1;
                expR_bt709 = TEST_R1_BT709;
                expG_bt709 = TEST_G1_BT709;
                expB_bt709 = TEST_B1_BT709;
            } else {
                // zero background color
                expR = TEST_R0;
                expG = TEST_G0;
                expB = TEST_B0;
                expR_bt709 = TEST_R0_BT709;
                expG_bt709 = TEST_G0_BT709;
                expB_bt709 = TEST_B0_BT709;
            }

            // Some decoders use BT.709 when converting HD (i.e. >= 720p)
            // frames from YUV to RGB, so check against both BT.601 and BT.709
            if (mAllowBT601 &&
                    isColorClose(r, expR) &&
                    isColorClose(g, expG) &&
                    isColorClose(b, expB)) {
                // frame OK on BT.601
                mAllowBT709 = false;
            } else if (mAllowBT709 &&
                           isColorClose(r, expR_bt709) &&
                           isColorClose(g, expG_bt709) &&
                           isColorClose(b, expB_bt709)) {
                // frame OK on BT.709
                mAllowBT601 = false;
            } else {
                Log.w(TAG, ""Bad frame "" + frameIndex + "" (rect="" + i + "" @ "" + x + "" "" + y + "": rgb="" + r +
                        "","" + g + "","" + b + "" vs. expected "" + expR + "","" + expG +
                        "","" + expB + "")"");
                frameFailed = true;
            }
        }

        return !frameFailed;
    }

    /**
     * Returns true if the actual color value is close to the expected color value.  Updates
     * mLargestColorDelta.
     */
    boolean isColorClose(int actual, int expected) {
        final int MAX_DELTA = 8;
        int delta = Math.abs(actual - expected);
        if (delta > mLargestColorDelta) {
            mLargestColorDelta = delta;
        }
        return (delta <= MAX_DELTA);
    }

    /**
     * Generates the presentation time for frame N, in microseconds.
     */
    private static long computePresentationTime(int frameIndex) {
        return 132 + frameIndex * 1000000 / FRAME_RATE;
    }
}"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.audio.MidiNativeTestActivity"	"MidiNativeTestActivity"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/audio/MidiNativeTestActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.audio;

import java.io.IOException;

import android.media.midi.MidiDevice;
import android.media.midi.MidiDeviceInfo;
import android.media.midi.MidiManager;
import android.media.midi.MidiReceiver;
import android.os.Bundle;
import android.util.Log;

import com.android.cts.verifier.audio.midilib.MidiIODevice;
import com.android.cts.verifier.audio.midilib.NativeMidiManager;
import com.android.cts.verifier.R;

/*
 * A note about the USB MIDI device.
 * Any USB MIDI peripheral with standard female DIN jacks can be used. A standard MIDI cable
 * plugged into both input and output is required for the USB Loopback Test. A Bluetooth MIDI
 * device like the Yamaha MD-BT01 plugged into both input and output is required for the
 * Bluetooth Loopback test.
 */

/*
 * A note about the ""virtual MIDI"" device...
 * See file MidiEchoService for implementation of the echo server itself.
 * This service is started by the main manifest file (AndroidManifest.xml).
 */

/*
 * A note about Bluetooth MIDI devices...
 * Any Bluetooth MIDI device needs to be paired with the DUT with the ""MIDI+BTLE"" application
 * available in the Play Store:
 * (https://play.google.com/store/apps/details?id=com.mobileer.example.midibtlepairing).
 */

/**
 * CTS Verifier Activity for MIDI test
 */
public class MidiNativeTestActivity extends MidiTestActivityBase {
    private static final String TAG = ""MidiNativeTestActivity"";
    private static final boolean DEBUG = false;

    public MidiNativeTestActivity() {
        super();
        initTestModules(new NativeMidiTestModule(MidiDeviceInfo.TYPE_USB),
                new NativeMidiTestModule(MidiDeviceInfo.TYPE_VIRTUAL),
                new BTMidiTestModule());

        NativeMidiManager.loadNativeAPI();
        NativeMidiManager.initN();
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        if (DEBUG) {
            Log.i(TAG, ""---- onCreate()"");
        }

        setContentView(R.layout.ndk_midi_activity);

        super.onCreate(savedInstanceState);

        startMidiEchoServer();
        scanMidiDevices();

        connectDeviceListener();
    }

    @Override
    protected void onPause () {
        super.onPause();
        if (DEBUG) {
            Log.i(TAG, ""---- onPause()"");
        }

        boolean isFound = stopService(mMidiServiceIntent);
        if (DEBUG) {
            Log.i(TAG, ""---- Stop Service: "" + isFound);
        }
    }

    /**
     * A class to control and represent the state of a given test.
     * It hold the data needed for IO, and the logic for sending, receiving and matching
     * the MIDI data stream.
     */
    public class NativeMidiTestModule extends MidiTestModule {
        private static final String TAG = ""NativeMidiTestModule"";
        private static final boolean DEBUG = true;

        private NativeMidiManager   mNativeMidiManager;

        public NativeMidiTestModule(int deviceType) {
            super(deviceType);
            mNativeMidiManager = new NativeMidiManager();

            // this call is just to keep the build from stripping out ""endTest"", because
            // it is only called from JNI.
            endTest(TESTSTATUS_NOTRUN);
        }

        protected void closePorts() {
            // NOP
        }

        @Override
        void startLoopbackTest(int testID) {
            synchronized (mTestLock) {
                mTestRunning = true;
                enableTestButtons(false);
            }

            if (DEBUG) {
                Log.i(TAG, ""---- startLoopbackTest()"");
            }

            mRunningTestID = testID;

            synchronized (mTestLock) {
                mTestStatus = TESTSTATUS_NOTRUN;
            }

            if (mIODevice.mSendDevInfo != null) {
                mMidiManager.openDevice(mIODevice.mSendDevInfo, new TestModuleOpenListener(), null);
            }

            startTimeoutHandler();
        }

        @Override
        boolean hasTestPassed() {
            int status;
            synchronized (mTestLock) {
                status = mTestStatus;
            }
            return status == TESTSTATUS_PASSED;
        }

        public void endTest(int endCode) {
            synchronized (mTestLock) {
                mTestRunning = false;
                mTestStatus = endCode;
            }
            if (endCode != TESTSTATUS_NOTRUN) {
                updateTestStateUI();
                enableTestButtons(true);
            }

            closePorts();
        }

        /**
         * Listens for MIDI device opens. Opens I/O ports and sends out the apriori
         * setup messages.
         */
        class TestModuleOpenListener implements MidiManager.OnDeviceOpenedListener {
            //
            // This is where the logical part of the test starts
            //
            @Override
            public void onDeviceOpened(MidiDevice device) {
                if (DEBUG) {
                    Log.i(TAG, ""---- onDeviceOpened()"");
                }
                mNativeMidiManager.startTest(NativeMidiTestModule.this, device,
                        mRunningTestID == TESTID_BTLOOPBACK);
            }
        }
    } /* class NativeMidiTestModule */

    /**
     * Test Module for Bluetooth Loopback.
     * This is a specialization of NativeMidiTestModule (which has the connections for the BL device
     * itself) with and added MidiIODevice object for the USB audio device which does the
     * ""looping back"".
     */
    private class BTMidiTestModule extends NativeMidiTestModule {
        private static final String TAG = ""BTMidiTestModule"";
        private MidiIODevice mUSBLoopbackDevice = new MidiIODevice(MidiDeviceInfo.TYPE_USB);

        public BTMidiTestModule() {
            super(MidiDeviceInfo.TYPE_BLUETOOTH);
        }

        @Override
        public void scanDevices(MidiDeviceInfo[] devInfos) {
            // (normal) Scan for BT MIDI device
            super.scanDevices(devInfos);
            // Find a USB Loopback Device
            mUSBLoopbackDevice.scanDevices(devInfos);
        }

        protected void closePorts() {
            super.closePorts();
            if (mUSBLoopbackDevice != null) {
                mUSBLoopbackDevice.closePorts();
            }
        }

        @Override
        void startLoopbackTest(int testID) {
            if (DEBUG) {
                Log.i(TAG, ""---- startLoopbackTest()"");
            }
            // Setup the USB Loopback Device
            mUSBLoopbackDevice.closePorts();

            if (mIODevice.mSendDevInfo != null) {
                mMidiManager.openDevice(
                        mUSBLoopbackDevice.mSendDevInfo, new USBLoopbackOpenListener(), null);
            }

            // Now start the test as usual
            super.startLoopbackTest(testID);
        }

        /**
         * We need this OnDeviceOpenedListener to open the USB-Loopback device
         */
        private class USBLoopbackOpenListener implements MidiManager.OnDeviceOpenedListener {
            @Override
            public void onDeviceOpened(MidiDevice device) {
                if (DEBUG) {
                    Log.i(""USBLoopbackOpenListener"", ""---- onDeviceOpened()"");
                }
                mUSBLoopbackDevice.openPorts(device, new USBMidiEchoReceiver());
            }
        } /* class USBLoopbackOpenListener */

        /**
         * MidiReceiver subclass for BlueTooth Loopback Test
         *
         * This class receives bytes from the USB Interface (presumably coming from the
         * Bluetooth MIDI peripheral) and echoes them back out (presumably to the Bluetooth
         * MIDI peripheral).
         */
        //TODO - This could be pulled out into a separate class and shared with the identical
        // code in MidiJavaTestActivity is we pass in the send port
        private class USBMidiEchoReceiver extends MidiReceiver {
            private int mTotalBytesEchoed;

            @Override
            public void onSend(byte[] msg, int offset, int count, long timestamp) throws IOException {
                mTotalBytesEchoed += count;
                if (DEBUG) {
                    Log.i(TAG, ""---- USBMidiEchoReceiver.onSend() count:"" + count +
                            "" total:"" + mTotalBytesEchoed);
                }
                if (mUSBLoopbackDevice.mSendPort == null) {
                    Log.e(TAG, ""(native) mUSBLoopbackDevice.mSendPort is null"");
                } else {
                    mUSBLoopbackDevice.mSendPort.onSend(msg, offset, count, timestamp);
                }
            }
        } /* class USBMidiEchoReceiver */
    } /* class BTMidiTestModule */
} /* class MidiNativeTestActivity */"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.projection.offscreen.ProjectionOffscreenActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/projection/offscreen/ProjectionOffscreenActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.projection.offscreen;

import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.ServiceConnection;
import android.graphics.Color;
import android.graphics.PixelFormat;
import android.media.Image;
import android.media.ImageReader;
import android.media.Ringtone;
import android.media.RingtoneManager;
import android.net.Uri;
import android.os.Bundle;
import android.os.Handler;
import android.os.IBinder;
import android.os.Looper;
import android.os.RemoteException;
import android.os.SystemClock;
import android.os.Vibrator;
import android.util.DisplayMetrics;
import android.util.Log;
import android.view.KeyEvent;
import android.view.View;
import android.widget.TextView;

import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;
import com.android.cts.verifier.projection.IProjectionService;
import com.android.cts.verifier.projection.ProjectionPresentationType;
import com.android.cts.verifier.projection.ProjectionService;

import java.nio.ByteBuffer;

public class ProjectionOffscreenActivity extends PassFailButtons.Activity
        implements ImageReader.OnImageAvailableListener {
    private static String TAG = ProjectionOffscreenActivity.class.getSimpleName();
    private static final int WIDTH = 800;
    private static final int HEIGHT = 480;
    private static final int DENSITY = DisplayMetrics.DENSITY_MEDIUM;
    private static final int TIME_SCREEN_OFF = 5000; // Time screen must remain off for test to run
    private static final int DELAYED_RUNNABLE_TIME = 1000; // Time after screen turned off
                                                           // keyevent is sent
    private static final int RENDERER_DELAY_THRESHOLD = 2000; // Time after keyevent sent that
                                                              // rendering must happen by

    protected ImageReader mReader;
    protected IProjectionService mService;
    protected TextView mStatusView;
    protected int mPreviousColor = Color.BLACK;
    private long mTimeScreenTurnedOff = 0;
    private long mTimeKeyEventSent = 0;
    private enum TestStatus { CREATED, PASSED, FAILED, RUNNING };
    protected TestStatus mTestStatus = TestStatus.CREATED;

    private final Runnable sendKeyEventRunnable = new Runnable() {
        @Override
        public void run() {
            try {
                mService.onKeyEvent(new KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_DPAD_DOWN));
                mTimeKeyEventSent = SystemClock.elapsedRealtime();
            } catch (RemoteException e) {
                Log.e(TAG, ""Error running onKeyEvent"", e);
            }
        }
    };

    private final Runnable playNotificationRunnable = new Runnable() {

        @Override
        public void run() {
            Uri notification = RingtoneManager.getDefaultUri(RingtoneManager.TYPE_NOTIFICATION);
            Ringtone r = RingtoneManager.getRingtone(getApplicationContext(), notification);
            r.play();
            ((Vibrator) getSystemService(VIBRATOR_SERVICE)).vibrate(1000);
        }
    };

    private final BroadcastReceiver mReceiver = new BroadcastReceiver() {

    @Override
    public void onReceive(Context context, Intent intent) {
        if (intent.getAction().equals(Intent.ACTION_SCREEN_OFF)) {
            mTestStatus = TestStatus.RUNNING;
            Handler handler = new Handler(Looper.getMainLooper());
            handler.postDelayed(
                    sendKeyEventRunnable, DELAYED_RUNNABLE_TIME);
            mStatusView.setText(""Running test..."");
            mTimeScreenTurnedOff = SystemClock.elapsedRealtime();
            // Notify user its safe to turn screen back on after 5s + fudge factor
            handler.postDelayed(playNotificationRunnable, TIME_SCREEN_OFF + 500);
        } else if (intent.getAction().equals(Intent.ACTION_SCREEN_ON)) {
            if (SystemClock.elapsedRealtime() - mTimeScreenTurnedOff < TIME_SCREEN_OFF) {
                mStatusView.setText(""ERROR: Turned on screen too early"");
                getPassButton().setEnabled(false);
                mTestStatus = TestStatus.FAILED;
            } else if (mTestStatus == TestStatus.RUNNING) {
                mStatusView.setText(""Failed: Image not rendered"");
                mTestStatus = TestStatus.FAILED;
            }
        }
    }

};

    protected final ServiceConnection mConnection = new ServiceConnection() {

            @Override
        public void onServiceConnected(ComponentName name, IBinder binder) {
            mService = IProjectionService.Stub.asInterface(binder);
            new Handler().post(new Runnable() {

                    @Override
                public void run() {
                    Log.i(TAG, ""onServiceConnected thread "" + Thread.currentThread());
                    try {
                        mService.startRendering(mReader.getSurface(), WIDTH, HEIGHT, DENSITY,
                                ProjectionPresentationType.OFFSCREEN.ordinal());
                    } catch (RemoteException e) {
                        Log.e(TAG, ""Failed to execute startRendering"", e);
                    }

                    IntentFilter filter = new IntentFilter();
                    filter.addAction(Intent.ACTION_SCREEN_OFF);
                    filter.addAction(Intent.ACTION_SCREEN_ON);

                    registerReceiver(mReceiver, filter);
                    mStatusView.setText(""Please turn off your screen and turn it back on after "" +
                            ""5 seconds. A sound will be played when it is safe to turn the "" +
                            ""screen back on"");
                }

            });

        }

            @Override
        public void onServiceDisconnected(ComponentName name) {
            mService = null;
        }

    };



    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        View view = getLayoutInflater().inflate(R.layout.poa_main, null);
        mStatusView = (TextView) view.findViewById(R.id.poa_status_text);
        mStatusView.setText(""Waiting for service to bind..."");

        setContentView(view);

        setInfoResources(R.string.poa_test, R.string.poa_info, -1);
        setPassFailButtonClickListeners();
        mReader = ImageReader.newInstance(WIDTH, HEIGHT, PixelFormat.RGBA_8888, 2);

        mReader.setOnImageAvailableListener(this, null);
        bindService(new Intent(this, ProjectionService.class), mConnection,
                Context.BIND_AUTO_CREATE);

        getPassButton().setEnabled(false);
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        unregisterReceiver(mReceiver);
        try {
            mService.stopRendering();
        } catch (RemoteException e) {
            Log.e(TAG, ""Failed to execute stopRendering"", e);
        }
        if (mConnection != null) {
            unbindService(mConnection);
        }
        mReader.close();
    }

    @Override
    protected void onPause() {
        super.onPause();
        if (mTestStatus == TestStatus.FAILED) {
            setTestResultAndFinish(false);
        }
    }

    @Override
    public void onImageAvailable(ImageReader reader) {
        Log.i(TAG, ""onImageAvailable: "" + reader);
        if (mTestStatus == TestStatus.CREATED) {
            Log.i(TAG, ""onImageAvailable called before test started"");
            // Drop latest image to keep buffer clear.
            dropLatestImage(reader);
            return;
        }

        if (mTimeKeyEventSent != 0
                && mTestStatus == TestStatus.RUNNING
                && mTimeKeyEventSent + RENDERER_DELAY_THRESHOLD < SystemClock.elapsedRealtime()) {
            mTestStatus = TestStatus.FAILED;
            mStatusView.setText(""Failed: took too long to render"");
        }

        Image image = reader.acquireLatestImage();

        // No new images available
        if (image == null) {
            Log.w(TAG, ""onImageAvailable called but no image!"");
            return;
        }

        if (mTestStatus == TestStatus.RUNNING) {
            int ret = scanImage(image);
            if (ret == -1) {
                mStatusView.setText(""Failed: saw unexpected color"");
                getPassButton().setEnabled(false);
                mTestStatus = TestStatus.FAILED;
            } else if (ret != mPreviousColor && ret == Color.BLUE) {
                mStatusView.setText(""Success: virtual display rendered expected color"");
                getPassButton().setEnabled(true);
                mTestStatus = TestStatus.PASSED;
            }
        }
        image.close();
    }

    // modified from the VirtualDisplay Cts test
    /**
     * Gets the color of the image and ensures all the pixels are the same color
     * @param image input image
     * @return The color of the image, or -1 for failure
     */
    private int scanImage(Image image) {
        final Image.Plane plane = image.getPlanes()[0];
        final ByteBuffer buffer = plane.getBuffer();
        final int width = image.getWidth();
        final int height = image.getHeight();
        final int pixelStride = plane.getPixelStride();
        final int rowStride = plane.getRowStride();
        final int rowPadding = rowStride - pixelStride * width;

        Log.d(TAG, ""- Scanning image: width="" + width + "", height="" + height
                + "", pixelStride="" + pixelStride + "", rowStride="" + rowStride);

        int offset = 0;
        int blackPixels = 0;
        int bluePixels = 0;
        int otherPixels = 0;
        for (int y = 0; y < height; y++) {
            for (int x = 0; x < width; x++) {
                int pixel = 0;
                pixel |= (buffer.get(offset) & 0xff) << 16;     // R
                pixel |= (buffer.get(offset + 1) & 0xff) << 8;  // G
                pixel |= (buffer.get(offset + 2) & 0xff);       // B
                pixel |= (buffer.get(offset + 3) & 0xff) << 24; // A
                if (pixel == Color.BLACK || pixel == 0) {
                    blackPixels += 1;
                } else if (pixel == Color.BLUE) {
                    bluePixels += 1;
                } else {
                    otherPixels += 1;
                    if (otherPixels < 10) {
                        Log.d(TAG, ""- Found unexpected color: "" + Integer.toHexString(pixel));
                    }
                }
                offset += pixelStride;
            }
            offset += rowPadding;
        }

        // Return a color if it represents all of the pixels.
        Log.d(TAG, ""- Pixels: "" + blackPixels + "" black, ""
                + bluePixels + "" blue, ""
                + otherPixels + "" other"");
        if (blackPixels == width * height) {
            return Color.BLACK;
        } else if (bluePixels == width * height) {
            return Color.BLUE;
        } else {
            return -1;
        }
    }

    private void dropLatestImage(ImageReader reader) {
        Image image = reader.acquireLatestImage();
        if (image != null) {
            image.close();
        }
    }
}"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.widget.cts.NumberPickerTest"	"testEnterKey"	"CtsWidgetTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/NumberPickerTest.java"	""	"public void testEnterKey() throws Throwable {
        mActivityRule.runOnUiThread(() -> {
            mNumberPicker.setMinValue(10);
            mNumberPicker.setMaxValue(14);
            mNumberPicker.setDisplayedValues(NUMBER_NAMES5);
        });

        final NumberPicker.OnValueChangeListener mockValueChangeListener =
                mock(NumberPicker.OnValueChangeListener.class);
        mNumberPicker.setOnValueChangedListener(mockValueChangeListener);

        final int[] numberPickerLocationOnScreen = new int[2];
        mNumberPicker.getLocationOnScreen(numberPickerLocationOnScreen);
        int screenHeight = Resources.getSystem().getDisplayMetrics().heightPixels;
        int x = numberPickerLocationOnScreen[0] + mNumberPicker.getWidth() / 2;
        int y = numberPickerLocationOnScreen[1] + (int) mNumberPicker.getHeight() / 6;

        // Phase 1. Check enter key
        MotionEvent event = MotionEvent.obtain(System.currentTimeMillis(),
                System.currentTimeMillis(), MotionEvent.ACTION_DOWN, x, y, 0);
        mInstrumentation.sendPointerSync(event);

        // Send enter key to call removeAllCallbacks including longpressed
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mNumberPicker, KeyEvent.KEYCODE_ENTER);
        reset(mockValueChangeListener);

        // Wait a second to check if value is changed or not.
        SystemClock.sleep(1000);
        verifyZeroInteractions(mockValueChangeListener);

        event = MotionEvent.obtain(System.currentTimeMillis(), System.currentTimeMillis(),
                MotionEvent.ACTION_UP, x, y, 0);
        mInstrumentation.sendPointerSync(event);

        // Phase 2. Check numpad enter key
        event = MotionEvent.obtain(System.currentTimeMillis(), System.currentTimeMillis(),
                MotionEvent.ACTION_DOWN, x, y, 0);
        mInstrumentation.sendPointerSync(event);

        // Send numpad enter key. we expect it works like enter key.
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mNumberPicker,
                KeyEvent.KEYCODE_NUMPAD_ENTER);
        reset(mockValueChangeListener);

        // Wait a second to check if value is changed or not.
        SystemClock.sleep(1000);
        verifyZeroInteractions(mockValueChangeListener);

        event = MotionEvent.obtain(System.currentTimeMillis(), System.currentTimeMillis(),
                MotionEvent.ACTION_UP, x, y, 0);
        mInstrumentation.sendPointerSync(event);
    }
}"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.view.inputmethod.cts.util.TestUtils"	"isInteractive"	"CtsInputMethodTestCases"	"/home/gpoor/cts-12-source/cts/tests/inputmethod/src/android/view/inputmethod/cts/util/TestUtils.java"	""	"public void test/*
 *.
 */

package android.view.inputmethod.cts.util;

import static com.android.compatibility.common.util.SystemUtil.runShellCommand;
import static com.android.compatibility.common.util.SystemUtil.runShellCommandOrThrow;
import static com.android.compatibility.common.util.SystemUtil.runWithShellPermissionIdentity;

import static org.junit.Assert.assertFalse;

import android.app.Instrumentation;
import android.app.KeyguardManager;
import android.content.Context;
import android.os.PowerManager;
import android.view.KeyEvent;

import androidx.annotation.NonNull;
import androidx.test.platform.app.InstrumentationRegistry;

import com.android.compatibility.common.util.CommonTestUtils;
import com.android.compatibility.common.util.SystemUtil;

import java.util.concurrent.TimeoutException;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.BooleanSupplier;
import java.util.function.Supplier;

public final class TestUtils {
    private static final long TIME_SLICE = 100;  // msec

    /**
     * Executes a call on the application's main thread, blocking until it is complete.
     *
     * <p>A simple wrapper for {@link Instrumentation#runOnMainSync(Runnable)}.</p>
     *
     * @param task task to be called on the UI thread
     */
    public static void runOnMainSync(@NonNull Runnable task) {
        InstrumentationRegistry.getInstrumentation().runOnMainSync(task);
    }

    /**
     * Retrieves a value that needs to be obtained on the main thread.
     *
     * <p>A simple utility method that helps to return an object from the UI thread.</p>
     *
     * @param supplier callback to be called on the UI thread to return a value
     * @param <T> Type of the value to be returned
     * @return Value returned from {@code supplier}
     */
    public static <T> T getOnMainSync(@NonNull Supplier<T> supplier) {
        final AtomicReference<T> result = new AtomicReference<>();
        final Instrumentation instrumentation = InstrumentationRegistry.getInstrumentation();
        instrumentation.runOnMainSync(() -> result.set(supplier.get()));
        return result.get();
    }

    /**
     * Does polling loop on the UI thread to wait until the given condition is met.
     *
     * @param condition Condition to be satisfied. This is guaranteed to run on the UI thread.
     * @param timeout timeout in millisecond
     * @param message message to display when timeout occurs.
     * @throws TimeoutException when the no event is matched to the given condition within
     *                          {@code timeout}
     */
    public static void waitOnMainUntil(
            @NonNull BooleanSupplier condition, long timeout, String message)
            throws TimeoutException {
        final AtomicBoolean result = new AtomicBoolean();

        final Instrumentation instrumentation = InstrumentationRegistry.getInstrumentation();
        while (!result.get()) {
            if (timeout < 0) {
                throw new TimeoutException(message);
            }
            instrumentation.runOnMainSync(() -> {
                if (condition.getAsBoolean()) {
                    result.set(true);
                }
            });
            try {
                Thread.sleep(TIME_SLICE);
            } catch (InterruptedException e) {
                throw new IllegalStateException(e);
            }
            timeout -= TIME_SLICE;
        }
    }

    /**
     * Does polling loop on the UI thread to wait until the given condition is met.
     *
     * @param condition Condition to be satisfied. This is guaranteed to run on the UI thread.
     * @param timeout timeout in millisecond
     * @throws TimeoutException when the no event is matched to the given condition within
     *                          {@code timeout}
     */
    public static void waitOnMainUntil(@NonNull BooleanSupplier condition, long timeout)
            throws TimeoutException {
        waitOnMainUntil(condition, timeout, """");
    }

    /**
     * Call a command to turn screen On.
     *
     * This method will wait until the power state is interactive with {@link
     * PowerManager#isInteractive()}.
     */
    public static void turnScreenOn() throws Exception {
        final Context context = InstrumentationRegistry.getInstrumentation().getContext();
        final PowerManager pm = context.getSystemService(PowerManager.class);
        runShellCommand(""input keyevent KEYCODE_WAKEUP"");
        CommonTestUtils.waitUntil(""Device does not wake up after 5 seconds"", 5,
                () -> pm != null && pm.isInteractive());
    }

    /**
     * Call a command to turn screen off.
     *
     * This method will wait until the power state is *NOT* interactive with
     * {@link PowerManager#isInteractive()}.
     * Note that {@link PowerManager#isInteractive()} may not return {@code true} when the device
     * enables Aod mode, recommend to add (@link DisableScreenDozeRule} in the test to disable Aod
     * for making power state reliable.
     */
    public static void turnScreenOff() throws Exception {
        final Context context = InstrumentationRegistry.getInstrumentation().getContext();
        final PowerManager pm = context.getSystemService(PowerManager.class);
        runShellCommand(""input keyevent KEYCODE_SLEEP"");
        CommonTestUtils.waitUntil(""Device does not sleep after 5 seconds"", 5,
                () -> pm != null && !pm.isInteractive());
    }

    /**
     * Simulates a {@link KeyEvent#KEYCODE_MENU} event to unlock screen.
     *
     * This method will retry until {@link KeyguardManager#isKeyguardLocked()} return {@code false}
     * in given timeout.
     *
     * Note that {@link KeyguardManager} is not accessible in instant mode due to security concern,
     * so this method always throw exception with instant app.
     */
    public static void unlockScreen() throws Exception {
        final Instrumentation instrumentation = InstrumentationRegistry.getInstrumentation();
        final Context context = instrumentation.getContext();
        final KeyguardManager kgm = context.getSystemService(KeyguardManager.class);

        assertFalse(""This method is currently not supported in instant apps."",
                context.getPackageManager().isInstantApp());
        CommonTestUtils.waitUntil(""Device does not unlock after 3 seconds"", 3,
                () -> {
                    SystemUtil.runWithShellPermissionIdentity(
                            () -> instrumentation.sendKeyDownUpSync((KeyEvent.KEYCODE_MENU)));
                    return kgm != null && !kgm.isKeyguardLocked();
                });
    }

    /**
     * Call a command to force stop the given application package.
     *
     * @param pkg The name of the package to be stopped.
     */
    public static void forceStopPackage(@NonNull String pkg) {
        runWithShellPermissionIdentity(() -> {
            runShellCommandOrThrow(""am force-stop "" + pkg);
        });
    }
}"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.app.cts.ToolbarActionBarTest"	"testOptionsMenuKey"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ToolbarActionBarTest.java"	""	"public void testOptionsMenuKey() {
        if (!mActivity.getWindow().hasFeature(Window.FEATURE_OPTIONS_PANEL)) {
            return;
        }
        final boolean menuIsVisible[] = {false};
        mActivity.getActionBar().addOnMenuVisibilityListener(
                isVisible -> menuIsVisible[0] = isVisible);
        getInstrumentation().sendKeyDownUpSync(KeyEvent.KEYCODE_MENU);
        getInstrumentation().waitForIdleSync();
        assertTrue(menuIsVisible[0]);
        assertTrue(mActivity.getToolbar().isOverflowMenuShowing());
        getInstrumentation().sendKeyDownUpSync(KeyEvent.KEYCODE_MENU);
        getInstrumentation().waitForIdleSync();
        assertFalse(menuIsVisible[0]);
        assertFalse(mActivity.getToolbar().isOverflowMenuShowing());
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.webkit.cts.WebViewClientTest"	"testOnUnhandledKeyEvent"	"CtsWebkitTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/webkit/src/android/webkit/cts/WebViewClientTest.java"	""	"public void testOnUnhandledKeyEvent() throws Throwable {
        if (!NullWebViewUtils.isWebViewAvailable()) {
            return;
        }
        requireLoadedPage();
        final MockWebViewClient webViewClient = new MockWebViewClient();
        mOnUiThread.setWebViewClient(webViewClient);

        mOnUiThread.requestFocus();
        getInstrumentation().waitForIdleSync();

        assertFalse(webViewClient.hasOnUnhandledKeyEventCalled());
        sendKeys(KeyEvent.KEYCODE_1);

        new PollingCheck(TEST_TIMEOUT) {
            @Override
            protected boolean check() {
                return webViewClient.hasOnUnhandledKeyEventCalled();
            }
        }.run();
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.media.cts.MediaExtractorDeviceSideTest"	"testEntryPointNdkNoJvm"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/media/app/MediaExtractorTest/src/android/media/cts/MediaExtractorDeviceSideTest.java"	""	"public void testEntryPointNdkNoJvm() {
        extractUsingNdkMediaExtractor(mAssetManager, SAMPLE_PATH, /* withAttachedJvm= */ false);
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.media.cts.MediaExtractorDeviceSideTest"	"testEntryPointNdkWithJvm"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/media/app/MediaExtractorTest/src/android/media/cts/MediaExtractorDeviceSideTest.java"	""	"public void testEntryPointNdkWithJvm() {
        extractUsingNdkMediaExtractor(mAssetManager, SAMPLE_PATH, /* withAttachedJvm= */ true);
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.media.cts.MediaExtractorDeviceSideTest"	"testLogSessionId"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/media/app/MediaExtractorTest/src/android/media/cts/MediaExtractorDeviceSideTest.java"	""	"public void testLogSessionId() throws Exception {
        MediaExtractor mediaExtractor = new MediaExtractor();
        AssetManager assetManager =
                InstrumentationRegistry.getInstrumentation().getContext().getAssets();
        try (AssetFileDescriptor fileDescriptor = assetManager.openFd(SAMPLE_PATH)) {
            mediaExtractor.setDataSource(fileDescriptor);
            assertThat(mediaExtractor.getLogSessionId())
                    .isEqualTo(LogSessionId.LOG_SESSION_ID_NONE);
            mediaExtractor.setLogSessionId(new LogSessionId(""FakeLogSessionId""));
            assertThat(mediaExtractor.getLogSessionId().getStringId())
                    .isEqualTo(""FakeLogSessionId"");
        } finally {
            mediaExtractor.release();
        }
    }

    private native void extractUsingNdkMediaExtractor(
            AssetManager assetManager, String assetPath, boolean withAttachedJvm);
}"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.widget.cts.AbsSeekBarTest"	"testAccessKeyProgressIncrement"	"CtsWidgetTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/AbsSeekBarTest.java"	""	"public void testAccessKeyProgressIncrement() throws Throwable {
        // AbsSeekBar is an abstract class, use its subclass: SeekBar to do this test.
        WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, mActivity.getWindow().getDecorView(),
                () -> mActivity.setContentView(R.layout.seekbar_layout));

        final SeekBar seekBar = (SeekBar) mActivity.findViewById(R.id.seekBar);
        final int keyProgressIncrement = 2;
        mActivityRule.runOnUiThread(() -> {
            seekBar.setKeyProgressIncrement(keyProgressIncrement);
            seekBar.setFocusable(true);
            seekBar.requestFocus();
        });
        PollingCheck.waitFor(1000, seekBar::hasWindowFocus);
        assertEquals(keyProgressIncrement, seekBar.getKeyProgressIncrement());

        int oldProgress = seekBar.getProgress();
        KeyEvent keyEvent = new KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_DPAD_RIGHT);
        mInstrumentation.sendKeySync(keyEvent);
        assertEquals(oldProgress + keyProgressIncrement, seekBar.getProgress());
        oldProgress = seekBar.getProgress();
        keyEvent = new KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_DPAD_LEFT);
        mInstrumentation.sendKeySync(keyEvent);
        assertEquals(oldProgress - keyProgressIncrement, seekBar.getProgress());
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"com.android.cts.apicoverage.CtsReportParser"	"getTestPackageList"	""	"/home/gpoor/cts-12-source/cts/tools/cts-api-coverage/src/com/android/cts/apicoverage/CtsReportParser.java"	""	"public void test/*
 *.
 */

package com.android.cts.apicoverage;

import com.android.cts.apicoverage.CtsReportProto.*;

import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.XMLReader;
import org.xml.sax.helpers.XMLReaderFactory;

import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
/**
 * Class that outputs an XML report of the {@link ApiCoverage} collected. It can be viewed in a
 * browser when used with the api-coverage.css and api-coverage.xsl files.
 */
class CtsReportParser {
    public static final String TEST_RESULT_FILE_NAME = ""test_result.xml"";

    private static void printUsage() {
        System.out.println(""Usage: CtsReportParser [OPTION]... [APK]..."");
        System.out.println();
        System.out.println(""Generates a report about what Android NDK methods."");
        System.out.println();
        System.out.println(""Options:"");
        System.out.println(""  -o FILE                output file or standard out if not given"");
        System.out.println(""  -i PATH                path to the Test_Result.xml"");
        System.out.println(""  -s FILE                summary output file"");

        System.out.println();
        System.exit(1);
    }

    private static CtsReport parseCtsReport(String testResultPath)
            throws Exception {
        XMLReader xmlReader = XMLReaderFactory.createXMLReader();
        CtsReportHandler ctsReportXmlHandler =
                new CtsReportHandler(testResultPath);
        xmlReader.setContentHandler(ctsReportXmlHandler);
        FileReader fileReader = null;
        try {
            fileReader = new FileReader(testResultPath);
            xmlReader.parse(new InputSource(fileReader));
        } finally {
            if (fileReader != null) {
                fileReader.close();
            }
        }
        return ctsReportXmlHandler.getCtsReport();
    }

    private static void printCtsReport(CtsReport ctsReport) {
        //Header
        System.out.println(""Module,Class,Test,no,Abi,Result"");
        int i = 1;
        for (CtsReport.TestPackage tPkg : ctsReport.getTestPackageList()) {
            for (CtsReport.TestPackage.TestSuite tSuite : tPkg.getTestSuiteList()) {
                for (CtsReport.TestPackage.TestSuite.TestCase testCase : tSuite.getTestCaseList()) {
                    for (CtsReport.TestPackage.TestSuite.TestCase.Test test : testCase.getTestList()) {
                        System.out.printf(
                                ""%s,%s,%s,%d,%s,%s\n"",
                                tPkg.getName(),
                                testCase.getName(),
                                test.getName(),
                                i++,
                                tPkg.getAbi(),
                                test.getResult());
                    }
                }
            }
        }
    }

    static void printCtsReportSummary(CtsReport ctsReport, String fName)
        throws IOException{

        FileWriter fWriter = new FileWriter(fName);
        PrintWriter pWriter = new PrintWriter(fWriter);

        //Header
        pWriter.print(""Module,Test#,no,abi\n"");

        int moduleCnt = 0;
        for (CtsReport.TestPackage tPkg : ctsReport.getTestPackageList()) {
            int testCaseCnt = 0;
            for (CtsReport.TestPackage.TestSuite tSuite : tPkg.getTestSuiteList()) {
                for (CtsReport.TestPackage.TestSuite.TestCase testCase : tSuite.getTestCaseList()) {
                    for (CtsReport.TestPackage.TestSuite.TestCase.Test test : testCase.getTestList()) {
                        testCaseCnt++;
                    }
                }
            }
            pWriter.printf(
                    ""%s,%d,%d,%s\n"", tPkg.getName(), testCaseCnt, moduleCnt++, tPkg.getAbi());
        }

        pWriter.close();
    }

    public static void main(String[] args)
            throws IOException, SAXException, Exception {
        String testResultPath = ""./test_result.xml"";
        String outputFileName = ""./test_result.pb"";
        String outputSummaryFilePath = ""./reportSummary.csv"";
        int numTestModule = 0;

        for (int i = 0; i < args.length; i++) {
            if (args[i].startsWith(""-"")) {
                if (""-o"".equals(args[i])) {
                    outputFileName = getExpectedArg(args, ++i);
                } else if (""-i"".equals(args[i])) {
                    testResultPath = getExpectedArg(args, ++i);
                } else if (""-s"".equals(args[i])) {
                    outputSummaryFilePath = getExpectedArg(args, ++i);
                } else {
                    printUsage();
                }
            } else {
                printUsage();
            }
        }

        // Read message from the file and print them out
        CtsReport ctsReport = parseCtsReport(testResultPath);

        printCtsReport(ctsReport);
        printCtsReportSummary(ctsReport, outputSummaryFilePath);


        // Write test case list message to disk.
        FileOutputStream output = new FileOutputStream(outputFileName);
        try {
          ctsReport.writeTo(output);
        } finally {
          output.close();
        }
    }

    /** Get the argument or print out the usage and exit. */
    private static String getExpectedArg(String[] args, int index) {
        if (index < args.length) {
            return args[index];
        } else {
            printUsage();
            return null; // Never will happen because printUsage will call exit(1)
        }
    }
}"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.text.method.cts.MetaKeyKeyListenerTest"	"testGetMetaState_withCharSequenceAndKeyEvent"	"CtsTextTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/text/src/android/text/method/cts/MetaKeyKeyListenerTest.java"	""	"public void testGetMetaState_withCharSequenceAndKeyEvent() {
        KeyEvent event = new KeyEvent(0, 0, KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_0, 0,
                KeyEvent.META_SHIFT_MASK);

        assertEquals(KeyEvent.META_SHIFT_MASK, MetaKeyKeyListener.getMetaState(null, event));
        assertEquals(KeyEvent.META_SHIFT_MASK, MetaKeyKeyListener.getMetaState("""", event));
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.text.method.cts.MetaKeyKeyListenerTest"	"testGetMetaState_withCharSequenceAndMetaAndKeyEvent"	"CtsTextTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/text/src/android/text/method/cts/MetaKeyKeyListenerTest.java"	""	"public void testGetMetaState_withCharSequenceAndMetaAndKeyEvent() {
        KeyEvent event = new KeyEvent(0, 0, KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_0, 0,
                KeyEvent.META_CTRL_ON);

        assertEquals(0, MetaKeyKeyListener.getMetaState("""", MetaKeyKeyListener.META_SHIFT_ON,
                event));

        event = new KeyEvent(0, 0, KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_0, 0,
                KeyEvent.META_SHIFT_ON);

        assertEquals(1, MetaKeyKeyListener.getMetaState("""", MetaKeyKeyListener.META_SHIFT_ON,
                event));

        event = new KeyEvent(0, 0, KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_0, 0,
                MetaKeyKeyListener.META_SYM_LOCKED);

        assertEquals(2, MetaKeyKeyListener.getMetaState("""", MetaKeyKeyListener.META_SYM_ON,
                event));

        assertEquals(2, MetaKeyKeyListener.getMetaState(null, MetaKeyKeyListener.META_SYM_ON,
                event));
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.widget.cts.ToolbarTest"	"testKeyShortcuts"	"CtsWidgetTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/ToolbarTest.java"	""	"public void testKeyShortcuts() throws Throwable {
        WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, mMainToolbar,
                () -> mMainToolbar.inflateMenu(R.menu.toolbar_menu));

        final Boolean[] shareItemClicked = new Boolean[]{false};
        mMainToolbar.getMenu().findItem(R.id.action_share).setOnMenuItemClickListener(
                item -> shareItemClicked[0] = true);

        // Make sure valid menu shortcuts get handled by toolbar menu
        long now = SystemClock.uptimeMillis();
        KeyEvent handledShortcutKey = new KeyEvent(now, now, KeyEvent.ACTION_DOWN,
                KeyEvent.KEYCODE_S, 0, KeyEvent.META_CTRL_ON);
        mInstrumentation.runOnMainSync(() ->
                assertTrue(mActivity.dispatchKeyShortcutEvent(handledShortcutKey))
        );
        assertTrue(shareItemClicked[0]);

        final KeyEvent unhandledShortcutKey = new KeyEvent(now, now, KeyEvent.ACTION_DOWN,
                KeyEvent.KEYCODE_A, 0, KeyEvent.META_CTRL_ON);

        // Make sure we aren't eating unused shortcuts.
        mInstrumentation.runOnMainSync(() ->
                assertFalse(mActivity.dispatchKeyShortcutEvent(unhandledShortcutKey))
        );

        mActivity.resetCounts();

        // Make sure that unhandled shortcuts don't prepare menus (since toolbar is handling that).
        mInstrumentation.sendKeySync(unhandledShortcutKey);
        assertEquals(1, mActivity.mKeyShortcutCount);
        assertEquals(0, mActivity.mPrepareMenuCount);
        assertEquals(0, mActivity.mCreateMenuCount);
    }
}"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.media.cts.MediaActivityTest"	"testVolumeKey_whileSessionAlive"	"CtsMediaTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/MediaActivityTest.java"	""	"public void testVolumeKey_whileSessionAlive() throws Exception {
        if (mUseFixedVolume) {
            return;
        }

        final int testStream = mSession.getController().getPlaybackInfo().getAudioAttributes()
                .getVolumeControlStream();
        final int testKeyCode;
        if (mStreamVolumeMap.get(testStream) == mAudioManager.getStreamMinVolume(testStream)) {
            testKeyCode = KeyEvent.KEYCODE_VOLUME_UP;
        } else {
            testKeyCode = KeyEvent.KEYCODE_VOLUME_DOWN;
        }

        // The key event can be ignored and show volume panel instead. Use polling.
        assertTrue(""failed to adjust stream volume that foreground activity want"",
                pollingCheck(() -> {
                    sendKeyEvent(testKeyCode);
                    return mStreamVolumeMap.get(testStream)
                            != mAudioManager.getStreamVolume(testStream);
                }));
    }

    /**
     * Tests whether volume key changes a stream volume even after the session is released,
     * without being ignored.
     */"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.media.cts.MediaActivityTest"	"testVolumeKey_afterSessionReleased"	"CtsMediaTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/MediaActivityTest.java"	""	"public void testVolumeKey_afterSessionReleased() throws Exception {
        if (mUseFixedVolume) {
            return;
        }

        mSession.release();

        // The key event can be ignored and show volume panel instead. Use polling.
        boolean downKeySuccess = pollingCheck(() -> {
            sendKeyEvent(KeyEvent.KEYCODE_VOLUME_DOWN);
            return checkAnyStreamVolumeChanged();
        });
        if (downKeySuccess) {
            // Volume down key has changed a stream volume. Test success.
            return;
        }

        // Volume may not have been changed because the target stream's volume level was minimum.
        // Try again with the up key.
        assertTrue(pollingCheck(() -> {
            sendKeyEvent(KeyEvent.KEYCODE_VOLUME_UP);
            return checkAnyStreamVolumeChanged();
        }));
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.media.cts.MediaActivityTest"	"testMediaKey_whileSessionAlive"	"CtsMediaTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/MediaActivityTest.java"	""	"public void testMediaKey_whileSessionAlive() throws Exception {
        int testKeyEvent = KeyEvent.KEYCODE_MEDIA_PLAY;

        // Note: No extra setup for the session is needed after Activity#setMediaController().
        // i.e. No playback nor activeness is required.
        CountDownLatch latch = new CountDownLatch(2);
        mSession.setCallback(new MediaSession.Callback() {
            @Override
            public boolean onMediaButtonEvent(Intent mediaButtonIntent) {
                KeyEvent event = mediaButtonIntent.getParcelableExtra(Intent.EXTRA_KEY_EVENT);
                assertEquals(testKeyEvent, event.getKeyCode());
                latch.countDown();
                return true;
            }
        }, new Handler(Looper.getMainLooper()));

        sendKeyEvent(testKeyEvent);

        assertTrue(latch.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.media.cts.MediaActivityTest"	"testMediaKey_whileSessionReleased"	"CtsMediaTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/MediaActivityTest.java"	""	"public void testMediaKey_whileSessionReleased() throws Exception {
        int testKeyEvent = KeyEvent.KEYCODE_MEDIA_PLAY;

        CountDownLatch latch = new CountDownLatch(1);
        mSession.setCallback(new MediaSession.Callback() {
            @Override
            public boolean onMediaButtonEvent(Intent mediaButtonIntent) {
                fail(""Released session shouldn't be able to receive key event in any case"");
                latch.countDown();
                return true;
            }
        }, new Handler(Looper.getMainLooper()));
        mSession.release();

        sendKeyEvent(testKeyEvent);

        assertFalse(latch.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
    }

    private void sendKeyEvent(int keyCode) {
        final long downTime = SystemClock.uptimeMillis();
        final KeyEvent down = new KeyEvent(downTime, downTime, KeyEvent.ACTION_DOWN, keyCode, 0);
        final long upTime = SystemClock.uptimeMillis();
        final KeyEvent up = new KeyEvent(downTime, upTime, KeyEvent.ACTION_UP, keyCode, 0);
        try {
            mInstrumentation.sendKeySync(down);
            mInstrumentation.sendKeySync(up);
        } catch (SecurityException e) {
            throw new IllegalStateException(
                ""MediaSessionTestActivity isn't in the foreground.""
                        + "" Ensure no screen lock before running CTS test""
                        + "", and do not touch screen while the test is running."");
        }
    }

    private boolean checkAnyStreamVolumeChanged() {
        for (int stream : mStreamVolumeMap.keySet()) {
            int volume = mStreamVolumeMap.get(stream);
            if (mAudioManager.getStreamVolume(stream) != volume) {
                return true;
            }
        }
        return false;
    }

    private static boolean pollingCheck(Callable<Boolean> condition) throws Exception {
        long pollingCount = WAIT_TIME_MS / TIME_SLICE;
        while (!condition.call() && pollingCount-- > 0) {
            try {
                Thread.sleep(TIME_SLICE);
            } catch (InterruptedException e) {
                fail(""unexpected InterruptedException"");
            }
        }
        return pollingCount >= 0;
    }
}"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.app.cts.DialogTest"	"testConstructor_protectedCancellable"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/DialogTest.java"	""	"public void testConstructor_protectedCancellable() {
        startDialogActivity(DialogStubActivity.TEST_PROTECTED_CANCELABLE);
        mActivity.onCancelListenerCalled = false;
        sendKeys(KeyEvent.KEYCODE_BACK);
        PollingCheck.waitFor(() -> mActivity.onCancelListenerCalled);
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.app.cts.DialogTest"	"testConstructor_protectedNotCancellable"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/DialogTest.java"	""	"public void testConstructor_protectedNotCancellable() {
        startDialogActivity(DialogStubActivity.TEST_PROTECTED_NOT_CANCELABLE);
        mActivity.onCancelListenerCalled = false;
        sendKeys(KeyEvent.KEYCODE_BACK);
        assertFalse(mActivity.onCancelListenerCalled);
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.app.cts.DialogTest"	"testConstructor_protectedCancellableEsc"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/DialogTest.java"	""	"public void testConstructor_protectedCancellableEsc() {
        startDialogActivity(DialogStubActivity.TEST_PROTECTED_CANCELABLE);
        mActivity.onCancelListenerCalled = false;
        sendKeys(KeyEvent.KEYCODE_ESCAPE);
        PollingCheck.waitFor(() -> {
            return mActivity.onCancelListenerCalled; });
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.app.cts.DialogTest"	"testConstructor_protectedNotCancellableEsc"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/DialogTest.java"	""	"public void testConstructor_protectedNotCancellableEsc() {
        startDialogActivity(DialogStubActivity.TEST_PROTECTED_NOT_CANCELABLE);
        mActivity.onCancelListenerCalled = false;
        sendKeys(KeyEvent.KEYCODE_ESCAPE);
        assertFalse(mActivity.onCancelListenerCalled);
    }

    private void assertTextAppearanceStyle(TypedArray ta) {
        final int defValue = -1;
        // get Theme and assert
        final Resources.Theme expected = mContext.getResources().newTheme();
        expected.setTo(mContext.getTheme());
        expected.applyStyle(R.style.TextAppearance, true);
        TypedArray expectedTa = expected.obtainStyledAttributes(R.styleable.TextAppearance);
        assertEquals(expectedTa.getIndexCount(), ta.getIndexCount());
        assertEquals(expectedTa.getColor(R.styleable.TextAppearance_textColor, defValue),
                ta.getColor(R.styleable.TextAppearance_textColor, defValue));
        assertEquals(expectedTa.getColor(R.styleable.TextAppearance_textColorHint, defValue),
                ta.getColor(R.styleable.TextAppearance_textColorHint, defValue));
        assertEquals(expectedTa.getColor(R.styleable.TextAppearance_textColorLink, defValue),
                ta.getColor(R.styleable.TextAppearance_textColorLink, defValue));
        assertEquals(expectedTa.getColor(R.styleable.TextAppearance_textColorHighlight, defValue),
                ta.getColor(R.styleable.TextAppearance_textColorHighlight, defValue));
        assertEquals(expectedTa.getDimension(R.styleable.TextAppearance_textSize, defValue),
                ta.getDimension(R.styleable.TextAppearance_textSize, defValue), Float.MIN_VALUE);
        assertEquals(expectedTa.getInt(R.styleable.TextAppearance_textStyle, defValue),
                ta.getInt(R.styleable.TextAppearance_textStyle, defValue));
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.app.cts.DialogTest"	"testOnStartCreateStop"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/DialogTest.java"	""	"public void testOnStartCreateStop(){
        startDialogActivity(DialogStubActivity.TEST_ONSTART_AND_ONSTOP);
        final TestDialog d = (TestDialog) mActivity.getDialog();

        assertTrue(d.isOnStartCalled);
        assertTrue(d.isOnCreateCalled);

        assertFalse(d.isOnStopCalled);
        sendKeys(KeyEvent.KEYCODE_BACK);
        PollingCheck.waitFor(() -> {
            return d.isOnStopCalled; });
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.app.cts.DialogTest"	"testOnStartCreateStopEsc"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/DialogTest.java"	""	"public void testOnStartCreateStopEsc(){
        startDialogActivity(DialogStubActivity.TEST_ONSTART_AND_ONSTOP);
        final TestDialog d = (TestDialog) mActivity.getDialog();

        assertTrue(d.isOnStartCalled);
        assertTrue(d.isOnCreateCalled);

        assertFalse(d.isOnStopCalled);
        sendKeys(KeyEvent.KEYCODE_ESCAPE);
        PollingCheck.waitFor(() -> d.isOnStopCalled);
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.app.cts.DialogTest"	"testGetCurrentFocus"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/DialogTest.java"	""	"public void testGetCurrentFocus() throws Throwable {
        startDialogActivity(DialogStubActivity.TEST_ONSTART_AND_ONSTOP);
        final TestDialog d = (TestDialog) mActivity.getDialog();
        assertNull(d.getCurrentFocus());

        mScenario.onActivity(activity -> {
            d.takeKeyEvents(true);
            d.setContentView(R.layout.alert_dialog_text_entry);
        });
        mInstrumentation.waitForIdleSync();

        sendKeys(KeyEvent.KEYCODE_0);
        // When mWindow is not null getCurrentFocus is the view in dialog
        assertEquals(d.getWindow().getCurrentFocus(), d.getCurrentFocus());
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.app.cts.DialogTest"	"testOnKeyDownKeyUp"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/DialogTest.java"	""	"public void testOnKeyDownKeyUp() {
        startDialogActivity(DialogStubActivity.TEST_ONSTART_AND_ONSTOP);
        final TestDialog d = (TestDialog) mActivity.getDialog();
        assertFalse(d.isOnKeyDownCalled);
        assertFalse(d.isOnKeyUpCalled);

        // send key 0 down and up events, onKeyDown return false
        mInstrumentation.sendKeyDownUpSync(KeyEvent.KEYCODE_0);
        assertTrue(d.isOnKeyDownCalled);
        assertTrue(d.isOnKeyUpCalled);
        assertEquals(KeyEvent.KEYCODE_0, d.keyDownCode);
        assertFalse(d.onKeyDownReturn);

        // send key back down and up events, onKeyDown return true
        mInstrumentation.sendKeyDownUpSync(KeyEvent.KEYCODE_BACK);
        assertEquals(KeyEvent.KEYCODE_BACK, d.keyDownCode);
        assertTrue(d.onKeyDownReturn);
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.app.cts.DialogTest"	"testDispatchKeyEvent"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/DialogTest.java"	""	"public void testDispatchKeyEvent() {
        startDialogActivity(DialogStubActivity.TEST_ONSTART_AND_ONSTOP);
        final TestDialog d = (TestDialog) mActivity.getDialog();

        sendKeys(KeyEvent.KEYCODE_0);
        assertFalse(d.dispatchKeyEventResult);
        assertEquals(KeyEvent.KEYCODE_0, d.keyEvent.getKeyCode());

        d.setOnKeyListener(new OnKeyListener() {
            public boolean onKey(DialogInterface dialog, int keyCode, KeyEvent event) {
                if (KeyEvent.ACTION_DOWN == event.getAction()) {
                    if (KeyEvent.KEYCODE_0 == keyCode) {
                        mIsKey0Listened = true;
                        return true;
                    }

                    if (KeyEvent.KEYCODE_1 == keyCode) {
                        mIsKey1Listened = true;
                        return true;
                    }
                }

                return false;
            }
        });

        mIsKey1Listened = false;
        sendKeys(KeyEvent.KEYCODE_1);
        assertTrue(mIsKey1Listened);

        mIsKey0Listened = false;
        sendKeys(KeyEvent.KEYCODE_0);
        assertTrue(mIsKey0Listened);
    }

    /*
     * Test point
     * 1. registerForContextMenu() will OnCreateContextMenuListener on the view to this activity,
     * so onCreateContextMenu() will be called when it is time to show the context menu.
     * 2. Close context menu will make onPanelClosed to be called,
     * and onPanelClosed will calls through to the new onPanelClosed method.
     * 3. unregisterForContextMenu() will remove the OnCreateContextMenuListener on the view,
     * so onCreateContextMenu() will not be called when try to open context menu.
     * 4. Selected a item of context menu will make onMenuItemSelected() to be called,
     * and onMenuItemSelected will calls through to the new onContextItemSelected method.
     * 5. onContextMenuClosed is called whenever the context menu is being closed (either by
     * the user canceling the menu with the back/menu button, or when an item is selected).
     */"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.app.cts.DialogTest"	"testContextMenu"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/DialogTest.java"	""	"public void testContextMenu() throws Throwable {
        startDialogActivity(DialogStubActivity.TEST_ONSTART_AND_ONSTOP);
        final TestDialog d = (TestDialog) mActivity.getDialog();
        final LinearLayout parent = new LinearLayout(mContext);
        final MockView v = new MockView(mContext);
        parent.addView(v);
        assertFalse(v.isShowContextMenuCalled);
        // Register for context menu and open it
        mScenario.onActivity(activity -> {
            d.addContentView(parent, new LinearLayout.LayoutParams(
                    ViewGroup.LayoutParams.MATCH_PARENT,
                    ViewGroup.LayoutParams.WRAP_CONTENT));
            d.registerForContextMenu(v);
            d.openContextMenu(v);
        });
        PollingCheck.waitFor(d::contextMenuHasWindowFocus);
        PollingCheck.waitFor(() -> v.isShowContextMenuCalled);
        PollingCheck.waitFor(() -> d.isOnCreateContextMenuCalled);

        assertFalse(d.isOnPanelClosedCalled);
        assertFalse(d.isOnContextMenuClosedCalled);
        // Close context menu
        d.isOnWindowFocusChangedCalled = false;
        sendKeys(KeyEvent.KEYCODE_BACK);
        PollingCheck.waitFor(() -> d.isOnPanelClosedCalled);
        // Wait for window focus change after pressing back
        PollingCheck.waitFor(() -> d.isOnWindowFocusChangedCalled);
        // Here isOnContextMenuClosedCalled should be true, see bug 1716918.
        assertFalse(d.isOnContextMenuClosedCalled);

        v.isShowContextMenuCalled = false;
        d.isOnCreateContextMenuCalled = false;
        // Unregister for context menu, and try to open it
        mScenario.onActivity(activity -> {
            d.unregisterForContextMenu(v);
        });

        mScenario.onActivity(activity -> {
            d.openContextMenu(v);
        });

        assertTrue(v.isShowContextMenuCalled);
        assertFalse(d.isOnCreateContextMenuCalled);

        // Register for context menu and open it again
        v.isShowContextMenuCalled = false;
        d.isOnCreateContextMenuCalled = false;
        mScenario.onActivity(activity -> {
            d.registerForContextMenu(v);
            d.openContextMenu(v);
        });
        PollingCheck.waitFor(() -> d.isOnCreateContextMenuCalled);
        PollingCheck.waitFor(() -> v.isShowContextMenuCalled);
        PollingCheck.waitFor(d::contextMenuHasWindowFocus);

        assertFalse(d.isOnContextItemSelectedCalled);
        assertFalse(d.isOnMenuItemSelectedCalled);
        d.isOnPanelClosedCalled = false;
        assertFalse(d.isOnContextMenuClosedCalled);
        // select a context menu item
        d.selectContextMenuItem();
        assertTrue(d.isOnMenuItemSelectedCalled);
        // Here isOnContextItemSelectedCalled should be true, see bug 1716918.
        assertFalse(d.isOnContextItemSelectedCalled);
        PollingCheck.waitFor(() -> d.isOnPanelClosedCalled);
        // Here isOnContextMenuClosedCalled should be true, see bug 1716918.
        assertFalse(d.isOnContextMenuClosedCalled);
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.app.cts.DialogTest"	"testTakeKeyEvents"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/DialogTest.java"	""	"public void testTakeKeyEvents() throws Throwable {
        startDialogActivity(DialogStubActivity.TEST_ONSTART_AND_ONSTOP);
        final TestDialog d = (TestDialog) mActivity.getDialog();
        final View v = d.getWindow().getDecorView();
        assertNull(d.getCurrentFocus());
        takeKeyEvents(d, true);
        assertTrue(v.isFocusable());
        sendKeys(KeyEvent.KEYCODE_0);
        assertEquals(KeyEvent.KEYCODE_0, d.keyEvent.getKeyCode());
        d.keyEvent = null;

        takeKeyEvents(d, false);
        assertNull(d.getCurrentFocus());
        assertFalse(v.isFocusable());
        sendKeys(KeyEvent.KEYCODE_0);
        // d.keyEvent should be null
    }

    private void takeKeyEvents(final Dialog d, final boolean get) throws Throwable {
        mScenario.onActivity(activity -> {
            d.takeKeyEvents(get);
        });
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.app.cts.DialogTest"	"testSetCancellable_true"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/DialogTest.java"	""	"public void testSetCancellable_true() {
        startDialogActivity(DialogStubActivity.TEST_DIALOG_WITHOUT_THEME);
        final Dialog d = mActivity.getDialog();

        d.setCancelable(true);
        assertTrue(d.isShowing());
        sendKeys(KeyEvent.KEYCODE_BACK);
        PollingCheck.waitFor(() -> !d.isShowing());
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.app.cts.DialogTest"	"testSetCancellable_false"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/DialogTest.java"	""	"public void testSetCancellable_false() {
        startDialogActivity(DialogStubActivity.TEST_DIALOG_WITHOUT_THEME);
        final Dialog d = mActivity.getDialog();

        d.setCancelable(false);
        assertTrue(d.isShowing());
        sendKeys(KeyEvent.KEYCODE_BACK);
        assertTrue(d.isShowing());
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.app.cts.DialogTest"	"testSetCancellableEsc_true"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/DialogTest.java"	""	"public void testSetCancellableEsc_true() {
        startDialogActivity(DialogStubActivity.TEST_DIALOG_WITHOUT_THEME);
        final Dialog d = mActivity.getDialog();

        d.setCancelable(true);
        assertTrue(d.isShowing());
        sendKeys(KeyEvent.KEYCODE_ESCAPE);
        PollingCheck.waitFor(() -> !d.isShowing());
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.app.cts.DialogTest"	"testSetCancellableEsc_false"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/DialogTest.java"	""	"public void testSetCancellableEsc_false() {
        startDialogActivity(DialogStubActivity.TEST_DIALOG_WITHOUT_THEME);
        final Dialog d = mActivity.getDialog();

        d.setCancelable(false);
        assertTrue(d.isShowing());
        sendKeys(KeyEvent.KEYCODE_ESCAPE);
        assertTrue(d.isShowing());
    }

    /*
     * Test point
     * 1. Cancel the dialog.
     * 2. Set a listener to be invoked when the dialog is canceled.
     */"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.app.cts.DialogTest"	"testSetCancelMessage"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/DialogTest.java"	""	"public void testSetCancelMessage() throws Exception {
        mCalledCallback = false;
        startDialogActivity(DialogStubActivity.TEST_ONSTART_AND_ONSTOP);
        final TestDialog d = (TestDialog) mActivity.getDialog();
        final HandlerThread ht = new HandlerThread(""DialogTest"");
        ht.start();

        d.setCancelMessage(new MockDismissCancelHandler(d, ht.getLooper()).obtainMessage(CANCEL,
                new OnCancelListener() {
                    public void onCancel(DialogInterface dialog) {
                        mCalledCallback = true;
                    }
                }));
        assertTrue(d.isShowing());
        assertFalse(mCalledCallback);
        sendKeys(KeyEvent.KEYCODE_BACK);
        PollingCheck.waitFor(() -> mCalledCallback);
        PollingCheck.waitFor(() -> !d.isShowing());

        ht.join(100);
    }

    /*
     * Test point
     * 1. Set a listener to be invoked when the dialog is dismissed.
     * 2. set onDismissListener to null, it will not changed flag after dialog dismissed.
     */"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.app.cts.DialogTest"	"testSetDismissMessage"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/DialogTest.java"	""	"public void testSetDismissMessage() throws Throwable {
        mCalledCallback = false;
        startDialogActivity(DialogStubActivity.TEST_DIALOG_WITHOUT_THEME);
        final Dialog d = mActivity.getDialog();

        final HandlerThread ht = new HandlerThread(""DialogTest"");
        ht.start();

        d.setDismissMessage(new MockDismissCancelHandler(d, ht.getLooper()).obtainMessage(DISMISS,
                new OnDismissListener() {
                    public void onDismiss(DialogInterface dialog) {
                        mCalledCallback = true;
                    }
                }));
        assertTrue(d.isShowing());
        assertFalse(mCalledCallback);
        dialogDismiss(d);
        ht.join(100);
        assertTrue(mCalledCallback);
        assertFalse(d.isShowing());
    }

    private void dialogDismiss(final Dialog d) throws Throwable {
        mScenario.onActivity(activity -> {
            d.dismiss();
        });
        mInstrumentation.waitForIdleSync();
    }

    private void dialogCancel(final Dialog d) throws Throwable {
        mScenario.onActivity(activity -> {
            d.cancel();
        });
        mInstrumentation.waitForIdleSync();
    }

    private void sendKeys(int keyCode) {
        mInstrumentation.sendKeyDownUpSync(keyCode);
    }

    private static class MockDismissCancelHandler extends Handler {
        private WeakReference<DialogInterface> mDialog;

        public MockDismissCancelHandler(Dialog dialog, Looper looper) {
            super(looper);

            mDialog = new WeakReference<DialogInterface>(dialog);
        }

        @Override
        public void handleMessage(Message msg) {
            switch (msg.what) {
            case DISMISS:
                ((OnDismissListener) msg.obj).onDismiss(mDialog.get());
                break;
            case CANCEL:
                ((OnCancelListener) msg.obj).onCancel(mDialog.get());
                break;
            }
        }
    }

    private static class MockDrawable extends Drawable {
        @Override
        public void draw(Canvas canvas) {
        }

        @Override
        public int getOpacity() {
            return 0;
        }

        @Override
        public void setAlpha(int alpha) {
        }

        @Override
        public void setColorFilter(ColorFilter cf) {
        }
    }

    private static class MockView extends View {
        public boolean isShowContextMenuCalled;
        protected OnCreateContextMenuListener mOnCreateContextMenuListener;

        public MockView(Context context) {
            super(context);
        }

        public void setOnCreateContextMenuListener(OnCreateContextMenuListener l) {
            super.setOnCreateContextMenuListener(l);
            mOnCreateContextMenuListener = l;
        }

        @Override
        public boolean showContextMenu() {
            isShowContextMenuCalled = true;
            return super.showContextMenu();
        }
    }
}"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.media.cts.MediaExtractorHostSideTest"	"testMediaMetricsEntryPointNdkNoJvm"	"CtsMediaHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/media/src/android/media/cts/MediaExtractorHostSideTest.java"	""	"public void testMediaMetricsEntryPointNdkNoJvm() throws Exception {
        runDeviceTests(DEVICE_SIDE_TEST_PACKAGE, DEVICE_SIDE_TEST_CLASS, ""testEntryPointNdkNoJvm"");
        assertThat(getMediaExtractorReportedEntryPoint())
                .isEqualTo(MediametricsMessage.ExtractorData.EntryPoint.NDK_NO_JVM);
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.media.cts.MediaExtractorHostSideTest"	"testMediaMetricsEntryPointNdkWithJvm"	"CtsMediaHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/media/src/android/media/cts/MediaExtractorHostSideTest.java"	""	"public void testMediaMetricsEntryPointNdkWithJvm() throws Exception {
        runDeviceTests(
                DEVICE_SIDE_TEST_PACKAGE, DEVICE_SIDE_TEST_CLASS, ""testEntryPointNdkWithJvm"");
        assertThat(getMediaExtractorReportedEntryPoint())
                .isEqualTo(MediametricsMessage.ExtractorData.EntryPoint.NDK_WITH_JVM);
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.widget.cts.BackwardNavigationTest"	"testBackwardNavigation"	"CtsWidgetTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/BackwardNavigationTest.java"	""	"public void testBackwardNavigation() throws Throwable {
        // Press TAB to go through all the focusable Views.
        mActivityRule.runOnUiThread(() -> mOrderedButton1.requestFocus());
        mInstrumentation.waitForIdleSync();
        View focusedView = mActivity.getCurrentFocus();
        do {
            mFocusedViews.add(focusedView);
            CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mRoot, KeyEvent.KEYCODE_TAB);
            focusedView = mActivity.getCurrentFocus();
        } while (focusedView != mOrderedButton1);

        // Press SHIFT + TAB to go through them, and verify that they're focused in reversed order.
        for (int i = mFocusedViews.size() - 1; i >= 0; i--) {
            CtsKeyEventUtil.sendKeyWhileHoldingModifier(mInstrumentation, mRoot,
                    KeyEvent.KEYCODE_TAB, KeyEvent.KEYCODE_SHIFT_LEFT);
            assertTrue(mFocusedViews.get(i).hasFocus());
        }
    }
}"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.text.method.cts.DateTimeKeyListenerTest"	"testDateTimeKeyListener"	"CtsTextTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/text/src/android/text/method/cts/DateTimeKeyListenerTest.java"	""	"public void testDateTimeKeyListener() {
        final DateTimeKeyListener dateTimeKeyListener = DateTimeKeyListener.getInstance();
        setKeyListenerSync(dateTimeKeyListener);
        String expectedText = """";
        assertEquals(expectedText, mTextView.getText().toString());

        // press '1' key.
        CtsKeyEventUtil.sendString(mInstrumentation, mTextView, ""1"");
        expectedText += ""1"";
        assertEquals(expectedText, mTextView.getText().toString());

        // press '2' key.
        CtsKeyEventUtil.sendString(mInstrumentation, mTextView, ""2"");
        expectedText += ""2"";
        assertEquals(expectedText, mTextView.getText().toString());

        // press 'a' key if producible
        KeyCharacterMap kcm = KeyCharacterMap.load(KeyCharacterMap.VIRTUAL_KEYBOARD);
        if ('a' == kcm.getMatch(KeyEvent.KEYCODE_A, DateTimeKeyListener.CHARACTERS)) {
            expectedText += ""a"";
            CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTextView, KeyEvent.KEYCODE_A);
            assertEquals(expectedText, mTextView.getText().toString());
        }

        // press 'p' key if producible
        if ('p' == kcm.getMatch(KeyEvent.KEYCODE_P, DateTimeKeyListener.CHARACTERS)) {
            expectedText += ""p"";
            CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTextView, KeyEvent.KEYCODE_P);
            assertEquals(expectedText, mTextView.getText().toString());
        }

        // press 'm' key if producible
        if ('m' == kcm.getMatch(KeyEvent.KEYCODE_M, DateTimeKeyListener.CHARACTERS)) {
            expectedText += ""m"";
            CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTextView, KeyEvent.KEYCODE_M);
            assertEquals(expectedText, mTextView.getText().toString());
        }

        // press an unaccepted key if it exists.
        int keyCode = TextMethodUtils.getUnacceptedKeyCode(DateTimeKeyListener.CHARACTERS);
        if (-1 != keyCode) {
            CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, keyCode);
            assertEquals(expectedText, mTextView.getText().toString());
        }

        // remove DateTimeKeyListener
        setKeyListenerSync(null);
        assertEquals(expectedText, mTextView.getText().toString());

        CtsKeyEventUtil.sendString(mInstrumentation, mTextView, ""1"");
        assertEquals(expectedText, mTextView.getText().toString());
    }


    /**
     * A mocked {@link android.text.method.DateTimeKeyListener} for testing purposes.
     *
     * Allows {@link DateTimeKeyListenerTest} to call
     * {@link android.text.method.DateTimeKeyListener#getAcceptedChars()}.
     */
    private class MockDateTimeKeyListener extends DateTimeKeyListener {
        MockDateTimeKeyListener() {
            super();
        }

        MockDateTimeKeyListener(Locale locale) {
            super(locale);
        }

        @Override
        protected char[] getAcceptedChars() {
            return super.getAcceptedChars();
        }
    }
}"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.managedprovisioning.ByodFlowTestActivity"	"ByodFlowTestActivity"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/managedprovisioning/ByodFlowTestActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.managedprovisioning;

import android.app.KeyguardManager;
import android.app.admin.DevicePolicyManager;
import android.content.ActivityNotFoundException;
import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.content.pm.PackageManager;
import android.net.ConnectivityManager;
import android.os.Bundle;
import android.os.Handler;
import android.os.Looper;
import android.provider.Settings;
import android.util.Log;
import android.widget.Toast;

import com.android.cts.verifier.ArrayTestListAdapter;
import com.android.cts.verifier.DialogTestListActivity;
import com.android.cts.verifier.R;
import com.android.cts.verifier.TestListActivity;
import com.android.cts.verifier.TestListAdapter.TestListItem;
import com.android.cts.verifier.TestResult;

/**
 * CTS verifier test for BYOD managed provisioning flow
 *
 * This activity is responsible for starting the managed provisioning flow and verify the outcome of
 * provisioning. It performs the following verifications:
 *   Full disk encryption is enabled.
 *   Profile owner is correctly installed.
 *   Profile owner shows up in the Settings app.
 *   Badged work apps show up in launcher.
 * The first two verifications are performed automatically, by interacting with profile owner using
 * cross-profile intents, while the last two are carried out manually by the user.
 */
public class ByodFlowTestActivity extends DialogTestListActivity {

    // Action for delivering sub-test result from the profile.
    public static final String ACTION_TEST_RESULT =
            ""com.android.cts.verifier.managedprovisioning.BYOD_TEST_RESULT"";
    // Extra for ACTION_TEST_RESULT containing test result.
    public static final String EXTRA_RESULT = ""extra-result"";
    protected static final String HELPER_APP_PATH = ""/data/local/tmp/NotificationBot.apk"";

    private static final String TAG = ""ByodFlowTestActivity"";
    private static final int PROVISIONING_CHECK_PERIOD_MS = 3000;
    private static ConnectivityManager mCm;
    private static final int REQUEST_MANAGED_PROVISIONING = 0;
    private static final int REQUEST_PROFILE_OWNER_STATUS = 1;
    private static final int REQUEST_INTENT_FILTERS_STATUS = 2;
    private static final int REQUEST_CHECK_DISK_ENCRYPTION = 3;
    private static final int REQUEST_SET_LOCK_FOR_ENCRYPTION = 4;

    private static final String PROVISIONING_PREFERENCES = ""provisioning_preferences"";
    private static final String PREFERENCE_PROVISIONING_COMPLETE_STATUS =
            ""provisioning_complete_status"";
    private static final int PREFERENCE_PROVISIONING_COMPLETE_STATUS_NOT_RECEIVED = 0;
    private static final int PREFERENCE_PROVISIONING_COMPLETE_STATUS_RECEIVED = 1;
    private static final int PREFERENCE_PROVISIONING_COMPLETE_STATUS_PROCESSED = 2;

    private ComponentName mAdminReceiverComponent;
    private KeyguardManager mKeyguardManager;
    private ByodFlowTestHelper mByodFlowTestHelper;

    private DialogTestListItem mProfileOwnerInstalled;
    private DialogTestListItem mDiskEncryptionTest;
    private DialogTestListItem mProfileAccountVisibleTest;
    private DialogTestListItem mDeviceAdminVisibleTest;
    private DialogTestListItem mWorkAppVisibleTest;
    private DialogTestListItem mCrossProfileIntentFiltersTestFromPersonal;
    private DialogTestListItem mCrossProfileIntentFiltersTestFromWork;
    private TestListItem mCrossProfilePermissionControl;
    private DialogTestListItem mAppLinkingTest;
    private TestListItem mNonMarketAppsTest;
    private DialogTestListItem mWorkNotificationBadgedTest;
    private DialogTestListItem mWorkStatusBarIconTest;
    private DialogTestListItem mWorkStatusBarToastTest;
    private DialogTestListItem mUserSettingsVisibleTest;
    private DialogTestListItem mAppSettingsVisibleTest;
    private DialogTestListItem mLocationSettingsVisibleTest;
    private DialogTestListItem mWiFiDataUsageSettingsVisibleTest;
    private DialogTestListItem mCellularDataUsageSettingsVisibleTest;
    private DialogTestListItem mCredSettingsVisibleTest;
    private DialogTestListItem mPrintSettingsVisibleTest;
    private DialogTestListItem mIntentFiltersTest;
    private DialogTestListItem mPermissionLockdownTest;
    private DialogTestListItem mCrossProfileImageCaptureSupportTest;
    private DialogTestListItem mCrossProfileVideoCaptureWithExtraOutputSupportTest;
    private DialogTestListItem mCrossProfileVideoCaptureWithoutExtraOutputSupportTest;
    private DialogTestListItem mCrossProfileAudioCaptureSupportTest;
    private TestListItem mKeyguardDisabledFeaturesTest;
    private DialogTestListItem mDisableNfcBeamTest;
    private TestListItem mAuthenticationBoundKeyTest;
    private TestListItem mEnableLocationModeTest;
    private TestListItem mDisableLocationModeThroughMainSwitchTest;
    private TestListItem mDisableLocationModeThroughWorkSwitchTest;
    private TestListItem mPrimaryLocationWhenWorkDisabledTest;
    private DialogTestListItem mSelectWorkChallenge;
    private DialogTestListItem mConfirmWorkCredentials;
    private DialogTestListItem mPatternWorkChallenge;
    private DialogTestListItem mParentProfilePassword;
    private DialogTestListItem mPersonalRingtonesTest;
    private TestListItem mVpnTest;
    private TestListItem mKeyChainTest;
    private TestListItem mAlwaysOnVpnSettingsTest;
    private TestListItem mRecentsTest;
    private TestListItem mDisallowAppsControlTest;
    private TestListItem mOrganizationInfoTest;
    private TestListItem mPolicyTransparencyTest;
    private TestListItem mTurnOffWorkFeaturesTest;
    private TestListItem mWidgetTest;
    private final Handler mHandler = new Handler(Looper.myLooper());

    private final Runnable mPeriodicProvisioningCheckRunnable = new Runnable() {
        @Override
        public void run() {
            if (isProvisioningCompleteBroadcastReceived(getApplicationContext())) {
                markProvisioningCompleteBroadcastProcessed(getApplicationContext());
                queryProfileOwner(true);
            } else {
                mHandler.postDelayed(this, PROVISIONING_CHECK_PERIOD_MS);
            }
        }
    };

    public static class ProvisioningCompleteReceiver extends BroadcastReceiver {
        @Override
        public void onReceive(Context context, Intent intent) {
            markProvisioningCompleteBroadcastReceived(context);
        }
    }

    public ByodFlowTestActivity() {
        super(R.layout.provisioning_byod,
                R.string.provisioning_byod, R.string.provisioning_byod_info,
                R.string.provisioning_byod_instructions);
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        mByodFlowTestHelper = new ByodFlowTestHelper(this);
        mAdminReceiverComponent = new ComponentName(this, DeviceAdminTestReceiver.class.getName());
        mKeyguardManager = (KeyguardManager) getSystemService(KEYGUARD_SERVICE);

        mByodFlowTestHelper.setup();

        mPrepareTestButton.setText(R.string.provisioning_byod_start);
        mPrepareTestButton.setOnClickListener(v -> Utils.provisionManagedProfile(
                ByodFlowTestActivity.this, mAdminReceiverComponent,
                REQUEST_MANAGED_PROVISIONING));

        // If we are started by managed provisioning (fresh managed provisioning after encryption
        // reboot), redirect the user back to the main test list. This is because the test result
        // is only saved by the parent TestListActivity, and if we did allow the user to proceed
        // here, the test result would be lost when this activity finishes.
        if (ByodHelperActivity.ACTION_PROFILE_OWNER_STATUS.equals(getIntent().getAction())) {
            startActivity(new Intent(this, TestListActivity.class));
            // Calling super.finish() because we delete managed profile in our overridden of finish(),
            // which is not what we want to do here.
            super.finish();
        } else {
            queryProfileOwner(false);
        }
    }

    @Override
    protected void onStart() {
        super.onStart();
        startPeriodicProvisioningCheckIfNecessary();
    }

    private void startPeriodicProvisioningCheckIfNecessary() {
        if (mHandler.hasCallbacks(mPeriodicProvisioningCheckRunnable)) {
            return;
        }
        if (!isProvisioningCompleteBroadcastProcessed(this)) {
            mHandler.post(mPeriodicProvisioningCheckRunnable);
        }
    }

    @Override
    protected void onStop() {
        super.onStop();
        mHandler.removeCallbacks(mPeriodicProvisioningCheckRunnable);
    }

    @Override
    protected void onNewIntent(Intent intent) {
        super.onNewIntent(intent);
        if (ByodHelperActivity.ACTION_PROFILE_OWNER_STATUS.equals(intent.getAction())) {
            // This is called when managed provisioning completes successfully without reboot.
            handleStatusUpdate(RESULT_OK, intent);
        } else if (ACTION_TEST_RESULT.equals(intent.getAction())) {
            // Called when subtest cannot communicate test result from the profile via setResult().
            handleLaunchTestResult(RESULT_OK, intent.getParcelableExtra(EXTRA_RESULT));
        }
    }

    @Override
    protected void handleActivityResult(int requestCode, int resultCode, Intent data) {
        switch (requestCode) {
            case REQUEST_MANAGED_PROVISIONING:
                return;
            case REQUEST_PROFILE_OWNER_STATUS:
                // Called after queryProfileOwner()
                handleStatusUpdate(resultCode, data);
                break;
            case REQUEST_CHECK_DISK_ENCRYPTION:
                // Called after checkDiskEncryption()
                handleDiskEncryptionStatus(resultCode, data);
                break;
            case REQUEST_SET_LOCK_FOR_ENCRYPTION:
                // Called after handleDiskEncryptionStatus() to set screen lock if necessary
                handleSetLockForEncryption();
                break;
            case REQUEST_INTENT_FILTERS_STATUS:
                // Called after checkIntentFilters()
                handleIntentFiltersStatus(resultCode);
                break;
            default:
                super.handleActivityResult(requestCode, resultCode, data);
        }
    }

    private void handleStatusUpdate(int resultCode, Intent data) {
        boolean provisioned = data != null &&
                data.getBooleanExtra(ByodHelperActivity.EXTRA_PROVISIONED, false);
        setProfileOwnerTestResult((provisioned && resultCode == RESULT_OK) ?
                TestResult.TEST_RESULT_PASSED : TestResult.TEST_RESULT_FAILED);
    }

    @Override
    public void finish() {
        // Pass and fail buttons are known to call finish() when clicked, and this is when we want to
        // clean up the provisioned profile.
        mByodFlowTestHelper.tearDown();
        super.finish();
    }

    @Override
    protected void setupTests(ArrayTestListAdapter adapter) {
        mProfileOwnerInstalled = new DialogTestListItem(this,
                R.string.provisioning_byod_profileowner,
                ""BYOD_ProfileOwnerInstalled"") {
            @Override
            public void performTest(DialogTestListActivity activity) {
                queryProfileOwner(true);
            }
        };

        mDiskEncryptionTest = new DialogTestListItem(this,
                R.string.provisioning_byod_disk_encryption,
                ""BYOD_DiskEncryptionTest"") {
            @Override
            public void performTest(DialogTestListActivity activity) {
                checkDiskEncryption();
            }
        };

        /*
         * To keep the image in this test up to date, use the instructions in
         * {@link ByodIconSamplerActivity}.
         */

        if (!getPackageManager().hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE)) {
            mWorkAppVisibleTest = new DialogTestListItemWithIcon(this,
                    R.string.provisioning_byod_workapps_visible,
                    ""BYOD_WorkAppVisibleTest"",
                    R.string.provisioning_byod_workapps_visible_instruction,
                    new Intent(Intent.ACTION_MAIN).addCategory(Intent.CATEGORY_HOME),
                    R.drawable.badged_icon);

            mConfirmWorkCredentials = new DialogTestListItem(this,
                    R.string.provisioning_byod_confirm_work_credentials,
                    ""BYOD_ConfirmWorkCredentials"",
                    R.string.provisioning_byod_confirm_work_credentials_description,
                    new Intent(Intent.ACTION_MAIN).addCategory(Intent.CATEGORY_HOME));

            mPatternWorkChallenge = new DialogTestListItem(this,
                    R.string.provisioning_byod_pattern_work_challenge,
                    ""BYOD_PatternWorkChallenge"",
                    R.string.provisioning_byod_pattern_work_challenge_description,
                    new Intent(ByodHelperActivity.ACTION_TEST_PATTERN_WORK_CHALLENGE));

            mWiFiDataUsageSettingsVisibleTest = new DialogTestListItem(this,
                    R.string.provisioning_byod_wifi_data_usage_settings,
                    ""BYOD_WiFiDataUsageSettingsVisibleTest"",
                    R.string.provisioning_byod_wifi_data_usage_settings_instruction,
                    new Intent(Settings.ACTION_SETTINGS));
        }

        mWorkNotificationBadgedTest = new DialogTestListItemWithIcon(this,
                R.string.provisioning_byod_work_notification,
                ""BYOD_WorkNotificationBadgedTest"",
                R.string.provisioning_byod_work_notification_instruction,
                new Intent(ByodHelperActivity.ACTION_NOTIFICATION),
                R.drawable.ic_corp_icon);

        Intent workStatusIcon = new Intent(WorkStatusTestActivity.ACTION_WORK_STATUS_ICON);
        workStatusIcon.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        mWorkStatusBarIconTest = new DialogTestListItemWithIcon(this,
                R.string.provisioning_byod_work_status_icon,
                ""BYOD_WorkStatusBarIconTest"",
                R.string.provisioning_byod_work_status_icon_instruction,
                workStatusIcon,
                R.drawable.stat_sys_managed_profile_status);

        /* Disable due to b/111734436.
        Intent workStatusToast = new Intent(WorkStatusTestActivity.ACTION_WORK_STATUS_TOAST);
        workStatusToast.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        mWorkStatusBarToastTest = new DialogTestListItem(this,
                R.string.provisioning_byod_work_status_toast,
                ""BYOD_WorkStatusBarToastTest"",
                R.string.provisioning_byod_work_status_toast_instruction,
                workStatusToast);
        */

        mNonMarketAppsTest = TestListItem.newTest(this,
                R.string.provisioning_byod_non_market_apps,
                NonMarketAppsActivity.class.getName(),
                new Intent(this, NonMarketAppsActivity.class), null);

        mProfileAccountVisibleTest = new DialogTestListItem(this,
                R.string.provisioning_byod_profile_visible,
                ""BYOD_ProfileAccountVisibleTest"",
                R.string.provisioning_byod_profile_visible_instruction,
                new Intent(Settings.ACTION_SETTINGS));

        mUserSettingsVisibleTest = new DialogTestListItem(this,
            R.string.provisioning_byod_user_settings,
            ""BYOD_UserSettingsVisibleTest"",
            R.string.provisioning_byod_user_settings_instruction,
            new Intent(Settings.ACTION_SETTINGS));

        mAppSettingsVisibleTest = new DialogTestListItem(this,
                R.string.provisioning_byod_app_settings,
                ""BYOD_AppSettingsVisibleTest"",
                R.string.provisioning_byod_app_settings_instruction,
                new Intent(Settings.ACTION_APPLICATION_SETTINGS));

        mDeviceAdminVisibleTest = new DialogTestListItem(this,
                R.string.provisioning_byod_admin_visible,
                ""BYOD_DeviceAdminVisibleTest"",
                R.string.provisioning_byod_admin_visible_instruction,
                new Intent(Settings.ACTION_SECURITY_SETTINGS));

        mCredSettingsVisibleTest = new DialogTestListItem(this,
                R.string.provisioning_byod_cred_settings,
                ""BYOD_CredSettingsVisibleTest"",
                R.string.provisioning_byod_cred_settings_instruction,
                new Intent(Settings.ACTION_SECURITY_SETTINGS));

        mLocationSettingsVisibleTest = new DialogTestListItem(this,
                R.string.provisioning_byod_location_settings,
                ""BYOD_LocationSettingsVisibleTest"",
                R.string.provisioning_byod_location_settings_instruction,
                new Intent(Settings.ACTION_LOCATION_SOURCE_SETTINGS));

        mCellularDataUsageSettingsVisibleTest = new DialogTestListItem(this,
                R.string.provisioning_byod_cellular_data_usage_settings,
                ""BYOD_CellularDataUsageSettingsVisibleTest"",
                R.string.provisioning_byod_cellular_data_usage_settings_instruction,
                new Intent(Settings.ACTION_SETTINGS));

        mPrintSettingsVisibleTest = new DialogTestListItem(this,
                R.string.provisioning_byod_print_settings,
                ""BYOD_PrintSettingsVisibleTest"",
                R.string.provisioning_byod_print_settings_instruction,
                new Intent(Settings.ACTION_PRINT_SETTINGS));

        Intent intent = new Intent(CrossProfileTestActivity.ACTION_CROSS_PROFILE_TO_WORK);
        intent.putExtra(CrossProfileTestActivity.EXTRA_STARTED_FROM_WORK, false);
        Intent chooser = Intent.createChooser(intent,
                getResources().getString(R.string.provisioning_cross_profile_chooser));
        mCrossProfileIntentFiltersTestFromPersonal = new DialogTestListItem(this,
                R.string.provisioning_byod_cross_profile_from_personal,
                ""BYOD_CrossProfileIntentFiltersTestFromPersonal"",
                R.string.provisioning_byod_cross_profile_from_personal_instruction,
                chooser);

        mCrossProfileIntentFiltersTestFromWork = new DialogTestListItem(this,
                R.string.provisioning_byod_cross_profile_from_work,
                ""BYOD_CrossProfileIntentFiltersTestFromWork"",
                R.string.provisioning_byod_cross_profile_from_work_instruction,
                new Intent(ByodHelperActivity.ACTION_TEST_CROSS_PROFILE_INTENTS_DIALOG));

        /* Disable due to b/33571176
        mAppLinkingTest = new DialogTestListItem(this,
                R.string.provisioning_app_linking,
                ""BYOD_AppLinking"",
                R.string.provisioning_byod_app_linking_instruction,
                new Intent(ByodHelperActivity.ACTION_TEST_APP_LINKING_DIALOG));
        */

        mKeyguardDisabledFeaturesTest = TestListItem.newTest(this,
                R.string.provisioning_byod_keyguard_disabled_features,
                KeyguardDisabledFeaturesActivity.class.getName(),
                new Intent(this, KeyguardDisabledFeaturesActivity.class), null);

        mAuthenticationBoundKeyTest = TestListItem.newTest(this,
                R.string.provisioning_byod_auth_bound_key,
                AuthenticationBoundKeyTestActivity.class.getName(),
                new Intent(AuthenticationBoundKeyTestActivity.ACTION_AUTH_BOUND_KEY_TEST),
                null);

        mVpnTest = TestListItem.newTest(this,
                R.string.provisioning_byod_vpn,
                VpnTestActivity.class.getName(),
                new Intent(VpnTestActivity.ACTION_VPN),
                null);

        mAlwaysOnVpnSettingsTest = TestListItem.newTest(this,
                R.string.provisioning_byod_always_on_vpn,
                AlwaysOnVpnSettingsTestActivity.class.getName(),
                new Intent(AlwaysOnVpnSettingsTestActivity.ACTION_ALWAYS_ON_VPN_SETTINGS_TEST),
                null);

        mDisallowAppsControlTest = TestListItem.newTest(this,
                R.string.provisioning_byod_disallow_apps_control,
                DisallowAppsControlActivity.class.getName(),
                new Intent(this, DisallowAppsControlActivity.class), null);

        // Test for checking if the required intent filters are set during managed provisioning.
        mIntentFiltersTest = new DialogTestListItem(this,
                R.string.provisioning_byod_cross_profile_intent_filters,
                ""BYOD_IntentFiltersTest"") {
            @Override
            public void performTest(DialogTestListActivity activity) {
                checkIntentFilters();
            }
        };

        mCrossProfilePermissionControl = TestListItem.newTest(this,
                R.string.provisioning_byod_cross_profile_permission_control,
                CrossProfilePermissionControlActivity.class.getName(),
                new Intent(
                        CrossProfilePermissionControlActivity.ACTION_CROSS_PROFILE_PERMISSION_CONTROL),
                        null);

        mTurnOffWorkFeaturesTest = TestListItem.newTest(this,
                R.string.provisioning_byod_turn_off_work,
                TurnOffWorkActivity.class.getName(),
                new Intent(this, TurnOffWorkActivity.class), null);

        Intent permissionCheckIntent = new Intent(
                PermissionLockdownTestActivity.ACTION_MANAGED_PROFILE_CHECK_PERMISSION_LOCKDOWN);
        mPermissionLockdownTest = new DialogTestListItem(this,
                R.string.device_profile_owner_permission_lockdown_test,
                ""BYOD_PermissionLockdownTest"",
                R.string.profile_owner_permission_lockdown_test_info,
                permissionCheckIntent);

        mSelectWorkChallenge = new DialogTestListItem(this,
                R.string.provisioning_byod_select_work_challenge,
                ""BYOD_SelectWorkChallenge"",
                R.string.provisioning_byod_select_work_challenge_description,
                new Intent(ByodHelperActivity.ACTION_TEST_SELECT_WORK_CHALLENGE));

        mRecentsTest = TestListItem.newTest(this,
                R.string.provisioning_byod_recents,
                RecentsRedactionActivity.class.getName(),
                new Intent(RecentsRedactionActivity.ACTION_RECENTS).setFlags(
                        Intent.FLAG_ACTIVITY_NEW_TASK),
                null);

        mOrganizationInfoTest = TestListItem.newTest(this,
                R.string.provisioning_byod_organization_info,
                OrganizationInfoTestActivity.class.getName(),
                new Intent(this, OrganizationInfoTestActivity.class),
                null);

        mKeyChainTest = TestListItem.newTest(this,
                R.string.provisioning_byod_keychain,
                KeyChainTestActivity.class.getName(),
                new Intent(KeyChainTestActivity.ACTION_KEYCHAIN),
                null);

        mParentProfilePassword = new DialogTestListItem(this,
                R.string.provisioning_byod_parent_profile_password,
                ""BYOD_ParentProfilePasswordTest"",
                R.string.provisioning_byod_parent_profile_password_description,
                new Intent(ByodHelperActivity.ACTION_TEST_PARENT_PROFILE_PASSWORD));

        mPersonalRingtonesTest = new DialogTestListItem(this,
                R.string.provisioning_byod_personal_ringtones,
                ""BYOD_PersonalRingtones"",
                R.string.provisioning_byod_personal_ringtones_instruction,
                new Intent(Settings.ACTION_SOUND_SETTINGS));

        final Intent policyTransparencyTestIntent = new Intent(this,
                PolicyTransparencyTestListActivity.class);
        policyTransparencyTestIntent.putExtra(
                PolicyTransparencyTestListActivity.EXTRA_MODE,
                PolicyTransparencyTestListActivity.MODE_MANAGED_PROFILE);
        policyTransparencyTestIntent.putExtra(
                PolicyTransparencyTestActivity.EXTRA_TEST_ID, ""BYOD_PolicyTransparency"");
        mPolicyTransparencyTest = TestListItem.newTest(this,
                R.string.device_profile_owner_policy_transparency_test,
                ""BYOD_PolicyTransparency"",
                policyTransparencyTestIntent, null);

        adapter.add(mProfileOwnerInstalled);
        adapter.add(mDiskEncryptionTest);

        // Badge related tests
        if (!getPackageManager().hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE)) {
            adapter.add(mWorkAppVisibleTest);
        }

        adapter.add(mWorkNotificationBadgedTest);
        adapter.add(mWorkStatusBarIconTest);

        /* Disable due to b/111734436.
        adapter.add(mWorkStatusBarToastTest);
        */

        // Settings related tests.
        adapter.add(mProfileAccountVisibleTest);
        adapter.add(mDeviceAdminVisibleTest);
        adapter.add(mCredSettingsVisibleTest);
        adapter.add(mUserSettingsVisibleTest);
        adapter.add(mAppSettingsVisibleTest);
        adapter.add(mLocationSettingsVisibleTest);
        adapter.add(mPrintSettingsVisibleTest);
        adapter.add(mPersonalRingtonesTest);

        adapter.add(mCrossProfileIntentFiltersTestFromPersonal);
        adapter.add(mCrossProfileIntentFiltersTestFromWork);
        /* Disable due to b/33571176
        adapter.add(mAppLinkingTest);
        */
        adapter.add(mIntentFiltersTest);
        adapter.add(mCrossProfilePermissionControl);
        adapter.add(mNonMarketAppsTest);
        adapter.add(mPermissionLockdownTest);
        adapter.add(mKeyguardDisabledFeaturesTest);
        adapter.add(mAuthenticationBoundKeyTest);
        adapter.add(mVpnTest);
        adapter.add(mAlwaysOnVpnSettingsTest);
        adapter.add(mTurnOffWorkFeaturesTest);
        adapter.add(mSelectWorkChallenge);
        if (!getPackageManager().hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE)) {
            adapter.add(mConfirmWorkCredentials);
            adapter.add(mPatternWorkChallenge);
        }
        adapter.add(mRecentsTest);
        adapter.add(mOrganizationInfoTest);
        adapter.add(mParentProfilePassword);
        adapter.add(mPolicyTransparencyTest);

        if (!getPackageManager().hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE)) {
            if (getPackageManager().hasSystemFeature(PackageManager.FEATURE_WIFI)) {
                adapter.add(mWiFiDataUsageSettingsVisibleTest);
            }
        }

        mCm = (ConnectivityManager)getSystemService(Context.CONNECTIVITY_SERVICE);
        if(mCm.getNetworkInfo(ConnectivityManager.TYPE_MOBILE) != null) {
            adapter.add(mCellularDataUsageSettingsVisibleTest);
        }

        if (canResolveIntent(new Intent(Settings.ACTION_APPLICATION_SETTINGS))) {
            adapter.add(mDisallowAppsControlTest);
        }

        /* If there is an application that handles ACTION_IMAGE_CAPTURE, test that it handles it
         * well.
         */
        if (canResolveIntent(ByodHelperActivity.getCaptureImageIntent())) {
            // Capture image intent can be resolved in primary profile, so test.
            mCrossProfileImageCaptureSupportTest = new DialogTestListItem(this,
                    R.string.provisioning_byod_capture_image_support,
                    ""BYOD_CrossProfileImageCaptureSupportTest"",
                    R.string.provisioning_byod_capture_image_support_info,
                    new Intent(ByodHelperActivity.ACTION_CAPTURE_AND_CHECK_IMAGE));
            adapter.add(mCrossProfileImageCaptureSupportTest);
        } else {
            // Capture image intent cannot be resolved in primary profile, so skip test.
            Toast.makeText(ByodFlowTestActivity.this,
                    R.string.provisioning_byod_no_image_capture_resolver, Toast.LENGTH_SHORT)
                    .show();
        }

        /* If there is an application that handles ACTION_VIDEO_CAPTURE, test that it handles it
         * well.
         */
        if (canResolveIntent(ByodHelperActivity.getCaptureVideoIntent())) {
            // Capture video intent can be resolved in primary profile, so test.
            mCrossProfileVideoCaptureWithExtraOutputSupportTest = new DialogTestListItem(this,
                    R.string.provisioning_byod_capture_video_support_with_extra_output,
                    ""BYOD_CrossProfileVideoCaptureWithExtraOutputSupportTest"",
                    R.string.provisioning_byod_capture_video_support_info,
                    new Intent(ByodHelperActivity.ACTION_CAPTURE_AND_CHECK_VIDEO_WITH_EXTRA_OUTPUT));
            adapter.add(mCrossProfileVideoCaptureWithExtraOutputSupportTest);
            mCrossProfileVideoCaptureWithoutExtraOutputSupportTest = new DialogTestListItem(this,
                    R.string.provisioning_byod_capture_video_support_without_extra_output,
                    ""BYOD_CrossProfileVideoCaptureWithoutExtraOutputSupportTest"",
                    R.string.provisioning_byod_capture_video_support_info,
                    new Intent(ByodHelperActivity.ACTION_CAPTURE_AND_CHECK_VIDEO_WITHOUT_EXTRA_OUTPUT));
            adapter.add(mCrossProfileVideoCaptureWithoutExtraOutputSupportTest);
        } else {
            // Capture video intent cannot be resolved in primary profile, so skip test.
            Toast.makeText(ByodFlowTestActivity.this,
                    R.string.provisioning_byod_no_video_capture_resolver, Toast.LENGTH_SHORT)
                    .show();
        }

        if (getPackageManager().hasSystemFeature(PackageManager.FEATURE_NFC)
                && getPackageManager().hasSystemFeature(PackageManager.FEATURE_NFC_BEAM)) {
            mDisableNfcBeamTest = new DialogTestListItem(this, R.string.provisioning_byod_nfc_beam,
                    ""BYOD_DisableNfcBeamTest"",
                    R.string.provisioning_byod_nfc_beam_allowed_instruction,
                    new Intent(ByodHelperActivity.ACTION_TEST_NFC_BEAM)) {
                @Override
                public void performTest(final DialogTestListActivity activity) {
                    activity.showManualTestDialog(mDisableNfcBeamTest,
                            new DefaultTestCallback(mDisableNfcBeamTest) {
                        @Override
                        public void onPass() {
                            // Start a second test with beam disallowed by policy.
                            Intent testNfcBeamIntent = new Intent(
                                    ByodHelperActivity.ACTION_TEST_NFC_BEAM);
                            testNfcBeamIntent.putExtra(NfcTestActivity.EXTRA_DISALLOW_BY_POLICY,
                                    true);
                            DialogTestListItem disableNfcBeamTest2 =
                                    new DialogTestListItem(activity,
                                    R.string.provisioning_byod_nfc_beam,
                                    ""BYOD_DisableNfcBeamTest"",
                                    R.string.provisioning_byod_nfc_beam_disallowed_instruction,
                                    testNfcBeamIntent);
                            // The result should be reflected on the original test.
                            activity.showManualTestDialog(disableNfcBeamTest2,
                                    new DefaultTestCallback(mDisableNfcBeamTest));
                        }
                    });
                }
            };
            adapter.add(mDisableNfcBeamTest);
        }

        adapter.add(mKeyChainTest);

        /* If there is an application that handles RECORD_SOUND_ACTION, test that it handles it
         * well.
         */
        if (canResolveIntent(ByodHelperActivity.getCaptureAudioIntent())) {
            // Capture audio intent can be resolved in primary profile, so test.
            mCrossProfileAudioCaptureSupportTest = new DialogTestListItem(this,
                    R.string.provisioning_byod_capture_audio_support,
                    ""BYOD_CrossProfileAudioCaptureSupportTest"",
                    R.string.provisioning_byod_capture_audio_support_info,
                    new Intent(ByodHelperActivity.ACTION_CAPTURE_AND_CHECK_AUDIO));
            adapter.add(mCrossProfileAudioCaptureSupportTest);
        } else {
            // Capture audio intent cannot be resolved in primary profile, so skip test.
            Toast.makeText(ByodFlowTestActivity.this,
                    R.string.provisioning_byod_no_audio_capture_resolver, Toast.LENGTH_SHORT)
                    .show();
        }

        if (getPackageManager().hasSystemFeature(PackageManager.FEATURE_LOCATION_GPS)) {
            mEnableLocationModeTest = TestListItem.newTest(this,
                    R.string.provisioning_byod_location_mode_enable,
                    LocationTestActivity.TEST_ID_LOCATION_ENABLED,
                    new Intent(LocationTestActivity.ACTION_TEST_LOCATION_ENABLED),
                    null);
            mDisableLocationModeThroughMainSwitchTest = TestListItem.newTest(this,
                    R.string.provisioning_byod_location_mode_disable,
                    LocationTestActivity.TEST_ID_LOCATION_DISABLED,
                    new Intent(LocationTestActivity.ACTION_TEST_LOCATION_DISABLED),
                    null);
            mDisableLocationModeThroughWorkSwitchTest = TestListItem.newTest(this,
                    R.string.provisioning_byod_work_location_mode_disable,
                    LocationTestActivity.TEST_ID_WORK_LOCATION_DISABLED,
                    new Intent(LocationTestActivity.ACTION_TEST_WORK_LOCATION_DISABLED),
                    null);
            mPrimaryLocationWhenWorkDisabledTest = TestListItem.newTest(this,
                    R.string.provisioning_byod_primary_location_when_work_disabled,
                    LocationTestActivity.TEST_ID_WORK_LOCATION_DISABLED_PRIMARY,
                    new Intent(LocationTestActivity.ACTION_TEST_WORK_LOCATION_DISABLED_PRIMARY),
                    null);
            adapter.add(mEnableLocationModeTest);
            adapter.add(mDisableLocationModeThroughMainSwitchTest);
            adapter.add(mDisableLocationModeThroughWorkSwitchTest);
            adapter.add(mPrimaryLocationWhenWorkDisabledTest);
        } else {
            // The system does not support GPS feature, so skip test.
            Toast.makeText(ByodFlowTestActivity.this,
                    R.string.provisioning_byod_no_gps_location_feature, Toast.LENGTH_SHORT)
                    .show();
        }

        if (getPackageManager().hasSystemFeature(PackageManager.FEATURE_APP_WIDGETS)) {
            mWidgetTest = TestListItem.newTest(this,
                    R.string.provisioning_byod_work_profile_widget,
                    WorkProfileWidgetActivity.class.getName(),
                    new Intent(WorkProfileWidgetActivity.ACTION_TEST_WORK_PROFILE_WIDGET),
                    new String[]{PackageManager.FEATURE_APP_WIDGETS});
            adapter.add(mWidgetTest);
        }

        adapter.add(new DialogTestListItem(this,
                R.string.provisioning_byod_uninstall_work_app,
                ""BYOD_UninstallWorkApp"",
                R.string.provisioning_byod_uninstall_work_app_instruction,
                createInstallWorkProfileAppIntent()));
    }

    private Intent createInstallWorkProfileAppIntent() {
        // We place the APK file in /data/local/tmp to make it visible from the work profile.
        return new Intent(ByodHelperActivity.ACTION_INSTALL_APK)
                .putExtra(ByodHelperActivity.EXTRA_ALLOW_NON_MARKET_APPS, true)
                .putExtra(ByodHelperActivity.EXTRA_PARAMETER_1, HELPER_APP_PATH);
    }

    // Return whether the intent can be resolved in the current profile
    private boolean canResolveIntent(Intent intent) {
        return intent.resolveActivity(getPackageManager()) != null;
    }

    @Override
    protected void clearRemainingState(final DialogTestListItem test) {
        super.clearRemainingState(test);
        if (ByodHelperActivity.ACTION_NOTIFICATION.equals(
                test.getManualTestIntent().getAction())) {
            try {
                startActivity(new Intent(
                        ByodHelperActivity.ACTION_CLEAR_NOTIFICATION));
            } catch (ActivityNotFoundException e) {
                // User shouldn't run this test before work profile is set up.
            }
        }
    }

    private void queryProfileOwner(boolean showToast) {
        try {
            // Set execution start time for counting test execution time.
            mStartTime = System.currentTimeMillis();
            Intent intent = new Intent(ByodHelperActivity.ACTION_QUERY_PROFILE_OWNER);
            startActivityForResult(intent, REQUEST_PROFILE_OWNER_STATUS);
        }
        catch (ActivityNotFoundException e) {
            Log.d(TAG, ""queryProfileOwner: ActivityNotFoundException"", e);
            setProfileOwnerTestResult(TestResult.TEST_RESULT_FAILED);
            if (showToast) {
                Utils.showToast(this, R.string.provisioning_byod_no_activity);
            }
        }
    }

    private void setProfileOwnerTestResult(int result) {
        setTestResult(mProfileOwnerInstalled, result);
        if (result == TestResult.TEST_RESULT_FAILED) {
            clearProvisioningCompleteBroadcastStatus(this);
            startPeriodicProvisioningCheckIfNecessary();
        }
    }

    private void checkDiskEncryption() {
        try {
            Intent intent = new Intent(ByodHelperActivity.ACTION_CHECK_DISK_ENCRYPTION);
            startActivityForResult(intent, REQUEST_CHECK_DISK_ENCRYPTION);
        } catch (ActivityNotFoundException e) {
            Log.d(TAG, ""checkDiskEncryption: ActivityNotFoundException"", e);
            setTestResult(mDiskEncryptionTest, TestResult.TEST_RESULT_FAILED);
            Utils.showToast(this, R.string.provisioning_byod_no_activity);
        }
    }

    private void handleDiskEncryptionStatus(int resultCode, Intent data) {
        if (resultCode != RESULT_OK || data == null) {
            Log.e(TAG, ""Failed to get result for disk encryption, result code: "" + resultCode);
            setTestResult(mDiskEncryptionTest, TestResult.TEST_RESULT_FAILED);
            return;
        }

        final int status = data.getIntExtra(ByodHelperActivity.EXTRA_ENCRYPTION_STATUS,
                DevicePolicyManager.ENCRYPTION_STATUS_UNSUPPORTED);
        switch (status) {
            case DevicePolicyManager.ENCRYPTION_STATUS_ACTIVE:
            case DevicePolicyManager.ENCRYPTION_STATUS_ACTIVE_PER_USER:
                setTestResult(mDiskEncryptionTest, TestResult.TEST_RESULT_PASSED);
                break;
            case DevicePolicyManager.ENCRYPTION_STATUS_ACTIVE_DEFAULT_KEY:
                if (!mKeyguardManager.isDeviceSecure()) {
                    Utils.setScreenLock(this, REQUEST_SET_LOCK_FOR_ENCRYPTION);
                    return;
                }
                Log.e(TAG, ""Disk encryption key is not entangled with lock screen credentials"");
                Toast.makeText(this, R.string.provisioning_byod_disk_encryption_default_key_toast,
                        Toast.LENGTH_LONG).show();
                // fall through
            default:
                setTestResult(mDiskEncryptionTest, TestResult.TEST_RESULT_FAILED);
        }

        if (mKeyguardManager.isDeviceSecure()) {
            Utils.removeScreenLock(this);
        }
    }

    private void handleSetLockForEncryption() {
        if (mKeyguardManager.isDeviceSecure()) {
            checkDiskEncryption();
        } else {
            setTestResult(mDiskEncryptionTest, TestResult.TEST_RESULT_FAILED);
            Toast.makeText(this, R.string.provisioning_byod_disk_encryption_no_pin_toast,
                    Toast.LENGTH_LONG).show();
        }
    }

    private void checkIntentFilters() {
        try {
            // Enable component HandleIntentActivity before intent filters are checked.
            setHandleIntentActivityEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_ENABLED);
            // We disable the ByodHelperActivity in the primary profile. So, this intent
            // will be handled by the ByodHelperActivity in the managed profile.
            Intent intent = new Intent(ByodHelperActivity.ACTION_CHECK_INTENT_FILTERS);
            startActivityForResult(intent, REQUEST_INTENT_FILTERS_STATUS);
        } catch (ActivityNotFoundException e) {
            // Disable component HandleIntentActivity if intent filters check fails.
            setHandleIntentActivityEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_DISABLED);
            Log.d(TAG, ""checkIntentFilters: ActivityNotFoundException"", e);
            setTestResult(mIntentFiltersTest, TestResult.TEST_RESULT_FAILED);
            Utils.showToast(this, R.string.provisioning_byod_no_activity);
        }
    }

    private void handleIntentFiltersStatus(int resultCode) {
        // Disable component HandleIntentActivity after intent filters are checked.
        setHandleIntentActivityEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_DISABLED);
        // we use the resultCode from ByodHelperActivity in the managed profile to know if certain
        // intents fired from the managed profile are forwarded.
        final boolean intentFiltersSetForManagedIntents = (resultCode == RESULT_OK);
        // Since the ByodFlowTestActivity is running in the primary profile, we directly use
        // the IntentFiltersTestHelper to know if certain intents fired from the primary profile
        // are forwarded.
        final boolean intentFiltersSetForPrimaryIntents =
                new IntentFiltersTestHelper(this).checkCrossProfileIntentFilters(
                        IntentFiltersTestHelper.FLAG_INTENTS_FROM_PRIMARY);
        final boolean intentFiltersSet =
                intentFiltersSetForPrimaryIntents & intentFiltersSetForManagedIntents;
        setTestResult(mIntentFiltersTest,
                intentFiltersSet ? TestResult.TEST_RESULT_PASSED : TestResult.TEST_RESULT_FAILED);
    }

    private void setHandleIntentActivityEnabledSetting(final int enableState) {
        getPackageManager().setComponentEnabledSetting(
            new ComponentName(ByodFlowTestActivity.this, HandleIntentActivity.class.getName()),
            enableState, PackageManager.DONT_KILL_APP);
    }

    private static void markProvisioningCompleteBroadcastReceived(Context context) {
        markProvisioningCompleteBroadcastWithStatus(context,
                PREFERENCE_PROVISIONING_COMPLETE_STATUS_RECEIVED);
    }

    private static void markProvisioningCompleteBroadcastProcessed(Context context) {
        markProvisioningCompleteBroadcastWithStatus(context,
                PREFERENCE_PROVISIONING_COMPLETE_STATUS_PROCESSED);
    }

    private static void clearProvisioningCompleteBroadcastStatus(Context context) {
        markProvisioningCompleteBroadcastWithStatus(context,
                PREFERENCE_PROVISIONING_COMPLETE_STATUS_NOT_RECEIVED);
    }

    private static void markProvisioningCompleteBroadcastWithStatus(Context context, int status) {
        final SharedPreferences prefs = getProvisioningPreferences(context);
        final SharedPreferences.Editor editor = prefs.edit();
        editor.putInt(PREFERENCE_PROVISIONING_COMPLETE_STATUS, status);
        editor.commit();
    }

    private static boolean isProvisioningCompleteBroadcastReceived(Context context) {
        return getProvisioningPreferences(context)
                .getInt(PREFERENCE_PROVISIONING_COMPLETE_STATUS, 0) ==
                PREFERENCE_PROVISIONING_COMPLETE_STATUS_RECEIVED;
    }

    private static boolean isProvisioningCompleteBroadcastProcessed(Context context) {
        return getProvisioningPreferences(context)
                .getInt(PREFERENCE_PROVISIONING_COMPLETE_STATUS, 0) ==
                PREFERENCE_PROVISIONING_COMPLETE_STATUS_PROCESSED;
    }

    private static SharedPreferences getProvisioningPreferences(Context context) {
        return context.getSharedPreferences(PROVISIONING_PREFERENCES, MODE_PRIVATE);
    }
}"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.widget.cts.AbsListViewTest"	"testSelectorOnScreen"	"CtsWidgetTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/AbsListViewTest.java"	""	"public void testSelectorOnScreen() throws Throwable {
        // leave touch-mode
        mInstrumentation.setInTouchMode(false);
        setAdapter();
        WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, mListView, null);
        // Entering touch mode hides selector
        if (mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_TOUCHSCREEN)) {
            // make sure we've left touchmode (including message sending. instrumentation just sets
            // a variable without any broadcast).
            mInstrumentation.sendKeyDownUpSync(KeyEvent.KEYCODE_TAB);
            WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, mListView, () -> {
                mListView.requestFocus();
                mListView.setSelectionFromTop(1, 0);
            });
            assertEquals(1, mListView.getSelectedItemPosition());
            final int[] pt = new int[2];
            mListView.getLocationOnScreen(pt);
            CtsTouchUtils.emulateDragGesture(mInstrumentation, mActivityRule,
                    pt[0] + 2, pt[1] + 2, 0, 10);
            assertEquals(AdapterView.INVALID_POSITION, mListView.getSelectedItemPosition());
            // leave touch-mode
            mInstrumentation.sendKeyDownUpSync(KeyEvent.KEYCODE_TAB);
        }

        // Scroll off-screen hides selector, but shows up again when on-screen
        WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, mListView, () -> {
            mListView.requestFocus();
            mListView.setSelectionFromTop(1, 0);
        });
        assertEquals(1, mListView.getSelectedItemPosition());
        int selViewHeight = mListView.getSelectedView().getHeight();
        final int[] pt = new int[2];
        mListView.getLocationOnScreen(pt);
        pt[0] += mListView.getWidth() / 2;
        pt[1] += selViewHeight / 2;
        WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, mListView,
                () -> mListView.scrollListBy(selViewHeight * 2));
        assertEquals(1, mListView.getSelectedItemPosition());
        assertFalse(mListView.shouldDrawSelector());
        mActivityRule.runOnUiThread(() -> mListView.scrollListBy(-(selViewHeight * 4) / 3));
        assertEquals(1, mListView.getSelectedItemPosition());
        assertTrue(mListView.shouldDrawSelector());
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.widget.cts.AbsListViewTest"	"testEnterKey"	"CtsWidgetTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/AbsListViewTest.java"	""	"public void testEnterKey() throws Throwable {
        final MyListView listView = new MyListView(mContext, mAttributeSet);

        WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, listView, () -> {
            mActivityRule.getActivity().setContentView(listView);
            listView.setAdapter(mCountriesAdapter);
            listView.setTextFilterEnabled(true);
            listView.requestFocus();
        });

        // KEYCODE_ENTER is handled by isConfirmKey, so it comsumed before sendToTextFilter called.
        // because of this, make keyevent with repeat count.
        KeyEvent event = new KeyEvent(0, 0, KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_ENTER, 1);
        CtsKeyEventUtil.sendKey(mInstrumentation, listView, event);
        assertTrue(listView.isTextFilterEnabled());

        // we expect keyevent will be passed with nothing to do
        assertFalse(listView.hasTextFilter());
        assertEquals(-1, listView.getOnFilterCompleteCount());

        // KEYCODE_NUMPAD_ENTER is handled by isConfirmKey, too.
        // so make keyevent with repeat count.
        event = new KeyEvent(0, 0, KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_NUMPAD_ENTER, 1);
        CtsKeyEventUtil.sendKey(mInstrumentation, listView, event);
        assertTrue(listView.isTextFilterEnabled());

        // we expect keyevent will be passed with nothing to do, like KEYCODE_ENTER
        assertFalse(listView.hasTextFilter());
        assertEquals(-1, listView.getOnFilterCompleteCount());
    }

    /**
     * MyListView for test.
     */
    private static class MyListView extends ListView {
        public MyListView(Context context) {
            super(context);
        }

        public MyListView(Context context, AttributeSet attrs) {
            super(context, attrs);
        }

        public MyListView(Context context, AttributeSet attrs, int defStyle) {
            super(context, attrs, defStyle);
        }

        @Override
        protected boolean checkLayoutParams(ViewGroup.LayoutParams p) {
            return super.checkLayoutParams(p);
        }

        @Override
        protected int computeVerticalScrollExtent() {
            return super.computeVerticalScrollExtent();
        }

        @Override
        protected int computeVerticalScrollOffset() {
            return super.computeVerticalScrollOffset();
        }

        @Override
        protected int computeVerticalScrollRange() {
            return super.computeVerticalScrollRange();
        }

        @Override
        protected void dispatchDraw(Canvas canvas) {
            super.dispatchDraw(canvas);
        }

        @Override
        protected void dispatchSetPressed(boolean pressed) {
            super.dispatchSetPressed(pressed);
        }

        @Override
        protected ViewGroup.LayoutParams generateLayoutParams(ViewGroup.LayoutParams p) {
            return super.generateLayoutParams(p);
        }

        @Override
        protected float getBottomFadingEdgeStrength() {
            return super.getBottomFadingEdgeStrength();
        }

        @Override
        protected ContextMenuInfo getContextMenuInfo() {
            return super.getContextMenuInfo();
        }

        @Override
        protected float getTopFadingEdgeStrength() {
            return super.getTopFadingEdgeStrength();
        }

        @Override
        protected void handleDataChanged() {
            super.handleDataChanged();
        }

        @Override
        protected boolean isInFilterMode() {
            return super.isInFilterMode();
        }

        private boolean mIsBeforeTextChangedCalled;
        private boolean mIsOnTextChangedCalled;
        private boolean mIsAfterTextChangedCalled;

        @Override
        public void beforeTextChanged(CharSequence s, int start, int count, int after) {
            mIsBeforeTextChangedCalled = true;
            super.beforeTextChanged(s, start, count, after);
        }

        @Override
        public void onTextChanged(CharSequence s, int start, int before, int count) {
            mIsOnTextChangedCalled = true;
            super.onTextChanged(s, start, before, count);
        }

        @Override
        public void afterTextChanged(Editable s) {
            mIsAfterTextChangedCalled = true;
            super.afterTextChanged(s);
        }

        public boolean isBeforeTextChangedCalled() {
            return mIsBeforeTextChangedCalled;
        }

        public boolean isOnTextChangedCalled() {
            return mIsOnTextChangedCalled;
        }

        public boolean isAfterTextChangedCalled() {
            return mIsAfterTextChangedCalled;
        }

        private int mOnFilterCompleteCount = -1;

        @Override
        public void onFilterComplete(int count) {
            super.onFilterComplete(count);
            mOnFilterCompleteCount = count;
        }

        public int getOnFilterCompleteCount() {
            return mOnFilterCompleteCount;
        }

        private boolean mIsOnScrollChangedCalled;

        @Override
        protected void onScrollChanged(int l, int t, int oldl, int oldt) {
            mIsOnScrollChangedCalled = true;
            super.onScrollChanged(l, t, oldl, oldt);
        }

        public boolean isOnScrollChangedCalled() {
            return mIsOnScrollChangedCalled;
        }

        public void resetIsOnScrollChangedCalled() {
            mIsOnScrollChangedCalled = false;
        }
    }
}"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.server.wm.WindowFocusTests"	"getDisplayId"	"CtsWindowManagerDeviceTestCases"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/WindowFocusTests.java"	""	"/*
 *
 */

package android.server.wm;

import static android.hardware.display.DisplayManager.VIRTUAL_DISPLAY_FLAG_OWN_CONTENT_ONLY;
import static android.hardware.display.DisplayManager.VIRTUAL_DISPLAY_FLAG_PUBLIC;
import static android.view.Display.DEFAULT_DISPLAY;
import static android.view.Display.INVALID_DISPLAY;
import static android.view.KeyEvent.ACTION_DOWN;
import static android.view.KeyEvent.ACTION_UP;
import static android.view.KeyEvent.FLAG_CANCELED;
import static android.view.KeyEvent.KEYCODE_0;
import static android.view.KeyEvent.KEYCODE_1;
import static android.view.KeyEvent.KEYCODE_2;
import static android.view.KeyEvent.KEYCODE_3;
import static android.view.KeyEvent.KEYCODE_4;
import static android.view.KeyEvent.KEYCODE_5;
import static android.view.KeyEvent.KEYCODE_6;
import static android.view.KeyEvent.KEYCODE_7;
import static android.view.KeyEvent.KEYCODE_8;
import static android.view.KeyEvent.keyCodeToString;

import static androidx.test.platform.app.InstrumentationRegistry.getInstrumentation;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assume.assumeFalse;
import static org.junit.Assume.assumeTrue;

import android.app.Activity;
import android.content.Context;
import android.content.res.Configuration;
import android.graphics.Canvas;
import android.graphics.PixelFormat;
import android.graphics.Point;
import android.hardware.display.DisplayManager;
import android.hardware.display.VirtualDisplay;
import android.media.ImageReader;
import android.os.SystemClock;
import android.platform.test.annotations.Presubmit;
import android.view.Display;
import android.view.KeyEvent;
import android.view.MotionEvent;
import android.view.View;
import android.view.WindowManager.LayoutParams;

import androidx.annotation.NonNull;

import com.android.compatibility.common.util.SystemUtil;

import org.junit.Test;

import java.util.ArrayList;

import javax.annotation.concurrent.GuardedBy;

/**
 * Ensure window focus assignment is executed as expected.
 *
 * Build/Install/Run:
 *     atest WindowFocusTests
 */
@Presubmit
public class WindowFocusTests extends WindowManagerTestBase {

    private static void sendKey(int action, int keyCode, int displayId) {
        final KeyEvent keyEvent = new KeyEvent(action, keyCode);
        keyEvent.setDisplayId(displayId);
        SystemUtil.runWithShellPermissionIdentity(() -> {
            getInstrumentation().sendKeySync(keyEvent);
        });
    }

    private static void sendAndAssertTargetConsumedKey(InputTargetActivity target, int keyCode,
            int targetDisplayId) {
        sendAndAssertTargetConsumedKey(target, ACTION_DOWN, keyCode, targetDisplayId);
        sendAndAssertTargetConsumedKey(target, ACTION_UP, keyCode, targetDisplayId);
    }

    private static void sendAndAssertTargetConsumedKey(InputTargetActivity target, int action,
            int keyCode, int targetDisplayId) {
        final int eventCount = target.getKeyEventCount();
        sendKey(action, keyCode, targetDisplayId);
        target.assertAndConsumeKeyEvent(action, keyCode, 0 /* flags */);
        assertEquals(target.getLogTag() + "" must only receive key event sent."", eventCount,
                target.getKeyEventCount());
    }

    private static void tapOn(@NonNull Activity activity) {
        final Point p = getCenterOfActivityOnScreen(activity);
        final int displayId = activity.getDisplayId();

        final long downTime = SystemClock.elapsedRealtime();
        final MotionEvent downEvent = MotionEvent.obtain(downTime, downTime,
                MotionEvent.ACTION_DOWN, p.x, p.y, 0 /* metaState */);
        downEvent.setDisplayId(displayId);
        getInstrumentation().sendPointerSync(downEvent);
        final MotionEvent upEvent = MotionEvent.obtain(downTime, SystemClock.elapsedRealtime(),
                MotionEvent.ACTION_UP, p.x, p.y, 0 /* metaState */);
        upEvent.setDisplayId(displayId);
        getInstrumentation().sendPointerSync(upEvent);
    }

    private static Point getCenterOfActivityOnScreen(@NonNull Activity activity) {
        final View decorView = activity.getWindow().getDecorView();
        final int[] location = new int[2];
        decorView.getLocationOnScreen(location);
        return new Point(location[0] + decorView.getWidth() / 2,
                location[1] + decorView.getHeight() / 2);
    }

    /**
     * Test the following conditions:
     * - Each display can have a focused window at the same time.
     * - Focused windows can receive display-specified key events.
     * - The top focused window can receive display-unspecified key events.
     * - Taping on a display will make the focused window on it become top-focused.
     * - The window which lost top-focus can receive display-unspecified cancel events.
     */"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.server.wm.WindowFocusTests"	"testKeyReceiving"	"CtsWindowManagerDeviceTestCases"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/WindowFocusTests.java"	""	"public void testKeyReceiving() {
        final PrimaryActivity primaryActivity = startActivity(PrimaryActivity.class,
                DEFAULT_DISPLAY);
        sendAndAssertTargetConsumedKey(primaryActivity, KEYCODE_0, INVALID_DISPLAY);
        sendAndAssertTargetConsumedKey(primaryActivity, KEYCODE_1, DEFAULT_DISPLAY);

        assumeTrue(supportsMultiDisplay());

        // VirtualDisplay can't maintain perDisplayFocus because it is not trusted,
        // so uses SimulatedDisplay instead.
        final SimulatedDisplaySession session = createManagedSimulatedDisplaySession();
        final int secondaryDisplayId = session.getDisplayId();
        final SecondaryActivity secondaryActivity = session.startActivityAndFocus();
        sendAndAssertTargetConsumedKey(secondaryActivity, KEYCODE_2, INVALID_DISPLAY);
        sendAndAssertTargetConsumedKey(secondaryActivity, KEYCODE_3, secondaryDisplayId);

        final boolean perDisplayFocusEnabled = perDisplayFocusEnabled();
        if (perDisplayFocusEnabled) {
            primaryActivity.assertWindowFocusState(true /* hasFocus */);
            sendAndAssertTargetConsumedKey(primaryActivity, KEYCODE_4, DEFAULT_DISPLAY);
        } else {
            primaryActivity.waitAndAssertWindowFocusState(false /* hasFocus */);
        }

        // Press display-unspecified keys and a display-specified key but not release them.
        sendKey(ACTION_DOWN, KEYCODE_5, INVALID_DISPLAY);
        sendKey(ACTION_DOWN, KEYCODE_6, secondaryDisplayId);
        sendKey(ACTION_DOWN, KEYCODE_7, INVALID_DISPLAY);
        secondaryActivity.assertAndConsumeKeyEvent(ACTION_DOWN, KEYCODE_5, 0 /* flags */);
        secondaryActivity.assertAndConsumeKeyEvent(ACTION_DOWN, KEYCODE_6, 0 /* flags */);
        secondaryActivity.assertAndConsumeKeyEvent(ACTION_DOWN, KEYCODE_7, 0 /* flags */);

        tapOn(primaryActivity);

        // Assert only display-unspecified key would be cancelled after secondary activity is
        // not top focused if per-display focus is enabled. Otherwise, assert all non-released
        // key events sent to secondary activity would be cancelled.
        secondaryActivity.waitAssertAndConsumeKeyEvent(ACTION_UP, KEYCODE_5, FLAG_CANCELED);
        secondaryActivity.waitAssertAndConsumeKeyEvent(ACTION_UP, KEYCODE_7, FLAG_CANCELED);
        if (!perDisplayFocusEnabled) {
            secondaryActivity.waitAssertAndConsumeKeyEvent(ACTION_UP, KEYCODE_6, FLAG_CANCELED);
        }
        assertEquals(secondaryActivity.getLogTag() + "" must only receive expected events."",
                0 /* expected event count */, secondaryActivity.getKeyEventCount());

        // Assert primary activity become top focused after tapping on default display.
        sendAndAssertTargetConsumedKey(primaryActivity, KEYCODE_8, INVALID_DISPLAY);
    }

    /**
     * Test if a display targeted by a key event can be moved to top in a single-focus system.
     */"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.text.method.cts.BaseKeyListenerTest"	"testBackspace_withSendKeys"	"CtsTextTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/text/src/android/text/method/cts/BaseKeyListenerTest.java"	""	"public void testBackspace_withSendKeys() throws Throwable {
        final BaseKeyListener mockBaseKeyListener = new MockBaseKeyListener();

        // Delete the first character '1'
        prepTextViewSync(TEST_STRING, mockBaseKeyListener, true, 1, 1);
        CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, KeyEvent.KEYCODE_DEL);
        assertEquals(""23456"", mTextView.getText().toString());

        // Delete character '2' and '3'
        prepTextViewSync(TEST_STRING, mockBaseKeyListener, true, 1, 3);
        CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, KeyEvent.KEYCODE_DEL);
        assertEquals(""1456"", mTextView.getText().toString());

        // Delete everything on the line the cursor is on.
        prepTextViewSync(TEST_STRING, mockBaseKeyListener, true, 0, 0);
        CtsKeyEventUtil.sendKeyWhileHoldingModifier(
                mInstrumentation, mTextView, KeyEvent.KEYCODE_DEL, KeyEvent.KEYCODE_ALT_LEFT);
        assertEquals("""", mTextView.getText().toString());

        // ALT+DEL deletes the selection only.
        prepTextViewSync(TEST_STRING, mockBaseKeyListener, true, 2, 4);
        CtsKeyEventUtil.sendKeyWhileHoldingModifier(
                mInstrumentation, mTextView, KeyEvent.KEYCODE_DEL, KeyEvent.KEYCODE_ALT_LEFT);
        assertEquals(""1256"", mTextView.getText().toString());

        // DEL key does not take effect when TextView does not have BaseKeyListener.
        prepTextViewSync(TEST_STRING, null, true, 1, 1);
        CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, KeyEvent.KEYCODE_DEL);
        assertEquals(TEST_STRING, mTextView.getText().toString());
    }

    private void verifyCursorPosition(Editable content, int offset) {
        assertEquals(offset, Selection.getSelectionStart(content));
        assertEquals(offset, Selection.getSelectionEnd(content));
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.text.method.cts.BaseKeyListenerTest"	"testPressKey"	"CtsTextTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/text/src/android/text/method/cts/BaseKeyListenerTest.java"	""	"public void testPressKey() throws Throwable {
        final BaseKeyListener mockBaseKeyListener = new MockBaseKeyListener();

        // press '0' key.
        prepTextViewSync(TEST_STRING, mockBaseKeyListener, true, 0, 0);
        CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, KeyEvent.KEYCODE_0);
        assertEquals(""123456"", mTextView.getText().toString());

        // delete character '2'
        prepTextViewSync(mTextView.getText(), mockBaseKeyListener, true, 1, 2);
        CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, KeyEvent.KEYCODE_DEL);
        assertEquals(""13456"", mTextView.getText().toString());

        // test ACTION_MULTIPLE KEYCODE_UNKNOWN key event.
        KeyEvent event = new KeyEvent(SystemClock.uptimeMillis(), ""abcd"",
                KeyCharacterMap.BUILT_IN_KEYBOARD, 0);
        prepTextViewSync(mTextView.getText(), mockBaseKeyListener, true, 2, 2);
        CtsKeyEventUtil.sendKey(mInstrumentation, mTextView, event);
        mInstrumentation.waitForIdleSync();
        // the text of TextView is never changed, onKeyOther never works.
//        assertEquals(""13abcd456"", mTextView.getText().toString());
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.autofillservice.cts.commontests.DatasetFilteringTest"	"DatasetFilteringTest"	"CtsAutoFillServiceTestCases"	"/home/gpoor/cts-12-source/cts/tests/autofillservice/src/android/autofillservice/cts/commontests/DatasetFilteringTest.java"	""	"/*
 *.
 */

package android.autofillservice.cts.commontests;

import static android.autofillservice.cts.testcore.Helper.ID_USERNAME;
import static android.autofillservice.cts.testcore.Timeouts.MOCK_IME_TIMEOUT_MS;

import static com.android.compatibility.common.util.ShellUtils.sendKeyEvent;
import static com.android.cts.mockime.ImeEventStreamTestUtils.editorMatcher;
import static com.android.cts.mockime.ImeEventStreamTestUtils.expectBindInput;
import static com.android.cts.mockime.ImeEventStreamTestUtils.expectCommand;
import static com.android.cts.mockime.ImeEventStreamTestUtils.expectEvent;

import static org.junit.Assume.assumeTrue;

import android.autofillservice.cts.activities.AuthenticationActivity;
import android.autofillservice.cts.testcore.CannedFillResponse;
import android.autofillservice.cts.testcore.CannedFillResponse.CannedDataset;
import android.autofillservice.cts.testcore.MaxVisibleDatasetsRule;
import android.autofillservice.cts.testcore.MyAutofillCallback;
import android.autofillservice.cts.testcore.UiBot;
import android.content.IntentSender;
import android.os.Process;
import android.platform.test.annotations.AppModeFull;
import android.platform.test.annotations.Presubmit;
import android.view.KeyEvent;
import android.widget.EditText;

import com.android.cts.mockime.ImeCommand;
import com.android.cts.mockime.ImeEventStream;
import com.android.cts.mockime.MockImeSession;

import org.junit.Test;
import org.junit.rules.RuleChain;
import org.junit.rules.TestRule;

import java.util.regex.Pattern;

public abstract class DatasetFilteringTest extends AbstractLoginActivityTestCase {

    protected DatasetFilteringTest() {
    }

    protected DatasetFilteringTest(UiBot inlineUiBot) {
        super(inlineUiBot);
    }

    @Override
    protected TestRule getMainTestRule() {
        return RuleChain.outerRule(new MaxVisibleDatasetsRule(4))
                        .around(super.getMainTestRule());
    }


    private void changeUsername(CharSequence username) {
        mActivity.onUsername((v) -> v.setText(username));
    }

    @Presubmit"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.autofillservice.cts.commontests.DatasetFilteringTest"	"testFilter_injectingEvents"	"CtsAutoFillServiceTestCases"	"/home/gpoor/cts-12-source/cts/tests/autofillservice/src/android/autofillservice/cts/commontests/DatasetFilteringTest.java"	""	"public void testFilter_injectingEvents() throws Exception {
        final String aa = ""Two A's"";
        final String ab = ""A and B"";
        final String b = ""Only B"";

        enableService();

        // Set expectations.
        sReplier.addResponse(new CannedFillResponse.Builder()
                .addDataset(new CannedDataset.Builder()
                        .setField(ID_USERNAME, ""aa"")
                        .setPresentation(aa, isInlineMode())
                        .build())
                .addDataset(new CannedDataset.Builder()
                        .setField(ID_USERNAME, ""ab"")
                        .setPresentation(ab, isInlineMode())
                        .build())
                .addDataset(new CannedDataset.Builder()
                        .setField(ID_USERNAME, ""b"")
                        .setPresentation(b, isInlineMode())
                        .build())
                .build());

        // Trigger auto-fill.
        mUiBot.selectByRelativeId(ID_USERNAME);
        mUiBot.waitForIdle();
        sReplier.getNextFillRequest();

        // With no filter text all datasets should be shown
        mUiBot.assertDatasets(aa, ab, b);

        // Only two datasets start with 'a'
        sendKeyEvent(""KEYCODE_A"");
        mUiBot.assertDatasets(aa, ab);

        // Only one dataset start with 'aa'
        sendKeyEvent(""KEYCODE_A"");
        mUiBot.assertDatasets(aa);

        // Only two datasets start with 'a'
        sendKeyEvent(""KEYCODE_DEL"");
        mUiBot.assertDatasets(aa, ab);

        // With no filter text all datasets should be shown
        sendKeyEvent(""KEYCODE_DEL"");
        mUiBot.assertDatasets(aa, ab, b);

        // No dataset start with 'aaa'
        final MyAutofillCallback callback = mActivity.registerCallback();
        sendKeyEvent(""KEYCODE_A"");
        sendKeyEvent(""KEYCODE_A"");
        sendKeyEvent(""KEYCODE_A"");
        callback.assertUiHiddenEvent(mActivity.getUsername());
        mUiBot.assertNoDatasets();
    }

    @Presubmit"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.autofillservice.cts.commontests.DatasetFilteringTest"	"testFilter_usingKeyboard"	"CtsAutoFillServiceTestCases"	"/home/gpoor/cts-12-source/cts/tests/autofillservice/src/android/autofillservice/cts/commontests/DatasetFilteringTest.java"	""	"@AppModeFull(reason = ""testFilter_usingKeyboard() is enough"")
    public void testFilter_mixPlainAndRegex_usingKeyboard() throws Exception {
        final String plain = ""Plain"";
        final String regexPlain = ""RegexPlain"";
        final String authRegex = ""AuthRegex"";
        final String kitchnSync = ""KitchenSync"";
        final Pattern everything = Pattern.compile("".*"");

        enableService();

        // Set expectations.
        final IntentSender authentication = AuthenticationActivity.createSender(mContext, 1,
                new CannedDataset.Builder()
                        .setField(ID_USERNAME, ""dude"")
                        .build());
        sReplier.addResponse(new CannedFillResponse.Builder()
                .addDataset(new CannedDataset.Builder()
                        .setField(ID_USERNAME, ""aword"")
                        .setPresentation(plain, isInlineMode())
                        .build())
                .addDataset(new CannedDataset.Builder()
                        .setField(ID_USERNAME, ""a ignore"", everything)
                        .setPresentation(regexPlain, isInlineMode())
                        .build())
                .addDataset(new CannedDataset.Builder()
                        .setField(ID_USERNAME, ""ab ignore"", everything)
                        .setAuthentication(authentication)
                        .setPresentation(authRegex, isInlineMode())
                        .build())
                .addDataset(new CannedDataset.Builder()
                        .setField(ID_USERNAME, ""ab ignore"",
                                everything)
                        .setPresentation(kitchnSync, isInlineMode())
                        .build())
                .build());

        // Trigger auto-fill.
        mUiBot.selectByRelativeId(ID_USERNAME);
        mUiBot.waitForIdle();
        sReplier.getNextFillRequest();

        // With no filter text all datasets should be shown
        mUiBot.assertDatasets(plain, regexPlain, authRegex, kitchnSync);

        // All datasets start with 'a'
        sendKeyEvent(""KEYCODE_A"");
        mUiBot.assertDatasets(plain, regexPlain, authRegex, kitchnSync);

        // Only the regex datasets should start with 'ab'
        sendKeyEvent(""KEYCODE_B"");
        mUiBot.assertDatasets(regexPlain, authRegex, kitchnSync);
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.hdmicec.cts.HdmiCecClientWrapper"	"ArrayList"	"CtsHdmiCecHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/hdmicec/src/android/hdmicec/cts/HdmiCecClientWrapper.java"	""	"public void test/*
 *.
 */

package android.hdmicec.cts;

import android.hdmicec.cts.error.CecClientWrapperException;
import android.hdmicec.cts.error.ErrorCodes;

import com.android.tradefed.device.DeviceNotAvailableException;
import com.android.tradefed.device.ITestDevice;
import com.android.tradefed.log.LogUtil.CLog;
import com.android.tradefed.util.RunUtil;

import org.junit.rules.ExternalResource;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.TimeUnit;
import java.util.regex.Pattern;

/** Class that helps communicate with the cec-client */
public final class HdmiCecClientWrapper extends ExternalResource {

    private static final int MILLISECONDS_TO_READY = 10000;
    private static final int DEFAULT_TIMEOUT = 20000;
    private static final int BUFFER_SIZE = 1024;

    private Process mCecClient;
    private BufferedWriter mOutputConsole;
    private BufferedReader mInputConsole;
    private boolean mCecClientInitialised = false;

    private LogicalAddress selfDevice = LogicalAddress.RECORDER_1;
    private LogicalAddress targetDevice = LogicalAddress.UNKNOWN;
    private String clientParams[];
    private StringBuilder sendVendorCommand = new StringBuilder(""cmd hdmi_control vendorcommand "");
    private int physicalAddress = 0xFFFF;

    private CecOperand featureAbortOperand = CecOperand.FEATURE_ABORT;
    private List<Integer> featureAbortReasons =
            new ArrayList<>(HdmiCecConstants.ABORT_INVALID_OPERAND);
    private boolean isFeatureAbortExpected = false;

    private static final String CEC_PORT_BUSY = ""unable to open the device on port"";

    public HdmiCecClientWrapper(String ...clientParams) {
        this.clientParams = clientParams;
    }

    @Override
    protected void after() {
        this.killCecProcess();
    }

    void setTargetLogicalAddress(LogicalAddress dutLogicalAddress) {
        targetDevice = dutLogicalAddress;
    }

    public List<String> getValidCecClientPorts() throws CecClientWrapperException {

        List<String> listPortsCommand = new ArrayList();
        Process cecClient;

        listPortsCommand.add(""cec-client"");
        listPortsCommand.add(""-l"");

        List<String> comPorts = new ArrayList();
        try {
            cecClient = RunUtil.getDefault().runCmdInBackground(listPortsCommand);
        } catch (IOException ioe) {
            throw new CecClientWrapperException(
                    ErrorCodes.CecClientStart,
                    ""as cec-client may not be installed. Please refer to README for""
                        + "" setup/installation instructions."");
        }
        try {
            BufferedReader inputConsole =
                    new BufferedReader(new InputStreamReader(cecClient.getInputStream()));
            while (cecClient.isAlive()) {
                if (inputConsole.ready()) {
                    String line = inputConsole.readLine();
                    if (line.toLowerCase().contains(""com port"")) {
                        String port = line.split("":"")[1].trim();
                        comPorts.add(port);
                    }
                }
            }
            inputConsole.close();
            cecClient.waitFor();
        } catch (IOException | InterruptedException ioe) {
            throw new CecClientWrapperException(ErrorCodes.ReadConsole, ioe);
        }

        return comPorts;
    }

    boolean initValidCecClient(ITestDevice device, List<String> clientCommands)
            throws CecClientWrapperException {

        String serialNo;
        List<String> launchCommand = new ArrayList(clientCommands);
        try {
            serialNo = device.getProperty(""ro.serialno"");
        } catch (DeviceNotAvailableException de) {
            throw new CecClientWrapperException(ErrorCodes.DeviceNotAvailable, de);
        }
        File mDeviceEntry = new File(HdmiCecConstants.CEC_MAP_FOLDER, serialNo);

        try (BufferedReader reader = new BufferedReader(new FileReader(mDeviceEntry))) {
            String port = reader.readLine();
            launchCommand.add(port);
            mCecClient = RunUtil.getDefault().runCmdInBackground(launchCommand);
            mInputConsole = new BufferedReader(new InputStreamReader(mCecClient.getInputStream()));

            /* Wait for the client to become ready */
            if (checkConsoleOutput(
                    CecClientMessage.CLIENT_CONSOLE_READY + """", MILLISECONDS_TO_READY)) {
                        mOutputConsole =
                                new BufferedWriter(
                                        new OutputStreamWriter(mCecClient.getOutputStream()),
                                        BUFFER_SIZE);
                        return true;
            } else {
                CLog.e(""Console did not get ready!"");
                /* Kill the unwanted cec-client process. */
                Process killProcess = mCecClient.destroyForcibly();
                killProcess.waitFor();
            }
        } catch (IOException | InterruptedException ioe) {
            throw new CecClientWrapperException(
                    ErrorCodes.ReadConsole, ioe, ""Could not open port mapping file"");
        }
        return false;
    }

    /** Initialise the client */
    void init(boolean startAsTv, ITestDevice device) throws CecClientWrapperException {
        if (targetDevice == LogicalAddress.UNKNOWN) {
            throw new CecClientWrapperException(
                    ErrorCodes.CecClientStart, ""Missing logical address of the target device."");
        }

        List<String> commands = new ArrayList();

        commands.add(""cec-client"");

        /* ""-p 2"" starts the client as if it is connected to HDMI port 2, taking the physical
         * address 2.0.0.0 */
        commands.add(""-p"");
        commands.add(""2"");
        physicalAddress = 0x2000;
        if (startAsTv) {
            commands.add(""-t"");
            commands.add(""x"");
            selfDevice = LogicalAddress.TV;
        }
        /* ""-d 15"" set the log level to ERROR|WARNING|NOTICE|TRAFFIC */
        commands.add(""-d"");
        commands.add(""15"");
        commands.addAll(Arrays.asList(clientParams));
        if (Arrays.asList(clientParams).contains(""a"")) {
            selfDevice = LogicalAddress.AUDIO_SYSTEM;
        }

        mCecClientInitialised = true;
        if (!initValidCecClient(device, commands)) {
            mCecClientInitialised = false;

            throw new CecClientWrapperException(ErrorCodes.CecClientStart);
        }
    }

    private void checkCecClient() throws CecClientWrapperException {
        if (!mCecClientInitialised) {
            throw new CecClientWrapperException(ErrorCodes.CecClientStart);
        }
        if (!mCecClient.isAlive()) {
            throw new CecClientWrapperException(ErrorCodes.CecClientNotRunning);
        }
    }

    /**
     * Sends a CEC message with source marked as broadcast to the device passed in the constructor
     * through the output console of the cec-communication channel.
     */
    public void sendCecMessage(CecOperand message) throws CecClientWrapperException {
        sendCecMessage(LogicalAddress.BROADCAST, targetDevice, message, """");
    }

    /**
     * Sends a CEC message from source device to the device passed in the constructor through the
     * output console of the cec-communication channel.
     */
    public void sendCecMessage(LogicalAddress source, CecOperand message)
            throws CecClientWrapperException {
        sendCecMessage(source, targetDevice, message, """");
    }

    /**
     * Sends a CEC message from source device to the device passed in the constructor through the
     * output console of the cec-communication channel with the appended params.
     */
    public void sendCecMessage(LogicalAddress source, CecOperand message, String params)
            throws Exception {
        sendCecMessage(source, targetDevice, message, params);
    }

    /**
     * Sends a CEC message from source device to a destination device through the output console of
     * the cec-communication channel.
     */
    public void sendCecMessage(
            LogicalAddress source, LogicalAddress destination, CecOperand message)
            throws CecClientWrapperException {
        sendCecMessage(source, destination, message, """");
    }

    /**
     * Broadcasts a CEC ACTIVE_SOURCE message from client device source through the output console
     * of the cec-communication channel.
     */
    public void broadcastActiveSource(LogicalAddress source) throws CecClientWrapperException {
        int sourcePa = (source == selfDevice) ? physicalAddress : 0xFFFF;
        sendCecMessage(
                source,
                LogicalAddress.BROADCAST,
                CecOperand.ACTIVE_SOURCE,
                CecMessage.formatParams(sourcePa, HdmiCecConstants.PHYSICAL_ADDRESS_LENGTH));
    }

    /**
     * Broadcasts a CEC ACTIVE_SOURCE message with physicalAddressOfActiveDevice from client device
     * source through the output console of the cec-communication channel.
     */
    public void broadcastActiveSource(LogicalAddress source, int physicalAddressOfActiveDevice)
            throws CecClientWrapperException {
        sendCecMessage(
                source,
                LogicalAddress.BROADCAST,
                CecOperand.ACTIVE_SOURCE,
                CecMessage.formatParams(
                        physicalAddressOfActiveDevice, HdmiCecConstants.PHYSICAL_ADDRESS_LENGTH));
    }

    /**
     * Broadcasts a CEC REPORT_PHYSICAL_ADDRESS message from client device source through the output
     * console of the cec-communication channel.
     */
    public void broadcastReportPhysicalAddress(LogicalAddress source)
            throws CecClientWrapperException {
        String deviceType = CecMessage.formatParams(source.getDeviceType());
        int sourcePa = (source == selfDevice) ? physicalAddress : 0xFFFF;
        String physicalAddress =
                CecMessage.formatParams(sourcePa, HdmiCecConstants.PHYSICAL_ADDRESS_LENGTH);
        sendCecMessage(
                source,
                LogicalAddress.BROADCAST,
                CecOperand.REPORT_PHYSICAL_ADDRESS,
                physicalAddress + deviceType);
    }

    /**
     * Broadcasts a CEC REPORT_PHYSICAL_ADDRESS message with physicalAddressToReport from client
     * device source through the output console of the cec-communication channel.
     */
    public void broadcastReportPhysicalAddress(LogicalAddress source, int physicalAddressToReport)
            throws CecClientWrapperException {
        String deviceType = CecMessage.formatParams(source.getDeviceType());
        String physicalAddress =
                CecMessage.formatParams(
                        physicalAddressToReport, HdmiCecConstants.PHYSICAL_ADDRESS_LENGTH);
        sendCecMessage(
                source,
                LogicalAddress.BROADCAST,
                CecOperand.REPORT_PHYSICAL_ADDRESS,
                physicalAddress + deviceType);
    }

    /**
     * Sends a CEC message from source device to a destination device through the output console of
     * the cec-communication channel with the appended params.
     */
    public void sendCecMessage(
            LogicalAddress source, LogicalAddress destination, CecOperand message, String params)
            throws CecClientWrapperException {
        checkCecClient();
        String sendMessageString = ""tx "" + source + destination + "":"" + message + params;
        try {
            CLog.v(""Sending CEC message: "" + sendMessageString);
            mOutputConsole.write(sendMessageString);
            mOutputConsole.newLine();
            mOutputConsole.flush();
        } catch (IOException ioe) {
            throw new CecClientWrapperException(ErrorCodes.WriteConsole, ioe);
        }
    }

    /**
     * Sends a <USER_CONTROL_PRESSED> and <USER_CONTROL_RELEASED> from source to device through the
     * output console of the cec-communication channel with the mentioned keycode.
     */
    public void sendUserControlPressAndRelease(LogicalAddress source, int keycode, boolean holdKey)
            throws CecClientWrapperException {
        sendUserControlPressAndRelease(source, targetDevice, keycode, holdKey);
    }

    /**
     * Sends a <USER_CONTROL_PRESSED> and <USER_CONTROL_RELEASED> from source to destination
     * through the output console of the cec-communication channel with the mentioned keycode.
     */
    public void sendUserControlPressAndRelease(
            LogicalAddress source, LogicalAddress destination, int keycode, boolean holdKey)
            throws CecClientWrapperException {
        sendUserControlPress(source, destination, keycode, holdKey);
        try {
            /* Sleep less than 200ms between press and release */
            TimeUnit.MILLISECONDS.sleep(100);
            mOutputConsole.write(
                    ""tx "" + source + destination + "":"" + CecOperand.USER_CONTROL_RELEASED);
            mOutputConsole.flush();
        } catch (IOException | InterruptedException ioe) {
            throw new CecClientWrapperException(ErrorCodes.WriteConsole, ioe);
        }
    }

    /**
     * Sends a <UCP> message from source to destination through the output console of the
     * cec-communication channel with the mentioned keycode. If holdKey is true, the method will
     * send multiple <UCP> messages to simulate a long press. No <UCR> will be sent.
     */
    public void sendUserControlPress(
            LogicalAddress source, LogicalAddress destination, int keycode, boolean holdKey)
            throws CecClientWrapperException {
        String key = String.format(""%02x"", keycode);
        String command = ""tx "" + source + destination + "":"" +
                CecOperand.USER_CONTROL_PRESSED + "":"" + key;

        try {
            if (holdKey) {
                /* Repeat once every 450ms for at least 5 seconds. Send 11 times in loop every
                 * 450ms. The message is sent once after the loop as well.
                 * ((11 + 1) * 0.45 = 5.4s total) */
                int repeat = 11;
                for (int i = 0; i < repeat; i++) {
                    mOutputConsole.write(command);
                    mOutputConsole.newLine();
                    mOutputConsole.flush();
                    TimeUnit.MILLISECONDS.sleep(450);
                }
            }

            mOutputConsole.write(command);
            mOutputConsole.newLine();
            mOutputConsole.flush();
        } catch (IOException | InterruptedException ioe) {
            throw new CecClientWrapperException(ErrorCodes.WriteConsole, ioe);
        }
    }

    /**
     * Sends a series of <UCP> [firstKeycode] from source to destination through the output console
     * of the cec-communication channel immediately followed by <UCP> [secondKeycode]. No <UCR>
     * message is sent.
     */
    public void sendUserControlInterruptedPressAndHold(
            LogicalAddress source,
            LogicalAddress destination,
            int firstKeycode,
            int secondKeycode,
            boolean holdKey)
            throws CecClientWrapperException {
        sendUserControlPress(source, destination, firstKeycode, holdKey);
        try {
            /* Sleep less than 200ms between press and release */
            TimeUnit.MILLISECONDS.sleep(100);
        } catch (InterruptedException ie) {
            throw new CecClientWrapperException(ErrorCodes.WriteConsole, ie);
        }
        sendUserControlPress(source, destination, secondKeycode, false);
    }

    /** Sends a poll message to the device */
    public void sendPoll() throws Exception {
        sendPoll(targetDevice);
    }

    /** Sends a poll message to the destination */
    public void sendPoll(LogicalAddress destination) throws Exception {
        String command = CecClientMessage.POLL + "" "" + destination;
        sendConsoleMessage(command);
    }


    /** Sends a message to the output console of the cec-client */
    public void sendConsoleMessage(String message) throws CecClientWrapperException {
        checkCecClient();
        CLog.v(""Sending console message:: "" + message);
        try {
            mOutputConsole.write(message);
            mOutputConsole.flush();
        } catch (IOException ioe) {
            throw new CecClientWrapperException(ErrorCodes.WriteConsole, ioe);
        }
    }

    /** Check for any string on the input console of the cec-client, uses default timeout */
    public boolean checkConsoleOutput(String expectedMessage) throws CecClientWrapperException {
        return checkConsoleOutput(expectedMessage, DEFAULT_TIMEOUT);
    }

    /** Check for any string on the input console of the cec-client */
    public boolean checkConsoleOutput(String expectedMessage, long timeoutMillis)
            throws CecClientWrapperException {
        checkCecClient();
        return checkConsoleOutput(expectedMessage, timeoutMillis, mInputConsole);
    }

    /** Check for any string on the specified input console */
    public boolean checkConsoleOutput(
            String expectedMessage, long timeoutMillis, BufferedReader inputConsole)
            throws CecClientWrapperException {
        long startTime = System.currentTimeMillis();
        long endTime = startTime;

        while ((endTime - startTime <= timeoutMillis)) {
            try {
                if (inputConsole.ready()) {
                    String line = inputConsole.readLine();
                    if (line != null
                            && line.toLowerCase().contains(expectedMessage.toLowerCase())) {
                        CLog.v(""Found "" + expectedMessage + "" in "" + line);
                        return true;
                    } else if (line.toLowerCase().contains(CEC_PORT_BUSY.toLowerCase())) {
                        throw new CecClientWrapperException(ErrorCodes.CecPortBusy);
                    }
                }
            } catch (IOException ioe) {
                throw new CecClientWrapperException(ErrorCodes.ReadConsole, ioe);
            }
            endTime = System.currentTimeMillis();
        }
        return false;
    }

    /** Gets all the messages received from the given list of source devices during a period of
     * duration seconds.
     */
    public List<CecOperand> getAllMessages(List<LogicalAddress> sourceList, int duration)
            throws CecClientWrapperException {
        List<CecOperand> receivedOperands = new ArrayList<>();
        long startTime = System.currentTimeMillis();
        long endTime = startTime;

        String source = sourceList.toString().replace("","", """").replace("" "", """");

        Pattern pattern = Pattern.compile(""(.*>>)(.*?)"" +
                ""("" + source + ""\\p{XDigit}):(.*)"",
            Pattern.CASE_INSENSITIVE);

        while ((endTime - startTime <= (duration * 1000))) {
            try {
                if (mInputConsole.ready()) {
                    String line = mInputConsole.readLine();
                    if (pattern.matcher(line).matches()) {
                        CecOperand operand = CecMessage.getOperand(line);
                        if (!receivedOperands.contains(operand)) {
                            receivedOperands.add(operand);
                        }
                    }
                }
            } catch (IOException ioe) {
                throw new CecClientWrapperException(ErrorCodes.ReadConsole, ioe);
            }
            endTime = System.currentTimeMillis();
        }
        return receivedOperands;
    }

    /**
     * Gets the list of logical addresses which receives messages with operand expectedMessage
     * during a period of duration seconds.
     */
    public List<LogicalAddress> getAllDestLogicalAddresses(CecOperand expectedMessage, int duration)
            throws CecClientWrapperException {
        return getAllDestLogicalAddresses(expectedMessage, """", duration);
    }

    /**
     * Gets the list of logical addresses which receives messages with operand expectedMessage and
     * params during a period of duration seconds.
     */
    public List<LogicalAddress> getAllDestLogicalAddresses(
            CecOperand expectedMessage, String params, int duration)
            throws CecClientWrapperException {
        List<LogicalAddress> destinationAddresses = new ArrayList<>();
        long startTime = System.currentTimeMillis();
        long endTime = startTime;
        Pattern pattern =
                Pattern.compile(
                        ""(.*>>)(.*?)"" + "":("" + expectedMessage + params + "")(.*)"",
                        Pattern.CASE_INSENSITIVE);

        while ((endTime - startTime <= (duration * 1000))) {
            try {
                if (mInputConsole.ready()) {
                    String line = mInputConsole.readLine();
                    if (pattern.matcher(line).matches()) {
                        LogicalAddress destination = CecMessage.getDestination(line);
                        if (!destinationAddresses.contains(destination)) {
                            destinationAddresses.add(destination);
                        }
                    }
                }
            } catch (IOException ioe) {
                throw new CecClientWrapperException(ErrorCodes.ReadConsole, ioe);
            }
            endTime = System.currentTimeMillis();
        }
        return destinationAddresses;
    }

    /**
     * The next checkExpectedOutput calls will also permit a feature abort as an alternate to the
     * expected operand. The feature abort will be permissible if it has
     *
     * @param abortForOperand The operand for which the feature abort could be an allowed response
     * @param reasons List of allowed reasons that the feature abort message could have
     */
    private void setExpectFeatureAbortFor(CecOperand abortOperand, Integer... abortReasons) {
        isFeatureAbortExpected = true;
        featureAbortOperand = abortOperand;
        featureAbortReasons = Arrays.asList(abortReasons);
    }

    /** Removes feature abort as a permissible alternate response for {@link checkExpectedOutput} */
    private void unsetExpectFeatureAbort() {
        isFeatureAbortExpected = false;
        CecOperand featureAbortOperand = CecOperand.FEATURE_ABORT;
        List<Integer> featureAbortReasons = new ArrayList<>(HdmiCecConstants.ABORT_INVALID_OPERAND);
    }

    /**
     * Looks for the CEC expectedMessage broadcast on the cec-client communication channel and
     * returns the first line that contains that message within default timeout. If the CEC message
     * is not found within the timeout, an CecClientWrapperException is thrown.
     */
    public String checkExpectedOutput(CecOperand expectedMessage) throws CecClientWrapperException {
        return checkExpectedOutput(
                targetDevice, LogicalAddress.BROADCAST, expectedMessage, DEFAULT_TIMEOUT, false);
    }

    /**
     * Looks for the CEC expectedMessage sent to CEC device toDevice on the cec-client communication
     * channel and returns the first line that contains that message within default timeout. If the
     * CEC message is not found within the timeout, an CecClientWrapperException is thrown.
     */
    public String checkExpectedOutput(LogicalAddress toDevice, CecOperand expectedMessage)
            throws CecClientWrapperException {
        return checkExpectedOutput(targetDevice, toDevice, expectedMessage, DEFAULT_TIMEOUT, false);
    }

    /**
     * Looks for the broadcasted CEC expectedMessage sent from cec-client device fromDevice on the
     * cec-client communication channel and returns the first line that contains that message within
     * default timeout. If the CEC message is not found within the timeout, an
     * CecClientWrapperException is thrown.
     */
    public String checkExpectedMessageFromClient(
            LogicalAddress fromDevice, CecOperand expectedMessage)
            throws CecClientWrapperException {
        return checkExpectedMessageFromClient(
                fromDevice, LogicalAddress.BROADCAST, expectedMessage);
    }

    /**
     * Looks for the CEC expectedMessage sent from cec-client device fromDevice to CEC device
     * toDevice on the cec-client communication channel and returns the first line that contains
     * that message within default timeout. If the CEC message is not found within the timeout, an
     * CecClientWrapperException is thrown.
     */
    public String checkExpectedMessageFromClient(
            LogicalAddress fromDevice, LogicalAddress toDevice, CecOperand expectedMessage)
            throws CecClientWrapperException {
        return checkExpectedOutput(fromDevice, toDevice, expectedMessage, DEFAULT_TIMEOUT, true);
    }

    /**
     * Looks for the CEC expectedMessage or a {@code <Feature Abort>} for {@code
     * featureAbortOperand} with one of the abort reasons in {@code abortReason} is sent from
     * cec-client device fromDevice to the DUT on the cec-client communication channel and returns
     * the first line that contains that message within default timeout. If the CEC message is not
     * found within the timeout, a CecClientWrapperException is thrown.
     */
    public String checkExpectedOutputOrFeatureAbort(
            LogicalAddress fromDevice,
            CecOperand expectedMessage,
            CecOperand featureAbortOperand,
            Integer... featureAbortReasons)
            throws CecClientWrapperException {
        setExpectFeatureAbortFor(featureAbortOperand, featureAbortReasons);
        String message =
                checkExpectedOutput(
                        targetDevice, fromDevice, expectedMessage, DEFAULT_TIMEOUT, false);
        unsetExpectFeatureAbort();
        return message;
    }

    /**
     * Looks for the CEC expectedMessage broadcast on the cec-client communication channel and
     * returns the first line that contains that message within timeoutMillis. If the CEC message is
     * not found within the timeout, an CecClientWrapperException is thrown.
     */
    public String checkExpectedOutput(CecOperand expectedMessage, long timeoutMillis)
            throws CecClientWrapperException {
        return checkExpectedOutput(
                targetDevice, LogicalAddress.BROADCAST, expectedMessage, timeoutMillis, false);
    }

    /**
     * Looks for the CEC expectedMessage sent to CEC device toDevice on the cec-client communication
     * channel and returns the first line that contains that message within timeoutMillis. If the
     * CEC message is not found within the timeout, an CecClientWrapperException is thrown.
     */
    public String checkExpectedOutput(
            LogicalAddress toDevice, CecOperand expectedMessage, long timeoutMillis)
            throws CecClientWrapperException {
        return checkExpectedOutput(targetDevice, toDevice, expectedMessage, timeoutMillis, false);
    }

    /**
     * Looks for the CEC expectedMessage sent from CEC device fromDevice to CEC device toDevice on
     * the cec-client communication channel and returns the first line that contains that message
     * within timeoutMillis. If the CEC message is not found within the timeout, an
     * CecClientWrapperException is thrown. This method looks for the CEC messages coming from
     * Cec-client if fromCecClient is true.
     */
    public String checkExpectedOutput(
            LogicalAddress fromDevice,
            LogicalAddress toDevice,
            CecOperand expectedMessage,
            long timeoutMillis,
            boolean fromCecClient)
            throws CecClientWrapperException {
        checkCecClient();
        long startTime = System.currentTimeMillis();
        long endTime = startTime;
        String direction = fromCecClient ? ""<<"" : "">>"";
        Pattern pattern;
        if (expectedMessage == CecOperand.POLL) {
            pattern =
                    Pattern.compile(
                            ""(.*""
                                    + direction
                                    + "")(.*?)""
                                    + ""(""
                                    + fromDevice
                                    + toDevice
                                    + "")(.*)"",
                            Pattern.CASE_INSENSITIVE);
        } else {
            String expectedOperands = expectedMessage.toString();
            if (isFeatureAbortExpected) {
                expectedOperands += ""|"" + CecOperand.FEATURE_ABORT;
            }
            pattern =
                    Pattern.compile(
                            ""(.*""
                                    + direction
                                    + "")(.*?)""
                                    + ""(""
                                    + fromDevice
                                    + toDevice
                                    + ""):""
                                    + ""(""
                                    + expectedOperands
                                    + "")(.*)"",
                            Pattern.CASE_INSENSITIVE);
        }
        while ((endTime - startTime <= timeoutMillis)) {
            try {
                if (mInputConsole.ready()) {
                    String line = mInputConsole.readLine();
                    if (pattern.matcher(line).matches()) {
                        if (isFeatureAbortExpected
                                && CecMessage.getOperand(line) == CecOperand.FEATURE_ABORT) {
                            CecOperand featureAbortedFor =
                                    CecOperand.getOperand(CecMessage.getParams(line, 0, 2));
                            int reason = CecMessage.getParams(line, 2, 4);
                            if (featureAbortedFor == featureAbortOperand
                                    && featureAbortReasons.contains(reason)) {
                                return line;
                            } else {
                                continue;
                            }
                        }
                        CLog.v(""Found "" + expectedMessage.name() + "" in "" + line);
                        return line;
                    }
                }
            } catch (IOException ioe) {
                throw new CecClientWrapperException(ErrorCodes.ReadConsole, ioe);
            }
            endTime = System.currentTimeMillis();
        }
        throw new CecClientWrapperException(ErrorCodes.CecMessageNotFound, expectedMessage.name());
    }

    /**
     * Looks for the CEC message incorrectMessage sent to CEC device toDevice on the cec-client
     * communication channel and throws an CecClientWrapperException if it finds the line that
     * contains the message within the default timeout. If the CEC message is not found within the
     * timeout, function returns without error.
     */
    public void checkOutputDoesNotContainMessage(
            LogicalAddress toDevice, CecOperand incorrectMessage) throws CecClientWrapperException {
        checkOutputDoesNotContainMessage(toDevice, incorrectMessage, """", DEFAULT_TIMEOUT);
     }

    /**
     * Looks for the CEC message incorrectMessage along with the params sent to CEC device toDevice
     * on the cec-client communication channel and throws an CecClientWrapperException if it finds
     * the line that contains the message with its params within the default timeout. If the CEC
     * message is not found within the timeout, function returns without error.
     */
    public void checkOutputDoesNotContainMessage(
            LogicalAddress toDevice, CecOperand incorrectMessage, String params)
            throws CecClientWrapperException {
        checkOutputDoesNotContainMessage(toDevice, incorrectMessage, params, DEFAULT_TIMEOUT);
    }

    /**
     * Looks for the CEC message incorrectMessage sent to CEC device toDevice on the cec-client
     * communication channel and throws an CecClientWrapperException if it finds the line that
     * contains the message within timeoutMillis. If the CEC message is not found within the
     * timeout, function returns without error.
     */
    public void checkOutputDoesNotContainMessage(
            LogicalAddress toDevice, CecOperand incorrectMessage, long timeoutMillis)
            throws CecClientWrapperException {
        checkOutputDoesNotContainMessage(toDevice, incorrectMessage, """", timeoutMillis);
    }

    /**
     * Looks for the CEC message incorrectMessage along with the params sent to CEC device toDevice
     * on the cec-client communication channel and throws an CecClientWrapperException if it finds
     * the line that contains the message and params within timeoutMillis. If the CEC message is not
     * found within the timeout, function returns without error.
     */
    public void checkOutputDoesNotContainMessage(
            LogicalAddress toDevice, CecOperand incorrectMessage, String params, long timeoutMillis)
            throws CecClientWrapperException {
        checkCecClient();
        long startTime = System.currentTimeMillis();
        long endTime = startTime;
        Pattern pattern =
                Pattern.compile(
                        ""(.*>>)(.*?)""
                                + ""(""
                                + targetDevice
                                + toDevice
                                + ""):""
                                + ""(""
                                + incorrectMessage
                                + params
                                + "")(.*)"",
                        Pattern.CASE_INSENSITIVE);

        while ((endTime - startTime <= timeoutMillis)) {
            try {
                if (mInputConsole.ready()) {
                    String line = mInputConsole.readLine();
                    if (pattern.matcher(line).matches()) {
                        CLog.v(""Found "" + incorrectMessage.name() + "" in "" + line);
                        throw new CecClientWrapperException(
                                ErrorCodes.CecMessageFound,
                                incorrectMessage.name()
                                        + "" to ""
                                        + toDevice
                                        + "" with params ""
                                        + CecMessage.getParamsAsString(line));
                    }
                }
            } catch (IOException ioe) {
                throw new CecClientWrapperException(ErrorCodes.ReadConsole, ioe);
            }
            endTime = System.currentTimeMillis();
        }
     }

    /** Returns the device type that the cec-client has started as. */
    public LogicalAddress getSelfDevice() {
        return selfDevice;
    }

    /** Set the physical address of the cec-client instance */
    public void setPhysicalAddress(int newPhysicalAddress) throws CecClientWrapperException {
        String command =
                String.format(
                        ""pa %02d %02d"",
                        (newPhysicalAddress & 0xFF00) >> 8, newPhysicalAddress & 0xFF);
        sendConsoleMessage(command);
        physicalAddress = newPhysicalAddress;
    }

    /** Get the physical address of the cec-client instance, will return 0xFFFF if uninitialised */
    public int getPhysicalAddress() {
        return physicalAddress;
    }

    public void clearClientOutput() {
        mInputConsole = new BufferedReader(new InputStreamReader(mCecClient.getInputStream()));
    }

    /**
     * Kills the cec-client process that was created in init().
     */
    private void killCecProcess() {
        try {
            checkCecClient();
            sendConsoleMessage(CecClientMessage.QUIT_CLIENT.toString());
            mOutputConsole.close();
            mInputConsole.close();
            mCecClientInitialised = false;
            if (!mCecClient.waitFor(MILLISECONDS_TO_READY, TimeUnit.MILLISECONDS)) {
                /* Use a pkill cec-client if the cec-client process is not dead in spite of the
                 * quit above.
                 */
                List<String> commands = new ArrayList<>();
                Process killProcess;
                commands.add(""pkill"");
                commands.add(""cec-client"");
                killProcess = RunUtil.getDefault().runCmdInBackground(commands);
                killProcess.waitFor();
            }
        } catch (IOException | InterruptedException | CecClientWrapperException e) {
            /*
             * If cec-client is not running, do not throw a CecClientWrapperException, just return.
             */
            CLog.w(new CecClientWrapperException(ErrorCodes.CecClientStop, e));
        }
    }
}"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.widget.cts.ExpandableListViewBasicTest"	"testPreconditions"	"CtsWidgetTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/ExpandableListViewBasicTest.java"	""	"public void testPreconditions() {
        assertNotNull(mActivity);
        assertNotNull(mExpandableListView);
    }

    private int expandGroup(int numChildren, boolean atLeastOneChild) {
        final int groupPos = mActivity.findGroupWithNumChildren(numChildren, atLeastOneChild);

        assertTrue(""Could not find group to expand"", groupPos >= 0);
        assertFalse(""Group is already expanded"", mExpandableListView.isGroupExpanded(groupPos));

        // The following injects key events to emulate the sequence of expanding the group,
        // each waiting for a redraw pass to complete. Note that we can't inject key events on
        // the main thread, which is why we're passing null as the last parameter to the draw sync
        mListUtil.arrowScrollToSelectedPosition(groupPos);
        WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, mExpandableListView, null);
        CtsKeyEventUtil.sendKeys(mInstrumentation, mExpandableListView,
                KeyEvent.KEYCODE_DPAD_CENTER);
        WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, mExpandableListView, null);

        assertTrue(""Group did not expand"", mExpandableListView.isGroupExpanded(groupPos));

        return groupPos;
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.widget.cts.ExpandableListViewBasicTest"	"testCollapseGroup"	"CtsWidgetTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/ExpandableListViewBasicTest.java"	""	"public void testCollapseGroup() {
        final int groupPos = expandGroup(-1, true);

        CtsKeyEventUtil.sendKeys(mInstrumentation, mExpandableListView,
                KeyEvent.KEYCODE_DPAD_CENTER);
        WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, mExpandableListView, null);

        assertFalse(""Group did not collapse"", mExpandableListView.isGroupExpanded(groupPos));
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.widget.cts.ExpandableListViewBasicTest"	"testExpandedGroupMovement"	"CtsWidgetTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/ExpandableListViewBasicTest.java"	""	"public void testExpandedGroupMovement() throws Throwable {
        // Expand the first group
        mListUtil.arrowScrollToSelectedPosition(0);
        WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, mExpandableListView, null);
        CtsKeyEventUtil.sendKeys(mInstrumentation, mExpandableListView,
                KeyEvent.KEYCODE_DPAD_CENTER);
        WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, mExpandableListView, null);

        // Ensure it expanded
        assertTrue(""Group did not expand"", mExpandableListView.isGroupExpanded(0));

        // Insert a collapsed group in front of the one just expanded
        List<MyGroup> groups = mActivity.getGroups();
        MyGroup insertedGroup = new MyGroup(1);
        groups.add(0, insertedGroup);

        // Notify data change
        assertTrue(""Adapter is not an instance of the base adapter"",
                mAdapter instanceof BaseExpandableListAdapter);
        final BaseExpandableListAdapter adapter = (BaseExpandableListAdapter) mAdapter;

        WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, mExpandableListView,
                adapter::notifyDataSetChanged);

        // Make sure the right group is expanded
        assertTrue(""The expanded state didn't stay with the proper group"",
                mExpandableListView.isGroupExpanded(1));
        assertFalse(""The expanded state was given to the inserted group"",
                mExpandableListView.isGroupExpanded(0));
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"com.android.cts.appdataisolation.appa.AppATests"	"testOtherUserDirsNotAccessible"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/AppDataIsolationTestApp/AppA/src/com/android/cts/appdataisolation/appa/AppATests.java"	""	"public void testOtherUserDirsNotAccessible() throws Exception {
        final Bundle arguments = InstrumentationRegistry.getArguments();
        final int otherUserId = Integer.parseInt(arguments.getString(""other_user_id""));

        final String ceDataRoot = ""/data/user/"" + otherUserId;
        final String deDataRoot = ""/data/user_de/"" + otherUserId;
        final String profileRoot = ""/data/misc/profiles/cur/"" + otherUserId;

        // APPA (this app) is installed in this user but not the other one.
        // APPB is installed in this user and the other one.
        // NOT_INSTALLED_PKG isn't installed anywhere.
        // We must get the same answer for all of them, so we can't infer if any of them are or
        // are not installed in the other user.
        assertDirIsNotAccessible(ceDataRoot);
        assertDirIsNotAccessible(ceDataRoot + ""/"" + APPA_PKG);
        assertDirIsNotAccessible(ceDataRoot + ""/"" + APPB_PKG);
        assertDirIsNotAccessible(ceDataRoot + ""/"" + NOT_INSTALLED_PKG);

        assertDirIsNotAccessible(deDataRoot);
        assertDirIsNotAccessible(deDataRoot + ""/"" + APPA_PKG);
        assertDirIsNotAccessible(deDataRoot + ""/"" + APPB_PKG);
        assertDirIsNotAccessible(deDataRoot + ""/"" + NOT_INSTALLED_PKG);

        // If the vendor policy is pre-R then backward compatibility rules apply.
        if (isVendorPolicyNewerThanR()) {
            assertDirIsNotAccessible(profileRoot);
            assertDirIsNotAccessible(profileRoot + ""/"" + APPA_PKG);
            assertDirIsNotAccessible(profileRoot + ""/"" + APPB_PKG);
            assertDirIsNotAccessible(profileRoot + ""/"" + NOT_INSTALLED_PKG);
        }
    }

    private boolean isVendorPolicyNewerThanR() {
        if (SystemProperties.get(""ro.vndk.version"").equals(""S"")) {
            // Vendor build is S, but before the API level bump - good enough for us.
            return true;
        }
        return PropertyUtil.isVendorApiLevelNewerThan(Build.VERSION_CODES.R);
    }
}"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.media.cts.DecoderTest"	"testLowLatencyVp9At1280x720"	"CtsMediaTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/DecoderTest.java"	""	"public void testLowLatencyVp9At1280x720() throws Exception {
        testLowLatencyVideo(
                ""video_1280x720_webm_vp9_csd_309kbps_25fps_vorbis_stereo_128kbps_48000hz.webm"", 300,
                false /* useNdk */);
        testLowLatencyVideo(
                ""video_1280x720_webm_vp9_csd_309kbps_25fps_vorbis_stereo_128kbps_48000hz.webm"", 300,
                true /* useNdk */);
    }

    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.R)"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.media.cts.DecoderTest"	"testLowLatencyVp9At1920x1080"	"CtsMediaTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/DecoderTest.java"	""	"public void testLowLatencyVp9At1920x1080() throws Exception {
        testLowLatencyVideo(
                ""bbb_s2_1920x1080_webm_vp9_0p41_10mbps_60fps_vorbis_6ch_384kbps_22050hz.webm"", 300,
                false /* useNdk */);
        testLowLatencyVideo(
                ""bbb_s2_1920x1080_webm_vp9_0p41_10mbps_60fps_vorbis_6ch_384kbps_22050hz.webm"", 300,
                true /* useNdk */);
    }

    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.R)"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.media.cts.DecoderTest"	"testLowLatencyVp9At3840x2160"	"CtsMediaTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/DecoderTest.java"	""	"public void testLowLatencyVp9At3840x2160() throws Exception {
        testLowLatencyVideo(
                ""bbb_s2_3840x2160_webm_vp9_0p51_20mbps_60fps_vorbis_6ch_384kbps_32000hz.webm"", 300,
                false /* useNdk */);
        testLowLatencyVideo(
                ""bbb_s2_3840x2160_webm_vp9_0p51_20mbps_60fps_vorbis_6ch_384kbps_32000hz.webm"", 300,
                true /* useNdk */);
    }

    @NonMediaMainlineTest"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.media.cts.DecoderTest"	"testLowLatencyAVCAt1280x720"	"CtsMediaTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/DecoderTest.java"	""	"public void testLowLatencyAVCAt1280x720() throws Exception {
        testLowLatencyVideo(
                ""video_1280x720_mp4_h264_1000kbps_25fps_aac_stereo_128kbps_44100hz.mp4"", 300,
                false /* useNdk */);
        testLowLatencyVideo(
                ""video_1280x720_mp4_h264_1000kbps_25fps_aac_stereo_128kbps_44100hz.mp4"", 300,
                true /* useNdk */);
    }

    @NonMediaMainlineTest"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.media.cts.DecoderTest"	"testLowLatencyHEVCAt480x360"	"CtsMediaTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/DecoderTest.java"	""	"public void testLowLatencyHEVCAt480x360() throws Exception {
        testLowLatencyVideo(
                ""video_480x360_mp4_hevc_650kbps_30fps_aac_stereo_128kbps_48000hz.mp4"", 300,
                false /* useNdk */);
        testLowLatencyVideo(
                ""video_480x360_mp4_hevc_650kbps_30fps_aac_stereo_128kbps_48000hz.mp4"", 300,
                true /* useNdk */);
    }

    private void testLowLatencyVideo(String testVideo, int frameCount, boolean useNdk)
            throws Exception {
        AssetFileDescriptor fd = getAssetFileDescriptorFor(testVideo);
        MediaExtractor extractor = new MediaExtractor();
        extractor.setDataSource(fd.getFileDescriptor(), fd.getStartOffset(), fd.getLength());
        fd.close();

        MediaFormat format = null;
        int trackIndex = -1;
        for (int i = 0; i < extractor.getTrackCount(); i++) {
            format = extractor.getTrackFormat(i);
            if (format.getString(MediaFormat.KEY_MIME).startsWith(""video/"")) {
                trackIndex = i;
                break;
            }
        }

        assertTrue(""No video track was found"", trackIndex >= 0);

        extractor.selectTrack(trackIndex);
        format.setFeatureEnabled(MediaCodecInfo.CodecCapabilities.FEATURE_LowLatency,
                true /* enable */);

        MediaCodecList mcl = new MediaCodecList(MediaCodecList.ALL_CODECS);
        String decoderName = mcl.findDecoderForFormat(format);
        if (decoderName == null) {
            MediaUtils.skipTest(""no low latency decoder for "" + format);
            return;
        }
        String entry = (useNdk ? ""NDK"" : ""SDK"");
        Log.v(TAG, ""found "" + entry + "" decoder "" + decoderName + "" for format: "" + format);

        Surface surface = getActivity().getSurfaceHolder().getSurface();
        MediaCodecWrapper decoder = null;
        if (useNdk) {
            decoder = new NdkMediaCodec(decoderName);
        } else {
            decoder = new SdkMediaCodec(MediaCodec.createByCodecName(decoderName));
        }
        format.removeFeature(MediaCodecInfo.CodecCapabilities.FEATURE_LowLatency);
        format.setInteger(MediaFormat.KEY_LOW_LATENCY, 1);
        decoder.configure(format, 0 /* flags */, surface);
        decoder.start();

        if (!useNdk) {
            decoder.getInputBuffers();
        }
        ByteBuffer[] codecOutputBuffers = decoder.getOutputBuffers();
        String decoderOutputFormatString = null;

        // start decoding
        final long kTimeOutUs = 1000000;  // 1 second
        MediaCodec.BufferInfo info = new MediaCodec.BufferInfo();
        int bufferCounter = 0;
        long[] latencyMs = new long[frameCount];
        boolean waitingForOutput = false;
        long startTimeMs = System.currentTimeMillis();
        while (bufferCounter < frameCount) {
            if (!waitingForOutput) {
                int inputBufferId = decoder.dequeueInputBuffer(kTimeOutUs);
                if (inputBufferId < 0) {
                    Log.v(TAG, ""no input buffer"");
                    break;
                }

                ByteBuffer dstBuf = decoder.getInputBuffer(inputBufferId);

                int sampleSize = extractor.readSampleData(dstBuf, 0 /* offset */);
                long presentationTimeUs = 0;
                if (sampleSize < 0) {
                    Log.v(TAG, ""had input EOS, early termination at frame "" + bufferCounter);
                    break;
                } else {
                    presentationTimeUs = extractor.getSampleTime();
                }

                startTimeMs = System.currentTimeMillis();
                decoder.queueInputBuffer(
                        inputBufferId,
                        0 /* offset */,
                        sampleSize,
                        presentationTimeUs,
                        0 /* flags */);

                extractor.advance();
                waitingForOutput = true;
            }

            int outputBufferId = decoder.dequeueOutputBuffer(info, kTimeOutUs);

            if (outputBufferId >= 0) {
                waitingForOutput = false;
                //Log.d(TAG, ""got output, size "" + info.size + "", time "" + info.presentationTimeUs);
                latencyMs[bufferCounter++] = System.currentTimeMillis() - startTimeMs;
                // TODO: render the frame and find the rendering time to calculate the total delay
                decoder.releaseOutputBuffer(outputBufferId, false /* render */);
            } else if (outputBufferId == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {
                codecOutputBuffers = decoder.getOutputBuffers();
                Log.d(TAG, ""output buffers have changed."");
            } else if (outputBufferId == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {
                decoderOutputFormatString = decoder.getOutputFormatString();
                Log.d(TAG, ""output format has changed to "" + decoderOutputFormatString);
            } else {
                fail(""No output buffer returned without frame delay, status "" + outputBufferId);
            }
        }

        assertTrue(""No INFO_OUTPUT_FORMAT_CHANGED from decoder"", decoderOutputFormatString != null);

        long latencyMean = 0;
        long latencyMax = 0;
        int maxIndex = 0;
        for (int i = 0; i < bufferCounter; ++i) {
            latencyMean += latencyMs[i];
            if (latencyMs[i] > latencyMax) {
                latencyMax = latencyMs[i];
                maxIndex = i;
            }
        }
        if (bufferCounter > 0) {
            latencyMean /= bufferCounter;
        }
        Log.d(TAG, entry + "" latency average "" + latencyMean + "" ms, max "" + latencyMax +
                "" ms at frame "" + maxIndex);

        DeviceReportLog log = new DeviceReportLog(REPORT_LOG_NAME, ""video_decoder_latency"");
        String mime = format.getString(MediaFormat.KEY_MIME);
        int width = format.getInteger(MediaFormat.KEY_WIDTH);
        int height = format.getInteger(MediaFormat.KEY_HEIGHT);
        log.addValue(""codec_name"", decoderName, ResultType.NEUTRAL, ResultUnit.NONE);
        log.addValue(""mime_type"", mime, ResultType.NEUTRAL, ResultUnit.NONE);
        log.addValue(""width"", width, ResultType.NEUTRAL, ResultUnit.NONE);
        log.addValue(""height"", height, ResultType.NEUTRAL, ResultUnit.NONE);
        log.addValue(""video_res"", testVideo, ResultType.NEUTRAL, ResultUnit.NONE);
        log.addValue(""decode_to"", surface == null ? ""buffer"" : ""surface"",
                ResultType.NEUTRAL, ResultUnit.NONE);

        log.addValue(""average_latency"", latencyMean, ResultType.LOWER_BETTER, ResultUnit.MS);
        log.addValue(""max_latency"", latencyMax, ResultType.LOWER_BETTER, ResultUnit.MS);

        log.submit(getInstrumentation());

        decoder.stop();
        decoder.release();
        extractor.release();
    }
}"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.autofillservice.cts.dropdown.LoginActivityTest"	"testUiShowOnChangeAfterAutofill"	"CtsAutoFillServiceTestCases"	"/home/gpoor/cts-12-source/cts/tests/autofillservice/src/android/autofillservice/cts/dropdown/LoginActivityTest.java"	""	"public void testUiShowOnChangeAfterAutofill() throws Exception {
        // Set service.
        enableService();

        // Set expectations.
        sReplier.addResponse(new CannedDataset.Builder()
                .setField(ID_USERNAME, ""dude"", createPresentation(""dude""))
                .setField(ID_PASSWORD, ""sweet"", createPresentation(""sweet""))
                .build());
        mActivity.expectAutoFill(""dude"", ""sweet"");

        // Trigger auto-fill.
        requestFocusOnUsername();
        mUiBot.assertDatasets(""dude"");
        sReplier.getNextFillRequest();
        mUiBot.selectDataset(""dude"");

        // Check the results.
        mActivity.assertAutoFilled();
        mUiBot.assertNoDatasets();

        // Delete a character.
        sendKeyEvent(""KEYCODE_DEL"");
        assertThat(mUiBot.getTextByRelativeId(ID_USERNAME)).isEqualTo(""dud"");

        mActivity.expectAutoFill(""dude"", ""sweet"");

        // Check autofill UI show.
        final UiObject2 datasetPicker = mUiBot.assertDatasets(""dude"");

        // Autofill again.
        mUiBot.selectDataset(datasetPicker, ""dude"");

        // Check the results.
        mActivity.assertAutoFilled();
        mUiBot.assertNoDatasets();
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.widget.cts.EditTextTest"	"testEnterKey"	"CtsWidgetTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/EditTextTest.java"	""	"public void testEnterKey() throws Throwable {
        mActivityRule.runOnUiThread(() -> {
            mEditText1.setSingleLine(true);
            mEditText1.requestFocus();
        });

        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mEditText1, KeyEvent.KEYCODE_ENTER);
        mInstrumentation.waitForIdleSync();
        assertTrue(mEditText2.hasFocus());

        mActivityRule.runOnUiThread(() -> mEditText1.requestFocus());
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mEditText1, KeyEvent.KEYCODE_NUMPAD_ENTER);
        assertTrue(mEditText2.hasFocus());
    }

    private static final int FRAMEWORK_MAX_LENGTH_FOR_SINGLE_LINE_EDIT_TEXT = 5000;

    @UiThreadTest"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.os.cts.BuildTest"	"testCpuAbi_valuesMatchPermitted"	""	"/home/gpoor/cts-12-source/cts/tests/tests/os/src/android/os/cts/BuildTest.java"	""	"public void testCpuAbi_valuesMatchPermitted() throws Exception {
        // The permitted ABIs are listed in https://developer.android.com/ndk/guides/abis.
        Set<String> just32 = new HashSet<>(Arrays.asList(""armeabi"", ""armeabi-v7a"", ""x86""));
        Set<String> just64 = new HashSet<>(Arrays.asList(""x86_64"", ""arm64-v8a""));
        Set<String> all = new HashSet<>();
        all.addAll(just32);
        all.addAll(just64);
        Set<String> allAndEmpty = new HashSet<>(all);
        allAndEmpty.add("""");

        // The cpu abi fields on the device must match the permitted values.
        assertValueIsAllowed(all, Build.CPU_ABI);
        // CPU_ABI2 will be empty when the device does not support a secondary CPU architecture.
        assertValueIsAllowed(allAndEmpty, Build.CPU_ABI2);

        // The supported abi fields on the device must match the permitted values.
        assertValuesAreAllowed(all, Build.SUPPORTED_ABIS);
        assertValuesAreAllowed(just32, Build.SUPPORTED_32_BIT_ABIS);
        assertValuesAreAllowed(just64, Build.SUPPORTED_64_BIT_ABIS);
    }

    private void runTestCpuAbiCommon() throws Exception {
        // The build property must match Build.SUPPORTED_ABIS exactly.
        final String[] abiListProperty = getStringList(RO_PRODUCT_CPU_ABILIST);
        assertEquals(Arrays.toString(abiListProperty), Arrays.toString(Build.SUPPORTED_ABIS));

        List<String> abiList = Arrays.asList(abiListProperty);

        // Every supported 32 bit ABI must be present in Build.SUPPORTED_ABIS.
        for (String abi : Build.SUPPORTED_32_BIT_ABIS) {
            assertTrue(abiList.contains(abi));
            assertFalse(Build.is64BitAbi(abi));
        }

        // Every supported 64 bit ABI must be present in Build.SUPPORTED_ABIS.
        for (String abi : Build.SUPPORTED_64_BIT_ABIS) {
            assertTrue(abiList.contains(abi));
            assertTrue(Build.is64BitAbi(abi));
        }

        // Build.CPU_ABI and Build.CPU_ABI2 must be present in Build.SUPPORTED_ABIS.
        assertTrue(abiList.contains(Build.CPU_ABI));
        if (!Build.CPU_ABI2.isEmpty()) {
            assertTrue(abiList.contains(Build.CPU_ABI2));
        }
    }

    private void runTestCpuAbi32() throws Exception {
        List<String> abi32 = Arrays.asList(Build.SUPPORTED_32_BIT_ABIS);
        assertTrue(abi32.contains(Build.CPU_ABI));

        if (!Build.CPU_ABI2.isEmpty()) {
            assertTrue(abi32.contains(Build.CPU_ABI2));
        }
    }

    private void runTestCpuAbi64() {
        List<String> abi64 = Arrays.asList(Build.SUPPORTED_64_BIT_ABIS);
        assertTrue(abi64.contains(Build.CPU_ABI));

        if (!Build.CPU_ABI2.isEmpty()) {
            assertTrue(abi64.contains(Build.CPU_ABI2));
        }
    }

    private String[] getStringList(String property) throws IOException {
        String value = getProperty(property);
        if (value.isEmpty()) {
            return new String[0];
        } else {
            return value.split("","");
        }
    }

    /**
     * @param property name passed to getprop
     */
    static String getProperty(String property)
            throws IOException {
        Process process = new ProcessBuilder(""getprop"", property).start();
        Scanner scanner = null;
        String line = """";
        try {
            scanner = new Scanner(process.getInputStream());
            line = scanner.nextLine();
        } finally {
            if (scanner != null) {
                scanner.close();
            }
        }
        return line;
    }
    /**
     * @param message shown when the test fails
     * @param property name passed to getprop
     * @param expected value of the property
     */
    private void assertProperty(String message, String property, String expected)
            throws IOException {
        Process process = new ProcessBuilder(""getprop"", property).start();
        Scanner scanner = null;
        try {
            scanner = new Scanner(process.getInputStream());
            String line = scanner.nextLine();
            assertEquals(message + "" Value found: "" + line , expected, line);
            assertFalse(scanner.hasNext());
        } finally {
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Check that a property is not set by scanning through the list of properties returned by
     * getprop, since calling getprop on an property set to """" and on a non-existent property
     * yields the same output.
     *
     * @param message shown when the test fails
     * @param property name passed to getprop
     */
    private void assertNoPropertySet(String message, String property) throws IOException {
        Process process = new ProcessBuilder(""getprop"").start();
        Scanner scanner = null;
        try {
            scanner = new Scanner(process.getInputStream());
            while (scanner.hasNextLine()) {
                String line = scanner.nextLine();
                assertFalse(message + ""Property found: "" + line,
                        line.startsWith(""["" + property + ""]""));
            }
        } finally {
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    private static void assertValueIsAllowed(Set<String> allowedValues, String actualValue) {
        assertTrue(""Expected one of "" + allowedValues + "", but was: '"" + actualValue + ""'"",
                allowedValues.contains(actualValue));
    }

    private static void assertValuesAreAllowed(Set<String> allowedValues, String[] actualValues) {
        for (String actualValue : actualValues) {
            assertValueIsAllowed(allowedValues, actualValue);
        }
    }

    private static final Pattern BOARD_PATTERN =
        Pattern.compile(""^([0-9A-Za-z._-]+)$"");
    private static final Pattern BRAND_PATTERN =
        Pattern.compile(""^([0-9A-Za-z._-]+)$"");
    private static final Pattern DEVICE_PATTERN =
        Pattern.compile(""^([0-9A-Za-z._-]+)$"");
    private static final Pattern ID_PATTERN =
        Pattern.compile(""^([0-9A-Za-z._-]+)$"");
    private static final Pattern HARDWARE_PATTERN =
        Pattern.compile(""^([0-9A-Za-z.,_-]+)$"");
    private static final Pattern PRODUCT_PATTERN =
        Pattern.compile(""^([0-9A-Za-z._-]+)$"");
    private static final Pattern SOC_MANUFACTURER_PATTERN =
        Pattern.compile(""^([0-9A-Za-z ]+)$"");
    private static final Pattern SOC_MODEL_PATTERN =
        Pattern.compile(""^([0-9A-Za-z ._/+-]+)$"");
    private static final Pattern SERIAL_NUMBER_PATTERN =
        Pattern.compile(""^([0-9A-Za-z]{6,20})$"");
    private static final Pattern SKU_PATTERN =
        Pattern.compile(""^([0-9A-Za-z.,_-]+)$"");
    private static final Pattern TAGS_PATTERN =
        Pattern.compile(""^([0-9A-Za-z.,_-]+)$"");
    private static final Pattern TYPE_PATTERN =
        Pattern.compile(""^([0-9A-Za-z._-]+)$"");

    /** Tests that check for valid values of constants in Build. */"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.os.cts.BuildTest"	"testIsSecureUserBuild"	""	"/home/gpoor/cts-12-source/cts/tests/tests/os/src/android/os/cts/BuildTest.java"	""	"public void testIsSecureUserBuild() throws IOException {
        assertEquals(""Must be a user build"", ""user"", Build.TYPE);
        assertProperty(""Must be a non-debuggable build"", RO_DEBUGGABLE, ""0"");
        assertFalse(""Must be a non-debuggable build"", Build.isDebuggable());
        assertProperty(""Must be a secure build"", RO_SECURE, ""1"");
    }

    private void assertNotEmpty(String value) {
        assertNotNull(value);
        assertFalse(value.isEmpty());
    }

    private int getVendorPartitionVersion() {
        String version = SystemProperties.get(""ro.vndk.version"");
        try {
            return Integer.parseInt(version);
        } catch (NumberFormatException ignore) {
            return Build.VERSION_CODES.CUR_DEVELOPMENT;
        }
    }
}"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.server.wm.LayoutTests"	"testChangingFocusableFlag"	"CtsWindowManagerDeviceTestCases"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/LayoutTests.java"	""	"public void testChangingFocusableFlag() throws Exception {
        final View[] view = new View[1];
        final LayoutParams attrs = new LayoutParams(TYPE_APPLICATION_PANEL, FLAG_NOT_FOCUSABLE);
        final boolean[] childWindowHasFocus = { false };
        final boolean[] childWindowGotKeyEvent = { false };
        final TestActivity activity = startActivity(TestActivity.class);

        // Add a not-focusable window.
        getInstrumentation().runOnMainSync(() -> {
            view[0] = new View(activity) {
                public void onWindowFocusChanged(boolean hasWindowFocus) {
                    super.onWindowFocusChanged(hasWindowFocus);
                    childWindowHasFocus[0] = hasWindowFocus;
                    synchronized (activity) {
                        activity.notify();
                    }
                }

                public boolean onKeyDown(int keyCode, KeyEvent event) {
                    synchronized (activity) {
                        childWindowGotKeyEvent[0] = true;
                    }
                    return super.onKeyDown(keyCode, event);
                }
            };
            activity.addWindow(view[0], attrs);
        });
        getInstrumentation().waitForIdleSync();

        // Make the window focusable.
        getInstrumentation().runOnMainSync(() -> {
            attrs.flags &= ~FLAG_NOT_FOCUSABLE;
            activity.getWindowManager().updateViewLayout(view[0], attrs);
        });
        synchronized (activity) {
            activity.wait(TIMEOUT_WINDOW_FOCUS_CHANGED);
        }

        // The window must have focus.
        assertTrue(""Child window must have focus."", childWindowHasFocus[0]);

        // Ensure the window can receive keys.
        PollingCheck.check(""Child window must get key event."", TIMEOUT_RECEIVE_KEY, () -> {
            getInstrumentation().sendKeyDownUpSync(KeyEvent.KEYCODE_0);
            synchronized (activity) {
                return childWindowGotKeyEvent[0];
            }
        });
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.widget.cts.ListPopupWindowTest"	"testNoDefaultDismissalWithBackButton"	"CtsWidgetTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/ListPopupWindowTest.java"	""	"public void testNoDefaultDismissalWithBackButton() {
        mPopupWindowBuilder = new Builder().withDismissListener();
        WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, mActivity.getWindow().getDecorView(),
                mPopupWindowBuilder::show);

        // Send BACK key event. As we don't have any custom code that dismisses ListPopupWindow,
        // and ListPopupWindow doesn't track that system-level key event on its own, ListPopupWindow
        // should stay visible
        mInstrumentation.sendKeyDownUpSync(KeyEvent.KEYCODE_BACK);
        verify(mPopupWindowBuilder.mOnDismissListener, never()).onDismiss();
        assertTrue(mPopupWindow.isShowing());
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.widget.cts.ListPopupWindowTest"	"testCustomDismissalWithBackButton"	"CtsWidgetTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/ListPopupWindowTest.java"	""	"public void testCustomDismissalWithBackButton() {
        WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, mActivity.getWindow().getDecorView(),
                () -> {
                    mPopupWindowBuilder = new Builder().withAnchor(R.id.anchor_upper_left)
                            .withDismissListener();
                    mPopupWindowBuilder.show();
                });

        // ""Point"" our custom extension of EditText to our ListPopupWindow
        final MockViewForListPopupWindow anchor =
                (MockViewForListPopupWindow) mPopupWindow.getAnchorView();
        anchor.wireTo(mPopupWindow);
        // Request focus on our EditText
        WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, mActivity.getWindow().getDecorView(),
                anchor::requestFocus);
        assertTrue(anchor.isFocused());

        // Send BACK key event. As our custom extension of EditText calls
        // ListPopupWindow.onKeyPreIme, the end result should be the dismissal of the
        // ListPopupWindow
        mInstrumentation.sendKeyDownUpSync(KeyEvent.KEYCODE_BACK);
        verify(mPopupWindowBuilder.mOnDismissListener, times(1)).onDismiss();
        assertFalse(mPopupWindow.isShowing());
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.widget.cts.ListPopupWindowTest"	"testListSelectionWithDPad"	"CtsWidgetTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/ListPopupWindowTest.java"	""	"public void testListSelectionWithDPad() {
        mPopupWindowBuilder = new Builder().withAnchor(R.id.anchor_upper_left)
                .withDismissListener().withItemSelectedListener();
        WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, mActivity.getWindow().getDecorView(),
                mPopupWindowBuilder::show);

        final View root = mPopupWindow.getListView().getRootView();

        // ""Point"" our custom extension of EditText to our ListPopupWindow
        final MockViewForListPopupWindow anchor =
                (MockViewForListPopupWindow) mPopupWindow.getAnchorView();
        anchor.wireTo(mPopupWindow);
        // Request focus on our EditText
        WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, mActivity.getWindow().getDecorView(),
                anchor::requestFocus);
        assertTrue(anchor.isFocused());

        // Select entry #1 in the popup list
        final ListView listView = mPopupWindow.getListView();
        WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, listView,
                () -> mPopupWindow.setSelection(1));
        PollingCheck.waitFor(()-> mPopupWindow.getSelectedItemPosition() == 1);
        verify(mPopupWindowBuilder.mOnItemSelectedListener, times(1)).onItemSelected(
                any(AdapterView.class), any(View.class), eq(1), eq(1L));

        // Send DPAD_DOWN key event. As our custom extension of EditText calls
        // ListPopupWindow.onKeyDown and onKeyUp, the end result should be transfer of selection
        // down one row
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, listView, KeyEvent.KEYCODE_DPAD_DOWN);
        WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, root, null);

        // At this point we expect that item #2 was selected
        verify(mPopupWindowBuilder.mOnItemSelectedListener, times(1)).onItemSelected(
                any(AdapterView.class), any(View.class), eq(2), eq(2L));

        // Send a DPAD_UP key event. As our custom extension of EditText calls
        // ListPopupWindow.onKeyDown and onKeyUp, the end result should be transfer of selection
        // up one row
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, listView, KeyEvent.KEYCODE_DPAD_UP);
        WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, root, null);

        // At this point we expect that item #1 was selected
        verify(mPopupWindowBuilder.mOnItemSelectedListener, times(2)).onItemSelected(
                any(AdapterView.class), any(View.class), eq(1), eq(1L));

        // Send one more DPAD_UP key event. As our custom extension of EditText calls
        // ListPopupWindow.onKeyDown and onKeyUp, the end result should be transfer of selection
        // up one more row
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, listView, KeyEvent.KEYCODE_DPAD_UP);
        WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, root, null);

        // At this point we expect that item #0 was selected
        verify(mPopupWindowBuilder.mOnItemSelectedListener, times(1)).onItemSelected(
                any(AdapterView.class), any(View.class), eq(0), eq(0L));

        // Send ENTER key event. As our custom extension of EditText calls
        // ListPopupWindow.onKeyDown and onKeyUp, the end result should be dismissal of
        // the popup window
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation,listView, KeyEvent.KEYCODE_ENTER);
        WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, mActivity.getWindow().getDecorView(),
                null);

        verify(mPopupWindowBuilder.mOnDismissListener, times(1)).onDismiss();
        assertFalse(mPopupWindow.isShowing());

        verifyNoMoreInteractions(mPopupWindowBuilder.mOnItemSelectedListener);
        verifyNoMoreInteractions(mPopupWindowBuilder.mOnDismissListener);
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.widget.cts.ListPopupWindowTest"	"testListSelectionWithDPadEnter"	"CtsWidgetTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/ListPopupWindowTest.java"	""	"public void testListSelectionWithDPadEnter() {
        mPopupWindowBuilder = new Builder().withAnchor(R.id.anchor_upper_left)
                .withDismissListener().withItemSelectedListener().withItemClickListener();
        WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, mActivity.getWindow().getDecorView(),
                mPopupWindowBuilder::show);

        final View root = mPopupWindow.getListView().getRootView();

        // ""Point"" our custom extension of EditText to our ListPopupWindow
        final MockViewForListPopupWindow anchor =
                (MockViewForListPopupWindow) mPopupWindow.getAnchorView();
        anchor.wireTo(mPopupWindow);
        // Request focus on our EditText
        WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, mActivity.getWindow().getDecorView(),
                anchor::requestFocus);
        assertTrue(anchor.isFocused());

        // Select entry #1 in the popup list
        final ListView listView = mPopupWindow.getListView();
        WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, listView,
                () -> mPopupWindow.setSelection(1));
        PollingCheck.waitFor(()-> mPopupWindow.getSelectedItemPosition() == 1);
        verify(mPopupWindowBuilder.mOnItemSelectedListener, times(1)).onItemSelected(
                any(AdapterView.class), any(View.class), eq(1), eq(1L));

        // Send DPAD_DOWN key event. As our custom extension of EditText calls
        // ListPopupWindow.onKeyDown and onKeyUp, the end result should be transfer of selection
        // down one row
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, listView, KeyEvent.KEYCODE_DPAD_DOWN);
        WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, root, null);

        // At this point we expect that item #2 was selected
        verify(mPopupWindowBuilder.mOnItemSelectedListener, times(1)).onItemSelected(
                any(AdapterView.class), any(View.class), eq(2), eq(2L));

        // Send a DPAD_UP key event. As our custom extension of EditText calls
        // ListPopupWindow.onKeyDown and onKeyUp, the end result should be transfer of selection
        // up one row
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, listView, KeyEvent.KEYCODE_DPAD_UP);
        WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, root, null);

        // At this point we expect that item #1 was selected
        verify(mPopupWindowBuilder.mOnItemSelectedListener, times(2)).onItemSelected(
                any(AdapterView.class), any(View.class), eq(1), eq(1L));

        // Send one more DPAD_UP key event. As our custom extension of EditText calls
        // ListPopupWindow.onKeyDown and onKeyUp, the end result should be transfer of selection
        // up one more row
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, listView, KeyEvent.KEYCODE_DPAD_UP);
        WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, root, null);

        // At this point we expect that item #0 was selected
        verify(mPopupWindowBuilder.mOnItemSelectedListener, times(1)).onItemSelected(
                any(AdapterView.class), any(View.class), eq(0), eq(0L));

        // Send NUMPAD_ENTER key event. As our custom extension of EditText calls
        // ListPopupWindow.onKeyDown and onKeyUp, the end result should be item click and dismissal
        // of the popup window
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, listView, KeyEvent.KEYCODE_NUMPAD_ENTER);
        WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, mActivity.getWindow().getDecorView(),
                null);
        verify(mPopupWindowBuilder.mOnItemClickListener, times(1)).onItemClick(
                any(AdapterView.class), any(View.class), eq(0), eq(0L));
        verify(mPopupWindowBuilder.mOnDismissListener, times(1)).onDismiss();
        assertFalse(mPopupWindow.isShowing());

        verifyNoMoreInteractions(mPopupWindowBuilder.mOnItemSelectedListener);
        verifyNoMoreInteractions(mPopupWindowBuilder.mOnDismissListener);
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.mediav2.cts.MuxerTest"	"testSimpleMuxNative"	"CtsMediaV2TestCases"	"/home/gpoor/cts-12-source/cts/tests/media/src/android/mediav2/cts/MuxerTest.java"	""	"public void testSimpleMuxNative() {
            Assume.assumeTrue(""TODO(b/146421018)"",
                    !mMime.equals(MediaFormat.MIMETYPE_AUDIO_OPUS));
            Assume.assumeTrue(""TODO(b/146923287)"",
                    !mMime.equals(MediaFormat.MIMETYPE_AUDIO_VORBIS));
            assertTrue(nativeTestSimpleMux(mInpPath, mOutPath, mMime, selector));
        }

        /* Does MediaMuxer throw IllegalStateException on missing codec specific data when required.
         * Check if relevant exception is thrown for AAC, AVC, HEVC, and MPEG4
         * codecs that require CSD in MediaMuxer.OutputFormat.MUXER_OUTPUT_MPEG_4.
         * TODO(b/156767190): Need to evaluate what all codecs need CSD and also what all formats
         * can contain these codecs, and add test cases accordingly.
         * TODO(b/156767190): Add similar tests in the native side/NDK as well.
         * TODO(b/156767190): Make a separate class, like TestNoCSDMux, instead of being part of
         * TestSimpleMux?
         */"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.binder.cts.JavaClientTest"	"testRepeatStringNullableLater"	"CtsNdkBinderTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/binder_ndk/src/android/binder/cts/JavaClientTest.java"	""	"public void testRepeatStringNullableLater() throws RemoteException {
        // see notes in native NdkBinderTest_Aidl RepeatStringNullableLater
        boolean handlesNull = !mShouldBeOld || mExpectedName == ""JAVA"";
        ICompatTest compatTest = ICompatTest.Stub.asInterface(mInterface.getICompatTest());

        try {
            assertEquals(null, compatTest.RepeatStringNullableLater(null));
            assertTrue(""should reach here if null is handled"", handlesNull);
        } catch (NullPointerException e) {
            assertFalse(""should reach here if null isn't handled"", handlesNull);
        }
        assertEquals("""", compatTest.RepeatStringNullableLater(""""));
        assertEquals(""a"", compatTest.RepeatStringNullableLater(""a""));
        assertEquals(""foo"", compatTest.RepeatStringNullableLater(""foo""));
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"com.android.cts.mockime.MockIme"	"shouldDispatchToMainThread"	""	"/home/gpoor/cts-12-source/cts/tests/inputmethod/mockime/src/com/android/cts/mockime/MockIme.java"	""	"public void test/*
 *.
 */

package com.android.cts.mockime;

import static android.view.ViewGroup.LayoutParams.MATCH_PARENT;
import static android.view.ViewGroup.LayoutParams.WRAP_CONTENT;
import static android.view.WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS;

import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageManager;
import android.content.res.Configuration;
import android.graphics.Bitmap;
import android.inputmethodservice.InputMethodService;
import android.os.Build;
import android.os.Bundle;
import android.os.Handler;
import android.os.HandlerThread;
import android.os.IBinder;
import android.os.Looper;
import android.os.Process;
import android.os.ResultReceiver;
import android.os.StrictMode;
import android.os.SystemClock;
import android.text.TextUtils;
import android.util.Log;
import android.util.Size;
import android.util.TypedValue;
import android.view.Display;
import android.view.GestureDetector;
import android.view.Gravity;
import android.view.KeyEvent;
import android.view.View;
import android.view.ViewConfiguration;
import android.view.Window;
import android.view.WindowInsets;
import android.view.WindowManager;
import android.view.inputmethod.CompletionInfo;
import android.view.inputmethod.CorrectionInfo;
import android.view.inputmethod.CursorAnchorInfo;
import android.view.inputmethod.EditorInfo;
import android.view.inputmethod.ExtractedTextRequest;
import android.view.inputmethod.InlineSuggestion;
import android.view.inputmethod.InlineSuggestionsRequest;
import android.view.inputmethod.InlineSuggestionsResponse;
import android.view.inputmethod.InputBinding;
import android.view.inputmethod.InputConnection;
import android.view.inputmethod.InputContentInfo;
import android.view.inputmethod.InputMethod;
import android.widget.FrameLayout;
import android.widget.HorizontalScrollView;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.TextView;
import android.widget.inline.InlinePresentationSpec;

import androidx.annotation.AnyThread;
import androidx.annotation.CallSuper;
import androidx.annotation.MainThread;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.annotation.WorkerThread;
import androidx.autofill.inline.UiVersions;
import androidx.autofill.inline.UiVersions.StylesBuilder;
import androidx.autofill.inline.v1.InlineSuggestionUi;

import java.util.ArrayList;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.BooleanSupplier;
import java.util.function.Consumer;
import java.util.function.Supplier;

/**
 * Mock IME for end-to-end tests.
 */
public final class MockIme extends InputMethodService {

    private static final String TAG = ""MockIme"";

    private static final String PACKAGE_NAME = ""com.android.cts.mockime"";

    static ComponentName getComponentName() {
        return new ComponentName(PACKAGE_NAME, MockIme.class.getName());
    }

    static String getImeId() {
        return getComponentName().flattenToShortString();
    }

    static String getCommandActionName(@NonNull String eventActionName) {
        return eventActionName + "".command"";
    }

    private final HandlerThread mHandlerThread = new HandlerThread(""CommandReceiver"");

    private final Handler mMainHandler = new Handler();

    private static final class CommandReceiver extends BroadcastReceiver {
        @NonNull
        private final String mActionName;
        @NonNull
        private final Consumer<ImeCommand> mOnReceiveCommand;

        CommandReceiver(@NonNull String actionName,
                @NonNull Consumer<ImeCommand> onReceiveCommand) {
            mActionName = actionName;
            mOnReceiveCommand = onReceiveCommand;
        }

        @Override
        public void onReceive(Context context, Intent intent) {
            if (TextUtils.equals(mActionName, intent.getAction())) {
                mOnReceiveCommand.accept(ImeCommand.fromBundle(intent.getExtras()));
            }
        }
    }

    @Nullable
    private InputConnection mMemorizedInputConnection = null;

    @Nullable
    @MainThread
    private InputConnection getMemorizedOrCurrentInputConnection() {
        return mMemorizedInputConnection != null
                ? mMemorizedInputConnection : getCurrentInputConnection();
    }

    @WorkerThread
    private void onReceiveCommand(@NonNull ImeCommand command) {
        getTracer().onReceiveCommand(command, () -> {
            if (command.shouldDispatchToMainThread()) {
                mMainHandler.post(() -> onHandleCommand(command));
            } else {
                onHandleCommand(command);
            }
        });
    }

    @AnyThread
    private void onHandleCommand(@NonNull ImeCommand command) {
        getTracer().onHandleCommand(command, () -> {
            if (command.shouldDispatchToMainThread()) {
                if (Looper.myLooper() != Looper.getMainLooper()) {
                    throw new IllegalStateException(""command "" + command
                            + "" should be handled on the main thread"");
                }
                // The context which created from InputMethodService#createXXXContext must behave
                // like an UI context, which can obtain a display, a window manager,
                // a view configuration and a gesture detector instance without strict mode
                // violation.
                final Configuration testConfig = new Configuration();
                testConfig.setToDefaults();
                final Context configContext = createConfigurationContext(testConfig);
                final Context attrContext = createAttributionContext(null /* attributionTag */);
                // UI component accesses on a display context must throw strict mode violations.
                final Context displayContext = createDisplayContext(getDisplay());
                switch (command.getName()) {
                    case ""memorizeCurrentInputConnection"": {
                        if (!Looper.getMainLooper().isCurrentThread()) {
                            return new UnsupportedOperationException(
                                    ""memorizeCurrentInputConnection can be requested only for the""
                                            + "" main thread."");
                        }
                        mMemorizedInputConnection = getCurrentInputConnection();
                        return ImeEvent.RETURN_VALUE_UNAVAILABLE;
                    }
                    case ""unmemorizeCurrentInputConnection"": {
                        if (!Looper.getMainLooper().isCurrentThread()) {
                            return new UnsupportedOperationException(
                                    ""unmemorizeCurrentInputConnection can be requested only for the""
                                            + "" main thread."");
                        }
                        mMemorizedInputConnection = null;
                        return ImeEvent.RETURN_VALUE_UNAVAILABLE;
                    }
                    case ""getTextBeforeCursor"": {
                        final int n = command.getExtras().getInt(""n"");
                        final int flag = command.getExtras().getInt(""flag"");
                        return getMemorizedOrCurrentInputConnection().getTextBeforeCursor(n, flag);
                    }
                    case ""getTextAfterCursor"": {
                        final int n = command.getExtras().getInt(""n"");
                        final int flag = command.getExtras().getInt(""flag"");
                        return getMemorizedOrCurrentInputConnection().getTextAfterCursor(n, flag);
                    }
                    case ""getSelectedText"": {
                        final int flag = command.getExtras().getInt(""flag"");
                        return getMemorizedOrCurrentInputConnection().getSelectedText(flag);
                    }
                    case ""getCursorCapsMode"": {
                        final int reqModes = command.getExtras().getInt(""reqModes"");
                        return getMemorizedOrCurrentInputConnection().getCursorCapsMode(reqModes);
                    }
                    case ""getExtractedText"": {
                        final ExtractedTextRequest request =
                                command.getExtras().getParcelable(""request"");
                        final int flags = command.getExtras().getInt(""flags"");
                        return getMemorizedOrCurrentInputConnection().getExtractedText(request,
                                flags);
                    }
                    case ""deleteSurroundingText"": {
                        final int beforeLength = command.getExtras().getInt(""beforeLength"");
                        final int afterLength = command.getExtras().getInt(""afterLength"");
                        return getMemorizedOrCurrentInputConnection().deleteSurroundingText(
                                beforeLength, afterLength);
                    }
                    case ""deleteSurroundingTextInCodePoints"": {
                        final int beforeLength = command.getExtras().getInt(""beforeLength"");
                        final int afterLength = command.getExtras().getInt(""afterLength"");
                        return getMemorizedOrCurrentInputConnection()
                                .deleteSurroundingTextInCodePoints(beforeLength, afterLength);
                    }
                    case ""setComposingText"": {
                        final CharSequence text = command.getExtras().getCharSequence(""text"");
                        final int newCursorPosition =
                                command.getExtras().getInt(""newCursorPosition"");
                        return getMemorizedOrCurrentInputConnection().setComposingText(
                                text, newCursorPosition);
                    }
                    case ""setComposingRegion"": {
                        final int start = command.getExtras().getInt(""start"");
                        final int end = command.getExtras().getInt(""end"");
                        return getMemorizedOrCurrentInputConnection().setComposingRegion(start,
                                end);
                    }
                    case ""finishComposingText"":
                        return getMemorizedOrCurrentInputConnection().finishComposingText();
                    case ""commitText"": {
                        final CharSequence text = command.getExtras().getCharSequence(""text"");
                        final int newCursorPosition =
                                command.getExtras().getInt(""newCursorPosition"");
                        return getMemorizedOrCurrentInputConnection().commitText(text,
                                newCursorPosition);
                    }
                    case ""commitCompletion"": {
                        final CompletionInfo text = command.getExtras().getParcelable(""text"");
                        return getMemorizedOrCurrentInputConnection().commitCompletion(text);
                    }
                    case ""commitCorrection"": {
                        final CorrectionInfo correctionInfo =
                                command.getExtras().getParcelable(""correctionInfo"");
                        return getMemorizedOrCurrentInputConnection().commitCorrection(
                                correctionInfo);
                    }
                    case ""setSelection"": {
                        final int start = command.getExtras().getInt(""start"");
                        final int end = command.getExtras().getInt(""end"");
                        return getMemorizedOrCurrentInputConnection().setSelection(start, end);
                    }
                    case ""performEditorAction"": {
                        final int editorAction = command.getExtras().getInt(""editorAction"");
                        return getMemorizedOrCurrentInputConnection().performEditorAction(
                                editorAction);
                    }
                    case ""performContextMenuAction"": {
                        final int id = command.getExtras().getInt(""id"");
                        return getMemorizedOrCurrentInputConnection().performContextMenuAction(id);
                    }
                    case ""beginBatchEdit"":
                        return getMemorizedOrCurrentInputConnection().beginBatchEdit();
                    case ""endBatchEdit"":
                        return getMemorizedOrCurrentInputConnection().endBatchEdit();
                    case ""sendKeyEvent"": {
                        final KeyEvent event = command.getExtras().getParcelable(""event"");
                        return getMemorizedOrCurrentInputConnection().sendKeyEvent(event);
                    }
                    case ""clearMetaKeyStates"": {
                        final int states = command.getExtras().getInt(""states"");
                        return getMemorizedOrCurrentInputConnection().clearMetaKeyStates(states);
                    }
                    case ""reportFullscreenMode"": {
                        final boolean enabled = command.getExtras().getBoolean(""enabled"");
                        return getMemorizedOrCurrentInputConnection().reportFullscreenMode(enabled);
                    }
                    case ""performSpellCheck"": {
                        return getMemorizedOrCurrentInputConnection().performSpellCheck();
                    }
                    case ""performPrivateCommand"": {
                        final String action = command.getExtras().getString(""action"");
                        final Bundle data = command.getExtras().getBundle(""data"");
                        return getMemorizedOrCurrentInputConnection().performPrivateCommand(action,
                                data);
                    }
                    case ""requestCursorUpdates"": {
                        final int cursorUpdateMode = command.getExtras().getInt(""cursorUpdateMode"");
                        return getMemorizedOrCurrentInputConnection().requestCursorUpdates(
                                cursorUpdateMode);
                    }
                    case ""getHandler"":
                        return getMemorizedOrCurrentInputConnection().getHandler();
                    case ""closeConnection"":
                        getMemorizedOrCurrentInputConnection().closeConnection();
                        return ImeEvent.RETURN_VALUE_UNAVAILABLE;
                    case ""commitContent"": {
                        final InputContentInfo inputContentInfo =
                                command.getExtras().getParcelable(""inputContentInfo"");
                        final int flags = command.getExtras().getInt(""flags"");
                        final Bundle opts = command.getExtras().getBundle(""opts"");
                        return getMemorizedOrCurrentInputConnection().commitContent(
                                inputContentInfo, flags, opts);
                    }
                    case ""setBackDisposition"": {
                        final int backDisposition =
                                command.getExtras().getInt(""backDisposition"");
                        setBackDisposition(backDisposition);
                        return ImeEvent.RETURN_VALUE_UNAVAILABLE;
                    }
                    case ""requestHideSelf"": {
                        final int flags = command.getExtras().getInt(""flags"");
                        requestHideSelf(flags);
                        return ImeEvent.RETURN_VALUE_UNAVAILABLE;
                    }
                    case ""requestShowSelf"": {
                        final int flags = command.getExtras().getInt(""flags"");
                        requestShowSelf(flags);
                        return ImeEvent.RETURN_VALUE_UNAVAILABLE;
                    }
                    case ""sendDownUpKeyEvents"": {
                        final int keyEventCode = command.getExtras().getInt(""keyEventCode"");
                        sendDownUpKeyEvents(keyEventCode);
                        return ImeEvent.RETURN_VALUE_UNAVAILABLE;
                    }
                    case ""getApplicationInfo"": {
                        final String packageName = command.getExtras().getString(""packageName"");
                        final int flags = command.getExtras().getInt(""flags"");
                        try {
                            return getPackageManager().getApplicationInfo(packageName, flags);
                        } catch (PackageManager.NameNotFoundException e) {
                            return e;
                        }
                    }
                    case ""getDisplayId"":
                        return getDisplay().getDisplayId();
                    case ""verifyLayoutInflaterContext"":
                        return getLayoutInflater().getContext() == this;
                    case ""setHeight"":
                        final int height = command.getExtras().getInt(""height"");
                        mView.setHeight(height);
                        return ImeEvent.RETURN_VALUE_UNAVAILABLE;
                    case ""setInlineSuggestionsExtras"":
                        mInlineSuggestionsExtras = command.getExtras();
                        return ImeEvent.RETURN_VALUE_UNAVAILABLE;
                    case ""verifyGetDisplay"":
                        try {
                            return verifyGetDisplay();
                        } catch (UnsupportedOperationException e) {
                            return e;
                        }
                    case ""verifyGetWindowManager"": {
                        final WindowManager imsWm = getSystemService(WindowManager.class);
                        final WindowManager configContextWm =
                                configContext.getSystemService(WindowManager.class);
                        final WindowManager attrContextWm =
                                attrContext.getSystemService(WindowManager.class);
                        return ImeEvent.RETURN_VALUE_UNAVAILABLE;
                    }
                    case ""verifyGetViewConfiguration"": {
                        final ViewConfiguration imsViewConfig = ViewConfiguration.get(this);
                        final ViewConfiguration configContextViewConfig =
                                ViewConfiguration.get(configContext);
                        final ViewConfiguration attrContextViewConfig =
                                ViewConfiguration.get(attrContext);
                        return ImeEvent.RETURN_VALUE_UNAVAILABLE;
                    }
                    case ""verifyGetGestureDetector"": {
                        GestureDetector.SimpleOnGestureListener listener =
                                new GestureDetector.SimpleOnGestureListener();
                        final GestureDetector imsGestureDetector =
                                new GestureDetector(this, listener);
                        final GestureDetector configContextGestureDetector =
                                new GestureDetector(configContext, listener);
                        final GestureDetector attrGestureDetector =
                                new GestureDetector(attrContext, listener);
                        return ImeEvent.RETURN_VALUE_UNAVAILABLE;
                    }
                    case ""verifyGetWindowManagerOnDisplayContext"": {
                        // Obtaining a WindowManager on a display context must throw a strict mode
                        // violation.
                        final WindowManager wm = displayContext
                                .getSystemService(WindowManager.class);

                        return ImeEvent.RETURN_VALUE_UNAVAILABLE;
                    }
                    case ""verifyGetViewConfigurationOnDisplayContext"": {
                        // Obtaining a ViewConfiguration on a display context must throw a strict
                        // mode violation.
                        final ViewConfiguration viewConfiguration =
                                ViewConfiguration.get(displayContext);

                        return ImeEvent.RETURN_VALUE_UNAVAILABLE;
                    }
                    case ""verifyGetGestureDetectorOnDisplayContext"": {
                        // Obtaining a GestureDetector on a display context must throw a strict mode
                        // violation.
                        GestureDetector.SimpleOnGestureListener listener =
                                new GestureDetector.SimpleOnGestureListener();
                        final GestureDetector gestureDetector =
                                new GestureDetector(displayContext, listener);

                        return ImeEvent.RETURN_VALUE_UNAVAILABLE;
                    }
                }
            }
            return ImeEvent.RETURN_VALUE_UNAVAILABLE;
        });
    }

    private boolean verifyGetDisplay() throws UnsupportedOperationException {
        final Display display;
        final Display configContextDisplay;
        final Configuration config = new Configuration();
        config.setToDefaults();
        final Context configContext = createConfigurationContext(config);
        display = getDisplay();
        configContextDisplay = configContext.getDisplay();
        return display != null && configContextDisplay != null;
    }

    @Nullable
    private Bundle mInlineSuggestionsExtras;

    @Nullable
    private CommandReceiver mCommandReceiver;

    @Nullable
    private ImeSettings mSettings;

    private final AtomicReference<String> mImeEventActionName = new AtomicReference<>();

    @Nullable
    String getImeEventActionName() {
        return mImeEventActionName.get();
    }

    private final AtomicReference<String> mClientPackageName = new AtomicReference<>();

    @Nullable
    String getClientPackageName() {
        return mClientPackageName.get();
    }

    private class MockInputMethodImpl extends InputMethodImpl {
        @Override
        public void showSoftInput(int flags, ResultReceiver resultReceiver) {
            getTracer().showSoftInput(flags, resultReceiver,
                    () -> super.showSoftInput(flags, resultReceiver));
        }

        @Override
        public void hideSoftInput(int flags, ResultReceiver resultReceiver) {
            getTracer().hideSoftInput(flags, resultReceiver,
                    () -> super.hideSoftInput(flags, resultReceiver));
        }

        @Override
        public void attachToken(IBinder token) {
            getTracer().attachToken(token, () -> super.attachToken(token));
        }

        @Override
        public void bindInput(InputBinding binding) {
            getTracer().bindInput(binding, () -> super.bindInput(binding));
        }

        @Override
        public void unbindInput() {
            getTracer().unbindInput(() -> super.unbindInput());
        }
    }

    @Override
    public void onCreate() {
        // Initialize minimum settings to send events in Tracer#onCreate().
        mSettings = SettingsProvider.getSettings();
        if (mSettings == null) {
            throw new IllegalStateException(""Settings file is not found. ""
                    + ""Make sure MockImeSession.create() is used to launch Mock IME."");
        }
        mClientPackageName.set(mSettings.getClientPackageName());
        mImeEventActionName.set(mSettings.getEventCallbackActionName());

        // TODO(b/159593676): consider to detect more violations
        if (mSettings.isStrictModeEnabled()) {
            StrictMode.setVmPolicy(
                    new StrictMode.VmPolicy.Builder()
                            .detectIncorrectContextUse()
                            .penaltyLog()
                            .penaltyListener(Runnable::run,
                                    v -> getTracer().onStrictModeViolated(() -> { }))
                            .build());
        }

        getTracer().onCreate(() -> {
            super.onCreate();
            mHandlerThread.start();
            final String actionName = getCommandActionName(mSettings.getEventCallbackActionName());
            mCommandReceiver = new CommandReceiver(actionName, this::onReceiveCommand);
            final IntentFilter filter = new IntentFilter(actionName);
            final Handler handler = new Handler(mHandlerThread.getLooper());
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                registerReceiver(mCommandReceiver, filter, null /* broadcastPermission */, handler,
                        Context.RECEIVER_VISIBLE_TO_INSTANT_APPS);
            } else {
                registerReceiver(mCommandReceiver, filter, null /* broadcastPermission */, handler);
            }
            if (mSettings.isVerifyGetDisplayOnCreate()) {
                getTracer().onVerify(""getDisplay"", this::verifyGetDisplay);
            }
            final int windowFlags = mSettings.getWindowFlags(0);
            final int windowFlagsMask = mSettings.getWindowFlagsMask(0);
            if (windowFlags != 0 || windowFlagsMask != 0) {
                final int prevFlags = getWindow().getWindow().getAttributes().flags;
                getWindow().getWindow().setFlags(windowFlags, windowFlagsMask);
                // For some reasons, seems that we need to post another requestLayout() when
                // FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS bit is changed.
                // TODO: Investigate the reason.
                if ((windowFlagsMask & FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) != 0) {
                    final boolean hadFlag = (prevFlags & FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) != 0;
                    final boolean hasFlag = (windowFlags & FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) != 0;
                    if (hadFlag != hasFlag) {
                        final View decorView = getWindow().getWindow().getDecorView();
                        decorView.post(() -> decorView.requestLayout());
                    }
                }
            }

            // Ensuring bar contrast interferes with the tests.
            getWindow().getWindow().setStatusBarContrastEnforced(false);
            getWindow().getWindow().setNavigationBarContrastEnforced(false);

            if (mSettings.hasNavigationBarColor()) {
                getWindow().getWindow().setNavigationBarColor(mSettings.getNavigationBarColor());
            }
        });
    }

    @Override
    public void onConfigureWindow(Window win, boolean isFullscreen, boolean isCandidatesOnly) {
        getTracer().onConfigureWindow(win, isFullscreen, isCandidatesOnly,
                () -> super.onConfigureWindow(win, isFullscreen, isCandidatesOnly));
    }

    @Override
    public boolean onEvaluateFullscreenMode() {
        return getTracer().onEvaluateFullscreenMode(() ->
                mSettings.fullscreenModeAllowed(false) && super.onEvaluateFullscreenMode());
    }

    private static final class KeyboardLayoutView extends LinearLayout {
        @NonNull
        private final MockIme mMockIme;
        @NonNull
        private final ImeSettings mSettings;
        @NonNull
        private final View.OnLayoutChangeListener mLayoutListener;

        private final LinearLayout mLayout;

        @Nullable
        private final LinearLayout mSuggestionView;

        private boolean mDrawsBehindNavBar = false;

        KeyboardLayoutView(MockIme mockIme, @NonNull ImeSettings imeSettings,
                @Nullable Consumer<ImeLayoutInfo> onInputViewLayoutChangedCallback) {
            super(mockIme);

            mMockIme = mockIme;
            mSettings = imeSettings;

            setOrientation(VERTICAL);

            final int defaultBackgroundColor =
                    getResources().getColor(android.R.color.holo_orange_dark, null);

            final int mainSpacerHeight = mSettings.getInputViewHeight(LayoutParams.WRAP_CONTENT);
            mLayout = new LinearLayout(getContext());
            mLayout.setOrientation(LinearLayout.VERTICAL);

            if (mSettings.getInlineSuggestionsEnabled()) {
                final HorizontalScrollView scrollView = new HorizontalScrollView(getContext());
                final LayoutParams scrollViewParams = new LayoutParams(MATCH_PARENT, 100);
                scrollView.setLayoutParams(scrollViewParams);

                final LinearLayout suggestionView = new LinearLayout(getContext());
                suggestionView.setBackgroundColor(0xFFEEEEEE);
                final String suggestionViewContentDesc =
                        mSettings.getInlineSuggestionViewContentDesc(null /* default */);
                if (suggestionViewContentDesc != null) {
                    suggestionView.setContentDescription(suggestionViewContentDesc);
                }
                scrollView.addView(suggestionView, new LayoutParams(MATCH_PARENT, MATCH_PARENT));
                mSuggestionView = suggestionView;

                mLayout.addView(scrollView);
            } else {
                mSuggestionView = null;
            }

            {
                final FrameLayout secondaryLayout = new FrameLayout(getContext());
                secondaryLayout.setForegroundGravity(Gravity.CENTER);

                final TextView textView = new TextView(getContext());
                textView.setLayoutParams(new LayoutParams(MATCH_PARENT, WRAP_CONTENT));
                textView.setTextSize(TypedValue.COMPLEX_UNIT_SP, 20);
                textView.setGravity(Gravity.CENTER);
                textView.setText(getImeId());
                textView.setBackgroundColor(
                        mSettings.getBackgroundColor(defaultBackgroundColor));
                secondaryLayout.addView(textView);

                if (mSettings.isWatermarkEnabled(true /* defaultValue */)) {
                    final ImageView imageView = new ImageView(getContext());
                    final Bitmap bitmap = Watermark.create();
                    imageView.setImageBitmap(bitmap);
                    secondaryLayout.addView(imageView,
                            new FrameLayout.LayoutParams(bitmap.getWidth(), bitmap.getHeight(),
                                    Gravity.CENTER));
                }

                mLayout.addView(secondaryLayout);
            }

            addView(mLayout, MATCH_PARENT, mainSpacerHeight);

            final int systemUiVisibility = mSettings.getInputViewSystemUiVisibility(0);
            if (systemUiVisibility != 0) {
                setSystemUiVisibility(systemUiVisibility);
            }

            if (mSettings.getDrawsBehindNavBar()) {
                mDrawsBehindNavBar = true;
                mMockIme.getWindow().getWindow().setDecorFitsSystemWindows(false);
                setSystemUiVisibility(getSystemUiVisibility()
                        | SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION);
            }

            mLayoutListener = (View v, int left, int top, int right, int bottom, int oldLeft,
                    int oldTop, int oldRight, int oldBottom) ->
                    onInputViewLayoutChangedCallback.accept(
                            ImeLayoutInfo.fromLayoutListenerCallback(
                                    v, left, top, right, bottom, oldLeft, oldTop, oldRight,
                                    oldBottom));
            this.addOnLayoutChangeListener(mLayoutListener);
        }

        private void setHeight(int height) {
            mLayout.getLayoutParams().height = height;
            mLayout.requestLayout();
        }

        private void updateBottomPaddingIfNecessary(int newPaddingBottom) {
            if (getPaddingBottom() != newPaddingBottom) {
                setPadding(getPaddingLeft(), getPaddingTop(), getPaddingRight(), newPaddingBottom);
            }
        }

        @Override
        public WindowInsets onApplyWindowInsets(WindowInsets insets) {
            if (insets.isConsumed()
                    || mDrawsBehindNavBar
                    || (getSystemUiVisibility() & SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION) == 0) {
                // In this case we are not interested in consuming NavBar region.
                // Make sure that the bottom padding is empty.
                updateBottomPaddingIfNecessary(0);
                return insets;
            }

            // In some cases the bottom system window inset is not a navigation bar. Wear devices
            // that have bottom chin are examples.  For now, assume that it's a navigation bar if it
            // has the same height as the root window's stable bottom inset.
            final WindowInsets rootWindowInsets = getRootWindowInsets();
            if (rootWindowInsets != null && (rootWindowInsets.getStableInsetBottom()
                    != insets.getSystemWindowInsetBottom())) {
                // This is probably not a NavBar.
                updateBottomPaddingIfNecessary(0);
                return insets;
            }

            final int possibleNavBarHeight = insets.getSystemWindowInsetBottom();
            updateBottomPaddingIfNecessary(possibleNavBarHeight);
            return possibleNavBarHeight <= 0
                    ? insets
                    : insets.replaceSystemWindowInsets(
                            insets.getSystemWindowInsetLeft(),
                            insets.getSystemWindowInsetTop(),
                            insets.getSystemWindowInsetRight(),
                            0 /* bottom */);
        }

        @Override
        protected void onWindowVisibilityChanged(int visibility) {
            mMockIme.getTracer().onWindowVisibilityChanged(() -> {
                super.onWindowVisibilityChanged(visibility);
            }, visibility);
        }

        @Override
        protected void onDetachedFromWindow() {
            super.onDetachedFromWindow();
            removeOnLayoutChangeListener(mLayoutListener);
        }

        @MainThread
        private void updateInlineSuggestions(
                @NonNull PendingInlineSuggestions pendingInlineSuggestions) {
            Log.d(TAG, ""updateInlineSuggestions() called: "" + pendingInlineSuggestions.mTotalCount);
            if (mSuggestionView == null || !pendingInlineSuggestions.mValid.get()) {
                return;
            }
            mSuggestionView.removeAllViews();
            for (int i = 0; i < pendingInlineSuggestions.mTotalCount; i++) {
                View view = pendingInlineSuggestions.mViews[i];
                if (view == null) {
                    continue;
                }
                mSuggestionView.addView(view);
            }
        }
    }

    KeyboardLayoutView mView;

    private void onInputViewLayoutChanged(@NonNull ImeLayoutInfo layoutInfo) {
        getTracer().onInputViewLayoutChanged(layoutInfo, () -> { });
    }

    @Override
    public View onCreateInputView() {
        return getTracer().onCreateInputView(() -> {
            mView = new KeyboardLayoutView(this, mSettings, this::onInputViewLayoutChanged);
            return mView;
        });
    }

    @Override
    public void onStartInput(EditorInfo editorInfo, boolean restarting) {
        getTracer().onStartInput(editorInfo, restarting,
                () -> super.onStartInput(editorInfo, restarting));
    }

    @Override
    public void onStartInputView(EditorInfo editorInfo, boolean restarting) {
        getTracer().onStartInputView(editorInfo, restarting,
                () -> super.onStartInputView(editorInfo, restarting));
    }

    @Override
    public void onFinishInputView(boolean finishingInput) {
        getTracer().onFinishInputView(finishingInput,
                () -> super.onFinishInputView(finishingInput));
    }

    @Override
    public void onFinishInput() {
        getTracer().onFinishInput(() -> super.onFinishInput());
    }

    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event) {
        return getTracer().onKeyDown(keyCode, event, () -> super.onKeyDown(keyCode, event));
    }

    @Override
    public void onUpdateCursorAnchorInfo(CursorAnchorInfo cursorAnchorInfo) {
        getTracer().onUpdateCursorAnchorInfo(cursorAnchorInfo,
                () -> super.onUpdateCursorAnchorInfo(cursorAnchorInfo));
    }

    @Override
    public void onUpdateSelection(int oldSelStart, int oldSelEnd, int newSelStart, int newSelEnd,
            int candidatesStart, int candidatesEnd) {
        getTracer().onUpdateSelection(oldSelStart, oldSelEnd, newSelStart, newSelEnd,
                candidatesStart, candidatesEnd,
                () -> super.onUpdateSelection(oldSelStart, oldSelEnd, newSelStart, newSelEnd,
                        candidatesStart, candidatesEnd));
    }

    @CallSuper
    public boolean onEvaluateInputViewShown() {
        return getTracer().onEvaluateInputViewShown(() -> {
            // onShowInputRequested() is indeed @CallSuper so we always call this, even when the
            // result is ignored.
            final boolean originalResult = super.onEvaluateInputViewShown();
            if (!mSettings.getHardKeyboardConfigurationBehaviorAllowed(false)) {
                final Configuration config = getResources().getConfiguration();
                if (config.keyboard != Configuration.KEYBOARD_NOKEYS
                        && config.hardKeyboardHidden != Configuration.HARDKEYBOARDHIDDEN_YES) {
                    // Override the behavior of InputMethodService#onEvaluateInputViewShown()
                    return true;
                }
            }
            return originalResult;
        });
    }

    @Override
    public boolean onShowInputRequested(int flags, boolean configChange) {
        return getTracer().onShowInputRequested(flags, configChange, () -> {
            // onShowInputRequested() is not marked with @CallSuper, but just in case.
            final boolean originalResult = super.onShowInputRequested(flags, configChange);
            if (!mSettings.getHardKeyboardConfigurationBehaviorAllowed(false)) {
                if ((flags & InputMethod.SHOW_EXPLICIT) == 0
                        && getResources().getConfiguration().keyboard
                        != Configuration.KEYBOARD_NOKEYS) {
                    // Override the behavior of InputMethodService#onShowInputRequested()
                    return true;
                }
            }
            return originalResult;
        });
    }

    @Override
    public void onDestroy() {
        getTracer().onDestroy(() -> {
            super.onDestroy();
            unregisterReceiver(mCommandReceiver);
            mHandlerThread.quitSafely();
        });
    }

    @Override
    public AbstractInputMethodImpl onCreateInputMethodInterface() {
        return getTracer().onCreateInputMethodInterface(() -> new MockInputMethodImpl());
    }

    private final ThreadLocal<Tracer> mThreadLocalTracer = new ThreadLocal<>();

    private Tracer getTracer() {
        Tracer tracer = mThreadLocalTracer.get();
        if (tracer == null) {
            tracer = new Tracer(this);
            mThreadLocalTracer.set(tracer);
        }
        return tracer;
    }

    @NonNull
    private ImeState getState() {
        final boolean hasInputBinding = getCurrentInputBinding() != null;
        final boolean hasFallbackInputConnection =
                !hasInputBinding
                        || getCurrentInputConnection() == getCurrentInputBinding().getConnection();
        return new ImeState(hasInputBinding, hasFallbackInputConnection);
    }

    private PendingInlineSuggestions mPendingInlineSuggestions;

    private static final class PendingInlineSuggestions {
        final InlineSuggestionsResponse mResponse;
        final int mTotalCount;
        final View[] mViews;
        final AtomicInteger mInflatedViewCount;
        final AtomicBoolean mValid = new AtomicBoolean(true);

        PendingInlineSuggestions(InlineSuggestionsResponse response) {
            mResponse = response;
            mTotalCount = response.getInlineSuggestions().size();
            mViews = new View[mTotalCount];
            mInflatedViewCount = new AtomicInteger(0);
        }
    }

    @MainThread
    @Override
    public InlineSuggestionsRequest onCreateInlineSuggestionsRequest(Bundle uiExtras) {
        StylesBuilder stylesBuilder = UiVersions.newStylesBuilder();
        stylesBuilder.addStyle(InlineSuggestionUi.newStyleBuilder().build());
        Bundle styles = stylesBuilder.build();

        if (mInlineSuggestionsExtras != null) {
            styles.putAll(mInlineSuggestionsExtras);
        }

        return getTracer().onCreateInlineSuggestionsRequest(() -> {
            final ArrayList<InlinePresentationSpec> presentationSpecs = new ArrayList<>();
            presentationSpecs.add(new InlinePresentationSpec.Builder(new Size(100, 100),
                    new Size(400, 100)).setStyle(styles).build());
            presentationSpecs.add(new InlinePresentationSpec.Builder(new Size(100, 100),
                    new Size(400, 100)).setStyle(styles).build());

            final InlinePresentationSpec tooltipSpec =
                    new InlinePresentationSpec.Builder(new Size(100, 100),
                            new Size(400, 100)).setStyle(styles).build();
            final InlineSuggestionsRequest.Builder builder =
                    new InlineSuggestionsRequest.Builder(presentationSpecs)
                            .setInlineTooltipPresentationSpec(tooltipSpec)
                            .setMaxSuggestionCount(6);
            if (mInlineSuggestionsExtras != null) {
                builder.setExtras(mInlineSuggestionsExtras.deepCopy());
            }
            return builder.build();
        });
    }

    @MainThread
    @Override
    public boolean onInlineSuggestionsResponse(@NonNull InlineSuggestionsResponse response) {
        return getTracer().onInlineSuggestionsResponse(response, () -> {
            final PendingInlineSuggestions pendingInlineSuggestions =
                    new PendingInlineSuggestions(response);
            if (mPendingInlineSuggestions != null) {
                mPendingInlineSuggestions.mValid.set(false);
            }
            mPendingInlineSuggestions = pendingInlineSuggestions;
            if (pendingInlineSuggestions.mTotalCount == 0) {
                if (mView != null) {
                    mView.updateInlineSuggestions(pendingInlineSuggestions);
                }
                return true;
            }

            final ExecutorService executorService = Executors.newCachedThreadPool();
            for (int i = 0; i < pendingInlineSuggestions.mTotalCount; i++) {
                final int index = i;
                InlineSuggestion inlineSuggestion =
                        pendingInlineSuggestions.mResponse.getInlineSuggestions().get(index);
                inlineSuggestion.inflate(
                        this,
                        new Size(WRAP_CONTENT, WRAP_CONTENT),
                        executorService,
                        suggestionView -> {
                            Log.d(TAG, ""new inline suggestion view ready"");
                            if (suggestionView != null) {
                                suggestionView.setOnClickListener((v) -> {
                                    getTracer().onInlineSuggestionClickedEvent(() -> { });
                                });
                                suggestionView.setOnLongClickListener((v) -> {
                                    getTracer().onInlineSuggestionLongClickedEvent(() -> { });
                                    return true;
                                });
                                pendingInlineSuggestions.mViews[index] = suggestionView;
                            }
                            if (pendingInlineSuggestions.mInflatedViewCount.incrementAndGet()
                                    == pendingInlineSuggestions.mTotalCount
                                    && pendingInlineSuggestions.mValid.get()) {
                                Log.d(TAG, ""ready to display all suggestions"");
                                mMainHandler.post(() ->
                                        mView.updateInlineSuggestions(pendingInlineSuggestions));
                            }
                        });
            }
            return true;
        });
    }

    /**
     * Event tracing helper class for {@link MockIme}.
     */
    private static final class Tracer {

        @NonNull
        private final MockIme mIme;

        private final int mThreadId = Process.myTid();

        @NonNull
        private final String mThreadName =
                Thread.currentThread().getName() != null ? Thread.currentThread().getName() : """";

        private final boolean mIsMainThread =
                Looper.getMainLooper().getThread() == Thread.currentThread();

        private int mNestLevel = 0;

        private String mImeEventActionName;

        private String mClientPackageName;

        Tracer(@NonNull MockIme mockIme) {
            mIme = mockIme;
        }

        private void sendEventInternal(@NonNull ImeEvent event) {
            if (mImeEventActionName == null) {
                mImeEventActionName = mIme.getImeEventActionName();
            }
            if (mClientPackageName == null) {
                mClientPackageName = mIme.getClientPackageName();
            }
            if (mImeEventActionName == null || mClientPackageName == null) {
                Log.e(TAG, ""Tracer cannot be used before onCreate()"");
                return;
            }
            final Intent intent = new Intent()
                    .setAction(mImeEventActionName)
                    .setPackage(mClientPackageName)
                    .putExtras(event.toBundle())
                    .addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY
                            | Intent.FLAG_RECEIVER_VISIBLE_TO_INSTANT_APPS);
            mIme.sendBroadcast(intent);
        }

        private void recordEventInternal(@NonNull String eventName, @NonNull Runnable runnable) {
            recordEventInternal(eventName, runnable, new Bundle());
        }

        private void recordEventInternal(@NonNull String eventName, @NonNull Runnable runnable,
                @NonNull Bundle arguments) {
            recordEventInternal(eventName, () -> {
                runnable.run(); return ImeEvent.RETURN_VALUE_UNAVAILABLE;
            }, arguments);
        }

        private <T> T recordEventInternal(@NonNull String eventName,
                @NonNull Supplier<T> supplier) {
            return recordEventInternal(eventName, supplier, new Bundle());
        }

        private <T> T recordEventInternal(@NonNull String eventName,
                @NonNull Supplier<T> supplier, @NonNull Bundle arguments) {
            final ImeState enterState = mIme.getState();
            final long enterTimestamp = SystemClock.elapsedRealtimeNanos();
            final long enterWallTime = System.currentTimeMillis();
            final int nestLevel = mNestLevel;
            // Send enter event
            sendEventInternal(new ImeEvent(eventName, nestLevel, mThreadName,
                    mThreadId, mIsMainThread, enterTimestamp, 0, enterWallTime,
                    0, enterState, null, arguments,
                    ImeEvent.RETURN_VALUE_UNAVAILABLE));
            ++mNestLevel;
            T result;
            try {
                result = supplier.get();
            } finally {
                --mNestLevel;
            }
            final long exitTimestamp = SystemClock.elapsedRealtimeNanos();
            final long exitWallTime = System.currentTimeMillis();
            final ImeState exitState = mIme.getState();
            // Send exit event
            sendEventInternal(new ImeEvent(eventName, nestLevel, mThreadName,
                    mThreadId, mIsMainThread, enterTimestamp, exitTimestamp, enterWallTime,
                    exitWallTime, enterState, exitState, arguments, result));
            return result;
        }

        void onCreate(@NonNull Runnable runnable) {
            recordEventInternal(""onCreate"", runnable);
        }

        void onVerify(String name, @NonNull BooleanSupplier supplier) {
            final Bundle arguments = new Bundle();
            arguments.putString(""name"", name);
            recordEventInternal(""onVerify"", supplier::getAsBoolean, arguments);
        }

        void onConfigureWindow(Window win, boolean isFullscreen, boolean isCandidatesOnly,
                @NonNull Runnable runnable) {
            final Bundle arguments = new Bundle();
            arguments.putBoolean(""isFullscreen"", isFullscreen);
            arguments.putBoolean(""isCandidatesOnly"", isCandidatesOnly);
            recordEventInternal(""onConfigureWindow"", runnable, arguments);
        }

        boolean onEvaluateFullscreenMode(@NonNull BooleanSupplier supplier) {
            return recordEventInternal(""onEvaluateFullscreenMode"", supplier::getAsBoolean);
        }

        boolean onEvaluateInputViewShown(@NonNull BooleanSupplier supplier) {
            return recordEventInternal(""onEvaluateInputViewShown"", supplier::getAsBoolean);
        }

        View onCreateInputView(@NonNull Supplier<View> supplier) {
            return recordEventInternal(""onCreateInputView"", supplier);
        }

        void onStartInput(EditorInfo editorInfo, boolean restarting, @NonNull Runnable runnable) {
            final Bundle arguments = new Bundle();
            arguments.putParcelable(""editorInfo"", editorInfo);
            arguments.putBoolean(""restarting"", restarting);
            recordEventInternal(""onStartInput"", runnable, arguments);
        }

        void onWindowVisibilityChanged(@NonNull Runnable runnable, int visibility) {
            final Bundle arguments = new Bundle();
            arguments.putInt(""visible"", visibility);
            recordEventInternal(""onWindowVisibilityChanged"", runnable, arguments);
        }

        void onStartInputView(EditorInfo editorInfo, boolean restarting,
                @NonNull Runnable runnable) {
            final Bundle arguments = new Bundle();
            arguments.putParcelable(""editorInfo"", editorInfo);
            arguments.putBoolean(""restarting"", restarting);
            recordEventInternal(""onStartInputView"", runnable, arguments);
        }

        void onFinishInputView(boolean finishingInput, @NonNull Runnable runnable) {
            final Bundle arguments = new Bundle();
            arguments.putBoolean(""finishingInput"", finishingInput);
            recordEventInternal(""onFinishInputView"", runnable, arguments);
        }

        void onFinishInput(@NonNull Runnable runnable) {
            recordEventInternal(""onFinishInput"", runnable);
        }

        boolean onKeyDown(int keyCode, KeyEvent event, @NonNull BooleanSupplier supplier) {
            final Bundle arguments = new Bundle();
            arguments.putInt(""keyCode"", keyCode);
            arguments.putParcelable(""event"", event);
            return recordEventInternal(""onKeyDown"", supplier::getAsBoolean, arguments);
        }

        void onUpdateCursorAnchorInfo(CursorAnchorInfo cursorAnchorInfo,
                @NonNull Runnable runnable) {
            final Bundle arguments = new Bundle();
            arguments.putParcelable(""cursorAnchorInfo"", cursorAnchorInfo);
            recordEventInternal(""onUpdateCursorAnchorInfo"", runnable, arguments);
        }

        void onUpdateSelection(int oldSelStart,
                int oldSelEnd,
                int newSelStart,
                int newSelEnd,
                int candidatesStart,
                int candidatesEnd,
                @NonNull Runnable runnable) {
            final Bundle arguments = new Bundle();
            arguments.putInt(""oldSelStart"", oldSelStart);
            arguments.putInt(""oldSelEnd"", oldSelEnd);
            arguments.putInt(""newSelStart"", newSelStart);
            arguments.putInt(""newSelEnd"", newSelEnd);
            arguments.putInt(""candidatesStart"", candidatesStart);
            arguments.putInt(""candidatesEnd"", candidatesEnd);
            recordEventInternal(""onUpdateSelection"", runnable, arguments);
        }

        boolean onShowInputRequested(int flags, boolean configChange,
                @NonNull BooleanSupplier supplier) {
            final Bundle arguments = new Bundle();
            arguments.putInt(""flags"", flags);
            arguments.putBoolean(""configChange"", configChange);
            return recordEventInternal(""onShowInputRequested"", supplier::getAsBoolean, arguments);
        }

        void onDestroy(@NonNull Runnable runnable) {
            recordEventInternal(""onDestroy"", runnable);
        }

        void attachToken(IBinder token, @NonNull Runnable runnable) {
            final Bundle arguments = new Bundle();
            arguments.putBinder(""token"", token);
            recordEventInternal(""attachToken"", runnable, arguments);
        }

        void bindInput(InputBinding binding, @NonNull Runnable runnable) {
            final Bundle arguments = new Bundle();
            arguments.putParcelable(""binding"", binding);
            recordEventInternal(""bindInput"", runnable, arguments);
        }

        void unbindInput(@NonNull Runnable runnable) {
            recordEventInternal(""unbindInput"", runnable);
        }

        void showSoftInput(int flags, ResultReceiver resultReceiver, @NonNull Runnable runnable) {
            final Bundle arguments = new Bundle();
            arguments.putInt(""flags"", flags);
            arguments.putParcelable(""resultReceiver"", resultReceiver);
            recordEventInternal(""showSoftInput"", runnable, arguments);
        }

        void hideSoftInput(int flags, ResultReceiver resultReceiver, @NonNull Runnable runnable) {
            final Bundle arguments = new Bundle();
            arguments.putInt(""flags"", flags);
            arguments.putParcelable(""resultReceiver"", resultReceiver);
            recordEventInternal(""hideSoftInput"", runnable, arguments);
        }

        AbstractInputMethodImpl onCreateInputMethodInterface(
                @NonNull Supplier<AbstractInputMethodImpl> supplier) {
            return recordEventInternal(""onCreateInputMethodInterface"", supplier);
        }

        void onReceiveCommand(@NonNull ImeCommand command, @NonNull Runnable runnable) {
            final Bundle arguments = new Bundle();
            arguments.putBundle(""command"", command.toBundle());
            recordEventInternal(""onReceiveCommand"", runnable, arguments);
        }

        void onHandleCommand(
                @NonNull ImeCommand command, @NonNull Supplier<Object> resultSupplier) {
            final Bundle arguments = new Bundle();
            arguments.putBundle(""command"", command.toBundle());
            recordEventInternal(""onHandleCommand"", resultSupplier, arguments);
        }

        void onInputViewLayoutChanged(@NonNull ImeLayoutInfo imeLayoutInfo,
                @NonNull Runnable runnable) {
            final Bundle arguments = new Bundle();
            imeLayoutInfo.writeToBundle(arguments);
            recordEventInternal(""onInputViewLayoutChanged"", runnable, arguments);
        }

        void onStrictModeViolated(@NonNull Runnable runnable) {
            final Bundle arguments = new Bundle();
            recordEventInternal(""onStrictModeViolated"", runnable, arguments);
        }

        InlineSuggestionsRequest onCreateInlineSuggestionsRequest(
                @NonNull Supplier<InlineSuggestionsRequest> supplier) {
            return recordEventInternal(""onCreateInlineSuggestionsRequest"", supplier);
        }

        boolean onInlineSuggestionsResponse(@NonNull InlineSuggestionsResponse response,
                @NonNull BooleanSupplier supplier) {
            final Bundle arguments = new Bundle();
            arguments.putParcelable(""response"", response);
            return recordEventInternal(""onInlineSuggestionsResponse"", supplier::getAsBoolean,
                    arguments);
        }

        void onInlineSuggestionClickedEvent(@NonNull Runnable runnable) {
            final Bundle arguments = new Bundle();
            recordEventInternal(""onInlineSuggestionClickedEvent"", runnable, arguments);
        }

        void onInlineSuggestionLongClickedEvent(@NonNull Runnable runnable) {
            final Bundle arguments = new Bundle();
            recordEventInternal(""onInlineSuggestionLongClickedEvent"", runnable, arguments);
        }
    }
}"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.app.cts.AlertDialogTest"	"testCallback"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/AlertDialogTest.java"	""	"public void testCallback() {
        startDialogActivity(DialogStubActivity.TEST_ALERTDIALOG_CALLBACK);
        assertTrue(mActivity.onCreateCalled);

        mInstrumentation.sendKeySync(new KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_0));
        assertTrue(mActivity.onKeyDownCalled);
        mInstrumentation.sendKeySync(new KeyEvent(KeyEvent.ACTION_UP, KeyEvent.KEYCODE_0));
        assertTrue(mActivity.onKeyUpCalled);
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.app.cts.AlertDialogTest"	"testAlertDialogCancelable"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/AlertDialogTest.java"	""	"public void testAlertDialogCancelable() {
        startDialogActivity(DialogStubActivity.TEST_ALERTDIALOG_CANCELABLE);
        assertTrue(mActivity.getDialog().isShowing());
        assertFalse(mActivity.onCancelCalled);
        mInstrumentation.sendKeyDownUpSync(KeyEvent.KEYCODE_BACK);
        PollingCheck.waitFor(() -> mActivity.onCancelCalled);
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.app.cts.AlertDialogTest"	"testAlertDialogNotCancelable"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/AlertDialogTest.java"	""	"public void testAlertDialogNotCancelable() {
        startDialogActivity(DialogStubActivity.TEST_ALERTDIALOG_NOT_CANCELABLE);
        assertTrue(mActivity.getDialog().isShowing());
        assertFalse(mActivity.onCancelCalled);
        mInstrumentation.sendKeyDownUpSync(KeyEvent.KEYCODE_BACK);
        assertFalse(mActivity.onCancelCalled);
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.graphics.cts.BitmapTest"	"testNdkAccessAfterRecycle"	"CtsGraphicsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/graphics/src/android/graphics/cts/BitmapTest.java"	""	"public void testNdkAccessAfterRecycle() {
        Bitmap bitmap = Bitmap.createBitmap(10, 20, Config.RGB_565);
        Bitmap hardware = bitmap.copy(Config.HARDWARE, false);
        nValidateBitmapInfo(bitmap, 10, 20, true);
        nValidateBitmapInfo(hardware, 10, 20, true);

        bitmap.recycle();
        hardware.recycle();

        nValidateBitmapInfo(bitmap, 10, 20, true);
        nValidateBitmapInfo(hardware, 10, 20, true);
        nValidateNdkAccessFails(bitmap);
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.graphics.cts.BitmapTest"	"testNdkFormats"	"CtsGraphicsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/graphics/src/android/graphics/cts/BitmapTest.java"	""	"public void testNdkFormats() {
        for (ConfigToFormat pair : CONFIG_TO_FORMAT) {
            Bitmap bm = Bitmap.createBitmap(10, 10, pair.config);
            assertNotNull(bm);
            int nativeFormat = nGetFormat(bm);
            assertEquals(""Config: "" + pair.config, pair.format, nativeFormat);
        }
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.graphics.cts.BitmapTest"	"testNdkFormatsHardware"	"CtsGraphicsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/graphics/src/android/graphics/cts/BitmapTest.java"	""	"public void testNdkFormatsHardware() {
        for (ConfigToFormat pair : CONFIG_TO_FORMAT) {
            Bitmap bm = Bitmap.createBitmap(10, 10, pair.config);
            bm = bm.copy(Bitmap.Config.HARDWARE, false);

            // ALPHA_8 is not supported in HARDWARE.
            if (bm == null) {
                assertEquals(Bitmap.Config.ALPHA_8, pair.config);
                continue;
            }
            assertNotEquals(Bitmap.Config.ALPHA_8, pair.config);

            int nativeFormat = nGetFormat(bm);
            if (pair.config == Bitmap.Config.RGBA_F16) {
                // It is possible the system does not support RGBA_F16 in HARDWARE.
                // In that case, it will fall back to ARGB_8888.
                assertTrue(nativeFormat == ANDROID_BITMAP_FORMAT_RGBA_8888
                        || nativeFormat == ANDROID_BITMAP_FORMAT_RGBA_F16);
            } else {
                assertEquals(""Config: "" + pair.config, pair.format, nativeFormat);
            }
        }
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.graphics.cts.BitmapTest"	"testNullBitmapNdk"	"CtsGraphicsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/graphics/src/android/graphics/cts/BitmapTest.java"	""	"public void testNullBitmapNdk() {
        Bitmap bitmap = Bitmap.createBitmap(10, 10, Bitmap.Config.ARGB_8888);
        nTestNullBitmap(bitmap);
    }

    private Object[] parametersForTestNdkInfo() {
        return new Object[] {
            new Object[] { Config.ALPHA_8,   ANDROID_BITMAP_FORMAT_A_8  },
            new Object[] { Config.ARGB_8888, ANDROID_BITMAP_FORMAT_RGBA_8888 },
            new Object[] { Config.RGB_565,   ANDROID_BITMAP_FORMAT_RGB_565 },
            new Object[] { Config.RGBA_F16,  ANDROID_BITMAP_FORMAT_RGBA_F16 },
        };
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.graphics.cts.BitmapTest"	"isPremultiplied"	"CtsGraphicsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/graphics/src/android/graphics/cts/BitmapTest.java"	""	"@Parameters(method = ""parametersForTestNdkInfo"")
    public void testNdkInfo(Config config, final int expectedFormat) {
        // Arbitrary width and height.
        final int width = 13;
        final int height = 7;
        boolean[] trueFalse = new boolean[] { true, false };
        for (boolean hasAlpha : trueFalse) {
            for (boolean premultiplied : trueFalse) {
                Bitmap bm = Bitmap.createBitmap(width, height, config, hasAlpha);
                bm.setPremultiplied(premultiplied);
                nTestInfo(bm, expectedFormat, width, height, bm.hasAlpha(),
                        bm.isPremultiplied(), false);
                Bitmap hwBitmap = bm.copy(Bitmap.Config.HARDWARE, false);
                if (config == Bitmap.Config.ALPHA_8) {
                    // ALPHA_8 is not supported in HARDWARE. b/141480329
                    assertNull(hwBitmap);
                } else {
                    assertNotNull(hwBitmap);

                    // Some devices do not support F16 + HARDWARE. These fall back to 8888, and can
                    // be identified by their use of SRGB instead of EXTENDED_SRGB.
                    int tempExpectedFormat = expectedFormat;
                    if (config == Config.RGBA_F16 && hwBitmap.getColorSpace() == ColorSpace.get(
                            ColorSpace.Named.SRGB)) {
                        tempExpectedFormat = ANDROID_BITMAP_FORMAT_RGBA_8888;
                    }
                    nTestInfo(hwBitmap, tempExpectedFormat, width, height, hwBitmap.hasAlpha(),
                            hwBitmap.isPremultiplied(), true);
                    hwBitmap.recycle();
                }
                bm.recycle();
            }
        }
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.graphics.cts.BitmapTest"	"testNdkDataSpaceF16Extended"	"CtsGraphicsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/graphics/src/android/graphics/cts/BitmapTest.java"	""	"public void testNdkDataSpaceF16Extended() {
        // In RGBA_F16 we force EXTENDED in these cases.
        for (ColorSpace colorSpace : new ColorSpace[] {
                ColorSpace.get(Named.SRGB),
                ColorSpace.get(Named.EXTENDED_SRGB),
        }) {
            Bitmap bm = Bitmap.createBitmap(10, 10, Config.RGBA_F16, false, colorSpace);
            assertNotNull(bm);

            assertEquals(ColorSpace.get(Named.EXTENDED_SRGB), bm.getColorSpace());
            assertEquals(DataSpace.ADATASPACE_SCRGB, nGetDataSpace(bm));
        }

        for (ColorSpace colorSpace : new ColorSpace[] {
                ColorSpace.get(Named.LINEAR_SRGB),
                ColorSpace.get(Named.LINEAR_EXTENDED_SRGB),
        }) {
            Bitmap bm = Bitmap.createBitmap(10, 10, Config.RGBA_F16, false, colorSpace);
            assertNotNull(bm);

            assertEquals(ColorSpace.get(Named.LINEAR_EXTENDED_SRGB), bm.getColorSpace());
            assertEquals(DataSpace.ADATASPACE_SCRGB_LINEAR, nGetDataSpace(bm));
        }
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.graphics.cts.BitmapTest"	"testNdkDataSpaceNonExtended"	"CtsGraphicsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/graphics/src/android/graphics/cts/BitmapTest.java"	""	"public void testNdkDataSpaceNonExtended() {
        // In 565 and 8888, these force non-extended.
        for (ColorSpace colorSpace : new ColorSpace[] {
                ColorSpace.get(Named.SRGB),
                ColorSpace.get(Named.EXTENDED_SRGB),
        }) {
            for (Config c: new Config[] { Config.ARGB_8888, Config.RGB_565 }) {
                Bitmap bm = Bitmap.createBitmap(10, 10, c, false, colorSpace);
                assertNotNull(bm);

                assertEquals(ColorSpace.get(Named.SRGB), bm.getColorSpace());
                assertEquals(DataSpace.ADATASPACE_SRGB, nGetDataSpace(bm));
            }
        }

        for (ColorSpace colorSpace : new ColorSpace[] {
                ColorSpace.get(Named.LINEAR_SRGB),
                ColorSpace.get(Named.LINEAR_EXTENDED_SRGB),
        }) {
            for (Config c: new Config[] { Config.ARGB_8888, Config.RGB_565 }) {
                Bitmap bm = Bitmap.createBitmap(10, 10, c, false, colorSpace);
                assertNotNull(bm);

                assertEquals(ColorSpace.get(Named.LINEAR_SRGB), bm.getColorSpace());
                assertEquals(DataSpace.ADATASPACE_SRGB_LINEAR, nGetDataSpace(bm));
            }
        }
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.graphics.cts.BitmapTest"	"testNdkDataSpace"	"CtsGraphicsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/graphics/src/android/graphics/cts/BitmapTest.java"	""	"public void testNdkDataSpace() {
        // DataSpace.ADATASPACEs that do not depend on the Config.
        for (ColorSpace colorSpace : new ColorSpace[] {
                // These have corresponding DataSpace.ADATASPACEs that are independent of the Config
                ColorSpace.get(Named.DISPLAY_P3),
                ColorSpace.get(Named.BT2020),
                ColorSpace.get(Named.ADOBE_RGB),
                ColorSpace.get(Named.BT709),
                ColorSpace.get(Named.DCI_P3),

                // These have no public ADATASPACE.
                ColorSpace.get(Named.ACES),
                ColorSpace.get(Named.ACESCG),
                ColorSpace.get(Named.NTSC_1953),
                ColorSpace.get(Named.PRO_PHOTO_RGB),
                ColorSpace.get(Named.SMPTE_C),
        }) {
            for (Config c: new Config[] { Config.ARGB_8888, Config.RGB_565, Config.RGBA_F16 }) {
                Bitmap bm = Bitmap.createBitmap(10, 10, c, false, colorSpace);
                assertNotNull(bm);

                int dataSpace = nGetDataSpace(bm);
                assertEquals(""Bitmap with "" + c + "" and "" + bm.getColorSpace()
                        + "" has unexpected data space"", DataSpace.fromColorSpace(colorSpace),
                        dataSpace);
            }
        }
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.graphics.cts.BitmapTest"	"testNdkDataSpaceAlpha8"	"CtsGraphicsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/graphics/src/android/graphics/cts/BitmapTest.java"	""	"public void testNdkDataSpaceAlpha8() {
        // ALPHA_8 doesn't support ColorSpaces
        Bitmap bm = Bitmap.createBitmap(10, 10, Config.ALPHA_8);
        assertNotNull(bm);
        assertNull(bm.getColorSpace());
        int dataSpace = nGetDataSpace(bm);
        assertEquals(DataSpace.ADATASPACE_UNKNOWN, dataSpace);
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.graphics.cts.BitmapTest"	"testNdkDataSpaceNullBitmap"	"CtsGraphicsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/graphics/src/android/graphics/cts/BitmapTest.java"	""	"public void testNdkDataSpaceNullBitmap() {
        assertEquals(DataSpace.ADATASPACE_UNKNOWN, nGetDataSpace(null));
    }

    private static native int nGetDataSpace(Bitmap bm);

    // These match the NDK APIs.
    private static final int ANDROID_BITMAP_COMPRESS_FORMAT_JPEG = 0;
    private static final int ANDROID_BITMAP_COMPRESS_FORMAT_PNG = 1;
    private static final int ANDROID_BITMAP_COMPRESS_FORMAT_WEBP_LOSSY = 3;
    private static final int ANDROID_BITMAP_COMPRESS_FORMAT_WEBP_LOSSLESS = 4;

    private int nativeCompressFormat(CompressFormat format) {
        switch (format) {
            case JPEG:
                return ANDROID_BITMAP_COMPRESS_FORMAT_JPEG;
            case PNG:
                return ANDROID_BITMAP_COMPRESS_FORMAT_PNG;
            case WEBP_LOSSY:
                return ANDROID_BITMAP_COMPRESS_FORMAT_WEBP_LOSSY;
            case WEBP_LOSSLESS:
                return ANDROID_BITMAP_COMPRESS_FORMAT_WEBP_LOSSLESS;
            default:
                fail(""format "" + format + "" has no corresponding native compress format!"");
                return -1;
        }
    }

    private static Object[] parametersForNdkCompress() {
        // Skip WEBP, which has no corresponding native compress format.
        Object[] formats = new Object[] {
                CompressFormat.JPEG,
                CompressFormat.PNG,
                CompressFormat.WEBP_LOSSY,
                CompressFormat.WEBP_LOSSLESS,
        };
        // These are the ColorSpaces with corresponding ADataSpaces
        Object[] colorSpaces = new Object[] {
                ColorSpace.get(Named.SRGB),
                ColorSpace.get(Named.EXTENDED_SRGB),
                ColorSpace.get(Named.LINEAR_SRGB),
                ColorSpace.get(Named.LINEAR_EXTENDED_SRGB),

                ColorSpace.get(Named.DISPLAY_P3),
                ColorSpace.get(Named.DCI_P3),
                ColorSpace.get(Named.BT2020),
                ColorSpace.get(Named.BT709),
                ColorSpace.get(Named.ADOBE_RGB),
        };

        Object[] configs = new Object[] {
                Config.ARGB_8888,
                Config.RGB_565,
                Config.RGBA_F16,
        };

        return crossProduct(formats, colorSpaces, configs);
    }

    private static Object[] crossProduct(Object[] a, Object[] b, Object[] c) {
        final int length = a.length * b.length * c.length;
        Object[] ret = new Object[length];
        for (int i = 0; i < a.length; i++) {
            for (int j = 0; j < b.length; j++) {
                for (int k = 0; k < c.length; k++) {
                    int index = i * (b.length * c.length) + j * c.length + k;
                    assertNull(ret[index]);
                    ret[index] = new Object[] { a[i], b[j], c[k] };
                }
            }
        }
        return ret;
    }

    private static boolean isSrgb(ColorSpace cs) {
        return cs == ColorSpace.get(Named.SRGB)
                || cs == ColorSpace.get(Named.EXTENDED_SRGB)
                || cs == ColorSpace.get(Named.LINEAR_SRGB)
                || cs == ColorSpace.get(Named.LINEAR_EXTENDED_SRGB);
    }

    // Helper method for populating a Bitmap with interesting pixels for comparison.
    private static void drawGradient(Bitmap bitmap) {
        // Use different colors and alphas.
        Canvas canvas = new Canvas(bitmap);
        ColorSpace cs = bitmap.getColorSpace();
        if (cs == null) {
            assertSame(Config.ALPHA_8, bitmap.getConfig());
            cs = ColorSpace.get(ColorSpace.Named.SRGB);
        }
        long color0 = Color.pack(0, 0, 1, 1, cs);
        long color1 = Color.pack(1, 0, 0, 0, cs);
        LinearGradient gradient = new LinearGradient(0, 0, 10, 10, color0, color1,
                Shader.TileMode.CLAMP);
        Paint paint = new Paint();
        paint.setShader(gradient);
        canvas.drawPaint(paint);
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.graphics.cts.BitmapTest"	"testNdkCompressBadParameter"	"CtsGraphicsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/graphics/src/android/graphics/cts/BitmapTest.java"	""	"public void testNdkCompressBadParameter() throws IOException {
        try (ByteArrayOutputStream stream = new ByteArrayOutputStream()) {
            nTestNdkCompressBadParameter(mBitmap, stream, new byte[16 * 1024]);
        }
    }

    private static native boolean nCompress(Bitmap bitmap, int format, int quality,
            OutputStream stream, byte[] storage);
    private static native void nTestNdkCompressBadParameter(Bitmap bitmap,
            OutputStream stream, byte[] storage);

    private void strictModeTest(Runnable runnable) {
        StrictMode.ThreadPolicy originalPolicy = StrictMode.getThreadPolicy();
        StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder()
                .detectCustomSlowCalls().penaltyDeath().build());
        try {
            runnable.run();
            fail(""Shouldn't reach it"");
        } catch (RuntimeException expected){
            // expect to receive StrictModeViolation
        } finally {
            StrictMode.setThreadPolicy(originalPolicy);
        }
    }

    private static native void nValidateBitmapInfo(Bitmap bitmap, int width, int height,
            boolean is565);
    private static native void nValidateNdkAccessFails(Bitmap bitmap);

    private static native void nFillRgbaHwBuffer(HardwareBuffer hwBuffer);
    private static native void nTestNullBitmap(Bitmap bitmap);

    private static final int ANDROID_BITMAP_FORMAT_NONE = 0;
    static final int ANDROID_BITMAP_FORMAT_RGBA_8888 = 1;
    private static final int ANDROID_BITMAP_FORMAT_RGB_565 = 4;
    private static final int ANDROID_BITMAP_FORMAT_A_8 = 8;
    private static final int ANDROID_BITMAP_FORMAT_RGBA_F16 = 9;

    private static class ConfigToFormat {
        public final Config config;
        public final int format;

        ConfigToFormat(Config c, int f) {
            this.config = c;
            this.format = f;
        }
    }

    private static int configToFormat(Config config) {
        for (ConfigToFormat pair : CONFIG_TO_FORMAT) {
            if (config == pair.config) {
                return pair.format;
            }
        }
        return ANDROID_BITMAP_FORMAT_NONE;
    }

    private static final ConfigToFormat[] CONFIG_TO_FORMAT = new ConfigToFormat[] {
        new ConfigToFormat(Bitmap.Config.ARGB_8888, ANDROID_BITMAP_FORMAT_RGBA_8888),
        // ARGB_4444 is deprecated, and createBitmap converts to 8888.
        new ConfigToFormat(Bitmap.Config.ARGB_4444, ANDROID_BITMAP_FORMAT_RGBA_8888),
        new ConfigToFormat(Bitmap.Config.RGB_565, ANDROID_BITMAP_FORMAT_RGB_565),
        new ConfigToFormat(Bitmap.Config.ALPHA_8, ANDROID_BITMAP_FORMAT_A_8),
        new ConfigToFormat(Bitmap.Config.RGBA_F16, ANDROID_BITMAP_FORMAT_RGBA_F16),
    };

    static native int nGetFormat(Bitmap bitmap);

    private static native void nTestInfo(Bitmap bm, int androidBitmapFormat, int width, int height,
            boolean hasAlpha, boolean premultiplied, boolean hardware);

    private static HardwareBuffer createTestBuffer(int width, int height, boolean cpuAccess) {
        long usage = HardwareBuffer.USAGE_GPU_SAMPLED_IMAGE;
        if (cpuAccess) {
            usage |= HardwareBuffer.USAGE_CPU_WRITE_RARELY;
        }
        // We can assume that RGBA_8888 format is supported for every platform.
        HardwareBuffer hwBuffer = HardwareBuffer.create(width, height, HardwareBuffer.RGBA_8888,
                1, usage);
        return hwBuffer;
    }

    private static int scaleFromDensity(int size, int sdensity, int tdensity) {
        if (sdensity == Bitmap.DENSITY_NONE || sdensity == tdensity) {
            return size;
        }

        // Scale by tdensity / sdensity, rounding up.
        return ((size * tdensity) + (sdensity >> 1)) / sdensity;
    }

    private static int[] createColors(int size) {
        int[] colors = new int[size];

        for (int i = 0; i < size; i++) {
            colors[i] = (0xFF << 24) | (i << 16) | (i << 8) | i;
        }

        return colors;
    }

    private static BitmapFactory.Options createHardwareBitmapOptions() {
        BitmapFactory.Options options = new BitmapFactory.Options();
        options.inPreferredConfig = Config.HARDWARE;
        return options;
    }
}"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.media.cts.VideoCodecTest"	"testBasic"	"CtsMediaTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/VideoCodecTest.java"	""	"public void test/*
 *.
 */

package android.media.cts;

import android.media.MediaCodec;
import android.media.MediaCodecInfo;
import android.media.MediaCodecList;
import android.media.MediaFormat;
import android.platform.test.annotations.AppModeFull;
import android.util.Log;

import java.io.File;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Arrays;

/**
 * Verification test for video encoder and decoder.
 *
 * A raw yv12 stream is encoded at various settings and written to an IVF
 * file. Encoded stream bitrate and key frame interval are checked against target values.
 * The stream is later decoded by video decoder to verify frames are decodable and to
 * calculate PSNR values for various bitrates.
 */
@MediaHeavyPresubmitTest
@AppModeFull(reason = ""TODO: evaluate and port to instant"")
public class VideoCodecTest extends VideoCodecTestBase {

    private static final String ENCODED_IVF_BASE = ""football"";
    private static final String INPUT_YUV = null;
    private static final String OUTPUT_YUV = SDCARD_DIR + File.separator +
            ENCODED_IVF_BASE + ""_out.yuv"";

    // YUV stream properties.
    private static final int WIDTH = 320;
    private static final int HEIGHT = 240;
    private static final int FPS = 30;
    // Default encoding bitrate.
    private static final int BITRATE = 400000;
    // List of bitrates used in quality and basic bitrate tests.
    private static final int[] TEST_BITRATES_SET = { 300000, 500000, 700000, 900000 };
    // Maximum allowed bitrate variation from the target value.
    // Keep in sync with the variation at libmediandkjni/native_media_utils.h
    // used in some tests along with BITRATE
    private static final double MAX_BITRATE_VARIATION = 0.2;
    // The tolerance varies by the bitrate, because lower bitrates interact with
    // video quality standards introduced in Android 12.
    private static final double[] MAX_CBR_BITRATE_VARIATIONS = { 0.20, 0.20, 0.20, 0.20 };
    private static final double[] MAX_VBR_BITRATE_VARIATIONS = { 0.30, 0.20, 0.20, 0.20 };
    // Average PSNR values for reference Google Video codec for the above bitrates.
    private static final double[] REFERENCE_AVERAGE_PSNR = { 33.1, 35.2, 36.6, 37.8 };
    // Minimum PSNR values for reference Google Video codec for the above bitrates.
    private static final double[] REFERENCE_MINIMUM_PSNR = { 25.9, 27.5, 28.4, 30.3 };
    // Maximum allowed average PSNR difference of encoder comparing to reference Google encoder.
    private static final double MAX_AVERAGE_PSNR_DIFFERENCE = 2;
    // Maximum allowed minimum PSNR difference of encoder comparing to reference Google encoder.
    private static final double MAX_MINIMUM_PSNR_DIFFERENCE = 4;
    // Maximum allowed average PSNR difference of the encoder running in a looper thread with 0 ms
    // buffer dequeue timeout comparing to the encoder running in a callee's thread with 100 ms
    // buffer dequeue timeout.
    private static final double MAX_ASYNC_AVERAGE_PSNR_DIFFERENCE = 1.5;
    // Maximum allowed minimum PSNR difference of the encoder running in a looper thread
    // comparing to the encoder running in a callee's thread.
    private static final double MAX_ASYNC_MINIMUM_PSNR_DIFFERENCE = 2;
    // Maximum allowed average key frame interval variation from the target value.
    private static final int MAX_AVERAGE_KEYFRAME_INTERVAL_VARIATION = 1;
    // Maximum allowed key frame interval variation from the target value.
    private static final int MAX_KEYFRAME_INTERVAL_VARIATION = 3;

    /**
     * A basic test for Video encoder.
     *
     * Encodes 9 seconds of raw stream with default configuration options,
     * and then decodes it to verify the bitstream.
     * Verifies the average bitrate is within allowed MAX_BITRATE_VARIATIONS[] of
     * the target value.
     */
    private void internalTestBasic(String codecMimeType, int bitRateMode) throws Exception {
        int encodeSeconds = 9;
        boolean skipped = true;

        for (int i = 0; i < TEST_BITRATES_SET.length; i++) {
            int targetBitrate = TEST_BITRATES_SET[i];

            EncoderOutputStreamParameters params = getDefaultEncodingParameters(
                    INPUT_YUV,
                    ENCODED_IVF_BASE,
                    codecMimeType,
                    encodeSeconds,
                    WIDTH,
                    HEIGHT,
                    FPS,
                    bitRateMode,
                    targetBitrate,
                    true);
            ArrayList<ByteBuffer> codecConfigs = new ArrayList<>();
            ArrayList<MediaCodec.BufferInfo> bufInfo = encode(params, codecConfigs);
            if (bufInfo == null) {
                continue;
            }
            skipped = false;

            VideoEncodingStatistics statistics = computeEncodingStatistics(bufInfo);

            if (params.bitrateType == VIDEO_ControlRateConstant) {
                /* Constant bitrate -- variation applies to both over/under */
                double allowedVariance = MAX_CBR_BITRATE_VARIATIONS[i];
                assertEquals(""Stream bitrate "" + statistics.mAverageBitrate +
                    "" differs from the target "" + targetBitrate
                    + "" by more than "" + allowedVariance * targetBitrate,
                    targetBitrate, statistics.mAverageBitrate,
                    allowedVariance * targetBitrate);
            } else if (params.bitrateType == VIDEO_ControlRateVariable
                            && statistics.mAverageBitrate > targetBitrate) {
                /* VIDEO_ControlRateVariable mode only checks over-run */
                double allowedVariance = MAX_VBR_BITRATE_VARIATIONS[i];
                assertEquals(""Stream bitrate "" + statistics.mAverageBitrate
                    + "" above target "" + targetBitrate
                    + "" by more than "" + allowedVariance * targetBitrate,
                    targetBitrate, statistics.mAverageBitrate,
                    allowedVariance * targetBitrate);
            }

            decode(params.outputIvfFilename, null, codecMimeType, FPS,
                    params.forceGoogleEncoder, codecConfigs);
        }

        if (skipped) {
            Log.i(TAG, ""SKIPPING testBasic(): codec is not supported"");
        }
    }

    /**
     * Asynchronous encoding test for Video encoder.
     *
     * Encodes 9 seconds of raw stream using synchronous and asynchronous calls.
     * Checks the PSNR difference between the encoded and decoded output and reference yuv input
     * does not change much for two different ways of the encoder call.
     */
    private void internalTestAsyncEncoding(String codecMimeType, int bitRateMode) throws Exception {
        int encodeSeconds = 9;

        // First test the encoder running in a looper thread with buffer callbacks enabled.
        boolean syncEncoding = false;
        EncoderOutputStreamParameters params = getDefaultEncodingParameters(
                INPUT_YUV,
                ENCODED_IVF_BASE,
                codecMimeType,
                encodeSeconds,
                WIDTH,
                HEIGHT,
                FPS,
                bitRateMode,
                BITRATE,
                syncEncoding);
        ArrayList<ByteBuffer> codecConfigs = new ArrayList<>();
        ArrayList<MediaCodec.BufferInfo> bufInfos = encodeAsync(params, codecConfigs);
        if (bufInfos == null) {
            Log.i(TAG, ""SKIPPING testAsyncEncoding(): no suitable encoder found"");
            return;
        }
        computeEncodingStatistics(bufInfos);
        decode(params.outputIvfFilename, OUTPUT_YUV, codecMimeType, FPS,
                params.forceGoogleEncoder, codecConfigs);
        VideoDecodingStatistics statisticsAsync = computeDecodingStatistics(
                params.inputYuvFilename, ""football_qvga.yuv"", OUTPUT_YUV,
                params.frameWidth, params.frameHeight);


        // Test the encoder running in a callee's thread.
        syncEncoding = true;
        params = getDefaultEncodingParameters(
                INPUT_YUV,
                ENCODED_IVF_BASE,
                codecMimeType,
                encodeSeconds,
                WIDTH,
                HEIGHT,
                FPS,
                bitRateMode,
                BITRATE,
                syncEncoding);
        codecConfigs.clear();
        bufInfos = encode(params, codecConfigs);
        if (bufInfos == null) {
            Log.i(TAG, ""SKIPPING testAsyncEncoding(): no suitable encoder found"");
            return;
        }
        computeEncodingStatistics(bufInfos);
        decode(params.outputIvfFilename, OUTPUT_YUV, codecMimeType, FPS,
                params.forceGoogleEncoder, codecConfigs);
        VideoDecodingStatistics statisticsSync = computeDecodingStatistics(
                params.inputYuvFilename, ""football_qvga.yuv"", OUTPUT_YUV,
                params.frameWidth, params.frameHeight);

        // Check PSNR difference.
        Log.d(TAG, ""PSNR Average: Async: "" + statisticsAsync.mAveragePSNR +
                "". Sync: "" + statisticsSync.mAveragePSNR);
        Log.d(TAG, ""PSNR Minimum: Async: "" + statisticsAsync.mMinimumPSNR +
                "". Sync: "" + statisticsSync.mMinimumPSNR);
        if ((Math.abs(statisticsAsync.mAveragePSNR - statisticsSync.mAveragePSNR) >
            MAX_ASYNC_AVERAGE_PSNR_DIFFERENCE) ||
            (Math.abs(statisticsAsync.mMinimumPSNR - statisticsSync.mMinimumPSNR) >
            MAX_ASYNC_MINIMUM_PSNR_DIFFERENCE)) {
            throw new RuntimeException(""Difference between PSNRs for async and sync encoders"");
        }
    }

    /**
     * Check if MediaCodec.PARAMETER_KEY_REQUEST_SYNC_FRAME is honored.
     *
     * Encodes 9 seconds of raw stream and requests a sync frame every second (30 frames).
     * The test does not verify the output stream.
     */
    private void internalTestSyncFrame(
            String codecMimeType, int bitRateMode, boolean useNdk) throws Exception {
        int encodeSeconds = 9;

        EncoderOutputStreamParameters params = getDefaultEncodingParameters(
                INPUT_YUV,
                ENCODED_IVF_BASE,
                codecMimeType,
                encodeSeconds,
                WIDTH,
                HEIGHT,
                FPS,
                bitRateMode,
                BITRATE,
                true);
        params.syncFrameInterval = encodeSeconds * FPS;
        params.syncForceFrameInterval = FPS;
        params.useNdk = useNdk;
        ArrayList<MediaCodec.BufferInfo> bufInfo = encode(params);
        if (bufInfo == null) {
            Log.i(TAG, ""SKIPPING testSyncFrame(): no suitable encoder found"");
            return;
        }

        VideoEncodingStatistics statistics = computeEncodingStatistics(bufInfo);

        // First check if we got expected number of key frames.
        int actualKeyFrames = statistics.mKeyFrames.size();
        if (actualKeyFrames != encodeSeconds) {
            throw new RuntimeException(""Number of key frames "" + actualKeyFrames +
                    "" is different from the expected "" + encodeSeconds);
        }

        // Check key frame intervals:
        // Average value should be within +/- 1 frame of the target value,
        // maximum value should not be greater than target value + 3,
        // and minimum value should not be less that target value - 3.
        if (Math.abs(statistics.mAverageKeyFrameInterval - FPS) >
            MAX_AVERAGE_KEYFRAME_INTERVAL_VARIATION ||
            (statistics.mMaximumKeyFrameInterval - FPS > MAX_KEYFRAME_INTERVAL_VARIATION) ||
            (FPS - statistics.mMinimumKeyFrameInterval > MAX_KEYFRAME_INTERVAL_VARIATION)) {
            throw new RuntimeException(
                    ""Key frame intervals are different from the expected "" + FPS);
        }
    }

    /**
     * Check if MediaCodec.PARAMETER_KEY_VIDEO_BITRATE is honored.
     *
     * Run the the encoder for 12 seconds. Request changes to the
     * bitrate after 6 seconds and ensure the encoder responds.
     */
    private void internalTestDynamicBitrateChange(
            String codecMimeType, int bitRateMode, boolean useNdk) throws Exception {
        int encodeSeconds = 12;    // Encoding sequence duration in seconds.
        int[] bitrateTargetValues = { 400000, 800000 };  // List of bitrates to test.

        EncoderOutputStreamParameters params = getDefaultEncodingParameters(
                INPUT_YUV,
                ENCODED_IVF_BASE,
                codecMimeType,
                encodeSeconds,
                WIDTH,
                HEIGHT,
                FPS,
                bitRateMode,
                bitrateTargetValues[0],
                true);

        // Number of seconds for each bitrate
        int stepSeconds = encodeSeconds / bitrateTargetValues.length;
        // Fill the bitrates values.
        params.bitrateSet = new int[encodeSeconds * FPS];
        for (int i = 0; i < bitrateTargetValues.length ; i++) {
            Arrays.fill(params.bitrateSet,
                    i * encodeSeconds * FPS / bitrateTargetValues.length,
                    (i + 1) * encodeSeconds * FPS / bitrateTargetValues.length,
                    bitrateTargetValues[i]);
        }

        params.useNdk = useNdk;
        ArrayList<MediaCodec.BufferInfo> bufInfo = encode(params);
        if (bufInfo == null) {
            Log.i(TAG, ""SKIPPING testDynamicBitrateChange(): no suitable encoder found"");
            return;
        }

        VideoEncodingStatistics statistics = computeEncodingStatistics(bufInfo);

        // Calculate actual average bitrates  for every [stepSeconds] second.
        int[] bitrateActualValues = new int[bitrateTargetValues.length];
        for (int i = 0; i < bitrateTargetValues.length ; i++) {
            bitrateActualValues[i] = 0;
            for (int j = i * stepSeconds; j < (i + 1) * stepSeconds; j++) {
                bitrateActualValues[i] += statistics.mBitrates.get(j);
            }
            bitrateActualValues[i] /= stepSeconds;
            Log.d(TAG, ""Actual bitrate for interval #"" + i + "" : "" + bitrateActualValues[i] +
                    "". Target: "" + bitrateTargetValues[i]);

            // Compare actual bitrate values to make sure at least same increasing/decreasing
            // order as the target bitrate values.
            for (int j = 0; j < i; j++) {
                long differenceTarget = bitrateTargetValues[i] - bitrateTargetValues[j];
                long differenceActual = bitrateActualValues[i] - bitrateActualValues[j];
                if (differenceTarget * differenceActual < 0) {
                    throw new RuntimeException(""Target bitrates: "" +
                            bitrateTargetValues[j] + "" , "" + bitrateTargetValues[i] +
                            "". Actual bitrates: ""
                            + bitrateActualValues[j] + "" , "" + bitrateActualValues[i]);
                }
            }
        }
    }

     /**
      * Check if encoder and decoder can run simultaneously on different threads.
      *
      * Encodes and decodes 9 seconds of raw stream sequentially in CBR mode,
      * and then run parallel encoding and decoding of the same streams.
      * Compares average bitrate and PSNR for sequential and parallel runs.
      */
     private void internalTestParallelEncodingAndDecoding(String codecMimeType) throws Exception {
         // check for encoder up front, as by the time we detect lack of
         // encoder support, we may have already started decoding.
         MediaCodecList mcl = new MediaCodecList(MediaCodecList.REGULAR_CODECS);
         MediaFormat format = MediaFormat.createVideoFormat(codecMimeType, WIDTH, HEIGHT);
         if (mcl.findEncoderForFormat(format) == null) {
             Log.i(TAG, ""SKIPPING testParallelEncodingAndDecoding(): no suitable encoder found"");
             return;
         }

         int encodeSeconds = 9;
         final int[] bitrate = new int[1];
         final double[] psnr = new double[1];
         final Exception[] exceptionEncoder = new Exception[1];
         final Exception[] exceptionDecoder = new Exception[1];
         final EncoderOutputStreamParameters params = getDefaultEncodingParameters(
                 INPUT_YUV,
                 ENCODED_IVF_BASE,
                 codecMimeType,
                 encodeSeconds,
                 WIDTH,
                 HEIGHT,
                 FPS,
                 VIDEO_ControlRateConstant,
                 BITRATE,
                 true);
         final String inputIvfFilename = params.outputIvfFilename;
         final ArrayList<ByteBuffer> codecConfigs = new ArrayList<>();

         Runnable runEncoder = new Runnable() {
             public void run() {
                 try {
                     ArrayList<MediaCodec.BufferInfo> bufInfo;
                     if (codecConfigs.isEmpty()) {
                         bufInfo = encode(params, codecConfigs);
                     } else {
                         bufInfo = encode(params);
                     }
                     VideoEncodingStatistics statistics = computeEncodingStatistics(bufInfo);
                     bitrate[0] = statistics.mAverageBitrate;
                 } catch (Exception e) {
                     Log.e(TAG, ""Encoder error: "" + e.toString());
                     exceptionEncoder[0] = e;
                 }
             }
         };
         Runnable runDecoder = new Runnable() {
             public void run() {
                 try {
                     decode(inputIvfFilename, OUTPUT_YUV, codecMimeType, FPS,
                            params.forceGoogleEncoder, codecConfigs);
                     VideoDecodingStatistics statistics = computeDecodingStatistics(
                            params.inputYuvFilename, ""football_qvga.yuv"", OUTPUT_YUV,
                            params.frameWidth, params.frameHeight);
                     psnr[0] = statistics.mAveragePSNR;
                 } catch (Exception e) {
                     Log.e(TAG, ""Decoder error: "" + e.toString());
                     exceptionDecoder[0] = e;
                 }
             }
         };

         // Sequential encoding and decoding.
         runEncoder.run();
         if (exceptionEncoder[0] != null) {
             throw exceptionEncoder[0];
         }
         int referenceBitrate = bitrate[0];
         runDecoder.run();
         if (exceptionDecoder[0] != null) {
             throw exceptionDecoder[0];
         }
         double referencePsnr = psnr[0];

         // Parallel encoding and decoding.
         params.outputIvfFilename = SDCARD_DIR + File.separator + ENCODED_IVF_BASE + ""_copy.ivf"";
         Thread threadEncoder = new Thread(runEncoder);
         Thread threadDecoder = new Thread(runDecoder);
         threadEncoder.start();
         threadDecoder.start();
         threadEncoder.join();
         threadDecoder.join();
         if (exceptionEncoder[0] != null) {
             throw exceptionEncoder[0];
         }
         if (exceptionDecoder[0] != null) {
             throw exceptionDecoder[0];
         }

         // Compare bitrates and PSNRs for sequential and parallel cases.
         Log.d(TAG, ""Sequential bitrate: "" + referenceBitrate + "". PSNR: "" + referencePsnr);
         Log.d(TAG, ""Parallel bitrate: "" + bitrate[0] + "". PSNR: "" + psnr[0]);
         assertEquals(""Bitrate for sequenatial encoding"" + referenceBitrate +
                 "" is different from parallel encoding "" + bitrate[0],
                 referenceBitrate, bitrate[0], MAX_BITRATE_VARIATION * referenceBitrate);
         assertEquals(""PSNR for sequenatial encoding"" + referencePsnr +
                 "" is different from parallel encoding "" + psnr[0],
                 referencePsnr, psnr[0], MAX_ASYNC_AVERAGE_PSNR_DIFFERENCE);
     }


    /**
     * Check the encoder quality for various bitrates by calculating PSNR
     *
     * Run the the encoder for 9 seconds for each bitrate and calculate PSNR
     * for each encoded stream.
     * Video streams with higher bitrates should have higher PSNRs.
     * Also compares average and minimum PSNR of codec with PSNR values of reference Google codec.
     */
    private void internalTestEncoderQuality(String codecMimeType, int bitRateMode)
            throws Exception {
        int encodeSeconds = 9;      // Encoding sequence duration in seconds for each bitrate.
        double[] psnrPlatformCodecAverage = new double[TEST_BITRATES_SET.length];
        double[] psnrPlatformCodecMin = new double[TEST_BITRATES_SET.length];
        boolean[] completed = new boolean[TEST_BITRATES_SET.length];
        boolean skipped = true;

        // Run platform specific encoder for different bitrates
        // and compare PSNR of codec with PSNR of reference Google codec.
        for (int i = 0; i < TEST_BITRATES_SET.length; i++) {
            EncoderOutputStreamParameters params = getDefaultEncodingParameters(
                    INPUT_YUV,
                    ENCODED_IVF_BASE,
                    codecMimeType,
                    encodeSeconds,
                    WIDTH,
                    HEIGHT,
                    FPS,
                    bitRateMode,
                    TEST_BITRATES_SET[i],
                    true);
            ArrayList<ByteBuffer> codecConfigs = new ArrayList<>();
            if (encode(params, codecConfigs) == null) {
                // parameters not supported, try other bitrates
                completed[i] = false;
                continue;
            }
            completed[i] = true;
            skipped = false;

            decode(params.outputIvfFilename, OUTPUT_YUV, codecMimeType, FPS,
                    params.forceGoogleEncoder, codecConfigs);
            VideoDecodingStatistics statistics = computeDecodingStatistics(
                    params.inputYuvFilename, ""football_qvga.yuv"", OUTPUT_YUV,
                    params.frameWidth, params.frameHeight);
            psnrPlatformCodecAverage[i] = statistics.mAveragePSNR;
            psnrPlatformCodecMin[i] = statistics.mMinimumPSNR;
        }

        if (skipped) {
            Log.i(TAG, ""SKIPPING testEncoderQuality(): no bitrates supported"");
            return;
        }

        // First do a sanity check - higher bitrates should results in higher PSNR.
        for (int i = 1; i < TEST_BITRATES_SET.length ; i++) {
            if (!completed[i]) {
                continue;
            }
            for (int j = 0; j < i; j++) {
                if (!completed[j]) {
                    continue;
                }
                double differenceBitrate = TEST_BITRATES_SET[i] - TEST_BITRATES_SET[j];
                double differencePSNR = psnrPlatformCodecAverage[i] - psnrPlatformCodecAverage[j];
                if (differenceBitrate * differencePSNR < 0) {
                    throw new RuntimeException(""Target bitrates: "" +
                            TEST_BITRATES_SET[j] + "", "" + TEST_BITRATES_SET[i] +
                            "". Actual PSNRs: ""
                            + psnrPlatformCodecAverage[j] + "", "" + psnrPlatformCodecAverage[i]);
                }
            }
        }

        // Then compare average and minimum PSNR of platform codec with reference Google codec -
        // average PSNR for platform codec should be no more than 2 dB less than reference PSNR
        // and minumum PSNR - no more than 4 dB less than reference minimum PSNR.
        // These PSNR difference numbers are arbitrary for now, will need further estimation
        // when more devices with HW video codec will appear.
        for (int i = 0; i < TEST_BITRATES_SET.length ; i++) {
            if (!completed[i]) {
                continue;
            }

            Log.d(TAG, ""Bitrate "" + TEST_BITRATES_SET[i]);
            Log.d(TAG, ""Reference: Average: "" + REFERENCE_AVERAGE_PSNR[i] + "". Minimum: "" +
                    REFERENCE_MINIMUM_PSNR[i]);
            Log.d(TAG, ""Platform:  Average: "" + psnrPlatformCodecAverage[i] + "". Minimum: "" +
                    psnrPlatformCodecMin[i]);
            if (psnrPlatformCodecAverage[i] < REFERENCE_AVERAGE_PSNR[i] -
                    MAX_AVERAGE_PSNR_DIFFERENCE) {
                throw new RuntimeException(""Low average PSNR "" + psnrPlatformCodecAverage[i] +
                        "" comparing to reference PSNR "" + REFERENCE_AVERAGE_PSNR[i] +
                        "" for bitrate "" + TEST_BITRATES_SET[i]);
            }
            if (psnrPlatformCodecMin[i] < REFERENCE_MINIMUM_PSNR[i] -
                    MAX_MINIMUM_PSNR_DIFFERENCE) {
                throw new RuntimeException(""Low minimum PSNR "" + psnrPlatformCodecMin[i] +
                        "" comparing to reference PSNR "" + REFERENCE_MINIMUM_PSNR[i] +
                        "" for bitrate "" + TEST_BITRATES_SET[i]);
            }
        }
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.media.cts.VideoCodecTest"	"testSyncFrameVP8NdkCBR"	"CtsMediaTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/VideoCodecTest.java"	""	"public void testSyncFrameVP8NdkCBR() throws Exception {
        internalTestSyncFrame(VP8_MIME, VIDEO_ControlRateConstant, true);
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.media.cts.VideoCodecTest"	"testSyncFrameVP8NdkVBR"	"CtsMediaTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/VideoCodecTest.java"	""	"public void testSyncFrameVP8NdkVBR() throws Exception {
        internalTestSyncFrame(VP8_MIME, VIDEO_ControlRateVariable, true);
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.media.cts.VideoCodecTest"	"testSyncFrameVP9NdkCBR"	"CtsMediaTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/VideoCodecTest.java"	""	"public void testSyncFrameVP9NdkCBR() throws Exception {
        internalTestSyncFrame(VP9_MIME, VIDEO_ControlRateConstant, true);
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.media.cts.VideoCodecTest"	"testSyncFrameVP9NdkVBR"	"CtsMediaTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/VideoCodecTest.java"	""	"public void testSyncFrameVP9NdkVBR() throws Exception {
        internalTestSyncFrame(VP9_MIME, VIDEO_ControlRateVariable, true);
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.media.cts.VideoCodecTest"	"testSyncFrameAVCNdkCBR"	"CtsMediaTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/VideoCodecTest.java"	""	"public void testSyncFrameAVCNdkCBR() throws Exception {
        internalTestSyncFrame(AVC_MIME, VIDEO_ControlRateConstant, true);
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.media.cts.VideoCodecTest"	"testSyncFrameAVCNdkVBR"	"CtsMediaTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/VideoCodecTest.java"	""	"public void testSyncFrameAVCNdkVBR() throws Exception {
        internalTestSyncFrame(AVC_MIME, VIDEO_ControlRateVariable, true);
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.media.cts.VideoCodecTest"	"testSyncFrameHEVCNdkCBR"	"CtsMediaTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/VideoCodecTest.java"	""	"public void testSyncFrameHEVCNdkCBR() throws Exception {
        internalTestSyncFrame(HEVC_MIME, VIDEO_ControlRateConstant, true);
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.media.cts.VideoCodecTest"	"testSyncFrameHEVCNdkVBR"	"CtsMediaTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/VideoCodecTest.java"	""	"public void testSyncFrameHEVCNdkVBR() throws Exception {
        internalTestSyncFrame(HEVC_MIME, VIDEO_ControlRateVariable, true);
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.media.cts.VideoCodecTest"	"testDynamicBitrateChangeVP8NdkCBR"	"CtsMediaTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/VideoCodecTest.java"	""	"public void testDynamicBitrateChangeVP8NdkCBR() throws Exception {
        internalTestDynamicBitrateChange(VP8_MIME, VIDEO_ControlRateConstant, true);
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.media.cts.VideoCodecTest"	"testDynamicBitrateChangeVP8NdkVBR"	"CtsMediaTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/VideoCodecTest.java"	""	"public void testDynamicBitrateChangeVP8NdkVBR() throws Exception {
        internalTestDynamicBitrateChange(VP8_MIME, VIDEO_ControlRateVariable, true);
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.media.cts.VideoCodecTest"	"testDynamicBitrateChangeVP9NdkCBR"	"CtsMediaTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/VideoCodecTest.java"	""	"public void testDynamicBitrateChangeVP9NdkCBR() throws Exception {
        internalTestDynamicBitrateChange(VP9_MIME, VIDEO_ControlRateConstant, true);
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.media.cts.VideoCodecTest"	"testDynamicBitrateChangeVP9NdkVBR"	"CtsMediaTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/VideoCodecTest.java"	""	"public void testDynamicBitrateChangeVP9NdkVBR() throws Exception {
        internalTestDynamicBitrateChange(VP9_MIME, VIDEO_ControlRateVariable, true);
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.media.cts.VideoCodecTest"	"testDynamicBitrateChangeAVCNdkCBR"	"CtsMediaTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/VideoCodecTest.java"	""	"public void testDynamicBitrateChangeAVCNdkCBR() throws Exception {
        internalTestDynamicBitrateChange(AVC_MIME, VIDEO_ControlRateConstant, true);
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.media.cts.VideoCodecTest"	"testDynamicBitrateChangeAVCNdkVBR"	"CtsMediaTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/VideoCodecTest.java"	""	"public void testDynamicBitrateChangeAVCNdkVBR() throws Exception {
        internalTestDynamicBitrateChange(AVC_MIME, VIDEO_ControlRateVariable, true);
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.media.cts.VideoCodecTest"	"testDynamicBitrateChangeHEVCNdkCBR"	"CtsMediaTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/VideoCodecTest.java"	""	"public void testDynamicBitrateChangeHEVCNdkCBR() throws Exception {
        internalTestDynamicBitrateChange(HEVC_MIME, VIDEO_ControlRateConstant, true);
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.media.cts.VideoCodecTest"	"testDynamicBitrateChangeHEVCNdkVBR"	"CtsMediaTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/VideoCodecTest.java"	""	"public void testDynamicBitrateChangeHEVCNdkVBR() throws Exception {
        internalTestDynamicBitrateChange(HEVC_MIME, VIDEO_ControlRateVariable, true);
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.widget.cts.TabHostTest"	"testKeyboardNavigation"	"CtsWidgetTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TabHostTest.java"	""	"public void testKeyboardNavigation() throws Throwable {
        mActivityRule.runOnUiThread(() -> {
            mActivity.setContentView(R.layout.tabhost_focus);
            TabHost tabHost = mActivity.findViewById(android.R.id.tabhost);
            tabHost.setup();
            TabSpec spec = tabHost.newTabSpec(""Tab 1"");
            spec.setContent(R.id.tab1);
            spec.setIndicator(""Tab 1"");
            tabHost.addTab(spec);
            spec = tabHost.newTabSpec(""Tab 2"");
            spec.setContent(R.id.tab2);
            spec.setIndicator(""Tab 2"");
            tabHost.addTab(spec);
            View topBut = mActivity.findViewById(R.id.before_button);
            topBut.requestFocus();
            assertTrue(topBut.isFocused());
        });
        mInstrumentation.waitForIdleSync();
        mInstrumentation.sendKeyDownUpSync(KeyEvent.KEYCODE_TAB);
        View tabs = mActivity.findViewById(android.R.id.tabs);
        assertTrue(tabs.hasFocus());
        View firstTab = tabs.findFocus();
        mInstrumentation.sendKeyDownUpSync(KeyEvent.KEYCODE_TAB);
        assertTrue(tabs.hasFocus());
        int[] shiftKey = new int[]{KeyEvent.KEYCODE_SHIFT_LEFT};
        sendKeyComboSync(KeyEvent.KEYCODE_TAB, shiftKey);
        assertTrue(tabs.hasFocus());
        mInstrumentation.sendKeyDownUpSync(KeyEvent.KEYCODE_TAB);
        assertTrue(tabs.hasFocus());

        // non-navigation sends focus to content
        mInstrumentation.sendKeyDownUpSync(KeyEvent.KEYCODE_E);
        assertTrue(mActivity.findViewById(R.id.tab1_button).isFocused());
        sendKeyComboSync(KeyEvent.KEYCODE_TAB, shiftKey);
        assertTrue(tabs.hasFocus());

        mActivityRule.runOnUiThread(() -> firstTab.requestFocus());
        mInstrumentation.waitForIdleSync();
        sendKeyComboSync(KeyEvent.KEYCODE_TAB, shiftKey);
        assertTrue(mActivity.findViewById(R.id.before_button).isFocused());
    }

    private class MyTabContentFactoryText implements TabHost.TabContentFactory {
        public View createTabContent(String tag) {
            final TextView tv = new TextView(mActivity);
            tv.setText(tag);
            return tv;
        }
    }

    private class MyTabContentFactoryList implements TabHost.TabContentFactory {
        public View createTabContent(String tag) {
            final ListView lv = new ListView(mActivity);
            return lv;
        }
    }

    private static int metaFromKey(int keyCode) {
        switch(keyCode) {
            case KeyEvent.KEYCODE_ALT_LEFT: return KeyEvent.META_ALT_LEFT_ON;
            case KeyEvent.KEYCODE_ALT_RIGHT: return KeyEvent.META_ALT_RIGHT_ON;
            case KeyEvent.KEYCODE_SHIFT_LEFT: return KeyEvent.META_SHIFT_LEFT_ON;
            case KeyEvent.KEYCODE_SHIFT_RIGHT: return KeyEvent.META_SHIFT_RIGHT_ON;
            case KeyEvent.KEYCODE_CTRL_LEFT: return KeyEvent.META_CTRL_LEFT_ON;
            case KeyEvent.KEYCODE_CTRL_RIGHT: return KeyEvent.META_CTRL_RIGHT_ON;
            case KeyEvent.KEYCODE_META_LEFT: return KeyEvent.META_META_LEFT_ON;
            case KeyEvent.KEYCODE_META_RIGHT: return KeyEvent.META_META_RIGHT_ON;
        }
        return 0;
    }

    /**
     * High-level method for sending a chorded key-combo (modifiers + key). This will send all the
     * down and up key events as a user would press them (ie. all the modifiers get their own
     * down and up events).
     *
     * @param keyCode The keycode to send while all meta keys are pressed.
     * @param metaKeys An array of meta key *keycodes* (not modifiers).
     */
    private void sendKeyComboSync(int keyCode, int[] metaKeys) {
        int metaState = 0;
        if (metaKeys != null) {
            for (int mk = 0; mk < metaKeys.length; ++mk) {
                metaState |= metaFromKey(metaKeys[mk]);
                mInstrumentation.sendKeySync(new KeyEvent(0, 0, KeyEvent.ACTION_DOWN, metaKeys[mk],
                        0, KeyEvent.normalizeMetaState(metaState)));
            }
        }
        mInstrumentation.sendKeySync(new KeyEvent(0, 0, KeyEvent.ACTION_DOWN, keyCode, 0,
                KeyEvent.normalizeMetaState(metaState)));
        mInstrumentation.sendKeySync(new KeyEvent(0, 0, KeyEvent.ACTION_UP, keyCode, 0,
                KeyEvent.normalizeMetaState(metaState)));
        if (metaKeys != null) {
            for (int mk = 0; mk < metaKeys.length; ++mk) {
                metaState &= ~metaFromKey(metaKeys[mk]);
                mInstrumentation.sendKeySync(new KeyEvent(0, 0, KeyEvent.ACTION_UP, metaKeys[mk], 0,
                        KeyEvent.normalizeMetaState(metaState)));
            }
        }
    }
}"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"com.android.cts.atracetestapp.AtraceDeviceTests"	"assertTracingOn"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/atrace/AtraceTestApp/src/com/android/cts/atracetestapp/AtraceDeviceTests.java"	""	"public void assertTracingOn() {
        assertTrue(Trace.isEnabled());
        assertTrue(AtraceNdkMethods.isEnabled());
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"com.android.cts.atracetestapp.AtraceDeviceTests"	"assertTracingOff"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/atrace/AtraceTestApp/src/com/android/cts/atracetestapp/AtraceDeviceTests.java"	""	"public void assertTracingOff() {
        assertFalse(Trace.isEnabled());
        assertFalse(AtraceNdkMethods.isEnabled());
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"com.android.cts.atracetestapp.AtraceDeviceTests"	"isEnabled"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/atrace/AtraceTestApp/src/com/android/cts/atracetestapp/AtraceDeviceTests.java"	""	"public void counter() {
        assertTrue(Trace.isEnabled());
        assertTrue(AtraceNdkMethods.isEnabled());
        Trace.setCounter(""AtraceDeviceTest::counter"", 10);
        Trace.setCounter(""AtraceDeviceTest::counter"", 20);
        Trace.setCounter(""AtraceDeviceTest::counter"", 30);
        Trace.setCounter(""AtraceDeviceTest::counter"", 9223372000000005807L);
        AtraceNdkMethods.counter();
    }"	""	""	"NDK NDK NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.jni.cts.LinkerNamespacesHelper"	"exists"	"CtsJniTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/jni/src/android/jni/cts/LinkerNamespacesHelper.java"	""	"public void test/*
 *.
 */

package android.jni.cts;

import android.content.pm.ApplicationInfo;
import android.content.pm.PackageManager;
import android.content.pm.PackageManager.NameNotFoundException;
import android.os.Build;

import androidx.test.InstrumentationRegistry;

import dalvik.system.PathClassLoader;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.FilenameFilter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

class LinkerNamespacesHelper {
    private final static String PUBLIC_CONFIG_DIR = ""/system/etc/"";
    private final static String PRODUCT_CONFIG_DIR = ""/product/etc/"";
    private final static String SYSTEM_CONFIG_FILE = PUBLIC_CONFIG_DIR + ""public.libraries.txt"";
    private final static Pattern EXTENSION_CONFIG_FILE_PATTERN = Pattern.compile(
            ""public\\.libraries-([A-Za-z0-9\\-_.]+)\\.txt"");
    private final static String VENDOR_CONFIG_FILE = ""/vendor/etc/public.libraries.txt"";
    private final static String[] PUBLIC_SYSTEM_LIBRARIES = {
        ""libaaudio.so"",
        ""libamidi.so"",
        ""libandroid.so"",
        ""libbinder_ndk.so"",
        ""libc.so"",
        ""libcamera2ndk.so"",
        ""libdl.so"",
        ""libEGL.so"",
        ""libGLESv1_CM.so"",
        ""libGLESv2.so"",
        ""libGLESv3.so"",
        ""libjnigraphics.so"",
        ""liblog.so"",
        ""libmediandk.so"",
        ""libm.so"",
        ""libnativewindow.so"",
        ""libOpenMAXAL.so"",
        ""libOpenSLES.so"",
        ""libRS.so"",
        ""libstdc++.so"",
        ""libsync.so"",
        ""libvulkan.so"",
        ""libz.so""
    };

    // System libraries that may exist in some types of builds.
    private final static String[] OPTIONAL_SYSTEM_LIBRARIES = {
      ""libclang_rt.hwasan-aarch64-android.so""
    };

    // Libraries listed in public.libraries.android.txt that are located in APEXes
    private final static String[] PUBLIC_APEX_LIBRARIES = {
        // Libraries in /apex/com.android.i18n/${LIB}
        ""libicu.so"",
        ""libicui18n.so"",
        ""libicuuc.so"",
        // Libraries in /apex/com.android.art/${LIB}
        ""libnativehelper.so"",
        // Libraries in /apex/com.android.neuralnetworks/${LIB}
        ""libneuralnetworks.so"",
    };

    // The grey-list.
    private final static String[] PRIVATE_SYSTEM_LIBRARIES = {
        ""libandroid_runtime.so"",
        ""libbinder.so"",
        ""libcrypto.so"",
        ""libcutils.so"",
        ""libexpat.so"",
        ""libgui.so"",
        ""libmedia.so"",
        ""libskia.so"",
        ""libssl.so"",
        ""libstagefright.so"",
        ""libsqlite.so"",
        ""libui.so"",
        ""libutils.so"",
        ""libvorbisidec.so"",
    };

    private final static String WEBVIEW_PLAT_SUPPORT_LIB = ""libwebviewchromium_plat_support.so"";

    static enum Bitness { ALL, ONLY_32, ONLY_64 }

    private static List<String> readPublicLibrariesFile(File file) throws IOException {
        List<String> libs = new ArrayList<>();
        if (file.exists()) {
            try (BufferedReader br = new BufferedReader(new FileReader(file))) {
                String line;
                final boolean is64Bit = android.os.Process.is64Bit();
                while ((line = br.readLine()) != null) {
                    line = line.trim();
                    if (line.isEmpty() || line.startsWith(""#"")) {
                        continue;
                    }
                    String[] tokens = line.split("" "");
                    if (tokens.length < 1 || tokens.length > 3) {
                        throw new RuntimeException(""Malformed line: '"" + line + ""' in "" + file);
                    }
                    String soname = tokens[0];
                    Bitness bitness = Bitness.ALL;
                    int i = tokens.length;
                    while(--i >= 1) {
                        if (tokens[i].equals(""nopreload"")) {
                            continue;
                        }
                        else if (tokens[i].equals(""32"") || tokens[i].equals(""64"")) {
                            if (bitness != Bitness.ALL) {
                                throw new RuntimeException(""Malformed line: '"" + line +
                                        ""' in "" + file + "". Bitness can be specified only once"");
                            }
                            bitness = tokens[i].equals(""32"") ? Bitness.ONLY_32 : Bitness.ONLY_64;
                        } else {
                            throw new RuntimeException(""Unrecognized token '"" + tokens[i] +
                                  ""' in "" + file);
                        }
                    }
                    if ((is64Bit && bitness == Bitness.ONLY_32) ||
                        (!is64Bit && bitness == Bitness.ONLY_64)) {
                        // skip unsupported bitness
                        continue;
                    }
                    libs.add(soname);
                }
            }
        }
        return libs;
    }

    private static String readExtensionConfigFiles(String configDir, List<String> libs) throws IOException {
        File[] configFiles = new File(configDir).listFiles(
                new FilenameFilter() {
                    public boolean accept(File dir, String name) {
                        return EXTENSION_CONFIG_FILE_PATTERN.matcher(name).matches();
                    }
                });
        if (configFiles == null) return null;

        for (File configFile: configFiles) {
            String fileName = configFile.toPath().getFileName().toString();
            Matcher configMatcher = EXTENSION_CONFIG_FILE_PATTERN.matcher(fileName);
            if (configMatcher.matches()) {
                String companyName = configMatcher.group(1);
                // a lib in public.libraries-acme.txt should be
                // libFoo.acme.so
                List<String> libNames = readPublicLibrariesFile(configFile);
                for (String lib : libNames) {
                    if (lib.endsWith(""."" + companyName + "".so"")) {
                        libs.add(lib);
                    } else {
                        return ""Library \"""" + lib + ""\"" in "" + configFile.toString()
                                + "" must have company name "" + companyName + "" as suffix."";
                    }
                }
            }
        }
        return null;
    }

    public static String runAccessibilityTest() throws IOException {
        List<String> systemLibs = new ArrayList<>();
        List<String> apexLibs = new ArrayList<>();

        Collections.addAll(systemLibs, PUBLIC_SYSTEM_LIBRARIES);
        Collections.addAll(systemLibs, OPTIONAL_SYSTEM_LIBRARIES);
        // System path could contain public ART libraries on foreign arch. http://b/149852946
        if (isForeignArchitecture()) {
            Collections.addAll(systemLibs, PUBLIC_APEX_LIBRARIES);
        }

        if (InstrumentationRegistry.getContext().getPackageManager().
                hasSystemFeature(PackageManager.FEATURE_WEBVIEW)) {
            systemLibs.add(WEBVIEW_PLAT_SUPPORT_LIB);
        }

        Collections.addAll(apexLibs, PUBLIC_APEX_LIBRARIES);

        // Check if /system/etc/public.libraries-company.txt and /product/etc/public.libraries
        // -company.txt files are well-formed. The libraries however are not loaded for test;
        // It is done in another test CtsUsesNativeLibraryTest because since Android S those libs
        // are not available unless they are explicited listed in the app manifest.

        List<String> oemLibs = new ArrayList<>();
        String oemLibsError = readExtensionConfigFiles(PUBLIC_CONFIG_DIR, oemLibs);
        if (oemLibsError != null) return oemLibsError;

        // PRODUCT libs that passed are also available
        List<String> productLibs = new ArrayList<>();
        String productLibsError = readExtensionConfigFiles(PRODUCT_CONFIG_DIR, productLibs);
        if (productLibsError != null) return productLibsError;

        // Make sure that the libs in grey-list are not exposed to apps. In fact, it
        // would be better for us to run this check against all system libraries which
        // are not NDK libs, but grey-list libs are enough for now since they have been
        // the most popular violators.
        Set<String> greyListLibs = new HashSet<>();
        Collections.addAll(greyListLibs, PRIVATE_SYSTEM_LIBRARIES);
        // Note: check for systemLibs isn't needed since we already checked
        // /system/etc/public.libraries.txt against NDK and
        // /system/etc/public.libraries-<company>.txt against lib<name>.<company>.so.
        List<String> vendorLibs = readPublicLibrariesFile(new File(VENDOR_CONFIG_FILE));
        for (String lib : vendorLibs) {
            if (greyListLibs.contains(lib)) {
                return ""Internal library \"""" + lib + ""\"" must not be available to apps."";
            }
        }

        return runAccessibilityTestImpl(systemLibs.toArray(new String[systemLibs.size()]),
                                        apexLibs.toArray(new String[apexLibs.size()]));
    }

    private static native String runAccessibilityTestImpl(String[] publicSystemLibs,
                                                          String[] publicApexLibs);

    private static void invokeIncrementGlobal(Class<?> clazz) throws Exception {
        clazz.getMethod(""incrementGlobal"").invoke(null);
    }
    private static int invokeGetGlobal(Class<?> clazz) throws Exception  {
        return (Integer)clazz.getMethod(""getGlobal"").invoke(null);
    }

    private static ApplicationInfo getApplicationInfo(String packageName) {
        PackageManager pm = InstrumentationRegistry.getContext().getPackageManager();
        try {
            return pm.getApplicationInfo(packageName, 0);
        } catch (NameNotFoundException nnfe) {
            throw new RuntimeException(nnfe);
        }
    }

    private static String getSourcePath(String packageName) {
        String sourcePath = getApplicationInfo(packageName).sourceDir;
        if (sourcePath == null) {
            throw new IllegalStateException(""No source path path found for "" + packageName);
        }
        return sourcePath;
    }

    private static String getNativePath(String packageName) {
        String nativePath = getApplicationInfo(packageName).nativeLibraryDir;
        if (nativePath == null) {
            throw new IllegalStateException(""No native path path found for "" + packageName);
        }
        return nativePath;
    }

    private static boolean isAlreadyOpenedError(UnsatisfiedLinkError e, String libFilePath) {
        // If one of the public system libraries are already opened in the bootclassloader, consider
        // this try as success, because dlopen to the lib is successful.
        String baseName = new File(libFilePath).getName();
        return e.getMessage().contains(""Shared library \"""" + libFilePath +
            ""\"" already opened by ClassLoader"") &&
            Arrays.asList(PUBLIC_SYSTEM_LIBRARIES).contains(baseName);
    }

    private static String loadWithSystemLoad(String libFilePath) {
        try {
            System.load(libFilePath);
        } catch (UnsatisfiedLinkError e) {
            // all other exceptions are just thrown
            if (!isAlreadyOpenedError(e, libFilePath)) {
                return ""System.load() UnsatisfiedLinkError: "" + e.getMessage();
            }
        }
        return """";
    }

    private static String loadWithSystemLoadLibrary(String libFileName) {
        // Drop 'lib' and '.so' from the base name
        String libName = libFileName.substring(3, libFileName.length()-3);
        try {
            System.loadLibrary(libName);
        } catch (UnsatisfiedLinkError e) {
            if (!isAlreadyOpenedError(e, libFileName)) {
                return ""System.loadLibrary(\"""" + libName + ""\"") UnsatisfiedLinkError: "" +
                    e.getMessage();
            }
        }
        return """";
    }

    // Verify the behaviour of native library loading in class loaders.
    // In this test:
    //    - libjninamespacea1, libjninamespacea2 and libjninamespaceb depend on libjnicommon
    //    - loaderA will load ClassNamespaceA1 (loading libjninamespacea1)
    //    - loaderA will load ClassNamespaceA2 (loading libjninamespacea2)
    //    - loaderB will load ClassNamespaceB (loading libjninamespaceb)
    //    - incrementGlobal/getGlobal operate on a static global from libjnicommon
    //      and each class should get its own view on it.
    //
    // This is a test case for 2 different scenarios:
    //    - loading native libraries in different class loaders
    //    - loading native libraries in the same class loader
    // Ideally we would have 2 different tests but JNI doesn't allow loading the same library in
    // different class loaders. So to keep the number of native libraries manageable we just
    // re-use the same class loaders for the two tests.
    public static String runClassLoaderNamespaces() throws Exception {
        // Test for different class loaders.
        // Verify that common dependencies get a separate copy in each class loader.
        // libjnicommon should be loaded twice:
        // in the namespace for loaderA and the one for loaderB.
        String apkPath = getSourcePath(""android.jni.cts"");
        String nativePath = getNativePath(""android.jni.cts"");
        PathClassLoader loaderA = new PathClassLoader(
                apkPath, nativePath, ClassLoader.getSystemClassLoader());
        Class<?> testA1Class = loaderA.loadClass(""android.jni.cts.ClassNamespaceA1"");
        PathClassLoader loaderB = new PathClassLoader(
                apkPath, nativePath, ClassLoader.getSystemClassLoader());
        Class<?> testBClass = loaderB.loadClass(""android.jni.cts.ClassNamespaceB"");

        int globalA1 = invokeGetGlobal(testA1Class);
        int globalB = invokeGetGlobal(testBClass);
        if (globalA1 != 0 || globalB != 0) {
            return ""Expected globals to be 0/0: globalA1="" + globalA1 + "" globalB="" + globalB;
        }

        invokeIncrementGlobal(testA1Class);
        globalA1 = invokeGetGlobal(testA1Class);
        globalB = invokeGetGlobal(testBClass);
        if (globalA1 != 1 || globalB != 0) {
            return ""Expected globals to be 1/0: globalA1="" + globalA1 + "" globalB="" + globalB;
        }

        invokeIncrementGlobal(testBClass);
        globalA1 = invokeGetGlobal(testA1Class);
        globalB = invokeGetGlobal(testBClass);
        if (globalA1 != 1 || globalB != 1) {
            return ""Expected globals to be 1/1: globalA1="" + globalA1 + "" globalB="" + globalB;
        }

        // Test for the same class loaders.
        // Verify that if we load ClassNamespaceA2 into loaderA we get the same view on the
        // globals.
        Class<?> testA2Class = loaderA.loadClass(""android.jni.cts.ClassNamespaceA2"");

        int globalA2 = invokeGetGlobal(testA2Class);
        if (globalA1 != 1 || globalA2 !=1) {
            return ""Expected globals to be 1/1: globalA1="" + globalA1 + "" globalA2="" + globalA2;
        }

        invokeIncrementGlobal(testA1Class);
        globalA1 = invokeGetGlobal(testA1Class);
        globalA2 = invokeGetGlobal(testA2Class);
        if (globalA1 != 2 || globalA2 != 2) {
            return ""Expected globals to be 2/2: globalA1="" + globalA1 + "" globalA2="" + globalA2;
        }

        invokeIncrementGlobal(testA2Class);
        globalA1 = invokeGetGlobal(testA1Class);
        globalA2 = invokeGetGlobal(testA2Class);
        if (globalA1 != 3 || globalA2 != 3) {
            return ""Expected globals to be 2/2: globalA1="" + globalA1 + "" globalA2="" + globalA2;
        }
        // On success we return null.
        return null;
    }

    public static String runDlopenPublicLibraries() {
        String error = null;
        List<String> publicLibs = new ArrayList<>();
        Collections.addAll(publicLibs, PUBLIC_SYSTEM_LIBRARIES);
        Collections.addAll(publicLibs, PUBLIC_APEX_LIBRARIES);
        for (String lib : publicLibs) {
            String result = LinkerNamespacesHelper.tryDlopen(lib);
            if (result != null) {
                if (error == null) {
                    error = """";
                }
                error += result + ""\n"";
            }
        }
        return error;
    }

    public static native String tryDlopen(String lib);

    private static boolean isForeignArchitecture() {
        int libAbi = getLibAbi();
        String cpuAbi = android.os.SystemProperties.get(""ro.product.cpu.abi"");
        if ((libAbi == 1 || libAbi == 2) && !cpuAbi.startsWith(""arm"")) {
            return true;
        } else if ((libAbi == 3 || libAbi == 4) && !cpuAbi.startsWith(""x86"")) {
            return true;
        }
        return false;
    }

    /**
     * @return ABI type of the JNI library. 1: ARM64, 2:ARM, 3: x86_64, 4: x86, 0: others
     */
    private static native int getLibAbi();
}

class ClassNamespaceA1 {
    static {
        System.loadLibrary(""jninamespacea1"");
    }

    public static native void incrementGlobal();
    public static native int getGlobal();
}

class ClassNamespaceA2 {
    static {
        System.loadLibrary(""jninamespacea2"");
    }

    public static native void incrementGlobal();
    public static native int getGlobal();
}

class ClassNamespaceB {
    static {
        System.loadLibrary(""jninamespaceb"");
    }

    public static native void incrementGlobal();
    public static native int getGlobal();
}"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.media.cts.NdkInputSurface"	"eglGetDisplay"	""	"/home/gpoor/cts-12-source/cts/tests/tests/media/common/src/android/media/cts/NdkInputSurface.java"	""	"public void test/*
 *.
 */

package android.media.cts;

import android.media.MediaCodec;
import android.util.Log;

public class NdkInputSurface implements InputSurfaceInterface {

    private static final String TAG = NdkInputSurface.class.getName();

    private long mNativeWindow;
    private long mEGLDisplay;
    private long mEGLConfig;
    private long mEGLContext;
    private long mEGLSurface;
    private int mWidth, mHeight;

    static private native long eglGetDisplay();
    static private native long eglChooseConfig(long eglDisplay);
    static private native long eglCreateContext(long eglDisplay, long eglConfig);
    static private native long createEGLSurface(long eglDisplay, long eglConfig, long nativeWindow);
    static private native boolean eglMakeCurrent(long eglDisplay, long eglSurface, long eglContext);
    static private native boolean eglSwapBuffers(long eglDisplay, long eglSurface);
    static private native boolean eglPresentationTimeANDROID(long eglDisplay, long eglSurface, long nsecs);
    static private native int eglGetWidth(long eglDisplay, long eglSurface);
    static private native int eglGetHeight(long eglDisplay, long eglSurface);
    static private native boolean eglDestroySurface(long eglDisplay, long eglSurface);
    static private native void nativeRelease(long eglDisplay, long eglSurface, long eglContext, long nativeWindow);

    public NdkInputSurface(long nativeWindow) {

        mNativeWindow = nativeWindow;

        mEGLDisplay = eglGetDisplay();
        if (mEGLDisplay == 0) {
            throw new RuntimeException(""unable to get EGL14 display"");
        }

        mEGLConfig = eglChooseConfig(mEGLDisplay);
        if (mEGLConfig == 0) {
            throw new RuntimeException(""unable to find RGB888+recordable ES2 EGL config"");
        }

        mEGLContext = eglCreateContext(mEGLDisplay, mEGLConfig);
        if (mEGLContext == 0) {
            throw new RuntimeException(""null context"");
        }

        mEGLSurface = createEGLSurface(mEGLDisplay, mEGLConfig, mNativeWindow);
        if (mEGLSurface == 0) {
            throw new RuntimeException(""surface was null"");
        }

        mWidth = eglGetWidth(mEGLDisplay, mEGLSurface);
        mHeight = eglGetHeight(mEGLDisplay, mEGLSurface);

    }

    @Override
    public void makeCurrent() {
        if (!eglMakeCurrent(mEGLDisplay, mEGLSurface, mEGLContext)) {
            throw new RuntimeException(""eglMakeCurrent failed"");
        }
    }

    @Override
    public boolean swapBuffers() {
        return eglSwapBuffers(mEGLDisplay, mEGLSurface);
    }

    @Override
    public void setPresentationTime(long nsecs) {
        eglPresentationTimeANDROID(mEGLDisplay, mEGLSurface, nsecs);
    }

    @Override
    public void configure(MediaCodec codec) {
        throw new UnsupportedOperationException(codec.toString());
    }

    @Override
    public void configure(NdkMediaCodec codec) {
        codec.setInputSurface(mNativeWindow);
    }

    @Override
    public void updateSize(int width, int height) {
        if (width != mWidth || height != mHeight) {
            Log.d(TAG, ""re-create EGLSurface"");
            releaseEGLSurface();
            mEGLSurface = createEGLSurface(mEGLDisplay, mEGLConfig, mNativeWindow);
            mWidth = eglGetWidth(mEGLDisplay, mEGLSurface);
            mHeight = eglGetHeight(mEGLDisplay, mEGLSurface);
        }
    }

    private void releaseEGLSurface() {
        if (mEGLDisplay != 0) {
            eglDestroySurface(mEGLDisplay, mEGLSurface);
            mEGLSurface = 0;
        }
    }

    @Override
    public void release() {

        nativeRelease(mEGLDisplay, mEGLSurface, mEGLContext, mNativeWindow);

        mEGLDisplay = 0;
        mEGLContext = 0;
        mEGLSurface = 0;
        mNativeWindow = 0;

    }

}"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.hardware.camera2.cts.CameraManagerTest"	"testCameraManagerGetCameraCharacteristics"	"CtsCameraTestCases"	"/home/gpoor/cts-12-source/cts/tests/camera/src/android/hardware/camera2/cts/CameraManagerTest.java"	""	"public void testCameraManagerGetCameraCharacteristics() throws Exception {
        String[] ids = mCameraIdsUnderTest;
        for (int i = 0; i < ids.length; i++) {
            CameraCharacteristics props = mCameraManager.getCameraCharacteristics(ids[i]);
            assertNotNull(
                    String.format(""Can't get camera characteristics from: ID %s"", ids[i]), props);
        }
    }

    // Test: that properties queried between the Java SDK and the C++ NDK are equivalent."	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.hardware.camera2.cts.CameraManagerTest"	"testCameraCharacteristicsNdkFromSdk"	"CtsCameraTestCases"	"/home/gpoor/cts-12-source/cts/tests/camera/src/android/hardware/camera2/cts/CameraManagerTest.java"	""	"public void testCameraCharacteristicsNdkFromSdk() throws Exception {
        String[] ids = mCameraIdsUnderTest;
        for (int i = 0; i < ids.length; i++) {
            CameraCharacteristics props = mCameraManager.getCameraCharacteristics(ids[i]);
            Integer lensFacing = props.get(CameraCharacteristics.LENS_FACING);
            assertNotNull(""Can't get lens facing info"", lensFacing);

            assertTrue(validateACameraMetadataFromCameraMetadataCriticalTagsNative(
                props, lensFacing.intValue()));
        }
    }

    // Returns true if `props` has lens facing `lensFacing` when queried from the NDK via
    // ACameraMetadata_fromCameraMetadata().
    private static native boolean validateACameraMetadataFromCameraMetadataCriticalTagsNative(
        CameraCharacteristics props, int lensFacing);

    // Test: that an exception is thrown if an invalid device id is passed down."	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.jobscheduler.cts.JobThrottlingTest"	"testForegroundJobsStartImmediately"	"CtsJobSchedulerTestCases"	"/home/gpoor/cts-12-source/cts/tests/JobScheduler/src/android/jobscheduler/cts/JobThrottlingTest.java"	""	"public void testForegroundJobsStartImmediately() throws Exception {
        assumeTrue(""device idle not enabled"", mDeviceIdleEnabled);

        sendScheduleJobBroadcast(false);
        runJob();
        assertTrue(""Job did not start after scheduling"",
                mTestAppInterface.awaitJobStart(DEFAULT_WAIT_TIMEOUT));
        toggleDozeState(true);
        assertTrue(""Job did not stop on entering doze"",
                mTestAppInterface.awaitJobStop(DEFAULT_WAIT_TIMEOUT));
        Thread.sleep(TestJobSchedulerReceiver.JOB_INITIAL_BACKOFF);
        // The adb command will force idle even with the screen on, so we need to turn Doze off
        // explicitly.
        toggleDozeState(false);
        // Turn the screen on to ensure the test app ends up in TOP.
        setScreenState(true);
        mTestAppInterface.startAndKeepTestActivity();
        assertTrue(""Job for foreground app did not start immediately when device exited doze"",
                mTestAppInterface.awaitJobStart(DEFAULT_WAIT_TIMEOUT));
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.jobscheduler.cts.JobThrottlingTest"	"testRestrictedJobAllowedWhenUidActive"	"CtsJobSchedulerTestCases"	"/home/gpoor/cts-12-source/cts/tests/JobScheduler/src/android/jobscheduler/cts/JobThrottlingTest.java"	""	"public void testRestrictedJobAllowedWhenUidActive() throws Exception {
        setTestPackageRestricted(true);
        sendScheduleJobBroadcast(false);
        assertFalse(""Job started for restricted app"",
                mTestAppInterface.awaitJobStart(DEFAULT_WAIT_TIMEOUT));
        // Turn the screen on to ensure the app gets into the TOP state.
        setScreenState(true);
        mTestAppInterface.startAndKeepTestActivity(true);
        assertTrue(""Job did not start when app had an activity"",
                mTestAppInterface.awaitJobStart(DEFAULT_WAIT_TIMEOUT));

        mTestAppInterface.closeActivity();
        // Don't put full minute as the timeout to give some leeway with test timing/processing.
        assertFalse(""Job stopped within grace period after activity closed"",
                mTestAppInterface.awaitJobStop(55_000L));
        assertTrue(""Job did not stop after grace period ended"",
                mTestAppInterface.awaitJobStop(15_000L));
        assertEquals(JobParameters.STOP_REASON_BACKGROUND_RESTRICTION,
                mTestAppInterface.getLastParams().getStopReason());
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.jobscheduler.cts.JobThrottlingTest"	"testRestrictedEJAllowedWhenUidActive"	"CtsJobSchedulerTestCases"	"/home/gpoor/cts-12-source/cts/tests/JobScheduler/src/android/jobscheduler/cts/JobThrottlingTest.java"	""	"public void testRestrictedEJAllowedWhenUidActive() throws Exception {
        setTestPackageRestricted(true);
        mTestAppInterface.scheduleJob(false, JobInfo.NETWORK_TYPE_NONE, true);
        assertFalse(""Job started for restricted app"",
                mTestAppInterface.awaitJobStart(DEFAULT_WAIT_TIMEOUT));
        // Turn the screen on to ensure the app gets into the TOP state.
        setScreenState(true);
        mTestAppInterface.startAndKeepTestActivity(true);
        assertTrue(""Job did not start when app had an activity"",
                mTestAppInterface.awaitJobStart(DEFAULT_WAIT_TIMEOUT));

        mTestAppInterface.closeActivity();
        // Don't put full minute as the timeout to give some leeway with test timing/processing.
        assertFalse(""Job stopped within grace period after activity closed"",
                mTestAppInterface.awaitJobStop(55_000L));
        assertTrue(""Job did not stop after grace period ended"",
                mTestAppInterface.awaitJobStop(15_000L));
        assertEquals(JobParameters.STOP_REASON_BACKGROUND_RESTRICTION,
                mTestAppInterface.getLastParams().getStopReason());
    }

    @RequiresDevice // Emulators don't always have access to wifi/network"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.media.cts.VideoCodecTestBase"	"isEncoder"	"CtsMediaTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/VideoCodecTestBase.java"	""	"public void test/*
 *.
 */

package android.media.cts;

import android.content.Context;
import android.content.res.Resources;
import android.media.MediaCodec;
import android.media.MediaCodec.CodecException;
import android.media.MediaCodecInfo.CodecCapabilities;
import android.media.MediaCodecList;
import android.media.MediaCodecInfo;
import android.media.MediaFormat;
import android.os.Bundle;
import android.os.Environment;
import android.os.Looper;
import android.os.Handler;
import android.platform.test.annotations.AppModeFull;
import android.test.AndroidTestCase;
import android.util.Log;

import com.android.compatibility.common.util.MediaUtils;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Locale;
import java.util.concurrent.Callable;
import java.util.concurrent.CountDownLatch;

/**
 * Verification test for video encoder and decoder.
 *
 * A raw yv12 stream is encoded at various settings and written to an IVF
 * file. Encoded stream bitrate and key frame interval are checked against target values.
 * The stream is later decoded by the decoder to verify frames are decodable and to
 * calculate PSNR values for various bitrates.
 */
@AppModeFull(reason = ""Instant apps cannot access the SD card"")
public class VideoCodecTestBase extends AndroidTestCase {

    protected static final String TAG = ""VideoCodecTestBase"";
    protected static final String VP8_MIME = MediaFormat.MIMETYPE_VIDEO_VP8;
    protected static final String VP9_MIME = MediaFormat.MIMETYPE_VIDEO_VP9;
    protected static final String AVC_MIME = MediaFormat.MIMETYPE_VIDEO_AVC;
    protected static final String HEVC_MIME = MediaFormat.MIMETYPE_VIDEO_HEVC;
    protected static final String SDCARD_DIR =
            Environment.getExternalStorageDirectory().getAbsolutePath();
    static final String mInpPrefix = WorkDir.getMediaDirString();

    // Default timeout for MediaCodec buffer dequeue - 200 ms.
    protected static final long DEFAULT_DEQUEUE_TIMEOUT_US = 200000;
    // Default timeout for MediaEncoderAsync - 30 sec.
    protected static final long DEFAULT_ENCODE_TIMEOUT_MS = 30000;
    // Default sync frame interval in frames
    private static final int SYNC_FRAME_INTERVAL = 30;
    // Video bitrate type - should be set to OMX_Video_ControlRateConstant from OMX_Video.h
    protected static final int VIDEO_ControlRateVariable = 1;
    protected static final int VIDEO_ControlRateConstant = 2;
    // NV12 color format supported by QCOM codec, but not declared in MediaCodec -
    // see /hardware/qcom/media/mm-core/inc/OMX_QCOMExtns.h
    private static final int COLOR_QCOM_FORMATYUV420PackedSemiPlanar32m = 0x7FA30C04;
    // Allowable color formats supported by codec - in order of preference.
    private static final int[] mSupportedColorList = {
            CodecCapabilities.COLOR_FormatYUV420Planar,
            CodecCapabilities.COLOR_FormatYUV420SemiPlanar,
            CodecCapabilities.COLOR_QCOM_FormatYUV420SemiPlanar,
            COLOR_QCOM_FORMATYUV420PackedSemiPlanar32m
    };
    // Scaled image cache list - contains scale factors, for which up-scaled frames
    // were calculated and were written to yuv file.
    ArrayList<Integer> mScaledImages = new ArrayList<Integer>();

    private Resources mResources;

    @Override
    public void setContext(Context context) {
        super.setContext(context);
        mResources = mContext.getResources();
    }

    /**
     *  Video codec properties generated by getVideoCodecProperties() function.
     */
    private class CodecProperties {
        CodecProperties(String codecName, int colorFormat) {
            this.codecName = codecName;
            this.colorFormat = colorFormat;
        }
        public final String codecName; // OpenMax component name for Video codec.
        public final int colorFormat;  // Color format supported by codec.
    }

    /**
     * Function to find Video codec.
     *
     * Iterates through the list of available codecs and tries to find
     * Video codec, which can support either YUV420 planar or NV12 color formats.
     * If forceGoogleCodec parameter set to true the function always returns
     * Google Video codec.
     * If forceGoogleCodec parameter set to false the functions looks for platform
     * specific Video codec first. If no platform specific codec exist, falls back to
     * Google Video codec.
     *
     * @param isEncoder     Flag if encoder is requested.
     * @param forceGoogleCodec  Forces to use Google codec.
     */
    private CodecProperties getVideoCodecProperties(
            boolean isEncoder,
            MediaFormat format,
            boolean forceGoogleCodec) throws Exception {
        CodecProperties codecProperties = null;
        String mime = format.getString(MediaFormat.KEY_MIME);

        // Loop through the list of codec components in case platform specific codec
        // is requested.
        MediaCodecList mcl = new MediaCodecList(MediaCodecList.REGULAR_CODECS);
        for (MediaCodecInfo codecInfo : mcl.getCodecInfos()) {
            if (isEncoder != codecInfo.isEncoder()) {
                continue;
            }
            Log.v(TAG, codecInfo.getName());
            // TODO: remove dependence of Google from the test
            // Check if this is Google codec - we should ignore it.
            if (codecInfo.isVendor() && forceGoogleCodec) {
                continue;
            }

            for (String type : codecInfo.getSupportedTypes()) {
                if (!type.equalsIgnoreCase(mime)) {
                    continue;
                }
                CodecCapabilities capabilities = codecInfo.getCapabilitiesForType(type);
                if (!capabilities.isFormatSupported(format)) {
                    continue;
                }

                // Get candidate codec properties.
                Log.v(TAG, ""Found candidate codec "" + codecInfo.getName());
                for (int colorFormat: capabilities.colorFormats) {
                    Log.v(TAG, ""   Color: 0x"" + Integer.toHexString(colorFormat));
                }

                // Check supported color formats.
                for (int supportedColorFormat : mSupportedColorList) {
                    for (int codecColorFormat : capabilities.colorFormats) {
                        if (codecColorFormat == supportedColorFormat) {
                            codecProperties = new CodecProperties(codecInfo.getName(),
                                    codecColorFormat);
                            Log.v(TAG, ""Found target codec "" + codecProperties.codecName +
                                    "". Color: 0x"" + Integer.toHexString(codecColorFormat));
                            // return first vendor codec (hopefully HW) found
                            if (codecInfo.isVendor()) {
                                return codecProperties;
                            }
                        }
                    }
                }
            }
        }
        if (codecProperties == null) {
            Log.i(TAG, ""no suitable "" + (forceGoogleCodec ? ""google "" : """")
                    + (isEncoder ? ""encoder "" : ""decoder "") + ""found for "" + format);
        }
        return codecProperties;
    }

    /**
     * Parameters for encoded video stream.
     */
    protected class EncoderOutputStreamParameters {
        // Name of raw YUV420 input file. When the value of this parameter
        // is set to null input file descriptor from inputResource parameter
        // is used instead.
        public String inputYuvFilename;
        // Name of scaled YUV420 input file.
        public String scaledYuvFilename;
        // File descriptor for the raw input file (YUV420). Used only if
        // inputYuvFilename parameter is null.
        public String inputResource;
        // Name of the IVF file to write encoded bitsream
        public String outputIvfFilename;
        // Mime Type of the Encoded content.
        public String codecMimeType;
        // Force to use Google Video encoder.
        boolean forceGoogleEncoder;
        // Number of frames to encode.
        int frameCount;
        // Frame rate of input file in frames per second.
        int frameRate;
        // Encoded frame width.
        public int frameWidth;
        // Encoded frame height.
        public int frameHeight;
        // Encoding bitrate array in bits/second for every frame. If array length
        // is shorter than the total number of frames, the last value is re-used for
        // all remaining frames. For constant bitrate encoding single element
        // array can be used with first element set to target bitrate value.
        public int[] bitrateSet;
        // Encoding bitrate type - VBR or CBR
        public int bitrateType;
        // Number of temporal layers
        public int temporalLayers;
        // Desired key frame interval - codec is asked to generate key frames
        // at a period defined by this parameter.
        public int syncFrameInterval;
        // Optional parameter - forced key frame interval. Used to
        // explicitly request the codec to generate key frames using
        // MediaCodec.PARAMETER_KEY_REQUEST_SYNC_FRAME parameter.
        public int syncForceFrameInterval;
        // Buffer timeout
        long timeoutDequeue;
        // Flag if encoder should run in Looper thread.
        boolean runInLooperThread;
        // Flag if use NdkMediaCodec
        boolean useNdk;
    }

    private String getCodecSuffix(String codecMimeType) {
        switch(codecMimeType) {
        case VP8_MIME:
            return ""vp8"";
        case VP9_MIME:
            return ""vp9"";
        case AVC_MIME:
            return ""avc"";
        case HEVC_MIME:
            return ""hevc"";
        default:
            Log.w(TAG, ""getCodecSuffix got an unexpected codecMimeType."");
        }
        return ""video"";
    }

    /**
     * Generates an array of default parameters for encoder output stream based on
     * upscaling value.
     */
    protected ArrayList<EncoderOutputStreamParameters> getDefaultEncodingParameterList(
            String inputYuvName,
            String outputIvfBaseName,
            String codecMimeType,
            int encodeSeconds,
            int[] resolutionScales,
            int frameWidth,
            int frameHeight,
            int frameRate,
            int bitrateMode,
            int[] bitrates,
            boolean syncEncoding) {
        assertTrue(resolutionScales.length == bitrates.length);
        int numCodecs = resolutionScales.length;
        ArrayList<EncoderOutputStreamParameters> outputParameters =
                new ArrayList<EncoderOutputStreamParameters>(numCodecs);
        for (int i = 0; i < numCodecs; i++) {
            EncoderOutputStreamParameters params = new EncoderOutputStreamParameters();
            if (inputYuvName != null) {
                params.inputYuvFilename = SDCARD_DIR + File.separator + inputYuvName;
            } else {
                params.inputYuvFilename = null;
            }
            params.scaledYuvFilename = SDCARD_DIR + File.separator +
                    outputIvfBaseName + resolutionScales[i]+ "".yuv"";
            params.inputResource = ""football_qvga.yuv"";
            params.codecMimeType = codecMimeType;
            String codecSuffix = getCodecSuffix(codecMimeType);
            params.outputIvfFilename = SDCARD_DIR + File.separator +
                    outputIvfBaseName + resolutionScales[i] + ""_"" + codecSuffix + "".ivf"";
            params.forceGoogleEncoder = false;
            params.frameCount = encodeSeconds * frameRate;
            params.frameRate = frameRate;
            params.frameWidth = Math.min(frameWidth * resolutionScales[i], 1280);
            params.frameHeight = Math.min(frameHeight * resolutionScales[i], 720);
            params.bitrateSet = new int[1];
            params.bitrateSet[0] = bitrates[i];
            params.bitrateType = bitrateMode;
            params.temporalLayers = 0;
            params.syncFrameInterval = SYNC_FRAME_INTERVAL;
            params.syncForceFrameInterval = 0;
            if (syncEncoding) {
                params.timeoutDequeue = DEFAULT_DEQUEUE_TIMEOUT_US;
                params.runInLooperThread = false;
            } else {
                params.timeoutDequeue = 0;
                params.runInLooperThread = true;
            }
            outputParameters.add(params);
        }
        return outputParameters;
    }

    protected EncoderOutputStreamParameters getDefaultEncodingParameters(
            String inputYuvName,
            String outputIvfBaseName,
            String codecMimeType,
            int encodeSeconds,
            int frameWidth,
            int frameHeight,
            int frameRate,
            int bitrateMode,
            int bitrate,
            boolean syncEncoding) {
        int[] scaleValues = { 1 };
        int[] bitrates = { bitrate };
        return getDefaultEncodingParameterList(
                inputYuvName,
                outputIvfBaseName,
                codecMimeType,
                encodeSeconds,
                scaleValues,
                frameWidth,
                frameHeight,
                frameRate,
                bitrateMode,
                bitrates,
                syncEncoding).get(0);
    }

    /**
     * Converts (interleaves) YUV420 planar to NV12.
     * Assumes packed, macroblock-aligned frame with no cropping
     * (visible/coded row length == stride).
     */
    private static byte[] YUV420ToNV(int width, int height, byte[] yuv) {
        byte[] nv = new byte[yuv.length];
        // Y plane we just copy.
        System.arraycopy(yuv, 0, nv, 0, width * height);

        // U & V plane we interleave.
        int u_offset = width * height;
        int v_offset = u_offset + u_offset / 4;
        int nv_offset = width * height;
        for (int i = 0; i < width * height / 4; i++) {
            nv[nv_offset++] = yuv[u_offset++];
            nv[nv_offset++] = yuv[v_offset++];
        }
        return nv;
    }

    /**
     * Converts (de-interleaves) NV12 to YUV420 planar.
     * Stride may be greater than width, slice height may be greater than height.
     */
    private static byte[] NV12ToYUV420(int width, int height,
            int stride, int sliceHeight, byte[] nv12) {
        byte[] yuv = new byte[width * height * 3 / 2];

        // Y plane we just copy.
        for (int i = 0; i < height; i++) {
            System.arraycopy(nv12, i * stride, yuv, i * width, width);
        }

        // U & V plane - de-interleave.
        int u_offset = width * height;
        int v_offset = u_offset + u_offset / 4;
        int nv_offset;
        for (int i = 0; i < height / 2; i++) {
            nv_offset = stride * (sliceHeight + i);
            for (int j = 0; j < width / 2; j++) {
                yuv[u_offset++] = nv12[nv_offset++];
                yuv[v_offset++] = nv12[nv_offset++];
            }
        }
        return yuv;
    }

    /**
     * Packs YUV420 frame by moving it to a smaller size buffer with stride and slice
     * height equal to the crop window.
     */
    private static byte[] PackYUV420(int left, int top, int width, int height,
            int stride, int sliceHeight, byte[] src) {
        byte[] dst = new byte[width * height * 3 / 2];
        // Y copy.
        for (int i = 0; i < height; i++) {
            System.arraycopy(src, (i + top) * stride + left, dst, i * width, width);
        }
        // U and V copy.
        int u_src_offset = stride * sliceHeight;
        int v_src_offset = u_src_offset + u_src_offset / 4;
        int u_dst_offset = width * height;
        int v_dst_offset = u_dst_offset + u_dst_offset / 4;
        // Downsample and align to floor-2 for crop origin.
        left /= 2;
        top /= 2;
        for (int i = 0; i < height / 2; i++) {
            System.arraycopy(src, u_src_offset + (i + top) * (stride / 2) + left,
                    dst, u_dst_offset + i * (width / 2), width / 2);
            System.arraycopy(src, v_src_offset + (i + top) * (stride / 2) + left,
                    dst, v_dst_offset + i * (width / 2), width / 2);
        }
        return dst;
    }


    private static void imageUpscale1To2(byte[] src, int srcByteOffset, int srcStride,
            byte[] dst, int dstByteOffset, int dstWidth, int dstHeight) {
        for (int i = 0; i < dstHeight/2 - 1; i++) {
            int dstOffset0 = 2 * i * dstWidth + dstByteOffset;
            int dstOffset1 = dstOffset0 + dstWidth;
            int srcOffset0 = i * srcStride + srcByteOffset;
            int srcOffset1 = srcOffset0 + srcStride;
            int pixel00 = (int)src[srcOffset0++] & 0xff;
            int pixel10 = (int)src[srcOffset1++] & 0xff;
            for (int j = 0; j < dstWidth/2 - 1; j++) {
                int pixel01 = (int)src[srcOffset0++] & 0xff;
                int pixel11 = (int)src[srcOffset1++] & 0xff;
                dst[dstOffset0++] = (byte)pixel00;
                dst[dstOffset0++] = (byte)((pixel00 + pixel01 + 1) / 2);
                dst[dstOffset1++] = (byte)((pixel00 + pixel10 + 1) / 2);
                dst[dstOffset1++] = (byte)((pixel00 + pixel01 + pixel10 + pixel11 + 2) / 4);
                pixel00 = pixel01;
                pixel10 = pixel11;
            }
            // last column
            dst[dstOffset0++] = (byte)pixel00;
            dst[dstOffset0++] = (byte)pixel00;
            dst[dstOffset1++] = (byte)((pixel00 + pixel10 + 1) / 2);
            dst[dstOffset1++] = (byte)((pixel00 + pixel10 + 1) / 2);
        }

        // last row
        int dstOffset0 = (dstHeight - 2) * dstWidth + dstByteOffset;
        int dstOffset1 = dstOffset0 + dstWidth;
        int srcOffset0 = (dstHeight/2 - 1) * srcStride + srcByteOffset;
        int pixel00 = (int)src[srcOffset0++] & 0xff;
        for (int j = 0; j < dstWidth/2 - 1; j++) {
            int pixel01 = (int)src[srcOffset0++] & 0xff;
            dst[dstOffset0++] = (byte)pixel00;
            dst[dstOffset0++] = (byte)((pixel00 + pixel01 + 1) / 2);
            dst[dstOffset1++] = (byte)pixel00;
            dst[dstOffset1++] = (byte)((pixel00 + pixel01 + 1) / 2);
            pixel00 = pixel01;
        }
        // the very last pixel - bottom right
        dst[dstOffset0++] = (byte)pixel00;
        dst[dstOffset0++] = (byte)pixel00;
        dst[dstOffset1++] = (byte)pixel00;
        dst[dstOffset1++] = (byte)pixel00;
    }

    /**
    * Up-scale image.
    * Scale factor is defined by source and destination width ratio.
    * Only 1:2 and 1:4 up-scaling is supported for now.
    * For 640x480 -> 1280x720 conversion only top 640x360 part of the original
    * image is scaled.
    */
    private static byte[] imageScale(byte[] src, int srcWidth, int srcHeight,
            int dstWidth, int dstHeight) throws Exception {
        int srcYSize = srcWidth * srcHeight;
        int dstYSize = dstWidth * dstHeight;
        byte[] dst = null;
        if (dstWidth == 2 * srcWidth && dstHeight <= 2 * srcHeight) {
            // 1:2 upscale
            dst = new byte[dstWidth * dstHeight * 3 / 2];
            imageUpscale1To2(src, 0, srcWidth,
                    dst, 0, dstWidth, dstHeight);                                 // Y
            imageUpscale1To2(src, srcYSize, srcWidth / 2,
                    dst, dstYSize, dstWidth / 2, dstHeight / 2);                  // U
            imageUpscale1To2(src, srcYSize * 5 / 4, srcWidth / 2,
                    dst, dstYSize * 5 / 4, dstWidth / 2, dstHeight / 2);          // V
        } else if (dstWidth == 4 * srcWidth && dstHeight <= 4 * srcHeight) {
            // 1:4 upscale - in two steps
            int midWidth = 2 * srcWidth;
            int midHeight = 2 * srcHeight;
            byte[] midBuffer = imageScale(src, srcWidth, srcHeight, midWidth, midHeight);
            dst = imageScale(midBuffer, midWidth, midHeight, dstWidth, dstHeight);

        } else {
            throw new RuntimeException(""Can not find proper scaling function"");
        }

        return dst;
    }

    private void cacheScaledImage(
            String srcYuvFilename, String srcResource, int srcFrameWidth, int srcFrameHeight,
            String dstYuvFilename, int dstFrameWidth, int dstFrameHeight) throws Exception {
        InputStream srcStream = OpenFileOrResource(srcYuvFilename, srcResource);
        FileOutputStream dstFile = new FileOutputStream(dstYuvFilename, false);
        int srcFrameSize = srcFrameWidth * srcFrameHeight * 3 / 2;
        byte[] srcFrame = new byte[srcFrameSize];
        byte[] dstFrame = null;
        Log.d(TAG, ""Scale to "" + dstFrameWidth + "" x "" + dstFrameHeight + "". -> "" + dstYuvFilename);
        while (true) {
            int bytesRead = srcStream.read(srcFrame);
            if (bytesRead != srcFrame.length) {
                break;
            }
            if (dstFrameWidth == srcFrameWidth && dstFrameHeight == srcFrameHeight) {
                dstFrame = srcFrame;
            } else {
                dstFrame = imageScale(srcFrame, srcFrameWidth, srcFrameHeight,
                        dstFrameWidth, dstFrameHeight);
            }
            dstFile.write(dstFrame);
        }
        srcStream.close();
        dstFile.close();
    }


    /**
     * A basic check if an encoded stream is decodable.
     *
     * The most basic confirmation we can get about a frame
     * being properly encoded is trying to decode it.
     * (Especially in realtime mode encode output is non-
     * deterministic, therefore a more thorough check like
     * md5 sum comparison wouldn't work.)
     *
     * Indeed, MediaCodec will raise an IllegalStateException
     * whenever video decoder fails to decode a frame, and
     * this test uses that fact to verify the bitstream.
     *
     * @param inputIvfFilename  The name of the IVF file containing encoded bitsream.
     * @param outputYuvFilename The name of the output YUV file (optional).
     * @param frameRate         Frame rate of input file in frames per second
     * @param forceGoogleDecoder    Force to use Google Video decoder.
     * @param codecConfigs      Codec config buffers to be added to the format
     */
    protected ArrayList<MediaCodec.BufferInfo> decode(
            String inputIvfFilename,
            String outputYuvFilename,
            String codecMimeType,
            int frameRate,
            boolean forceGoogleDecoder,
            ArrayList<ByteBuffer> codecConfigs) throws Exception {
        ArrayList<MediaCodec.BufferInfo> bufferInfos = new ArrayList<MediaCodec.BufferInfo>();

        // Open input/output.
        IvfReader ivf = new IvfReader(inputIvfFilename);
        int frameWidth = ivf.getWidth();
        int frameHeight = ivf.getHeight();
        int frameCount = ivf.getFrameCount();
        int frameStride = frameWidth;
        int frameSliceHeight = frameHeight;
        int cropLeft = 0;
        int cropTop = 0;
        int cropWidth = frameWidth;
        int cropHeight = frameHeight;
        assertTrue(frameWidth > 0);
        assertTrue(frameHeight > 0);
        assertTrue(frameCount > 0);

        // Create decoder.
        MediaFormat format = MediaFormat.createVideoFormat(
                codecMimeType, ivf.getWidth(), ivf.getHeight());
        CodecProperties properties = getVideoCodecProperties(
                false /* encoder */, format, forceGoogleDecoder);
        if (properties == null) {
            ivf.close();
            return null;
        }
        int frameColorFormat = properties.colorFormat;
        format.setInteger(MediaFormat.KEY_COLOR_FORMAT, properties.colorFormat);
        int csdIndex = 0;
        for (ByteBuffer config : codecConfigs) {
            format.setByteBuffer(""csd-"" + csdIndex, config);
            ++csdIndex;
        }

        FileOutputStream yuv = null;
        if (outputYuvFilename != null) {
            yuv = new FileOutputStream(outputYuvFilename, false);
        }

        Log.d(TAG, ""Creating decoder "" + properties.codecName +
                "". Color format: 0x"" + Integer.toHexString(frameColorFormat) +
                "". "" + frameWidth + "" x "" + frameHeight);
        Log.d(TAG, ""  Format: "" + format);
        Log.d(TAG, ""  In: "" + inputIvfFilename + "". Out:"" + outputYuvFilename);
        MediaCodec decoder = MediaCodec.createByCodecName(properties.codecName);
        decoder.configure(format,
                          null,  // surface
                          null,  // crypto
                          0);    // flags
        decoder.start();

        ByteBuffer[] inputBuffers = decoder.getInputBuffers();
        ByteBuffer[] outputBuffers = decoder.getOutputBuffers();
        MediaCodec.BufferInfo bufferInfo = new MediaCodec.BufferInfo();

        // decode loop
        int inputFrameIndex = 0;
        int outputFrameIndex = 0;
        long inPresentationTimeUs = 0;
        long outPresentationTimeUs = 0;
        boolean sawOutputEOS = false;
        boolean sawInputEOS = false;

        while (!sawOutputEOS) {
            if (!sawInputEOS) {
                int inputBufIndex = decoder.dequeueInputBuffer(DEFAULT_DEQUEUE_TIMEOUT_US);
                if (inputBufIndex >= 0) {
                    byte[] frame = ivf.readFrame(inputFrameIndex);

                    if (inputFrameIndex == frameCount - 1) {
                        Log.d(TAG, ""  Input EOS for frame # "" + inputFrameIndex);
                        sawInputEOS = true;
                    }

                    inputBuffers[inputBufIndex].clear();
                    inputBuffers[inputBufIndex].put(frame);
                    inputBuffers[inputBufIndex].rewind();
                    inPresentationTimeUs = (inputFrameIndex * 1000000) / frameRate;

                    decoder.queueInputBuffer(
                            inputBufIndex,
                            0,  // offset
                            frame.length,
                            inPresentationTimeUs,
                            sawInputEOS ? MediaCodec.BUFFER_FLAG_END_OF_STREAM : 0);

                    inputFrameIndex++;
                }
            }

            int result = decoder.dequeueOutputBuffer(bufferInfo, DEFAULT_DEQUEUE_TIMEOUT_US);
            while (result == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED ||
                    result == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {
                if (result == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {
                    outputBuffers = decoder.getOutputBuffers();
                } else  if (result == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {
                    // Process format change
                    format = decoder.getOutputFormat();
                    frameWidth = format.getInteger(MediaFormat.KEY_WIDTH);
                    frameHeight = format.getInteger(MediaFormat.KEY_HEIGHT);
                    frameColorFormat = format.getInteger(MediaFormat.KEY_COLOR_FORMAT);
                    Log.d(TAG, ""Decoder output format change. Color: 0x"" +
                            Integer.toHexString(frameColorFormat));
                    Log.d(TAG, ""Format: "" + format.toString());

                    // Parse frame and slice height from undocumented values
                    if (format.containsKey(""stride"")) {
                        frameStride = format.getInteger(""stride"");
                    } else {
                        frameStride = frameWidth;
                    }
                    if (format.containsKey(""slice-height"")) {
                        frameSliceHeight = format.getInteger(""slice-height"");
                    } else {
                        frameSliceHeight = frameHeight;
                    }
                    Log.d(TAG, ""Frame stride and slice height: "" + frameStride +
                            "" x "" + frameSliceHeight);
                    frameStride = Math.max(frameWidth, frameStride);
                    frameSliceHeight = Math.max(frameHeight, frameSliceHeight);

                    // Parse crop window for the area of recording decoded frame data.
                    if (format.containsKey(""crop-left"")) {
                        cropLeft = format.getInteger(""crop-left"");
                    }
                    if (format.containsKey(""crop-top"")) {
                        cropTop = format.getInteger(""crop-top"");
                    }
                    if (format.containsKey(""crop-right"")) {
                        cropWidth = format.getInteger(""crop-right"") - cropLeft + 1;
                    } else {
                        cropWidth = frameWidth;
                    }
                    if (format.containsKey(""crop-bottom"")) {
                        cropHeight = format.getInteger(""crop-bottom"") - cropTop + 1;
                    } else {
                        cropHeight = frameHeight;
                    }
                    Log.d(TAG, ""Frame crop window origin: "" + cropLeft + "" x "" + cropTop
                            + "", size: "" + cropWidth + "" x "" + cropHeight);
                    cropWidth = Math.min(frameWidth - cropLeft, cropWidth);
                    cropHeight = Math.min(frameHeight - cropTop, cropHeight);
                }
                result = decoder.dequeueOutputBuffer(bufferInfo, DEFAULT_DEQUEUE_TIMEOUT_US);
            }
            if (result >= 0) {
                int outputBufIndex = result;
                outPresentationTimeUs = bufferInfo.presentationTimeUs;
                Log.v(TAG, ""Writing buffer # "" + outputFrameIndex +
                        "". Size: "" + bufferInfo.size +
                        "". InTime: "" + (inPresentationTimeUs + 500)/1000 +
                        "". OutTime: "" + (outPresentationTimeUs + 500)/1000);
                if ((bufferInfo.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {
                    sawOutputEOS = true;
                    Log.d(TAG, ""   Output EOS for frame # "" + outputFrameIndex);
                }

                if (bufferInfo.size > 0) {
                    // Save decoder output to yuv file.
                    if (yuv != null) {
                        byte[] frame = new byte[bufferInfo.size];
                        outputBuffers[outputBufIndex].position(bufferInfo.offset);
                        outputBuffers[outputBufIndex].get(frame, 0, bufferInfo.size);
                        // Convert NV12 to YUV420 if necessary.
                        if (frameColorFormat != CodecCapabilities.COLOR_FormatYUV420Planar) {
                            frame = NV12ToYUV420(frameWidth, frameHeight,
                                    frameStride, frameSliceHeight, frame);
                        }
                        int writeLength = Math.min(cropWidth * cropHeight * 3 / 2, frame.length);
                        // Pack frame if necessary.
                        if (writeLength < frame.length &&
                                (frameStride > cropWidth || frameSliceHeight > cropHeight)) {
                            frame = PackYUV420(cropLeft, cropTop, cropWidth, cropHeight,
                                    frameStride, frameSliceHeight, frame);
                        }
                        yuv.write(frame, 0, writeLength);
                    }
                    outputFrameIndex++;

                    // Update statistics - store presentation time delay in offset
                    long presentationTimeUsDelta = inPresentationTimeUs - outPresentationTimeUs;
                    MediaCodec.BufferInfo bufferInfoCopy = new MediaCodec.BufferInfo();
                    bufferInfoCopy.set((int)presentationTimeUsDelta, bufferInfo.size,
                            outPresentationTimeUs, bufferInfo.flags);
                    bufferInfos.add(bufferInfoCopy);
                }
                decoder.releaseOutputBuffer(outputBufIndex, false);
            }
        }
        decoder.stop();
        decoder.release();
        ivf.close();
        if (yuv != null) {
            yuv.close();
        }

        return bufferInfos;
    }


    /**
     * Helper function to return InputStream from either fully specified filename (if set)
     * or resource name within test assets (if filename is not set).
     */
    private InputStream OpenFileOrResource(String filename, final String resource)
            throws Exception {
        if (filename != null) {
            Preconditions.assertTestFileExists(filename);
            return new FileInputStream(filename);
        }
        Preconditions.assertTestFileExists(mInpPrefix + resource);
        return new FileInputStream(mInpPrefix + resource);
    }

    /**
     * Results of frame encoding.
     */
    protected class MediaEncoderOutput {
        public long inPresentationTimeUs;
        public long outPresentationTimeUs;
        public boolean outputGenerated;
        public int flags;
        public byte[] buffer;
    }

    protected class MediaEncoderAsyncHelper {
        private final EncoderOutputStreamParameters mStreamParams;
        private final CodecProperties mProperties;
        private final ArrayList<MediaCodec.BufferInfo> mBufferInfos;
        private final IvfWriter mIvf;
        private final ArrayList<ByteBuffer> mCodecConfigs;
        private final byte[] mSrcFrame;

        private InputStream mYuvStream;
        private int mInputFrameIndex;

        MediaEncoderAsyncHelper(
                EncoderOutputStreamParameters streamParams,
                CodecProperties properties,
                ArrayList<MediaCodec.BufferInfo> bufferInfos,
                IvfWriter ivf,
                ArrayList<ByteBuffer> codecConfigs)
                throws Exception {
            mStreamParams = streamParams;
            mProperties = properties;
            mBufferInfos = bufferInfos;
            mIvf = ivf;
            mCodecConfigs = codecConfigs;

            int srcFrameSize = streamParams.frameWidth * streamParams.frameHeight * 3 / 2;
            mSrcFrame = new byte[srcFrameSize];

            mYuvStream = OpenFileOrResource(
                    streamParams.inputYuvFilename, streamParams.inputResource);
        }

        public byte[] getInputFrame() {
            // Check EOS
            if (mStreamParams.frameCount == 0
                    || (mStreamParams.frameCount > 0
                            && mInputFrameIndex >= mStreamParams.frameCount)) {
                Log.d(TAG, ""---Sending EOS empty frame for frame # "" + mInputFrameIndex);
                return null;
            }

            try {
                int bytesRead = mYuvStream.read(mSrcFrame);

                if (bytesRead == -1) {
                    // rewind to beginning of file
                    mYuvStream.close();
                    mYuvStream = OpenFileOrResource(
                            mStreamParams.inputYuvFilename, mStreamParams.inputResource);
                    bytesRead = mYuvStream.read(mSrcFrame);
                }
            } catch (Exception e) {
                Log.e(TAG, ""Failed to read YUV file."");
                return null;
            }
            mInputFrameIndex++;

            // Convert YUV420 to NV12 if necessary
            if (mProperties.colorFormat != CodecCapabilities.COLOR_FormatYUV420Planar) {
                return YUV420ToNV(mStreamParams.frameWidth, mStreamParams.frameHeight,
                        mSrcFrame);
            } else {
                return mSrcFrame;
            }
        }

        public boolean saveOutputFrame(MediaEncoderOutput out) {
            if (out.outputGenerated) {
                if ((out.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) != 0) {
                    Log.d(TAG, ""Storing codec config separately"");
                    ByteBuffer csdBuffer = ByteBuffer.allocate(out.buffer.length).put(out.buffer);
                    csdBuffer.rewind();
                    mCodecConfigs.add(csdBuffer);
                    out.buffer = new byte[0];
                }
                if (out.buffer.length > 0) {
                    // Save frame
                    try {
                        mIvf.writeFrame(out.buffer, out.outPresentationTimeUs);
                    } catch (Exception e) {
                        Log.d(TAG, ""Failed to write frame"");
                        return true;
                    }

                    // Update statistics - store presentation time delay in offset
                    long presentationTimeUsDelta = out.inPresentationTimeUs -
                            out.outPresentationTimeUs;
                    MediaCodec.BufferInfo bufferInfoCopy = new MediaCodec.BufferInfo();
                    bufferInfoCopy.set((int)presentationTimeUsDelta, out.buffer.length,
                            out.outPresentationTimeUs, out.flags);
                    mBufferInfos.add(bufferInfoCopy);
                }
                // Detect output EOS
                if ((out.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {
                    Log.d(TAG, ""----Output EOS "");
                    return true;
                }
            }
            return false;
        }
    }

    /**
     * Video encoder wrapper class.
     * Allows to run the encoder either in a callee's thread or in a looper thread
     * using buffer dequeue ready notification callbacks.
     *
     * Function feedInput() is used to send raw video frame to the encoder input. When encoder
     * is configured to run in async mode the function will run in a looper thread.
     * Encoded frame can be retrieved by calling getOutput() function.
     */
    protected class MediaEncoderAsync extends Thread {
        private int mId;
        private MediaCodecWrapper mCodec;
        private ByteBuffer[] mInputBuffers;
        private ByteBuffer[] mOutputBuffers;
        private int mInputFrameIndex;
        private int mOutputFrameIndex;
        private int mInputBufIndex;
        private int mFrameRate;
        private long mTimeout;
        private MediaCodec.BufferInfo mBufferInfo;
        private long mInPresentationTimeUs;
        private long mOutPresentationTimeUs;
        private boolean mAsync;
        // Flag indicating if input frame was consumed by the encoder in feedInput() call.
        private boolean mConsumedInput;
        // Result of frame encoding returned by getOutput() call.
        private MediaEncoderOutput mOutput;
        // Object used to signal that looper thread has started and Handler instance associated
        // with looper thread has been allocated.
        private final Object mThreadEvent = new Object();
        // Object used to signal that MediaCodec buffer dequeue notification callback
        // was received.
        private final Object mCallbackEvent = new Object();
        private Handler mHandler;
        private boolean mCallbackReceived;
        private MediaEncoderAsyncHelper mHelper;
        private final Object mCompletionEvent = new Object();
        private boolean mCompleted;
        private boolean mInitialSyncFrameReceived;

        private MediaCodec.Callback mCallback = new MediaCodec.Callback() {
            @Override
            public void onInputBufferAvailable(MediaCodec codec, int index) {
                if (mHelper == null) {
                    Log.e(TAG, ""async helper not available"");
                    return;
                }

                byte[] encFrame = mHelper.getInputFrame();
                boolean inputEOS = (encFrame == null);

                int encFrameLength = 0;
                int flags = 0;
                if (inputEOS) {
                    flags = MediaCodec.BUFFER_FLAG_END_OF_STREAM;
                } else {
                    encFrameLength = encFrame.length;

                    ByteBuffer byteBuffer = mCodec.getInputBuffer(index);
                    byteBuffer.put(encFrame);
                    byteBuffer.rewind();

                    mInPresentationTimeUs = (mInputFrameIndex * 1000000) / mFrameRate;

                    Log.v(TAG, ""Enc"" + mId + "". Frame in # "" + mInputFrameIndex +
                            "". InTime: "" + (mInPresentationTimeUs + 500)/1000);

                    mInputFrameIndex++;
                }

                mCodec.queueInputBuffer(
                        index,
                        0,  // offset
                        encFrameLength,  // size
                        mInPresentationTimeUs,
                        flags);
            }

            @Override
            public void onOutputBufferAvailable(MediaCodec codec,
                    int index, MediaCodec.BufferInfo info) {
                if (mHelper == null) {
                    Log.e(TAG, ""async helper not available"");
                    return;
                }

                MediaEncoderOutput out = new MediaEncoderOutput();

                out.buffer = new byte[info.size];
                ByteBuffer outputBuffer = mCodec.getOutputBuffer(index);
                outputBuffer.get(out.buffer, 0, info.size);
                mOutPresentationTimeUs = info.presentationTimeUs;

                String logStr = ""Enc"" + mId + "". Frame # "" + mOutputFrameIndex;
                if ((info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) != 0) {
                    logStr += "" CONFIG. "";
                }
                if ((info.flags & MediaCodec.BUFFER_FLAG_SYNC_FRAME) != 0) {
                    logStr += "" KEY. "";
                    if (!mInitialSyncFrameReceived) {
                        mInitialSyncFrameReceived = true;
                    }
                }
                if ((info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {
                    logStr += "" EOS. "";
                }
                logStr += "" Size: "" + info.size;
                logStr += "". InTime: "" + (mInPresentationTimeUs + 500)/1000 +
                        "". OutTime: "" + (mOutPresentationTimeUs + 500)/1000;
                Log.v(TAG, logStr);

                if (!mInitialSyncFrameReceived
                        && (info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) == 0) {
                    throw new RuntimeException(""Non codec_config_frame before first sync."");
                }

                if (info.size > 0) {
                    mOutputFrameIndex++;
                    out.inPresentationTimeUs = mInPresentationTimeUs;
                    out.outPresentationTimeUs = mOutPresentationTimeUs;
                }
                mCodec.releaseOutputBuffer(index, false);

                out.flags = info.flags;
                out.outputGenerated = true;

                if (mHelper.saveOutputFrame(out)) {
                    // output EOS
                    signalCompletion();
                }
            }

            @Override
            public void onError(MediaCodec codec, CodecException e) {
                Log.e(TAG, ""onError: "" + e
                        + "", transient "" + e.isTransient()
                        + "", recoverable "" + e.isRecoverable()
                        + "", error "" + e.getErrorCode());
            }

            @Override
            public void onOutputFormatChanged(MediaCodec codec, MediaFormat format) {
                Log.i(TAG, ""onOutputFormatChanged: "" + format.toString());
            }
        };

        private synchronized void requestStart() throws Exception {
            mHandler = null;
            start();
            // Wait for Hander allocation
            synchronized (mThreadEvent) {
                while (mHandler == null) {
                    mThreadEvent.wait();
                }
            }
        }

        public void setAsyncHelper(MediaEncoderAsyncHelper helper) {
            mHelper = helper;
        }

        @Override
        public void run() {
            Looper.prepare();
            synchronized (mThreadEvent) {
                mHandler = new Handler();
                mThreadEvent.notify();
            }
            Looper.loop();
        }

        private void runCallable(final Callable<?> callable) throws Exception {
            if (mAsync) {
                final Exception[] exception = new Exception[1];
                final CountDownLatch countDownLatch = new CountDownLatch(1);
                mHandler.post( new Runnable() {
                    @Override
                    public void run() {
                        try {
                            callable.call();
                        } catch (Exception e) {
                            exception[0] = e;
                        } finally {
                            countDownLatch.countDown();
                        }
                    }
                } );

                // Wait for task completion
                countDownLatch.await();
                if (exception[0] != null) {
                    throw exception[0];
                }
            } else {
                callable.call();
            }
        }

        private synchronized void requestStop() throws Exception {
            mHandler.post( new Runnable() {
                @Override
                public void run() {
                    // This will run on the Looper thread
                    Log.v(TAG, ""MediaEncoder looper quitting"");
                    Looper.myLooper().quitSafely();
                }
            } );
            // Wait for completion
            join();
            mHandler = null;
        }

        private void createCodecInternal(final String name,
                final MediaFormat format, final long timeout, boolean useNdk) throws Exception {
            mBufferInfo = new MediaCodec.BufferInfo();
            mFrameRate = format.getInteger(MediaFormat.KEY_FRAME_RATE);
            mTimeout = timeout;
            mInputFrameIndex = 0;
            mOutputFrameIndex = 0;
            mInPresentationTimeUs = 0;
            mOutPresentationTimeUs = 0;

            if (useNdk) {
                mCodec = new NdkMediaCodec(name);
            } else {
                mCodec = new SdkMediaCodec(MediaCodec.createByCodecName(name), mAsync);
            }
            if (mAsync) {
                mCodec.setCallback(mCallback);
            }
            mCodec.configure(format, MediaCodec.CONFIGURE_FLAG_ENCODE);
            mCodec.start();

            // get the cached input/output only in sync mode
            if (!mAsync) {
                mInputBuffers = mCodec.getInputBuffers();
                mOutputBuffers = mCodec.getOutputBuffers();
            }
        }

        public void createCodec(int id, final String name, final MediaFormat format,
                final long timeout, boolean async, final boolean useNdk)  throws Exception {
            mId = id;
            mAsync = async;
            if (mAsync) {
                requestStart(); // start looper thread
            }
            runCallable( new Callable<Void>() {
                @Override
                public Void call() throws Exception {
                    createCodecInternal(name, format, timeout, useNdk);
                    return null;
                }
            } );
        }

        private void feedInputInternal(final byte[] encFrame, final boolean inputEOS) {
            mConsumedInput = false;
            // Feed input
            mInputBufIndex = mCodec.dequeueInputBuffer(mTimeout);

            if (mInputBufIndex >= 0) {
                ByteBuffer inputBuffer = mCodec.getInputBuffer(mInputBufIndex);
                inputBuffer.clear();
                inputBuffer.put(encFrame);
                inputBuffer.rewind();
                int encFrameLength = encFrame.length;
                int flags = 0;
                if (inputEOS) {
                    encFrameLength = 0;
                    flags = MediaCodec.BUFFER_FLAG_END_OF_STREAM;
                }
                if (!inputEOS) {
                    Log.v(TAG, ""Enc"" + mId + "". Frame in # "" + mInputFrameIndex +
                            "". InTime: "" + (mInPresentationTimeUs + 500)/1000);
                    mInPresentationTimeUs = (mInputFrameIndex * 1000000) / mFrameRate;
                    mInputFrameIndex++;
                }

                mCodec.queueInputBuffer(
                        mInputBufIndex,
                        0,  // offset
                        encFrameLength,  // size
                        mInPresentationTimeUs,
                        flags);

                mConsumedInput = true;
            } else {
                Log.v(TAG, ""In "" + mId + "" - TRY_AGAIN_LATER"");
            }
            mCallbackReceived = false;
        }

        public boolean feedInput(final byte[] encFrame, final boolean inputEOS) throws Exception {
            runCallable( new Callable<Void>() {
                @Override
                public Void call() throws Exception {
                    feedInputInternal(encFrame, inputEOS);
                    return null;
                }
            } );
            return mConsumedInput;
        }

        private void getOutputInternal() {
            mOutput = new MediaEncoderOutput();
            mOutput.inPresentationTimeUs = mInPresentationTimeUs;
            mOutput.outPresentationTimeUs = mOutPresentationTimeUs;
            mOutput.outputGenerated = false;

            // Get output from the encoder
            int result = mCodec.dequeueOutputBuffer(mBufferInfo, mTimeout);
            while (result == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED ||
                    result == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {
                if (result == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {
                    mOutputBuffers = mCodec.getOutputBuffers();
                } else if (result == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {
                    Log.d(TAG, ""Format changed: "" + mCodec.getOutputFormatString());
                }
                result = mCodec.dequeueOutputBuffer(mBufferInfo, mTimeout);
            }
            if (result == MediaCodec.INFO_TRY_AGAIN_LATER) {
                Log.v(TAG, ""Out "" + mId + "" - TRY_AGAIN_LATER"");
            }

            if (result >= 0) {
                int outputBufIndex = result;
                mOutput.buffer = new byte[mBufferInfo.size];
                ByteBuffer outputBuffer = mCodec.getOutputBuffer(outputBufIndex);
                outputBuffer.position(mBufferInfo.offset);
                outputBuffer.get(mOutput.buffer, 0, mBufferInfo.size);
                mOutPresentationTimeUs = mBufferInfo.presentationTimeUs;

                String logStr = ""Enc"" + mId + "". Frame # "" + mOutputFrameIndex;
                if ((mBufferInfo.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) != 0) {
                    logStr += "" CONFIG. "";
                }
                if ((mBufferInfo.flags & MediaCodec.BUFFER_FLAG_SYNC_FRAME) != 0) {
                    logStr += "" KEY. "";
                    if (!mInitialSyncFrameReceived) {
                        mInitialSyncFrameReceived = true;
                    }
                }
                if ((mBufferInfo.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {
                    logStr += "" EOS. "";
                }
                logStr += "" Size: "" + mBufferInfo.size;
                logStr += "". InTime: "" + (mInPresentationTimeUs + 500)/1000 +
                        "". OutTime: "" + (mOutPresentationTimeUs + 500)/1000;
                Log.v(TAG, logStr);

                if (!mInitialSyncFrameReceived
                        && (mBufferInfo.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) == 0) {
                    throw new RuntimeException(""Non codec_config_frame before first sync."");
                }

                if (mBufferInfo.size > 0) {
                    mOutputFrameIndex++;
                    mOutput.outPresentationTimeUs = mOutPresentationTimeUs;
                }
                mCodec.releaseOutputBuffer(outputBufIndex, false);

                mOutput.flags = mBufferInfo.flags;
                mOutput.outputGenerated = true;
            }
            mCallbackReceived = false;
        }

        public MediaEncoderOutput getOutput() throws Exception {
            runCallable( new Callable<Void>() {
                @Override
                public Void call() throws Exception {
                    getOutputInternal();
                    return null;
                }
            } );
            return mOutput;
        }

        public void forceSyncFrame() throws Exception {
            final Bundle syncFrame = new Bundle();
            syncFrame.putInt(MediaCodec.PARAMETER_KEY_REQUEST_SYNC_FRAME, 0);
            runCallable( new Callable<Void>() {
                @Override
                public Void call() throws Exception {
                    mCodec.setParameters(syncFrame);
                    return null;
                }
            } );
        }

        public void updateBitrate(int bitrate) throws Exception {
            final Bundle bitrateUpdate = new Bundle();
            bitrateUpdate.putInt(MediaCodec.PARAMETER_KEY_VIDEO_BITRATE, bitrate);
            runCallable( new Callable<Void>() {
                @Override
                public Void call() throws Exception {
                    mCodec.setParameters(bitrateUpdate);
                    return null;
                }
            } );
        }


        public void waitForBufferEvent() throws Exception {
            Log.v(TAG, ""----Enc"" + mId + "" waiting for bufferEvent"");
            if (mAsync) {
                synchronized (mCallbackEvent) {
                    if (!mCallbackReceived) {
                        mCallbackEvent.wait(1000); // wait 1 sec for a callback
                        // throw an exception if callback was not received
                        if (!mCallbackReceived) {
                            throw new RuntimeException(""MediaCodec callback was not received"");
                        }
                    }
                }
            } else {
                Thread.sleep(5);
            }
            Log.v(TAG, ""----Waiting for bufferEvent done"");
        }


        public void waitForCompletion(long timeoutMs) throws Exception {
            synchronized (mCompletionEvent) {
                long timeoutExpiredMs = System.currentTimeMillis() + timeoutMs;

                while (!mCompleted) {
                    mCompletionEvent.wait(timeoutExpiredMs - System.currentTimeMillis());
                    if (System.currentTimeMillis() >= timeoutExpiredMs) {
                        throw new RuntimeException(""encoding has timed out!"");
                    }
                }
            }
        }

        public void signalCompletion() {
            synchronized (mCompletionEvent) {
                mCompleted = true;
                mCompletionEvent.notify();
            }
        }

        public void deleteCodec() throws Exception {
            runCallable( new Callable<Void>() {
                @Override
                public Void call() throws Exception {
                    mCodec.stop();
                    mCodec.release();
                    return null;
                }
            } );
            if (mAsync) {
                requestStop(); // Stop looper thread
            }
        }
    }

    /**
     * @see #encode(EncoderOutputStreamParameters, ArrayList<ByteBuffer>)
     */
    protected ArrayList<MediaCodec.BufferInfo> encode(
            EncoderOutputStreamParameters streamParams) throws Exception {
        return encode(streamParams, new ArrayList<ByteBuffer>());
    }

    /**
     * Video encoding loop supporting encoding single streams with an option
     * to run in a looper thread and use buffer ready notification callbacks.
     *
     * Output stream is described by encodingParams parameters.
     *
     * MediaCodec will raise an IllegalStateException
     * whenever video encoder fails to encode a frame.
     *
     * Color format of input file should be YUV420, and frameWidth,
     * frameHeight should be supplied correctly as raw input file doesn't
     * include any header data.
     *
     * @param streamParams  Structure with encoder parameters
     * @param codecConfigs  List to be filled with codec config buffers
     * @return              Returns array of encoded frames information for each frame.
     */
    protected ArrayList<MediaCodec.BufferInfo> encode(
            EncoderOutputStreamParameters streamParams,
            ArrayList<ByteBuffer> codecConfigs) throws Exception {

        ArrayList<MediaCodec.BufferInfo> bufferInfos = new ArrayList<MediaCodec.BufferInfo>();
        Log.d(TAG, ""Source resolution: ""+streamParams.frameWidth + "" x "" +
                streamParams.frameHeight);
        int bitrate = streamParams.bitrateSet[0];

        // Create minimal media format signifying desired output.
        MediaFormat format = MediaFormat.createVideoFormat(
                streamParams.codecMimeType, streamParams.frameWidth,
                streamParams.frameHeight);
        format.setInteger(MediaFormat.KEY_BIT_RATE, bitrate);
        CodecProperties properties = getVideoCodecProperties(
                true, format, streamParams.forceGoogleEncoder);
        if (properties == null) {
            return null;
        }

        // Open input/output
        InputStream yuvStream = OpenFileOrResource(
                streamParams.inputYuvFilename, streamParams.inputResource);
        IvfWriter ivf = new IvfWriter(
                streamParams.outputIvfFilename, streamParams.codecMimeType,
                streamParams.frameWidth, streamParams.frameHeight);

        // Create a media format signifying desired output.
        if (streamParams.bitrateType == VIDEO_ControlRateConstant) {
            format.setInteger(""bitrate-mode"", VIDEO_ControlRateConstant); // set CBR
        }
        if (streamParams.temporalLayers > 0) {
            format.setInteger(""ts-layers"", streamParams.temporalLayers); // 1 temporal layer
        }
        format.setInteger(MediaFormat.KEY_COLOR_FORMAT, properties.colorFormat);
        format.setInteger(MediaFormat.KEY_FRAME_RATE, streamParams.frameRate);
        int syncFrameInterval = (streamParams.syncFrameInterval + streamParams.frameRate/2) /
                streamParams.frameRate;
        format.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, syncFrameInterval);

        // Create encoder
        Log.d(TAG, ""Creating encoder "" + properties.codecName +
                "". Color format: 0x"" + Integer.toHexString(properties.colorFormat)+ "" : "" +
                streamParams.frameWidth + "" x "" + streamParams.frameHeight +
                "". Bitrate: "" + bitrate + "" Bitrate type: "" + streamParams.bitrateType +
                "". Fps:"" + streamParams.frameRate + "". TS Layers: "" + streamParams.temporalLayers +
                "". Key frame:"" + syncFrameInterval * streamParams.frameRate +
                "". Force keyFrame: "" + streamParams.syncForceFrameInterval);
        Log.d(TAG, ""  Format: "" + format);
        Log.d(TAG, ""  Output ivf:"" + streamParams.outputIvfFilename);
        MediaEncoderAsync codec = new MediaEncoderAsync();
        codec.createCodec(0, properties.codecName, format,
                streamParams.timeoutDequeue, streamParams.runInLooperThread, streamParams.useNdk);

        // encode loop
        boolean sawInputEOS = false;  // no more data
        boolean consumedInputEOS = false; // EOS flag is consumed dy encoder
        boolean sawOutputEOS = false;
        boolean inputConsumed = true;
        int inputFrameIndex = 0;
        int lastBitrate = bitrate;
        int srcFrameSize = streamParams.frameWidth * streamParams.frameHeight * 3 / 2;
        byte[] srcFrame = new byte[srcFrameSize];

        while (!sawOutputEOS) {

            // Read and feed input frame
            if (!consumedInputEOS) {

                // Read new input buffers - if previous input was consumed and no EOS
                if (inputConsumed && !sawInputEOS) {
                    int bytesRead = yuvStream.read(srcFrame);

                    // Check EOS
                    if (streamParams.frameCount > 0 && inputFrameIndex >= streamParams.frameCount) {
                        sawInputEOS = true;
                        Log.d(TAG, ""---Sending EOS empty frame for frame # "" + inputFrameIndex);
                    }

                    if (!sawInputEOS && bytesRead == -1) {
                        if (streamParams.frameCount == 0) {
                            sawInputEOS = true;
                            Log.d(TAG, ""---Sending EOS empty frame for frame # "" + inputFrameIndex);
                        } else {
                            yuvStream.close();
                            yuvStream = OpenFileOrResource(
                                    streamParams.inputYuvFilename, streamParams.inputResource);
                            bytesRead = yuvStream.read(srcFrame);
                        }
                    }

                    // Force sync frame if syncForceFrameinterval is set.
                    if (!sawInputEOS && inputFrameIndex > 0 &&
                            streamParams.syncForceFrameInterval > 0 &&
                            (inputFrameIndex % streamParams.syncForceFrameInterval) == 0) {
                        Log.d(TAG, ""---Requesting sync frame # "" + inputFrameIndex);
                        codec.forceSyncFrame();
                    }

                    // Dynamic bitrate change.
                    if (!sawInputEOS && streamParams.bitrateSet.length > inputFrameIndex) {
                        int newBitrate = streamParams.bitrateSet[inputFrameIndex];
                        if (newBitrate != lastBitrate) {
                            Log.d(TAG, ""--- Requesting new bitrate "" + newBitrate +
                                    "" for frame "" + inputFrameIndex);
                            codec.updateBitrate(newBitrate);
                            lastBitrate = newBitrate;
                        }
                    }

                    // Convert YUV420 to NV12 if necessary
                    if (properties.colorFormat != CodecCapabilities.COLOR_FormatYUV420Planar) {
                        srcFrame = YUV420ToNV(streamParams.frameWidth, streamParams.frameHeight,
                                srcFrame);
                    }
                }

                inputConsumed = codec.feedInput(srcFrame, sawInputEOS);
                if (inputConsumed) {
                    inputFrameIndex++;
                    consumedInputEOS = sawInputEOS;
                }
            }

            // Get output from the encoder
            MediaEncoderOutput out = codec.getOutput();
            if (out.outputGenerated) {
                // Detect output EOS
                if ((out.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {
                    Log.d(TAG, ""----Output EOS "");
                    sawOutputEOS = true;
                }
                if ((out.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) != 0) {
                    Log.d(TAG, ""Storing codec config separately"");
                    ByteBuffer csdBuffer = ByteBuffer.allocate(out.buffer.length).put(out.buffer);
                    csdBuffer.rewind();
                    codecConfigs.add(csdBuffer);
                    out.buffer = new byte[0];
                }

                if (out.buffer.length > 0) {
                    // Save frame
                    ivf.writeFrame(out.buffer, out.outPresentationTimeUs);

                    // Update statistics - store presentation time delay in offset
                    long presentationTimeUsDelta = out.inPresentationTimeUs -
                            out.outPresentationTimeUs;
                    MediaCodec.BufferInfo bufferInfoCopy = new MediaCodec.BufferInfo();
                    bufferInfoCopy.set((int)presentationTimeUsDelta, out.buffer.length,
                            out.outPresentationTimeUs, out.flags);
                    bufferInfos.add(bufferInfoCopy);
                }
            }

            // If codec is not ready to accept input/poutput - wait for buffer ready callback
            if ((!inputConsumed || consumedInputEOS) && !out.outputGenerated) {
                codec.waitForBufferEvent();
            }
        }

        codec.deleteCodec();
        ivf.close();
        yuvStream.close();

        return bufferInfos;
    }

    /**
     * Video encoding run in a looper thread and use buffer ready callbacks.
     *
     * Output stream is described by encodingParams parameters.
     *
     * MediaCodec will raise an IllegalStateException
     * whenever video encoder fails to encode a frame.
     *
     * Color format of input file should be YUV420, and frameWidth,
     * frameHeight should be supplied correctly as raw input file doesn't
     * include any header data.
     *
     * @param streamParams  Structure with encoder parameters
     * @param codecConfigs  List to be filled with codec config buffers
     * @return              Returns array of encoded frames information for each frame.
     */
    protected ArrayList<MediaCodec.BufferInfo> encodeAsync(
            EncoderOutputStreamParameters streamParams,
            ArrayList<ByteBuffer> codecConfigs) throws Exception {
        if (!streamParams.runInLooperThread) {
            throw new RuntimeException(""encodeAsync should run with a looper thread!"");
        }

        ArrayList<MediaCodec.BufferInfo> bufferInfos = new ArrayList<MediaCodec.BufferInfo>();
        Log.d(TAG, ""Source resolution: ""+streamParams.frameWidth + "" x "" +
                streamParams.frameHeight);
        int bitrate = streamParams.bitrateSet[0];

        // Create minimal media format signifying desired output.
        MediaFormat format = MediaFormat.createVideoFormat(
                streamParams.codecMimeType, streamParams.frameWidth,
                streamParams.frameHeight);
        format.setInteger(MediaFormat.KEY_BIT_RATE, bitrate);
        CodecProperties properties = getVideoCodecProperties(
                true, format, streamParams.forceGoogleEncoder);
        if (properties == null) {
            return null;
        }

        // Open input/output
        IvfWriter ivf = new IvfWriter(
                streamParams.outputIvfFilename, streamParams.codecMimeType,
                streamParams.frameWidth, streamParams.frameHeight);

        // Create a media format signifying desired output.
        if (streamParams.bitrateType == VIDEO_ControlRateConstant) {
            format.setInteger(""bitrate-mode"", VIDEO_ControlRateConstant); // set CBR
        }
        if (streamParams.temporalLayers > 0) {
            format.setInteger(""ts-layers"", streamParams.temporalLayers); // 1 temporal layer
        }
        format.setInteger(MediaFormat.KEY_COLOR_FORMAT, properties.colorFormat);
        format.setInteger(MediaFormat.KEY_FRAME_RATE, streamParams.frameRate);
        int syncFrameInterval = (streamParams.syncFrameInterval + streamParams.frameRate/2) /
                streamParams.frameRate;
        format.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, syncFrameInterval);

        // Create encoder
        Log.d(TAG, ""Creating encoder "" + properties.codecName +
                "". Color format: 0x"" + Integer.toHexString(properties.colorFormat)+ "" : "" +
                streamParams.frameWidth + "" x "" + streamParams.frameHeight +
                "". Bitrate: "" + bitrate + "" Bitrate type: "" + streamParams.bitrateType +
                "". Fps:"" + streamParams.frameRate + "". TS Layers: "" + streamParams.temporalLayers +
                "". Key frame:"" + syncFrameInterval * streamParams.frameRate +
                "". Force keyFrame: "" + streamParams.syncForceFrameInterval);
        Log.d(TAG, ""  Format: "" + format);
        Log.d(TAG, ""  Output ivf:"" + streamParams.outputIvfFilename);

        MediaEncoderAsync codec = new MediaEncoderAsync();
        MediaEncoderAsyncHelper helper = new MediaEncoderAsyncHelper(
                streamParams, properties, bufferInfos, ivf, codecConfigs);

        codec.setAsyncHelper(helper);
        codec.createCodec(0, properties.codecName, format,
                streamParams.timeoutDequeue, streamParams.runInLooperThread, streamParams.useNdk);
        codec.waitForCompletion(DEFAULT_ENCODE_TIMEOUT_MS);

        codec.deleteCodec();
        ivf.close();

        return bufferInfos;
    }

    /**
     * Video encoding loop supporting encoding multiple streams at a time.
     * Each output stream is described by encodingParams parameters allowing
     * simultaneous encoding of various resolutions, bitrates with an option to
     * control key frame and dynamic bitrate for each output stream indepandently.
     *
     * MediaCodec will raise an IllegalStateException
     * whenever video encoder fails to encode a frame.
     *
     * Color format of input file should be YUV420, and frameWidth,
     * frameHeight should be supplied correctly as raw input file doesn't
     * include any header data.
     *
     * @param srcFrameWidth     Frame width of input yuv file
     * @param srcFrameHeight    Frame height of input yuv file
     * @param encodingParams    Encoder parameters
     * @param codecConfigs      List to be filled with codec config buffers
     * @return                  Returns 2D array of encoded frames information for each stream and
     *                          for each frame.
     */
    protected ArrayList<ArrayList<MediaCodec.BufferInfo>> encodeSimulcast(
            int srcFrameWidth,
            int srcFrameHeight,
            ArrayList<EncoderOutputStreamParameters> encodingParams,
            ArrayList<ArrayList<ByteBuffer>> codecConfigs) throws Exception {
        int numEncoders = encodingParams.size();

        // Create arrays of input/output, formats, bitrates etc
        ArrayList<ArrayList<MediaCodec.BufferInfo>> bufferInfos =
                new ArrayList<ArrayList<MediaCodec.BufferInfo>>(numEncoders);
        InputStream yuvStream[] = new InputStream[numEncoders];
        IvfWriter[] ivf = new IvfWriter[numEncoders];
        FileOutputStream[] yuvScaled = new FileOutputStream[numEncoders];
        MediaFormat[] format = new MediaFormat[numEncoders];
        MediaEncoderAsync[] codec = new MediaEncoderAsync[numEncoders];
        int[] inputFrameIndex = new int[numEncoders];
        boolean[] sawInputEOS = new boolean[numEncoders];
        boolean[] consumedInputEOS = new boolean[numEncoders];
        boolean[] inputConsumed = new boolean[numEncoders];
        boolean[] bufferConsumed = new boolean[numEncoders];
        boolean[] sawOutputEOS = new boolean[numEncoders];
        byte[][] srcFrame = new byte[numEncoders][];
        boolean sawOutputEOSTotal = false;
        boolean bufferConsumedTotal = false;
        CodecProperties[] codecProperties = new CodecProperties[numEncoders];

        numEncoders = 0;
        for (EncoderOutputStreamParameters params : encodingParams) {
            int i = numEncoders;
            Log.d(TAG, ""Source resolution: "" + params.frameWidth + "" x "" +
                    params.frameHeight);
            int bitrate = params.bitrateSet[0];

            // Create minimal media format signifying desired output.
            format[i] = MediaFormat.createVideoFormat(
                    params.codecMimeType, params.frameWidth,
                    params.frameHeight);
            format[i].setInteger(MediaFormat.KEY_BIT_RATE, bitrate);
            CodecProperties properties = getVideoCodecProperties(
                    true, format[i], params.forceGoogleEncoder);
            if (properties == null) {
                continue;
            }

            // Check if scaled image was created
            int scale = params.frameWidth / srcFrameWidth;
            if (!mScaledImages.contains(scale)) {
                // resize image
                cacheScaledImage(params.inputYuvFilename, params.inputResource,
                        srcFrameWidth, srcFrameHeight,
                        params.scaledYuvFilename, params.frameWidth, params.frameHeight);
                mScaledImages.add(scale);
            }

            // Create buffer info storage
            bufferInfos.add(new ArrayList<MediaCodec.BufferInfo>());

            // Create YUV reader
            yuvStream[i] = new FileInputStream(params.scaledYuvFilename);

            // Create IVF writer
            ivf[i] = new IvfWriter(
                    params.outputIvfFilename, params.codecMimeType,
                    params.frameWidth, params.frameHeight);

            // Frame buffer
            int frameSize = params.frameWidth * params.frameHeight * 3 / 2;
            srcFrame[i] = new byte[frameSize];

            // Create a media format signifying desired output.
            if (params.bitrateType == VIDEO_ControlRateConstant) {
                format[i].setInteger(""bitrate-mode"", VIDEO_ControlRateConstant); // set CBR
            }
            if (params.temporalLayers > 0) {
                format[i].setInteger(""ts-layers"", params.temporalLayers); // 1 temporal layer
            }
            format[i].setInteger(MediaFormat.KEY_COLOR_FORMAT, properties.colorFormat);
            format[i].setInteger(MediaFormat.KEY_FRAME_RATE, params.frameRate);
            int syncFrameInterval = (params.syncFrameInterval + params.frameRate/2) /
                    params.frameRate; // in sec
            format[i].setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, syncFrameInterval);
            // Create encoder
            Log.d(TAG, ""Creating encoder #"" + i +"" : "" + properties.codecName +
                    "". Color format: 0x"" + Integer.toHexString(properties.colorFormat)+ "" : "" +
                    params.frameWidth + "" x "" + params.frameHeight +
                    "". Bitrate: "" + bitrate + "" Bitrate type: "" + params.bitrateType +
                    "". Fps:"" + params.frameRate + "". TS Layers: "" + params.temporalLayers +
                    "". Key frame:"" + syncFrameInterval * params.frameRate +
                    "". Force keyFrame: "" + params.syncForceFrameInterval);
            Log.d(TAG, ""  Format: "" + format[i]);
            Log.d(TAG, ""  Output ivf:"" + params.outputIvfFilename);

            // Create encoder
            codec[i] = new MediaEncoderAsync();
            codec[i].createCodec(i, properties.codecName, format[i],
                    params.timeoutDequeue, params.runInLooperThread, params.useNdk);
            codecProperties[i] = new CodecProperties(properties.codecName, properties.colorFormat);

            inputConsumed[i] = true;
            ++numEncoders;
        }
        if (numEncoders == 0) {
            Log.i(TAG, ""no suitable encoders found for any of the streams"");
            return null;
        }

        while (!sawOutputEOSTotal) {
            // Feed input buffer to all encoders
            for (int i = 0; i < numEncoders; i++) {
                bufferConsumed[i] = false;
                if (consumedInputEOS[i]) {
                    continue;
                }

                EncoderOutputStreamParameters params = encodingParams.get(i);
                // Read new input buffers - if previous input was consumed and no EOS
                if (inputConsumed[i] && !sawInputEOS[i]) {
                    int bytesRead = yuvStream[i].read(srcFrame[i]);

                    // Check EOS
                    if (params.frameCount > 0 && inputFrameIndex[i] >= params.frameCount) {
                        sawInputEOS[i] = true;
                        Log.d(TAG, ""---Enc"" + i +
                                "". Sending EOS empty frame for frame # "" + inputFrameIndex[i]);
                    }

                    if (!sawInputEOS[i] && bytesRead == -1) {
                        if (params.frameCount == 0) {
                            sawInputEOS[i] = true;
                            Log.d(TAG, ""---Enc"" + i +
                                    "". Sending EOS empty frame for frame # "" + inputFrameIndex[i]);
                        } else {
                            yuvStream[i].close();
                            yuvStream[i] = new FileInputStream(params.scaledYuvFilename);
                            bytesRead = yuvStream[i].read(srcFrame[i]);
                        }
                    }

                    // Convert YUV420 to NV12 if necessary
                    if (codecProperties[i].colorFormat !=
                            CodecCapabilities.COLOR_FormatYUV420Planar) {
                        srcFrame[i] =
                            YUV420ToNV(params.frameWidth, params.frameHeight, srcFrame[i]);
                    }
                }

                inputConsumed[i] = codec[i].feedInput(srcFrame[i], sawInputEOS[i]);
                if (inputConsumed[i]) {
                    inputFrameIndex[i]++;
                    consumedInputEOS[i] = sawInputEOS[i];
                    bufferConsumed[i] = true;
                }

            }

            // Get output from all encoders
            for (int i = 0; i < numEncoders; i++) {
                if (sawOutputEOS[i]) {
                    continue;
                }

                MediaEncoderOutput out = codec[i].getOutput();
                if (out.outputGenerated) {
                    bufferConsumed[i] = true;
                    // Detect output EOS
                    if ((out.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {
                        Log.d(TAG, ""----Enc"" + i + "". Output EOS "");
                        sawOutputEOS[i] = true;
                    }
                    if ((out.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) != 0) {
                        Log.d(TAG, ""----Enc"" + i + "". Storing codec config separately"");
                        ByteBuffer csdBuffer = ByteBuffer.allocate(out.buffer.length).put(out.buffer);
                        csdBuffer.rewind();
                        codecConfigs.get(i).add(csdBuffer);
                        out.buffer = new byte[0];
                    }

                    if (out.buffer.length > 0) {
                        // Save frame
                        ivf[i].writeFrame(out.buffer, out.outPresentationTimeUs);

                        // Update statistics - store presentation time delay in offset
                        long presentationTimeUsDelta = out.inPresentationTimeUs -
                                out.outPresentationTimeUs;
                        MediaCodec.BufferInfo bufferInfoCopy = new MediaCodec.BufferInfo();
                        bufferInfoCopy.set((int)presentationTimeUsDelta, out.buffer.length,
                                out.outPresentationTimeUs, out.flags);
                        bufferInfos.get(i).add(bufferInfoCopy);
                    }
                }
            }

            // If codec is not ready to accept input/output - wait for buffer ready callback
            bufferConsumedTotal = false;
            for (boolean bufferConsumedCurrent : bufferConsumed) {
                bufferConsumedTotal |= bufferConsumedCurrent;
            }
            if (!bufferConsumedTotal) {
                // Pick the encoder to wait for
                for (int i = 0; i < numEncoders; i++) {
                    if (!bufferConsumed[i] && !sawOutputEOS[i]) {
                        codec[i].waitForBufferEvent();
                        break;
                    }
                }
            }

            // Check if EOS happened for all encoders
            sawOutputEOSTotal = true;
            for (boolean sawOutputEOSStream : sawOutputEOS) {
                sawOutputEOSTotal &= sawOutputEOSStream;
            }
        }

        for (int i = 0; i < numEncoders; i++) {
            codec[i].deleteCodec();
            ivf[i].close();
            yuvStream[i].close();
            if (yuvScaled[i] != null) {
                yuvScaled[i].close();
            }
        }

        return bufferInfos;
    }

    /**
     * Some encoding statistics.
     */
    protected class VideoEncodingStatistics {
        VideoEncodingStatistics() {
            mBitrates = new ArrayList<Integer>();
            mFrames = new ArrayList<Integer>();
            mKeyFrames = new ArrayList<Integer>();
            mMinimumKeyFrameInterval = Integer.MAX_VALUE;
        }

        public ArrayList<Integer> mBitrates;// Bitrate values for each second of the encoded stream.
        public ArrayList<Integer> mFrames; // Number of frames in each second of the encoded stream.
        public int mAverageBitrate;         // Average stream bitrate.
        public ArrayList<Integer> mKeyFrames;// Stores the position of key frames in a stream.
        public int mAverageKeyFrameInterval; // Average key frame interval.
        public int mMaximumKeyFrameInterval; // Maximum key frame interval.
        public int mMinimumKeyFrameInterval; // Minimum key frame interval.
    }

    /**
     * Calculates average bitrate and key frame interval for the encoded streams.
     * Output mBitrates field will contain bitrate values for every second
     * of the encoded stream.
     * Average stream bitrate will be stored in mAverageBitrate field.
     * mKeyFrames array will contain the position of key frames in the encoded stream and
     * mKeyFrameInterval - average key frame interval.
     */
    protected VideoEncodingStatistics computeEncodingStatistics(int encoderId,
            ArrayList<MediaCodec.BufferInfo> bufferInfos ) {
        VideoEncodingStatistics statistics = new VideoEncodingStatistics();

        int totalSize = 0;
        int frames = 0;
        int framesPerSecond = 0;
        int totalFrameSizePerSecond = 0;
        int maxFrameSize = 0;
        int currentSecond;
        int nextSecond = 0;
        String keyFrameList = ""  IFrame List: "";
        String bitrateList = ""  Bitrate list: "";
        String framesList = ""  FPS list: "";


        for (int j = 0; j < bufferInfos.size(); j++) {
            MediaCodec.BufferInfo info = bufferInfos.get(j);
            currentSecond = (int)(info.presentationTimeUs / 1000000);
            boolean lastFrame = (j == bufferInfos.size() - 1);
            if (!lastFrame) {
                nextSecond = (int)(bufferInfos.get(j+1).presentationTimeUs / 1000000);
            }

            totalSize += info.size;
            totalFrameSizePerSecond += info.size;
            maxFrameSize = Math.max(maxFrameSize, info.size);
            framesPerSecond++;
            frames++;

            // Update the bitrate statistics if the next frame will
            // be for the next second
            if (lastFrame || nextSecond > currentSecond) {
                int currentBitrate = totalFrameSizePerSecond * 8;
                bitrateList += (currentBitrate + "" "");
                framesList += (framesPerSecond + "" "");
                statistics.mBitrates.add(currentBitrate);
                statistics.mFrames.add(framesPerSecond);
                totalFrameSizePerSecond = 0;
                framesPerSecond = 0;
            }

            // Update key frame statistics.
            if ((info.flags & MediaCodec.BUFFER_FLAG_SYNC_FRAME) != 0) {
                statistics.mKeyFrames.add(j);
                keyFrameList += (j + ""  "");
            }
        }
        int duration = (int)(bufferInfos.get(bufferInfos.size() - 1).presentationTimeUs / 1000);
        duration = (duration + 500) / 1000;
        statistics.mAverageBitrate = (int)(((long)totalSize * 8) / duration);
        Log.d(TAG, ""Statistics for encoder # "" + encoderId);
        // Calculate average key frame interval in frames.
        int keyFrames = statistics.mKeyFrames.size();
        if (keyFrames > 1) {
            statistics.mAverageKeyFrameInterval =
                    statistics.mKeyFrames.get(keyFrames - 1) - statistics.mKeyFrames.get(0);
            statistics.mAverageKeyFrameInterval =
                    Math.round((float)statistics.mAverageKeyFrameInterval / (keyFrames - 1));
            for (int j = 1; j < keyFrames; j++) {
                int keyFrameInterval =
                        statistics.mKeyFrames.get(j) - statistics.mKeyFrames.get(j - 1);
                statistics.mMaximumKeyFrameInterval =
                        Math.max(statistics.mMaximumKeyFrameInterval, keyFrameInterval);
                statistics.mMinimumKeyFrameInterval =
                        Math.min(statistics.mMinimumKeyFrameInterval, keyFrameInterval);
            }
            Log.d(TAG, ""  Key frame intervals: Max: "" + statistics.mMaximumKeyFrameInterval +
                    "". Min: "" + statistics.mMinimumKeyFrameInterval +
                    "". Avg: "" + statistics.mAverageKeyFrameInterval);
        }
        Log.d(TAG, ""  Frames: "" + frames + "". Duration: "" + duration +
                "". Total size: "" + totalSize + "". Key frames: "" + keyFrames);
        Log.d(TAG, keyFrameList);
        Log.d(TAG, bitrateList);
        Log.d(TAG, framesList);
        Log.d(TAG, ""  Bitrate average: "" + statistics.mAverageBitrate);
        Log.d(TAG, ""  Maximum frame size: "" + maxFrameSize);

        return statistics;
    }

    protected VideoEncodingStatistics computeEncodingStatistics(
            ArrayList<MediaCodec.BufferInfo> bufferInfos ) {
        return computeEncodingStatistics(0, bufferInfos);
    }

    protected ArrayList<VideoEncodingStatistics> computeSimulcastEncodingStatistics(
            ArrayList<ArrayList<MediaCodec.BufferInfo>> bufferInfos) {
        int numCodecs = bufferInfos.size();
        ArrayList<VideoEncodingStatistics> statistics = new ArrayList<VideoEncodingStatistics>();

        for (int i = 0; i < numCodecs; i++) {
            VideoEncodingStatistics currentStatistics =
                    computeEncodingStatistics(i, bufferInfos.get(i));
            statistics.add(currentStatistics);
        }
        return statistics;
    }

    /**
     * Calculates maximum latency for encoder/decoder based on buffer info array
     * generated either by encoder or decoder.
     */
    protected int maxPresentationTimeDifference(ArrayList<MediaCodec.BufferInfo> bufferInfos) {
        int maxValue = 0;
        for (MediaCodec.BufferInfo bufferInfo : bufferInfos) {
            maxValue = Math.max(maxValue,  bufferInfo.offset);
        }
        maxValue = (maxValue + 500) / 1000; // mcs -> ms
        return maxValue;
    }

    /**
     * Decoding PSNR statistics.
     */
    protected class VideoDecodingStatistics {
        VideoDecodingStatistics() {
            mMinimumPSNR = Integer.MAX_VALUE;
        }
        public double mAveragePSNR;
        public double mMinimumPSNR;
    }

    /**
     * Calculates PSNR value between two video frames.
     */
    private double computePSNR(byte[] data0, byte[] data1) {
        long squareError = 0;
        assertTrue(data0.length == data1.length);
        int length = data0.length;
        for (int i = 0 ; i < length; i++) {
            int diff = ((int)data0[i] & 0xff) - ((int)data1[i] & 0xff);
            squareError += diff * diff;
        }
        double meanSquareError = (double)squareError / length;
        double psnr = 10 * Math.log10((double)255 * 255 / meanSquareError);
        return psnr;
    }

    /**
     * Calculates average and minimum PSNR values between
     * set of reference and decoded video frames.
     * Runs PSNR calculation for the full duration of the decoded data.
     */
    protected VideoDecodingStatistics computeDecodingStatistics(
            String referenceYuvFilename,
            String referenceYuvRaw,
            String decodedYuvFilename,
            int width,
            int height) throws Exception {
        VideoDecodingStatistics statistics = new VideoDecodingStatistics();
        InputStream referenceStream =
                OpenFileOrResource(referenceYuvFilename, referenceYuvRaw);
        InputStream decodedStream = new FileInputStream(decodedYuvFilename);

        int ySize = width * height;
        int uvSize = width * height / 4;
        byte[] yRef = new byte[ySize];
        byte[] yDec = new byte[ySize];
        byte[] uvRef = new byte[uvSize];
        byte[] uvDec = new byte[uvSize];

        int frames = 0;
        double averageYPSNR = 0;
        double averageUPSNR = 0;
        double averageVPSNR = 0;
        double minimumYPSNR = Integer.MAX_VALUE;
        double minimumUPSNR = Integer.MAX_VALUE;
        double minimumVPSNR = Integer.MAX_VALUE;
        int minimumPSNRFrameIndex = 0;

        while (true) {
            // Calculate Y PSNR.
            int bytesReadRef = referenceStream.read(yRef);
            int bytesReadDec = decodedStream.read(yDec);
            if (bytesReadDec == -1) {
                break;
            }
            if (bytesReadRef == -1) {
                // Reference file wrapping up
                referenceStream.close();
                referenceStream =
                        OpenFileOrResource(referenceYuvFilename, referenceYuvRaw);
                bytesReadRef = referenceStream.read(yRef);
            }
            double curYPSNR = computePSNR(yRef, yDec);
            averageYPSNR += curYPSNR;
            minimumYPSNR = Math.min(minimumYPSNR, curYPSNR);
            double curMinimumPSNR = curYPSNR;

            // Calculate U PSNR.
            bytesReadRef = referenceStream.read(uvRef);
            bytesReadDec = decodedStream.read(uvDec);
            double curUPSNR = computePSNR(uvRef, uvDec);
            averageUPSNR += curUPSNR;
            minimumUPSNR = Math.min(minimumUPSNR, curUPSNR);
            curMinimumPSNR = Math.min(curMinimumPSNR, curUPSNR);

            // Calculate V PSNR.
            bytesReadRef = referenceStream.read(uvRef);
            bytesReadDec = decodedStream.read(uvDec);
            double curVPSNR = computePSNR(uvRef, uvDec);
            averageVPSNR += curVPSNR;
            minimumVPSNR = Math.min(minimumVPSNR, curVPSNR);
            curMinimumPSNR = Math.min(curMinimumPSNR, curVPSNR);

            // Frame index for minimum PSNR value - help to detect possible distortions
            if (curMinimumPSNR < statistics.mMinimumPSNR) {
                statistics.mMinimumPSNR = curMinimumPSNR;
                minimumPSNRFrameIndex = frames;
            }

            String logStr = String.format(Locale.US, ""PSNR #%d: Y: %.2f. U: %.2f. V: %.2f"",
                    frames, curYPSNR, curUPSNR, curVPSNR);
            Log.v(TAG, logStr);

            frames++;
        }

        averageYPSNR /= frames;
        averageUPSNR /= frames;
        averageVPSNR /= frames;
        statistics.mAveragePSNR = (4 * averageYPSNR + averageUPSNR + averageVPSNR) / 6;

        Log.d(TAG, ""PSNR statistics for "" + frames + "" frames."");
        String logStr = String.format(Locale.US,
                ""Average PSNR: Y: %.1f. U: %.1f. V: %.1f. Average: %.1f"",
                averageYPSNR, averageUPSNR, averageVPSNR, statistics.mAveragePSNR);
        Log.d(TAG, logStr);
        logStr = String.format(Locale.US,
                ""Minimum PSNR: Y: %.1f. U: %.1f. V: %.1f. Overall: %.1f at frame %d"",
                minimumYPSNR, minimumUPSNR, minimumVPSNR,
                statistics.mMinimumPSNR, minimumPSNRFrameIndex);
        Log.d(TAG, logStr);

        referenceStream.close();
        decodedStream.close();
        return statistics;
    }
}"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.video.cts.CodecPerformanceTestBase"	"isEncoder"	"CtsVideoTestCases"	"/home/gpoor/cts-12-source/cts/tests/video/src/android/video/cts/CodecPerformanceTestBase.java"	""	"public void test/*
 *.
 */

package android.video.cts;

import android.media.MediaCodec;
import android.media.MediaCodecInfo;
import android.media.MediaCodecList;
import android.media.MediaExtractor;
import android.media.MediaFormat;
import android.os.Build;
import android.os.SystemProperties;
import android.util.Range;
import android.view.Surface;

import java.io.File;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.List;

import org.junit.Before;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.junit.Assume.assumeTrue;

class CodecPerformanceTestBase {
    private static final String LOG_TAG = CodecPerformanceTestBase.class.getSimpleName();
    static final long Q_DEQ_TIMEOUT_US = 5000; // block at most 5ms while looking for io buffers
    static final int PER_TEST_TIMEOUT_LARGE_TEST_MS = 300000;
    static final int MIN_FRAME_COUNT = 500;
    static final int SELECT_ALL = 0; // Select all codecs
    static final int SELECT_HARDWARE = 1; // Select Hardware codecs only
    static final int SELECT_SOFTWARE = 2; // Select Software codecs only
    // allowed tolerance in measured fps vs expected fps, i.e. codecs achieving fps
    // that is greater than (FPS_TOLERANCE_FACTOR * expectedFps) will be considered as
    // passing the test
    static final double FPS_TOLERANCE_FACTOR;
    static final boolean IS_AT_LEAST_VNDK_S;

    static final int DEVICE_INITIAL_SDK;

    // Some older devices can not support concurrent instances of both decoder and encoder
    // at max resolution. To handle such cases, this test is limited to test the
    // resolutions that are less than half of max supported frame sizes of encoder.
    static final boolean EXCLUDE_ENCODER_MAX_RESOLUTION;

    // Some older devices can not support concurrent instances of both decoder and encoder
    // for operating rates > 0 and < 30 for resolutions 4k
    static final boolean EXCLUDE_ENCODER_OPRATE_0_TO_30_FOR_4K;

    static final String mInputPrefix = WorkDir.getMediaDirString();

    ArrayList<MediaCodec.BufferInfo> mBufferInfos;
    ByteBuffer mBuff;

    final String mDecoderName;
    final String mTestFile;
    final int mKeyPriority;
    final float mMaxOpRateScalingFactor;

    String mDecoderMime;
    int mWidth;
    int mHeight;
    int mFrameRate;

    boolean mSawDecInputEOS = false;
    boolean mSawDecOutputEOS = false;
    int mDecInputNum = 0;
    int mDecOutputNum = 0;
    int mSampleIndex = 0;

    MediaCodec mDecoder;
    MediaFormat mDecoderFormat;
    Surface mSurface;
    double mOperatingRateExpected;

    static final float[] SCALING_FACTORS_LIST = new float[]{2.5f, 1.25f, 1.0f, 0.75f, 0.0f, -1.0f};
    static final int[] KEY_PRIORITIES_LIST = new int[]{1, 0};

    static {
        // os.Build.VERSION.DEVICE_INITIAL_SDK_INT can be used here, but it was called
        // os.Build.VERSION.FIRST_SDK_INT in Android R and below. Using DEVICE_INITIAL_SDK_INT
        // will mean that the tests built in Android S can't be run on Android R and below.
        DEVICE_INITIAL_SDK = SystemProperties.getInt(""ro.product.first_api_level"", 0);

        // fps tolerance factor is kept quite low for devices launched on Android R and lower
        FPS_TOLERANCE_FACTOR = DEVICE_INITIAL_SDK <= Build.VERSION_CODES.R ? 0.67 : 0.95;

        IS_AT_LEAST_VNDK_S = SystemProperties.getInt(""ro.vndk.version"", 0) > Build.VERSION_CODES.R;

        // Encoders on devices launched on Android Q and lower aren't tested at maximum resolution
        EXCLUDE_ENCODER_MAX_RESOLUTION = DEVICE_INITIAL_SDK <= Build.VERSION_CODES.Q;

        // Encoders on devices launched on Android R and lower aren't tested when operating rate
        // that is set is > 0 and < 30 for resolution 4k
        EXCLUDE_ENCODER_OPRATE_0_TO_30_FOR_4K = DEVICE_INITIAL_SDK <= Build.VERSION_CODES.R;
    }

    @Before
    public void prologue() {
        assumeTrue(""For VNDK R and below, operating rate <= 0 isn't tested"",
                IS_AT_LEAST_VNDK_S || mMaxOpRateScalingFactor > 0.0);

        assumeTrue(""For devices launched on Android P and below, operating rate tests are disabled"",
                DEVICE_INITIAL_SDK > Build.VERSION_CODES.P);

        if (DEVICE_INITIAL_SDK <= Build.VERSION_CODES.Q) {
            assumeTrue(""For devices launched with Android Q and below, operating rate tests are "" +
                            ""limited to operating rate scaling factor > 0.0 and <= 1.25"",
                    mMaxOpRateScalingFactor > 0.0 && mMaxOpRateScalingFactor <= 1.25);
        }
    }

    public CodecPerformanceTestBase(String decoderName, String testFile, int keyPriority,
            float maxOpRateScalingFactor) {
        mDecoderName = decoderName;
        mTestFile = testFile;
        mKeyPriority = keyPriority;
        mMaxOpRateScalingFactor = maxOpRateScalingFactor;
        mBufferInfos = new ArrayList<>();
    }

    static MediaFormat getVideoFormat(String filePath) throws IOException {
        final String input = mInputPrefix + filePath;
        MediaExtractor extractor = new MediaExtractor();
        extractor.setDataSource(input);
        for (int trackID = 0; trackID < extractor.getTrackCount(); trackID++) {
            MediaFormat format = extractor.getTrackFormat(trackID);
            if (format.getString(MediaFormat.KEY_MIME).startsWith(""video/"")) {
                extractor.release();
                return format;
            }
        }
        extractor.release();
        return null;
    }

    static ArrayList<String> selectCodecs(String mime, ArrayList<MediaFormat> formats,
            String[] features, boolean isEncoder) {
        return selectCodecs(mime, formats, features, isEncoder, SELECT_ALL);
    }

    static ArrayList<String> selectHardwareCodecs(String mime, ArrayList<MediaFormat> formats,
            String[] features, boolean isEncoder) {
        return selectCodecs(mime, formats, features, isEncoder, SELECT_HARDWARE);
    }

    static ArrayList<String> selectCodecs(String mime, ArrayList<MediaFormat> formats,
            String[] features, boolean isEncoder, int selectCodecOption) {
        MediaCodecList codecList = new MediaCodecList(MediaCodecList.REGULAR_CODECS);
        MediaCodecInfo[] codecInfos = codecList.getCodecInfos();
        ArrayList<String> listOfCodecs = new ArrayList<>();
        for (MediaCodecInfo codecInfo : codecInfos) {
            if (codecInfo.isEncoder() != isEncoder) continue;
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q && codecInfo.isAlias()) continue;
            if (selectCodecOption == SELECT_HARDWARE && !codecInfo.isHardwareAccelerated())
                continue;
            else if (selectCodecOption == SELECT_SOFTWARE && !codecInfo.isSoftwareOnly())
                continue;
            String[] types = codecInfo.getSupportedTypes();
            for (String type : types) {
                if (type.equalsIgnoreCase(mime)) {
                    boolean isOk = true;
                    MediaCodecInfo.CodecCapabilities codecCapabilities =
                            codecInfo.getCapabilitiesForType(type);
                    if (formats != null) {
                        for (MediaFormat format : formats) {
                            if (!codecCapabilities.isFormatSupported(format)) {
                                isOk = false;
                                break;
                            }
                        }
                    }
                    if (features != null) {
                        for (String feature : features) {
                            if (!codecCapabilities.isFeatureSupported(feature)) {
                                isOk = false;
                                break;
                            }
                        }
                    }
                    if (isOk) listOfCodecs.add(codecInfo.getName());
                }
            }
        }
        return listOfCodecs;
    }

    MediaFormat setUpDecoderInput() throws IOException {
        final String input = mInputPrefix + mTestFile;
        MediaExtractor extractor = new MediaExtractor();
        extractor.setDataSource(input);
        for (int trackID = 0; trackID < extractor.getTrackCount(); trackID++) {
            MediaFormat format = extractor.getTrackFormat(trackID);
            if (format.getString(MediaFormat.KEY_MIME).startsWith(""video/"")) {
                extractor.selectTrack(trackID);
                File file = new File(input);
                int bufferSize = (int) file.length();
                mBuff = ByteBuffer.allocate(bufferSize);
                int offset = 0;
                long maxPTS = 0;
                while (true) {
                    MediaCodec.BufferInfo bufferInfo = new MediaCodec.BufferInfo();
                    bufferInfo.size = extractor.readSampleData(mBuff, offset);
                    if (bufferInfo.size < 0) break;
                    bufferInfo.offset = offset;
                    bufferInfo.presentationTimeUs = extractor.getSampleTime();
                    maxPTS = Math.max(maxPTS, bufferInfo.presentationTimeUs);
                    int flags = extractor.getSampleFlags();
                    bufferInfo.flags = 0;
                    if ((flags & MediaExtractor.SAMPLE_FLAG_SYNC) != 0) {
                        bufferInfo.flags |= MediaCodec.BUFFER_FLAG_KEY_FRAME;
                    }
                    mBufferInfos.add(bufferInfo);
                    extractor.advance();
                    offset += bufferInfo.size;
                }

                // If the clip doesn't have sufficient frames, loopback by copying bufferInfos
                // from the start of the list and incrementing the timestamp.
                int actualBufferInfosCount = mBufferInfos.size();
                long ptsOffset;
                while (mBufferInfos.size() < MIN_FRAME_COUNT) {
                    ptsOffset = maxPTS + 1000000L;
                    for (int i = 0; i < actualBufferInfosCount; i++) {
                        MediaCodec.BufferInfo tmpBufferInfo = mBufferInfos.get(i);
                        MediaCodec.BufferInfo bufferInfo = new MediaCodec.BufferInfo();
                        bufferInfo.set(tmpBufferInfo.offset, tmpBufferInfo.size,
                                ptsOffset + tmpBufferInfo.presentationTimeUs,
                                tmpBufferInfo.flags);
                        maxPTS = Math.max(maxPTS, bufferInfo.presentationTimeUs);
                        mBufferInfos.add(bufferInfo);
                        if (mBufferInfos.size() >= MIN_FRAME_COUNT) break;
                    }
                }
                MediaCodec.BufferInfo bufferInfo = new MediaCodec.BufferInfo();
                bufferInfo.set(0, 0, 0, MediaCodec.BUFFER_FLAG_END_OF_STREAM);
                mBufferInfos.add(bufferInfo);
                mDecoderMime = format.getString(MediaFormat.KEY_MIME);
                mWidth = format.getInteger(MediaFormat.KEY_WIDTH);
                mHeight = format.getInteger(MediaFormat.KEY_HEIGHT);
                mFrameRate = format.getInteger(MediaFormat.KEY_FRAME_RATE, 30);
                extractor.release();
                return format;
            }
        }
        extractor.release();
        fail(""No video track found in file: "" + mTestFile);
        return null;
    }

    // TODO (b/193458026) Limit max expected fps
    static int getMaxExpectedFps(int width, int height) {
        int numSamples = width * height;
        if (numSamples > 3840 * 2160 * 2) { // 8K
            return 30;
        } else if (numSamples > 1920 * 1088 * 2) { // 4K
            return 120;
        } else {
            return 240;
        }
    }

    int getMaxOperatingRate(String codecName, String mime) throws IOException {
        MediaCodec codec = MediaCodec.createByCodecName(codecName);
        MediaCodecInfo mediaCodecInfo = codec.getCodecInfo();
        List<MediaCodecInfo.VideoCapabilities.PerformancePoint> pps = mediaCodecInfo
                .getCapabilitiesForType(mime).getVideoCapabilities()
                .getSupportedPerformancePoints();
        assertTrue(pps.size() > 0);
        MediaCodecInfo.VideoCapabilities.PerformancePoint cpp =
                new MediaCodecInfo.VideoCapabilities.PerformancePoint(mWidth, mHeight, mFrameRate);
        int macroblocks = cpp.getMaxMacroBlocks();
        int maxOperatingRate = -1;
        for (MediaCodecInfo.VideoCapabilities.PerformancePoint pp : pps) {
            if (pp.covers(cpp)) {
                maxOperatingRate = Math.max(Math.min(pp.getMaxFrameRate(),
                        (int) pp.getMaxMacroBlockRate() / macroblocks), maxOperatingRate);
            }
        }
        codec.release();
        assumeTrue(""Codec doesn't advertise performance point for "" + mWidth + ""x"" + mHeight,
                maxOperatingRate != -1);
        return maxOperatingRate;
    }

    int getEncoderMinComplexity(String codecName, String mime) throws IOException {
        MediaCodec codec = MediaCodec.createByCodecName(codecName);
        MediaCodecInfo mediaCodecInfo = codec.getCodecInfo();
        int minComplexity = -1;
        if (mediaCodecInfo.isEncoder()) {
            Range<Integer> complexityRange = mediaCodecInfo
                    .getCapabilitiesForType(mime).getEncoderCapabilities()
                    .getComplexityRange();
            minComplexity = complexityRange.getLower();
        }
        codec.release();
        return minComplexity;
    }

    static int getMaxFrameSize(String codecName, String mime) throws IOException {
        MediaCodec codec = MediaCodec.createByCodecName(codecName);
        MediaCodecInfo.CodecCapabilities codecCapabilities =
                codec.getCodecInfo().getCapabilitiesForType(mime);
        MediaCodecInfo.VideoCapabilities vc = codecCapabilities.getVideoCapabilities();
        Range<Integer> heights = vc.getSupportedHeights();
        Range<Integer> widths = vc.getSupportedWidthsFor(heights.getUpper());
        int maxFrameSize = heights.getUpper() * widths.getUpper();
        codec.release();
        return maxFrameSize;
    }

    void enqueueDecoderInput(int bufferIndex) {
        MediaCodec.BufferInfo info = mBufferInfos.get(mSampleIndex++);
        if (info.size > 0 && (info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) == 0) {
            ByteBuffer dstBuf = mDecoder.getInputBuffer(bufferIndex);
            dstBuf.put(mBuff.array(), info.offset, info.size);
            mDecInputNum++;
        }
        if ((info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {
            mSawDecInputEOS = true;
        }
        mDecoder.queueInputBuffer(bufferIndex, 0, info.size, info.presentationTimeUs, info.flags);
    }

    void dequeueDecoderOutput(int bufferIndex, MediaCodec.BufferInfo info, boolean render) {
        if (info.size > 0) {
            mDecOutputNum++;
        }
        if ((info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {
            mSawDecOutputEOS = true;
        }
        mDecoder.releaseOutputBuffer(bufferIndex, render);
    }
}"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"com.android.cts.mockime.MockImeSession"	"getCurrentInputMethodIdForTesting"	""	"/home/gpoor/cts-12-source/cts/tests/inputmethod/mockime/src/com/android/cts/mockime/MockImeSession.java"	""	"public void test/*
 *.
 */

package com.android.cts.mockime;

import static android.inputmethodservice.InputMethodService.FINISH_INPUT_NO_FALLBACK_CONNECTION;

import static androidx.test.platform.app.InstrumentationRegistry.getInstrumentation;

import static com.android.compatibility.common.util.SystemUtil.runWithShellPermissionIdentity;

import android.app.UiAutomation;
import android.app.compat.CompatChanges;
import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageManager;
import android.os.Bundle;
import android.os.Handler;
import android.os.HandlerThread;
import android.os.ParcelFileDescriptor;
import android.os.SystemClock;
import android.os.UserHandle;
import android.provider.Settings;
import android.text.TextUtils;
import android.view.KeyEvent;
import android.view.inputmethod.CompletionInfo;
import android.view.inputmethod.CorrectionInfo;
import android.view.inputmethod.ExtractedTextRequest;
import android.view.inputmethod.InputConnection;
import android.view.inputmethod.InputContentInfo;
import android.view.inputmethod.InputMethodManager;

import androidx.annotation.GuardedBy;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import com.android.compatibility.common.util.PollingCheck;

import org.junit.AssumptionViolatedException;

import java.io.IOException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * Represents an active Mock IME session, which provides basic primitives to write end-to-end tests
 * for IME APIs.
 *
 * <p>To use {@link MockIme} via {@link MockImeSession}, you need to </p>
 * <p>Public methods are not thread-safe.</p>
 */
public class MockImeSession implements AutoCloseable {
    private final String mImeEventActionName =
            ""com.android.cts.mockime.action.IME_EVENT."" + SystemClock.elapsedRealtimeNanos();

    private static final long TIMEOUT = TimeUnit.SECONDS.toMillis(10);

    @NonNull
    private final Context mContext;
    @NonNull
    private final UiAutomation mUiAutomation;

    private final HandlerThread mHandlerThread = new HandlerThread(""EventReceiver"");

    private static final class EventStore {
        private static final int INITIAL_ARRAY_SIZE = 32;

        @NonNull
        public final ImeEvent[] mArray;
        public int mLength;

        EventStore() {
            mArray = new ImeEvent[INITIAL_ARRAY_SIZE];
            mLength = 0;
        }

        EventStore(EventStore src, int newLength) {
            mArray = new ImeEvent[newLength];
            mLength = src.mLength;
            System.arraycopy(src.mArray, 0, mArray, 0, src.mLength);
        }

        public EventStore add(ImeEvent event) {
            if (mLength + 1 <= mArray.length) {
                mArray[mLength] = event;
                ++mLength;
                return this;
            } else {
                return new EventStore(this, mLength * 2).add(event);
            }
        }

        public ImeEventStream.ImeEventArray takeSnapshot() {
            return new ImeEventStream.ImeEventArray(mArray, mLength);
        }
    }

    private static final class MockImeEventReceiver extends BroadcastReceiver {
        private final Object mLock = new Object();

        @GuardedBy(""mLock"")
        @NonNull
        private EventStore mCurrentEventStore = new EventStore();

        @NonNull
        private final String mActionName;

        MockImeEventReceiver(@NonNull String actionName) {
            mActionName = actionName;
        }

        @Override
        public void onReceive(Context context, Intent intent) {
            if (TextUtils.equals(mActionName, intent.getAction())) {
                synchronized (mLock) {
                    mCurrentEventStore =
                            mCurrentEventStore.add(ImeEvent.fromBundle(intent.getExtras()));
                }
            }
        }

        public ImeEventStream.ImeEventArray takeEventSnapshot() {
            synchronized (mLock) {
                return mCurrentEventStore.takeSnapshot();
            }
        }
    }
    private final MockImeEventReceiver mEventReceiver =
            new MockImeEventReceiver(mImeEventActionName);

    private final ImeEventStream mEventStream =
            new ImeEventStream(mEventReceiver::takeEventSnapshot);

    private static String executeShellCommand(
            @NonNull UiAutomation uiAutomation, @NonNull String command) throws IOException {
        try (ParcelFileDescriptor.AutoCloseInputStream in =
                     new ParcelFileDescriptor.AutoCloseInputStream(
                             uiAutomation.executeShellCommand(command))) {
            final StringBuilder sb = new StringBuilder();
            final byte[] buffer = new byte[4096];
            while (true) {
                final int numRead = in.read(buffer);
                if (numRead <= 0) {
                    break;
                }
                sb.append(new String(buffer, 0, numRead));
            }
            return sb.toString();
        }
    }

    @Nullable
    private String getCurrentInputMethodId() {
        // TODO: Replace this with IMM#getCurrentInputMethodIdForTesting()
        return Settings.Secure.getString(mContext.getContentResolver(),
                Settings.Secure.DEFAULT_INPUT_METHOD);
    }

    @Nullable
    private static void writeMockImeSettings(@NonNull Context context,
            @NonNull String imeEventActionName,
            @Nullable ImeSettings.Builder imeSettings) throws Exception {
        final Bundle bundle = ImeSettings.serializeToBundle(imeEventActionName, imeSettings);
        context.getContentResolver().call(SettingsProvider.AUTHORITY, ""write"", null, bundle);
    }

    private ComponentName getMockImeComponentName() {
        return MockIme.getComponentName();
    }

    private String getMockImeId() {
        return MockIme.getImeId();
    }

    private MockImeSession(@NonNull Context context, @NonNull UiAutomation uiAutomation) {
        mContext = context;
        mUiAutomation = uiAutomation;
    }

    private void initialize(@Nullable ImeSettings.Builder imeSettings) throws Exception {
        // Make sure that MockIME is not selected.
        if (mContext.getSystemService(InputMethodManager.class)
                .getInputMethodList()
                .stream()
                .anyMatch(info -> getMockImeComponentName().equals(info.getComponent()))) {
            executeShellCommand(mUiAutomation, ""ime reset"");
        }
        if (mContext.getSystemService(InputMethodManager.class)
                .getEnabledInputMethodList()
                .stream()
                .anyMatch(info -> getMockImeComponentName().equals(info.getComponent()))) {
            throw new IllegalStateException();
        }

        writeMockImeSettings(mContext, mImeEventActionName, imeSettings);

        mHandlerThread.start();
        mContext.registerReceiver(mEventReceiver,
                new IntentFilter(mImeEventActionName), null /* broadcastPermission */,
                new Handler(mHandlerThread.getLooper()));

        executeShellCommand(mUiAutomation, ""ime enable "" + getMockImeId());
        executeShellCommand(mUiAutomation, ""ime set "" + getMockImeId());

        PollingCheck.check(""Make sure that MockIME becomes available"", TIMEOUT,
                () -> getMockImeId().equals(getCurrentInputMethodId()));
    }

    /** @see #create(Context, UiAutomation, ImeSettings.Builder) */
    @NonNull
    public static MockImeSession create(@NonNull Context context) throws Exception {
        return create(context, getInstrumentation().getUiAutomation(), new ImeSettings.Builder());
    }

    /**
     * Creates a new Mock IME session. During this session, you can receive various events from
     * {@link MockIme}.
     *
     * @param context {@link Context} to be used to receive inter-process events from the
     *                {@link MockIme} (e.g. via {@link BroadcastReceiver}
     * @param uiAutomation {@link UiAutomation} object to change the device state that are typically
     *                     guarded by permissions.
     * @param imeSettings Key-value pairs to be passed to the {@link MockIme}.
     * @return A session object, with which you can retrieve event logs from the {@link MockIme} and
     *         can clean up the session.
     */
    @NonNull
    public static MockImeSession create(
            @NonNull Context context,
            @NonNull UiAutomation uiAutomation,
            @Nullable ImeSettings.Builder imeSettings) throws Exception {
        final String unavailabilityReason = getUnavailabilityReason(context);
        if (unavailabilityReason != null) {
            throw new AssumptionViolatedException(unavailabilityReason);
        }

        final MockImeSession client = new MockImeSession(context, uiAutomation);
        client.initialize(imeSettings);
        return client;
    }

    /**
     * Checks if the {@link MockIme} can be used in this device.
     *
     * @return {@code null} if it can be used, or message describing why if it cannot.
     */
    @Nullable
    public static String getUnavailabilityReason(@NonNull Context context) {
        if (!context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_INPUT_METHODS)) {
            return ""Device must support installable IMEs that implement InputMethodService API"";
        }
        return null;
    }

    /**
     * Whether {@link MockIme} enabled a compatibility flag to finish input without fallback
     * input connection when device interactive state changed. See detailed description in
     * {@link MockImeSession#setEnabledFinishInputNoFallbackConnection}.
     *
     * @return {@code true} if the compatibility flag is enabled.
     */
    public static boolean isFinishInputNoFallbackConnectionEnabled() {
        AtomicBoolean result = new AtomicBoolean();
        runWithShellPermissionIdentity(() ->
                result.set(CompatChanges.isChangeEnabled(FINISH_INPUT_NO_FALLBACK_CONNECTION,
                        MockIme.getComponentName().getPackageName(), UserHandle.CURRENT)));
        return result.get();
    }

    /**
     * @return {@link ImeEventStream} object that stores events sent from {@link MockIme} since the
     *         session is created.
     */
    public ImeEventStream openEventStream() {
        return mEventStream.copy();
    }

    /**
     * Closes the active session and de-selects {@link MockIme}. Currently which IME will be
     * selected next is up to the system.
     */
    public void close() throws Exception {
        executeShellCommand(mUiAutomation, ""ime reset"");

        PollingCheck.check(""Make sure that MockIME becomes unavailable"", TIMEOUT, () ->
                mContext.getSystemService(InputMethodManager.class)
                        .getEnabledInputMethodList()
                        .stream()
                        .noneMatch(info -> getMockImeComponentName().equals(info.getComponent())));
        mContext.unregisterReceiver(mEventReceiver);
        mHandlerThread.quitSafely();
        mContext.getContentResolver().call(SettingsProvider.AUTHORITY, ""delete"", null, null);
    }

    /**
     * Common logic to send a special command to {@link MockIme}.
     *
     * @param commandName command to be passed to {@link MockIme}
     * @param params {@link Bundle} to be passed to {@link MockIme} as a parameter set of
     *               {@code commandName}
     * @return {@link ImeCommand} that is sent to {@link MockIme}.  It can be passed to
     *         {@link ImeEventStreamTestUtils#expectCommand(ImeEventStream, ImeCommand, long)} to
     *         wait until this event is handled by {@link MockIme}.
     */
    @NonNull
    private ImeCommand callCommandInternal(@NonNull String commandName, @NonNull Bundle params) {
        final ImeCommand command = new ImeCommand(
                commandName, SystemClock.elapsedRealtimeNanos(), true, params);
        final Intent intent = new Intent();
        intent.setPackage(MockIme.getComponentName().getPackageName());
        intent.setAction(MockIme.getCommandActionName(mImeEventActionName));
        intent.putExtras(command.toBundle());
        mContext.sendBroadcast(intent);
        return command;
    }

    /**
     * Lets {@link MockIme} to call
     * {@link android.inputmethodservice.InputMethodService#getCurrentInputConnection()} and
     * memorize  it for later {@link InputConnection}-related operations.
     *
     * <p>Only the last one will be memorized if this method gets called multiple times.</p>
     *
     * @return {@link ImeCommand} object that can be passed to
     *         {@link ImeEventStreamTestUtils#expectCommand(ImeEventStream, ImeCommand, long)} to
     *         wait until this event is handled by {@link MockIme}.
     * @see #unmemorizeCurrentInputConnection()
     */
    @NonNull
    public ImeCommand memorizeCurrentInputConnection() {
        final Bundle params = new Bundle();
        return callCommandInternal(""memorizeCurrentInputConnection"", params);
    }

    /**
     * Lets {@link MockIme} to forget memorized {@link InputConnection} if any. Does nothing
     * otherwise.
     *
     * @return {@link ImeCommand} object that can be passed to
     *         {@link ImeEventStreamTestUtils#expectCommand(ImeEventStream, ImeCommand, long)} to
     *         wait until this event is handled by {@link MockIme}.
     * @see #memorizeCurrentInputConnection()
     */
    @NonNull
    public ImeCommand unmemorizeCurrentInputConnection() {
        final Bundle params = new Bundle();
        return callCommandInternal(""unmemorizeCurrentInputConnection"", params);
    }

    /**
     * Lets {@link MockIme} to call {@link InputConnection#getTextBeforeCursor(int, int)} with the
     * given parameters.
     *
     * <p>This triggers {@code getCurrentInputConnection().getTextBeforeCursor(n, flag)}.</p>
     *
     * <p>Use {@link ImeEvent#getReturnCharSequenceValue()} for {@link ImeEvent} returned from
     * {@link ImeEventStreamTestUtils#expectCommand(ImeEventStream, ImeCommand, long)} to see the
     * value returned from the API.</p>
     *
     * <p>This can be affected by {@link #memorizeCurrentInputConnection()}.</p>
     *
     * @param n to be passed as the {@code n} parameter.
     * @param flag to be passed as the {@code flag} parameter.
     * @return {@link ImeCommand} object that can be passed to
     *         {@link ImeEventStreamTestUtils#expectCommand(ImeEventStream, ImeCommand, long)} to
     *         wait until this event is handled by {@link MockIme}.
     */
    @NonNull
    public ImeCommand callGetTextBeforeCursor(int n, int flag) {
        final Bundle params = new Bundle();
        params.putInt(""n"", n);
        params.putInt(""flag"", flag);
        return callCommandInternal(""getTextBeforeCursor"", params);
    }

    /**
     * Lets {@link MockIme} to call {@link InputConnection#getTextAfterCursor(int, int)} with the
     * given parameters.
     *
     * <p>This triggers {@code getCurrentInputConnection().getTextAfterCursor(n, flag)}.</p>
     *
     * <p>Use {@link ImeEvent#getReturnCharSequenceValue()} for {@link ImeEvent} returned from
     * {@link ImeEventStreamTestUtils#expectCommand(ImeEventStream, ImeCommand, long)} to see the
     * value returned from the API.</p>
     *
     * <p>This can be affected by {@link #memorizeCurrentInputConnection()}.</p>
     *
     * @param n to be passed as the {@code n} parameter.
     * @param flag to be passed as the {@code flag} parameter.
     * @return {@link ImeCommand} object that can be passed to
     *         {@link ImeEventStreamTestUtils#expectCommand(ImeEventStream, ImeCommand, long)} to
     *         wait until this event is handled by {@link MockIme}.
     */
    @NonNull
    public ImeCommand callGetTextAfterCursor(int n, int flag) {
        final Bundle params = new Bundle();
        params.putInt(""n"", n);
        params.putInt(""flag"", flag);
        return callCommandInternal(""getTextAfterCursor"", params);
    }

    /**
     * Lets {@link MockIme} to call {@link InputConnection#getSelectedText(int)} with the
     * given parameters.
     *
     * <p>This triggers {@code getCurrentInputConnection().getSelectedText(flag)}.</p>
     *
     * <p>Use {@link ImeEvent#getReturnCharSequenceValue()} for {@link ImeEvent} returned from
     * {@link ImeEventStreamTestUtils#expectCommand(ImeEventStream, ImeCommand, long)} to see the
     * value returned from the API.</p>
     *
     * <p>This can be affected by {@link #memorizeCurrentInputConnection()}.</p>
     *
     * @param flag to be passed as the {@code flag} parameter.
     * @return {@link ImeCommand} object that can be passed to
     *         {@link ImeEventStreamTestUtils#expectCommand(ImeEventStream, ImeCommand, long)} to
     *         wait until this event is handled by {@link MockIme}.
     */
    @NonNull
    public ImeCommand callGetSelectedText(int flag) {
        final Bundle params = new Bundle();
        params.putInt(""flag"", flag);
        return callCommandInternal(""getSelectedText"", params);
    }

    /**
     * Lets {@link MockIme} to call {@link InputConnection#getCursorCapsMode(int)} with the given
     * parameters.
     *
     * <p>This triggers {@code getCurrentInputConnection().getCursorCapsMode(reqModes)}.</p>
     *
     * <p>Use {@link ImeEvent#getReturnIntegerValue()} for {@link ImeEvent} returned from
     * {@link ImeEventStreamTestUtils#expectCommand(ImeEventStream, ImeCommand, long)} to see the
     * value returned from the API.</p>
     *
     * <p>This can be affected by {@link #memorizeCurrentInputConnection()}.</p>
     *
     * @param reqModes to be passed as the {@code reqModes} parameter.
     * @return {@link ImeCommand} object that can be passed to
     *         {@link ImeEventStreamTestUtils#expectCommand(ImeEventStream, ImeCommand, long)} to
     *         wait until this event is handled by {@link MockIme}.
     */
    @NonNull
    public ImeCommand callGetCursorCapsMode(int reqModes) {
        final Bundle params = new Bundle();
        params.putInt(""reqModes"", reqModes);
        return callCommandInternal(""getCursorCapsMode"", params);
    }

    /**
     * Lets {@link MockIme} to call
     * {@link InputConnection#getExtractedText(ExtractedTextRequest, int)} with the given
     * parameters.
     *
     * <p>This triggers {@code getCurrentInputConnection().getExtractedText(request, flags)}.</p>
     *
     * <p>Use {@link ImeEvent#getReturnParcelableValue()} for {@link ImeEvent} returned from
     * {@link ImeEventStreamTestUtils#expectCommand(ImeEventStream, ImeCommand, long)} to see the
     * value returned from the API.</p>
     *
     * <p>This can be affected by {@link #memorizeCurrentInputConnection()}.</p>
     *
     * @param request to be passed as the {@code request} parameter
     * @param flags to be passed as the {@code flags} parameter
     * @return {@link ImeCommand} object that can be passed to
     *         {@link ImeEventStreamTestUtils#expectCommand(ImeEventStream, ImeCommand, long)} to
     *         wait until this event is handled by {@link MockIme}.
     */
    @NonNull
    public ImeCommand callGetExtractedText(@Nullable ExtractedTextRequest request, int flags) {
        final Bundle params = new Bundle();
        params.putParcelable(""request"", request);
        params.putInt(""flags"", flags);
        return callCommandInternal(""getExtractedText"", params);
    }

    /**
     * Lets {@link MockIme} to call {@link InputConnection#deleteSurroundingText(int, int)} with the
     * given parameters.
     *
     * <p>This triggers
     * {@code getCurrentInputConnection().deleteSurroundingText(beforeLength, afterLength)}.</p>
     *
     * <p>Use {@link ImeEvent#getReturnBooleanValue()} for {@link ImeEvent} returned from
     * {@link ImeEventStreamTestUtils#expectCommand(ImeEventStream, ImeCommand, long)} to see the
     * value returned from the API.</p>
     *
     * <p>This can be affected by {@link #memorizeCurrentInputConnection()}.</p>
     *
     * @param beforeLength to be passed as the {@code beforeLength} parameter
     * @param afterLength to be passed as the {@code afterLength} parameter
     * @return {@link ImeCommand} object that can be passed to
     *         {@link ImeEventStreamTestUtils#expectCommand(ImeEventStream, ImeCommand, long)} to
     *         wait until this event is handled by {@link MockIme}.
     */
    @NonNull
    public ImeCommand callDeleteSurroundingText(int beforeLength, int afterLength) {
        final Bundle params = new Bundle();
        params.putInt(""beforeLength"", beforeLength);
        params.putInt(""afterLength"", afterLength);
        return callCommandInternal(""deleteSurroundingText"", params);
    }

    /**
     * Lets {@link MockIme} to call
     * {@link InputConnection#deleteSurroundingTextInCodePoints(int, int)} with the given
     * parameters.
     *
     * <p>This triggers {@code getCurrentInputConnection().deleteSurroundingTextInCodePoints(
     * beforeLength, afterLength)}.</p>
     *
     * <p>Use {@link ImeEvent#getReturnBooleanValue()} for {@link ImeEvent} returned from
     * {@link ImeEventStreamTestUtils#expectCommand(ImeEventStream, ImeCommand, long)} to see the
     * value returned from the API.</p>
     *
     * <p>This can be affected by {@link #memorizeCurrentInputConnection()}.</p>
     *
     * @param beforeLength to be passed as the {@code beforeLength} parameter
     * @param afterLength to be passed as the {@code afterLength} parameter
     * @return {@link ImeCommand} object that can be passed to
     *         {@link ImeEventStreamTestUtils#expectCommand(ImeEventStream, ImeCommand, long)} to
     *         wait until this event is handled by {@link MockIme}.
     */
    @NonNull
    public ImeCommand callDeleteSurroundingTextInCodePoints(int beforeLength, int afterLength) {
        final Bundle params = new Bundle();
        params.putInt(""beforeLength"", beforeLength);
        params.putInt(""afterLength"", afterLength);
        return callCommandInternal(""deleteSurroundingTextInCodePoints"", params);
    }

    /**
     * Lets {@link MockIme} to call {@link InputConnection#setComposingText(CharSequence, int)} with
     * the given parameters.
     *
     * <p>This triggers
     * {@code getCurrentInputConnection().setComposingText(text, newCursorPosition)}.</p>
     *
     * <p>Use {@link ImeEvent#getReturnBooleanValue()} for {@link ImeEvent} returned from
     * {@link ImeEventStreamTestUtils#expectCommand(ImeEventStream, ImeCommand, long)} to see the
     * value returned from the API.</p>
     *
     * <p>This can be affected by {@link #memorizeCurrentInputConnection()}.</p>
     *
     * @param text to be passed as the {@code text} parameter
     * @param newCursorPosition to be passed as the {@code newCursorPosition} parameter
     * @return {@link ImeCommand} object that can be passed to
     *         {@link ImeEventStreamTestUtils#expectCommand(ImeEventStream, ImeCommand, long)} to
     *         wait until this event is handled by {@link MockIme}.
     */
    @NonNull
    public ImeCommand callSetComposingText(@Nullable CharSequence text, int newCursorPosition) {
        final Bundle params = new Bundle();
        params.putCharSequence(""text"", text);
        params.putInt(""newCursorPosition"", newCursorPosition);
        return callCommandInternal(""setComposingText"", params);
    }

    /**
     * Lets {@link MockIme} to call {@link InputConnection#setComposingRegion(int, int)} with the
     * given parameters.
     *
     * <p>This triggers {@code getCurrentInputConnection().setComposingRegion(start, end)}.</p>
     *
     * <p>Use {@link ImeEvent#getReturnBooleanValue()} for {@link ImeEvent} returned from
     * {@link ImeEventStreamTestUtils#expectCommand(ImeEventStream, ImeCommand, long)} to see the
     * value returned from the API.</p>
     *
     * <p>This can be affected by {@link #memorizeCurrentInputConnection()}.</p>
     *
     * @param start to be passed as the {@code start} parameter
     * @param end to be passed as the {@code end} parameter
     * @return {@link ImeCommand} object that can be passed to
     *         {@link ImeEventStreamTestUtils#expectCommand(ImeEventStream, ImeCommand, long)} to
     *         wait until this event is handled by {@link MockIme}.
     */
    @NonNull
    public ImeCommand callSetComposingRegion(int start, int end) {
        final Bundle params = new Bundle();
        params.putInt(""start"", start);
        params.putInt(""end"", end);
        return callCommandInternal(""setComposingRegion"", params);
    }

    /**
     * Lets {@link MockIme} to call {@link InputConnection#finishComposingText()} with the given
     * parameters.
     *
     * <p>This triggers {@code getCurrentInputConnection().finishComposingText()}.</p>
     *
     * <p>Use {@link ImeEvent#getReturnBooleanValue()} for {@link ImeEvent} returned from
     * {@link ImeEventStreamTestUtils#expectCommand(ImeEventStream, ImeCommand, long)} to see the
     * value returned from the API.</p>
     *
     * <p>This can be affected by {@link #memorizeCurrentInputConnection()}.</p>
     *
     * @return {@link ImeCommand} object that can be passed to
     *         {@link ImeEventStreamTestUtils#expectCommand(ImeEventStream, ImeCommand, long)} to
     *         wait until this event is handled by {@link MockIme}.
     */
    @NonNull
    public ImeCommand callFinishComposingText() {
        final Bundle params = new Bundle();
        return callCommandInternal(""finishComposingText"", params);
    }

    /**
     * Lets {@link MockIme} to call {@link InputConnection#commitText(CharSequence, int)} with the
     * given parameters.
     *
     * <p>This triggers {@code getCurrentInputConnection().commitText(text, newCursorPosition)}.</p>
     *
     * <p>Use {@link ImeEvent#getReturnBooleanValue()} for {@link ImeEvent} returned from
     * {@link ImeEventStreamTestUtils#expectCommand(ImeEventStream, ImeCommand, long)} to see the
     * value returned from the API.</p>
     *
     * <p>This can be affected by {@link #memorizeCurrentInputConnection()}.</p>
     *
     * @param text to be passed as the {@code text} parameter
     * @param newCursorPosition to be passed as the {@code newCursorPosition} parameter
     * @return {@link ImeCommand} object that can be passed to
     *         {@link ImeEventStreamTestUtils#expectCommand(ImeEventStream, ImeCommand, long)} to
     *         wait until this event is handled by {@link MockIme}
     */
    @NonNull
    public ImeCommand callCommitText(@Nullable CharSequence text, int newCursorPosition) {
        final Bundle params = new Bundle();
        params.putCharSequence(""text"", text);
        params.putInt(""newCursorPosition"", newCursorPosition);
        return callCommandInternal(""commitText"", params);
    }

    /**
     * Lets {@link MockIme} to call {@link InputConnection#commitCompletion(CompletionInfo)} with
     * the given parameters.
     *
     * <p>This triggers {@code getCurrentInputConnection().commitCompletion(text)}.</p>
     *
     * <p>Use {@link ImeEvent#getReturnBooleanValue()} for {@link ImeEvent} returned from
     * {@link ImeEventStreamTestUtils#expectCommand(ImeEventStream, ImeCommand, long)} to see the
     * value returned from the API.</p>
     *
     * <p>This can be affected by {@link #memorizeCurrentInputConnection()}.</p>
     *
     * @param text to be passed as the {@code text} parameter
     * @return {@link ImeCommand} object that can be passed to
     *         {@link ImeEventStreamTestUtils#expectCommand(ImeEventStream, ImeCommand, long)} to
     *         wait until this event is handled by {@link MockIme}
     */
    @NonNull
    public ImeCommand callCommitCompletion(@Nullable CompletionInfo text) {
        final Bundle params = new Bundle();
        params.putParcelable(""text"", text);
        return callCommandInternal(""commitCompletion"", params);
    }

    /**
     * Lets {@link MockIme} to call {@link InputConnection#commitCorrection(CorrectionInfo)} with
     * the given parameters.
     *
     * <p>This triggers {@code getCurrentInputConnection().commitCorrection(correctionInfo)}.</p>
     *
     * <p>Use {@link ImeEvent#getReturnBooleanValue()} for {@link ImeEvent} returned from
     * {@link ImeEventStreamTestUtils#expectCommand(ImeEventStream, ImeCommand, long)} to see the
     * value returned from the API.</p>
     *
     * <p>This can be affected by {@link #memorizeCurrentInputConnection()}.</p>
     *
     * @param correctionInfo to be passed as the {@code correctionInfo} parameter
     * @return {@link ImeCommand} object that can be passed to
     *         {@link ImeEventStreamTestUtils#expectCommand(ImeEventStream, ImeCommand, long)} to
     *         wait until this event is handled by {@link MockIme}
     */
    @NonNull
    public ImeCommand callCommitCorrection(@Nullable CorrectionInfo correctionInfo) {
        final Bundle params = new Bundle();
        params.putParcelable(""correctionInfo"", correctionInfo);
        return callCommandInternal(""commitCorrection"", params);
    }

    /**
     * Lets {@link MockIme} to call {@link InputConnection#setSelection(int, int)} with the given
     * parameters.
     *
     * <p>This triggers {@code getCurrentInputConnection().setSelection(start, end)}.</p>
     *
     * <p>Use {@link ImeEvent#getReturnBooleanValue()} for {@link ImeEvent} returned from
     * {@link ImeEventStreamTestUtils#expectCommand(ImeEventStream, ImeCommand, long)} to see the
     * value returned from the API.</p>
     *
     * <p>This can be affected by {@link #memorizeCurrentInputConnection()}.</p>
     *
     * @param start to be passed as the {@code start} parameter
     * @param end to be passed as the {@code end} parameter
     * @return {@link ImeCommand} object that can be passed to
     *         {@link ImeEventStreamTestUtils#expectCommand(ImeEventStream, ImeCommand, long)} to
     *         wait until this event is handled by {@link MockIme}
     */
    @NonNull
    public ImeCommand callSetSelection(int start, int end) {
        final Bundle params = new Bundle();
        params.putInt(""start"", start);
        params.putInt(""end"", end);
        return callCommandInternal(""setSelection"", params);
    }

    /**
     * Lets {@link MockIme} to call {@link InputConnection#performEditorAction(int)} with the given
     * parameters.
     *
     * <p>This triggers {@code getCurrentInputConnection().performEditorAction(editorAction)}.</p>
     *
     * <p>Use {@link ImeEvent#getReturnBooleanValue()} for {@link ImeEvent} returned from
     * {@link ImeEventStreamTestUtils#expectCommand(ImeEventStream, ImeCommand, long)} to see the
     * value returned from the API.</p>
     *
     * <p>This can be affected by {@link #memorizeCurrentInputConnection()}.</p>
     *
     * @param editorAction to be passed as the {@code editorAction} parameter
     * @return {@link ImeCommand} object that can be passed to
     *         {@link ImeEventStreamTestUtils#expectCommand(ImeEventStream, ImeCommand, long)} to
     *         wait until this event is handled by {@link MockIme}
     */
    @NonNull
    public ImeCommand callPerformEditorAction(int editorAction) {
        final Bundle params = new Bundle();
        params.putInt(""editorAction"", editorAction);
        return callCommandInternal(""performEditorAction"", params);
    }

    /**
     * Lets {@link MockIme} to call {@link InputConnection#performContextMenuAction(int)} with the
     * given parameters.
     *
     * <p>This triggers {@code getCurrentInputConnection().performContextMenuAction(id)}.</p>
     *
     * <p>Use {@link ImeEvent#getReturnBooleanValue()} for {@link ImeEvent} returned from
     * {@link ImeEventStreamTestUtils#expectCommand(ImeEventStream, ImeCommand, long)} to see the
     * value returned from the API.</p>
     *
     * <p>This can be affected by {@link #memorizeCurrentInputConnection()}.</p>
     *
     * @param id to be passed as the {@code id} parameter
     * @return {@link ImeCommand} object that can be passed to
     *         {@link ImeEventStreamTestUtils#expectCommand(ImeEventStream, ImeCommand, long)} to
     *         wait until this event is handled by {@link MockIme}
     */
    @NonNull
    public ImeCommand callPerformContextMenuAction(int id) {
        final Bundle params = new Bundle();
        params.putInt(""id"", id);
        return callCommandInternal(""performContextMenuAction"", params);
    }

    /**
     * Lets {@link MockIme} to call {@link InputConnection#beginBatchEdit()} with the given
     * parameters.
     *
     * <p>This triggers {@code getCurrentInputConnection().beginBatchEdit()}.</p>
     *
     * <p>Use {@link ImeEvent#getReturnBooleanValue()} for {@link ImeEvent} returned from
     * {@link ImeEventStreamTestUtils#expectCommand(ImeEventStream, ImeCommand, long)} to see the
     * value returned from the API.</p>
     *
     * <p>This can be affected by {@link #memorizeCurrentInputConnection()}.</p>
     *
     * @return {@link ImeCommand} object that can be passed to
     *         {@link ImeEventStreamTestUtils#expectCommand(ImeEventStream, ImeCommand, long)} to
     *         wait until this event is handled by {@link MockIme}
     */
    @NonNull
    public ImeCommand callBeginBatchEdit() {
        final Bundle params = new Bundle();
        return callCommandInternal(""beginBatchEdit"", params);
    }

    /**
     * Lets {@link MockIme} to call {@link InputConnection#endBatchEdit()} with the given
     * parameters.
     *
     * <p>This triggers {@code getCurrentInputConnection().endBatchEdit()}.</p>
     *
     * <p>Use {@link ImeEvent#getReturnBooleanValue()} for {@link ImeEvent} returned from
     * {@link ImeEventStreamTestUtils#expectCommand(ImeEventStream, ImeCommand, long)} to see the
     * value returned from the API.</p>
     *
     * <p>This can be affected by {@link #memorizeCurrentInputConnection()}.</p>
     *
     * @return {@link ImeCommand} object that can be passed to
     *         {@link ImeEventStreamTestUtils#expectCommand(ImeEventStream, ImeCommand, long)} to
     *         wait until this event is handled by {@link MockIme}
     */
    @NonNull
    public ImeCommand callEndBatchEdit() {
        final Bundle params = new Bundle();
        return callCommandInternal(""endBatchEdit"", params);
    }

    /**
     * Lets {@link MockIme} to call {@link InputConnection#sendKeyEvent(KeyEvent)} with the given
     * parameters.
     *
     * <p>This triggers {@code getCurrentInputConnection().sendKeyEvent(event)}.</p>
     *
     * <p>Use {@link ImeEvent#getReturnBooleanValue()} for {@link ImeEvent} returned from
     * {@link ImeEventStreamTestUtils#expectCommand(ImeEventStream, ImeCommand, long)} to see the
     * value returned from the API.</p>
     *
     * <p>This can be affected by {@link #memorizeCurrentInputConnection()}.</p>
     *
     * @param event to be passed as the {@code event} parameter
     * @return {@link ImeCommand} object that can be passed to
     *         {@link ImeEventStreamTestUtils#expectCommand(ImeEventStream, ImeCommand, long)} to
     *         wait until this event is handled by {@link MockIme}
     */
    @NonNull
    public ImeCommand callSendKeyEvent(@Nullable KeyEvent event) {
        final Bundle params = new Bundle();
        params.putParcelable(""event"", event);
        return callCommandInternal(""sendKeyEvent"", params);
    }

    /**
     * Lets {@link MockIme} to call {@link InputConnection#performSpellCheck()}.
     *
     * <p>This triggers {@code getCurrentInputConnection().performSpellCheck()}.</p>
     *
     * <p>This can be affected by {@link #memorizeCurrentInputConnection()}.</p>

     * @return {@link ImeCommand} object that can be passed to
     *         {@link ImeEventStreamTestUtils#expectCommand(ImeEventStream, ImeCommand, long)} to
     *         wait until this event is handled by {@link MockIme}
     */
    @NonNull
    public ImeCommand callPerformSpellCheck() {
        return callCommandInternal(""performSpellCheck"", new Bundle());
    }

    /**
     * Lets {@link MockIme} to call {@link InputConnection#clearMetaKeyStates(int)} with the given
     * parameters.
     *
     * <p>This triggers {@code getCurrentInputConnection().sendKeyEvent(event)}.</p>
     *
     * <p>Use {@link ImeEvent#getReturnBooleanValue()} for {@link ImeEvent} returned from
     * {@link ImeEventStreamTestUtils#expectCommand(ImeEventStream, ImeCommand, long)} to see the
     * value returned from the API.</p>
     *
     * <p>This can be affected by {@link #memorizeCurrentInputConnection()}.</p>
     *
     * @param states to be passed as the {@code states} parameter
     * @return {@link ImeCommand} object that can be passed to
     *         {@link ImeEventStreamTestUtils#expectCommand(ImeEventStream, ImeCommand, long)} to
     *         wait until this event is handled by {@link MockIme}
     */
    @NonNull
    public ImeCommand callClearMetaKeyStates(int states) {
        final Bundle params = new Bundle();
        params.putInt(""states"", states);
        return callCommandInternal(""clearMetaKeyStates"", params);
    }

    /**
     * Lets {@link MockIme} to call {@link InputConnection#reportFullscreenMode(boolean)} with the
     * given parameters.
     *
     * <p>This triggers {@code getCurrentInputConnection().reportFullscreenMode(enabled)}.</p>
     *
     * <p>Use {@link ImeEvent#getReturnBooleanValue()} for {@link ImeEvent} returned from
     * {@link ImeEventStreamTestUtils#expectCommand(ImeEventStream, ImeCommand, long)} to see the
     * value returned from the API.</p>
     *
     * <p>This can be affected by {@link #memorizeCurrentInputConnection()}.</p>
     *
     * @param enabled to be passed as the {@code enabled} parameter
     * @return {@link ImeCommand} object that can be passed to
     *         {@link ImeEventStreamTestUtils#expectCommand(ImeEventStream, ImeCommand, long)} to
     *         wait until this event is handled by {@link MockIme}
     */
    @NonNull
    public ImeCommand callReportFullscreenMode(boolean enabled) {
        final Bundle params = new Bundle();
        params.putBoolean(""enabled"", enabled);
        return callCommandInternal(""reportFullscreenMode"", params);
    }

    /**
     * Lets {@link MockIme} to call {@link InputConnection#performPrivateCommand(String, Bundle)}
     * with the given parameters.
     *
     * <p>This triggers {@code getCurrentInputConnection().performPrivateCommand(action, data)}.</p>
     *
     * <p>Use {@link ImeEvent#getReturnBooleanValue()} for {@link ImeEvent} returned from
     * {@link ImeEventStreamTestUtils#expectCommand(ImeEventStream, ImeCommand, long)} to see the
     * value returned from the API.</p>
     *
     * <p>This can be affected by {@link #memorizeCurrentInputConnection()}.</p>
     *
     * @param action to be passed as the {@code action} parameter
     * @param data to be passed as the {@code data} parameter
     * @return {@link ImeCommand} object that can be passed to
     *         {@link ImeEventStreamTestUtils#expectCommand(ImeEventStream, ImeCommand, long)} to
     *         wait until this event is handled by {@link MockIme}
     */
    @NonNull
    public ImeCommand callPerformPrivateCommand(@Nullable String action, Bundle data) {
        final Bundle params = new Bundle();
        params.putString(""action"", action);
        params.putBundle(""data"", data);
        return callCommandInternal(""performPrivateCommand"", params);
    }

    /**
     * Lets {@link MockIme} to call {@link InputConnection#requestCursorUpdates(int)} with the given
     * parameters.
     *
     * <p>This triggers {@code getCurrentInputConnection().requestCursorUpdates(cursorUpdateMode)}.
     * </p>
     *
     * <p>Use {@link ImeEvent#getReturnBooleanValue()} for {@link ImeEvent} returned from
     * {@link ImeEventStreamTestUtils#expectCommand(ImeEventStream, ImeCommand, long)} to see the
     * value returned from the API.</p>
     *
     * <p>This can be affected by {@link #memorizeCurrentInputConnection()}.</p>
     *
     * @param cursorUpdateMode to be passed as the {@code cursorUpdateMode} parameter
     * @return {@link ImeCommand} object that can be passed to
     *         {@link ImeEventStreamTestUtils#expectCommand(ImeEventStream, ImeCommand, long)} to
     *         wait until this event is handled by {@link MockIme}
     */
    @NonNull
    public ImeCommand callRequestCursorUpdates(int cursorUpdateMode) {
        final Bundle params = new Bundle();
        params.putInt(""cursorUpdateMode"", cursorUpdateMode);
        return callCommandInternal(""requestCursorUpdates"", params);
    }

    /**
     * Lets {@link MockIme} to call {@link InputConnection#getHandler()} with the given parameters.
     *
     * <p>This triggers {@code getCurrentInputConnection().getHandler()}.</p>
     *
     * <p>Use {@link ImeEvent#isNullReturnValue()} for {@link ImeEvent} returned from
     * {@link ImeEventStreamTestUtils#expectCommand(ImeEventStream, ImeCommand, long)} to see the
     * value returned from the API was {@code null} or not.</p>
     *
     * <p>This can be affected by {@link #memorizeCurrentInputConnection()}.</p>
     *
     * @return {@link ImeCommand} object that can be passed to
     *         {@link ImeEventStreamTestUtils#expectCommand(ImeEventStream, ImeCommand, long)} to
     *         wait until this event is handled by {@link MockIme}
     */
    @NonNull
    public ImeCommand callGetHandler() {
        final Bundle params = new Bundle();
        return callCommandInternal(""getHandler"", params);
    }

    /**
     * Lets {@link MockIme} to call {@link InputConnection#closeConnection()} with the given
     * parameters.
     *
     * <p>This triggers {@code getCurrentInputConnection().closeConnection()}.</p>
     *
     * <p>Return value information is not available for this command.</p>
     *
     * <p>This can be affected by {@link #memorizeCurrentInputConnection()}.</p>
     *
     * @return {@link ImeCommand} object that can be passed to
     *         {@link ImeEventStreamTestUtils#expectCommand(ImeEventStream, ImeCommand, long)} to
     *         wait until this event is handled by {@link MockIme}
     */
    @NonNull
    public ImeCommand callCloseConnection() {
        final Bundle params = new Bundle();
        return callCommandInternal(""closeConnection"", params);
    }

    /**
     * Lets {@link MockIme} to call
     * {@link InputConnection#commitContent(InputContentInfo, int, Bundle)} with the given
     * parameters.
     *
     * <p>This triggers
     * {@code getCurrentInputConnection().commitContent(inputContentInfo, flags, opts)}.</p>
     *
     * <p>Use {@link ImeEvent#getReturnBooleanValue()} for {@link ImeEvent} returned from
     * {@link ImeEventStreamTestUtils#expectCommand(ImeEventStream, ImeCommand, long)} to see the
     * value returned from the API.</p>
     *
     * <p>This can be affected by {@link #memorizeCurrentInputConnection()}.</p>
     *
     * @param inputContentInfo to be passed as the {@code inputContentInfo} parameter
     * @param flags to be passed as the {@code flags} parameter
     * @param opts to be passed as the {@code opts} parameter
     * @return {@link ImeCommand} object that can be passed to
     *         {@link ImeEventStreamTestUtils#expectCommand(ImeEventStream, ImeCommand, long)} to
     *         wait until this event is handled by {@link MockIme}
     */
    @NonNull
    public ImeCommand callCommitContent(@NonNull InputContentInfo inputContentInfo, int flags,
            @Nullable Bundle opts) {
        final Bundle params = new Bundle();
        params.putParcelable(""inputContentInfo"", inputContentInfo);
        params.putInt(""flags"", flags);
        params.putBundle(""opts"", opts);
        return callCommandInternal(""commitContent"", params);
    }

    /**
     * Lets {@link MockIme} to call
     * {@link android.inputmethodservice.InputMethodService#setBackDisposition(int)} with the given
     * parameters.
     *
     * <p>This triggers {@code setBackDisposition(backDisposition)}.</p>
     *
     * @param backDisposition to be passed as the {@code backDisposition} parameter
     * @return {@link ImeCommand} object that can be passed to
     *         {@link ImeEventStreamTestUtils#expectCommand(ImeEventStream, ImeCommand, long)} to
     *         wait until this event is handled by {@link MockIme}
     */
    @NonNull
    public ImeCommand callSetBackDisposition(int backDisposition) {
        final Bundle params = new Bundle();
        params.putInt(""backDisposition"", backDisposition);
        return callCommandInternal(""setBackDisposition"", params);
    }

    /**
     * Lets {@link MockIme} to call
     * {@link android.inputmethodservice.InputMethodService#requestHideSelf(int)} with the given
     * parameters.
     *
     * <p>This triggers {@code requestHideSelf(flags)}.</p>
     *
     * @param flags to be passed as the {@code flags} parameter
     * @return {@link ImeCommand} object that can be passed to
     *         {@link ImeEventStreamTestUtils#expectCommand(ImeEventStream, ImeCommand, long)} to
     *         wait until this event is handled by {@link MockIme}
     */
    @NonNull
    public ImeCommand callRequestHideSelf(int flags) {
        final Bundle params = new Bundle();
        params.putInt(""flags"", flags);
        return callCommandInternal(""requestHideSelf"", params);
    }

    /**
     * Lets {@link MockIme} to call
     * {@link android.inputmethodservice.InputMethodService#requestShowSelf(int)} with the given
     * parameters.
     *
     * <p>This triggers {@code requestShowSelf(flags)}.</p>
     *
     * @param flags to be passed as the {@code flags} parameter
     * @return {@link ImeCommand} object that can be passed to
     *         {@link ImeEventStreamTestUtils#expectCommand(ImeEventStream, ImeCommand, long)} to
     *         wait until this event is handled by {@link MockIme}
     */
    @NonNull
    public ImeCommand callRequestShowSelf(int flags) {
        final Bundle params = new Bundle();
        params.putInt(""flags"", flags);
        return callCommandInternal(""requestShowSelf"", params);
    }

    /**
     * Lets {@link MockIme} call
     * {@link android.inputmethodservice.InputMethodService#sendDownUpKeyEvents(int)} with the given
     * {@code keyEventCode}.
     *
     * @param keyEventCode to be passed as the {@code keyEventCode} parameter.
     * @return {@link ImeCommand} object that can be passed to
     *         {@link ImeEventStreamTestUtils#expectCommand(ImeEventStream, ImeCommand, long)} to
     *         wait until this event is handled by {@link MockIme}
     */
    @NonNull
    public ImeCommand callSendDownUpKeyEvents(int keyEventCode) {
        final Bundle params = new Bundle();
        params.putInt(""keyEventCode"", keyEventCode);
        return callCommandInternal(""sendDownUpKeyEvents"", params);
    }

    /**
     * Lets {@link MockIme} call
     * {@link android.content.pm.PackageManager#getApplicationInfo(String, int)} with the given
     * {@code packageName} and {@code flags}.
     *
     * @param packageName the package name to be passed to
     *                    {@link android.content.pm.PackageManager#getApplicationInfo(String, int)}.
     * @param flags the flags to be passed to
     *                    {@link android.content.pm.PackageManager#getApplicationInfo(String, int)}.
     * @return {@link ImeCommand} object that can be passed to
     *         {@link ImeEventStreamTestUtils#expectCommand(ImeEventStream, ImeCommand, long)} to
     *         wait until this event is handled by {@link MockIme}.
     */
    @NonNull
    public ImeCommand callGetApplicationInfo(@NonNull String packageName, int flags) {
        final Bundle params = new Bundle();
        params.putString(""packageName"", packageName);
        params.putInt(""flags"", flags);
        return callCommandInternal(""getApplicationInfo"", params);
    }

    @NonNull
    public ImeCommand callGetDisplayId() {
        final Bundle params = new Bundle();
        return callCommandInternal(""getDisplayId"", params);
    }

    /**
     * Verifies {@code InputMethodService.getLayoutInflater().getContext()} is equal to
     * {@code InputMethodService.this}.
     *
     * @return {@link ImeCommand} object that can be passed to
     *         {@link ImeEventStreamTestUtils#expectCommand(ImeEventStream, ImeCommand, long)} to
     *         wait until this event is handled by {@link MockIme}
     */
    @NonNull
    public ImeCommand verifyLayoutInflaterContext() {
        final Bundle params = new Bundle();
        return callCommandInternal(""verifyLayoutInflaterContext"", params);
    }

    @NonNull
    public ImeCommand callSetHeight(int height) {
        final Bundle params = new Bundle();
        params.putInt(""height"", height);
        return callCommandInternal(""setHeight"", params);
    }

    @NonNull
    public ImeCommand callSetInlineSuggestionsExtras(@NonNull Bundle bundle) {
        return callCommandInternal(""setInlineSuggestionsExtras"", bundle);
    }

    @NonNull
    public ImeCommand callVerifyGetDisplay() {
        return callCommandInternal(""verifyGetDisplay"", new Bundle());
    }

    @NonNull
    public ImeCommand callVerifyGetWindowManager() {
        return callCommandInternal(""verifyGetWindowManager"", new Bundle());
    }

    @NonNull
    public ImeCommand callVerifyGetViewConfiguration() {
        return callCommandInternal(""verifyGetViewConfiguration"", new Bundle());
    }

    @NonNull
    public ImeCommand callVerifyGetGestureDetector() {
        return callCommandInternal(""verifyGetGestureDetector"", new Bundle());
    }

    @NonNull
    public ImeCommand callVerifyGetWindowManagerOnDisplayContext() {
        return callCommandInternal(""verifyGetWindowManagerOnDisplayContext"", new Bundle());
    }

    @NonNull
    public ImeCommand callVerifyGetViewConfigurationOnDisplayContext() {
        return callCommandInternal(""verifyGetViewConfigurationOnDisplayContext"", new Bundle());
    }

    @NonNull
    public ImeCommand callVerifyGetGestureDetectorOnDisplayContext() {
        return callCommandInternal(""verifyGetGestureDetectorOnDisplayContext"", new Bundle());
    }
}"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.view.cts.ContentPaneFocusTest"	"testAccessActionBar"	"CtsViewTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/view/src/android/view/cts/ContentPaneFocusTest.java"	""	"public void testAccessActionBar() throws Throwable {
        final View v1 = mActivity.findViewById(R.id.view1);
        mActivityRule.runOnUiThread(v1::requestFocus);

        mInstrumentation.waitForIdleSync();
        sendMetaHotkey(KeyEvent.KEYCODE_TAB);
        mInstrumentation.waitForIdleSync();

        ActionBar action = mActivity.getActionBar();
        if (action == null || !action.isShowing()) {
            // No action bar, so we only needed to make sure that the shortcut didn't cause
            // the framework to crash.
            return;
        }

        final View actionBar = getActionBarView();
        // Should jump to the action bar after meta+tab
        mActivityRule.runOnUiThread(() -> {
            assertFalse(v1.hasFocus());
            assertTrue(actionBar.hasFocus());
        });

        boolean isTouchScreen = mActivity.getPackageManager()
                .hasSystemFeature(PackageManager.FEATURE_TOUCHSCREEN);
        if (isTouchScreen) {
            mInstrumentation.sendKeyDownUpSync(KeyEvent.KEYCODE_DPAD_DOWN);
            mInstrumentation.waitForIdleSync();

            // Shouldn't leave actionbar with normal keyboard navigation on touchscreens.
            mActivityRule.runOnUiThread(() -> assertTrue(actionBar.hasFocus()));
        }

        sendMetaHotkey(KeyEvent.KEYCODE_TAB);
        mInstrumentation.waitForIdleSync();

        // Should jump to the first view again.
        mActivityRule.runOnUiThread(() -> assertTrue(v1.hasFocus()));

        if (isTouchScreen) {
            mInstrumentation.sendKeyDownUpSync(KeyEvent.KEYCODE_DPAD_UP);
            mInstrumentation.waitForIdleSync();
            // Now it shouldn't go up to action bar -- it doesn't allow taking focus once left
            // but only for touch screens.
            mActivityRule.runOnUiThread(() -> assertTrue(v1.hasFocus()));
        }
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.view.cts.ContentPaneFocusTest"	"testNoFocusablesInContent"	"CtsViewTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/view/src/android/view/cts/ContentPaneFocusTest.java"	""	"public void testNoFocusablesInContent() throws Throwable {
        ViewGroup top = mActivity.findViewById(R.id.linearlayout);
        top.setDescendantFocusability(ViewGroup.FOCUS_BLOCK_DESCENDANTS);
        mActivityRule.runOnUiThread(top::clearFocus);
        mInstrumentation.waitForIdleSync();
        top.clearFocus();
        final View content = mActivity.findViewById(android.R.id.content);
        assertTrue(content.findFocus() == null);
        sendMetaHotkey(KeyEvent.KEYCODE_TAB);
        mInstrumentation.waitForIdleSync();

        ActionBar action = mActivity.getActionBar();
        if (action == null || !action.isShowing()) {
            // No action bar, so we only needed to make sure that the shortcut didn't cause
            // the framework to crash.
            return;
        }

        assertTrue(getActionBarView().hasFocus());
    }

    private View getActionBarView() {
        final View content = mActivity.findViewById(android.R.id.content);
        assertNotNull(content);
        final ViewParent viewParent = content.getParent();
        assertNotNull(viewParent);
        assertTrue(viewParent instanceof ViewGroup);
        ViewGroup parent = (ViewGroup) viewParent;
        View actionBarView = null;
        for (int i = 0; i < parent.getChildCount(); i++) {
            View child = parent.getChildAt(i);
            if (""android:action_bar"".equals(child.getTransitionName())) {
                actionBarView = child;
                break;
            }
        }
        assertNotNull(actionBarView);
        return actionBarView;
    }

    private void sendMetaHotkey(int keyCode) throws Throwable {
        sendMetaKey(KeyEvent.ACTION_DOWN);
        long time = SystemClock.uptimeMillis();
        KeyEvent metaHotkey = new KeyEvent(time, time, KeyEvent.ACTION_DOWN, keyCode,
                0, KeyEvent.META_META_ON | KeyEvent.META_META_LEFT_ON);
        mInstrumentation.sendKeySync(metaHotkey);
        time = SystemClock.uptimeMillis();
        metaHotkey = new KeyEvent(time, time, KeyEvent.ACTION_UP, keyCode,
                0, KeyEvent.META_META_ON | KeyEvent.META_META_LEFT_ON);
        mInstrumentation.sendKeySync(metaHotkey);
        Thread.sleep(2);
        sendMetaKey(KeyEvent.ACTION_UP);
    }

    private void sendMetaKey(int action) throws Throwable {
        long time = SystemClock.uptimeMillis();
        KeyEvent keyEvent = new KeyEvent(time, time, action, KeyEvent.KEYCODE_META_LEFT, 0,
                KeyEvent.META_META_LEFT_ON | KeyEvent.META_META_ON);
        mInstrumentation.sendKeySync(keyEvent);
        Thread.sleep(2);
    }
}"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.managedprovisioning.AuthenticationBoundKeyTestActivity"	"AuthenticationBoundKeyTestActivity"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/managedprovisioning/AuthenticationBoundKeyTestActivity.java"	""	"public void testpackage com.android.cts.verifier.managedprovisioning;

import android.Manifest;
import android.app.Activity;
import android.app.AlertDialog;
import android.app.Dialog;
import android.app.DialogFragment;
import android.app.KeyguardManager;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.hardware.fingerprint.FingerprintManager;
import android.os.Bundle;
import android.os.CancellationSignal;
import android.os.CountDownTimer;
import android.provider.Settings;
import android.security.keystore.KeyGenParameterSpec;
import android.security.keystore.KeyPermanentlyInvalidatedException;
import android.security.keystore.KeyProperties;
import android.security.keystore.UserNotAuthenticatedException;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Toast;

import com.android.cts.verifier.ArrayTestListAdapter;
import com.android.cts.verifier.DialogTestListActivity;
import com.android.cts.verifier.R;
import com.android.cts.verifier.TestResult;

import java.io.IOException;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.UnrecoverableKeyException;
import java.security.cert.CertificateException;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.KeyGenerator;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;

/**
 * Test device credential-bound keys in work profile.
 * Currently there are two types, one is keys bound to lockscreen passwords which can be configured
 * to remain available within a certain timeout after the latest successful user authentication.
 * The other is keys bound to fingerprint authentication which require explicit fingerprint
 * authentication before they can be accessed.
 */
public class AuthenticationBoundKeyTestActivity extends DialogTestListActivity {

    public static final String ACTION_AUTH_BOUND_KEY_TEST =
            ""com.android.cts.verifier.managedprovisioning.action.AUTH_BOUND_KEY_TEST"";

    private static final int AUTHENTICATION_DURATION_SECONDS = 5;
    private static final String LOCKSCREEN_KEY_NAME = ""mp_lockscreen_key"";
    private static final String FINGERPRINT_KEY_NAME = ""mp_fingerprint_key"";
    private static final byte[] SECRET_BYTE_ARRAY = new byte[] {1, 2, 3, 4, 5, 6};
    private static final int CONFIRM_CREDENTIALS_REQUEST_CODE = 1;
    private static final int FINGERPRINT_PERMISSION_REQUEST_CODE = 0;

    private static final int LOCKSCREEN = 1;
    private static final int FINGERPRINT = 2;

    private static final String KEYSTORE_NAME = ""AndroidKeyStore"";
    private static final String CIPHER_TRANSFORMATION =  KeyProperties.KEY_ALGORITHM_AES + ""/""
            + KeyProperties.BLOCK_MODE_CBC + ""/"" + KeyProperties.ENCRYPTION_PADDING_PKCS7;


    private KeyguardManager mKeyguardManager;
    private FingerprintManager mFingerprintManager;
    private boolean mFingerprintSupported;

    private DialogTestListItem mLockScreenBoundKeyTest;
    private DialogTestListItem mFingerprintBoundKeyTest;

    private Cipher mFingerprintCipher;

    public AuthenticationBoundKeyTestActivity() {
        super(R.layout.provisioning_byod,
                R.string.provisioning_byod_auth_bound_key,
                R.string.provisioning_byod_auth_bound_key_info,
                R.string.provisioning_byod_auth_bound_key_instruction);
    }


    @Override
    protected void onCreate(Bundle savedInstanceState) {
        mKeyguardManager = (KeyguardManager) getSystemService(KEYGUARD_SERVICE);
        mFingerprintManager = (FingerprintManager) getSystemService(FINGERPRINT_SERVICE);
        mFingerprintSupported = mFingerprintManager != null
                && mFingerprintManager.isHardwareDetected();
        // Need to have valid mFingerprintSupported value before calling super.onCreate() because
        // mFingerprintSupported is used in setupTests() which gets called by super.onCreate().
        super.onCreate(savedInstanceState);

        mPrepareTestButton.setText(R.string.provisioning_byod_auth_bound_key_set_up);
        mPrepareTestButton.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View arg0) {
                startActivity(new Intent(Settings.ACTION_SECURITY_SETTINGS));
            }
        });
        if (mFingerprintSupported) {
            requestPermissions(new String[] {Manifest.permission.USE_FINGERPRINT},
                    FINGERPRINT_PERMISSION_REQUEST_CODE);
        }
    }

    private class LockscreenCountDownTester extends CountDownTimer {

        private Toast mToast;

        public LockscreenCountDownTester() {
            // Wait for AUTHENTICATION_DURATION_SECONDS so the key is evicted before the real test.
            super(AUTHENTICATION_DURATION_SECONDS * 1000, 1000);
            mToast = Toast.makeText(AuthenticationBoundKeyTestActivity.this, """", Toast.LENGTH_SHORT);
        }

        @Override
        public void onFinish() {
            mToast.cancel();
            if (tryEncryptWithLockscreenKey()) {
                showToast(""Test failed. Key accessible without auth."");
                setTestResult(mLockScreenBoundKeyTest, TestResult.TEST_RESULT_FAILED);
            } else {
                // Start the Confirm Credentials screen.
                Intent intent = mKeyguardManager.createConfirmDeviceCredentialIntent(null, null);
                if (intent != null) {
                    startActivityForResult(intent, CONFIRM_CREDENTIALS_REQUEST_CODE);
                } else {
                    showToast(""Test failed. No lockscreen password exists."");
                    setTestResult(mLockScreenBoundKeyTest, TestResult.TEST_RESULT_FAILED);
                }
            }
        }

        @Override
        public void onTick(long millisUntilFinished) {
            mToast.setText(String.format(""Lockscreen challenge start in %d seconds.."",
                    millisUntilFinished / 1000));
            mToast.show();
        }
    }


    @Override
    protected void setupTests(ArrayTestListAdapter adapter) {
        mLockScreenBoundKeyTest = new DialogTestListItem(this,
                R.string.provisioning_byod_lockscreen_bound_key,
                ""BYOD_LockScreenBoundKeyTest"") {

            @Override
            public void performTest(DialogTestListActivity activity) {
                if (checkPreconditions()) {
                    createKey(LOCKSCREEN);
                    new LockscreenCountDownTester().start();
                }
            }
        };
        adapter.add(mLockScreenBoundKeyTest);
        if (mFingerprintSupported) {
            AuthenticationBoundKeyTestActivity that = this;
            mFingerprintBoundKeyTest = new DialogTestListItem(this,
                    R.string.provisioning_byod_fingerprint_bound_key,
                    ""BYOD_FingerprintBoundKeyTest"") {

                @Override
                public void performTest(DialogTestListActivity activity) {
                    if (checkPreconditions()) {
                        createKey(FINGERPRINT);
                        if (tryEncryptWithFingerprintKey(initFingerprintEncryptionCipher())) {
                            showToast(""Test failed. Key accessible without auth."");
                            setTestResult(mFingerprintBoundKeyTest, TestResult.TEST_RESULT_FAILED);
                        } else {
                            mFingerprintCipher = initFingerprintEncryptionCipher();
                            FingerprintAuthDialogFragment fadf =
                                    new FingerprintAuthDialogFragment();
                            fadf.setActivity(that);
                            fadf.show(getFragmentManager(),""fingerprint_dialog"");
                        }
                    }
                }
            };
            adapter.add(mFingerprintBoundKeyTest);
        }
    }

    private boolean checkPreconditions() {
        if (!mKeyguardManager.isKeyguardSecure()) {
            showToast(""Please set a lockscreen password."");
            return false;
        } else if (mFingerprintSupported && !mFingerprintManager.hasEnrolledFingerprints()) {
            showToast(""Please enroll a fingerprint."");
            return false;
        } else {
            return true;
        }
    }

    private String getKeyName(int testType) {
        return testType == LOCKSCREEN ? LOCKSCREEN_KEY_NAME : FINGERPRINT_KEY_NAME;
    }
    /**
     * Creates a symmetric key in the Android Key Store which can only be used after the user has
     * authenticated with device credentials.
     */
    private void createKey(int testType) {
        try {
            KeyStore keyStore = KeyStore.getInstance(KEYSTORE_NAME);
            keyStore.load(null);
            // Set the alias of the entry in Android KeyStore where the key will appear
            // and the constrains (purposes) in the constructor of the Builder
            KeyGenParameterSpec.Builder builder;
            builder = new KeyGenParameterSpec.Builder(getKeyName(testType),
                    KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT)
                    .setBlockModes(KeyProperties.BLOCK_MODE_CBC)
                    .setUserAuthenticationRequired(true)
                    .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_PKCS7);
            if (testType == LOCKSCREEN) {
                // Require that the user unlocked the lockscreen in the last 5 seconds
                builder.setUserAuthenticationValidityDurationSeconds(
                        AUTHENTICATION_DURATION_SECONDS);
            }
            KeyGenerator keyGenerator = KeyGenerator.getInstance(
                    KeyProperties.KEY_ALGORITHM_AES, KEYSTORE_NAME);
            keyGenerator.init(builder.build());
            keyGenerator.generateKey();
        } catch (NoSuchAlgorithmException | NoSuchProviderException
                | InvalidAlgorithmParameterException | KeyStoreException
                | CertificateException | IOException e) {
            throw new RuntimeException(""Failed to create a symmetric key"", e);
        }
    }

    private SecretKey loadSecretKey(int testType) {
        try {
            KeyStore keyStore = KeyStore.getInstance(KEYSTORE_NAME);
            keyStore.load(null);
            return (SecretKey) keyStore.getKey(getKeyName(testType), null);
        } catch (UnrecoverableKeyException  | CertificateException |KeyStoreException | IOException
                | NoSuchAlgorithmException e) {
            throw new RuntimeException(""Failed to load a symmetric key"", e);
        }
    }

    private boolean tryEncryptWithLockscreenKey() {
        try {
            // Try encrypting something, it will only work if the user authenticated within
            // the last AUTHENTICATION_DURATION_SECONDS seconds.
            Cipher cipher = Cipher.getInstance(CIPHER_TRANSFORMATION);
            cipher.init(Cipher.ENCRYPT_MODE, loadSecretKey(LOCKSCREEN));
            cipher.doFinal(SECRET_BYTE_ARRAY);
            return true;
        } catch (UserNotAuthenticatedException e) {
            // User is not authenticated, let's authenticate with device credentials.
            return false;
        } catch (KeyPermanentlyInvalidatedException e) {
            // This happens if the lock screen has been disabled or reset after the key was
            // generated.
            createKey(LOCKSCREEN);
            showToast(""Set up lockscreen after test ran. Retry the test."");
            return false;
        } catch (IllegalBlockSizeException | BadPaddingException | InvalidKeyException
                | NoSuchPaddingException | NoSuchAlgorithmException e) {
            throw new RuntimeException(""Encrypt with lockscreen-bound key failed"", e);
        }
    }

    private Cipher initFingerprintEncryptionCipher() {
        try {
            Cipher cipher =  Cipher.getInstance(CIPHER_TRANSFORMATION);
            cipher.init(Cipher.ENCRYPT_MODE, loadSecretKey(FINGERPRINT));
            return cipher;
        } catch (NoSuchPaddingException | NoSuchAlgorithmException e) {
            return null;
        } catch (KeyPermanentlyInvalidatedException e) {
            // This happens if the lock screen has been disabled or reset after the key was
            // generated after the key was generated.
            createKey(FINGERPRINT);
            showToast(""Set up lockscreen after test ran. Retry the test."");
            return null;
        } catch (InvalidKeyException e) {
            throw new RuntimeException(""Init cipher with fingerprint-bound key failed"", e);
        }
    }

    private boolean tryEncryptWithFingerprintKey(Cipher cipher) {

        try {
            cipher.doFinal(SECRET_BYTE_ARRAY);
            return true;
        } catch (IllegalBlockSizeException e) {
            // Cannot encrypt, key is unavailable
            return false;
        } catch (BadPaddingException e) {
            throw new RuntimeException(e);
        }
    }

    @Override
    protected void handleActivityResult(int requestCode, int resultCode, Intent data) {
        switch (requestCode) {
            case CONFIRM_CREDENTIALS_REQUEST_CODE:
                if (resultCode == RESULT_OK) {
                    if (tryEncryptWithLockscreenKey()) {
                        setTestResult(mLockScreenBoundKeyTest, TestResult.TEST_RESULT_PASSED);
                    } else {
                        showToast(""Test failed. Key not accessible after auth"");
                        setTestResult(mLockScreenBoundKeyTest, TestResult.TEST_RESULT_FAILED);
                    }
                } else {
                    showToast(""Lockscreen challenge canceled."");
                    setTestResult(mLockScreenBoundKeyTest, TestResult.TEST_RESULT_FAILED);
                }
                break;
            default:
                super.handleActivityResult(requestCode, resultCode, data);
        }
    }

    private void showToast(String message) {
        Toast.makeText(this, message, Toast.LENGTH_LONG).show();
    }

    static public class FingerprintAuthDialogFragment extends DialogFragment {

        private AuthenticationBoundKeyTestActivity mActivity;
        private CancellationSignal mCancellationSignal;
        private FingerprintManager mFingerprintManager;
        private FingerprintManagerCallback mFingerprintManagerCallback;
        private boolean mSelfCancelled;

        class FingerprintManagerCallback extends FingerprintManager.AuthenticationCallback {
            @Override
            public void onAuthenticationError(int errMsgId, CharSequence errString) {
                if (!mSelfCancelled) {
                    showToast(errString.toString());
                }
            }

            @Override
            public void onAuthenticationHelp(int helpMsgId, CharSequence helpString) {
                showToast(helpString.toString());
            }

            @Override
            public void onAuthenticationFailed() {
                showToast(getString(R.string.sec_fp_auth_failed));
            }

            @Override
            public void onAuthenticationSucceeded(FingerprintManager.AuthenticationResult result) {
                if (mActivity.tryEncryptWithFingerprintKey(mActivity.mFingerprintCipher)) {
                    showToast(""Test passed."");
                    mActivity.setTestResult(mActivity.mFingerprintBoundKeyTest,
                            TestResult.TEST_RESULT_PASSED);
                } else {
                    showToast(""Test failed. Key not accessible after auth"");
                    mActivity.setTestResult(mActivity.mFingerprintBoundKeyTest,
                            TestResult.TEST_RESULT_FAILED);
                }
                FingerprintAuthDialogFragment.this.dismiss();
            }
        }

        @Override
        public void onDismiss(DialogInterface dialog) {
            mCancellationSignal.cancel();
            mSelfCancelled = true;
        }

        private void setActivity(AuthenticationBoundKeyTestActivity activity) {
            mActivity = activity;
        }

        private void showToast(String message) {
            Toast.makeText(getContext(), message, Toast.LENGTH_LONG)
                .show();
        }


        @Override
        public Dialog onCreateDialog(Bundle savedInstanceState) {
            mCancellationSignal = new CancellationSignal();
            mSelfCancelled = false;
            mFingerprintManager =
                    (FingerprintManager) getContext().getSystemService(Context.FINGERPRINT_SERVICE);
            mFingerprintManagerCallback = new FingerprintManagerCallback();
            mFingerprintManager.authenticate(
                    new FingerprintManager.CryptoObject(mActivity.mFingerprintCipher),
                    mCancellationSignal, 0, mFingerprintManagerCallback, null);
            AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
            builder.setMessage(R.string.sec_fp_dialog_message);
            return builder.create();
        }

    }

}"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.server.wm.CommandSession"	"takeCallbackHistory"	""	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/util/src/android/server/wm/CommandSession.java"	""	"public void test/*
 *
 */

package android.server.wm;

import android.app.Activity;
import android.app.Application;
import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.res.Configuration;
import android.content.res.Resources;
import android.graphics.Point;
import android.os.Build;
import android.os.Bundle;
import android.os.Handler;
import android.os.HandlerThread;
import android.os.Looper;
import android.os.Parcel;
import android.os.Parcelable;
import android.os.Process;
import android.os.SystemClock;
import android.server.wm.TestJournalProvider.TestJournalClient;
import android.util.ArrayMap;
import android.util.DisplayMetrics;
import android.util.Log;
import android.view.Display;
import android.view.View;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.concurrent.TimeoutException;
import java.util.function.Consumer;

/**
 * A mechanism for communication between the started activity and its caller in different package or
 * process. Generally, a test case is the client, and the testing activity is the host. The client
 * can control whether to send an async or sync command with response data.
 * <p>Sample:</p>
 * <pre>
 * try (ActivitySessionClient client = new ActivitySessionClient(context)) {
 *     final ActivitySession session = client.startActivity(
 *             new Intent(context, TestActivity.class));
 *     final Bundle response = session.requestOrientation(
 *             ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
 *     Log.i(""Test"", ""Config: "" + CommandSession.getConfigInfo(response));
 *     Log.i(""Test"", ""Callbacks: "" + CommandSession.getCallbackHistory(response));
 *
 *     session.startActivity(session.getOriginalLaunchIntent());
 *     Log.i(""Test"", ""New intent callbacks: "" + session.takeCallbackHistory());
 * }
 * </pre>
 * <p>To perform custom command, use sendCommand* in {@link ActivitySession} to send the request,
 * and the receiving side (activity) can extend {@link BasicTestActivity} or
 * {@link CommandSessionActivity} with overriding handleCommand to do the corresponding action.</p>
 */
public final class CommandSession {
    private static final boolean DEBUG = ""eng"".equals(Build.TYPE);
    private static final String TAG = ""CommandSession"";

    private static final String EXTRA_PREFIX = ""s_"";

    static final String KEY_FORWARD = EXTRA_PREFIX + ""key_forward"";

    private static final String KEY_CALLBACK_HISTORY = EXTRA_PREFIX + ""key_callback_history"";
    private static final String KEY_CLIENT_ID = EXTRA_PREFIX + ""key_client_id"";
    private static final String KEY_COMMAND = EXTRA_PREFIX + ""key_command"";
    private static final String KEY_CONFIG_INFO = EXTRA_PREFIX + ""key_config_info"";
    private static final String KEY_APP_CONFIG_INFO = EXTRA_PREFIX + ""key_app_config_info"";
    private static final String KEY_HOST_ID = EXTRA_PREFIX + ""key_host_id"";
    private static final String KEY_ORIENTATION = EXTRA_PREFIX + ""key_orientation"";
    private static final String KEY_REQUEST_TOKEN = EXTRA_PREFIX + ""key_request_id"";
    private static final String KEY_UID_HAS_ACCESS_ON_DISPLAY =
            EXTRA_PREFIX + ""uid_has_access_on_display"";

    private static final String COMMAND_FINISH = EXTRA_PREFIX + ""command_finish"";
    private static final String COMMAND_GET_CONFIG = EXTRA_PREFIX + ""command_get_config"";
    private static final String COMMAND_GET_APP_CONFIG = EXTRA_PREFIX + ""command_get_app_config"";
    private static final String COMMAND_ORIENTATION = EXTRA_PREFIX + ""command_orientation"";
    private static final String COMMAND_TAKE_CALLBACK_HISTORY = EXTRA_PREFIX
            + ""command_take_callback_history"";
    private static final String COMMAND_WAIT_IDLE = EXTRA_PREFIX + ""command_wait_idle"";
    private static final String COMMAND_GET_NAME = EXTRA_PREFIX + ""command_get_name"";
    private static final String COMMAND_DISPLAY_ACCESS_CHECK =
            EXTRA_PREFIX + ""display_access_check"";

    private static final long INVALID_REQUEST_TOKEN = -1;

    private CommandSession() {
    }

    /** Get {@link ConfigInfo} from bundle. */
    public static ConfigInfo getConfigInfo(Bundle data) {
        return data.getParcelable(KEY_CONFIG_INFO);
    }

    /** Get application {@link ConfigInfo} from bundle. */
    public static ConfigInfo getAppConfigInfo(Bundle data) {
        return data.getParcelable(KEY_APP_CONFIG_INFO);
    }

    /** Get list of {@link ActivityCallback} from bundle. */
    public static ArrayList<ActivityCallback> getCallbackHistory(Bundle data) {
        return data.getParcelableArrayList(KEY_CALLBACK_HISTORY);
    }

    /** Return non-null if the session info should forward to launch target. */
    public static LaunchInjector handleForward(Bundle data) {
        if (data == null || !data.getBoolean(KEY_FORWARD)) {
            return null;
        }

        // Only keep the necessary data which relates to session.
        final Bundle sessionInfo = new Bundle(data);
        sessionInfo.remove(KEY_FORWARD);
        for (String key : sessionInfo.keySet()) {
            if (key != null && !key.startsWith(EXTRA_PREFIX)) {
                sessionInfo.remove(key);
            }
        }

        return new LaunchInjector() {
            @Override
            public void setupIntent(Intent intent) {
                intent.putExtras(sessionInfo);
            }

            @Override
            public void setupShellCommand(StringBuilder shellCommand) {
                // Currently there is no use case from shell.
                throw new UnsupportedOperationException();
            }
        };
    }

    private static String generateId(String prefix, Object obj) {
        return prefix + ""_"" + Integer.toHexString(System.identityHashCode(obj));
    }

    private static String commandIntentToString(Intent intent) {
        return intent.getStringExtra(KEY_COMMAND)
                + ""@"" + intent.getLongExtra(KEY_REQUEST_TOKEN, INVALID_REQUEST_TOKEN);
    }

    /** Get an unique token to match the request and reply. */
    private static long generateRequestToken() {
        return SystemClock.elapsedRealtimeNanos();
    }

    /**
     * As a controller associated with the testing activity. It can only process one sync command
     * (require response) at a time.
     */
    public static class ActivitySession {
        private final ActivitySessionClient mClient;
        private final String mHostId;
        private final Response mPendingResponse = new Response();
        // Only set when requiring response.
        private long mPendingRequestToken = INVALID_REQUEST_TOKEN;
        private String mPendingCommand;
        private boolean mFinished;
        private Intent mOriginalLaunchIntent;

        ActivitySession(ActivitySessionClient client, boolean requireReply) {
            mClient = client;
            mHostId = generateId(""activity"", this);
            if (requireReply) {
                mPendingRequestToken = generateRequestToken();
                mPendingCommand = COMMAND_WAIT_IDLE;
            }
        }

        /** Start the activity again. The intent must have the same filter as original one. */
        public void startActivity(Intent intent) {
            if (!intent.filterEquals(mOriginalLaunchIntent)) {
                throw new IllegalArgumentException(""The intent filter is different "" + intent);
            }
            mClient.mContext.startActivity(intent);
            mFinished = false;
        }

        /**
         * Request the activity to set the given orientation. The returned bundle contains the
         * changed config info and activity lifecycles during the change.
         *
         * @param orientation An orientation constant as used in
         *                    {@link android.content.pm.ActivityInfo#screenOrientation}.
         */
        public Bundle requestOrientation(int orientation) {
            final Bundle data = new Bundle();
            data.putInt(KEY_ORIENTATION, orientation);
            return sendCommandAndWaitReply(COMMAND_ORIENTATION, data);
        }

        /** Get {@link ConfigInfo} of the associated activity. */
        public ConfigInfo getConfigInfo() {
            return CommandSession.getConfigInfo(sendCommandAndWaitReply(COMMAND_GET_CONFIG));
        }

        /** Get {@link ConfigInfo} of the Application of the associated activity. */
        public ConfigInfo getAppConfigInfo() {
            return CommandSession.getAppConfigInfo(sendCommandAndWaitReply(COMMAND_GET_APP_CONFIG));
        }

        /**
         * Get executed callbacks of the activity since the last command. The current callback
         * history will also be cleared.
         */
        public ArrayList<ActivityCallback> takeCallbackHistory() {
            return getCallbackHistory(sendCommandAndWaitReply(COMMAND_TAKE_CALLBACK_HISTORY,
                    null /* data */));
        }

        /** Get the intent that launches the activity. Null if launch from shell command. */
        public Intent getOriginalLaunchIntent() {
            return mOriginalLaunchIntent;
        }

        /** Get a name to represent this session by the original launch intent if possible. */
        public ComponentName getName() {
            if (mOriginalLaunchIntent != null) {
                final ComponentName componentName = mOriginalLaunchIntent.getComponent();
                if (componentName != null) {
                    return componentName;
                }
            }
            return sendCommandAndWaitReply(COMMAND_GET_NAME, null /* data */)
                    .getParcelable(COMMAND_GET_NAME);
        }

        public boolean isUidAccesibleOnDisplay() {
            return sendCommandAndWaitReply(COMMAND_DISPLAY_ACCESS_CHECK, null).getBoolean(
                    KEY_UID_HAS_ACCESS_ON_DISPLAY);
        }

        /** Send command to the associated activity. */
        public void sendCommand(String command) {
            sendCommand(command, null /* data */);
        }

        /** Send command with extra parameters to the associated activity. */
        public void sendCommand(String command, Bundle data) {
            if (mFinished) {
                throw new IllegalStateException(""The session is finished"");
            }

            final Intent intent = new Intent(mHostId);
            if (data != null) {
                intent.putExtras(data);
            }
            intent.putExtra(KEY_COMMAND, command);
            mClient.mContext.sendBroadcast(intent);
            if (DEBUG) {
                Log.i(TAG, mClient.mClientId + "" sends "" + commandIntentToString(intent)
                        + "" to "" + mHostId);
            }
        }

        public Bundle sendCommandAndWaitReply(String command) {
            return sendCommandAndWaitReply(command, null /* data */);
        }

        /** Returns the reply data by the given command. */
        public Bundle sendCommandAndWaitReply(String command, Bundle data) {
            if (data == null) {
                data = new Bundle();
            }

            if (mPendingRequestToken != INVALID_REQUEST_TOKEN) {
                throw new IllegalStateException(""The previous pending request ""
                        + mPendingCommand + "" has not replied"");
            }
            mPendingRequestToken = generateRequestToken();
            mPendingCommand = command;
            data.putLong(KEY_REQUEST_TOKEN, mPendingRequestToken);

            sendCommand(command, data);
            return waitReply();
        }

        private Bundle waitReply() {
            if (mPendingRequestToken == INVALID_REQUEST_TOKEN) {
                throw new IllegalStateException(""No pending request to wait"");
            }

            if (DEBUG) Log.i(TAG, ""Waiting for request "" + mPendingRequestToken);
            try {
                return mPendingResponse.takeResult();
            } catch (TimeoutException e) {
                throw new RuntimeException(""Timeout on command ""
                        + mPendingCommand + "" with token "" + mPendingRequestToken, e);
            } finally {
                mPendingRequestToken = INVALID_REQUEST_TOKEN;
                mPendingCommand = null;
            }
        }

        // This method should run on an independent thread.
        void receiveReply(Bundle reply) {
            final long incomingToken = reply.getLong(KEY_REQUEST_TOKEN);
            if (incomingToken == mPendingRequestToken) {
                mPendingResponse.setResult(reply);
            } else {
                throw new IllegalStateException(""Mismatched token: incoming="" + incomingToken
                        + "" pending="" + mPendingRequestToken);
            }
        }

        /** Finish the activity that associates with this session. */
        public void finish() {
            if (!mFinished) {
                sendCommand(COMMAND_FINISH);
                mClient.mSessions.remove(mHostId);
                mFinished = true;
            }
        }

        private static class Response {
            static final int TIMEOUT_MILLIS = 5000;
            private volatile boolean mHasResult;
            private Bundle mResult;

            synchronized void setResult(Bundle result) {
                mHasResult = true;
                mResult = result;
                notifyAll();
            }

            synchronized Bundle takeResult() throws TimeoutException {
                final long startTime = SystemClock.uptimeMillis();
                while (!mHasResult) {
                    try {
                        wait(TIMEOUT_MILLIS);
                    } catch (InterruptedException ignored) {
                    }
                    if (!mHasResult && (SystemClock.uptimeMillis() - startTime > TIMEOUT_MILLIS)) {
                        throw new TimeoutException(""No response over "" + TIMEOUT_MILLIS + ""ms"");
                    }
                }

                final Bundle result = mResult;
                mHasResult = false;
                mResult = null;
                return result;
            }
        }
    }

    /** For LaunchProxy to setup launch parameter that establishes session. */
    interface LaunchInjector {
        void setupIntent(Intent intent);
        void setupShellCommand(StringBuilder shellCommand);
    }

    /** A proxy to launch activity by intent or shell command. */
    interface LaunchProxy {
        void setLaunchInjector(LaunchInjector injector);
        default Bundle getExtras() { return null; }
        void execute();
        boolean shouldWaitForLaunched();
    }

    abstract static class DefaultLaunchProxy implements LaunchProxy {
        LaunchInjector mLaunchInjector;

        @Override
        public boolean shouldWaitForLaunched() {
            return true;
        }

        @Override
        public void setLaunchInjector(LaunchInjector injector) {
            mLaunchInjector = injector;
        }
    }

    /** Created by test case to control testing activity that implements the session protocol. */
    public static class ActivitySessionClient extends BroadcastReceiver implements AutoCloseable {
        private final Context mContext;
        private final String mClientId;
        private final HandlerThread mThread;
        private final ArrayMap<String, ActivitySession> mSessions = new ArrayMap<>();
        private boolean mClosed;

        public ActivitySessionClient(Context context) {
            mContext = context;
            mClientId = generateId(""testcase"", this);
            mThread = new HandlerThread(mClientId);
            mThread.start();
            context.registerReceiver(this, new IntentFilter(mClientId),
                    null /* broadcastPermission */, new Handler(mThread.getLooper()));
        }

        /** Start the activity by the given intent and wait it becomes idle. */
        public ActivitySession startActivity(Intent intent) {
            return startActivity(intent, null /* options */, true /* waitIdle */);
        }

        /**
         * Launch the activity and establish a new session.
         *
         * @param intent The description of the activity to start.
         * @param options Additional options for how the Activity should be started.
         * @param waitIdle Block in this method until the target activity is idle.
         * @return The session to communicate with the started activity.
         */
        public ActivitySession startActivity(Intent intent, Bundle options, boolean waitIdle) {
            ensureNotClosed();
            final ActivitySession session = new ActivitySession(this, waitIdle);
            mSessions.put(session.mHostId, session);
            setupLaunchIntent(intent, waitIdle, session);

            if (!(mContext instanceof Activity)) {
                intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            }
            mContext.startActivity(intent, options);
            if (waitIdle) {
                session.waitReply();
            }
            return session;
        }

        /** Launch activity via proxy that allows to inject session parameters. */
        public ActivitySession startActivity(LaunchProxy proxy) {
            ensureNotClosed();
            final boolean waitIdle = proxy.shouldWaitForLaunched();
            final ActivitySession session = new ActivitySession(this, waitIdle);
            mSessions.put(session.mHostId, session);

            proxy.setLaunchInjector(new LaunchInjector() {
                @Override
                public void setupIntent(Intent intent) {
                    final Bundle bundle = proxy.getExtras();
                    if (bundle != null) {
                        intent.putExtras(bundle);
                    }
                    setupLaunchIntent(intent, waitIdle, session);
                }

                @Override
                public void setupShellCommand(StringBuilder commandBuilder) {
                    commandBuilder.append("" --es "" + KEY_HOST_ID + "" "" + session.mHostId);
                    commandBuilder.append("" --es "" + KEY_CLIENT_ID + "" "" + mClientId);
                    if (waitIdle) {
                        commandBuilder.append(
                                "" --el "" + KEY_REQUEST_TOKEN + "" "" + session.mPendingRequestToken);
                        commandBuilder.append("" --es "" + KEY_COMMAND + "" "" + COMMAND_WAIT_IDLE);
                    }
                }
            });

            proxy.execute();
            if (waitIdle) {
                session.waitReply();
            }
            return session;
        }

        private void setupLaunchIntent(Intent intent, boolean waitIdle, ActivitySession session) {
            intent.putExtra(KEY_HOST_ID, session.mHostId);
            intent.putExtra(KEY_CLIENT_ID, mClientId);
            if (waitIdle) {
                intent.putExtra(KEY_REQUEST_TOKEN, session.mPendingRequestToken);
                intent.putExtra(KEY_COMMAND, COMMAND_WAIT_IDLE);
            }
            session.mOriginalLaunchIntent = intent;
        }

        public ActivitySession getLastStartedSession() {
            if (mSessions.isEmpty()) {
                throw new IllegalStateException(""No started sessions"");
            }
            return mSessions.valueAt(mSessions.size() - 1);
        }

        private void ensureNotClosed() {
            if (mClosed) {
                throw new IllegalStateException(""This session client is closed."");
            }
        }

        @Override
        public void onReceive(Context context, Intent intent) {
            final ActivitySession session = mSessions.get(intent.getStringExtra(KEY_HOST_ID));
            if (DEBUG) Log.i(TAG, mClientId + "" receives "" + commandIntentToString(intent));
            if (session != null) {
                session.receiveReply(intent.getExtras());
            } else {
                Log.w(TAG, ""No available session for "" + commandIntentToString(intent));
            }
        }

        /** Complete cleanup with finishing all associated activities. */
        @Override
        public void close() {
            close(true /* finishSession */);
        }

        /** Cleanup except finish associated activities. */
        public void closeAndKeepSession() {
            close(false /* finishSession */);
        }

        /**
         * Closes this client. Once a client is closed, all methods on it will throw an
         * IllegalStateException and all responses from host are ignored.
         *
         * @param finishSession Whether to finish activities launched from this client.
         */
        public void close(boolean finishSession) {
            ensureNotClosed();
            mClosed = true;
            if (finishSession) {
                for (int i = mSessions.size() - 1; i >= 0; i--) {
                    mSessions.valueAt(i).finish();
                }
            }
            mContext.unregisterReceiver(this);
            mThread.quit();
        }
    }

    /**
     * Interface definition for session host to process command from {@link ActivitySessionClient}.
     */
    interface CommandReceiver {
        /** Called when the session host is receiving command. */
        void receiveCommand(String command, Bundle data);
    }

    /** The host receives command from the test client. */
    public static class ActivitySessionHost extends BroadcastReceiver {
        private final Context mContext;
        private final String mClientId;
        private final String mHostId;
        private CommandReceiver mCallback;
        /** The intents received when the host activity is relaunching. */
        private ArrayList<Intent> mPendingIntents;

        ActivitySessionHost(Context context, String hostId, String clientId,
                CommandReceiver callback) {
            mContext = context;
            mHostId = hostId;
            mClientId = clientId;
            mCallback = callback;
            context.registerReceiver(this, new IntentFilter(hostId));
        }

        @Override
        public void onReceive(Context context, Intent intent) {
            if (DEBUG) {
                Log.i(TAG, mHostId + ""(""
                        + (mCallback != null
                                ? mCallback.getClass().getName()
                                : mContext.getClass().getName())
                        + "") receives "" + commandIntentToString(intent));
            }
            if (mCallback == null) {
                if (mPendingIntents == null) {
                    mPendingIntents = new ArrayList<>();
                }
                mPendingIntents.add(intent);
                return;
            }
            dispatchCommand(mCallback, intent);
        }

        private static void dispatchCommand(CommandReceiver callback, Intent intent) {
            callback.receiveCommand(intent.getStringExtra(KEY_COMMAND), intent.getExtras());
        }

        void reply(String command, Bundle data) {
            final Intent intent = new Intent(mClientId);
            intent.putExtras(data);
            intent.putExtra(KEY_COMMAND, command);
            intent.putExtra(KEY_HOST_ID, mHostId);
            mContext.sendBroadcast(intent);
            if (DEBUG) {
                Log.i(TAG, mHostId + ""("" + mContext.getClass().getSimpleName()
                        + "") replies "" + commandIntentToString(intent) + "" to "" + mClientId);
            }
        }

        void setCallback(CommandReceiver callback) {
            if (mPendingIntents != null && mCallback == null && callback != null) {
                for (Intent intent : mPendingIntents) {
                    dispatchCommand(callback, intent);
                }
                mPendingIntents = null;
            }
            mCallback = callback;
        }

        void destroy() {
            mContext.unregisterReceiver(this);
        }
    }

    /**
     * A map to store data by host id. The usage should be declared as static that is able to keep
     * data after activity is relaunched.
     */
    private static class StaticHostStorage<T> {
        final ArrayMap<String, ArrayList<T>> mStorage = new ArrayMap<>();

        void add(String hostId, T data) {
            ArrayList<T> commands = mStorage.get(hostId);
            if (commands == null) {
                commands = new ArrayList<>();
                mStorage.put(hostId, commands);
            }
            commands.add(data);
        }

        ArrayList<T> get(String hostId) {
            return mStorage.get(hostId);
        }

        void clear(String hostId) {
            mStorage.remove(hostId);
        }
    }

    /** Store the commands which have not been handled. */
    private static class CommandStorage extends StaticHostStorage<Bundle> {

        /** Remove the oldest matched command and return its request token. */
        long consume(String hostId, String command) {
            final ArrayList<Bundle> commands = mStorage.get(hostId);
            if (commands != null) {
                final Iterator<Bundle> iterator = commands.iterator();
                while (iterator.hasNext()) {
                    final Bundle data = iterator.next();
                    if (command.equals(data.getString(KEY_COMMAND))) {
                        iterator.remove();
                        return data.getLong(KEY_REQUEST_TOKEN);
                    }
                }
                if (commands.isEmpty()) {
                    clear(hostId);
                }
            }
            return INVALID_REQUEST_TOKEN;
        }

        boolean containsCommand(String receiverId, String command) {
            final ArrayList<Bundle> dataList = mStorage.get(receiverId);
            if (dataList != null) {
                for (Bundle data : dataList) {
                    if (command.equals(data.getString(KEY_COMMAND))) {
                        return true;
                    }
                }
            }
            return false;
        }
    }

    /**
     * The base activity which supports the session protocol. If the caller does not use
     * {@link ActivitySessionClient}, it behaves as a normal activity.
     */
    public static class CommandSessionActivity extends Activity implements CommandReceiver {
        /** Static command storage for across relaunch. */
        private static CommandStorage sCommandStorage;
        private ActivitySessionHost mReceiver;

        /** The subclasses can disable the test journal client if its information is not used. */
        protected boolean mUseTestJournal = true;
        protected TestJournalClient mTestJournalClient;

        @Override
        protected void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            if (mUseTestJournal) {
                mTestJournalClient = TestJournalClient.create(this /* context */,
                        getComponentName());
            }

            final String hostId = getIntent().getStringExtra(KEY_HOST_ID);
            final String clientId = getIntent().getStringExtra(KEY_CLIENT_ID);
            if (hostId != null && clientId != null) {
                if (sCommandStorage == null) {
                    sCommandStorage = new CommandStorage();
                }
                final Object receiver = getLastNonConfigurationInstance();
                if (receiver instanceof ActivitySessionHost) {
                    mReceiver = (ActivitySessionHost) receiver;
                    mReceiver.setCallback(this);
                } else {
                    mReceiver = new ActivitySessionHost(getApplicationContext(), hostId, clientId,
                            this /* callback */);
                }
            }
        }

        @Override
        protected void onDestroy() {
            super.onDestroy();
            if (isChangingConfigurations()) {
                // Detach the callback if the activity is relaunching. The callback will be
                // associated again in onCreate.
                if (mReceiver != null) {
                    mReceiver.setCallback(null);
                }
            } else if (mReceiver != null) {
                // Clean up for real removal.
                sCommandStorage.clear(getHostId());
                mReceiver.destroy();
                mReceiver = null;
            }
            if (mTestJournalClient != null) {
                mTestJournalClient.close();
            }
        }

        @Override
        public Object onRetainNonConfigurationInstance() {
            return mReceiver;
        }

        @Override
        public final void receiveCommand(String command, Bundle data) {
            if (mReceiver == null) {
                throw new IllegalStateException(""The receiver is not created"");
            }
            sCommandStorage.add(getHostId(), data);
            handleCommand(command, data);
        }

        /** Handle the incoming command from client. */
        protected void handleCommand(String command, Bundle data) {
        }

        protected final void reply(String command) {
            reply(command, null /* data */);
        }

        /** Reply data to client for the command. */
        protected final void reply(String command, Bundle data) {
            if (mReceiver == null) {
                throw new IllegalStateException(""The receiver is not created"");
            }
            final long requestToke = sCommandStorage.consume(getHostId(), command);
            if (requestToke == INVALID_REQUEST_TOKEN) {
                throw new IllegalStateException(""There is no pending command "" + command);
            }
            if (data == null) {
                data = new Bundle();
            }
            data.putLong(KEY_REQUEST_TOKEN, requestToke);
            mReceiver.reply(command, data);
        }

        protected boolean hasPendingCommand(String command) {
            return mReceiver != null && sCommandStorage.containsCommand(getHostId(), command);
        }

        /** Returns null means this activity does support the session protocol. */
        final String getHostId() {
            return mReceiver != null ? mReceiver.mHostId : null;
        }
    }

    /** The default implementation that supports basic commands to interact with activity. */
    public static class BasicTestActivity extends CommandSessionActivity {
        /** Static callback history for across relaunch. */
        private static final StaticHostStorage<ActivityCallback> sCallbackStorage =
                new StaticHostStorage<>();

        private final String mTag = getClass().getSimpleName();
        protected boolean mPrintCallbackLog;

        @Override
        protected void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            onCallback(ActivityCallback.ON_CREATE);

            if (getHostId() != null) {
                final int orientation = getIntent().getIntExtra(KEY_ORIENTATION, Integer.MIN_VALUE);
                if (orientation != Integer.MIN_VALUE) {
                    setRequestedOrientation(orientation);
                }
                if (COMMAND_WAIT_IDLE.equals(getIntent().getStringExtra(KEY_COMMAND))) {
                    receiveCommand(COMMAND_WAIT_IDLE, getIntent().getExtras());
                    // No need to execute again if the activity is relaunched.
                    getIntent().removeExtra(KEY_COMMAND);
                }
            }
        }

        @Override
        public void handleCommand(String command, Bundle data) {
            switch (command) {
                case COMMAND_ORIENTATION:
                    clearCallbackHistory();
                    setRequestedOrientation(data.getInt(KEY_ORIENTATION));
                    getWindow().getDecorView().postDelayed(() -> {
                        if (reportConfigIfNeeded()) {
                            Log.w(getTag(), ""Fallback report. The orientation may not change."");
                        }
                    }, ActivitySession.Response.TIMEOUT_MILLIS / 2);
                    break;

                case COMMAND_GET_CONFIG:
                    runWhenIdle(() -> {
                        final Bundle replyData = new Bundle();
                        replyData.putParcelable(KEY_CONFIG_INFO, getConfigInfo());
                        reply(COMMAND_GET_CONFIG, replyData);
                    });
                    break;

                case COMMAND_GET_APP_CONFIG:
                    runWhenIdle(() -> {
                        final Bundle replyData = new Bundle();
                        replyData.putParcelable(KEY_APP_CONFIG_INFO, getAppConfigInfo());
                        reply(COMMAND_GET_APP_CONFIG, replyData);
                    });
                    break;

                case COMMAND_FINISH:
                    if (!isFinishing()) {
                        finish();
                    }
                    break;

                case COMMAND_TAKE_CALLBACK_HISTORY:
                    final Bundle replyData = new Bundle();
                    replyData.putParcelableArrayList(KEY_CALLBACK_HISTORY, getCallbackHistory());
                    reply(command, replyData);
                    clearCallbackHistory();
                    break;

                case COMMAND_WAIT_IDLE:
                    runWhenIdle(() -> reply(command));
                    break;

                case COMMAND_GET_NAME: {
                    final Bundle result = new Bundle();
                    result.putParcelable(COMMAND_GET_NAME, getComponentName());
                    reply(COMMAND_GET_NAME, result);
                    break;
                }

                case COMMAND_DISPLAY_ACCESS_CHECK:
                    final Bundle result = new Bundle();
                    final boolean displayHasAccess = getDisplay().hasAccess(Process.myUid());
                    result.putBoolean(KEY_UID_HAS_ACCESS_ON_DISPLAY, displayHasAccess);
                    reply(command, result);
                    break;

                default:
                    break;
            }
        }

        protected final void clearCallbackHistory() {
            sCallbackStorage.clear(getHostId());
        }

        protected final ArrayList<ActivityCallback> getCallbackHistory() {
            return sCallbackStorage.get(getHostId());
        }

        protected void runWhenIdle(Runnable r) {
            Looper.getMainLooper().getQueue().addIdleHandler(() -> {
                r.run();
                return false;
            });
        }

        protected boolean reportConfigIfNeeded() {
            if (!hasPendingCommand(COMMAND_ORIENTATION)) {
                return false;
            }
            runWhenIdle(() -> {
                final Bundle replyData = new Bundle();
                replyData.putParcelable(KEY_CONFIG_INFO, getConfigInfo());
                replyData.putParcelableArrayList(KEY_CALLBACK_HISTORY, getCallbackHistory());
                reply(COMMAND_ORIENTATION, replyData);
                clearCallbackHistory();
            });
            return true;
        }

        @Override
        protected void onStart() {
            super.onStart();
            onCallback(ActivityCallback.ON_START);
        }

        @Override
        protected void onRestart() {
            super.onRestart();
            onCallback(ActivityCallback.ON_RESTART);
        }

        @Override
        protected void onResume() {
            super.onResume();
            onCallback(ActivityCallback.ON_RESUME);
            reportConfigIfNeeded();
        }

        @Override
        protected void onPause() {
            super.onPause();
            onCallback(ActivityCallback.ON_PAUSE);
        }

        @Override
        protected void onStop() {
            super.onStop();
            onCallback(ActivityCallback.ON_STOP);
        }

        @Override
        protected void onDestroy() {
            super.onDestroy();
            onCallback(ActivityCallback.ON_DESTROY);
        }

        @Override
        protected void onActivityResult(int requestCode, int resultCode, Intent data) {
            super.onActivityResult(requestCode, resultCode, data);
            onCallback(ActivityCallback.ON_ACTIVITY_RESULT);
        }

        @Override
        protected void onUserLeaveHint() {
            super.onUserLeaveHint();
            onCallback(ActivityCallback.ON_USER_LEAVE_HINT);
        }

        @Override
        protected void onNewIntent(Intent intent) {
            super.onNewIntent(intent);
            onCallback(ActivityCallback.ON_NEW_INTENT);
        }

        @Override
        public void onConfigurationChanged(Configuration newConfig) {
            super.onConfigurationChanged(newConfig);
            onCallback(ActivityCallback.ON_CONFIGURATION_CHANGED);
            reportConfigIfNeeded();
        }

        @Override
        public void onMultiWindowModeChanged(boolean isInMultiWindowMode, Configuration newConfig) {
            super.onMultiWindowModeChanged(isInMultiWindowMode, newConfig);
            onCallback(ActivityCallback.ON_MULTI_WINDOW_MODE_CHANGED);
        }

        @Override
        public void onPictureInPictureModeChanged(boolean isInPictureInPictureMode,
                Configuration newConfig) {
            super.onPictureInPictureModeChanged(isInPictureInPictureMode, newConfig);
            onCallback(ActivityCallback.ON_PICTURE_IN_PICTURE_MODE_CHANGED);
        }

        @Override
        public void onMovedToDisplay(int displayId, Configuration config) {
            super.onMovedToDisplay(displayId, config);
            onCallback(ActivityCallback.ON_MOVED_TO_DISPLAY);
        }

        public void onCallback(ActivityCallback callback) {
            if (mPrintCallbackLog) {
                Log.i(getTag(), callback + "" @ ""
                        + Integer.toHexString(System.identityHashCode(this)));
            }
            final String hostId = getHostId();
            if (hostId != null) {
                sCallbackStorage.add(hostId, callback);
            }
            if (mTestJournalClient != null) {
                mTestJournalClient.addCallback(callback);
            }
        }

        protected void withTestJournalClient(Consumer<TestJournalClient> client) {
            if (mTestJournalClient != null) {
                client.accept(mTestJournalClient);
            }
        }

        protected String getTag() {
            return mTag;
        }

        /** Get configuration and display info. It should be called only after resumed. */
        protected ConfigInfo getConfigInfo() {
            final View view = getWindow().getDecorView();
            if (!view.isAttachedToWindow()) {
                Log.w(getTag(), ""Decor view has not attached"");
            }
            return new ConfigInfo(view.getContext(), view.getDisplay());
        }

        /** Same as {@link #getConfigInfo()}, but for Application. */
        private ConfigInfo getAppConfigInfo() {
            final Application application = (Application) getApplicationContext();
            return new ConfigInfo(application, getDisplay());
        }
    }

    public enum ActivityCallback implements Parcelable {
        ON_CREATE,
        ON_START,
        ON_RESUME,
        ON_PAUSE,
        ON_STOP,
        ON_RESTART,
        ON_DESTROY,
        ON_ACTIVITY_RESULT,
        ON_USER_LEAVE_HINT,
        ON_NEW_INTENT,
        ON_CONFIGURATION_CHANGED,
        ON_MULTI_WINDOW_MODE_CHANGED,
        ON_PICTURE_IN_PICTURE_MODE_CHANGED,
        ON_MOVED_TO_DISPLAY,
        ON_PICTURE_IN_PICTURE_REQUESTED;

        private static final ActivityCallback[] sValues = ActivityCallback.values();
        public static final int SIZE = sValues.length;

        @Override
        public int describeContents() {
            return 0;
        }

        @Override
        public void writeToParcel(final Parcel dest, final int flags) {
            dest.writeInt(ordinal());
        }

        public static final Creator<ActivityCallback> CREATOR = new Creator<ActivityCallback>() {
            @Override
            public ActivityCallback createFromParcel(final Parcel source) {
                return sValues[source.readInt()];
            }

            @Override
            public ActivityCallback[] newArray(final int size) {
                return new ActivityCallback[size];
            }
        };
    }

    public static class ConfigInfo implements Parcelable {
        public int displayId = Display.INVALID_DISPLAY;
        public int rotation;
        public SizeInfo sizeInfo;

        ConfigInfo() {
        }

        public ConfigInfo(Context context, Display display) {
            final Resources res = context.getResources();
            final DisplayMetrics metrics = res.getDisplayMetrics();
            final Configuration config = res.getConfiguration();

            if (display != null) {
                displayId = display.getDisplayId();
                rotation = display.getRotation();
            }
            sizeInfo = new SizeInfo(display, metrics, config);
        }

        public ConfigInfo(Resources res) {
            final DisplayMetrics metrics = res.getDisplayMetrics();
            final Configuration config = res.getConfiguration();
            sizeInfo = new SizeInfo(null /* display */, metrics, config);
        }

        @Override
        public String toString() {
            return ""ConfigInfo: {displayId="" + displayId + "" rotation="" + rotation
                    + "" "" + sizeInfo + ""}"";
        }

        @Override
        public int describeContents() {
            return 0;
        }

        @Override
        public void writeToParcel(Parcel dest, int flags) {
            dest.writeInt(displayId);
            dest.writeInt(rotation);
            dest.writeParcelable(sizeInfo, 0 /* parcelableFlags */);
        }

        public void readFromParcel(Parcel in) {
            displayId = in.readInt();
            rotation = in.readInt();
            sizeInfo = in.readParcelable(SizeInfo.class.getClassLoader());
        }

        public static final Creator<ConfigInfo> CREATOR = new Creator<ConfigInfo>() {
            @Override
            public ConfigInfo createFromParcel(Parcel source) {
                final ConfigInfo sizeInfo = new ConfigInfo();
                sizeInfo.readFromParcel(source);
                return sizeInfo;
            }

            @Override
            public ConfigInfo[] newArray(int size) {
                return new ConfigInfo[size];
            }
        };
    }

    public static class SizeInfo implements Parcelable {
        public int widthDp;
        public int heightDp;
        public int displayWidth;
        public int displayHeight;
        public int metricsWidth;
        public int metricsHeight;
        public int smallestWidthDp;
        public int densityDpi;
        public int orientation;
        public int windowWidth;
        public int windowHeight;
        public int windowAppWidth;
        public int windowAppHeight;

        SizeInfo() {
        }

        public SizeInfo(Display display, DisplayMetrics metrics, Configuration config) {
            if (display != null) {
                final Point displaySize = new Point();
                display.getSize(displaySize);
                displayWidth = displaySize.x;
                displayHeight = displaySize.y;
            }

            widthDp = config.screenWidthDp;
            heightDp = config.screenHeightDp;
            metricsWidth = metrics.widthPixels;
            metricsHeight = metrics.heightPixels;
            smallestWidthDp = config.smallestScreenWidthDp;
            densityDpi = config.densityDpi;
            orientation = config.orientation;
            windowWidth = config.windowConfiguration.getBounds().width();
            windowHeight = config.windowConfiguration.getBounds().height();
            windowAppWidth = config.windowConfiguration.getAppBounds().width();
            windowAppHeight = config.windowConfiguration.getAppBounds().height();
        }

        @Override
        public String toString() {
            return ""SizeInfo: {widthDp="" + widthDp + "" heightDp="" + heightDp
                    + "" displayWidth="" + displayWidth + "" displayHeight="" + displayHeight
                    + "" metricsWidth="" + metricsWidth + "" metricsHeight="" + metricsHeight
                    + "" smallestWidthDp="" + smallestWidthDp + "" densityDpi="" + densityDpi
                    + "" windowWidth="" + windowWidth + "" windowHeight="" + windowHeight
                    + "" windowAppWidth="" + windowAppWidth + "" windowAppHeight="" + windowAppHeight
                    + "" orientation="" + orientation + ""}"";
        }

        @Override
        public boolean equals(Object obj) {
            if (obj == this) {
                return true;
            }
            if (!(obj instanceof SizeInfo)) {
                return false;
            }
            final SizeInfo that = (SizeInfo) obj;
            return widthDp == that.widthDp
                    && heightDp == that.heightDp
                    && displayWidth == that.displayWidth
                    && displayHeight == that.displayHeight
                    && metricsWidth == that.metricsWidth
                    && metricsHeight == that.metricsHeight
                    && smallestWidthDp == that.smallestWidthDp
                    && densityDpi == that.densityDpi
                    && orientation == that.orientation
                    && windowWidth == that.windowWidth
                    && windowHeight == that.windowHeight
                    && windowAppWidth == that.windowAppWidth
                    && windowAppHeight == that.windowAppHeight;
        }

        @Override
        public int hashCode() {
            int result = 0;
            result = 31 * result + widthDp;
            result = 31 * result + heightDp;
            result = 31 * result + displayWidth;
            result = 31 * result + displayHeight;
            result = 31 * result + metricsWidth;
            result = 31 * result + metricsHeight;
            result = 31 * result + smallestWidthDp;
            result = 31 * result + densityDpi;
            result = 31 * result + orientation;
            result = 31 * result + windowWidth;
            result = 31 * result + windowHeight;
            result = 31 * result + windowAppWidth;
            result = 31 * result + windowAppHeight;
            return result;
        }

        @Override
        public int describeContents() {
            return 0;
        }

        @Override
        public void writeToParcel(Parcel dest, int flags) {
            dest.writeInt(widthDp);
            dest.writeInt(heightDp);
            dest.writeInt(displayWidth);
            dest.writeInt(displayHeight);
            dest.writeInt(metricsWidth);
            dest.writeInt(metricsHeight);
            dest.writeInt(smallestWidthDp);
            dest.writeInt(densityDpi);
            dest.writeInt(orientation);
            dest.writeInt(windowWidth);
            dest.writeInt(windowHeight);
            dest.writeInt(windowAppWidth);
            dest.writeInt(windowAppHeight);
        }

        public void readFromParcel(Parcel in) {
            widthDp = in.readInt();
            heightDp = in.readInt();
            displayWidth = in.readInt();
            displayHeight = in.readInt();
            metricsWidth = in.readInt();
            metricsHeight = in.readInt();
            smallestWidthDp = in.readInt();
            densityDpi = in.readInt();
            orientation = in.readInt();
            windowWidth = in.readInt();
            windowHeight = in.readInt();
            windowAppWidth = in.readInt();
            windowAppHeight = in.readInt();
        }

        public static final Creator<SizeInfo> CREATOR = new Creator<SizeInfo>() {
            @Override
            public SizeInfo createFromParcel(Parcel source) {
                final SizeInfo sizeInfo = new SizeInfo();
                sizeInfo.readFromParcel(source);
                return sizeInfo;
            }

            @Override
            public SizeInfo[] newArray(int size) {
                return new SizeInfo[size];
            }
        };
    }
}"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"com.android.compatibility.common.deviceinfo.VintfDeviceInfo"	"emptyList"	""	"/home/gpoor/cts-12-source/cts/common/device-side/device-info/src/com/android/compatibility/common/deviceinfo/VintfDeviceInfo.java"	""	"public void test/*
 *.
 */
package com.android.compatibility.common.deviceinfo;

import android.os.Build;
import android.os.VintfObject;
import android.os.VintfRuntimeInfo;

import java.util.Arrays;
import java.util.Collections;
import java.util.Map;

import com.android.compatibility.common.util.DeviceInfoStore;

/**
 * VINTF device info collector.
 * Keep name in sync with SELinuxHostTest#VINTF_DEVICE_CLASS.
 */
public final class VintfDeviceInfo extends DeviceInfo {

    private static final String[] sEmptyStringArray = new String[0];

    @Override
    protected void collectDeviceInfo(DeviceInfoStore store) throws Exception {
        // VintfRuntimeInfo is available Android O onward.
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.O) {
           return;
        }
        store.addResult(""cpu_info"", VintfRuntimeInfo.getCpuInfo());
        store.addResult(""os_name"", VintfRuntimeInfo.getOsName());
        store.addResult(""node_name"", VintfRuntimeInfo.getNodeName());
        store.addResult(""os_release"", VintfRuntimeInfo.getOsRelease());
        store.addResult(""os_version"", VintfRuntimeInfo.getOsVersion());
        store.addResult(""hardware_id"", VintfRuntimeInfo.getHardwareId());
        store.addResult(""kernel_version"", VintfRuntimeInfo.getKernelVersion());
        store.addResult(""sepolicy_version"", VintfObject.getSepolicyVersion());

        String[] hals = VintfObject.getHalNamesAndVersions();
        store.addListResult(""hals"", hals == null
                ? Collections.emptyList() : Arrays.<String>asList(hals));

        Map<String, String[]> vndks = VintfObject.getVndkSnapshots();
        if (vndks == null) vndks = Collections.emptyMap();
        store.startArray(""vndk_snapshots"");
        for (Map.Entry<String, String[]> e : vndks.entrySet()) {
            store.startGroup();
            store.addResult(""version"", e.getKey());
            String[] libraries = e.getValue();
            store.addListResult(""libraries"", libraries == null
                    ? Collections.emptyList() : Arrays.<String>asList(libraries));
            store.endGroup();
        }
        store.endArray();

        // getTargetFrameworkCompatibilityMatrixVersion is available Android P onward.
        // (Use O_MR1 until P is released.)
        if (Build.VERSION.SDK_INT <= Build.VERSION_CODES.O_MR1) {
           return;
        }
        Long version = VintfObject.getTargetFrameworkCompatibilityMatrixVersion();
        if (version != null) {
            store.addResult(""target_fcm_version"", version);
        }

        // getPlatformSepolicyVersion is available Android S onward.
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
            store.addResult(""platform_sepolicy_version"", VintfObject.getPlatformSepolicyVersion());
        }
    }
}"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.view.cts.SearchEventTest"	"testBasics"	"CtsViewTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/view/src/android/view/cts/SearchEventTest.java"	""	"public void testBasics() {
        // Only run for non-watch devices
        if (mActivity.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WATCH)) {
            return;
        }
        mInstrumentation.sendKeyDownUpSync(KeyEvent.KEYCODE_SEARCH);
        SearchEvent se = mActivity.getTestSearchEvent();
        assertNotNull(se);
        InputDevice id = se.getInputDevice();
        assertNotNull(id);
        assertEquals(-1, id.getId());
    }
}"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.util.cts.ArrayMapTest"	"testCanNotIteratePastEnd_keySetIterator"	"CtsUtilTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/util/src/android/util/cts/ArrayMapTest.java"	""	"public void testCanNotIteratePastEnd_keySetIterator() {
        Map<String, String> map = new ArrayMap<>();
        map.put(""key 1"", ""value 1"");
        map.put(""key 2"", ""value 2"");
        Set<String> expectedKeysToIterate = new HashSet<>(Arrays.asList(""key 1"", ""key 2""));
        Iterator<String> iterator = map.keySet().iterator();

        // Assert iteration over the expected two keys in any order
        assertTrue(iterator.hasNext());
        String firstKey = iterator.next();
        assertTrue(expectedKeysToIterate.remove(firstKey));

        assertTrue(iterator.hasNext());
        String secondKey = iterator.next();
        assertTrue(expectedKeysToIterate.remove(secondKey));

        assertFalse(iterator.hasNext());

        try {
            iterator.next();
            fail();
        } catch (NoSuchElementException expected) {
        }
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testStartLocalOnlyHotspotWithConfigBssid"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testStartLocalOnlyHotspotWithConfigBssid() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // check that softap mode is supported by the device
        if (!mWifiManager.isPortableHotspotSupported()) {
            return;
        }

        TestExecutor executor = new TestExecutor();
        TestLocalOnlyHotspotCallback callback = new TestLocalOnlyHotspotCallback(mLock);
        TestSoftApCallback capabilityCallback = new TestSoftApCallback(mLock);
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        boolean wifiEnabled = mWifiManager.isWifiEnabled();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            verifyRegisterSoftApCallback(executor, capabilityCallback);
            SoftApConfiguration.Builder customConfigBuilder = new SoftApConfiguration.Builder()
                    .setSsid(TEST_SSID_UNQUOTED)
                    .setPassphrase(TEST_PASSPHRASE, SoftApConfiguration.SECURITY_TYPE_WPA2_PSK);

            boolean isSupportCustomizedMac = capabilityCallback.getCurrentSoftApCapability()
                        .areFeaturesSupported(
                        SoftApCapability.SOFTAP_FEATURE_MAC_ADDRESS_CUSTOMIZATION)
                    && PropertyUtil.isVndkApiLevelNewerThan(Build.VERSION_CODES.S);
            if (isSupportCustomizedMac) {
                customConfigBuilder.setBssid(TEST_MAC);
            }
            SoftApConfiguration customConfig = customConfigBuilder.build();

            mWifiManager.startLocalOnlyHotspot(customConfig, executor, callback);
            // now wait for callback
            Thread.sleep(TEST_WAIT_DURATION_MS);

            // Verify callback is run on the supplied executor
            assertFalse(callback.onStartedCalled);
            executor.runAll();
            assertTrue(callback.onStartedCalled);

            assertNotNull(callback.reservation);
            SoftApConfiguration softApConfig = callback.reservation.getSoftApConfiguration();
            assertNotNull(softApConfig);
            if (isSupportCustomizedMac) {
                assertEquals(TEST_MAC, softApConfig.getBssid());
            }
            assertEquals(TEST_SSID_UNQUOTED, softApConfig.getSsid());
            assertEquals(TEST_PASSPHRASE, softApConfig.getPassphrase());
        } finally {
            // clean up
            stopLocalOnlyHotspot(callback, wifiEnabled);
            mWifiManager.unregisterSoftApCallback(capabilityCallback);
            uiAutomation.dropShellPermissionIdentity();
        }
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testSetGetSoftApConfigurationAndSoftApCapabilityCallback"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testSetGetSoftApConfigurationAndSoftApCapabilityCallback() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // check that softap mode is supported by the device
        if (!mWifiManager.isPortableHotspotSupported()) {
            return;
        }
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        TestExecutor executor = new TestExecutor();
        TestSoftApCallback callback = new TestSoftApCallback(mLock);
        try {
            uiAutomation.adoptShellPermissionIdentity();
            turnOffWifiAndTetheredHotspotIfEnabled();
            verifyRegisterSoftApCallback(executor, callback);

            SoftApConfiguration.Builder softApConfigBuilder = new SoftApConfiguration.Builder()
                    .setSsid(TEST_SSID_UNQUOTED)
                    .setPassphrase(TEST_PASSPHRASE, SoftApConfiguration.SECURITY_TYPE_WPA2_PSK)
                    .setAutoShutdownEnabled(true)
                    .setShutdownTimeoutMillis(100000)
                    .setBand(getAvailableBandAndChannelForTesting(
                            callback.getCurrentSoftApCapability()).keyAt(0))
                    .setHiddenSsid(false);

            // Test SoftApConfiguration set and get
            verifySetGetSoftApConfig(softApConfigBuilder.build());

            boolean isSupportCustomizedMac = callback.getCurrentSoftApCapability()
                        .areFeaturesSupported(
                        SoftApCapability.SOFTAP_FEATURE_MAC_ADDRESS_CUSTOMIZATION)
                    && PropertyUtil.isVndkApiLevelNewerThan(Build.VERSION_CODES.S);

            //Test MAC_ADDRESS_CUSTOMIZATION supported config
            if (isSupportCustomizedMac) {
                softApConfigBuilder.setBssid(TEST_MAC)
                        .setMacRandomizationSetting(SoftApConfiguration.RANDOMIZATION_NONE);

                // Test SoftApConfiguration set and get
                verifySetGetSoftApConfig(softApConfigBuilder.build());
            }

            // Test CLIENT_FORCE_DISCONNECT supported config.
            if (callback.getCurrentSoftApCapability()
                    .areFeaturesSupported(
                    SoftApCapability.SOFTAP_FEATURE_CLIENT_FORCE_DISCONNECT)) {
                softApConfigBuilder.setMaxNumberOfClients(10);
                softApConfigBuilder.setClientControlByUserEnabled(true);
                softApConfigBuilder.setBlockedClientList(new ArrayList<>());
                softApConfigBuilder.setAllowedClientList(new ArrayList<>());
                verifySetGetSoftApConfig(softApConfigBuilder.build());
            }

            // Test SAE config
            if (callback.getCurrentSoftApCapability()
                    .areFeaturesSupported(SoftApCapability.SOFTAP_FEATURE_WPA3_SAE)) {
                softApConfigBuilder
                        .setPassphrase(TEST_PASSPHRASE,
                          SoftApConfiguration.SECURITY_TYPE_WPA3_SAE_TRANSITION);
                verifySetGetSoftApConfig(softApConfigBuilder.build());
                softApConfigBuilder
                        .setPassphrase(TEST_PASSPHRASE,
                        SoftApConfiguration.SECURITY_TYPE_WPA3_SAE);
                verifySetGetSoftApConfig(softApConfigBuilder.build());
            }

            // Test 11 AX control config.
            if (callback.getCurrentSoftApCapability()
                    .areFeaturesSupported(SoftApCapability.SOFTAP_FEATURE_IEEE80211_AX)) {
                softApConfigBuilder.setIeee80211axEnabled(true);
                verifySetGetSoftApConfig(softApConfigBuilder.build());
            }

            if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
                softApConfigBuilder.setBridgedModeOpportunisticShutdownEnabled(false);
                verifySetGetSoftApConfig(softApConfigBuilder.build());
            }

        } finally {
            mWifiManager.unregisterSoftApCallback(callback);
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Verify that startTetheredHotspot with specific channel config.
     * @throws Exception
     */"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testStartTetheredHotspotWithChannelConfigAndSoftApStateAndInfoCallback"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testStartTetheredHotspotWithChannelConfigAndSoftApStateAndInfoCallback()
            throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // check that softap mode is supported by the device
        if (!mWifiManager.isPortableHotspotSupported()) {
            return;
        }
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        TestExecutor executor = new TestExecutor();
        TestSoftApCallback callback = new TestSoftApCallback(mLock);
        try {
            uiAutomation.adoptShellPermissionIdentity();
            // check that tethering is supported by the device
            if (!mTetheringManager.isTetheringSupported()) {
                return;
            }
            turnOffWifiAndTetheredHotspotIfEnabled();
            verifyRegisterSoftApCallback(executor, callback);

            SparseIntArray testBandsAndChannels = getAvailableBandAndChannelForTesting(
                    callback.getCurrentSoftApCapability());

            if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
                assertNotEquals(0, testBandsAndChannels.size());
            }
            boolean isSupportCustomizedMac = callback.getCurrentSoftApCapability()
                    .areFeaturesSupported(
                    SoftApCapability.SOFTAP_FEATURE_MAC_ADDRESS_CUSTOMIZATION)
                    && PropertyUtil.isVndkApiLevelNewerThan(Build.VERSION_CODES.S);

            SoftApConfiguration.Builder testSoftApConfigBuilder = new SoftApConfiguration.Builder()
                    .setSsid(TEST_SSID_UNQUOTED)
                    .setPassphrase(TEST_PASSPHRASE, SoftApConfiguration.SECURITY_TYPE_WPA2_PSK)
                    .setChannel(testBandsAndChannels.valueAt(0), testBandsAndChannels.keyAt(0));

            if (isSupportCustomizedMac) testSoftApConfigBuilder.setBssid(TEST_MAC);

            SoftApConfiguration testSoftApConfig = testSoftApConfigBuilder.build();

            mWifiManager.setSoftApConfiguration(testSoftApConfig);

            // start tethering which used to verify startTetheredHotspot
            mTetheringManager.startTethering(ConnectivityManager.TETHERING_WIFI, executor,
                new TetheringManager.StartTetheringCallback() {
                    @Override
                    public void onTetheringFailed(final int result) {
                    }
                });

            // Verify state and info callback value as expected
            PollingCheck.check(
                    ""SoftAp channel and state mismatch!!!"", 10_000,
                    () -> {
                        executor.runAll();
                        int sapChannel = ScanResult.convertFrequencyMhzToChannelIfSupported(
                                callback.getCurrentSoftApInfo().getFrequency());
                        boolean isInfoCallbackSupported =
                                callback.getOnSoftapInfoChangedCalledCount() > 1;
                        if (isInfoCallbackSupported) {
                            return WifiManager.WIFI_AP_STATE_ENABLED == callback.getCurrentState()
                                && testBandsAndChannels.valueAt(0) == sapChannel;
                        }
                        return WifiManager.WIFI_AP_STATE_ENABLED == callback.getCurrentState();
                    });
            // After Soft Ap enabled, check SoftAp info if it supported
            if (isSupportCustomizedMac && callback.getOnSoftapInfoChangedCalledCount() > 1) {
                assertEquals(callback.getCurrentSoftApInfo().getBssid(), TEST_MAC);
            }
            if (PropertyUtil.isVndkApiLevelNewerThan(Build.VERSION_CODES.S)
                    && callback.getOnSoftapInfoChangedCalledCount() > 1) {
                assertNotEquals(callback.getCurrentSoftApInfo().getWifiStandard(),
                        ScanResult.WIFI_STANDARD_UNKNOWN);
            }

            if (callback.getOnSoftapInfoChangedCalledCount() > 1) {
                assertTrue(callback.getCurrentSoftApInfo().getAutoShutdownTimeoutMillis() > 0);
            }
        } finally {
            // stop tethering which used to verify stopSoftAp
            mTetheringManager.stopTethering(ConnectivityManager.TETHERING_WIFI);

            // Verify clean up
            PollingCheck.check(
                    ""Stop Softap failed"", 3_000,
                    () -> {
                        executor.runAll();
                        return WifiManager.WIFI_AP_STATE_DISABLED == callback.getCurrentState() &&
                                0 == callback.getCurrentSoftApInfo().getBandwidth() &&
                                0 == callback.getCurrentSoftApInfo().getFrequency();
                    });
            if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
                assertEquals(callback.getCurrentSoftApInfo().getBssid(), null);
                assertEquals(ScanResult.WIFI_STANDARD_UNKNOWN,
                        callback.getCurrentSoftApInfo().getWifiStandard());
            }
            mWifiManager.unregisterSoftApCallback(callback);
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    private static class TestActionListener implements WifiManager.ActionListener {
        private final Object mLock;
        public boolean onSuccessCalled = false;
        public boolean onFailedCalled = false;
        public int failureReason = -1;

        TestActionListener(Object lock) {
            mLock = lock;
        }

        @Override
        public void onSuccess() {
            synchronized (mLock) {
                onSuccessCalled = true;
                mLock.notify();
            }
        }

        @Override
        public void onFailure(int reason) {
            synchronized (mLock) {
                onFailedCalled = true;
                failureReason = reason;
                mLock.notify();
            }
        }
    }

    /**
     * Triggers connection to one of the saved networks using {@link WifiManager#connect(
     * int, WifiManager.ActionListener)} or {@link WifiManager#connect(WifiConfiguration,
     * WifiManager.ActionListener)}
     *
     * @param withNetworkId Use networkId for triggering connection, false for using
     *                      WifiConfiguration.
     * @throws Exception
     */
    private void testConnect(boolean withNetworkId) throws Exception {
        TestActionListener actionListener = new TestActionListener(mLock);
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        List<WifiConfiguration> savedNetworks = null;
        try {
            uiAutomation.adoptShellPermissionIdentity();
            // These below API's only work with privileged permissions (obtained via shell identity
            // for test)
            savedNetworks = mWifiManager.getConfiguredNetworks();

            // Disable all the saved networks to trigger disconnect & disable autojoin.
            for (WifiConfiguration network : savedNetworks) {
                assertTrue(mWifiManager.disableNetwork(network.networkId));
            }
            waitForDisconnection();

            // Now trigger connection to the last saved network.
            WifiConfiguration savedNetworkToConnect =
                    savedNetworks.get(savedNetworks.size() - 1);
            synchronized (mLock) {
                try {
                    if (withNetworkId) {
                        mWifiManager.connect(savedNetworkToConnect.networkId, actionListener);
                    } else {
                        mWifiManager.connect(savedNetworkToConnect, actionListener);
                    }
                    // now wait for callback
                    mLock.wait(TEST_WAIT_DURATION_MS);
                } catch (InterruptedException e) {
                }
            }
            // check if we got the success callback
            assertTrue(actionListener.onSuccessCalled);
            // Wait for connection to complete & ensure we are connected to the saved network.
            waitForConnection();
            if (SdkLevel.isAtLeastS()) {
                assertEquals(savedNetworkToConnect.networkId,
                        mWifiManager.getConnectionInfo().getNetworkId());
            } else {
                // In R, auto-upgraded network IDs may be different from the original saved network.
                // Since we may end up selecting the auto-upgraded network ID for connection and end
                // up connected to the original saved network with a different network ID, we should
                // instead match by SSID.
                assertEquals(savedNetworkToConnect.SSID,
                        mWifiManager.getConnectionInfo().getSSID());
            }
        } finally {
            // Re-enable all saved networks before exiting.
            if (savedNetworks != null) {
                for (WifiConfiguration network : savedNetworks) {
                    mWifiManager.enableNetwork(network.networkId, true);
                }
            }
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link WifiManager#connect(int, WifiManager.ActionListener)} to an existing saved
     * network.
     */"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.text.method.cts.DateKeyListenerTest"	"testDateTimeKeyListener"	"CtsTextTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/text/src/android/text/method/cts/DateKeyListenerTest.java"	""	"public void testDateTimeKeyListener() {
        final DateKeyListener dateKeyListener = DateKeyListener.getInstance();

        setKeyListenerSync(dateKeyListener);
        assertEquals("""", mTextView.getText().toString());

        // press '1' key.
        CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, KeyEvent.KEYCODE_1);
        assertEquals(""1"", mTextView.getText().toString());

        // press '2' key.
        CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, KeyEvent.KEYCODE_2);
        assertEquals(""12"", mTextView.getText().toString());

        // press an unaccepted key if it exists.
        int keyCode = TextMethodUtils.getUnacceptedKeyCode(DateKeyListener.CHARACTERS);
        if (-1 != keyCode) {
            CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, keyCode);
            assertEquals(""12"", mTextView.getText().toString());
        }

        // press '-' key.
        CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, KeyEvent.KEYCODE_MINUS);
        assertEquals(""12-"", mTextView.getText().toString());

        // press '/' key.
        CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, KeyEvent.KEYCODE_SLASH);
        assertEquals(""12-/"", mTextView.getText().toString());

        // remove DateKeyListener
        setKeyListenerSync(null);
        assertEquals(""12-/"", mTextView.getText().toString());

        // press '/' key, it will not be accepted.
        CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, KeyEvent.KEYCODE_SLASH);
        assertEquals(""12-/"", mTextView.getText().toString());
    }

    /**
     * A mocked {@link android.text.method.DateKeyListener} for testing purposes.
     *
     * Allows {@link DateKeyListenerTest} to call
     * {@link android.text.method.DateKeyListener#getAcceptedChars()}.
     */
    private class MockDateKeyListener extends DateKeyListener {
        MockDateKeyListener() {
            super();
        }

        MockDateKeyListener(Locale locale) {
            super(locale);
        }

        @Override
        protected char[] getAcceptedChars() {
            return super.getAcceptedChars();
        }
    }
}"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.view.cts.ASurfaceControlTest"	"testSurfaceTransaction_apply"	"CtsViewTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/view/src/android/view/cts/ASurfaceControlTest.java"	""	"public void testSurfaceTransaction_apply() {
        long surfaceTransaction = nSurfaceTransaction_create();
        assertTrue(""failed to create surface transaction"", surfaceTransaction != 0);

        Log.e(""Transaction"", ""created: "" + surfaceTransaction);

        nSurfaceTransaction_apply(surfaceTransaction);
        nSurfaceTransaction_delete(surfaceTransaction);
    }

    // INTRO: The following tests run a series of commands and verify the
    // output based on the number of pixels with a certain color on the display.
    //
    // The interface being tested is a NDK api but the only way to record the display
    // through public apis is in through the SDK. So the test logic and test verification
    // is in Java but the hooks that call into the NDK api are jni code.
    //
    // The set up is done during the surfaceCreated callback. In most cases, the
    // test uses the opportunity to create a child layer through createFromWindow and
    // performs operations on the child layer.
    //
    // When there is no visible buffer for the layer(s) the color defaults to black.
    // The test cases allow a +/- 10% error rate. This is based on the error
    // rate allowed in the SurfaceViewSyncTests"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"com.android.compatibility.common.util.CtsKeyEventUtil"	"uptimeMillis"	""	"/home/gpoor/cts-12-source/cts/common/device-side/util-axt/src/com/android/compatibility/common/util/CtsKeyEventUtil.java"	""	"public void test/*
 *.
 */

package com.android.compatibility.common.util;

import android.app.Instrumentation;
import android.os.Looper;
import android.os.SystemClock;
import android.util.Log;
import android.view.InputDevice;
import android.view.KeyCharacterMap;
import android.view.KeyEvent;
import android.view.View;
import android.view.inputmethod.InputMethodManager;

import java.lang.reflect.Field;

/**
 * Utility class to send KeyEvents bypassing the IME. The code is similar to functions in
 * {@link Instrumentation} and {@link android.test.InstrumentationTestCase} classes. It uses
 * {@link InputMethodManager#dispatchKeyEventFromInputMethod(View, KeyEvent)} to send the events.
 * After sending the events waits for idle.
 */
public final class CtsKeyEventUtil {

    private CtsKeyEventUtil() {}

    /**
     * Sends the key events corresponding to the text to the app being instrumented.
     *
     * @param instrumentation the instrumentation used to run the test.
     * @param targetView View to find the ViewRootImpl and dispatch.
     * @param text The text to be sent. Null value returns immediately.
     */
    public static void sendString(final Instrumentation instrumentation, final View targetView,
            final String text) {
        if (text == null) {
            return;
        }

        KeyEvent[] events = getKeyEvents(text);

        if (events != null) {
            for (int i = 0; i < events.length; i++) {
                // We have to change the time of an event before injecting it because
                // all KeyEvents returned by KeyCharacterMap.getEvents() have the same
                // time stamp and the system rejects too old events. Hence, it is
                // possible for an event to become stale before it is injected if it
                // takes too long to inject the preceding ones.
                sendKey(instrumentation, targetView, KeyEvent.changeTimeRepeat(
                        events[i], SystemClock.uptimeMillis(), 0 /* newRepeat */));
            }
        }
    }

    /**
     * Sends a series of key events through instrumentation. For instance:
     * sendKeys(view, KEYCODE_DPAD_LEFT, KEYCODE_DPAD_CENTER).
     *
     * @param instrumentation the instrumentation used to run the test.
     * @param targetView View to find the ViewRootImpl and dispatch.
     * @param keys The series of key codes.
     */
    public static void sendKeys(final Instrumentation instrumentation, final View targetView,
            final int...keys) {
        final int count = keys.length;

        for (int i = 0; i < count; i++) {
            try {
                sendKeyDownUp(instrumentation, targetView, keys[i]);
            } catch (SecurityException e) {
                // Ignore security exceptions that are now thrown
                // when trying to send to another app, to retain
                // compatibility with existing tests.
            }
        }
    }

    /**
     * Sends a series of key events through instrumentation. The sequence of keys is a string
     * containing the key names as specified in KeyEvent, without the KEYCODE_ prefix. For
     * instance: sendKeys(view, ""DPAD_LEFT A B C DPAD_CENTER""). Each key can be repeated by using
     * the N* prefix. For instance, to send two KEYCODE_DPAD_LEFT, use the following:
     * sendKeys(view, ""2*DPAD_LEFT"").
     *
     * @param instrumentation the instrumentation used to run the test.
     * @param targetView View to find the ViewRootImpl and dispatch.
     * @param keysSequence The sequence of keys.
     */
    public static void sendKeys(final Instrumentation instrumentation, final View targetView,
            final String keysSequence) {
        final String[] keys = keysSequence.split("" "");
        final int count = keys.length;

        for (int i = 0; i < count; i++) {
            String key = keys[i];
            int repeater = key.indexOf('*');

            int keyCount;
            try {
                keyCount = repeater == -1 ? 1 : Integer.parseInt(key.substring(0, repeater));
            } catch (NumberFormatException e) {
                Log.w(""ActivityTestCase"", ""Invalid repeat count: "" + key);
                continue;
            }

            if (repeater != -1) {
                key = key.substring(repeater + 1);
            }

            for (int j = 0; j < keyCount; j++) {
                try {
                    final Field keyCodeField = KeyEvent.class.getField(""KEYCODE_"" + key);
                    final int keyCode = keyCodeField.getInt(null);
                    try {
                        sendKeyDownUp(instrumentation, targetView, keyCode);
                    } catch (SecurityException e) {
                        // Ignore security exceptions that are now thrown
                        // when trying to send to another app, to retain
                        // compatibility with existing tests.
                    }
                } catch (NoSuchFieldException e) {
                    Log.w(""ActivityTestCase"", ""Unknown keycode: KEYCODE_"" + key);
                    break;
                } catch (IllegalAccessException e) {
                    Log.w(""ActivityTestCase"", ""Unknown keycode: KEYCODE_"" + key);
                    break;
                }
            }
        }
    }

    /**
     * Sends an up and down key events.
     *
     * @param instrumentation the instrumentation used to run the test.
     * @param targetView View to find the ViewRootImpl and dispatch.
     * @param key The integer keycode for the event to be sent.
     */
    public static void sendKeyDownUp(final Instrumentation instrumentation, final View targetView,
            final int key) {
        sendKey(instrumentation, targetView, new KeyEvent(KeyEvent.ACTION_DOWN, key),
                false /* waitForIdle */);
        sendKey(instrumentation, targetView, new KeyEvent(KeyEvent.ACTION_UP, key));
    }

    /**
     * Sends a key event.
     *
     * @param instrumentation the instrumentation used to run the test.
     * @param targetView View to find the ViewRootImpl and dispatch.
     * @param event KeyEvent to be send.
     */
    public static void sendKey(final Instrumentation instrumentation, final View targetView,
            final KeyEvent event) {
        sendKey(instrumentation, targetView, event, true /* waitForIdle */);
    }

    private static void sendKey(final Instrumentation instrumentation, final View targetView,
            final KeyEvent event, boolean waitForIdle) {
        validateNotAppThread();

        long downTime = event.getDownTime();
        long eventTime = event.getEventTime();
        int action = event.getAction();
        int code = event.getKeyCode();
        int repeatCount = event.getRepeatCount();
        int metaState = event.getMetaState();
        int deviceId = event.getDeviceId();
        int scanCode = event.getScanCode();
        int source = event.getSource();
        int flags = event.getFlags();
        if (source == InputDevice.SOURCE_UNKNOWN) {
            source = InputDevice.SOURCE_KEYBOARD;
        }
        if (eventTime == 0) {
            eventTime = SystemClock.uptimeMillis();
        }
        if (downTime == 0) {
            downTime = eventTime;
        }

        final KeyEvent newEvent = new KeyEvent(downTime, eventTime, action, code, repeatCount,
                metaState, deviceId, scanCode, flags, source);

        InputMethodManager imm = targetView.getContext().getSystemService(InputMethodManager.class);
        imm.dispatchKeyEventFromInputMethod(imm.isActive() ? null : targetView, newEvent);
        if (waitForIdle) {
            instrumentation.waitForIdleSync();
        }
    }

    /**
     * Sends a key event while holding another modifier key down, then releases both keys and
     * waits for idle sync. Useful for sending combinations like shift + tab.
     *
     * @param instrumentation the instrumentation used to run the test.
     * @param targetView View to find the ViewRootImpl and dispatch.
     * @param keyCodeToSend The integer keycode for the event to be sent.
     * @param modifierKeyCodeToHold The integer keycode of the modifier to be held.
     */
    public static void sendKeyWhileHoldingModifier(final Instrumentation instrumentation,
            final View targetView, final int keyCodeToSend,
            final int modifierKeyCodeToHold) {
        final int metaState = getMetaStateForModifierKeyCode(modifierKeyCodeToHold);
        final long downTime = SystemClock.uptimeMillis();

        final KeyEvent holdKeyDown = new KeyEvent(downTime, downTime, KeyEvent.ACTION_DOWN,
                modifierKeyCodeToHold, 0 /* repeat */);
        sendKey(instrumentation ,targetView, holdKeyDown);

        final KeyEvent keyDown = new KeyEvent(downTime, downTime, KeyEvent.ACTION_DOWN,
                keyCodeToSend, 0 /* repeat */, metaState);
        sendKey(instrumentation, targetView, keyDown);

        final KeyEvent keyUp = new KeyEvent(downTime, downTime, KeyEvent.ACTION_UP,
                keyCodeToSend, 0 /* repeat */, metaState);
        sendKey(instrumentation, targetView, keyUp);

        final KeyEvent holdKeyUp = new KeyEvent(downTime, downTime, KeyEvent.ACTION_UP,
                modifierKeyCodeToHold, 0 /* repeat */);
        sendKey(instrumentation, targetView, holdKeyUp);

        instrumentation.waitForIdleSync();
    }

    private static int getMetaStateForModifierKeyCode(int modifierKeyCode) {
        if (!KeyEvent.isModifierKey(modifierKeyCode)) {
            throw new IllegalArgumentException(""Modifier key expected, but got: ""
                    + KeyEvent.keyCodeToString(modifierKeyCode));
        }

        int metaState;
        switch (modifierKeyCode) {
            case KeyEvent.KEYCODE_SHIFT_LEFT:
                metaState = KeyEvent.META_SHIFT_LEFT_ON;
                break;
            case KeyEvent.KEYCODE_SHIFT_RIGHT:
                metaState = KeyEvent.META_SHIFT_RIGHT_ON;
                break;
            case KeyEvent.KEYCODE_ALT_LEFT:
                metaState = KeyEvent.META_ALT_LEFT_ON;
                break;
            case KeyEvent.KEYCODE_ALT_RIGHT:
                metaState = KeyEvent.META_ALT_RIGHT_ON;
                break;
            case KeyEvent.KEYCODE_CTRL_LEFT:
                metaState = KeyEvent.META_CTRL_LEFT_ON;
                break;
            case KeyEvent.KEYCODE_CTRL_RIGHT:
                metaState = KeyEvent.META_CTRL_RIGHT_ON;
                break;
            case KeyEvent.KEYCODE_META_LEFT:
                metaState = KeyEvent.META_META_LEFT_ON;
                break;
            case KeyEvent.KEYCODE_META_RIGHT:
                metaState = KeyEvent.META_META_RIGHT_ON;
                break;
            case KeyEvent.KEYCODE_SYM:
                metaState = KeyEvent.META_SYM_ON;
                break;
            case KeyEvent.KEYCODE_NUM:
                metaState = KeyEvent.META_NUM_LOCK_ON;
                break;
            case KeyEvent.KEYCODE_FUNCTION:
                metaState = KeyEvent.META_FUNCTION_ON;
                break;
            default:
                // Safety net: all modifier keys need to have at least one meta state associated.
                throw new UnsupportedOperationException(""No meta state associated with ""
                        + ""modifier key: "" + KeyEvent.keyCodeToString(modifierKeyCode));
        }

        return KeyEvent.normalizeMetaState(metaState);
    }

    private static KeyEvent[] getKeyEvents(final String text) {
        KeyCharacterMap keyCharacterMap = KeyCharacterMap.load(KeyCharacterMap.VIRTUAL_KEYBOARD);
        return keyCharacterMap.getEvents(text.toCharArray());
    }

    private static void validateNotAppThread() {
        if (Looper.myLooper() == Looper.getMainLooper()) {
            throw new RuntimeException(
                    ""This method can not be called from the main application thread"");
        }
    }
}"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.view.cts.KeyEventInjectionTest"	"testLongPressKeyEventInjectedViaInstrumentation"	"CtsViewTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/view/src/android/view/cts/KeyEventInjectionTest.java"	""	"public void testLongPressKeyEventInjectedViaInstrumentation() {
        sendKeyViaInstrumentation(TEST_KEYCODE, true /*longPress*/);
        checkKeyLongPress(TEST_KEYCODE);
    }

    /**
     * Long press event can be injected through ADB
     */"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.view.cts.KeyEventInjectionTest"	"testLongPressKeyEventInjectedViaAdb"	"CtsViewTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/view/src/android/view/cts/KeyEventInjectionTest.java"	""	"public void testLongPressKeyEventInjectedViaAdb() {
        sendKeyViaAdb(TEST_KEYCODE, true /* logPress */);
        checkKeyLongPress(TEST_KEYCODE);
    }

    /**
     * Inject a regular key event through UiAutomation
     */"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.view.cts.KeyEventInjectionTest"	"testKeyEventInjectedViaInstrumentation"	"CtsViewTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/view/src/android/view/cts/KeyEventInjectionTest.java"	""	"public void testKeyEventInjectedViaInstrumentation() {
        sendKeyViaInstrumentation(TEST_KEYCODE, false /*longPress*/);
        checkKeyPress(TEST_KEYCODE);
    }

    /**
     * Inject a regular key event through ADB
     */"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.view.cts.KeyEventInjectionTest"	"testKeyEventInjectedViaAdb"	"CtsViewTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/view/src/android/view/cts/KeyEventInjectionTest.java"	""	"public void testKeyEventInjectedViaAdb() {
        sendKeyViaAdb(TEST_KEYCODE, false /*longPress*/);
        checkKeyPress(TEST_KEYCODE);
    }

    // KeyEvent.Callback overrides
    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event) {
        mEvents.add(event);
        return true;
    }

    @Override
    public boolean onKeyUp(int keyCode, KeyEvent event) {
        mEvents.add(event);
        return true;
    }

    @Override
    public boolean onKeyLongPress(int keyCode, KeyEvent event) {
        mLongPressEvents.add(event);
        return true;
    }

    @Override
    public boolean onKeyMultiple(int keyCode, int count, KeyEvent event) {
        fail(""ACTION_MULTIPLE is deprecated. Received: "" + event);
        return true;
    }

    private KeyEvent popEvent(BlockingQueue<KeyEvent> events) {
        try {
            return events.poll(5, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
            fail(""Interrupted while waiting for event to be added to queue"");
        }
        return null;
    }

    private void sendKeyViaAdb(int keyCode, boolean longPress) {
        // Inject key event through the adb command
        final String command = ""input keyevent "" + (longPress ? ""--longpress "" : """") + keyCode;
        try {
            SystemUtil.runShellCommand(mInstrumentation, command);
        } catch (IOException e) {
            fail(""Could not send adb command '"" + command + ""', "" + e);
        }
    }

    private void sendKeyViaInstrumentation(int keyCode, boolean longPress) {
        final long downTime = SystemClock.uptimeMillis();
        int repeatCount = 0;
        KeyEvent downEvent =
                new KeyEvent(downTime, downTime, KeyEvent.ACTION_DOWN, keyCode, repeatCount);
        mAutomation.injectInputEvent(downEvent, true);
        if (longPress) {
            repeatCount += 1;
            KeyEvent repeatEvent = new KeyEvent(downTime, SystemClock.uptimeMillis(),
                    KeyEvent.ACTION_DOWN, keyCode, repeatCount);
            mAutomation.injectInputEvent(repeatEvent, true);
        }
        KeyEvent upEvent = new KeyEvent(downTime, SystemClock.uptimeMillis(),
                KeyEvent.ACTION_UP, keyCode, 0 /* repeatCount */);
        mAutomation.injectInputEvent(upEvent, true);
    }

    private void waitForLongPress(int keyCode) {
        KeyEvent event = popEvent(mLongPressEvents);
        assertNotNull(event);
        assertEquals(keyCode, event.getKeyCode());
    }

    private void assertLongPressNotReceived() {
        // Should not have received any long press invocations
        assertTrue(mLongPressEvents.isEmpty());
    }

    private void checkKeyEvent(int action, int keyCode, int repeatCount) {
        KeyEvent event = popEvent(mEvents);
        assertNotNull(event);
        assertEquals(""action: "", action, event.getAction());
        assertEquals(""Expected "" + KeyEvent.keyCodeToString(keyCode) + "", received ""
                + KeyEvent.keyCodeToString(event.getKeyCode()),
                keyCode, event.getKeyCode());
        assertEquals(""repeatCount: "" , repeatCount, event.getRepeatCount());
    }

    private void checkKeyLongPress(int keyCode) {
        checkKeyEvent(KeyEvent.ACTION_DOWN, keyCode, 0 /* repeatCount */);
        checkKeyEvent(KeyEvent.ACTION_DOWN, keyCode, 1 /* repeatCount */);
        checkKeyEvent(KeyEvent.ACTION_UP, keyCode, 0 /* repeatCount */);
        waitForLongPress(keyCode);
    }

    private void checkKeyPress(int keyCode) {
        checkKeyEvent(KeyEvent.ACTION_DOWN, keyCode, 0 /* repeatCount */);
        checkKeyEvent(KeyEvent.ACTION_UP, keyCode, 0 /* repeatCount */);
        assertLongPressNotReceived();
    }
}"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.keystore.cts.KeyFactoryTest"	"testGetKeySpecWithKeystorePrivateKeyAndKeyInfoReflectsAllAuthorizations"	"CtsKeystoreTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/keystore/src/android/keystore/cts/KeyFactoryTest.java"	""	"public void testGetKeySpecWithKeystorePrivateKeyAndKeyInfoReflectsAllAuthorizations()
            throws Exception {
        Date keyValidityStart = new Date(System.currentTimeMillis() - TestUtils.DAY_IN_MILLIS);
        Date keyValidityForOriginationEnd =
                new Date(System.currentTimeMillis() + TestUtils.DAY_IN_MILLIS);
        Date keyValidityForConsumptionEnd =
                new Date(System.currentTimeMillis() + 3 * TestUtils.DAY_IN_MILLIS);
        for (String algorithm : EXPECTED_ALGORITHMS) {
            try {
                String[] blockModes = new String[] {KeyProperties.BLOCK_MODE_ECB};
                String[] encryptionPaddings =
                        new String[] {KeyProperties.ENCRYPTION_PADDING_RSA_PKCS1,
                                KeyProperties.ENCRYPTION_PADDING_RSA_OAEP};
                String[] digests = new String[] {KeyProperties.DIGEST_SHA1,
                        KeyProperties.DIGEST_SHA224,
                        KeyProperties.DIGEST_SHA384,
                        KeyProperties.DIGEST_SHA512};
                int purposes = KeyProperties.PURPOSE_DECRYPT | KeyProperties.PURPOSE_SIGN;
                KeyPairGenerator keyGenerator =
                        KeyPairGenerator.getInstance(algorithm, EXPECTED_PROVIDER_NAME);
                keyGenerator.initialize(new KeyGenParameterSpec.Builder(""test1"", purposes)
                        .setBlockModes(blockModes)
                        .setEncryptionPaddings(encryptionPaddings)
                        .setDigests(digests)
                        .setKeyValidityStart(keyValidityStart)
                        .setKeyValidityForOriginationEnd(keyValidityForOriginationEnd)
                        .setKeyValidityForConsumptionEnd(keyValidityForConsumptionEnd)
                        .build());
                KeyPair keyPair = keyGenerator.generateKeyPair();
                KeyFactory keyFactory = getKeyFactory(algorithm);
                KeyInfo keyInfo = keyFactory.getKeySpec(keyPair.getPrivate(), KeyInfo.class);
                assertEquals(""test1"", keyInfo.getKeystoreAlias());
                assertEquals(purposes, keyInfo.getPurposes());
                TestUtils.assertContentsInAnyOrder(
                        Arrays.asList(keyInfo.getBlockModes()), blockModes);

                List<String> actualEncryptionPaddings =
                        new ArrayList<String>(Arrays.asList(keyInfo.getEncryptionPaddings()));
                // Keystore may have added ENCRYPTION_PADDING_NONE to allow software padding.
                actualEncryptionPaddings.remove(KeyProperties.ENCRYPTION_PADDING_NONE);
                TestUtils.assertContentsInAnyOrder(
                        actualEncryptionPaddings, encryptionPaddings);

                List<String> actualDigests =
                        new ArrayList<String>(Arrays.asList(keyInfo.getDigests()));
                // Keystore may have added DIGEST_NONE to allow software digesting.
                actualDigests.remove(KeyProperties.DIGEST_NONE);
                TestUtils.assertContentsInAnyOrder(actualDigests, digests);

                MoreAsserts.assertEmpty(Arrays.asList(keyInfo.getSignaturePaddings()));
                assertEquals(keyValidityStart, keyInfo.getKeyValidityStart());
                assertEquals(keyValidityForOriginationEnd,
                        keyInfo.getKeyValidityForOriginationEnd());
                assertEquals(keyValidityForConsumptionEnd,
                        keyInfo.getKeyValidityForConsumptionEnd());
                assertFalse(keyInfo.isUserAuthenticationRequired());
                assertFalse(keyInfo.isUserAuthenticationRequirementEnforcedBySecureHardware());
            } catch (Throwable e) {
                throw new RuntimeException(""Failed for "" + algorithm, e);
            }
        }
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.text.method.cts.DigitsKeyListenerTest"	"testDigitsKeyListener1"	"CtsTextTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/text/src/android/text/method/cts/DigitsKeyListenerTest.java"	""	"public void testDigitsKeyListener1() {
        final DigitsKeyListener digitsKeyListener = DigitsKeyListener.getInstance();

        setKeyListenerSync(digitsKeyListener);
        assertEquals("""", mTextView.getText().toString());

        // press '-' key.
        CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, KeyEvent.KEYCODE_MINUS);
        assertEquals("""", mTextView.getText().toString());

        // press '1' key.
        CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, KeyEvent.KEYCODE_1);
        assertEquals(""1"", mTextView.getText().toString());

        // press '.' key.
        CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, KeyEvent.KEYCODE_PERIOD);
        assertEquals(""1"", mTextView.getText().toString());

        // press '2' key.
        CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, KeyEvent.KEYCODE_2);
        assertEquals(""12"", mTextView.getText().toString());
    }

    /*
     * Scenario description:
     * Current accepted characters are '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '+'.
     *  1. Press '-' key and check if the content of TextView becomes ""-""
     *  2. Press '1' key and check if the content of TextView becomes ""-1""
     *  3. Press '.' key and this key could not be accepted.
     *  4. Press '+' key and this key could not be accepted.
     *  5. Press '2' key and check if the content of TextView becomes ""-12""
     *  6. Press '-' key and this key could not be accepted,
     *     because text view accepts minus sign iff it at the beginning.
     */"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.text.method.cts.DigitsKeyListenerTest"	"testDigitsKeyListener2"	"CtsTextTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/text/src/android/text/method/cts/DigitsKeyListenerTest.java"	""	"public void testDigitsKeyListener2() {
        final DigitsKeyListener digitsKeyListener = DigitsKeyListener.getInstance(true, false);

        setKeyListenerSync(digitsKeyListener);
        assertEquals("""", mTextView.getText().toString());

        // press '-' key.
        CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, KeyEvent.KEYCODE_MINUS);
        assertEquals(""-"", mTextView.getText().toString());

        // press '1' key.
        CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, KeyEvent.KEYCODE_1);
        assertEquals(""-1"", mTextView.getText().toString());

        // press '.' key.
        CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, KeyEvent.KEYCODE_PERIOD);
        assertEquals(""-1"", mTextView.getText().toString());

        // press '+' key.
        CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, KeyEvent.KEYCODE_PLUS);
        assertEquals(""-1"", mTextView.getText().toString());

        // press '2' key.
        CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, KeyEvent.KEYCODE_2);
        assertEquals(""-12"", mTextView.getText().toString());

        // press '-' key.
        CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, KeyEvent.KEYCODE_MINUS);
        assertEquals(""-12"", mTextView.getText().toString());
    }

    /*
     * Scenario description:
     * Current accepted characters are '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.'.
     *  1. Press '-' key and check if the content of TextView becomes """"
     *  2. Press '+' key and check if the content of TextView becomes """"
     *  3. Press '1' key and check if the content of TextView becomes ""1""
     *  4. Press '.' key and check if the content of TextView becomes ""1.""
     *  5. Press '2' key and check if the content of TextView becomes ""1.2""
     *  6. Press '.' key and this key could not be accepted,
     *     because text view accepts only one decimal point per field.
     */"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.text.method.cts.DigitsKeyListenerTest"	"testDigitsKeyListener3"	"CtsTextTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/text/src/android/text/method/cts/DigitsKeyListenerTest.java"	""	"public void testDigitsKeyListener3() {
        final DigitsKeyListener digitsKeyListener = DigitsKeyListener.getInstance(false, true);

        setKeyListenerSync(digitsKeyListener);
        assertEquals("""", mTextView.getText().toString());

        // press '-' key.
        CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, KeyEvent.KEYCODE_MINUS);
        assertEquals("""", mTextView.getText().toString());

        // press '+' key.
        CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, KeyEvent.KEYCODE_PLUS);
        assertEquals("""", mTextView.getText().toString());

        // press '1' key.
        CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, KeyEvent.KEYCODE_1);
        assertEquals(""1"", mTextView.getText().toString());

        // press '.' key.
        CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, KeyEvent.KEYCODE_PERIOD);
        assertEquals(""1."", mTextView.getText().toString());

        // press '2' key.
        CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, KeyEvent.KEYCODE_2);
        assertEquals(""1.2"", mTextView.getText().toString());

        // press '.' key.
        CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, KeyEvent.KEYCODE_PERIOD);
        assertEquals(""1.2"", mTextView.getText().toString());
    }

    /*
     * Scenario description:
     * Current accepted characters are '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '+',
     * '.'.
     *  1. Press '+' key and check if the content of TextView becomes ""+""
     *  2. Press '1' key and check if the content of TextView becomes ""+1""
     *  3. Press '.' key and this key could not be accepted.
     *  4. Press '2' key and check if the content of TextView becomes ""+12""
     *  5. Press '-' key and this key could not be accepted,
     *     because text view accepts minus sign iff it at the beginning.
     *  6. Press '.' key and this key could not be accepted,
     *     because text view accepts only one decimal point per field.
     */"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.text.method.cts.DigitsKeyListenerTest"	"testDigitsKeyListener4"	"CtsTextTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/text/src/android/text/method/cts/DigitsKeyListenerTest.java"	""	"public void testDigitsKeyListener4() {
        final DigitsKeyListener digitsKeyListener = DigitsKeyListener.getInstance(true, true);

        setKeyListenerSync(digitsKeyListener);
        assertEquals("""", mTextView.getText().toString());

        // press '+' key.
        CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, KeyEvent.KEYCODE_PLUS);
        assertEquals(""+"", mTextView.getText().toString());

        // press '1' key.
        CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, KeyEvent.KEYCODE_1);
        assertEquals(""+1"", mTextView.getText().toString());

        // press '.' key.
        CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, KeyEvent.KEYCODE_PERIOD);
        assertEquals(""+1."", mTextView.getText().toString());

        // press '2' key.
        CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, KeyEvent.KEYCODE_2);
        assertEquals(""+1.2"", mTextView.getText().toString());

        // press '-' key.
        CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, KeyEvent.KEYCODE_MINUS);
        assertEquals(""+1.2"", mTextView.getText().toString());

        // press '.' key.
        CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, KeyEvent.KEYCODE_PERIOD);
        assertEquals(""+1.2"", mTextView.getText().toString());
    }

    /*
     * Scenario description:
     * Current accepted characters are '5', '6', '7', '8', '9'.
     *  1. Press '1' key and this key could not be accepted.
     *  2. Press '5' key and check if the content of TextView becomes ""5""
     *  3. Press '.' key and this key could not be accepted.
     *  4. Press '-' key and this key could not be accepted.
     *  5. remove DigitsKeyListener and Press '5' key, this key will not be accepted
     */"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.text.method.cts.DigitsKeyListenerTest"	"testDigitsKeyListener5"	"CtsTextTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/text/src/android/text/method/cts/DigitsKeyListenerTest.java"	""	"public void testDigitsKeyListener5() throws Throwable {
        final String accepted = ""56789"";
        final DigitsKeyListener digitsKeyListener = DigitsKeyListener.getInstance(accepted);

        setKeyListenerSync(digitsKeyListener);
        assertEquals("""", mTextView.getText().toString());

        // press '1' key.
        CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, KeyEvent.KEYCODE_1);
        assertEquals("""", mTextView.getText().toString());

        // press '5' key.
        CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, KeyEvent.KEYCODE_5);
        assertEquals(""5"", mTextView.getText().toString());

        // press '.' key.
        CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, KeyEvent.KEYCODE_PERIOD);
        assertEquals(""5"", mTextView.getText().toString());

        // press '-' key.
        CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, KeyEvent.KEYCODE_MINUS);
        assertEquals(""5"", mTextView.getText().toString());

        // remove DigitsKeyListener
        mActivityRule.runOnUiThread(() -> {
            mTextView.setKeyListener(null);
            mTextView.requestFocus();
        });
        mInstrumentation.waitForIdleSync();
        assertEquals(""5"", mTextView.getText().toString());

        // press '5' key.
        CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, KeyEvent.KEYCODE_5);
        assertEquals(""5"", mTextView.getText().toString());
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.hardware.cts.helpers.SensorRatePermissionDirectReportTestHelper"	"toList"	"CtsSensorTestCases"	"/home/gpoor/cts-12-source/cts/tests/sensor/src/android/hardware/cts/helpers/SensorRatePermissionDirectReportTestHelper.java"	""	"public void test/*
 *.
 */

package android.hardware.cts.helpers;

import android.content.Context;
import android.hardware.HardwareBuffer;
import android.hardware.Sensor;
import android.hardware.SensorDirectChannel;
import android.hardware.SensorManager;
import android.hardware.SensorPrivacyManager;
import android.hardware.cts.SensorDirectReportTest;

import com.android.compatibility.common.util.ShellUtils;
import com.android.compatibility.common.util.SystemUtil;

import com.google.common.collect.ImmutableSet;

import org.junit.Assert;
import org.junit.Assume;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.List;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

/**
 * A helper class to test sampling rates of direct sensor channels.
 */
public class SensorRatePermissionDirectReportTestHelper {
    public static final int CAPPED_SAMPLE_RATE_HZ = 200;
    public static final int CAPPED_DIRECT_REPORT_RATE_LEVEL = SensorDirectChannel.RATE_NORMAL;
    // Set of sensors that are throttled
    public static final ImmutableSet<Integer> CAPPED_SENSOR_TYPE_SET = ImmutableSet.of(
            Sensor.TYPE_ACCELEROMETER,
            Sensor.TYPE_ACCELEROMETER_UNCALIBRATED,
            Sensor.TYPE_GYROSCOPE,
            Sensor.TYPE_GYROSCOPE_UNCALIBRATED,
            Sensor.TYPE_MAGNETIC_FIELD,
            Sensor.TYPE_MAGNETIC_FIELD_UNCALIBRATED
    );
    public static final int TEST_RUN_TIME_PERIOD_MILLISEC = 1000;
    public static final int SENSORS_EVENT_SIZE = 104;

    static {
        System.loadLibrary(""cts-sensors-ndk-jni"");
    }

    private final SensorManager mSensorManager;

    private Sensor mSensor;

    public SensorRatePermissionDirectReportTestHelper(Context context, int sensorType) {
        mSensorManager = context.getSystemService(SensorManager.class);
        mSensor = null;
        for (Sensor sensor : mSensorManager.getSensorList(sensorType)) {
            if (!CAPPED_SENSOR_TYPE_SET.contains(sensor.getType())) {
                continue;
            }
            if (sensor.isDirectChannelTypeSupported(SensorDirectChannel.TYPE_HARDWARE_BUFFER)) {
                mSensor = sensor;
                break;
            }
        }
        Assume.assumeTrue(""Failed to find a sensor!"", mSensor != null);
    }

    private static native boolean nativeReadHardwareBuffer(HardwareBuffer hardwareBuffer,
            byte[] buffer, int srcOffset, int destOffset, int count);

    public static double computeAvgRate(List<SensorDirectReportTest.DirectReportSensorEvent> events,
            long startTimestamp, long endTimestamp) {

        List<SensorDirectReportTest.DirectReportSensorEvent> filteredEvents = events.stream()
                .filter(event -> event.ts > startTimestamp && event.ts < endTimestamp)
                .collect(Collectors.toList());

        double rate = Double.MIN_VALUE;
        int numOfEvents = filteredEvents.size();
        if (numOfEvents >= 2) {
            long lastTimestamp = filteredEvents.get(numOfEvents - 1).ts;
            long firstTimestamp = filteredEvents.get(0).ts;
            rate = SensorCtsHelper.getFrequency(
                    (lastTimestamp - firstTimestamp) / (numOfEvents - 1),
                    TimeUnit.NANOSECONDS);
        }
        return rate;
    }

    public Sensor getSensor() {
        return mSensor;
    }

    /**
     * Error message being shown in Assert statements of unit tests when the sampling rate exceeds
     * the allowed capped rate.
     */
    public String errorWhenExceedCappedRate() {
        return String.format(
                ""%s: Sampling rate is expected to be less than or equal to %d (Hz)"",
                mSensor.getName(),
                CAPPED_SAMPLE_RATE_HZ);
    }

    /**
     * Error message being shown in Assert statements of unit tests when the sampling rate is below
     * its expected rate.
     */
    public String errorWhenBelowExpectedRate() {
        return String.format(
                ""%s: Sampling rate is expected to larger than to %d (Hz)"",
                mSensor.getName(),
                CAPPED_SAMPLE_RATE_HZ);
    }

    /**
     * Flip the microphone toggle to off and assert that it is indeed off.
     */
    public void flipAndAssertMicToggleOff(int userID, SensorPrivacyManager spm) {
        ShellUtils.runShellCommand(""cmd sensor_privacy disable "" + userID + "" microphone"");
        SystemUtil.runWithShellPermissionIdentity(() -> {
            Assert.assertTrue(""Failed to switch the mic toggle off!"",
                    !spm.isSensorPrivacyEnabled(SensorPrivacyManager.Sensors.MICROPHONE));
        });
    }

    /**
     * Flip the microphone toggle to off and assert that it is indeed on.
     */
    public void flipAndAssertMicToggleOn(int userID, SensorPrivacyManager spm) {
        ShellUtils.runShellCommand(""cmd sensor_privacy enable "" + userID + "" microphone"");
        SystemUtil.runWithShellPermissionIdentity(() -> {
            Assert.assertTrue(""Failed to switch the mic toggle on!"",
                    spm.isSensorPrivacyEnabled(SensorPrivacyManager.Sensors.MICROPHONE));
        });
    }

    /**
     * Configure a direct channel and return the sensor data in a DirectReportSensorEvent list.
     */
    public List<SensorDirectReportTest.DirectReportSensorEvent> getSensorEvents(int rateLevel)
            throws InterruptedException {
        int sensorEventCount = 2000; // 800 Hz * 2.2 * 1s + extra
        int sharedMemorySize = sensorEventCount * SENSORS_EVENT_SIZE;
        HardwareBuffer hardwareBuffer = HardwareBuffer.create(
                sharedMemorySize, 1, HardwareBuffer.BLOB, 1,
                HardwareBuffer.USAGE_CPU_READ_OFTEN | HardwareBuffer.USAGE_GPU_DATA_BUFFER
                        | HardwareBuffer.USAGE_SENSOR_DIRECT_DATA);

        SensorDirectChannel channel = mSensorManager.createDirectChannel(hardwareBuffer);
        int token = channel.configure(mSensor, rateLevel);
        SensorCtsHelper.sleep(TEST_RUN_TIME_PERIOD_MILLISEC, TimeUnit.MILLISECONDS);
        channel.configure(mSensor, SensorDirectChannel.RATE_STOP);
        List<SensorDirectReportTest.DirectReportSensorEvent> events =
                readEventsFromHardwareBuffer(token, hardwareBuffer, sensorEventCount);
        channel.close();
        hardwareBuffer.close();
        return events;
    }

    /**
     * Parse HardwareBuffer to return a list of DirectReportSensorEvents
     */
    public List<SensorDirectReportTest.DirectReportSensorEvent> readEventsFromHardwareBuffer(
            int token, HardwareBuffer hardwareBuffer, int sensorEventCount) {
        int sharedMemorySize = sensorEventCount * SENSORS_EVENT_SIZE;
        SensorDirectReportTest.EventPool eventPool = new SensorDirectReportTest.EventPool(
                10 * sensorEventCount);
        ByteBuffer byteBuffer = ByteBuffer.allocate(sharedMemorySize);
        byte[] buffer = byteBuffer.array();
        byteBuffer.order(ByteOrder.nativeOrder());
        nativeReadHardwareBuffer(hardwareBuffer, buffer, 0, 0, sharedMemorySize);
        List<SensorDirectReportTest.DirectReportSensorEvent> events =
                SensorDirectReportTest.parseEntireBuffer(token, eventPool, byteBuffer,
                        sharedMemorySize);
        eventPool.reset();
        byteBuffer.clear();
        return events;
    }
}"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.mediastress.cts.NativeMediaActivity"	"exists"	"CtsMediaStressTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/mediastress/src/android/mediastress/cts/NativeMediaActivity.java"	""	"public void test/*
 *.
 */

/* Original code copied from NDK Native-media sample code */
package android.mediastress.cts;

import android.app.Activity;
import android.content.res.Configuration;
import android.graphics.SurfaceTexture;
import android.os.Bundle;
import android.util.Log;
import android.view.Surface;
import android.view.WindowManager;

import java.io.File;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;

import junit.framework.Assert;

public class NativeMediaActivity extends Activity implements OnSurfaceChangedListener {
    public static final String EXTRA_VIDEO_HEIGHT = ""videoHeight"";
    // should be long enough. time-out can be treated as error
    public static final long NATIVE_MEDIA_LIFECYCLE_TIMEOUT_MS = 10000;
    static final String TAG = ""NativeMedia"";
    static final String[] MEDIA = {
        ""bbb_short/480x360/mp4_libx264_libfaac/"" +
        ""bbb_short.ffmpeg.480x360.mp4.libx264_1000kbps_30fps.libfaac_stereo_192kbps_44100Hz.ts"",
        ""bbb_short/720x480/mp4_libx264_libfaac/"" +
        ""bbb_short.ffmpeg.720x480.mp4.libx264_1000kbps_30fps.libfaac_stereo_192kbps_44100Hz.ts"",
        ""bbb_short/1280x720/mp4_libx264_libfaac/"" +
        ""bbb_short.ffmpeg.1280x720.mp4.libx264_1000kbps_30fps.libfaac_stereo_192kbps_44100Hz.ts"",
        ""bbb_short/1920x1080/mp4_libx264_libfaac/"" +
        ""bbb_short.ffmpeg.1920x1080.mp4.libx264_5000kbps_30fps.libfaac_stereo_192kbps_48000Hz.ts""
    };

    private SurfaceTextureGLSurfaceView mGLView;
    private volatile boolean mNativeCreated = false;
    private int mVideoHeight = 360;
    // native media status queued whenever there is a change in life.
    private final BlockingQueue<Boolean> mNativeWaitQ = new LinkedBlockingQueue<Boolean>();

    @Override
    public void onCreate(Bundle icicle) {
        super.onCreate(icicle);
        getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON |
                WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON);
        mVideoHeight = getIntent().getIntExtra(EXTRA_VIDEO_HEIGHT, mVideoHeight);
        mGLView = new SurfaceTextureGLSurfaceView(this, this);
        setContentView(mGLView);
    }

    @Override
    public void onConfigurationChanged(Configuration newConfig) {
        Log.w(TAG, ""configuration changed "" + newConfig.orientation);
        super.onConfigurationChanged(newConfig);
    }

    /**
     * should be called by GLThread after GlSurface is created.
     */
    @Override
    public void onSurfaceCreated() {
        runOnUiThread(new Runnable() {
            @Override
            public void run() {
                Log.i(TAG, ""onSurfaceCreated create engine"");
                // initialize native media system
                Assert.assertTrue(createEngine());
                Assert.assertTrue(setSurfaceForNative());
                String fileName = getMediaString();
                File f = new File(fileName);
                Log.i(TAG, ""start playing "" + fileName + "", exists: "" + f.exists());
                Assert.assertTrue(""file '"" + fileName + ""' does not exist"", f.exists());
                Assert.assertTrue(createMediaPlayer(""file://"" + fileName));
                mNativeCreated = true;
                mNativeWaitQ.add(mNativeCreated);
            }
        });
    }

    /**
     * should be called inside main thread
     */
    @Override
    public void onSurfaceDestroyed() {
        shutdownIfActive();
    }

    /**
     * check if native media is alive. If it does not become alive
     * for more than certain time, assertion fail will happen.
     * @return the status of native media, true if it is alive, null if timed-out
     * @throws InterruptedException
     */
    public Boolean waitForNativeMediaLifeCycle() throws InterruptedException {
        return mNativeWaitQ.poll(NATIVE_MEDIA_LIFECYCLE_TIMEOUT_MS, TimeUnit.MILLISECONDS);
    }

    @Override
    protected void onPause() {
        //GLSurfaceView destroys surface on pause. so shutdown should be done.
        shutdownIfActive();
        mGLView.onPause();
        super.onPause();
    }

    @Override
    protected void onResume() {
        super.onResume();
        mGLView.onResume();
        if (mNativeCreated) {
            Assert.assertTrue(playOrPauseMediaPlayer(true));
        }
    }

    @Override
    protected void onDestroy() {
        if (mNativeCreated) {
            shutdown();
        }
        super.onDestroy();
    }

    private void shutdownIfActive() {
        if (mNativeCreated) {
            Log.i(TAG, ""shutdownIfActive shutdown"");
            // surface no longer available, so just shutdown
            shutdown();
            mNativeCreated = false;
            mNativeWaitQ.add(mNativeCreated);
        }
    }

    private boolean setSurfaceForNative() {
        SurfaceTexture st = mGLView.getSurfaceTexture();
        Assert.assertNotNull(st);
        Surface s = new Surface(st);
        boolean res = setSurface(s);
        s.release();
        return res;
    }

    private String getMediaString() {
        int mediaIndex = 0; // default: 480x360
        switch(mVideoHeight) {
        case 1080:
            mediaIndex = 3;
            break;
        case 720:
            mediaIndex = 2;
            break;
        case 480:
            mediaIndex = 1;
            break;
        }
        return WorkDir.getMediaDirString() + MEDIA[mediaIndex];
    }

    /**
     * creates OpenMaxAl Engine
    */
    public static native boolean createEngine();
    /**
     * set surface to render. should be called before creating Media player
     * @param surface
     */
    public static native boolean setSurface(Surface surface);

    public static native boolean createMediaPlayer(String fileUri);
    public static native boolean playOrPauseMediaPlayer(boolean play);
    public static native void shutdown();

    /** Load jni on initialization */
    static {
         System.loadLibrary(""ctsmediastress_jni"");
    }

}"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.view.inputmethod.cts.InputConnectionWrapperTest"	"testInputConnectionWrapper"	"CtsInputMethodTestCases"	"/home/gpoor/cts-12-source/cts/tests/inputmethod/src/android/view/inputmethod/cts/InputConnectionWrapperTest.java"	""	"public void testInputConnectionWrapper() {
        InputConnection inputConnection = mock(InputConnection.class);
        doReturn(true).when(inputConnection).commitContent(any(InputContentInfo.class),
                anyInt(), any(Bundle.class));
        InputConnectionWrapper wrapper = new InputConnectionWrapper(null, true);
        try {
            wrapper.beginBatchEdit();
            fail(""Failed to throw NullPointerException!"");
        } catch (NullPointerException e) {
            // expected
        }
        wrapper.setTarget(inputConnection);

        wrapper.beginBatchEdit();
        verify(inputConnection, times(1)).beginBatchEdit();

        wrapper.clearMetaKeyStates(KeyEvent.META_ALT_ON);
        verify(inputConnection, times(1)).clearMetaKeyStates(KeyEvent.META_ALT_ON);

        wrapper.commitCompletion(new CompletionInfo(1, 1, ""testText""));
        ArgumentCaptor<CompletionInfo> completionInfoCaptor =
                ArgumentCaptor.forClass(CompletionInfo.class);
        verify(inputConnection, times(1)).commitCompletion(completionInfoCaptor.capture());
        assertEquals(1, completionInfoCaptor.getValue().getId());
        assertEquals(1, completionInfoCaptor.getValue().getPosition());
        assertEquals(""testText"", completionInfoCaptor.getValue().getText());

        wrapper.commitCorrection(new CorrectionInfo(0, ""oldText"", ""newText""));
        ArgumentCaptor<CorrectionInfo> correctionInfoCaptor =
                ArgumentCaptor.forClass(CorrectionInfo.class);
        verify(inputConnection, times(1)).commitCorrection(correctionInfoCaptor.capture());
        assertEquals(0, correctionInfoCaptor.getValue().getOffset());
        assertEquals(""oldText"", correctionInfoCaptor.getValue().getOldText());
        assertEquals(""newText"", correctionInfoCaptor.getValue().getNewText());

        wrapper.commitText(""Text"", 1);
        verify(inputConnection, times(1)).commitText(sameCharSequence(""Text""), eq(1));

        wrapper.deleteSurroundingText(10, 100);
        verify(inputConnection, times(1)).deleteSurroundingText(10, 100);

        wrapper.deleteSurroundingTextInCodePoints(10, 100);
        verify(inputConnection, times(1)).deleteSurroundingTextInCodePoints(10, 100);

        wrapper.endBatchEdit();
        verify(inputConnection, times(1)).endBatchEdit();

        wrapper.finishComposingText();
        verify(inputConnection, times(1)).finishComposingText();

        wrapper.getCursorCapsMode(TextUtils.CAP_MODE_CHARACTERS);
        verify(inputConnection, times(1)).getCursorCapsMode(TextUtils.CAP_MODE_CHARACTERS);

        wrapper.getExtractedText(new ExtractedTextRequest(), 0);
        verify(inputConnection, times(1)).getExtractedText(any(ExtractedTextRequest.class), eq(0));

        wrapper.getTextAfterCursor(5, 0);
        verify(inputConnection, times(1)).getTextAfterCursor(5, 0);

        wrapper.getTextBeforeCursor(3, 0);
        verify(inputConnection, times(1)).getTextBeforeCursor(3, 0);

        wrapper.performContextMenuAction(1);
        verify(inputConnection, times(1)).performContextMenuAction(1);

        wrapper.performEditorAction(EditorInfo.IME_ACTION_GO);
        verify(inputConnection, times(1)).performEditorAction(EditorInfo.IME_ACTION_GO);

        wrapper.performPrivateCommand(""com.android.action.MAIN"", new Bundle());
        verify(inputConnection, times(1)).performPrivateCommand(eq(""com.android.action.MAIN""),
                any(Bundle.class));

        wrapper.reportFullscreenMode(true);
        verify(inputConnection, times(1)).reportFullscreenMode(true);

        wrapper.sendKeyEvent(new KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_0));
        ArgumentCaptor<KeyEvent> keyEventCaptor = ArgumentCaptor.forClass(KeyEvent.class);
        verify(inputConnection, times(1)).sendKeyEvent(keyEventCaptor.capture());
        assertEquals(KeyEvent.ACTION_DOWN, keyEventCaptor.getValue().getAction());
        assertEquals(KeyEvent.KEYCODE_0, keyEventCaptor.getValue().getKeyCode());

        wrapper.setComposingText(""Text"", 1);
        verify(inputConnection, times(1)).setComposingText(""Text"", 1);

        wrapper.setSelection(0, 10);
        verify(inputConnection, times(1)).setSelection(0, 10);

        wrapper.getSelectedText(0);
        verify(inputConnection, times(1)).getSelectedText(0);

        wrapper.setComposingRegion(0, 3);
        verify(inputConnection, times(1)).setComposingRegion(0, 3);

        wrapper.requestCursorUpdates(InputConnection.CURSOR_UPDATE_IMMEDIATE);
        verify(inputConnection, times(1))
                .requestCursorUpdates(InputConnection.CURSOR_UPDATE_IMMEDIATE);

        wrapper.closeConnection();
        verify(inputConnection, times(1)).closeConnection();

        verify(inputConnection, never()).getHandler();
        assertNull(wrapper.getHandler());
        verify(inputConnection, times(1)).getHandler();

        verify(inputConnection, never()).commitContent(any(InputContentInfo.class), anyInt(),
                any(Bundle.class));

        final InputContentInfo inputContentInfo = new InputContentInfo(
                Uri.parse(""content://com.example/path""),
                new ClipDescription(""sample content"", new String[]{""image/png""}),
                Uri.parse(""https://example.com""));
        wrapper.commitContent(inputContentInfo, 0 /* flags */, null /* opt */);
        verify(inputConnection, times(1)).commitContent(inputContentInfo, 0, null);
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.mediav2.cts.ExtractorTest"	"testFileDescriptor"	"CtsMediaV2TestCases"	"/home/gpoor/cts-12-source/cts/tests/media/src/android/mediav2/cts/ExtractorTest.java"	""	"public void testFileDescriptor() throws IOException {
            Preconditions.assertTestFileExists(mInpPrefix + mInpMedia);
            File inpFile = new File(mInpPrefix + mInpMedia);
            MediaExtractor testExtractor = new MediaExtractor();
            try (FileInputStream fInp = new FileInputStream(inpFile)) {
                testExtractor.setDataSource(fInp.getFD());
            }
            assertTrue(testExtractor.getCachedDuration() < 0);
            if (!isMediaSimilar(mRefExtractor, testExtractor, null, Integer.MAX_VALUE) ||
                    !areMetricsIdentical(mRefExtractor, testExtractor) ||
                    !isSeekOk(mRefExtractor, testExtractor)) {
                fail(""setDataSource failed: "" + testName.getMethodName());
            }
            long sdkChecksum = readAllData(testExtractor, null, Integer.MAX_VALUE);
            long ndkChecksum = nativeReadAllData(mInpPrefix + mInpMedia, """",
                    Integer.MAX_VALUE, null, null, false);
            testExtractor.release();
            assertEquals(""SDK and NDK checksums mismatch"", sdkChecksum, ndkChecksum);
        }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.mediav2.cts.ExtractorTest"	"testUrlDataSource"	"CtsMediaV2TestCases"	"/home/gpoor/cts-12-source/cts/tests/media/src/android/mediav2/cts/ExtractorTest.java"	""	"public void testUrlDataSource() throws Exception {
            checkExtractorOkForUrlDS(null);

            Map<String, String> headers = new HashMap<>();
            checkExtractorOkForUrlDS(headers);

            String[] keys = new String[]{""From"", ""Client"", ""Location""};
            String[] values = new String[]{""alcor@bigdipper.asm"", ""CtsTestServer"", ""UrsaMajor""};
            for (int i = 0; i < keys.length; i++) {
                headers.put(keys[i], values[i]);
            }
            checkExtractorOkForUrlDS(headers);

            MediaExtractor testExtractor = new MediaExtractor();
            testExtractor.setDataSource(mInpMediaUrl, headers);
            long sdkChecksum = readAllData(testExtractor, null, Integer.MAX_VALUE);
            testExtractor.release();
            long ndkChecksum = nativeReadAllData(mInpMediaUrl, """", Integer.MAX_VALUE, keys,
                    values, true);
            assertEquals(""SDK and NDK checksums mismatch"", sdkChecksum, ndkChecksum);
            ndkChecksum = nativeReadAllData(mInpMediaUrl, """", Integer.MAX_VALUE, new String[0],
                    new String[0], true);
            assertEquals(""SDK and NDK checksums mismatch"", sdkChecksum, ndkChecksum);
        }

        private native boolean nativeTestDataSource(String srcPath, String srcUrl);"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.mediav2.cts.ExtractorTest"	"testExtract"	"CtsMediaV2TestCases"	"/home/gpoor/cts-12-source/cts/tests/media/src/android/mediav2/cts/ExtractorTest.java"	""	"public void testExtract() throws IOException {
            assumeTrue(shouldRunTest(mMime));
            Preconditions.assertTestFileExists(mInpPrefix + mSrcFiles[0]);
            MediaExtractor refExtractor = new MediaExtractor();
            refExtractor.setDataSource(mInpPrefix + mSrcFiles[0]);
            long sdkChecksum = readAllData(refExtractor, mMime, Integer.MAX_VALUE);
            long ndkChecksum = nativeReadAllData(mInpPrefix + mSrcFiles[0], mMime,
                    Integer.MAX_VALUE, null, null, false);
            assertEquals(""SDK and NDK checksums mismatch"", sdkChecksum, ndkChecksum);
            if (mSrcFiles.length == 1) {
                refExtractor.release();
                return;
            }
            assumeTrue(""TODO(b/146925481)"", !mMime.equals(MediaFormat.MIMETYPE_AUDIO_VORBIS));
            assumeTrue(""TODO(b/146925481)"", !mMime.equals(MediaFormat.MIMETYPE_AUDIO_OPUS));
            assumeTrue(""TODO(b/146925481)"", !mMime.equals(MediaFormat.MIMETYPE_AUDIO_MPEG));
            assumeTrue(""TODO(b/146925481)"", !mMime.equals(MediaFormat.MIMETYPE_AUDIO_AAC));
            boolean isOk = true;
            for (int i = 1; i < mSrcFiles.length && isOk; i++) {
                MediaExtractor testExtractor = new MediaExtractor();
                Preconditions.assertTestFileExists(mInpPrefix + mSrcFiles[i]);
                testExtractor.setDataSource(mInpPrefix + mSrcFiles[i]);
                if (!isMediaSimilar(refExtractor, testExtractor, mMime, Integer.MAX_VALUE)) {
                    if (ENABLE_LOGS) {
                        Log.d(LOG_TAG, ""Files: "" + mSrcFiles[0] + "", "" + mSrcFiles[i] +
                                "" are different from extractor perspective"");
                    }
                    if (!codecListSupp.contains(mMime)) {
                        isOk = false;
                    }
                }
                testExtractor.release();
            }
            refExtractor.release();
            assertTrue(testName.getMethodName() + "" failed for mime: "" + mMime, isOk);
        }

        /**
         * Tests seek functionality, verifies if we seek to most accurate point for a given
         * choice of timestamp and mode.
         */
        @LargeTest"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.view.cts.TooltipTest"	"getWindowSystemUiVisibility"	"CtsViewTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/view/src/android/view/cts/TooltipTest.java"	""	"/*
 *.
 */

package android.view.cts;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import android.app.Activity;
import android.app.Instrumentation;
import android.os.SystemClock;
import android.util.Log;
import android.view.Gravity;
import android.view.InputDevice;
import android.view.KeyEvent;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewConfiguration;
import android.view.ViewGroup;
import android.widget.PopupWindow;
import android.widget.TextView;

import androidx.test.InstrumentationRegistry;
import androidx.test.filters.LargeTest;
import androidx.test.rule.ActivityTestRule;
import androidx.test.runner.AndroidJUnit4;

import com.android.compatibility.common.util.CtsTouchUtils;
import com.android.compatibility.common.util.PollingCheck;

import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;

/**
 * Test {@link View}.
 */
@LargeTest
@RunWith(AndroidJUnit4.class)
public class TooltipTest {
    private static final String LOG_TAG = ""TooltipTest"";

    private static final long TIMEOUT_DELTA = 10000;
    private static final long WAIT_MARGIN = 100;

    private Instrumentation mInstrumentation;
    private Activity mActivity;
    private ViewGroup mTopmostView;
    private ViewGroup mGroupView;
    private View mNoTooltipView;
    private View mTooltipView;
    private View mNoTooltipView2;
    private View mEmptyGroup;

    @Rule
    public ActivityTestRule<TooltipActivity> mActivityRule =
            new ActivityTestRule<>(TooltipActivity.class);

    @Rule
    public ActivityTestRule<CtsActivity> mCtsActivityRule =
            new ActivityTestRule<>(CtsActivity.class, false, false);

    @Before
    public void setup() {
        mInstrumentation = InstrumentationRegistry.getInstrumentation();
        mActivity = mActivityRule.getActivity();
        mTopmostView = (ViewGroup) mActivity.findViewById(R.id.tooltip_layout);
        mGroupView = (ViewGroup) mActivity.findViewById(R.id.tooltip_group);
        mNoTooltipView = mActivity.findViewById(R.id.no_tooltip);
        mTooltipView = mActivity.findViewById(R.id.has_tooltip);
        mNoTooltipView2 = mActivity.findViewById(R.id.no_tooltip2);
        mEmptyGroup = mActivity.findViewById(R.id.empty_group);

        PollingCheck.waitFor(TIMEOUT_DELTA, mActivity::hasWindowFocus);
    }

    private void waitOut(long msDelay) {
        try {
            Thread.sleep(msDelay + WAIT_MARGIN);
        } catch (InterruptedException e) {
            Log.e(LOG_TAG, ""Wait interrupted. Test may fail!"", e);
        }
    }

    private void setTooltipText(View view, CharSequence tooltipText) throws Throwable {
        mActivityRule.runOnUiThread(() -> view.setTooltipText(tooltipText));
    }

    private boolean hasTooltip(View view) {
        final View tooltipView = view.getTooltipView();
        return tooltipView != null && tooltipView.getParent() != null;
    }


    private void addView(ViewGroup parent, View view) throws Throwable {
        mActivityRule.runOnUiThread(() -> parent.addView(view));
        mInstrumentation.waitForIdleSync();
    }

    private void removeView(View view) throws Throwable {
        mActivityRule.runOnUiThread(() -> ((ViewGroup) (view.getParent())).removeView(view));
        mInstrumentation.waitForIdleSync();
    }

    private void setVisibility(View view, int visibility) throws Throwable {
        mActivityRule.runOnUiThread(() -> view.setVisibility(visibility));
    }

    private void setClickable(View view) throws Throwable {
        mActivityRule.runOnUiThread(() -> view.setClickable(true));
    }

    private void setLongClickable(View view) throws Throwable {
        mActivityRule.runOnUiThread(() -> view.setLongClickable(true));
    }

    private void setContextClickable(View view) throws Throwable {
        mActivityRule.runOnUiThread(() -> view.setContextClickable(true));
    }

    private void callPerformLongClick(View view) throws Throwable {
        mActivityRule.runOnUiThread(() -> view.performLongClick(0, 0));
    }

    private void requestLowProfileSystemUi() throws Throwable {
        final int flag = View.SYSTEM_UI_FLAG_LOW_PROFILE;
        mActivityRule.runOnUiThread(() -> mTooltipView.setSystemUiVisibility(flag));
        PollingCheck.waitFor(TIMEOUT_DELTA,
                () -> (mTooltipView.getWindowSystemUiVisibility() & flag) == flag);
    }

    private void injectKeyPress(View target, int keyCode, int duration) throws Throwable {
        if (target != null) {
            mActivityRule.runOnUiThread(() -> {
                target.setFocusableInTouchMode(true);
                target.requestFocus();
            });
            mInstrumentation.waitForIdleSync();
            assertTrue(target.isFocused());
        }
        mInstrumentation.sendKeySync(new KeyEvent(KeyEvent.ACTION_DOWN, keyCode));
        waitOut(duration);
        mInstrumentation.sendKeySync(new KeyEvent(KeyEvent.ACTION_UP, keyCode));
    }

    private void injectArbitraryShortKeyPress() throws Throwable {
        injectKeyPress(null, KeyEvent.KEYCODE_0, 0);
    }

    private void injectLongKeyPress(View target, int keyCode) throws Throwable {
        injectKeyPress(target, keyCode, ViewConfiguration.getLongPressTimeout());
    }

    private void injectLongEnter(View target) throws Throwable {
        injectLongKeyPress(target, KeyEvent.KEYCODE_ENTER);
    }

    private void injectShortClick(View target) {
        CtsTouchUtils.emulateTapOnViewCenter(mInstrumentation, mActivityRule, target);
    }

    private void injectLongClick(View target) {
        CtsTouchUtils.emulateLongPressOnView(mInstrumentation, mActivityRule, target,
                target.getWidth() / 2, target.getHeight() / 2);
    }

    private void injectMotionEvent(MotionEvent event) {
        mInstrumentation.sendPointerSync(event);
    }

    private void injectHoverMove(int source, View target, int offsetX, int offsetY) {
        injectMotionEvent(obtainMotionEvent(
                    source, target, MotionEvent.ACTION_HOVER_MOVE, offsetX,  offsetY));
    }

    private void injectHoverMove(View target, int offsetX, int offsetY) {
        injectHoverMove(InputDevice.SOURCE_MOUSE, target, offsetX,  offsetY);
    }

    private void injectHoverMove(View target) {
        injectHoverMove(target, 0, 0);
    }

    private void injectLongHoverMove(View target) {
        injectHoverMove(target);
        waitOut(ViewConfiguration.getHoverTooltipShowTimeout());
    }

    private static MotionEvent obtainMouseEvent(View target, int action, int offsetX, int offsetY) {
        return obtainMotionEvent(InputDevice.SOURCE_MOUSE, target, action, offsetX, offsetY);
    }

    private static MotionEvent obtainMotionEvent(
                int source, View target, int action, int offsetX, int offsetY) {
        final long eventTime = SystemClock.uptimeMillis();
        final int[] xy = new int[2];
        target.getLocationOnScreen(xy);
        MotionEvent event = MotionEvent.obtain(eventTime, eventTime, action,
                xy[0] + target.getWidth() / 2 + offsetX, xy[1] + target.getHeight() / 2 + offsetY,
                0);
        event.setSource(source);
        return event;
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.managedprovisioning.DeviceAdminTestReceiver"	"isHeadlessSystemUserMode"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/managedprovisioning/DeviceAdminTestReceiver.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.managedprovisioning;

import static android.app.admin.DevicePolicyManager.EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE;

import android.app.Service;
import android.app.admin.DeviceAdminReceiver;
import android.app.admin.DevicePolicyManager;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.ServiceConnection;
import android.content.pm.PackageManager;
import android.os.IBinder;
import android.os.PersistableBundle;
import android.os.Process;
import android.os.RemoteException;
import android.os.UserHandle;
import android.os.UserManager;
import android.util.Log;

import androidx.localbroadcastmanager.content.LocalBroadcastManager;

import com.android.bedstead.dpmwrapper.DeviceOwnerHelper;
import com.android.compatibility.common.util.enterprise.DeviceAdminReceiverUtils;
import com.android.cts.verifier.R;

import java.util.Collections;
import java.util.HashSet;
import java.util.Set;
import java.util.function.Consumer;

/**
 * Profile owner receiver for BYOD flow test.
 * Setup cross-profile intent filter after successful provisioning.
 */
public class DeviceAdminTestReceiver extends DeviceAdminReceiver {
    public static final String KEY_BUNDLE_WIPE_IMMEDIATELY = ""wipe_immediately"";
    private static final String TAG = ""DeviceAdminTestReceiver"";
    private static final String DEVICE_OWNER_PKG =
            ""com.android.cts.verifier"";
    private static final String ADMIN_RECEIVER_TEST_CLASS =
            DEVICE_OWNER_PKG + "".managedprovisioning.DeviceAdminTestReceiver"";
    private static final ComponentName RECEIVER_COMPONENT_NAME = new ComponentName(
            DEVICE_OWNER_PKG, ADMIN_RECEIVER_TEST_CLASS);
    public static final String EXTRA_MANAGED_USER_TEST =
            ""com.android.cts.verifier.managedprovisioning.extra.MANAGED_USER_TEST"";
    public static final String EXTRA_LOGOUT_ON_START =
            ""com.android.cts.verifier.managedprovisioning.extra.LOGOUT_ON_START"";
    public static final String AFFILIATION_ID = ""affiliationId"";

    public static ComponentName getReceiverComponentName() {
        return RECEIVER_COMPONENT_NAME;
    }

    @Override
    public void onReceive(Context context, Intent intent) {
        if (DeviceAdminReceiverUtils.disableSelf(context, intent)) return;
        if (DeviceOwnerHelper.runManagerMethod(this, context, intent)) return;

        String action = intent.getAction();
        Log.d(TAG, ""onReceive(): user="" + UserHandle.myUserId() + "", action="" + action);

        // Must set affiliation on headless system user, otherwise some operations in the current
        // user (which is PO) won't be allowed (like uininstalling a package)
        if (ACTION_DEVICE_ADMIN_ENABLED.equals(action) && UserManager.isHeadlessSystemUserMode()) {
            Set<String> ids = new HashSet<>();
            ids.add(""affh!"");
            Log.i(TAG, ""Setting affiliation ids to "" + ids);
            getManager(context).setAffiliationIds(getWho(context), ids);
        }

        super.onReceive(context, intent);
    }

    @Override
    public void onProfileProvisioningComplete(Context context, Intent intent) {
        Log.d(TAG, ""Provisioning complete intent received"");
        setupProfile(context);
        wipeIfNecessary(context, intent);
    }

    @Override
    public void onBugreportSharingDeclined(Context context, Intent intent) {
        Log.i(TAG, ""Bugreport sharing declined"");
        Utils.showBugreportNotification(context, context.getString(
                R.string.bugreport_sharing_declined), Utils.BUGREPORT_NOTIFICATION_ID);
    }

    @Override
    public void onBugreportShared(Context context, Intent intent, String bugreportFileHash) {
        Log.i(TAG, ""Bugreport shared"");
        Utils.showBugreportNotification(context, context.getString(
                R.string.bugreport_shared_successfully), Utils.BUGREPORT_NOTIFICATION_ID);
    }

    @Override
    public void onBugreportFailed(Context context, Intent intent, int failureCode) {
        Log.i(TAG, ""Bugreport collection operation failed, code: "" + failureCode);
        Utils.showBugreportNotification(context, context.getString(
                R.string.bugreport_failed_completing), Utils.BUGREPORT_NOTIFICATION_ID);
    }

    @Override
    public void onLockTaskModeEntering(Context context, Intent intent, String pkg) {
        Log.i(TAG, ""Entering LockTask mode: "" + pkg);
        LocalBroadcastManager.getInstance(context)
                .sendBroadcast(new Intent(LockTaskUiTestActivity.ACTION_LOCK_TASK_STARTED));
    }

    @Override
    public void onLockTaskModeExiting(Context context, Intent intent) {
        Log.i(TAG, ""Exiting LockTask mode"");
        LocalBroadcastManager.getInstance(context)
                .sendBroadcast(new Intent(LockTaskUiTestActivity.ACTION_LOCK_TASK_STOPPED));
    }

    @Override
    public void onEnabled(Context context, Intent intent) {
        Log.i(TAG, ""Device admin enabled"");
        if (intent.getBooleanExtra(EXTRA_MANAGED_USER_TEST, false)) {
            DevicePolicyManager dpm = context.getSystemService(DevicePolicyManager.class);
            ComponentName admin = getReceiverComponentName();
            dpm.setAffiliationIds(admin,
                    Collections.singleton(DeviceAdminTestReceiver.AFFILIATION_ID));
            context.startActivity(
                    new Intent(context, ManagedUserPositiveTestActivity.class).setFlags(
                            Intent.FLAG_ACTIVITY_NEW_TASK));

            bindPrimaryUserService(context, iCrossUserService -> {
                try {
                    UserHandle userHandle = Process.myUserHandle();
                    Log.d(TAG, ""calling switchUser("" + userHandle + "")"");
                    iCrossUserService.switchUser(userHandle);
                } catch (RemoteException re) {
                    Log.e(TAG, ""Error when calling primary user"", re);
                }
            });
        } else if (intent.getBooleanExtra(EXTRA_LOGOUT_ON_START, false)) {
            DevicePolicyManager dpm = context.getSystemService(DevicePolicyManager.class);
            ComponentName admin = getReceiverComponentName();
            dpm.setAffiliationIds(admin,
                    Collections.singleton(DeviceAdminTestReceiver.AFFILIATION_ID));
            dpm.logoutUser(admin);
        }
    }

    private void setupProfile(Context context) {
        DevicePolicyManager dpm = (DevicePolicyManager) context.getSystemService(Context.DEVICE_POLICY_SERVICE);
        dpm.setProfileEnabled(new ComponentName(context.getApplicationContext(), getClass()));

        // Setup cross-profile intent filter to allow communications between the two versions of CtsVerifier
        // Primary -> work direction
        IntentFilter filter = new IntentFilter();
        filter.addAction(ByodHelperActivity.ACTION_QUERY_PROFILE_OWNER);
        filter.addAction(ByodHelperActivity.ACTION_REMOVE_MANAGED_PROFILE);
        filter.addAction(ByodHelperActivity.ACTION_CHECK_DISK_ENCRYPTION);
        filter.addAction(ByodHelperActivity.ACTION_INSTALL_APK);
        filter.addAction(ByodHelperActivity.ACTION_INSTALL_APK_WORK_PROFILE_GLOBAL_RESTRICTION);
        filter.addAction(ByodHelperActivity.ACTION_INSTALL_APK_PRIMARY_PROFILE_GLOBAL_RESTRICTION);
        filter.addAction(ByodHelperActivity.ACTION_CHECK_INTENT_FILTERS);
        filter.addAction(ByodHelperActivity.ACTION_CAPTURE_AND_CHECK_IMAGE);
        filter.addAction(ByodHelperActivity.ACTION_CAPTURE_AND_CHECK_VIDEO_WITH_EXTRA_OUTPUT);
        filter.addAction(ByodHelperActivity.ACTION_CAPTURE_AND_CHECK_VIDEO_WITHOUT_EXTRA_OUTPUT);
        filter.addAction(ByodHelperActivity.ACTION_CAPTURE_AND_CHECK_AUDIO);
        filter.addAction(ByodHelperActivity.ACTION_KEYGUARD_DISABLED_FEATURES);
        filter.addAction(ByodHelperActivity.ACTION_LOCKNOW);
        filter.addAction(ByodHelperActivity.ACTION_TEST_NFC_BEAM);
        filter.addAction(ByodHelperActivity.ACTION_TEST_CROSS_PROFILE_INTENTS_DIALOG);
        filter.addAction(ByodHelperActivity.ACTION_TEST_APP_LINKING_DIALOG);
        filter.addAction(ByodHelperActivity.ACTION_NOTIFICATION);
        filter.addAction(ByodHelperActivity.ACTION_NOTIFICATION_ON_LOCKSCREEN);
        filter.addAction(ByodHelperActivity.ACTION_CLEAR_NOTIFICATION);
        filter.addAction(ByodHelperActivity.ACTION_SET_USER_RESTRICTION);
        filter.addAction(ByodHelperActivity.ACTION_CLEAR_USER_RESTRICTION);
        filter.addAction(CrossProfileTestActivity.ACTION_CROSS_PROFILE_TO_WORK);
        filter.addAction(WorkStatusTestActivity.ACTION_WORK_STATUS_TOAST);
        filter.addAction(WorkStatusTestActivity.ACTION_WORK_STATUS_ICON);
        filter.addAction(
                PermissionLockdownTestActivity.ACTION_MANAGED_PROFILE_CHECK_PERMISSION_LOCKDOWN);
        filter.addAction(AuthenticationBoundKeyTestActivity.ACTION_AUTH_BOUND_KEY_TEST);
        filter.addAction(VpnTestActivity.ACTION_VPN);
        filter.addAction(AlwaysOnVpnSettingsTestActivity.ACTION_ALWAYS_ON_VPN_SETTINGS_TEST);
        filter.addAction(RecentsRedactionActivity.ACTION_RECENTS);
        filter.addAction(ByodHelperActivity.ACTION_TEST_SELECT_WORK_CHALLENGE);
        filter.addAction(ByodHelperActivity.ACTION_TEST_PATTERN_WORK_CHALLENGE);
        filter.addAction(ByodHelperActivity.ACTION_LAUNCH_CONFIRM_WORK_CREDENTIALS);
        filter.addAction(ByodHelperActivity.ACTION_SET_ORGANIZATION_INFO);
        filter.addAction(ByodHelperActivity.ACTION_TEST_PARENT_PROFILE_PASSWORD);
        filter.addAction(SetSupportMessageActivity.ACTION_SET_SUPPORT_MSG);
        filter.addAction(KeyChainTestActivity.ACTION_KEYCHAIN);
        filter.addAction(CommandReceiverActivity.ACTION_EXECUTE_COMMAND);
        filter.addAction(WorkProfileWidgetActivity.ACTION_TEST_WORK_PROFILE_WIDGET);
        filter.addAction(
                CrossProfilePermissionControlActivity.ACTION_CROSS_PROFILE_PERMISSION_CONTROL);
        filter.addAction(LocationCheckerActivity.ACTION_CHECK_LOCATION_WORK);
        dpm.addCrossProfileIntentFilter(getWho(context), filter,
                DevicePolicyManager.FLAG_MANAGED_CAN_ACCESS_PARENT);

        // Work -> primary direction
        filter = new IntentFilter();
        filter.addAction(ByodHelperActivity.ACTION_PROFILE_OWNER_STATUS);
        filter.addAction(ByodHelperActivity.ACTION_DISK_ENCRYPTION_STATUS);
        filter.addAction(ByodHelperActivity.ACTION_INSTALL_APK_IN_PRIMARY);
        filter.addAction(ByodFlowTestActivity.ACTION_TEST_RESULT);
        filter.addAction(CrossProfileTestActivity.ACTION_CROSS_PROFILE_TO_PERSONAL);

        dpm.addCrossProfileIntentFilter(getWho(context), filter,
                DevicePolicyManager.FLAG_PARENT_CAN_ACCESS_MANAGED);

        // Disable the work profile instance of this activity, because it is a helper activity for
        // the work -> primary direction.
        context.getPackageManager().setComponentEnabledSetting(
                new ComponentName(context, ByodPrimaryHelperActivity.class.getName()),
                PackageManager.COMPONENT_ENABLED_STATE_DISABLED, PackageManager.DONT_KILL_APP);

        // Disable the work profile instance of ByodFlowTestActivity
        context.getPackageManager().setComponentEnabledSetting(
                new ComponentName(context, ByodFlowTestActivity.class),
                PackageManager.COMPONENT_ENABLED_STATE_DISABLED, PackageManager.DONT_KILL_APP);
    }

    private void wipeIfNecessary(Context context, Intent intent) {
        PersistableBundle bundle = intent.getParcelableExtra(
                EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE);
        if (bundle != null && bundle.getBoolean(KEY_BUNDLE_WIPE_IMMEDIATELY, false)) {
            getManager(context).wipeData(0);
        }
    }

    private void bindPrimaryUserService(Context context, Consumer<ICrossUserService> consumer) {
        DevicePolicyManager devicePolicyManager = context.getSystemService(
                DevicePolicyManager.class);
        UserHandle primaryUser = devicePolicyManager.getBindDeviceAdminTargetUsers(
                getReceiverComponentName()).get(0);

        Log.d(TAG, ""Calling primary user: "" + primaryUser);
        final ServiceConnection serviceConnection = new ServiceConnection() {
            @Override
            public void onServiceConnected(ComponentName name, IBinder service) {
                Log.d(TAG, ""onServiceConnected is called"");
                consumer.accept(ICrossUserService.Stub.asInterface(service));
            }

            @Override
            public void onServiceDisconnected(ComponentName name) {
                Log.d(TAG, ""onServiceDisconnected is called"");
            }
        };
        final Intent serviceIntent = new Intent(context, PrimaryUserService.class);
        devicePolicyManager.bindDeviceAdminServiceAsUser(getReceiverComponentName(), serviceIntent,
                serviceConnection, Context.BIND_AUTO_CREATE, primaryUser);
    }

    public static final class PrimaryUserService extends Service {
        private final ICrossUserService.Stub mBinder = new ICrossUserService.Stub() {
            public void switchUser(UserHandle userHandle) {
                Log.d(TAG, ""switchUser: "" + userHandle);
                getSystemService(DevicePolicyManager.class).switchUser(getReceiverComponentName(),
                        userHandle);
            }
        };

        @Override
        public IBinder onBind(Intent intent) {
            return mBinder;
        }
    }
}"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.widget.cts.AutoCompleteTextViewTest"	"testPerformFiltering"	"CtsWidgetTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/AutoCompleteTextViewTest.java"	""	"public void testPerformFiltering() throws Throwable {
        if (isTvMode()) {
            return;
        }
        WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, mAutoCompleteTextView, () -> {
            mAutoCompleteTextView.setAdapter(mAdapter);
            mAutoCompleteTextView.setValidator(mValidator);

            mAutoCompleteTextView.setText(""test"");
            mAutoCompleteTextView.setFocusable(true);
            mAutoCompleteTextView.requestFocus();
            mAutoCompleteTextView.showDropDown();
        });
        assertTrue(mAutoCompleteTextView.isPopupShowing());

        mInstrumentation.sendKeyDownUpSync(KeyEvent.KEYCODE_BACK);
        // KeyBack will close the popup.
        assertFalse(mAutoCompleteTextView.isPopupShowing());

        WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, mAutoCompleteTextView, () -> {
            mAutoCompleteTextView.dismissDropDown();
            mAutoCompleteTextView.setText(STRING_TEST);
        });

        assertEquals(STRING_TEST, mAutoCompleteTextView.getText().toString());
        mInstrumentation.sendKeyDownUpSync(KeyEvent.KEYCODE_DPAD_DOWN);
        // If the popup is closed, onKeyDown will invoke performValidation.
        assertEquals(STRING_VALIDATED, mAutoCompleteTextView.getText().toString());

        final MockAdapter<String> adapter = new MockAdapter<String>(mActivity,
                android.R.layout.simple_dropdown_item_1line, WORDS);

        // Set Threshold to 4 characters onKeyDown
        WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, mAutoCompleteTextView, () -> {
            mAutoCompleteTextView.setAdapter(adapter);
            mAutoCompleteTextView.requestFocus();
            mAutoCompleteTextView.setText("""");
        });
        // Create and get the filter.
        final MockFilter filter = (MockFilter) adapter.getFilter();

        // performFiltering will be indirectly invoked by onKeyDown
        assertNull(filter.getResult());
        // 12-key support
        if (mNumeric) {
            // ""numeric"" in case of 12-key(NUMERIC) keyboard
            mInstrumentation.sendStringSync(""6688633777444222"");
            PollingCheck.waitFor(() -> ""numeric"".equals(filter.getResult()));
        } else {
            SystemClock.sleep(200);
            mInstrumentation.sendStringSync(STRING_TEST);
            PollingCheck.waitFor(() -> STRING_TEST.equals(filter.getResult()));
        }
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.widget.cts.AutoCompleteTextViewTest"	"testPerformCompletionWithDPad"	"CtsWidgetTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/AutoCompleteTextViewTest.java"	""	"public void testPerformCompletionWithDPad() throws Throwable {
        if (isTvMode()) {
            return;
        }
        final AdapterView.OnItemClickListener mockItemClickListener =
                mock(AdapterView.OnItemClickListener.class);
        assertFalse(mAutoCompleteTextView.isPerformingCompletion());

        WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, mAutoCompleteTextView, () -> {
            mAutoCompleteTextView.setOnItemClickListener(mockItemClickListener);
            mAutoCompleteTextView.setAdapter(mAdapter);
            mAutoCompleteTextView.requestFocus();
            mAutoCompleteTextView.showDropDown();
        });
        assertFalse(mAutoCompleteTextView.isPerformingCompletion());

        // Key is ENTER, will invoke completion
        mInstrumentation.sendKeyDownUpSync(KeyEvent.KEYCODE_DPAD_DOWN);
        mInstrumentation.sendKeyDownUpSync(KeyEvent.KEYCODE_ENTER);
        WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, mAutoCompleteTextView, null);
        verify(mockItemClickListener, times(1)).onItemClick(any(AdapterView.class), any(View.class),
                eq(0), eq(0L));
        assertEquals(WORDS[0], mAutoCompleteTextView.getText().toString());

        WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, mAutoCompleteTextView,
                mAutoCompleteTextView::showDropDown);
        // Key is NUMPAD_ENTER, will invoke completion
        mInstrumentation.sendKeyDownUpSync(KeyEvent.KEYCODE_DPAD_DOWN);
        mInstrumentation.sendKeyDownUpSync(KeyEvent.KEYCODE_NUMPAD_ENTER);
        WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, mAutoCompleteTextView, null);
        verify(mockItemClickListener, times(2)).onItemClick(any(AdapterView.class), any(View.class),
                eq(0), eq(0L));
        assertEquals(WORDS[0], mAutoCompleteTextView.getText().toString());

        WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, mAutoCompleteTextView,
                mAutoCompleteTextView::showDropDown);
        mInstrumentation.sendKeyDownUpSync(KeyEvent.KEYCODE_DPAD_DOWN);
        mInstrumentation.sendKeyDownUpSync(KeyEvent.KEYCODE_DPAD_CENTER);
        verify(mockItemClickListener, times(3)).onItemClick(any(AdapterView.class), any(View.class),
                eq(0), eq(0L));
        assertEquals(WORDS[0], mAutoCompleteTextView.getText().toString());
        assertFalse(mAutoCompleteTextView.isPerformingCompletion());

        mActivityRule.runOnUiThread(mAutoCompleteTextView::showDropDown);
        mInstrumentation.sendKeyDownUpSync(KeyEvent.KEYCODE_DPAD_DOWN);
        // Test normal key code.
        mInstrumentation.sendKeyDownUpSync(KeyEvent.KEYCODE_0);
        verifyNoMoreInteractions(mockItemClickListener);
        assertNotSame("""", mAutoCompleteTextView.getText().toString());
        assertFalse(mAutoCompleteTextView.isPerformingCompletion());

        // Test the method on the scene of popup is closed.
        mActivityRule.runOnUiThread(mAutoCompleteTextView::dismissDropDown);

        mInstrumentation.sendKeyDownUpSync(KeyEvent.KEYCODE_DPAD_DOWN);
        mInstrumentation.sendKeyDownUpSync(KeyEvent.KEYCODE_ENTER);
        verifyNoMoreInteractions(mockItemClickListener);
        assertNotSame("""", mAutoCompleteTextView.getText().toString());
        assertFalse(mAutoCompleteTextView.isPerformingCompletion());
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.widget.cts.AutoCompleteTextViewTest"	"testPerformCompletionExplicit"	"CtsWidgetTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/AutoCompleteTextViewTest.java"	""	"public void testPerformCompletionExplicit() throws Throwable {
        final AdapterView.OnItemClickListener mockItemClickListener =
                mock(AdapterView.OnItemClickListener.class);
        assertFalse(mAutoCompleteTextView.isPerformingCompletion());

        // Create a custom watcher that checks isPerformingCompletion to return true
        // in the ""middle"" of the performCompletion processing. We also spy on this watcher
        // to make sure that its onTextChanged is invoked.
        final TextWatcher myTextWatcher = new MyTextWatcher(WORDS[1]);
        final TextWatcher spyTextWatcher = spy(myTextWatcher);
        mAutoCompleteTextView.addTextChangedListener(spyTextWatcher);

        WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, mAutoCompleteTextView, () -> {
            mAutoCompleteTextView.setOnItemClickListener(mockItemClickListener);
            mAutoCompleteTextView.setAdapter(mAdapter);
            mAutoCompleteTextView.requestFocus();
            mAutoCompleteTextView.showDropDown();
        });

        assertTrue(mAutoCompleteTextView.isPopupShowing());
        assertFalse(mAutoCompleteTextView.isPerformingCompletion());

        mInstrumentation.sendKeyDownUpSync(KeyEvent.KEYCODE_DPAD_DOWN);
        mInstrumentation.sendKeyDownUpSync(KeyEvent.KEYCODE_DPAD_DOWN);
        mActivityRule.runOnUiThread(mAutoCompleteTextView::performCompletion);
        verify(mockItemClickListener, times(1)).onItemClick(any(AdapterView.class), any(View.class),
                eq(1), eq(1L));
        assertEquals(WORDS[1], mAutoCompleteTextView.getText().toString());
        assertFalse(mAutoCompleteTextView.isPerformingCompletion());
        assertFalse(mAutoCompleteTextView.isPopupShowing());

        verify(spyTextWatcher, atLeastOnce()).onTextChanged(sameCharSequence(WORDS[1]),
                eq(0), eq(0), eq(WORDS[1].length()));
        verifyNoMoreInteractions(mockItemClickListener);
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.widget.cts.SearchView_CursorTest"	"testSuggestionEnterKey"	"CtsWidgetTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/SearchView_CursorTest.java"	""	"public void testSuggestionEnterKey() throws Throwable {
        final SearchView.OnSuggestionListener mockSuggestionListener =
                spy(new MySuggestionListener());
        when(mockSuggestionListener.onSuggestionClick(anyInt())).thenCallRealMethod();

        final SearchView.OnQueryTextListener mockQueryTextListener =
                spy(new MyQueryTextListener());
        when(mockQueryTextListener.onQueryTextChange(anyString())).thenCallRealMethod();

        WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, mSearchView, () -> {
            mSearchView.setIconifiedByDefault(false);
            mSearchView.setOnQueryTextListener(mockQueryTextListener);
            mSearchView.setOnSuggestionListener(mockSuggestionListener);
            mSearchView.requestFocus();
            mSearchView.setQuery(""Di"", false);
        });

        mInstrumentation.waitForIdleSync();
        verify(mockQueryTextListener, times(1)).onQueryTextChange(""Di"");

        CtsKeyEventUtil.sendKeys(mInstrumentation, mSearchView, KeyEvent.KEYCODE_DPAD_DOWN,
                KeyEvent.KEYCODE_ENTER);

        // Verify that our spy suggestion listener was called.
        verify(mockSuggestionListener, times(1)).onSuggestionClick(0);

        WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, mSearchView, () -> {
            mSearchView.setQuery(""Bo"", false);
        });

        mInstrumentation.waitForIdleSync();
        verify(mockQueryTextListener, times(1)).onQueryTextChange(""Bo"");

        CtsKeyEventUtil.sendKeys(mInstrumentation, mSearchView, KeyEvent.KEYCODE_DPAD_DOWN,
                KeyEvent.KEYCODE_NUMPAD_ENTER);

        // Verify that our spy suggestion listener was called.
        verify(mockSuggestionListener, times(2)).onSuggestionClick(0);

        verifyNoMoreInteractions(mockSuggestionListener);
    }
}"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.security.ScreenLockBoundKeysTest"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/security/ScreenLockBoundKeysTest.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.security;

import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;

import android.app.AlertDialog;
import android.app.KeyguardManager;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.security.keystore.KeyGenParameterSpec;
import android.security.keystore.KeyPermanentlyInvalidatedException;
import android.security.keystore.KeyProperties;
import android.security.keystore.UserNotAuthenticatedException;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.Toast;

import java.io.IOException;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.UnrecoverableKeyException;
import java.security.cert.CertificateException;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.KeyGenerator;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;

public class ScreenLockBoundKeysTest extends PassFailButtons.Activity {

    /** Alias for our key in the Android Key Store. */
    private static final String KEY_NAME = ""my_lock_key"";
    private static final byte[] SECRET_BYTE_ARRAY = new byte[] {1, 2, 3, 4, 5, 6};
    private static final int AUTHENTICATION_DURATION_SECONDS = 5;
    private static final int CONFIRM_CREDENTIALS_REQUEST_CODE = 1;

    private KeyguardManager mKeyguardManager;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.sec_screen_lock_keys_main);
        setPassFailButtonClickListeners();
        setInfoResources(R.string.sec_lock_bound_key_test, R.string.sec_lock_bound_key_test_info, -1);

        mKeyguardManager = (KeyguardManager) getSystemService(KEYGUARD_SERVICE);

        getPassButton().setEnabled(false);

        Button startTestButton = (Button) findViewById(R.id.sec_start_test_button);
        startTestButton.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                showToast(""Test running..."");
                v.postDelayed(new Runnable() {
                    @Override
                    public void run() {
                        if (tryEncrypt()) {
                            showToast(""Test failed. Key accessible without auth."");
                        } else {
                            showAuthenticationScreen();
                        }
                    }
                },
                AUTHENTICATION_DURATION_SECONDS * 1000);
            }

        });

        if (!mKeyguardManager.isKeyguardSecure()) {
            // Show a message that the user hasn't set up a lock screen.
            Toast.makeText(this,
                    ""Secure lock screen hasn't set up.\n""
                            + ""Go to 'Settings -> Security -> Screenlock' to set up a lock screen"",
                    Toast.LENGTH_LONG).show();
            startTestButton.setEnabled(false);
            return;
        }

        createKey();
    }

    /**
     * Creates a symmetric key in the Android Key Store which can only be used after the user has
     * authenticated with device credentials within the last X seconds.
     */
    private void createKey() {
        // Generate a key to decrypt payment credentials, tokens, etc.
        // This will most likely be a registration step for the user when they are setting up your app.
        try {
            KeyStore keyStore = KeyStore.getInstance(""AndroidKeyStore"");
            keyStore.load(null);
            KeyGenerator keyGenerator = KeyGenerator.getInstance(
                    KeyProperties.KEY_ALGORITHM_AES, ""AndroidKeyStore"");

            // Set the alias of the entry in Android KeyStore where the key will appear
            // and the constrains (purposes) in the constructor of the Builder
            keyGenerator.init(new KeyGenParameterSpec.Builder(KEY_NAME,
                    KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT)
                    .setBlockModes(KeyProperties.BLOCK_MODE_CBC)
                    .setUserAuthenticationRequired(true)
                            // Require that the user has unlocked in the last 30 seconds
                    .setUserAuthenticationValidityDurationSeconds(AUTHENTICATION_DURATION_SECONDS)
                    .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_PKCS7)
                    .build());
            keyGenerator.generateKey();
        } catch (NoSuchAlgorithmException | NoSuchProviderException
                | InvalidAlgorithmParameterException | KeyStoreException
                | CertificateException | IOException e) {
            throw new RuntimeException(""Failed to create a symmetric key"", e);
        }
    }

    /**
     * Tries to encrypt some data with the generated key in {@link #createKey} which is
     * only works if the user has just authenticated via device credentials.
     */
    private boolean tryEncrypt() {
        try {
            KeyStore keyStore = KeyStore.getInstance(""AndroidKeyStore"");
            keyStore.load(null);
            SecretKey secretKey = (SecretKey) keyStore.getKey(KEY_NAME, null);
            Cipher cipher = Cipher.getInstance(
                    KeyProperties.KEY_ALGORITHM_AES + ""/"" + KeyProperties.BLOCK_MODE_CBC + ""/""
                            + KeyProperties.ENCRYPTION_PADDING_PKCS7);

            // Try encrypting something, it will only work if the user authenticated within
            // the last AUTHENTICATION_DURATION_SECONDS seconds.
            cipher.init(Cipher.ENCRYPT_MODE, secretKey);
            cipher.doFinal(SECRET_BYTE_ARRAY);
            return true;
        } catch (UserNotAuthenticatedException e) {
            // User is not authenticated, let's authenticate with device credentials.
            return false;
        } catch (KeyPermanentlyInvalidatedException e) {
            // This happens if the lock screen has been disabled or reset after the key was
            // generated after the key was generated.
            createKey();
            Toast.makeText(this, ""Set up lockscreen after test ran. Retry the test.\n""
                            + e.getMessage(),
                    Toast.LENGTH_LONG).show();
            return false;
        } catch (BadPaddingException | IllegalBlockSizeException | KeyStoreException |
                CertificateException | UnrecoverableKeyException | IOException
                | NoSuchPaddingException | NoSuchAlgorithmException | InvalidKeyException e) {
            throw new RuntimeException(e);
        }
    }

    private void showAuthenticationScreen() {
        // Create the Confirm Credentials screen. You can customize the title and description. Or
        // we will provide a generic one for you if you leave it null
        Intent intent = mKeyguardManager.createConfirmDeviceCredentialIntent(null, null);
        if (intent != null) {
            startActivityForResult(intent, CONFIRM_CREDENTIALS_REQUEST_CODE);
        }
    }

    private void showToast(String message) {
        Toast.makeText(this, message, Toast.LENGTH_LONG)
            .show();
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        switch (requestCode) {
            case CONFIRM_CREDENTIALS_REQUEST_CODE:
                if (resultCode == RESULT_OK) {
                    if (tryEncrypt()) {
                        showToast(""Test passed."");
                        getPassButton().setEnabled(true);
                    } else {
                        showToast(""Test failed. Key not accessible after auth"");
                    }
                }
        }
    }
}"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.widget.cts.GridViewTest"	"testPressKey"	"CtsWidgetTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/GridViewTest.java"	""	"public void testPressKey() throws Throwable {
        final int NUM_COLUMNS = 3;

        GridView.OnItemClickListener mockItemClickListener =
                mock(GridView.OnItemClickListener.class);
        mGridView.setOnItemClickListener(mockItemClickListener);

        // this test case can not be ran in UI thread.
        WidgetTestUtils.runOnMainAndLayoutSync(mActivityRule, mGridView, () -> {
            mGridView.setAdapter(new ImageAdapter(mActivity));
            mGridView.setNumColumns(NUM_COLUMNS);
            mGridView.requestLayout();
            mGridView.requestFocus();
        }, true);

        assertEquals(0, mGridView.getSelectedItemPosition());
        KeyEvent event = new KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_DPAD_RIGHT);
        mInstrumentation.sendKeySync(event);
        assertEquals(1, mGridView.getSelectedItemPosition());

        event = new KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_DPAD_LEFT);
        mInstrumentation.sendKeySync(event);
        assertEquals(0, mGridView.getSelectedItemPosition());

        assertEquals(0, mGridView.getSelectedItemPosition());
        mInstrumentation.sendKeyDownUpSync(KeyEvent.KEYCODE_DPAD_RIGHT);
        assertEquals(1, mGridView.getSelectedItemPosition());

        mInstrumentation.sendKeyDownUpSync(KeyEvent.KEYCODE_DPAD_LEFT);
        assertEquals(0, mGridView.getSelectedItemPosition());

        mInstrumentation.sendKeyDownUpSync(KeyEvent.KEYCODE_TAB);
        assertEquals(1, mGridView.getSelectedItemPosition());

        event = new KeyEvent(0, 0, KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_TAB, 0,
                KeyEvent.META_SHIFT_LEFT_ON);
        mInstrumentation.sendKeySync(event);
        event = new KeyEvent(0, 0, KeyEvent.ACTION_UP, KeyEvent.KEYCODE_TAB, 0,
                KeyEvent.META_SHIFT_LEFT_ON);
        mInstrumentation.sendKeySync(event);
        assertEquals(0, mGridView.getSelectedItemPosition());

        mInstrumentation.sendKeyDownUpSync(KeyEvent.KEYCODE_DPAD_DOWN);
        assertEquals(NUM_COLUMNS, mGridView.getSelectedItemPosition());

        verify(mockItemClickListener, never()).onItemClick(any(AdapterView.class), any(View.class),
                anyInt(), anyLong());
        mInstrumentation.sendKeyDownUpSync(KeyEvent.KEYCODE_DPAD_CENTER);
        verify(mockItemClickListener, times(1)).onItemClick(eq(mGridView), any(View.class),
                eq(NUM_COLUMNS), eq((long) NUM_COLUMNS));

        reset(mockItemClickListener);
        mInstrumentation.sendKeyDownUpSync(KeyEvent.KEYCODE_ENTER);
        verify(mockItemClickListener, times(1)).onItemClick(eq(mGridView), any(View.class),
                eq(NUM_COLUMNS), eq((long) NUM_COLUMNS));
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.widget.cts.GridViewTest"	"testFullyDetachUnusedViewOnScrollForFocus"	"CtsWidgetTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/GridViewTest.java"	""	"public void testFullyDetachUnusedViewOnScrollForFocus() throws Throwable {
        final AttachDetachAwareView theView = new AttachDetachAwareView(mActivity);
        WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, mGridView, () -> {
            mGridView.setAdapter(new DummyAdapter(1000, theView));
            mGridView.requestFocus();
        });
        assertEquals(""test sanity"", 1, theView.mOnAttachCount);
        assertEquals(""test sanity"", 0, theView.mOnDetachCount);
        while(theView.getParent() != null) {
            assertEquals(""the view should NOT be detached"", 0, theView.mOnDetachCount);
            CtsKeyEventUtil.sendKeys(mInstrumentation, mGridView, KeyEvent.KEYCODE_DPAD_DOWN);
            WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, mGridView, null);
        }
        assertEquals(""the view should be detached"", 1, theView.mOnDetachCount);
        assertFalse(theView.isTemporarilyDetached());
        while(theView.getParent() == null) {
            CtsKeyEventUtil.sendKeys(mInstrumentation, mGridView, KeyEvent.KEYCODE_DPAD_UP);
            WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, mGridView, null);
        }
        assertEquals(""the view should be re-attached"", 2, theView.mOnAttachCount);
        assertEquals(""the view should not receive another detach"", 1, theView.mOnDetachCount);
        assertFalse(theView.isTemporarilyDetached());
    }

    @LargeTest"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.hardware.camera2.cts.CaptureResultTest"	"testResultTimestamps"	"CtsCameraTestCases"	"/home/gpoor/cts-12-source/cts/tests/camera/src/android/hardware/camera2/cts/CaptureResultTest.java"	""	"public void testResultTimestamps() throws Exception {
        for (String id : mCameraIdsUnderTest) {
            ImageReader previewReader = null;
            ImageReader jpegReader = null;

            CaptureResult resultForNdk = null;

            SimpleImageReaderListener jpegListener = new SimpleImageReaderListener();
            SimpleImageReaderListener prevListener = new SimpleImageReaderListener();
            try {
                if (!mAllStaticInfo.get(id).isColorOutputSupported()) {
                    Log.i(TAG, ""Camera "" + id + "" does not support color outputs, skipping"");
                    continue;
                }

                openDevice(id);
                CaptureRequest.Builder previewBuilder =
                        mCamera.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);
                CaptureRequest.Builder multiBuilder =
                        mCamera.createCaptureRequest(CameraDevice.TEMPLATE_STILL_CAPTURE);

                // Create image reader and surface.
                Size previewSize = mOrderedPreviewSizes.get(0);
                Size jpegSize = mOrderedStillSizes.get(0);

                // Create ImageReaders.
                previewReader = makeImageReader(previewSize, ImageFormat.YUV_420_888,
                        MAX_NUM_IMAGES, prevListener, mHandler);
                jpegReader = makeImageReader(jpegSize, ImageFormat.JPEG,
                        MAX_NUM_IMAGES, jpegListener, mHandler);

                // Configure output streams with preview and jpeg streams.
                List<Surface> outputSurfaces = new ArrayList<>(Arrays.asList(
                        previewReader.getSurface(), jpegReader.getSurface()));

                SessionListener mockSessionListener = getMockSessionListener();

                CameraCaptureSession session = configureAndVerifySession(mockSessionListener,
                        mCamera, outputSurfaces, mHandler);

                // Configure the requests.
                previewBuilder.addTarget(previewReader.getSurface());
                multiBuilder.addTarget(previewReader.getSurface());
                multiBuilder.addTarget(jpegReader.getSurface());

                if (mStaticInfo.isEnableZslSupported()) {
                    // Turn off ZSL to ensure timestamps are increasing
                    previewBuilder.set(CaptureRequest.CONTROL_ENABLE_ZSL, false);
                    multiBuilder.set(CaptureRequest.CONTROL_ENABLE_ZSL, false);
                }

                CaptureCallback mockCaptureCallback = getMockCaptureListener();

                // Capture targeting only preview
                Pair<TotalCaptureResult, Long> result = captureAndVerifyResult(mockCaptureCallback,
                        session, previewBuilder.build(), mHandler);

                // Check if all timestamps are the same
                Image prevImage = prevListener.getImage(CAPTURE_IMAGE_TIMEOUT_MS);
                validateTimestamps(""Result 1"", result.first,
                        prevImage, result.second);
                prevImage.close();

                // Capture targeting both jpeg and preview
                Pair<TotalCaptureResult, Long> result2 = captureAndVerifyResult(mockCaptureCallback,
                        session, multiBuilder.build(), mHandler);

                // Check if all timestamps are the same
                prevImage = prevListener.getImage(CAPTURE_IMAGE_TIMEOUT_MS);
                Image jpegImage = jpegListener.getImage(CAPTURE_IMAGE_TIMEOUT_MS);
                validateTimestamps(""Result 2 Preview"", result2.first,
                        prevImage, result2.second);
                validateTimestamps(""Result 2 Jpeg"", result2.first,
                        jpegImage, result2.second);
                prevImage.close();
                jpegImage.close();

                // Check if timestamps are increasing
                mCollector.expectGreater(""Timestamps must be increasing."", result.second,
                        result2.second);

                // Capture two preview frames
                long startTime = SystemClock.elapsedRealtimeNanos();
                Pair<TotalCaptureResult, Long> result3 = captureAndVerifyResult(mockCaptureCallback,
                        session, previewBuilder.build(), mHandler);
                Pair<TotalCaptureResult, Long> result4 = captureAndVerifyResult(mockCaptureCallback,
                        session, previewBuilder.build(), mHandler);
                long clockDiff = SystemClock.elapsedRealtimeNanos() - startTime;
                long resultDiff = result4.second - result3.second;

                // Check if all timestamps are the same
                prevImage = prevListener.getImage(CAPTURE_IMAGE_TIMEOUT_MS);
                validateTimestamps(""Result 3"", result3.first,
                        prevImage, result3.second);
                prevImage.close();
                prevImage = prevListener.getImage(CAPTURE_IMAGE_TIMEOUT_MS);
                validateTimestamps(""Result 4"", result4.first,
                        prevImage, result4.second);
                prevImage.close();

                // Check that the timestamps monotonically increase at a reasonable rate
                mCollector.expectGreaterOrEqual(""Timestamps increase faster than system clock."",
                        resultDiff, clockDiff);
                mCollector.expectGreater(""Timestamps must be increasing."", result3.second,
                        result4.second);

                resultForNdk = result.first;
            } finally {
                closeDevice(id);
                closeImageReader(previewReader);
                closeImageReader(jpegReader);
            }

            mCollector.expectTrue(
                ""validateACameraMetadataFromCameraMetadataCriticalTagsNative failed"",
                validateACameraMetadataFromCameraMetadataCriticalTagsNative(resultForNdk,
                        resultForNdk.get(CaptureResult.SENSOR_TIMESTAMP)));

            long timestamp = resultForNdk.get(CaptureResult.SENSOR_TIMESTAMP);
            mCollector.expectTrue(
                ""stashACameraMetadataFromCameraMetadataNative failed"",
                stashACameraMetadataFromCameraMetadataNative(resultForNdk));

            // Try to drop the Java side object here
            resultForNdk = null;
            int[] block = null;
            final int count = 9;
            for (int i = 0; i < count + 1; i++) {
                block = new int[1000000];
                block[1000 + i] = i;

                Runtime.getRuntime().gc();
                Runtime.getRuntime().runFinalization();

                mCollector.expectTrue(""This should never fail"", block[1000 + i] == i);
            }
            mCollector.expectTrue(
                ""validateStashedACameraMetadataFromCameraMetadataNative failed"",
                validateStashedACameraMetadataFromCameraMetadataNative(timestamp));
            mCollector.expectTrue(""This should never fail"", block[1000 + count] == count);
        }
    }

    private void validateTimestamps(String msg, TotalCaptureResult result, Image resultImage,
                                    long captureTime) {
        mCollector.expectKeyValueEquals(result, CaptureResult.SENSOR_TIMESTAMP, captureTime);
        mCollector.expectEquals(msg + "": Capture timestamp must be same as resultImage timestamp"",
                resultImage.getTimestamp(), captureTime);
    }

    public static void validateCaptureResult(CameraErrorCollector errorCollector,
            SimpleCaptureCallback captureListener, StaticMetadata staticInfo,
            Map<String, StaticMetadata> allStaticInfo, List<String> requestedPhysicalIds,
            CaptureRequest.Builder requestBuilder, int numFramesVerified) throws Exception {
        // List that includes all public keys from CaptureResult
        List<CaptureResult.Key<?>> allKeys = getAllCaptureResultKeys();
        // Get the waived keys for current camera device
        List<CaptureResult.Key<?>> waiverKeys = getWaiverKeysForCamera(staticInfo);
        if (requestedPhysicalIds == null) {
            requestedPhysicalIds = new ArrayList<String>();
        }

        HashMap<String, List<CaptureResult.Key<?>>> physicalWaiverKeys = new HashMap<>();
        for (String physicalId : requestedPhysicalIds) {
            StaticMetadata physicalStaticInfo = allStaticInfo.get(physicalId);
            physicalWaiverKeys.put(physicalId, getWaiverKeysForCamera(physicalStaticInfo));
        }

        TotalCaptureResult result = null;
        // List of (frameNumber, physical camera Id) pairs
        ArrayList<Pair<Long, String>> droppedPhysicalResults = new ArrayList<>();
        for (int i = 0; i < numFramesVerified; i++) {
            result = captureListener.getTotalCaptureResult(WAIT_FOR_RESULT_TIMEOUT_MS);

            Map<String, CaptureResult> physicalCaptureResults = result.getPhysicalCameraResults();
            ArrayList<String> droppedIds = new ArrayList<String>(requestedPhysicalIds);
            droppedIds.removeAll(physicalCaptureResults.keySet());
            for (String droppedId : droppedIds) {
                droppedPhysicalResults.add(
                        new Pair<Long, String>(result.getFrameNumber(), droppedId));
            }

            validateOneCaptureResult(errorCollector, staticInfo, waiverKeys, allKeys,
                    requestBuilder, result, null/*cameraId*/, i);
            for (String physicalId : physicalCaptureResults.keySet()) {
                StaticMetadata physicalStaticInfo = allStaticInfo.get(physicalId);
                validateOneCaptureResult(errorCollector, physicalStaticInfo,
                        physicalWaiverKeys.get(physicalId),
                        allKeys, null/*requestBuilder*/, physicalCaptureResults.get(physicalId),
                        physicalId, i);
            }
        }

        // Verify that all dropped physical camera results are notified via capture failure.
        while (captureListener.hasMoreFailures()) {
            ArrayList<CaptureFailure> failures =
                    captureListener.getCaptureFailures(/*maxNumFailures*/ 1);
            for (CaptureFailure failure : failures) {
                String failedPhysicalId = failure.getPhysicalCameraId();
                Long failedFrameNumber = failure.getFrameNumber();
                if (failedPhysicalId != null) {
                    droppedPhysicalResults.removeIf(
                            n -> n.equals(
                            new Pair<Long, String>(failedFrameNumber, failedPhysicalId)));
                }
            }
        }
        errorCollector.expectTrue(""Not all dropped results for physical cameras are notified"",
                droppedPhysicalResults.isEmpty());
    }

    private static void validateOneCaptureResult(CameraErrorCollector errorCollector,
            StaticMetadata staticInfo, List<CaptureResult.Key<?>> skippedKeys,
            List<CaptureResult.Key<?>> allKeys,
            CaptureRequest.Builder requestBuilder, CaptureResult result, String cameraId,
            int resultCount) throws Exception {
        String failMsg = ""Failed capture result "" + resultCount + "" test"";
        String cameraIdString = "" "";
        if (cameraId != null) {
            cameraIdString += ""for physical camera "" + cameraId;
        }
        boolean verifyMatchRequest = (requestBuilder != null);
        for (CaptureResult.Key<?> key : allKeys) {
            if (!skippedKeys.contains(key)) {
                /**
                 * Check the critical tags here.
                 * TODO: Can use the same key for request and result when request/result
                 * becomes symmetric (b/14059883). Then below check can be wrapped into
                 * a generic function.
                 */
                String msg = failMsg + cameraIdString + ""for key "" + key.getName();
                if (verifyMatchRequest) {
                    if (key.equals(CaptureResult.CONTROL_AE_MODE)) {
                        errorCollector.expectEquals(msg,
                                requestBuilder.get(CaptureRequest.CONTROL_AE_MODE),
                                result.get(CaptureResult.CONTROL_AE_MODE));
                    } else if (key.equals(CaptureResult.CONTROL_AF_MODE)) {
                        errorCollector.expectEquals(msg,
                                requestBuilder.get(CaptureRequest.CONTROL_AF_MODE),
                                result.get(CaptureResult.CONTROL_AF_MODE));
                    } else if (key.equals(CaptureResult.CONTROL_AWB_MODE)) {
                        errorCollector.expectEquals(msg,
                                requestBuilder.get(CaptureRequest.CONTROL_AWB_MODE),
                                result.get(CaptureResult.CONTROL_AWB_MODE));
                    } else if (key.equals(CaptureResult.CONTROL_MODE)) {
                        errorCollector.expectEquals(msg,
                                requestBuilder.get(CaptureRequest.CONTROL_MODE),
                                result.get(CaptureResult.CONTROL_MODE));
                    } else if (key.equals(CaptureResult.STATISTICS_FACE_DETECT_MODE)) {
                        errorCollector.expectEquals(msg,
                                requestBuilder.get(CaptureRequest.STATISTICS_FACE_DETECT_MODE),
                                result.get(CaptureResult.STATISTICS_FACE_DETECT_MODE));
                    } else if (key.equals(CaptureResult.NOISE_REDUCTION_MODE)) {
                        errorCollector.expectEquals(msg,
                                requestBuilder.get(CaptureRequest.NOISE_REDUCTION_MODE),
                                result.get(CaptureResult.NOISE_REDUCTION_MODE));
                    } else if (key.equals(CaptureResult.NOISE_REDUCTION_MODE)) {
                        errorCollector.expectEquals(msg,
                                requestBuilder.get(CaptureRequest.NOISE_REDUCTION_MODE),
                                result.get(CaptureResult.NOISE_REDUCTION_MODE));
                    } else if (key.equals(CaptureResult.REQUEST_PIPELINE_DEPTH)) {

                    } else if (key.equals(CaptureResult.STATISTICS_OIS_DATA_MODE)) {
                        errorCollector.expectEquals(msg,
                                requestBuilder.get(CaptureRequest.STATISTICS_OIS_DATA_MODE),
                                result.get(CaptureResult.STATISTICS_OIS_DATA_MODE));
                    } else if (key.equals(CaptureResult.DISTORTION_CORRECTION_MODE)) {
                        errorCollector.expectEquals(msg,
                                requestBuilder.get(CaptureRequest.DISTORTION_CORRECTION_MODE),
                                result.get(CaptureResult.DISTORTION_CORRECTION_MODE));
                    } else if (key.equals(CaptureResult.SENSOR_DYNAMIC_BLACK_LEVEL)) {
                        float[] blackLevel = errorCollector.expectKeyValueNotNull(
                                result, CaptureResult.SENSOR_DYNAMIC_BLACK_LEVEL);
                        if (blackLevel != null && staticInfo.isMonochromeCamera()) {
                            errorCollector.expectEquals(
                                    ""Monochrome camera dynamic blacklevel must be 2x2"",
                                    blackLevel.length, 4);
                            for (int index = 1; index < blackLevel.length; index++) {
                                errorCollector.expectEquals(
                                    ""Monochrome camera 2x2 channels blacklevel value must be the same."",
                                    blackLevel[index], blackLevel[0]);
                            }
                        }
                    } else {
                        // Only do non-null check for the rest of keys.
                        errorCollector.expectKeyValueNotNull(failMsg, result, key);
                    }
                } else {
                    // Only do non-null check for the rest of keys.
                    errorCollector.expectKeyValueNotNull(failMsg, result, key);
                }
            } else {
                // These keys should always be null
                if (key.equals(CaptureResult.CONTROL_AE_REGIONS)) {
                    errorCollector.expectNull(
                            ""Capture result contains AE regions but aeMaxRegions is 0""
                            + cameraIdString,
                            result.get(CaptureResult.CONTROL_AE_REGIONS));
                } else if (key.equals(CaptureResult.CONTROL_AWB_REGIONS)) {
                    errorCollector.expectNull(
                            ""Capture result contains AWB regions but awbMaxRegions is 0""
                            + cameraIdString,
                            result.get(CaptureResult.CONTROL_AWB_REGIONS));
                } else if (key.equals(CaptureResult.CONTROL_AF_REGIONS)) {
                    errorCollector.expectNull(
                            ""Capture result contains AF regions but afMaxRegions is 0""
                            + cameraIdString,
                            result.get(CaptureResult.CONTROL_AF_REGIONS));
                }
            }
        }
    }

    /*
     * Add waiver keys per camera device hardware level and capability.
     *
     * Must be called after camera device is opened.
     */
    private static List<CaptureResult.Key<?>> getWaiverKeysForCamera(StaticMetadata staticInfo) {
        List<CaptureResult.Key<?>> waiverKeys = new ArrayList<>();

        // Global waiver keys
        waiverKeys.add(CaptureResult.JPEG_GPS_LOCATION);
        waiverKeys.add(CaptureResult.JPEG_ORIENTATION);
        waiverKeys.add(CaptureResult.JPEG_QUALITY);
        waiverKeys.add(CaptureResult.JPEG_THUMBNAIL_QUALITY);
        waiverKeys.add(CaptureResult.JPEG_THUMBNAIL_SIZE);

        if (!staticInfo.isUltraHighResolutionSensor()) {
            waiverKeys.add(CaptureResult.SENSOR_PIXEL_MODE);
            waiverKeys.add(CaptureResult.SENSOR_RAW_BINNING_FACTOR_USED);
        }

        // Keys only present when corresponding control is on are being
        // verified in its own functional test
        // Only present in certain tonemap mode. Test in CaptureRequestTest.
        waiverKeys.add(CaptureResult.TONEMAP_CURVE);
        waiverKeys.add(CaptureResult.TONEMAP_GAMMA);
        waiverKeys.add(CaptureResult.TONEMAP_PRESET_CURVE);
        // Only present when test pattern mode is SOLID_COLOR.
        // TODO: verify this key in test pattern test later
        waiverKeys.add(CaptureResult.SENSOR_TEST_PATTERN_DATA);
        // Only present when STATISTICS_LENS_SHADING_MAP_MODE is ON
        waiverKeys.add(CaptureResult.STATISTICS_LENS_SHADING_CORRECTION_MAP);
        // Only present when STATISTICS_INFO_AVAILABLE_HOT_PIXEL_MAP_MODES is ON
        waiverKeys.add(CaptureResult.STATISTICS_HOT_PIXEL_MAP);
        // Only present when face detection is on
        waiverKeys.add(CaptureResult.STATISTICS_FACES);
        // Only present in reprocessing capture result.
        waiverKeys.add(CaptureResult.REPROCESS_EFFECTIVE_EXPOSURE_FACTOR);

        // LOGICAL_MULTI_CAMERA_ACTIVE_PHYSICAL_ID not required if key is not supported.
        if (!staticInfo.isLogicalMultiCamera() ||
                !staticInfo.isActivePhysicalCameraIdSupported()) {
            waiverKeys.add(CaptureResult.LOGICAL_MULTI_CAMERA_ACTIVE_PHYSICAL_ID);
        }

        //Keys not required if RAW is not supported
        if (!staticInfo.isCapabilitySupported(
                CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_RAW)) {
            waiverKeys.add(CaptureResult.SENSOR_NEUTRAL_COLOR_POINT);
            waiverKeys.add(CaptureResult.SENSOR_GREEN_SPLIT);
            waiverKeys.add(CaptureResult.SENSOR_NOISE_PROFILE);
        } else if (staticInfo.isMonochromeCamera()) {
            waiverKeys.add(CaptureResult.SENSOR_NEUTRAL_COLOR_POINT);
            waiverKeys.add(CaptureResult.SENSOR_GREEN_SPLIT);
        }

        boolean calibrationReported = staticInfo.areKeysAvailable(
                CameraCharacteristics.LENS_POSE_ROTATION,
                CameraCharacteristics.LENS_POSE_TRANSLATION,
                CameraCharacteristics.LENS_INTRINSIC_CALIBRATION);

        // If any of distortion coefficients is reported in CameraCharacteristics, HAL must
        // also report (one of) them in CaptureResult
        boolean distortionReported = 
                staticInfo.areKeysAvailable(
                        CameraCharacteristics.LENS_RADIAL_DISTORTION) || 
                staticInfo.areKeysAvailable(
                        CameraCharacteristics.LENS_DISTORTION);

        //Keys for lens distortion correction
        boolean distortionCorrectionSupported = staticInfo.isDistortionCorrectionSupported();
        if (!distortionCorrectionSupported) {
            waiverKeys.add(CaptureResult.DISTORTION_CORRECTION_MODE);
        }

        boolean mustReportDistortion = true;
        // These keys must present on either DEPTH or distortion correction devices
        if (!staticInfo.isCapabilitySupported(
                CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_DEPTH_OUTPUT) &&
                !distortionCorrectionSupported &&
                !distortionReported) {
            mustReportDistortion = false;
            waiverKeys.add(CaptureResult.LENS_RADIAL_DISTORTION);
            waiverKeys.add(CaptureResult.LENS_DISTORTION);
        } else {
            // Radial distortion doesn't need to be present for new devices, or old devices that
            // opt in the new lens distortion tag.
            CameraCharacteristics c = staticInfo.getCharacteristics();
            if (Build.VERSION.DEVICE_INITIAL_SDK_INT > Build.VERSION_CODES.O_MR1 ||
                    c.get(CameraCharacteristics.LENS_DISTORTION) != null) {
                waiverKeys.add(CaptureResult.LENS_RADIAL_DISTORTION);
            }
        }

        // Calibration keys must exist for
        //   - DEPTH capable devices
        //   - Devices that reports calibration keys in static metadata
        //   - Devices that reports lens distortion keys in static metadata
        if (!staticInfo.isCapabilitySupported(
                CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_DEPTH_OUTPUT) &&
                !calibrationReported && !mustReportDistortion) {
            waiverKeys.add(CaptureResult.LENS_POSE_ROTATION);
            waiverKeys.add(CaptureResult.LENS_POSE_TRANSLATION);
            waiverKeys.add(CaptureResult.LENS_INTRINSIC_CALIBRATION);
        }

        // Waived if RAW output is not supported
        int[] outputFormats = staticInfo.getAvailableFormats(
                StaticMetadata.StreamDirection.Output);
        boolean supportRaw = false;
        for (int format : outputFormats) {
            if (format == ImageFormat.RAW_SENSOR || format == ImageFormat.RAW10 ||
                    format == ImageFormat.RAW12 || format == ImageFormat.RAW_PRIVATE) {
                supportRaw = true;
                break;
            }
        }
        if (!supportRaw) {
            waiverKeys.add(CaptureResult.CONTROL_POST_RAW_SENSITIVITY_BOOST);
        }

        // Waived if MONOCHROME capability
        if (staticInfo.isMonochromeCamera()) {
            waiverKeys.add(CaptureResult.COLOR_CORRECTION_MODE);
            waiverKeys.add(CaptureResult.COLOR_CORRECTION_TRANSFORM);
            waiverKeys.add(CaptureResult.COLOR_CORRECTION_GAINS);
        }

        if (staticInfo.getAeMaxRegionsChecked() == 0) {
            waiverKeys.add(CaptureResult.CONTROL_AE_REGIONS);
        }
        if (staticInfo.getAwbMaxRegionsChecked() == 0) {
            waiverKeys.add(CaptureResult.CONTROL_AWB_REGIONS);
        }
        if (staticInfo.getAfMaxRegionsChecked() == 0) {
            waiverKeys.add(CaptureResult.CONTROL_AF_REGIONS);
        }

        // Keys for dynamic black/white levels
        if (!staticInfo.isOpticalBlackRegionSupported()) {
            waiverKeys.add(CaptureResult.SENSOR_DYNAMIC_BLACK_LEVEL);
            waiverKeys.add(CaptureResult.SENSOR_DYNAMIC_WHITE_LEVEL);
        }

        if (!staticInfo.isEnableZslSupported()) {
            waiverKeys.add(CaptureResult.CONTROL_ENABLE_ZSL);
        }

        if (!staticInfo.isAfSceneChangeSupported()) {
            waiverKeys.add(CaptureResult.CONTROL_AF_SCENE_CHANGE);
        }

        if (!staticInfo.isOisDataModeSupported()) {
            waiverKeys.add(CaptureResult.STATISTICS_OIS_DATA_MODE);
            waiverKeys.add(CaptureResult.STATISTICS_OIS_SAMPLES);
        }

        if (staticInfo.getAvailableExtendedSceneModeCapsChecked().length == 0) {
            waiverKeys.add(CaptureResult.CONTROL_EXTENDED_SCENE_MODE);
        }

        if (!staticInfo.isRotateAndCropSupported()) {
            waiverKeys.add(CaptureResult.SCALER_ROTATE_AND_CROP);
        }

        if (staticInfo.isHardwareLevelAtLeastFull()) {
            return waiverKeys;
        }

        /*
         * Hardware Level = LIMITED or LEGACY
         */
        // Key not present if certain control is not supported
        if (!staticInfo.isColorCorrectionSupported()) {
            waiverKeys.add(CaptureResult.COLOR_CORRECTION_GAINS);
            waiverKeys.add(CaptureResult.COLOR_CORRECTION_MODE);
            waiverKeys.add(CaptureResult.COLOR_CORRECTION_TRANSFORM);
        }

        if (!staticInfo.isManualColorAberrationControlSupported()) {
            waiverKeys.add(CaptureResult.COLOR_CORRECTION_ABERRATION_MODE);
        }

        if (!staticInfo.isManualToneMapSupported()) {
            waiverKeys.add(CaptureResult.TONEMAP_MODE);
        }

        if (!staticInfo.isEdgeModeControlSupported()) {
            waiverKeys.add(CaptureResult.EDGE_MODE);
        }

        if (!staticInfo.isHotPixelMapModeControlSupported()) {
            waiverKeys.add(CaptureResult.HOT_PIXEL_MODE);
        }

        if (!staticInfo.isNoiseReductionModeControlSupported()) {
            waiverKeys.add(CaptureResult.NOISE_REDUCTION_MODE);
        }

        if (!staticInfo.isManualLensShadingMapSupported()) {
            waiverKeys.add(CaptureResult.SHADING_MODE);
        }

        //Keys not required if neither MANUAL_SENSOR nor READ_SENSOR_SETTINGS is supported
        if (!staticInfo.isCapabilitySupported(
                CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_MANUAL_SENSOR) &&
            !staticInfo.isCapabilitySupported(
                CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_READ_SENSOR_SETTINGS)) {
            waiverKeys.add(CaptureResult.SENSOR_EXPOSURE_TIME);
            waiverKeys.add(CaptureResult.SENSOR_SENSITIVITY);
            waiverKeys.add(CaptureResult.LENS_FOCUS_DISTANCE);
            waiverKeys.add(CaptureResult.LENS_APERTURE);
        }

        if (!staticInfo.isCapabilitySupported(
                CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_MANUAL_SENSOR)) {
            waiverKeys.add(CaptureResult.SENSOR_FRAME_DURATION);
            waiverKeys.add(CaptureResult.BLACK_LEVEL_LOCK);
            waiverKeys.add(CaptureResult.LENS_FOCUS_RANGE);
            waiverKeys.add(CaptureResult.LENS_STATE);
            waiverKeys.add(CaptureResult.LENS_FILTER_DENSITY);
        }

        if (staticInfo.isHardwareLevelLimited() && staticInfo.isColorOutputSupported()) {
            return waiverKeys;
        }

        /*
         * Hardware Level = EXTERNAL
         */
        if (staticInfo.isExternalCamera()) {
            waiverKeys.add(CaptureResult.LENS_FOCAL_LENGTH);
            waiverKeys.add(CaptureResult.SENSOR_TEST_PATTERN_MODE);
            waiverKeys.add(CaptureResult.SENSOR_ROLLING_SHUTTER_SKEW);
        }

        if (staticInfo.isExternalCamera() && staticInfo.isColorOutputSupported()) {
            return waiverKeys;
        }

        /*
         * Hardware Level = LEGACY or no regular output is supported
         */
        waiverKeys.add(CaptureResult.CONTROL_AE_PRECAPTURE_TRIGGER);
        waiverKeys.add(CaptureResult.CONTROL_AE_STATE);
        waiverKeys.add(CaptureResult.CONTROL_AWB_STATE);
        waiverKeys.add(CaptureResult.FLASH_STATE);
        waiverKeys.add(CaptureResult.LENS_OPTICAL_STABILIZATION_MODE);
        waiverKeys.add(CaptureResult.SENSOR_ROLLING_SHUTTER_SKEW);
        waiverKeys.add(CaptureResult.STATISTICS_LENS_SHADING_MAP_MODE);
        waiverKeys.add(CaptureResult.STATISTICS_SCENE_FLICKER);
        waiverKeys.add(CaptureResult.STATISTICS_HOT_PIXEL_MAP_MODE);
        waiverKeys.add(CaptureResult.CONTROL_AE_TARGET_FPS_RANGE);
        waiverKeys.add(CaptureResult.CONTROL_AF_TRIGGER);

        if (staticInfo.isHardwareLevelLegacy()) {
            return waiverKeys;
        }

        /*
         * Regular output not supported, only depth, waive color-output-related keys
         */
        waiverKeys.add(CaptureResult.CONTROL_SCENE_MODE);
        waiverKeys.add(CaptureResult.CONTROL_EFFECT_MODE);
        waiverKeys.add(CaptureResult.CONTROL_VIDEO_STABILIZATION_MODE);
        waiverKeys.add(CaptureResult.SENSOR_TEST_PATTERN_MODE);
        waiverKeys.add(CaptureResult.NOISE_REDUCTION_MODE);
        waiverKeys.add(CaptureResult.COLOR_CORRECTION_ABERRATION_MODE);
        waiverKeys.add(CaptureResult.CONTROL_AE_ANTIBANDING_MODE);
        waiverKeys.add(CaptureResult.CONTROL_AE_EXPOSURE_COMPENSATION);
        waiverKeys.add(CaptureResult.CONTROL_AE_LOCK);
        waiverKeys.add(CaptureResult.CONTROL_AE_MODE);
        waiverKeys.add(CaptureResult.CONTROL_AF_MODE);
        waiverKeys.add(CaptureResult.CONTROL_AWB_MODE);
        waiverKeys.add(CaptureResult.CONTROL_AWB_LOCK);
        waiverKeys.add(CaptureResult.CONTROL_ZOOM_RATIO);
        waiverKeys.add(CaptureResult.STATISTICS_FACE_DETECT_MODE);
        waiverKeys.add(CaptureResult.FLASH_MODE);
        waiverKeys.add(CaptureResult.SCALER_CROP_REGION);
        waiverKeys.add(CaptureResult.SCALER_ROTATE_AND_CROP);

        return waiverKeys;
    }

    /**
     * A capture listener implementation for collecting both partial and total results.
     *
     * <p> This is not a full-blown class and has some implicit assumptions. The class groups
     * capture results by capture request, so the user must guarantee each request this listener
     * is listening is unique. This class is not thread safe, so don't attach an instance object
     * with multiple handlers.</p>
     * */
    private static class TotalAndPartialResultListener
            extends CameraCaptureSession.CaptureCallback {
        static final int ERROR_DUPLICATED_REQUEST = 1 << 0;
        static final int ERROR_WRONG_CALLBACK_ORDER = 1 << 1;

        private final LinkedBlockingQueue<Pair<TotalCaptureResult, List<CaptureResult>> > mQueue =
                new LinkedBlockingQueue<>();
        private final HashMap<CaptureRequest, List<CaptureResult>> mPartialResultsMap =
                new HashMap<CaptureRequest, List<CaptureResult>>();
        private final HashSet<CaptureRequest> completedRequests = new HashSet<>();
        private int errorCode = 0;

        @Override
        public void onCaptureStarted(
            CameraCaptureSession session, CaptureRequest request, long timestamp, long frameNumber)
        {
            checkCallbackOrder(request);
            createMapEntryIfNecessary(request);
        }

        @Override
        public void onCaptureCompleted(CameraCaptureSession session, CaptureRequest request,
                TotalCaptureResult result) {
            try {
                List<CaptureResult> partialResultsList = mPartialResultsMap.get(request);
                if (partialResultsList == null) {
                    Log.w(TAG, ""onCaptureCompleted: unknown request"");
                }
                mQueue.put(new Pair<TotalCaptureResult, List<CaptureResult>>(
                        result, partialResultsList));
                mPartialResultsMap.remove(request);
                boolean newEntryAdded = completedRequests.add(request);
                if (!newEntryAdded) {
                    Integer frame = (Integer) request.getTag();
                    Log.e(TAG, ""Frame "" + frame + ""ERROR_DUPLICATED_REQUEST"");
                    errorCode |= ERROR_DUPLICATED_REQUEST;
                }
            } catch (InterruptedException e) {
                throw new UnsupportedOperationException(
                        ""Can't handle InterruptedException in onCaptureCompleted"");
            }
        }

        @Override
        public void onCaptureProgressed(CameraCaptureSession session, CaptureRequest request,
                CaptureResult partialResult) {
            createMapEntryIfNecessary(request);
            List<CaptureResult> partialResultsList = mPartialResultsMap.get(request);
            partialResultsList.add(partialResult);
        }

        private void createMapEntryIfNecessary(CaptureRequest request) {
            if (!mPartialResultsMap.containsKey(request)) {
                // create a new entry in the map
                mPartialResultsMap.put(request, new ArrayList<CaptureResult>());
            }
        }

        private void checkCallbackOrder(CaptureRequest request) {
            if (completedRequests.contains(request)) {
                Integer frame = (Integer) request.getTag();
                Log.e(TAG, ""Frame "" + frame + ""ERROR_WRONG_CALLBACK_ORDER"");
                errorCode |= ERROR_WRONG_CALLBACK_ORDER;
            }
        }

        public Pair<TotalCaptureResult, List<CaptureResult>> getCaptureResultPairs(long timeout) {
            try {
                Pair<TotalCaptureResult, List<CaptureResult>> result =
                        mQueue.poll(timeout, TimeUnit.MILLISECONDS);
                assertNotNull(""Wait for a capture result timed out in "" + timeout + ""ms"", result);
                return result;
            } catch (InterruptedException e) {
                throw new UnsupportedOperationException(""Unhandled interrupted exception"", e);
            }
        }

        public int getErrorCode() {
            return errorCode;
        }
    }

    // Returns true if `result` has timestamp `sensorTimestamp` when queried from the NDK via
    // ACameraMetadata_fromCameraMetadata().
    private static native boolean validateACameraMetadataFromCameraMetadataCriticalTagsNative(
        CaptureResult result, long sensorTimestamp);

    // First stash a native ACameraMetadata created from a capture result, then compare the stored value
    // to the passed-in timestamp.
    private static native boolean stashACameraMetadataFromCameraMetadataNative(CaptureResult result);
    private static native boolean validateStashedACameraMetadataFromCameraMetadataNative(long timestamp);

    /**
     * TODO: Use CameraCharacteristics.getAvailableCaptureResultKeys() once we can filter out
     * @hide keys.
     *
     */

    /*@O~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~
     * The key entries below this point are generated from metadata
     * definitions in /system/media/camera/docs. Do not modify by hand or
     * modify the comment blocks at the start or end.
     *~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~*/

    private static List<CaptureResult.Key<?>> getAllCaptureResultKeys() {
        ArrayList<CaptureResult.Key<?>> resultKeys = new ArrayList<CaptureResult.Key<?>>();
        resultKeys.add(CaptureResult.COLOR_CORRECTION_MODE);
        resultKeys.add(CaptureResult.COLOR_CORRECTION_TRANSFORM);
        resultKeys.add(CaptureResult.COLOR_CORRECTION_GAINS);
        resultKeys.add(CaptureResult.COLOR_CORRECTION_ABERRATION_MODE);
        resultKeys.add(CaptureResult.CONTROL_AE_ANTIBANDING_MODE);
        resultKeys.add(CaptureResult.CONTROL_AE_EXPOSURE_COMPENSATION);
        resultKeys.add(CaptureResult.CONTROL_AE_LOCK);
        resultKeys.add(CaptureResult.CONTROL_AE_MODE);
        resultKeys.add(CaptureResult.CONTROL_AE_REGIONS);
        resultKeys.add(CaptureResult.CONTROL_AE_TARGET_FPS_RANGE);
        resultKeys.add(CaptureResult.CONTROL_AE_PRECAPTURE_TRIGGER);
        resultKeys.add(CaptureResult.CONTROL_AF_MODE);
        resultKeys.add(CaptureResult.CONTROL_AF_REGIONS);
        resultKeys.add(CaptureResult.CONTROL_AF_TRIGGER);
        resultKeys.add(CaptureResult.CONTROL_AWB_LOCK);
        resultKeys.add(CaptureResult.CONTROL_AWB_MODE);
        resultKeys.add(CaptureResult.CONTROL_AWB_REGIONS);
        resultKeys.add(CaptureResult.CONTROL_CAPTURE_INTENT);
        resultKeys.add(CaptureResult.CONTROL_EFFECT_MODE);
        resultKeys.add(CaptureResult.CONTROL_MODE);
        resultKeys.add(CaptureResult.CONTROL_SCENE_MODE);
        resultKeys.add(CaptureResult.CONTROL_VIDEO_STABILIZATION_MODE);
        resultKeys.add(CaptureResult.CONTROL_AE_STATE);
        resultKeys.add(CaptureResult.CONTROL_AF_STATE);
        resultKeys.add(CaptureResult.CONTROL_AWB_STATE);
        resultKeys.add(CaptureResult.CONTROL_POST_RAW_SENSITIVITY_BOOST);
        resultKeys.add(CaptureResult.CONTROL_ENABLE_ZSL);
        resultKeys.add(CaptureResult.CONTROL_AF_SCENE_CHANGE);
        resultKeys.add(CaptureResult.CONTROL_EXTENDED_SCENE_MODE);
        resultKeys.add(CaptureResult.CONTROL_ZOOM_RATIO);
        resultKeys.add(CaptureResult.EDGE_MODE);
        resultKeys.add(CaptureResult.FLASH_MODE);
        resultKeys.add(CaptureResult.FLASH_STATE);
        resultKeys.add(CaptureResult.HOT_PIXEL_MODE);
        resultKeys.add(CaptureResult.JPEG_GPS_LOCATION);
        resultKeys.add(CaptureResult.JPEG_ORIENTATION);
        resultKeys.add(CaptureResult.JPEG_QUALITY);
        resultKeys.add(CaptureResult.JPEG_THUMBNAIL_QUALITY);
        resultKeys.add(CaptureResult.JPEG_THUMBNAIL_SIZE);
        resultKeys.add(CaptureResult.LENS_APERTURE);
        resultKeys.add(CaptureResult.LENS_FILTER_DENSITY);
        resultKeys.add(CaptureResult.LENS_FOCAL_LENGTH);
        resultKeys.add(CaptureResult.LENS_FOCUS_DISTANCE);
        resultKeys.add(CaptureResult.LENS_OPTICAL_STABILIZATION_MODE);
        resultKeys.add(CaptureResult.LENS_POSE_ROTATION);
        resultKeys.add(CaptureResult.LENS_POSE_TRANSLATION);
        resultKeys.add(CaptureResult.LENS_FOCUS_RANGE);
        resultKeys.add(CaptureResult.LENS_STATE);
        resultKeys.add(CaptureResult.LENS_INTRINSIC_CALIBRATION);
        resultKeys.add(CaptureResult.LENS_RADIAL_DISTORTION);
        resultKeys.add(CaptureResult.LENS_DISTORTION);
        resultKeys.add(CaptureResult.NOISE_REDUCTION_MODE);
        resultKeys.add(CaptureResult.REQUEST_PIPELINE_DEPTH);
        resultKeys.add(CaptureResult.SCALER_CROP_REGION);
        resultKeys.add(CaptureResult.SCALER_ROTATE_AND_CROP);
        resultKeys.add(CaptureResult.SENSOR_EXPOSURE_TIME);
        resultKeys.add(CaptureResult.SENSOR_FRAME_DURATION);
        resultKeys.add(CaptureResult.SENSOR_SENSITIVITY);
        resultKeys.add(CaptureResult.SENSOR_TIMESTAMP);
        resultKeys.add(CaptureResult.SENSOR_NEUTRAL_COLOR_POINT);
        resultKeys.add(CaptureResult.SENSOR_NOISE_PROFILE);
        resultKeys.add(CaptureResult.SENSOR_GREEN_SPLIT);
        resultKeys.add(CaptureResult.SENSOR_TEST_PATTERN_DATA);
        resultKeys.add(CaptureResult.SENSOR_TEST_PATTERN_MODE);
        resultKeys.add(CaptureResult.SENSOR_ROLLING_SHUTTER_SKEW);
        resultKeys.add(CaptureResult.SENSOR_DYNAMIC_BLACK_LEVEL);
        resultKeys.add(CaptureResult.SENSOR_DYNAMIC_WHITE_LEVEL);
        resultKeys.add(CaptureResult.SENSOR_PIXEL_MODE);
        resultKeys.add(CaptureResult.SENSOR_RAW_BINNING_FACTOR_USED);
        resultKeys.add(CaptureResult.SHADING_MODE);
        resultKeys.add(CaptureResult.STATISTICS_FACE_DETECT_MODE);
        resultKeys.add(CaptureResult.STATISTICS_HOT_PIXEL_MAP_MODE);
        resultKeys.add(CaptureResult.STATISTICS_FACES);
        resultKeys.add(CaptureResult.STATISTICS_LENS_SHADING_CORRECTION_MAP);
        resultKeys.add(CaptureResult.STATISTICS_SCENE_FLICKER);
        resultKeys.add(CaptureResult.STATISTICS_HOT_PIXEL_MAP);
        resultKeys.add(CaptureResult.STATISTICS_LENS_SHADING_MAP_MODE);
        resultKeys.add(CaptureResult.STATISTICS_OIS_DATA_MODE);
        resultKeys.add(CaptureResult.STATISTICS_OIS_SAMPLES);
        resultKeys.add(CaptureResult.TONEMAP_CURVE);
        resultKeys.add(CaptureResult.TONEMAP_MODE);
        resultKeys.add(CaptureResult.TONEMAP_GAMMA);
        resultKeys.add(CaptureResult.TONEMAP_PRESET_CURVE);
        resultKeys.add(CaptureResult.BLACK_LEVEL_LOCK);
        resultKeys.add(CaptureResult.REPROCESS_EFFECTIVE_EXPOSURE_FACTOR);
        resultKeys.add(CaptureResult.LOGICAL_MULTI_CAMERA_ACTIVE_PHYSICAL_ID);
        resultKeys.add(CaptureResult.DISTORTION_CORRECTION_MODE);

        return resultKeys;
    }

    /*~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~
     * End generated code
     *~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~O@*/
}"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.view.cts.KeyEventInterceptTest"	"testKeyCodeBackShortcutRightMeta"	"CtsViewTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/view/src/android/view/cts/KeyEventInterceptTest.java"	""	"public void testKeyCodeBackShortcutRightMeta() {
        testKeyCodeBackShortcut(KeyEvent.META_META_RIGHT_ON | KeyEvent.META_META_ON);
    }

    private void testKeyCodeHomeShortcut(int metaState) {
        final long downTime = SystemClock.uptimeMillis();
        injectEvent(new KeyEvent(downTime, downTime, KeyEvent.ACTION_DOWN,
                KeyEvent.KEYCODE_ENTER, 0, metaState));
        injectEvent(new KeyEvent(downTime, SystemClock.uptimeMillis(), KeyEvent.ACTION_UP,
                KeyEvent.KEYCODE_ENTER, 0, metaState));

        assertKeyNotReceived();
    }

    private void testKeyCodeBackShortcut(int metaState) {
        long downTime = SystemClock.uptimeMillis();
        injectEvent(new KeyEvent(downTime, downTime, KeyEvent.ACTION_DOWN,
                KeyEvent.KEYCODE_DEL, 0, metaState));
        injectEvent(new KeyEvent(downTime, downTime + 1, KeyEvent.ACTION_UP,
                KeyEvent.KEYCODE_DEL, 0, metaState));

        assertKeyReceived(KeyEvent.KEYCODE_BACK, KeyEvent.ACTION_DOWN);
        assertKeyReceived(KeyEvent.KEYCODE_BACK, KeyEvent.ACTION_UP);
        assertKeyNotReceived();
    }

    private void testKey(int keyCode) {
        sendKey(keyCode);
        assertKeyNotReceived();
    }

    private void sendKey(int keyCodeToSend) {
        long downTime = SystemClock.uptimeMillis();
        injectEvent(new KeyEvent(downTime, downTime, KeyEvent.ACTION_DOWN,
                keyCodeToSend, 0, 0));
        injectEvent(new KeyEvent(downTime, downTime + 1, KeyEvent.ACTION_UP,
                keyCodeToSend, 0, 0));
    }

    private void injectEvent(KeyEvent event) {
        final UiAutomation automation = mInstrumentation.getUiAutomation();
        automation.injectInputEvent(event, true);
    }

    private void assertKeyNotReceived() {
        KeyEvent keyEvent = mActivity.mKeyEvents.poll();
        if (keyEvent == null) {
            return;
        }
        fail(""Should not have received "" + KeyEvent.keyCodeToString(keyEvent.getKeyCode()));
    }

    private void assertKeyReceived(int keyCode, int action) {
        KeyEvent keyEvent = mActivity.mKeyEvents.poll();
        if (keyEvent == null) {
            fail(""Did not receive "" + KeyEvent.keyCodeToString(keyCode) + "", queue is empty"");
        }
        assertEquals(keyCode, keyEvent.getKeyCode());
        assertEquals(action, keyEvent.getAction());
    }
}"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.mediadrm.cts.MediaDrmClearkeyTest"	"MediaDrmClearkeyTest"	"CtsMediaDrmTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/mediadrm/src/android/mediadrm/cts/MediaDrmClearkeyTest.java"	""	"public void test/*
 *.
 */
package android.mediadrm.cts;

import android.media.MediaCodecInfo.CodecCapabilities;
import android.media.MediaDrm;
import android.media.MediaDrm.KeyStatus;
import android.media.MediaDrm.MediaDrmStateException;
import android.media.MediaDrmException;
import android.media.MediaFormat;
import android.media.NotProvisionedException;
import android.media.ResourceBusyException;
import android.media.UnsupportedSchemeException;
import android.media.cts.AudioManagerStub;
import android.media.cts.AudioManagerStubHelper;
import android.media.cts.CodecState;
import android.media.cts.ConnectionStatus;
import android.media.cts.IConnectionStatus;
import android.media.cts.InputSurface;
import android.media.cts.InputSurfaceInterface;
import android.media.cts.MediaCodecClearKeyPlayer;
import android.media.cts.MediaCodecPlayerTestBase;
import android.media.cts.MediaCodecWrapper;
import android.media.cts.MediaTimeProvider;
import android.media.cts.MediaStubActivity;
import android.media.cts.NdkInputSurface;
import android.media.cts.NdkMediaCodec;
import android.media.cts.TestUtils.Monitor;
import android.net.Uri;
import android.os.Build;
import android.os.Looper;
import android.platform.test.annotations.Presubmit;
import android.util.Base64;
import android.util.Log;

import android.view.Surface;

import com.android.compatibility.common.util.ApiLevelUtil;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Set;
import java.util.UUID;
import java.util.Vector;

import androidx.annotation.NonNull;
import androidx.test.filters.SdkSuppress;


/**
 * Tests of MediaPlayer streaming capabilities.
 */
public class MediaDrmClearkeyTest extends MediaCodecPlayerTestBase<MediaStubActivity> {

    private static final String TAG = MediaDrmClearkeyTest.class.getSimpleName();

    // Add additional keys here if the content has more keys.
    private static final byte[] CLEAR_KEY_CENC = {
            (byte)0x3f, (byte)0x0a, (byte)0x33, (byte)0xf3, (byte)0x40, (byte)0x98, (byte)0xb9, (byte)0xe2,
            (byte)0x2b, (byte)0xc0, (byte)0x78, (byte)0xe0, (byte)0xa1, (byte)0xb5, (byte)0xe8, (byte)0x54 };

    private static final byte[] CLEAR_KEY_WEBM = ""_CLEAR_KEY_WEBM_"".getBytes();

    private static final int NUMBER_OF_SECURE_STOPS = 10;
    private static final int VIDEO_WIDTH_CENC = 1280;
    private static final int VIDEO_HEIGHT_CENC = 720;
    private static final int VIDEO_WIDTH_WEBM = 352;
    private static final int VIDEO_HEIGHT_WEBM = 288;
    private static final int VIDEO_WIDTH_MPEG2TS = 320;
    private static final int VIDEO_HEIGHT_MPEG2TS = 240;
    private static final String MIME_VIDEO_AVC = MediaFormat.MIMETYPE_VIDEO_AVC;
    private static final String MIME_VIDEO_VP8 = MediaFormat.MIMETYPE_VIDEO_VP8;

    // Property Keys
    private static final String ALGORITHMS_PROPERTY_KEY = MediaDrm.PROPERTY_ALGORITHMS;
    private static final String DESCRIPTION_PROPERTY_KEY = MediaDrm.PROPERTY_DESCRIPTION;
    private static final String DEVICEID_PROPERTY_KEY = ""deviceId"";
    private static final String INVALID_PROPERTY_KEY = ""invalid property key"";
    private static final String LISTENER_TEST_SUPPORT_PROPERTY_KEY = ""listenerTestSupport"";
    private static final String VENDOR_PROPERTY_KEY = MediaDrm.PROPERTY_VENDOR;
    private static final String VERSION_PROPERTY_KEY = MediaDrm.PROPERTY_VERSION;

    // Error message
    private static final String ERR_MSG_CRYPTO_SCHEME_NOT_SUPPORTED = ""Crypto scheme is not supported"";

    private static final String CENC_AUDIO_PATH = ""/clear/h264/llama/llama_aac_audio.mp4"";
    private static final String CENC_VIDEO_PATH = ""/clearkey/llama_h264_main_720p_8000.mp4"";
    private static final Uri WEBM_URL = Uri.parse(
            ""android.resource://android.mediadrm.cts/"" + R.raw.video_320x240_webm_vp8_800kbps_30fps_vorbis_stereo_128kbps_44100hz_crypt);
    private static final Uri MPEG2TS_SCRAMBLED_URL = Uri.parse(
            ""android.resource://android.mediadrm.cts/"" + R.raw.segment000001_scrambled);
    private static final Uri MPEG2TS_CLEAR_URL = Uri.parse(
            ""android.resource://android.mediadrm.cts/"" + R.raw.segment000001);

    private static final UUID COMMON_PSSH_SCHEME_UUID =
            new UUID(0x1077efecc0b24d02L, 0xace33c1e52e2fb4bL);
    private static final UUID CLEARKEY_SCHEME_UUID =
            new UUID(0xe2719d58a985b3c9L, 0x781ab030af78d30eL);

    private byte[] mDrmInitData;
    private byte[] mKeySetId;
    private byte[] mSessionId;
    private Monitor mSessionMonitor = new Monitor();
    private Looper mLooper;
    private MediaDrm mDrm = null;
    private final Object mLock = new Object();
    private boolean mEventListenerCalled;
    private boolean mExpirationUpdateReceived;
    private boolean mLostStateReceived;

    private static boolean sIsAtLeastS = ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S);

    public MediaDrmClearkeyTest() {
        super(MediaStubActivity.class);
    }

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        if (false == deviceHasMediaDrm()) {
            tearDown();
        }
    }

    @Override
    protected void tearDown() throws Exception {
        super.tearDown();
    }

    private boolean deviceHasMediaDrm() {
        // ClearKey is introduced after KitKat.
        if (ApiLevelUtil.isAtMost(android.os.Build.VERSION_CODES.KITKAT)) {
            return false;
        }
        return true;
    }

    /**
     * Extracts key ids from the pssh blob returned by getKeyRequest() and
     * places it in keyIds.
     * keyRequestBlob format (section 5.1.3.1):
     * https://dvcs.w3.org/hg/html-media/raw-file/default/encrypted-media/encrypted-media.html#clear-key
     *
     * @return size of keyIds vector that contains the key ids, 0 for error
     */
    private static int getKeyIds(byte[] keyRequestBlob, Vector<String> keyIds) {
        if (0 == keyRequestBlob.length || keyIds == null)
            return 0;

        String jsonLicenseRequest = new String(keyRequestBlob);
        keyIds.clear();

        try {
            JSONObject license = new JSONObject(jsonLicenseRequest);
            final JSONArray ids = license.getJSONArray(""kids"");
            for (int i = 0; i < ids.length(); ++i) {
                keyIds.add(ids.getString(i));
            }
        } catch (JSONException e) {
            Log.e(TAG, ""Invalid JSON license = "" + jsonLicenseRequest);
            return 0;
        }
        return keyIds.size();
    }

    /**
     * Creates the JSON Web Key string.
     *
     * @return JSON Web Key string.
     */
    private static String createJsonWebKeySet(
            Vector<String> keyIds, Vector<String> keys, int keyType) {
        String jwkSet = ""{\""keys\"":["";
        for (int i = 0; i < keyIds.size(); ++i) {
            String id = new String(keyIds.get(i).getBytes(Charset.forName(""UTF-8"")));
            String key = new String(keys.get(i).getBytes(Charset.forName(""UTF-8"")));

            jwkSet += ""{\""kty\"":\""oct\"",\""kid\"":\"""" + id +
                    ""\"",\""k\"":\"""" + key + ""\""}"";
        }
        jwkSet += ""], \""type\"":"";
        if (keyType == MediaDrm.KEY_TYPE_OFFLINE || keyType == MediaDrm.KEY_TYPE_RELEASE) {
            jwkSet += ""\""persistent-license\"" }"";
        } else {
            jwkSet += ""\""temporary\"" }"";
        }
        return jwkSet;
    }

    /**
     * Retrieves clear key ids from getKeyRequest(), create JSON Web Key
     * set and send it to the CDM via provideKeyResponse().
     *
     * @return key set ID
     */
    public static byte[] retrieveKeys(MediaDrm drm, String initDataType,
            byte[] sessionId, byte[] drmInitData, int keyType, byte[][] clearKeyIds) {
        MediaDrm.KeyRequest drmRequest = null;
        try {
            drmRequest = drm.getKeyRequest(sessionId, drmInitData, initDataType,
                    keyType, null);
        } catch (Exception e) {
            e.printStackTrace();
            Log.i(TAG, ""Failed to get key request: "" + e.toString());
        }
        if (drmRequest == null) {
            Log.e(TAG, ""Failed getKeyRequest"");
            return null;
        }

        Vector<String> keyIds = new Vector<String>();
        if (0 == getKeyIds(drmRequest.getData(), keyIds)) {
            Log.e(TAG, ""No key ids found in initData"");
            return null;
        }

        if (clearKeyIds.length != keyIds.size()) {
            Log.e(TAG, ""Mismatch number of key ids and keys: ids="" +
                    keyIds.size() + "", keys="" + clearKeyIds.length);
            return null;
        }

        // Base64 encodes clearkeys. Keys are known to the application.
        Vector<String> keys = new Vector<String>();
        for (int i = 0; i < clearKeyIds.length; ++i) {
            String clearKey = Base64.encodeToString(clearKeyIds[i],
                    Base64.NO_PADDING | Base64.NO_WRAP);
            keys.add(clearKey);
        }

        String jwkSet = createJsonWebKeySet(keyIds, keys, keyType);
        byte[] jsonResponse = jwkSet.getBytes(Charset.forName(""UTF-8""));

        try {
            try {
                return drm.provideKeyResponse(sessionId, jsonResponse);
            } catch (IllegalStateException e) {
                Log.e(TAG, ""Failed to provide key response: "" + e.toString());
            }
        } catch (Exception e) {
            e.printStackTrace();
            Log.e(TAG, ""Failed to provide key response: "" + e.toString());
        }
        return null;
    }

    /**
     * Retrieves clear key ids from getKeyRequest(), create JSON Web Key
     * set and send it to the CDM via provideKeyResponse().
     */
    private void getKeys(MediaDrm drm, String initDataType,
            byte[] sessionId, byte[] drmInitData, int keyType, byte[][] clearKeyIds) {
        mKeySetId = retrieveKeys(drm, initDataType, sessionId, drmInitData, keyType, clearKeyIds);
    }

    private @NonNull MediaDrm startDrm(final byte[][] clearKeyIds, final String initDataType,
                                       final UUID drmSchemeUuid, int keyType) {
        if (!MediaDrm.isCryptoSchemeSupported(drmSchemeUuid)) {
            throw new Error(ERR_MSG_CRYPTO_SCHEME_NOT_SUPPORTED);
        }

        new Thread() {
            @Override
            public void run() {
                if (mDrm != null) {
                    Log.e(TAG, ""Failed to startDrm: already started"");
                    return;
                }
                // Set up a looper to handle events
                Looper.prepare();

                // Save the looper so that we can terminate this thread
                // after we are done with it.
                mLooper = Looper.myLooper();

                try {
                    mDrm = new MediaDrm(drmSchemeUuid);
                } catch (MediaDrmException e) {
                    Log.e(TAG, ""Failed to create MediaDrm: "" + e.getMessage());
                    return;
                }

                synchronized(mLock) {
                    mDrm.setOnEventListener(new MediaDrm.OnEventListener() {
                            @Override
                            public void onEvent(MediaDrm md, byte[] sid, int event,
                                    int extra, byte[] data) {
                                if (md != mDrm) {
                                    Log.e(TAG, ""onEvent callback: drm object mismatch"");
                                    return;
                                } else if (!Arrays.equals(mSessionId, sid)) {
                                    Log.e(TAG, ""onEvent callback: sessionId mismatch: |"" +
                                            Arrays.toString(mSessionId) + ""| vs |"" + Arrays.toString(sid) + ""|"");
                                    return;
                                }

                                mEventListenerCalled = true;
                                if (event == MediaDrm.EVENT_PROVISION_REQUIRED) {
                                    Log.i(TAG, ""MediaDrm event: Provision required"");
                                } else if (event == MediaDrm.EVENT_KEY_REQUIRED) {
                                    Log.i(TAG, ""MediaDrm event: Key required"");
                                    getKeys(mDrm, initDataType, mSessionId, mDrmInitData,
                                            keyType, clearKeyIds);
                                } else if (event == MediaDrm.EVENT_KEY_EXPIRED) {
                                    Log.i(TAG, ""MediaDrm event: Key expired"");
                                    getKeys(mDrm, initDataType, mSessionId, mDrmInitData,
                                            keyType, clearKeyIds);
                                } else if (event == MediaDrm.EVENT_VENDOR_DEFINED) {
                                    Log.i(TAG, ""MediaDrm event: Vendor defined"");
                                } else if (event == MediaDrm.EVENT_SESSION_RECLAIMED) {
                                    Log.i(TAG, ""MediaDrm event: Session reclaimed"");
                                } else {
                                    Log.e(TAG, ""MediaDrm event not supported: "" + event);
                                }
                            }
                        });
                    mDrm.setOnExpirationUpdateListener(new MediaDrm.OnExpirationUpdateListener() {
                            @Override
                            public void onExpirationUpdate(MediaDrm md, byte[] sid, long expirationTime) {
                                if (md != mDrm) {
                                    Log.e(TAG, ""onExpirationUpdate callback: drm object mismatch"");
                                } else if (!Arrays.equals(mSessionId, sid)) {
                                    Log.e(TAG, ""onExpirationUpdate callback: sessionId mismatch: |"" +
                                            Arrays.toString(mSessionId) + ""| vs |"" + Arrays.toString(sid) + ""|"");
                                } else {
                                    mExpirationUpdateReceived = true;
                                }
                            }
                        }, null);
                    mDrm.setOnSessionLostStateListener(new MediaDrm.OnSessionLostStateListener() {
                            @Override
                            public void onSessionLostState(MediaDrm md, byte[] sid) {
                                if (md != mDrm) {
                                    Log.e(TAG, ""onSessionLostState callback: drm object mismatch"");
                                } else if (!Arrays.equals(mSessionId, sid)) {
                                    Log.e(TAG, ""onSessionLostState callback: sessionId mismatch: |"" +
                                            Arrays.toString(mSessionId) + ""| vs |"" + Arrays.toString(sid) + ""|"");
                                } else {
                                    mLostStateReceived = true;
                                }
                            }
                        }, null);
                    mDrm.setOnKeyStatusChangeListener(new MediaDrm.OnKeyStatusChangeListener() {
                            @Override
                            public void onKeyStatusChange(MediaDrm md, byte[] sessionId,
                                    List<KeyStatus> keyInformation, boolean hasNewUsableKey) {
                                Log.d(TAG, ""onKeyStatusChange"");
                                assertTrue(md == mDrm);
                                assertTrue(Arrays.equals(sessionId, mSessionId));
                                mSessionMonitor.signal();
                                assertTrue(hasNewUsableKey);

                                assertEquals(3, keyInformation.size());
                                KeyStatus keyStatus = keyInformation.get(0);
                                assertTrue(Arrays.equals(keyStatus.getKeyId(), new byte[] {0xa, 0xb, 0xc}));
                                assertTrue(keyStatus.getStatusCode() == MediaDrm.KeyStatus.STATUS_USABLE);
                                keyStatus = keyInformation.get(1);
                                assertTrue(Arrays.equals(keyStatus.getKeyId(), new byte[] {0xd, 0xe, 0xf}));
                                assertTrue(keyStatus.getStatusCode() == MediaDrm.KeyStatus.STATUS_EXPIRED);
                                keyStatus = keyInformation.get(2);
                                assertTrue(Arrays.equals(keyStatus.getKeyId(), new byte[] {0x0, 0x1, 0x2}));
                                assertTrue(keyStatus.getStatusCode() == MediaDrm.KeyStatus.STATUS_USABLE_IN_FUTURE);
                            }
                        }, null);

                    mLock.notify();
                }
                Looper.loop();  // Blocks forever until Looper.quit() is called.
            }
        }.start();

        // wait for mDrm to be created
        synchronized(mLock) {
            try {
                mLock.wait(1000);
            } catch (Exception e) {
            }
        }
        return mDrm;
    }

    private void stopDrm(MediaDrm drm) {
        if (drm != mDrm) {
            Log.e(TAG, ""invalid drm specified in stopDrm"");
        }
        mLooper.quit();
        mDrm.close();
        mDrm = null;
    }

    private @NonNull byte[] openSession(MediaDrm drm) {
        byte[] mSessionId = null;
        boolean mRetryOpen;
        do {
            try {
                mRetryOpen = false;
                mSessionId = drm.openSession();
            } catch (Exception e) {
                mRetryOpen = true;
            }
        } while (mRetryOpen);
        return mSessionId;
    }

    private void closeSession(MediaDrm drm, byte[] sessionId) {
        drm.closeSession(sessionId);
    }

    /**
     * Tests clear key system playback.
     */
    private void testClearKeyPlayback(
            UUID drmSchemeUuid,
            String videoMime, String[] videoFeatures,
            String initDataType, byte[][] clearKeyIds,
            Uri audioUrl, boolean audioEncrypted,
            Uri videoUrl, boolean videoEncrypted,
            int videoWidth, int videoHeight, boolean scrambled, int keyType) throws Exception {

        if (isWatchDevice()) {
            return;
        }

        MediaDrm drm = null;
        mSessionId = null;
        final boolean hasDrm = !scrambled && drmSchemeUuid != null;
        if (hasDrm) {
            drm = startDrm(clearKeyIds, initDataType, drmSchemeUuid, keyType);
            mSessionId = openSession(drm);
        }

        if (!preparePlayback(videoMime, videoFeatures, audioUrl, audioEncrypted, videoUrl,
                videoEncrypted, videoWidth, videoHeight, scrambled, mSessionId, getSurfaces())) {
            // Allow device to skip test to keep existing behavior.
            // We should throw an exception for new tests.
            return;
        }

        if (hasDrm) {
            mDrmInitData = mMediaCodecPlayer.getDrmInitData();
            getKeys(mDrm, initDataType, mSessionId, mDrmInitData, keyType, clearKeyIds);
        }

        if (hasDrm && keyType == MediaDrm.KEY_TYPE_OFFLINE) {
            closeSession(drm, mSessionId);
            mSessionMonitor.waitForSignal();
            mSessionId = openSession(drm);
            if (mKeySetId.length > 0) {
                drm.restoreKeys(mSessionId, mKeySetId);
            } else {
                closeSession(drm, mSessionId);
                stopDrm(drm);
                throw new Error(""Invalid keySetId size for offline license"");
            }
        }

        // starts video playback
        playUntilEnd();
        if (hasDrm) {
            closeSession(drm, mSessionId);
            stopDrm(drm);
        }
    }

    /**
     * Tests KEY_TYPE_RELEASE for offline license.
     */
    @Presubmit"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"com.android.cts.tagging.TaggingBaseTest"	"isChangeEnabled"	"CtsTaggingHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/tagging/src/com/android/cts/tagging/TaggingBaseTest.java"	""	"public void test/*
 *.
 */

package com.android.cts.tagging;

import android.compat.cts.CompatChangeGatingTestCase;
import com.android.tradefed.device.ITestDevice;
import com.google.common.collect.ImmutableSet;
import java.util.Scanner;

public class TaggingBaseTest extends CompatChangeGatingTestCase {
    private static final String DEVICE_KERNEL_HELPER_CLASS_NAME = ""DeviceKernelHelpers"";
    private static final String DEVICE_KERNEL_HELPER_APK_NAME = ""DeviceKernelHelpers.apk"";
    private static final String DEVICE_KERNEL_HELPER_PKG_NAME = ""android.cts.tagging.support"";
    private static final String KERNEL_HELPER_START_COMMAND = String.format(
        ""am instrument -w -e package %1$s %1$s/androidx.test.runner.AndroidJUnitRunner"",
        DEVICE_KERNEL_HELPER_PKG_NAME);

    protected static final long NATIVE_HEAP_POINTER_TAGGING_CHANGE_ID = 135754954;
    protected static final String DEVICE_TEST_CLASS_NAME = "".TaggingTest"";
    protected static final String DEVICE_TAGGING_DISABLED_TEST_NAME = ""testHeapTaggingDisabled"";
    protected static final String DEVICE_TAGGING_ENABLED_TEST_NAME = ""testHeapTaggingEnabled"";

    // True if test device supports ARM MTE extension.
    protected boolean deviceSupportsMemoryTagging = false;
    // Initialized in setUp(), contains a set of pointer tagging changes that should be reported by
    // statsd. This set contains the compat change ID for heap tagging iff we can guarantee a statsd
    // report containing the compat change, and is empty otherwise. If the platform doesn't call
    // mPlatformCompat.isChangeEnabled(), the statsd report doesn't contain an entry to the status
    // of the corresponding compat feature. Compat isn't probed in a few scenarios: non-aarch64
    // builds, if the kernel doesn't have support for tagged pointers, if the device supports MTE,
    // or if the app has opted-out of the tagged pointers feature via. the manifest flag.
    protected ImmutableSet reportedChangeSet = ImmutableSet.of();
    // Initialized in setUp(), contains DEVICE_TAGGING_ENABLED_TEST_NAME iff the device supports
    // tagged pointers, and DEVICE_TAGGING_DISABLED_TEST_NAME otherwise. Note - if MTE hardware
    // is present, the device does not support the tagged pointers feature.
    protected String testForWhenSoftwareWantsTagging = DEVICE_TAGGING_DISABLED_TEST_NAME;

    @Override
    protected void setUp() throws Exception {
        installPackage(DEVICE_KERNEL_HELPER_APK_NAME, true);
        ITestDevice device = getDevice();

        // Compat features have a very complicated truth table as to whether they can be
        // enabled/disabled, including variants for:
        //   - Enabling vs. disabling.
        //   - `-userdebug` vs. ""pre-release"" `-user` vs. ""release"" `-user` builds.
        //   - `targetSdkLevel`-gated changes vs. default-enabled vs. default-disabled.
        //   - Debuggable vs. non-debuggable apps.
        // We care most about compat features working correctly in the context of released `-user`
        // builds, as these are what the customers of the compat features are most likely using. In
        // order to ensure consistency here, we basically remove all these variables by reducing our
        // device config permutations to a single set. All our apps are debuggable, and the
        // following code forces the device to treat this test as a ""released"" `-user` build, which
        // is the most restrictive and the most realistic w.r.t. what our users will use.
        device.executeShellCommand(
                ""settings put global force_non_debuggable_final_build_for_compat 1"");

        // Kernel support for tagged pointers can only be determined on device.
        // Deploy a helper package and observe what the kernel tells us about
        // tagged pointers support.
        device.executeAdbCommand(""logcat"", ""-c"");
        device.executeShellCommand(KERNEL_HELPER_START_COMMAND);
        String logs = device.executeAdbCommand(
                ""logcat"", ""-v"", ""brief"", ""-d"", DEVICE_KERNEL_HELPER_CLASS_NAME + "":I"", ""*:S"");

        // Holds whether the device that this test is running on was determined to have both
        // requirements for ARM TBI: the correct architecture (aarch64) and the full set of kernel
        // patches (as indicated by a successful prctl(PR_GET_TAGGED_ADDR_CTRL)).
        boolean deviceHasTBI = false;
        boolean foundKernelHelperResult = false;
        Scanner in = new Scanner(logs);
        while (in.hasNextLine()) {
            String line = in.nextLine();
            if (line.contains(""Kernel supports tagged pointers"")) {
                foundKernelHelperResult = true;
                deviceHasTBI = line.contains(""true"");
                break;
            }
        }
        in.close();
        if (!foundKernelHelperResult) {
            throw new Exception(""Failed to get a result from the kernel helper."");
        }

        deviceSupportsMemoryTagging = !runCommand(""grep 'Features.* mte' /proc/cpuinfo"").isEmpty();

        if (deviceHasTBI && !deviceSupportsMemoryTagging) {
            reportedChangeSet = ImmutableSet.of(NATIVE_HEAP_POINTER_TAGGING_CHANGE_ID);
            testForWhenSoftwareWantsTagging = DEVICE_TAGGING_ENABLED_TEST_NAME;
        }
    }

    @Override
    protected void tearDown() throws Exception {
        uninstallPackage(DEVICE_KERNEL_HELPER_PKG_NAME, true);
        ITestDevice device = getDevice();
        device.executeShellCommand(
                ""settings put global force_non_debuggable_final_build_for_compat 0"");
    }
}"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.atrace.cts.AtraceHostTest"	"testBeginEndSection"	"CtsAtraceHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/atrace/src/android/atrace/cts/AtraceHostTest.java"	""	"public void testBeginEndSection() {
        TraceResult result = traceSingleTest(beginEndSection);
        assertTrue(result.getPid() > 0);
        assertTrue(result.getTid() > 0);
        assertNotNull(result.getModel());
        ThreadModel thread = findThread(result.getModel(), result.getTid());
        assertNotNull(thread);
        assertEquals(2, thread.getSlices().size());
        Slice sdkSlice = thread.getSlices().get(0);
        assertEquals(""AtraceDeviceTest::beginEndSection"", sdkSlice.getName());
        Slice ndkSlice = thread.getSlices().get(1);
        assertEquals(""ndk::beginEndSection"", ndkSlice.getName());
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.atrace.cts.AtraceHostTest"	"testAsyncBeginEndSection"	"CtsAtraceHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/atrace/src/android/atrace/cts/AtraceHostTest.java"	""	"public void testAsyncBeginEndSection() {
        TraceResult result = traceSingleTest(asyncBeginEndSection);
        assertTrue(result.getPid() > 0);
        assertTrue(result.getTid() > 0);
        assertNotNull(result.getModel());
        ProcessModel process = findProcess(result.getModel(), result.getPid());
        assertNotNull(process);
        assertEquals(2, process.getAsyncSlices().size());
        AsyncSlice sdkSlice = process.getAsyncSlices().get(0);
        assertEquals(""AtraceDeviceTest::asyncBeginEndSection"", sdkSlice.getName());
        assertEquals(42, sdkSlice.getCookie());
        AsyncSlice ndkSlice = process.getAsyncSlices().get(1);
        assertEquals(""ndk::asyncBeginEndSection"", ndkSlice.getName());
        assertEquals(4770, ndkSlice.getCookie());
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"com.android.cts.apicoverage.CtsApiCoverage"	"isDirectory"	""	"/home/gpoor/cts-12-source/cts/tools/cts-api-coverage/src/com/android/cts/apicoverage/CtsApiCoverage.java"	""	"public void test/*
 *.
 */

package com.android.cts.apicoverage;

import com.android.compatibility.common.util.CddTest;
import com.android.compatibility.common.util.ReadElf;

import org.jf.dexlib2.DexFileFactory;
import org.jf.dexlib2.Opcodes;
import org.jf.dexlib2.iface.Annotation;
import org.jf.dexlib2.iface.AnnotationElement;
import org.jf.dexlib2.iface.ClassDef;
import org.jf.dexlib2.iface.DexFile;
import org.jf.dexlib2.iface.Method;
import org.jf.dexlib2.iface.value.StringEncodedValue;

import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.XMLReader;
import org.xml.sax.helpers.XMLReaderFactory;

import java.io.File;
import java.io.FilenameFilter;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.OutputStream;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Locale;
import java.util.Set;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

import javax.xml.transform.TransformerException;

/**
 * Tool that generates a report of what Android framework methods are being called from a given
 * set of APKS. See the {@link #printUsage()} method for more details.
 */
public class CtsApiCoverage {

    private static final FilenameFilter SUPPORTED_FILE_NAME_FILTER = new FilenameFilter() {
        public boolean accept(File dir, String name) {
            String fileName = name.toLowerCase();
            return fileName.endsWith("".apk"") || fileName.endsWith("".jar"");
        }
    };

    private static final int FORMAT_TXT = 0;

    private static final int FORMAT_XML = 1;

    private static final int FORMAT_HTML = 2;

    private static final String CDD_REQUIREMENT_ANNOTATION = ""Lcom/android/compatibility/common/util/CddTest;"";

    private static final String CDD_REQUIREMENT_ELEMENT_NAME = ""requirement"";

    private static final String NDK_PACKAGE_NAME = ""ndk"";

    private static void printUsage() {
        System.out.println(""Usage: cts-api-coverage [OPTION]... [APK]..."");
        System.out.println();
        System.out.println(""Generates a report about what Android framework methods are called "");
        System.out.println(""from the given APKs."");
        System.out.println();
        System.out.println(""Use the Makefiles rules in CtsCoverage.mk to generate the report "");
        System.out.println(""rather than executing this directly. If you still want to run this "");
        System.out.println(""directly, then this must be used from the $ANDROID_BUILD_TOP "");
        System.out.println(""directory and dexdeps must be built via \""make dexdeps\""."");
        System.out.println();
        System.out.println(""Options:"");
        System.out.println(""  -o FILE                output file or standard out if not given"");
        System.out.println(""  -f [txt|xml|html]      format of output"");
        System.out.println(""  -d PATH                path to dexdeps or expected to be in $PATH"");
        System.out.println(""  -a PATH                path to the API XML file"");
        System.out.println(
                ""  -n PATH                path to the NDK API XML file, which can be updated via ndk-api-report with the ndk target"");
        System.out.println(""  -p PACKAGENAMEPREFIX   report coverage only for package that start with"");
        System.out.println(""  -t TITLE               report title"");
        System.out.println(""  -a API                 the Android API Level"");
        System.out.println(""  -b BITS                64 or 32 bits, default 64"");
        System.out.println();
        System.exit(1);
    }

    public static void main(String[] args) throws Exception {
        List<File> testApks = new ArrayList<File>();
        File outputFile = null;
        int format = FORMAT_TXT;
        String dexDeps = ""dexDeps"";
        String apiXmlPath = """";
        String napiXmlPath = """";
        PackageFilter packageFilter = new PackageFilter();
        String reportTitle = ""CTS API Coverage"";
        int apiLevel = Integer.MAX_VALUE;
        String testCasesFolder = """";
        String bits = ""64"";

        List<File> notFoundTestApks = new ArrayList<File>();
        int numTestApkArgs = 0;
        for (int i = 0; i < args.length; i++) {
            if (args[i].startsWith(""-"")) {
                if (""-o"".equals(args[i])) {
                    outputFile = new File(getExpectedArg(args, ++i));
                } else if (""-f"".equals(args[i])) {
                    String formatSpec = getExpectedArg(args, ++i);
                    if (""xml"".equalsIgnoreCase(formatSpec)) {
                        format = FORMAT_XML;
                    } else if (""txt"".equalsIgnoreCase(formatSpec)) {
                        format = FORMAT_TXT;
                    } else if (""html"".equalsIgnoreCase(formatSpec)) {
                        format = FORMAT_HTML;
                    } else {
                        printUsage();
                    }
                } else if (""-d"".equals(args[i])) {
                    dexDeps = getExpectedArg(args, ++i);
                } else if (""-a"".equals(args[i])) {
                    apiXmlPath = getExpectedArg(args, ++i);
                } else if (""-n"".equals(args[i])) {
                    napiXmlPath = getExpectedArg(args, ++i);
                } else if (""-p"".equals(args[i])) {
                    packageFilter.addPrefixToFilter(getExpectedArg(args, ++i));
                } else if (""-t"".equals(args[i])) {
                    reportTitle = getExpectedArg(args, ++i);
                } else if (""-a"".equals(args[i])) {
                    apiLevel = Integer.parseInt(getExpectedArg(args, ++i));
                } else if (""-b"".equals(args[i])) {
                    bits = getExpectedArg(args, ++i);
                } else {
                    printUsage();
                }
            } else {
                File file = new File(args[i]);
                numTestApkArgs++;
                if (file.isDirectory()) {
                    testApks.addAll(Arrays.asList(file.listFiles(SUPPORTED_FILE_NAME_FILTER)));
                    testCasesFolder = args[i];
                } else if (file.isFile()) {
                    testApks.add(file);
                } else {
                    notFoundTestApks.add(file);
                }
            }
        }

        if (!notFoundTestApks.isEmpty()) {
            String msg = String.format(Locale.US, ""%d/%d testApks not found: %s"",
                    notFoundTestApks.size(), numTestApkArgs, notFoundTestApks);
            throw new IllegalArgumentException(msg);
        }

        /*
         * 1. Create an ApiCoverage object that is a tree of Java objects representing the API
         *    in current.xml. The object will have no information about the coverage for each
         *    constructor or method yet.
         *
         * 2. For each provided APK, scan it using dexdeps, parse the output of dexdeps, and
         *    call methods on the ApiCoverage object to cumulatively add coverage stats.
         *
         * 3. Output a report based on the coverage stats in the ApiCoverage object.
         */

        ApiCoverage apiCoverage = getEmptyApiCoverage(apiXmlPath);
        CddCoverage cddCoverage = getEmptyCddCoverage();

        if (!napiXmlPath.equals("""")) {
            System.out.println(""napiXmlPath: "" + napiXmlPath);
            ApiCoverage napiCoverage = getEmptyApiCoverage(napiXmlPath);
            ApiPackage napiPackage = napiCoverage.getPackage(NDK_PACKAGE_NAME);
            System.out.println(
                    String.format(
                            ""%s, NDK Methods = %d, MemberSize = %d"",
                            napiXmlPath,
                            napiPackage.getTotalMethods(),
                            napiPackage.getMemberSize()));
            apiCoverage.addPackage(napiPackage);
        }

        // Add superclass information into api coverage.
        apiCoverage.resolveSuperClasses();

        ExecutorService service =
            Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
        List<Future> tasks = new ArrayList<>();
        for (File testApk : testApks) {
            tasks.add(addApiCoverage(service, apiCoverage, testApk, dexDeps));
            tasks.add(addCddCoverage(service, cddCoverage, testApk, apiLevel));
        }
        // Wait until all tasks finish.
        for (Future task : tasks) {
            task.get();
        }
        service.shutdown();

        // The below two coverage methods assume all classes and methods have been already
        // registered, which is why we don't run them parallelly with others.

        try {
            // Add coverage for GTest modules
            addGTestNdkApiCoverage(apiCoverage, testCasesFolder, bits);
        } catch (Exception e) {
            System.out.println(""warning: addGTestNdkApiCoverage failed to add to apiCoverage:"");
            e.printStackTrace();
        }

        try {
            // Add coverage for APK with Share Objects
            addNdkApiCoverage(apiCoverage, testCasesFolder, bits);
        } catch (Exception e) {
            System.out.println(""warning: addNdkApiCoverage failed to add to apiCoverage:"");
            e.printStackTrace();
        }

        outputCoverageReport(apiCoverage, cddCoverage, testApks, outputFile,
            format, packageFilter, reportTitle);
    }

    /** Get the argument or print out the usage and exit. */
    private static String getExpectedArg(String[] args, int index) {
        if (index < args.length) {
            return args[index];
        } else {
            printUsage();
            return null;    // Never will happen because printUsage will call exit(1)
        }
    }

    /**
     * Creates an object representing the API that will be used later to collect coverage
     * statistics as we iterate over the test APKs.
     *
     * @param apiXmlPath to the API XML file
     * @return an {@link ApiCoverage} object representing the API in current.xml without any
     *     coverage statistics yet
     */
    private static ApiCoverage getEmptyApiCoverage(String apiXmlPath)
            throws SAXException, IOException {
        XMLReader xmlReader = XMLReaderFactory.createXMLReader();
        CurrentXmlHandler currentXmlHandler = new CurrentXmlHandler();
        xmlReader.setContentHandler(currentXmlHandler);

        File currentXml = new File(apiXmlPath);
        FileReader fileReader = null;
        try {
            fileReader = new FileReader(currentXml);
            xmlReader.parse(new InputSource(fileReader));
        } finally {
            if (fileReader != null) {
                fileReader.close();
            }
        }

        return currentXmlHandler.getApi();
    }

    /**
     * Adds coverage information gleamed from running dexdeps on the APK to the
     * {@link ApiCoverage} object.
     *
     * @param apiCoverage object to which the coverage statistics will be added to
     * @param testApk containing the tests that will be scanned by dexdeps
     */
    private static Future addApiCoverage(
        ExecutorService service, ApiCoverage apiCoverage, File testApk, String dexdeps) {
        return service.submit(() -> {
            String apkPath = testApk.getPath();
            try {
                XMLReader xmlReader = XMLReaderFactory.createXMLReader();
                String testApkName = testApk.getName();
                DexDepsXmlHandler dexDepsXmlHandler = new DexDepsXmlHandler(apiCoverage, testApkName);
                xmlReader.setContentHandler(dexDepsXmlHandler);

                Process process = new ProcessBuilder(dexdeps, ""--format=xml"", apkPath).start();
                xmlReader.parse(new InputSource(process.getInputStream()));
            } catch (SAXException e) {
                // Catch this exception, but continue. SAXException is acceptable in cases
                // where the apk does not contain a classes.dex and therefore parsing won't work.
                System.err.println(""warning: dexdeps failed for: "" + apkPath);
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        });
    }

    /**
     * Adds coverage information from native code symbol array to the {@link ApiCoverage} object.
     *
     * @param apiPackage object to which the coverage statistics will be added to
     * @param symArr containing native code symbols
     * @param testModules containing a list of TestModule
     * @param moduleName test module name
     */
    private static void addNdkSymArrToApiCoverage(
            ApiCoverage apiCoverage, List<TestModule> testModules)
            throws SAXException, IOException {

        final List<String> parameterTypes = new ArrayList<String>();
        final ApiPackage apiPackage = apiCoverage.getPackage(NDK_PACKAGE_NAME);

        if (apiPackage != null) {
            for (TestModule tm : testModules) {
                final String moduleName = tm.getModuleName();
                final ReadElf.Symbol[] symArr = tm.getDynSymArr();
                if (symArr != null) {
                    for (ReadElf.Symbol sym : symArr) {
                        if (sym.isGlobalUnd()) {
                            String className = sym.getExternalLibFileName();
                            ApiClass apiClass = apiPackage.getClass(className);
                            if (apiClass != null) {
                                apiClass.markMethodCovered(
                                        sym.name,
                                        parameterTypes,
                                        moduleName);
                            } else {
                                System.err.println(
                                        String.format(
                                                ""warning: addNdkApiCoverage failed to getClass: %s"",
                                                className));
                            }
                        }
                    }
                } else {
                    System.err.println(
                            String.format(
                                    ""warning: addNdkSymbolArrToApiCoverage failed to getSymArr: %s"",
                                    moduleName));
                }
            }
        } else {
            System.err.println(
                    String.format(
                            ""warning: addNdkApiCoverage failed to getPackage: %s"",
                            NDK_PACKAGE_NAME));
        }
    }

    /**
     * Adds coverage information gleamed from readelf on so in the APK to the {@link ApiCoverage}
     * object.
     *
     * @param apiCoverage object to which the coverage statistics will be added to
     * @param testCasesFolder containing GTest modules
     * @param bits 64 or 32 bits of executiable
     */
    private static void addNdkApiCoverage(
            ApiCoverage apiCoverage, String testCasesFolder, String bits)
            throws SAXException, IOException {
        ApkNdkApiReport apiReport = ApkNdkApiReport.parseTestcasesFolder(testCasesFolder, bits);
        if (apiReport != null) {
            addNdkSymArrToApiCoverage(apiCoverage, apiReport.getTestModules());
        } else {
            System.err.println(
                    String.format(
                            ""warning: addNdkApiCoverage failed to get GTestApiReport from: %s @ %s bits"",
                            testCasesFolder, bits));
        }
    }

    /**
     * Adds GTest coverage information gleamed from running ReadElf on the executiable to the {@link
     * ApiCoverage} object.
     *
     * @param apiCoverage object to which the coverage statistics will be added to
     * @param testCasesFolder containing GTest modules
     * @param bits 64 or 32 bits of executiable
     */
    private static void addGTestNdkApiCoverage(
            ApiCoverage apiCoverage, String testCasesFolder, String bits)
            throws SAXException, IOException {
        GTestApiReport apiReport = GTestApiReport.parseTestcasesFolder(testCasesFolder, bits);
        if (apiReport != null) {
            addNdkSymArrToApiCoverage(apiCoverage, apiReport.getTestModules());
        } else {
            System.err.println(
                    String.format(
                            ""warning: addGTestNdkApiCoverage failed to get GTestApiReport from: %s @ %s bits"",
                            testCasesFolder, bits));
        }
    }

    private static Future addCddCoverage(
        ExecutorService service, CddCoverage cddCoverage, File testSource, int api) {
        return service.submit(() -> {
            try {
                if (testSource.getName().endsWith("".apk"")) {
                    addCddApkCoverage(cddCoverage, testSource, api);
                } else if (testSource.getName().endsWith("".jar"")) {
                    addCddJarCoverage(cddCoverage, testSource);
                } else {
                    System.err
                        .println(""Unsupported file type for CDD coverage: "" + testSource.getPath());
                }
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        });
    }

    private static void addCddJarCoverage(CddCoverage cddCoverage, File testSource)
            throws IOException {

        Collection<Class<?>> classes = JarTestFinder.getClasses(testSource);
        for (Class<?> c : classes) {
            for (java.lang.reflect.Method m : c.getMethods()) {
                if (m.isAnnotationPresent(CddTest.class)) {
                    CddTest cddTest = m.getAnnotation(CddTest.class);
                    CddCoverage.TestMethod testMethod =
                            new CddCoverage.TestMethod(
                                    testSource.getName(), c.getName(), m.getName());
                    cddCoverage.addCoverage(cddTest.requirement(), testMethod);
                }
            }
        }
    }

    private static void addCddApkCoverage(
        CddCoverage cddCoverage, File testSource, int api)
            throws IOException {

        DexFile dexFile = null;
        try {
            dexFile = DexFileFactory.loadDexFile(testSource, Opcodes.forApi(api));
        } catch (IOException | DexFileFactory.DexFileNotFoundException e) {
            System.err.println(""Unable to load dex file: "" + testSource.getPath());
            return;
        }

        String moduleName = testSource.getName();
        for (ClassDef classDef : dexFile.getClasses()) {
            String className = classDef.getType();
            handleAnnotations(
                cddCoverage, moduleName, className, null /*methodName*/,
                classDef.getAnnotations());

            for (Method method : classDef.getMethods()) {
                String methodName = method.getName();
                handleAnnotations(
                    cddCoverage, moduleName, className, methodName, method.getAnnotations());
            }
        }
    }

    private static void handleAnnotations(
            CddCoverage cddCoverage, String moduleName, String className,
                    String methodName, Set<? extends Annotation> annotations) {
        for (Annotation annotation : annotations) {
            if (annotation.getType().equals(CDD_REQUIREMENT_ANNOTATION)) {
                for (AnnotationElement annotationElement : annotation.getElements()) {
                    if (annotationElement.getName().equals(CDD_REQUIREMENT_ELEMENT_NAME)) {
                        String cddRequirement =
                                ((StringEncodedValue) annotationElement.getValue()).getValue();
                        CddCoverage.TestMethod testMethod =
                                new CddCoverage.TestMethod(
                                        moduleName, dexToJavaName(className), methodName);
                        cddCoverage.addCoverage(cddRequirement, testMethod);
                    }
                }
            }
        }
    }

    /**
     * Given a string like Landroid/app/cts/DownloadManagerTest;
     * return android.app.cts.DownloadManagerTest.
     */
    private static String dexToJavaName(String dexName) {
        if (!dexName.startsWith(""L"") || !dexName.endsWith("";"")) {
            return dexName;
        }
        dexName = dexName.replace('/', '.');
        if (dexName.length() > 2) {
            dexName = dexName.substring(1, dexName.length() - 1);
        }
        return dexName;
    }

    private static CddCoverage getEmptyCddCoverage() {
        CddCoverage cddCoverage = new CddCoverage();
        // TODO(nicksauer): Read in the valid list of requirements
        return cddCoverage;
    }

    private static void outputCoverageReport(ApiCoverage apiCoverage, CddCoverage cddCoverage,
            List<File> testApks, File outputFile, int format, PackageFilter packageFilter,
            String reportTitle)
                throws IOException, TransformerException, InterruptedException {

        OutputStream out = outputFile != null
                ? new FileOutputStream(outputFile)
                : System.out;

        try {
            switch (format) {
                case FORMAT_TXT:
                    TextReport.printTextReport(apiCoverage, cddCoverage, packageFilter, out);
                    break;

                case FORMAT_XML:
                    XmlReport.printXmlReport(testApks, apiCoverage, cddCoverage,
                        packageFilter, reportTitle, out);
                    break;

                case FORMAT_HTML:
                    HtmlReport.printHtmlReport(testApks, apiCoverage, cddCoverage,
                        packageFilter, reportTitle, out);
                    break;
            }
        } finally {
            out.close();
        }
    }
}"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.text.method.cts.PasswordTransformationMethodTest"	"testTextChangedCallBacks"	"CtsTextTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/text/src/android/text/method/cts/PasswordTransformationMethodTest.java"	""	"public void testTextChangedCallBacks() throws Throwable {
        mActivityRule.runOnUiThread(() ->
            mTransformedText = mMethod.getTransformation(mEditText.getText(), mEditText));

        reset(mMethod);
        // 12-key support
        KeyCharacterMap keymap = KeyCharacterMap.load(KeyCharacterMap.VIRTUAL_KEYBOARD);
        if (keymap.getKeyboardType() == KeyCharacterMap.NUMERIC) {
            // ""HELLO"" in case of 12-key(NUMERIC) keyboard
            CtsKeyEventUtil.sendKeys(mInstrumentation, mEditText,
                    ""6*4 6*3 7*5 DPAD_RIGHT 7*5 7*6 DPAD_RIGHT"");
        }
        else {
            CtsKeyEventUtil.sendKeys(mInstrumentation, mEditText, ""H E 2*L O"");
        }
        verify(mMethod, atLeastOnce()).beforeTextChanged(any(), anyInt(), anyInt(), anyInt());
        verify(mMethod, atLeastOnce()).onTextChanged(any(), anyInt(), anyInt(), anyInt());
        verify(mMethod, atLeastOnce()).afterTextChanged(any());

        reset(mMethod);

        mActivityRule.runOnUiThread(() -> mEditText.append("" ""));

        // the appended string will not get transformed immediately
        // ""***** ""
        assertEquals(""\u2022\u2022\u2022\u2022\u2022 "", mTransformedText.toString());
        verify(mMethod, atLeastOnce()).beforeTextChanged(any(), anyInt(), anyInt(), anyInt());
        verify(mMethod, atLeastOnce()).onTextChanged(any(), anyInt(), anyInt(), anyInt());
        verify(mMethod, atLeastOnce()).afterTextChanged(any());

        // it will get transformed after a while
        // ""******""
        PollingCheck.waitFor(() -> mTransformedText.toString()
                .equals(""\u2022\u2022\u2022\u2022\u2022\u2022""));
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.app.cts.ActionBarTest"	"testOptionsMenuKey"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActionBarTest.java"	""	"public void testOptionsMenuKey() throws Exception {
        boolean hasPermanentMenuKey = ViewConfiguration.get(getActivity()).hasPermanentMenuKey();
        if (!mActivity.getWindow().hasFeature(Window.FEATURE_OPTIONS_PANEL)
                || hasPermanentMenuKey) {
            return;
        }
        final boolean menuIsVisible[] = {false};
        mActivity.getActionBar().addOnMenuVisibilityListener(
                isVisible -> menuIsVisible[0] = isVisible);
        // Wait here for test activity to gain focus before sending keyevent.
        // Visibility listener needs the action bar to be visible.
        getInstrumentation().sendKeyDownUpSync(KeyEvent.KEYCODE_MENU);

        assertTrue(menuIsVisible[0]);
        assertTrue(mActivity.windowFocusSignal.await(1000, TimeUnit.MILLISECONDS));
        getInstrumentation().sendKeyDownUpSync(KeyEvent.KEYCODE_MENU);

        assertTrue(mActivity.windowFocusSignal.await(1000, TimeUnit.MILLISECONDS));
        assertFalse(menuIsVisible[0]);
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"com.android.cts.apicoverage.GTestApiReport"	"getTestModules"	""	"/home/gpoor/cts-12-source/cts/tools/cts-api-coverage/src/com/android/cts/apicoverage/GTestApiReport.java"	""	"public void test/*
 *.
 */

package com.android.cts.apicoverage;


import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.XMLReader;
import org.xml.sax.helpers.XMLReaderFactory;

import java.io.File;
import java.io.FileReader;
import java.io.FilenameFilter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
/**
 * Class that outputs an XML report of the {@link ApiCoverage} collected. It can be viewed in a
 * browser when used with the api-coverage.css and api-coverage.xsl files.
 */
class GTestApiReport {
    public static final String CONFIG_EXT = "".config"";
    public static final String DEFAULT_OUTPUT_FILE_NAME = ""./gtest-coverage.txt"";
    public static final String TEST_TYPE = ""com.android.tradefed.testtype.GTest"";

    private static final FilenameFilter SUPPORTED_FILE_NAME_FILTER =
            new FilenameFilter() {
                public boolean accept(File dir, String name) {
                    String fileName = name.toLowerCase();
                    return fileName.endsWith(CONFIG_EXT);
                }
            };

    private static void printUsage() {
        System.out.println(""Usage: GTestApiXmlReport [OPTION]... [APK]..."");
        System.out.println();
        System.out.println(""Generates a report about what Android NDK methods."");
        System.out.println();
        System.out.println(""Options:"");
        System.out.println(""  -o FILE                output file or standard out if not given"");
        System.out.println(""  -t PATH                path to the CTS testcases Folder"");
        System.out.println(""  -b BITS                64 or 32"");
        System.out.println();
        System.exit(1);
    }

    /** Get the argument or print out the usage and exit. */
    private static String getExpectedArg(String[] args, int index) {
        if (index < args.length) {
            return args[index];
        } else {
            printUsage();
            return null; // Never will happen because printUsage will call exit(1)
        }
    }

    public static void main(String[] args) throws IOException, SAXException {
        GTestApiReport apiReport;
        String testCasePath = """";
        String bits = ""64"";
        String outputFileName = DEFAULT_OUTPUT_FILE_NAME;
        int numTestModule = 0;

        for (int i = 0; i < args.length; i++) {
            if (args[i].startsWith(""-"")) {
                if (""-o"".equals(args[i])) {
                    outputFileName = getExpectedArg(args, ++i);
                } else if (""-t"".equals(args[i])) {
                    testCasePath = getExpectedArg(args, ++i);
                } else if (""-b"".equals(args[i])) {
                    bits = getExpectedArg(args, ++i);
                } else {
                    printUsage();
                }
            } else {
                printUsage();
            }
        }

        apiReport = parseTestcasesFolder(testCasePath, bits);
        if (apiReport != null) {
            for (TestModule tm : apiReport.mTestModules) {
                tm.getDynSymArr();
            }
        } else {
            printUsage();
        }
    }

    private List<TestModule> mTestModules;
    private String mBits;

    GTestApiReport(List<TestModule> testModules, String bits) {
        mTestModules = testModules;
        mBits = bits;
    }

    public List<TestModule> getTestModules() {
        return mTestModules;
    }

    public String getBits() {
        return mBits;
    }

    public static GTestApiReport parseTestcasesFolder(String testCasePath, String bits)
            throws IOException, SAXException {
        File[] testConfigFiles;
        List<TestModule> testModules = new ArrayList<TestModule>();

        File file = new File(testCasePath);
        if (file.isDirectory()) {
            testConfigFiles = file.listFiles(SUPPORTED_FILE_NAME_FILTER);

            for (File testConfigFile : testConfigFiles) {
                XMLReader xmlReader = XMLReaderFactory.createXMLReader();
                TestModuleConfigHandler testModuleXmlHandler = new TestModuleConfigHandler(file.getName());
                xmlReader.setContentHandler(testModuleXmlHandler);
                FileReader fileReader = null;

                try {
                    fileReader = new FileReader(testConfigFile);
                    xmlReader.parse(new InputSource(fileReader));
                    if (TEST_TYPE.equalsIgnoreCase(testModuleXmlHandler.getTestClassName())) {
                        File gTestExe =
                                new File(
                                        testCasePath
                                                + ""/""
                                                + testModuleXmlHandler.getModuleName()
                                                + bits);

                        System.out.println(gTestExe.getName());
                        System.out.println(
                                String.format(
                                        ""%s: %s, %s"",
                                        testConfigFile.getName(),
                                        testModuleXmlHandler.getModuleName(),
                                        testModuleXmlHandler.getTestClassName()));

                        testModules.add(
                                new TestModule(
                                        gTestExe,
                                        testModuleXmlHandler.getModuleName(),
                                        testModuleXmlHandler.getTestClassName()));
                    }

                } finally {
                    if (fileReader != null) {
                        fileReader.close();
                    }
                }
            }
        } else {
            return null;
        }
        return new GTestApiReport(testModules, bits);
    }
}"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.server.biometrics.Utils"	"isBusy"	"CtsBiometricsTestCases"	"/home/gpoor/cts-12-source/cts/tests/framework/base/biometrics/src/android/server/biometrics/Utils.java"	""	"public void test/*
 *.
 */

package android.server.biometrics;

import static androidx.test.platform.app.InstrumentationRegistry.getInstrumentation;

import android.content.ComponentName;
import android.hardware.biometrics.BiometricManager;
import android.hardware.biometrics.BiometricPrompt;
import android.hardware.biometrics.SensorProperties;
import android.os.ParcelFileDescriptor;
import android.security.keystore.KeyGenParameterSpec;
import android.security.keystore.KeyProperties;
import android.server.wm.Condition;
import android.util.Log;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import com.android.server.biometrics.nano.BiometricServiceStateProto;

import java.io.ByteArrayOutputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.security.KeyStore;
import java.util.List;
import java.util.function.BooleanSupplier;
import java.util.function.Consumer;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;

public class Utils {

    private static final String TAG = ""BiometricTestUtils"";
    private static final String KEYSTORE_PROVIDER = ""AndroidKeyStore"";

    /** adb command for dumping the biometric proto */
    public static final String DUMPSYS_BIOMETRIC = ""dumpsys biometric --proto"";

    /**
     * Retrieves the current SensorStates.
     */
    public interface SensorStatesSupplier {
        SensorStates getSensorStates() throws Exception;
    }

    /**
     * Waits for the service to become idle
     * @throws Exception
     */
    public static void waitForIdleService(@NonNull SensorStatesSupplier supplier) throws Exception {
        for (int i = 0; i < 10; i++) {
            if (!supplier.getSensorStates().areAllSensorsIdle()) {
                Log.d(TAG, ""Not idle yet.."");
                Thread.sleep(300);
            } else {
                return;
            }
        }
        Log.d(TAG, ""Timed out waiting for idle"");
    }

    /**
     * Waits for the specified sensor to become non-idle
     */
    public static void waitForBusySensor(int sensorId, @NonNull SensorStatesSupplier supplier)
            throws Exception {
        for (int i = 0; i < 10; i++) {
            if (!supplier.getSensorStates().sensorStates.get(sensorId).isBusy()) {
                Log.d(TAG, ""Not busy yet.."");
                Thread.sleep(300);
            } else {
                return;
            }
        }
        Log.d(TAG, ""Timed out waiting to become busy"");
    }

    public static void waitFor(@NonNull String message, @NonNull BooleanSupplier condition) {
        waitFor(message, condition, null /* onFailure */);
    }

    public static void waitFor(@NonNull String message, @NonNull BooleanSupplier condition,
            @Nullable Consumer<Object> onFailure) {
        Condition.waitFor(new Condition<>(message, condition)
                .setRetryIntervalMs(500)
                .setRetryLimit(20)
                .setOnFailure(onFailure));
    }

    /**
     * Retrieves the current states of all biometric sensor services (e.g. FingerprintService,
     * FaceService, etc).
     *
     * Note that the states are retrieved from BiometricService, instead of individual services.
     * This is because 1) BiometricService is the source of truth for all public API-facing things,
     * and 2) This to include other information, such as UI states, etc as well.
     */
    @NonNull
    public static BiometricServiceState getBiometricServiceCurrentState() throws Exception {
        final byte[] dump = Utils.executeShellCommand(DUMPSYS_BIOMETRIC);
        final BiometricServiceStateProto proto = BiometricServiceStateProto.parseFrom(dump);
        return BiometricServiceState.parseFrom(proto);
    }

    /**
     * Runs a shell command, similar to running ""adb shell ..."" from the command line.
     * @param cmd A command, without the preceding ""adb shell"" portion. For example,
     *            passing in ""dumpsys fingerprint"" would be the equivalent of running
     *            ""adb shell dumpsys fingerprint"" from the command line.
     * @return The result of the command.
     */
    public static byte[] executeShellCommand(String cmd) {
        Log.d(TAG, ""execute: "" + cmd);
        try {
            ParcelFileDescriptor pfd = getInstrumentation().getUiAutomation()
                    .executeShellCommand(cmd);
            byte[] buf = new byte[512];
            int bytesRead;
            FileInputStream fis = new ParcelFileDescriptor.AutoCloseInputStream(pfd);
            ByteArrayOutputStream stdout = new ByteArrayOutputStream();
            while ((bytesRead = fis.read(buf)) != -1) {
                stdout.write(buf, 0, bytesRead);
            }
            fis.close();
            return stdout.toByteArray();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public static void forceStopActivity(ComponentName componentName) {
        executeShellCommand(""am force-stop "" + componentName.getPackageName()
                + "" "" + componentName.getShortClassName().replaceAll(""\\."", """"));
    }

    public static int numberOfSpecifiedOperations(@NonNull BiometricServiceState state,
            int sensorId, int operation) {
        int count = 0;
        final List<Integer> recentOps = state.mSensorStates.sensorStates.get(sensorId)
                .getSchedulerState().getRecentOperations();
        for (Integer i : recentOps) {
            if (i == operation) {
                count++;
            }
        }
        return count;
    }

    public static void createTimeBoundSecretKey_deprecated(String keyName, boolean useStrongBox)
            throws Exception {
        KeyStore keyStore = KeyStore.getInstance(""AndroidKeyStore"");
        keyStore.load(null);
        KeyGenerator keyGenerator = KeyGenerator.getInstance(
                KeyProperties.KEY_ALGORITHM_AES, ""AndroidKeyStore"");

        // Set the alias of the entry in Android KeyStore where the key will appear
        // and the constrains (purposes) in the constructor of the Builder
        keyGenerator.init(new KeyGenParameterSpec.Builder(keyName,
                KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT)
                .setBlockModes(KeyProperties.BLOCK_MODE_CBC)
                .setUserAuthenticationRequired(true)
                .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_PKCS7)
                .setIsStrongBoxBacked(useStrongBox)
                .setUserAuthenticationValidityDurationSeconds(5 /* seconds */)
                .build());
        keyGenerator.generateKey();
    }

    static void createTimeBoundSecretKey(String keyName, int authTypes, boolean useStrongBox)
            throws Exception {
        KeyStore keyStore = KeyStore.getInstance(""AndroidKeyStore"");
        keyStore.load(null);
        KeyGenerator keyGenerator = KeyGenerator.getInstance(
                KeyProperties.KEY_ALGORITHM_AES, ""AndroidKeyStore"");

        // Set the alias of the entry in Android KeyStore where the key will appear
        // and the constrains (purposes) in the constructor of the Builder
        keyGenerator.init(new KeyGenParameterSpec.Builder(keyName,
                KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT)
                .setBlockModes(KeyProperties.BLOCK_MODE_CBC)
                .setUserAuthenticationRequired(true)
                .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_PKCS7)
                .setIsStrongBoxBacked(useStrongBox)
                .setUserAuthenticationParameters(1 /* seconds */, authTypes)
                .build());
        keyGenerator.generateKey();
    }

    public static void generateBiometricBoundKey(String keyName, boolean useStrongBox)
            throws Exception {
        final KeyStore keystore = KeyStore.getInstance(KEYSTORE_PROVIDER);
        keystore.load(null);
        KeyGenParameterSpec.Builder builder = new KeyGenParameterSpec.Builder(
                keyName,
                KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT)
                .setBlockModes(KeyProperties.BLOCK_MODE_CBC)
                .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_PKCS7)
                .setUserAuthenticationRequired(true)
                .setInvalidatedByBiometricEnrollment(true)
                .setIsStrongBoxBacked(useStrongBox)
                .setUserAuthenticationParameters(0, KeyProperties.AUTH_BIOMETRIC_STRONG);

        KeyGenerator keyGenerator = KeyGenerator
                .getInstance(KeyProperties.KEY_ALGORITHM_AES, KEYSTORE_PROVIDER);
        keyGenerator.init(builder.build());

        // Generates and stores the key in Android KeyStore under the keystoreAlias (keyName)
        // specified in the builder.
        keyGenerator.generateKey();
    }

    public static BiometricPrompt.CryptoObject initializeCryptoObject(String keyName)
            throws Exception {
        final KeyStore keystore = KeyStore.getInstance(KEYSTORE_PROVIDER);
        keystore.load(null);
        final SecretKey secretKey = (SecretKey) keystore.getKey(
                keyName, null /* password */);
        final Cipher cipher = Cipher.getInstance(KeyProperties.KEY_ALGORITHM_AES + ""/""
                + KeyProperties.BLOCK_MODE_CBC + ""/""
                + KeyProperties.ENCRYPTION_PADDING_PKCS7);
        cipher.init(Cipher.ENCRYPT_MODE, secretKey);

        final BiometricPrompt.CryptoObject cryptoObject =
                new BiometricPrompt.CryptoObject(cipher);
        return cryptoObject;
    }

    public static boolean isPublicAuthenticatorConstant(int authenticator) {
        switch (authenticator) {
            case BiometricManager.Authenticators.BIOMETRIC_STRONG:
            case BiometricManager.Authenticators.BIOMETRIC_WEAK:
            case BiometricManager.Authenticators.DEVICE_CREDENTIAL:
                return true;
            default:
                return false;
        }
    }

    public static int testApiStrengthToAuthenticatorStrength(int testApiStrength) {
        switch (testApiStrength) {
            case SensorProperties.STRENGTH_STRONG:
                return BiometricManager.Authenticators.BIOMETRIC_STRONG;
            case SensorProperties.STRENGTH_WEAK:
                return BiometricManager.Authenticators.BIOMETRIC_WEAK;
            default:
                throw new IllegalArgumentException(""Unable to convert testApiStrength: ""
                        + testApiStrength);
        }
    }
}"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.jobscheduler.cts.TestAppInterface"	"TestJobState"	"CtsJobSchedulerTestCases"	"/home/gpoor/cts-12-source/cts/tests/JobScheduler/src/android/jobscheduler/cts/TestAppInterface.java"	""	"public void test/*
 *.
 */
package android.jobscheduler.cts;

import static android.app.ActivityManager.getCapabilitiesSummary;
import static android.app.ActivityManager.procStateToString;
import static android.jobscheduler.cts.jobtestapp.TestJobSchedulerReceiver.EXTRA_REQUEST_JOB_UID_STATE;
import static android.jobscheduler.cts.jobtestapp.TestJobService.ACTION_JOB_STARTED;
import static android.jobscheduler.cts.jobtestapp.TestJobService.ACTION_JOB_STOPPED;
import static android.jobscheduler.cts.jobtestapp.TestJobService.INVALID_ADJ;
import static android.jobscheduler.cts.jobtestapp.TestJobService.JOB_CAPABILITIES_KEY;
import static android.jobscheduler.cts.jobtestapp.TestJobService.JOB_OOM_SCORE_ADJ_KEY;
import static android.jobscheduler.cts.jobtestapp.TestJobService.JOB_PARAMS_EXTRA_KEY;
import static android.jobscheduler.cts.jobtestapp.TestJobService.JOB_PROC_STATE_KEY;
import static android.server.wm.WindowManagerState.STATE_RESUMED;

import static org.junit.Assert.assertEquals;

import android.app.ActivityManager;
import android.app.job.JobParameters;
import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.jobscheduler.cts.jobtestapp.TestActivity;
import android.jobscheduler.cts.jobtestapp.TestJobSchedulerReceiver;
import android.os.SystemClock;
import android.os.UserHandle;
import android.server.wm.WindowManagerStateHelper;
import android.util.Log;

import com.android.compatibility.common.util.CallbackAsserter;
import com.android.compatibility.common.util.SystemUtil;

import java.util.Map;

/**
 * Common functions to interact with the test app.
 */
class TestAppInterface {
    private static final String TAG = TestAppInterface.class.getSimpleName();

    static final String TEST_APP_PACKAGE = ""android.jobscheduler.cts.jobtestapp"";
    private static final String TEST_APP_ACTIVITY = TEST_APP_PACKAGE + "".TestActivity"";
    static final String TEST_APP_RECEIVER = TEST_APP_PACKAGE + "".TestJobSchedulerReceiver"";

    private final Context mContext;
    private final int mJobId;

    /* accesses must be synchronized on itself */
    private final TestJobState mTestJobState = new TestJobState();

    TestAppInterface(Context ctx, int jobId) {
        mContext = ctx;
        mJobId = jobId;

        final IntentFilter intentFilter = new IntentFilter();
        intentFilter.addAction(ACTION_JOB_STARTED);
        intentFilter.addAction(ACTION_JOB_STOPPED);
        mContext.registerReceiver(mReceiver, intentFilter);
    }

    void cleanup() {
        final Intent cancelJobsIntent = new Intent(TestJobSchedulerReceiver.ACTION_CANCEL_JOBS);
        cancelJobsIntent.setComponent(new ComponentName(TEST_APP_PACKAGE, TEST_APP_RECEIVER));
        cancelJobsIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        mContext.sendBroadcast(cancelJobsIntent);
        closeActivity();
        mContext.unregisterReceiver(mReceiver);
        mTestJobState.reset();
    }

    void scheduleJob(boolean allowWhileIdle, int requiredNetworkType, boolean asExpeditedJob)
            throws Exception {
        scheduleJob(
                Map.of(
                        TestJobSchedulerReceiver.EXTRA_ALLOW_IN_IDLE, allowWhileIdle,
                        TestJobSchedulerReceiver.EXTRA_AS_EXPEDITED, asExpeditedJob
                ),
                Map.of(
                        TestJobSchedulerReceiver.EXTRA_REQUIRED_NETWORK_TYPE, requiredNetworkType
                ));
    }

    void scheduleJob(Map<String, Boolean> booleanExtras, Map<String, Integer> intExtras)
            throws Exception {
        final Intent scheduleJobIntent = new Intent(TestJobSchedulerReceiver.ACTION_SCHEDULE_JOB);
        scheduleJobIntent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
        scheduleJobIntent.putExtra(TestJobSchedulerReceiver.EXTRA_JOB_ID_KEY, mJobId);
        booleanExtras.forEach(scheduleJobIntent::putExtra);
        intExtras.forEach(scheduleJobIntent::putExtra);
        scheduleJobIntent.setComponent(new ComponentName(TEST_APP_PACKAGE, TEST_APP_RECEIVER));

        final CallbackAsserter resultBroadcastAsserter = CallbackAsserter.forBroadcast(
                new IntentFilter(TestJobSchedulerReceiver.ACTION_JOB_SCHEDULE_RESULT));
        mContext.sendBroadcast(scheduleJobIntent);
        resultBroadcastAsserter.assertCalled(""Didn't get schedule job result broadcast"",
                15 /* 15 seconds */);
    }

    /** Asks (not forces) JobScheduler to run the job if constraints are met. */
    void runSatisfiedJob() throws Exception {
        SystemUtil.runShellCommand(""cmd jobscheduler run -s""
                + "" -u "" + UserHandle.myUserId() + "" "" + TEST_APP_PACKAGE + "" "" + mJobId);
    }

    void startAndKeepTestActivity() {
        startAndKeepTestActivity(false);
    }

    void startAndKeepTestActivity(boolean waitForResume) {
        final Intent testActivity = new Intent();
        testActivity.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        ComponentName testComponentName = new ComponentName(TEST_APP_PACKAGE, TEST_APP_ACTIVITY);
        testActivity.setComponent(testComponentName);
        mContext.startActivity(testActivity);
        if (waitForResume) {
            new WindowManagerStateHelper().waitForActivityState(testComponentName, STATE_RESUMED);
        }
    }

    void closeActivity() {
        mContext.sendBroadcast(new Intent(TestActivity.ACTION_FINISH_ACTIVITY));
    }

    private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            Log.d(TAG, ""Received action "" + intent.getAction());
            switch (intent.getAction()) {
                case ACTION_JOB_STARTED:
                case ACTION_JOB_STOPPED:
                    final JobParameters params = intent.getParcelableExtra(JOB_PARAMS_EXTRA_KEY);
                    Log.d(TAG, ""JobId: "" + params.getJobId());
                    synchronized (mTestJobState) {
                        mTestJobState.running = ACTION_JOB_STARTED.equals(intent.getAction());
                        mTestJobState.jobId = params.getJobId();
                        mTestJobState.params = params;
                        if (intent.getBooleanExtra(EXTRA_REQUEST_JOB_UID_STATE, false)) {
                            mTestJobState.procState = intent.getIntExtra(JOB_PROC_STATE_KEY,
                                    ActivityManager.PROCESS_STATE_NONEXISTENT);
                            mTestJobState.capabilities = intent.getIntExtra(JOB_CAPABILITIES_KEY,
                                    ActivityManager.PROCESS_CAPABILITY_NONE);
                            mTestJobState.oomScoreAdj = intent.getIntExtra(JOB_OOM_SCORE_ADJ_KEY,
                                    INVALID_ADJ);
                        }
                    }
                    break;
            }
        }
    };

    boolean awaitJobStart(long maxWait) throws Exception {
        return waitUntilTrue(maxWait, () -> {
            synchronized (mTestJobState) {
                return (mTestJobState.jobId == mJobId) && mTestJobState.running;
            }
        });
    }

    boolean awaitJobStop(long maxWait) throws Exception {
        return waitUntilTrue(maxWait, () -> {
            synchronized (mTestJobState) {
                return (mTestJobState.jobId == mJobId) && !mTestJobState.running;
            }
        });
    }

    void assertJobUidState(int procState, int capabilities, int oomScoreAdj) {
        synchronized (mTestJobState) {
            assertEquals(""procState expected="" + procStateToString(procState)
                    + "",actual="" + procStateToString(mTestJobState.procState),
                    procState, mTestJobState.procState);
            assertEquals(""capabilities expected="" + getCapabilitiesSummary(capabilities)
                    + "",actual="" + getCapabilitiesSummary(mTestJobState.capabilities),
                    capabilities, mTestJobState.capabilities);
            assertEquals(""Unexpected oomScoreAdj"", oomScoreAdj, mTestJobState.oomScoreAdj);
        }
    }

    private boolean waitUntilTrue(long maxWait, Condition condition) throws Exception {
        final long deadLine = SystemClock.uptimeMillis() + maxWait;
        do {
            Thread.sleep(500);
        } while (!condition.isTrue() && SystemClock.uptimeMillis() < deadLine);
        return condition.isTrue();
    }

    JobParameters getLastParams() {
        synchronized (mTestJobState) {
            return mTestJobState.params;
        }
    }

    private static final class TestJobState {
        int jobId;
        boolean running;
        int procState;
        int capabilities;
        int oomScoreAdj;
        JobParameters params;

        TestJobState() {
            initState();
        }

        private void reset() {
            initState();
        }

        private void initState() {
            running = false;
            procState = ActivityManager.PROCESS_STATE_NONEXISTENT;
            capabilities = ActivityManager.PROCESS_CAPABILITY_NONE;
            oomScoreAdj = INVALID_ADJ;
        }
    }

    private interface Condition {
        boolean isTrue() throws Exception;
    }
}"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.widget.cts.SpinnerTest"	"testDropDownBackgroundDropdownMode"	"CtsWidgetTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/SpinnerTest.java"	""	"public void testDropDownBackgroundDropdownMode() throws Throwable {
        ArrayAdapter<CharSequence> adapter = ArrayAdapter.createFromResource(mActivity,
                R.array.string, android.R.layout.simple_spinner_item);
        adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
        mActivityRule.runOnUiThread(() -> mSpinnerDropdownMode.setAdapter(adapter));

        // Set blue background on the popup
        mActivityRule.runOnUiThread(() ->
                mSpinnerDropdownMode.setPopupBackgroundResource(R.drawable.blue_fill));

        // Use instrumentation to emulate a tap on the spinner to bring down its popup
        CtsTouchUtils.emulateTapOnViewCenter(mInstrumentation, mActivityRule, mSpinnerDropdownMode);
        // Verify that we're showing the popup
        PollingCheck.waitFor(() -> mSpinnerDropdownMode.isPopupShowing());
        // And test its fill
        Drawable dropDownBackground = mSpinnerDropdownMode.getPopupBackground();
        TestUtils.assertAllPixelsOfColor(""Drop down should be blue"", dropDownBackground,
                dropDownBackground.getBounds().width(), dropDownBackground.getBounds().height(),
                false, Color.BLUE, 1, true);
        waitForHasFocusMS(SPINNER_HAS_FOCUS_DELAY_MS);
        // Dismiss the popup with the emulated back key
        mInstrumentation.sendKeyDownUpSync(KeyEvent.KEYCODE_BACK);
        // Verify that we're not showing the popup
        PollingCheck.waitFor(() -> !mSpinnerDropdownMode.isPopupShowing());

        // Set yellow background on the popup
        mActivityRule.runOnUiThread(() ->
                mSpinnerDropdownMode.setPopupBackgroundDrawable(
                        mActivity.getDrawable(R.drawable.yellow_fill)));

        // Use instrumentation to emulate a tap on the spinner to bring down its popup
        WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, mSpinnerDropdownMode, () -> {
            mSpinnerDropdownMode.performClick();
        });
        // Verify that we're showing the popup
        PollingCheck.waitFor(() -> mSpinnerDropdownMode.isPopupShowing());
        // And test its fill
        dropDownBackground = mSpinnerDropdownMode.getPopupBackground();
        TestUtils.assertAllPixelsOfColor(""Drop down should be yellow"", dropDownBackground,
                dropDownBackground.getBounds().width(), dropDownBackground.getBounds().height(),
                false, Color.YELLOW, 1, true);
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.widget.cts.SpinnerTest"	"testDropDownBackgroundDialogMode"	"CtsWidgetTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/SpinnerTest.java"	""	"public void testDropDownBackgroundDialogMode() throws Throwable {
        ArrayAdapter<CharSequence> adapter = ArrayAdapter.createFromResource(mActivity,
                R.array.string, android.R.layout.simple_spinner_item);
        adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
        mActivityRule.runOnUiThread(() -> mSpinnerDialogMode.setAdapter(adapter));

        // Set blue background on the popup
        mActivityRule.runOnUiThread(() ->
                mSpinnerDialogMode.setPopupBackgroundResource(R.drawable.blue_fill));

        // Use instrumentation to emulate a tap on the spinner to bring down its popup
        CtsTouchUtils.emulateTapOnViewCenter(mInstrumentation, null, mSpinnerDialogMode);
        // Verify that we're showing the popup
        PollingCheck.waitFor(() -> mSpinnerDialogMode.isPopupShowing());
        // And test that getPopupBackground returns null
        assertNull(mSpinnerDialogMode.getPopupBackground());

        // Dismiss the popup with the emulated back key
        mInstrumentation.sendKeyDownUpSync(KeyEvent.KEYCODE_BACK);
        // Verify that we're not showing the popup
        PollingCheck.waitFor(() -> !mSpinnerDropdownMode.isPopupShowing());

        // Set yellow background on the popup
        mActivityRule.runOnUiThread(() ->
                mSpinnerDialogMode.setPopupBackgroundDrawable(
                        mActivity.getDrawable(R.drawable.yellow_fill)));

        // Use instrumentation to emulate a tap on the spinner to bring down its popup
        WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, mSpinnerDialogMode, () -> {
            mSpinnerDialogMode.performClick();
        });
        // Verify that we're showing the popup
        PollingCheck.waitFor(() -> mSpinnerDialogMode.isPopupShowing());
        // And test that getPopupBackground returns null
        assertNull(mSpinnerDialogMode.getPopupBackground());
    }

    private void waitForHasFocusMS(int milliseconds) {
        try {
            Thread.sleep(milliseconds);
        } catch (InterruptedException e) {
            fail(""unexpected InterruptedException : ""+ e);
        }

    }
}"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.app.cts.InstrumentationTest"	"testSendKeyDownUpSync"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/InstrumentationTest.java"	""	"public void testSendKeyDownUpSync() throws Exception {
        mInstrumentation.sendKeyDownUpSync(KeyEvent.KEYCODE_0);
        mInstrumentation.waitForIdleSync();
        assertEquals(1, mActivity.getKeyUpList().size());
        assertEquals(1, mActivity.getKeyDownList().size());
        assertEquals(KeyEvent.KEYCODE_0, mActivity.getKeyUpList().get(0).getKeyCode());
        assertEquals(KeyEvent.KEYCODE_0, mActivity.getKeyDownList().get(0).getKeyCode());
    }

    @UiThreadTest"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.app.cts.InstrumentationTest"	"testSendKeySync"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/InstrumentationTest.java"	""	"public void testSendKeySync() throws Exception {
        KeyEvent key = new KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_0);
        mInstrumentation.sendKeySync(key);
        mInstrumentation.waitForIdleSync();
        assertEquals(KeyEvent.KEYCODE_0, mActivity.getKeyDownCode());
    }

    private static class MockRunnable implements Runnable {
        private boolean mIsRunCalled ;

        public void run() {
            mIsRunCalled = true;
        }

        public boolean isRunCalled() {
            return mIsRunCalled;
        }
    }

    private class MockActivity extends Activity {
        MockWindow mWindow = new MockWindow(mContext);

        @Override
        public Window getWindow() {
            return mWindow;
        }

        private class MockWindow extends Window {

            public int mId;
            public int mFlags;

            public MockWindow(Context context) {
                super(context);
            }

            @Override
            public void addContentView(View view, LayoutParams params) {
            }

            @Override
            public void closeAllPanels() {
            }

            @Override
            public void closePanel(int featureId) {
            }

            @Override
            public View getCurrentFocus() {
                return null;
            }

            @Override
            public View getDecorView() {
                return null;
            }

            @Override
            public LayoutInflater getLayoutInflater() {
                return null;
            }

            @Override
            public int getVolumeControlStream() {
                return 0;
            }

            @Override
            public boolean isFloating() {
                return false;
            }

            @Override
            public boolean isShortcutKey(int keyCode, KeyEvent event) {
                return false;
            }

            @Override
            protected void onActive() {
            }

            @Override
            public void onConfigurationChanged(Configuration newConfig) {
            }

            @Override
            public void openPanel(int featureId, KeyEvent event) {
            }

            public void alwaysReadCloseOnTouchAttr() {
            }

            @Override
            public View peekDecorView() {
                return null;
            }

            @Override
            public boolean performContextMenuIdentifierAction(int id, int flags) {
                mId = id;
                mFlags = flags;
                return false;
            }

            @Override
            public boolean performPanelIdentifierAction(int featureId, int id, int flags) {
                return false;
            }

            @Override
            public boolean performPanelShortcut(int featureId, int keyCode,
                    KeyEvent event, int flags) {
                return false;
            }

            @Override
            public void restoreHierarchyState(Bundle savedInstanceState) {
            }

            @Override
            public Bundle saveHierarchyState() {
                return null;
            }

            @Override
            public void setBackgroundDrawable(Drawable drawable) {
            }

            @Override
            public void setChildDrawable(int featureId, Drawable drawable) {
            }

            @Override
            public void setChildInt(int featureId, int value) {
            }

            @Override
            public void setContentView(int layoutResID) {
            }

            @Override
            public void setContentView(View view) {
            }

            @Override
            public void setContentView(View view, LayoutParams params) {
            }

            @Override
            public void setFeatureDrawable(int featureId, Drawable drawable) {
            }

            @Override
            public void setFeatureDrawableAlpha(int featureId, int alpha) {
            }

            @Override
            public void setFeatureDrawableResource(int featureId, int resId) {
            }

            @Override
            public void setFeatureDrawableUri(int featureId, Uri uri) {
            }

            @Override
            public void setFeatureInt(int featureId, int value) {
            }

            @Override
            public void setTitle(CharSequence title) {
            }

            @Override
            public void setTitleColor(int textColor) {
            }

            @Override
            public void setVolumeControlStream(int streamType) {
            }

            @Override
            public boolean superDispatchKeyEvent(KeyEvent event) {
                return false;
            }

            @Override
            public boolean superDispatchKeyShortcutEvent(KeyEvent event) {
                return false;
            }

            @Override
            public boolean superDispatchTouchEvent(MotionEvent event) {
                return false;
            }

            @Override
            public boolean superDispatchTrackballEvent(MotionEvent event) {
                return false;
            }

            @Override
            public boolean superDispatchGenericMotionEvent(MotionEvent event) {
                return false;
            }

            @Override
            public void takeKeyEvents(boolean get) {
            }

            @Override
            public void togglePanel(int featureId, KeyEvent event) {
            }

            @Override
            public void invalidatePanelMenu(int featureId) {
            }

            @Override
            public void takeSurface(SurfaceHolder.Callback2 callback) {
            }

            @Override
            public void takeInputQueue(InputQueue.Callback queue) {
            }

            @Override
            public void setStatusBarColor(int color) {
            }

            @Override
            public int getStatusBarColor() {
                return 0;
            }

            @Override
            public void setNavigationBarColor(int color) {
            }

            @Override
            public void setDecorCaptionShade(int decorCaptionShade) {
            }

            @Override
            public void setResizingCaptionDrawable(Drawable drawable) {
            }

            @Override
            public int getNavigationBarColor() {
                return 0;
            }
        }
    }

    private static class InstrumentationTestStub extends Application {
        boolean mIsOnCreateCalled = false;

        @Override
        public void onCreate() {
            super.onCreate();
            mIsOnCreateCalled = true;
        }
    }
}"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"com.android.cts.atracetestapp.AtraceNdkMethods"	"isEnabled"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/atrace/AtraceTestApp/src/com/android/cts/atracetestapp/AtraceNdkMethods.java"	""	"public void test/*
 *.
 */

package com.android.cts.atracetestapp;

public class AtraceNdkMethods {
    public static native boolean isEnabled();
    public static native void beginEndSection();
    public static native void asyncBeginEndSection();
    public static native void counter();
}"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.text.method.cts.TextKeyListenerTest"	"testPressKey"	"CtsTextTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/text/src/android/text/method/cts/TextKeyListenerTest.java"	""	"public void testPressKey() throws Throwable {
        final TextKeyListener textKeyListener
                = TextKeyListener.getInstance(false, Capitalize.NONE);

        mActivityRule.runOnUiThread(() -> {
            mTextView.setText("""", BufferType.EDITABLE);
            Selection.setSelection(mTextView.getText(), 0, 0);
            mTextView.setKeyListener(textKeyListener);
            mTextView.requestFocus();
        });
        mInstrumentation.waitForIdleSync();
        assertEquals("""", mTextView.getText().toString());

        CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, KeyEvent.KEYCODE_4);
        waitForListenerTimeout();
        String text = mTextView.getText().toString();
        int keyType = KeyCharacterMap.load(KeyCharacterMap.VIRTUAL_KEYBOARD).getKeyboardType();
        if (KeyCharacterMap.ALPHA == keyType
                || KeyCharacterMap.FULL == keyType) {
            assertEquals(""4"", text);
        } else if (KeyCharacterMap.NUMERIC == keyType) {
            assertEquals(""g"", text);
        } else {
            assertEquals("""", text);
        }

        textKeyListener.release();
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.text.method.cts.TextKeyListenerTest"	"testOnKeyOther"	"CtsTextTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/text/src/android/text/method/cts/TextKeyListenerTest.java"	""	"public void testOnKeyOther() throws Throwable {
        final String text = ""abcd"";
        final TextKeyListener textKeyListener
                = TextKeyListener.getInstance(false, Capitalize.NONE);

        mActivityRule.runOnUiThread(() -> {
            mTextView.setText("""", BufferType.EDITABLE);
            Selection.setSelection(mTextView.getText(), 0, 0);
            mTextView.setKeyListener(textKeyListener);
        });
        mInstrumentation.waitForIdleSync();
        assertEquals("""", mTextView.getText().toString());

        // test ACTION_MULTIPLE KEYCODE_UNKNOWN key event.
        KeyEvent event = new KeyEvent(SystemClock.uptimeMillis(), text,
                1, KeyEvent.FLAG_WOKE_HERE);
        CtsKeyEventUtil.sendKey(mInstrumentation, mTextView, event);
        mInstrumentation.waitForIdleSync();
        // the text of TextView is never changed, onKeyOther never works.
//        assertEquals(text, mTextView.getText().toString()); issue 1731439

        textKeyListener.release();
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.view.cts.ViewTest"	"testOnKeyShortcut"	"CtsViewTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/view/src/android/view/cts/ViewTest.java"	""	"public void testOnKeyShortcut() throws Throwable {
        final MockView view = (MockView) mActivity.findViewById(R.id.mock_view);
        mActivityRule.runOnUiThread(() -> {
            view.setFocusable(true);
            view.requestFocus();
        });
        mInstrumentation.waitForIdleSync();
        assertTrue(view.isFocused());

        KeyEvent event = new KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_MENU);
        mInstrumentation.sendKeySync(event);
        event = new KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_0);
        mInstrumentation.sendKeySync(event);
        assertTrue(view.hasCalledOnKeyShortcut());
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.view.cts.ViewTest"	"testDispatchUnhandledMove"	"CtsViewTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/view/src/android/view/cts/ViewTest.java"	""	"public void testDispatchUnhandledMove() throws Throwable {
        final MockView view = (MockView) mActivity.findViewById(R.id.mock_view);
        mActivityRule.runOnUiThread(() -> {
            view.setFocusable(true);
            view.requestFocus();
        });
        mInstrumentation.waitForIdleSync();

        KeyEvent event = new KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_DPAD_RIGHT);
        mInstrumentation.sendKeySync(event);

        assertTrue(view.hasCalledDispatchUnhandledMove());
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.view.cts.ViewTest"	"testUnhandledKeys"	"CtsViewTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/view/src/android/view/cts/ViewTest.java"	""	"public void testUnhandledKeys() throws Throwable {
        MockUnhandledKeyListener listener = new MockUnhandledKeyListener();
        ViewGroup viewGroup = (ViewGroup) mActivity.findViewById(R.id.viewlayout_root);
        // Attaching a fallback handler
        TextView mockView1 = new TextView(mActivity);
        mockView1.addOnUnhandledKeyEventListener(listener);

        // Before the view is attached, it shouldn't respond to anything
        mInstrumentation.sendKeyDownUpSync(KeyEvent.KEYCODE_B);
        assertFalse(listener.fired());

        // Once attached, it should start receiving fallback events
        mActivityRule.runOnUiThread(() -> viewGroup.addView(mockView1));
        mInstrumentation.waitForIdleSync();
        mInstrumentation.sendKeyDownUpSync(KeyEvent.KEYCODE_B);
        assertTrue(listener.fired());
        listener.reset();

        // If multiple on one view, last added should receive event first
        MockUnhandledKeyListener listener2 = new MockUnhandledKeyListener();
        listener2.mReturnVal = true;
        mActivityRule.runOnUiThread(() -> mockView1.addOnUnhandledKeyEventListener(listener2));
        mInstrumentation.waitForIdleSync();
        mInstrumentation.sendKeyDownUpSync(KeyEvent.KEYCODE_B);
        assertTrue(listener2.fired());
        assertFalse(listener.fired());
        listener2.reset();

        // If removed, it should not receive fallbacks anymore
        mActivityRule.runOnUiThread(() -> {
            mockView1.removeOnUnhandledKeyEventListener(listener);
            mockView1.removeOnUnhandledKeyEventListener(listener2);
        });
        mInstrumentation.waitForIdleSync();
        mInstrumentation.sendKeyDownUpSync(KeyEvent.KEYCODE_B);
        assertFalse(listener.fired());

        mActivityRule.runOnUiThread(() -> mActivity.setContentView(R.layout.key_fallback_layout));
        mInstrumentation.waitForIdleSync();
        View higherInNormal = mActivity.findViewById(R.id.higher_in_normal);
        View higherGroup = mActivity.findViewById(R.id.higher_group);
        View lowerInHigher = mActivity.findViewById(R.id.lower_in_higher);
        View lastButton = mActivity.findViewById(R.id.last_button);
        View lastInHigher = mActivity.findViewById(R.id.last_in_higher);
        View lastInNormal = mActivity.findViewById(R.id.last_in_normal);

        View[] allViews = new View[]{higherInNormal, higherGroup, lowerInHigher, lastButton,
                lastInHigher, lastInNormal};

        // Test ordering by depth
        listener.mReturnVal = true;
        mActivityRule.runOnUiThread(() -> {
            for (View v : allViews) {
                v.addOnUnhandledKeyEventListener(listener);
            }
        });
        mInstrumentation.waitForIdleSync();

        mInstrumentation.sendKeyDownUpSync(KeyEvent.KEYCODE_B);
        assertEquals(lastInHigher, listener.mLastView);
        listener.reset();

        mActivityRule.runOnUiThread(
                () -> lastInHigher.removeOnUnhandledKeyEventListener(listener));
        mInstrumentation.waitForIdleSync();
        mInstrumentation.sendKeyDownUpSync(KeyEvent.KEYCODE_B);
        assertEquals(lowerInHigher, listener.mLastView);
        listener.reset();

        mActivityRule.runOnUiThread(
                () -> lowerInHigher.removeOnUnhandledKeyEventListener(listener));
        mInstrumentation.waitForIdleSync();
        mInstrumentation.sendKeyDownUpSync(KeyEvent.KEYCODE_B);
        assertEquals(higherGroup, listener.mLastView);
        listener.reset();

        mActivityRule.runOnUiThread(() -> higherGroup.removeOnUnhandledKeyEventListener(listener));
        mInstrumentation.waitForIdleSync();
        mInstrumentation.sendKeyDownUpSync(KeyEvent.KEYCODE_B);
        assertEquals(lastButton, listener.mLastView);
        listener.reset();

        mActivityRule.runOnUiThread(() -> lastButton.removeOnUnhandledKeyEventListener(listener));
        mInstrumentation.waitForIdleSync();
        mInstrumentation.sendKeyDownUpSync(KeyEvent.KEYCODE_B);
        assertEquals(higherInNormal, listener.mLastView);
        listener.reset();

        mActivityRule.runOnUiThread(
                () -> higherInNormal.removeOnUnhandledKeyEventListener(listener));
        mInstrumentation.waitForIdleSync();
        mInstrumentation.sendKeyDownUpSync(KeyEvent.KEYCODE_B);
        assertEquals(lastInNormal, listener.mLastView);
        listener.reset();

        // Test ""capture""
        mActivityRule.runOnUiThread(() -> lastInNormal.requestFocus());
        mInstrumentation.waitForIdleSync();
        lastInNormal.setOnKeyListener((v, keyCode, event)
                -> (keyCode == KeyEvent.KEYCODE_B && event.getAction() == KeyEvent.ACTION_UP));
        mInstrumentation.sendKeyDownUpSync(KeyEvent.KEYCODE_B);
        assertTrue(listener.fired()); // checks that both up and down were received
        listener.reset();
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.view.cts.ViewTest"	"testOnKeyDownOrUp"	"CtsViewTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/view/src/android/view/cts/ViewTest.java"	""	"public void testOnKeyDownOrUp() throws Throwable {
        final MockView view = (MockView) mActivity.findViewById(R.id.mock_view);
        mActivityRule.runOnUiThread(() -> {
            view.setFocusable(true);
            view.requestFocus();
        });
        mInstrumentation.waitForIdleSync();
        assertTrue(view.isFocused());

        KeyEvent event = new KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_0);
        mInstrumentation.sendKeySync(event);
        assertTrue(view.hasCalledOnKeyDown());

        event = new KeyEvent(KeyEvent.ACTION_UP, KeyEvent.KEYCODE_0);
        mInstrumentation.sendKeySync(event);
        assertTrue(view.hasCalledOnKeyUp());

        view.reset();
        assertTrue(view.isEnabled());
        assertFalse(view.isClickable());
        assertFalse(view.isPressed());
        event = new KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_ENTER);
        mInstrumentation.sendKeySync(event);
        assertFalse(view.isPressed());
        assertTrue(view.hasCalledOnKeyDown());

        mActivityRule.runOnUiThread(() -> {
            view.setEnabled(true);
            view.setClickable(true);
        });
        view.reset();
        View.OnClickListener listener = mock(View.OnClickListener.class);
        view.setOnClickListener(listener);

        assertFalse(view.isPressed());
        event = new KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_ENTER);
        mInstrumentation.sendKeySync(event);
        assertTrue(view.isPressed());
        assertTrue(view.hasCalledOnKeyDown());
        event = new KeyEvent(KeyEvent.ACTION_UP, KeyEvent.KEYCODE_ENTER);
        mInstrumentation.sendKeySync(event);
        assertFalse(view.isPressed());
        assertTrue(view.hasCalledOnKeyUp());
        verify(listener, times(1)).onClick(view);

        view.setPressed(false);
        reset(listener);
        view.reset();

        assertFalse(view.isPressed());
        event = new KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_DPAD_CENTER);
        mInstrumentation.sendKeySync(event);
        assertTrue(view.isPressed());
        assertTrue(view.hasCalledOnKeyDown());
        event = new KeyEvent(KeyEvent.ACTION_UP, KeyEvent.KEYCODE_DPAD_CENTER);
        mInstrumentation.sendKeySync(event);
        assertFalse(view.isPressed());
        assertTrue(view.hasCalledOnKeyUp());
        verify(listener, times(1)).onClick(view);
    }

    private void checkBounds(final ViewGroup viewGroup, final View view,
            final CountDownLatch countDownLatch, final int left, final int top,
            final int width, final int height) {
        viewGroup.getViewTreeObserver().addOnPreDrawListener(
                new ViewTreeObserver.OnPreDrawListener() {
            @Override
            public boolean onPreDraw() {
                assertEquals(left, view.getLeft());
                assertEquals(top, view.getTop());
                assertEquals(width, view.getWidth());
                assertEquals(height, view.getHeight());
                countDownLatch.countDown();
                viewGroup.getViewTreeObserver().removeOnPreDrawListener(this);
                return true;
            }
        });
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.view.cts.ViewTest"	"testTouchMode"	"CtsViewTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/view/src/android/view/cts/ViewTest.java"	""	"public void testTouchMode() throws Throwable {
        final MockView mockView = (MockView) mActivity.findViewById(R.id.mock_view);
        final View fitWindowsView = mActivity.findViewById(R.id.fit_windows);
        mActivityRule.runOnUiThread(() -> {
            mockView.setFocusableInTouchMode(true);
            fitWindowsView.setFocusable(true);
            fitWindowsView.requestFocus();
        });
        mInstrumentation.waitForIdleSync();
        assertTrue(mockView.isFocusableInTouchMode());
        assertFalse(fitWindowsView.isFocusableInTouchMode());
        assertTrue(mockView.isFocusable());
        assertTrue(fitWindowsView.isFocusable());
        assertFalse(mockView.isFocused());
        assertTrue(fitWindowsView.isFocused());
        assertFalse(mockView.isInTouchMode());
        assertFalse(fitWindowsView.isInTouchMode());

        CtsTouchUtils.emulateTapOnViewCenter(mInstrumentation, mActivityRule, mockView);
        assertFalse(fitWindowsView.isFocused());
        assertFalse(mockView.isFocused());
        mActivityRule.runOnUiThread(mockView::requestFocus);
        mInstrumentation.waitForIdleSync();
        assertTrue(mockView.isFocused());
        mActivityRule.runOnUiThread(fitWindowsView::requestFocus);
        mInstrumentation.waitForIdleSync();
        assertFalse(fitWindowsView.isFocused());
        assertTrue(mockView.isInTouchMode());
        assertTrue(fitWindowsView.isInTouchMode());

        KeyEvent keyEvent = new KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_0);
        mInstrumentation.sendKeySync(keyEvent);
        assertTrue(mockView.isFocused());
        assertFalse(fitWindowsView.isFocused());
        mActivityRule.runOnUiThread(fitWindowsView::requestFocus);
        mInstrumentation.waitForIdleSync();
        assertFalse(mockView.isFocused());
        assertTrue(fitWindowsView.isFocused());
        assertFalse(mockView.isInTouchMode());
        assertFalse(fitWindowsView.isInTouchMode());

        // Mouse events should trigger touch mode.
        final MotionEvent event =
                CtsMouseUtil.obtainMouseEvent(MotionEvent.ACTION_SCROLL, mockView, 0, 0);
        mInstrumentation.sendPointerSync(event);
        assertTrue(fitWindowsView.isInTouchMode());

        mInstrumentation.sendKeySync(keyEvent);
        assertFalse(fitWindowsView.isInTouchMode());

        event.setAction(MotionEvent.ACTION_DOWN);
        mInstrumentation.sendPointerSync(event);
        assertTrue(fitWindowsView.isInTouchMode());

        mInstrumentation.sendKeySync(keyEvent);
        assertFalse(fitWindowsView.isInTouchMode());

        // Stylus events should trigger touch mode.
        event.setSource(InputDevice.SOURCE_STYLUS);
        mInstrumentation.sendPointerSync(event);
        assertTrue(fitWindowsView.isInTouchMode());
    }

    @UiThreadTest"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.view.cts.ViewTest"	"testKeyPreIme"	"CtsViewTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/view/src/android/view/cts/ViewTest.java"	""	"public void testKeyPreIme() throws Throwable {
        final MockView view = (MockView) mActivity.findViewById(R.id.mock_view);

        mActivityRule.runOnUiThread(() -> {
            view.setFocusable(true);
            view.requestFocus();
        });
        mInstrumentation.waitForIdleSync();

        mInstrumentation.sendKeySync(new KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_BACK));
        assertTrue(view.hasCalledDispatchKeyEventPreIme());
        assertTrue(view.hasCalledOnKeyPreIme());
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.webkit.cts.WebViewTest"	"testRequestFocusNodeHref"	"CtsWebkitTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/webkit/src/android/webkit/cts/WebViewTest.java"	""	"public void testRequestFocusNodeHref() throws Throwable {
        if (!NullWebViewUtils.isWebViewAvailable()) {
            return;
        }
        startWebServer(false);
        String url1 = mWebServer.getAssetUrl(TestHtmlConstants.HTML_URL1);
        String url2 = mWebServer.getAssetUrl(TestHtmlConstants.HTML_URL2);
        final String links = ""<DL><p><DT><A HREF=\"""" + url1
                + ""\"">HTML_URL1</A><DT><A HREF=\"""" + url2
                + ""\"">HTML_URL2</A></DL><p>"";
        mOnUiThread.loadDataAndWaitForCompletion(""<html><body>"" + links + ""</body></html>"", ""text/html"", null);
        getInstrumentation().waitForIdleSync();

        final HrefCheckHandler handler = new HrefCheckHandler(mWebView.getHandler().getLooper());
        final Message hrefMsg = new Message();
        hrefMsg.setTarget(handler);

        // focus on first link
        handler.reset();
        getInstrumentation().sendKeyDownUpSync(KeyEvent.KEYCODE_TAB);
        mOnUiThread.requestFocusNodeHref(hrefMsg);
        new PollingCheck() {
            @Override
            protected boolean check() {
                boolean done = false;
                if (handler.hasCalledHandleMessage()) {
                    if (handler.mResultUrl != null) {
                        done = true;
                    } else {
                        handler.reset();
                        Message newMsg = new Message();
                        newMsg.setTarget(handler);
                        mOnUiThread.requestFocusNodeHref(newMsg);
                    }
                }
                return done;
            }
        }.run();
        assertEquals(url1, handler.getResultUrl());

        // focus on second link
        handler.reset();
        final Message hrefMsg2 = new Message();
        hrefMsg2.setTarget(handler);
        getInstrumentation().sendKeyDownUpSync(KeyEvent.KEYCODE_TAB);
        mOnUiThread.requestFocusNodeHref(hrefMsg2);
        new PollingCheck() {
            @Override
            protected boolean check() {
                boolean done = false;
                final String url2 = mWebServer.getAssetUrl(TestHtmlConstants.HTML_URL2);
                if (handler.hasCalledHandleMessage()) {
                    if (handler.mResultUrl != null &&
                            handler.mResultUrl.equals(url2)) {
                        done = true;
                    } else {
                        handler.reset();
                        Message newMsg = new Message();
                        newMsg.setTarget(handler);
                        mOnUiThread.requestFocusNodeHref(newMsg);
                    }
                }
                return done;
            }
        }.run();
        assertEquals(url2, handler.getResultUrl());

        mOnUiThread.requestFocusNodeHref(null);
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.webkit.cts.WebViewTest"	"testStartSafeBrowsingInvokesCallback"	"CtsWebkitTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/webkit/src/android/webkit/cts/WebViewTest.java"	""	"public void testStartSafeBrowsingInvokesCallback() throws Exception {
        if (!NullWebViewUtils.isWebViewAvailable()) {
            return;
        }

        final SettableFuture<Boolean> startSafeBrowsingFuture = SettableFuture.create();
        WebView.startSafeBrowsing(getActivity().getApplicationContext(),
                new ValueCallback<Boolean>() {
            @Override
            public void onReceiveValue(Boolean value) {
                startSafeBrowsingFuture.set(Looper.getMainLooper().isCurrentThread());
                return;
            }
        });
        assertTrue(WebkitUtils.waitForFuture(startSafeBrowsingFuture));
    }

    private void savePrintedPage(final PrintDocumentAdapter adapter,
            final ParcelFileDescriptor descriptor, final PageRange[] pageRanges,
            final SettableFuture<Void> result) {
        adapter.onWrite(pageRanges, descriptor,
                new CancellationSignal(),
                new WriteResultCallback() {
                    @Override
                    public void onWriteFinished(PageRange[] pages) {
                        try {
                            descriptor.close();
                            result.set(null);
                        } catch (IOException ex) {
                            result.setException(ex);
                        }
                    }
                });
    }

    private void printDocumentStart(final PrintDocumentAdapter adapter) {
        WebkitUtils.onMainThreadSync(() -> {
            adapter.onStart();
        });
    }

    private void printDocumentLayout(final PrintDocumentAdapter adapter,
            final PrintAttributes oldAttributes, final PrintAttributes newAttributes,
            final LayoutResultCallback layoutResultCallback) {
        WebkitUtils.onMainThreadSync(() -> {
            adapter.onLayout(oldAttributes, newAttributes, new CancellationSignal(),
                    layoutResultCallback, null);
        });
    }

    private static class HrefCheckHandler extends Handler {
        private boolean mHadRecieved;

        private String mResultUrl;

        public HrefCheckHandler(Looper looper) {
            super(looper);
        }

        public boolean hasCalledHandleMessage() {
            return mHadRecieved;
        }

        public String getResultUrl() {
            return mResultUrl;
        }

        public void reset(){
            mResultUrl = null;
            mHadRecieved = false;
        }

        @Override
        public void handleMessage(Message msg) {
            mResultUrl = msg.getData().getString(""url"");
            mHadRecieved = true;
        }
    }

    private void moveFocusDown() throws Throwable {
        // send down key and wait for idle
        getInstrumentation().sendKeyDownUpSync(KeyEvent.KEYCODE_TAB);
        // waiting for idle isn't always sufficient for the key to be fully processed
        Thread.sleep(500);
    }

    private void pollingCheckWebBackForwardList(final String currUrl, final int currIndex,
            final int size) {
        new PollingCheck() {
            @Override
            protected boolean check() {
                WebBackForwardList list = mWebView.copyBackForwardList();
                return checkWebBackForwardList(list, currUrl, currIndex, size);
            }
        }.run();
    }

    private boolean checkWebBackForwardList(WebBackForwardList list, String currUrl,
            int currIndex, int size) {
        return (list != null)
                && (list.getSize() == size)
                && (list.getCurrentIndex() == currIndex)
                && list.getItemAtIndex(currIndex).getUrl().equals(currUrl);
    }

    private void assertGoBackOrForwardBySteps(boolean expected, int steps) {
        // skip if steps equals to 0
        if (steps == 0)
            return;

        int start = steps > 0 ? 1 : steps;
        int end = steps > 0 ? steps : -1;

        // check all the steps in the history
        for (int i = start; i <= end; i++) {
            assertEquals(expected, mWebView.canGoBackOrForward(i));

            // shortcut methods for one step
            if (i == 1) {
                assertEquals(expected, mWebView.canGoForward());
            } else if (i == -1) {
                assertEquals(expected, mWebView.canGoBack());
            }
        }
    }

    private boolean isPictureFilledWithColor(Picture picture, int color) {
        if (picture.getWidth() == 0 || picture.getHeight() == 0)
            return false;

        Bitmap bitmap = Bitmap.createBitmap(picture.getWidth(), picture.getHeight(),
                Config.ARGB_8888);
        picture.draw(new Canvas(bitmap));

        for (int i = 0; i < bitmap.getWidth(); i ++) {
            for (int j = 0; j < bitmap.getHeight(); j ++) {
                if (color != bitmap.getPixel(i, j)) {
                    return false;
                }
            }
        }
        return true;
    }

    /**
     * Waits at least MIN_SCROLL_WAIT_MS for scrolling to start. Once started,
     * scrolling is checked every SCROLL_WAIT_INTERVAL_MS for changes. Once
     * changes have stopped, the function exits. If no scrolling has happened
     * then the function exits after MIN_SCROLL_WAIT milliseconds.
     * @param previousScrollY The Y scroll position prior to waiting.
     */
    private void waitForScrollingComplete(int previousScrollY)
            throws InterruptedException {
        int scrollY = previousScrollY;
        // wait at least MIN_SCROLL_WAIT for something to happen.
        long noChangeMinWait = SystemClock.uptimeMillis() + MIN_SCROLL_WAIT_MS;
        boolean scrollChanging = false;
        boolean scrollChanged = false;
        boolean minWaitExpired = false;
        while (scrollChanging || (!scrollChanged && !minWaitExpired)) {
            Thread.sleep(SCROLL_WAIT_INTERVAL_MS);
            int oldScrollY = scrollY;
            scrollY = mOnUiThread.getScrollY();
            scrollChanging = (scrollY != oldScrollY);
            scrollChanged = (scrollY != previousScrollY);
            minWaitExpired = (SystemClock.uptimeMillis() > noChangeMinWait);
        }
    }

    /**
     * This should remain functionally equivalent to
     * androidx.webkit.WebViewCompatTest#testGetSafeBrowsingPrivacyPolicyUrl. Modifications to this
     * test should be reflected in that test as necessary. See http://go/modifying-webview-cts.
     */"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.media.cts.NdkMediaCodec"	"AMediaCodecCreatePersistentInputSurface"	""	"/home/gpoor/cts-12-source/cts/tests/tests/media/common/src/android/media/cts/NdkMediaCodec.java"	""	"public void test/*
 *.
 */

package android.media.cts;

import android.media.MediaCodec;
import android.media.MediaCodec.BufferInfo;
import android.media.MediaCodec.Callback;
import android.media.MediaFormat;
import android.os.Build;
import android.os.Bundle;
import android.util.Log;
import android.view.Surface;

import com.android.compatibility.common.util.ApiLevelUtil;

import java.nio.ByteBuffer;

public class NdkMediaCodec implements MediaCodecWrapper {

    private static final String CSD_0 = ""csd-0"";
    private static final String CSD_1 = ""csd-1"";
    private static final String CSD_2 = ""csd-2"";
    private long mNdkMediaCodec;
    private final String mName;

    static {
        Log.i(""@@@"", ""before loadlibrary"");
        System.loadLibrary(""ctsmediacodec_jni"");
        Log.i(""@@@"", ""after loadlibrary"");
    }

    private static native long AMediaCodecCreateCodecByName(String name);
    private static native boolean AMediaCodecDelete(long ndkMediaCodec);
    private static native boolean AMediaCodecStart(long ndkMediaCodec);
    private static native boolean AMediaCodecStop(long ndkMediaCodec);
    private static native String AMediaCodecGetOutputFormatString(long ndkMediaCodec);
    private static native boolean AMediaCodecSetInputSurface(long ndkMediaCodec, Surface surface);
    private static native boolean AMediaCodecSetNativeInputSurface(long ndkMediaCodec, long aNativeWindow);
    private static native long AMediaCodecCreateInputSurface(long ndkMediaCodec);
    private static native long AMediaCodecCreatePersistentInputSurface();
    private static native boolean AMediaCodecSignalEndOfInputStream(long ndkMediaCodec);
    private static native boolean AMediaCodecReleaseOutputBuffer(long ndkMediaCodec, int index, boolean render);
    private static native ByteBuffer AMediaCodecGetOutputBuffer(long ndkMediaCodec, int index);
    private static native long[] AMediaCodecDequeueOutputBuffer(long ndkMediaCodec, long timeoutUs);
    private static native ByteBuffer AMediaCodecGetInputBuffer(long ndkMediaCodec, int index);
    private static native int AMediaCodecDequeueInputBuffer(long ndkMediaCodec, long timeoutUs);
    private static native boolean AMediaCodecSetParameter(long ndkMediaCodec, String key, int value);

    private static native boolean AMediaCodecConfigure(
            long ndkMediaCodec,
            String mime,
            int width,
            int height,
            int colorFormat,
            int bitRate,
            int frameRate,
            int iFrameInterval,
            ByteBuffer csd0,
            ByteBuffer csd1,
            int flags,
            int lowLatency,
            Surface surface,
            int range,
            int standard,
            int transfer);

    private static native boolean AMediaCodecQueueInputBuffer(
            long ndkMediaCodec,
            int index,
            int offset,
            int size,
            long presentationTimeUs,
            int flags);

    public NdkMediaCodec(String name) {
        mName = name;
        mNdkMediaCodec = AMediaCodecCreateCodecByName(name);
    }

    @Override
    protected void finalize() throws Throwable {
        AMediaCodecDelete(mNdkMediaCodec);
    }

    @Override
    public void release() {
        AMediaCodecDelete(mNdkMediaCodec);
        mNdkMediaCodec = 0;
    }

    @Override
    public void start() {
        AMediaCodecStart(mNdkMediaCodec);
    }

    @Override
    public void stop() {
        AMediaCodecStop(mNdkMediaCodec);
    }

    @Override
    public void configure(MediaFormat format, int flags) {
        configure(format, flags, null /* surface */);
    }

    @Override
    public void configure(MediaFormat format, int flags, Surface surface) {

        int width = format.getInteger(MediaFormat.KEY_WIDTH, -1);
        int height = format.getInteger(MediaFormat.KEY_HEIGHT, -1);
        int colorFormat = format.getInteger(MediaFormat.KEY_COLOR_FORMAT, -1);
        int bitRate = format.getInteger(MediaFormat.KEY_BIT_RATE, -1);
        int frameRate = format.getInteger(MediaFormat.KEY_FRAME_RATE, -1);
        int iFrameInterval = format.getInteger(MediaFormat.KEY_I_FRAME_INTERVAL, -1);
        int lowLatency = ApiLevelUtil.isAtLeast(Build.VERSION_CODES.R) ?
                format.getInteger(MediaFormat.KEY_LOW_LATENCY, -1) : -1;
        int range = format.getInteger(MediaFormat.KEY_COLOR_RANGE, -1);
        int standard = format.getInteger(MediaFormat.KEY_COLOR_STANDARD, -1);
        int transfer = format.getInteger(MediaFormat.KEY_COLOR_TRANSFER, -1);

        ByteBuffer csd0BufCopy = null;
        if (format.containsKey(CSD_0)) {
            ByteBuffer csd0BufOld = format.getByteBuffer(CSD_0);
            csd0BufCopy = ByteBuffer.allocateDirect(csd0BufOld.remaining());
            csd0BufCopy.put(csd0BufOld);
            csd0BufCopy.position(0);
        }

        ByteBuffer csd1BufCopy = null;
        if (format.containsKey(CSD_1)) {
            ByteBuffer csd1BufOld = format.getByteBuffer(CSD_1);
            csd1BufCopy = ByteBuffer.allocateDirect(csd1BufOld.remaining());
            csd1BufCopy.put(csd1BufOld);
            csd1BufCopy.position(0);
        }

        // fail loudly so the test can be properly extended.
        if (format.containsKey(CSD_2)) {
            throw new UnsupportedOperationException(""test error: does not handle csd-2"");
        }

        AMediaCodecConfigure(
                mNdkMediaCodec,
                format.getString(MediaFormat.KEY_MIME),
                width,
                height,
                colorFormat,
                bitRate,
                frameRate,
                iFrameInterval ,
                csd0BufCopy,
                csd1BufCopy,
                flags,
                lowLatency,
                surface,
                range,
                standard,
                transfer);
    }

    @Override
    public void setInputSurface(InputSurfaceInterface surface) {
        surface.configure(this);
    }

    public void setInputSurface(Surface surface) {
        AMediaCodecSetInputSurface(mNdkMediaCodec, surface);
    }

    public void setInputSurface(long aNativeWindow) {
        AMediaCodecSetNativeInputSurface(mNdkMediaCodec, aNativeWindow);
    }

    @Override
    public InputSurfaceInterface createInputSurface() {
        return new NdkInputSurface(AMediaCodecCreateInputSurface(mNdkMediaCodec));
    }

    public static InputSurfaceInterface createPersistentInputSurface() {
        return new NdkInputSurface(AMediaCodecCreatePersistentInputSurface());
    }

    @Override
    public int dequeueOutputBuffer(BufferInfo info, long timeoutUs) {
        long[] ret = AMediaCodecDequeueOutputBuffer(mNdkMediaCodec, timeoutUs);
        if (ret[0] >= 0) {
            info.offset = (int)ret[1];
            info.size = (int)ret[2];
            info.presentationTimeUs = ret[3];
            info.flags = (int)ret[4];
        }
        return (int)ret[0];
    }

    @Override
    public ByteBuffer getOutputBuffer(int index) {
        return AMediaCodecGetOutputBuffer(mNdkMediaCodec, index);
    }

    @Override
    public void releaseOutputBuffer(int index, boolean render) {
        AMediaCodecReleaseOutputBuffer(mNdkMediaCodec, index, render);
    }

    @Override
    public void signalEndOfInputStream() {
        AMediaCodecSignalEndOfInputStream(mNdkMediaCodec);
    }

    @Override
    public String getOutputFormatString() {
        return AMediaCodecGetOutputFormatString(mNdkMediaCodec);
    }

    @Override
    public ByteBuffer[] getOutputBuffers() {
        return null;
    }

    @Override
    public ByteBuffer getInputBuffer(int index) {
        return AMediaCodecGetInputBuffer(mNdkMediaCodec, index);
    }

    @Override
    public ByteBuffer[] getInputBuffers() {
        return null;
    }

    @Override
    public void queueInputBuffer(
            int index,
            int offset,
            int size,
            long presentationTimeUs,
            int flags) {

        AMediaCodecQueueInputBuffer(mNdkMediaCodec, index, offset, size, presentationTimeUs, flags);

    }

    @Override
    public int dequeueInputBuffer(long timeoutUs) {
        return AMediaCodecDequeueInputBuffer(mNdkMediaCodec, timeoutUs);
    }

    @Override
    public void setParameters(Bundle params) {

        String keys[] = new String[] {
                MediaCodec.PARAMETER_KEY_REQUEST_SYNC_FRAME,
                MediaCodec.PARAMETER_KEY_VIDEO_BITRATE};

        for (String key : keys) {
            if (params.containsKey(key)) {
                int value = params.getInt(key);
                AMediaCodecSetParameter(mNdkMediaCodec, key, value);
            }
        }

    }

    @Override
    public void setCallback(Callback mCallback) {
        throw new UnsupportedOperationException(mCallback.toString());
    }

    @Override
    public String toString() {
        return String.format(""%s(%s, %x)"", getClass(), mName, mNdkMediaCodec);
    }
}"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.mediav2.cts.CodecTestBase"	"isEmpty"	"CtsMediaV2TestCases"	"/home/gpoor/cts-12-source/cts/tests/media/src/android/mediav2/cts/CodecTestBase.java"	""	"public void test/*
 *.
 */

package android.mediav2.cts;

import android.content.Context;
import android.content.pm.PackageManager;
import android.graphics.ImageFormat;
import android.graphics.Rect;
import android.hardware.display.DisplayManager;
import android.media.Image;
import android.media.MediaCodec;
import android.media.MediaCodecInfo;
import android.media.MediaCodecList;
import android.media.MediaExtractor;
import android.media.MediaFormat;
import android.os.Build;
import android.os.PersistableBundle;
import android.util.Log;
import android.util.Pair;
import android.view.Display;
import android.view.Surface;

import androidx.annotation.NonNull;
import androidx.test.platform.app.InstrumentationRegistry;

import org.junit.Assert;
import org.junit.Before;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.zip.CRC32;

import com.android.compatibility.common.util.ApiLevelUtil;

import static android.media.MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface;
import static android.media.MediaCodecInfo.CodecCapabilities.COLOR_FormatYUV420Flexible;
import static android.media.MediaCodecInfo.CodecProfileLevel.*;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

class CodecAsyncHandler extends MediaCodec.Callback {
    private static final String LOG_TAG = CodecAsyncHandler.class.getSimpleName();
    private final Lock mLock = new ReentrantLock();
    private final Condition mCondition = mLock.newCondition();
    private final LinkedList<Pair<Integer, MediaCodec.BufferInfo>> mCbInputQueue;
    private final LinkedList<Pair<Integer, MediaCodec.BufferInfo>> mCbOutputQueue;
    private MediaFormat mOutFormat;
    private boolean mSignalledOutFormatChanged;
    private volatile boolean mSignalledError;

    CodecAsyncHandler() {
        mCbInputQueue = new LinkedList<>();
        mCbOutputQueue = new LinkedList<>();
        mSignalledError = false;
        mSignalledOutFormatChanged = false;
    }

    void clearQueues() {
        mLock.lock();
        mCbInputQueue.clear();
        mCbOutputQueue.clear();
        mLock.unlock();
    }

    void resetContext() {
        clearQueues();
        mOutFormat = null;
        mSignalledOutFormatChanged = false;
        mSignalledError = false;
    }

    @Override
    public void onInputBufferAvailable(@NonNull MediaCodec codec, int bufferIndex) {
        assertTrue(bufferIndex >= 0);
        mLock.lock();
        mCbInputQueue.add(new Pair<>(bufferIndex, (MediaCodec.BufferInfo) null));
        mCondition.signalAll();
        mLock.unlock();
    }

    @Override
    public void onOutputBufferAvailable(@NonNull MediaCodec codec, int bufferIndex,
            @NonNull MediaCodec.BufferInfo info) {
        assertTrue(bufferIndex >= 0);
        mLock.lock();
        mCbOutputQueue.add(new Pair<>(bufferIndex, info));
        mCondition.signalAll();
        mLock.unlock();
    }

    @Override
    public void onError(@NonNull MediaCodec codec, MediaCodec.CodecException e) {
        mLock.lock();
        mSignalledError = true;
        mCondition.signalAll();
        mLock.unlock();
        Log.e(LOG_TAG, ""received media codec error : "" + e.getMessage());
    }

    @Override
    public void onOutputFormatChanged(@NonNull MediaCodec codec, @NonNull MediaFormat format) {
        mOutFormat = format;
        mSignalledOutFormatChanged = true;
        Log.i(LOG_TAG, ""Output format changed: "" + format.toString());
    }

    void setCallBack(MediaCodec codec, boolean isCodecInAsyncMode) {
        if (isCodecInAsyncMode) {
            codec.setCallback(this);
        } else {
            codec.setCallback(null);
        }
    }

    Pair<Integer, MediaCodec.BufferInfo> getInput() throws InterruptedException {
        Pair<Integer, MediaCodec.BufferInfo> element = null;
        mLock.lock();
        while (!mSignalledError) {
            if (mCbInputQueue.isEmpty()) {
                mCondition.await();
            } else {
                element = mCbInputQueue.remove(0);
                break;
            }
        }
        mLock.unlock();
        return element;
    }

    Pair<Integer, MediaCodec.BufferInfo> getOutput() throws InterruptedException {
        Pair<Integer, MediaCodec.BufferInfo> element = null;
        mLock.lock();
        while (!mSignalledError) {
            if (mCbOutputQueue.isEmpty()) {
                mCondition.await();
            } else {
                element = mCbOutputQueue.remove(0);
                break;
            }
        }
        mLock.unlock();
        return element;
    }

    Pair<Integer, MediaCodec.BufferInfo> getWork() throws InterruptedException {
        Pair<Integer, MediaCodec.BufferInfo> element = null;
        mLock.lock();
        while (!mSignalledError) {
            if (mCbInputQueue.isEmpty() && mCbOutputQueue.isEmpty()) {
                mCondition.await();
            } else {
                if (!mCbOutputQueue.isEmpty()) {
                    element = mCbOutputQueue.remove(0);
                    break;
                }
                if (!mCbInputQueue.isEmpty()) {
                    element = mCbInputQueue.remove(0);
                    break;
                }
            }
        }
        mLock.unlock();
        return element;
    }

    boolean isInputQueueEmpty() {
        mLock.lock();
        boolean isEmpty = mCbInputQueue.isEmpty();
        mLock.unlock();
        return isEmpty;
    }

    boolean hasSeenError() {
        return mSignalledError;
    }

    boolean hasOutputFormatChanged() {
        return mSignalledOutFormatChanged;
    }

    MediaFormat getOutputFormat() {
        return mOutFormat;
    }
}

class OutputManager {
    private static final String LOG_TAG = OutputManager.class.getSimpleName();
    private byte[] memory;
    private int memIndex;
    private CRC32 mCrc32UsingImage;
    private CRC32 mCrc32UsingBuffer;
    private ArrayList<Long> inpPtsList;
    private ArrayList<Long> outPtsList;

    OutputManager() {
        memory = new byte[1024];
        memIndex = 0;
        mCrc32UsingImage = new CRC32();
        mCrc32UsingBuffer = new CRC32();
        inpPtsList = new ArrayList<>();
        outPtsList = new ArrayList<>();
    }

    void saveInPTS(long pts) {
        // Add only Unique timeStamp, discarding any duplicate frame / non-display frame
        if (!inpPtsList.contains(pts)) {
            inpPtsList.add(pts);
        }
    }

    void saveOutPTS(long pts) {
        outPtsList.add(pts);
    }

    boolean isPtsStrictlyIncreasing(long lastPts) {
        boolean res = true;
        for (int i = 0; i < outPtsList.size(); i++) {
            if (lastPts < outPtsList.get(i)) {
                lastPts = outPtsList.get(i);
            } else {
                Log.e(LOG_TAG, ""Timestamp ordering check failed: last timestamp: "" + lastPts +
                        "" current timestamp:"" + outPtsList.get(i));
                res = false;
                break;
            }
        }
        return res;
    }

    boolean isOutPtsListIdenticalToInpPtsList(boolean requireSorting) {
        boolean res;
        Collections.sort(inpPtsList);
        if (requireSorting) {
            Collections.sort(outPtsList);
        }
        if (outPtsList.size() != inpPtsList.size()) {
            Log.e(LOG_TAG, ""input and output presentation timestamp list sizes are not identical"" +
                    ""exp/rec"" + inpPtsList.size() + '/' + outPtsList.size());
            return false;
        } else {
            int count = 0;
            for (int i = 0; i < outPtsList.size(); i++) {
                if (!outPtsList.get(i).equals(inpPtsList.get(i))) {
                    count ++;
                    Log.e(LOG_TAG, ""input output pts mismatch, exp/rec "" + outPtsList.get(i) + '/' +
                            inpPtsList.get(i));
                    if (count == 20) {
                        Log.e(LOG_TAG, ""stopping after 20 mismatches, ..."");
                        break;
                    }
                }
            }
            res = (count == 0);
        }
        return res;
    }

    int getOutStreamSize() {
        return memIndex;
    }

    void checksum(ByteBuffer buf, int size) {
        checksum(buf, size, 0, 0, 0);
    }

    void checksum(ByteBuffer buf, int size, int width, int height, int stride) {
        int cap = buf.capacity();
        assertTrue(""checksum() params are invalid: size = "" + size + "" cap = "" + cap,
                size > 0 && size <= cap);
        if (buf.hasArray()) {
            if (width > 0 && height > 0 && stride > 0) {
                int offset = buf.position() + buf.arrayOffset();
                byte[] bb = new byte[width * height];
                for (int i = 0; i < height; ++i) {
                    System.arraycopy(buf.array(), offset, bb, i * width, width);
                    offset += stride;
                }
                mCrc32UsingBuffer.update(bb, 0, width * height);
            } else {
                mCrc32UsingBuffer.update(buf.array(), buf.position() + buf.arrayOffset(), size);
            }
        } else if (width > 0 && height > 0 && stride > 0) {
            // Checksum only the Y plane
            int pos = buf.position();
            int offset = pos;
            byte[] bb = new byte[width * height];
            for (int i = 0; i < height; ++i) {
                buf.position(offset);
                buf.get(bb, i * width, width);
                offset += stride;
            }
            mCrc32UsingBuffer.update(bb, 0, width * height);
            buf.position(pos);
        } else {
            int pos = buf.position();
            final int rdsize = Math.min(4096, size);
            byte[] bb = new byte[rdsize];
            int chk;
            for (int i = 0; i < size; i += chk) {
                chk = Math.min(rdsize, size - i);
                buf.get(bb, 0, chk);
                mCrc32UsingBuffer.update(bb, 0, chk);
            }
            buf.position(pos);
        }
    }

    void checksum(Image image) {
        int format = image.getFormat();
        assertEquals(""unexpected image format"", ImageFormat.YUV_420_888, format);

        Rect cropRect = image.getCropRect();
        int imageWidth = cropRect.width();
        int imageHeight = cropRect.height();
        assertTrue(""unexpected image dimensions"", imageWidth > 0 && imageHeight > 0);

        int imageLeft = cropRect.left;
        int imageTop = cropRect.top;
        Image.Plane[] planes = image.getPlanes();
        for (int i = 0; i < planes.length; ++i) {
            ByteBuffer buf = planes[i].getBuffer();
            int width, height, rowStride, pixelStride, x, y, left, top;
            rowStride = planes[i].getRowStride();
            pixelStride = planes[i].getPixelStride();
            if (i == 0) {
                width = imageWidth;
                height = imageHeight;
                left = imageLeft;
                top = imageTop;
            } else {
                width = imageWidth / 2;
                height = imageHeight / 2;
                left = imageLeft / 2;
                top = imageTop / 2;
            }
            int cropOffset = left + top * rowStride;
            // local contiguous pixel buffer
            byte[] bb = new byte[width * height];
            if (buf.hasArray()) {
                byte[] b = buf.array();
                int offs = buf.arrayOffset() + cropOffset;
                if (pixelStride == 1) {
                    for (y = 0; y < height; ++y) {
                        System.arraycopy(b, offs + y * rowStride, bb, y * width, width);
                    }
                } else {
                    // do it pixel-by-pixel
                    for (y = 0; y < height; ++y) {
                        int lineOffset = offs + y * rowStride;
                        for (x = 0; x < width; ++x) {
                            bb[y * width + x] = b[lineOffset + x * pixelStride];
                        }
                    }
                }
            } else { // almost always ends up here due to direct buffers
                int base = buf.position();
                int pos = base + cropOffset;
                if (pixelStride == 1) {
                    for (y = 0; y < height; ++y) {
                        buf.position(pos + y * rowStride);
                        buf.get(bb, y * width, width);
                    }
                } else {
                    // local line buffer
                    byte[] lb = new byte[rowStride];
                    // do it pixel-by-pixel
                    for (y = 0; y < height; ++y) {
                        buf.position(pos + y * rowStride);
                        // we're only guaranteed to have pixelStride * (width - 1) + 1 bytes
                        buf.get(lb, 0, pixelStride * (width - 1) + 1);
                        for (x = 0; x < width; ++x) {
                            bb[y * width + x] = lb[x * pixelStride];
                        }
                    }
                }
                buf.position(base);
            }
            mCrc32UsingImage.update(bb, 0, width * height);
        }
    }

    void saveToMemory(ByteBuffer buf, MediaCodec.BufferInfo info) {
        if (memIndex + info.size >= memory.length) {
            memory = Arrays.copyOf(memory, memIndex + info.size);
        }
        buf.position(info.offset);
        buf.get(memory, memIndex, info.size);
        memIndex += info.size;
    }

    void position(int index) {
        if (index < 0 || index >= memory.length) index = 0;
        memIndex = index;
    }

    ByteBuffer getBuffer() {
        return ByteBuffer.wrap(memory);
    }

    void reset() {
        position(0);
        mCrc32UsingImage.reset();
        mCrc32UsingBuffer.reset();
        inpPtsList.clear();
        outPtsList.clear();
    }

    float getRmsError(short[] refData) {
        long totalErrorSquared = 0;
        assertTrue(0 == (memIndex & 1));
        short[] shortData = new short[memIndex / 2];
        ByteBuffer.wrap(memory, 0, memIndex).order(ByteOrder.LITTLE_ENDIAN).asShortBuffer()
                .get(shortData);
        if (refData.length != shortData.length) return Float.MAX_VALUE;
        for (int i = 0; i < shortData.length; i++) {
            int d = shortData[i] - refData[i];
            totalErrorSquared += d * d;
        }
        long avgErrorSquared = (totalErrorSquared / shortData.length);
        return (float) Math.sqrt(avgErrorSquared);
    }

    long getCheckSumImage() {
        return mCrc32UsingImage.getValue();
    }

    long getCheckSumBuffer() {
        return mCrc32UsingBuffer.getValue();
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        OutputManager that = (OutputManager) o;
        // TODO: Timestamps for deinterlaced content are under review. (E.g. can decoders
        // produce multiple progressive frames?) For now, do not verify timestamps.
        boolean isEqual = this.equalsInterlaced(o);
        if (!outPtsList.equals(that.outPtsList)) {
            isEqual = false;
            Log.e(LOG_TAG, ""ref and test presentation timestamp mismatch"");
        }
        return isEqual;
    }

    public boolean equalsInterlaced(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        OutputManager that = (OutputManager) o;
        boolean isEqual = true;
        if (mCrc32UsingImage.getValue() != that.mCrc32UsingImage.getValue()) {
            isEqual = false;
            Log.e(LOG_TAG, ""ref and test crc32 checksums calculated using image mismatch "" +
                          mCrc32UsingImage.getValue() + '/' + that.mCrc32UsingImage.getValue());
        }
        if (mCrc32UsingBuffer.getValue() != that.mCrc32UsingBuffer.getValue()) {
            isEqual = false;
            Log.e(LOG_TAG, ""ref and test crc32 checksums calculated using buffer mismatch "" +
                          mCrc32UsingBuffer.getValue() + '/' + that.mCrc32UsingBuffer.getValue());
            if (memIndex == that.memIndex) {
                int count = 0;
                for (int i = 0; i < memIndex; i++) {
                    if (memory[i] != that.memory[i]) {
                        count++;
                        if (count < 20) {
                            Log.d(LOG_TAG, ""sample at "" + i + "" exp/got:: "" + memory[i] + '/' +
                                    that.memory[i]);
                        }
                    }
                }
                if (count != 0) {
                    Log.e(LOG_TAG, ""ref and test o/p samples mismatch "" + count);
                }
            } else {
                Log.e(LOG_TAG, ""ref and test o/p sizes mismatch "" + memIndex + '/' + that.memIndex);
            }
        }
        return isEqual;
    }
}

abstract class CodecTestBase {
    public static final boolean IS_AT_LEAST_R = ApiLevelUtil.isAtLeast(Build.VERSION_CODES.R);
    private static final String LOG_TAG = CodecTestBase.class.getSimpleName();

    static final String CODEC_PREFIX_KEY = ""codec-prefix"";
    static final String MIME_SEL_KEY = ""mime-sel"";
    static final Map<String, String> codecSelKeyMimeMap = new HashMap<>();
    static final Map<String, String> mDefaultEncoders = new HashMap<>();
    static final Map<String, String> mDefaultDecoders = new HashMap<>();
    static final boolean ENABLE_LOGS = false;
    static final int PER_TEST_TIMEOUT_LARGE_TEST_MS = 300000;
    static final int PER_TEST_TIMEOUT_SMALL_TEST_MS = 60000;
    static final int UNSPECIFIED = 0;
    static final int CODEC_ALL = 0; // All codecs must support
    static final int CODEC_ANY = 1; // At least one codec must support
    static final int CODEC_DEFAULT = 2; // Default codec must support
    static final int CODEC_OPTIONAL = 3; // Codec support is optional
    // Maintain Timeouts in sync with their counterpart in NativeMediaCommon.h
    static final long Q_DEQ_TIMEOUT_US = 5000; // block at most 5ms while looking for io buffers
    static final int RETRY_LIMIT = 100; // max poll counter before test aborts and returns error
    static final String INVALID_CODEC = ""unknown.codec_"";
    static final String mInpPrefix = WorkDir.getMediaDirString();
    static final Context mContext = InstrumentationRegistry.getInstrumentation().getTargetContext();
    static final PackageManager pm = mContext.getPackageManager();
    static String mimeSelKeys;
    static String codecPrefix;

    CodecAsyncHandler mAsyncHandle;
    boolean mIsCodecInAsyncMode;
    boolean mSawInputEOS;
    boolean mSawOutputEOS;
    boolean mSignalEOSWithLastFrame;
    int mInputCount;
    int mOutputCount;
    long mPrevOutputPts;
    boolean mSignalledOutFormatChanged;
    MediaFormat mOutFormat;
    boolean mIsAudio;

    boolean mSaveToMem;
    OutputManager mOutputBuff;

    String mCodecName;
    MediaCodec mCodec;
    Surface mSurface;

    static {
        System.loadLibrary(""ctsmediav2codec_jni"");

        codecSelKeyMimeMap.put(""vp8"", MediaFormat.MIMETYPE_VIDEO_VP8);
        codecSelKeyMimeMap.put(""vp9"", MediaFormat.MIMETYPE_VIDEO_VP9);
        codecSelKeyMimeMap.put(""av1"", MediaFormat.MIMETYPE_VIDEO_AV1);
        codecSelKeyMimeMap.put(""avc"", MediaFormat.MIMETYPE_VIDEO_AVC);
        codecSelKeyMimeMap.put(""hevc"", MediaFormat.MIMETYPE_VIDEO_HEVC);
        codecSelKeyMimeMap.put(""mpeg4"", MediaFormat.MIMETYPE_VIDEO_MPEG4);
        codecSelKeyMimeMap.put(""h263"", MediaFormat.MIMETYPE_VIDEO_H263);
        codecSelKeyMimeMap.put(""mpeg2"", MediaFormat.MIMETYPE_VIDEO_MPEG2);
        codecSelKeyMimeMap.put(""vraw"", MediaFormat.MIMETYPE_VIDEO_RAW);
        codecSelKeyMimeMap.put(""amrnb"", MediaFormat.MIMETYPE_AUDIO_AMR_NB);
        codecSelKeyMimeMap.put(""amrwb"", MediaFormat.MIMETYPE_AUDIO_AMR_WB);
        codecSelKeyMimeMap.put(""mp3"", MediaFormat.MIMETYPE_AUDIO_MPEG);
        codecSelKeyMimeMap.put(""aac"", MediaFormat.MIMETYPE_AUDIO_AAC);
        codecSelKeyMimeMap.put(""vorbis"", MediaFormat.MIMETYPE_AUDIO_VORBIS);
        codecSelKeyMimeMap.put(""opus"", MediaFormat.MIMETYPE_AUDIO_OPUS);
        codecSelKeyMimeMap.put(""g711alaw"", MediaFormat.MIMETYPE_AUDIO_G711_ALAW);
        codecSelKeyMimeMap.put(""g711mlaw"", MediaFormat.MIMETYPE_AUDIO_G711_MLAW);
        codecSelKeyMimeMap.put(""araw"", MediaFormat.MIMETYPE_AUDIO_RAW);
        codecSelKeyMimeMap.put(""flac"", MediaFormat.MIMETYPE_AUDIO_FLAC);
        codecSelKeyMimeMap.put(""gsm"", MediaFormat.MIMETYPE_AUDIO_MSGSM);

        android.os.Bundle args = InstrumentationRegistry.getArguments();
        mimeSelKeys = args.getString(MIME_SEL_KEY);
        codecPrefix = args.getString(CODEC_PREFIX_KEY);
    }

    static boolean isTv() {
        return pm.hasSystemFeature(PackageManager.FEATURE_LEANBACK);
    }

    static boolean hasMicrophone() {
        return pm.hasSystemFeature(PackageManager.FEATURE_MICROPHONE);
    }

    static boolean hasCamera() {
        return pm.hasSystemFeature(PackageManager.FEATURE_CAMERA_ANY);
    }

    static boolean isWatch() {
        return pm.hasSystemFeature(PackageManager.FEATURE_WATCH);
    }

    static boolean isAutomotive() {
        return pm.hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE);
    }

    static boolean isPc() {
        return pm.hasSystemFeature(PackageManager.FEATURE_PC);
    }

    static boolean hasAudioOutput() {
        return pm.hasSystemFeature(PackageManager.FEATURE_AUDIO_OUTPUT);
    }

    static boolean isHandheld() {
        // handheld nature is not exposed to package manager, for now
        // we check for touchscreen and NOT watch and NOT tv and NOT pc
        return pm.hasSystemFeature(PackageManager.FEATURE_TOUCHSCREEN) && !isWatch() && !isTv() &&
                !isAutomotive() && !isPc();
    }

    static boolean hasDecoder(String mime) {
        return CodecTestBase.selectCodecs(mime, null, null, false).size() != 0;
    }

    static boolean hasEncoder(String mime) {
        return CodecTestBase.selectCodecs(mime, null, null, true).size() != 0;
    }

    static boolean isFeatureSupported(String name, String mime, String feature) throws IOException {
        MediaCodec codec = MediaCodec.createByCodecName(name);
        MediaCodecInfo.CodecCapabilities codecCapabilities =
                codec.getCodecInfo().getCapabilitiesForType(mime);
        boolean isSupported = codecCapabilities.isFeatureSupported(feature);
        codec.release();
        return isSupported;
    }

    static boolean doesAnyFormatHaveHDRProfile(String mime, ArrayList<MediaFormat> formats) {
        boolean isHDR = false;
        for (MediaFormat format : formats) {
            assertEquals(mime, format.getString(MediaFormat.KEY_MIME));
            if (mime.equals(MediaFormat.MIMETYPE_VIDEO_AVC)) {
                int profile = format.getInteger(MediaFormat.KEY_PROFILE);
                if (profile == AVCProfileHigh10 || profile == AVCProfileHigh422 ||
                        profile == AVCProfileHigh444) {
                    isHDR = true;
                    break;
                }
            } else if (mime.equals(MediaFormat.MIMETYPE_VIDEO_VP9)) {
                int profile = format.getInteger(MediaFormat.KEY_PROFILE, VP9Profile0);
                if (profile == VP9Profile2HDR || profile == VP9Profile3HDR ||
                        profile == VP9Profile2HDR10Plus || profile == VP9Profile3HDR10Plus) {
                    isHDR = true;
                    break;
                }
            } else if (mime.equals(MediaFormat.MIMETYPE_VIDEO_HEVC)) {
                int profile = format.getInteger(MediaFormat.KEY_PROFILE, HEVCProfileMain);
                if (profile == HEVCProfileMain10HDR10 || profile == HEVCProfileMain10HDR10Plus) {
                    isHDR = true;
                    break;
                }
            } else if (mime.equals(MediaFormat.MIMETYPE_VIDEO_AV1)) {
                int profile = format.getInteger(MediaFormat.KEY_PROFILE, AV1ProfileMain8);
                if (profile == AV1ProfileMain10HDR10 || profile == AV1ProfileMain10HDR10Plus) {
                    isHDR = true;
                    break;
                }
            }
        }
        return isHDR;
    }

    static boolean canDisplaySupportHDRContent() {
        DisplayManager displayManager = mContext.getSystemService(DisplayManager.class);
        return displayManager.getDisplay(Display.DEFAULT_DISPLAY).getHdrCapabilities()
                .getSupportedHdrTypes().length != 0;
    }

    static boolean areFormatsSupported(String name, String mime, ArrayList<MediaFormat> formats)
            throws IOException {
        MediaCodec codec = MediaCodec.createByCodecName(name);
        MediaCodecInfo.CodecCapabilities codecCapabilities =
                codec.getCodecInfo().getCapabilitiesForType(mime);
        boolean isSupported = true;
        if (formats != null) {
            for (int i = 0; i < formats.size() && isSupported; i++) {
                isSupported = codecCapabilities.isFormatSupported(formats.get(i));
            }
        }
        codec.release();
        return isSupported;
    }

    static boolean isDefaultCodec(String codecName, String mime, boolean isEncoder)
            throws IOException {
        Map<String,String> mDefaultCodecs = isEncoder ? mDefaultEncoders:  mDefaultDecoders;
        if (mDefaultCodecs.containsKey(mime)) {
            return mDefaultCodecs.get(mime).equalsIgnoreCase(codecName);
        }
        MediaCodec codec = isEncoder ? MediaCodec.createEncoderByType(mime)
                : MediaCodec.createDecoderByType(mime);
        boolean isDefault = codec.getName().equalsIgnoreCase(codecName);
        mDefaultCodecs.put(mime, codec.getName());
        codec.release();
        return isDefault;
    }

    static ArrayList<String> compileRequiredMimeList(boolean isEncoder, boolean needAudio,
            boolean needVideo) {
        Set<String> list = new HashSet<>();
        if (!isEncoder) {
            if (hasAudioOutput() && needAudio) {
                // sec 5.1.2
                list.add(MediaFormat.MIMETYPE_AUDIO_AAC);
                list.add(MediaFormat.MIMETYPE_AUDIO_FLAC);
                list.add(MediaFormat.MIMETYPE_AUDIO_MPEG);
                list.add(MediaFormat.MIMETYPE_AUDIO_VORBIS);
                list.add(MediaFormat.MIMETYPE_AUDIO_RAW);
                list.add(MediaFormat.MIMETYPE_AUDIO_OPUS);
            }
            if (isHandheld() || isTv() || isAutomotive()) {
                // sec 2.2.2, 2.3.2, 2.5.2
                if (needAudio) {
                    list.add(MediaFormat.MIMETYPE_AUDIO_AAC);
                }
                if (needVideo) {
                    list.add(MediaFormat.MIMETYPE_VIDEO_AVC);
                    list.add(MediaFormat.MIMETYPE_VIDEO_MPEG4);
                    list.add(MediaFormat.MIMETYPE_VIDEO_H263);
                    list.add(MediaFormat.MIMETYPE_VIDEO_VP8);
                    list.add(MediaFormat.MIMETYPE_VIDEO_VP9);
                }
            }
            if (isHandheld()) {
                // sec 2.2.2
                if (needAudio) {
                    list.add(MediaFormat.MIMETYPE_AUDIO_AMR_NB);
                    list.add(MediaFormat.MIMETYPE_AUDIO_AMR_WB);
                }
                if (needVideo) {
                    list.add(MediaFormat.MIMETYPE_VIDEO_HEVC);
                }
            }
            if (isTv() && needVideo) {
                // sec 2.3.2
                list.add(MediaFormat.MIMETYPE_VIDEO_HEVC);
                list.add(MediaFormat.MIMETYPE_VIDEO_MPEG2);
            }
        } else {
            if (hasMicrophone() && needAudio) {
                // sec 5.1.1
                // TODO(b/154423550)
                // list.add(MediaFormat.MIMETYPE_AUDIO_RAW);
                list.add(MediaFormat.MIMETYPE_AUDIO_FLAC);
                list.add(MediaFormat.MIMETYPE_AUDIO_OPUS);
            }
            if (isHandheld() || isTv() || isAutomotive()) {
                // sec 2.2.2, 2.3.2, 2.5.2
                if (needAudio) {
                    list.add(MediaFormat.MIMETYPE_AUDIO_AAC);
                }
                if (needVideo) {
                    list.add(MediaFormat.MIMETYPE_VIDEO_AVC);
                    list.add(MediaFormat.MIMETYPE_VIDEO_VP8);
                }
            }
            if (isHandheld() && needAudio) {
                // sec 2.2.2
                list.add(MediaFormat.MIMETYPE_AUDIO_AMR_NB);
                list.add(MediaFormat.MIMETYPE_AUDIO_AMR_WB);
            }
        }
        return new ArrayList<>(list);
    }

    static ArrayList<String> compileCompleteTestMimeList(boolean isEncoder, boolean needAudio,
            boolean needVideo) {
        ArrayList<String> mimes = new ArrayList<>();
        if (mimeSelKeys == null) {
            ArrayList<String> cddRequiredMimeList =
                    compileRequiredMimeList(isEncoder, needAudio, needVideo);
            MediaCodecList codecList = new MediaCodecList(MediaCodecList.REGULAR_CODECS);
            MediaCodecInfo[] codecInfos = codecList.getCodecInfos();
            for (MediaCodecInfo codecInfo : codecInfos) {
                if (codecInfo.isEncoder() != isEncoder) continue;
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q && codecInfo.isAlias()) continue;
                String[] types = codecInfo.getSupportedTypes();
                for (String type : types) {
                    if (!needAudio && type.startsWith(""audio/"")) continue;
                    if (!needVideo && type.startsWith(""video/"")) continue;
                    if (!mimes.contains(type)) {
                        mimes.add(type);
                    }
                }
            }
            // TODO(b/154423708): add checks for video o/p port and display length >= 2.5""
            /* sec 5.2: device implementations include an embedded screen display with the
            diagonal length of at least 2.5inches or include a video output port or declare the
            support of a camera */
            if (isEncoder && hasCamera() && needVideo &&
                    !mimes.contains(MediaFormat.MIMETYPE_VIDEO_AVC) &&
                    !mimes.contains(MediaFormat.MIMETYPE_VIDEO_VP8)) {
                // Add required cdd mimes here so that respective codec tests fail.
                mimes.add(MediaFormat.MIMETYPE_VIDEO_AVC);
                mimes.add(MediaFormat.MIMETYPE_VIDEO_VP8);
                Log.e(LOG_TAG,""device must support at least one of VP8 or AVC video encoders"");
            }
            for (String mime : cddRequiredMimeList) {
                if (!mimes.contains(mime)) {
                    // Add required cdd mimes here so that respective codec tests fail.
                    mimes.add(mime);
                    Log.e(LOG_TAG, ""no codec found for mime "" + mime + "" as required by cdd"");
                }
            }
        } else {
            for (Map.Entry<String, String> entry : codecSelKeyMimeMap.entrySet()) {
                String key = entry.getKey();
                String value = entry.getValue();
                if (mimeSelKeys.contains(key) && !mimes.contains(value)) mimes.add(value);
            }
        }
        return mimes;
    }

    static List<Object[]> prepareParamList(List<Object[]> exhaustiveArgsList, boolean isEncoder,
            boolean needAudio, boolean needVideo, boolean mustTestAllCodecs) {
        ArrayList<String> mimes = compileCompleteTestMimeList(isEncoder, needAudio, needVideo);
        ArrayList<String> cddRequiredMimeList =
                compileRequiredMimeList(isEncoder, needAudio, needVideo);
        final List<Object[]> argsList = new ArrayList<>();
        int argLength = exhaustiveArgsList.get(0).length;
        for (String mime : mimes) {
            ArrayList<String> totalListOfCodecs = selectCodecs(mime, null, null, isEncoder);
            ArrayList<String> listOfCodecs = new ArrayList<>();
            if (codecPrefix != null) {
                for (String codec : totalListOfCodecs) {
                    if (codec.startsWith(codecPrefix)) {
                        listOfCodecs.add(codec);
                    }
                }
            } else {
                listOfCodecs = totalListOfCodecs;
            }
            if (mustTestAllCodecs && listOfCodecs.size() == 0 && codecPrefix == null) {
                listOfCodecs.add(INVALID_CODEC + mime);
            }
            boolean miss = true;
            for (Object[] arg : exhaustiveArgsList) {
                if (mime.equals(arg[0])) {
                    for (String codec : listOfCodecs) {
                        Object[] arg_ = new Object[argLength + 1];
                        arg_[0] = codec;
                        System.arraycopy(arg, 0, arg_, 1, argLength);
                        argsList.add(arg_);
                    }
                    miss = false;
                }
            }
            if (miss && mustTestAllCodecs) {
                if (!cddRequiredMimeList.contains(mime)) {
                    Log.w(LOG_TAG, ""no test vectors available for optional mime type "" + mime);
                    continue;
                }
                for (String codec : listOfCodecs) {
                    Object[] arg_ = new Object[argLength + 1];
                    arg_[0] = codec;
                    arg_[1] = mime;
                    System.arraycopy(exhaustiveArgsList.get(0), 1, arg_, 2, argLength - 1);
                    argsList.add(arg_);
                }
            }
        }
        return argsList;
    }

    abstract void enqueueInput(int bufferIndex) throws IOException;

    abstract void dequeueOutput(int bufferIndex, MediaCodec.BufferInfo info);

    void configureCodec(MediaFormat format, boolean isAsync, boolean signalEOSWithLastFrame,
            boolean isEncoder) {
        resetContext(isAsync, signalEOSWithLastFrame);
        mAsyncHandle.setCallBack(mCodec, isAsync);
        // signalEOS flag has nothing to do with configure. We are using this flag to try all
        // available configure apis
        if (signalEOSWithLastFrame) {
            mCodec.configure(format, mSurface, null,
                    isEncoder ? MediaCodec.CONFIGURE_FLAG_ENCODE : 0);
        } else {
            mCodec.configure(format, mSurface, isEncoder ? MediaCodec.CONFIGURE_FLAG_ENCODE : 0,
                    null);
        }
        if (ENABLE_LOGS) {
            Log.v(LOG_TAG, ""codec configured"");
        }
    }

    void flushCodec() {
        mCodec.flush();
        // TODO(b/147576107): is it ok to clearQueues right away or wait for some signal
        mAsyncHandle.clearQueues();
        mSawInputEOS = false;
        mSawOutputEOS = false;
        mInputCount = 0;
        mOutputCount = 0;
        mPrevOutputPts = Long.MIN_VALUE;
        if (ENABLE_LOGS) {
            Log.v(LOG_TAG, ""codec flushed"");
        }
    }

    void reConfigureCodec(MediaFormat format, boolean isAsync, boolean signalEOSWithLastFrame,
            boolean isEncoder) {
        /* TODO(b/147348711) */
        if (false) mCodec.stop();
        else mCodec.reset();
        configureCodec(format, isAsync, signalEOSWithLastFrame, isEncoder);
    }

    void resetContext(boolean isAsync, boolean signalEOSWithLastFrame) {
        mAsyncHandle.resetContext();
        mIsCodecInAsyncMode = isAsync;
        mSawInputEOS = false;
        mSawOutputEOS = false;
        mSignalEOSWithLastFrame = signalEOSWithLastFrame;
        mInputCount = 0;
        mOutputCount = 0;
        mPrevOutputPts = Long.MIN_VALUE;
        mSignalledOutFormatChanged = false;
    }

    void enqueueEOS(int bufferIndex) {
        if (!mSawInputEOS) {
            mCodec.queueInputBuffer(bufferIndex, 0, 0, 0, MediaCodec.BUFFER_FLAG_END_OF_STREAM);
            mSawInputEOS = true;
            if (ENABLE_LOGS) {
                Log.v(LOG_TAG, ""Queued End of Stream"");
            }
        }
    }

    void doWork(int frameLimit) throws InterruptedException, IOException {
        int frameCount = 0;
        if (mIsCodecInAsyncMode) {
            // dequeue output after inputEOS is expected to be done in waitForAllOutputs()
            while (!mAsyncHandle.hasSeenError() && !mSawInputEOS && frameCount < frameLimit) {
                Pair<Integer, MediaCodec.BufferInfo> element = mAsyncHandle.getWork();
                if (element != null) {
                    int bufferID = element.first;
                    MediaCodec.BufferInfo info = element.second;
                    if (info != null) {
                        // <id, info> corresponds to output callback. Handle it accordingly
                        dequeueOutput(bufferID, info);
                    } else {
                        // <id, null> corresponds to input callback. Handle it accordingly
                        enqueueInput(bufferID);
                        frameCount++;
                    }
                }
            }
        } else {
            MediaCodec.BufferInfo outInfo = new MediaCodec.BufferInfo();
            // dequeue output after inputEOS is expected to be done in waitForAllOutputs()
            while (!mSawInputEOS && frameCount < frameLimit) {
                int outputBufferId = mCodec.dequeueOutputBuffer(outInfo, Q_DEQ_TIMEOUT_US);
                if (outputBufferId >= 0) {
                    dequeueOutput(outputBufferId, outInfo);
                } else if (outputBufferId == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {
                    mOutFormat = mCodec.getOutputFormat();
                    mSignalledOutFormatChanged = true;
                }
                int inputBufferId = mCodec.dequeueInputBuffer(Q_DEQ_TIMEOUT_US);
                if (inputBufferId != -1) {
                    enqueueInput(inputBufferId);
                    frameCount++;
                }
            }
        }
    }

    void queueEOS() throws InterruptedException {
        if (mIsCodecInAsyncMode) {
            while (!mAsyncHandle.hasSeenError() && !mSawInputEOS) {
                Pair<Integer, MediaCodec.BufferInfo> element = mAsyncHandle.getWork();
                if (element != null) {
                    int bufferID = element.first;
                    MediaCodec.BufferInfo info = element.second;
                    if (info != null) {
                        dequeueOutput(bufferID, info);
                    } else {
                        enqueueEOS(element.first);
                    }
                }
            }
        } else {
            MediaCodec.BufferInfo outInfo = new MediaCodec.BufferInfo();
            while (!mSawInputEOS) {
                int outputBufferId = mCodec.dequeueOutputBuffer(outInfo, Q_DEQ_TIMEOUT_US);
                if (outputBufferId >= 0) {
                    dequeueOutput(outputBufferId, outInfo);
                } else if (outputBufferId == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {
                    mOutFormat = mCodec.getOutputFormat();
                    mSignalledOutFormatChanged = true;
                }
                int inputBufferId = mCodec.dequeueInputBuffer(Q_DEQ_TIMEOUT_US);
                if (inputBufferId != -1) {
                    enqueueEOS(inputBufferId);
                }
            }
        }
    }

    void waitForAllOutputs() throws InterruptedException {
        if (mIsCodecInAsyncMode) {
            while (!mAsyncHandle.hasSeenError() && !mSawOutputEOS) {
                Pair<Integer, MediaCodec.BufferInfo> element = mAsyncHandle.getOutput();
                if (element != null) {
                    dequeueOutput(element.first, element.second);
                }
            }
        } else {
            MediaCodec.BufferInfo outInfo = new MediaCodec.BufferInfo();
            while (!mSawOutputEOS) {
                int outputBufferId = mCodec.dequeueOutputBuffer(outInfo, Q_DEQ_TIMEOUT_US);
                if (outputBufferId >= 0) {
                    dequeueOutput(outputBufferId, outInfo);
                } else if (outputBufferId == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {
                    mOutFormat = mCodec.getOutputFormat();
                    mSignalledOutFormatChanged = true;
                }
            }
        }
    }

    static ArrayList<String> selectCodecs(String mime, ArrayList<MediaFormat> formats,
            String[] features, boolean isEncoder) {
        MediaCodecList codecList = new MediaCodecList(MediaCodecList.REGULAR_CODECS);
        MediaCodecInfo[] codecInfos = codecList.getCodecInfos();
        ArrayList<String> listOfCodecs = new ArrayList<>();
        for (MediaCodecInfo codecInfo : codecInfos) {
            if (codecInfo.isEncoder() != isEncoder) continue;
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q && codecInfo.isAlias()) continue;
            String[] types = codecInfo.getSupportedTypes();
            for (String type : types) {
                if (type.equalsIgnoreCase(mime)) {
                    boolean isOk = true;
                    MediaCodecInfo.CodecCapabilities codecCapabilities =
                            codecInfo.getCapabilitiesForType(type);
                    if (formats != null) {
                        for (MediaFormat format : formats) {
                            if (!codecCapabilities.isFormatSupported(format)) {
                                isOk = false;
                                break;
                            }
                        }
                    }
                    if (features != null) {
                        for (String feature : features) {
                            if (!codecCapabilities.isFeatureSupported(feature)) {
                                isOk = false;
                                break;
                            }
                        }
                    }
                    if (isOk) listOfCodecs.add(codecInfo.getName());
                }
            }
        }
        return listOfCodecs;
    }

    static int getWidth(MediaFormat format) {
        int width = format.getInteger(MediaFormat.KEY_WIDTH, -1);
        if (format.containsKey(""crop-left"") && format.containsKey(""crop-right"")) {
            width = format.getInteger(""crop-right"") + 1 - format.getInteger(""crop-left"");
        }
        return width;
    }

    static int getHeight(MediaFormat format) {
        int height = format.getInteger(MediaFormat.KEY_HEIGHT, -1);
        if (format.containsKey(""crop-top"") && format.containsKey(""crop-bottom"")) {
            height = format.getInteger(""crop-bottom"") + 1 - format.getInteger(""crop-top"");
        }
        return height;
    }

    boolean isFormatSimilar(MediaFormat inpFormat, MediaFormat outFormat) {
        if (inpFormat == null || outFormat == null) return false;
        String inpMime = inpFormat.getString(MediaFormat.KEY_MIME);
        String outMime = outFormat.getString(MediaFormat.KEY_MIME);
        // not comparing input and output mimes because for a codec, mime is raw on one side and
        // encoded type on the other
        if (outMime.startsWith(""audio/"")) {
            return inpFormat.getInteger(MediaFormat.KEY_CHANNEL_COUNT, -1) ==
                    outFormat.getInteger(MediaFormat.KEY_CHANNEL_COUNT, -2) &&
                    inpFormat.getInteger(MediaFormat.KEY_SAMPLE_RATE, -1) ==
                            outFormat.getInteger(MediaFormat.KEY_SAMPLE_RATE, -2) &&
                    inpMime.startsWith(""audio/"");
        } else if (outMime.startsWith(""video/"")) {
            return getWidth(inpFormat) == getWidth(outFormat) &&
                    getHeight(inpFormat) == getHeight(outFormat) && inpMime.startsWith(""video/"");
        }
        return true;
    }

    PersistableBundle validateMetrics(String codec) {
        PersistableBundle metrics = mCodec.getMetrics();
        assertTrue(""metrics is null"", metrics != null);
        assertTrue(metrics.getString(MediaCodec.MetricsConstants.CODEC).equals(codec));
        if (mIsAudio) {
            assertTrue(metrics.getString(MediaCodec.MetricsConstants.MODE)
                    .equals(MediaCodec.MetricsConstants.MODE_AUDIO));
        } else {
            assertTrue(metrics.getString(MediaCodec.MetricsConstants.MODE)
                    .equals(MediaCodec.MetricsConstants.MODE_VIDEO));
        }
        return metrics;
    }

    PersistableBundle validateMetrics(String codec, MediaFormat format) {
        PersistableBundle metrics = validateMetrics(codec);
        if (!mIsAudio) {
            assertTrue(metrics.getInt(MediaCodec.MetricsConstants.WIDTH) == getWidth(format));
            assertTrue(metrics.getInt(MediaCodec.MetricsConstants.HEIGHT) == getHeight(format));
        }
        assertTrue(metrics.getInt(MediaCodec.MetricsConstants.SECURE) == 0);
        return metrics;
    }

    void validateColorAspects(MediaFormat fmt, int range, int standard, int transfer) {
        int colorRange = fmt.getInteger(MediaFormat.KEY_COLOR_RANGE, UNSPECIFIED);
        int colorStandard = fmt.getInteger(MediaFormat.KEY_COLOR_STANDARD, UNSPECIFIED);
        int colorTransfer = fmt.getInteger(MediaFormat.KEY_COLOR_TRANSFER, UNSPECIFIED);
        if (range > UNSPECIFIED) {
            assertEquals(""color range mismatch "", range, colorRange);
        }
        if (standard > UNSPECIFIED) {
            assertEquals(""color standard mismatch "", standard, colorStandard);
        }
        if (transfer > UNSPECIFIED) {
            assertEquals(""color transfer mismatch "", transfer, colorTransfer);
        }
    }

    public void setUpSurface(CodecTestActivity activity) throws InterruptedException {
        activity.waitTillSurfaceIsCreated();
        mSurface = activity.getSurface();
        assertTrue(""Surface created is null."", mSurface != null);
        assertTrue(""Surface created is invalid."", mSurface.isValid());
    }

    public void tearDownSurface() {
        if (mSurface != null) {
            mSurface.release();
            mSurface = null;
        }
    }

    @Before
    public void isCodecNameValid() {
        if (mCodecName != null && mCodecName.startsWith(INVALID_CODEC)) {
            fail(""no valid component available for current test "");
        }
    }
}

class CodecDecoderTestBase extends CodecTestBase {
    private static final String LOG_TAG = CodecDecoderTestBase.class.getSimpleName();

    String mMime;
    String mTestFile;
    boolean mIsInterlaced;

    ArrayList<ByteBuffer> mCsdBuffers;
    private int mCurrCsdIdx;

    private ByteBuffer flatBuffer = ByteBuffer.allocate(4 * Integer.BYTES);

    MediaExtractor mExtractor;

    CodecDecoderTestBase(String codecName, String mime, String testFile) {
        mCodecName = codecName;
        mMime = mime;
        mTestFile = testFile;
        mAsyncHandle = new CodecAsyncHandler();
        mCsdBuffers = new ArrayList<>();
        mIsAudio = mMime.startsWith(""audio/"");
    }

    MediaFormat setUpSource(String srcFile) throws IOException {
        return setUpSource(mInpPrefix, srcFile);
    }

    MediaFormat setUpSource(String prefix, String srcFile) throws IOException {
        mExtractor = new MediaExtractor();
        mExtractor.setDataSource(prefix + srcFile);
        for (int trackID = 0; trackID < mExtractor.getTrackCount(); trackID++) {
            MediaFormat format = mExtractor.getTrackFormat(trackID);
            if (mMime.equalsIgnoreCase(format.getString(MediaFormat.KEY_MIME))) {
                mExtractor.selectTrack(trackID);
                if (!mIsAudio) {
                    if (mSurface == null) {
                        // COLOR_FormatYUV420Flexible must be supported by all components
                        format.setInteger(MediaFormat.KEY_COLOR_FORMAT, COLOR_FormatYUV420Flexible);
                    } else {
                        format.setInteger(MediaFormat.KEY_COLOR_FORMAT, COLOR_FormatSurface);
                    }
                }
                // TODO: determine this from the extractor format when it becomes exposed.
                mIsInterlaced = srcFile.contains(""_interlaced_"");
                return format;
            }
        }
        fail(""No track with mime: "" + mMime + "" found in file: "" + srcFile);
        return null;
    }

    boolean hasCSD(MediaFormat format) {
        return format.containsKey(""csd-0"");
    }

    void flattenBufferInfo(MediaCodec.BufferInfo info, boolean isAudio) {
        if (isAudio) {
            flatBuffer.putInt(info.size);
        }
        flatBuffer.putInt(info.flags & ~MediaCodec.BUFFER_FLAG_END_OF_STREAM)
                .putLong(info.presentationTimeUs);
        flatBuffer.flip();
    }

    void enqueueCodecConfig(int bufferIndex) {
        ByteBuffer inputBuffer = mCodec.getInputBuffer(bufferIndex);
        ByteBuffer csdBuffer = mCsdBuffers.get(mCurrCsdIdx);
        inputBuffer.put((ByteBuffer) csdBuffer.rewind());
        mCodec.queueInputBuffer(bufferIndex, 0, csdBuffer.limit(), 0,
                MediaCodec.BUFFER_FLAG_CODEC_CONFIG);
        if (ENABLE_LOGS) {
            Log.v(LOG_TAG, ""queued csd: id: "" + bufferIndex + "" size: "" + csdBuffer.limit());
        }
    }

    void enqueueInput(int bufferIndex) {
        if (mExtractor.getSampleSize() < 0) {
            enqueueEOS(bufferIndex);
        } else {
            ByteBuffer inputBuffer = mCodec.getInputBuffer(bufferIndex);
            mExtractor.readSampleData(inputBuffer, 0);
            int size = (int) mExtractor.getSampleSize();
            long pts = mExtractor.getSampleTime();
            int extractorFlags = mExtractor.getSampleFlags();
            int codecFlags = 0;
            if ((extractorFlags & MediaExtractor.SAMPLE_FLAG_SYNC) != 0) {
                codecFlags |= MediaCodec.BUFFER_FLAG_KEY_FRAME;
            }
            if ((extractorFlags & MediaExtractor.SAMPLE_FLAG_PARTIAL_FRAME) != 0) {
                codecFlags |= MediaCodec.BUFFER_FLAG_PARTIAL_FRAME;
            }
            if (!mExtractor.advance() && mSignalEOSWithLastFrame) {
                codecFlags |= MediaCodec.BUFFER_FLAG_END_OF_STREAM;
                mSawInputEOS = true;
            }
            if (ENABLE_LOGS) {
                Log.v(LOG_TAG, ""input: id: "" + bufferIndex + "" size: "" + size + "" pts: "" + pts +
                        "" flags: "" + codecFlags);
            }
            mCodec.queueInputBuffer(bufferIndex, 0, size, pts, codecFlags);
            if (size > 0 && (codecFlags & (MediaCodec.BUFFER_FLAG_CODEC_CONFIG |
                    MediaCodec.BUFFER_FLAG_PARTIAL_FRAME)) == 0) {
                mOutputBuff.saveInPTS(pts);
                mInputCount++;
            }
        }
    }

    void enqueueInput(int bufferIndex, ByteBuffer buffer, MediaCodec.BufferInfo info) {
        ByteBuffer inputBuffer = mCodec.getInputBuffer(bufferIndex);
        buffer.position(info.offset);
        for (int i = 0; i < info.size; i++) {
            inputBuffer.put(buffer.get());
        }
        if (ENABLE_LOGS) {
            Log.v(LOG_TAG, ""input: id: "" + bufferIndex + "" flags: "" + info.flags + "" size: "" +
                    info.size + "" timestamp: "" + info.presentationTimeUs);
        }
        mCodec.queueInputBuffer(bufferIndex, 0, info.size, info.presentationTimeUs,
                info.flags);
        if (info.size > 0 && ((info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) == 0) &&
                ((info.flags & MediaCodec.BUFFER_FLAG_PARTIAL_FRAME) == 0)) {
            mOutputBuff.saveInPTS(info.presentationTimeUs);
            mInputCount++;
        }
        if ((info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {
            mSawInputEOS = true;
        }
    }

    void dequeueOutput(int bufferIndex, MediaCodec.BufferInfo info) {
        if (info.size > 0 && mSaveToMem) {
            ByteBuffer buf = mCodec.getOutputBuffer(bufferIndex);
            flattenBufferInfo(info, mIsAudio);
            mOutputBuff.checksum(flatBuffer, flatBuffer.limit());
            if (mIsAudio) {
                mOutputBuff.checksum(buf, info.size);
                mOutputBuff.saveToMemory(buf, info);
            } else {
                // tests both getOutputImage and getOutputBuffer. Can do time division
                // multiplexing but lets allow it for now
                MediaFormat format = mCodec.getOutputFormat();
                int width = format.getInteger(MediaFormat.KEY_WIDTH);
                int height = format.getInteger(MediaFormat.KEY_HEIGHT);
                int stride = format.getInteger(MediaFormat.KEY_STRIDE);
                mOutputBuff.checksum(buf, info.size, width, height, stride);

                Image img = mCodec.getOutputImage(bufferIndex);
                assertTrue(img != null);
                mOutputBuff.checksum(img);
            }
        }
        if ((info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {
            mSawOutputEOS = true;
        }
        if (ENABLE_LOGS) {
            Log.v(LOG_TAG, ""output: id: "" + bufferIndex + "" flags: "" + info.flags + "" size: "" +
                    info.size + "" timestamp: "" + info.presentationTimeUs);
        }
        if (info.size > 0 && (info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) == 0) {
            mOutputBuff.saveOutPTS(info.presentationTimeUs);
            mOutputCount++;
        }
        mCodec.releaseOutputBuffer(bufferIndex, false);
    }

    void doWork(ByteBuffer buffer, ArrayList<MediaCodec.BufferInfo> list)
            throws InterruptedException {
        int frameCount = 0;
        if (mIsCodecInAsyncMode) {
            // output processing after queuing EOS is done in waitForAllOutputs()
            while (!mAsyncHandle.hasSeenError() && !mSawInputEOS && frameCount < list.size()) {
                Pair<Integer, MediaCodec.BufferInfo> element = mAsyncHandle.getWork();
                if (element != null) {
                    int bufferID = element.first;
                    MediaCodec.BufferInfo info = element.second;
                    if (info != null) {
                        dequeueOutput(bufferID, info);
                    } else {
                        enqueueInput(bufferID, buffer, list.get(frameCount));
                        frameCount++;
                    }
                }
            }
        } else {
            MediaCodec.BufferInfo outInfo = new MediaCodec.BufferInfo();
            // output processing after queuing EOS is done in waitForAllOutputs()
            while (!mSawInputEOS && frameCount < list.size()) {
                int outputBufferId = mCodec.dequeueOutputBuffer(outInfo, Q_DEQ_TIMEOUT_US);
                if (outputBufferId >= 0) {
                    dequeueOutput(outputBufferId, outInfo);
                } else if (outputBufferId == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {
                    mOutFormat = mCodec.getOutputFormat();
                    mSignalledOutFormatChanged = true;
                }
                int inputBufferId = mCodec.dequeueInputBuffer(Q_DEQ_TIMEOUT_US);
                if (inputBufferId != -1) {
                    enqueueInput(inputBufferId, buffer, list.get(frameCount));
                    frameCount++;
                }
            }
        }
    }

    void queueCodecConfig() throws InterruptedException {
        if (mIsCodecInAsyncMode) {
            for (mCurrCsdIdx = 0; !mAsyncHandle.hasSeenError() && mCurrCsdIdx < mCsdBuffers.size();
                 mCurrCsdIdx++) {
                Pair<Integer, MediaCodec.BufferInfo> element = mAsyncHandle.getInput();
                if (element != null) {
                    enqueueCodecConfig(element.first);
                }
            }
        } else {
            for (mCurrCsdIdx = 0; mCurrCsdIdx < mCsdBuffers.size(); mCurrCsdIdx++) {
                enqueueCodecConfig(mCodec.dequeueInputBuffer(-1));
            }
        }
    }

    void decodeToMemory(String file, String decoder, long pts, int mode, int frameLimit)
            throws IOException, InterruptedException {
        mSaveToMem = true;
        mOutputBuff = new OutputManager();
        mCodec = MediaCodec.createByCodecName(decoder);
        MediaFormat format = setUpSource(file);
        configureCodec(format, false, true, false);
        mCodec.start();
        mExtractor.seekTo(pts, mode);
        doWork(frameLimit);
        queueEOS();
        waitForAllOutputs();
        mCodec.stop();
        mCodec.release();
        mExtractor.release();
        mSaveToMem = false;
    }

    @Override
    PersistableBundle validateMetrics(String decoder, MediaFormat format) {
        PersistableBundle metrics = super.validateMetrics(decoder, format);
        assertTrue(metrics.getString(MediaCodec.MetricsConstants.MIME_TYPE).equals(mMime));
        assertTrue(metrics.getInt(MediaCodec.MetricsConstants.ENCODER) == 0);
        return metrics;
    }

    void validateColorAspects(String decoder, String parent, String name, int range, int standard,
            int transfer, boolean ignoreColorBox)
            throws IOException, InterruptedException {
        mOutputBuff = new OutputManager();
        MediaFormat format = setUpSource(parent, name);
        if (ignoreColorBox) {
            format.removeKey(MediaFormat.KEY_COLOR_RANGE);
            format.removeKey(MediaFormat.KEY_COLOR_STANDARD);
            format.removeKey(MediaFormat.KEY_COLOR_TRANSFER);
        }
        if (decoder == null) {
            MediaCodecList codecList = new MediaCodecList(MediaCodecList.REGULAR_CODECS);
            decoder = codecList.findDecoderForFormat(format);
        }
        mCodec = MediaCodec.createByCodecName(decoder);
        configureCodec(format, true, true, false);
        mCodec.start();
        doWork(1);
        queueEOS();
        waitForAllOutputs();
        validateColorAspects(mCodec.getOutputFormat(), range, standard, transfer);
        mCodec.stop();
        mCodec.release();
        mExtractor.release();
    }
}

class CodecEncoderTestBase extends CodecTestBase {
    private static final String LOG_TAG = CodecEncoderTestBase.class.getSimpleName();

    // files are in WorkDir.getMediaDirString();
    private static final String mInputAudioFile = ""bbb_2ch_44kHz_s16le.raw"";
    private static final String mInputVideoFile = ""bbb_cif_yuv420p_30fps.yuv"";
    private final int INP_FRM_WIDTH = 352;
    private final int INP_FRM_HEIGHT = 288;

    final String mMime;
    final int[] mBitrates;
    final int[] mEncParamList1;
    final int[] mEncParamList2;

    final String mInputFile;
    byte[] mInputData;
    int mNumBytesSubmitted;
    long mInputOffsetPts;

    ArrayList<MediaFormat> mFormats;
    ArrayList<MediaCodec.BufferInfo> mInfoList;

    int mWidth, mHeight;
    int mFrameRate;
    int mMaxBFrames;
    int mChannels;
    int mSampleRate;

    CodecEncoderTestBase(String encoder, String mime, int[] bitrates, int[] encoderInfo1,
            int[] encoderInfo2) {
        mMime = mime;
        mCodecName = encoder;
        mBitrates = bitrates;
        mEncParamList1 = encoderInfo1;
        mEncParamList2 = encoderInfo2;
        mFormats = new ArrayList<>();
        mInfoList = new ArrayList<>();
        mWidth = INP_FRM_WIDTH;
        mHeight = INP_FRM_HEIGHT;
        if (mime.equals(MediaFormat.MIMETYPE_VIDEO_MPEG4)) mFrameRate = 12;
        else if (mime.equals(MediaFormat.MIMETYPE_VIDEO_H263)) mFrameRate = 12;
        else mFrameRate = 30;
        mMaxBFrames = 0;
        mChannels = 1;
        mSampleRate = 8000;
        mAsyncHandle = new CodecAsyncHandler();
        mIsAudio = mMime.startsWith(""audio/"");
        mInputFile = mIsAudio ? mInputAudioFile : mInputVideoFile;
    }

    /**
     * Selects encoder input color format in byte buffer mode. As of now ndk tests support only
     * 420p, 420sp. COLOR_FormatYUV420Flexible although can represent any form of yuv, it doesn't
     * work in ndk due to lack of AMediaCodec_GetInputImage()
     */
    static int findByteBufferColorFormat(String encoder, String mime) throws IOException {
        MediaCodec codec = MediaCodec.createByCodecName(encoder);
        MediaCodecInfo.CodecCapabilities cap = codec.getCodecInfo().getCapabilitiesForType(mime);
        int colorFormat = -1;
        for (int c : cap.colorFormats) {
            if (c == MediaCodecInfo.CodecCapabilities.COLOR_FormatYUV420SemiPlanar ||
                    c == MediaCodecInfo.CodecCapabilities.COLOR_FormatYUV420Planar) {
                Log.v(LOG_TAG, ""selecting color format: "" + c);
                colorFormat = c;
                break;
            }
        }
        codec.release();
        return colorFormat;
    }

    @Override
    void resetContext(boolean isAsync, boolean signalEOSWithLastFrame) {
        super.resetContext(isAsync, signalEOSWithLastFrame);
        mNumBytesSubmitted = 0;
        mInputOffsetPts = 0;
    }

    @Override
    void flushCodec() {
        super.flushCodec();
        if (mIsAudio) {
            mInputOffsetPts =
                    (mNumBytesSubmitted + 1024) * 1000000L / (2 * mChannels * mSampleRate);
        } else {
            mInputOffsetPts = (mInputCount + 5) * 1000000L / mFrameRate;
        }
        mPrevOutputPts = mInputOffsetPts - 1;
        mNumBytesSubmitted = 0;
    }

    void setUpSource(String srcFile) throws IOException {
        String inpPath = mInpPrefix + srcFile;
        try (FileInputStream fInp = new FileInputStream(inpPath)) {
            int size = (int) new File(inpPath).length();
            mInputData = new byte[size];
            fInp.read(mInputData, 0, size);
        }
    }

    void fillImage(Image image) {
        Assert.assertTrue(image.getFormat() == ImageFormat.YUV_420_888);
        int imageWidth = image.getWidth();
        int imageHeight = image.getHeight();
        Image.Plane[] planes = image.getPlanes();
        int offset = mNumBytesSubmitted;
        for (int i = 0; i < planes.length; ++i) {
            ByteBuffer buf = planes[i].getBuffer();
            int width = imageWidth;
            int height = imageHeight;
            int tileWidth = INP_FRM_WIDTH;
            int tileHeight = INP_FRM_HEIGHT;
            int rowStride = planes[i].getRowStride();
            int pixelStride = planes[i].getPixelStride();
            if (i != 0) {
                width = imageWidth / 2;
                height = imageHeight / 2;
                tileWidth = INP_FRM_WIDTH / 2;
                tileHeight = INP_FRM_HEIGHT / 2;
            }
            if (pixelStride == 1) {
                if (width == rowStride && width == tileWidth && height == tileHeight) {
                    buf.put(mInputData, offset, width * height);
                } else {
                    for (int z = 0; z < height; z += tileHeight) {
                        int rowsToCopy = Math.min(height - z, tileHeight);
                        for (int y = 0; y < rowsToCopy; y++) {
                            for (int x = 0; x < width; x += tileWidth) {
                                int colsToCopy = Math.min(width - x, tileWidth);
                                buf.position((z + y) * rowStride + x);
                                buf.put(mInputData, offset + y * tileWidth, colsToCopy);
                            }
                        }
                    }
                }
            } else {
                // do it pixel-by-pixel
                for (int z = 0; z < height; z += tileHeight) {
                    int rowsToCopy = Math.min(height - z, tileHeight);
                    for (int y = 0; y < rowsToCopy; y++) {
                        int lineOffset = (z + y) * rowStride;
                        for (int x = 0; x < width; x += tileWidth) {
                            int colsToCopy = Math.min(width - x, tileWidth);
                            for (int w = 0; w < colsToCopy; w++) {
                                buf.position(lineOffset + (x + w) * pixelStride);
                                buf.put(mInputData[offset + y * tileWidth + w]);
                            }
                        }
                    }
                }
            }
            offset += tileWidth * tileHeight;
        }
    }

    void fillByteBuffer(ByteBuffer inputBuffer) {
        int offset = 0, frmOffset = mNumBytesSubmitted;
        for (int plane = 0; plane < 3; plane++) {
            int width = mWidth;
            int height = mHeight;
            int tileWidth = INP_FRM_WIDTH;
            int tileHeight = INP_FRM_HEIGHT;
            if (plane != 0) {
                width = mWidth / 2;
                height = mHeight / 2;
                tileWidth = INP_FRM_WIDTH / 2;
                tileHeight = INP_FRM_HEIGHT / 2;
            }
            for (int k = 0; k < height; k += tileHeight) {
                int rowsToCopy = Math.min(height - k, tileHeight);
                for (int j = 0; j < rowsToCopy; j++) {
                    for (int i = 0; i < width; i += tileWidth) {
                        int colsToCopy = Math.min(width - i, tileWidth);
                        inputBuffer.position(offset + (k + j) * width + i);
                        inputBuffer.put(mInputData, frmOffset + j * tileWidth, colsToCopy);
                    }
                }
            }
            offset += width * height;
            frmOffset += tileWidth * tileHeight;
        }
    }

    void enqueueInput(int bufferIndex) {
        ByteBuffer inputBuffer = mCodec.getInputBuffer(bufferIndex);
        if (mNumBytesSubmitted >= mInputData.length) {
            enqueueEOS(bufferIndex);
        } else {
            int size;
            int flags = 0;
            long pts = mInputOffsetPts;
            if (mIsAudio) {
                pts += mNumBytesSubmitted * 1000000L / (2 * mChannels * mSampleRate);
                size = Math.min(inputBuffer.capacity(), mInputData.length - mNumBytesSubmitted);
                inputBuffer.put(mInputData, mNumBytesSubmitted, size);
                if (mNumBytesSubmitted + size >= mInputData.length && mSignalEOSWithLastFrame) {
                    flags |= MediaCodec.BUFFER_FLAG_END_OF_STREAM;
                    mSawInputEOS = true;
                }
                mNumBytesSubmitted += size;
            } else {
                pts += mInputCount * 1000000L / mFrameRate;
                size = mWidth * mHeight * 3 / 2;
                int frmSize = INP_FRM_WIDTH * INP_FRM_HEIGHT * 3 / 2;
                if (mNumBytesSubmitted + frmSize > mInputData.length) {
                    fail(""received partial frame to encode"");
                } else {
                    Image img = mCodec.getInputImage(bufferIndex);
                    if (img != null) {
                        fillImage(img);
                    } else {
                        if (mWidth == INP_FRM_WIDTH && mHeight == INP_FRM_HEIGHT) {
                            inputBuffer.put(mInputData, mNumBytesSubmitted, size);
                        } else {
                            fillByteBuffer(inputBuffer);
                        }
                    }
                }
                if (mNumBytesSubmitted + frmSize >= mInputData.length && mSignalEOSWithLastFrame) {
                    flags |= MediaCodec.BUFFER_FLAG_END_OF_STREAM;
                    mSawInputEOS = true;
                }
                mNumBytesSubmitted += frmSize;
            }
            if (ENABLE_LOGS) {
                Log.v(LOG_TAG, ""input: id: "" + bufferIndex + "" size: "" + size + "" pts: "" + pts +
                        "" flags: "" + flags);
            }
            mCodec.queueInputBuffer(bufferIndex, 0, size, pts, flags);
            mOutputBuff.saveInPTS(pts);
            mInputCount++;
        }
    }

    void dequeueOutput(int bufferIndex, MediaCodec.BufferInfo info) {
        if (ENABLE_LOGS) {
            Log.v(LOG_TAG, ""output: id: "" + bufferIndex + "" flags: "" + info.flags + "" size: "" +
                    info.size + "" timestamp: "" + info.presentationTimeUs);
        }
        if ((info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {
            mSawOutputEOS = true;
        }
        if (info.size > 0) {
            if (mSaveToMem) {
                MediaCodec.BufferInfo copy = new MediaCodec.BufferInfo();
                copy.set(mOutputBuff.getOutStreamSize(), info.size, info.presentationTimeUs,
                        info.flags);
                mInfoList.add(copy);

                ByteBuffer buf = mCodec.getOutputBuffer(bufferIndex);
                mOutputBuff.saveToMemory(buf, info);
            }
            if ((info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) == 0) {
                mOutputBuff.saveOutPTS(info.presentationTimeUs);
                mOutputCount++;
            }
        }
        mCodec.releaseOutputBuffer(bufferIndex, false);
    }

    @Override
    PersistableBundle validateMetrics(String codec, MediaFormat format) {
        PersistableBundle metrics = super.validateMetrics(codec, format);
        assertTrue(metrics.getString(MediaCodec.MetricsConstants.MIME_TYPE).equals(mMime));
        assertTrue(metrics.getInt(MediaCodec.MetricsConstants.ENCODER) == 1);
        return metrics;
    }

    void setUpParams(int limit) {
        int count = 0;
        for (int bitrate : mBitrates) {
            if (mIsAudio) {
                for (int rate : mEncParamList1) {
                    for (int channels : mEncParamList2) {
                        MediaFormat format = new MediaFormat();
                        format.setString(MediaFormat.KEY_MIME, mMime);
                        if (mMime.equals(MediaFormat.MIMETYPE_AUDIO_FLAC)) {
                            format.setInteger(MediaFormat.KEY_FLAC_COMPRESSION_LEVEL, bitrate);
                        } else {
                            format.setInteger(MediaFormat.KEY_BIT_RATE, bitrate);
                        }
                        format.setInteger(MediaFormat.KEY_SAMPLE_RATE, rate);
                        format.setInteger(MediaFormat.KEY_CHANNEL_COUNT, channels);
                        mFormats.add(format);
                        count++;
                        if (count >= limit) return;
                    }
                }
            } else {
                assertTrue(""Wrong number of height, width parameters"",
                        mEncParamList1.length == mEncParamList2.length);
                for (int i = 0; i < mEncParamList1.length; i++) {
                    MediaFormat format = new MediaFormat();
                    format.setString(MediaFormat.KEY_MIME, mMime);
                    format.setInteger(MediaFormat.KEY_BIT_RATE, bitrate);
                    format.setInteger(MediaFormat.KEY_WIDTH, mEncParamList1[i]);
                    format.setInteger(MediaFormat.KEY_HEIGHT, mEncParamList2[i]);
                    format.setInteger(MediaFormat.KEY_FRAME_RATE, mFrameRate);
                    format.setInteger(MediaFormat.KEY_MAX_B_FRAMES, mMaxBFrames);
                    format.setFloat(MediaFormat.KEY_I_FRAME_INTERVAL, 1.0f);
                    format.setInteger(MediaFormat.KEY_COLOR_FORMAT,
                            MediaCodecInfo.CodecCapabilities.COLOR_FormatYUV420Flexible);
                    mFormats.add(format);
                    count++;
                    if (count >= limit) return;
                }
            }
        }
    }

    void encodeToMemory(String file, String encoder, int frameLimit, MediaFormat format,
            boolean saveToMem) throws IOException, InterruptedException {
        mSaveToMem = saveToMem;
        mOutputBuff = new OutputManager();
        mInfoList.clear();
        mCodec = MediaCodec.createByCodecName(encoder);
        setUpSource(file);
        configureCodec(format, false, true, true);
        if (mIsAudio) {
            mSampleRate = format.getInteger(MediaFormat.KEY_SAMPLE_RATE);
            mChannels = format.getInteger(MediaFormat.KEY_CHANNEL_COUNT);
        } else {
            mWidth = format.getInteger(MediaFormat.KEY_WIDTH);
            mHeight = format.getInteger(MediaFormat.KEY_HEIGHT);
        }
        mCodec.start();
        doWork(frameLimit);
        queueEOS();
        waitForAllOutputs();
        mCodec.stop();
        mCodec.release();
        mSaveToMem = false;
    }

    ByteBuffer decodeElementaryStream(String decoder, MediaFormat format,
            ByteBuffer elementaryStream, ArrayList<MediaCodec.BufferInfo> infos)
            throws IOException, InterruptedException {
        String mime = format.getString(MediaFormat.KEY_MIME);
        CodecDecoderTestBase cdtb = new CodecDecoderTestBase(decoder, mime, null);
        cdtb.mOutputBuff = new OutputManager();
        cdtb.mSaveToMem = true;
        cdtb.mCodec = MediaCodec.createByCodecName(decoder);
        cdtb.mCodec.configure(format, null, null, 0);
        cdtb.mCodec.start();
        cdtb.doWork(elementaryStream, infos);
        cdtb.queueEOS();
        cdtb.waitForAllOutputs();
        cdtb.mCodec.stop();
        cdtb.mCodec.release();
        return cdtb.mOutputBuff.getBuffer();
    }
}"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.media.tv.cts.TvViewTest"	"testTrackChange"	"CtsTvTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/tv/src/android/media/tv/cts/TvViewTest.java"	""	"public void testTrackChange() throws Throwable {
        if (!Utils.hasTvInputFramework(getActivity())) {
            return;
        }
        TvTrackInfo videoTrack1 = new TvTrackInfo.Builder(TvTrackInfo.TYPE_VIDEO, ""video-HD"")
                .setVideoHeight(1920).setVideoWidth(1080).build();
        TvTrackInfo videoTrack2 = new TvTrackInfo.Builder(TvTrackInfo.TYPE_VIDEO, ""video-SD"")
                .setVideoHeight(640).setVideoWidth(360).setVideoPixelAspectRatio(1.09f).build();
        TvTrackInfo audioTrack1 =
                new TvTrackInfo.Builder(TvTrackInfo.TYPE_AUDIO, ""audio-stereo-eng"")
                .setLanguage(""eng"").setAudioChannelCount(2).setAudioSampleRate(48000).build();
        TvTrackInfo audioTrack2 = new TvTrackInfo.Builder(TvTrackInfo.TYPE_AUDIO, ""audio-mono-esp"")
                .setLanguage(""esp"").setAudioChannelCount(1).setAudioSampleRate(48000).build();
        TvTrackInfo subtitleTrack1 =
                new TvTrackInfo.Builder(TvTrackInfo.TYPE_SUBTITLE, ""subtitle-eng"")
                .setLanguage(""eng"").build();
        TvTrackInfo subtitleTrack2 =
                new TvTrackInfo.Builder(TvTrackInfo.TYPE_SUBTITLE, ""subtitle-esp"")
                .setLanguage(""esp"").build();
        TvTrackInfo subtitleTrack3 =
                new TvTrackInfo.Builder(TvTrackInfo.TYPE_SUBTITLE, ""subtitle-eng2"")
                .setLanguage(""eng"").setDescription(""audio commentary"").build();

        StubTunerTvInputService.injectTrack(videoTrack1, videoTrack2, audioTrack1, audioTrack2,
                subtitleTrack1, subtitleTrack2);

        final List<TvTrackInfo> tracks = new ArrayList<TvTrackInfo>();
        Collections.addAll(tracks, videoTrack1, videoTrack2, audioTrack1, audioTrack2,
                subtitleTrack1, subtitleTrack2, subtitleTrack3);
        tryTuneAllChannels(null, new Runnable() {
            @Override
            public void run() {
                new PollingCheck(TIME_OUT_MS) {
                    @Override
                    protected boolean check() {
                        return mTvView.getTracks(TvTrackInfo.TYPE_AUDIO) != null;
                    }
                }.run();
                final int[] types = { TvTrackInfo.TYPE_AUDIO, TvTrackInfo.TYPE_VIDEO,
                    TvTrackInfo.TYPE_SUBTITLE };
                for (int type : types) {
                    for (TvTrackInfo track : mTvView.getTracks(type)) {
                        selectTrackAndVerify(type, track, tracks);
                    }
                    selectTrackAndVerify(TvTrackInfo.TYPE_SUBTITLE, null, tracks);
                }
            }
        });
    }

    private void verifyKeyEvent(final KeyEvent keyEvent, final InputEvent[] unhandledEvent) {
        unhandledEvent[0] = null;
        mInstrumentation.sendKeySync(keyEvent);
        mInstrumentation.waitForIdleSync();
        new PollingCheck(TIME_OUT_MS) {
            @Override
            protected boolean check() {
                return unhandledEvent[0] != null;
            }
        }.run();
        assertTrue(unhandledEvent[0] instanceof KeyEvent);
        KeyEvent unhandled = (KeyEvent) unhandledEvent[0];
        assertEquals(unhandled.getAction(), keyEvent.getAction());
        assertEquals(unhandled.getKeyCode(), keyEvent.getKeyCode());
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.widget.cts.DatePickerTest"	"testEnterKey"	"CtsWidgetTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/DatePickerTest.java"	""	"public void testEnterKey() throws Throwable {
        mActivityRule.runOnUiThread(() -> mDatePickerCalendarMode.updateDate(
                2015, Calendar.DECEMBER, 15));
        mActivityRule.runOnUiThread(() -> mDatePickerCalendarMode.requestFocus());
        mInstrumentation.waitForIdleSync();

        // Move focus to calendar and verify the requested date.
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mDatePickerCalendarMode,
                KeyEvent.KEYCODE_TAB);
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mDatePickerCalendarMode,
                KeyEvent.KEYCODE_TAB);
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mDatePickerCalendarMode,
                KeyEvent.KEYCODE_TAB);
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mDatePickerCalendarMode,
                KeyEvent.KEYCODE_ENTER);
        assertValues(mDatePickerCalendarMode, 2015, Calendar.DECEMBER, 15);

        // Move focus to previous week and select previous week by pressing ENTER
        // key.
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mDatePickerCalendarMode,
                KeyEvent.KEYCODE_DPAD_UP);
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mDatePickerCalendarMode,
                KeyEvent.KEYCODE_ENTER);
        assertValues(mDatePickerCalendarMode, 2015, Calendar.DECEMBER, 8);

        // Move focus to previous week and this time select the previous week by
        // pressing NUMPAD_ENTER key.
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mDatePickerCalendarMode,
                KeyEvent.KEYCODE_DPAD_UP);
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mDatePickerCalendarMode,
                KeyEvent.KEYCODE_NUMPAD_ENTER);
        assertValues(mDatePickerCalendarMode, 2015, Calendar.DECEMBER, 1);
    }

    private void assertValues(DatePicker datePicker, int year, int month, int dayOfMonth) {
        assertEquals(year, datePicker.getYear());
        assertEquals(month, datePicker.getMonth());
        assertEquals(dayOfMonth, datePicker.getDayOfMonth());
    }

    private class MockDatePicker extends DatePicker {
        private boolean mCalledOnSaveInstanceState = false;
        private boolean mCalledOnRestoreInstanceState = false;

        public MockDatePicker(Context context) {
            super(context);
        }

        @Override
        protected void dispatchRestoreInstanceState(SparseArray<Parcelable> container) {
            super.dispatchRestoreInstanceState(container);
        }

        @Override
        protected Parcelable onSaveInstanceState() {
            mCalledOnSaveInstanceState = true;
            return super.onSaveInstanceState();
        }

        public boolean hasCalledOnSaveInstanceState() {
            return mCalledOnSaveInstanceState;
        }

        @Override
        protected void onRestoreInstanceState(Parcelable state) {
            mCalledOnRestoreInstanceState = true;
            super.onRestoreInstanceState(state);
        }

        public boolean hasCalledOnRestoreInstanceState() {
            return mCalledOnRestoreInstanceState;
        }
    }
}"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.security.FingerprintBoundKeysTest"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/security/FingerprintBoundKeysTest.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.security;

import android.Manifest;
import android.app.AlertDialog;
import android.app.Dialog;
import android.app.DialogFragment;
import android.app.KeyguardManager;
import android.content.Context;
import android.content.DialogInterface;
import android.content.pm.PackageManager;
import android.hardware.fingerprint.FingerprintManager;
import android.os.Bundle;
import android.os.CancellationSignal;
import android.security.keystore.KeyGenParameterSpec;
import android.security.keystore.KeyPermanentlyInvalidatedException;
import android.security.keystore.KeyProperties;
import android.security.keystore.UserNotAuthenticatedException;
import android.util.Log;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.Toast;

import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;

import java.io.IOException;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.UnrecoverableKeyException;
import java.security.cert.CertificateException;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.KeyGenerator;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;

public class FingerprintBoundKeysTest extends PassFailButtons.Activity {
    private static final boolean DEBUG = false;
    private static final String TAG = ""FingerprintBoundKeysTest"";

    /** Alias for our key in the Android Key Store. */
    private static final String KEY_NAME = ""my_key"";
    private static final byte[] SECRET_BYTE_ARRAY = new byte[] {1, 2, 3, 4, 5, 6};
    private static final int AUTHENTICATION_DURATION_SECONDS = 2;
    private static final int CONFIRM_CREDENTIALS_REQUEST_CODE = 1;
    private static final int BIOMETRIC_REQUEST_PERMISSION_CODE = 0;

    protected boolean useStrongBox;

    private FingerprintManager mFingerprintManager;
    private KeyguardManager mKeyguardManager;
    private FingerprintAuthDialogFragment mFingerprintDialog;
    private Cipher mCipher;

    protected int getTitleRes() {
        return R.string.sec_fingerprint_bound_key_test;
    }

    protected int getDescriptionRes() {
        return R.string.sec_fingerprint_bound_key_test_info;
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.sec_screen_lock_keys_main);
        setPassFailButtonClickListeners();
        setInfoResources(getTitleRes(), getDescriptionRes(), -1);
        getPassButton().setEnabled(false);
        requestPermissions(new String[]{Manifest.permission.USE_BIOMETRIC},
                BIOMETRIC_REQUEST_PERMISSION_CODE);
    }

    @Override
    public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] state) {
        if (requestCode == BIOMETRIC_REQUEST_PERMISSION_CODE && state[0] == PackageManager.PERMISSION_GRANTED) {
            useStrongBox = false;
            mFingerprintManager = (FingerprintManager) getSystemService(Context.FINGERPRINT_SERVICE);
            mKeyguardManager = getSystemService(KeyguardManager.class);
            Button startTestButton = findViewById(R.id.sec_start_test_button);

            if (!mKeyguardManager.isKeyguardSecure()) {
                // Show a message that the user hasn't set up a lock screen.
                showToast( ""Secure lock screen hasn't been set up.\n""
                                + ""Go to 'Settings -> Security -> Screen lock' to set up a lock screen"");
                startTestButton.setEnabled(false);
                return;
            }

            onPermissionsGranted();

            startTestButton.setOnClickListener(new OnClickListener() {
                @Override
                public void onClick(View v) {
                    startTest();
                }
            });
        }
    }

    /**
     * Fingerprint-specific check before allowing test to be started
     */
    protected void onPermissionsGranted() {
        mFingerprintManager = getSystemService(FingerprintManager.class);
        if (!mFingerprintManager.hasEnrolledFingerprints()) {
            showToast(""No fingerprints enrolled.\n""
                    + ""Go to 'Settings -> Security -> Fingerprint' to set up a fingerprint"");
            Button startTestButton = findViewById(R.id.sec_start_test_button);
            startTestButton.setEnabled(false);
        }
    }

    protected void startTest() {
        createKey(false /* hasValidityDuration */);
        prepareEncrypt();
        if (tryEncrypt()) {
            showToast(""Test failed. Key accessible without auth."");
        } else {
            prepareEncrypt();
            showAuthenticationScreen();
        }
    }

    /**
     * Creates a symmetric key in the Android Key Store which requires auth
     */
    private void createKey(boolean hasValidityDuration) {
        // Generate a key to decrypt payment credentials, tokens, etc.
        // This will most likely be a registration step for the user when they are setting up your app.
        try {
            KeyStore keyStore = KeyStore.getInstance(""AndroidKeyStore"");
            keyStore.load(null);
            KeyGenerator keyGenerator = KeyGenerator.getInstance(
                    KeyProperties.KEY_ALGORITHM_AES, ""AndroidKeyStore"");

            // Set the alias of the entry in Android KeyStore where the key will appear
            // and the constrains (purposes) in the constructor of the Builder
            keyGenerator.init(new KeyGenParameterSpec.Builder(KEY_NAME,
                    KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT)
                    .setBlockModes(KeyProperties.BLOCK_MODE_CBC)
                    .setUserAuthenticationRequired(true)
                    .setUserAuthenticationValidityDurationSeconds(
                        hasValidityDuration ? AUTHENTICATION_DURATION_SECONDS : -1)
                    .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_PKCS7)
                    .setIsStrongBoxBacked(useStrongBox)
                    .build());
            keyGenerator.generateKey();
            if (DEBUG) {
                Log.i(TAG, ""createKey: [1]: done"");
            }
        } catch (NoSuchAlgorithmException | NoSuchProviderException
                | InvalidAlgorithmParameterException | KeyStoreException
                | CertificateException | IOException e) {
            if (DEBUG) {
                Log.i(TAG, ""createKey: [2]: failed"");
            }
            throw new RuntimeException(""Failed to create a symmetric key"", e);
        }
    }

    /**
     * create and init cipher; has to be done before we do auth
     */
    private boolean prepareEncrypt() {
        return encryptInternal(false);
    }

    /**
     * Tries to encrypt some data with the generated key in {@link #createKey} which is
     * only works if the user has just authenticated via device credentials.
     * has to be run after successful auth, in order to succeed
     */
    protected boolean tryEncrypt() {
        return encryptInternal(true);
    }

    protected Cipher getCipher() {
        return mCipher;
    }

    protected boolean doValidityDurationTest(boolean useStrongBox) {
        mCipher = null;
        createKey(true /* hasValidityDuration */);
        if (prepareEncrypt()) {
            return tryEncrypt();
        }
        return false;
    }

    private boolean encryptInternal(boolean doEncrypt) {
        try {
            if (!doEncrypt) {
                KeyStore keyStore = KeyStore.getInstance(""AndroidKeyStore"");
                keyStore.load(null);
                SecretKey secretKey = (SecretKey) keyStore.getKey(KEY_NAME, null);
                if (DEBUG) {
                    Log.i(TAG, ""encryptInternal: [1]: key retrieved"");
                }
                if (mCipher == null) {
                    mCipher = Cipher.getInstance(KeyProperties.KEY_ALGORITHM_AES + ""/""
                            + KeyProperties.BLOCK_MODE_CBC + ""/""
                            + KeyProperties.ENCRYPTION_PADDING_PKCS7);
                }
                mCipher.init(Cipher.ENCRYPT_MODE, secretKey);
                if (DEBUG) {
                    Log.i(TAG, ""encryptInternal: [2]: cipher initialized"");
                }
            } else {
                mCipher.doFinal(SECRET_BYTE_ARRAY);
                if (DEBUG) {
                    Log.i(TAG, ""encryptInternal: [3]: encryption performed"");
                }
            }
            return true;
        } catch (BadPaddingException | IllegalBlockSizeException e) {
            // this happens in ""no-error"" scenarios routinely;
            // All we want it to see the event in the log;
            // Extra exception info is not valuable
            if (DEBUG) {
                Log.w(TAG, ""encryptInternal: [4]: Encryption failed"", e);
            }
            return false;
        } catch (KeyPermanentlyInvalidatedException e) {
            // Extra exception info is not of big value, but let's have it,
            // since this is an unlikely sutuation and potential error condition
            Log.w(TAG, ""encryptInternal: [5]: Key invalidated"", e);
            createKey(false /* hasValidityDuration */);
            showToast(""The key has been invalidated, please try again.\n"");
            return false;
        } catch (UserNotAuthenticatedException e) {
            Log.w(TAG, ""encryptInternal: [6]: User not authenticated"", e);
            return false;
        } catch (NoSuchPaddingException | KeyStoreException | CertificateException
                 | UnrecoverableKeyException | IOException
                 | NoSuchAlgorithmException | InvalidKeyException e) {
            throw new RuntimeException(""Failed to init Cipher"", e);
        }
    }

    protected void showAuthenticationScreen() {
        mFingerprintDialog = new FingerprintAuthDialogFragment();
        mFingerprintDialog.setActivity(this);
        mFingerprintDialog.show(getFragmentManager(), ""fingerprint_dialog"");
    }

    protected void showToast(String message) {
        Toast.makeText(this, message, Toast.LENGTH_LONG).show();
    }

    public static class FingerprintAuthDialogFragment extends DialogFragment {

        private FingerprintBoundKeysTest mActivity;
        private CancellationSignal mCancellationSignal;
        private FingerprintManager mFingerprintManager;
        private FingerprintManagerCallback mFingerprintManagerCallback;
        private boolean mSelfCancelled;
        private boolean hasStrongBox;

        class FingerprintManagerCallback extends FingerprintManager.AuthenticationCallback {
            @Override
            public void onAuthenticationError(int errMsgId, CharSequence errString) {
                if (DEBUG) {
                    Log.i(TAG,""onAuthenticationError: id="" + errMsgId + ""; str="" + errString);
                }
                if (!mSelfCancelled) {
                    showToast(errString.toString());
                }
            }

            @Override
            public void onAuthenticationHelp(int helpMsgId, CharSequence helpString) {
                showToast(helpString.toString());
            }

            @Override
            public void onAuthenticationFailed() {
                if (DEBUG) {
                    Log.i(TAG,""onAuthenticationFailed"");
                }
                showToast(getString(R.string.sec_fp_auth_failed));
            }

            @Override
            public void onAuthenticationSucceeded(FingerprintManager.AuthenticationResult result) {
                if (DEBUG) {
                    Log.i(TAG,""onAuthenticationSucceeded"");
                }
                hasStrongBox = getContext().getPackageManager()
                                    .hasSystemFeature(PackageManager.FEATURE_STRONGBOX_KEYSTORE);
                if (mActivity.tryEncrypt() &&
                    mActivity.doValidityDurationTest(false)) {
                    try {
                        Thread.sleep(3000);
                    } catch (Exception e) {
                        throw new RuntimeException(""Failed to sleep"", e);
                    }
                    if (!mActivity.doValidityDurationTest(false)) {
                        showToast(String.format(""Test passed. useStrongBox: %b"",
                                                mActivity.useStrongBox));
                        if (mActivity.useStrongBox || !hasStrongBox) {
                            mActivity.getPassButton().setEnabled(true);
                        } else {
                            showToast(""Rerunning with StrongBox"");
                        }
                        FingerprintAuthDialogFragment.this.dismiss();
                    } else {
                        showToast(""Test failed. Key accessible after validity time limit."");
                    }
                } else {
                    showToast(""Test failed. Key not accessible after auth"");
                }
            }
        }

        @Override
        public void onDismiss(DialogInterface dialog) {
            mCancellationSignal.cancel();
            mSelfCancelled = true;
            // Start the test again, but with StrongBox if supported
            if (!mActivity.useStrongBox && hasStrongBox) {
                mActivity.useStrongBox = true;
                mActivity.startTest();
            }
        }

        private void setActivity(FingerprintBoundKeysTest activity) {
            mActivity = activity;
        }

        private void showToast(String message) {
            Toast.makeText(getContext(), message, Toast.LENGTH_LONG)
                .show();
        }

        @Override
        public Dialog onCreateDialog(Bundle savedInstanceState) {
            mCancellationSignal = new CancellationSignal();
            mSelfCancelled = false;
            mFingerprintManager =
                    (FingerprintManager) getContext().getSystemService(Context.FINGERPRINT_SERVICE);
            mFingerprintManagerCallback = new FingerprintManagerCallback();
            mFingerprintManager.authenticate(
                    new FingerprintManager.CryptoObject(mActivity.mCipher),
                    mCancellationSignal, 0, mFingerprintManagerCallback, null);
            AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
            builder.setMessage(R.string.sec_fp_dialog_message);
            return builder.create();
        }

    }
}"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.media.cts.NativeDecoderTest"	"SKIP_testExtractor"	"CtsMediaTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/NativeDecoderTest.java"	""	"public void test/*
 *.
 */

package android.media.cts;

import android.content.res.AssetFileDescriptor;
import android.media.MediaCodec;
import android.media.MediaCodec.BufferInfo;
import android.media.MediaExtractor;
import android.media.MediaFormat;
import android.media.MediaPlayer;
import android.media.cts.TestUtils.Monitor;
import android.net.Uri;
import android.os.Build;
import android.os.ParcelFileDescriptor;
import android.platform.test.annotations.AppModeFull;
import android.platform.test.annotations.Presubmit;
import android.platform.test.annotations.RequiresDevice;
import android.util.Log;
import android.view.Surface;
import android.webkit.cts.CtsTestServer;

import androidx.test.filters.SmallTest;

import com.android.compatibility.common.util.ApiLevelUtil;
import com.android.compatibility.common.util.MediaUtils;

import org.apache.http.Header;
import org.apache.http.HttpRequest;
import org.apache.http.impl.DefaultHttpServerConnection;
import org.apache.http.impl.io.SocketOutputBuffer;
import org.apache.http.io.SessionOutputBuffer;
import org.apache.http.params.HttpParams;
import org.apache.http.util.CharArrayBuffer;

import java.io.File;
import java.io.FileDescriptor;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.net.Socket;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.zip.Adler32;

@SmallTest
@RequiresDevice
@AppModeFull(reason = ""TODO: evaluate and port to instant"")
public class NativeDecoderTest extends MediaPlayerTestBase {
    private static final String TAG = ""DecoderTest"";

    private static final int RESET_MODE_NONE = 0;
    private static final int RESET_MODE_RECONFIGURE = 1;
    private static final int RESET_MODE_FLUSH = 2;
    private static final int RESET_MODE_EOS_FLUSH = 3;

    private static final String[] CSD_KEYS = new String[] { ""csd-0"", ""csd-1"" };

    private static final int CONFIG_MODE_NONE = 0;
    private static final int CONFIG_MODE_QUEUE = 1;

    private static boolean sIsAtLeastS = ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S);

    static final String mInpPrefix = WorkDir.getMediaDirString();
    short[] mMasterBuffer;

    /** Load jni on initialization */
    static {
        Log.i(""@@@"", ""before loadlibrary"");
        System.loadLibrary(""ctsmediacodec_jni"");
        Log.i(""@@@"", ""after loadlibrary"");
    }

    @Override
    protected void setUp() throws Exception {
        super.setUp();

    }

    // check that native extractor behavior matches java extractor

    private void compareArrays(String message, int[] a1, int[] a2) {
        if (a1 == a2) {
            return;
        }

        assertNotNull(message + "": array 1 is null"", a1);
        assertNotNull(message + "": array 2 is null"", a2);

        assertEquals(message + "": arraylengths differ"", a1.length, a2.length);
        int length = a1.length;

        for (int i = 0; i < length; i++)
            if (a1[i] != a2[i]) {
                Log.i(""@@@@"", Arrays.toString(a1));
                Log.i(""@@@@"", Arrays.toString(a2));
                fail(message + "": at index "" + i);
            }
    }

    public void SKIP_testExtractor() throws Exception {
        // duplicate of CtsMediaV2TestCases:ExtractorTest$FunctionalityTest#testExtract where
        // checksum is computed over track format attributes, track buffer and buffer
        // info in both SDK and NDK side and checked for equality
        testExtractor(""sinesweepogg.ogg"");
        testExtractor(""sinesweepoggmkv.mkv"");
        testExtractor(""sinesweepoggmp4.mp4"");
        testExtractor(""sinesweepmp3lame.mp3"");
        testExtractor(""sinesweepmp3smpb.mp3"");
        testExtractor(""sinesweepopus.mkv"");
        testExtractor(""sinesweepopusmp4.mp4"");
        testExtractor(""sinesweepm4a.m4a"");
        testExtractor(""sinesweepflacmkv.mkv"");
        testExtractor(""sinesweepflac.flac"");
        testExtractor(""sinesweepflacmp4.mp4"");
        testExtractor(""sinesweepwav.wav"");

        testExtractor(""video_1280x720_mp4_h264_1000kbps_25fps_aac_stereo_128kbps_44100hz.mp4"");
        testExtractor(""bbb_s3_1280x720_webm_vp8_8mbps_60fps_opus_6ch_384kbps_48000hz.webm"");
        testExtractor(""bbb_s4_1280x720_webm_vp9_0p31_4mbps_30fps_opus_stereo_128kbps_48000hz.webm"");
        testExtractor(""video_1280x720_webm_av1_2000kbps_30fps_vorbis_stereo_128kbps_48000hz.webm"");
        testExtractor(""video_176x144_3gp_h263_300kbps_12fps_aac_mono_24kbps_11025hz.3gp"");
        testExtractor(""video_480x360_mp4_mpeg2_1500kbps_30fps_aac_stereo_128kbps_48000hz.mp4"");
        testExtractor(""video_480x360_mp4_mpeg4_860kbps_25fps_aac_stereo_128kbps_44100hz.mp4"");

        CtsTestServer foo = new CtsTestServer(mContext);
        testExtractor(foo.getAssetUrl(""noiseandchirps.ogg""), null, null);
        testExtractor(foo.getAssetUrl(""ringer.mp3""), null, null);
        testExtractor(foo.getRedirectingAssetUrl(""ringer.mp3""), null, null);

        String[] keys = new String[] {""header0"", ""header1""};
        String[] values = new String[] {""value0"", ""value1""};
        testExtractor(foo.getAssetUrl(""noiseandchirps.ogg""), keys, values);
        HttpRequest req = foo.getLastRequest(""noiseandchirps.ogg"");
        for (int i = 0; i < keys.length; i++) {
            String key = keys[i];
            String value = values[i];
            Header[] header = req.getHeaders(key);
            assertTrue(""expecting "" + key + "":"" + value + "", saw "" + Arrays.toString(header),
                    header.length == 1 && header[0].getValue().equals(value));
        }

        String[] emptyArray = new String[0];
        testExtractor(foo.getAssetUrl(""noiseandchirps.ogg""), emptyArray, emptyArray);
    }

    /**
     * |keys| and |values| should be arrays of the same length.
     *
     * If keys or values is null, test {@link MediaExtractor#setDataSource(String)}
     * and NDK counter part, i.e. set data source without headers.
     *
     * If keys or values is zero length, test {@link MediaExtractor#setDataSource(String, Map))}
     * and NDK counter part with null headers.
     *
     */
    private void testExtractor(String path, String[] keys, String[] values) throws Exception {
        int[] jsizes = getSampleSizes(path, keys, values);
        int[] nsizes = getSampleSizesNativePath(path, keys, values, /* testNativeSource = */ false);
        int[] nsizes2 = getSampleSizesNativePath(path, keys, values, /* testNativeSource = */ true);

        compareArrays(""different samplesizes"", jsizes, nsizes);
        compareArrays(""different samplesizes native source"", jsizes, nsizes2);
    }

    protected static AssetFileDescriptor getAssetFileDescriptorFor(final String res)
            throws FileNotFoundException {
        Preconditions.assertTestFileExists(mInpPrefix + res);
        File inpFile = new File(mInpPrefix + res);
        ParcelFileDescriptor parcelFD =
                ParcelFileDescriptor.open(inpFile, ParcelFileDescriptor.MODE_READ_ONLY);
        return new AssetFileDescriptor(parcelFD, 0, parcelFD.getStatSize());
    }

    private void testExtractor(final String res) throws Exception {
        AssetFileDescriptor fd = getAssetFileDescriptorFor(res);

        int[] jsizes = getSampleSizes(
                fd.getFileDescriptor(), fd.getStartOffset(), fd.getLength());
        int[] nsizes = getSampleSizesNative(
                fd.getParcelFileDescriptor().getFd(), fd.getStartOffset(), fd.getLength());

        fd.close();
        compareArrays(""different samples"", jsizes, nsizes);
    }

    private static int[] getSampleSizes(String path, String[] keys, String[] values) throws IOException {
        MediaExtractor ex = new MediaExtractor();
        if (keys == null || values == null) {
            ex.setDataSource(path);
        } else {
            Map<String, String> headers = null;
            int numheaders = Math.min(keys.length, values.length);
            for (int i = 0; i < numheaders; i++) {
                if (headers == null) {
                    headers = new HashMap<>();
                }
                String key = keys[i];
                String value = values[i];
                headers.put(key, value);
            }
            ex.setDataSource(path, headers);
        }

        return getSampleSizes(ex);
    }

    private static int[] getSampleSizes(FileDescriptor fd, long offset, long size)
            throws IOException {
        MediaExtractor ex = new MediaExtractor();
        ex.setDataSource(fd, offset, size);
        return getSampleSizes(ex);
    }

    private static int[] getSampleSizes(MediaExtractor ex) {
        ArrayList<Integer> foo = new ArrayList<Integer>();
        ByteBuffer buf = ByteBuffer.allocate(1024*1024);
        int numtracks = ex.getTrackCount();
        assertTrue(""no tracks"", numtracks > 0);
        foo.add(numtracks);
        for (int i = 0; i < numtracks; i++) {
            MediaFormat format = ex.getTrackFormat(i);
            String mime = format.getString(MediaFormat.KEY_MIME);
            if (mime.startsWith(""audio/"")) {
                foo.add(0);
                foo.add(format.getInteger(MediaFormat.KEY_SAMPLE_RATE));
                foo.add(format.getInteger(MediaFormat.KEY_CHANNEL_COUNT));
                foo.add((int)format.getLong(MediaFormat.KEY_DURATION));
            } else if (mime.startsWith(""video/"")) {
                foo.add(1);
                foo.add(format.getInteger(MediaFormat.KEY_WIDTH));
                foo.add(format.getInteger(MediaFormat.KEY_HEIGHT));
                foo.add((int)format.getLong(MediaFormat.KEY_DURATION));
            } else {
                fail(""unexpected mime type: "" + mime);
            }
            ex.selectTrack(i);
        }
        while(true) {
            int n = ex.readSampleData(buf, 0);
            if (n < 0) {
                break;
            }
            foo.add(n);
            foo.add(ex.getSampleTrackIndex());
            foo.add(ex.getSampleFlags());
            foo.add((int)ex.getSampleTime()); // just the low bits should be OK
            byte foobar[] = new byte[n];
            buf.get(foobar, 0, n);
            foo.add((int)adler32(foobar));
            ex.advance();
        }

        int [] ret = new int[foo.size()];
        for (int i = 0; i < ret.length; i++) {
            ret[i] = foo.get(i);
        }
        return ret;
    }

    private static native int[] getSampleSizesNative(int fd, long offset, long size);
    private static native int[] getSampleSizesNativePath(
            String path, String[] keys, String[] values, boolean testNativeSource);

    @Presubmit
    public void SKIP_testExtractorFileDurationNative() throws Exception {
        // duplicate of CtsMediaV2TestCases:ExtractorTest$FunctionalityTest#testExtract where
        // checksum is computed over track format attributes, track buffer and buffer
        // info in both SDK and NDK side and checked for equality. KEY_DURATION for each track is
        // part of the checksum.
        testExtractorFileDurationNative(
                ""video_1280x720_mp4_h264_1000kbps_25fps_aac_stereo_128kbps_44100hz.mp4"");
    }

    private void testExtractorFileDurationNative(final String res) throws Exception {
        AssetFileDescriptor fd = getAssetFileDescriptorFor(res);
        long durationUs = getExtractorFileDurationNative(
                fd.getParcelFileDescriptor().getFd(), fd.getStartOffset(), fd.getLength());

        MediaExtractor ex = new MediaExtractor();
        ex.setDataSource(fd.getFileDescriptor(), fd.getStartOffset(), fd.getLength());

        int numtracks = ex.getTrackCount();
        long aDurationUs = -1, vDurationUs = -1;
        for (int i = 0; i < numtracks; i++) {
            MediaFormat format = ex.getTrackFormat(i);
            String mime = format.getString(MediaFormat.KEY_MIME);
            if (mime.startsWith(""audio/"")) {
                aDurationUs = format.getLong(MediaFormat.KEY_DURATION);
            } else if (mime.startsWith(""video/"")) {
                vDurationUs = format.getLong(MediaFormat.KEY_DURATION);
            }
        }

        assertTrue(""duration inconsistency"",
                durationUs < 0 || durationUs >= aDurationUs && durationUs >= vDurationUs);

    }

    private static native long getExtractorFileDurationNative(int fd, long offset, long size);

    @Presubmit
    public void SKIP_testExtractorCachedDurationNative() throws Exception {
        // duplicate of CtsMediaV2TestCases:ExtractorTest$SetDataSourceTest#testDataSourceNative
        CtsTestServer foo = new CtsTestServer(mContext);
        String url = foo.getAssetUrl(""ringer.mp3"");
        long cachedDurationUs = getExtractorCachedDurationNative(url, /* testNativeSource = */ false);
        assertTrue(""cached duration negative"", cachedDurationUs >= 0);
        cachedDurationUs = getExtractorCachedDurationNative(url, /* testNativeSource = */ true);
        assertTrue(""cached duration negative native source"", cachedDurationUs >= 0);
    }

    private static native long getExtractorCachedDurationNative(String uri, boolean testNativeSource);

    public void SKIP_testDecoder() throws Exception {
        // duplicate of CtsMediaV2TestCases:CodecDecoderTest#testSimpleDecode where checksum  is
        // computed over decoded output in both SDK and NDK side and checked for equality.
        int testsRun =
            testDecoder(""sinesweepogg.ogg"") +
            testDecoder(""sinesweepoggmkv.mkv"") +
            testDecoder(""sinesweepoggmp4.mp4"") +
            testDecoder(""sinesweepmp3lame.mp3"") +
            testDecoder(""sinesweepmp3smpb.mp3"") +
            testDecoder(""sinesweepopus.mkv"") +
            testDecoder(""sinesweepopusmp4.mp4"") +
            testDecoder(""sinesweepm4a.m4a"") +
            testDecoder(""sinesweepflacmkv.mkv"") +
            testDecoder(""sinesweepflac.flac"") +
            testDecoder(""sinesweepflacmp4.mp4"") +
            testDecoder(""sinesweepwav.wav"") +
            testDecoder(""video_1280x720_mp4_h264_1000kbps_25fps_aac_stereo_128kbps_44100hz.mp4"") +
            testDecoder(""bbb_s1_640x360_webm_vp8_2mbps_30fps_vorbis_5ch_320kbps_48000hz.webm"") +
            testDecoder(""bbb_s1_640x360_webm_vp9_0p21_1600kbps_30fps_vorbis_stereo_128kbps_48000hz.webm"") +
            testDecoder(""video_176x144_3gp_h263_300kbps_12fps_aac_mono_24kbps_11025hz.3gp"") +
            testDecoder(""video_480x360_mp4_mpeg2_1500kbps_30fps_aac_stereo_128kbps_48000hz.mp4"");
            testDecoder(""video_480x360_mp4_mpeg4_860kbps_25fps_aac_stereo_128kbps_44100hz.mp4"");
        if (testsRun == 0) {
            MediaUtils.skipTest(""no decoders found"");
        }
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.widget.cts.ListViewTest"	"testFullDetachHeaderViewOnScrollForFocus"	"CtsWidgetTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/ListViewTest.java"	""	"public void testFullDetachHeaderViewOnScrollForFocus() throws Throwable {
        final AttachDetachAwareView header = new AttachDetachAwareView(mActivity);
        WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, mListView, () -> {
            mListView.setAdapter(new DummyAdapter(1000));
            mListView.addHeaderView(header);
        });
        assertEquals(""test sanity"", 1, header.mOnAttachCount);
        assertEquals(""test sanity"", 0, header.mOnDetachCount);
        while (header.getParent() != null) {
            assertEquals(""header view should NOT be detached"", 0, header.mOnDetachCount);
            CtsKeyEventUtil.sendKeys(mInstrumentation, mListView, KeyEvent.KEYCODE_DPAD_DOWN);
            WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, mListView, null);
        }
        assertEquals(""header view should be detached"", 1, header.mOnDetachCount);
        assertFalse(header.isTemporarilyDetached());
    }

    @MediumTest"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.widget.cts.ListViewTest"	"testFullyDetachUnusedViewOnScrollForFocus"	"CtsWidgetTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/ListViewTest.java"	""	"public void testFullyDetachUnusedViewOnScrollForFocus() throws Throwable {
        final AttachDetachAwareView theView = new AttachDetachAwareView(mActivity);
        WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, mListView,
                () -> mListView.setAdapter(new DummyAdapter(1000, theView)));
        assertEquals(""test sanity"", 1, theView.mOnAttachCount);
        assertEquals(""test sanity"", 0, theView.mOnDetachCount);
        while(theView.getParent() != null) {
            assertEquals(""the view should NOT be detached"", 0, theView.mOnDetachCount);
            CtsKeyEventUtil.sendKeys(mInstrumentation, mListView, KeyEvent.KEYCODE_DPAD_DOWN);
            WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, mListView, null);
        }
        assertEquals(""the view should be detached"", 1, theView.mOnDetachCount);
        assertFalse(theView.isTemporarilyDetached());
        while(theView.getParent() == null) {
            CtsKeyEventUtil.sendKeys(mInstrumentation, mListView, KeyEvent.KEYCODE_DPAD_UP);
            WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, mListView, null);
        }
        assertEquals(""the view should be re-attached"", 2, theView.mOnAttachCount);
        assertEquals(""the view should not recieve another detach"", 1, theView.mOnDetachCount);
        assertFalse(theView.isTemporarilyDetached());
    }

    @MediumTest"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.security.identity.cts.UserAuthTest"	"isDeviceLocked"	"CtsIdentityTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/identity/src/android/security/identity/cts/UserAuthTest.java"	""	"/*
 *.
 */

package android.security.identity.cts;

import static android.security.identity.IdentityCredentialStore.CIPHERSUITE_ECDHE_HKDF_ECDSA_WITH_AES_256_GCM_SHA256;

import android.security.identity.AccessControlProfile;
import android.security.identity.AccessControlProfileId;
import android.security.identity.AlreadyPersonalizedException;
import android.security.identity.PersonalizationData;
import android.security.identity.IdentityCredential;
import android.security.identity.IdentityCredentialException;
import android.security.identity.IdentityCredentialStore;
import android.security.identity.WritableIdentityCredential;
import android.security.identity.ResultData;
import com.android.security.identity.internal.Util;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assume.assumeTrue;

import android.content.Context;
import android.os.SystemClock;
import android.util.Log;

import androidx.test.InstrumentationRegistry;

import android.app.KeyguardManager;
import android.server.wm.ActivityManagerTestBase;

import org.junit.Test;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.KeyPair;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.Signature;
import java.security.SignatureException;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.Collection;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.Map;

import co.nstant.in.cbor.CborBuilder;
import co.nstant.in.cbor.CborEncoder;
import co.nstant.in.cbor.CborException;

import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.PrivateKey;
import java.security.UnrecoverableEntryException;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.KeyGenerator;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.spec.GCMParameterSpec;

import android.security.keystore.KeyGenParameterSpec;
import android.security.keystore.KeyProperties;
import android.security.keystore.UserNotAuthenticatedException;


public class UserAuthTest {
    private static final String TAG = ""UserAuthTest"";

    private class DeviceLockSession extends ActivityManagerTestBase implements AutoCloseable {

        private LockScreenSession mLockCredential;

        public DeviceLockSession() throws Exception {
            mLockCredential = new LockScreenSession();
            mLockCredential.setLockCredential();
        }

        public void performDeviceLock() {
            mLockCredential.sleepDevice();
            Context appContext = InstrumentationRegistry.getTargetContext();
            KeyguardManager keyguardManager = (KeyguardManager)appContext.
                                              getSystemService(Context.KEYGUARD_SERVICE);
            for (int i = 0; i < 25 && !keyguardManager.isDeviceLocked(); i++) {
                SystemClock.sleep(200);
            }
        }

        public void performDeviceUnlock() throws Exception {
            mLockCredential.gotoKeyguard();
            mLockCredential.enterAndConfirmLockCredential();
            launchHomeActivity();
            Context appContext = InstrumentationRegistry.getTargetContext();
            KeyguardManager keyguardManager = (KeyguardManager)appContext.
                                              getSystemService(Context.KEYGUARD_SERVICE);
            int waitCount = 5;
            do {
                SystemClock.sleep(1000);
                if (!keyguardManager.isDeviceLocked()) {
                    break;
                }
                Log.w(TAG, ""Device was still locked, sleeping and retrying..."");
                mLockCredential.enterAndConfirmLockCredential();
            } while (waitCount-- >= 0);
        }

        @Override
        public void close() throws Exception {
            mLockCredential.close();
        }
    }

    private boolean checkAuthBoundKey(String alias) {
        // Unfortunately there are no APIs to tell if a key needs user authentication to work so
        // we check if the key is available by simply trying to encrypt some data.
        try {
            KeyStore ks = KeyStore.getInstance(""AndroidKeyStore"");
            ks.load(null);
            KeyStore.Entry entry = ks.getEntry(alias, null);
            SecretKey secretKey = ((KeyStore.SecretKeyEntry) entry).getSecretKey();

            Cipher cipher = Cipher.getInstance(""AES/GCM/NoPadding"");
            cipher.init(Cipher.ENCRYPT_MODE, secretKey);
            byte[] clearText = {0x01, 0x02};
            byte[] cipherText = cipher.doFinal(clearText);
            return true;
        } catch (UserNotAuthenticatedException e) {
            return false;
        } catch (Exception e) {
            throw new RuntimeException(""Failed!"", e);
        }
    }

    void createAuthBoundKey(String alias, int timeoutSeconds) {
        try {
            KeyGenerator kg = KeyGenerator.getInstance(
                KeyProperties.KEY_ALGORITHM_AES, ""AndroidKeyStore"");
            KeyGenParameterSpec.Builder builder =
                    new KeyGenParameterSpec.Builder(
                        alias,
                        KeyProperties.PURPOSE_ENCRYPT| KeyProperties.PURPOSE_DECRYPT)
                            .setBlockModes(KeyProperties.BLOCK_MODE_GCM)
                            .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE)
                            .setUserAuthenticationRequired(true)
                            .setUserAuthenticationValidityDurationSeconds(timeoutSeconds)
                            .setKeySize(128);
            kg.init(builder.build());
            kg.generateKey();
        } catch (InvalidAlgorithmParameterException
                | NoSuchAlgorithmException
                | NoSuchProviderException e) {
            throw new RuntimeException(""Error creating auth-bound key"", e);
        }
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.keystore.cts.KeyChainTest"	"testIsBoundKeyAlgorithm_RequiredAlgorithmsSupported"	"CtsKeystoreTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/keystore/src/android/keystore/cts/KeyChainTest.java"	""	"public void testIsBoundKeyAlgorithm_RequiredAlgorithmsSupported() throws Exception {
        if (isLeanbackOnly()) {
            KeyChain.isBoundKeyAlgorithm(""RSA"");
        }
        else {
            assertTrue(""RSA must be hardware-backed by a hardware-specific Keymaster HAL"",
                       KeyChain.isBoundKeyAlgorithm(""RSA""));
        }

        // These are not required, but must not throw an exception
        KeyChain.isBoundKeyAlgorithm(""DSA"");
        KeyChain.isBoundKeyAlgorithm(""EC"");
    }

    private boolean isLeanbackOnly() {
        PackageManager pm = getContext().getPackageManager();
        return (pm != null && pm.hasSystemFeature(""android.software.leanback_only""));
    }
}"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.biometrics.BiometricStrongTests"	"isOnPauseAllowed"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/biometrics/BiometricStrongTests.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.biometrics;

import static android.hardware.biometrics.BiometricManager.Authenticators;

import android.content.DialogInterface;
import android.content.pm.PackageManager;
import android.hardware.biometrics.BiometricManager;
import android.hardware.biometrics.BiometricPrompt;
import android.hardware.biometrics.BiometricPrompt.AuthenticationCallback;
import android.hardware.biometrics.BiometricPrompt.AuthenticationResult;
import android.hardware.biometrics.BiometricPrompt.CryptoObject;
import android.os.Bundle;
import android.os.CancellationSignal;
import android.provider.Settings;
import android.security.keystore.KeyPermanentlyInvalidatedException;
import android.util.Log;
import android.view.View;
import android.widget.Button;

import com.android.cts.verifier.R;

import java.util.Arrays;

import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;

/**
 * On devices without a strong biometric, ensure that the
 * {@link BiometricManager#canAuthenticate(int)} returns
 * {@link BiometricManager#BIOMETRIC_ERROR_NO_HARDWARE}
 *
 * Ensure that this result is consistent with the configuration in core/res/res/values/config.xml
 *
 * Ensure that invoking {@link Settings.ACTION_BIOMETRIC_ENROLL} with its corresponding
 * {@link Settings.EXTRA_BIOMETRIC_AUTHENTICATORS_ALLOWED} enrolls a
 * {@link BiometricManager.Authenticators.BIOMETRIC_STRONG} authenticator. This can be done by
 * authenticating a {@link BiometricPrompt.CryptoObject}.
 *
 * Ensure that authentication with a strong biometric unlocks the appropriate keys.
 *
 * Ensure that the BiometricPrompt UI displays all fields in the public API surface.
 */
public class BiometricStrongTests extends AbstractBaseTest {
    private static final String TAG = ""BiometricStrongTests"";

    private static final String KEY_NAME_STRONGBOX = ""key_using_strongbox"";
    private static final String KEY_NAME_NO_STRONGBOX = ""key_without_strongbox"";
    private static final byte[] PAYLOAD = new byte[] {1, 2, 3, 4, 5, 6};

    // TODO: Build these lists in a smarter way. For now, when adding a test to this list, please
    // double check the logic in isOnPauseAllowed()
    private boolean mHasStrongBox;
    private Button mCheckAndEnrollButton;
    private Button mAuthenticateWithoutStrongBoxButton;
    private Button mAuthenticateWithStrongBoxButton;
    private Button mKeyInvalidatedButton;

    private boolean mAuthenticateWithoutStrongBoxPassed;
    private boolean mAuthenticateWithStrongBoxPassed;
    private boolean mKeyInvalidatedStrongboxPassed;
    private boolean mKeyInvalidatedNoStrongboxPassed;

    @Override
    protected String getTag() {
        return TAG;
    }

    @Override
    protected void onBiometricEnrollFinished() {
        final int biometricStatus =
                mBiometricManager.canAuthenticate(Authenticators.BIOMETRIC_STRONG);
        if (biometricStatus == BiometricManager.BIOMETRIC_SUCCESS) {
            showToastAndLog(""Successfully enrolled, please continue the test"");
            mCheckAndEnrollButton.setEnabled(false);
            mAuthenticateWithoutStrongBoxButton.setEnabled(true);
            mAuthenticateWithStrongBoxButton.setEnabled(true);
        } else {
            showToastAndLog(""Unexpected result after enrollment: "" + biometricStatus);
        }
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.biometric_test_strong_tests);
        setPassFailButtonClickListeners();
        getPassButton().setEnabled(false);

        mCheckAndEnrollButton = findViewById(R.id.check_and_enroll_button);
        mAuthenticateWithoutStrongBoxButton = findViewById(R.id.authenticate_no_strongbox_button);
        mAuthenticateWithStrongBoxButton = findViewById(R.id.authenticate_strongbox_button);
        mKeyInvalidatedButton = findViewById(R.id.authenticate_key_invalidated_button);

        mHasStrongBox = getPackageManager()
                .hasSystemFeature(PackageManager.FEATURE_STRONGBOX_KEYSTORE);
        if (!mHasStrongBox) {
            Log.d(TAG, ""Device does not support StrongBox"");
            mAuthenticateWithStrongBoxButton.setVisibility(View.GONE);
            mAuthenticateWithStrongBoxPassed = true;
            mKeyInvalidatedStrongboxPassed = true;
        }

        mCheckAndEnrollButton.setOnClickListener((view) -> {
            checkAndEnroll(mCheckAndEnrollButton, Authenticators.BIOMETRIC_STRONG);
        });

        mAuthenticateWithoutStrongBoxButton.setOnClickListener((view) -> {
            testBiometricBoundEncryption(KEY_NAME_NO_STRONGBOX, PAYLOAD,
                    false /* useStrongBox */);
        });

        mAuthenticateWithStrongBoxButton.setOnClickListener((view) -> {
            testBiometricBoundEncryption(KEY_NAME_STRONGBOX, PAYLOAD,
                    true /* useStrongBox */);
        });

        mKeyInvalidatedButton.setOnClickListener((view) -> {
            Utils.showInstructionDialog(this,
                    R.string.biometric_test_strong_authenticate_invalidated_instruction_title,
                    R.string.biometric_test_strong_authenticate_invalidated_instruction_contents,
                    R.string.biometric_test_strong_authenticate_invalidated_instruction_continue,
                    (dialog, which) -> {
                if (which == DialogInterface.BUTTON_POSITIVE) {
                    // If the device supports StrongBox, check that this key is invalidated.
                    if (mHasStrongBox)
                        if (isKeyInvalidated(KEY_NAME_STRONGBOX)) {
                            mKeyInvalidatedStrongboxPassed = true;
                        } else {
                            showToastAndLog(""StrongBox key not invalidated"");
                            return;
                        }
                    }

                // Always check that non-StrongBox keys are invalidated.
                if (isKeyInvalidated(KEY_NAME_NO_STRONGBOX)) {
                    mKeyInvalidatedNoStrongboxPassed = true;
                } else {
                    showToastAndLog(""Key not invalidated"");
                    return;
                }

                mKeyInvalidatedButton.setEnabled(false);
                updatePassButton();
            });
        });
    }

    @Override
    protected boolean isOnPauseAllowed() {
        // Test hasn't started yet, user may need to go to Settings to remove enrollments
        if (mCheckAndEnrollButton.isEnabled()) {
            return true;
        }

        // Key invalidation test is currently the last test. Thus, if every other test is currently
        // completed, let's allow onPause (allow tester to go into settings multiple times if
        // needed).
        if (mAuthenticateWithoutStrongBoxPassed && mAuthenticateWithStrongBoxPassed) {
            return true;
        }

        if (mCurrentlyEnrolling) {
            return true;
        }

        return false;
    }

    private boolean isKeyInvalidated(String keyName) {
        try {
            Utils.initCipher(keyName);
        } catch (KeyPermanentlyInvalidatedException e) {
            return true;
        } catch (Exception e) {
            showToastAndLog(""Unexpected exception: "" + e);
        }
        return false;
    }

    private void testBiometricBoundEncryption(String keyName, byte[] secret, boolean useStrongBox) {
        try {
            // Create the biometric-bound key
            Utils.createBiometricBoundKey(keyName, useStrongBox);

            // Initialize a cipher and try to use it before a biometric has been authenticated
            Cipher tryUseBeforeAuthCipher = Utils.initCipher(keyName);

            try {
                byte[] encrypted = Utils.doEncrypt(tryUseBeforeAuthCipher, secret);
                showToastAndLog(""Should not be able to encrypt prior to authenticating: ""
                        + Arrays.toString(encrypted));
                return;
            } catch (IllegalBlockSizeException e) {
                // Normal, user has not authenticated yet
                Log.d(TAG, ""Exception before authentication has occurred: "" + e);
            }

            // Initialize a cipher and try to use it after a biometric has been authenticated
            final Cipher tryUseAfterAuthCipher = Utils.initCipher(keyName);
            CryptoObject crypto = new CryptoObject(tryUseAfterAuthCipher);

            final BiometricPrompt.Builder builder = new BiometricPrompt.Builder(this);
            builder.setTitle(""Please authenticate"");
            builder.setAllowedAuthenticators(Authenticators.BIOMETRIC_STRONG);
            builder.setNegativeButton(""Cancel"", mExecutor, (dialog, which) -> {
                // Do nothing
            });
            final BiometricPrompt prompt = builder.build();
            prompt.authenticate(crypto, new CancellationSignal(), mExecutor,
                    new AuthenticationCallback() {
                        @Override
                        public void onAuthenticationSucceeded(AuthenticationResult result) {
                            try {
                                final int authenticationType = result.getAuthenticationType();
                                if (authenticationType
                                        != BiometricPrompt.AUTHENTICATION_RESULT_TYPE_BIOMETRIC) {
                                    showToastAndLog(""Unexpected authenticationType: ""
                                            + authenticationType);
                                    return;
                                }

                                byte[] encrypted = Utils.doEncrypt(tryUseAfterAuthCipher,
                                        secret);
                                showToastAndLog(""Encrypted payload: "" + Arrays.toString(encrypted)
                                        + "", please run the next test"");
                                if (useStrongBox) {
                                    mAuthenticateWithStrongBoxPassed = true;
                                    mAuthenticateWithStrongBoxButton.setEnabled(false);
                                } else {
                                    mAuthenticateWithoutStrongBoxPassed = true;
                                    mAuthenticateWithoutStrongBoxButton.setEnabled(false);
                                }
                                updatePassButton();
                            } catch (Exception e) {
                                showToastAndLog(""Failed to encrypt after biometric was""
                                        + ""authenticated: "" + e, e);
                            }
                        }
                    });
        } catch (Exception e) {
            showToastAndLog(""Failed during Crypto test: "" + e);
        }
    }

    private void updatePassButton() {
        if (mAuthenticateWithoutStrongBoxPassed && mAuthenticateWithStrongBoxPassed) {

            if (!mKeyInvalidatedStrongboxPassed || !mKeyInvalidatedNoStrongboxPassed) {
                mKeyInvalidatedButton.setEnabled(true);
            }

            if (mKeyInvalidatedStrongboxPassed && mKeyInvalidatedNoStrongboxPassed) {
                showToastAndLog(""All tests passed"");
                getPassButton().setEnabled(true);
            }
        }
    }
}"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"com.android.cts.releaseparser.SoParserTest"	"testNdkSo"	""	"/home/gpoor/cts-12-source/cts/tools/release-parser/tests/src/com/android/cts/releaseparser/SoParserTest.java"	""	"public void testNdkSo() throws Exception {
        testSoParser(TEST_NDK_SO, TEST_NDK_SO_TXT, true);
    }

    /**
     * Test {@link SoParser} with an CTS GTEST EXE file
     *
     * @throws Exception
     */"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.view.inputmethod.cts.InputMethodServiceTest"	"testSendDownUpKeyEvents"	"CtsInputMethodTestCases"	"/home/gpoor/cts-12-source/cts/tests/inputmethod/src/android/view/inputmethod/cts/InputMethodServiceTest.java"	""	"public void testSendDownUpKeyEvents() throws Exception {
        try (MockImeSession imeSession = MockImeSession.create(
                InstrumentationRegistry.getInstrumentation().getContext(),
                InstrumentationRegistry.getInstrumentation().getUiAutomation(),
                new ImeSettings.Builder())) {
            final ImeEventStream stream = imeSession.openEventStream();

            final AtomicReference<ArrayList<KeyEvent>> keyEventsRef = new AtomicReference<>();
            final String marker = ""testSendDownUpKeyEvents/"" + SystemClock.elapsedRealtimeNanos();

            TestActivity.startSync(activity -> {
                final LinearLayout layout = new LinearLayout(activity);
                layout.setOrientation(LinearLayout.VERTICAL);

                final ArrayList<KeyEvent> keyEvents = new ArrayList<>();
                keyEventsRef.set(keyEvents);
                final EditText editText = new EditText(activity) {
                    @Override
                    public InputConnection onCreateInputConnection(EditorInfo editorInfo) {
                        return new InputConnectionWrapper(
                                super.onCreateInputConnection(editorInfo), false) {
                            /**
                             * {@inheritDoc}
                             */
                            @Override
                            public boolean sendKeyEvent(KeyEvent event) {
                                keyEvents.add(event);
                                return super.sendKeyEvent(event);
                            }
                        };
                    }
                };
                editText.setPrivateImeOptions(marker);
                layout.addView(editText);
                editText.requestFocus();
                return layout;
            });

            // Wait until ""onStartInput"" gets called for the EditText.
            expectEvent(stream, editorMatcher(""onStartInput"", marker), TIMEOUT);

            // Make sure that InputConnection#sendKeyEvent() has never been called yet.
            assertTrue(TestUtils.getOnMainSync(
                    () -> new ArrayList<>(keyEventsRef.get())).isEmpty());

            final int expectedKeyCode = KeyEvent.KEYCODE_0;
            final long uptimeStart = SystemClock.uptimeMillis();
            expectCommand(stream, imeSession.callSendDownUpKeyEvents(expectedKeyCode), TIMEOUT);
            final long uptimeEnd = SystemClock.uptimeMillis();

            final ArrayList<KeyEvent> keyEvents = TestUtils.getOnMainSync(
                    () -> new ArrayList<>(keyEventsRef.get()));

            // Check KeyEvent objects.
            assertNotNull(keyEvents);
            assertEquals(2, keyEvents.size());
            assertSynthesizedSoftwareKeyEvent(keyEvents.get(0), KeyEvent.ACTION_DOWN,
                    expectedKeyCode, uptimeStart, uptimeEnd);
            assertSynthesizedSoftwareKeyEvent(keyEvents.get(1), KeyEvent.ACTION_UP,
                    expectedKeyCode, uptimeStart, uptimeEnd);
            final Bundle arguments = expectEvent(stream,
                    event -> ""onUpdateSelection"".equals(event.getEventName()),
                    TIMEOUT).getArguments();
            expectOnUpdateSelectionArguments(arguments, 0, 0, 1, 1, -1, -1);
        }
    }

    /**
     * Ensure that {@link InputConnection#requestCursorUpdates(int)} works for the built-in
     * {@link EditText} and {@link InputMethodService#onUpdateCursorAnchorInfo(CursorAnchorInfo)}
     * will be called back.
     */"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"com.android.cts.apicoverage.NdkApiXmlReport"	"isDirectory"	""	"/home/gpoor/cts-12-source/cts/tools/cts-api-coverage/src/com/android/cts/apicoverage/NdkApiXmlReport.java"	""	"public void test/*
 *.
 */

package com.android.cts.apicoverage;

import com.android.compatibility.common.util.ReadElf;

import org.w3c.dom.Attr;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;

import java.io.File;
import java.io.FileOutputStream;
import java.io.FilenameFilter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
/**
 * Class that outputs an XML report of the {@link ApiCoverage} collected. It can be viewed in a
 * browser when used with the api-coverage.css and api-coverage.xsl files.
 */
class NdkApiXmlReport {
    private static final String API_TAG = ""api"";
    private static final String PACKAGE_TAG = ""package"";
    private static final String CLASS_TAG = ""class"";
    private static final String METHOD_TAG = ""method"";
    private static final String FIELD_TAG = ""field"";
    private static final String ATTRIBUTE_NAME = ""name"";
    private static final String NDK_PACKAGE_NAME = ""ndk"";
    private static final String NDK_DUMMY_RETURN_TYPE = ""na"";

    private static final Map<String, String> sInternalSymMap;
    static {
        sInternalSymMap = new HashMap<String, String>();
        sInternalSymMap.put(""__bss_start"", ""bss"");
        sInternalSymMap.put(""_end"", ""initialized data"");
        sInternalSymMap.put(""_edata"", ""uninitialized data"");
    }

    private static final FilenameFilter SUPPORTED_FILE_NAME_FILTER =
            new FilenameFilter() {
                public boolean accept(File dir, String name) {
                    String fileName = name.toLowerCase();
                    return fileName.endsWith("".so"");
                }
            };

    private static void printUsage() {
        System.out.println(""Usage: ndk-api-xml-report [OPTION]... [APK]..."");
        System.out.println();
        System.out.println(""Generates a report about what Android NDK methods."");
        System.out.println();
        System.out.println(""this must be used from the $ANDROID_BUILD_TOP"");
        System.out.println(""make cts-test-coverage"");
        System.out.println(""unzip the target ndk_platform.tar.bz2 to a folder."");
        System.out.println(
                ""$ANDROID_HOST_OUT/bin/ndk-api-report ""
                        + ""-o $ANDROID_BUILD_TOP/cts/tools/cts-api-coverage/etc/ndk-api.xml ""
                        + ""-n <ndk-folder>/platforms/android-current/arch-arm64/usr/lib"");
        System.out.println();
        System.out.println(""Options:"");
        System.out.println(""  -o FILE                output file or standard out if not given"");
        System.out.println(""  -n PATH                path to the NDK Lib Folder"");
        System.out.println();
        System.exit(1);
    }

    /** Get the argument or print out the usage and exit. */
    private static String getExpectedArg(String[] args, int index) {
        if (index < args.length) {
            return args[index];
        } else {
            printUsage();
            return null; // Never will happen because printUsage will call exit(1)
        }
    }

    public static void main(String[] args) throws IOException {
        List<File> ndkSos = new ArrayList<File>();
        int numNdkSos = 0;
        String ndkLibPath = """";
        String outputFilePath = ""./ndk-api.xml"";

        for (int i = 0; i < args.length; i++) {
            if (args[i].startsWith(""-"")) {
                if (""-o"".equals(args[i])) {
                    outputFilePath = getExpectedArg(args, ++i);
                } else if (""-n"".equals(args[i])) {
                    ndkLibPath = getExpectedArg(args, ++i);
                    File file = new File(ndkLibPath);
                    if (file.isDirectory()) {
                        ndkSos.addAll(Arrays.asList(file.listFiles(SUPPORTED_FILE_NAME_FILTER)));
                    } else {
                        printUsage();
                    }
                } else {
                    printUsage();
                }
            } else {
                printUsage();
            }
        }

        Document dom;
        // instance of a DocumentBuilderFactory
        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
        try {
            // use factory to get an instance of document builder
            DocumentBuilder db = dbf.newDocumentBuilder();
            // create instance of DOM
            dom = db.newDocument();

            // create the root element
            Element apiEle = dom.createElement(API_TAG);
            Element pkgEle = dom.createElement(PACKAGE_TAG);
            setAttribute(dom, pkgEle, ATTRIBUTE_NAME, NDK_PACKAGE_NAME);
            apiEle.appendChild(pkgEle);
            dom.appendChild(apiEle);

            for (File ndkSo : ndkSos) {
                ReadElf re = ReadElf.read(ndkSo);
                re.getDynamicSymbol("""");
                ReadElf.Symbol[] symArr = re.getDynSymArr();
                System.out.println(ndkSo.getName());
                Element classEle = addToDom(dom, pkgEle, symArr, ndkSo.getName().toLowerCase());
                pkgEle.appendChild(classEle);
            }

            try {
                Transformer tr = TransformerFactory.newInstance().newTransformer();
                // enable indent in result file
                tr.setOutputProperty(OutputKeys.INDENT, ""yes"");
                tr.setOutputProperty(""{http://xml.apache.org/xslt}indent-amount"", ""2"");

                // send DOM to file
                tr.transform(
                        new DOMSource(dom), new StreamResult(new FileOutputStream(outputFilePath)));

            } catch (TransformerException te) {
                System.out.println(te.getMessage());
            } catch (IOException ioe) {
                System.out.println(ioe.getMessage());
            }
        } catch (ParserConfigurationException pce) {
            System.out.println(""UsersXML: Error trying to instantiate DocumentBuilder "" + pce);
        }
    }

    public static Element addToDom(
            Document dom, Element pkgEle, ReadElf.Symbol[] symArr, String libName) {
        Element classEle = createClassEle(dom, libName);
        for (int i = 0; i < symArr.length; i++) {
            if (symArr[i].isExtern()) {
                Element methodEle;
                if(isInternalSymbol(symArr[i])) {
                    continue;
                }

                if (symArr[i].type == ReadElf.Symbol.STT_OBJECT) {
                    methodEle = createFieldEle(dom, symArr[i].name);
                } else {
                    methodEle = createMethodEle(dom, symArr[i].name);
                }

                System.out.println(symArr[i].name);
                classEle.appendChild(methodEle);
            }
        }
        return classEle;
    }

    public static void addToDom(Document dom, Element pkgEle, ReadElf.Symbol[] symArr) {
        HashMap<String, Element> classEleMap = new HashMap<String, Element>();
        for (int i = 0; i < symArr.length; i++) {
            if (symArr[i].isExtern()) {
                Element methodEle;
                if (symArr[i].type == ReadElf.Symbol.STT_OBJECT) {
                    methodEle = createFieldEle(dom, symArr[i].name);
                } else {
                    methodEle = createMethodEle(dom, symArr[i].name);
                }

                System.out.println(symArr[i].name);

                // add to the class element
                String libName = symArr[i].getVerDefLibName();
                Element classEle = classEleMap.get(libName);
                if (classEle == null) {
                    classEle = createClassEle(dom, libName);
                    classEleMap.put(libName, classEle);
                }
                classEle.appendChild(methodEle);
            }
        }
        Iterator ite = classEleMap.entrySet().iterator();
        while (ite.hasNext()) {
            Map.Entry<String, Element> entry = (Map.Entry<String, Element>) ite.next();
            pkgEle.appendChild(entry.getValue());
        }
    }

    public static void saveToXML(String xml, ReadElf.Symbol[] symArr) {
        Document dom;
        Element ele = null;

        // instance of a DocumentBuilderFactory
        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
        try {
            // use factory to get an instance of document builder
            DocumentBuilder db = dbf.newDocumentBuilder();
            // create instance of DOM
            dom = db.newDocument();

            // create the root element
            Element apiEle = dom.createElement(API_TAG);
            Element packageEle = dom.createElement(PACKAGE_TAG);
            setAttribute(dom, packageEle, ATTRIBUTE_NAME, NDK_PACKAGE_NAME);
            Element classEle = createClassEle(dom, ""class"");
            packageEle.appendChild(classEle);
            apiEle.appendChild(packageEle);
            dom.appendChild(apiEle);

            for (int i = 0; i < symArr.length; i++) {
                if (symArr[i].isExtern()) {
                    Element methodEle;
                    if (symArr[i].type == ReadElf.Symbol.STT_OBJECT) {
                        methodEle = createFieldEle(dom, symArr[i].name);
                    } else {
                        methodEle = createMethodEle(dom, symArr[i].name);
                    }
                    classEle.appendChild(methodEle);
                }
            }

            try {
                Transformer tr = TransformerFactory.newInstance().newTransformer();
                // enable indent in result file
                tr.setOutputProperty(OutputKeys.INDENT, ""yes"");
                tr.setOutputProperty(""{http://xml.apache.org/xslt}indent-amount"", ""2"");

                // send DOM to file
                tr.transform(new DOMSource(dom), new StreamResult(new FileOutputStream(xml)));

            } catch (TransformerException te) {
                System.out.println(te.getMessage());
            } catch (IOException ioe) {
                System.out.println(ioe.getMessage());
            }
        } catch (ParserConfigurationException pce) {
            System.out.println(""UsersXML: Error trying to instantiate DocumentBuilder "" + pce);
        }
    }

    protected static boolean isInternalSymbol(ReadElf.Symbol sym) {
        String value = sInternalSymMap.get(sym.name);
        if (value == null) {
            return false;
        } else {
            return true;
        }
    }

    protected static void setAttribute(Document doc, Node elem, String name, String value) {
        Attr attr = doc.createAttribute(name);
        attr.setNodeValue(value);
        elem.getAttributes().setNamedItem(attr);
    }

    protected static Element createClassEle(Document doc, String name) {
        Element ele = doc.createElement(CLASS_TAG);
        setAttribute(doc, ele, ATTRIBUTE_NAME, name);
        setAttribute(doc, ele, ""abstract"", ""false"");
        setAttribute(doc, ele, ""static"", ""false"");
        setAttribute(doc, ele, ""final"", ""true"");
        setAttribute(doc, ele, ""deprecated"", ""not deprecated"");
        setAttribute(doc, ele, ""visibility"", ""public"");
        return ele;
    }

    protected static Element createMethodEle(Document doc, String name) {
        Element ele = doc.createElement(METHOD_TAG);
        setAttribute(doc, ele, ATTRIBUTE_NAME, name);
        setAttribute(doc, ele, ""return"", NDK_DUMMY_RETURN_TYPE);
        setAttribute(doc, ele, ""abstract"", ""false"");
        setAttribute(doc, ele, ""native"", ""true"");
        setAttribute(doc, ele, ""synchronized"", ""true"");
        setAttribute(doc, ele, ""static"", ""false"");
        setAttribute(doc, ele, ""final"", ""true"");
        setAttribute(doc, ele, ""deprecated"", ""not deprecated"");
        setAttribute(doc, ele, ""visibility"", ""public"");
        return ele;
    }

    protected static Element createFieldEle(Document doc, String name) {
        Element ele = doc.createElement(FIELD_TAG);
        setAttribute(doc, ele, ATTRIBUTE_NAME, name);
        setAttribute(doc, ele, ""type"", ""native"");
        setAttribute(doc, ele, ""transient"", ""false"");
        setAttribute(doc, ele, ""volatile"", ""false"");
        setAttribute(doc, ele, ""value"", """");
        setAttribute(doc, ele, ""static"", ""false"");
        setAttribute(doc, ele, ""final"", ""true"");
        setAttribute(doc, ele, ""deprecated"", ""not deprecated"");
        setAttribute(doc, ele, ""visibility"", ""public"");
        return ele;
    }
}"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.keystore.cts.CipherTest"	"testCanCreateAuthBoundKeyWhenScreenLocked"	"CtsKeystoreTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/keystore/src/android/keystore/cts/CipherTest.java"	""	"public void testCanCreateAuthBoundKeyWhenScreenLocked() throws Exception {
        final boolean isUnlockedDeviceRequired = false;
        final boolean isUserAuthRequired = true;

        if (!hasSecureLockScreen()) {
            return;
        }

        try (DeviceLockSession dl = new DeviceLockSession()) {
            KeyguardManager keyguardManager = (KeyguardManager)getContext().getSystemService(Context.KEYGUARD_SERVICE);

            dl.performDeviceLock();
            assertTrue(keyguardManager.isDeviceLocked());

            Provider provider = Security.getProvider(EXPECTED_PROVIDER_NAME);
            assertNotNull(provider);

            for (String algorithm : EXPECTED_ALGORITHMS) {
                for (ImportedKey key : importKatKeys(algorithm,
                        KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT,
                        false, isUnlockedDeviceRequired, isUserAuthRequired)) {
                    assertNotNull(key);
                }
            }
        }
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.keystore.cts.CipherTest"	"testCannotCreateAuthBoundKeyWhenDevicePinNotSet"	"CtsKeystoreTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/keystore/src/android/keystore/cts/CipherTest.java"	""	"public void testCannotCreateAuthBoundKeyWhenDevicePinNotSet() throws Exception {
        final boolean isUserAuthRequired = true;
        final boolean isUnlockedDeviceRequired = false;

        if (isLeanbackOnly()) {
            return;
        }

        KeyguardManager keyguardManager = (KeyguardManager)getContext().getSystemService(Context.KEYGUARD_SERVICE);
        assertFalse(keyguardManager.isDeviceLocked());

        for (String algorithm : EXPECTED_ALGORITHMS) {
            try {
                importKatKeys(algorithm, KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT,
                        false, isUnlockedDeviceRequired, isUserAuthRequired);
                fail(""Importing auth bound keys to an insecure device should fail"");
            } catch (KeyStoreException e) {
                // Expected behavior
            }
        }
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.hardware.cts.SensorDirectReportTest"	"isDirectChannelTypeSupported"	"CtsSensorTestCases"	"/home/gpoor/cts-12-source/cts/tests/sensor/src/android/hardware/cts/SensorDirectReportTest.java"	""	"public void test/*
 *.
 */

package android.hardware.cts;

import android.content.Context;
import android.hardware.HardwareBuffer;
import android.hardware.Sensor;
import android.hardware.SensorDirectChannel;
import android.hardware.SensorEvent;
import android.hardware.SensorEventListener;
import android.hardware.SensorManager;
import android.hardware.cts.helpers.SensorCtsHelper;
import android.hardware.cts.helpers.SensorCtsHelper.TestResultCollector;
import android.os.MemoryFile;
import android.os.SystemClock;
import android.util.Log;

import java.io.IOException;
import java.io.UncheckedIOException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.TimeUnit;

/**
 * Checks Sensor Direct Report functionality
 *
 * This testcase tests operation of:
 *   - SensorManager.createDirectChannel()
 *   - SensorDirectChannel.*
 *   - Sensor.getHighestDirectReportRateLevel()
 *   - Sensor.isDirectChannelTypeSupported()
 *
 * Tests:
 *   - test<Sensor><SharedMemoryType><RateLevel>
 *     tests basic operation of sensor in direct report mode at various rate level specification.
 *   - testRateIndependency<Sensor1><Sensor2>SingleChannel
 *     tests if two sensors in the same direct channel are able to run at different rates.
 *   - testRateIndependency<Sensor>MultiChannel
 *     tests if a sensor is able to be configured to different rate levels for multiple channels.
 *   - testRateIndependency<Sensor>MultiMode
 *     tests if a sensor is able to report at different rates in direct report mode and traditional
 *     report mode (polling).
 *   - testTimestamp<Sensor>
 *     tests if the timestamp is correct both in absolute sense and relative to traditional report.
 *   - testAtomicCounter<Sensor>
 *     test if atomic counter is increased as specified and if sensor event content is fully updated
 *     before update of atomic counter.
 *   - testRegisterMultipleChannels
 *     test scenarios when multiple channels are registered simultaneously.
 *   - testReconfigure
 *     test channel reconfiguration (configure to a rate level; configure to stop; configure to
 *     another rate level)
 *   - testRegisterMultipleChannelsUsingSameMemory
 *     test a negative case when the same memory is being used twice for registering sensor direct
 *     channel
 *   - testCloseWithoutConfigStop
 *     test a common mistake in API usage and make sure no negative effect is made to system.
 */
public class SensorDirectReportTest extends SensorTestCase {
    private static final String TAG = ""SensorDirectReportTest"";
    // nominal rates of each rate level supported
    private static final float RATE_NORMAL_NOMINAL = 50;
    private static final float RATE_FAST_NOMINAL = 200;
    private static final float RATE_VERY_FAST_NOMINAL = 800;

    // actuall value is allowed to be 55% to 220% of nominal value
    private static final float FREQ_LOWER_BOUND = 0.55f;
    private static final float FREQ_UPPER_BOUND = 2.2f;

    // actuall value is allowed to be 90% to 200% of nominal value in poll() interface
    private static final float FREQ_LOWER_BOUND_POLL = 0.90f;
    private static final float FREQ_UPPER_BOUND_POLL = 2.00f;

    // sensor reading assumption
    private static final float GRAVITY_MIN = 9.81f - 1.0f;
    private static final float GRAVITY_MAX = 9.81f + 1.0f;
    private static final float GYRO_NORM_MAX = 0.1f;

    // test constants
    public static final int REST_PERIOD_BEFORE_TEST_MILLISEC = 3000;
    private static final int TEST_RUN_TIME_PERIOD_MILLISEC = 5000;
    private static final int ALLOWED_SENSOR_INIT_TIME_MILLISEC = 500;
    private static final int SENSORS_EVENT_SIZE = 104;
    private static final int ATOMIC_COUNTER_OFFSET = 12;
    private static final int ATOMIC_COUNTER_SIZE = 4;
    private static final int SENSORS_EVENT_COUNT = 10240; // 800Hz * 2.2 * 5 sec + extra
    private static final int SHARED_MEMORY_SIZE = SENSORS_EVENT_COUNT * SENSORS_EVENT_SIZE;
    private static final float MERCY_FACTOR = 0.1f;
    private static final boolean CHECK_ABSOLUTE_LATENCY = false;

    // list of rate levels being tested
    private static final int[] POSSIBLE_RATE_LEVELS = new int[] {
            SensorDirectChannel.RATE_NORMAL,
            SensorDirectChannel.RATE_FAST,
            SensorDirectChannel.RATE_VERY_FAST
        };

    // list of channel types being tested
    private static final int[] POSSIBLE_CHANNEL_TYPES = new int [] {
            SensorDirectChannel.TYPE_MEMORY_FILE,
            SensorDirectChannel.TYPE_HARDWARE_BUFFER
        };

    // list of sensor types being tested
    private static final int[] POSSIBLE_SENSOR_TYPES = new int [] {
            Sensor.TYPE_ACCELEROMETER,
            Sensor.TYPE_GYROSCOPE,
            Sensor.TYPE_MAGNETIC_FIELD
        };

    // list of sampling period being tested
    private static final int[] POSSIBLE_SAMPLE_PERIOD_US = new int [] {
            200_000, // Normal 5 Hz
            66_667,  // UI    15 Hz
            20_000,  // Game  50 Hz
            5_000,   // 200Hz
            0        // fastest
        };

    private static final ByteOrder NATIVE_BYTE_ORDER = ByteOrder.nativeOrder();

    private static native boolean nativeReadHardwareBuffer(HardwareBuffer hardwareBuffer,
            byte[] buffer, int srcOffset, int destOffset, int count);

    private boolean mNeedMemoryFile;
    private MemoryFile mMemoryFile;
    private MemoryFile mMemoryFileSecondary;
    private boolean mNeedHardwareBuffer;
    private HardwareBuffer mHardwareBuffer;
    private HardwareBuffer mHardwareBufferSecondary;
    private ByteBuffer mByteBuffer;
    private byte[] mBuffer;

    private SensorManager mSensorManager;
    private SensorDirectChannel mChannel;
    private SensorDirectChannel mChannelSecondary;

    private EventPool mEventPool;

    static {
        System.loadLibrary(""cts-sensors-ndk-jni"");
    }

    @Override
    protected void setUp() throws Exception {
        super.setUp();

        mByteBuffer = ByteBuffer.allocate(SHARED_MEMORY_SIZE);
        mBuffer = mByteBuffer.array();
        mByteBuffer.order(ByteOrder.nativeOrder());

        mEventPool = new EventPool(10 * SENSORS_EVENT_COUNT);
        mSensorManager = (SensorManager) getContext().getSystemService(Context.SENSOR_SERVICE);

        mNeedMemoryFile = isMemoryTypeNeeded(SensorDirectChannel.TYPE_MEMORY_FILE);
        mNeedHardwareBuffer = isMemoryTypeNeeded(SensorDirectChannel.TYPE_HARDWARE_BUFFER);

        allocateSharedMemory();
    }

    @Override
    protected void tearDown() throws Exception {
        if (mChannel != null) {
            mChannel.close();
            mChannel = null;
        }

        if (mChannelSecondary != null) {
            mChannelSecondary.close();
            mChannelSecondary = null;
        }

        freeSharedMemory();
        super.tearDown();
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.app.cts.LauncherActivityTest"	"testLaunchActivity"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/LauncherActivityTest.java"	""	"public void testLaunchActivity() throws Throwable {
        runTestOnUiThread(new Runnable() {
            public void run() {
                // Test getTargetIntent. LaunchActivity#getTargetIntent() just returns a Intent() instance
                // with no content, so we use LaunchActivityStub#getSuperIntent() to get the default Intent,
                // and create a new intent for other tests.
                assertNotNull(mActivity.getSuperIntent());

                // Test makeListItems. Make sure the size > 0. The sorted order is related to the sort
                // way, so it's mutable.
                final List<ListItem> list = mActivity.makeListItems();
                assertTrue(list.size() > 0);

                // There should be an activity(but with uncertain content) in position 0.
                assertNotNull(mActivity.intentForPosition(0));
            }
        });
        mInstrumentation.waitForIdleSync();
        // Test onListItemClick
        sendKeys(KeyEvent.KEYCODE_DPAD_DOWN);
        sendKeys(KeyEvent.KEYCODE_DPAD_DOWN);
        sendKeys(KeyEvent.KEYCODE_DPAD_DOWN);
        sendKeys(KeyEvent.KEYCODE_DPAD_CENTER);
        assertTrue(mActivity.isOnListItemClick);
    }
}"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.os.cts.SharedMemoryTest"	"testNdkInterop"	""	"/home/gpoor/cts-12-source/cts/tests/tests/os/src/android/os/cts/SharedMemoryTest.java"	""	"public void testNdkInterop() throws ErrnoException {
        SharedMemory sharedMemory = SharedMemory.create(""hello"", 1024);
        ByteBuffer buffer = sharedMemory.mapReadWrite();
        assertEquals(0, buffer.get(0));
        assertTrue(nWriteByte(sharedMemory, 0, (byte) 1));
        assertEquals(1, buffer.get(0));
        sharedMemory.close();
        buffer.put(0, (byte) 5);
        assertFalse(nWriteByte(sharedMemory, 0, (byte) 2));
        assertEquals(5, buffer.get(0));
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
Not Testable, Related test included	Not Testable, Related test included	Not Testable, Related test included	Not Testable, Related test included	Not Testable, Related test included	Not Testable, Related test included	Not Testable, Related test included	Not Testable, Related test included	Not Testable, Related test included	Not Testable, Related test included	Not Testable, Related test included	Not Testable, Related test included	Not Testable, Related test included	Not Testable, Related test included	Not Testable, Related test included	Not Testable, Related test included	Not Testable, Related test included	Not Testable, Related test included	Not Testable, Related test included	Not Testable, Related test included	Not Testable, Related test included	Not Testable, Related test included	Not Testable, Related test included	Not Testable, Related test included	Not Testable, Related test included	Not Testable, Related test included	Not Testable, Related test included	Not Testable, Related test included	Not Testable, Related test included	Not Testable, Related test included	Not Testable, Related test included	Not Testable, Related test included	Not Testable, Related test included	Not Testable, Related test included	Not Testable, Related test included	Not Testable, Related test included
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.app.cts.AlertDialog_BuilderTest"	"testSetNeutralButtonWithParamCharSequence"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/AlertDialog_BuilderTest.java"	""	"public void testSetNeutralButtonWithParamCharSequence() throws Throwable {
        runOnUiThread(new Runnable() {
            public void run() {
                mBuilder = new AlertDialog.Builder(mContext);
                mBuilder.setNeutralButton(mTitle, mOnClickListener);
                mBuilder.setOnDismissListener(mOnDismissListener);
                mDialog = mBuilder.show();
                mButton = mDialog.getButton(DialogInterface.BUTTON_NEUTRAL);
                mButton.performClick();
            }
        });
        mInstrumentation.waitForIdleSync();
        assertEquals(mTitle, mButton.getText());
        verify(mOnClickListener, times(1)).onClick(mDialog, DialogInterface.BUTTON_NEUTRAL);
        verifyNoMoreInteractions(mOnClickListener);
        // Button click should also dismiss the dialog and notify the listener
        verify(mOnDismissListener, times(1)).onDismiss(mDialog);
        verifyNoMoreInteractions(mOnDismissListener);
    }

    private void testCancelable(final boolean cancelable) throws Throwable {
        runOnUiThread(new Runnable() {
            public void run() {
                mBuilder = new AlertDialog.Builder(mContext);
                mBuilder.setCancelable(cancelable);
                mDialog = mBuilder.show();
            }
        });
        mInstrumentation.waitForIdleSync();
        PollingCheck.waitFor(mDialog::isShowing);
        sendKeySync(KeyEvent.KEYCODE_BACK);
        mInstrumentation.waitForIdleSync();
        new PollingCheck() {
            @Override
            protected boolean check() {
                boolean showing = mDialog.isShowing();
                if (cancelable) {
                    // if the dialog is cancelable, then pressing back
                    // should cancel it. Thus it should not be showing
                    return !showing;
                } else {
                    // if the dialog is not cancelable, pressing back
                    // should so nothing and it should still be showing
                    return showing;
                }
            }
        }.run();
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.app.cts.AlertDialog_BuilderTest"	"testSetOnKeyListener"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/AlertDialog_BuilderTest.java"	""	"public void testSetOnKeyListener() throws Throwable {
        runOnUiThread(new Runnable() {
            public void run() {
                mBuilder = new AlertDialog.Builder(mContext);
                mBuilder.setOnKeyListener(mOnKeyListener);
                mDialog = mBuilder.show();
            }
        });
        mInstrumentation.waitForIdleSync();
        sendKeySync(KeyEvent.KEYCODE_0);
        sendKeySync(KeyEvent.KEYCODE_1);
        mInstrumentation.waitForIdleSync();
        // Use Mockito captures so that we can verify that each ""sent"" key code resulted
        // in one DOWN event and one UP event.
        ArgumentCaptor<KeyEvent> keyEvent0Captor = ArgumentCaptor.forClass(KeyEvent.class);
        ArgumentCaptor<KeyEvent> keyEvent1Captor = ArgumentCaptor.forClass(KeyEvent.class);
        verify(mOnKeyListener, times(2)).onKey(eq(mDialog), eq(KeyEvent.KEYCODE_0),
                keyEvent0Captor.capture());
        verify(mOnKeyListener, times(2)).onKey(eq(mDialog), eq(KeyEvent.KEYCODE_1),
                keyEvent1Captor.capture());
        verifyNoMoreInteractions(mOnKeyListener);
        assertEquals(KeyEvent.ACTION_DOWN, keyEvent0Captor.getAllValues().get(0).getAction());
        assertEquals(KeyEvent.ACTION_UP, keyEvent0Captor.getAllValues().get(1).getAction());
        assertEquals(KeyEvent.ACTION_DOWN, keyEvent1Captor.getAllValues().get(0).getAction());
        assertEquals(KeyEvent.ACTION_UP, keyEvent1Captor.getAllValues().get(1).getAction());
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.app.cts.AlertDialog_BuilderTest"	"testShow"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/AlertDialog_BuilderTest.java"	""	"public void testShow() throws Throwable {
        runOnUiThread(new Runnable() {
            public void run() {
                mBuilder = new AlertDialog.Builder(mContext);
                mDialog = mBuilder.show();
            }
        });
        mInstrumentation.waitForIdleSync();
        assertTrue(mDialog.isShowing());
    }

    private void sendKeySync(int keyCode) {
        final long downTime = SystemClock.uptimeMillis();
        final KeyEvent downEvent =
                new KeyEvent(downTime, downTime, KeyEvent.ACTION_DOWN, keyCode, 0);
        mInstrumentation.getUiAutomation().injectInputEvent(downEvent, true /*sync*/);

        final KeyEvent upEvent =
                new KeyEvent(downTime, SystemClock.uptimeMillis(), KeyEvent.ACTION_UP, keyCode, 0);
        mInstrumentation.getUiAutomation().injectInputEvent(upEvent, true /*sync*/);
    }

    private static class AdapterTest implements android.widget.ListAdapter {
        public boolean areAllItemsEnabled() {
            return true;
        }

        public boolean isEnabled(int position) {
            return false;
        }

        public int getCount() {
            return 0;
        }

        public Object getItem(int position) {
            return null;
        }

        public long getItemId(int position) {
            return 0;
        }

        public int getItemViewType(int position) {
            return 0;
        }

        public android.view.View getView( int position,
                                          android.view.View convertView,
                                          android.view.ViewGroup parent){
            return null;
        }

        public int getViewTypeCount() {
            return 1;
        }

        public boolean hasStableIds() {
            return false;
        }

        public boolean isEmpty() {
            return true;
        }

        public void registerDataSetObserver(
            android.database.DataSetObserver observer) {
        }

        public void unregisterDataSetObserver(
            android.database.DataSetObserver observer) {
        }
    }
}"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.widget.cts.TimePickerTest"	"testKeyboardInputModeClockAmPm"	"CtsWidgetTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TimePickerTest.java"	""	"public void testKeyboardInputModeClockAmPm() throws Throwable {
        if (isWatch()) {
            return;
        }
        final int initialHour = 6;
        final int initialMinute = 59;
        prepareForKeyboardInput(initialHour, initialMinute, false /* is24hFormat */,
                true /* isClockMode */);

        // Input valid hour.
        assertEquals(initialHour, mTimePicker.getHour());
        CtsTouchUtils.emulateTapOnViewCenter(mInstrumentation, mActivityRule,
                mTimePicker.getHourView());
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_1);
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_0);
        assertEquals(10, mTimePicker.getHour());
        assertTrue(mTimePicker.getMinuteView().hasFocus());

        // Input valid minute.
        assertEquals(initialMinute, mTimePicker.getMinute());
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_4);
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_3);
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_TAB);
        assertEquals(43, mTimePicker.getMinute());
        assertTrue(mTimePicker.getAmView().hasFocus());

        // Accepting AM changes nothing.
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_ENTER);
        assertEquals(10, mTimePicker.getHour());
        assertEquals(43, mTimePicker.getMinute());

        // Focus PM radio.
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_TAB);
        assertTrue(mTimePicker.getPmView().hasFocus());
        // Still nothing has changed.
        assertEquals(10, mTimePicker.getHour());
        assertEquals(43, mTimePicker.getMinute());
        // Select PM and verify the hour has changed.
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_ENTER);
        assertEquals(22, mTimePicker.getHour());
        assertEquals(43, mTimePicker.getMinute());
        // Set AM again.
        CtsKeyEventUtil.sendKeyWhileHoldingModifier(mInstrumentation, mTimePicker,
                KeyEvent.KEYCODE_TAB, KeyEvent.KEYCODE_SHIFT_LEFT);
        assertTrue(mTimePicker.getAmView().hasFocus());
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_ENTER);
        assertEquals(10, mTimePicker.getHour());

        // Re-focus the hour view.
        CtsKeyEventUtil.sendKeyWhileHoldingModifier(mInstrumentation, mTimePicker,
                KeyEvent.KEYCODE_TAB, KeyEvent.KEYCODE_SHIFT_LEFT);
        CtsKeyEventUtil.sendKeyWhileHoldingModifier(mInstrumentation, mTimePicker,
                KeyEvent.KEYCODE_TAB, KeyEvent.KEYCODE_SHIFT_LEFT);
        assertTrue(mTimePicker.getHourView().hasFocus());

        // Input an invalid value (larger than 12).
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_1);
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_3);
        // Force setting the hour by moving to minute.
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_TAB);
        // After sending 1 and 3 only 1 is accepted.
        assertEquals(1, mTimePicker.getHour());
        assertEquals(43, mTimePicker.getMinute());
        CtsKeyEventUtil.sendKeyWhileHoldingModifier(mInstrumentation, mTimePicker,
                KeyEvent.KEYCODE_TAB, KeyEvent.KEYCODE_SHIFT_LEFT);
        // The hour view still has focus.
        assertTrue(mTimePicker.getHourView().hasFocus());

        // This time send a valid hour (11).
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_1);
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_1);
        // The value is valid.
        assertEquals(11, mTimePicker.getHour());
        assertEquals(43, mTimePicker.getMinute());

        verifyModeClockMinuteInput();
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.widget.cts.TimePickerTest"	"testKeyboardInputModeClock24H"	"CtsWidgetTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TimePickerTest.java"	""	"public void testKeyboardInputModeClock24H() throws Throwable {
        if (isWatch()) {
            return;
        }
        final int initialHour = 6;
        final int initialMinute = 59;
        prepareForKeyboardInput(initialHour, initialMinute, true /* is24hFormat */,
                true /* isClockMode */);

        // Input valid hour.
        assertEquals(initialHour, mTimePicker.getHour());
        CtsTouchUtils.emulateTapOnViewCenter(mInstrumentation, mActivityRule,
                mTimePicker.getHourView());
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_1);
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_0);
        assertEquals(10, mTimePicker.getHour());
        assertTrue(mTimePicker.getMinuteView().hasFocus());

        // Input valid minute.
        assertEquals(initialMinute, mTimePicker.getMinute());
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_4);
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_3);
        assertEquals(43, mTimePicker.getMinute());

        // Re-focus the hour view.
        CtsKeyEventUtil.sendKeyWhileHoldingModifier(mInstrumentation, mTimePicker,
                KeyEvent.KEYCODE_TAB, KeyEvent.KEYCODE_SHIFT_LEFT);
        assertTrue(mTimePicker.getHourView().hasFocus());

        // Input an invalid value (larger than 24).
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_2);
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_5);
        // Force setting the hour by moving to minute.
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_TAB);
        // After sending 2 and 5 only 2 is accepted.
        assertEquals(2, mTimePicker.getHour());
        assertEquals(43, mTimePicker.getMinute());
        CtsKeyEventUtil.sendKeyWhileHoldingModifier(mInstrumentation, mTimePicker,
                KeyEvent.KEYCODE_TAB, KeyEvent.KEYCODE_SHIFT_LEFT);
        // The hour view still has focus.
        assertTrue(mTimePicker.getHourView().hasFocus());

        // This time send a valid hour.
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_2);
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_3);
        // The value is valid.
        assertEquals(23, mTimePicker.getHour());
        assertEquals(43, mTimePicker.getMinute());

        verifyModeClockMinuteInput();
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.widget.cts.TimePickerTest"	"testKeyboardInputModeSpinnerAmPm"	"CtsWidgetTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TimePickerTest.java"	""	"public void testKeyboardInputModeSpinnerAmPm() throws Throwable {
        if (isWatch()) {
            return;
        }
        final int initialHour = 6;
        final int initialMinute = 59;
        prepareForKeyboardInput(initialHour, initialMinute, false /* is24hFormat */,
                false /* isClockMode */);

        // when testing on device with lower resolution, the Spinner mode time picker may not show
        // completely, which will cause case fail, so in this case remove the clock time picker to
        // focus on the test of Spinner mode
        final TimePicker clock = mActivity.findViewById(R.id.timepicker_clock);
        mActivityRule.runOnUiThread(() -> clock.setVisibility(View.GONE));

        assertEquals(initialHour, mTimePicker.getHour());
        mActivityRule.runOnUiThread(() -> mTimePicker.getHourView().requestFocus());
        mInstrumentation.waitForIdleSync();

        // Input invalid hour.
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_1);
        // None of the keys below should be accepted after 1 was pressed.
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_3);
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_4);
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_5);
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_TAB);
        // Since only 0, 1 or 2 are accepted for AM/PM hour mode after pressing 1, we expect the
        // hour value to be 1.
        assertEquals(1, mTimePicker.getHour());
        assertFalse(mTimePicker.getHourView().hasFocus());

        //  Go back to hour view and input valid hour.
        mActivityRule.runOnUiThread(() -> mTimePicker.getHourView().requestFocus());
        mInstrumentation.waitForIdleSync();
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_1);
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_1);
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_TAB);
        assertEquals(11, mTimePicker.getHour());
        assertFalse(mTimePicker.getHourView().hasFocus());

        // Go back to hour view and exercise UP and DOWN keys.
        mActivityRule.runOnUiThread(() -> mTimePicker.getHourView().requestFocus());
        mInstrumentation.waitForIdleSync();
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_DPAD_DOWN);
        assertEquals(12, mTimePicker.getHour());
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_DPAD_UP);
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_DPAD_UP);
        assertEquals(10, mTimePicker.getHour());

        // Minute input testing.
        assertEquals(initialMinute, mTimePicker.getMinute());
        verifyModeSpinnerMinuteInput();

        // Reset to values preparing to test the AM/PM picker.
        mActivityRule.runOnUiThread(() -> {
            mTimePicker.setHour(6);
            mTimePicker.setMinute(initialMinute);
        });
        mInstrumentation.waitForIdleSync();
        // In spinner mode the AM view and PM view are the same.
        assertEquals(mTimePicker.getAmView(), mTimePicker.getPmView());
        mActivityRule.runOnUiThread(() -> mTimePicker.getAmView().requestFocus());
        mInstrumentation.waitForIdleSync();
        assertTrue(mTimePicker.getAmView().hasFocus());
        assertEquals(6, mTimePicker.getHour());
        // Pressing A changes nothing.
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_A);
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_TAB);
        assertEquals(6, mTimePicker.getHour());
        assertEquals(initialMinute, mTimePicker.getMinute());
        // Pressing P switches to PM.
        CtsKeyEventUtil.sendKeyWhileHoldingModifier(mInstrumentation, mTimePicker,
                KeyEvent.KEYCODE_TAB, KeyEvent.KEYCODE_SHIFT_LEFT);
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_P);
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_TAB);
        assertEquals(18, mTimePicker.getHour());
        assertEquals(initialMinute, mTimePicker.getMinute());
        // Pressing P again changes nothing.
        CtsKeyEventUtil.sendKeyWhileHoldingModifier(mInstrumentation, mTimePicker,
                KeyEvent.KEYCODE_TAB, KeyEvent.KEYCODE_SHIFT_LEFT);
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_P);
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_TAB);
        assertEquals(18, mTimePicker.getHour());
        assertEquals(initialMinute, mTimePicker.getMinute());
        // Pressing A switches to AM.
        CtsKeyEventUtil.sendKeyWhileHoldingModifier(mInstrumentation, mTimePicker,
                KeyEvent.KEYCODE_TAB, KeyEvent.KEYCODE_SHIFT_LEFT);
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_A);
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_TAB);
        assertEquals(6, mTimePicker.getHour());
        assertEquals(initialMinute, mTimePicker.getMinute());
        // Given that we are already set to AM, pressing UP changes nothing.
        mActivityRule.runOnUiThread(() -> mTimePicker.getAmView().requestFocus());
        mInstrumentation.waitForIdleSync();
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_DPAD_UP);
        assertEquals(6, mTimePicker.getHour());
        assertEquals(initialMinute, mTimePicker.getMinute());
        mActivityRule.runOnUiThread(() -> mTimePicker.getAmView().requestFocus());
        mInstrumentation.waitForIdleSync();
        // Pressing down switches to PM.
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_DPAD_DOWN);
        assertEquals(18, mTimePicker.getHour());
        assertEquals(initialMinute, mTimePicker.getMinute());
        mActivityRule.runOnUiThread(() -> mTimePicker.getAmView().requestFocus());
        mInstrumentation.waitForIdleSync();
        // Given that we are set to PM, pressing DOWN again changes nothing.
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_DPAD_DOWN);
        assertEquals(18, mTimePicker.getHour());
        assertEquals(initialMinute, mTimePicker.getMinute());
        mActivityRule.runOnUiThread(() -> mTimePicker.getAmView().requestFocus());
        mInstrumentation.waitForIdleSync();
        // Pressing UP switches to AM.
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_DPAD_UP);
        assertEquals(6, mTimePicker.getHour());
        assertEquals(initialMinute, mTimePicker.getMinute());
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.widget.cts.TimePickerTest"	"testKeyboardInputModeSpinner24H"	"CtsWidgetTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TimePickerTest.java"	""	"public void testKeyboardInputModeSpinner24H() throws Throwable {
        if (isWatch()) {
            return;
        }
        final int initialHour = 6;
        final int initialMinute = 59;
        prepareForKeyboardInput(initialHour, initialMinute, true /* is24hFormat */,
                false /* isClockMode */);

        // when testing on device with lower resolution, the Spinner mode time picker may not show
        // completely, which will cause case fail, so in this case remove the clock time picker to
        // focus on the test of Spinner mode
        final TimePicker clock = mActivity.findViewById(R.id.timepicker_clock);
        mActivityRule.runOnUiThread(() -> clock.setVisibility(View.GONE));

        assertEquals(initialHour, mTimePicker.getHour());
        mActivityRule.runOnUiThread(() -> mTimePicker.getHourView().requestFocus());
        mInstrumentation.waitForIdleSync();

        // Input invalid hour.
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_2);
        // None of the keys below should be accepted after 2 was pressed.
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_4);
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_5);
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_6);
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_TAB);
        // Only 2 is accepted (as the only 0, 1, 2, and 3 can form valid hours after pressing 2).
        assertEquals(2, mTimePicker.getHour());
        assertFalse(mTimePicker.getHourView().hasFocus());

        //  Go back to hour view and input valid hour.
        mActivityRule.runOnUiThread(() -> mTimePicker.getHourView().requestFocus());
        mInstrumentation.waitForIdleSync();
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_2);
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_3);
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_TAB);
        assertEquals(23, mTimePicker.getHour());
        assertFalse(mTimePicker.getHourView().hasFocus());

        // Go back to hour view and exercise UP and DOWN keys.
        mActivityRule.runOnUiThread(() -> mTimePicker.getHourView().requestFocus());
        mInstrumentation.waitForIdleSync();
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_DPAD_DOWN);
        assertEquals(0 /* 24 */, mTimePicker.getHour());
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_DPAD_UP);
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_DPAD_UP);
        assertEquals(22, mTimePicker.getHour());

        // Minute input testing.
        assertEquals(initialMinute, mTimePicker.getMinute());
        verifyModeSpinnerMinuteInput();
    }

    private void verifyModeClockMinuteInput() {
        assertTrue(mTimePicker.getMinuteView().hasFocus());
        // Send a invalid minute.
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_6);
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_7);
        // Sent 6 and 7 but only 6 was valid.
        assertEquals(6, mTimePicker.getMinute());
        // No matter what other invalid values we send, the minute is unchanged and the focus is
        // kept.
        // 61 invalid.
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_1);
        assertTrue(mTimePicker.getMinuteView().hasFocus());
        // 62 invalid.
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_2);
        assertTrue(mTimePicker.getMinuteView().hasFocus());
        // 63 invalid.
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_3);
        assertTrue(mTimePicker.getMinuteView().hasFocus());
        assertEquals(6, mTimePicker.getMinute());
        // Refocus.
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_TAB);
        CtsKeyEventUtil.sendKeyWhileHoldingModifier(mInstrumentation, mTimePicker,
                KeyEvent.KEYCODE_TAB, KeyEvent.KEYCODE_SHIFT_LEFT);
        assertTrue(mTimePicker.getMinuteView().hasFocus());

        // In the end pass a valid minute.
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_5);
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_9);
        assertEquals(59, mTimePicker.getMinute());
    }

    private void verifyModeSpinnerMinuteInput() throws Throwable {
        mActivityRule.runOnUiThread(() -> mTimePicker.getMinuteView().requestFocus());
        mInstrumentation.waitForIdleSync();
        assertTrue(mTimePicker.getMinuteView().hasFocus());

        // Input invalid minute.
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_6);
        // None of the keys below should be accepted after 6 was pressed.
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_3);
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_4);
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_5);
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_TAB);
        // Only 6 is accepted (as the only valid minute value that starts with 6 is 6 itself).
        assertEquals(6, mTimePicker.getMinute());

        // Go back to minute view and input valid minute.
        CtsKeyEventUtil.sendKeyWhileHoldingModifier(mInstrumentation, mTimePicker,
                KeyEvent.KEYCODE_TAB, KeyEvent.KEYCODE_SHIFT_LEFT);
        assertTrue(mTimePicker.getMinuteView().hasFocus());
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_4);
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_8);
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_TAB);
        assertEquals(48, mTimePicker.getMinute());

        // Go back to minute view and exercise UP and DOWN keys.
        CtsKeyEventUtil.sendKeyWhileHoldingModifier(mInstrumentation, mTimePicker,
                KeyEvent.KEYCODE_TAB, KeyEvent.KEYCODE_SHIFT_LEFT);
        assertTrue(mTimePicker.getMinuteView().hasFocus());
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_DPAD_DOWN);
        assertEquals(49, mTimePicker.getMinute());
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_DPAD_UP);
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTimePicker, KeyEvent.KEYCODE_DPAD_UP);
        assertEquals(47, mTimePicker.getMinute());
    }

    private void prepareForKeyboardInput(int initialHour, int initialMinute, boolean is24hFormat,
            boolean isClockMode) throws Throwable {
        mTimePicker = isClockMode
                ? (TimePicker) mActivity.findViewById(R.id.timepicker_clock)
                : (TimePicker) mActivity.findViewById(R.id.timepicker_spinner);

        mActivityRule.runOnUiThread(() -> {
            /* hide one of the widgets to assure they fit onto the screen */
            if (isClockMode) {
                mActivity.findViewById(R.id.timepicker_spinner).setVisibility(View.GONE);
            } else {
                mActivity.findViewById(R.id.timepicker_clock).setVisibility(View.GONE);
            }
            mTimePicker.setIs24HourView(is24hFormat);
            mTimePicker.setHour(initialHour);
            mTimePicker.setMinute(initialMinute);
            mTimePicker.requestFocus();
        });
        mInstrumentation.waitForIdleSync();
    }

    private void verifyTimePickerKeyboardTraversal(boolean goForward, boolean is24HourView)
            throws Throwable {
        ArrayList<View> forwardViews = new ArrayList<>();
        String summary = (goForward ? "" forward "" : "" backward "")
                + ""traversal, is24HourView="" + is24HourView;
        assertNotNull(""Unexpected NULL hour view for"" + summary, mTimePicker.getHourView());
        forwardViews.add(mTimePicker.getHourView());
        assertNotNull(""Unexpected NULL minute view for"" + summary, mTimePicker.getMinuteView());
        forwardViews.add(mTimePicker.getMinuteView());
        if (!is24HourView) {
            assertNotNull(""Unexpected NULL AM view for"" + summary, mTimePicker.getAmView());
            forwardViews.add(mTimePicker.getAmView());
            assertNotNull(""Unexpected NULL PM view for"" + summary, mTimePicker.getPmView());
            forwardViews.add(mTimePicker.getPmView());
        }

        if (!goForward) {
            Collections.reverse(forwardViews);
        }

        final int viewsSize = forwardViews.size();
        for (int i = 0; i < viewsSize; i++) {
            final View currentView = forwardViews.get(i);
            String afterKeyCodeFormattedString = """";
            int goForwardKeyCode = KeyEvent.KEYCODE_TAB;
            int modifierKeyCodeToHold = KeyEvent.KEYCODE_SHIFT_LEFT;

            if (i == 0) {
                // Make sure we always start by focusing the 1st element in the list.
                mActivityRule.runOnUiThread(currentView::requestFocus);
            } else {
                if (goForward) {
                    afterKeyCodeFormattedString = "" after pressing=""
                            + KeyEvent.keyCodeToString(goForwardKeyCode);
                } else {
                    afterKeyCodeFormattedString = "" after pressing=""
                            + KeyEvent.keyCodeToString(modifierKeyCodeToHold)
                            + ""+"" + KeyEvent.keyCodeToString(goForwardKeyCode)  + "" for"" + summary;
                }
            }

            assertTrue(""View='"" + currentView + ""'"" + "" with index "" + i + "" is not enabled""
                    + afterKeyCodeFormattedString + "" for"" + summary, currentView.isEnabled());
            assertTrue(""View='"" + currentView + ""'"" + "" with index "" + i + "" is not focused""
                    + afterKeyCodeFormattedString + "" for"" + summary, currentView.isFocused());

            if (i < viewsSize - 1) {
                if (goForward) {
                    CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, currentView, goForwardKeyCode);
                } else {
                    CtsKeyEventUtil.sendKeyWhileHoldingModifier(mInstrumentation, currentView,
                            goForwardKeyCode, modifierKeyCodeToHold);
                }
            }
        }
    }

    private class MyTimePicker extends TimePicker {
        public MyTimePicker(Context context) {
            super(context);
        }

        @Override
        protected void onRestoreInstanceState(Parcelable state) {
            super.onRestoreInstanceState(state);
        }

        @Override
        protected Parcelable onSaveInstanceState() {
            return super.onSaveInstanceState();
        }
    }
}"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.widget.cts.SearchViewTest"	"testEnterKey"	"CtsWidgetTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/SearchViewTest.java"	""	"public void testEnterKey() throws Throwable {
        mActivityRule.runOnUiThread(() -> {
            mSearchView.setIconifiedByDefault(false);
            mSearchView.setIconified(false);
        });

        final SearchView.OnQueryTextListener mockQueryTextListener =
                mock(SearchView.OnQueryTextListener.class);
        when(mockQueryTextListener.onQueryTextSubmit(anyString())).thenReturn(Boolean.TRUE);
        mSearchView.setOnQueryTextListener(mockQueryTextListener);

        WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, mSearchView, () -> {
            mSearchView.setQuery(""alpha"", false);
            mSearchView.requestFocus();
        });
        mInstrumentation.waitForIdleSync();

        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mSearchView, KeyEvent.KEYCODE_ENTER);

        verify(mockQueryTextListener, times(1)).onQueryTextChange(""alpha"");
        verify(mockQueryTextListener, atLeastOnce()).onQueryTextSubmit(""alpha"");

        WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, mSearchView, () -> {
            mSearchView.setQuery(""beta"", false);
            mSearchView.requestFocus();
        });
        mInstrumentation.waitForIdleSync();

        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mSearchView, KeyEvent.KEYCODE_NUMPAD_ENTER);

        verify(mockQueryTextListener, times(1)).onQueryTextChange(""beta"");
        verify(mockQueryTextListener, atLeastOnce()).onQueryTextSubmit(""beta"");

        verifyNoMoreInteractions(mockQueryTextListener);
    }

}"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.managedprovisioning.ByodFlowTestHelper"	"isHeadlessSystemUserMode"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/managedprovisioning/ByodFlowTestHelper.java"	""	"public void testpackage com.android.cts.verifier.managedprovisioning;

import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.os.UserManager;
import android.util.Log;

public class ByodFlowTestHelper {

    private static final String TAG = ByodFlowTestHelper.class.getSimpleName();

    private Context mContext;
    private PackageManager mPackageManager;

    public ByodFlowTestHelper(Context context) {
        this.mContext = context;
        this.mPackageManager = mContext.getPackageManager();
    }

    public void setup() {
        setComponentsEnabledState(PackageManager.COMPONENT_ENABLED_STATE_DISABLED);
    }

    /** Reports result to ByodFlowTestActivity if it is impossible via normal setResult. */
    public void sendResultToPrimary(Intent result) {
        final Intent intent = new Intent(ByodFlowTestActivity.ACTION_TEST_RESULT);
        intent.putExtra(ByodFlowTestActivity.EXTRA_RESULT, result);
        startActivityInPrimary(intent);
    }

    public void startActivityInPrimary(Intent intent) {
        // Disable app components in the current profile, so only the counterpart in the other
        // profile can respond (via cross-profile intent filter)
        mContext.getPackageManager().setComponentEnabledSetting(
                new ComponentName(mContext, ByodFlowTestActivity.class),
                PackageManager.COMPONENT_ENABLED_STATE_DISABLED,
                PackageManager.DONT_KILL_APP);
        mContext.startActivity(intent);
    }

    /**
     * Clean up things. This has to be working even it is called multiple times.
     */
    public void tearDown() {
        if (!UserManager.isHeadlessSystemUserMode()) {
            // TODO(b/177554984): figure out how to use it on headless system user mode - right now,
            // it removes the current user on teardown
            Log.i(TAG, ""tearDown(): not deleting managed profile on headless system user mode"");
            Utils.requestDeleteManagedProfile(mContext);
        }
        setComponentsEnabledState(PackageManager.COMPONENT_ENABLED_STATE_DEFAULT);
    }

    /**
     * Disable or enable app components in the current profile. When they are disabled only the
     * counterpart in the other profile can respond (via cross-profile intent filter).
     *
     * @param enabledState {@link PackageManager#COMPONENT_ENABLED_STATE_DISABLED} or
     *                     {@link PackageManager#COMPONENT_ENABLED_STATE_DEFAULT}
     */
    private void setComponentsEnabledState(final int enabledState) {
        final String[] components = {
                ByodHelperActivity.class.getName(),
                WorkStatusTestActivity.class.getName(),
                PermissionLockdownTestActivity.ACTIVITY_ALIAS,
                AuthenticationBoundKeyTestActivity.class.getName(),
                VpnTestActivity.class.getName(),
                AlwaysOnVpnSettingsTestActivity.class.getName(),
                CrossProfilePermissionControlActivity.class.getName(),
                IntermediateRecentActivity.class.getName(),
                CommandReceiverActivity.class.getName(),
                SetSupportMessageActivity.class.getName(),
                KeyChainTestActivity.class.getName(),
                WorkProfileWidgetActivity.class.getName(),
                LocationCheckerActivity.WORK_ACTIVITY_ALIAS
        };
        for (String component : components) {
            mPackageManager.setComponentEnabledSetting(new ComponentName(mContext, component),
                    enabledState, PackageManager.DONT_KILL_APP);
        }
    }
}"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.server.wm.ActivityManagerTestBase"	"PostAssertionRule"	""	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/util/src/android/server/wm/ActivityManagerTestBase.java"	""	"public void test/*
 *
 */

package android.server.wm;

import static android.app.AppOpsManager.MODE_ALLOWED;
import static android.app.AppOpsManager.OPSTR_SYSTEM_ALERT_WINDOW;
import static android.app.Instrumentation.ActivityMonitor;
import static android.app.WindowConfiguration.ACTIVITY_TYPE_ASSISTANT;
import static android.app.WindowConfiguration.ACTIVITY_TYPE_RECENTS;
import static android.app.WindowConfiguration.ACTIVITY_TYPE_STANDARD;
import static android.app.WindowConfiguration.ACTIVITY_TYPE_UNDEFINED;
import static android.app.WindowConfiguration.WINDOWING_MODE_UNDEFINED;
import static android.content.Intent.ACTION_MAIN;
import static android.content.Intent.CATEGORY_HOME;
import static android.content.Intent.FLAG_ACTIVITY_MULTIPLE_TASK;
import static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;
import static android.content.pm.PackageManager.COMPONENT_ENABLED_STATE_DISABLED;
import static android.content.pm.PackageManager.COMPONENT_ENABLED_STATE_ENABLED;
import static android.content.pm.PackageManager.DONT_KILL_APP;
import static android.content.pm.PackageManager.FEATURE_ACTIVITIES_ON_SECONDARY_DISPLAYS;
import static android.content.pm.PackageManager.FEATURE_AUTOMOTIVE;
import static android.content.pm.PackageManager.FEATURE_EMBEDDED;
import static android.content.pm.PackageManager.FEATURE_FREEFORM_WINDOW_MANAGEMENT;
import static android.content.pm.PackageManager.FEATURE_INPUT_METHODS;
import static android.content.pm.PackageManager.FEATURE_LEANBACK;
import static android.content.pm.PackageManager.FEATURE_PICTURE_IN_PICTURE;
import static android.content.pm.PackageManager.FEATURE_SCREEN_LANDSCAPE;
import static android.content.pm.PackageManager.FEATURE_SCREEN_PORTRAIT;
import static android.content.pm.PackageManager.FEATURE_SECURE_LOCK_SCREEN;
import static android.content.pm.PackageManager.FEATURE_TELEVISION;
import static android.content.pm.PackageManager.FEATURE_VR_MODE_HIGH_PERFORMANCE;
import static android.content.pm.PackageManager.FEATURE_WATCH;
import static android.content.pm.PackageManager.MATCH_DEFAULT_ONLY;
import static android.server.wm.ActivityLauncher.KEY_ACTIVITY_TYPE;
import static android.server.wm.ActivityLauncher.KEY_DISPLAY_ID;
import static android.server.wm.ActivityLauncher.KEY_INTENT_EXTRAS;
import static android.server.wm.ActivityLauncher.KEY_INTENT_FLAGS;
import static android.server.wm.ActivityLauncher.KEY_LAUNCH_ACTIVITY;
import static android.server.wm.ActivityLauncher.KEY_LAUNCH_TASK_BEHIND;
import static android.server.wm.ActivityLauncher.KEY_LAUNCH_TO_SIDE;
import static android.server.wm.ActivityLauncher.KEY_MULTIPLE_INSTANCES;
import static android.server.wm.ActivityLauncher.KEY_MULTIPLE_TASK;
import static android.server.wm.ActivityLauncher.KEY_NEW_TASK;
import static android.server.wm.ActivityLauncher.KEY_RANDOM_DATA;
import static android.server.wm.ActivityLauncher.KEY_REORDER_TO_FRONT;
import static android.server.wm.ActivityLauncher.KEY_SUPPRESS_EXCEPTIONS;
import static android.server.wm.ActivityLauncher.KEY_TARGET_COMPONENT;
import static android.server.wm.ActivityLauncher.KEY_USE_APPLICATION_CONTEXT;
import static android.server.wm.ActivityLauncher.KEY_WINDOWING_MODE;
import static android.server.wm.ActivityLauncher.launchActivityFromExtras;
import static android.server.wm.CommandSession.KEY_FORWARD;
import static android.server.wm.ComponentNameUtils.getActivityName;
import static android.server.wm.ComponentNameUtils.getLogTag;
import static android.server.wm.StateLogger.log;
import static android.server.wm.StateLogger.logE;
import static android.server.wm.UiDeviceUtils.pressBackButton;
import static android.server.wm.UiDeviceUtils.pressEnterButton;
import static android.server.wm.UiDeviceUtils.pressHomeButton;
import static android.server.wm.UiDeviceUtils.pressSleepButton;
import static android.server.wm.UiDeviceUtils.pressUnlockButton;
import static android.server.wm.UiDeviceUtils.pressWakeupButton;
import static android.server.wm.UiDeviceUtils.waitForDeviceIdle;
import static android.server.wm.WindowManagerState.STATE_RESUMED;
import static android.server.wm.app.Components.BROADCAST_RECEIVER_ACTIVITY;
import static android.server.wm.app.Components.BroadcastReceiverActivity.ACTION_TRIGGER_BROADCAST;
import static android.server.wm.app.Components.BroadcastReceiverActivity.EXTRA_BROADCAST_ORIENTATION;
import static android.server.wm.app.Components.BroadcastReceiverActivity.EXTRA_CUTOUT_EXISTS;
import static android.server.wm.app.Components.BroadcastReceiverActivity.EXTRA_DISMISS_KEYGUARD;
import static android.server.wm.app.Components.BroadcastReceiverActivity.EXTRA_DISMISS_KEYGUARD_METHOD;
import static android.server.wm.app.Components.BroadcastReceiverActivity.EXTRA_FINISH_BROADCAST;
import static android.server.wm.app.Components.BroadcastReceiverActivity.EXTRA_MOVE_BROADCAST_TO_BACK;
import static android.server.wm.app.Components.LAUNCHING_ACTIVITY;
import static android.server.wm.app.Components.LaunchingActivity.KEY_FINISH_BEFORE_LAUNCH;
import static android.server.wm.app.Components.PipActivity.ACTION_EXPAND_PIP;
import static android.server.wm.app.Components.PipActivity.ACTION_SET_REQUESTED_ORIENTATION;
import static android.server.wm.app.Components.PipActivity.ACTION_UPDATE_PIP_STATE;
import static android.server.wm.app.Components.PipActivity.EXTRA_PIP_ORIENTATION;
import static android.server.wm.app.Components.PipActivity.EXTRA_SET_ASPECT_RATIO_WITH_DELAY_DENOMINATOR;
import static android.server.wm.app.Components.PipActivity.EXTRA_SET_ASPECT_RATIO_WITH_DELAY_NUMERATOR;
import static android.server.wm.app.Components.PipActivity.EXTRA_SET_PIP_CALLBACK;
import static android.server.wm.app.Components.PipActivity.EXTRA_SET_PIP_STASHED;
import static android.server.wm.app.Components.TEST_ACTIVITY;
import static android.server.wm.second.Components.SECOND_ACTIVITY;
import static android.server.wm.third.Components.THIRD_ACTIVITY;
import static android.view.Display.DEFAULT_DISPLAY;
import static android.view.Display.INVALID_DISPLAY;
import static android.view.Surface.ROTATION_0;
import static android.view.WindowManager.LayoutParams.TYPE_BASE_APPLICATION;

import static androidx.test.platform.app.InstrumentationRegistry.getInstrumentation;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.junit.Assume.assumeTrue;

import static java.lang.Integer.toHexString;

import android.accessibilityservice.AccessibilityService;
import android.app.Activity;
import android.app.ActivityManager;
import android.app.ActivityOptions;
import android.app.ActivityTaskManager;
import android.app.Instrumentation;
import android.app.KeyguardManager;
import android.app.WindowConfiguration;
import android.content.ComponentName;
import android.content.ContentResolver;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.content.pm.ResolveInfo;
import android.content.res.Resources;
import android.database.ContentObserver;
import android.graphics.Bitmap;
import android.graphics.Rect;
import android.hardware.display.AmbientDisplayConfiguration;
import android.hardware.display.DisplayManager;
import android.os.Bundle;
import android.os.Handler;
import android.os.HandlerThread;
import android.os.PowerManager;
import android.os.RemoteCallback;
import android.os.SystemClock;
import android.os.SystemProperties;
import android.provider.Settings;
import android.server.wm.CommandSession.ActivityCallback;
import android.server.wm.CommandSession.ActivitySession;
import android.server.wm.CommandSession.ActivitySessionClient;
import android.server.wm.CommandSession.ConfigInfo;
import android.server.wm.CommandSession.LaunchInjector;
import android.server.wm.CommandSession.LaunchProxy;
import android.server.wm.CommandSession.SizeInfo;
import android.server.wm.TestJournalProvider.TestJournalContainer;
import android.server.wm.WindowManagerState.WindowState;
import android.server.wm.settings.SettingsSession;
import android.util.DisplayMetrics;
import android.util.EventLog;
import android.util.EventLog.Event;
import android.view.Display;
import android.view.View;
import android.view.WindowManager;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.test.ext.junit.rules.ActivityScenarioRule;

import com.android.compatibility.common.util.AppOpsUtils;
import com.android.compatibility.common.util.SystemUtil;

import org.junit.Before;
import org.junit.Rule;
import org.junit.rules.ErrorCollector;
import org.junit.rules.RuleChain;
import org.junit.rules.TestRule;
import org.junit.runner.Description;
import org.junit.runners.model.Statement;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.UUID;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.BooleanSupplier;
import java.util.function.Consumer;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public abstract class ActivityManagerTestBase {
    private static final boolean PRETEND_DEVICE_SUPPORTS_PIP = false;
    private static final boolean PRETEND_DEVICE_SUPPORTS_FREEFORM = false;
    private static final String LOG_SEPARATOR = ""LOG_SEPARATOR"";
    // Use one of the test tags as a separator
    private static final int EVENT_LOG_SEPARATOR_TAG = 42;

    protected static final int[] ALL_ACTIVITY_TYPE_BUT_HOME = {
            ACTIVITY_TYPE_STANDARD, ACTIVITY_TYPE_ASSISTANT, ACTIVITY_TYPE_RECENTS,
            ACTIVITY_TYPE_UNDEFINED
    };

    private static final String TEST_PACKAGE = TEST_ACTIVITY.getPackageName();
    private static final String SECOND_TEST_PACKAGE = SECOND_ACTIVITY.getPackageName();
    private static final String THIRD_TEST_PACKAGE = THIRD_ACTIVITY.getPackageName();
    private static final List<String> TEST_PACKAGES;

    static {
        final List<String> testPackages = new ArrayList<>();
        testPackages.add(TEST_PACKAGE);
        testPackages.add(SECOND_TEST_PACKAGE);
        testPackages.add(THIRD_TEST_PACKAGE);
        testPackages.add(""android.server.wm.cts"");
        testPackages.add(""android.server.wm.jetpack"");
        TEST_PACKAGES = Collections.unmodifiableList(testPackages);
    }

    protected static final String AM_START_HOME_ACTIVITY_COMMAND =
            ""am start -a android.intent.action.MAIN -c android.intent.category.HOME"";

    protected static final String MSG_NO_MOCK_IME =
            ""MockIme cannot be used for devices that do not support installable IMEs"";

    private static final String AM_BROADCAST_CLOSE_SYSTEM_DIALOGS =
            ""am broadcast -a android.intent.action.CLOSE_SYSTEM_DIALOGS"";

    protected static final String LOCK_CREDENTIAL = ""1234"";

    private static final int UI_MODE_TYPE_MASK = 0x0f;
    private static final int UI_MODE_TYPE_VR_HEADSET = 0x07;

    private static Boolean sHasHomeScreen = null;
    private static Boolean sSupportsSystemDecorsOnSecondaryDisplays = null;
    private static Boolean sSupportsInsecureLockScreen = null;
    private static Boolean sIsAssistantOnTop = null;
    private static boolean sIllegalTaskStateFound;

    protected static final int INVALID_DEVICE_ROTATION = -1;

    protected final Instrumentation mInstrumentation = getInstrumentation();
    protected final Context mContext = getInstrumentation().getContext();
    protected final ActivityManager mAm = mContext.getSystemService(ActivityManager.class);
    protected final ActivityTaskManager mAtm = mContext.getSystemService(ActivityTaskManager.class);
    protected final DisplayManager mDm = mContext.getSystemService(DisplayManager.class);
    protected final WindowManager mWm = mContext.getSystemService(WindowManager.class);
    protected final KeyguardManager mKm = mContext.getSystemService(KeyguardManager.class);

    /** The tracker to manage objects (especially {@link AutoCloseable}) in a test method. */
    protected final ObjectTracker mObjectTracker = new ObjectTracker();

    /** The last rule to handle all errors. */
    private final ErrorCollector mPostAssertionRule = new PostAssertionRule();

    /** The necessary procedures of set up and tear down. */
    @Rule
    public final TestRule mBaseRule = RuleChain.outerRule(mPostAssertionRule)
            .around(new WrapperRule(null /* before */, this::tearDownBase));

    /**
     * @return the am command to start the given activity with the following extra key/value pairs.
     * {@param extras} a list of {@link CliIntentExtra} representing a generic intent extra
     */
    // TODO: Make this more generic, for instance accepting flags or extras of other types.
    protected static String getAmStartCmd(final ComponentName activityName,
            final CliIntentExtra... extras) {
        return getAmStartCmdInternal(getActivityName(activityName), extras);
    }

    private static String getAmStartCmdInternal(final String activityName,
            final CliIntentExtra... extras) {
        return appendKeyValuePairs(
                new StringBuilder(""am start -n "").append(activityName),
                extras);
    }

    private static String appendKeyValuePairs(
            final StringBuilder cmd, final CliIntentExtra... extras) {
        for (int i = 0; i < extras.length; i++) {
            extras[i].appendTo(cmd);
        }
        return cmd.toString();
    }

    protected static String getAmStartCmd(final ComponentName activityName, final int displayId,
            final CliIntentExtra... extras) {
        return getAmStartCmdInternal(getActivityName(activityName), displayId, extras);
    }

    private static String getAmStartCmdInternal(final String activityName, final int displayId,
            final CliIntentExtra... extras) {
        return appendKeyValuePairs(
                new StringBuilder(""am start -n "")
                        .append(activityName)
                        .append("" -f 0x"")
                        .append(toHexString(FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_MULTIPLE_TASK))
                        .append("" --display "")
                        .append(displayId),
                extras);
    }

    protected static String getAmStartCmdInNewTask(final ComponentName activityName) {
        return ""am start -n "" + getActivityName(activityName) + "" -f 0x18000000"";
    }

    protected static String getAmStartCmdWithData(final ComponentName activityName, String data) {
        return ""am start -n "" + getActivityName(activityName) + "" -d "" + data;
    }

    protected static String getAmStartCmdOverHome(final ComponentName activityName) {
        return ""am start --activity-task-on-home -n "" + getActivityName(activityName);
    }

    protected WindowManagerStateHelper mWmState = new WindowManagerStateHelper();
    protected TouchHelper mTouchHelper = new TouchHelper(mInstrumentation, mWmState);
    // Initialized in setUp to execute with proper permission, such as MANAGE_ACTIVITY_TASKS
    public TestTaskOrganizer mTaskOrganizer;

    public WindowManagerStateHelper getWmState() {
        return mWmState;
    }

    protected BroadcastActionTrigger mBroadcastActionTrigger = new BroadcastActionTrigger();

    /** Runs a runnable with shell permissions. These can be nested. */
    protected void runWithShellPermission(Runnable runnable) {
        NestedShellPermission.run(runnable);
    }
    /**
     * Returns true if the activity is shown before timeout.
     */
    protected boolean waitForActivityFocused(int timeoutMs, ComponentName componentName) {
        long endTime = System.currentTimeMillis() + timeoutMs;
        while (endTime > System.currentTimeMillis()) {
            mWmState.computeState();
            if (mWmState.hasActivityState(componentName, STATE_RESUMED)) {
                SystemClock.sleep(200);
                mWmState.computeState();
                break;
            }
            SystemClock.sleep(200);
            mWmState.computeState();
        }
        return getActivityName(componentName).equals(mWmState.getFocusedActivity());
    }

    /**
     * Helper class to process test actions by broadcast.
     */
    protected class BroadcastActionTrigger {

        private Intent createIntentWithAction(String broadcastAction) {
            return new Intent(broadcastAction)
                    .setFlags(Intent.FLAG_RECEIVER_FOREGROUND);
        }

        void doAction(String broadcastAction) {
            mContext.sendBroadcast(createIntentWithAction(broadcastAction));
        }

        void finishBroadcastReceiverActivity() {
            mContext.sendBroadcast(createIntentWithAction(ACTION_TRIGGER_BROADCAST)
                    .putExtra(EXTRA_FINISH_BROADCAST, true));
        }

        void launchActivityNewTask(String launchComponent) {
            mContext.sendBroadcast(createIntentWithAction(ACTION_TRIGGER_BROADCAST)
                    .putExtra(KEY_LAUNCH_ACTIVITY, true)
                    .putExtra(KEY_NEW_TASK, true)
                    .putExtra(KEY_TARGET_COMPONENT, launchComponent));
        }

        void moveTopTaskToBack() {
            mContext.sendBroadcast(createIntentWithAction(ACTION_TRIGGER_BROADCAST)
                    .putExtra(EXTRA_MOVE_BROADCAST_TO_BACK, true));
        }

        void requestOrientation(int orientation) {
            mContext.sendBroadcast(createIntentWithAction(ACTION_TRIGGER_BROADCAST)
                    .putExtra(EXTRA_BROADCAST_ORIENTATION, orientation));
        }

        void dismissKeyguardByFlag() {
            mContext.sendBroadcast(createIntentWithAction(ACTION_TRIGGER_BROADCAST)
                    .putExtra(EXTRA_DISMISS_KEYGUARD, true));
        }

        void dismissKeyguardByMethod() {
            mContext.sendBroadcast(createIntentWithAction(ACTION_TRIGGER_BROADCAST)
                    .putExtra(EXTRA_DISMISS_KEYGUARD_METHOD, true));
        }

        void expandPip() {
            mContext.sendBroadcast(createIntentWithAction(ACTION_EXPAND_PIP));
        }

        void expandPipWithAspectRatio(String extraNum, String extraDenom) {
            mContext.sendBroadcast(createIntentWithAction(ACTION_EXPAND_PIP)
                    .putExtra(EXTRA_SET_ASPECT_RATIO_WITH_DELAY_NUMERATOR, extraNum)
                    .putExtra(EXTRA_SET_ASPECT_RATIO_WITH_DELAY_DENOMINATOR, extraDenom));
        }

        void sendPipStateUpdate(RemoteCallback callback, boolean stashed) {
            mContext.sendBroadcast(createIntentWithAction(ACTION_UPDATE_PIP_STATE)
                    .putExtra(EXTRA_SET_PIP_CALLBACK, callback)
                    .putExtra(EXTRA_SET_PIP_STASHED, stashed));
        }

        void requestOrientationForPip(int orientation) {
            mContext.sendBroadcast(createIntentWithAction(ACTION_SET_REQUESTED_ORIENTATION)
                    .putExtra(EXTRA_PIP_ORIENTATION, String.valueOf(orientation)));
        }
    }

    /**
     * Helper class to launch / close test activity by instrumentation way.
     */
    protected class TestActivitySession<T extends Activity> implements AutoCloseable {
        private T mTestActivity;
        boolean mFinishAfterClose;
        private static final int ACTIVITY_LAUNCH_TIMEOUT = 10000;
        private static final int WAIT_SLICE = 50;

        /**
         * Launches an {@link Activity} on a target display synchronously.
         * @param activityClass The {@link Activity} class to be launched
         * @param displayId ID of the target display
         */
        void launchTestActivityOnDisplaySync(Class<T> activityClass, int displayId) {
            launchTestActivityOnDisplaySync(activityClass, displayId, WINDOWING_MODE_UNDEFINED);
        }

        /**
         * Launches an {@link Activity} on a target display synchronously.
         *
         * @param activityClass The {@link Activity} class to be launched
         * @param displayId ID of the target display
         * @param windowingMode Windowing mode at launch
         */
        void launchTestActivityOnDisplaySync(
                Class<T> activityClass, int displayId, int windowingMode) {
            final Intent intent = new Intent(mContext, activityClass)
                    .addFlags(FLAG_ACTIVITY_NEW_TASK);
            final String className = intent.getComponent().getClassName();
            launchTestActivityOnDisplaySync(className, intent, displayId, windowingMode);
        }

        /**
         * Launches an {@link Activity} synchronously on a target display. The class name needs to
         * be provided either implicitly through the {@link Intent} or explicitly as a parameter
         *
         * @param className Optional class name of expected activity
         * @param intent Intent to launch an activity
         * @param displayId ID for the target display
         */
        void launchTestActivityOnDisplaySync(@Nullable String className, Intent intent,
                int displayId) {
            launchTestActivityOnDisplaySync(className, intent, displayId, WINDOWING_MODE_UNDEFINED);
        }

        /**
         * Launches an {@link Activity} synchronously on a target display. The class name needs to
         * be provided either implicitly through the {@link Intent} or explicitly as a parameter
         *
         * @param className Optional class name of expected activity
         * @param intent Intent to launch an activity
         * @param displayId ID for the target display
         * @param windowingMode Windowing mode at launch
         */
        void launchTestActivityOnDisplaySync(
                @Nullable String className, Intent intent, int displayId, int windowingMode) {
            runWithShellPermission(
                    () -> {
                        mTestActivity =
                                launchActivityOnDisplay(
                                        className, intent, displayId, windowingMode);
                        // Check activity is launched and resumed.
                        final ComponentName testActivityName = mTestActivity.getComponentName();
                        waitAndAssertTopResumedActivity(
                                testActivityName, displayId, ""Activity must be resumed"");
                    });
        }

        /**
         * Launches an {@link Activity} on a target display asynchronously.
         * @param activityClass The {@link Activity} class to be launched
         * @param displayId ID of the target display
         */
        void launchTestActivityOnDisplay(Class<T> activityClass, int displayId) {
            final Intent intent = new Intent(mContext, activityClass)
                    .addFlags(FLAG_ACTIVITY_NEW_TASK);
            final String className = intent.getComponent().getClassName();
            runWithShellPermission(
                    () -> {
                        mTestActivity =
                                launchActivityOnDisplay(
                                        className, intent, displayId, WINDOWING_MODE_UNDEFINED);
                        assertNotNull(mTestActivity);
                    });
        }

        /**
         * Launches an {@link Activity} on a target display. In order to return the correct activity
         * the class name or an explicit {@link Intent} must be provided.
         *
         * @param className Optional class name of expected activity
         * @param intent {@link Intent} to launch an activity
         * @param displayId ID for the target display
         * @param windowingMode Windowing mode at launch
         * @return The {@link Activity} that was launched
         */
        private T launchActivityOnDisplay(
                @Nullable String className, Intent intent, int displayId, int windowingMode) {
            final String localClassName = className != null ? className :
              (intent.getComponent() != null ? intent.getComponent().getClassName() : null);
            if (localClassName == null || localClassName.isEmpty()) {
                fail(""Must provide either a class name or an intent with a component"");
            }
            final ActivityOptions launchOptions = ActivityOptions.makeBasic();
            launchOptions.setLaunchDisplayId(displayId);
            launchOptions.setLaunchWindowingMode(windowingMode);
            final Bundle bundle = launchOptions.toBundle();
            final ActivityMonitor monitor = mInstrumentation.addMonitor(localClassName, null,
                    false);
            mContext.startActivity(intent.addFlags(FLAG_ACTIVITY_NEW_TASK), bundle);
            // Wait for activity launch with timeout.
            mTestActivity = (T) mInstrumentation.waitForMonitorWithTimeout(monitor,
                    ACTIVITY_LAUNCH_TIMEOUT);
            assertNotNull(mTestActivity);
            return mTestActivity;
        }

        void finishCurrentActivityNoWait() {
            if (mTestActivity != null) {
                mTestActivity.finishAndRemoveTask();
                mTestActivity = null;
            }
        }

        void runOnMainSyncAndWait(Runnable runnable) {
            mInstrumentation.runOnMainSync(runnable);
            mInstrumentation.waitForIdleSync();
        }

        void runOnMainAndAssertWithTimeout(@NonNull BooleanSupplier condition, long timeoutMs,
                String message) {
            final AtomicBoolean result = new AtomicBoolean();
            final long expiredTime = System.currentTimeMillis() + timeoutMs;
            while (!result.get()) {
                if (System.currentTimeMillis() >= expiredTime) {
                    fail(message);
                }
                runOnMainSyncAndWait(() -> {
                    if (condition.getAsBoolean()) {
                        result.set(true);
                    }
                });
                SystemClock.sleep(WAIT_SLICE);
            }
        }

        T getActivity() {
            return mTestActivity;
        }

        @Override
        public void close() {
            if (mTestActivity != null && mFinishAfterClose) {
                mTestActivity.finishAndRemoveTask();
            }
        }
    }

    @Before
    public void setUp() throws Exception {
        if (isKeyguardLocked() || !Objects.requireNonNull(
                mContext.getSystemService(PowerManager.class)).isInteractive()) {
            pressWakeupButton();
            pressUnlockButton();
        }
        launchHomeActivityNoWait();
        removeRootTasksWithActivityTypes(ALL_ACTIVITY_TYPE_BUT_HOME);

        runWithShellPermission(() -> {
            // TaskOrganizer ctor requires MANAGE_ACTIVITY_TASKS permission
            mTaskOrganizer = new TestTaskOrganizer(mContext);
            // Clear launch params for all test packages to make sure each test is run in a clean
            // state.
            mAtm.clearLaunchParamsForPackages(TEST_PACKAGES);
        });
    }

    /** It always executes after {@link org.junit.After}. */
    private void tearDownBase() {
        mObjectTracker.tearDown(mPostAssertionRule::addError);

        if (mTaskOrganizer != null) {
            mTaskOrganizer.unregisterOrganizerIfNeeded();
        }
        // Synchronous execution of removeRootTasksWithActivityTypes() ensures that all
        // activities but home are cleaned up from the root task at the end of each test. Am force
        // stop shell commands might be asynchronous and could interrupt the task cleanup
        // process if executed first.
        removeRootTasksWithActivityTypes(ALL_ACTIVITY_TYPE_BUT_HOME);
        stopTestPackage(TEST_PACKAGE);
        stopTestPackage(SECOND_TEST_PACKAGE);
        stopTestPackage(THIRD_TEST_PACKAGE);
        launchHomeActivityNoWait();
    }

    /**
     * After home key is pressed ({@link #pressHomeButton} is called), the later launch may be
     * deferred if the calling uid doesn't have android.permission.STOP_APP_SWITCHES. This method
     * will resume the temporary stopped state, so the launch won't be affected.
     */
    protected void resumeAppSwitches() {
        SystemUtil.runWithShellPermissionIdentity(ActivityManager::resumeAppSwitches);
    }

    protected void startActivityOnDisplay(int displayId, ComponentName component) {
        final ActivityOptions options = ActivityOptions.makeBasic();
        options.setLaunchDisplayId(displayId);

        mContext.startActivity(new Intent().addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                .setComponent(component), options.toBundle());
    }

    protected boolean noHomeScreen() {
        try {
            return mContext.getResources().getBoolean(
                    Resources.getSystem().getIdentifier(""config_noHomeScreen"", ""bool"",
                            ""android""));
        } catch (Resources.NotFoundException e) {
            // Assume there's a home screen.
            return false;
        }
    }

    private boolean getSupportsSystemDecorsOnSecondaryDisplays() {
        try {
            return mContext.getResources().getBoolean(
                    Resources.getSystem().getIdentifier(
                            ""config_supportsSystemDecorsOnSecondaryDisplays"", ""bool"", ""android""));
        } catch (Resources.NotFoundException e) {
            // Assume this device support system decorations.
            return true;
        }
    }

    protected ComponentName getDefaultSecondaryHomeComponent() {
        assumeTrue(supportsMultiDisplay());
        int resId = Resources.getSystem().getIdentifier(
                ""config_secondaryHomePackage"", ""string"", ""android"");
        final Intent intent = new Intent(Intent.ACTION_MAIN);
        intent.addCategory(Intent.CATEGORY_SECONDARY_HOME);
        intent.setPackage(mContext.getResources().getString(resId));
        final ResolveInfo resolveInfo =
                mContext.getPackageManager().resolveActivity(intent, MATCH_DEFAULT_ONLY);
        assertNotNull(""Should have default secondary home activity"", resolveInfo);

        return new ComponentName(resolveInfo.activityInfo.packageName,
                resolveInfo.activityInfo.name);
    }

    /**
     * Insert an input event (ACTION_DOWN -> ACTION_CANCEL) to ensures the display to be focused
     * without triggering potential clicked to impact the test environment.
     * (e.g: Keyguard credential activated unexpectedly.)
     *
     * @param displayId the display ID to gain focused by inject swipe action
     */
    protected void touchAndCancelOnDisplayCenterSync(int displayId) {
        mTouchHelper.touchAndCancelOnDisplayCenterSync(displayId);
    }

    protected void tapOnDisplaySync(int x, int y, int displayId) {
        mTouchHelper.tapOnDisplaySync(x, y, displayId);
    }

    private void tapOnDisplay(int x, int y, int displayId, boolean sync) {
        mTouchHelper.tapOnDisplay(x, y, displayId, sync);
    }

    protected void tapOnCenter(Rect bounds, int displayId) {
        mTouchHelper.tapOnCenter(bounds, displayId);
    }

    protected void tapOnViewCenter(View view) {
        mTouchHelper.tapOnViewCenter(view);
    }

    protected void tapOnCenterAsync(Rect bounds, int displayId) {
        final int tapX = bounds.left + bounds.width() / 2;
        final int tapY = bounds.top + bounds.height() / 2;
        tapOnDisplay(tapX, tapY, displayId, false /* sync*/);
    }

    protected void tapOnStackCenter(WindowManagerState.ActivityTask stack) {
        mTouchHelper.tapOnStackCenter(stack);
    }

    protected  void tapOnStackCenterAsync(WindowManagerState.ActivityTask stack) {
        tapOnCenterAsync(stack.getBounds(), stack.mDisplayId);
    }

    protected void tapOnDisplayCenter(int displayId) {
        mTouchHelper.tapOnDisplayCenter(displayId);
    }

    protected void tapOnDisplayCenterAsync(int displayId) {
        mTouchHelper.tapOnDisplayCenterAsync(displayId);
    }

    public static void injectKey(int keyCode, boolean longPress, boolean sync) {
        TouchHelper.injectKey(keyCode, longPress, sync);
    }

    protected void removeRootTasksWithActivityTypes(int... activityTypes) {
        runWithShellPermission(() -> mAtm.removeRootTasksWithActivityTypes(activityTypes));
        waitForIdle();
    }

    protected void removeRootTasksInWindowingModes(int... windowingModes) {
        runWithShellPermission(() -> mAtm.removeRootTasksInWindowingModes(windowingModes));
        waitForIdle();
    }

    protected void removeRootTask(int taskId) {
        runWithShellPermission(() -> mAtm.removeTask(taskId));
        waitForIdle();
    }

    public static String executeShellCommand(String command) {
        log(""Shell command: "" + command);
        try {
            return SystemUtil.runShellCommand(getInstrumentation(), command);
        } catch (IOException e) {
            //bubble it up
            logE(""Error running shell command: "" + command);
            throw new RuntimeException(e);
        }
    }

    protected Bitmap takeScreenshot() {
        return mInstrumentation.getUiAutomation().takeScreenshot();
    }

    protected void launchActivity(final ComponentName activityName,
            final CliIntentExtra... extras) {
        launchActivityNoWait(activityName, extras);
        mWmState.waitForValidState(activityName);
    }

    protected void launchActivityNoWait(final ComponentName activityName,
            final CliIntentExtra... extras) {
        executeShellCommand(getAmStartCmd(activityName, extras));
    }

    protected void launchActivityInNewTask(final ComponentName activityName) {
        executeShellCommand(getAmStartCmdInNewTask(activityName));
        mWmState.waitForValidState(activityName);
    }

    protected void launchActivityWithData(final ComponentName activityName, String data) {
        executeShellCommand(getAmStartCmdWithData(activityName, data));
        mWmState.waitForValidState(activityName);
    }

    protected static void waitForIdle() {
        getInstrumentation().waitForIdleSync();
    }

    static void waitForOrFail(String message, BooleanSupplier condition) {
        Condition.waitFor(new Condition<>(message, condition)
                .setRetryIntervalMs(500)
                .setRetryLimit(20)
                .setOnFailure(unusedResult -> fail(""FAILED because unsatisfied: "" + message)));
    }

    /** Returns the stack that contains the provided task. */
    protected WindowManagerState.ActivityTask getStackForTaskId(int taskId) {
        mWmState.computeState();
        final List<WindowManagerState.ActivityTask> stacks = mWmState.getRootTasks();
        for (WindowManagerState.ActivityTask stack : stacks) {
            if (stack.getTask(taskId) != null) {
                return stack;
            }
        }
        return null;
    }

    protected WindowManagerState.ActivityTask getRootTask(int taskId) {
        mWmState.computeState();
        final List<WindowManagerState.ActivityTask> rootTasks = mWmState.getRootTasks();
        for (WindowManagerState.ActivityTask rootTask : rootTasks) {
            if (rootTask.getTaskId() == taskId) {
                return rootTask;
            }
        }
        return null;
    }

    protected int getDisplayWindowingModeByActivity(ComponentName activity) {
        return mWmState.getDisplay(mWmState.getDisplayByActivity(activity)).getWindowingMode();
    }

    /**
     * Launches the home activity directly. If there is no specific reason to simulate a home key
     * (which will trigger stop-app-switches), it is the recommended method to go home.
     */
    protected static void launchHomeActivityNoWait() {
        // dismiss all system dialogs before launch home.
        executeShellCommand(AM_BROADCAST_CLOSE_SYSTEM_DIALOGS);
        executeShellCommand(AM_START_HOME_ACTIVITY_COMMAND);
    }

    /** Launches the home activity directly with waiting for it to be visible. */
    protected void launchHomeActivity() {
        launchHomeActivityNoWait();
        mWmState.waitForHomeActivityVisible();
    }

    protected void launchActivityNoWait(ComponentName activityName, int windowingMode,
            final CliIntentExtra... extras) {
        executeShellCommand(getAmStartCmd(activityName, extras)
                + "" --windowingMode "" + windowingMode);
    }

    protected void launchActivity(ComponentName activityName, int windowingMode,
            final CliIntentExtra... keyValuePairs) {
        launchActivityNoWait(activityName, windowingMode, keyValuePairs);
        mWmState.waitForValidState(new WaitForValidActivityState.Builder(activityName)
                .setWindowingMode(windowingMode)
                .build());
    }

    protected void launchActivityOnDisplay(ComponentName activityName, int windowingMode,
            int displayId, final CliIntentExtra... extras) {
        executeShellCommand(getAmStartCmd(activityName, displayId, extras)
                + "" --windowingMode "" + windowingMode);
        mWmState.waitForValidState(new WaitForValidActivityState.Builder(activityName)
                .setWindowingMode(windowingMode)
                .build());
    }

    protected void launchActivityOnDisplay(ComponentName activityName, int displayId,
            CliIntentExtra... extras) {
        launchActivityOnDisplayNoWait(activityName, displayId, extras);
        mWmState.waitForValidState(activityName);
    }

    protected void launchActivityOnDisplayNoWait(ComponentName activityName, int displayId,
            CliIntentExtra... extras) {
        executeShellCommand(getAmStartCmd(activityName, displayId, extras));
    }

    protected void launchActivityInPrimarySplit(ComponentName activityName) {
        runWithShellPermission(() -> {
            launchActivity(activityName);
            final int taskId = mWmState.getTaskByActivity(activityName).mTaskId;
            mTaskOrganizer.putTaskInSplitPrimary(taskId);
            mWmState.waitForValidState(activityName);
        });
    }

    protected void launchActivityInSecondarySplit(ComponentName activityName) {
        runWithShellPermission(() -> {
            launchActivity(activityName);
            final int taskId = mWmState.getTaskByActivity(activityName).mTaskId;
            mTaskOrganizer.putTaskInSplitSecondary(taskId);
            mWmState.waitForValidState(activityName);
        });
    }

    protected void putActivityInPrimarySplit(ComponentName activityName) {
        final int taskId = mWmState.getTaskByActivity(activityName).mTaskId;
        mTaskOrganizer.putTaskInSplitPrimary(taskId);
        mWmState.waitForValidState(activityName);
    }

    protected void putActivityInSecondarySplit(ComponentName activityName) {
        final int taskId = mWmState.getTaskByActivity(activityName).mTaskId;
        mTaskOrganizer.putTaskInSplitSecondary(taskId);
        mWmState.waitForValidState(activityName);
    }

    /**
     * Launches {@param primaryActivity} into split-screen primary windowing mode
     * and {@param secondaryActivity} to the side in split-screen secondary windowing mode.
     */
    protected void launchActivitiesInSplitScreen(LaunchActivityBuilder primaryActivity,
            LaunchActivityBuilder secondaryActivity) {
        // Launch split-screen primary.
        primaryActivity
                .setUseInstrumentation()
                .setWaitForLaunched(true)
                .execute();

        final int primaryTaskId = mWmState.getTaskByActivity(
                primaryActivity.mTargetActivity).mTaskId;
        mTaskOrganizer.putTaskInSplitPrimary(primaryTaskId);

        // Launch split-screen secondary
        secondaryActivity
                .setUseInstrumentation()
                .setWaitForLaunched(true)
                .setNewTask(true)
                .setMultipleTask(true)
                .execute();

        final int secondaryTaskId = mWmState.getTaskByActivity(
                secondaryActivity.mTargetActivity).mTaskId;
        mTaskOrganizer.putTaskInSplitSecondary(secondaryTaskId);
        mWmState.computeState(primaryActivity.getTargetActivity(),
                secondaryActivity.getTargetActivity());
        log(""launchActivitiesInSplitScreen(), primaryTaskId="" + primaryTaskId +
                "", secondaryTaskId="" + secondaryTaskId);
    }

    /**
     * Move the task of {@param primaryActivity} into split-screen primary and the task of
     * {@param secondaryActivity} to the side in split-screen secondary.
     */
    protected void moveActivitiesToSplitScreen(ComponentName primaryActivity,
            ComponentName secondaryActivity) {
        final int primaryTaskId = mWmState.getTaskByActivity(primaryActivity).mTaskId;
        mTaskOrganizer.putTaskInSplitPrimary(primaryTaskId);

        final int secondaryTaskId = mWmState.getTaskByActivity(secondaryActivity).mTaskId;
        mTaskOrganizer.putTaskInSplitSecondary(secondaryTaskId);

        mWmState.computeState(primaryActivity, secondaryActivity);
        log(""moveActivitiesToSplitScreen(), primaryTaskId="" + primaryTaskId +
                "", secondaryTaskId="" + secondaryTaskId);
    }

    protected void dismissSplitScreen(boolean primaryOnTop) {
        if (mTaskOrganizer != null) {
            mTaskOrganizer.dismissSplitScreen(primaryOnTop);
        }
    }

    /**
     * Move activity to root task or on top of the given root task when the root task is also a leaf
     * task.
     */
    protected void moveActivityToRootTaskOrOnTop(ComponentName activityName, int rootTaskId) {
        mWmState.computeState(activityName);
        WindowManagerState.ActivityTask rootTask = getRootTask(rootTaskId);
        if (rootTask.getActivities().size() != 0) {
            // If the root task is a 1-level task, start the activity on top of given task.
            getLaunchActivityBuilder()
                    .setDisplayId(rootTask.mDisplayId)
                    .setWindowingMode(rootTask.getWindowingMode())
                    .setActivityType(rootTask.getActivityType())
                    .setTargetActivity(activityName)
                    .allowMultipleInstances(false)
                    .setUseInstrumentation()
                    .execute();
        } else {
            final int taskId = mWmState.getTaskByActivity(activityName).mTaskId;
            runWithShellPermission(() -> mAtm.moveTaskToRootTask(taskId, rootTaskId, true));
        }
        mWmState.waitForValidState(new WaitForValidActivityState.Builder(activityName)
                .setStackId(rootTaskId)
                .build());
    }

    protected void resizeActivityTask(
            ComponentName activityName, int left, int top, int right, int bottom) {
        mWmState.computeState(activityName);
        final int taskId = mWmState.getTaskByActivity(activityName).mTaskId;
        runWithShellPermission(() -> mAtm.resizeTask(taskId, new Rect(left, top, right, bottom)));
    }

    protected boolean supportsVrMode() {
        return hasDeviceFeature(FEATURE_VR_MODE_HIGH_PERFORMANCE);
    }

    protected boolean supportsPip() {
        return hasDeviceFeature(FEATURE_PICTURE_IN_PICTURE)
                || PRETEND_DEVICE_SUPPORTS_PIP;
    }

    protected boolean supportsFreeform() {
        return hasDeviceFeature(FEATURE_FREEFORM_WINDOW_MANAGEMENT)
                || PRETEND_DEVICE_SUPPORTS_FREEFORM;
    }

    /** Whether or not the device supports lock screen. */
    protected boolean supportsLockScreen() {
        return supportsInsecureLock() || supportsSecureLock();
    }

    /** Whether or not the device supports pin/pattern/password lock. */
    protected boolean supportsSecureLock() {
        return hasDeviceFeature(FEATURE_SECURE_LOCK_SCREEN);
    }

    /** Whether or not the device supports ""swipe"" lock. */
    protected boolean supportsInsecureLock() {
        return !hasDeviceFeature(FEATURE_LEANBACK)
                && !hasDeviceFeature(FEATURE_WATCH)
                && !hasDeviceFeature(FEATURE_EMBEDDED)
                && !hasDeviceFeature(FEATURE_AUTOMOTIVE)
                && getSupportsInsecureLockScreen();
    }

    protected boolean supportsBlur() {
        return SystemProperties.get(""ro.surface_flinger.supports_background_blur"", ""default"")
                .equals(""1"");
    }

    protected boolean isWatch() {
        return hasDeviceFeature(FEATURE_WATCH);
    }

    protected boolean isCar() {
        return hasDeviceFeature(FEATURE_AUTOMOTIVE);
    }

    protected boolean isLeanBack() {
        return hasDeviceFeature(FEATURE_TELEVISION);
    }

    protected boolean isTablet() {
        // Larger than approx 7"" tablets
        return mContext.getResources().getConfiguration().smallestScreenWidthDp >= 600;
    }

    protected boolean isOperatorTierDevice() {
        return hasDeviceFeature(""com.google.android.tv.operator_tier"");
    }

    protected void waitAndAssertActivityState(ComponentName activityName,
            String state, String message) {
        mWmState.waitForActivityState(activityName, state);

        assertTrue(message, mWmState.hasActivityState(activityName, state));
    }

    protected boolean isKeyguardLocked() {
        return mKm != null && mKm.isKeyguardLocked();
    }

    protected void waitAndAssertActivityStateOnDisplay(ComponentName activityName, String state,
            int displayId, String message) {
        waitAndAssertActivityState(activityName, state, message);
        assertEquals(message, mWmState.getDisplayByActivity(activityName),
                displayId);
    }

    public void waitAndAssertTopResumedActivity(ComponentName activityName, int displayId,
            String message) {
        final String activityClassName = getActivityName(activityName);
        mWmState.waitForWithAmState(state -> activityClassName.equals(state.getFocusedActivity()),
                ""activity to be on top"");
        waitAndAssertResumedActivity(activityName, ""Activity must be resumed"");
        mWmState.assertFocusedActivity(message, activityName);

        final int frontRootTaskId = mWmState.getFrontRootTaskId(displayId);
        WindowManagerState.ActivityTask frontRootTaskOnDisplay =
                mWmState.getRootTask(frontRootTaskId);
        assertEquals(
                ""Resumed activity of front root task of the target display must match. "" + message,
                activityClassName,
                frontRootTaskOnDisplay.isLeafTask() ? frontRootTaskOnDisplay.mResumedActivity
                        : frontRootTaskOnDisplay.getTopTask().mResumedActivity);
        mWmState.assertFocusedStack(""Top activity's rootTask must also be on top"", frontRootTaskId);
    }

    /**
     * Waits and asserts that the activity represented by the given activity name is resumed and
     * visible, but is not necessarily the top activity.
     *
     * @param activityName the activity name
     * @param message the error message
     */
    public void waitAndAssertResumedActivity(ComponentName activityName, String message) {
        mWmState.waitForValidState(activityName);
        mWmState.waitForActivityState(activityName, STATE_RESUMED);
        mWmState.assertValidity();
        assertTrue(message, mWmState.hasActivityState(activityName, STATE_RESUMED));
        mWmState.assertVisibility(activityName, true /* visible */);
    }

    // TODO: Switch to using a feature flag, when available.
    protected static boolean isUiModeLockedToVrHeadset() {
        final String output = runCommandAndPrintOutput(""dumpsys uimode"");

        Integer curUiMode = null;
        Boolean uiModeLocked = null;
        for (String line : output.split(""\\n"")) {
            line = line.trim();
            Matcher matcher = sCurrentUiModePattern.matcher(line);
            if (matcher.find()) {
                curUiMode = Integer.parseInt(matcher.group(1), 16);
            }
            matcher = sUiModeLockedPattern.matcher(line);
            if (matcher.find()) {
                uiModeLocked = matcher.group(1).equals(""true"");
            }
        }

        boolean uiModeLockedToVrHeadset = (curUiMode != null) && (uiModeLocked != null)
                && ((curUiMode & UI_MODE_TYPE_MASK) == UI_MODE_TYPE_VR_HEADSET) && uiModeLocked;

        if (uiModeLockedToVrHeadset) {
            log(""UI mode is locked to VR headset"");
        }

        return uiModeLockedToVrHeadset;
    }

    protected boolean supportsMultiWindow() {
        Display defaultDisplay = mDm.getDisplay(DEFAULT_DISPLAY);
        return ActivityTaskManager.supportsSplitScreenMultiWindow(
                mContext.createDisplayContext(defaultDisplay));
    }

    /** Returns true if the default display supports split screen multi-window. */
    protected boolean supportsSplitScreenMultiWindow() {
        Display defaultDisplay = mDm.getDisplay(DEFAULT_DISPLAY);
        return supportsSplitScreenMultiWindow(mContext.createDisplayContext(defaultDisplay));
    }

    /**
     * Returns true if the display associated with the supplied {@code context} supports split
     * screen multi-window.
     */
    protected boolean supportsSplitScreenMultiWindow(Context context) {
        return ActivityTaskManager.supportsSplitScreenMultiWindow(context);
    }

    protected boolean hasHomeScreen() {
        if (sHasHomeScreen == null) {
            sHasHomeScreen = !noHomeScreen();
        }
        return sHasHomeScreen;
    }

    protected boolean supportsSystemDecorsOnSecondaryDisplays() {
        if (sSupportsSystemDecorsOnSecondaryDisplays == null) {
            sSupportsSystemDecorsOnSecondaryDisplays = getSupportsSystemDecorsOnSecondaryDisplays();
        }
        return sSupportsSystemDecorsOnSecondaryDisplays;
    }

    protected boolean getSupportsInsecureLockScreen() {
        if (sSupportsInsecureLockScreen == null) {
            try {
                sSupportsInsecureLockScreen = mContext.getResources().getBoolean(
                        Resources.getSystem().getIdentifier(
                                ""config_supportsInsecureLockScreen"", ""bool"", ""android""));
            } catch (Resources.NotFoundException e) {
                sSupportsInsecureLockScreen = true;
            }
        }
        return sSupportsInsecureLockScreen;
    }

    protected boolean isAssistantOnTopOfDream() {
        if (sIsAssistantOnTop == null) {
            sIsAssistantOnTop = mContext.getResources().getBoolean(
                    android.R.bool.config_assistantOnTopOfDream);
        }
        return sIsAssistantOnTop;
    }

    /**
     * Rotation support is indicated by explicitly having both landscape and portrait
     * features or not listing either at all.
     */
    protected boolean supportsRotation() {
        final boolean supportsLandscape = hasDeviceFeature(FEATURE_SCREEN_LANDSCAPE);
        final boolean supportsPortrait = hasDeviceFeature(FEATURE_SCREEN_PORTRAIT);
        return (supportsLandscape && supportsPortrait)
                || (!supportsLandscape && !supportsPortrait);
    }

    /**
     * The device should support orientation request from apps if it supports rotation and the
     * display is not close to square.
     */
    protected boolean supportsOrientationRequest() {
        return supportsRotation() && !isCloseToSquareDisplay();
    }

    /** Checks whether the display dimension is close to square. */
    protected boolean isCloseToSquareDisplay() {
        final Resources resources = mContext.getResources();
        final float closeToSquareMaxAspectRatio;
        try {
            closeToSquareMaxAspectRatio = resources.getFloat(resources.getIdentifier(
                    ""config_closeToSquareDisplayMaxAspectRatio"", ""dimen"", ""android""));
        } catch (Resources.NotFoundException e) {
            // Assume device is not close to square.
            return false;
        }
        final DisplayMetrics displayMetrics = new DisplayMetrics();
        mDm.getDisplay(DEFAULT_DISPLAY).getRealMetrics(displayMetrics);
        final int w = displayMetrics.widthPixels;
        final int h = displayMetrics.heightPixels;
        final float aspectRatio = Math.max(w, h) / (float) Math.min(w, h);
        return aspectRatio <= closeToSquareMaxAspectRatio;
    }

    protected boolean hasDeviceFeature(final String requiredFeature) {
        return mContext.getPackageManager()
                .hasSystemFeature(requiredFeature);
    }

    protected static boolean isDisplayPortrait() {
        final DisplayManager displayManager = getInstrumentation()
                .getContext().getSystemService(DisplayManager.class);
        final Display display = displayManager.getDisplay(DEFAULT_DISPLAY);
        final DisplayMetrics displayMetrics = new DisplayMetrics();
        display.getRealMetrics(displayMetrics);
        return displayMetrics.widthPixels < displayMetrics.heightPixels;
    }

    protected static boolean isDisplayOn(int displayId) {
        final DisplayManager displayManager = getInstrumentation()
                .getContext().getSystemService(DisplayManager.class);
        final Display display = displayManager.getDisplay(displayId);
        return display != null && display.getState() == Display.STATE_ON;
    }

    protected static boolean perDisplayFocusEnabled() {
        return getInstrumentation().getTargetContext().getResources()
                .getBoolean(android.R.bool.config_perDisplayFocusEnabled);
    }

    protected static void removeLockCredential() {
        runCommandAndPrintOutput(""locksettings clear --old "" + LOCK_CREDENTIAL);
    }

    protected static boolean remoteInsetsControllerControlsSystemBars() {
        return getInstrumentation().getTargetContext().getResources()
                .getBoolean(android.R.bool.config_remoteInsetsControllerControlsSystemBars);
    }

    /** @see ObjectTracker#manage(AutoCloseable) */
    protected HomeActivitySession createManagedHomeActivitySession(ComponentName homeActivity) {
        return mObjectTracker.manage(new HomeActivitySession(homeActivity));
    }

    /** @see ObjectTracker#manage(AutoCloseable) */
    protected ActivitySessionClient createManagedActivityClientSession() {
        return mObjectTracker.manage(new ActivitySessionClient(mContext));
    }

    /** @see ObjectTracker#manage(AutoCloseable) */
    protected LockScreenSession createManagedLockScreenSession() {
        return mObjectTracker.manage(new LockScreenSession());
    }

    /** @see ObjectTracker#manage(AutoCloseable) */
    protected RotationSession createManagedRotationSession() {
        return mObjectTracker.manage(new RotationSession());
    }

    /** @see ObjectTracker#manage(AutoCloseable) */
    protected AodSession createManagedAodSession() {
        return mObjectTracker.manage(new AodSession());
    }

    /** @see ObjectTracker#manage(AutoCloseable) */
    protected DevEnableNonResizableMultiWindowSession
    createManagedDevEnableNonResizableMultiWindowSession() {
        return mObjectTracker.manage(new DevEnableNonResizableMultiWindowSession());
    }

    /** @see ObjectTracker#manage(AutoCloseable) */
    protected <T extends Activity> TestActivitySession<T> createManagedTestActivitySession() {
        return new TestActivitySession<T>();
    }

    /** @see ObjectTracker#manage(AutoCloseable) */
    protected SystemAlertWindowAppOpSession createAllowSystemAlertWindowAppOpSession() {
        return mObjectTracker.manage(
                new SystemAlertWindowAppOpSession(mContext.getOpPackageName(), MODE_ALLOWED));
    }

    /** @see ObjectTracker#manage(AutoCloseable) */
    protected FontScaleSession createManagedFontScaleSession() {
        return mObjectTracker.manage(new FontScaleSession());
    }

    /**
     * Test @Rule class that disables screen doze settings before each test method running and
     * restoring to initial values after test method finished.
     */
    protected static class DisableScreenDozeRule implements TestRule {

        /** Copied from android.provider.Settings.Secure since these keys are hiden. */
        private static final String[] DOZE_SETTINGS = {
                ""doze_enabled"",
                ""doze_always_on"",
                ""doze_pulse_on_pick_up"",
                ""doze_pulse_on_long_press"",
                ""doze_pulse_on_double_tap"",
                ""doze_wake_screen_gesture"",
                ""doze_wake_display_gesture"",
                ""doze_tap_gesture""
        };

        private String get(String key) {
            return executeShellCommand(""settings get secure "" + key).trim();
        }

        private void put(String key, String value) {
            executeShellCommand(""settings put secure "" + key + "" "" + value);
        }

        @Override
        public Statement apply(final Statement base, final Description description) {
            return new Statement() {
                @Override
                public void evaluate() throws Throwable {
                    final Map<String, String> initialValues = new HashMap<>();
                    Arrays.stream(DOZE_SETTINGS).forEach(k -> initialValues.put(k, get(k)));
                    try {
                        Arrays.stream(DOZE_SETTINGS).forEach(k -> put(k, ""0""));
                        base.evaluate();
                    } finally {
                        Arrays.stream(DOZE_SETTINGS).forEach(k -> put(k, initialValues.get(k)));
                    }
                }
            };
        }
    }

    ComponentName getDefaultHomeComponent() {
        final Intent intent = new Intent(ACTION_MAIN);
        intent.addCategory(CATEGORY_HOME);
        intent.addFlags(FLAG_ACTIVITY_NEW_TASK);
        final ResolveInfo resolveInfo =
                mContext.getPackageManager().resolveActivity(intent, MATCH_DEFAULT_ONLY);
        if (resolveInfo == null) {
            throw new AssertionError(""Home activity not found"");
        }
        return new ComponentName(resolveInfo.activityInfo.packageName,
                resolveInfo.activityInfo.name);
    }

    /**
     * HomeActivitySession is used to replace the default home component, so that you can use
     * your preferred home for testing within the session. The original default home will be
     * restored automatically afterward.
     */
    protected class HomeActivitySession implements AutoCloseable {
        private PackageManager mPackageManager;
        private ComponentName mOrigHome;
        private ComponentName mSessionHome;

        HomeActivitySession(ComponentName sessionHome) {
            mSessionHome = sessionHome;
            mPackageManager = mContext.getPackageManager();
            mOrigHome = getDefaultHomeComponent();

            runWithShellPermission(
                    () -> mPackageManager.setComponentEnabledSetting(mSessionHome,
                            COMPONENT_ENABLED_STATE_ENABLED, DONT_KILL_APP));
            setDefaultHome(mSessionHome);
        }

        @Override
        public void close() {
            runWithShellPermission(
                    () -> mPackageManager.setComponentEnabledSetting(mSessionHome,
                            COMPONENT_ENABLED_STATE_DISABLED, DONT_KILL_APP));
            if (mOrigHome != null) {
                setDefaultHome(mOrigHome);
            }
        }

        private void setDefaultHome(ComponentName componentName) {
            executeShellCommand(""cmd package set-home-activity --user ""
                    + android.os.Process.myUserHandle().getIdentifier() + "" ""
                    + componentName.flattenToString());
        }
    }

    public class LockScreenSession implements AutoCloseable {
        private static final boolean DEBUG = false;

        private final boolean mIsLockDisabled;
        private boolean mLockCredentialSet;
        private boolean mRemoveActivitiesOnClose;
        private AmbientDisplayConfiguration mAmbientDisplayConfiguration;

        public static final int FLAG_REMOVE_ACTIVITIES_ON_CLOSE = 1;

        public LockScreenSession() {
            this(0 /* flags */);
        }

        public LockScreenSession(int flags) {
            mIsLockDisabled = isLockDisabled();
            // Enable lock screen (swipe) by default.
            setLockDisabled(false);
            if ((flags & FLAG_REMOVE_ACTIVITIES_ON_CLOSE) != 0) {
                mRemoveActivitiesOnClose = true;
            }
            mAmbientDisplayConfiguration = new AmbientDisplayConfiguration(mContext);
        }

        public LockScreenSession setLockCredential() {
            mLockCredentialSet = true;
            runCommandAndPrintOutput(""locksettings set-pin "" + LOCK_CREDENTIAL);
            return this;
        }

        public LockScreenSession enterAndConfirmLockCredential() {
            // Ensure focus will switch to default display. Meanwhile we cannot tap on center area,
            // which may tap on input credential area.
            touchAndCancelOnDisplayCenterSync(DEFAULT_DISPLAY);

            waitForDeviceIdle(3000);
            SystemUtil.runWithShellPermissionIdentity(() ->
                    mInstrumentation.sendStringSync(LOCK_CREDENTIAL));
            pressEnterButton();
            return this;
        }

        LockScreenSession disableLockScreen() {
            setLockDisabled(true);
            return this;
        }

        public LockScreenSession sleepDevice() {
            pressSleepButton();
            // Not all device variants lock when we go to sleep, so we need to explicitly lock the
            // device. Note that pressSleepButton() above is redundant because the action also
            // puts the device to sleep, but kept around for clarity.
            if (isWatch()) {
                mInstrumentation.getUiAutomation().performGlobalAction(
                        AccessibilityService.GLOBAL_ACTION_LOCK_SCREEN);
            }
            if (mAmbientDisplayConfiguration.alwaysOnEnabled(
                    android.os.Process.myUserHandle().getIdentifier())) {
                mWmState.waitForAodShowing();
            } else {
                Condition.waitFor(""display to turn off"", () -> !isDisplayOn(DEFAULT_DISPLAY));
            }
            if(!isLockDisabled()) {
                mWmState.waitFor(state -> state.getKeyguardControllerState().keyguardShowing,
                        ""Keyguard showing"");
            }
            return this;
        }

        LockScreenSession wakeUpDevice() {
            pressWakeupButton();
            return this;
        }

        LockScreenSession unlockDevice() {
            // Make sure the unlock button event is send to the default display.
            touchAndCancelOnDisplayCenterSync(DEFAULT_DISPLAY);

            pressUnlockButton();
            return this;
        }

        public LockScreenSession gotoKeyguard(ComponentName... showWhenLockedActivities) {
            if (DEBUG && isLockDisabled()) {
                logE(""LockScreenSession.gotoKeyguard() is called without lock enabled."");
            }
            sleepDevice();
            wakeUpDevice();
            if (showWhenLockedActivities.length == 0) {
                mWmState.waitForKeyguardShowingAndNotOccluded();
            } else {
                mWmState.waitForValidState(showWhenLockedActivities);
            }
            return this;
        }

        @Override
        public void close() {
            if (mRemoveActivitiesOnClose) {
                removeRootTasksWithActivityTypes(ALL_ACTIVITY_TYPE_BUT_HOME);
            }

            setLockDisabled(mIsLockDisabled);
            final boolean wasCredentialSet = mLockCredentialSet;
            boolean wasDeviceLocked = false;
            if (mLockCredentialSet) {
                wasDeviceLocked = mKm != null && mKm.isDeviceLocked();
                removeLockCredential();
                mLockCredentialSet = false;
            }

            // Dismiss active keyguard after credential is cleared, so keyguard doesn't ask for
            // the stale credential.
            // TODO (b/112015010) If keyguard is occluded, credential cannot be removed as expected.
            // LockScreenSession#close is always called before stopping all test activities,
            // which could cause the keyguard to stay occluded after wakeup.
            // If Keyguard is occluded, pressing the back key can hide the ShowWhenLocked activity.
            pressBackButton();

            // If the credential wasn't set, the steps for restoring can be simpler.
            if (!wasCredentialSet) {
                mWmState.computeState();
                if (WindowManagerStateHelper.isKeyguardShowingAndNotOccluded(mWmState)) {
                    // Keyguard is showing and not occluded so only need to unlock.
                    unlockDevice();
                    return;
                }

                final ComponentName home = mWmState.getHomeActivityName();
                if (home != null && mWmState.hasActivityState(home, STATE_RESUMED)) {
                    // Home is resumed so nothing to do (e.g. after finishing show-when-locked app).
                    return;
                }
            }

            // If device is unlocked, there might have ShowWhenLocked activity runs on,
            // use home key to clear all activity at foreground.
            pressHomeButton();
            if (wasDeviceLocked) {
                // The removal of credential needs an extra cycle to take effect.
                sleepDevice();
                wakeUpDevice();
            }
            if (isKeyguardLocked()) {
                unlockDevice();
            }
        }

        /**
         * Returns whether the lock screen is disabled.
         *
         * @return true if the lock screen is disabled, false otherwise.
         */
        private boolean isLockDisabled() {
            final String isLockDisabled = runCommandAndPrintOutput(
                    ""locksettings get-disabled"").trim();
            return !""null"".equals(isLockDisabled) && Boolean.parseBoolean(isLockDisabled);
        }

        /**
         * Disable the lock screen.
         *
         * @param lockDisabled true if should disable, false otherwise.
         */
        protected void setLockDisabled(boolean lockDisabled) {
            runCommandAndPrintOutput(""locksettings set-disabled "" + lockDisabled);
        }
    }

    /** Helper class to set and restore appop mode ""android:system_alert_window"". */
    protected static class SystemAlertWindowAppOpSession implements AutoCloseable {
        private final String mPackageName;
        private final int mPreviousOpMode;

        SystemAlertWindowAppOpSession(String packageName, int mode) {
            mPackageName = packageName;
            try {
                mPreviousOpMode = AppOpsUtils.getOpMode(mPackageName, OPSTR_SYSTEM_ALERT_WINDOW);
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
            setOpMode(mode);
        }

        @Override
        public void close() {
            setOpMode(mPreviousOpMode);
        }

        void setOpMode(int mode) {
            try {
                AppOpsUtils.setOpMode(mPackageName, OPSTR_SYSTEM_ALERT_WINDOW, mode);
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
    }

    protected class AodSession extends SettingsSession<Integer> {
        private AmbientDisplayConfiguration mConfig;

        AodSession() {
            super(Settings.Secure.getUriFor(Settings.Secure.DOZE_ALWAYS_ON),
                    Settings.Secure::getInt,
                    Settings.Secure::putInt);
            mConfig = new AmbientDisplayConfiguration(mContext);
        }

        boolean isAodAvailable() {
            return mConfig.alwaysOnAvailable();
        }

        void setAodEnabled(boolean enabled) {
            set(enabled ? 1 : 0);
        }
    }

    protected class DevEnableNonResizableMultiWindowSession extends SettingsSession<Integer> {
        DevEnableNonResizableMultiWindowSession() {
            super(Settings.Global.getUriFor(
                    Settings.Global.DEVELOPMENT_ENABLE_NON_RESIZABLE_MULTI_WINDOW),
                    (cr, name) -> Settings.Global.getInt(cr, name, 0 /* def */),
                    Settings.Global::putInt);
        }
    }

    /** Helper class to save, set & wait, and restore rotation related preferences. */
    protected class RotationSession extends SettingsSession<Integer> {
        private final String FIXED_TO_USER_ROTATION_COMMAND =
                ""cmd window fixed-to-user-rotation "";
        private final SettingsSession<Integer> mAccelerometerRotation;
        private final HandlerThread mThread;
        private final Handler mRunnableHandler;
        private final SettingsObserver mRotationObserver;
        private int mPreviousDegree;
        private String mPreviousFixedToUserRotationMode;

        public RotationSession() {
            // Save user_rotation and accelerometer_rotation preferences.
            super(Settings.System.getUriFor(Settings.System.USER_ROTATION),
                    Settings.System::getInt, Settings.System::putInt);
            mAccelerometerRotation = new SettingsSession<>(
                    Settings.System.getUriFor(Settings.System.ACCELEROMETER_ROTATION),
                    Settings.System::getInt, Settings.System::putInt);

            mThread = new HandlerThread(""Observer_Thread"");
            mThread.start();
            mRunnableHandler = new Handler(mThread.getLooper());
            mRotationObserver = new SettingsObserver(mRunnableHandler);

            // Disable fixed to user rotation
            mPreviousFixedToUserRotationMode = executeShellCommand(FIXED_TO_USER_ROTATION_COMMAND);
            executeShellCommand(FIXED_TO_USER_ROTATION_COMMAND + ""disabled"");

            mPreviousDegree = get();
            // Disable accelerometer_rotation.
            mAccelerometerRotation.set(0);
        }

        @Override
        public void set(@NonNull Integer value) {
            set(value, true /* waitDeviceRotation */);
        }

        /**
         * Sets the rotation preference.
         *
         * @param value The rotation between {@link android.view.Surface#ROTATION_0} ~
         *              {@link android.view.Surface#ROTATION_270}
         * @param waitDeviceRotation If {@code true}, it will wait until the display has applied the
         *                           rotation. Otherwise it only waits for the settings value has
         *                           been changed.
         */
        public void set(@NonNull Integer value, boolean waitDeviceRotation) {
            // When the rotation is locked and the SystemUI receives the rotation becoming 0deg, it
            // will call freezeRotation to WMS, which will cause USER_ROTATION be set to zero again.
            // In order to prevent our test target from being overwritten by SystemUI during
            // rotation test, wait for the USER_ROTATION changed then continue testing.
            final boolean waitSystemUI = value == ROTATION_0 && mPreviousDegree != ROTATION_0;
            final boolean observeRotationSettings = waitSystemUI || !waitDeviceRotation;
            if (observeRotationSettings) {
                mRotationObserver.observe();
            }
            super.set(value);
            mPreviousDegree = value;

            if (waitSystemUI) {
                Condition.waitFor(new Condition<>(""rotation notified"",
                        // There will receive USER_ROTATION changed twice because when the device
                        // rotates to 0deg, RotationContextButton will also set ROTATION_0 again.
                        () -> mRotationObserver.count == 2).setRetryIntervalMs(500));
            }

            if (waitDeviceRotation) {
                // Wait for the display to apply the rotation.
                mWmState.waitForRotation(value);
            } else {
                // Wait for the settings have been changed.
                Condition.waitFor(new Condition<>(""rotation setting changed"",
                        () -> mRotationObserver.count > 0).setRetryIntervalMs(100));
            }

            if (observeRotationSettings) {
                mRotationObserver.stopObserver();
            }
        }

        @Override
        public void close() {
            // Restore fixed to user rotation to default
            executeShellCommand(FIXED_TO_USER_ROTATION_COMMAND + mPreviousFixedToUserRotationMode);
            mThread.quitSafely();
            super.close();
            // Restore accelerometer_rotation preference.
            mAccelerometerRotation.close();
        }

        private class SettingsObserver extends ContentObserver {
            int count;

            SettingsObserver(Handler handler) { super(handler); }

            void observe() {
                count = 0;
                final ContentResolver resolver = mContext.getContentResolver();
                resolver.registerContentObserver(Settings.System.getUriFor(
                        Settings.System.USER_ROTATION), false, this);
            }

            void stopObserver() {
                count = 0;
                final ContentResolver resolver = mContext.getContentResolver();
                resolver.unregisterContentObserver(this);
            }

            @Override
            public void onChange(boolean selfChange) {
                count++;
            }
        }
    }

    /** Helper class to save, set, and restore font_scale preferences. */
    protected static class FontScaleSession extends SettingsSession<Float> {
        FontScaleSession() {
            super(Settings.System.getUriFor(Settings.System.FONT_SCALE),
                    Settings.System::getFloat,
                    Settings.System::putFloat);
        }

        @Override
        public Float get() {
            Float value = super.get();
            return value == null ? 1f : value;
        }
    }

    /**
     * Returns whether the test device respects settings of locked user rotation mode.
     *
     * The method sets the locked user rotation settings to the rotation that rotates the display by
     * 180 degrees and checks if the actual display rotation changes after that.
     *
     * This is a necessary assumption check before leveraging user rotation mode to force display
     * rotation, because there is no requirement that an Android device that supports both
     * orientations needs to support user rotation mode.
     *
     * @param session   the rotation session used to set user rotation
     * @param displayId the display ID to check rotation against
     * @return {@code true} if test device respects settings of locked user rotation mode;
     * {@code false} if not.
     */
    protected boolean supportsLockedUserRotation(RotationSession session, int displayId) {
        final int origRotation = getDeviceRotation(displayId);
        // Use the same orientation as target rotation to avoid affect of app-requested orientation.
        final int targetRotation = (origRotation + 2) % 4;
        session.set(targetRotation);
        final boolean result = (getDeviceRotation(displayId) == targetRotation);
        session.set(origRotation);
        return result;
    }

    protected int getDeviceRotation(int displayId) {
        final String displays = runCommandAndPrintOutput(""dumpsys display displays"").trim();
        Pattern pattern = Pattern.compile(
                ""(mDisplayId="" + displayId + "")([\\s\\S]*?)(mOverrideDisplayInfo)(.*)""
                        + ""(rotation)(\\s+)(\\d+)"");
        Matcher matcher = pattern.matcher(displays);
        if (matcher.find()) {
            final String match = matcher.group(7);
            return Integer.parseInt(match);
        }

        return INVALID_DEVICE_ROTATION;
    }

    /**
     * Creates a {#link ActivitySessionClient} instance with instrumentation context. It is used
     * when the caller doen't need try-with-resource.
     */
    public static ActivitySessionClient createActivitySessionClient() {
        return new ActivitySessionClient(getInstrumentation().getContext());
    }

    /** Empties the test journal so the following events won't be mixed-up with previous records. */
    protected void separateTestJournal() {
        TestJournalContainer.start();
    }

    protected static String runCommandAndPrintOutput(String command) {
        final String output = executeShellCommand(command);
        log(output);
        return output;
    }

    protected static class LogSeparator {
        private final String mUniqueString;

        private LogSeparator() {
            mUniqueString = UUID.randomUUID().toString();
        }

        @Override
        public String toString() {
            return mUniqueString;
        }
    }

    /**
     * Inserts a log separator so we can always find the starting point from where to evaluate
     * following logs.
     *
     * @return Unique log separator.
     */
    protected LogSeparator separateLogs() {
        final LogSeparator logSeparator = new LogSeparator();
        executeShellCommand(""log -t "" + LOG_SEPARATOR + "" "" + logSeparator);
        EventLog.writeEvent(EVENT_LOG_SEPARATOR_TAG, logSeparator.mUniqueString);
        return logSeparator;
    }

    protected static String[] getDeviceLogsForComponents(
            LogSeparator logSeparator, String... logTags) {
        String filters = LOG_SEPARATOR + "":I "";
        for (String component : logTags) {
            filters += component + "":I "";
        }
        final String[] result = executeShellCommand(""logcat -v brief -d "" + filters + "" *:S"")
                .split(""\\n"");
        if (logSeparator == null) {
            return result;
        }

        // Make sure that we only check logs after the separator.
        int i = 0;
        boolean lookingForSeparator = true;
        while (i < result.length && lookingForSeparator) {
            if (result[i].contains(logSeparator.toString())) {
                lookingForSeparator = false;
            }
            i++;
        }
        final String[] filteredResult = new String[result.length - i];
        for (int curPos = 0; i < result.length; curPos++, i++) {
            filteredResult[curPos] = result[i];
        }
        return filteredResult;
    }

    protected static List<Event> getEventLogsForComponents(LogSeparator logSeparator, int... tags) {
        List<Event> events = new ArrayList<>();

        int[] searchTags = Arrays.copyOf(tags, tags.length + 1);
        searchTags[searchTags.length - 1] = EVENT_LOG_SEPARATOR_TAG;

        try {
            EventLog.readEvents(searchTags, events);
        } catch (IOException e) {
            fail(""Could not read from event log."" + e);
        }

        for (Iterator<Event> itr = events.iterator(); itr.hasNext(); ) {
            Event event = itr.next();
            itr.remove();
            if (event.getTag() == EVENT_LOG_SEPARATOR_TAG &&
                    logSeparator.mUniqueString.equals(event.getData())) {
                break;
            }
        }
        return events;
    }

    protected boolean supportsMultiDisplay() {
        return mContext.getPackageManager().hasSystemFeature(
                FEATURE_ACTIVITIES_ON_SECONDARY_DISPLAYS);
    }

    protected boolean supportsInstallableIme() {
        return mContext.getPackageManager().hasSystemFeature(FEATURE_INPUT_METHODS);
    }

    static class CountSpec<T> {
        static final int DONT_CARE = Integer.MIN_VALUE;
        static final int EQUALS = 1;
        static final int GREATER_THAN = 2;
        static final int LESS_THAN = 3;

        final T mEvent;
        final int mRule;
        final int mCount;
        final String mMessage;

        CountSpec(T event, int rule, int count, String message) {
            mEvent = event;
            mRule = count == DONT_CARE ? DONT_CARE : rule;
            mCount = count;
            if (message != null) {
                mMessage = message;
            } else {
                switch (rule) {
                    case EQUALS:
                        mMessage = event + "" must equal to "" + count;
                        break;
                    case GREATER_THAN:
                        mMessage = event + "" must be greater than "" + count;
                        break;
                    case LESS_THAN:
                        mMessage = event + "" must be less than "" + count;
                        break;
                    default:
                        mMessage = ""Don't care"";
                }
            }
        }

        /** @return {@code true} if the given value is satisfied the condition. */
        boolean validate(int value) {
            switch (mRule) {
                case DONT_CARE:
                    return true;
                case EQUALS:
                    return value == mCount;
                case GREATER_THAN:
                    return value > mCount;
                case LESS_THAN:
                    return value < mCount;
                default:
            }
            throw new RuntimeException(""Unknown CountSpec rule"");
        }
    }

    static <T> CountSpec<T> countSpec(T event, int rule, int count, String message) {
        return new CountSpec<>(event, rule, count, message);
    }

    static <T> CountSpec<T> countSpec(T event, int rule, int count) {
        return new CountSpec<>(event, rule, count, null /* message */);
    }

    static void assertLifecycleCounts(ComponentName activityName, String message,
            int createCount, int startCount, int resumeCount, int pauseCount, int stopCount,
            int destroyCount, int configChangeCount) {
        new ActivityLifecycleCounts(activityName).assertCountWithRetry(
                message,
                countSpec(ActivityCallback.ON_CREATE, CountSpec.EQUALS, createCount),
                countSpec(ActivityCallback.ON_START, CountSpec.EQUALS, startCount),
                countSpec(ActivityCallback.ON_RESUME, CountSpec.EQUALS, resumeCount),
                countSpec(ActivityCallback.ON_PAUSE, CountSpec.EQUALS, pauseCount),
                countSpec(ActivityCallback.ON_STOP, CountSpec.EQUALS, stopCount),
                countSpec(ActivityCallback.ON_DESTROY, CountSpec.EQUALS, destroyCount),
                countSpec(ActivityCallback.ON_CONFIGURATION_CHANGED, CountSpec.EQUALS,
                        configChangeCount));
    }

    static void assertLifecycleCounts(ComponentName activityName,
            int createCount, int startCount, int resumeCount, int pauseCount, int stopCount,
            int destroyCount, int configChangeCount) {
        assertLifecycleCounts(activityName, ""Assert lifecycle of "" + getLogTag(activityName),
                createCount, startCount, resumeCount, pauseCount, stopCount,
                destroyCount, configChangeCount);
    }

    static void assertSingleLaunch(ComponentName activityName) {
        assertLifecycleCounts(activityName,
                ""activity create, start, and resume"",
                1 /* createCount */, 1 /* startCount */, 1 /* resumeCount */,
                0 /* pauseCount */, 0 /* stopCount */, 0 /* destroyCount */,
                CountSpec.DONT_CARE /* configChangeCount */);
    }

    static void assertSingleLaunchAndStop(ComponentName activityName) {
        assertLifecycleCounts(activityName,
                ""activity create, start, resume, pause, and stop"",
                1 /* createCount */, 1 /* startCount */, 1 /* resumeCount */,
                1 /* pauseCount */, 1 /* stopCount */, 0 /* destroyCount */,
                CountSpec.DONT_CARE /* configChangeCount */);
    }

    static void assertSingleStartAndStop(ComponentName activityName) {
        assertLifecycleCounts(activityName,
                ""activity start, resume, pause, and stop"",
                0 /* createCount */, 1 /* startCount */, 1 /* resumeCount */,
                1 /* pauseCount */, 1 /* stopCount */, 0 /* destroyCount */,
                CountSpec.DONT_CARE /* configChangeCount */);
    }

    static void assertSingleStart(ComponentName activityName) {
        assertLifecycleCounts(activityName,
                ""activity start and resume"",
                0 /* createCount */, 1 /* startCount */, 1 /* resumeCount */,
                0 /* pauseCount */, 0 /* stopCount */, 0 /* destroyCount */,
                CountSpec.DONT_CARE /* configChangeCount */);
    }

    /** Assert the activity is either relaunched or received configuration changed. */
    static void assertActivityLifecycle(ComponentName activityName, boolean relaunched) {
        Condition.<String>waitForResult(
                activityName + (relaunched ? "" relaunched"" : "" config changed""),
                condition -> condition
                .setResultSupplier(() -> checkActivityIsRelaunchedOrConfigurationChanged(
                        getActivityName(activityName),
                        TestJournalContainer.get(activityName).callbacks, relaunched))
                .setResultValidator(failedReasons -> failedReasons == null)
                .setOnFailure(failedReasons -> fail(failedReasons)));
    }

    /** Assert the activity is either relaunched or received configuration changed. */
    static List<ActivityCallback> assertActivityLifecycle(ActivitySession activitySession,
            boolean relaunched) {
        final String name = activitySession.getName().flattenToShortString();
        final List<ActivityCallback> callbackHistory = activitySession.takeCallbackHistory();
        String failedReason = checkActivityIsRelaunchedOrConfigurationChanged(
                name, callbackHistory, relaunched);
        if (failedReason != null) {
            fail(failedReason);
        }
        return callbackHistory;
    }

    private static String checkActivityIsRelaunchedOrConfigurationChanged(String name,
            List<ActivityCallback> callbackHistory, boolean relaunched) {
        final ActivityLifecycleCounts lifecycles = new ActivityLifecycleCounts(callbackHistory);
        if (relaunched) {
            return lifecycles.validateCount(
                    countSpec(ActivityCallback.ON_DESTROY, CountSpec.GREATER_THAN, 0,
                            name + "" must have been destroyed.""),
                    countSpec(ActivityCallback.ON_CREATE, CountSpec.GREATER_THAN, 0,
                            name + "" must have been (re)created.""));
        }
        return lifecycles.validateCount(
                countSpec(ActivityCallback.ON_DESTROY, CountSpec.LESS_THAN, 1,
                        name + "" must *NOT* have been destroyed.""),
                countSpec(ActivityCallback.ON_CREATE, CountSpec.LESS_THAN, 1,
                        name + "" must *NOT* have been (re)created.""),
                countSpec(ActivityCallback.ON_CONFIGURATION_CHANGED, CountSpec.GREATER_THAN, 0,
                                name + "" must have received configuration changed.""));
    }

    static void assertRelaunchOrConfigChanged(ComponentName activityName, int numRelaunch,
            int numConfigChange) {
        new ActivityLifecycleCounts(activityName).assertCountWithRetry(""relaunch or config changed"",
                countSpec(ActivityCallback.ON_DESTROY, CountSpec.EQUALS, numRelaunch),
                countSpec(ActivityCallback.ON_CREATE, CountSpec.EQUALS, numRelaunch),
                countSpec(ActivityCallback.ON_CONFIGURATION_CHANGED, CountSpec.EQUALS,
                        numConfigChange));
    }

    static void assertActivityDestroyed(ComponentName activityName) {
        new ActivityLifecycleCounts(activityName).assertCountWithRetry(""activity destroyed"",
                countSpec(ActivityCallback.ON_DESTROY, CountSpec.EQUALS, 1),
                countSpec(ActivityCallback.ON_CREATE, CountSpec.EQUALS, 0),
                countSpec(ActivityCallback.ON_CONFIGURATION_CHANGED, CountSpec.EQUALS, 0));
    }

    static void assertSecurityExceptionFromActivityLauncher() {
        waitForOrFail(""SecurityException from "" + ActivityLauncher.TAG,
                ActivityLauncher::hasCaughtSecurityException);
    }

    private static final Pattern sCurrentUiModePattern = Pattern.compile(""mCurUiMode=0x(\\d+)"");
    private static final Pattern sUiModeLockedPattern =
            Pattern.compile(""mUiModeLocked=(true|false)"");

    @NonNull
    SizeInfo getLastReportedSizesForActivity(ComponentName activityName) {
        return Condition.waitForResult(""sizes of "" + activityName + "" to be reported"",
                condition -> condition.setResultSupplier(() -> {
                    final ConfigInfo info = TestJournalContainer.get(activityName).lastConfigInfo;
                    return info != null ? info.sizeInfo : null;
                }).setResultValidator(Objects::nonNull).setOnFailure(unusedResult ->
                        fail(""No config reported from "" + activityName)));
    }

    /** Check if a device has display cutout. */
    boolean hasDisplayCutout() {
        // Launch an activity to report cutout state
        separateTestJournal();
        launchActivity(BROADCAST_RECEIVER_ACTIVITY);

        // Read the logs to check if cutout is present
        final Boolean displayCutoutPresent = getCutoutStateForActivity(BROADCAST_RECEIVER_ACTIVITY);
        assertNotNull(""The activity should report cutout state"", displayCutoutPresent);

        // Finish activity
        mBroadcastActionTrigger.finishBroadcastReceiverActivity();
        mWmState.waitForWithAmState(
                (state) -> !state.containsActivity(BROADCAST_RECEIVER_ACTIVITY),
                ""activity to be removed"");

        return displayCutoutPresent;
    }

    /**
     * Wait for activity to report cutout state in logs and return it. Will return {@code null}
     * after timeout.
     */
    @Nullable
    private Boolean getCutoutStateForActivity(ComponentName activityName) {
        return Condition.waitForResult(""cutout state to be reported"", condition -> condition
                .setResultSupplier(() -> {
                    final Bundle extras = TestJournalContainer.get(activityName).extras;
                    return extras.containsKey(EXTRA_CUTOUT_EXISTS)
                            ? extras.getBoolean(EXTRA_CUTOUT_EXISTS)
                            : null;
                }).setResultValidator(cutoutExists -> cutoutExists != null));
    }

    /** Waits for at least one onMultiWindowModeChanged event. */
    ActivityLifecycleCounts waitForOnMultiWindowModeChanged(ComponentName activityName) {
        final ActivityLifecycleCounts counts = new ActivityLifecycleCounts(activityName);
        Condition.waitFor(counts.countWithRetry(""waitForOnMultiWindowModeChanged"", countSpec(
                ActivityCallback.ON_MULTI_WINDOW_MODE_CHANGED, CountSpec.GREATER_THAN, 0)));
        return counts;
    }

    WindowState getPackageWindowState(String packageName) {
        final WindowManagerState.WindowState window =
                mWmState.getWindowByPackageName(packageName, TYPE_BASE_APPLICATION);
        assertNotNull(window);
        return window;
    }

    static class ActivityLifecycleCounts {
        private final int[] mCounts = new int[ActivityCallback.SIZE];
        private final int[] mFirstIndexes = new int[ActivityCallback.SIZE];
        private final int[] mLastIndexes = new int[ActivityCallback.SIZE];
        private ComponentName mActivityName;

        ActivityLifecycleCounts(ComponentName componentName) {
            mActivityName = componentName;
            updateCount(TestJournalContainer.get(componentName).callbacks);
        }

        ActivityLifecycleCounts(List<ActivityCallback> callbacks) {
            updateCount(callbacks);
        }

        private void updateCount(List<ActivityCallback> callbacks) {
            // The callback list could be from the reference of TestJournal. If we are counting for
            // retrying, there may be new data added to the list from other threads.
            TestJournalContainer.withThreadSafeAccess(() -> {
                Arrays.fill(mFirstIndexes, -1);
                for (int i = 0; i < callbacks.size(); i++) {
                    final ActivityCallback callback = callbacks.get(i);
                    final int ordinal = callback.ordinal();
                    mCounts[ordinal]++;
                    mLastIndexes[ordinal] = i;
                    if (mFirstIndexes[ordinal] == -1) {
                        mFirstIndexes[ordinal] = i;
                    }
                }
            });
        }

        int getCount(ActivityCallback callback) {
            return mCounts[callback.ordinal()];
        }

        int getFirstIndex(ActivityCallback callback) {
            return mFirstIndexes[callback.ordinal()];
        }

        int getLastIndex(ActivityCallback callback) {
            return mLastIndexes[callback.ordinal()];
        }

        @SafeVarargs
        final Condition<String> countWithRetry(String message,
                CountSpec<ActivityCallback>... countSpecs) {
            if (mActivityName == null) {
                throw new IllegalStateException(
                        ""It is meaningless to retry without specified activity"");
            }
            return new Condition<String>(message)
                    .setOnRetry(() -> {
                        Arrays.fill(mCounts, 0);
                        Arrays.fill(mLastIndexes, 0);
                        updateCount(TestJournalContainer.get(mActivityName).callbacks);
                    })
                    .setResultSupplier(() -> validateCount(countSpecs))
                    .setResultValidator(failedReasons -> failedReasons == null);
        }

        @SafeVarargs
        final void assertCountWithRetry(String message, CountSpec<ActivityCallback>... countSpecs) {
            if (mActivityName == null) {
                throw new IllegalStateException(
                        ""It is meaningless to retry without specified activity"");
            }
            Condition.<String>waitForResult(countWithRetry(message, countSpecs)
                    .setOnFailure(failedReasons -> fail(message + "": "" + failedReasons)));
        }

        @SafeVarargs
        final String validateCount(CountSpec<ActivityCallback>... countSpecs) {
            ArrayList<String> failedReasons = null;
            for (CountSpec<ActivityCallback> spec : countSpecs) {
                final int realCount = mCounts[spec.mEvent.ordinal()];
                if (!spec.validate(realCount)) {
                    if (failedReasons == null) {
                        failedReasons = new ArrayList<>();
                    }
                    failedReasons.add(spec.mMessage + "" (got "" + realCount + "")"");
                }
            }
            return failedReasons == null ? null : String.join(""\n"", failedReasons);
        }
    }

    protected void stopTestPackage(final String packageName) {
        runWithShellPermission(() -> mAm.forceStopPackage(packageName));
    }

    protected LaunchActivityBuilder getLaunchActivityBuilder() {
        return new LaunchActivityBuilder(mWmState);
    }

    public static <T extends Activity>
    ActivityScenarioRule<T> createFullscreenActivityScenarioRule(Class<T> clazz) {
        final ActivityOptions options = ActivityOptions.makeBasic();
        options.setLaunchWindowingMode(WindowConfiguration.WINDOWING_MODE_FULLSCREEN);
        return new ActivityScenarioRule<>(clazz, options.toBundle());
    }

    protected static class LaunchActivityBuilder implements LaunchProxy {
        private final WindowManagerStateHelper mAmWmState;

        // The activity to be launched
        private ComponentName mTargetActivity = TEST_ACTIVITY;
        private boolean mUseApplicationContext;
        private boolean mToSide;
        private boolean mRandomData;
        private boolean mNewTask;
        private boolean mMultipleTask;
        private boolean mAllowMultipleInstances = true;
        private boolean mLaunchTaskBehind;
        private boolean mFinishBeforeLaunch;
        private int mDisplayId = INVALID_DISPLAY;
        private int mWindowingMode = -1;
        private int mActivityType = ACTIVITY_TYPE_UNDEFINED;
        // A proxy activity that launches other activities including mTargetActivityName
        private ComponentName mLaunchingActivity = LAUNCHING_ACTIVITY;
        private boolean mReorderToFront;
        private boolean mWaitForLaunched;
        private boolean mSuppressExceptions;
        private boolean mWithShellPermission;
        // Use of the following variables indicates that a broadcast receiver should be used instead
        // of a launching activity;
        private ComponentName mBroadcastReceiver;
        private String mBroadcastReceiverAction;
        private int mIntentFlags;
        private Bundle mExtras;
        private LaunchInjector mLaunchInjector;
        private ActivitySessionClient mActivitySessionClient;

        private enum LauncherType {
            INSTRUMENTATION, LAUNCHING_ACTIVITY, BROADCAST_RECEIVER
        }

        private LauncherType mLauncherType = LauncherType.LAUNCHING_ACTIVITY;

        public LaunchActivityBuilder(WindowManagerStateHelper amWmState) {
            mAmWmState = amWmState;
            mWaitForLaunched = true;
            mWithShellPermission = true;
        }

        public LaunchActivityBuilder setToSide(boolean toSide) {
            mToSide = toSide;
            return this;
        }

        public LaunchActivityBuilder setRandomData(boolean randomData) {
            mRandomData = randomData;
            return this;
        }

        public LaunchActivityBuilder setNewTask(boolean newTask) {
            mNewTask = newTask;
            return this;
        }

        public LaunchActivityBuilder setMultipleTask(boolean multipleTask) {
            mMultipleTask = multipleTask;
            return this;
        }

        public LaunchActivityBuilder allowMultipleInstances(boolean allowMultipleInstances) {
            mAllowMultipleInstances = allowMultipleInstances;
            return this;
        }

        public LaunchActivityBuilder setLaunchTaskBehind(boolean launchTaskBehind) {
            mLaunchTaskBehind = launchTaskBehind;
            return this;
        }

        public LaunchActivityBuilder setReorderToFront(boolean reorderToFront) {
            mReorderToFront = reorderToFront;
            return this;
        }

        public LaunchActivityBuilder setUseApplicationContext(boolean useApplicationContext) {
            mUseApplicationContext = useApplicationContext;
            return this;
        }

        public LaunchActivityBuilder setFinishBeforeLaunch(boolean finishBeforeLaunch) {
            mFinishBeforeLaunch = finishBeforeLaunch;
            return this;
        }

        public ComponentName getTargetActivity() {
            return mTargetActivity;
        }

        public boolean isTargetActivityTranslucent() {
            return mAmWmState.isActivityTranslucent(mTargetActivity);
        }

        public LaunchActivityBuilder setTargetActivity(ComponentName targetActivity) {
            mTargetActivity = targetActivity;
            return this;
        }

        public LaunchActivityBuilder setDisplayId(int id) {
            mDisplayId = id;
            return this;
        }

        public LaunchActivityBuilder setWindowingMode(int windowingMode) {
            mWindowingMode = windowingMode;
            return this;
        }

        public LaunchActivityBuilder setActivityType(int type) {
            mActivityType = type;
            return this;
        }

        public LaunchActivityBuilder setLaunchingActivity(ComponentName launchingActivity) {
            mLaunchingActivity = launchingActivity;
            mLauncherType = LauncherType.LAUNCHING_ACTIVITY;
            return this;
        }

        public LaunchActivityBuilder setWaitForLaunched(boolean shouldWait) {
            mWaitForLaunched = shouldWait;
            return this;
        }

        /** Use broadcast receiver as a launchpad for activities. */
        public LaunchActivityBuilder setUseBroadcastReceiver(final ComponentName broadcastReceiver,
                final String broadcastAction) {
            mBroadcastReceiver = broadcastReceiver;
            mBroadcastReceiverAction = broadcastAction;
            mLauncherType = LauncherType.BROADCAST_RECEIVER;
            return this;
        }

        /** Use {@link android.app.Instrumentation} as a launchpad for activities. */
        public LaunchActivityBuilder setUseInstrumentation() {
            mLauncherType = LauncherType.INSTRUMENTATION;
            // Calling startActivity() from outside of an Activity context requires the
            // FLAG_ACTIVITY_NEW_TASK flag.
            setNewTask(true);
            return this;
        }

        public LaunchActivityBuilder setSuppressExceptions(boolean suppress) {
            mSuppressExceptions = suppress;
            return this;
        }

        public LaunchActivityBuilder setWithShellPermission(boolean withShellPermission) {
            mWithShellPermission = withShellPermission;
            return this;
        }

        public LaunchActivityBuilder setActivitySessionClient(ActivitySessionClient sessionClient) {
            mActivitySessionClient = sessionClient;
            return this;
        }

        @Override
        public boolean shouldWaitForLaunched() {
            return mWaitForLaunched;
        }

        public LaunchActivityBuilder setIntentFlags(int flags) {
            mIntentFlags = flags;
            return this;
        }

        public LaunchActivityBuilder setIntentExtra(Consumer<Bundle> extrasConsumer) {
            if (extrasConsumer != null) {
                mExtras = new Bundle();
                extrasConsumer.accept(mExtras);
            }
            return this;
        }

        @Override
        public Bundle getExtras() {
            return mExtras;
        }

        @Override
        public void setLaunchInjector(LaunchInjector injector) {
            mLaunchInjector = injector;
        }

        @Override
        public void execute() {
            if (mActivitySessionClient != null) {
                final ActivitySessionClient client = mActivitySessionClient;
                // Clear the session client so its startActivity can call the real execute().
                mActivitySessionClient = null;
                client.startActivity(this);
                return;
            }
            switch (mLauncherType) {
                case INSTRUMENTATION:
                    if (mWithShellPermission) {
                        NestedShellPermission.run(this::launchUsingInstrumentation);
                    } else {
                        launchUsingInstrumentation();
                    }
                    break;
                case LAUNCHING_ACTIVITY:
                case BROADCAST_RECEIVER:
                    launchUsingShellCommand();
            }

            if (mWaitForLaunched) {
                mAmWmState.waitForValidState(mTargetActivity);
            }
        }

        /** Launch an activity using instrumentation. */
        private void launchUsingInstrumentation() {
            final Bundle b = new Bundle();
            b.putBoolean(KEY_LAUNCH_ACTIVITY, true);
            b.putBoolean(KEY_LAUNCH_TO_SIDE, mToSide);
            b.putBoolean(KEY_RANDOM_DATA, mRandomData);
            b.putBoolean(KEY_NEW_TASK, mNewTask);
            b.putBoolean(KEY_MULTIPLE_TASK, mMultipleTask);
            b.putBoolean(KEY_MULTIPLE_INSTANCES, mAllowMultipleInstances);
            b.putBoolean(KEY_LAUNCH_TASK_BEHIND, mLaunchTaskBehind);
            b.putBoolean(KEY_REORDER_TO_FRONT, mReorderToFront);
            b.putInt(KEY_DISPLAY_ID, mDisplayId);
            b.putInt(KEY_WINDOWING_MODE, mWindowingMode);
            b.putInt(KEY_ACTIVITY_TYPE, mActivityType);
            b.putBoolean(KEY_USE_APPLICATION_CONTEXT, mUseApplicationContext);
            b.putString(KEY_TARGET_COMPONENT, getActivityName(mTargetActivity));
            b.putBoolean(KEY_SUPPRESS_EXCEPTIONS, mSuppressExceptions);
            b.putInt(KEY_INTENT_FLAGS, mIntentFlags);
            b.putBundle(KEY_INTENT_EXTRAS, getExtras());
            final Context context = getInstrumentation().getContext();
            launchActivityFromExtras(context, b, mLaunchInjector);
        }

        /** Build and execute a shell command to launch an activity. */
        private void launchUsingShellCommand() {
            StringBuilder commandBuilder = new StringBuilder();
            if (mBroadcastReceiver != null && mBroadcastReceiverAction != null) {
                // Use broadcast receiver to launch the target.
                commandBuilder.append(""am broadcast -a "").append(mBroadcastReceiverAction)
                        .append("" -p "").append(mBroadcastReceiver.getPackageName())
                        // Include stopped packages
                        .append("" -f 0x00000020"");
            } else {
                // If new task flag isn't set the windowing mode of launcher activity will be the
                // windowing mode of the target activity, so we need to launch launcher activity in
                // it.
                String amStartCmd =
                        (mWindowingMode == -1 || mNewTask)
                                ? getAmStartCmd(mLaunchingActivity)
                                : getAmStartCmd(mLaunchingActivity, mWindowingMode);
                // Use launching activity to launch the target.
                commandBuilder.append(amStartCmd)
                        .append("" -f 0x20000020"");
            }

            // Add a flag to ensure we actually mean to launch an activity.
            commandBuilder.append("" --ez "" + KEY_LAUNCH_ACTIVITY + "" true"");

            if (mToSide) {
                commandBuilder.append("" --ez "" + KEY_LAUNCH_TO_SIDE + "" true"");
            }
            if (mRandomData) {
                commandBuilder.append("" --ez "" + KEY_RANDOM_DATA + "" true"");
            }
            if (mNewTask) {
                commandBuilder.append("" --ez "" + KEY_NEW_TASK + "" true"");
            }
            if (mMultipleTask) {
                commandBuilder.append("" --ez "" + KEY_MULTIPLE_TASK + "" true"");
            }
            if (mAllowMultipleInstances) {
                commandBuilder.append("" --ez "" + KEY_MULTIPLE_INSTANCES + "" true"");
            }
            if (mReorderToFront) {
                commandBuilder.append("" --ez "" + KEY_REORDER_TO_FRONT + "" true"");
            }
            if (mFinishBeforeLaunch) {
                commandBuilder.append("" --ez "" + KEY_FINISH_BEFORE_LAUNCH + "" true"");
            }
            if (mDisplayId != INVALID_DISPLAY) {
                commandBuilder.append("" --ei "" + KEY_DISPLAY_ID + "" "").append(mDisplayId);
            }
            if (mWindowingMode != -1) {
                commandBuilder.append("" --ei "" + KEY_WINDOWING_MODE + "" "").append(mWindowingMode);
            }
            if (mActivityType != ACTIVITY_TYPE_UNDEFINED) {
                commandBuilder.append("" --ei "" + KEY_ACTIVITY_TYPE + "" "").append(mActivityType);
            }

            if (mUseApplicationContext) {
                commandBuilder.append("" --ez "" + KEY_USE_APPLICATION_CONTEXT + "" true"");
            }

            if (mTargetActivity != null) {
                // {@link ActivityLauncher} parses this extra string by
                // {@link ComponentName#unflattenFromString(String)}.
                commandBuilder.append("" --es "" + KEY_TARGET_COMPONENT + "" "")
                        .append(getActivityName(mTargetActivity));
            }

            if (mSuppressExceptions) {
                commandBuilder.append("" --ez "" + KEY_SUPPRESS_EXCEPTIONS + "" true"");
            }

            if (mIntentFlags != 0) {
                commandBuilder.append("" --ei "" + KEY_INTENT_FLAGS + "" "").append(mIntentFlags);
            }

            if (mLaunchInjector != null) {
                commandBuilder.append("" --ez "" + KEY_FORWARD + "" true"");
                mLaunchInjector.setupShellCommand(commandBuilder);
            }
            executeShellCommand(commandBuilder.toString());
        }
    }

    /**
     * The actions which wraps a test method. It is used to set necessary rules that cannot be
     * overridden by subclasses. It executes in the outer scope of {@link Before} and {@link After}.
     */
    protected class WrapperRule implements TestRule {
        private final Runnable mBefore;
        private final Runnable mAfter;

        protected WrapperRule(Runnable before, Runnable after) {
            mBefore = before;
            mAfter = after;
        }

        @Override
        public Statement apply(final Statement base, final Description description) {
            return new Statement() {
                @Override
                public void evaluate()  {
                    if (mBefore != null) {
                        mBefore.run();
                    }
                    try {
                        base.evaluate();
                    } catch (Throwable e) {
                        mPostAssertionRule.addError(e);
                    } finally {
                        if (mAfter != null) {
                            mAfter.run();
                        }
                    }
                }
            };
        }
    }

    /**
     * The post assertion to ensure all test methods don't violate the generic rule. It is also used
     * to collect multiple errors.
     */
    private class PostAssertionRule extends ErrorCollector {
        private Throwable mLastError;

        @Override
        protected void verify() throws Throwable {
            if (mLastError != null) {
                // Try to recover the bad state of device to avoid subsequent test failures.
                if (isKeyguardLocked()) {
                    mLastError.addSuppressed(new IllegalStateException(""Keyguard is locked""));
                    // To clear the credential immediately, the screen need to be turned on.
                    pressWakeupButton();
                    removeLockCredential();
                    // Off/on to refresh the keyguard state.
                    pressSleepButton();
                    pressWakeupButton();
                    pressUnlockButton();
                }
                final String overlayDisplaySettings = Settings.Global.getString(
                        mContext.getContentResolver(), Settings.Global.OVERLAY_DISPLAY_DEVICES);
                if (overlayDisplaySettings != null && overlayDisplaySettings.length() > 0) {
                    mLastError.addSuppressed(new IllegalStateException(
                            ""Overlay display is found: "" + overlayDisplaySettings));
                    // Remove the overlay display because it may obscure the screen and causes the
                    // next tests to fail.
                    SettingsSession.delete(Settings.Global.getUriFor(
                            Settings.Global.OVERLAY_DISPLAY_DEVICES));
                }
            }
            if (!sIllegalTaskStateFound) {
                // Skip if a illegal task state was already found in previous test, or all tests
                // afterward could also fail and fire unnecessary false alarms.
                try {
                    mWmState.assertIllegalTaskState();
                } catch (Throwable t) {
                    sIllegalTaskStateFound = true;
                    addError(t);
                }
            }
            super.verify();
        }

        @Override
        public void addError(Throwable error) {
            super.addError(error);
            logE(""addError: "" + error);
            mLastError = error;
        }
    }

    /** Activity that can handle all config changes. */
    public static class ConfigChangeHandlingActivity extends CommandSession.BasicTestActivity {
    }
}"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.mediadrm.cts.NativeMediaDrmClearkeyTest"	"isWatchDevice"	"CtsMediaDrmTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/mediadrm/src/android/mediadrm/cts/NativeMediaDrmClearkeyTest.java"	""	"public void test/*
 *.
 */
package android.mediadrm.cts;

import android.content.pm.PackageManager;
import android.media.MediaDrm;
import android.media.cts.ConnectionStatus;
import android.media.cts.IConnectionStatus;
import android.media.cts.MediaCodecBlockModelHelper;
import android.net.Uri;
import android.platform.test.annotations.AppModeFull;
import android.util.Log;
import android.view.Surface;

import com.android.compatibility.common.util.ApiLevelUtil;
import com.android.compatibility.common.util.MediaUtils;
import com.google.android.collect.Lists;

import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.UUID;

import static org.junit.Assert.assertThat;
import static org.junit.matchers.JUnitMatchers.containsString;

/**
 * Tests MediaDrm NDK APIs. ClearKey system uses a subset of NDK APIs,
 * this test only tests the APIs that are supported by ClearKey system.
 */
@AppModeFull(reason = ""TODO: evaluate and port to instant"")
public class NativeMediaDrmClearkeyTest extends MediaPlayerTestBase {
    private static final String TAG = NativeMediaDrmClearkeyTest.class.getSimpleName();

    private static final int CONNECTION_RETRIES = 10;
    private static final int VIDEO_WIDTH_CENC = 1280;
    private static final int VIDEO_HEIGHT_CENC = 720;
    private static final String ISO_BMFF_VIDEO_MIME_TYPE = ""video/avc"";
    private static final String ISO_BMFF_AUDIO_MIME_TYPE = ""audio/avc"";
    private static final String CENC_AUDIO_PATH =
            ""/clear/h264/llama/llama_aac_audio.mp4"";

    private static final String CENC_CLEARKEY_VIDEO_PATH =
            ""/clearkey/llama_h264_main_720p_8000.mp4"";

    private static final int UUID_BYTE_SIZE = 16;
    private static final UUID COMMON_PSSH_SCHEME_UUID =
            new UUID(0x1077efecc0b24d02L, 0xace33c1e52e2fb4bL);
    private static final UUID CLEARKEY_SCHEME_UUID =
            new UUID(0xe2719d58a985b3c9L, 0x781ab030af78d30eL);
    private static final UUID BAD_SCHEME_UUID =
            new UUID(0xffffffffffffffffL, 0xffffffffffffffffL);

    static {
        try {
            System.loadLibrary(""mediadrm_jni"");
        } catch (UnsatisfiedLinkError e) {
            Log.e(TAG, ""NativeMediaDrmClearkeyTest: Error loading JNI library"");
            e.printStackTrace();
        }
        try {
            System.loadLibrary(""mediandk"");
        } catch (UnsatisfiedLinkError e) {
            Log.e(TAG, ""NativeMediaDrmClearkeyTest: Error loading JNI library"");
            e.printStackTrace();
        }
    }

    public static class PlaybackParams {
        public Surface surface;
        public String mimeType;
        public String audioUrl;
        public String videoUrl;
    }

    protected void setUp() throws Exception {
        super.setUp();
        if (false == deviceHasMediaDrm()) {
            tearDown();
        }
    }

    protected void tearDown() throws Exception {
        super.tearDown();
    }

    private boolean watchHasNoClearkeySupport() {
        if (!MediaDrm.isCryptoSchemeSupported(CLEARKEY_SCHEME_UUID)) {
            if (isWatchDevice()) {
                return true;
            } else {
                throw new Error(""Crypto scheme is not supported"");
            }
        }
        return false;
    }

    private boolean isWatchDevice() {
        return mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WATCH);
    }

    private boolean deviceHasMediaDrm() {
        // ClearKey is introduced after KitKat.
        if (ApiLevelUtil.isAtMost(android.os.Build.VERSION_CODES.KITKAT)) {
            return false;
        }
        return true;
    }

    private static final byte[] uuidByteArray(UUID uuid) {
        ByteBuffer buffer = ByteBuffer.wrap(new byte[UUID_BYTE_SIZE]);
        buffer.putLong(uuid.getMostSignificantBits());
        buffer.putLong(uuid.getLeastSignificantBits());
        return buffer.array();
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.widget.cts.ExpandableListTester"	"getExpandableListAdapter"	"CtsWidgetTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/ExpandableListTester.java"	""	"public void test/*
 *.
 */

package android.widget.cts;

import android.app.Instrumentation;
import android.view.KeyEvent;
import android.view.View;
import android.widget.ExpandableListAdapter;
import android.widget.ExpandableListView;
import android.widget.cts.util.ListUtil;

import androidx.test.InstrumentationRegistry;
import androidx.test.rule.ActivityTestRule;

import com.android.compatibility.common.util.CtsKeyEventUtil;
import com.android.compatibility.common.util.WidgetTestUtils;

import junit.framework.Assert;

public class ExpandableListTester {
    private final ActivityTestRule<?> mActivityTestRule;
    private final ExpandableListView mExpandableListView;
    private final ExpandableListAdapter mAdapter;
    private final ListUtil mListUtil;
    private final Instrumentation mInstrumentation;

    public ExpandableListTester(ActivityTestRule<?> activityTestRule,
            ExpandableListView expandableListView) {
        mActivityTestRule = activityTestRule;
        mExpandableListView = expandableListView;
        mInstrumentation = InstrumentationRegistry.getInstrumentation();
        mListUtil = new ListUtil(mExpandableListView, mInstrumentation);
        mAdapter = mExpandableListView.getExpandableListAdapter();
    }

    private void expandGroup(final int groupIndex, int flatPosition) {
        Assert.assertFalse(""Group is already expanded"", mExpandableListView
                .isGroupExpanded(groupIndex));

        // The following injects key events to emulate the sequence of expanding the group,
        // each waiting for a redraw pass to complete. Note that we can't inject key events on
        // the main thread, which is why we're passing null as the last parameter to the draw sync
        mListUtil.arrowScrollToSelectedPosition(flatPosition);
        WidgetTestUtils.runOnMainAndDrawSync(mActivityTestRule, mExpandableListView, null);
        CtsKeyEventUtil.sendKeys(mInstrumentation, mExpandableListView,
                KeyEvent.KEYCODE_DPAD_CENTER);
        WidgetTestUtils.runOnMainAndDrawSync(mActivityTestRule, mExpandableListView, null);

        Assert.assertTrue(""Group did not expand "" + groupIndex,
                mExpandableListView.isGroupExpanded(groupIndex));
    }

    void testContextMenus() {
        // Add a position tester ContextMenu listener to the ExpandableListView
        PositionTesterContextMenuListener menuListener = new PositionTesterContextMenuListener();
        mExpandableListView.setOnCreateContextMenuListener(menuListener);

        int index = 0;

        // Scrolling on header elements should trigger an AdapterContextMenu
        for (int i=0; i<mExpandableListView.getHeaderViewsCount(); i++) {
            // Check group index in context menu
            menuListener.expectAdapterContextMenu(i);
            // Make sure the group is visible so that getChild finds it
            mListUtil.arrowScrollToSelectedPosition(index);
            View headerChild = mExpandableListView.getChildAt(index
                    - mExpandableListView.getFirstVisiblePosition());
            WidgetTestUtils.runOnMainAndDrawSync(mActivityTestRule, mExpandableListView,
                    () -> mExpandableListView.showContextMenuForChild(headerChild));
            Assert.assertNull(menuListener.getErrorMessage(), menuListener.getErrorMessage());
            index++;
        }

        int groupCount = mAdapter.getGroupCount();
        for (int groupIndex = 0; groupIndex < groupCount; groupIndex++) {

            // Expand group
            expandGroup(groupIndex, index);

            // Check group index in context menu
            menuListener.expectGroupContextMenu(groupIndex);
            // Make sure the group is visible so that getChild finds it
            mListUtil.arrowScrollToSelectedPosition(index);
            View groupChild = mExpandableListView.getChildAt(index
                    - mExpandableListView.getFirstVisiblePosition());
            WidgetTestUtils.runOnMainAndDrawSync(mActivityTestRule, mExpandableListView,
                    () -> mExpandableListView.showContextMenuForChild(groupChild));
            Assert.assertNull(menuListener.getErrorMessage(), menuListener.getErrorMessage());
            index++;

            final int childrenCount = mAdapter.getChildrenCount(groupIndex);
            for (int childIndex = 0; childIndex < childrenCount; childIndex++) {
                // Check child index in context menu
                mListUtil.arrowScrollToSelectedPosition(index);
                menuListener.expectChildContextMenu(groupIndex, childIndex);
                View child = mExpandableListView.getChildAt(index
                        - mExpandableListView.getFirstVisiblePosition());
                WidgetTestUtils.runOnMainAndDrawSync(mActivityTestRule, mExpandableListView,
                        () -> mExpandableListView.showContextMenuForChild(child));
                Assert.assertNull(menuListener.getErrorMessage(), menuListener.getErrorMessage());
                index++;
            }
        }

        // Scrolling on footer elements should trigger an AdapterContextMenu
        for (int i=0; i<mExpandableListView.getFooterViewsCount(); i++) {
            // Check group index in context menu
            menuListener.expectAdapterContextMenu(index);
            // Make sure the group is visible so that getChild finds it
            mListUtil.arrowScrollToSelectedPosition(index);
            View footerChild = mExpandableListView.getChildAt(index
                    - mExpandableListView.getFirstVisiblePosition());
            WidgetTestUtils.runOnMainAndDrawSync(mActivityTestRule, mExpandableListView,
                    () -> mExpandableListView.showContextMenuForChild(footerChild));
            Assert.assertNull(menuListener.getErrorMessage(), menuListener.getErrorMessage());
            index++;
        }

        // Cleanup: remove the listener we added.
        mExpandableListView.setOnCreateContextMenuListener(null);
    }

    private int expandAGroup() {
        final int groupIndex = 2;
        final int headerCount = mExpandableListView.getHeaderViewsCount();
        Assert.assertTrue(""Not enough groups"", groupIndex < mAdapter.getGroupCount());
        expandGroup(groupIndex, groupIndex + headerCount);
        return groupIndex;
    }

    // This method assumes that NO group is expanded when called
    void testConversionBetweenFlatAndPackedOnGroups() {
        final int headerCount = mExpandableListView.getHeaderViewsCount();

        for (int i=0; i<headerCount; i++) {
            Assert.assertEquals(""Non NULL position for header item"",
                    ExpandableListView.PACKED_POSITION_VALUE_NULL,
                    mExpandableListView.getExpandableListPosition(i));
        }

        // Test all (non expanded) groups
        final int groupCount = mAdapter.getGroupCount();
        for (int groupIndex = 0; groupIndex < groupCount; groupIndex++) {
            int expectedFlatPosition = headerCount + groupIndex;
            long packedPositionForGroup = ExpandableListView.getPackedPositionForGroup(groupIndex);
            Assert.assertEquals(""Group not found at flat position "" + expectedFlatPosition,
                    packedPositionForGroup,
                    mExpandableListView.getExpandableListPosition(expectedFlatPosition));

            Assert.assertEquals(""Wrong flat position for group "" + groupIndex,
                    expectedFlatPosition,
                    mExpandableListView.getFlatListPosition(packedPositionForGroup));
        }

        for (int i=0; i<mExpandableListView.getFooterViewsCount(); i++) {
            Assert.assertEquals(""Non NULL position for header item"",
                    ExpandableListView.PACKED_POSITION_VALUE_NULL,
                    mExpandableListView.getExpandableListPosition(headerCount + groupCount + i));
        }
    }

    // This method assumes that NO group is expanded when called
    void testConversionBetweenFlatAndPackedOnChildren() {
        // Test with an expanded group
        final int headerCount = mExpandableListView.getHeaderViewsCount();
        final int groupIndex = expandAGroup();

        final int childrenCount = mAdapter.getChildrenCount(groupIndex);
        for (int childIndex = 0; childIndex < childrenCount; childIndex++) {
            int expectedFlatPosition = headerCount + groupIndex + 1 + childIndex;
            long childPos = ExpandableListView.getPackedPositionForChild(groupIndex, childIndex);

            Assert.assertEquals(""Wrong flat position for child "",
                    childPos,
                    mExpandableListView.getExpandableListPosition(expectedFlatPosition));

            Assert.assertEquals(""Wrong flat position for child "",
                    expectedFlatPosition,
                    mExpandableListView.getFlatListPosition(childPos));
        }
    }

    // This method assumes that NO group is expanded when called
    void testSelectedPositionOnGroups() {
        int index = 0;

        // Scrolling on header elements should not give a valid selected position.
        for (int i=0; i<mExpandableListView.getHeaderViewsCount(); i++) {
            mListUtil.arrowScrollToSelectedPosition(index);
            Assert.assertEquals(""Header item is selected"",
                    ExpandableListView.PACKED_POSITION_VALUE_NULL,
                    mExpandableListView.getSelectedPosition());
            index++;
        }

        // Check selection on group items
        final int groupCount = mAdapter.getGroupCount();
        for (int groupIndex = 0; groupIndex < groupCount; groupIndex++) {
            mListUtil.arrowScrollToSelectedPosition(index);
            Assert.assertEquals(""Group item is not selected"",
                    ExpandableListView.getPackedPositionForGroup(groupIndex),
                    mExpandableListView.getSelectedPosition());
            index++;
        }

        // Scrolling on footer elements should not give a valid selected position.
        for (int i=0; i<mExpandableListView.getFooterViewsCount(); i++) {
            mListUtil.arrowScrollToSelectedPosition(index);
            Assert.assertEquals(""Footer item is selected"",
                    ExpandableListView.PACKED_POSITION_VALUE_NULL,
                    mExpandableListView.getSelectedPosition());
            index++;
        }
    }

    // This method assumes that NO group is expanded when called
    void testSelectedPositionOnChildren() {
        // Test with an expanded group
        final int headerCount = mExpandableListView.getHeaderViewsCount();
        final int groupIndex = expandAGroup();

        final int childrenCount = mAdapter.getChildrenCount(groupIndex);
        for (int childIndex = 0; childIndex < childrenCount; childIndex++) {
            int childFlatPosition = headerCount + groupIndex + 1 + childIndex;
            mListUtil.arrowScrollToSelectedPosition(childFlatPosition);
            Assert.assertEquals(""Group item is not selected"",
                    ExpandableListView.getPackedPositionForChild(groupIndex, childIndex),
                    mExpandableListView.getSelectedPosition());
        }
    }
}"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.widget.cts.ExpandableListViewWithHeadersTest"	"testExpandOnFirstPosition"	"CtsWidgetTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/ExpandableListViewWithHeadersTest.java"	""	"public void testExpandOnFirstPosition() {
        // Should be a header, and hence the first group should NOT have expanded
        mListUtil.arrowScrollToSelectedPosition(0);
        WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, mExpandableListView, null);

        CtsKeyEventUtil.sendKeys(mInstrumentation, mExpandableListView,
                KeyEvent.KEYCODE_DPAD_CENTER);
        WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, mExpandableListView, null);

        assertFalse(mExpandableListView.isGroupExpanded(0));
    }

    @LargeTest"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.widget.cts.ExpandableListViewWithHeadersTest"	"testExpandOnFirstGroup"	"CtsWidgetTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/ExpandableListViewWithHeadersTest.java"	""	"public void testExpandOnFirstGroup() {
        mListUtil.arrowScrollToSelectedPosition(mActivity.getNumOfHeadersAndFooters());
        WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, mExpandableListView, null);

        CtsKeyEventUtil.sendKeys(mInstrumentation, mExpandableListView,
                KeyEvent.KEYCODE_DPAD_CENTER);
        WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, mExpandableListView, null);

        assertTrue(mExpandableListView.isGroupExpanded(0));
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.server.biometrics.BiometricCryptoTests"	"testGenerateKeyWithoutDeviceCredential_throwsException"	"CtsBiometricsTestCases"	"/home/gpoor/cts-12-source/cts/tests/framework/base/biometrics/src/android/server/biometrics/BiometricCryptoTests.java"	""	"public void testGenerateKeyWithoutDeviceCredential_throwsException() {
        assertThrows(""Key shouldn't be generatable before device credentials are enrolled"",
                Exception.class,
                () -> Utils.generateBiometricBoundKey(""keyBeforeCredentialEnrolled"",
                        false /* useStrongBox */));
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.server.biometrics.BiometricCryptoTests"	"testGenerateKeyWithoutBiometricEnrolled_throwsInvalidAlgorithmParameterException"	"CtsBiometricsTestCases"	"/home/gpoor/cts-12-source/cts/tests/framework/base/biometrics/src/android/server/biometrics/BiometricCryptoTests.java"	""	"public void testGenerateKeyWithoutBiometricEnrolled_throwsInvalidAlgorithmParameterException()
            throws Exception {
        try (CredentialSession session = new CredentialSession()){
            session.setCredential();
            assertThrows(""Key shouldn't be generatable before biometrics are enrolled"",
                    InvalidAlgorithmParameterException.class,
                    () -> Utils.generateBiometricBoundKey(""keyBeforeBiometricEnrolled"",
                            false /* useStrongBox */));
        }
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.server.biometrics.BiometricCryptoTests"	"testGenerateKeyWhenCredentialAndBiometricEnrolled"	"CtsBiometricsTestCases"	"/home/gpoor/cts-12-source/cts/tests/framework/base/biometrics/src/android/server/biometrics/BiometricCryptoTests.java"	""	"public void testGenerateKeyWhenCredentialAndBiometricEnrolled() throws Exception {
        try (CredentialSession credentialSession = new CredentialSession()) {
            credentialSession.setCredential();

            // 1) Test biometric or credential time-based key. These should be generatable
            // regardless of biometric strength and enrollment, since credentials are enrolled.
            int authType = KeyProperties.AUTH_BIOMETRIC_STRONG
                    | KeyProperties.AUTH_DEVICE_CREDENTIAL;
            Utils.createTimeBoundSecretKey_deprecated(""credential_tb_d"", false /* useStrongBox */);
            Utils.createTimeBoundSecretKey(""credential_tb"", authType, false /* useStrongBox */);
            if (mHasStrongBox) {
                Utils.createTimeBoundSecretKey_deprecated(""credential_tb_d_sb"",
                        true /* useStrongBox */);
                Utils.createTimeBoundSecretKey(""credential_tb_sb"", authType,
                        true /* useStrongBox */);
            }

            for (SensorProperties prop : mSensorProperties) {
                final String keyPrefix = ""key"" + prop.getSensorId();
                Log.d(TAG, ""Testing sensor: "" + prop + "", key name: "" + keyPrefix);

                try (BiometricTestSession session =
                             mBiometricManager.createTestSession(prop.getSensorId())) {
                    waitForAllUnenrolled();
                    enrollForSensor(session, prop.getSensorId());

                    if (prop.getSensorStrength() == SensorProperties.STRENGTH_STRONG) {
                        // Test biometric-bound key
                        Utils.generateBiometricBoundKey(keyPrefix, false /* useStrongBox */);
                        if (mHasStrongBox) {
                            Utils.generateBiometricBoundKey(keyPrefix + ""sb"",
                                    true /* useStrongBox */);
                        }
                        // We can test initializing the key, which in this case is a Cipher.
                        // However, authenticating it and using it is not testable, since that
                        // requires a real authentication from the TEE or equivalent.
                        BiometricPrompt.CryptoObject crypto =
                                Utils.initializeCryptoObject(keyPrefix);
                    } else {
                        // 1) Test biometric auth-per-use keys
                        assertThrows(""Biometric auth-per-use key shouldn't be generatable with""
                                        + "" non-strong biometrics"",
                                InvalidAlgorithmParameterException.class,
                                () -> Utils.generateBiometricBoundKey(keyPrefix,
                                        false /* useStrongBox */));
                        if (mHasStrongBox) {
                            assertThrows(""Biometric auth-per-use strongbox-backed key shouldn't""
                                            + "" be generatable with non-strong biometrics"",
                                    InvalidAlgorithmParameterException.class,
                                    () -> Utils.generateBiometricBoundKey(keyPrefix,
                                            true /* useStrongBox */));
                        }

                        // 2) Test biometric time-based keys
                        assertThrows(""Biometric time-based key shouldn't be generatable with""
                                        + "" non-strong biometrics"",
                                Exception.class,
                                () -> Utils.createTimeBoundSecretKey(keyPrefix + ""tb"",
                                        KeyProperties.AUTH_BIOMETRIC_STRONG,
                                        false /* useStrongBox */));
                        if (mHasStrongBox) {
                            assertThrows(""Biometric time-based strongbox-backed key shouldn't be""
                                            + "" generatable with non-strong biometrics"",
                                    Exception.class,
                                    () -> Utils.createTimeBoundSecretKey(keyPrefix + ""tb"",
                                            KeyProperties.AUTH_BIOMETRIC_STRONG,
                                            true /* useStrongBox */));
                        }
                    }
                }
            }
        }
    }
}"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.keystore.cts.SecretKeyFactoryTest"	"testGetKeySpecWithKeystoreKeyAndKeyInfoReflectsAllAuthorizations"	"CtsKeystoreTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/keystore/src/android/keystore/cts/SecretKeyFactoryTest.java"	""	"public void testGetKeySpecWithKeystoreKeyAndKeyInfoReflectsAllAuthorizations()
            throws Exception {
        Date keyValidityStart = new Date(System.currentTimeMillis() - TestUtils.DAY_IN_MILLIS);
        Date keyValidityForOriginationEnd =
                new Date(System.currentTimeMillis() + TestUtils.DAY_IN_MILLIS);
        Date keyValidityForConsumptionEnd =
                new Date(System.currentTimeMillis() + 3 * TestUtils.DAY_IN_MILLIS);
        for (String algorithm : EXPECTED_ALGORITHMS) {
            try {
                String[] blockModes =
                        new String[] {KeyProperties.BLOCK_MODE_CTR, KeyProperties.BLOCK_MODE_ECB};
                String[] encryptionPaddings =
                        new String[] {KeyProperties.ENCRYPTION_PADDING_PKCS7,
                                KeyProperties.ENCRYPTION_PADDING_NONE};
                String[] digests;
                int purposes;
                if (TestUtils.isHmacAlgorithm(algorithm)) {
                    String digest = TestUtils.getHmacAlgorithmDigest(algorithm);
                    digests = new String[] {digest};
                    purposes = KeyProperties.PURPOSE_SIGN;
                } else {
                    digests = new String[] {KeyProperties.DIGEST_SHA384};
                    purposes = KeyProperties.PURPOSE_DECRYPT;
                }
                KeyGenerator keyGenerator =
                        KeyGenerator.getInstance(algorithm, EXPECTED_PROVIDER_NAME);
                keyGenerator.init(new KeyGenParameterSpec.Builder(""test1"", purposes)
                        .setBlockModes(blockModes)
                        .setEncryptionPaddings(encryptionPaddings)
                        .setDigests(digests)
                        .setKeyValidityStart(keyValidityStart)
                        .setKeyValidityForOriginationEnd(keyValidityForOriginationEnd)
                        .setKeyValidityForConsumptionEnd(keyValidityForConsumptionEnd)
                        .build());
                SecretKey key = keyGenerator.generateKey();
                SecretKeyFactory keyFactory = getKeyFactory(algorithm);
                KeyInfo keyInfo = (KeyInfo) keyFactory.getKeySpec(key, KeyInfo.class);
                assertEquals(""test1"", keyInfo.getKeystoreAlias());
                assertEquals(purposes, keyInfo.getPurposes());
                TestUtils.assertContentsInAnyOrder(
                        Arrays.asList(blockModes), keyInfo.getBlockModes());
                TestUtils.assertContentsInAnyOrder(
                        Arrays.asList(encryptionPaddings), keyInfo.getEncryptionPaddings());
                TestUtils.assertContentsInAnyOrder(Arrays.asList(digests), keyInfo.getDigests());
                MoreAsserts.assertEmpty(Arrays.asList(keyInfo.getSignaturePaddings()));
                assertEquals(keyValidityStart, keyInfo.getKeyValidityStart());
                assertEquals(keyValidityForOriginationEnd,
                        keyInfo.getKeyValidityForOriginationEnd());
                assertEquals(keyValidityForConsumptionEnd,
                        keyInfo.getKeyValidityForConsumptionEnd());
                assertFalse(keyInfo.isUserAuthenticationRequired());
                assertFalse(keyInfo.isUserAuthenticationRequirementEnforcedBySecureHardware());
            } catch (Throwable e) {
                throw new RuntimeException(""Failed for "" + algorithm, e);
            }
        }
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.text.method.cts.NumberKeyListenerTest"	"testPressKey"	"CtsTextTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/text/src/android/text/method/cts/NumberKeyListenerTest.java"	""	"public void testPressKey() {
        final CharSequence text = ""123456"";
        final MockNumberKeyListener mockNumberKeyListener =
            new MockNumberKeyListener(MockNumberKeyListener.DIGITS);

        mActivity.runOnUiThread(() -> {
            mTextView.setText(text, BufferType.EDITABLE);
            mTextView.setKeyListener(mockNumberKeyListener);
            mTextView.requestFocus();
            Selection.setSelection(mTextView.getText(), 0, 0);
        });
        mInstrumentation.waitForIdleSync();
        assertEquals(""123456"", mTextView.getText().toString());
        // press '0' key.
        CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, KeyEvent.KEYCODE_0);
        assertEquals(""0123456"", mTextView.getText().toString());

        // an unaccepted key if it exists.
        int keyCode = TextMethodUtils.getUnacceptedKeyCode(MockNumberKeyListener.DIGITS);
        if (-1 != keyCode) {
            CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, keyCode);
            // text of TextView will not be changed.
            assertEquals(""0123456"", mTextView.getText().toString());
        }

        mActivity.runOnUiThread(() -> {
            mTextView.setKeyListener(null);
            mTextView.requestFocus();
        });
        mInstrumentation.waitForIdleSync();
        // press '0' key.
        CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, KeyEvent.KEYCODE_0);
        assertEquals(""0123456"", mTextView.getText().toString());
    }

    /**
     * A mocked {@link android.text.method.NumberKeyListener} for testing purposes.
     *
     * Allows {@link NumberKeyListenerTest} to call
     * {@link android.text.method.NumberKeyListener#getAcceptedChars()},
     * {@link android.text.method.NumberKeyListener#lookup(KeyEvent, Spannable)}, and
     * {@link android.text.method.NumberKeyListener@ok(char[], char)}.
     */
    private static class MockNumberKeyListener extends NumberKeyListener {
        static final char[] DIGITS =
                new char[] {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'};

        static final char[] NOTHING = new char[0];

        private final char[] mAcceptedChars;

        MockNumberKeyListener(char[] acceptedChars) {
            this.mAcceptedChars = acceptedChars;
        }

        @Override
        protected char[] getAcceptedChars() {
            return mAcceptedChars;
        }

        @Override
        protected int lookup(KeyEvent event, Spannable content) {
            return super.lookup(event, content);
        }

        public boolean callOk(char[] accept, char c) {
            return NumberKeyListener.ok(accept, c);
        }

        public int getInputType() {
            return 0;
        }
    }
}"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.text.method.cts.TimeKeyListenerTest"	"testTimeKeyListener"	"CtsTextTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/text/src/android/text/method/cts/TimeKeyListenerTest.java"	""	"public void testTimeKeyListener() {
        final TimeKeyListener timeKeyListener = TimeKeyListener.getInstance();
        String expectedText = """";

        setKeyListenerSync(timeKeyListener);
        assertEquals(expectedText, mTextView.getText().toString());

        // press '1' key.
        CtsKeyEventUtil.sendString(mInstrumentation, mTextView, ""1"");
        expectedText += ""1"";
        assertEquals(expectedText, mTextView.getText().toString());

        // press '2' key.
        CtsKeyEventUtil.sendString(mInstrumentation, mTextView, ""2"");
        expectedText += ""2"";
        assertEquals(""12"", mTextView.getText().toString());

        // press 'a' key if producible
        KeyCharacterMap kcm = KeyCharacterMap.load(KeyCharacterMap.VIRTUAL_KEYBOARD);
        if ('a' == kcm.getMatch(KeyEvent.KEYCODE_A, TimeKeyListener.CHARACTERS)) {
            expectedText += ""a"";
            CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTextView, KeyEvent.KEYCODE_A);
            assertEquals(expectedText, mTextView.getText().toString());
        }

        // press 'p' key if producible
        if ('p' == kcm.getMatch(KeyEvent.KEYCODE_P, TimeKeyListener.CHARACTERS)) {
            expectedText += ""p"";
            CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTextView, KeyEvent.KEYCODE_P);
            assertEquals(expectedText, mTextView.getText().toString());
        }

        // press 'm' key if producible
        if ('m' == kcm.getMatch(KeyEvent.KEYCODE_M, TimeKeyListener.CHARACTERS)) {
            expectedText += ""m"";
            CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTextView, KeyEvent.KEYCODE_M);
            assertEquals(expectedText, mTextView.getText().toString());
        }

        // press an unaccepted key if it exists.
        int keyCode = TextMethodUtils.getUnacceptedKeyCode(TimeKeyListener.CHARACTERS);
        if (-1 != keyCode) {
            CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, keyCode);
            assertEquals(expectedText, mTextView.getText().toString());
        }

        setKeyListenerSync(null);

        // press '1' key.
        CtsKeyEventUtil.sendString(mInstrumentation, mTextView, ""1"");
        assertEquals(expectedText, mTextView.getText().toString());
    }

    /**
     * A mocked {@link android.text.method.TimeKeyListener} for testing purposes.
     *
     * Allows {@link TimeKeyListenerTest} to call
     * {@link android.text.method.TimeKeyListener#getAcceptedChars()}.
     */
    private class MockTimeKeyListener extends TimeKeyListener {
        MockTimeKeyListener() {
            super();
        }

        MockTimeKeyListener(Locale locale) {
            super(locale);
        }

        @Override
        protected char[] getAcceptedChars() {
            return super.getAcceptedChars();
        }
    }
}"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.view.inputmethod.cts.KeyboardVisibilityControlTest"	"testFloatingImeHideKeyboardAfterBackPressed"	"CtsInputMethodTestCases"	"/home/gpoor/cts-12-source/cts/tests/inputmethod/src/android/view/inputmethod/cts/KeyboardVisibilityControlTest.java"	""	"public void testFloatingImeHideKeyboardAfterBackPressed() throws Exception {
        final Instrumentation instrumentation = InstrumentationRegistry.getInstrumentation();
        final InputMethodManager imm = instrumentation.getTargetContext().getSystemService(
                InputMethodManager.class);

        // Initial MockIme with floating IME settings.
        try (MockImeSession imeSession = MockImeSession.create(
                instrumentation.getContext(), instrumentation.getUiAutomation(),
                getFloatingImeSettings(Color.BLACK))) {
            final ImeEventStream stream = imeSession.openEventStream();
            final String marker = getTestMarker();
            final EditText editText = launchTestActivity(marker);

            expectEvent(stream, editorMatcher(""onStartInput"", marker), TIMEOUT);
            notExpectEvent(stream, editorMatcher(""onStartInputView"", marker), TIMEOUT);
            expectImeInvisible(TIMEOUT);

            assertTrue(""isActive() must return true if the View has IME focus"",
                    getOnMainSync(() -> imm.isActive(editText)));

            // Test showSoftInput() flow
            assertTrue(""showSoftInput must success if the View has IME focus"",
                    getOnMainSync(() -> imm.showSoftInput(editText, 0)));

            expectEvent(stream, showSoftInputMatcher(InputMethod.SHOW_EXPLICIT), TIMEOUT);
            expectEvent(stream, editorMatcher(""onStartInputView"", marker), TIMEOUT);
            expectEventWithKeyValue(stream, ""onWindowVisibilityChanged"", ""visible"",
                    View.VISIBLE, TIMEOUT);
            expectImeVisible(TIMEOUT);

            // Pressing back key, expect soft-keyboard will become invisible.
            instrumentation.sendKeyDownUpSync(KeyEvent.KEYCODE_BACK);
            expectEvent(stream, hideSoftInputMatcher(), TIMEOUT);
            expectEvent(stream, onFinishInputViewMatcher(false), TIMEOUT);
            expectEventWithKeyValue(stream, ""onWindowVisibilityChanged"", ""visible"",
                    View.GONE, TIMEOUT);
            expectImeInvisible(TIMEOUT);
        }
    }"	""	""	"NDK"	""	""	""	""	""	""	""	""	""	""
"3.6  . API Namespaces"	"3.6"	"C-1-1"	"3.6/C-1-1"	"03060000.670101"	"""C-1-1] MUST NOT be in a NDK library or a library owned by another organization as described here. If a device implementer proposes to improve one of the package namespaces above (such as by adding useful new functionality to an existing API, or adding a new API), the implementer SHOULD visit source.android.com and begin the process for contributing changes and code, according to the information on that site. Note that the restrictions above correspond to standard conventions for naming APIs in the Java programming language; this section simply aims to reinforce those conventions and make them binding through inclusion in this Compatibility Definition. <h3 id=""37_runtime_compatibility"" """	""	""	"NDK"	""	""	""	""	""	""	""	""	"android.view.inputmethod.cts.KeyboardVisibilityControlTest"	"testRestoreImeVisibility_noRestoreForHiddenWithForwardNav"	"CtsInputMethodTestCases"	"/home/gpoor/cts-12-source/cts/tests/inputmethod/src/android/view/inputmethod/cts/KeyboardVisibilityControlTest.java"	""	"public void testRestoreImeVisibility_noRestoreForHiddenWithForwardNav() throws Exception {
        runRestoreImeVisibility(TestSoftInputMode.HIDDEN_WITH_FORWARD_NAV, false);
    }

    private enum TestSoftInputMode {
        UNCHANGED_WITH_BACKWARD_NAV,
        ALWAYS_HIDDEN_WITH_BACKWARD_NAV,
        HIDDEN_WITH_FORWARD_NAV
    }

    private void runRestoreImeVisibility(TestSoftInputMode mode, boolean expectImeVisible)
            throws Exception {
        final Instrumentation instrumentation = InstrumentationRegistry.getInstrumentation();
        final WindowManager wm = instrumentation.getContext().getSystemService(WindowManager.class);
        // As restoring IME visibility behavior is only available when TaskSnapshot mechanism
        // enabled, skip the test when TaskSnapshot is not supported.
        assumeTrue(""Restoring IME visibility not available when TaskSnapshot unsupported"",
                wm.isTaskSnapshotSupported());

        try (MockImeSession imeSession = MockImeSession.create(
                instrumentation.getContext(), instrumentation.getUiAutomation(),
                new ImeSettings.Builder())) {
            final ImeEventStream stream = imeSession.openEventStream();
            final String markerForActivity1 = getTestMarker();
            final AtomicReference<EditText> editTextRef = new AtomicReference<>();
            // Launch a test activity with focusing editText to show keyboard
            TestActivity.startSync(activity -> {
                final LinearLayout layout = new LinearLayout(activity);
                final EditText editText = new EditText(activity);
                editTextRef.set(editText);
                editText.setHint(""focused editText"");
                editText.setPrivateImeOptions(markerForActivity1);
                editText.requestFocus();
                layout.addView(editText);
                activity.getWindow().getDecorView().getWindowInsetsController().show(ime());
                if (mode == TestSoftInputMode.ALWAYS_HIDDEN_WITH_BACKWARD_NAV) {
                    activity.getWindow().setSoftInputMode(SOFT_INPUT_STATE_ALWAYS_HIDDEN);
                }
                return layout;
            });

            expectEvent(stream, editorMatcher(""onStartInput"", markerForActivity1), TIMEOUT);
            expectEvent(stream, editorMatcher(""onStartInputView"", markerForActivity1), TIMEOUT);
            expectEventWithKeyValue(stream, ""onWindowVisibilityChanged"", ""visible"",
                    View.VISIBLE, TIMEOUT);
            expectImeVisible(TIMEOUT);

            // Launch another app task activity to hide keyboard
            TestActivity.startNewTaskSync(activity -> {
                activity.getWindow().setSoftInputMode(SOFT_INPUT_STATE_ALWAYS_HIDDEN);
                return new LinearLayout(activity);
            });
            expectEvent(stream, hideSoftInputMatcher(), TIMEOUT);
            expectEvent(stream, onFinishInputViewMatcher(false), TIMEOUT);
            expectEventWithKeyValue(stream, ""onWindowVisibilityChanged"", ""visible"",
                    View.GONE, TIMEOUT);
            expectImeInvisible(TIMEOUT);

            if (mode == TestSoftInputMode.HIDDEN_WITH_FORWARD_NAV) {
                // Start new TestActivity on the same task with STATE_HIDDEN softInputMode.
                final String markerForActivity2 = getTestMarker();
                TestActivity.startSameTaskAndClearTopSync(activity -> {
                    final LinearLayout layout = new LinearLayout(activity);
                    final EditText editText = new EditText(activity);
                    editText.setHint(""focused editText"");
                    editText.setPrivateImeOptions(markerForActivity2);
                    editText.requestFocus();
                    layout.addView(editText);
                    activity.getWindow().setSoftInputMode(SOFT_INPUT_STATE_HIDDEN);
                    return layout;
                });
                expectEvent(stream, editorMatcher(""onStartInput"", markerForActivity2), TIMEOUT);
            } else {
                // Press back key to back to the first test activity
                instrumentation.sendKeyDownUpSync(KeyEvent.KEYCODE_BACK);
                expectEvent(stream, editorMatcher(""onStartInput"", markerForActivity1), TIMEOUT);
            }

            // Expect the IME visibility according to expectImeVisible
            // The expected result could be:
            //  1) The system can restore the IME visibility to show IME up when navigated back to
            //     the original app task, even the IME is hidden when switching to the next task.
            //  2) The system won't restore the IME visibility in some softInputMode cases.
            if (expectImeVisible) {
                expectImeVisible(TIMEOUT);
            } else {
                expectImeInvisible(TIMEOUT);
            }
        }
    }

    private void runImeVisibilityWhenImeTransitionBetweenActivities(boolean instant)
            throws Exception {
        try (MockImeSession imeSession = MockImeSession.create(
                InstrumentationRegistry.getInstrumentation().getContext(),
                InstrumentationRegistry.getInstrumentation().getUiAutomation(),
                new ImeSettings.Builder()
                        .setInputViewHeight(NEW_KEYBOARD_HEIGHT)
                        .setDrawsBehindNavBar(true))) {
            final ImeEventStream stream = imeSession.openEventStream();
            final String marker = getTestMarker();

            AtomicReference<EditText> editTextRef = new AtomicReference<>();
            // Launch test activity with focusing editor
            final TestActivity testActivity =
                    TestActivity.startSync(activity -> {
                        final LinearLayout layout = new LinearLayout(activity);
                        layout.setOrientation(LinearLayout.VERTICAL);
                        layout.setGravity(Gravity.BOTTOM);
                        final EditText editText = new EditText(activity);
                        editTextRef.set(editText);
                        editText.setHint(""focused editText"");
                        editText.setPrivateImeOptions(marker);
                        editText.requestFocus();
                        layout.addView(editText);
                        activity.getWindow().getDecorView().setFitsSystemWindows(true);
                        activity.getWindow().getDecorView().getWindowInsetsController().show(ime());
                        return layout;
                    });
            expectEvent(stream, editorMatcher(""onStartInput"", marker), TIMEOUT);
            expectEvent(stream, event -> ""showSoftInput"".equals(event.getEventName()), TIMEOUT);
            expectEvent(stream, editorMatcher(""onStartInputView"", marker), TIMEOUT);
            expectEventWithKeyValue(stream, ""onWindowVisibilityChanged"", ""visible"",
                    View.VISIBLE, TIMEOUT);
            expectImeVisible(TIMEOUT);

            // Launcher another test activity from another process with popup dialog.
            launchRemoteActivitySync(TEST_ACTIVITY, instant, TIMEOUT,
                    Map.of(EXTRA_KEY_SHOW_DIALOG, ""true""));
            // Dismiss dialog and back to original test activity
            triggerActionWithBroadcast(ACTION_TRIGGER, TEST_ACTIVITY.getPackageName(),
                    EXTRA_DISMISS_DIALOG);

            // Verify keyboard visibility should aligned with IME insets visibility.
            TestUtils.waitOnMainUntil(
                    () -> testActivity.getWindow().getDecorView().getVisibility() == VISIBLE
                            && testActivity.getWindow().getDecorView().hasWindowFocus(), TIMEOUT);

            AtomicReference<Boolean> imeInsetsVisible = new AtomicReference<>();
            TestUtils.runOnMainSync(() ->
                    imeInsetsVisible.set(editTextRef.get().getRootWindowInsets().isVisible(ime())));

            if (imeInsetsVisible.get()) {
                expectImeVisible(TIMEOUT);
            } else {
                expectImeInvisible(TIMEOUT);
            }
        }
    }

    private void runImeVisibilityTestWhenForceStopPackage(boolean instant) throws Exception {
        try (MockImeSession imeSession = MockImeSession.create(
                InstrumentationRegistry.getInstrumentation().getContext(),
                InstrumentationRegistry.getInstrumentation().getUiAutomation(),
                new ImeSettings.Builder())) {
            final ImeEventStream stream = imeSession.openEventStream();
            final String marker = getTestMarker();

            // Make sure that MockIme isn't shown in the initial state.
            final ImeLayoutInfo lastLayout =
                    waitForInputViewLayoutStable(stream, LAYOUT_STABLE_THRESHOLD);
            assertNull(lastLayout);
            expectImeInvisible(TIMEOUT);
            // Flush all the events happened before launching the test Activity.
            stream.skipAll();

            // Launch test activity with focusing an editor from remote process and expect the
            // IME is visible.
            try (AutoCloseable closable = launchRemoteActivitySync(TEST_ACTIVITY, instant, TIMEOUT,
                    Map.of(EXTRA_KEY_PRIVATE_IME_OPTIONS, marker))) {
                expectEvent(stream, editorMatcher(""onStartInput"", marker), START_INPUT_TIMEOUT);
                expectImeInvisible(TIMEOUT);

                // Request showSoftInput, expect the request is valid and soft-keyboard visible.
                triggerActionWithBroadcast(ACTION_TRIGGER, TEST_ACTIVITY.getPackageName(),
                        EXTRA_SHOW_SOFT_INPUT);
                expectEvent(stream, event -> ""showSoftInput"".equals(event.getEventName()), TIMEOUT);
                expectEvent(stream, editorMatcher(""onStartInputView"", marker), TIMEOUT);
                expectEventWithKeyValue(stream, ""onWindowVisibilityChanged"", ""visible"",
                        View.VISIBLE, TIMEOUT);
                expectImeVisible(TIMEOUT);

                // Force stop test app package, and then expect IME should be invisible after the
                // remote process stopped by forceStopPackage.
                TestUtils.forceStopPackage(TEST_ACTIVITY.getPackageName());
                expectEvent(stream, onFinishInputViewMatcher(false), TIMEOUT);
                expectImeInvisible(TIMEOUT);
            }
        }
    }

    private AutoCloseable launchRemoteActivitySync(ComponentName componentName, boolean instant,
             long timeout, Map<String, String> extras) {
        final StringBuilder commandBuilder = new StringBuilder();
        if (instant) {
            // Override app-links domain verification.
            runShellCommand(
                    String.format(""pm set-app-links-user-selection --user cur --package %s true %s"",
                            componentName.getPackageName(), TEST_ACTIVITY_URI.getHost()));
            final Uri uri = formatStringIntentParam(TEST_ACTIVITY_URI, extras);
            commandBuilder.append(String.format(""am start -a %s -c %s %s"",
                    Intent.ACTION_VIEW, Intent.CATEGORY_BROWSABLE, uri.toString()));
        } else {
            commandBuilder.append(""am start -n "").append(componentName.flattenToShortString());
            if (extras != null) {
                extras.forEach((key, value) -> commandBuilder.append("" --es "")
                        .append(key).append("" "").append(value));
            }
        }

        runWithShellPermissionIdentity(() -> {
            runShellCommand(commandBuilder.toString());
        });
        UiDevice uiDevice = UiDevice.getInstance(InstrumentationRegistry.getInstrumentation());
        BySelector activitySelector = By.pkg(componentName.getPackageName()).depth(0);
        uiDevice.wait(Until.hasObject(activitySelector), timeout);

        // Make sure to stop package after test finished for resource reclaim.
        return () -> TestUtils.forceStopPackage(componentName.getPackageName());
    }

    @NonNull
    private static Uri formatStringIntentParam(@NonNull Uri uri, Map<String, String> extras) {
        if (extras == null) {
            return uri;
        }
        final Uri.Builder builder = uri.buildUpon();
        extras.forEach(builder::appendQueryParameter);
        return builder.build();
    }

    private void triggerActionWithBroadcast(String action, String receiverPackage, String extra) {
        final StringBuilder commandBuilder = new StringBuilder();
        commandBuilder.append(""am broadcast -a "").append(action).append("" -p "").append(
                receiverPackage);
        commandBuilder.append("" -f 0x"").append(
                Integer.toHexString(FLAG_RECEIVER_VISIBLE_TO_INSTANT_APPS));
        commandBuilder.append("" --ez "" + extra + "" true"");
        runWithShellPermissionIdentity(() -> {
            runShellCommand(commandBuilder.toString());
        });
    }

    private static ImeSettings.Builder getFloatingImeSettings(@ColorInt int navigationBarColor) {
        final ImeSettings.Builder builder = new ImeSettings.Builder();
        builder.setWindowFlags(0, FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);
        // As documented, Window#setNavigationBarColor() is actually ignored when the IME window
        // does not have FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS.  We are calling setNavigationBarColor()
        // to ensure it.
        builder.setNavigationBarColor(navigationBarColor);
        return builder;
    }
}"	""	""	"NDK NDK"	""	""	""	""	""	""	""	""	""	""
