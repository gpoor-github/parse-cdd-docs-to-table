"Section"	"section_id"	"req_id"	"full_key"	"key_as_number"	"requirement"	"Test Availability"	"search_roots"	"search_terms"	"manual_search_terms"	"not_search_terms"	"not_files"	"max_matches"	"class_defs"	"methods"	"modules"	"protected"	"class_def"	"method"	"module"	"file_name"	"matched_files"	"methods_string"	"urls"	"method_text"	"matched_terms"	"qualified_method"	"Annotation?"	"New Req for S?"	"New CTS for S?"	"Comment(internal) e.g. why a test is not possible"	"CTS Bug Id"	"CDD Bug Id"	"Area"	"Shortened"	"Test Level"
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.TestMmTelFeature"	"TestImsSmsImpl"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/TestMmTelFeature.java"	""	"public void test/*
 *.
 */

package android.telephony.ims.cts;

import android.telephony.ims.RtpHeaderExtensionType;
import android.telephony.ims.feature.CapabilityChangeRequest;
import android.telephony.ims.feature.MmTelFeature;
import android.telephony.ims.stub.ImsRegistrationImplBase;
import android.util.Log;

import java.util.List;
import java.util.Set;
import java.util.concurrent.CountDownLatch;

public class TestMmTelFeature extends MmTelFeature {

    private final TestImsService.RemovedListener mRemovedListener;
    private final TestImsService.ReadyListener mReadyListener;
    private final TestImsService.CapabilitiesSetListener mCapSetListener;

    private static final String TAG = ""CtsTestImsService"";

    private MmTelCapabilities mCapabilities =
            new MmTelCapabilities(MmTelCapabilities.CAPABILITY_TYPE_SMS);
    private TestImsSmsImpl mSmsImpl;
    private Set<RtpHeaderExtensionType> mOfferedRtpHeaderExtensionTypes;
    private CountDownLatch mOfferedRtpHeaderExtensionLatch = new CountDownLatch(1);

    TestMmTelFeature(TestImsService.ReadyListener readyListener,
            TestImsService.RemovedListener removedListener,
            TestImsService.CapabilitiesSetListener setListener) {
        mReadyListener = readyListener;
        mRemovedListener = removedListener;
        mCapSetListener = setListener;
        mSmsImpl = new TestImsSmsImpl();
        // Must set the state to READY in the constructor - onFeatureReady depends on the state
        // being ready.
        setFeatureState(STATE_READY);
    }

    public TestImsSmsImpl getSmsImplementation() {
        return mSmsImpl;
    }

    @Override
    public boolean queryCapabilityConfiguration(int capability, int radioTech) {
        if (ImsUtils.VDBG) {
            Log.d(TAG, ""queryCapabilityConfiguration called with capability: "" + capability);
        }
        return mCapabilities.isCapable(capability);
    }

    @Override
    public void changeEnabledCapabilities(CapabilityChangeRequest request,
            CapabilityCallbackProxy c) {
        List<CapabilityChangeRequest.CapabilityPair> pairs = request.getCapabilitiesToEnable();
        for (CapabilityChangeRequest.CapabilityPair pair : pairs) {
            if (pair.getRadioTech() == ImsRegistrationImplBase.REGISTRATION_TECH_LTE) {
                mCapabilities.addCapabilities(pair.getCapability());
            }
        }
        pairs = request.getCapabilitiesToDisable();
        for (CapabilityChangeRequest.CapabilityPair pair : pairs) {
            if (pair.getRadioTech() == ImsRegistrationImplBase.REGISTRATION_TECH_LTE) {
                mCapabilities.removeCapabilities(pair.getCapability());
            }
        }
        mCapSetListener.onSet();
    }

    @Override
    public void onFeatureReady() {
        if (ImsUtils.VDBG) {
            Log.d(TAG, ""TestMmTelFeature.onFeatureReady called"");
        }
        mReadyListener.onReady();
    }

    @Override
    public void onFeatureRemoved() {
        if (ImsUtils.VDBG) {
            Log.d(TAG, ""TestMmTelFeature.onFeatureRemoved called"");
        }
        mRemovedListener.onRemoved();
    }

    @Override
    public void changeOfferedRtpHeaderExtensionTypes(Set<RtpHeaderExtensionType> extensionTypes) {
        mOfferedRtpHeaderExtensionTypes = extensionTypes;
        mOfferedRtpHeaderExtensionLatch.countDown();
    }

    public void setCapabilities(MmTelCapabilities capabilities) {
        mCapabilities = capabilities;
    }

    public MmTelCapabilities getCapabilities() {
        return mCapabilities;
    }

    public Set<RtpHeaderExtensionType> getOfferedRtpHeaderExtensionTypes() {
        return mOfferedRtpHeaderExtensionTypes;
    }

    public CountDownLatch getOfferedRtpHeaderExtensionLatch() {
        return mOfferedRtpHeaderExtensionLatch;
    }
}"	""	""	"MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.TestImsService"	"TestImsRegistration"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/TestImsService.java"	""	"public void test/*
 *.
 */

package android.telephony.ims.cts;

import android.app.Service;
import android.content.Context;
import android.content.Intent;
import android.os.Binder;
import android.os.IBinder;
import android.telephony.ims.ImsService;
import android.telephony.ims.feature.MmTelFeature;
import android.telephony.ims.feature.RcsFeature;
import android.telephony.ims.stub.ImsConfigImplBase;
import android.telephony.ims.stub.ImsFeatureConfiguration;
import android.telephony.ims.stub.ImsRegistrationImplBase;
import android.telephony.ims.stub.SipTransportImplBase;
import android.util.Log;


import androidx.annotation.Nullable;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

/**
 * A Test ImsService that will verify ImsService functionality.
 */
public class TestImsService extends Service {

    private static final String TAG = ""GtsImsTestImsService"";

    private static final TestImsRegistration sImsRegistrationImplBase =
            new TestImsRegistration();

    private TestRcsFeature mTestRcsFeature;
    private TestMmTelFeature mTestMmTelFeature;
    private TestImsConfig mTestImsConfig;
    private TestSipTransport mTestSipTransport;
    private ImsService mTestImsService;
    private boolean mIsEnabled = false;
    private boolean mSetNullRcsBinding = false;
    private boolean mIsSipTransportImplemented = false;
    private long mCapabilities = 0;
    private ImsFeatureConfiguration mFeatureConfig;
    private final Object mLock = new Object();

    public static final int LATCH_FEATURES_READY = 0;
    public static final int LATCH_ENABLE_IMS = 1;
    public static final int LATCH_DISABLE_IMS = 2;
    public static final int LATCH_CREATE_MMTEL = 3;
    public static final int LATCH_CREATE_RCS = 4;
    public static final int LATCH_REMOVE_MMTEL = 5;
    public static final int LATCH_REMOVE_RCS = 6;
    public static final int LATCH_MMTEL_READY = 7;
    public static final int LATCH_RCS_READY = 8;
    public static final int LATCH_MMTEL_CAP_SET = 9;
    public static final int LATCH_RCS_CAP_SET = 10;
    public static final int LATCH_UCE_LISTENER_SET = 11;
    public static final int LATCH_UCE_REQUEST_PUBLISH = 12;
    private static final int LATCH_MAX = 13;
    protected static final CountDownLatch[] sLatches = new CountDownLatch[LATCH_MAX];
    static {
        for (int i = 0; i < LATCH_MAX; i++) {
            sLatches[i] = new CountDownLatch(1);
        }
    }

    interface RemovedListener {
        void onRemoved();
    }
    interface ReadyListener {
        void onReady();
    }
    interface CapabilitiesSetListener {
        void onSet();
    }
    interface RcsCapabilityExchangeEventListener {
        void onSet();
    }
    interface DeviceCapPublishListener {
        void onPublish();
    }

    // This is defined here instead TestImsService extending ImsService directly because the GTS
    // tests were failing to run on pre-P devices. Not sure why, but TestImsService is loaded
    // even if it isn't used.
    private class ImsServiceUT extends ImsService {

        ImsServiceUT(Context context) {
            // As explained above, ImsServiceUT is created in order to get around classloader
            // restrictions. Attach the base context from the wrapper ImsService.
            if (getBaseContext() == null) {
                attachBaseContext(context);
            }
            mTestImsConfig = new TestImsConfig();
            // For testing, just run on binder thread until required otherwise.
            mTestSipTransport = new TestSipTransport(Runnable::run);
        }

        @Override
        public ImsFeatureConfiguration querySupportedImsFeatures() {
            return getFeatureConfig();
        }

        @Override
        public long getImsServiceCapabilities() {
            return mCapabilities;
        }

        @Override
        public void readyForFeatureCreation() {
            synchronized (mLock) {
                countDownLatch(LATCH_FEATURES_READY);
            }
        }

        @Override
        public void enableIms(int slotId) {
            synchronized (mLock) {
                countDownLatch(LATCH_ENABLE_IMS);
                setIsEnabled(true);
            }
        }

        @Override
        public void disableIms(int slotId) {
            synchronized (mLock) {
                countDownLatch(LATCH_DISABLE_IMS);
                setIsEnabled(false);
            }
        }

        @Override
        public RcsFeature createRcsFeature(int slotId) {
            synchronized (mLock) {
                countDownLatch(LATCH_CREATE_RCS);
                mTestRcsFeature = new TestRcsFeature(getBaseContext(),
                        //onReady
                        () -> {
                            synchronized (mLock) {
                                countDownLatch(LATCH_RCS_READY);
                            }
                        },
                        //onRemoved
                        () -> {
                            synchronized (mLock) {
                                countDownLatch(LATCH_REMOVE_RCS);
                                mTestRcsFeature = null;
                            }
                        },
                        //onCapabilitiesSet
                        () -> {
                            synchronized (mLock) {
                                countDownLatch(LATCH_RCS_CAP_SET);
                            }
                        },
                        () -> {
                            synchronized (mLock) {
                                countDownLatch(LATCH_UCE_LISTENER_SET);
                        }
                        });

                // Setup UCE request listener
                mTestRcsFeature.setDeviceCapPublishListener(() -> {
                    synchronized (mLock) {
                        countDownLatch(LATCH_UCE_REQUEST_PUBLISH);
                    }
                });

                if (mSetNullRcsBinding) {
                    return null;
                }
                return mTestRcsFeature;
            }
        }

        @Override
        public ImsConfigImplBase getConfig(int slotId) {
            return mTestImsConfig;
        }

        @Override
        public MmTelFeature createMmTelFeature(int slotId) {
            synchronized (mLock) {
                countDownLatch(LATCH_CREATE_MMTEL);
                mTestMmTelFeature = new TestMmTelFeature(
                        //onReady
                        () -> {
                            synchronized (mLock) {
                                countDownLatch(LATCH_MMTEL_READY);
                            }
                        },
                        //onRemoved
                        () -> {
                            synchronized (mLock) {
                                countDownLatch(LATCH_REMOVE_MMTEL);
                                mTestMmTelFeature = null;
                            }
                        },
                        //onCapabilitiesSet
                        () -> {
                            synchronized (mLock) {
                                countDownLatch(LATCH_MMTEL_CAP_SET);
                            }
                        }
                        );
                return mTestMmTelFeature;
            }
        }

        @Override
        public ImsRegistrationImplBase getRegistration(int slotId) {
            return sImsRegistrationImplBase;
        }

        @Nullable
        @Override
        public SipTransportImplBase getSipTransport(int slotId) {
            if (mIsSipTransportImplemented) {
                return mTestSipTransport;
            } else {
                return null;
            }
        }
    }

    private final LocalBinder mBinder = new LocalBinder();
    // For local access of this Service.
    class LocalBinder extends Binder {
        TestImsService getService() {
            return TestImsService.this;
        }
    }

    protected ImsService getImsService() {
        synchronized (mLock) {
            if (mTestImsService != null) {
                return mTestImsService;
            }
            mTestImsService = new ImsServiceUT(this);
            return mTestImsService;
        }
    }

    @Override
    public IBinder onBind(Intent intent) {
        if (""android.telephony.ims.ImsService"".equals(intent.getAction())) {
            if (ImsUtils.VDBG) {
                Log.d(TAG, ""onBind-Remote"");
            }
            return getImsService().onBind(intent);
        }
        if (ImsUtils.VDBG) {
            Log.i(TAG, ""onBind-Local"");
        }
        return mBinder;
    }

    public void resetState() {
        synchronized (mLock) {
            mTestMmTelFeature = null;
            mTestRcsFeature = null;
            mIsEnabled = false;
            mSetNullRcsBinding = false;
            mIsSipTransportImplemented = false;
            mCapabilities = 0;
            for (int i = 0; i < LATCH_MAX; i++) {
                sLatches[i] = new CountDownLatch(1);
            }
        }
    }

    // Sets the feature configuration. Make sure to call this before initiating Bind to this
    // ImsService.
    public void setFeatureConfig(ImsFeatureConfiguration f) {
        synchronized (mLock) {
            mFeatureConfig = f;
        }
    }

    public ImsFeatureConfiguration getFeatureConfig() {
        synchronized (mLock) {
            return mFeatureConfig;
        }
    }

    public boolean isEnabled() {
        synchronized (mLock) {
            return mIsEnabled;
        }
    }

    public void setNullRcsBinding() {
        synchronized (mLock) {
            mSetNullRcsBinding = true;
        }
    }

    public void setIsEnabled(boolean isEnabled) {
        synchronized (mLock) {
            mIsEnabled = isEnabled;
        }
    }

    public void addCapabilities(long capabilities) {
        synchronized (mLock) {
            mCapabilities |= capabilities;
        }
    }

    public void setSipTransportImplemented() {
        synchronized (mLock) {
            mIsSipTransportImplemented = true;
        }
    }

    public boolean waitForLatchCountdown(int latchIndex) {
        boolean complete = false;
        try {
            CountDownLatch latch;
            synchronized (mLock) {
                latch = sLatches[latchIndex];
            }
            complete = latch.await(ImsUtils.TEST_TIMEOUT_MS, TimeUnit.MILLISECONDS);
        } catch (InterruptedException e) {
            // complete == false
        }
        synchronized (mLock) {
            sLatches[latchIndex] = new CountDownLatch(1);
        }
        return complete;
    }

    public boolean waitForLatchCountdown(int latchIndex, long waitMs) {
        boolean complete = false;
        try {
            CountDownLatch latch;
            synchronized (mLock) {
                latch = sLatches[latchIndex];
            }
            complete = latch.await(waitMs, TimeUnit.MILLISECONDS);
        } catch (InterruptedException e) {
            // complete == false
        }
        synchronized (mLock) {
            sLatches[latchIndex] = new CountDownLatch(1);
        }
        return complete;
    }

    public void countDownLatch(int latchIndex) {
        synchronized (mLock) {
            sLatches[latchIndex].countDown();
        }
    }

    public TestMmTelFeature getMmTelFeature() {
        synchronized (mLock) {
            return mTestMmTelFeature;
        }
    }

    public TestRcsFeature getRcsFeature() {
        synchronized (mLock) {
            return mTestRcsFeature;
        }
    }

    public TestSipTransport getSipTransport() {
        synchronized (mLock) {
            return mTestSipTransport;
        }
    }

    public TestImsRegistration getImsRegistration() {
        synchronized (mLock) {
            return sImsRegistrationImplBase;
        }
    }

    public ImsConfigImplBase getConfig() {
        return mTestImsConfig;
    }
}"	""	""	"RCS MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.media.cts.MediaExtractorTest"	"testGetAudioPresentations"	"CtsMediaTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/MediaExtractorTest.java"	""	"public void testGetAudioPresentations() throws Exception {
        Preconditions.assertTestFileExists(mInpPrefix +
                        ""MultiLangPerso_1PID_PC0_Select_AC4_H265_DVB_50fps_Audio_Only.ts"");
        setDataSource(""MultiLangPerso_1PID_PC0_Select_AC4_H265_DVB_50fps_Audio_Only.ts"");
        int ac4TrackIndex = -1;
        for (int i = 0; i < mExtractor.getTrackCount(); i++) {
            MediaFormat format = mExtractor.getTrackFormat(i);
            String mime = format.getString(MediaFormat.KEY_MIME);
            if (MediaFormat.MIMETYPE_AUDIO_AC4.equals(mime)) {
                ac4TrackIndex = i;
                break;
            }
        }

        // Not all devices support AC4.
        if (ac4TrackIndex == -1) {
            List<AudioPresentation> presentations =
                    mExtractor.getAudioPresentations(0 /*trackIndex*/);
            assertNotNull(presentations);
            assertTrue(presentations.isEmpty());
            return;
        }

        // The test file has two sets of audio presentations. The presentation set
        // changes for every 100 audio presentation descriptors between two presentations.
        // Instead of attempting to count the presentation descriptors, the test assumes
        // a particular order of the presentations and advances to the next reference set
        // once getAudioPresentations returns a set that doesn't match the current reference set.
        // Thus the test can match the set 0 several times, then it encounters set 1,
        // advances the reference set index, matches set 1 until it encounters set 2 etc.
        // At the end it verifies that all the reference sets were met.
        List<Map<Integer, AudioPresentation>> refPresentations = Arrays.asList(
                new HashMap<Integer, AudioPresentation>() {{  // First set.
                    put(10, new AudioPresentation.Builder(10)
                            .setLocale(ULocale.ENGLISH)
                            .setMasteringIndication(AudioPresentation.MASTERED_FOR_SURROUND)
                            .setHasDialogueEnhancement(true)
                            .build());
                    put(11, new AudioPresentation.Builder(11)
                            .setLocale(ULocale.ENGLISH)
                            .setMasteringIndication(AudioPresentation.MASTERED_FOR_SURROUND)
                            .setHasAudioDescription(true)
                            .setHasDialogueEnhancement(true)
                            .build());
                    put(12, new AudioPresentation.Builder(12)
                            .setLocale(ULocale.FRENCH)
                            .setMasteringIndication(AudioPresentation.MASTERED_FOR_SURROUND)
                            .setHasDialogueEnhancement(true)
                            .build());
                }},
                new HashMap<Integer, AudioPresentation>() {{  // Second set.
                    put(10, new AudioPresentation.Builder(10)
                            .setLocale(ULocale.GERMAN)
                            .setMasteringIndication(AudioPresentation.MASTERED_FOR_SURROUND)
                            .setHasAudioDescription(true)
                            .setHasDialogueEnhancement(true)
                            .build());
                    put(11, new AudioPresentation.Builder(11)
                            .setLocale(new ULocale(""es""))
                            .setMasteringIndication(AudioPresentation.MASTERED_FOR_SURROUND)
                            .setHasSpokenSubtitles(true)
                            .setHasDialogueEnhancement(true)
                            .build());
                    put(12, new AudioPresentation.Builder(12)
                            .setLocale(ULocale.ENGLISH)
                            .setMasteringIndication(AudioPresentation.MASTERED_FOR_SURROUND)
                            .setHasDialogueEnhancement(true)
                            .build());
                }},
                null,
                null
        );
        refPresentations.set(2, refPresentations.get(0));
        refPresentations.set(3, refPresentations.get(1));
        boolean[] presentationsMatched = new boolean[refPresentations.size()];
        mExtractor.selectTrack(ac4TrackIndex);
        for (int i = 0; i < refPresentations.size(); ) {
            List<AudioPresentation> presentations = mExtractor.getAudioPresentations(ac4TrackIndex);
            assertNotNull(presentations);
            // Assumes all presentation sets have the same number of presentations.
            assertEquals(refPresentations.get(i).size(), presentations.size());
            if (!audioPresentationSetMatchesReference(refPresentations.get(i), presentations)) {
                    // Time to advance to the next presentation set.
                    i++;
                    continue;
            }
            Log.d(TAG, ""Matched presentation "" + i);
            presentationsMatched[i] = true;
            // No need to wait for another switch after the last presentation has been matched.
            if (i == presentationsMatched.length - 1 || !mExtractor.advance()) {
                break;
            }
        }
        for (int i = 0; i < presentationsMatched.length; i++) {
            assertTrue(""Presentation set "" + i + "" was not found in the stream"",
                    presentationsMatched[i]);
        }
    }

    @AppModeFull(reason = ""Instant apps cannot bind sockets."")
    public void SKIP_testExtractorGetCachedDuration() throws Exception {
        // duplicate of CtsMediaV2TestCases:ExtractorTest$SetDataSourceTest#testUrlDataSource
        CtsTestServer foo = new CtsTestServer(getContext());
        String url = foo.getAssetUrl(""ringer.mp3"");
        mExtractor.setDataSource(url);
        long cachedDurationUs = mExtractor.getCachedDuration();
        assertTrue(""cached duration should be non-negative"", cachedDurationUs >= 0);
        foo.shutdown();
    }

    public void SKIP_testExtractorHasCacheReachedEndOfStream() throws Exception {
        // duplicate of CtsMediaV2TestCases:ExtractorTest$SetDataSourceTest#testUrlDataSource
        // Using file source to get deterministic result.
        AssetFileDescriptor afd = getAssetFileDescriptorFor(""testvideo.3gp"");
        mExtractor.setDataSource(afd);
        assertTrue(mExtractor.hasCacheReachedEndOfStream());
        afd.close();
    }

    /*
     * Makes sure if PTS(order) of a video file with BFrames matches the expected values in
     * the corresponding text file with just PTS values.
     */
    public void SKIP_testVideoPresentationTimeStampsMatch() throws Exception {
        // duplicate of CtsMediaV2TestCases:ExtractorTest$ExtractorTimeStampTest
        setDataSource(""binary_counter_320x240_30fps_600frames.mp4"");
        // Select the only video track present in the file.
        final int trackCount = mExtractor.getTrackCount();
        for (int i = 0; i < trackCount; i++) {
            mExtractor.selectTrack(i);
        }

        Reader txtRdr = new BufferedReader(new InputStreamReader(new FileInputStream(
                mInpPrefix + ""timestamps_binary_counter_320x240_30fps_600frames.txt"")));
        StreamTokenizer strTok = new StreamTokenizer(txtRdr);
        strTok.parseNumbers();

        boolean srcAdvance = false;
        long srcSampleTimeUs = -1;
        long testSampleTimeUs = -1;

        strTok.nextToken();
        do {
            srcSampleTimeUs = mExtractor.getSampleTime();
            testSampleTimeUs = (long) strTok.nval;

            // Ignore round-off error if any.
            if (Math.abs(srcSampleTimeUs - testSampleTimeUs) > 1) {
                Log.d(TAG, ""srcSampleTimeUs:"" + srcSampleTimeUs + "" testSampleTimeUs:"" +
                        testSampleTimeUs);
                fail(""video presentation timestamp not equal"");
            }

            srcAdvance = mExtractor.advance();
            strTok.nextToken();
        } while (srcAdvance);
    }

    /* package */ static class ByteBufferDataSource extends MediaDataSource {
        private final long mSize;
        private TreeMap<Long, ByteBuffer> mMap = new TreeMap<Long, ByteBuffer>();

        public ByteBufferDataSource(MediaCodecTest.ByteBufferStream bufferStream)
                throws IOException {
            long size = 0;
            while (true) {
                final ByteBuffer buffer = bufferStream.read();
                if (buffer == null) break;
                final int limit = buffer.limit();
                if (limit == 0) continue;
                size += limit;
                mMap.put(size - 1, buffer); // key: last byte of validity for the buffer.
            }
            mSize = size;
        }

        @Override
        public long getSize() {
            return mSize;
        }

        @Override
        public int readAt(long position, byte[] buffer, int offset, int size) {
            Log.v(TAG, ""reading at "" + position + "" offset "" + offset + "" size "" + size);

            // This chooses all buffers with key >= position (e.g. valid buffers)
            final SortedMap<Long, ByteBuffer> map = mMap.tailMap(position);
            int copied = 0;
            for (Map.Entry<Long, ByteBuffer> e : map.entrySet()) {
                // Get a read-only version of the byte buffer.
                final ByteBuffer bb = e.getValue().asReadOnlyBuffer();
                // Convert read position to an offset within that byte buffer, bboffs.
                final long bboffs = position - e.getKey() + bb.limit() - 1;
                if (bboffs >= bb.limit() || bboffs < 0) {
                    break; // (negative position)?
                }
                bb.position((int)bboffs); // cast is safe as bb.limit is int.
                final int tocopy = Math.min(size, bb.remaining());
                if (tocopy == 0) {
                    break; // (size == 0)?
                }
                bb.get(buffer, offset, tocopy);
                copied += tocopy;
                size -= tocopy;
                offset += tocopy;
                position += tocopy;
                if (size == 0) {
                    break; // finished copying.
                }
            }
            if (copied == 0) {
                copied = -1;  // signal end of file
            }
            return copied;
        }

        @Override
        public void close() {
            mMap = null;
        }
    }

    /* package */ static class MediaExtractorStream
                extends MediaCodecTest.ByteBufferStream implements Closeable {
        public boolean mIsFloat;
        public boolean mSawOutputEOS;
        public MediaFormat mFormat;

        private MediaExtractor mExtractor;
        private MediaCodecTest.MediaCodecStream mDecoderStream;

        public MediaExtractorStream(
                String inMime, String outMime,
                MediaDataSource dataSource) throws Exception {
            mExtractor = new MediaExtractor();
            mExtractor.setDataSource(dataSource);
            final int numTracks = mExtractor.getTrackCount();
            // Single track?
            // assertEquals(""Number of tracks should be 1"", 1, numTracks);
            for (int i = 0; i < numTracks; ++i) {
                final MediaFormat format = mExtractor.getTrackFormat(i);
                final String actualMime = format.getString(MediaFormat.KEY_MIME);
                mExtractor.selectTrack(i);
                mFormat = format;
                if (outMime.equals(actualMime)) {
                    break;
                } else { // no matching mime, try to use decoder
                    mDecoderStream = new MediaCodecTest.MediaCodecStream(
                            mExtractor, mFormat);
                    Log.w(TAG, ""fallback to input mime type with decoder"");
                }
            }
            assertNotNull(""MediaExtractor cannot find mime type "" + inMime, mFormat);
            mIsFloat = mFormat.getInteger(
                    MediaFormat.KEY_PCM_ENCODING, AudioFormat.ENCODING_PCM_16BIT)
                            == AudioFormat.ENCODING_PCM_FLOAT;
        }

        public MediaExtractorStream(
                String inMime, String outMime,
                MediaCodecTest.ByteBufferStream inputStream) throws Exception {
            this(inMime, outMime, new ByteBufferDataSource(inputStream));
        }

        @Override
        public ByteBuffer read() throws IOException {
            if (mSawOutputEOS) {
                return null;
            }
            if (mDecoderStream != null) {
                return mDecoderStream.read();
            }
            // To preserve codec-like behavior, we create ByteBuffers
            // equal to the media sample size.
            final long size = mExtractor.getSampleSize();
            if (size >= 0) {
                final ByteBuffer inputBuffer = ByteBuffer.allocate((int)size);
                final int red = mExtractor.readSampleData(inputBuffer, 0 /* offset */); // sic
                if (red >= 0) {
                    assertEquals(""position must be zero"", 0, inputBuffer.position());
                    assertEquals(""limit must be read bytes"", red, inputBuffer.limit());
                    mExtractor.advance();
                    return inputBuffer;
                }
            }
            mSawOutputEOS = true;
            return null;
        }

        @Override
        public void close() throws IOException {
            if (mExtractor != null) {
                mExtractor.release();
                mExtractor = null;
            }
            mFormat = null;
        }

        @Override
        protected void finalize() throws Throwable {
            if (mExtractor != null) {
                Log.w(TAG, ""MediaExtractorStream wasn't closed"");
                mExtractor.release();
            }
            mFormat = null;
        }
    }

    @SmallTest
    public void SKIP_testFlacIdentity() throws Exception {
        // duplicate of CtsMediaV2TestCases:CodecEncoderTest$testLosslessEncodeDecode[audio/flac]
        // duplicate of CtsMediaV2TestCases:ExtractorTest$FusedExtractorDecoderTest[audio/flac]
        final int PCM_FRAMES = 1152 * 4; // FIXME: requires 4 flac frames to work with OMX codecs.
        final int CHANNEL_COUNT = 2;
        final int SAMPLES = PCM_FRAMES * CHANNEL_COUNT;
        final int[] SAMPLE_RATES = {44100, 192000}; // ensure 192kHz supported.

        for (int sampleRate : SAMPLE_RATES) {
            final MediaFormat format = new MediaFormat();
            format.setString(MediaFormat.KEY_MIME, MediaFormat.MIMETYPE_AUDIO_FLAC);
            format.setInteger(MediaFormat.KEY_SAMPLE_RATE, sampleRate);
            format.setInteger(MediaFormat.KEY_CHANNEL_COUNT, CHANNEL_COUNT);

            Log.d(TAG, ""Trying sample rate: "" + sampleRate
                    + "" channel count: "" + CHANNEL_COUNT);
            format.setInteger(MediaFormat.KEY_FLAC_COMPRESSION_LEVEL, 5);

            // TODO: Add float mode when MediaExtractor supports float configuration.
            final MediaCodecTest.PcmAudioBufferStream audioStream =
                    new MediaCodecTest.PcmAudioBufferStream(
                            SAMPLES, sampleRate, 1000 /* frequency */, 100 /* sweep */,
                          false /* useFloat */);

            final MediaCodecTest.MediaCodecStream rawToFlac =
                    new MediaCodecTest.MediaCodecStream(
                            new MediaCodecTest.ByteBufferInputStream(audioStream),
                            format, true /* encode */);
            final MediaExtractorStream flacToRaw =
                    new MediaExtractorStream(MediaFormat.MIMETYPE_AUDIO_FLAC /* inMime */,
                            MediaFormat.MIMETYPE_AUDIO_RAW /* outMime */, rawToFlac);

            // Note: the existence of signed zero (as well as NAN) may make byte
            // comparisons invalid for floating point output. In our case, since the
            // floats come through integer to float conversion, it does not matter.
            assertEquals(""Audio data not identical after compression"",
                audioStream.sizeInBytes(),
                MediaCodecTest.compareStreams(new MediaCodecTest.ByteBufferInputStream(flacToRaw),
                    new MediaCodecTest.ByteBufferInputStream(
                            new MediaCodecTest.PcmAudioBufferStream(audioStream))));
        }
    }

    public void SKIP_testFlacMovExtraction() throws Exception {
        // duplicate of CtsMediaV2TestCases:ExtractorTest$FusedExtractorDecoderTest[audio/flac]
        AssetFileDescriptor testFd = getAssetFileDescriptorFor(""sinesweepalac.mov"");
        MediaExtractor extractor = new MediaExtractor();
        extractor.setDataSource(testFd.getFileDescriptor(), testFd.getStartOffset(),
                testFd.getLength());
        testFd.close();
        extractor.selectTrack(0);
        boolean lastAdvanceResult = true;
        boolean lastReadResult = true;
        ByteBuffer buf = ByteBuffer.allocate(2*1024*1024);
        int totalSize = 0;
        while(true) {
            int n = extractor.readSampleData(buf, 0);
            if (n > 0) {
                totalSize += n;
            }
            if (!extractor.advance()) {
                break;
            }
        }
        assertTrue(""could not read alac mov"", totalSize > 0);
    }"	""	""	"RCS"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.cts.TelephonyCallbackTest"	"testOnBarringInfoChangedByRegisterTelephonyCallback"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyCallbackTest.java"	""	"public void testOnBarringInfoChangedByRegisterTelephonyCallback() throws Throwable {
        if (mCm.getNetworkInfo(ConnectivityManager.TYPE_MOBILE) == null) {
            Log.d(TAG, ""Skipping test that requires ConnectivityManager.TYPE_MOBILE"");
            return;
        }

        assertFalse(mOnBarringInfoChangedCalled);
        mHandler.post(() -> {
            mBarringInfoCallback = new BarringInfoListener();
            registerTelephonyCallbackWithPermission(mBarringInfoCallback);
        });

        synchronized (mLock) {
            if (!mOnBarringInfoChangedCalled) {
                mLock.wait(WAIT_TIME);
            }
        }
        assertTrue(mOnBarringInfoChangedCalled);

        assertBarringInfoSane(mBarringInfo);

        // Test unregister
        unRegisterTelephonyCallback(mOnBarringInfoChangedCalled, mBarringInfoCallback);
    }

    private static final int[] sBarringServiceInfoTypes = new int[]{
            BarringInfo.BARRING_SERVICE_TYPE_CS_SERVICE,
            BarringInfo.BARRING_SERVICE_TYPE_PS_SERVICE,
            BarringInfo.BARRING_SERVICE_TYPE_CS_VOICE,
            BarringInfo.BARRING_SERVICE_TYPE_MO_SIGNALLING,
            BarringInfo.BARRING_SERVICE_TYPE_MO_DATA,
            BarringInfo.BARRING_SERVICE_TYPE_CS_FALLBACK,
            BarringInfo.BARRING_SERVICE_TYPE_MMTEL_VOICE,
            BarringInfo.BARRING_SERVICE_TYPE_MMTEL_VIDEO,
            BarringInfo.BARRING_SERVICE_TYPE_EMERGENCY,
            BarringInfo.BARRING_SERVICE_TYPE_SMS
    };

    private static void assertBarringInfoSane(BarringInfo barringInfo) {
        assertNotNull(barringInfo);

        // Flags to track whether we have had unknown and known barring types reported
        boolean hasBarringTypeUnknown = false;
        boolean hasBarringTypeKnown = false;

        for (int bsiType : sBarringServiceInfoTypes) {
            BarringInfo.BarringServiceInfo bsi = barringInfo.getBarringServiceInfo(bsiType);
            assertNotNull(bsi);
            switch (bsi.getBarringType()) {
                case BarringInfo.BarringServiceInfo.BARRING_TYPE_UNKNOWN:
                    hasBarringTypeUnknown = true;
                    assertFalse(bsi.isConditionallyBarred());
                    assertEquals(0, bsi.getConditionalBarringFactor());
                    assertEquals(0, bsi.getConditionalBarringTimeSeconds());
                    assertFalse(bsi.isBarred());
                    break;

                case BarringInfo.BarringServiceInfo.BARRING_TYPE_NONE:
                    hasBarringTypeKnown = true;
                    // Unless conditional barring is active, all conditional barring fields
                    // should be ""unset"".
                    assertFalse(bsi.isConditionallyBarred());
                    assertEquals(0, bsi.getConditionalBarringFactor());
                    assertEquals(0, bsi.getConditionalBarringTimeSeconds());
                    assertFalse(bsi.isBarred());
                    break;

                case BarringInfo.BarringServiceInfo.BARRING_TYPE_UNCONDITIONAL:
                    hasBarringTypeKnown = true;
                    // Unless conditional barring is active, all conditional barring fields
                    // should be ""unset"".
                    assertFalse(bsi.isConditionallyBarred());
                    assertEquals(0, bsi.getConditionalBarringFactor());
                    assertEquals(0, bsi.getConditionalBarringTimeSeconds());
                    assertTrue(bsi.isBarred());
                    break;

                case BarringInfo.BarringServiceInfo.BARRING_TYPE_CONDITIONAL:
                    hasBarringTypeKnown = true;
                    // If conditional barring is active, then the barring time and factor must
                    // be known (set), but the device may or may not be barred at the moment,
                    // so isConditionallyBarred() can be either true or false (hence not checked).
                    assertNotEquals(0, bsi.getConditionalBarringFactor());
                    assertNotEquals(0, bsi.getConditionalBarringTimeSeconds());
                    assertEquals(bsi.isBarred(), bsi.isConditionallyBarred());
                    break;
            }
        }
        // If any barring type is unknown, then barring is not supported so all must be
        // unknown. If any type is known, then all that are not reported are assumed to
        // be not barred.
        assertNotEquals(hasBarringTypeUnknown, hasBarringTypeKnown);
    }

    private RegistrationFailedListener mRegistrationFailedCallback;

    private class RegistrationFailedListener extends TelephonyCallback
            implements TelephonyCallback.RegistrationFailedListener {
        @Override
        public void onRegistrationFailed(CellIdentity cid, String chosenPlmn,
                                         int domain, int causeCode, int additionalCauseCode) {
            synchronized (mLock) {
                mOnRegistrationFailedCalled = true;
                mLock.notify();
            }
        }
    }"	""	""	"MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.media.cts.MediaMuxerTest"	"testTimestampsStartOffsetNegativeAudioVideo"	"CtsMediaTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/MediaMuxerTest.java"	""	"public void testTimestampsStartOffsetNegativeAudioVideo() throws Exception {
        if (!MediaUtils.check(mAndroid11, ""test needs Android 11"")) return;

        Vector<Integer> startOffsetUsVect = new Vector<Integer>();
        // Video starts at 50000us.
        startOffsetUsVect.add(50000);
        // Audio starts at -23220us, multiple of duration of one frame (1024/44100hz)
        startOffsetUsVect.add(-23220);
        checkTimestampsWithStartOffsets(startOffsetUsVect);
    }

    /**
     * Test: makes sure if audio/video muxing using MPEG4Writer works with B Frames
     * when video and audio samples start after different times.
     */
    private void checkTimestampsAudioBVideoDiffStartOffsets(Vector<Integer> startOffsetUs)
            throws Exception {
        MPEG4CheckTimestampsAudioBVideoDiffStartOffsets(startOffsetUs);
        // TODO: uncomment webm testing once bugs related to timestamps in webmwriter are fixed.
        // WebMCheckTimestampsAudioBVideoDiffStartOffsets(startOffsetUsVect);
    }

    private void MPEG4CheckTimestampsAudioBVideoDiffStartOffsets(Vector<Integer> startOffsetUs)
            throws Exception {
        if (VERBOSE) {
            Log.v(TAG, ""MPEG4CheckTimestampsAudioBVideoDiffStartOffsets"");
        }
        final String source = ""video_h264_main_b_frames.mp4"";
        String outputFilePath = File.createTempFile(
            ""MediaMuxerTest_testTimestampsAudioBVideoDiffStartOffsets"", "".mp4"").getAbsolutePath();
        try {
            cloneMediaWithSamplesDropAndStartOffsets(source, outputFilePath,
                MediaMuxer.OutputFormat.MUXER_OUTPUT_MPEG_4, null, startOffsetUs);
            verifyTSWithSamplesDropAndStartOffset(
                    source, true /* has B frames */, outputFilePath, null, startOffsetUs);
        } finally {
            new File(outputFilePath).delete();
        }
    }

    /*
     * Check if timestamps are written consistently across all formats supported by MediaMuxer.
     */
    private void checkTimestampsWithStartOffsets(Vector<Integer> startOffsetUsVect)
            throws Exception {
        MPEG4CheckTimestampsWithStartOffsets(startOffsetUsVect);
        // TODO: uncomment webm testing once bugs related to timestamps in webmwriter are fixed.
        // WebMCheckTimestampsWithStartOffsets(startOffsetUsVect);
        // TODO: need to add other formats, OGG, AAC, AMR
    }

    /**
     * Make sure if audio/video muxing using MPEG4Writer works good with different start
     * offsets for audio and video.
     */
    private void MPEG4CheckTimestampsWithStartOffsets(Vector<Integer> startOffsetUsVect)
            throws Exception {
        if (VERBOSE) {
            Log.v(TAG, ""MPEG4CheckTimestampsWithStartOffsets"");
        }
        final String source = ""video_480x360_mp4_h264_500kbps_30fps_aac_stereo_128kbps_44100hz.mp4"";
        String outputFilePath =
            File.createTempFile(""MediaMuxerTest_MPEG4CheckTimestampsWithStartOffsets"", "".mp4"")
                .getAbsolutePath();
        try {
            cloneMediaWithSamplesDropAndStartOffsets(source, outputFilePath,
                    MediaMuxer.OutputFormat.MUXER_OUTPUT_MPEG_4, null, startOffsetUsVect);
            verifyTSWithSamplesDropAndStartOffset(
                    source, false /* no B frames */, outputFilePath, null, startOffsetUsVect);
        } finally {
            new File(outputFilePath).delete();
        }
    }

    /**
     * Make sure if audio/video muxing using WebMWriter works good with different start
     * offsets for audio and video.
     */
    private void WebMCheckTimestampsWithStartOffsets(Vector<Integer> startOffsetUsVect)
            throws Exception {
        if (VERBOSE) {
            Log.v(TAG, ""WebMCheckTimestampsWithStartOffsets"");
        }
        final String source =
                ""video_480x360_webm_vp9_333kbps_25fps_vorbis_stereo_128kbps_48000hz.webm"";
        String outputFilePath =
            File.createTempFile(""MediaMuxerTest_WebMCheckTimestampsWithStartOffsets"", "".webm"")
                .getAbsolutePath();
        try {
            cloneMediaWithSamplesDropAndStartOffsets(source, outputFilePath,
                    MediaMuxer.OutputFormat.MUXER_OUTPUT_WEBM, null, startOffsetUsVect);
            verifyTSWithSamplesDropAndStartOffset(
                    source, false /* no B frames */, outputFilePath, null, startOffsetUsVect);
        } finally {
            new File(outputFilePath).delete();
        }
    }

    /**
     * Clones a media file and then compares against the source file to make
     * sure they match.
     */
    private void cloneAndVerify(final String srcMedia, String outputMediaFile,
            int expectedTrackCount, int degrees, int fmt) throws IOException {
        try {
            cloneMediaUsingMuxer(srcMedia, outputMediaFile, expectedTrackCount,
                    degrees, fmt);
            if (fmt == MediaMuxer.OutputFormat.MUXER_OUTPUT_MPEG_4 ||
                    fmt == MediaMuxer.OutputFormat.MUXER_OUTPUT_3GPP) {
                verifyAttributesMatch(srcMedia, outputMediaFile, degrees);
                verifyLocationInFile(outputMediaFile);
            }
            // Verify timestamp of all samples.
            verifyTSWithSamplesDropAndStartOffset(
                    srcMedia, false /* no B frames */,outputMediaFile, null, null);
        } finally {
            new File(outputMediaFile).delete();
        }
    }

    /**
     * Using the MediaMuxer to clone a media file.
     */
    private void cloneMediaUsingMuxer(final String  srcMedia, String dstMediaPath,
            int expectedTrackCount, int degrees, int fmt)
            throws IOException {
        // Set up MediaExtractor to read from the source.
        AssetFileDescriptor srcFd = getAssetFileDescriptorFor(srcMedia);
        MediaExtractor extractor = new MediaExtractor();
        extractor.setDataSource(srcFd.getFileDescriptor(), srcFd.getStartOffset(),
                srcFd.getLength());

        int trackCount = extractor.getTrackCount();
        assertEquals(""wrong number of tracks"", expectedTrackCount, trackCount);

        // Set up MediaMuxer for the destination.
        MediaMuxer muxer;
        muxer = new MediaMuxer(dstMediaPath, fmt);

        // Set up the tracks.
        HashMap<Integer, Integer> indexMap = new HashMap<Integer, Integer>(trackCount);
        for (int i = 0; i < trackCount; i++) {
            extractor.selectTrack(i);
            MediaFormat format = extractor.getTrackFormat(i);
            int dstIndex = muxer.addTrack(format);
            indexMap.put(i, dstIndex);
        }

        // Copy the samples from MediaExtractor to MediaMuxer.
        boolean sawEOS = false;
        int bufferSize = MAX_SAMPLE_SIZE;
        int frameCount = 0;
        int offset = 100;

        ByteBuffer dstBuf = ByteBuffer.allocate(bufferSize);
        BufferInfo bufferInfo = new BufferInfo();

        if (degrees >= 0) {
            muxer.setOrientationHint(degrees);
        }

        if (fmt == MediaMuxer.OutputFormat.MUXER_OUTPUT_MPEG_4 ||
            fmt == MediaMuxer.OutputFormat.MUXER_OUTPUT_3GPP) {
            // Test setLocation out of bound cases
            try {
                muxer.setLocation(BAD_LATITUDE, LONGITUDE);
                fail(""setLocation succeeded with bad argument: ["" + BAD_LATITUDE + "","" + LONGITUDE
                    + ""]"");
            } catch (IllegalArgumentException e) {
                // Expected
            }
            try {
                muxer.setLocation(LATITUDE, BAD_LONGITUDE);
                fail(""setLocation succeeded with bad argument: ["" + LATITUDE + "","" + BAD_LONGITUDE
                    + ""]"");
            } catch (IllegalArgumentException e) {
                // Expected
            }

            muxer.setLocation(LATITUDE, LONGITUDE);
        }

        muxer.start();
        while (!sawEOS) {
            bufferInfo.offset = offset;
            bufferInfo.size = extractor.readSampleData(dstBuf, offset);

            if (bufferInfo.size < 0) {
                if (VERBOSE) {
                    Log.d(TAG, ""saw input EOS."");
                }
                sawEOS = true;
                bufferInfo.size = 0;
            } else {
                bufferInfo.presentationTimeUs = extractor.getSampleTime();
                bufferInfo.flags = extractor.getSampleFlags();
                int trackIndex = extractor.getSampleTrackIndex();

                muxer.writeSampleData(indexMap.get(trackIndex), dstBuf,
                        bufferInfo);
                extractor.advance();

                frameCount++;
                if (VERBOSE) {
                    Log.d(TAG, ""Frame ("" + frameCount + "") "" +
                            ""PresentationTimeUs:"" + bufferInfo.presentationTimeUs +
                            "" Flags:"" + bufferInfo.flags +
                            "" TrackIndex:"" + trackIndex +
                            "" Size(KB) "" + bufferInfo.size / 1024);
                }
            }
        }

        muxer.stop();
        muxer.release();
        extractor.release();
        srcFd.close();
        return;
    }

    /**
     * Compares some attributes using MediaMetadataRetriever to make sure the
     * cloned media file matches the source file.
     */
    private void verifyAttributesMatch(final String srcMedia, String testMediaPath,
            int degrees) throws IOException {
        AssetFileDescriptor testFd = getAssetFileDescriptorFor(srcMedia);

        MediaMetadataRetriever retrieverSrc = new MediaMetadataRetriever();
        retrieverSrc.setDataSource(testFd.getFileDescriptor(),
                testFd.getStartOffset(), testFd.getLength());

        MediaMetadataRetriever retrieverTest = new MediaMetadataRetriever();
        retrieverTest.setDataSource(testMediaPath);

        String testDegrees = retrieverTest.extractMetadata(
                MediaMetadataRetriever.METADATA_KEY_VIDEO_ROTATION);
        if (testDegrees != null) {
            assertEquals(""Different degrees"", degrees,
                    Integer.parseInt(testDegrees));
        }

        String heightSrc = retrieverSrc.extractMetadata(
                MediaMetadataRetriever.METADATA_KEY_VIDEO_HEIGHT);
        String heightTest = retrieverTest.extractMetadata(
                MediaMetadataRetriever.METADATA_KEY_VIDEO_HEIGHT);
        assertEquals(""Different height"", heightSrc,
                heightTest);

        String widthSrc = retrieverSrc.extractMetadata(
                MediaMetadataRetriever.METADATA_KEY_VIDEO_WIDTH);
        String widthTest = retrieverTest.extractMetadata(
                MediaMetadataRetriever.METADATA_KEY_VIDEO_WIDTH);
        assertEquals(""Different width"", widthSrc,
                widthTest);

        //TODO: need to check each individual track's duration also.
        String durationSrc = retrieverSrc.extractMetadata(
                MediaMetadataRetriever.METADATA_KEY_DURATION);
        String durationTest = retrieverTest.extractMetadata(
                MediaMetadataRetriever.METADATA_KEY_DURATION);
        assertEquals(""Different duration"", durationSrc,
                durationTest);

        retrieverSrc.release();
        retrieverTest.release();
        testFd.close();
    }

    private void verifyLocationInFile(String fileName) {
        MediaMetadataRetriever retriever = new MediaMetadataRetriever();
        retriever.setDataSource(fileName);
        String location = retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_LOCATION);
        assertNotNull(""No location information found in file "" + fileName, location);


        // parsing String location and recover the location information in floats
        // Make sure the tolerance is very small - due to rounding errors.

        // Trim the trailing slash, if any.
        int lastIndex = location.lastIndexOf('/');
        if (lastIndex != -1) {
            location = location.substring(0, lastIndex);
        }

        // Get the position of the -/+ sign in location String, which indicates
        // the beginning of the longitude.
        int minusIndex = location.lastIndexOf('-');
        int plusIndex = location.lastIndexOf('+');

        assertTrue(""+ or - is not found or found only at the beginning ["" + location + ""]"",
                (minusIndex > 0 || plusIndex > 0));
        int index = Math.max(minusIndex, plusIndex);

        float latitude = Float.parseFloat(location.substring(0, index));
        float longitude = Float.parseFloat(location.substring(index));
        assertTrue(""Incorrect latitude: "" + latitude + "" ["" + location + ""]"",
                Math.abs(latitude - LATITUDE) <= TOLERANCE);
        assertTrue(""Incorrect longitude: "" + longitude + "" ["" + location + ""]"",
                Math.abs(longitude - LONGITUDE) <= TOLERANCE);
        retriever.release();
    }

    /**
     * Uses 2 MediaExtractor, seeking to the same position, reads the sample and
     * makes sure the samples match.
     */
    private void verifySamplesMatch(final String srcMedia, String testMediaPath, int seekToUs,
            long offsetTimeUs) throws IOException {
        AssetFileDescriptor testFd = getAssetFileDescriptorFor(srcMedia);
        MediaExtractor extractorSrc = new MediaExtractor();
        extractorSrc.setDataSource(testFd.getFileDescriptor(),
                testFd.getStartOffset(), testFd.getLength());
        int trackCount = extractorSrc.getTrackCount();
        final int videoTrackIndex = 0;

        MediaExtractor extractorTest = new MediaExtractor();
        extractorTest.setDataSource(testMediaPath);

        assertEquals(""wrong number of tracks"", trackCount,
                extractorTest.getTrackCount());

        // Make sure the format is the same and select them
        for (int i = 0; i < trackCount; i++) {
            MediaFormat formatSrc = extractorSrc.getTrackFormat(i);
            MediaFormat formatTest = extractorTest.getTrackFormat(i);

            String mimeIn = formatSrc.getString(MediaFormat.KEY_MIME);
            String mimeOut = formatTest.getString(MediaFormat.KEY_MIME);
            if (!(mimeIn.equals(mimeOut))) {
                fail(""format didn't match on track No."" + i +
                        formatSrc.toString() + ""\n"" + formatTest.toString());
            }
            extractorSrc.selectTrack(videoTrackIndex);
            extractorTest.selectTrack(videoTrackIndex);

            // Pick a time and try to compare the frame.
            extractorSrc.seekTo(seekToUs, MediaExtractor.SEEK_TO_CLOSEST_SYNC);
            extractorTest.seekTo(seekToUs + offsetTimeUs, MediaExtractor.SEEK_TO_CLOSEST_SYNC);

            int bufferSize = MAX_SAMPLE_SIZE;
            ByteBuffer byteBufSrc = ByteBuffer.allocate(bufferSize);
            ByteBuffer byteBufTest = ByteBuffer.allocate(bufferSize);

            int srcBufSize = extractorSrc.readSampleData(byteBufSrc, 0);
            int testBufSize = extractorTest.readSampleData(byteBufTest, 0);

            if (!(byteBufSrc.equals(byteBufTest))) {
                if (VERBOSE) {
                    Log.d(TAG,
                            ""srcTrackIndex:"" + extractorSrc.getSampleTrackIndex()
                                    + ""  testTrackIndex:"" + extractorTest.getSampleTrackIndex());
                    Log.d(TAG,
                            ""srcTSus:"" + extractorSrc.getSampleTime()
                                    + "" testTSus:"" + extractorTest.getSampleTime());
                    Log.d(TAG, ""srcBufSize:"" + srcBufSize + ""testBufSize:"" + testBufSize);
                }
                fail(""byteBuffer didn't match"");
            }
            extractorSrc.unselectTrack(i);
            extractorTest.unselectTrack(i);
        }
        extractorSrc.release();
        extractorTest.release();
        testFd.close();
    }

    /**
     * Using MediaMuxer and MediaExtractor to mux a media file from another file while skipping
     * some video frames as in the issues b/63590381 and b/64949961.
     */
    private void simulateVideoFramesDropIssuesAndMux(final String srcMedia, String dstMediaPath,
            int expectedTrackCount, int fmt) throws IOException {
        // Set up MediaExtractor to read from the source.
        AssetFileDescriptor srcFd = getAssetFileDescriptorFor(srcMedia);
        MediaExtractor extractor = new MediaExtractor();
        extractor.setDataSource(srcFd.getFileDescriptor(), srcFd.getStartOffset(),
            srcFd.getLength());

        int trackCount = extractor.getTrackCount();
        assertEquals(""wrong number of tracks"", expectedTrackCount, trackCount);

        // Set up MediaMuxer for the destination.
        MediaMuxer muxer;
        muxer = new MediaMuxer(dstMediaPath, fmt);

        // Set up the tracks.
        HashMap<Integer, Integer> indexMap = new HashMap<Integer, Integer>(trackCount);

        for (int i = 0; i < trackCount; i++) {
            extractor.selectTrack(i);
            MediaFormat format = extractor.getTrackFormat(i);
            int dstIndex = muxer.addTrack(format);
            indexMap.put(i, dstIndex);
        }

        // Copy the samples from MediaExtractor to MediaMuxer.
        boolean sawEOS = false;
        int bufferSize = MAX_SAMPLE_SIZE;
        int sampleCount = 0;
        int offset = 0;
        int videoSampleCount = 0;
        // Counting frame index values starting from 1
        final int muxAllTypeVideoFramesUntilIndex = 136; // I/P/B frames passed as it is until this
        final int muxAllTypeVideoFramesFromIndex = 171; // I/P/B frames passed as it is from this
        final int pFrameBeforeARandomBframeIndex = 137;
        final int bFrameAfterPFrameIndex = pFrameBeforeARandomBframeIndex+1;

        ByteBuffer dstBuf = ByteBuffer.allocate(bufferSize);
        BufferInfo bufferInfo = new BufferInfo();

        muxer.start();
        while (!sawEOS) {
            bufferInfo.offset = 0;
            bufferInfo.size = extractor.readSampleData(dstBuf, offset);
            if (bufferInfo.size < 0) {
                if (VERBOSE) {
                    Log.d(TAG, ""saw input EOS."");
                }
                sawEOS = true;
                bufferInfo.size = 0;
            } else {
                bufferInfo.presentationTimeUs = extractor.getSampleTime();
                bufferInfo.flags = extractor.getSampleFlags();
                int trackIndex = extractor.getSampleTrackIndex();
                // Video track at index 0, skip some video frames while muxing.
                if (trackIndex == 0) {
                    ++videoSampleCount;
                    if (VERBOSE) {
                        Log.v(TAG, ""videoSampleCount : "" + videoSampleCount);
                    }
                    if (videoSampleCount <= muxAllTypeVideoFramesUntilIndex
                            || videoSampleCount == bFrameAfterPFrameIndex) {
                        // Write frame as it is.
                        muxer.writeSampleData(indexMap.get(trackIndex), dstBuf, bufferInfo);
                    } else if (videoSampleCount == pFrameBeforeARandomBframeIndex
                            || videoSampleCount >= muxAllTypeVideoFramesFromIndex) {
                        // Adjust time stamp for this P frame to a few frames later, say ~5seconds
                        bufferInfo.presentationTimeUs += OFFSET_TIME_US;
                        muxer.writeSampleData(indexMap.get(trackIndex), dstBuf, bufferInfo);
                    } else {
                        // Skip frames after bFrameAfterPFrameIndex
                        // and before muxAllTypeVideoFramesFromIndex.
                        if (VERBOSE) {
                            Log.i(TAG, ""skipped this frame"");
                        }
                    }
                } else {
                    // write audio data as it is continuously
                    muxer.writeSampleData(indexMap.get(trackIndex), dstBuf, bufferInfo);
                }
                extractor.advance();
                sampleCount++;
                if (VERBOSE) {
                    Log.d(TAG, ""Frame ("" + sampleCount + "") "" +
                            ""PresentationTimeUs:"" + bufferInfo.presentationTimeUs +
                            "" Flags:"" + bufferInfo.flags +
                            "" TrackIndex:"" + trackIndex +
                            "" Size(bytes) "" + bufferInfo.size );
                }
            }
        }

        muxer.stop();
        muxer.release();
        extractor.release();
        srcFd.close();

        return;
    }

    /**
     * Uses two MediaExtractor's and checks whether timestamps of first few and another few
     *  from last sync frame matches
     */
    private void verifyAFewSamplesTimestamp(final String srcMedia, String testMediaPath)
            throws IOException {
        final int numFramesTSCheck = 10; // Num frames to be checked for its timestamps

        AssetFileDescriptor srcFd = getAssetFileDescriptorFor(srcMedia);
        MediaExtractor extractorSrc = new MediaExtractor();
        extractorSrc.setDataSource(srcFd.getFileDescriptor(),
            srcFd.getStartOffset(), srcFd.getLength());
        MediaExtractor extractorTest = new MediaExtractor();
        extractorTest.setDataSource(testMediaPath);

        int trackCount = extractorSrc.getTrackCount();
        for (int i = 0; i < trackCount; i++) {
            MediaFormat format = extractorSrc.getTrackFormat(i);
            extractorSrc.selectTrack(i);
            extractorTest.selectTrack(i);
            if (format.getString(MediaFormat.KEY_MIME).startsWith(""video/"")) {
                // Check time stamps for numFramesTSCheck frames from 33333us.
                checkNumFramesTimestamp(33333, 0, numFramesTSCheck, extractorSrc, extractorTest);
                // Check time stamps for numFramesTSCheck frames from 9333333 -
                // sync frame after framedrops at index 172 of video track.
                checkNumFramesTimestamp(
                        9333333, OFFSET_TIME_US, numFramesTSCheck, extractorSrc, extractorTest);
            } else if (format.getString(MediaFormat.KEY_MIME).startsWith(""audio/"")) {
                // Check timestamps for all audio frames. Test file has 427 audio frames.
                checkNumFramesTimestamp(0, 0, 427, extractorSrc, extractorTest);
            }
            extractorSrc.unselectTrack(i);
            extractorTest.unselectTrack(i);
        }

        extractorSrc.release();
        extractorTest.release();
        srcFd.close();
    }

    private void checkNumFramesTimestamp(long seekTimeUs, long offsetTimeUs, int numFrames,
            MediaExtractor extractorSrc, MediaExtractor extractorTest) {
        long srcSampleTimeUs = -1;
        long testSampleTimeUs = -1;
        extractorSrc.seekTo(seekTimeUs, MediaExtractor.SEEK_TO_CLOSEST_SYNC);
        extractorTest.seekTo(seekTimeUs + offsetTimeUs, MediaExtractor.SEEK_TO_CLOSEST_SYNC);
        while (numFrames-- > 0 ) {
            srcSampleTimeUs = extractorSrc.getSampleTime();
            testSampleTimeUs = extractorTest.getSampleTime();
            if (srcSampleTimeUs == -1 || testSampleTimeUs == -1) {
                fail(""either of tracks reached end of stream"");
            }
            if ((srcSampleTimeUs + offsetTimeUs) != testSampleTimeUs) {
                if (VERBOSE) {
                    Log.d(TAG, ""srcTrackIndex:"" + extractorSrc.getSampleTrackIndex() +
                        ""  testTrackIndex:"" + extractorTest.getSampleTrackIndex());
                    Log.d(TAG, ""srcTSus:"" + srcSampleTimeUs + "" testTSus:"" + testSampleTimeUs);
                }
                fail(""timestamps didn't match"");
            }
            extractorSrc.advance();
            extractorTest.advance();
        }
    }

    /**
     * Using MediaMuxer and MediaExtractor to mux a media file from another file while skipping
     * 0 or more video frames and desired start offsets for each track.
     * startOffsetUsVect : order of tracks is the same as in the input file
     */
    private void cloneMediaWithSamplesDropAndStartOffsets(final String srcMedia, String dstMediaPath,
            int fmt, HashSet<Integer> samplesDropSet, Vector<Integer> startOffsetUsVect)
            throws IOException {
        // Set up MediaExtractor to read from the source.
        AssetFileDescriptor srcFd = getAssetFileDescriptorFor(srcMedia);
        MediaExtractor extractor = new MediaExtractor();
        extractor.setDataSource(srcFd.getFileDescriptor(), srcFd.getStartOffset(),
            srcFd.getLength());

        int trackCount = extractor.getTrackCount();

        // Set up MediaMuxer for the destination.
        MediaMuxer muxer;
        muxer = new MediaMuxer(dstMediaPath, fmt);

        // Set up the tracks.
        HashMap<Integer, Integer> indexMap = new HashMap<Integer, Integer>(trackCount);

        int videoTrackIndex = 100;
        int videoStartOffsetUs = 0;
        int audioTrackIndex = 100;
        int audioStartOffsetUs = 0;
        for (int i = 0; i < trackCount; i++) {
            extractor.selectTrack(i);
            MediaFormat format = extractor.getTrackFormat(i);
            int dstIndex = muxer.addTrack(format);
            indexMap.put(i, dstIndex);
            if (format.getString(MediaFormat.KEY_MIME).startsWith(""video/"")) {
                videoTrackIndex = i;
                // Make sure there's an entry for video track.
                if (startOffsetUsVect != null && (videoTrackIndex < startOffsetUsVect.size())) {
                    videoStartOffsetUs = startOffsetUsVect.get(videoTrackIndex);
                }
            }
            if (format.getString(MediaFormat.KEY_MIME).startsWith(""audio/"")) {
                audioTrackIndex = i;
                // Make sure there's an entry for audio track.
                if (startOffsetUsVect != null && (audioTrackIndex < startOffsetUsVect.size())) {
                    audioStartOffsetUs = startOffsetUsVect.get(audioTrackIndex);
                }
            }
        }

        // Copy the samples from MediaExtractor to MediaMuxer.
        boolean sawEOS = false;
        int bufferSize = MAX_SAMPLE_SIZE;
        int sampleCount = 0;
        int offset = 0;
        int videoSampleCount = 0;

        ByteBuffer dstBuf = ByteBuffer.allocate(bufferSize);
        BufferInfo bufferInfo = new BufferInfo();

        muxer.start();
        while (!sawEOS) {
            bufferInfo.offset = 0;
            bufferInfo.size = extractor.readSampleData(dstBuf, offset);
            if (bufferInfo.size < 0) {
                if (VERBOSE) {
                    Log.d(TAG, ""saw input EOS."");
                }
                sawEOS = true;
                bufferInfo.size = 0;
            } else {
                bufferInfo.presentationTimeUs = extractor.getSampleTime();
                bufferInfo.flags = extractor.getSampleFlags();
                int trackIndex = extractor.getSampleTrackIndex();
                if (VERBOSE) {
                    Log.v(TAG, ""TrackIndex:"" + trackIndex + "" PresentationTimeUs:"" +
                                bufferInfo.presentationTimeUs + "" Flags:"" + bufferInfo.flags +
                                "" Size(bytes)"" + bufferInfo.size);
                }
                if (trackIndex == videoTrackIndex) {
                    ++videoSampleCount;
                    if (VERBOSE) {
                        Log.v(TAG, ""videoSampleCount : "" + videoSampleCount);
                    }
                    if (samplesDropSet == null || (!samplesDropSet.contains(videoSampleCount))) {
                        // Write video frame with start offset adjustment.
                        bufferInfo.presentationTimeUs += videoStartOffsetUs;
                        muxer.writeSampleData(indexMap.get(trackIndex), dstBuf, bufferInfo);
                    }
                    else {
                        if (VERBOSE) {
                            Log.v(TAG, ""skipped this frame"");
                        }
                    }
                } else {
                    // write audio sample with start offset adjustment.
                    bufferInfo.presentationTimeUs += audioStartOffsetUs;
                    muxer.writeSampleData(indexMap.get(trackIndex), dstBuf, bufferInfo);
                }
                extractor.advance();
                sampleCount++;
                if (VERBOSE) {
                    Log.i(TAG, ""Sample ("" + sampleCount + "")"" +
                            "" TrackIndex:"" + trackIndex +
                            "" PresentationTimeUs:"" + bufferInfo.presentationTimeUs +
                            "" Flags:"" + bufferInfo.flags +
                            "" Size(bytes)"" + bufferInfo.size );
                }
            }
        }

        muxer.stop();
        muxer.release();
        extractor.release();
        srcFd.close();

        return;
    }

    /*
     * Uses MediaExtractors and checks whether timestamps of all samples except in samplesDropSet
     *  and with start offsets adjustments for each track match.
     */
    private void verifyTSWithSamplesDropAndStartOffset(final String srcMedia, boolean hasBframes,
            String testMediaPath, HashSet<Integer> samplesDropSet,
            Vector<Integer> startOffsetUsVect) throws IOException {
        AssetFileDescriptor srcFd = getAssetFileDescriptorFor(srcMedia);
        MediaExtractor extractorSrc = new MediaExtractor();
        extractorSrc.setDataSource(srcFd.getFileDescriptor(),
            srcFd.getStartOffset(), srcFd.getLength());
        MediaExtractor extractorTest = new MediaExtractor();
        extractorTest.setDataSource(testMediaPath);

        int videoTrackIndex = -1;
        int videoStartOffsetUs = 0;
        int minStartOffsetUs = Integer.MAX_VALUE;
        int trackCount = extractorSrc.getTrackCount();

        /*
         * When all track's start offsets are positive, MPEG4Writer makes the start timestamp of the
         * earliest track as zero and adjusts all other tracks' timestamp accordingly.
         */
        // TODO: need to confirm if the above logic holds good with all others writers we support.
        if (startOffsetUsVect != null) {
            for (int startOffsetUs : startOffsetUsVect) {
                minStartOffsetUs = Math.min(startOffsetUs, minStartOffsetUs);
            }
        } else {
            minStartOffsetUs = 0;
        }

        if (minStartOffsetUs < 0) {
            /*
             * Atleast one of the start offsets were negative. We have some test cases with negative
             * offsets for audio, minStartOffset has to be reset as Writer won't adjust any of the
             * track's timestamps.
             */
            minStartOffsetUs = 0;
        }

        // Select video track.
        for (int i = 0; i < trackCount; i++) {
            MediaFormat format = extractorSrc.getTrackFormat(i);
            if (format.getString(MediaFormat.KEY_MIME).startsWith(""video/"")) {
                videoTrackIndex = i;
                if (startOffsetUsVect != null && videoTrackIndex < startOffsetUsVect.size()) {
                    videoStartOffsetUs = startOffsetUsVect.get(videoTrackIndex);
                }
                extractorSrc.selectTrack(videoTrackIndex);
                extractorTest.selectTrack(videoTrackIndex);
                checkVideoSamplesTimeStamps(extractorSrc, hasBframes, extractorTest, samplesDropSet,
                    videoStartOffsetUs - minStartOffsetUs);
                extractorSrc.unselectTrack(videoTrackIndex);
                extractorTest.unselectTrack(videoTrackIndex);
            }
        }

        int audioTrackIndex = -1;
        int audioSampleCount = 0;
        int audioStartOffsetUs = 0;
        //select audio track
        for (int i = 0; i < trackCount; i++) {
            MediaFormat format = extractorSrc.getTrackFormat(i);
            if (format.getString(MediaFormat.KEY_MIME).startsWith(""audio/"")) {
                audioTrackIndex = i;
                if (startOffsetUsVect != null && audioTrackIndex < startOffsetUsVect.size()) {
                    audioStartOffsetUs = startOffsetUsVect.get(audioTrackIndex);
                }
                extractorSrc.selectTrack(audioTrackIndex);
                extractorTest.selectTrack(audioTrackIndex);
                checkAudioSamplesTimestamps(
                        extractorSrc, extractorTest, audioStartOffsetUs - minStartOffsetUs);
            }
        }

        extractorSrc.release();
        extractorTest.release();
        srcFd.close();
    }

    // Check timestamps of all video samples.
    private void checkVideoSamplesTimeStamps(MediaExtractor extractorSrc, boolean hasBFrames,
            MediaExtractor extractorTest, HashSet<Integer> samplesDropSet, int videoStartOffsetUs) {
        long srcSampleTimeUs = -1;
        long testSampleTimeUs = -1;
        boolean srcAdvance = false;
        boolean testAdvance = false;
        int videoSampleCount = 0;

        extractorSrc.seekTo(0, MediaExtractor.SEEK_TO_CLOSEST_SYNC);
        extractorTest.seekTo(0, MediaExtractor.SEEK_TO_CLOSEST_SYNC);

        if (VERBOSE) {
            Log.v(TAG, ""srcTrackIndex:"" + extractorSrc.getSampleTrackIndex() +
                        ""  testTrackIndex:"" + extractorTest.getSampleTrackIndex());
            Log.v(TAG, ""videoStartOffsetUs:"" + videoStartOffsetUs);
        }

        do {
            ++videoSampleCount;
            srcSampleTimeUs = extractorSrc.getSampleTime();
            testSampleTimeUs = extractorTest.getSampleTime();
            if (VERBOSE) {
                Log.v(TAG, ""videoSampleCount:"" + videoSampleCount);
                Log.i(TAG, ""srcTSus:"" + srcSampleTimeUs + "" testTSus:"" + testSampleTimeUs);
            }
            if (samplesDropSet == null || !samplesDropSet.contains(videoSampleCount)) {
                if (srcSampleTimeUs == -1 || testSampleTimeUs == -1) {
                    if (VERBOSE) {
                        Log.v(TAG, ""srcUs:"" + srcSampleTimeUs + ""testUs:"" + testSampleTimeUs);
                    }
                    fail(""either source or test track reached end of stream"");
                }
                /* Stts values within 0.1ms(100us) difference are fudged to save too many
                 * stts entries in MPEG4Writer.
                 */
                else if (Math.abs(srcSampleTimeUs + videoStartOffsetUs - testSampleTimeUs) > 100) {
                    if (VERBOSE) {
                        Log.v(TAG, ""Fail:video timestamps didn't match"");
                        Log.v(TAG,
                            ""srcTrackIndex:"" + extractorSrc.getSampleTrackIndex()
                                + ""  testTrackIndex:"" + extractorTest.getSampleTrackIndex());
                        Log.v(TAG, ""srcTSus:"" + srcSampleTimeUs + "" testTSus:"" + testSampleTimeUs);
                  }
                    fail(""video timestamps didn't match"");
                }
                testAdvance = extractorTest.advance();
            }
            srcAdvance = extractorSrc.advance();
        } while (srcAdvance && testAdvance);
        if (srcAdvance != testAdvance) {
            if (VERBOSE) {
                Log.v(TAG, ""videoSampleCount:"" + videoSampleCount);
            }
            fail(""either video track has not reached its last sample"");
        }
    }

    private void checkAudioSamplesTimestamps(MediaExtractor extractorSrc,
                MediaExtractor extractorTest, int audioStartOffsetUs) {
        long srcSampleTimeUs = -1;
        long testSampleTimeUs = -1;
        boolean srcAdvance = false;
        boolean testAdvance = false;
        int audioSampleCount = 0;

        extractorSrc.seekTo(0, MediaExtractor.SEEK_TO_CLOSEST_SYNC);
        if (audioStartOffsetUs >= 0) {
            // Added edit list support for maintaining only the diff in start offsets of tracks.
            // TODO: Remove this once we add support for preserving absolute timestamps as well.
            extractorTest.seekTo(0, MediaExtractor.SEEK_TO_CLOSEST_SYNC);
        } else {
            extractorTest.seekTo(audioStartOffsetUs, MediaExtractor.SEEK_TO_CLOSEST_SYNC);
        }
        if (VERBOSE) {
            Log.v(TAG, ""audioStartOffsetUs:"" + audioStartOffsetUs);
            Log.v(TAG, ""srcTrackIndex:"" + extractorSrc.getSampleTrackIndex() +
                        ""  testTrackIndex:"" + extractorTest.getSampleTrackIndex());
        }
        // Check timestamps of all audio samples.
        do {
            ++audioSampleCount;
            srcSampleTimeUs = extractorSrc.getSampleTime();
            testSampleTimeUs = extractorTest.getSampleTime();
            if (VERBOSE) {
                Log.v(TAG, ""audioSampleCount:"" + audioSampleCount);
                Log.v(TAG, ""srcTSus:"" + srcSampleTimeUs + "" testTSus:"" + testSampleTimeUs);
            }

            if (srcSampleTimeUs == -1 || testSampleTimeUs == -1) {
                if (VERBOSE) {
                    Log.v(TAG, ""srcTSus:"" + srcSampleTimeUs + "" testTSus:"" + testSampleTimeUs);
                }
                fail(""either source or test track reached end of stream"");
            }
            // > 1us to ignore any round off errors.
            else if (Math.abs(srcSampleTimeUs + audioStartOffsetUs - testSampleTimeUs) > 1) {
                fail(""audio timestamps didn't match"");
            }
            testAdvance = extractorTest.advance();
            srcAdvance = extractorSrc.advance();
        } while (srcAdvance && testAdvance);
        if (srcAdvance != testAdvance) {
            fail(""either audio track has not reached its last sample"");
        }
    }
}"	""	""	"RCS"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.TestRcsFeature"	"getEventListener"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/TestRcsFeature.java"	""	"public void test/*
 *.
 */

package android.telephony.ims.cts;

import android.content.Context;
import android.telephony.ims.feature.CapabilityChangeRequest;
import android.telephony.ims.feature.RcsFeature;
import android.telephony.ims.stub.CapabilityExchangeEventListener;
import android.telephony.ims.stub.ImsRegistrationImplBase;
import android.telephony.ims.stub.RcsCapabilityExchangeImplBase;
import android.util.Log;

import java.util.List;
import java.util.concurrent.Executor;

public class TestRcsFeature extends RcsFeature {

    private static final String TAG = ""CtsTestImsService"";

    private final TestImsService.ReadyListener mReadyListener;
    private final TestImsService.RemovedListener mRemovedListener;
    private final TestImsService.RcsCapabilityExchangeEventListener mCapExchangeEventListener;

    private final RcsImsCapabilities mRcsCapabilitiesLte;
    private final RcsImsCapabilities mRcsCapabilitiesIWan;
    private final TestImsService.CapabilitiesSetListener mRcsCapabilityChangedListener;

    private TestRcsCapabilityExchangeImpl mCapExchangeImpl;
    private CapabilityExchangeEventListener mCapEventListener;
    private TestImsService.DeviceCapPublishListener mDeviceCapPublishListener;

    TestRcsFeature(Context context,
            TestImsService.ReadyListener readyListener,
            TestImsService.RemovedListener removedListener,
            TestImsService.CapabilitiesSetListener setListener,
            TestImsService.RcsCapabilityExchangeEventListener capExchangeEventListener) {
        super(context.getMainExecutor());

        mReadyListener = readyListener;
        mRemovedListener = removedListener;
        mCapExchangeEventListener = capExchangeEventListener;

        mRcsCapabilityChangedListener = setListener;
        mRcsCapabilitiesLte = new RcsImsCapabilities(RcsImsCapabilities.CAPABILITY_TYPE_NONE);
        mRcsCapabilitiesIWan = new RcsImsCapabilities(RcsImsCapabilities.CAPABILITY_TYPE_NONE);

        setFeatureState(STATE_READY);
    }

    public void setDeviceCapPublishListener(TestImsService.DeviceCapPublishListener listener) {
        mDeviceCapPublishListener = listener;
    }

    @Override
    public void onFeatureReady() {
        if (ImsUtils.VDBG) {
            Log.d(TAG, ""TestRcsFeature.onFeatureReady called"");
        }
        mReadyListener.onReady();
    }

    @Override
    public void onFeatureRemoved() {
        if (ImsUtils.VDBG) {
            Log.d(TAG, ""TestRcsFeature.onFeatureRemoved called"");
        }
        mRemovedListener.onRemoved();
    }

    public RcsCapabilityExchangeImplBase createCapabilityExchangeImpl(Executor executor,
            CapabilityExchangeEventListener listener) {
        return createCapabilityExchangeImpl(listener);
    }

    @Override
    public RcsCapabilityExchangeImplBase createCapabilityExchangeImpl(
            CapabilityExchangeEventListener listener) {
        if (ImsUtils.VDBG) {
            Log.d(TAG, ""TestRcsFeature.createCapabilityExchangeImpl called"");
        }
        mCapEventListener = listener;
        mCapExchangeImpl = new TestRcsCapabilityExchangeImpl(mDeviceCapPublishListener);
        mCapExchangeEventListener.onSet();
        return mCapExchangeImpl;
    }

    @Override
    public void destroyCapabilityExchangeImpl(RcsCapabilityExchangeImplBase capExchangeImpl) {
        if (ImsUtils.VDBG) {
            Log.d(TAG, ""TestRcsFeature.destroyCapabilityExchangeImpl called"");
        }
        mCapEventListener = null;
        mCapExchangeEventListener.onSet();
    }

    public CapabilityExchangeEventListener getEventListener() {
        return mCapEventListener;
    }

    public TestRcsCapabilityExchangeImpl getRcsCapabilityExchangeImpl() {
        return mCapExchangeImpl;
    }

    @Override
    public void changeEnabledCapabilities(CapabilityChangeRequest request,
            CapabilityCallbackProxy c) {

        // Enabled RCS capabilities
        List<CapabilityChangeRequest.CapabilityPair> pairs = request.getCapabilitiesToEnable();
        for (CapabilityChangeRequest.CapabilityPair pair : pairs) {
            if (pair.getRadioTech() == ImsRegistrationImplBase.REGISTRATION_TECH_LTE) {
                mRcsCapabilitiesLte.addCapabilities(pair.getCapability());
            } else if (pair.getRadioTech() == ImsRegistrationImplBase.REGISTRATION_TECH_IWLAN) {
                mRcsCapabilitiesIWan.addCapabilities(pair.getCapability());
            }
        }

        // Disabled RCS capabilities
        pairs = request.getCapabilitiesToDisable();
        for (CapabilityChangeRequest.CapabilityPair pair : pairs) {
            if (pair.getRadioTech() == ImsRegistrationImplBase.REGISTRATION_TECH_LTE) {
                mRcsCapabilitiesLte.removeCapabilities(pair.getCapability());
            } else if (pair.getRadioTech() == ImsRegistrationImplBase.REGISTRATION_TECH_IWLAN) {
                mRcsCapabilitiesIWan.removeCapabilities(pair.getCapability());
            }
        }
        mRcsCapabilityChangedListener.onSet();
    }

    @Override
    public boolean queryCapabilityConfiguration(int capability, int radioTech) {
        if (ImsUtils.VDBG) {
            Log.d(TAG, ""TestRcsFeature.queryCapabilityConfiguration capability: "" + capability);
        }
        if (radioTech == ImsRegistrationImplBase.REGISTRATION_TECH_LTE) {
            return mRcsCapabilitiesLte.isCapable(capability);
        } else if (radioTech == ImsRegistrationImplBase.REGISTRATION_TECH_IWLAN) {
            return mRcsCapabilitiesIWan.isCapable(capability);
        }
        return false;
    }
}"	""	""	"RCS"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telecom.cts.ConnectionServiceTest"	"testCallFilteringCompleteSignalNotInContacts"	"CtsTelecomTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/ConnectionServiceTest.java"	""	"public void testCallFilteringCompleteSignalNotInContacts() throws Exception {
        if (!mShouldTestTelecom) {
            return;
        }
        InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .adoptShellPermissionIdentity(""android.permission.MODIFY_PHONE_STATE"");
        MockCallScreeningService.enableService(mContext);
        try {
            CallScreeningService.CallResponse response =
                    new CallScreeningService.CallResponse.Builder()
                            .setDisallowCall(false)
                            .setRejectCall(false)
                            .setSilenceCall(false)
                            .setSkipCallLog(false)
                            .setSkipNotification(false)
                            .setShouldScreenCallViaAudioProcessing(false)
                            .setCallComposerAttachmentsToShow(
                                    CallResponse.CALL_COMPOSER_ATTACHMENT_PRIORITY
                                            | CallResponse.CALL_COMPOSER_ATTACHMENT_SUBJECT)
                            .build();
            MockCallScreeningService.setCallbacks(createCallbackForCsTest(response));

            addAndVerifyNewIncomingCall(createTestNumber(), null);
            MockConnection connection = verifyConnectionForIncomingCall();

            Object[] callFilteringCompleteInvocations =
                    connection.getInvokeCounter(MockConnection.ON_CALL_FILTERING_COMPLETED)
                            .getArgs(0);
            Connection.CallFilteringCompletionInfo completionInfo =
                    (Connection.CallFilteringCompletionInfo) callFilteringCompleteInvocations[0];

            assertFalse(completionInfo.isBlocked());
            assertFalse(completionInfo.isInContacts());
            assertEquals(response, completionInfo.getCallResponse());
            assertEquals(PACKAGE, completionInfo.getCallScreeningComponent().getPackageName());
        } finally {
            InstrumentationRegistry.getInstrumentation().getUiAutomation()
                    .dropShellPermissionIdentity();
            MockCallScreeningService.disableService(mContext);
        }
    }"	""	""	"RCS"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telecom.cts.ConnectionServiceTest"	"testCallFilteringCompleteSignalInContacts"	"CtsTelecomTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/ConnectionServiceTest.java"	""	"public void testCallFilteringCompleteSignalInContacts() throws Exception {
        if (!mShouldTestTelecom) {
            return;
        }
        InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .adoptShellPermissionIdentity(""android.permission.MODIFY_PHONE_STATE"");
        Uri testNumber = createTestNumber();
        Uri contactUri = TestUtils.insertContact(mContext.getContentResolver(),
                testNumber.getSchemeSpecificPart());
        MockCallScreeningService.enableService(mContext);
        try {
            CallScreeningService.CallResponse response =
                    new CallScreeningService.CallResponse.Builder()
                            .setDisallowCall(false)
                            .setRejectCall(false)
                            .setSilenceCall(false)
                            .setSkipCallLog(false)
                            .setSkipNotification(false)
                            .setShouldScreenCallViaAudioProcessing(false)
                            .setCallComposerAttachmentsToShow(
                                    CallResponse.CALL_COMPOSER_ATTACHMENT_PRIORITY
                                            | CallResponse.CALL_COMPOSER_ATTACHMENT_SUBJECT)
                            .build();
            MockCallScreeningService.setCallbacks(createCallbackForCsTest(response));

            assertEquals(CallResponse.CALL_COMPOSER_ATTACHMENT_PRIORITY
                    | CallResponse.CALL_COMPOSER_ATTACHMENT_SUBJECT,
                    response.getCallComposerAttachmentsToShow());
            addAndVerifyNewIncomingCall(testNumber, null);

            MockConnection connection = verifyConnectionForIncomingCall();

            Object[] callFilteringCompleteInvocations =
                    connection.getInvokeCounter(MockConnection.ON_CALL_FILTERING_COMPLETED)
                            .getArgs(0);
            Connection.CallFilteringCompletionInfo completionInfo =
                    (Connection.CallFilteringCompletionInfo) callFilteringCompleteInvocations[0];

            assertFalse(completionInfo.isBlocked());
            assertTrue(completionInfo.isInContacts());
            assertEquals(response, completionInfo.getCallResponse());
            assertEquals(PACKAGE, completionInfo.getCallScreeningComponent().getPackageName());
        } finally {
            InstrumentationRegistry.getInstrumentation().getUiAutomation()
                    .dropShellPermissionIdentity();
            TestUtils.deleteContact(mContext.getContentResolver(), contactUri);
            MockCallScreeningService.disableService(mContext);
        }
    }

    private MockCallScreeningService.CallScreeningServiceCallbacks createCallbackForCsTest(
            CallScreeningService.CallResponse response) {
        return new MockCallScreeningService.CallScreeningServiceCallbacks() {
            @Override
            public void onScreenCall(Call.Details callDetails) {

                getService().respondToCall(callDetails, response);
            }
        };
    }"	""	""	"RCS"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.EabBulkCapabilityUpdaterTest"	"beforeAllTests"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/EabBulkCapabilityUpdaterTest.java"	""	"/*
 *.
 */

package android.telephony.ims.cts;

import static android.provider.ContactsContract.CommonDataKinds;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import android.content.BroadcastReceiver;
import android.content.ContentProviderOperation;
import android.content.ContentProviderResult;
import android.content.ContentResolver;
import android.content.ContentUris;
import android.content.ContentValues;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.database.Cursor;
import android.net.Uri;
import android.os.HandlerThread;
import android.os.Looper;
import android.os.PersistableBundle;
import android.provider.ContactsContract;
import android.telecom.PhoneAccount;
import android.telephony.CarrierConfigManager;
import android.telephony.SubscriptionManager;
import android.telephony.TelephonyManager;
import android.telephony.cts.TelephonyUtils;
import android.telephony.ims.ImsException;
import android.telephony.ims.ImsManager;
import android.telephony.ims.ImsRcsManager;
import android.telephony.ims.RcsContactPresenceTuple;
import android.telephony.ims.feature.ImsFeature;
import android.telephony.ims.stub.ImsFeatureConfiguration;
import android.text.TextUtils;
import android.util.Log;

import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.platform.app.InstrumentationRegistry;

import com.android.compatibility.common.util.ShellIdentityUtils;
import com.android.i18n.phonenumbers.NumberParseException;
import com.android.i18n.phonenumbers.PhoneNumberUtil;
import com.android.i18n.phonenumbers.Phonenumber;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.GregorianCalendar;
import java.util.Random;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

@RunWith(AndroidJUnit4.class)
public class EabBulkCapabilityUpdaterTest {
    private static final String TAG = ""EabBulkCapabilityUpdaterTest"";

    private static Context mContext;
    private static ContentResolver mContentResolver;
    private static int sTestSlot = SubscriptionManager.INVALID_SIM_SLOT_INDEX;
    private static int sTestSub = SubscriptionManager.INVALID_SUBSCRIPTION_ID;
    private static ImsServiceConnector sServiceConnector;
    private static CarrierConfigReceiver sReceiver;
    private static String sTestPhoneNumber;
    private static String sUpdatePhoneNumber;
    private static String sFormattedPhoneNumber;
    private static Uri sTestNumberUri;
    private static boolean mPrevEabSettings = false;
    private static boolean sDeviceUceEnabled;

    private static final int POLLING_RETRY_TIMES = 20;
    private static final int WAITING_IN_MILLI_SEC = 1000;
    private static final String TEST_CONTACT_NAME = ""android_cts_eab_test_contact"";

    private static final String COMMAND_BASE = ""cmd phone "";
    private static final String COMMAND_SLOT_IDENTIFIER = ""-s "";
    private static final String COMMAND_GET_EAB_CONTACT = ""uce get-eab-contact "";
    private static final String COMMAND_REMOVE_EAB_CONTACT = ""uce remove-eab-contact "";
    private static final String TEST_SERVICE_DESCRIPTION = ""description_test1"";

    private CountDownLatch mWaitNotifyResult;

    private static class CarrierConfigReceiver extends BroadcastReceiver {
        private CountDownLatch mLatch = new CountDownLatch(1);
        private final int mSubId;

        CarrierConfigReceiver(int subId) {
            mSubId = subId;
        }

        @Override
        public void onReceive(Context context, Intent intent) {
            if (CarrierConfigManager.ACTION_CARRIER_CONFIG_CHANGED.equals(intent.getAction())) {
                int subId = intent.getIntExtra(CarrierConfigManager.EXTRA_SUBSCRIPTION_INDEX, -1);
                if (mSubId == subId) {
                    mLatch.countDown();
                }
            }
        }

        void clearQueue() {
            mLatch = new CountDownLatch(1);
        }

        void waitForCarrierConfigChanged() throws Exception {
            mLatch.await(5000, TimeUnit.MILLISECONDS);
        }
    }

    @BeforeClass
    public static void beforeAllTests() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }

        mContext = InstrumentationRegistry.getInstrumentation().getContext();
        mContentResolver = mContext.getContentResolver();

        sTestPhoneNumber = generateRandomPhoneNumber();
        sFormattedPhoneNumber = formatNumber(mContext, sTestPhoneNumber);
        sTestNumberUri = Uri.fromParts(PhoneAccount.SCHEME_TEL, sTestPhoneNumber, null);

        sTestSub = ImsUtils.getPreferredActiveSubId();
        sTestSlot = SubscriptionManager.getSlotIndex(sTestSub);

        sReceiver = new CarrierConfigReceiver(sTestSub);

        mPrevEabSettings = isUserEnableUce();

        sServiceConnector = new ImsServiceConnector(InstrumentationRegistry.getInstrumentation());
        sServiceConnector.clearAllActiveImsServices(sTestSlot);
        sDeviceUceEnabled = sServiceConnector.getDeviceUceEnabled();
        sServiceConnector.setDeviceUceEnabled(true);

        IntentFilter filter = new IntentFilter(CarrierConfigManager.ACTION_CARRIER_CONFIG_CHANGED);
        // ACTION_CARRIER_CONFIG_CHANGED is sticky, so we will get a callback right away.
        InstrumentationRegistry.getInstrumentation().getContext()
                .registerReceiver(sReceiver, filter);

        updateEabCarrierConfig(true);
        updateEabUserSettings(true);

        connectTestImsService();
    }

    @AfterClass
    public static void afterAllTests() throws Exception {
        // Restore all ImsService configurations that existed before the test.
        if (sServiceConnector != null) {
            sServiceConnector.disconnectCarrierImsService();
            sServiceConnector.disconnectDeviceImsService();
            sServiceConnector.disconnectServices();
            sServiceConnector.setDeviceUceEnabled(sDeviceUceEnabled);
        }
        sServiceConnector = null;

        if (sReceiver != null) {
            InstrumentationRegistry.getInstrumentation().getContext().unregisterReceiver(sReceiver);
            sReceiver = null;
        }


        updateEabUserSettings(mPrevEabSettings);
        overrideCarrierConfig(null);

        if (sReceiver != null) {
            InstrumentationRegistry.getInstrumentation().getContext()
                    .unregisterReceiver(sReceiver);
        }
    }

    @Before
    public void setup() {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }

        if (!SubscriptionManager.isValidSubscriptionId(sTestSub)) {
            fail(""This test requires that there is a SIM in the device!"");
        }

        mWaitNotifyResult = new CountDownLatch(1);
        fakeNetworkResult(getPidfXmlData());
    }

    @After
    public void teardown() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }

        cleanupTestContactFromContactProvider();
        cleanupTestContactInEabProvider();
    }"	""	""	"RCS"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.EabBulkCapabilityUpdaterTest"	"deleteContactTest"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/EabBulkCapabilityUpdaterTest.java"	""	"public void deleteContactTest() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }

        insertContactToContactProvider();
        waitingEabProviderInsertContact(sFormattedPhoneNumber, POLLING_RETRY_TIMES);

        deleteTestContact();
        waitingEabProviderDeleteContact(sFormattedPhoneNumber, POLLING_RETRY_TIMES);

        // Verify the phone number in EAB provider has been removed
        String contactFromEab = getEabContact(sTestPhoneNumber);
        assertTrue(TextUtils.isEmpty(contactFromEab));
    }

    private void waitingEabProviderInsertContact(
            String phoneNumber, int retryTimes) throws Exception {
        mWaitNotifyResult.await(ImsUtils.TEST_TIMEOUT_MS, TimeUnit.MILLISECONDS);

        String contactFromEab;
        do {
            contactFromEab = getEabContact(phoneNumber);
            Thread.sleep(WAITING_IN_MILLI_SEC);
            retryTimes--;
        } while (retryTimes > 0 && TextUtils.isEmpty(contactFromEab));
        mWaitNotifyResult = new CountDownLatch(1);
    }

    private void waitingEabProviderDeleteContact(
            String phoneNumber, int retryTimes) throws Exception {
        String contactFromEab;
        do {
            contactFromEab = getEabContact(phoneNumber);
            Thread.sleep(WAITING_IN_MILLI_SEC);
            retryTimes--;
        } while (retryTimes > 0 && !TextUtils.isEmpty(contactFromEab));
    }

    private void updatePhoneNumber(String newNumber) {
        Cursor cursor = mContentResolver.query(ContactsContract.Contacts.CONTENT_URI,
                null,
                ContactsContract.Contacts.DISPLAY_NAME_PRIMARY + ""=?"",
                new String[]{TEST_CONTACT_NAME},
                null);
        ContentValues updateContentValues = new ContentValues();
        updateContentValues.put(CommonDataKinds.Phone.DATA, newNumber);
        while (cursor.moveToNext()) {
            String contactId = cursor.getString(cursor.getColumnIndex(
                    ContactsContract.Contacts.NAME_RAW_CONTACT_ID));
            mContentResolver.update(ContactsContract.Data.CONTENT_URI,
                    updateContentValues,
                    ContactsContract.Data.RAW_CONTACT_ID + ""=? AND ""
                            + ContactsContract.Data.MIMETYPE + ""='""
                            + CommonDataKinds.Phone.CONTENT_ITEM_TYPE + ""'"",
                    new String[]{contactId});
        }
        cursor.close();
    }

    private String getEabContact(String phoneNum) throws Exception {
        StringBuilder cmdBuilder = new StringBuilder();
        cmdBuilder.append(COMMAND_BASE).append(COMMAND_GET_EAB_CONTACT)
                .append("" "").append(phoneNum);
        return TelephonyUtils.executeShellCommand(InstrumentationRegistry.getInstrumentation(),
                cmdBuilder.toString());
    }

    private void deleteTestContact() {
        Uri uri = ContactsContract.RawContacts.CONTENT_URI.buildUpon().appendQueryParameter(
                ContactsContract.CALLER_IS_SYNCADAPTER, ""true"").build();

        ArrayList<ContentProviderOperation> operationList = new ArrayList<>();
        operationList.add(ContentProviderOperation.newDelete(uri)
                .withSelection(ContactsContract.RawContacts.DISPLAY_NAME_PRIMARY + ""=?"",
                        new String[]{TEST_CONTACT_NAME}).build());
        try {
            mContentResolver.applyBatch(ContactsContract.AUTHORITY, operationList);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private ContentProviderResult[] insertContactToContactProvider() {
        ContentProviderResult[] result = null;

        ArrayList<ContentProviderOperation> contactInfoList = new ArrayList<>();
        contactInfoList.add(
                ContentProviderOperation.newInsert(ContactsContract.RawContacts.CONTENT_URI)
                        .withValue(ContactsContract.RawContacts.ACCOUNT_NAME, null)
                        .withValue(ContactsContract.RawContacts.ACCOUNT_TYPE, null)
                        .build());

        // Add contact name
        contactInfoList.add(ContentProviderOperation.newInsert(ContactsContract.Data.CONTENT_URI)
                .withValueBackReference(ContactsContract.Data.RAW_CONTACT_ID, 0)
                .withValue(ContactsContract.Data.MIMETYPE,
                        CommonDataKinds.StructuredName.CONTENT_ITEM_TYPE)
                .withValue(CommonDataKinds.StructuredName.DISPLAY_NAME, TEST_CONTACT_NAME)
                .build());

        // Add phone number
        contactInfoList.add(ContentProviderOperation.newInsert(ContactsContract.Data.CONTENT_URI)
                .withValueBackReference(ContactsContract.Data.RAW_CONTACT_ID, 0)
                .withValue(ContactsContract.Data.MIMETYPE, CommonDataKinds.Phone.CONTENT_ITEM_TYPE)
                .withValue(CommonDataKinds.Phone.NUMBER, sTestPhoneNumber)
                .withValue(CommonDataKinds.Phone.TYPE, CommonDataKinds.Phone.TYPE_MOBILE)
                .build());

        try {
            result = mContentResolver.applyBatch(ContactsContract.AUTHORITY, contactInfoList);
        } catch (Exception e) {
            fail(""Insert contact failed"");
        }
        return result;
    }

    private void deletePhoneNumberOfContact() {
        Cursor cursor = mContentResolver.query(ContactsContract.Contacts.CONTENT_URI,
                null,
                ContactsContract.Contacts.DISPLAY_NAME_PRIMARY + ""=?"",
                new String[]{TEST_CONTACT_NAME},
                null);
        while (cursor.moveToNext()) {
            String contactId = cursor.getString(cursor.getColumnIndex(
                    ContactsContract.Contacts.NAME_RAW_CONTACT_ID));
            mContentResolver.delete(ContactsContract.Data.CONTENT_URI,
                    ContactsContract.Data.RAW_CONTACT_ID + ""=? AND ""
                            + ContactsContract.Data.MIMETYPE + ""='""
                            + CommonDataKinds.Phone.CONTENT_ITEM_TYPE + ""'"",
                    new String[]{contactId});
        }
        cursor.close();
    }

    private void cleanupTestContactFromContactProvider() {
        Cursor cursor = mContentResolver.query(ContactsContract.Contacts.CONTENT_URI,
                null,
                ContactsContract.Contacts.DISPLAY_NAME_PRIMARY + ""=?"",
                new String[]{TEST_CONTACT_NAME},
                null);
        while (cursor.moveToNext()) {
            String contactId = cursor.getString(cursor.getColumnIndex(
                    ContactsContract.Contacts.NAME_RAW_CONTACT_ID));
            mContentResolver.delete(ContactsContract.Data.CONTENT_URI,
                    ContactsContract.Data.RAW_CONTACT_ID + ""=?"",
                    new String[]{contactId});
        }
        cursor.close();
    }

    private void cleanupTestContactInEabProvider() throws Exception {
        StringBuilder cmdBuilder = new StringBuilder();
        cmdBuilder.append(COMMAND_BASE).append(COMMAND_REMOVE_EAB_CONTACT)
                .append(COMMAND_SLOT_IDENTIFIER).append(0).append("" "").append(sTestPhoneNumber);
        TelephonyUtils.executeShellCommand(InstrumentationRegistry.getInstrumentation(),
                cmdBuilder.toString());
        waitingEabProviderDeleteContact(sTestPhoneNumber, POLLING_RETRY_TIMES);

        cmdBuilder = new StringBuilder();
        cmdBuilder.append(COMMAND_BASE).append(COMMAND_REMOVE_EAB_CONTACT)
                .append(COMMAND_SLOT_IDENTIFIER).append(0).append("" "")
                .append(sUpdatePhoneNumber);
        TelephonyUtils.executeShellCommand(InstrumentationRegistry.getInstrumentation(),
                cmdBuilder.toString());
        waitingEabProviderDeleteContact(sUpdatePhoneNumber, POLLING_RETRY_TIMES);
    }

    private static void updateEabCarrierConfig(boolean enable) throws Exception {
        sReceiver.clearQueue();

        PersistableBundle bundle = new PersistableBundle();
        bundle.putBoolean(CarrierConfigManager.KEY_USE_RCS_SIP_OPTIONS_BOOL, true);
        bundle.putBoolean(CarrierConfigManager.Ims.KEY_ENABLE_PRESENCE_PUBLISH_BOOL, true);
        bundle.putBoolean(CarrierConfigManager.Ims.KEY_ENABLE_PRESENCE_CAPABILITY_EXCHANGE_BOOL,
                true);
        bundle.putBoolean(CarrierConfigManager.Ims.KEY_RCS_BULK_CAPABILITY_EXCHANGE_BOOL, enable);
        overrideCarrierConfig(bundle);

        sReceiver.waitForCarrierConfigChanged();
    }

    private static void updateEabUserSettings(boolean enable) {
        ImsManager manager = mContext.getSystemService(ImsManager.class);
        try {
            ImsRcsManager rcsManager = manager.getImsRcsManager(sTestSub);
            ShellIdentityUtils.invokeThrowableMethodWithShellPermissionsNoReturn(
                    rcsManager.getUceAdapter(),
                    (adapter) -> adapter.setUceSettingEnabled(enable),
                    ImsException.class,
                    ""android.permission.MODIFY_PHONE_STATE"");
        } catch (Exception e) {
            Log.d(TAG, ""fail on setting setUceSettingEnabled to true"", e);
        }
    }

    private static void overrideCarrierConfig(PersistableBundle bundle) {
        CarrierConfigManager carrierConfigManager = mContext.getSystemService(
                CarrierConfigManager.class);
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(carrierConfigManager,
                (m) -> m.overrideConfig(sTestSub, bundle));
    }

    private static boolean getBooleanCarrierConfig(String key, int subId) {
        CarrierConfigManager mConfigManager = mContext.getSystemService(CarrierConfigManager.class);
        PersistableBundle b = null;
        if (mConfigManager != null) {
            b = mConfigManager.getConfigForSubId(subId);
        }
        if (b != null) {
            return b.getBoolean(key);
        } else {
            return CarrierConfigManager.getDefaultConfig().getBoolean(key);
        }
    }

    private static boolean isUserEnableUce() {
        ImsManager manager = mContext.getSystemService(ImsManager.class);
        if (manager == null) {
            Log.e(TAG, ""ImsManager is null"");
            return false;
        }
        try {
            ImsRcsManager rcsManager = manager.getImsRcsManager(sTestSub);
            return (rcsManager != null) && rcsManager.getUceAdapter().isUceSettingEnabled();
        } catch (Exception e) {
            Log.e(TAG, ""hasUserEnabledUce: exception = "" + e.getMessage());
        }
        return false;
    }

    private static void connectTestImsService() throws Exception {
        assertTrue(sServiceConnector.connectCarrierImsService(new ImsFeatureConfiguration.Builder()
                .addFeature(sTestSlot, ImsFeature.FEATURE_RCS)
                .build()));

        // The RcsFeature is created when the ImsService is bound. If it wasn't created, then the
        // Framework did not call it.
        assertTrue(""Did not receive createRcsFeature"", sServiceConnector.getCarrierService()
                .waitForLatchCountdown(TestImsService.LATCH_CREATE_RCS));
        assertTrue(""Did not receive RcsFeature#onReady"", sServiceConnector.getCarrierService()
                .waitForLatchCountdown(TestImsService.LATCH_RCS_READY));
        // Make sure the RcsFeature was created in the test service.
        assertNotNull(""Device ImsService created, but TestDeviceImsService#createRcsFeature was not""
                + ""called!"", sServiceConnector.getCarrierService().getRcsFeature());
        assertTrue(""Did not receive RcsFeature#setCapabilityExchangeEventListener"",
                sServiceConnector.getCarrierService().waitForLatchCountdown(
                        TestImsService.LATCH_UCE_LISTENER_SET));
        int serviceSlot = sServiceConnector.getCarrierService().getRcsFeature().getSlotIndex();
        assertEquals(""The slot specified for the test ("" + sTestSlot + "") does not match the ""
                        + ""assigned slot ("" + serviceSlot + ""+ for the associated RcsFeature"",
                sTestSlot, serviceSlot);
    }

    private static String generateRandomPhoneNumber() {
        Random random = new Random();
        StringBuilder builder = new StringBuilder();
        for (int i = 0; i < 10; i++) {
            builder.append(random.nextInt(10));
        }
        return builder.toString();
    }

    private void fakeNetworkResult(String pidfXml) {
        TestRcsCapabilityExchangeImpl capabilityExchangeImpl = sServiceConnector
                .getCarrierService().getRcsFeature().getRcsCapabilityExchangeImpl();

        ArrayList<String> pidfXmlList = new ArrayList<>(1);
        pidfXmlList.add(pidfXml);

        // Setup the network response is 200 OK and notify capabilities update
        int networkRespCode = 200;
        String networkRespReason = ""OK"";
        capabilityExchangeImpl.setSubscribeOperation((uris, cb) -> {
            cb.onNetworkResponse(networkRespCode, networkRespReason);
            cb.onNotifyCapabilitiesUpdate(pidfXmlList);
            cb.onTerminated("""", 0L);
            mWaitNotifyResult.countDown();
        });
    }

    private String getPidfXmlData() {
        GregorianCalendar date = new GregorianCalendar();
        date.add(Calendar.DATE, 120);

        String timeStamp = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ssXXX"")
                .format(date.getTime());

        String pidfBuilder = ""<?xml version='1.0' encoding='utf-8' standalone='yes' ?>""
                + ""<presence entity=\"""" + sTestNumberUri + ""\""""
                + "" xmlns=\""urn:ietf:params:xml:ns:pidf\""""
                + "" xmlns:op=\""urn:oma:xml:prs:pidf:oma-pres\""""
                + "" xmlns:caps=\""urn:ietf:params:xml:ns:pidf:caps\"">""
                + ""<tuple id=\""tid0\"">""
                // status
                + ""<status><basic>""
                + RcsContactPresenceTuple.TUPLE_BASIC_STATUS_OPEN
                + ""</basic></status>""
                // timestamp
                + ""<timestamp>"" + timeStamp + ""</timestamp>""

                // service description
                + ""<op:service-description>""
                + ""<op:service-id>service_id_01</op:service-id>""
                + ""<op:version>1.0</op:version>""
                + ""<op:description>"" + TEST_SERVICE_DESCRIPTION + ""</op:description>""
                + ""</op:service-description>""

                // service capabilities
                + ""<caps:servcaps>""
                // audio capabilities
                + ""<caps:audio>"" + false + ""</caps:audio>""
                // video capabilities
                + ""<caps:video>"" + true + ""</caps:video>""

                // duplex mode
                + ""<caps:duplex>""
                // support duplex mode
                + ""<caps:supported>""
                + ""<caps:"" + RcsContactPresenceTuple.ServiceCapabilities.DUPLEX_MODE_RECEIVE_ONLY
                + ""/>""
                + ""</caps:supported>""

                // unsupported duplex mode
                + ""<caps:notsupported>""
                + ""<caps:"" + RcsContactPresenceTuple.ServiceCapabilities.DUPLEX_MODE_SEND_ONLY
                + ""/>""
                + ""</caps:notsupported>""
                + ""</caps:duplex>""
                + ""</caps:servcaps>""
                + ""<contact>"" + sTestNumberUri + ""</contact>""
                + ""</tuple>""
                + ""</presence>"";
        return pidfBuilder;
    }

    private static String formatNumber(Context context, String number) {
        TelephonyManager manager = context.getSystemService(TelephonyManager.class);
        String simCountryIso = manager.getSimCountryIso();
        if (simCountryIso != null) {
            simCountryIso = simCountryIso.toUpperCase();
            PhoneNumberUtil util = PhoneNumberUtil.getInstance();
            try {
                Phonenumber.PhoneNumber phoneNumber = util.parse(number, simCountryIso);
                return util.format(phoneNumber, PhoneNumberUtil.PhoneNumberFormat.E164);
            } catch (NumberParseException e) {
                Log.w(TAG, ""formatNumber: could not format "" + number + "", error: "" + e);
            }
        }
        return number;
    }
}"	""	""	"RCS"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"com.android.compatibility.common.util.ShellIdentityUtils"	"adoptShellPermissionIdentity"	""	"/home/gpoor/cts-12-source/cts/common/device-side/util-axt/src/com/android/compatibility/common/util/ShellIdentityUtils.java"	""	"public void test/*
 *.
 */

package com.android.compatibility.common.util;

import android.app.UiAutomation;

import androidx.test.InstrumentationRegistry;

import java.util.function.BiFunction;
import java.util.function.Supplier;

/**
 * Provides utility methods to invoke system and privileged APIs as the shell user.
 */
public class ShellIdentityUtils {

    /**
     * Utility interface to invoke a method against the target object.
     *
     * @param <T> the type returned by the invoked method.
     * @param <U> the type of the object against which the method is invoked.
     */
    public interface ShellPermissionMethodHelper<T, U> {
        /**
         * Invokes the method against the target object.
         *
         * @param targetObject the object against which the method should be invoked.
         * @return the result of the invoked method.
         */
        T callMethod(U targetObject);
    }

    /**
     * Utility interface to invoke a method against the target object.
     *
     * @param <U> the type of the object against which the method is invoked.
     */
    public interface ShellPermissionMethodHelperNoReturn<U> {
        /**
         * Invokes the method against the target object.
         *
         * @param targetObject the object against which the method should be invoked.
         */
        void callMethod(U targetObject);
    }

    /**
     * Utility interface to invoke a method against the target object that may throw an Exception.
     *
     * @param <U> the type of the object against which the method is invoked.
     */
    public interface ShellPermissionThrowableMethodHelper<T, U, E extends Throwable> {
        /**
         * Invokes the method against the target object.
         *
         * @param targetObject the object against which the method should be invoked.
         * @return the result of the target method.
         */
        T callMethod(U targetObject) throws E;
    }

    /**
     * Utility interface to invoke a method against the target object that may throw an Exception.
     *
     * @param <U> the type of the object against which the method is invoked.
     */
    public interface ShellPermissionThrowableMethodHelperNoReturn<U, E extends Throwable> {
        /**
         * Invokes the method against the target object.
         *
         * @param targetObject the object against which the method should be invoked.
         */
        void callMethod(U targetObject) throws E;
    }

    /**
     * Invokes the specified method on the targetObject as the shell user. The method can be invoked
     * as follows:
     *
     * {@code ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,
     *        (tm) -> tm.getDeviceId());}
     */
    public static <T, U> T invokeMethodWithShellPermissions(U targetObject,
            ShellPermissionMethodHelper<T, U> methodHelper) {
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            return methodHelper.callMethod(targetObject);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Invokes the specified method on the targetObject as the shell user with only the subset of
     * permissions specified. The method can be invoked as follows:
     *
     * {@code ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,
     *        (tm) -> tm.getDeviceId(), ""android.permission.READ_PHONE_STATE"");}
     */
    public static <T, U> T invokeMethodWithShellPermissions(U targetObject,
            ShellPermissionMethodHelper<T, U> methodHelper, String... permissions) {
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity(permissions);
            return methodHelper.callMethod(targetObject);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /** A three argument {@link java.util.function.Function}. */
    public interface TriFunction<T, U, V, R> {
        R apply(T t, U u, V v);
    }

    /** A four argument {@link java.util.function.Function}. */
    public interface QuadFunction<T, U, V, W, R> {
        R apply(T t, U u, V v, W w);
    }

    /**
     * Invokes the specified method wht arg1 and arg2, as the shell user
     * with only the subset of permissions specified. The method can be invoked as follows:
     *
     * {@code ShellIdentityUtils.invokeMethodWithShellPermissions(op, pers,
     *        mTelephonyManager::setNetworkSelectionModeManual(on, p),
     *        ""android.permission.MODIFY_PHONE_STATE"");}
     */
    public static <T, U, R> R invokeMethodWithShellPermissions(T arg1, U arg2,
            BiFunction<? super T, ? super U, ? extends R>  methodHelper, String... permissions) {
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity(permissions);
            return methodHelper.apply(arg1, arg2);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Invokes the specified method with arg1, arg2 and arg3, as the shell user
     * with only the subset of permissions specified. The method can be invoked as follows:
     *
     * {@code ShellIdentityUtils.invokeMethodWithShellPermissions(req, cb, exe,
     *        mTelephonyManager::requestNetworkScan,
     *        ""android.permission.MODIFY_PHONE_STATE"",
     *        ""android.permission.ACCESS_FINE_LOCATION"");}
     */
    public static <T, U, V, R> R invokeMethodWithShellPermissions(T arg1, U arg2, V arg3,
            TriFunction<? super T, ? super U, ? super V, ? extends R>  methodHelper,
            String... permissions) {
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity(permissions);
            return methodHelper.apply(arg1, arg2, arg3);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Invokes the specified method with arg1, arg2, arg3 and arg4, as the shell
     * user with only the subset of permissions specified. The method can be invoked as follows:
     *
     * {@code ShellIdentityUtils.invokeMethodWithShellPermissions(a, b, c, d,
     *        mTelephonyManager::requestSomething,
     *        ""android.permission.MODIFY_PHONE_STATE"",
     *        ""android.permission.ACCESS_FINE_LOCATION"");}
     */
    public static <T, U, V, W, R> R invokeMethodWithShellPermissions(T arg1, U arg2, V arg3, W arg4,
            QuadFunction<? super T, ? super U, ? super V, ? super W, ? extends R>  methodHelper,
            String... permissions) {
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity(permissions);
            return methodHelper.apply(arg1, arg2, arg3, arg4);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Invokes the specified method on the targetObject as the shell user with only the subset of
     * permissions specified. The method can be invoked as follows:
     *
     * {@code ShellIdentityUtils.invokeMethodWithShellPermissions(mRcsUceAdapter,
     *        (m) -> RcsUceAdapter::getUcePublishState, ImsException.class,
     *                     ""android.permission.READ_PRIVILEGED_PHONE_STATE"")}
     */
    public static <T, U, E extends Throwable> T invokeThrowableMethodWithShellPermissions(
            U targetObject, ShellPermissionThrowableMethodHelper<T, U, E> methodHelper,
            Class<E> clazz, String... permissions) throws E {
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity(permissions);
            return methodHelper.callMethod(targetObject);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Invokes the specified method on the targetObject as the shell user for only the permissions
     * specified. The method can be invoked as follows:
     *
     * {@code ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,
     *        (tm) -> tm.getDeviceId(), ""android.permission.READ_PHONE_STATE"");}
     */
    public static <U> void invokeMethodWithShellPermissionsNoReturn(
            U targetObject, ShellPermissionMethodHelperNoReturn<U> methodHelper,
            String... permissions) {
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity(permissions);
            methodHelper.callMethod(targetObject);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Invokes the specified throwable method on the targetObject as the shell user with only the
     * subset of permissions specified specified. The method can be invoked as follows:
     *
     * {@code ShellIdentityUtils.invokeMethodWithShellPermissions(mImsMmtelManager,
     *        (m) -> m.isSupported(...), ImsException.class);}
     */
    public static <U, E extends Throwable> void invokeThrowableMethodWithShellPermissionsNoReturn(
            U targetObject, ShellPermissionThrowableMethodHelperNoReturn<U, E> methodHelper,
            Class<E> clazz) throws E {
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            methodHelper.callMethod(targetObject);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Invokes the specified throwable method on the targetObject as the shell user with only the
     * subset of permissions specified specified. The method can be invoked as follows:
     *
     * {@code ShellIdentityUtils.invokeMethodWithShellPermissions(mImsMmtelManager,
     *        (m) -> m.isSupported(...), ImsException.class,
     *        ""android.permission.READ_PRIVILEGED_PHONE_STATE"");}
     */
    public static <U, E extends Throwable> void invokeThrowableMethodWithShellPermissionsNoReturn(
            U targetObject, ShellPermissionThrowableMethodHelperNoReturn<U, E> methodHelper,
            Class<E> clazz, String... permissions) throws E {
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity(permissions);
            methodHelper.callMethod(targetObject);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }


    /**
     * Invokes the specified method on the targetObject as the shell user. The method can be invoked
     * as follows:
     *
     * {@code ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,
     *        (tm) -> tm.getDeviceId());}
     */
    public static <U> void invokeMethodWithShellPermissionsNoReturn(
            U targetObject, ShellPermissionMethodHelperNoReturn<U> methodHelper) {
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            methodHelper.callMethod(targetObject);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Utility interface to invoke a static method.
     *
     * @param <T> the type returned by the invoked method.
     */
    public interface StaticShellPermissionMethodHelper<T> {
        /**
         * Invokes the static method.
         *
         * @return the result of the invoked method.
         */
        T callMethod();
    }

    /**
     * Invokes the specified static method as the shell user. This method can be invoked as follows:
     *
     * {@code ShellIdentityUtils.invokeStaticMethodWithShellPermissions(Build::getSerial));}
     */
    public static <T> T invokeStaticMethodWithShellPermissions(
            StaticShellPermissionMethodHelper<T> methodHelper) {
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            return methodHelper.callMethod();
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Drop the shell permission identity adopted by a previous call to
     * {@link UiAutomation#adoptShellPermissionIdentity()}.
     */
    public static void dropShellPermissionIdentity() {
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();

        uiAutomation.dropShellPermissionIdentity();
    }

    /**
     * Run an arbitrary piece of code while holding shell permissions.
     *
     * @param supplier an expression that performs the desired operation with shell permissions
     * @param <T> the return type of the expression
     * @return the return value of the expression
     */
    public static <T> T invokeWithShellPermissions(Supplier<T> supplier) {
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            return supplier.get();
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Run an arbitrary piece of code while holding shell permissions.
     *
     * @param runnable an expression that performs the desired operation with shell permissions
     * @return the return value of the expression
     */
    public static void invokeWithShellPermissions(Runnable runnable) {
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            runnable.run();
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }
}"	""	""	"RCS MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.ImsServiceConnector"	"checkConfigurationExists"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceConnector.java"	""	"public void test/*
 *.
 */

package android.telephony.ims.cts;

import android.app.Instrumentation;
import android.app.role.RoleManager;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.ServiceConnection;
import android.os.IBinder;
import android.telephony.cts.TelephonyUtils;
import android.telephony.cts.externalimsservice.ITestExternalImsService;
import android.telephony.cts.externalimsservice.TestExternalImsService;
import android.telephony.ims.feature.ImsFeature;
import android.telephony.ims.stub.ImsFeatureConfiguration;
import android.text.TextUtils;
import android.util.Log;
import android.util.SparseArray;

import androidx.test.platform.app.InstrumentationRegistry;

import com.android.compatibility.common.util.ShellIdentityUtils;

import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;

/**
 * Connects The CTS test ImsService to the Telephony Framework.
 */
class ImsServiceConnector {

    private static final String TAG = ""CtsImsServiceConnector"";

    private static final String PACKAGE_NAME =
            InstrumentationRegistry.getInstrumentation().getTargetContext().getPackageName();
    private static final String EXTERNAL_PACKAGE_NAME =
            TestExternalImsService.class.getPackage().getName();

    private static final String COMMAND_BASE = ""cmd phone "";
    private static final String COMMAND_SET_IMS_SERVICE = ""ims set-ims-service "";
    private static final String COMMAND_GET_IMS_SERVICE = ""ims get-ims-service "";
    private static final String COMMAND_CLEAR_SERVICE_OVERRIDE = ""ims clear-ims-service-override"";
    private static final String COMMAND_CARRIER_SERVICE_IDENTIFIER = ""-c "";
    private static final String COMMAND_DEVICE_SERVICE_IDENTIFIER = ""-d "";
    private static final String COMMAND_SLOT_IDENTIFIER = ""-s "";
    private static final String COMMAND_FEATURE_IDENTIFIER = ""-f "";
    private static final String COMMAND_ENABLE_IMS = ""ims enable "";
    private static final String COMMAND_DISABLE_IMS = ""ims disable "";
    private static final String COMMAND_SET_DEVICE_SINGLE_REGISTRATION_ENABLED =
            ""src set-device-enabled "";
    private static final String COMMAND_GET_DEVICE_SINGLE_REGISTRATION_ENABLED =
            ""src get-device-enabled"";
    private static final String COMMAND_SET_CARRIER_SINGLE_REGISTRATION_ENABLED =
            ""src set-carrier-enabled "";
    private static final String COMMAND_GET_CARRIER_SINGLE_REGISTRATION_ENABLED =
            ""src get-carrier-enabled"";
    private static final String COMMAND_REMOVE_EAB_CONTACT = ""uce remove-eab-contact "";
    private static final String COMMAND_GET_UCE_ENABLED = ""uce get-device-enabled"";
    private static final String COMMAND_SET_UCE_ENABLED = ""uce set-device-enabled "";
    private static final String COMMAND_REMOVE_UCE_REQUEST_DISALLOWED_STATUS =
            ""uce remove-request-disallowed-status "";
    private static final String COMMAND_SET_CAPABILITY_REQUEST_TIMEOUT =
            ""uce set-capabilities-request-timeout "";
    private static final String COMMAND_SET_TEST_MODE_ENABLED = ""src set-test-enabled "";
    private static final String COMMAND_SET_D2D_ENABLED = ""d2d set-device-support "";

    private class TestCarrierServiceConnection implements ServiceConnection {

        private final CountDownLatch mLatch;

        TestCarrierServiceConnection(CountDownLatch latch) {
            mLatch = latch;
        }

        @Override
        public void onServiceConnected(ComponentName name, IBinder service) {
            mCarrierService = ((TestImsService.LocalBinder) service).getService();
            mLatch.countDown();
        }

        @Override
        public void onServiceDisconnected(ComponentName name) {
            mCarrierService = null;
        }
    }

    private class TestDeviceServiceConnection implements ServiceConnection {

        private final CountDownLatch mLatch;

        TestDeviceServiceConnection(CountDownLatch latch) {
            mLatch = latch;
        }

        @Override
        public void onServiceConnected(ComponentName name, IBinder service) {
            mExternalService = ITestExternalImsService.Stub.asInterface(service);
            mLatch.countDown();
        }

        @Override
        public void onServiceDisconnected(ComponentName name) {
            mCarrierService = null;
        }
    }

    public class Connection {

        private static final int CONNECTION_TYPE_IMS_SERVICE_DEVICE = 1;
        private static final int CONNECTION_TYPE_IMS_SERVICE_CARRIER = 2;
        private static final int CONNECTION_TYPE_DEFAULT_SMS_APP = 3;

        private boolean mIsServiceOverridden = false;
        private String mOrigMmTelServicePackage;
        private String mOrigRcsServicePackage;
        private String mOrigSmsPackage;
        private int mConnectionType;
        private int mSlotId;
        private SparseArray<String> mFeatureTypeToPackageOverrideMap = new SparseArray<>(2);
        Connection(int connectionType, int slotId) {
            mConnectionType = connectionType;
            mSlotId = slotId;
        }

        void clearPackage() throws Exception {
            mIsServiceOverridden = true;
            switch (mConnectionType) {
                case CONNECTION_TYPE_IMS_SERVICE_CARRIER: {
                    setCarrierImsService(""none"");
                    break;
                }
                case CONNECTION_TYPE_IMS_SERVICE_DEVICE: {
                    setDeviceImsService("""");
                    break;
                }
                case CONNECTION_TYPE_DEFAULT_SMS_APP: {
                    // We don't need to clear anything for default SMS app.
                    break;
                }
            }
        }

        boolean overrideService(ImsFeatureConfiguration config) throws Exception {
            mIsServiceOverridden = true;
            switch (mConnectionType) {
                case CONNECTION_TYPE_IMS_SERVICE_CARRIER: {
                    return bindCarrierImsService(config, PACKAGE_NAME);
                }
                case CONNECTION_TYPE_IMS_SERVICE_DEVICE: {
                    return bindDeviceImsService(config, EXTERNAL_PACKAGE_NAME);
                }
                case CONNECTION_TYPE_DEFAULT_SMS_APP: {
                    return setDefaultSmsApp(PACKAGE_NAME);
                }
            }
            return false;
        }

        void restoreOriginalPackage() throws Exception {
            if (!mIsServiceOverridden) {
                return;
            }
            mIsServiceOverridden = false;

            if (mOrigRcsServicePackage == null) {
                mOrigRcsServicePackage = """";
            }

            if (mOrigMmTelServicePackage == null) {
                mOrigMmTelServicePackage = """";
            }

            switch (mConnectionType) {
                case CONNECTION_TYPE_IMS_SERVICE_CARRIER: {
                    clearCarrierImsServiceOverride();
                    break;
                }
                case CONNECTION_TYPE_IMS_SERVICE_DEVICE: {
                    setDeviceImsService(mOrigMmTelServicePackage, ImsFeature.FEATURE_MMTEL);
                    setDeviceImsService(mOrigRcsServicePackage, ImsFeature.FEATURE_RCS);
                    break;
                }
                case CONNECTION_TYPE_DEFAULT_SMS_APP: {
                    setDefaultSmsApp(mOrigSmsPackage);
                    break;
                }
            }
        }

        /**
         * @return true if the configuration set here still exists in telephony or false if it was
         * changed (due to something like a Phone process crash).
         */
        boolean checkConfigurationExists() throws Exception {
            boolean result = true;
            String mmTelPackage = mFeatureTypeToPackageOverrideMap.get(ImsFeature.FEATURE_MMTEL);
            String rcsPackage = mFeatureTypeToPackageOverrideMap.get(ImsFeature.FEATURE_RCS);
            switch (mConnectionType) {
                case CONNECTION_TYPE_IMS_SERVICE_CARRIER: {
                    result &= isPackageTheSame(mmTelPackage, getMmTelCarrierService());
                    result &= isPackageTheSame(rcsPackage, getRcsCarrierService());
                    break;
                }
                case CONNECTION_TYPE_IMS_SERVICE_DEVICE: {
                    result &= isPackageTheSame(mmTelPackage, getMmTelDeviceService());
                    result &= isPackageTheSame(rcsPackage, getRcsDeviceService());
                    break;
                }
                case CONNECTION_TYPE_DEFAULT_SMS_APP: {
                    break;
                }
            }
            return result;
        }

        private boolean isPackageTheSame(String pkgA, String pkgB) {
            if (TextUtils.isEmpty(pkgA) && TextUtils.isEmpty(pkgB)) {
                return true;
            }
            return TextUtils.equals(pkgA, pkgB);
        }

        private void storeOriginalPackage() throws Exception {
            switch (mConnectionType) {
                case CONNECTION_TYPE_IMS_SERVICE_CARRIER: {
                    mOrigMmTelServicePackage = getMmTelCarrierService();
                    mOrigRcsServicePackage = getRcsCarrierService();
                    break;
                }
                case CONNECTION_TYPE_IMS_SERVICE_DEVICE: {
                    mOrigMmTelServicePackage = getMmTelDeviceService();
                    mOrigRcsServicePackage = getRcsDeviceService();
                    break;
                }
                case CONNECTION_TYPE_DEFAULT_SMS_APP: {
                    mOrigSmsPackage = getDefaultSmsApp();
                    break;
                }
            }
        }

        private boolean setDeviceImsService(String packageName) throws Exception {
            mFeatureTypeToPackageOverrideMap.put(ImsFeature.FEATURE_MMTEL, packageName);
            mFeatureTypeToPackageOverrideMap.put(ImsFeature.FEATURE_RCS, packageName);
            String result = TelephonyUtils.executeShellCommand(mInstrumentation,
                    constructSetImsServiceOverrideCommand(false, packageName, new int[] {
                            ImsFeature.FEATURE_MMTEL, ImsFeature.FEATURE_RCS}));
            if (ImsUtils.VDBG) {
                Log.d(TAG, ""setDeviceMmTelImsService result: "" + result);
            }
            return ""true"".equals(result);
        }

        private boolean setCarrierImsService(String packageName) throws Exception {
            mFeatureTypeToPackageOverrideMap.put(ImsFeature.FEATURE_MMTEL, packageName);
            mFeatureTypeToPackageOverrideMap.put(ImsFeature.FEATURE_RCS, packageName);
            String result = TelephonyUtils.executeShellCommand(mInstrumentation,
                    constructSetImsServiceOverrideCommand(true, packageName, new int[] {
                            ImsFeature.FEATURE_EMERGENCY_MMTEL, ImsFeature.FEATURE_MMTEL,
                            ImsFeature.FEATURE_RCS}));
            if (ImsUtils.VDBG) {
                Log.d(TAG, ""setCarrierMmTelImsService result: "" + result);
            }
            return ""true"".equals(result);
        }

        private boolean setDeviceImsService(String packageName, int featureType) throws Exception {
            mFeatureTypeToPackageOverrideMap.put(featureType, packageName);
            String result = TelephonyUtils.executeShellCommand(mInstrumentation,
                    constructSetImsServiceOverrideCommand(false, packageName,
                            new int[]{featureType}));
            if (ImsUtils.VDBG) {
                Log.d(TAG, ""setDeviceMmTelImsService result: "" + result);
            }
            return ""true"".equals(result);
        }

        private boolean setCarrierImsService(String packageName, int featureType) throws Exception {
            mFeatureTypeToPackageOverrideMap.put(featureType, packageName);
            String result = TelephonyUtils.executeShellCommand(mInstrumentation,
                    constructSetImsServiceOverrideCommand(true, packageName,
                            new int[]{featureType}));
            if (ImsUtils.VDBG) {
                Log.d(TAG, ""setCarrierMmTelImsService result: "" + result);
            }
            return ""true"".equals(result);
        }

        private boolean clearCarrierImsServiceOverride() throws Exception {
            String result = TelephonyUtils.executeShellCommand(mInstrumentation,
                    constructClearCarrierImsServiceOverrideCommand());
            if (ImsUtils.VDBG) {
                Log.d(TAG, ""clearCarrierImsServiceOverride result: "" + result);
            }
            return ""true"".equals(result);
        }

        private boolean setDefaultSmsApp(String packageName) throws Exception {
            RoleManager roleManager = mInstrumentation.getContext()
                    .getSystemService(RoleManager.class);
            Boolean result;
            LinkedBlockingQueue<Boolean> queue = new LinkedBlockingQueue<>(1);
            if (TextUtils.isEmpty(packageName)) {
                ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(roleManager,
                        (m) -> m.clearRoleHoldersAsUser(RoleManager.ROLE_SMS,
                                RoleManager.MANAGE_HOLDERS_FLAG_DONT_KILL_APP,
                                android.os.Process.myUserHandle(),
                                // Run on calling binder thread.
                                Runnable::run, queue::offer));
            } else {
                ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(roleManager,
                        (m) -> m.addRoleHolderAsUser(RoleManager.ROLE_SMS, packageName, 0,
                                android.os.Process.myUserHandle(),
                                // Run on calling binder thread.
                                Runnable::run, queue::offer));
            }
            result = queue.poll(ImsUtils.TEST_TIMEOUT_MS, TimeUnit.MILLISECONDS);
            if (ImsUtils.VDBG) {
                Log.d(TAG, ""setDefaultSmsApp result: "" + result);
            }
            return result;
        }

        private String getDefaultSmsApp() throws Exception {
            RoleManager roleManager = mInstrumentation.getContext()
                    .getSystemService(RoleManager.class);
            List<String> result = ShellIdentityUtils.invokeMethodWithShellPermissions(roleManager,
                    (m) -> m.getRoleHolders(RoleManager.ROLE_SMS));
            if (ImsUtils.VDBG) {
                Log.d(TAG, ""getDefaultSmsApp result: "" + result);
            }
            if (result.isEmpty()) {
                // No default SMS app.
                return null;
            }
            // There should only be one default sms app
            return result.get(0);
        }

        private boolean bindCarrierImsService(ImsFeatureConfiguration config, String packageName)
                throws Exception {
            getCarrierService().setFeatureConfig(config);
            return setCarrierImsService(packageName) && getCarrierService().waitForLatchCountdown(
                            TestImsService.LATCH_FEATURES_READY);
        }

        private boolean bindDeviceImsService(ImsFeatureConfiguration config, String packageName)
                throws Exception {
            getExternalService().setFeatureConfig(config);
            return setDeviceImsService(packageName) && getExternalService().waitForLatchCountdown(
                    TestImsService.LATCH_FEATURES_READY);
        }

        private String getMmTelCarrierService() throws Exception {
            String result = TelephonyUtils.executeShellCommand(mInstrumentation,
                    constructGetImsServiceCommand(true, ImsFeature.FEATURE_MMTEL));
            if (ImsUtils.VDBG) {
                Log.d(TAG, ""getMmTelCarrierService result: "" + result);
            }
            return result;
        }

        private String getRcsCarrierService() throws Exception {
            String result = TelephonyUtils.executeShellCommand(mInstrumentation,
                    constructGetImsServiceCommand(true, ImsFeature.FEATURE_RCS));
            if (ImsUtils.VDBG) {
                Log.d(TAG, ""getRcsCarrierService result: "" + result);
            }
            return result;
        }

        private String getMmTelDeviceService() throws Exception {
            String result = TelephonyUtils.executeShellCommand(mInstrumentation,
                    constructGetImsServiceCommand(false, ImsFeature.FEATURE_MMTEL));
            if (ImsUtils.VDBG) {
                Log.d(TAG, ""getMmTelDeviceService result: "" + result);
            }
            return result;
        }

        private String getRcsDeviceService() throws Exception {
            String result = TelephonyUtils.executeShellCommand(mInstrumentation,
                    constructGetImsServiceCommand(false, ImsFeature.FEATURE_RCS));
            if (ImsUtils.VDBG) {
                Log.d(TAG, ""getRcsDeviceService result: "" + result);
            }
            return result;
        }

        private String constructSetImsServiceOverrideCommand(boolean isCarrierService,
                String packageName, int[] featureTypes) {
            return COMMAND_BASE + COMMAND_SET_IMS_SERVICE + COMMAND_SLOT_IDENTIFIER + mSlotId + "" ""
                    + (isCarrierService
                        ? COMMAND_CARRIER_SERVICE_IDENTIFIER : COMMAND_DEVICE_SERVICE_IDENTIFIER)
                    + COMMAND_FEATURE_IDENTIFIER + getFeatureTypesString(featureTypes) + "" ""
                    + packageName;
        }

        private String constructGetImsServiceCommand(boolean isCarrierService, int featureType) {
            return COMMAND_BASE + COMMAND_GET_IMS_SERVICE + COMMAND_SLOT_IDENTIFIER + mSlotId + "" ""
                    + (isCarrierService
                        ? COMMAND_CARRIER_SERVICE_IDENTIFIER : COMMAND_DEVICE_SERVICE_IDENTIFIER)
                    + COMMAND_FEATURE_IDENTIFIER + featureType;
        }

        private String constructClearCarrierImsServiceOverrideCommand() {
            return COMMAND_BASE + COMMAND_CLEAR_SERVICE_OVERRIDE + COMMAND_SLOT_IDENTIFIER
                    + mSlotId;
        }

        private String getFeatureTypesString(int[] featureTypes) {
            if (featureTypes.length == 0) return """";
            StringBuilder builder = new StringBuilder();
            builder.append(featureTypes[0]);
            for (int i = 1; i < featureTypes.length; i++) {
                builder.append("","");
                builder.append(featureTypes[i]);
            }
            return builder.toString();
        }
    }

    private Instrumentation mInstrumentation;

    private TestImsService mCarrierService;
    private TestCarrierServiceConnection mCarrierServiceConn;
    private ITestExternalImsService mExternalService;
    private TestDeviceServiceConnection mExternalServiceConn;

    private Connection mDeviceServiceConnection;
    private Connection mCarrierServiceConnection;
    private Connection mDefaultSmsAppConnection;

    ImsServiceConnector(Instrumentation instrumentation) {
        mInstrumentation = instrumentation;
    }

    void clearAllActiveImsServices(int slotId) throws Exception {
        mDeviceServiceConnection = new Connection(Connection.CONNECTION_TYPE_IMS_SERVICE_DEVICE,
                slotId);
        mDeviceServiceConnection.storeOriginalPackage();
        mDeviceServiceConnection.clearPackage();

        mCarrierServiceConnection = new Connection(Connection.CONNECTION_TYPE_IMS_SERVICE_CARRIER,
                slotId);
        mCarrierServiceConnection.storeOriginalPackage();
        mCarrierServiceConnection.clearPackage();

        mDefaultSmsAppConnection = new Connection(Connection.CONNECTION_TYPE_DEFAULT_SMS_APP,
                slotId);
        mDefaultSmsAppConnection.storeOriginalPackage();
        // No need to clear SMS App, only replace when necessary.
    }

    /**
     * Binds to the local implementation of ImsService but does not trigger ImsService bind from
     * telephony to allow additional configuration steps.
     * @return true if this request succeeded, false otherwise.
     */
    boolean connectCarrierImsServiceLocally() {
        if (!setupLocalCarrierImsService()) {
            Log.w(TAG, ""connectCarrierImsService: couldn't set up service."");
            return false;
        }
        mCarrierService.resetState();
        return true;
    }

    /**
     * Trigger the telephony framework to bind to the local ImsService implementation.
     * @return true if this request succeeded, false otherwise.
     */
    boolean triggerFrameworkConnectionToCarrierImsService(
            ImsFeatureConfiguration config) throws Exception {
        return mCarrierServiceConnection.overrideService(config);
    }

    boolean connectCarrierImsService(ImsFeatureConfiguration config) throws Exception {
        if (!connectCarrierImsServiceLocally()) return false;
        return triggerFrameworkConnectionToCarrierImsService(config);
    }

    boolean connectDeviceImsService(ImsFeatureConfiguration config) throws Exception {
        if (!setupExternalImsService()) {
            Log.w(TAG, ""connectDeviceImsService: couldn't set up service."");
            return false;
        }
        mExternalService.resetState();
        return mDeviceServiceConnection.overrideService(config);
    }

    boolean setDefaultSmsApp() throws Exception {
        return mDefaultSmsAppConnection.overrideService(null);
    }

    void restoreDefaultSmsApp() throws Exception {
        mDefaultSmsAppConnection.restoreOriginalPackage();
    }

    void disconnectCarrierImsService() throws Exception {
        mCarrierServiceConnection.clearPackage();
    }

    void disconnectDeviceImsService() throws Exception {
        mDeviceServiceConnection.clearPackage();
    }

    boolean isCarrierServiceStillConfigured() throws Exception {
        return mCarrierServiceConnection.checkConfigurationExists();
    }

    private boolean setupLocalCarrierImsService() {
        if (mCarrierService != null) {
            return true;
        }
        CountDownLatch latch = new CountDownLatch(1);
        mCarrierServiceConn = new TestCarrierServiceConnection(latch);
        mInstrumentation.getContext().bindService(new Intent(mInstrumentation.getContext(),
                        TestImsService.class), mCarrierServiceConn, Context.BIND_AUTO_CREATE);
        try {
            return latch.await(5000, TimeUnit.MILLISECONDS);
        } catch (InterruptedException e) {
            return false;
        }
    }

    private boolean setupExternalImsService() {
        if (mExternalService != null) {
            return true;
        }
        CountDownLatch latch = new CountDownLatch(1);
        mExternalServiceConn = new TestDeviceServiceConnection(latch);
        Intent deviceIntent = new Intent();
        deviceIntent.setComponent(new ComponentName(EXTERNAL_PACKAGE_NAME,
                TestExternalImsService.class.getName()));
        mInstrumentation.getContext().bindService(deviceIntent, mExternalServiceConn,
                Context.BIND_AUTO_CREATE);
        try {
            return latch.await(5000, TimeUnit.MILLISECONDS);
        } catch (InterruptedException e) {
            return false;
        }
    }

    // Detect and disconnect all active services.
    void disconnectServices() throws Exception {
        // Remove local connection
        if (mCarrierServiceConn != null) {
            mInstrumentation.getContext().unbindService(mCarrierServiceConn);
            mCarrierService = null;
        }
        if (mExternalServiceConn != null) {
            mInstrumentation.getContext().unbindService(mExternalServiceConn);
            mExternalService = null;
        }
        mDeviceServiceConnection.restoreOriginalPackage();
        mCarrierServiceConnection.restoreOriginalPackage();
        mDefaultSmsAppConnection.restoreOriginalPackage();

        // Remove any overrides for single registration state
        setDeviceSingleRegistrationEnabled(null);
    }

    void enableImsService(int slot) throws Exception {
        TelephonyUtils.executeShellCommand(mInstrumentation, COMMAND_BASE + COMMAND_ENABLE_IMS
                + COMMAND_SLOT_IDENTIFIER + slot);
    }

    void disableImsService(int slot) throws Exception {
        TelephonyUtils.executeShellCommand(mInstrumentation, COMMAND_BASE + COMMAND_DISABLE_IMS
                + COMMAND_SLOT_IDENTIFIER + slot);
    }

    void setDeviceSingleRegistrationEnabled(Boolean enabled) throws Exception {
        TelephonyUtils.executeShellCommand(mInstrumentation, COMMAND_BASE
                + COMMAND_SET_DEVICE_SINGLE_REGISTRATION_ENABLED
                // if ""null"" is sent, it will remove override
                + (enabled != null ? enabled : ""null""));
    }

    boolean getDeviceSingleRegistrationEnabled() throws Exception {
        return Boolean.parseBoolean(TelephonyUtils.executeShellCommand(mInstrumentation,
                COMMAND_BASE + COMMAND_GET_DEVICE_SINGLE_REGISTRATION_ENABLED));
    }

    boolean getCarrierSingleRegistrationEnabled() throws Exception {
        return Boolean.parseBoolean(TelephonyUtils.executeShellCommand(mInstrumentation,
                COMMAND_BASE + COMMAND_GET_CARRIER_SINGLE_REGISTRATION_ENABLED));
    }

    boolean getDeviceUceEnabled() throws Exception {
        return Boolean.parseBoolean(TelephonyUtils.executeShellCommand(mInstrumentation,
                COMMAND_BASE + COMMAND_GET_UCE_ENABLED));
    }

    void setDeviceUceEnabled(boolean isEnabled) throws Exception {
        TelephonyUtils.executeShellCommand(mInstrumentation,
                COMMAND_BASE + COMMAND_SET_UCE_ENABLED + isEnabled);
    }

    void removeEabContacts(int slotId, String phoneNum) throws Exception {
        StringBuilder cmdBuilder = new StringBuilder();
        cmdBuilder.append(COMMAND_BASE).append(COMMAND_REMOVE_EAB_CONTACT)
                .append(COMMAND_SLOT_IDENTIFIER).append(slotId).append("" "").append(phoneNum);
        TelephonyUtils.executeShellCommand(mInstrumentation, cmdBuilder.toString());
    }

    TestImsService getCarrierService() {
        return mCarrierService;
    }

    ITestExternalImsService getExternalService() {
        return mExternalService;
    }

    void setSingleRegistrationTestModeEnabled(boolean enabled) throws Exception {
        TelephonyUtils.executeShellCommand(mInstrumentation, COMMAND_BASE
                + COMMAND_SET_TEST_MODE_ENABLED  + (enabled ? ""true"" : ""false""));
    }

    void removeUceRequestDisallowedStatus(int slotId) throws Exception {
        StringBuilder cmdBuilder = new StringBuilder();
        cmdBuilder.append(COMMAND_BASE).append(COMMAND_REMOVE_UCE_REQUEST_DISALLOWED_STATUS)
                .append(COMMAND_SLOT_IDENTIFIER).append(slotId);
        TelephonyUtils.executeShellCommand(mInstrumentation, cmdBuilder.toString());
    }

    void setCapabilitiesRequestTimeout(int slotId, long timeoutAfterMs) throws Exception {
        StringBuilder cmdBuilder = new StringBuilder();
        cmdBuilder.append(COMMAND_BASE).append(COMMAND_SET_CAPABILITY_REQUEST_TIMEOUT)
                .append(COMMAND_SLOT_IDENTIFIER).append(slotId).append("" "").append(timeoutAfterMs);
        TelephonyUtils.executeShellCommand(mInstrumentation, cmdBuilder.toString());
    }

    void setDeviceToDeviceCommunicationEnabled(boolean enabled) throws Exception {
        TelephonyUtils.executeShellCommand(mInstrumentation, COMMAND_BASE
                + COMMAND_SET_D2D_ENABLED  + (enabled ? ""true"" : ""default""));
    }
}"	""	""	"RCS MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.media.cts.VideoCodecTestBase"	"isEncoder"	"CtsMediaTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/VideoCodecTestBase.java"	""	"public void test/*
 *.
 */

package android.media.cts;

import android.content.Context;
import android.content.res.Resources;
import android.media.MediaCodec;
import android.media.MediaCodec.CodecException;
import android.media.MediaCodecInfo.CodecCapabilities;
import android.media.MediaCodecList;
import android.media.MediaCodecInfo;
import android.media.MediaFormat;
import android.os.Bundle;
import android.os.Environment;
import android.os.Looper;
import android.os.Handler;
import android.platform.test.annotations.AppModeFull;
import android.test.AndroidTestCase;
import android.util.Log;

import com.android.compatibility.common.util.MediaUtils;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Locale;
import java.util.concurrent.Callable;
import java.util.concurrent.CountDownLatch;

/**
 * Verification test for video encoder and decoder.
 *
 * A raw yv12 stream is encoded at various settings and written to an IVF
 * file. Encoded stream bitrate and key frame interval are checked against target values.
 * The stream is later decoded by the decoder to verify frames are decodable and to
 * calculate PSNR values for various bitrates.
 */
@AppModeFull(reason = ""Instant apps cannot access the SD card"")
public class VideoCodecTestBase extends AndroidTestCase {

    protected static final String TAG = ""VideoCodecTestBase"";
    protected static final String VP8_MIME = MediaFormat.MIMETYPE_VIDEO_VP8;
    protected static final String VP9_MIME = MediaFormat.MIMETYPE_VIDEO_VP9;
    protected static final String AVC_MIME = MediaFormat.MIMETYPE_VIDEO_AVC;
    protected static final String HEVC_MIME = MediaFormat.MIMETYPE_VIDEO_HEVC;
    protected static final String SDCARD_DIR =
            Environment.getExternalStorageDirectory().getAbsolutePath();
    static final String mInpPrefix = WorkDir.getMediaDirString();

    // Default timeout for MediaCodec buffer dequeue - 200 ms.
    protected static final long DEFAULT_DEQUEUE_TIMEOUT_US = 200000;
    // Default timeout for MediaEncoderAsync - 30 sec.
    protected static final long DEFAULT_ENCODE_TIMEOUT_MS = 30000;
    // Default sync frame interval in frames
    private static final int SYNC_FRAME_INTERVAL = 30;
    // Video bitrate type - should be set to OMX_Video_ControlRateConstant from OMX_Video.h
    protected static final int VIDEO_ControlRateVariable = 1;
    protected static final int VIDEO_ControlRateConstant = 2;
    // NV12 color format supported by QCOM codec, but not declared in MediaCodec -
    // see /hardware/qcom/media/mm-core/inc/OMX_QCOMExtns.h
    private static final int COLOR_QCOM_FORMATYUV420PackedSemiPlanar32m = 0x7FA30C04;
    // Allowable color formats supported by codec - in order of preference.
    private static final int[] mSupportedColorList = {
            CodecCapabilities.COLOR_FormatYUV420Planar,
            CodecCapabilities.COLOR_FormatYUV420SemiPlanar,
            CodecCapabilities.COLOR_QCOM_FormatYUV420SemiPlanar,
            COLOR_QCOM_FORMATYUV420PackedSemiPlanar32m
    };
    // Scaled image cache list - contains scale factors, for which up-scaled frames
    // were calculated and were written to yuv file.
    ArrayList<Integer> mScaledImages = new ArrayList<Integer>();

    private Resources mResources;

    @Override
    public void setContext(Context context) {
        super.setContext(context);
        mResources = mContext.getResources();
    }

    /**
     *  Video codec properties generated by getVideoCodecProperties() function.
     */
    private class CodecProperties {
        CodecProperties(String codecName, int colorFormat) {
            this.codecName = codecName;
            this.colorFormat = colorFormat;
        }
        public final String codecName; // OpenMax component name for Video codec.
        public final int colorFormat;  // Color format supported by codec.
    }

    /**
     * Function to find Video codec.
     *
     * Iterates through the list of available codecs and tries to find
     * Video codec, which can support either YUV420 planar or NV12 color formats.
     * If forceGoogleCodec parameter set to true the function always returns
     * Google Video codec.
     * If forceGoogleCodec parameter set to false the functions looks for platform
     * specific Video codec first. If no platform specific codec exist, falls back to
     * Google Video codec.
     *
     * @param isEncoder     Flag if encoder is requested.
     * @param forceGoogleCodec  Forces to use Google codec.
     */
    private CodecProperties getVideoCodecProperties(
            boolean isEncoder,
            MediaFormat format,
            boolean forceGoogleCodec) throws Exception {
        CodecProperties codecProperties = null;
        String mime = format.getString(MediaFormat.KEY_MIME);

        // Loop through the list of codec components in case platform specific codec
        // is requested.
        MediaCodecList mcl = new MediaCodecList(MediaCodecList.REGULAR_CODECS);
        for (MediaCodecInfo codecInfo : mcl.getCodecInfos()) {
            if (isEncoder != codecInfo.isEncoder()) {
                continue;
            }
            Log.v(TAG, codecInfo.getName());
            // TODO: remove dependence of Google from the test
            // Check if this is Google codec - we should ignore it.
            if (codecInfo.isVendor() && forceGoogleCodec) {
                continue;
            }

            for (String type : codecInfo.getSupportedTypes()) {
                if (!type.equalsIgnoreCase(mime)) {
                    continue;
                }
                CodecCapabilities capabilities = codecInfo.getCapabilitiesForType(type);
                if (!capabilities.isFormatSupported(format)) {
                    continue;
                }

                // Get candidate codec properties.
                Log.v(TAG, ""Found candidate codec "" + codecInfo.getName());
                for (int colorFormat: capabilities.colorFormats) {
                    Log.v(TAG, ""   Color: 0x"" + Integer.toHexString(colorFormat));
                }

                // Check supported color formats.
                for (int supportedColorFormat : mSupportedColorList) {
                    for (int codecColorFormat : capabilities.colorFormats) {
                        if (codecColorFormat == supportedColorFormat) {
                            codecProperties = new CodecProperties(codecInfo.getName(),
                                    codecColorFormat);
                            Log.v(TAG, ""Found target codec "" + codecProperties.codecName +
                                    "". Color: 0x"" + Integer.toHexString(codecColorFormat));
                            // return first vendor codec (hopefully HW) found
                            if (codecInfo.isVendor()) {
                                return codecProperties;
                            }
                        }
                    }
                }
            }
        }
        if (codecProperties == null) {
            Log.i(TAG, ""no suitable "" + (forceGoogleCodec ? ""google "" : """")
                    + (isEncoder ? ""encoder "" : ""decoder "") + ""found for "" + format);
        }
        return codecProperties;
    }

    /**
     * Parameters for encoded video stream.
     */
    protected class EncoderOutputStreamParameters {
        // Name of raw YUV420 input file. When the value of this parameter
        // is set to null input file descriptor from inputResource parameter
        // is used instead.
        public String inputYuvFilename;
        // Name of scaled YUV420 input file.
        public String scaledYuvFilename;
        // File descriptor for the raw input file (YUV420). Used only if
        // inputYuvFilename parameter is null.
        public String inputResource;
        // Name of the IVF file to write encoded bitsream
        public String outputIvfFilename;
        // Mime Type of the Encoded content.
        public String codecMimeType;
        // Force to use Google Video encoder.
        boolean forceGoogleEncoder;
        // Number of frames to encode.
        int frameCount;
        // Frame rate of input file in frames per second.
        int frameRate;
        // Encoded frame width.
        public int frameWidth;
        // Encoded frame height.
        public int frameHeight;
        // Encoding bitrate array in bits/second for every frame. If array length
        // is shorter than the total number of frames, the last value is re-used for
        // all remaining frames. For constant bitrate encoding single element
        // array can be used with first element set to target bitrate value.
        public int[] bitrateSet;
        // Encoding bitrate type - VBR or CBR
        public int bitrateType;
        // Number of temporal layers
        public int temporalLayers;
        // Desired key frame interval - codec is asked to generate key frames
        // at a period defined by this parameter.
        public int syncFrameInterval;
        // Optional parameter - forced key frame interval. Used to
        // explicitly request the codec to generate key frames using
        // MediaCodec.PARAMETER_KEY_REQUEST_SYNC_FRAME parameter.
        public int syncForceFrameInterval;
        // Buffer timeout
        long timeoutDequeue;
        // Flag if encoder should run in Looper thread.
        boolean runInLooperThread;
        // Flag if use NdkMediaCodec
        boolean useNdk;
    }

    private String getCodecSuffix(String codecMimeType) {
        switch(codecMimeType) {
        case VP8_MIME:
            return ""vp8"";
        case VP9_MIME:
            return ""vp9"";
        case AVC_MIME:
            return ""avc"";
        case HEVC_MIME:
            return ""hevc"";
        default:
            Log.w(TAG, ""getCodecSuffix got an unexpected codecMimeType."");
        }
        return ""video"";
    }

    /**
     * Generates an array of default parameters for encoder output stream based on
     * upscaling value.
     */
    protected ArrayList<EncoderOutputStreamParameters> getDefaultEncodingParameterList(
            String inputYuvName,
            String outputIvfBaseName,
            String codecMimeType,
            int encodeSeconds,
            int[] resolutionScales,
            int frameWidth,
            int frameHeight,
            int frameRate,
            int bitrateMode,
            int[] bitrates,
            boolean syncEncoding) {
        assertTrue(resolutionScales.length == bitrates.length);
        int numCodecs = resolutionScales.length;
        ArrayList<EncoderOutputStreamParameters> outputParameters =
                new ArrayList<EncoderOutputStreamParameters>(numCodecs);
        for (int i = 0; i < numCodecs; i++) {
            EncoderOutputStreamParameters params = new EncoderOutputStreamParameters();
            if (inputYuvName != null) {
                params.inputYuvFilename = SDCARD_DIR + File.separator + inputYuvName;
            } else {
                params.inputYuvFilename = null;
            }
            params.scaledYuvFilename = SDCARD_DIR + File.separator +
                    outputIvfBaseName + resolutionScales[i]+ "".yuv"";
            params.inputResource = ""football_qvga.yuv"";
            params.codecMimeType = codecMimeType;
            String codecSuffix = getCodecSuffix(codecMimeType);
            params.outputIvfFilename = SDCARD_DIR + File.separator +
                    outputIvfBaseName + resolutionScales[i] + ""_"" + codecSuffix + "".ivf"";
            params.forceGoogleEncoder = false;
            params.frameCount = encodeSeconds * frameRate;
            params.frameRate = frameRate;
            params.frameWidth = Math.min(frameWidth * resolutionScales[i], 1280);
            params.frameHeight = Math.min(frameHeight * resolutionScales[i], 720);
            params.bitrateSet = new int[1];
            params.bitrateSet[0] = bitrates[i];
            params.bitrateType = bitrateMode;
            params.temporalLayers = 0;
            params.syncFrameInterval = SYNC_FRAME_INTERVAL;
            params.syncForceFrameInterval = 0;
            if (syncEncoding) {
                params.timeoutDequeue = DEFAULT_DEQUEUE_TIMEOUT_US;
                params.runInLooperThread = false;
            } else {
                params.timeoutDequeue = 0;
                params.runInLooperThread = true;
            }
            outputParameters.add(params);
        }
        return outputParameters;
    }

    protected EncoderOutputStreamParameters getDefaultEncodingParameters(
            String inputYuvName,
            String outputIvfBaseName,
            String codecMimeType,
            int encodeSeconds,
            int frameWidth,
            int frameHeight,
            int frameRate,
            int bitrateMode,
            int bitrate,
            boolean syncEncoding) {
        int[] scaleValues = { 1 };
        int[] bitrates = { bitrate };
        return getDefaultEncodingParameterList(
                inputYuvName,
                outputIvfBaseName,
                codecMimeType,
                encodeSeconds,
                scaleValues,
                frameWidth,
                frameHeight,
                frameRate,
                bitrateMode,
                bitrates,
                syncEncoding).get(0);
    }

    /**
     * Converts (interleaves) YUV420 planar to NV12.
     * Assumes packed, macroblock-aligned frame with no cropping
     * (visible/coded row length == stride).
     */
    private static byte[] YUV420ToNV(int width, int height, byte[] yuv) {
        byte[] nv = new byte[yuv.length];
        // Y plane we just copy.
        System.arraycopy(yuv, 0, nv, 0, width * height);

        // U & V plane we interleave.
        int u_offset = width * height;
        int v_offset = u_offset + u_offset / 4;
        int nv_offset = width * height;
        for (int i = 0; i < width * height / 4; i++) {
            nv[nv_offset++] = yuv[u_offset++];
            nv[nv_offset++] = yuv[v_offset++];
        }
        return nv;
    }

    /**
     * Converts (de-interleaves) NV12 to YUV420 planar.
     * Stride may be greater than width, slice height may be greater than height.
     */
    private static byte[] NV12ToYUV420(int width, int height,
            int stride, int sliceHeight, byte[] nv12) {
        byte[] yuv = new byte[width * height * 3 / 2];

        // Y plane we just copy.
        for (int i = 0; i < height; i++) {
            System.arraycopy(nv12, i * stride, yuv, i * width, width);
        }

        // U & V plane - de-interleave.
        int u_offset = width * height;
        int v_offset = u_offset + u_offset / 4;
        int nv_offset;
        for (int i = 0; i < height / 2; i++) {
            nv_offset = stride * (sliceHeight + i);
            for (int j = 0; j < width / 2; j++) {
                yuv[u_offset++] = nv12[nv_offset++];
                yuv[v_offset++] = nv12[nv_offset++];
            }
        }
        return yuv;
    }

    /**
     * Packs YUV420 frame by moving it to a smaller size buffer with stride and slice
     * height equal to the crop window.
     */
    private static byte[] PackYUV420(int left, int top, int width, int height,
            int stride, int sliceHeight, byte[] src) {
        byte[] dst = new byte[width * height * 3 / 2];
        // Y copy.
        for (int i = 0; i < height; i++) {
            System.arraycopy(src, (i + top) * stride + left, dst, i * width, width);
        }
        // U and V copy.
        int u_src_offset = stride * sliceHeight;
        int v_src_offset = u_src_offset + u_src_offset / 4;
        int u_dst_offset = width * height;
        int v_dst_offset = u_dst_offset + u_dst_offset / 4;
        // Downsample and align to floor-2 for crop origin.
        left /= 2;
        top /= 2;
        for (int i = 0; i < height / 2; i++) {
            System.arraycopy(src, u_src_offset + (i + top) * (stride / 2) + left,
                    dst, u_dst_offset + i * (width / 2), width / 2);
            System.arraycopy(src, v_src_offset + (i + top) * (stride / 2) + left,
                    dst, v_dst_offset + i * (width / 2), width / 2);
        }
        return dst;
    }


    private static void imageUpscale1To2(byte[] src, int srcByteOffset, int srcStride,
            byte[] dst, int dstByteOffset, int dstWidth, int dstHeight) {
        for (int i = 0; i < dstHeight/2 - 1; i++) {
            int dstOffset0 = 2 * i * dstWidth + dstByteOffset;
            int dstOffset1 = dstOffset0 + dstWidth;
            int srcOffset0 = i * srcStride + srcByteOffset;
            int srcOffset1 = srcOffset0 + srcStride;
            int pixel00 = (int)src[srcOffset0++] & 0xff;
            int pixel10 = (int)src[srcOffset1++] & 0xff;
            for (int j = 0; j < dstWidth/2 - 1; j++) {
                int pixel01 = (int)src[srcOffset0++] & 0xff;
                int pixel11 = (int)src[srcOffset1++] & 0xff;
                dst[dstOffset0++] = (byte)pixel00;
                dst[dstOffset0++] = (byte)((pixel00 + pixel01 + 1) / 2);
                dst[dstOffset1++] = (byte)((pixel00 + pixel10 + 1) / 2);
                dst[dstOffset1++] = (byte)((pixel00 + pixel01 + pixel10 + pixel11 + 2) / 4);
                pixel00 = pixel01;
                pixel10 = pixel11;
            }
            // last column
            dst[dstOffset0++] = (byte)pixel00;
            dst[dstOffset0++] = (byte)pixel00;
            dst[dstOffset1++] = (byte)((pixel00 + pixel10 + 1) / 2);
            dst[dstOffset1++] = (byte)((pixel00 + pixel10 + 1) / 2);
        }

        // last row
        int dstOffset0 = (dstHeight - 2) * dstWidth + dstByteOffset;
        int dstOffset1 = dstOffset0 + dstWidth;
        int srcOffset0 = (dstHeight/2 - 1) * srcStride + srcByteOffset;
        int pixel00 = (int)src[srcOffset0++] & 0xff;
        for (int j = 0; j < dstWidth/2 - 1; j++) {
            int pixel01 = (int)src[srcOffset0++] & 0xff;
            dst[dstOffset0++] = (byte)pixel00;
            dst[dstOffset0++] = (byte)((pixel00 + pixel01 + 1) / 2);
            dst[dstOffset1++] = (byte)pixel00;
            dst[dstOffset1++] = (byte)((pixel00 + pixel01 + 1) / 2);
            pixel00 = pixel01;
        }
        // the very last pixel - bottom right
        dst[dstOffset0++] = (byte)pixel00;
        dst[dstOffset0++] = (byte)pixel00;
        dst[dstOffset1++] = (byte)pixel00;
        dst[dstOffset1++] = (byte)pixel00;
    }

    /**
    * Up-scale image.
    * Scale factor is defined by source and destination width ratio.
    * Only 1:2 and 1:4 up-scaling is supported for now.
    * For 640x480 -> 1280x720 conversion only top 640x360 part of the original
    * image is scaled.
    */
    private static byte[] imageScale(byte[] src, int srcWidth, int srcHeight,
            int dstWidth, int dstHeight) throws Exception {
        int srcYSize = srcWidth * srcHeight;
        int dstYSize = dstWidth * dstHeight;
        byte[] dst = null;
        if (dstWidth == 2 * srcWidth && dstHeight <= 2 * srcHeight) {
            // 1:2 upscale
            dst = new byte[dstWidth * dstHeight * 3 / 2];
            imageUpscale1To2(src, 0, srcWidth,
                    dst, 0, dstWidth, dstHeight);                                 // Y
            imageUpscale1To2(src, srcYSize, srcWidth / 2,
                    dst, dstYSize, dstWidth / 2, dstHeight / 2);                  // U
            imageUpscale1To2(src, srcYSize * 5 / 4, srcWidth / 2,
                    dst, dstYSize * 5 / 4, dstWidth / 2, dstHeight / 2);          // V
        } else if (dstWidth == 4 * srcWidth && dstHeight <= 4 * srcHeight) {
            // 1:4 upscale - in two steps
            int midWidth = 2 * srcWidth;
            int midHeight = 2 * srcHeight;
            byte[] midBuffer = imageScale(src, srcWidth, srcHeight, midWidth, midHeight);
            dst = imageScale(midBuffer, midWidth, midHeight, dstWidth, dstHeight);

        } else {
            throw new RuntimeException(""Can not find proper scaling function"");
        }

        return dst;
    }

    private void cacheScaledImage(
            String srcYuvFilename, String srcResource, int srcFrameWidth, int srcFrameHeight,
            String dstYuvFilename, int dstFrameWidth, int dstFrameHeight) throws Exception {
        InputStream srcStream = OpenFileOrResource(srcYuvFilename, srcResource);
        FileOutputStream dstFile = new FileOutputStream(dstYuvFilename, false);
        int srcFrameSize = srcFrameWidth * srcFrameHeight * 3 / 2;
        byte[] srcFrame = new byte[srcFrameSize];
        byte[] dstFrame = null;
        Log.d(TAG, ""Scale to "" + dstFrameWidth + "" x "" + dstFrameHeight + "". -> "" + dstYuvFilename);
        while (true) {
            int bytesRead = srcStream.read(srcFrame);
            if (bytesRead != srcFrame.length) {
                break;
            }
            if (dstFrameWidth == srcFrameWidth && dstFrameHeight == srcFrameHeight) {
                dstFrame = srcFrame;
            } else {
                dstFrame = imageScale(srcFrame, srcFrameWidth, srcFrameHeight,
                        dstFrameWidth, dstFrameHeight);
            }
            dstFile.write(dstFrame);
        }
        srcStream.close();
        dstFile.close();
    }


    /**
     * A basic check if an encoded stream is decodable.
     *
     * The most basic confirmation we can get about a frame
     * being properly encoded is trying to decode it.
     * (Especially in realtime mode encode output is non-
     * deterministic, therefore a more thorough check like
     * md5 sum comparison wouldn't work.)
     *
     * Indeed, MediaCodec will raise an IllegalStateException
     * whenever video decoder fails to decode a frame, and
     * this test uses that fact to verify the bitstream.
     *
     * @param inputIvfFilename  The name of the IVF file containing encoded bitsream.
     * @param outputYuvFilename The name of the output YUV file (optional).
     * @param frameRate         Frame rate of input file in frames per second
     * @param forceGoogleDecoder    Force to use Google Video decoder.
     * @param codecConfigs      Codec config buffers to be added to the format
     */
    protected ArrayList<MediaCodec.BufferInfo> decode(
            String inputIvfFilename,
            String outputYuvFilename,
            String codecMimeType,
            int frameRate,
            boolean forceGoogleDecoder,
            ArrayList<ByteBuffer> codecConfigs) throws Exception {
        ArrayList<MediaCodec.BufferInfo> bufferInfos = new ArrayList<MediaCodec.BufferInfo>();

        // Open input/output.
        IvfReader ivf = new IvfReader(inputIvfFilename);
        int frameWidth = ivf.getWidth();
        int frameHeight = ivf.getHeight();
        int frameCount = ivf.getFrameCount();
        int frameStride = frameWidth;
        int frameSliceHeight = frameHeight;
        int cropLeft = 0;
        int cropTop = 0;
        int cropWidth = frameWidth;
        int cropHeight = frameHeight;
        assertTrue(frameWidth > 0);
        assertTrue(frameHeight > 0);
        assertTrue(frameCount > 0);

        // Create decoder.
        MediaFormat format = MediaFormat.createVideoFormat(
                codecMimeType, ivf.getWidth(), ivf.getHeight());
        CodecProperties properties = getVideoCodecProperties(
                false /* encoder */, format, forceGoogleDecoder);
        if (properties == null) {
            ivf.close();
            return null;
        }
        int frameColorFormat = properties.colorFormat;
        format.setInteger(MediaFormat.KEY_COLOR_FORMAT, properties.colorFormat);
        int csdIndex = 0;
        for (ByteBuffer config : codecConfigs) {
            format.setByteBuffer(""csd-"" + csdIndex, config);
            ++csdIndex;
        }

        FileOutputStream yuv = null;
        if (outputYuvFilename != null) {
            yuv = new FileOutputStream(outputYuvFilename, false);
        }

        Log.d(TAG, ""Creating decoder "" + properties.codecName +
                "". Color format: 0x"" + Integer.toHexString(frameColorFormat) +
                "". "" + frameWidth + "" x "" + frameHeight);
        Log.d(TAG, ""  Format: "" + format);
        Log.d(TAG, ""  In: "" + inputIvfFilename + "". Out:"" + outputYuvFilename);
        MediaCodec decoder = MediaCodec.createByCodecName(properties.codecName);
        decoder.configure(format,
                          null,  // surface
                          null,  // crypto
                          0);    // flags
        decoder.start();

        ByteBuffer[] inputBuffers = decoder.getInputBuffers();
        ByteBuffer[] outputBuffers = decoder.getOutputBuffers();
        MediaCodec.BufferInfo bufferInfo = new MediaCodec.BufferInfo();

        // decode loop
        int inputFrameIndex = 0;
        int outputFrameIndex = 0;
        long inPresentationTimeUs = 0;
        long outPresentationTimeUs = 0;
        boolean sawOutputEOS = false;
        boolean sawInputEOS = false;

        while (!sawOutputEOS) {
            if (!sawInputEOS) {
                int inputBufIndex = decoder.dequeueInputBuffer(DEFAULT_DEQUEUE_TIMEOUT_US);
                if (inputBufIndex >= 0) {
                    byte[] frame = ivf.readFrame(inputFrameIndex);

                    if (inputFrameIndex == frameCount - 1) {
                        Log.d(TAG, ""  Input EOS for frame # "" + inputFrameIndex);
                        sawInputEOS = true;
                    }

                    inputBuffers[inputBufIndex].clear();
                    inputBuffers[inputBufIndex].put(frame);
                    inputBuffers[inputBufIndex].rewind();
                    inPresentationTimeUs = (inputFrameIndex * 1000000) / frameRate;

                    decoder.queueInputBuffer(
                            inputBufIndex,
                            0,  // offset
                            frame.length,
                            inPresentationTimeUs,
                            sawInputEOS ? MediaCodec.BUFFER_FLAG_END_OF_STREAM : 0);

                    inputFrameIndex++;
                }
            }

            int result = decoder.dequeueOutputBuffer(bufferInfo, DEFAULT_DEQUEUE_TIMEOUT_US);
            while (result == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED ||
                    result == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {
                if (result == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {
                    outputBuffers = decoder.getOutputBuffers();
                } else  if (result == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {
                    // Process format change
                    format = decoder.getOutputFormat();
                    frameWidth = format.getInteger(MediaFormat.KEY_WIDTH);
                    frameHeight = format.getInteger(MediaFormat.KEY_HEIGHT);
                    frameColorFormat = format.getInteger(MediaFormat.KEY_COLOR_FORMAT);
                    Log.d(TAG, ""Decoder output format change. Color: 0x"" +
                            Integer.toHexString(frameColorFormat));
                    Log.d(TAG, ""Format: "" + format.toString());

                    // Parse frame and slice height from undocumented values
                    if (format.containsKey(""stride"")) {
                        frameStride = format.getInteger(""stride"");
                    } else {
                        frameStride = frameWidth;
                    }
                    if (format.containsKey(""slice-height"")) {
                        frameSliceHeight = format.getInteger(""slice-height"");
                    } else {
                        frameSliceHeight = frameHeight;
                    }
                    Log.d(TAG, ""Frame stride and slice height: "" + frameStride +
                            "" x "" + frameSliceHeight);
                    frameStride = Math.max(frameWidth, frameStride);
                    frameSliceHeight = Math.max(frameHeight, frameSliceHeight);

                    // Parse crop window for the area of recording decoded frame data.
                    if (format.containsKey(""crop-left"")) {
                        cropLeft = format.getInteger(""crop-left"");
                    }
                    if (format.containsKey(""crop-top"")) {
                        cropTop = format.getInteger(""crop-top"");
                    }
                    if (format.containsKey(""crop-right"")) {
                        cropWidth = format.getInteger(""crop-right"") - cropLeft + 1;
                    } else {
                        cropWidth = frameWidth;
                    }
                    if (format.containsKey(""crop-bottom"")) {
                        cropHeight = format.getInteger(""crop-bottom"") - cropTop + 1;
                    } else {
                        cropHeight = frameHeight;
                    }
                    Log.d(TAG, ""Frame crop window origin: "" + cropLeft + "" x "" + cropTop
                            + "", size: "" + cropWidth + "" x "" + cropHeight);
                    cropWidth = Math.min(frameWidth - cropLeft, cropWidth);
                    cropHeight = Math.min(frameHeight - cropTop, cropHeight);
                }
                result = decoder.dequeueOutputBuffer(bufferInfo, DEFAULT_DEQUEUE_TIMEOUT_US);
            }
            if (result >= 0) {
                int outputBufIndex = result;
                outPresentationTimeUs = bufferInfo.presentationTimeUs;
                Log.v(TAG, ""Writing buffer # "" + outputFrameIndex +
                        "". Size: "" + bufferInfo.size +
                        "". InTime: "" + (inPresentationTimeUs + 500)/1000 +
                        "". OutTime: "" + (outPresentationTimeUs + 500)/1000);
                if ((bufferInfo.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {
                    sawOutputEOS = true;
                    Log.d(TAG, ""   Output EOS for frame # "" + outputFrameIndex);
                }

                if (bufferInfo.size > 0) {
                    // Save decoder output to yuv file.
                    if (yuv != null) {
                        byte[] frame = new byte[bufferInfo.size];
                        outputBuffers[outputBufIndex].position(bufferInfo.offset);
                        outputBuffers[outputBufIndex].get(frame, 0, bufferInfo.size);
                        // Convert NV12 to YUV420 if necessary.
                        if (frameColorFormat != CodecCapabilities.COLOR_FormatYUV420Planar) {
                            frame = NV12ToYUV420(frameWidth, frameHeight,
                                    frameStride, frameSliceHeight, frame);
                        }
                        int writeLength = Math.min(cropWidth * cropHeight * 3 / 2, frame.length);
                        // Pack frame if necessary.
                        if (writeLength < frame.length &&
                                (frameStride > cropWidth || frameSliceHeight > cropHeight)) {
                            frame = PackYUV420(cropLeft, cropTop, cropWidth, cropHeight,
                                    frameStride, frameSliceHeight, frame);
                        }
                        yuv.write(frame, 0, writeLength);
                    }
                    outputFrameIndex++;

                    // Update statistics - store presentation time delay in offset
                    long presentationTimeUsDelta = inPresentationTimeUs - outPresentationTimeUs;
                    MediaCodec.BufferInfo bufferInfoCopy = new MediaCodec.BufferInfo();
                    bufferInfoCopy.set((int)presentationTimeUsDelta, bufferInfo.size,
                            outPresentationTimeUs, bufferInfo.flags);
                    bufferInfos.add(bufferInfoCopy);
                }
                decoder.releaseOutputBuffer(outputBufIndex, false);
            }
        }
        decoder.stop();
        decoder.release();
        ivf.close();
        if (yuv != null) {
            yuv.close();
        }

        return bufferInfos;
    }


    /**
     * Helper function to return InputStream from either fully specified filename (if set)
     * or resource name within test assets (if filename is not set).
     */
    private InputStream OpenFileOrResource(String filename, final String resource)
            throws Exception {
        if (filename != null) {
            Preconditions.assertTestFileExists(filename);
            return new FileInputStream(filename);
        }
        Preconditions.assertTestFileExists(mInpPrefix + resource);
        return new FileInputStream(mInpPrefix + resource);
    }

    /**
     * Results of frame encoding.
     */
    protected class MediaEncoderOutput {
        public long inPresentationTimeUs;
        public long outPresentationTimeUs;
        public boolean outputGenerated;
        public int flags;
        public byte[] buffer;
    }

    protected class MediaEncoderAsyncHelper {
        private final EncoderOutputStreamParameters mStreamParams;
        private final CodecProperties mProperties;
        private final ArrayList<MediaCodec.BufferInfo> mBufferInfos;
        private final IvfWriter mIvf;
        private final ArrayList<ByteBuffer> mCodecConfigs;
        private final byte[] mSrcFrame;

        private InputStream mYuvStream;
        private int mInputFrameIndex;

        MediaEncoderAsyncHelper(
                EncoderOutputStreamParameters streamParams,
                CodecProperties properties,
                ArrayList<MediaCodec.BufferInfo> bufferInfos,
                IvfWriter ivf,
                ArrayList<ByteBuffer> codecConfigs)
                throws Exception {
            mStreamParams = streamParams;
            mProperties = properties;
            mBufferInfos = bufferInfos;
            mIvf = ivf;
            mCodecConfigs = codecConfigs;

            int srcFrameSize = streamParams.frameWidth * streamParams.frameHeight * 3 / 2;
            mSrcFrame = new byte[srcFrameSize];

            mYuvStream = OpenFileOrResource(
                    streamParams.inputYuvFilename, streamParams.inputResource);
        }

        public byte[] getInputFrame() {
            // Check EOS
            if (mStreamParams.frameCount == 0
                    || (mStreamParams.frameCount > 0
                            && mInputFrameIndex >= mStreamParams.frameCount)) {
                Log.d(TAG, ""---Sending EOS empty frame for frame # "" + mInputFrameIndex);
                return null;
            }

            try {
                int bytesRead = mYuvStream.read(mSrcFrame);

                if (bytesRead == -1) {
                    // rewind to beginning of file
                    mYuvStream.close();
                    mYuvStream = OpenFileOrResource(
                            mStreamParams.inputYuvFilename, mStreamParams.inputResource);
                    bytesRead = mYuvStream.read(mSrcFrame);
                }
            } catch (Exception e) {
                Log.e(TAG, ""Failed to read YUV file."");
                return null;
            }
            mInputFrameIndex++;

            // Convert YUV420 to NV12 if necessary
            if (mProperties.colorFormat != CodecCapabilities.COLOR_FormatYUV420Planar) {
                return YUV420ToNV(mStreamParams.frameWidth, mStreamParams.frameHeight,
                        mSrcFrame);
            } else {
                return mSrcFrame;
            }
        }

        public boolean saveOutputFrame(MediaEncoderOutput out) {
            if (out.outputGenerated) {
                if ((out.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) != 0) {
                    Log.d(TAG, ""Storing codec config separately"");
                    ByteBuffer csdBuffer = ByteBuffer.allocate(out.buffer.length).put(out.buffer);
                    csdBuffer.rewind();
                    mCodecConfigs.add(csdBuffer);
                    out.buffer = new byte[0];
                }
                if (out.buffer.length > 0) {
                    // Save frame
                    try {
                        mIvf.writeFrame(out.buffer, out.outPresentationTimeUs);
                    } catch (Exception e) {
                        Log.d(TAG, ""Failed to write frame"");
                        return true;
                    }

                    // Update statistics - store presentation time delay in offset
                    long presentationTimeUsDelta = out.inPresentationTimeUs -
                            out.outPresentationTimeUs;
                    MediaCodec.BufferInfo bufferInfoCopy = new MediaCodec.BufferInfo();
                    bufferInfoCopy.set((int)presentationTimeUsDelta, out.buffer.length,
                            out.outPresentationTimeUs, out.flags);
                    mBufferInfos.add(bufferInfoCopy);
                }
                // Detect output EOS
                if ((out.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {
                    Log.d(TAG, ""----Output EOS "");
                    return true;
                }
            }
            return false;
        }
    }

    /**
     * Video encoder wrapper class.
     * Allows to run the encoder either in a callee's thread or in a looper thread
     * using buffer dequeue ready notification callbacks.
     *
     * Function feedInput() is used to send raw video frame to the encoder input. When encoder
     * is configured to run in async mode the function will run in a looper thread.
     * Encoded frame can be retrieved by calling getOutput() function.
     */
    protected class MediaEncoderAsync extends Thread {
        private int mId;
        private MediaCodecWrapper mCodec;
        private ByteBuffer[] mInputBuffers;
        private ByteBuffer[] mOutputBuffers;
        private int mInputFrameIndex;
        private int mOutputFrameIndex;
        private int mInputBufIndex;
        private int mFrameRate;
        private long mTimeout;
        private MediaCodec.BufferInfo mBufferInfo;
        private long mInPresentationTimeUs;
        private long mOutPresentationTimeUs;
        private boolean mAsync;
        // Flag indicating if input frame was consumed by the encoder in feedInput() call.
        private boolean mConsumedInput;
        // Result of frame encoding returned by getOutput() call.
        private MediaEncoderOutput mOutput;
        // Object used to signal that looper thread has started and Handler instance associated
        // with looper thread has been allocated.
        private final Object mThreadEvent = new Object();
        // Object used to signal that MediaCodec buffer dequeue notification callback
        // was received.
        private final Object mCallbackEvent = new Object();
        private Handler mHandler;
        private boolean mCallbackReceived;
        private MediaEncoderAsyncHelper mHelper;
        private final Object mCompletionEvent = new Object();
        private boolean mCompleted;
        private boolean mInitialSyncFrameReceived;

        private MediaCodec.Callback mCallback = new MediaCodec.Callback() {
            @Override
            public void onInputBufferAvailable(MediaCodec codec, int index) {
                if (mHelper == null) {
                    Log.e(TAG, ""async helper not available"");
                    return;
                }

                byte[] encFrame = mHelper.getInputFrame();
                boolean inputEOS = (encFrame == null);

                int encFrameLength = 0;
                int flags = 0;
                if (inputEOS) {
                    flags = MediaCodec.BUFFER_FLAG_END_OF_STREAM;
                } else {
                    encFrameLength = encFrame.length;

                    ByteBuffer byteBuffer = mCodec.getInputBuffer(index);
                    byteBuffer.put(encFrame);
                    byteBuffer.rewind();

                    mInPresentationTimeUs = (mInputFrameIndex * 1000000) / mFrameRate;

                    Log.v(TAG, ""Enc"" + mId + "". Frame in # "" + mInputFrameIndex +
                            "". InTime: "" + (mInPresentationTimeUs + 500)/1000);

                    mInputFrameIndex++;
                }

                mCodec.queueInputBuffer(
                        index,
                        0,  // offset
                        encFrameLength,  // size
                        mInPresentationTimeUs,
                        flags);
            }

            @Override
            public void onOutputBufferAvailable(MediaCodec codec,
                    int index, MediaCodec.BufferInfo info) {
                if (mHelper == null) {
                    Log.e(TAG, ""async helper not available"");
                    return;
                }

                MediaEncoderOutput out = new MediaEncoderOutput();

                out.buffer = new byte[info.size];
                ByteBuffer outputBuffer = mCodec.getOutputBuffer(index);
                outputBuffer.get(out.buffer, 0, info.size);
                mOutPresentationTimeUs = info.presentationTimeUs;

                String logStr = ""Enc"" + mId + "". Frame # "" + mOutputFrameIndex;
                if ((info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) != 0) {
                    logStr += "" CONFIG. "";
                }
                if ((info.flags & MediaCodec.BUFFER_FLAG_SYNC_FRAME) != 0) {
                    logStr += "" KEY. "";
                    if (!mInitialSyncFrameReceived) {
                        mInitialSyncFrameReceived = true;
                    }
                }
                if ((info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {
                    logStr += "" EOS. "";
                }
                logStr += "" Size: "" + info.size;
                logStr += "". InTime: "" + (mInPresentationTimeUs + 500)/1000 +
                        "". OutTime: "" + (mOutPresentationTimeUs + 500)/1000;
                Log.v(TAG, logStr);

                if (!mInitialSyncFrameReceived
                        && (info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) == 0) {
                    throw new RuntimeException(""Non codec_config_frame before first sync."");
                }

                if (info.size > 0) {
                    mOutputFrameIndex++;
                    out.inPresentationTimeUs = mInPresentationTimeUs;
                    out.outPresentationTimeUs = mOutPresentationTimeUs;
                }
                mCodec.releaseOutputBuffer(index, false);

                out.flags = info.flags;
                out.outputGenerated = true;

                if (mHelper.saveOutputFrame(out)) {
                    // output EOS
                    signalCompletion();
                }
            }

            @Override
            public void onError(MediaCodec codec, CodecException e) {
                Log.e(TAG, ""onError: "" + e
                        + "", transient "" + e.isTransient()
                        + "", recoverable "" + e.isRecoverable()
                        + "", error "" + e.getErrorCode());
            }

            @Override
            public void onOutputFormatChanged(MediaCodec codec, MediaFormat format) {
                Log.i(TAG, ""onOutputFormatChanged: "" + format.toString());
            }
        };

        private synchronized void requestStart() throws Exception {
            mHandler = null;
            start();
            // Wait for Hander allocation
            synchronized (mThreadEvent) {
                while (mHandler == null) {
                    mThreadEvent.wait();
                }
            }
        }

        public void setAsyncHelper(MediaEncoderAsyncHelper helper) {
            mHelper = helper;
        }

        @Override
        public void run() {
            Looper.prepare();
            synchronized (mThreadEvent) {
                mHandler = new Handler();
                mThreadEvent.notify();
            }
            Looper.loop();
        }

        private void runCallable(final Callable<?> callable) throws Exception {
            if (mAsync) {
                final Exception[] exception = new Exception[1];
                final CountDownLatch countDownLatch = new CountDownLatch(1);
                mHandler.post( new Runnable() {
                    @Override
                    public void run() {
                        try {
                            callable.call();
                        } catch (Exception e) {
                            exception[0] = e;
                        } finally {
                            countDownLatch.countDown();
                        }
                    }
                } );

                // Wait for task completion
                countDownLatch.await();
                if (exception[0] != null) {
                    throw exception[0];
                }
            } else {
                callable.call();
            }
        }

        private synchronized void requestStop() throws Exception {
            mHandler.post( new Runnable() {
                @Override
                public void run() {
                    // This will run on the Looper thread
                    Log.v(TAG, ""MediaEncoder looper quitting"");
                    Looper.myLooper().quitSafely();
                }
            } );
            // Wait for completion
            join();
            mHandler = null;
        }

        private void createCodecInternal(final String name,
                final MediaFormat format, final long timeout, boolean useNdk) throws Exception {
            mBufferInfo = new MediaCodec.BufferInfo();
            mFrameRate = format.getInteger(MediaFormat.KEY_FRAME_RATE);
            mTimeout = timeout;
            mInputFrameIndex = 0;
            mOutputFrameIndex = 0;
            mInPresentationTimeUs = 0;
            mOutPresentationTimeUs = 0;

            if (useNdk) {
                mCodec = new NdkMediaCodec(name);
            } else {
                mCodec = new SdkMediaCodec(MediaCodec.createByCodecName(name), mAsync);
            }
            if (mAsync) {
                mCodec.setCallback(mCallback);
            }
            mCodec.configure(format, MediaCodec.CONFIGURE_FLAG_ENCODE);
            mCodec.start();

            // get the cached input/output only in sync mode
            if (!mAsync) {
                mInputBuffers = mCodec.getInputBuffers();
                mOutputBuffers = mCodec.getOutputBuffers();
            }
        }

        public void createCodec(int id, final String name, final MediaFormat format,
                final long timeout, boolean async, final boolean useNdk)  throws Exception {
            mId = id;
            mAsync = async;
            if (mAsync) {
                requestStart(); // start looper thread
            }
            runCallable( new Callable<Void>() {
                @Override
                public Void call() throws Exception {
                    createCodecInternal(name, format, timeout, useNdk);
                    return null;
                }
            } );
        }

        private void feedInputInternal(final byte[] encFrame, final boolean inputEOS) {
            mConsumedInput = false;
            // Feed input
            mInputBufIndex = mCodec.dequeueInputBuffer(mTimeout);

            if (mInputBufIndex >= 0) {
                ByteBuffer inputBuffer = mCodec.getInputBuffer(mInputBufIndex);
                inputBuffer.clear();
                inputBuffer.put(encFrame);
                inputBuffer.rewind();
                int encFrameLength = encFrame.length;
                int flags = 0;
                if (inputEOS) {
                    encFrameLength = 0;
                    flags = MediaCodec.BUFFER_FLAG_END_OF_STREAM;
                }
                if (!inputEOS) {
                    Log.v(TAG, ""Enc"" + mId + "". Frame in # "" + mInputFrameIndex +
                            "". InTime: "" + (mInPresentationTimeUs + 500)/1000);
                    mInPresentationTimeUs = (mInputFrameIndex * 1000000) / mFrameRate;
                    mInputFrameIndex++;
                }

                mCodec.queueInputBuffer(
                        mInputBufIndex,
                        0,  // offset
                        encFrameLength,  // size
                        mInPresentationTimeUs,
                        flags);

                mConsumedInput = true;
            } else {
                Log.v(TAG, ""In "" + mId + "" - TRY_AGAIN_LATER"");
            }
            mCallbackReceived = false;
        }

        public boolean feedInput(final byte[] encFrame, final boolean inputEOS) throws Exception {
            runCallable( new Callable<Void>() {
                @Override
                public Void call() throws Exception {
                    feedInputInternal(encFrame, inputEOS);
                    return null;
                }
            } );
            return mConsumedInput;
        }

        private void getOutputInternal() {
            mOutput = new MediaEncoderOutput();
            mOutput.inPresentationTimeUs = mInPresentationTimeUs;
            mOutput.outPresentationTimeUs = mOutPresentationTimeUs;
            mOutput.outputGenerated = false;

            // Get output from the encoder
            int result = mCodec.dequeueOutputBuffer(mBufferInfo, mTimeout);
            while (result == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED ||
                    result == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {
                if (result == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {
                    mOutputBuffers = mCodec.getOutputBuffers();
                } else if (result == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {
                    Log.d(TAG, ""Format changed: "" + mCodec.getOutputFormatString());
                }
                result = mCodec.dequeueOutputBuffer(mBufferInfo, mTimeout);
            }
            if (result == MediaCodec.INFO_TRY_AGAIN_LATER) {
                Log.v(TAG, ""Out "" + mId + "" - TRY_AGAIN_LATER"");
            }

            if (result >= 0) {
                int outputBufIndex = result;
                mOutput.buffer = new byte[mBufferInfo.size];
                ByteBuffer outputBuffer = mCodec.getOutputBuffer(outputBufIndex);
                outputBuffer.position(mBufferInfo.offset);
                outputBuffer.get(mOutput.buffer, 0, mBufferInfo.size);
                mOutPresentationTimeUs = mBufferInfo.presentationTimeUs;

                String logStr = ""Enc"" + mId + "". Frame # "" + mOutputFrameIndex;
                if ((mBufferInfo.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) != 0) {
                    logStr += "" CONFIG. "";
                }
                if ((mBufferInfo.flags & MediaCodec.BUFFER_FLAG_SYNC_FRAME) != 0) {
                    logStr += "" KEY. "";
                    if (!mInitialSyncFrameReceived) {
                        mInitialSyncFrameReceived = true;
                    }
                }
                if ((mBufferInfo.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {
                    logStr += "" EOS. "";
                }
                logStr += "" Size: "" + mBufferInfo.size;
                logStr += "". InTime: "" + (mInPresentationTimeUs + 500)/1000 +
                        "". OutTime: "" + (mOutPresentationTimeUs + 500)/1000;
                Log.v(TAG, logStr);

                if (!mInitialSyncFrameReceived
                        && (mBufferInfo.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) == 0) {
                    throw new RuntimeException(""Non codec_config_frame before first sync."");
                }

                if (mBufferInfo.size > 0) {
                    mOutputFrameIndex++;
                    mOutput.outPresentationTimeUs = mOutPresentationTimeUs;
                }
                mCodec.releaseOutputBuffer(outputBufIndex, false);

                mOutput.flags = mBufferInfo.flags;
                mOutput.outputGenerated = true;
            }
            mCallbackReceived = false;
        }

        public MediaEncoderOutput getOutput() throws Exception {
            runCallable( new Callable<Void>() {
                @Override
                public Void call() throws Exception {
                    getOutputInternal();
                    return null;
                }
            } );
            return mOutput;
        }

        public void forceSyncFrame() throws Exception {
            final Bundle syncFrame = new Bundle();
            syncFrame.putInt(MediaCodec.PARAMETER_KEY_REQUEST_SYNC_FRAME, 0);
            runCallable( new Callable<Void>() {
                @Override
                public Void call() throws Exception {
                    mCodec.setParameters(syncFrame);
                    return null;
                }
            } );
        }

        public void updateBitrate(int bitrate) throws Exception {
            final Bundle bitrateUpdate = new Bundle();
            bitrateUpdate.putInt(MediaCodec.PARAMETER_KEY_VIDEO_BITRATE, bitrate);
            runCallable( new Callable<Void>() {
                @Override
                public Void call() throws Exception {
                    mCodec.setParameters(bitrateUpdate);
                    return null;
                }
            } );
        }


        public void waitForBufferEvent() throws Exception {
            Log.v(TAG, ""----Enc"" + mId + "" waiting for bufferEvent"");
            if (mAsync) {
                synchronized (mCallbackEvent) {
                    if (!mCallbackReceived) {
                        mCallbackEvent.wait(1000); // wait 1 sec for a callback
                        // throw an exception if callback was not received
                        if (!mCallbackReceived) {
                            throw new RuntimeException(""MediaCodec callback was not received"");
                        }
                    }
                }
            } else {
                Thread.sleep(5);
            }
            Log.v(TAG, ""----Waiting for bufferEvent done"");
        }


        public void waitForCompletion(long timeoutMs) throws Exception {
            synchronized (mCompletionEvent) {
                long timeoutExpiredMs = System.currentTimeMillis() + timeoutMs;

                while (!mCompleted) {
                    mCompletionEvent.wait(timeoutExpiredMs - System.currentTimeMillis());
                    if (System.currentTimeMillis() >= timeoutExpiredMs) {
                        throw new RuntimeException(""encoding has timed out!"");
                    }
                }
            }
        }

        public void signalCompletion() {
            synchronized (mCompletionEvent) {
                mCompleted = true;
                mCompletionEvent.notify();
            }
        }

        public void deleteCodec() throws Exception {
            runCallable( new Callable<Void>() {
                @Override
                public Void call() throws Exception {
                    mCodec.stop();
                    mCodec.release();
                    return null;
                }
            } );
            if (mAsync) {
                requestStop(); // Stop looper thread
            }
        }
    }

    /**
     * @see #encode(EncoderOutputStreamParameters, ArrayList<ByteBuffer>)
     */
    protected ArrayList<MediaCodec.BufferInfo> encode(
            EncoderOutputStreamParameters streamParams) throws Exception {
        return encode(streamParams, new ArrayList<ByteBuffer>());
    }

    /**
     * Video encoding loop supporting encoding single streams with an option
     * to run in a looper thread and use buffer ready notification callbacks.
     *
     * Output stream is described by encodingParams parameters.
     *
     * MediaCodec will raise an IllegalStateException
     * whenever video encoder fails to encode a frame.
     *
     * Color format of input file should be YUV420, and frameWidth,
     * frameHeight should be supplied correctly as raw input file doesn't
     * include any header data.
     *
     * @param streamParams  Structure with encoder parameters
     * @param codecConfigs  List to be filled with codec config buffers
     * @return              Returns array of encoded frames information for each frame.
     */
    protected ArrayList<MediaCodec.BufferInfo> encode(
            EncoderOutputStreamParameters streamParams,
            ArrayList<ByteBuffer> codecConfigs) throws Exception {

        ArrayList<MediaCodec.BufferInfo> bufferInfos = new ArrayList<MediaCodec.BufferInfo>();
        Log.d(TAG, ""Source resolution: ""+streamParams.frameWidth + "" x "" +
                streamParams.frameHeight);
        int bitrate = streamParams.bitrateSet[0];

        // Create minimal media format signifying desired output.
        MediaFormat format = MediaFormat.createVideoFormat(
                streamParams.codecMimeType, streamParams.frameWidth,
                streamParams.frameHeight);
        format.setInteger(MediaFormat.KEY_BIT_RATE, bitrate);
        CodecProperties properties = getVideoCodecProperties(
                true, format, streamParams.forceGoogleEncoder);
        if (properties == null) {
            return null;
        }

        // Open input/output
        InputStream yuvStream = OpenFileOrResource(
                streamParams.inputYuvFilename, streamParams.inputResource);
        IvfWriter ivf = new IvfWriter(
                streamParams.outputIvfFilename, streamParams.codecMimeType,
                streamParams.frameWidth, streamParams.frameHeight);

        // Create a media format signifying desired output.
        if (streamParams.bitrateType == VIDEO_ControlRateConstant) {
            format.setInteger(""bitrate-mode"", VIDEO_ControlRateConstant); // set CBR
        }
        if (streamParams.temporalLayers > 0) {
            format.setInteger(""ts-layers"", streamParams.temporalLayers); // 1 temporal layer
        }
        format.setInteger(MediaFormat.KEY_COLOR_FORMAT, properties.colorFormat);
        format.setInteger(MediaFormat.KEY_FRAME_RATE, streamParams.frameRate);
        int syncFrameInterval = (streamParams.syncFrameInterval + streamParams.frameRate/2) /
                streamParams.frameRate;
        format.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, syncFrameInterval);

        // Create encoder
        Log.d(TAG, ""Creating encoder "" + properties.codecName +
                "". Color format: 0x"" + Integer.toHexString(properties.colorFormat)+ "" : "" +
                streamParams.frameWidth + "" x "" + streamParams.frameHeight +
                "". Bitrate: "" + bitrate + "" Bitrate type: "" + streamParams.bitrateType +
                "". Fps:"" + streamParams.frameRate + "". TS Layers: "" + streamParams.temporalLayers +
                "". Key frame:"" + syncFrameInterval * streamParams.frameRate +
                "". Force keyFrame: "" + streamParams.syncForceFrameInterval);
        Log.d(TAG, ""  Format: "" + format);
        Log.d(TAG, ""  Output ivf:"" + streamParams.outputIvfFilename);
        MediaEncoderAsync codec = new MediaEncoderAsync();
        codec.createCodec(0, properties.codecName, format,
                streamParams.timeoutDequeue, streamParams.runInLooperThread, streamParams.useNdk);

        // encode loop
        boolean sawInputEOS = false;  // no more data
        boolean consumedInputEOS = false; // EOS flag is consumed dy encoder
        boolean sawOutputEOS = false;
        boolean inputConsumed = true;
        int inputFrameIndex = 0;
        int lastBitrate = bitrate;
        int srcFrameSize = streamParams.frameWidth * streamParams.frameHeight * 3 / 2;
        byte[] srcFrame = new byte[srcFrameSize];

        while (!sawOutputEOS) {

            // Read and feed input frame
            if (!consumedInputEOS) {

                // Read new input buffers - if previous input was consumed and no EOS
                if (inputConsumed && !sawInputEOS) {
                    int bytesRead = yuvStream.read(srcFrame);

                    // Check EOS
                    if (streamParams.frameCount > 0 && inputFrameIndex >= streamParams.frameCount) {
                        sawInputEOS = true;
                        Log.d(TAG, ""---Sending EOS empty frame for frame # "" + inputFrameIndex);
                    }

                    if (!sawInputEOS && bytesRead == -1) {
                        if (streamParams.frameCount == 0) {
                            sawInputEOS = true;
                            Log.d(TAG, ""---Sending EOS empty frame for frame # "" + inputFrameIndex);
                        } else {
                            yuvStream.close();
                            yuvStream = OpenFileOrResource(
                                    streamParams.inputYuvFilename, streamParams.inputResource);
                            bytesRead = yuvStream.read(srcFrame);
                        }
                    }

                    // Force sync frame if syncForceFrameinterval is set.
                    if (!sawInputEOS && inputFrameIndex > 0 &&
                            streamParams.syncForceFrameInterval > 0 &&
                            (inputFrameIndex % streamParams.syncForceFrameInterval) == 0) {
                        Log.d(TAG, ""---Requesting sync frame # "" + inputFrameIndex);
                        codec.forceSyncFrame();
                    }

                    // Dynamic bitrate change.
                    if (!sawInputEOS && streamParams.bitrateSet.length > inputFrameIndex) {
                        int newBitrate = streamParams.bitrateSet[inputFrameIndex];
                        if (newBitrate != lastBitrate) {
                            Log.d(TAG, ""--- Requesting new bitrate "" + newBitrate +
                                    "" for frame "" + inputFrameIndex);
                            codec.updateBitrate(newBitrate);
                            lastBitrate = newBitrate;
                        }
                    }

                    // Convert YUV420 to NV12 if necessary
                    if (properties.colorFormat != CodecCapabilities.COLOR_FormatYUV420Planar) {
                        srcFrame = YUV420ToNV(streamParams.frameWidth, streamParams.frameHeight,
                                srcFrame);
                    }
                }

                inputConsumed = codec.feedInput(srcFrame, sawInputEOS);
                if (inputConsumed) {
                    inputFrameIndex++;
                    consumedInputEOS = sawInputEOS;
                }
            }

            // Get output from the encoder
            MediaEncoderOutput out = codec.getOutput();
            if (out.outputGenerated) {
                // Detect output EOS
                if ((out.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {
                    Log.d(TAG, ""----Output EOS "");
                    sawOutputEOS = true;
                }
                if ((out.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) != 0) {
                    Log.d(TAG, ""Storing codec config separately"");
                    ByteBuffer csdBuffer = ByteBuffer.allocate(out.buffer.length).put(out.buffer);
                    csdBuffer.rewind();
                    codecConfigs.add(csdBuffer);
                    out.buffer = new byte[0];
                }

                if (out.buffer.length > 0) {
                    // Save frame
                    ivf.writeFrame(out.buffer, out.outPresentationTimeUs);

                    // Update statistics - store presentation time delay in offset
                    long presentationTimeUsDelta = out.inPresentationTimeUs -
                            out.outPresentationTimeUs;
                    MediaCodec.BufferInfo bufferInfoCopy = new MediaCodec.BufferInfo();
                    bufferInfoCopy.set((int)presentationTimeUsDelta, out.buffer.length,
                            out.outPresentationTimeUs, out.flags);
                    bufferInfos.add(bufferInfoCopy);
                }
            }

            // If codec is not ready to accept input/poutput - wait for buffer ready callback
            if ((!inputConsumed || consumedInputEOS) && !out.outputGenerated) {
                codec.waitForBufferEvent();
            }
        }

        codec.deleteCodec();
        ivf.close();
        yuvStream.close();

        return bufferInfos;
    }

    /**
     * Video encoding run in a looper thread and use buffer ready callbacks.
     *
     * Output stream is described by encodingParams parameters.
     *
     * MediaCodec will raise an IllegalStateException
     * whenever video encoder fails to encode a frame.
     *
     * Color format of input file should be YUV420, and frameWidth,
     * frameHeight should be supplied correctly as raw input file doesn't
     * include any header data.
     *
     * @param streamParams  Structure with encoder parameters
     * @param codecConfigs  List to be filled with codec config buffers
     * @return              Returns array of encoded frames information for each frame.
     */
    protected ArrayList<MediaCodec.BufferInfo> encodeAsync(
            EncoderOutputStreamParameters streamParams,
            ArrayList<ByteBuffer> codecConfigs) throws Exception {
        if (!streamParams.runInLooperThread) {
            throw new RuntimeException(""encodeAsync should run with a looper thread!"");
        }

        ArrayList<MediaCodec.BufferInfo> bufferInfos = new ArrayList<MediaCodec.BufferInfo>();
        Log.d(TAG, ""Source resolution: ""+streamParams.frameWidth + "" x "" +
                streamParams.frameHeight);
        int bitrate = streamParams.bitrateSet[0];

        // Create minimal media format signifying desired output.
        MediaFormat format = MediaFormat.createVideoFormat(
                streamParams.codecMimeType, streamParams.frameWidth,
                streamParams.frameHeight);
        format.setInteger(MediaFormat.KEY_BIT_RATE, bitrate);
        CodecProperties properties = getVideoCodecProperties(
                true, format, streamParams.forceGoogleEncoder);
        if (properties == null) {
            return null;
        }

        // Open input/output
        IvfWriter ivf = new IvfWriter(
                streamParams.outputIvfFilename, streamParams.codecMimeType,
                streamParams.frameWidth, streamParams.frameHeight);

        // Create a media format signifying desired output.
        if (streamParams.bitrateType == VIDEO_ControlRateConstant) {
            format.setInteger(""bitrate-mode"", VIDEO_ControlRateConstant); // set CBR
        }
        if (streamParams.temporalLayers > 0) {
            format.setInteger(""ts-layers"", streamParams.temporalLayers); // 1 temporal layer
        }
        format.setInteger(MediaFormat.KEY_COLOR_FORMAT, properties.colorFormat);
        format.setInteger(MediaFormat.KEY_FRAME_RATE, streamParams.frameRate);
        int syncFrameInterval = (streamParams.syncFrameInterval + streamParams.frameRate/2) /
                streamParams.frameRate;
        format.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, syncFrameInterval);

        // Create encoder
        Log.d(TAG, ""Creating encoder "" + properties.codecName +
                "". Color format: 0x"" + Integer.toHexString(properties.colorFormat)+ "" : "" +
                streamParams.frameWidth + "" x "" + streamParams.frameHeight +
                "". Bitrate: "" + bitrate + "" Bitrate type: "" + streamParams.bitrateType +
                "". Fps:"" + streamParams.frameRate + "". TS Layers: "" + streamParams.temporalLayers +
                "". Key frame:"" + syncFrameInterval * streamParams.frameRate +
                "". Force keyFrame: "" + streamParams.syncForceFrameInterval);
        Log.d(TAG, ""  Format: "" + format);
        Log.d(TAG, ""  Output ivf:"" + streamParams.outputIvfFilename);

        MediaEncoderAsync codec = new MediaEncoderAsync();
        MediaEncoderAsyncHelper helper = new MediaEncoderAsyncHelper(
                streamParams, properties, bufferInfos, ivf, codecConfigs);

        codec.setAsyncHelper(helper);
        codec.createCodec(0, properties.codecName, format,
                streamParams.timeoutDequeue, streamParams.runInLooperThread, streamParams.useNdk);
        codec.waitForCompletion(DEFAULT_ENCODE_TIMEOUT_MS);

        codec.deleteCodec();
        ivf.close();

        return bufferInfos;
    }

    /**
     * Video encoding loop supporting encoding multiple streams at a time.
     * Each output stream is described by encodingParams parameters allowing
     * simultaneous encoding of various resolutions, bitrates with an option to
     * control key frame and dynamic bitrate for each output stream indepandently.
     *
     * MediaCodec will raise an IllegalStateException
     * whenever video encoder fails to encode a frame.
     *
     * Color format of input file should be YUV420, and frameWidth,
     * frameHeight should be supplied correctly as raw input file doesn't
     * include any header data.
     *
     * @param srcFrameWidth     Frame width of input yuv file
     * @param srcFrameHeight    Frame height of input yuv file
     * @param encodingParams    Encoder parameters
     * @param codecConfigs      List to be filled with codec config buffers
     * @return                  Returns 2D array of encoded frames information for each stream and
     *                          for each frame.
     */
    protected ArrayList<ArrayList<MediaCodec.BufferInfo>> encodeSimulcast(
            int srcFrameWidth,
            int srcFrameHeight,
            ArrayList<EncoderOutputStreamParameters> encodingParams,
            ArrayList<ArrayList<ByteBuffer>> codecConfigs) throws Exception {
        int numEncoders = encodingParams.size();

        // Create arrays of input/output, formats, bitrates etc
        ArrayList<ArrayList<MediaCodec.BufferInfo>> bufferInfos =
                new ArrayList<ArrayList<MediaCodec.BufferInfo>>(numEncoders);
        InputStream yuvStream[] = new InputStream[numEncoders];
        IvfWriter[] ivf = new IvfWriter[numEncoders];
        FileOutputStream[] yuvScaled = new FileOutputStream[numEncoders];
        MediaFormat[] format = new MediaFormat[numEncoders];
        MediaEncoderAsync[] codec = new MediaEncoderAsync[numEncoders];
        int[] inputFrameIndex = new int[numEncoders];
        boolean[] sawInputEOS = new boolean[numEncoders];
        boolean[] consumedInputEOS = new boolean[numEncoders];
        boolean[] inputConsumed = new boolean[numEncoders];
        boolean[] bufferConsumed = new boolean[numEncoders];
        boolean[] sawOutputEOS = new boolean[numEncoders];
        byte[][] srcFrame = new byte[numEncoders][];
        boolean sawOutputEOSTotal = false;
        boolean bufferConsumedTotal = false;
        CodecProperties[] codecProperties = new CodecProperties[numEncoders];

        numEncoders = 0;
        for (EncoderOutputStreamParameters params : encodingParams) {
            int i = numEncoders;
            Log.d(TAG, ""Source resolution: "" + params.frameWidth + "" x "" +
                    params.frameHeight);
            int bitrate = params.bitrateSet[0];

            // Create minimal media format signifying desired output.
            format[i] = MediaFormat.createVideoFormat(
                    params.codecMimeType, params.frameWidth,
                    params.frameHeight);
            format[i].setInteger(MediaFormat.KEY_BIT_RATE, bitrate);
            CodecProperties properties = getVideoCodecProperties(
                    true, format[i], params.forceGoogleEncoder);
            if (properties == null) {
                continue;
            }

            // Check if scaled image was created
            int scale = params.frameWidth / srcFrameWidth;
            if (!mScaledImages.contains(scale)) {
                // resize image
                cacheScaledImage(params.inputYuvFilename, params.inputResource,
                        srcFrameWidth, srcFrameHeight,
                        params.scaledYuvFilename, params.frameWidth, params.frameHeight);
                mScaledImages.add(scale);
            }

            // Create buffer info storage
            bufferInfos.add(new ArrayList<MediaCodec.BufferInfo>());

            // Create YUV reader
            yuvStream[i] = new FileInputStream(params.scaledYuvFilename);

            // Create IVF writer
            ivf[i] = new IvfWriter(
                    params.outputIvfFilename, params.codecMimeType,
                    params.frameWidth, params.frameHeight);

            // Frame buffer
            int frameSize = params.frameWidth * params.frameHeight * 3 / 2;
            srcFrame[i] = new byte[frameSize];

            // Create a media format signifying desired output.
            if (params.bitrateType == VIDEO_ControlRateConstant) {
                format[i].setInteger(""bitrate-mode"", VIDEO_ControlRateConstant); // set CBR
            }
            if (params.temporalLayers > 0) {
                format[i].setInteger(""ts-layers"", params.temporalLayers); // 1 temporal layer
            }
            format[i].setInteger(MediaFormat.KEY_COLOR_FORMAT, properties.colorFormat);
            format[i].setInteger(MediaFormat.KEY_FRAME_RATE, params.frameRate);
            int syncFrameInterval = (params.syncFrameInterval + params.frameRate/2) /
                    params.frameRate; // in sec
            format[i].setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, syncFrameInterval);
            // Create encoder
            Log.d(TAG, ""Creating encoder #"" + i +"" : "" + properties.codecName +
                    "". Color format: 0x"" + Integer.toHexString(properties.colorFormat)+ "" : "" +
                    params.frameWidth + "" x "" + params.frameHeight +
                    "". Bitrate: "" + bitrate + "" Bitrate type: "" + params.bitrateType +
                    "". Fps:"" + params.frameRate + "". TS Layers: "" + params.temporalLayers +
                    "". Key frame:"" + syncFrameInterval * params.frameRate +
                    "". Force keyFrame: "" + params.syncForceFrameInterval);
            Log.d(TAG, ""  Format: "" + format[i]);
            Log.d(TAG, ""  Output ivf:"" + params.outputIvfFilename);

            // Create encoder
            codec[i] = new MediaEncoderAsync();
            codec[i].createCodec(i, properties.codecName, format[i],
                    params.timeoutDequeue, params.runInLooperThread, params.useNdk);
            codecProperties[i] = new CodecProperties(properties.codecName, properties.colorFormat);

            inputConsumed[i] = true;
            ++numEncoders;
        }
        if (numEncoders == 0) {
            Log.i(TAG, ""no suitable encoders found for any of the streams"");
            return null;
        }

        while (!sawOutputEOSTotal) {
            // Feed input buffer to all encoders
            for (int i = 0; i < numEncoders; i++) {
                bufferConsumed[i] = false;
                if (consumedInputEOS[i]) {
                    continue;
                }

                EncoderOutputStreamParameters params = encodingParams.get(i);
                // Read new input buffers - if previous input was consumed and no EOS
                if (inputConsumed[i] && !sawInputEOS[i]) {
                    int bytesRead = yuvStream[i].read(srcFrame[i]);

                    // Check EOS
                    if (params.frameCount > 0 && inputFrameIndex[i] >= params.frameCount) {
                        sawInputEOS[i] = true;
                        Log.d(TAG, ""---Enc"" + i +
                                "". Sending EOS empty frame for frame # "" + inputFrameIndex[i]);
                    }

                    if (!sawInputEOS[i] && bytesRead == -1) {
                        if (params.frameCount == 0) {
                            sawInputEOS[i] = true;
                            Log.d(TAG, ""---Enc"" + i +
                                    "". Sending EOS empty frame for frame # "" + inputFrameIndex[i]);
                        } else {
                            yuvStream[i].close();
                            yuvStream[i] = new FileInputStream(params.scaledYuvFilename);
                            bytesRead = yuvStream[i].read(srcFrame[i]);
                        }
                    }

                    // Convert YUV420 to NV12 if necessary
                    if (codecProperties[i].colorFormat !=
                            CodecCapabilities.COLOR_FormatYUV420Planar) {
                        srcFrame[i] =
                            YUV420ToNV(params.frameWidth, params.frameHeight, srcFrame[i]);
                    }
                }

                inputConsumed[i] = codec[i].feedInput(srcFrame[i], sawInputEOS[i]);
                if (inputConsumed[i]) {
                    inputFrameIndex[i]++;
                    consumedInputEOS[i] = sawInputEOS[i];
                    bufferConsumed[i] = true;
                }

            }

            // Get output from all encoders
            for (int i = 0; i < numEncoders; i++) {
                if (sawOutputEOS[i]) {
                    continue;
                }

                MediaEncoderOutput out = codec[i].getOutput();
                if (out.outputGenerated) {
                    bufferConsumed[i] = true;
                    // Detect output EOS
                    if ((out.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {
                        Log.d(TAG, ""----Enc"" + i + "". Output EOS "");
                        sawOutputEOS[i] = true;
                    }
                    if ((out.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) != 0) {
                        Log.d(TAG, ""----Enc"" + i + "". Storing codec config separately"");
                        ByteBuffer csdBuffer = ByteBuffer.allocate(out.buffer.length).put(out.buffer);
                        csdBuffer.rewind();
                        codecConfigs.get(i).add(csdBuffer);
                        out.buffer = new byte[0];
                    }

                    if (out.buffer.length > 0) {
                        // Save frame
                        ivf[i].writeFrame(out.buffer, out.outPresentationTimeUs);

                        // Update statistics - store presentation time delay in offset
                        long presentationTimeUsDelta = out.inPresentationTimeUs -
                                out.outPresentationTimeUs;
                        MediaCodec.BufferInfo bufferInfoCopy = new MediaCodec.BufferInfo();
                        bufferInfoCopy.set((int)presentationTimeUsDelta, out.buffer.length,
                                out.outPresentationTimeUs, out.flags);
                        bufferInfos.get(i).add(bufferInfoCopy);
                    }
                }
            }

            // If codec is not ready to accept input/output - wait for buffer ready callback
            bufferConsumedTotal = false;
            for (boolean bufferConsumedCurrent : bufferConsumed) {
                bufferConsumedTotal |= bufferConsumedCurrent;
            }
            if (!bufferConsumedTotal) {
                // Pick the encoder to wait for
                for (int i = 0; i < numEncoders; i++) {
                    if (!bufferConsumed[i] && !sawOutputEOS[i]) {
                        codec[i].waitForBufferEvent();
                        break;
                    }
                }
            }

            // Check if EOS happened for all encoders
            sawOutputEOSTotal = true;
            for (boolean sawOutputEOSStream : sawOutputEOS) {
                sawOutputEOSTotal &= sawOutputEOSStream;
            }
        }

        for (int i = 0; i < numEncoders; i++) {
            codec[i].deleteCodec();
            ivf[i].close();
            yuvStream[i].close();
            if (yuvScaled[i] != null) {
                yuvScaled[i].close();
            }
        }

        return bufferInfos;
    }

    /**
     * Some encoding statistics.
     */
    protected class VideoEncodingStatistics {
        VideoEncodingStatistics() {
            mBitrates = new ArrayList<Integer>();
            mFrames = new ArrayList<Integer>();
            mKeyFrames = new ArrayList<Integer>();
            mMinimumKeyFrameInterval = Integer.MAX_VALUE;
        }

        public ArrayList<Integer> mBitrates;// Bitrate values for each second of the encoded stream.
        public ArrayList<Integer> mFrames; // Number of frames in each second of the encoded stream.
        public int mAverageBitrate;         // Average stream bitrate.
        public ArrayList<Integer> mKeyFrames;// Stores the position of key frames in a stream.
        public int mAverageKeyFrameInterval; // Average key frame interval.
        public int mMaximumKeyFrameInterval; // Maximum key frame interval.
        public int mMinimumKeyFrameInterval; // Minimum key frame interval.
    }

    /**
     * Calculates average bitrate and key frame interval for the encoded streams.
     * Output mBitrates field will contain bitrate values for every second
     * of the encoded stream.
     * Average stream bitrate will be stored in mAverageBitrate field.
     * mKeyFrames array will contain the position of key frames in the encoded stream and
     * mKeyFrameInterval - average key frame interval.
     */
    protected VideoEncodingStatistics computeEncodingStatistics(int encoderId,
            ArrayList<MediaCodec.BufferInfo> bufferInfos ) {
        VideoEncodingStatistics statistics = new VideoEncodingStatistics();

        int totalSize = 0;
        int frames = 0;
        int framesPerSecond = 0;
        int totalFrameSizePerSecond = 0;
        int maxFrameSize = 0;
        int currentSecond;
        int nextSecond = 0;
        String keyFrameList = ""  IFrame List: "";
        String bitrateList = ""  Bitrate list: "";
        String framesList = ""  FPS list: "";


        for (int j = 0; j < bufferInfos.size(); j++) {
            MediaCodec.BufferInfo info = bufferInfos.get(j);
            currentSecond = (int)(info.presentationTimeUs / 1000000);
            boolean lastFrame = (j == bufferInfos.size() - 1);
            if (!lastFrame) {
                nextSecond = (int)(bufferInfos.get(j+1).presentationTimeUs / 1000000);
            }

            totalSize += info.size;
            totalFrameSizePerSecond += info.size;
            maxFrameSize = Math.max(maxFrameSize, info.size);
            framesPerSecond++;
            frames++;

            // Update the bitrate statistics if the next frame will
            // be for the next second
            if (lastFrame || nextSecond > currentSecond) {
                int currentBitrate = totalFrameSizePerSecond * 8;
                bitrateList += (currentBitrate + "" "");
                framesList += (framesPerSecond + "" "");
                statistics.mBitrates.add(currentBitrate);
                statistics.mFrames.add(framesPerSecond);
                totalFrameSizePerSecond = 0;
                framesPerSecond = 0;
            }

            // Update key frame statistics.
            if ((info.flags & MediaCodec.BUFFER_FLAG_SYNC_FRAME) != 0) {
                statistics.mKeyFrames.add(j);
                keyFrameList += (j + ""  "");
            }
        }
        int duration = (int)(bufferInfos.get(bufferInfos.size() - 1).presentationTimeUs / 1000);
        duration = (duration + 500) / 1000;
        statistics.mAverageBitrate = (int)(((long)totalSize * 8) / duration);
        Log.d(TAG, ""Statistics for encoder # "" + encoderId);
        // Calculate average key frame interval in frames.
        int keyFrames = statistics.mKeyFrames.size();
        if (keyFrames > 1) {
            statistics.mAverageKeyFrameInterval =
                    statistics.mKeyFrames.get(keyFrames - 1) - statistics.mKeyFrames.get(0);
            statistics.mAverageKeyFrameInterval =
                    Math.round((float)statistics.mAverageKeyFrameInterval / (keyFrames - 1));
            for (int j = 1; j < keyFrames; j++) {
                int keyFrameInterval =
                        statistics.mKeyFrames.get(j) - statistics.mKeyFrames.get(j - 1);
                statistics.mMaximumKeyFrameInterval =
                        Math.max(statistics.mMaximumKeyFrameInterval, keyFrameInterval);
                statistics.mMinimumKeyFrameInterval =
                        Math.min(statistics.mMinimumKeyFrameInterval, keyFrameInterval);
            }
            Log.d(TAG, ""  Key frame intervals: Max: "" + statistics.mMaximumKeyFrameInterval +
                    "". Min: "" + statistics.mMinimumKeyFrameInterval +
                    "". Avg: "" + statistics.mAverageKeyFrameInterval);
        }
        Log.d(TAG, ""  Frames: "" + frames + "". Duration: "" + duration +
                "". Total size: "" + totalSize + "". Key frames: "" + keyFrames);
        Log.d(TAG, keyFrameList);
        Log.d(TAG, bitrateList);
        Log.d(TAG, framesList);
        Log.d(TAG, ""  Bitrate average: "" + statistics.mAverageBitrate);
        Log.d(TAG, ""  Maximum frame size: "" + maxFrameSize);

        return statistics;
    }

    protected VideoEncodingStatistics computeEncodingStatistics(
            ArrayList<MediaCodec.BufferInfo> bufferInfos ) {
        return computeEncodingStatistics(0, bufferInfos);
    }

    protected ArrayList<VideoEncodingStatistics> computeSimulcastEncodingStatistics(
            ArrayList<ArrayList<MediaCodec.BufferInfo>> bufferInfos) {
        int numCodecs = bufferInfos.size();
        ArrayList<VideoEncodingStatistics> statistics = new ArrayList<VideoEncodingStatistics>();

        for (int i = 0; i < numCodecs; i++) {
            VideoEncodingStatistics currentStatistics =
                    computeEncodingStatistics(i, bufferInfos.get(i));
            statistics.add(currentStatistics);
        }
        return statistics;
    }

    /**
     * Calculates maximum latency for encoder/decoder based on buffer info array
     * generated either by encoder or decoder.
     */
    protected int maxPresentationTimeDifference(ArrayList<MediaCodec.BufferInfo> bufferInfos) {
        int maxValue = 0;
        for (MediaCodec.BufferInfo bufferInfo : bufferInfos) {
            maxValue = Math.max(maxValue,  bufferInfo.offset);
        }
        maxValue = (maxValue + 500) / 1000; // mcs -> ms
        return maxValue;
    }

    /**
     * Decoding PSNR statistics.
     */
    protected class VideoDecodingStatistics {
        VideoDecodingStatistics() {
            mMinimumPSNR = Integer.MAX_VALUE;
        }
        public double mAveragePSNR;
        public double mMinimumPSNR;
    }

    /**
     * Calculates PSNR value between two video frames.
     */
    private double computePSNR(byte[] data0, byte[] data1) {
        long squareError = 0;
        assertTrue(data0.length == data1.length);
        int length = data0.length;
        for (int i = 0 ; i < length; i++) {
            int diff = ((int)data0[i] & 0xff) - ((int)data1[i] & 0xff);
            squareError += diff * diff;
        }
        double meanSquareError = (double)squareError / length;
        double psnr = 10 * Math.log10((double)255 * 255 / meanSquareError);
        return psnr;
    }

    /**
     * Calculates average and minimum PSNR values between
     * set of reference and decoded video frames.
     * Runs PSNR calculation for the full duration of the decoded data.
     */
    protected VideoDecodingStatistics computeDecodingStatistics(
            String referenceYuvFilename,
            String referenceYuvRaw,
            String decodedYuvFilename,
            int width,
            int height) throws Exception {
        VideoDecodingStatistics statistics = new VideoDecodingStatistics();
        InputStream referenceStream =
                OpenFileOrResource(referenceYuvFilename, referenceYuvRaw);
        InputStream decodedStream = new FileInputStream(decodedYuvFilename);

        int ySize = width * height;
        int uvSize = width * height / 4;
        byte[] yRef = new byte[ySize];
        byte[] yDec = new byte[ySize];
        byte[] uvRef = new byte[uvSize];
        byte[] uvDec = new byte[uvSize];

        int frames = 0;
        double averageYPSNR = 0;
        double averageUPSNR = 0;
        double averageVPSNR = 0;
        double minimumYPSNR = Integer.MAX_VALUE;
        double minimumUPSNR = Integer.MAX_VALUE;
        double minimumVPSNR = Integer.MAX_VALUE;
        int minimumPSNRFrameIndex = 0;

        while (true) {
            // Calculate Y PSNR.
            int bytesReadRef = referenceStream.read(yRef);
            int bytesReadDec = decodedStream.read(yDec);
            if (bytesReadDec == -1) {
                break;
            }
            if (bytesReadRef == -1) {
                // Reference file wrapping up
                referenceStream.close();
                referenceStream =
                        OpenFileOrResource(referenceYuvFilename, referenceYuvRaw);
                bytesReadRef = referenceStream.read(yRef);
            }
            double curYPSNR = computePSNR(yRef, yDec);
            averageYPSNR += curYPSNR;
            minimumYPSNR = Math.min(minimumYPSNR, curYPSNR);
            double curMinimumPSNR = curYPSNR;

            // Calculate U PSNR.
            bytesReadRef = referenceStream.read(uvRef);
            bytesReadDec = decodedStream.read(uvDec);
            double curUPSNR = computePSNR(uvRef, uvDec);
            averageUPSNR += curUPSNR;
            minimumUPSNR = Math.min(minimumUPSNR, curUPSNR);
            curMinimumPSNR = Math.min(curMinimumPSNR, curUPSNR);

            // Calculate V PSNR.
            bytesReadRef = referenceStream.read(uvRef);
            bytesReadDec = decodedStream.read(uvDec);
            double curVPSNR = computePSNR(uvRef, uvDec);
            averageVPSNR += curVPSNR;
            minimumVPSNR = Math.min(minimumVPSNR, curVPSNR);
            curMinimumPSNR = Math.min(curMinimumPSNR, curVPSNR);

            // Frame index for minimum PSNR value - help to detect possible distortions
            if (curMinimumPSNR < statistics.mMinimumPSNR) {
                statistics.mMinimumPSNR = curMinimumPSNR;
                minimumPSNRFrameIndex = frames;
            }

            String logStr = String.format(Locale.US, ""PSNR #%d: Y: %.2f. U: %.2f. V: %.2f"",
                    frames, curYPSNR, curUPSNR, curVPSNR);
            Log.v(TAG, logStr);

            frames++;
        }

        averageYPSNR /= frames;
        averageUPSNR /= frames;
        averageVPSNR /= frames;
        statistics.mAveragePSNR = (4 * averageYPSNR + averageUPSNR + averageVPSNR) / 6;

        Log.d(TAG, ""PSNR statistics for "" + frames + "" frames."");
        String logStr = String.format(Locale.US,
                ""Average PSNR: Y: %.1f. U: %.1f. V: %.1f. Average: %.1f"",
                averageYPSNR, averageUPSNR, averageVPSNR, statistics.mAveragePSNR);
        Log.d(TAG, logStr);
        logStr = String.format(Locale.US,
                ""Minimum PSNR: Y: %.1f. U: %.1f. V: %.1f. Overall: %.1f at frame %d"",
                minimumYPSNR, minimumUPSNR, minimumVPSNR,
                statistics.mMinimumPSNR, minimumPSNRFrameIndex);
        Log.d(TAG, logStr);

        referenceStream.close();
        decodedStream.close();
        return statistics;
    }
}"	""	""	"RCS"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.ImsRcsManagerTest"	"beforeAllTests"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsRcsManagerTest.java"	""	"/*
 *.
 */

package android.telephony.ims.cts;

import static org.junit.Assert.fail;

import android.content.Context;
import android.os.Looper;
import android.telephony.SubscriptionManager;
import android.telephony.ims.ImsException;
import android.telephony.ims.ImsManager;
import android.telephony.ims.ImsRcsManager;
import android.telephony.ims.ImsStateCallback;

import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.platform.app.InstrumentationRegistry;

import com.android.compatibility.common.util.ShellIdentityUtils;

import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;

@RunWith(AndroidJUnit4.class)
public class ImsRcsManagerTest {

    private static int sTestSub = SubscriptionManager.INVALID_SUBSCRIPTION_ID;

    @BeforeClass
    public static void beforeAllTests() {
        // assumeTrue() in @BeforeClass is not supported by our test runner.
        // Resort to the early exit.
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }

        sTestSub = ImsUtils.getPreferredActiveSubId();

        if (Looper.getMainLooper() == null) {
            Looper.prepareMainLooper();
        }
    }

    @Before
    public void beforeTest() {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }

        if (!SubscriptionManager.isValidSubscriptionId(sTestSub)) {
            fail(""This test requires that there is a SIM in the device!"");
        }
    }

    /**
     * Test Permissions on various APIs.
     */"	""	""	"RCS"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.ImsRcsManagerTest"	"testMethodPermissions"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsRcsManagerTest.java"	""	"public void testMethodPermissions() throws Exception {
        if (!ImsUtils.shouldTestTelephony()) {
            return;
        }

        // This verifies the permission checking in ITelephony,
        // not the IMS service's behavior.
        // Since SecurityException has the highest priority,
        // DEFAULT_SUBSCRIPTION_ID is enough to check permissions.
        // Though it throws an ImsException, we ignore that.
        if (sTestSub == SubscriptionManager.INVALID_SUBSCRIPTION_ID) {
            sTestSub = SubscriptionManager.DEFAULT_SUBSCRIPTION_ID;
        }

        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        ImsRcsManager rcsManager = imsManager.getImsRcsManager(sTestSub);

        ImsStateCallback callback = new ImsStateCallback() {
            @Override
            public void onUnavailable(int reason) { }
            @Override
            public void onAvailable() { }
            @Override
            public void onError() { }
        };

        try {
            rcsManager.registerImsStateCallback(Runnable::run, callback);
            fail(""registerImsStateCallback requires READ_PRECISE_PHONE_STATE, ""
                    + ""ACCESS_RCS_USER_CAPABILITY_EXCHANGE or ""
                    + ""READ_PRIVILEGED_PHONE_STATE permission."");
        } catch (SecurityException e) {
            //expected
        } catch (ImsException ie) {
            fail(""registerImsStateCallback requires READ_PRECISE_PHONE_STATE, ""
                    + ""ACCESS_RCS_USER_CAPABILITY_EXCHANGE or ""
                    + ""READ_PRIVILEGED_PHONE_STATE permission."");
        }

        try {
            ShellIdentityUtils.invokeThrowableMethodWithShellPermissionsNoReturn(rcsManager,
                    m -> m.registerImsStateCallback(Runnable::run, callback),
                    ImsException.class, ""android.permission.READ_PRECISE_PHONE_STATE"");
        } catch (SecurityException e) {
            fail(""registerImsStateCallback requires READ_PRECISE_PHONE_STATE permission."");
        } catch (ImsException ignore) {
            // don't care, permission check passed
        }

        try {
            rcsManager.unregisterImsStateCallback(callback);
        } catch (SecurityException e) {
            fail(""uregisterImsStateCallback requires no permission."");
        }

        try {
            ShellIdentityUtils.invokeThrowableMethodWithShellPermissionsNoReturn(rcsManager,
                    m -> m.registerImsStateCallback(Runnable::run, callback),
                    ImsException.class, ""android.permission.ACCESS_RCS_USER_CAPABILITY_EXCHANGE"");
        } catch (SecurityException e) {
            fail(""registerImsStateCallback requires ""
                    + ""ACCESS_RCS_USER_CAPABILITY_EXCHANGE permission."");
        } catch (ImsException ignore) {
            // don't care, permission check passed
        }

        try {
            rcsManager.unregisterImsStateCallback(callback);
        } catch (SecurityException e) {
            // unreachable, already passed permission check
            fail(""uregisterImsStateCallback requires no permission."");
        }

        try {
            ShellIdentityUtils.invokeThrowableMethodWithShellPermissionsNoReturn(rcsManager,
                    m -> m.registerImsStateCallback(Runnable::run, callback),
                    ImsException.class, ""android.permission.READ_PRIVILEGED_PHONE_STATE"");
        } catch (SecurityException e) {
            fail(""registerImsStateCallback requires READ_PRIVILEGED_PHONE_STATE permission."");
        } catch (ImsException ignore) {
            // don't care, permission check passed
        }

        try {
            rcsManager.unregisterImsStateCallback(callback);
        } catch (SecurityException e) {
            // unreachable, already passed permission check
            fail(""uregisterImsStateCallback requires no permission."");
        }
    }

    private static Context getContext() {
        return InstrumentationRegistry.getInstrumentation().getContext();
    }
}"	""	""	"RCS"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.SipDelegateManagerTest"	"connectTestImsServiceWithSipTransportAndConfig"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/SipDelegateManagerTest.java"	""	"/*
 *.
 */

package android.telephony.ims.cts;

import static junit.framework.Assert.assertNotNull;
import static junit.framework.Assert.assertTrue;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.fail;

import static java.nio.charset.StandardCharsets.UTF_8;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.net.InetAddresses;
import android.net.Uri;
import android.os.Parcel;
import android.os.PersistableBundle;
import android.telephony.CarrierConfigManager;
import android.telephony.SubscriptionManager;
import android.telephony.TelephonyManager;
import android.telephony.ims.DelegateRegistrationState;
import android.telephony.ims.DelegateRequest;
import android.telephony.ims.FeatureTagState;
import android.telephony.ims.ImsException;
import android.telephony.ims.ImsManager;
import android.telephony.ims.ImsService;
import android.telephony.ims.ImsStateCallback;
import android.telephony.ims.SipDelegateConfiguration;
import android.telephony.ims.SipDelegateManager;
import android.telephony.ims.SipMessage;
import android.telephony.ims.feature.ImsFeature;
import android.telephony.ims.stub.ImsFeatureConfiguration;
import android.util.ArraySet;

import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.platform.app.InstrumentationRegistry;

import com.android.compatibility.common.util.ShellIdentityUtils;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Ignore;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.net.InetSocketAddress;
import java.util.Arrays;
import java.util.Collections;
import java.util.Set;
import java.util.concurrent.Callable;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

/**
 * CTS tests for {@link SipDelegateManager} API.
 */
@RunWith(AndroidJUnit4.class)
public class SipDelegateManagerTest {
    private static final String MMTEL_TAG =
            ""+g.3gpp.iari-ref=\""urn%3Aurn-7%3A3gpp-service.ims.icsi.mmtel\"""";
    private static final String ONE_TO_ONE_CHAT_TAG =
            ""+g.3gpp.icsi-ref=\""urn%3Aurn-7%3A3gppservice.ims.icsi.oma.cpm.msg\"""";
    private static final String GROUP_CHAT_TAG =
            ""+g.3gpp.icsi-ref=\""urn%3Aurn-7%3A3gppservice.ims.icsi.oma.cpm.session\"""";
    private static final String FILE_TRANSFER_HTTP_TAG =
            ""+g.3gpp.iari-ref=\""urn%3Aurn-7%3A3gppapplication.ims.iari.rcs.fthttp\"""";

    private static final String[] DEFAULT_FEATURE_TAGS = {
            ONE_TO_ONE_CHAT_TAG, GROUP_CHAT_TAG, FILE_TRANSFER_HTTP_TAG};

    private static class CarrierConfigReceiver extends BroadcastReceiver {
        private CountDownLatch mLatch = new CountDownLatch(1);
        private final int mSubId;

        CarrierConfigReceiver(int subId) {
            mSubId = subId;
        }

        @Override
        public void onReceive(Context context, Intent intent) {
            if (CarrierConfigManager.ACTION_CARRIER_CONFIG_CHANGED.equals(intent.getAction())) {
                int subId = intent.getIntExtra(CarrierConfigManager.EXTRA_SUBSCRIPTION_INDEX, -1);
                if (mSubId == subId) {
                    mLatch.countDown();
                }
            }
        }

        void clearQueue() {
            mLatch = new CountDownLatch(1);
        }

        void waitForCarrierConfigChanged() throws Exception {
            mLatch.await(5000, TimeUnit.MILLISECONDS);
        }
    }

    /**
     * Encapsulates the interfaces created during SipDelegateManager testing.
     */
    public class TransportInterfaces {
        public final DelegateRequest request;
        public final Set<FeatureTagState> deniedTags;
        public final SipDelegateManager manager;
        public TestSipTransport transport;
        public TestImsRegistration reg;
        public TestSipDelegate delegate;
        public TestSipDelegateConnection delegateConn;
        private final int mDelegateIndex;

        public TransportInterfaces(DelegateRequest request, Set<FeatureTagState>  deniedTags,
                int delegateIndex) {
            this.request = request;
            this.deniedTags = deniedTags;
            manager = getSipDelegateManager();
            mDelegateIndex = delegateIndex;
        }

        public void connect() throws Exception {
            assertTrue(sServiceConnector.setDefaultSmsApp());
            connectTestImsServiceWithSipTransportAndConfig();

            transport = sServiceConnector.getCarrierService().getSipTransport();
            reg = sServiceConnector.getCarrierService().getImsRegistration();
            delegateConn = new TestSipDelegateConnection(request);

            delegate = createSipDelegateConnectionAndVerify(manager, delegateConn,
                    transport, deniedTags, mDelegateIndex);
            assertNotNull(delegate);
            // ensure we got a callback for initial reg state.
            verifyUpdateRegistrationCalled(reg);

            InetSocketAddress localAddr = new InetSocketAddress(
                    InetAddresses.parseNumericAddress(""1.1.1.1""), 80);
            InetSocketAddress serverAddr = new InetSocketAddress(
                    InetAddresses.parseNumericAddress(""2.2.2.2""), 81);
            SipDelegateConfiguration c = new SipDelegateConfiguration.Builder(1,
                    SipDelegateConfiguration.SIP_TRANSPORT_TCP, localAddr, serverAddr).build();
            // send first SIP config and verify
            verifyRegisteredAndSendSipConfig(delegateConn, delegate, request.getFeatureTags(),
                    deniedTags, c);
        }

        /**
         * Create a connection between fake app interface and fake ImsService impl and set up the
         * framework to accept incoming/outgoing messages. Once done, verify the transport is open.
         */
        public void connectAndVerify() throws Exception {
            connect();

            // Verify message transport is open.
            verifyOutgoingTransport(delegateConn, delegate);
            verifyIncomingTransport(delegateConn, delegate);
        }
    }

    private static int sTestSlot = 0;
    private static int sTestSub = SubscriptionManager.INVALID_SUBSCRIPTION_ID;
    private static ImsServiceConnector sServiceConnector;
    private static CarrierConfigReceiver sReceiver;

    @BeforeClass
    public static void beforeAllTests() throws Exception {
        // First, only populate test slot/sub
        if (!ImsUtils.shouldTestTelephony()) {
            return;
        }

        TelephonyManager tm = (TelephonyManager) getContext()
                .getSystemService(Context.TELEPHONY_SERVICE);
        sTestSub = ImsUtils.getPreferredActiveSubId();
        sTestSlot = SubscriptionManager.getSlotIndex(sTestSub);
        if (tm.getSimState(sTestSlot) != TelephonyManager.SIM_STATE_READY) {
            return;
        }
        // Next, only start tests that require ImsResolver to bind to test ImsService if
        // feature FEATURE_TELEPHONY_IMS is supported on this device.
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        sServiceConnector = new ImsServiceConnector(InstrumentationRegistry.getInstrumentation());
        // Remove all live ImsServices until after these tests are done
        sServiceConnector.clearAllActiveImsServices(sTestSlot);

        sReceiver = new CarrierConfigReceiver(sTestSub);
        IntentFilter filter = new IntentFilter(CarrierConfigManager.ACTION_CARRIER_CONFIG_CHANGED);
        // ACTION_CARRIER_CONFIG_CHANGED is sticky, so we will get a callback right away.
        InstrumentationRegistry.getInstrumentation().getContext()
                .registerReceiver(sReceiver, filter);

        if (!ImsUtils.shouldTestImsSingleRegistration()) {
            // override FEATURE_TELEPHONY_IMS_SINGLE_REGISTRATION setting for this test to enable
            // APIs.
            sServiceConnector.setDeviceSingleRegistrationEnabled(true);
        }

        setFeatureTagsCarrierAllowed(DEFAULT_FEATURE_TAGS);
    }

    @AfterClass
    public static void afterAllTests() throws Exception {
        // Only clean up ImsResolver overrides if feature FEATURE_TELEPHONY_IMS is supported.
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }

        // Restore all ImsService configurations that existed before the test.
        if (sServiceConnector != null) {
            sServiceConnector.disconnectServices();
        }
        sServiceConnector = null;

        // Ensure there are no CarrierConfig overrides as well as reset the ImsResolver in case the
        // ImsService override changed in CarrierConfig while we were overriding it.
        overrideCarrierConfig(null);

        if (sReceiver != null) {
            InstrumentationRegistry.getInstrumentation().getContext().unregisterReceiver(sReceiver);
            sReceiver = null;
        }
    }

    @Before
    public void beforeTest() {
        if (!ImsUtils.shouldTestTelephony()) {
            return;
        }
        TelephonyManager tm = (TelephonyManager) InstrumentationRegistry.getInstrumentation()
                .getContext().getSystemService(Context.TELEPHONY_SERVICE);
        if (tm.getSimState(sTestSlot) != TelephonyManager.SIM_STATE_READY) {
            fail(""This test requires that there is a SIM in the device!"");
        }
        // Correctness check: ensure that the subscription hasn't changed between tests.
        int[] subs = SubscriptionManager.getSubId(sTestSlot);

        if (subs == null) {
            fail(""This test requires there is an active subscription in slot "" + sTestSlot);
        }
        boolean isFound = false;
        for (int sub : subs) {
            isFound |= (sTestSub == sub);
        }
        if (!isFound) {
            fail(""Invalid state found: the test subscription in slot "" + sTestSlot + "" changed ""
                    + ""during this test."");
        }
    }

    @After
    public void afterTest() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        // Unbind the ImsService after the test completes only if feature FEATURE_TELEPHONY_IMS
        // is enabled.
        if (sServiceConnector != null) {
            sServiceConnector.disconnectCarrierImsService();
            sServiceConnector.restoreDefaultSmsApp();
        }
    }"	""	""	"RCS MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.SipDelegateManagerTest"	"testIsSupportedWithSipTransportCapableCarrierConfigNotSet"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/SipDelegateManagerTest.java"	""	"public void testIsSupportedWithSipTransportCapableCarrierConfigNotSet() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        PersistableBundle b = new PersistableBundle();
        // Carrier Config is explicitly set to not support single registration.
        b.putBoolean(CarrierConfigManager.Ims.KEY_IMS_SINGLE_REGISTRATION_REQUIRED_BOOL, false);
        overrideCarrierConfig(b);
        connectTestImsServiceWithSipTransport();

        Boolean result = callUntilImsServiceIsAvailable(() ->
                ShellIdentityUtils.invokeThrowableMethodWithShellPermissions(
                        getSipDelegateManager(), SipDelegateManager::isSupported,
                        ImsException.class, ""android.permission.PERFORM_IMS_SINGLE_REGISTRATION""));
        assertNotNull(result);
        assertFalse(""isSupported should return false if""
                + ""CarrierConfigManager.Ims.KEY_RCS_SINGLE_REGISTRATION_REQUIRED_BOOL is set to ""
                + ""false"", result);
    }

    @Ignore(""Disabling for integration b/175766573"")"	""	""	"RCS"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.SipDelegateManagerTest"	"testIsSupportedWithSipTransportCapableOnlyRcs"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/SipDelegateManagerTest.java"	""	"public void testIsSupportedWithSipTransportCapableOnlyRcs() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        PersistableBundle b = new PersistableBundle();
        b.putBoolean(CarrierConfigManager.Ims.KEY_IMS_SINGLE_REGISTRATION_REQUIRED_BOOL, true);
        overrideCarrierConfig(b);

        assertTrue(sServiceConnector.connectCarrierImsServiceLocally());
        // set SipTransport as supported with RCS only attached.
        sServiceConnector.getCarrierService().addCapabilities(
                ImsService.CAPABILITY_SIP_DELEGATE_CREATION);
        sServiceConnector.getCarrierService().setSipTransportImplemented();

        ImsFeatureConfiguration c = getConfigForRcs();
        assertTrue(sServiceConnector.triggerFrameworkConnectionToCarrierImsService(c));
        verifyImsServiceState(c);

        Boolean result = callUntilImsServiceIsAvailable(() ->
                ShellIdentityUtils.invokeThrowableMethodWithShellPermissions(
                        getSipDelegateManager(), SipDelegateManager::isSupported,
                        ImsException.class, ""android.permission.PERFORM_IMS_SINGLE_REGISTRATION""));
        assertNotNull(result);
        assertFalse(""isSupported should return false in the case that the ImsService is only ""
                + ""attached for RCS and not MMTEL and RCS"", result);
    }"	""	""	"RCS MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.SipDelegateManagerTest"	"testIsSupportedWithSipTransportCapableButNotImplemented"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/SipDelegateManagerTest.java"	""	"public void testIsSupportedWithSipTransportCapableButNotImplemented() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        PersistableBundle b = new PersistableBundle();
        b.putBoolean(CarrierConfigManager.Ims.KEY_IMS_SINGLE_REGISTRATION_REQUIRED_BOOL, true);
        overrideCarrierConfig(b);

        assertTrue(sServiceConnector.connectCarrierImsServiceLocally());
        // SipTransport set as capable, but no SipTransport implementation is returned.
        sServiceConnector.getCarrierService().addCapabilities(
                ImsService.CAPABILITY_SIP_DELEGATE_CREATION);
        ImsFeatureConfiguration c = getConfigForMmTelAndRcs();
        assertTrue(sServiceConnector.triggerFrameworkConnectionToCarrierImsService(c));
        verifyImsServiceState(c);

        Boolean result = callUntilImsServiceIsAvailable(() ->
                ShellIdentityUtils.invokeThrowableMethodWithShellPermissions(
                        getSipDelegateManager(), SipDelegateManager::isSupported,
                        ImsException.class, ""android.permission.PERFORM_IMS_SINGLE_REGISTRATION""));
        assertNotNull(result);
        assertFalse(""isSupported should return false in the case that SipTransport is not ""
                + ""implemented"", result);
    }"	""	""	"RCS MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.SipDelegateManagerTest"	"testIsSupportedWithSipTransportImplementedButNotCapable"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/SipDelegateManagerTest.java"	""	"public void testIsSupportedWithSipTransportImplementedButNotCapable() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        PersistableBundle b = new PersistableBundle();
        b.putBoolean(CarrierConfigManager.Ims.KEY_IMS_SINGLE_REGISTRATION_REQUIRED_BOOL, true);
        overrideCarrierConfig(b);

        assertTrue(sServiceConnector.connectCarrierImsServiceLocally());
        // SipTransport is set as Implemented, but not Capable
        sServiceConnector.getCarrierService().setSipTransportImplemented();
        ImsFeatureConfiguration c = getConfigForMmTelAndRcs();
        assertTrue(sServiceConnector.triggerFrameworkConnectionToCarrierImsService(c));
        verifyImsServiceState(c);

        Boolean result = callUntilImsServiceIsAvailable(() ->
                ShellIdentityUtils.invokeThrowableMethodWithShellPermissions(
                        getSipDelegateManager(), SipDelegateManager::isSupported,
                        ImsException.class, ""android.permission.PERFORM_IMS_SINGLE_REGISTRATION""));
        assertNotNull(result);
        assertFalse(""isSupported should return false in the case that SipTransport is not ""
                + ""set as capable in ImsService#getImsServiceCapabilities"", result);
    }"	""	""	"RCS MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.SipDelegateManagerTest"	"testIsSupportedWithSipTransportNotImplementedNotCapable"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/SipDelegateManagerTest.java"	""	"public void testIsSupportedWithSipTransportNotImplementedNotCapable() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        PersistableBundle b = new PersistableBundle();
        b.putBoolean(CarrierConfigManager.Ims.KEY_IMS_SINGLE_REGISTRATION_REQUIRED_BOOL, true);
        overrideCarrierConfig(b);

        assertTrue(sServiceConnector.connectCarrierImsServiceLocally());
        // Not Implemented/capable
        ImsFeatureConfiguration c = getConfigForMmTelAndRcs();
        assertTrue(sServiceConnector.triggerFrameworkConnectionToCarrierImsService(c));
        verifyImsServiceState(c);

        Boolean result = callUntilImsServiceIsAvailable(() ->
                ShellIdentityUtils.invokeThrowableMethodWithShellPermissions(
                        getSipDelegateManager(), SipDelegateManager::isSupported,
                        ImsException.class, ""android.permission.PERFORM_IMS_SINGLE_REGISTRATION""));
        assertNotNull(result);
        assertFalse(""isSupported should return false in the case that SipTransport is not ""
                + ""set as capable in ImsService#getImsServiceCapabilities"", result);
    }"	""	""	"RCS MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.SipDelegateManagerTest"	"testIncomingInviteDeregistering"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/SipDelegateManagerTest.java"	""	"public void testIncomingInviteDeregistering() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        TransportInterfaces ifaces = new TransportInterfaces(getDefaultRequest(),
                Collections.emptySet(), 0);
        ifaces.connect();
        // move chat to deregistering
        Set<String> regFeatures = new ArraySet<>(Arrays.asList(DEFAULT_FEATURE_TAGS));
        regFeatures.remove(ONE_TO_ONE_CHAT_TAG);
        DelegateRegistrationState state = getDeregisteringState(regFeatures,
                Collections.singleton(ONE_TO_ONE_CHAT_TAG),
                DelegateRegistrationState.DEREGISTERING_REASON_PROVISIONING_CHANGE);
        verifyRegistrationState(ifaces, state);
        // receive invite, which can not be blocked
        SipDialogAttributes attr = new SipDialogAttributes();
        receiveChatInvite(attr, ifaces);
        // ensure delegate connection can still respond to the request, even if in restricted state.
        send200OkResponse(attr, ifaces);
        receiveAck(attr, ifaces);
        // receive BYE and clean up
        receiveByeRequest(attr, ifaces);
        ifaces.delegateConn.sendCleanupSession(attr.callId);
        ifaces.delegate.verifyCleanupSession(attr.callId);

        destroySipDelegateAndVerify(ifaces);
        assertEquals(""There should be no more delegates"", 0,
                ifaces.transport.getDelegates().size());
        verifyUpdateRegistrationCalled(ifaces.reg);
    }

    private SipMessage generateSipMessage(String str) {
        String crlf = ""\r\n"";
        String[] components = str.split(crlf);
        String startLine = """";
        String header = """";
        String content = """";
        StringBuilder sb = new StringBuilder();
        int idx = 1;
        if (components.length > 0) {
            startLine = components[0] + crlf;
        }
        // generate sip header
        idx = composeSipSection(idx, components, sb);
        header = sb.toString();

        idx++;
        sb.setLength(0);
        // generate sip body
        idx = composeSipSection(idx, components, sb);
        content = sb.toString();

        return new SipMessage(startLine, header, content.getBytes(UTF_8));
    }

    private int composeSipSection(int index, String[] components, StringBuilder sb) {
        String crlf = ""\r\n"";
        while (index < components.length) {
            if (components[index].length() > 0) {
                sb.append(components[index]).append(crlf);
                index++;
            } else {
                break;
            }
        }
        return index;
    }

    private void sendChatInvite(SipDialogAttributes attr,
            TransportInterfaces ifaces) throws Exception {
        SipDialogAttributes invAttr = attr.fromExisting().copyWithNewBranch();
        invAttr.addAcceptContactTag(ONE_TO_ONE_CHAT_TAG);
        SipMessage invite = SipMessageUtils.generateSipRequest(SipMessageUtils.INVITE_SIP_METHOD,
                invAttr);
        sendMessageAndVerifyAck(invite, ifaces);
    }

    private void sendDeniedChatInvite(SipDialogAttributes attr,
            TransportInterfaces ifaces, int denyReason) throws Exception {
        SipDialogAttributes invAttr = attr.fromExisting().copyWithNewBranch();
        SipMessage invite = SipMessageUtils.generateSipRequest(SipMessageUtils.INVITE_SIP_METHOD,
                invAttr);
        ifaces.delegateConn.sendMessageAndVerifyFailure(invite, denyReason);
    }

    private void receiveChatInvite(SipDialogAttributes attr,
            TransportInterfaces ifaces) throws Exception {
        SipDialogAttributes invAttr = attr.fromExisting().copyWithNewBranch();
        invAttr.addAcceptContactTag(ONE_TO_ONE_CHAT_TAG);
        SipMessage invite = SipMessageUtils.generateSipRequest(SipMessageUtils.INVITE_SIP_METHOD,
                invAttr);
        receiveMessageAndVerifyAck(invite, ifaces);
    }

    private void send200OkResponse(SipDialogAttributes attr,
            TransportInterfaces ifaces) throws Exception {
        attr.setToTag();
        // do not update branch here, as it is a response to a request.
        SipMessage resp = SipMessageUtils.generateSipResponse(""200"", ""OK"",
                attr);
        sendMessageAndVerifyAck(resp, ifaces);
    }

    private void receive200OkResponse(SipDialogAttributes attr,
            TransportInterfaces ifaces) throws Exception {
        attr.setToTag();
        // do not update branch here, as it is a response to a request.
        SipMessage resp = SipMessageUtils.generateSipResponse(""200"", ""OK"",
                attr);
        receiveMessageAndVerifyAck(resp, ifaces);
    }

    private void sendAck(SipDialogAttributes attr,
            TransportInterfaces ifaces) throws Exception {
        attr = attr.copyWithNewBranch();
        SipMessage invite = SipMessageUtils.generateSipRequest(SipMessageUtils.ACK_SIP_METHOD,
                attr);
        sendMessageAndVerifyAck(invite, ifaces);
    }

    private void receiveAck(SipDialogAttributes attr,
            TransportInterfaces ifaces) throws Exception {
        attr = attr.copyWithNewBranch();
        SipMessage invite = SipMessageUtils.generateSipRequest(SipMessageUtils.ACK_SIP_METHOD,
                attr);
        receiveMessageAndVerifyAck(invite, ifaces);
    }

    private void sendByeRequest(SipDialogAttributes attr,
            TransportInterfaces ifaces) throws Exception {
        attr = attr.copyWithNewBranch();
        SipMessage invite = SipMessageUtils.generateSipRequest(SipMessageUtils.BYE_SIP_METHOD,
                attr);
        sendMessageAndVerifyAck(invite, ifaces);
    }

    private void receiveByeRequest(SipDialogAttributes attr,
            TransportInterfaces ifaces) throws Exception {
        attr = attr.copyWithNewBranch();
        SipMessage invite = SipMessageUtils.generateSipRequest(SipMessageUtils.BYE_SIP_METHOD,
                attr);
        receiveMessageAndVerifyAck(invite, ifaces);
    }

    private void createSipDelegateConnectionNoDelegateExpected(SipDelegateManager manager,
            TestSipDelegateConnection conn, TestSipTransport transport) throws Exception {
        // wait for onCreated and reg state changed
        conn.setOperationCountDownLatch(2);
        conn.connect(manager);
        conn.waitForCountDown(ImsUtils.TEST_TIMEOUT_MS);
        conn.verifyDelegateCreated();
        conn.verifyRegistrationStateEmpty();
        // All requested features should have been denied due to the app not being the default sms
        // app.
        conn.verifyAllDenied(SipDelegateManager.DENIED_REASON_NOT_ALLOWED);
        // There should not have been a call to create a SipDelegate on the service side, since all
        // features were denied due to permissions issues.
        assertEquals(""SipDelegate should not have been created"", 0,
                transport.getDelegates().size());
    }

    private void destroySipDelegateConnectionNoDelegate(SipDelegateManager manager,
            TestSipDelegateConnection delegateConn) throws Exception {
        delegateConn.setOperationCountDownLatch(1);
        delegateConn.disconnect(manager,
                SipDelegateManager.SIP_DELEGATE_DESTROY_REASON_REQUESTED_BY_APP);
        delegateConn.waitForCountDown(ImsUtils.TEST_TIMEOUT_MS);
        delegateConn.verifyDestroyed(
                SipDelegateManager.SIP_DELEGATE_DESTROY_REASON_REQUESTED_BY_APP);
    }

    private void destroySipDelegate(SipDelegateManager manager,
            TestSipTransport transportImpl, TestSipDelegateConnection delegateConn,
            TestSipDelegate delegate) throws Exception {
        delegateConn.disconnect(manager,
                SipDelegateManager.SIP_DELEGATE_DESTROY_REASON_REQUESTED_BY_APP);
        transportImpl.waitForLatchCountdownAndReset(TestSipTransport.LATCH_DESTROY_DELEGATE);
        delegate.notifyOnDestroyed(
                SipDelegateManager.SIP_DELEGATE_DESTROY_REASON_REQUESTED_BY_APP);

    }

    private void destroySipDelegateAndVerifyConnDestroyed(SipDelegateManager manager,
            TestSipTransport transportImpl, TestSipDelegateConnection delegateConn,
            TestSipDelegate delegate) throws Exception {
        delegateConn.setOperationCountDownLatch(1);
        destroySipDelegate(manager, transportImpl, delegateConn, delegate);
        delegateConn.waitForCountDown(ImsUtils.TEST_TIMEOUT_MS);
        delegateConn.verifyDestroyed(
                SipDelegateManager.SIP_DELEGATE_DESTROY_REASON_REQUESTED_BY_APP);
    }

    private void destroySipDelegateAndVerify(TransportInterfaces ifaces) throws Exception {
        // wait for on destroyed
        destroySipDelegateAndVerifyConnDestroyed(ifaces.manager, ifaces.transport,
                ifaces.delegateConn, ifaces.delegate);
    }

    private void verifySipDelegateDestroyed(TestSipTransport transportImpl,
            TestSipDelegate delegate) {
        transportImpl.waitForLatchCountdownAndReset(TestSipTransport.LATCH_DESTROY_DELEGATE);
        delegate.notifyOnDestroyed(
                SipDelegateManager.SIP_DELEGATE_DESTROY_REASON_REQUESTED_BY_APP);
    }

    private TestSipDelegate createSipDelegateConnectionAndVerify(SipDelegateManager manager,
            TestSipDelegateConnection conn, TestSipTransport transport,
            Set<FeatureTagState>  deniedTags, int delegateIndex) throws Exception {
        conn.setOperationCountDownLatch(1);
        conn.connect(manager);
        TestSipDelegate d = getSipDelegate(transport, deniedTags, delegateIndex);
        conn.waitForCountDown(ImsUtils.TEST_TIMEOUT_MS);
        conn.verifyDelegateCreated();
        return d;
    }

    private TestSipDelegate getSipDelegate(TestSipTransport transport,
            Set<FeatureTagState> deniedTags, int delegateIndex) {
        transport.waitForLatchCountdownAndReset(TestSipTransport.LATCH_CREATE_DELEGATE);
        // There must have been a call to create a SipDelegate on the service side.
        assertEquals(""SipDelegate should have been created"", delegateIndex + 1,
                transport.getDelegates().size());
        TestSipDelegate d = transport.getDelegates().get(delegateIndex);
        d.notifyOnCreated(deniedTags);
        return d;
    }

    private void verifyRegisteredAndSendSipConfig(TestSipDelegateConnection delegateConn,
            TestSipDelegate delegate, Set<String> registeredTags,
            Set<FeatureTagState> deniedTags, SipDelegateConfiguration sipConfig) {
        // wait for reg change to be called
        delegateConn.setOperationCountDownLatch(1);
        DelegateRegistrationState s = getRegisteredRegistrationState(registeredTags);
        delegate.notifyImsRegistrationUpdate(s);
        delegateConn.waitForCountDown(ImsUtils.TEST_TIMEOUT_MS);
        delegateConn.verifyRegistrationStateRegistered(registeredTags);
        delegateConn.verifyDenied(deniedTags);

        // send config change as well.
        sendConfigChange(sipConfig, delegateConn, delegate);
    }

    private Set<FeatureTagState> generateDeniedSetFromRequest(Set<String> grantedTags,
            Set<String> newTags, int reason) {
        // Deny features from newTags that are already granted in grantedTags.
        return grantedTags.stream().filter(newTags::contains)
                .map(s -> new FeatureTagState(s, reason))
                .collect(Collectors.toSet());
    }

    private void verifyUpdateRegistrationCalled(TestImsRegistration regImpl) {
        regImpl.resetLatch(TestImsRegistration.LATCH_UPDATE_REGISTRATION, 1);
        // it is okay to reset and wait here (without race conditions) because there is a
        // second delay between triggering update registration and the latch being triggered.
        assertTrue(regImpl.waitForLatchCountDown(TestImsRegistration.LATCH_UPDATE_REGISTRATION,
                ImsUtils.TEST_TIMEOUT_MS));
    }

    private void sendRestrictedRequestsAndVerifyFailed(
            TestSipDelegateConnection delegateConn) throws Exception {
        delegateConn.sendMessageAndVerifyFailure(SipMessageUtils.TEST_INVALID_SIP_REGISTER,
                SipDelegateManager.MESSAGE_FAILURE_REASON_INVALID_START_LINE);
        delegateConn.sendMessageAndVerifyFailure(SipMessageUtils.TEST_INVALID_SIP_PUBLISH,
                SipDelegateManager.MESSAGE_FAILURE_REASON_INVALID_START_LINE);
        delegateConn.sendMessageAndVerifyFailure(SipMessageUtils.TEST_INVALID_SIP_OPTIONS,
                SipDelegateManager.MESSAGE_FAILURE_REASON_INVALID_START_LINE);
        delegateConn.sendMessageAndVerifyFailure(
                SipMessageUtils.TEST_INVALID_SIP_SUBSCRIBE_PRESENCE,
                SipDelegateManager.MESSAGE_FAILURE_REASON_INVALID_HEADER_FIELDS);
    }

    private void verifyFullRegistrationTriggered(TransportInterfaces ifaces) throws Exception {
        ifaces.delegateConn.verifyDelegateCreated();
        ifaces.delegateConn.triggerFullNetworkRegistration(ifaces.manager, 403, ""FORBIDDEN"");
        TestImsRegistration.NetworkRegistrationInfo info =
                ifaces.reg.getNextFullNetworkRegRequest(ImsUtils.TEST_TIMEOUT_MS);
        assertNotNull(""full registration requested, but ImsRegistrationImplBase ""
                + ""implementation did not receive a request."", info);
        assertEquals(403, info.sipCode);
        assertEquals(""FORBIDDEN"", info.sipReason);
    }

    private void sendInvalidRequestsAndVerifyFailed(
            TestSipDelegateConnection delegateConn) throws Exception {
        delegateConn.sendMessageAndVerifyFailure(SipMessageUtils.TEST_SIP_MESSAGE_INVALID_REQUEST,
                SipDelegateManager.MESSAGE_FAILURE_REASON_INVALID_START_LINE);
        delegateConn.sendMessageAndVerifyFailure(SipMessageUtils.TEST_SIP_MESSAGE_INVALID_RESPONSE,
                SipDelegateManager.MESSAGE_FAILURE_REASON_INVALID_START_LINE);
    }

    private void verifyOutgoingTransport(TestSipDelegateConnection delegateConn,
            TestSipDelegate delegate) throws Exception {
        // Send a message and ensure it gets received on the other end as well as acked
        delegateConn.sendMessageAndVerifyCompletedSuccessfully(SipMessageUtils.TEST_SIP_MESSAGE);
        delegate.verifyMessageSend(SipMessageUtils.TEST_SIP_MESSAGE);
        delegateConn.sendCleanupSession(SipMessageUtils.TEST_SIP_MESSAGE.getCallIdParameter());
        delegate.verifyCleanupSession(SipMessageUtils.TEST_SIP_MESSAGE.getCallIdParameter());
        // send a message and notify connection that it failed
        delegate.setSendMessageDenyReason(
                SipDelegateManager.MESSAGE_FAILURE_REASON_NETWORK_NOT_AVAILABLE);
        delegateConn.sendMessageAndVerifyFailure(SipMessageUtils.TEST_SIP_MESSAGE,
                SipDelegateManager.MESSAGE_FAILURE_REASON_NETWORK_NOT_AVAILABLE);
        delegate.verifyMessageSend(SipMessageUtils.TEST_SIP_MESSAGE);
    }

    private void sendMessageAndVerifyAck(SipMessage message,
            TransportInterfaces ifaces) throws Exception {
        // Send a message and ensure it gets received on the other end as well as acked
        ifaces.delegateConn.sendMessageAndVerifyCompletedSuccessfully(message);
    }

    private void verifyIncomingTransport(TestSipDelegateConnection delegateConn,
            TestSipDelegate delegate) throws Exception {
        // Receive a message and ensure it gets received on the other end as well as acked
        delegate.receiveMessageAndVerifyReceivedCalled(SipMessageUtils.TEST_SIP_MESSAGE);
        delegateConn.verifyMessageReceived(SipMessageUtils.TEST_SIP_MESSAGE);
        // Receive a message and have connection notify that it didn't complete
        delegateConn.setReceivedMessageErrorResponseReason(
                SipDelegateManager.MESSAGE_FAILURE_REASON_INVALID_BODY_CONTENT);
        delegate.receiveMessageAndVerifyReceiveErrorCalled(SipMessageUtils.TEST_SIP_MESSAGE,
                SipDelegateManager.MESSAGE_FAILURE_REASON_INVALID_BODY_CONTENT);
    }

    private void receiveMessageAndVerifyAck(SipMessage message,
            TransportInterfaces ifaces) throws Exception {
        // Receive a message and ensure it gets received on the other end as well as acked
        ifaces.delegate.receiveMessageAndVerifyReceivedCalled(message);
        ifaces.delegateConn.verifyMessageReceived(message);
    }

    private void verifyRegistrationState(TransportInterfaces ifaces,
            DelegateRegistrationState state) {
        ifaces.delegateConn.setOperationCountDownLatch(1);
        ifaces.delegate.notifyImsRegistrationUpdate(state);
        ifaces.delegateConn.waitForCountDown(ImsUtils.TEST_TIMEOUT_MS);
        ifaces.delegateConn.verifyRegistrationStateEquals(state);
    }

    private DelegateRegistrationState getDeregisteringState(Set<String> registered,
            Set<String> deregistering, int deregisteringReason) {
        DelegateRegistrationState.Builder b = new DelegateRegistrationState.Builder();
        b.addRegisteredFeatureTags(registered);
        for (String dereg : deregistering) {
            b.addDeregisteringFeatureTag(dereg, deregisteringReason);
        }
        return b.build();
    }

    private void sendConfigChange(SipDelegateConfiguration c,
            TestSipDelegateConnection delegateConn, TestSipDelegate delegate) {
        delegateConn.setOperationCountDownLatch(1);
        delegate.notifyConfigurationUpdate(c);
        delegateConn.waitForCountDown(ImsUtils.TEST_TIMEOUT_MS);
        delegateConn.verifyConfigEquals(c);
    }

    /**
     * @return A new test SipDelegateConfiguration that has all fields populated.1
     */
    private SipDelegateConfiguration generateNewTestConfig() {
        InetSocketAddress localAddr = new InetSocketAddress(
                InetAddresses.parseNumericAddress(""1.1.1.1""), 80);
        InetSocketAddress serverAddr = new InetSocketAddress(
                InetAddresses.parseNumericAddress(""2.2.2.2""), 81);
        SipDelegateConfiguration.Builder b = new SipDelegateConfiguration.Builder(1,
                SipDelegateConfiguration.SIP_TRANSPORT_TCP, localAddr, serverAddr);
        b.setSipCompactFormEnabled(true);
        b.setSipKeepaliveEnabled(true);
        b.setMaxUdpPayloadSizeBytes(508);
        b.setPublicUserIdentifier(""test1"");
        b.setPrivateUserIdentifier(""test2"");
        b.setHomeDomain(""test.domain"");
        b.setImei(""testImei"");
        b.setSipAuthenticationHeader(""sipauth"");
        b.setSipAuthenticationNonce(""sipnonce"");
        b.setSipServiceRouteHeader(""srvroute"");
        b.setSipPathHeader(""path"");
        b.setSipUserAgentHeader(""ua"");
        b.setSipContactUserParameter(""user"");
        b.setSipPaniHeader(""pani"");
        b.setSipPlaniHeader(""plani"");
        b.setSipCniHeader(""cni"");
        b.setSipAssociatedUriHeader(""uri"");
        Uri gruuUri = Uri.parse(""sip:blah@gruu.net"");
        b.setPublicGruuUri(gruuUri);
        SipDelegateConfiguration.IpSecConfiguration ipSecConfig =
                new SipDelegateConfiguration.IpSecConfiguration(123, 124,
                        125, 126, 127, 128, ""secverify"");
        assertEquals(123, ipSecConfig.getLocalTxPort());
        assertEquals(124, ipSecConfig.getLocalRxPort());
        assertEquals(125, ipSecConfig.getLastLocalTxPort());
        assertEquals(126, ipSecConfig.getRemoteTxPort());
        assertEquals(127, ipSecConfig.getRemoteRxPort());
        assertEquals(128, ipSecConfig.getLastRemoteTxPort());
        assertEquals(""secverify"", ipSecConfig.getSipSecurityVerifyHeader());
        b.setIpSecConfiguration(ipSecConfig);
        InetSocketAddress natAddr = new InetSocketAddress(
                InetAddresses.parseNumericAddress(""3.3.3.3""), 129);
        b.setNatSocketAddress(natAddr);
        assertEquals(""3.3.3.3"", natAddr.getAddress().getHostAddress());
        assertEquals(129, natAddr.getPort());
        return b.build();
    }

    private DelegateRegistrationState getRegisteredRegistrationState(Set<String> registered) {
        return new DelegateRegistrationState.Builder().addRegisteredFeatureTags(registered).build();
    }

    private DelegateRegistrationState getDeregisteringState(Set<String> deregisterTags,
            int reason) {
        DelegateRegistrationState.Builder b = new DelegateRegistrationState.Builder();
        for (String t : deregisterTags) {
            b.addDeregisteringFeatureTag(t, reason);
        }
        return b.build();
    }

    private void connectTestImsServiceWithSipTransportAndConfig() throws Exception {
        PersistableBundle b = new PersistableBundle();
        b.putBoolean(CarrierConfigManager.Ims.KEY_IMS_SINGLE_REGISTRATION_REQUIRED_BOOL, true);
        overrideCarrierConfig(b);

        assertTrue(sServiceConnector.connectCarrierImsServiceLocally());
        sServiceConnector.getCarrierService().addCapabilities(
                ImsService.CAPABILITY_SIP_DELEGATE_CREATION);
        sServiceConnector.getCarrierService().setSipTransportImplemented();
        ImsFeatureConfiguration c = getConfigForMmTelAndRcs();
        assertTrue(sServiceConnector.triggerFrameworkConnectionToCarrierImsService(c));
        verifyImsServiceState(c);
    }


    private void connectTestImsServiceWithSipTransport() throws Exception {
        assertTrue(sServiceConnector.connectCarrierImsServiceLocally());
        sServiceConnector.getCarrierService().addCapabilities(
                ImsService.CAPABILITY_SIP_DELEGATE_CREATION);
        sServiceConnector.getCarrierService().setSipTransportImplemented();
        ImsFeatureConfiguration c = getConfigForMmTelAndRcs();
        assertTrue(sServiceConnector.triggerFrameworkConnectionToCarrierImsService(c));
        verifyImsServiceState(c);
    }

    private void verifyImsServiceState(ImsFeatureConfiguration config) {
        for (ImsFeatureConfiguration.FeatureSlotPair p : config.getServiceFeatures()) {
            switch (p.featureType) {
                case ImsFeature.FEATURE_MMTEL: {
                    sServiceConnector.getCarrierService().waitForLatchCountdown(
                            TestImsService.LATCH_CREATE_MMTEL);
                    assertNotNull(""ImsService created, but ImsService#createMmTelFeature was not ""
                            + ""called!"", sServiceConnector.getCarrierService().getMmTelFeature());
                    break;
                }
                case ImsFeature.FEATURE_RCS: {
                    sServiceConnector.getCarrierService().waitForLatchCountdown(
                            TestImsService.LATCH_CREATE_RCS);
                    assertNotNull(""ImsService created, but ImsService#createRcsFeature was not ""
                            + ""called!"", sServiceConnector.getCarrierService().getRcsFeature());
                    break;
                }
            }
        }
    }

    /**
     * Wait up to five seconds (retrying a command 1 time per second) until ImsExceptions due to the
     * ImsService not being available go away. If the ImsService never becomes available, this
     * method will return null.
     */
    private <T> T callUntilImsServiceIsAvailable(Callable<T> command) throws Exception {
        int retry = 0;
        while (retry < 5) {
            try {
                return command.call();
            } catch (ImsException e) {
                // we want to absorb only the unavailable error, as telephony may still be
                // internally setting up. Any other type of ImsException is unexpected.
                if (e.getCode() != ImsException.CODE_ERROR_SERVICE_UNAVAILABLE) {
                    throw e;
                }
            }
            Thread.sleep(1000);
            retry++;
        }
        return null;
    }

    private DelegateRequest getDefaultRequest() {
        ArraySet<String> features = new ArraySet<>(Arrays.asList(DEFAULT_FEATURE_TAGS));
        return new DelegateRequest(features);
    }

    private DelegateRequest getChatOnlyRequest() {
        ArraySet<String> features = new ArraySet<>(3);
        features.add(ONE_TO_ONE_CHAT_TAG);
        features.add(GROUP_CHAT_TAG);
        return new DelegateRequest(features);
    }

    private ImsFeatureConfiguration getConfigForMmTelAndRcs() {
        return new ImsFeatureConfiguration.Builder()
                .addFeature(sTestSlot, ImsFeature.FEATURE_EMERGENCY_MMTEL)
                .addFeature(sTestSlot, ImsFeature.FEATURE_MMTEL)
                .addFeature(sTestSlot, ImsFeature.FEATURE_RCS)
                .build();
    }

    private ImsFeatureConfiguration getConfigForRcs() {
        return new ImsFeatureConfiguration.Builder()
                .addFeature(sTestSlot, ImsFeature.FEATURE_RCS)
                .build();
    }

    private Set<FeatureTagState> getDeniedTagsForReason(Set<String> deniedTags, int reason) {
        return deniedTags.stream().map(t -> new FeatureTagState(t, reason))
                .collect(Collectors.toSet());
    }

    private static void overrideCarrierConfig(PersistableBundle bundle) throws Exception {
        CarrierConfigManager carrierConfigManager = InstrumentationRegistry.getInstrumentation()
                .getContext().getSystemService(CarrierConfigManager.class);
        sReceiver.clearQueue();
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(carrierConfigManager,
                (m) -> m.overrideConfig(sTestSub, bundle));
        sReceiver.waitForCarrierConfigChanged();
    }

    private static void setFeatureTagsCarrierAllowed(String[] tags) throws Exception {
        PersistableBundle bundle = new PersistableBundle();
        bundle.putStringArray(CarrierConfigManager.Ims.KEY_RCS_FEATURE_TAG_ALLOWED_STRING_ARRAY,
                tags);
        overrideCarrierConfig(bundle);
    }

    private SipDelegateManager getSipDelegateManager() {
        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        assertNotNull(imsManager);
        return imsManager.getSipDelegateManager(sTestSub);
    }

    private static Context getContext() {
        return InstrumentationRegistry.getInstrumentation().getContext();
    }
}"	""	""	"RCS MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.SipDelegateManagerTest"	"testParcelUnparcelDelegateRequest"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/SipDelegateManagerTest.java"	""	"public void testParcelUnparcelDelegateRequest() {
        ArraySet<String> testTags = new ArraySet<>();
        testTags.add(MMTEL_TAG);
        testTags.add(ONE_TO_ONE_CHAT_TAG);
        testTags.add(GROUP_CHAT_TAG);
        testTags.add(FILE_TRANSFER_HTTP_TAG);
        DelegateRequest r = new DelegateRequest(testTags);
        Parcel p = Parcel.obtain();
        r.writeToParcel(p, 0);
        p.setDataPosition(0);
        DelegateRequest unparcelled = DelegateRequest.CREATOR.createFromParcel(p);
        assertEquals(r, unparcelled);
        assertEquals(r.getFeatureTags(), unparcelled.getFeatureTags());
    }"	""	""	"MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.SipDelegateManagerTest"	"testParcelUnparcelFeatureTagState"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/SipDelegateManagerTest.java"	""	"public void testParcelUnparcelFeatureTagState() {
        FeatureTagState f = new FeatureTagState(MMTEL_TAG,
                DelegateRegistrationState.DEREGISTERED_REASON_NOT_REGISTERED);
        Parcel p = Parcel.obtain();
        f.writeToParcel(p, 0);
        p.setDataPosition(0);
        FeatureTagState unparcelled = FeatureTagState.CREATOR.createFromParcel(p);
        assertEquals(f, unparcelled);
        assertEquals(f.getFeatureTag(), unparcelled.getFeatureTag());
        assertEquals(f.getState(), unparcelled.getState());
    }"	""	""	"MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.SipDelegateManagerTest"	"testParcelUnparcelRegistrationState"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/SipDelegateManagerTest.java"	""	"public void testParcelUnparcelRegistrationState() {
        ArraySet<String> regTags = new ArraySet<>();
        regTags.add(MMTEL_TAG);
        DelegateRegistrationState s = new DelegateRegistrationState.Builder()
                .addRegisteredFeatureTags(regTags)
                .addRegisteredFeatureTag(ONE_TO_ONE_CHAT_TAG)
                .addDeregisteringFeatureTag(GROUP_CHAT_TAG,
                        DelegateRegistrationState.DEREGISTERING_REASON_PDN_CHANGE)
                .addDeregisteredFeatureTag(FILE_TRANSFER_HTTP_TAG,
                        DelegateRegistrationState.DEREGISTERED_REASON_NOT_REGISTERED)
                .build();
        Parcel p = Parcel.obtain();
        s.writeToParcel(p, 0);
        p.setDataPosition(0);
        DelegateRegistrationState unparcel = DelegateRegistrationState.CREATOR.createFromParcel(p);
        assertEquals(s, unparcel);
        assertEquals(s.getRegisteredFeatureTags(), unparcel.getRegisteredFeatureTags());
        assertEquals(s.getDeregisteringFeatureTags(), unparcel.getDeregisteringFeatureTags());
        assertEquals(s.getDeregisteredFeatureTags(), unparcel.getDeregisteredFeatureTags());
    }"	""	""	"MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.SipDelegateManagerTest"	"testInviteAcceptContactNotAssociated"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/SipDelegateManagerTest.java"	""	"public void testInviteAcceptContactNotAssociated() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        TransportInterfaces ifaces = new TransportInterfaces(getDefaultRequest(),
                Collections.emptySet(), 0);
        ifaces.connect();
        // send a new invite over the MMTEL feature tag, which is not in the set of feature tags
        // associated with this delegate.
        SipDialogAttributes attr = new SipDialogAttributes();
        attr.addAcceptContactTag(MMTEL_TAG);
        sendDeniedChatInvite(attr, ifaces,
                SipDelegateManager.MESSAGE_FAILURE_REASON_INVALID_FEATURE_TAG);

        destroySipDelegateAndVerify(ifaces);
        assertEquals(""There should be no more delegates"", 0,
                ifaces.transport.getDelegates().size());
        verifyUpdateRegistrationCalled(ifaces.reg);
    }"	""	""	"MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.EabControllerTest"	"beforeAllTests"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/EabControllerTest.java"	""	"/*
 *.
 */

package android.telephony.ims.cts;

import static android.telephony.ims.RcsContactPresenceTuple.ServiceCapabilities.DUPLEX_MODE_RECEIVE_ONLY;
import static android.telephony.ims.RcsContactPresenceTuple.ServiceCapabilities.DUPLEX_MODE_SEND_ONLY;
import static android.telephony.ims.RcsContactPresenceTuple.TUPLE_BASIC_STATUS_OPEN;
import static android.telephony.ims.RcsContactUceCapability.REQUEST_RESULT_FOUND;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import android.app.UiAutomation;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.net.Uri;
import android.os.PersistableBundle;
import android.telecom.PhoneAccount;
import android.telephony.CarrierConfigManager;
import android.telephony.SubscriptionManager;
import android.telephony.TelephonyManager;
import android.telephony.cts.TelephonyUtils;
import android.telephony.ims.ImsException;
import android.telephony.ims.ImsManager;
import android.telephony.ims.ProvisioningManager;
import android.telephony.ims.RcsContactPresenceTuple;
import android.telephony.ims.RcsContactUceCapability;
import android.telephony.ims.RcsUceAdapter;
import android.telephony.ims.feature.ImsFeature;
import android.telephony.ims.stub.ImsFeatureConfiguration;
import android.util.Log;

import androidx.test.platform.app.InstrumentationRegistry;

import com.android.compatibility.common.util.ShellIdentityUtils;
import com.android.i18n.phonenumbers.NumberParseException;
import com.android.i18n.phonenumbers.PhoneNumberUtil;
import com.android.i18n.phonenumbers.Phonenumber;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;

import java.text.SimpleDateFormat;
import java.time.Instant;
import java.util.ArrayList;
import java.util.GregorianCalendar;
import java.util.List;
import java.util.Random;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;

public class EabControllerTest {

    private static final String TAG = ""EabControllerTest"";
    private static final String COMMAND_BASE = ""cmd phone "";
    private static final String COMMAND_GET_EAB_CONTACT = ""uce get-eab-capability "";

    private static int sTestSlot = SubscriptionManager.INVALID_SIM_SLOT_INDEX;
    private static int sTestSub = SubscriptionManager.INVALID_SUBSCRIPTION_ID;
    private static ImsServiceConnector sServiceConnector;
    private static CarrierConfigReceiver sReceiver;
    private static String sTestPhoneNumber;
    private static Uri sTestNumberUri;
    private static boolean sDeviceUceEnabled;

    private static final String TEST_SERVICE_DESCRIPTION = ""description_test1"";
    private static final int EXPIRATION_TIME_IN_SEC = 1;
    private static final int WAITING_IN_MILLI_SEC = 1000;
    private static final int POLLING_RETRY_TIMES = 3;

    BlockingQueue<Long> mErrorQueue = new LinkedBlockingQueue<>();
    BlockingQueue<Boolean> mCompleteQueue = new LinkedBlockingQueue<>();
    BlockingQueue<RcsContactUceCapability> mCapabilityQueue = new LinkedBlockingQueue<>();
    RcsUceAdapter.CapabilitiesCallback mCallback = new RcsUceAdapter.CapabilitiesCallback() {
        @Override
        public void onCapabilitiesReceived(List<RcsContactUceCapability> capabilities) {
            capabilities.forEach(c -> mCapabilityQueue.offer(c));
        }

        @Override
        public void onComplete() {
            mCompleteQueue.offer(true);
        }

        @Override
        public void onError(int errorCode, long retryAfterMilliseconds) {
            mErrorQueue.offer(new Long(errorCode));
            mErrorQueue.offer(retryAfterMilliseconds);
        }
    };

    private static class CarrierConfigReceiver extends BroadcastReceiver {
        private CountDownLatch mLatch = new CountDownLatch(1);
        private final int mSubId;

        CarrierConfigReceiver(int subId) {
            mSubId = subId;
        }

        @Override
        public void onReceive(Context context, Intent intent) {
            if (CarrierConfigManager.ACTION_CARRIER_CONFIG_CHANGED.equals(intent.getAction())) {
                int subId = intent.getIntExtra(CarrierConfigManager.EXTRA_SUBSCRIPTION_INDEX, -1);
                if (mSubId == subId) {
                    mLatch.countDown();
                }
            }
        }

        void clearQueue() {
            mLatch = new CountDownLatch(1);
        }

        void waitForCarrierConfigChanged() throws Exception {
            mLatch.await(5000, TimeUnit.MILLISECONDS);
        }
    }

    @BeforeClass
    public static void beforeAllTests() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }

        sTestPhoneNumber = generateRandomPhoneNumber();
        sTestNumberUri = Uri.fromParts(PhoneAccount.SCHEME_TEL, sTestPhoneNumber, null);

        sTestSub = ImsUtils.getPreferredActiveSubId();
        sTestSlot = SubscriptionManager.getSlotIndex(sTestSub);

        sServiceConnector = new ImsServiceConnector(InstrumentationRegistry.getInstrumentation());
        sServiceConnector.clearAllActiveImsServices(sTestSlot);
        sDeviceUceEnabled = sServiceConnector.getDeviceUceEnabled();
        sServiceConnector.setDeviceUceEnabled(true);

        sReceiver = new CarrierConfigReceiver(sTestSub);
        IntentFilter filter = new IntentFilter(CarrierConfigManager.ACTION_CARRIER_CONFIG_CHANGED);
        // ACTION_CARRIER_CONFIG_CHANGED is sticky, so we will get a callback right away.
        InstrumentationRegistry.getInstrumentation().getContext()
                .registerReceiver(sReceiver, filter);

        overrideCarrierConfig();

        connectTestImsService();
    }

    private static String generateRandomPhoneNumber() {
        Random random = new Random();
        StringBuilder builder = new StringBuilder();
        for (int i = 0; i < 10; i++) {
            builder.append(random.nextInt(10));
        }
        return builder.toString();
    }

    @AfterClass
    public static void afterAllTests() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        // Restore all ImsService configurations that existed before the test.
        if (sServiceConnector != null) {
            sServiceConnector.disconnectCarrierImsService();
            sServiceConnector.disconnectDeviceImsService();
            sServiceConnector.disconnectServices();
            sServiceConnector.setDeviceUceEnabled(sDeviceUceEnabled);
        }
        sServiceConnector = null;

        overrideCarrierConfig(null);

        if (sReceiver != null) {
            InstrumentationRegistry.getInstrumentation().getContext().unregisterReceiver(sReceiver);
            sReceiver = null;
        }
    }

    @Before
    public void beforeTest() {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        if (!SubscriptionManager.isValidSubscriptionId(sTestSub)) {
            fail(""This test requires that there is a SIM in the device!"");
        }
    }

    @After
    public void afterTest() {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        // Remove all the test contacts from EAB database
        removeTestContactFromEab();

        mErrorQueue.clear();
        mCompleteQueue.clear();
        mCapabilityQueue.clear();
    }"	""	""	"RCS"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.EabControllerTest"	"testRequestCapabilities"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/EabControllerTest.java"	""	"public void testRequestCapabilities() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        ArrayList<Uri> contacts = new ArrayList<>(1);
        contacts.add(sTestNumberUri);
        fakeNetworkResult(getPidfXmlData(
                sTestNumberUri,
                TEST_SERVICE_DESCRIPTION,
                TUPLE_BASIC_STATUS_OPEN,
                false,
                true,
                DUPLEX_MODE_RECEIVE_ONLY,
                DUPLEX_MODE_SEND_ONLY));
        // Request capabilities for saving capability to EAB provider
        requestCapabilities(contacts);
        mErrorQueue.clear();
        mCompleteQueue.clear();
        mCapabilityQueue.clear();

        // Request capabilities again to get the capabilities in EAB provider
        RcsContactUceCapability capability = requestCapabilities(contacts);

        // Verify that the capability in EAB is the same as expected
        verifyCapabilityResult(capability,
                sTestNumberUri,
                TEST_SERVICE_DESCRIPTION,
                TUPLE_BASIC_STATUS_OPEN,
                REQUEST_RESULT_FOUND,
                RcsContactUceCapability.SOURCE_TYPE_CACHED,
                false,
                true,
                DUPLEX_MODE_RECEIVE_ONLY,
                DUPLEX_MODE_SEND_ONLY);

        // Verify the onCompleted is called
        waitForResult(mCompleteQueue);
    }"	""	""	"RCS"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.EabControllerTest"	"testRequestAvailabilities"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/EabControllerTest.java"	""	"public void testRequestAvailabilities() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        fakeNetworkResult(getPidfXmlData(
                sTestNumberUri,
                TEST_SERVICE_DESCRIPTION,
                TUPLE_BASIC_STATUS_OPEN,
                false,
                true,
                DUPLEX_MODE_RECEIVE_ONLY,
                DUPLEX_MODE_SEND_ONLY));
        // Request capabilities for saving capability to EAB provider
        requestAvailability(sTestNumberUri);
        mErrorQueue.clear();
        mCompleteQueue.clear();
        mCapabilityQueue.clear();

        // Request capabilities again to get the capabilities in EAB provider
        RcsContactUceCapability capability = requestAvailability(sTestNumberUri);

        // Verify that the capability in EAB is the same as expected
        verifyCapabilityResult(capability,
                sTestNumberUri,
                TEST_SERVICE_DESCRIPTION,
                TUPLE_BASIC_STATUS_OPEN,
                REQUEST_RESULT_FOUND,
                RcsContactUceCapability.SOURCE_TYPE_CACHED,
                false,
                true,
                DUPLEX_MODE_RECEIVE_ONLY,
                DUPLEX_MODE_SEND_ONLY);

        // Verify the onCompleted is called
        waitForResult(mCompleteQueue);
    }"	""	""	"RCS"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.EabControllerTest"	"testRequestExpiredCapabilities"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/EabControllerTest.java"	""	"public void testRequestExpiredCapabilities() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }

        // Set capabilities expiration time
        setProvisioningIntValue(ProvisioningManager.KEY_RCS_CAPABILITIES_CACHE_EXPIRATION_SEC,
                EXPIRATION_TIME_IN_SEC);

        ArrayList<Uri> contacts = new ArrayList<>(1);
        contacts.add(sTestNumberUri);
        fakeNetworkResult(getPidfXmlData(
                sTestNumberUri,
                TEST_SERVICE_DESCRIPTION,
                TUPLE_BASIC_STATUS_OPEN,
                false,
                true,
                DUPLEX_MODE_RECEIVE_ONLY,
                DUPLEX_MODE_SEND_ONLY));
        // Request capabilities for saving expired capability to EAB provider
        requestCapabilities(contacts);
        mErrorQueue.clear();
        mCompleteQueue.clear();
        mCapabilityQueue.clear();

        waitingEabCapabilityExpire();

        // Request capabilities again
        RcsContactUceCapability capability = requestCapabilities(contacts);

        // Verify that return the availabilities from network instead of the EAB provider
        verifyCapabilityResult(capability,
                sTestNumberUri,
                TEST_SERVICE_DESCRIPTION,
                TUPLE_BASIC_STATUS_OPEN,
                REQUEST_RESULT_FOUND,
                RcsContactUceCapability.SOURCE_TYPE_NETWORK,
                false,
                true,
                DUPLEX_MODE_RECEIVE_ONLY,
                DUPLEX_MODE_SEND_ONLY);

        // Verify the onCompleted is called
        waitForResult(mCompleteQueue);
    }"	""	""	"RCS"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.EabControllerTest"	"testRequestExpiredAvailabilities"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/EabControllerTest.java"	""	"public void testRequestExpiredAvailabilities() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }

        // Set availability expiration time
        setProvisioningIntValue(ProvisioningManager.KEY_RCS_AVAILABILITY_CACHE_EXPIRATION_SEC,
                EXPIRATION_TIME_IN_SEC);

        fakeNetworkResult(getPidfXmlData(
                sTestNumberUri,
                TEST_SERVICE_DESCRIPTION,
                TUPLE_BASIC_STATUS_OPEN,
                true,
                false,
                DUPLEX_MODE_RECEIVE_ONLY,
                DUPLEX_MODE_SEND_ONLY));
        // Request availabilities for saving availabilities to EAB provider
        requestAvailability(sTestNumberUri);
        mErrorQueue.clear();
        mCompleteQueue.clear();
        mCapabilityQueue.clear();

        // Waiting availabilities expire
        waitingEabCapabilityExpire();

        // Request availabilities again
        RcsContactUceCapability capability = requestAvailability(sTestNumberUri);

        // Verify that return the availabilities from network instead of the EAB provider
        verifyCapabilityResult(capability,
                sTestNumberUri,
                TEST_SERVICE_DESCRIPTION,
                TUPLE_BASIC_STATUS_OPEN,
                REQUEST_RESULT_FOUND,
                RcsContactUceCapability.SOURCE_TYPE_NETWORK,
                true,
                false,
                DUPLEX_MODE_RECEIVE_ONLY,
                DUPLEX_MODE_SEND_ONLY);

        // Verify the onCompleted is called
        waitForResult(mCompleteQueue);
    }

    private RcsContactUceCapability requestAvailability(Uri contact) throws Exception {
        // Request capabilities by calling the API requestCapabilities.
        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        RcsUceAdapter uceAdapter = imsManager.getImsRcsManager(sTestSub).getUceAdapter();

        try {
            ShellIdentityUtils.invokeThrowableMethodWithShellPermissionsNoReturn(
                    uceAdapter,
                    adapter -> adapter.requestAvailability(contact, Runnable::run,
                            mCallback),
                    ImsException.class,
                    ""android.permission.ACCESS_RCS_USER_CAPABILITY_EXCHANGE"");
        } catch (SecurityException e) {
            fail(""requestCapabilities should succeed with ACCESS_RCS_USER_CAPABILITY_EXCHANGE.""
                 + e);
        } catch (ImsException e) {
            fail(""requestCapabilities failed "" + e);
        }

        // Verify that all the contact's capabilities are received
        return waitForResult(mCapabilityQueue);
    }

    private RcsContactUceCapability requestCapabilities(List<Uri> contact) throws Exception {
        // Request capabilities by calling the API requestCapabilities.
        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        RcsUceAdapter uceAdapter = imsManager.getImsRcsManager(sTestSub).getUceAdapter();

        try {
            ShellIdentityUtils.invokeThrowableMethodWithShellPermissionsNoReturn(
                    uceAdapter,
                    adapter -> adapter.requestCapabilities(contact, Runnable::run, mCallback),
                    ImsException.class,
                    ""android.permission.ACCESS_RCS_USER_CAPABILITY_EXCHANGE"");
        } catch (SecurityException e) {
            fail(""requestCapabilities should succeed with ACCESS_RCS_USER_CAPABILITY_EXCHANGE.""
                 + e);
        } catch (ImsException e) {
            fail(""requestCapabilities failed "" + e);
        }

        // Verify that all the contact's capabilities are received
        return waitForResult(mCapabilityQueue);
    }

    private static void overrideCarrierConfig() throws Exception {
        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        RcsUceAdapter uceAdapter = imsManager.getImsRcsManager(sTestSub).getUceAdapter();
        assertNotNull(""UCE adapter should not be null!"", uceAdapter);


        // Trigger carrier config changed
        PersistableBundle bundle = new PersistableBundle();
        bundle.putBoolean(CarrierConfigManager.Ims.KEY_ENABLE_PRESENCE_PUBLISH_BOOL, true);
        bundle.putBoolean(CarrierConfigManager.Ims.KEY_ENABLE_PRESENCE_CAPABILITY_EXCHANGE_BOOL,
                true);
        overrideCarrierConfig(bundle);
    }

    private void fakeNetworkResult(String pidfXml) {
        TestRcsCapabilityExchangeImpl capabilityExchangeImpl = sServiceConnector
                .getCarrierService().getRcsFeature().getRcsCapabilityExchangeImpl();

        ArrayList<String> pidfXmlList = new ArrayList<>(1);
        pidfXmlList.add(pidfXml);

        // Setup the network response is 200 OK and notify capabilities update
        int networkRespCode = 200;
        String networkRespReason = ""OK"";
        capabilityExchangeImpl.setSubscribeOperation((uris, cb) -> {
            cb.onNetworkResponse(networkRespCode, networkRespReason);
            cb.onNotifyCapabilitiesUpdate(pidfXmlList);
            cb.onTerminated("""", 0L);
        });
    }

    private String getPidfXmlData(Uri contact,
            String serviceDescription,
            String serviceStatus,
            boolean audioSupported,
            boolean videoSupported,
            String supportedDuplexMode,
            String unSupportedDuplexMode) {
        GregorianCalendar date = new GregorianCalendar();
        String timeStamp = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ssXXX"")
                .format(date.getTime());

        String pidfBuilder = ""<?xml version='1.0' encoding='utf-8' standalone='yes' ?>""
                + ""<presence entity=\"""" + contact + ""\""""
                + "" xmlns=\""urn:ietf:params:xml:ns:pidf\""""
                + "" xmlns:op=\""urn:oma:xml:prs:pidf:oma-pres\""""
                + "" xmlns:caps=\""urn:ietf:params:xml:ns:pidf:caps\"">""
                + ""<tuple id=\""tid0\"">""
                // status
                + ""<status><basic>"" + serviceStatus + ""</basic></status>""
                // timestamp
                + ""<timestamp>"" + timeStamp + ""</timestamp>""

                // service description
                + ""<op:service-description>""
                + ""<op:service-id>service_id_01</op:service-id>""
                + ""<op:version>1.0</op:version>""
                + ""<op:description>"" + serviceDescription + ""</op:description>""
                + ""</op:service-description>""

                // service capabilities
                + ""<caps:servcaps>""
                // audio capabilities
                + ""<caps:audio>"" + audioSupported + ""</caps:audio>""
                // video capabilities
                + ""<caps:video>"" + videoSupported + ""</caps:video>""

                // duplex mode
                + ""<caps:duplex>""
                // support duplex mode
                + ""<caps:supported>""
                + ""<caps:"" + supportedDuplexMode + ""/>""
                + ""</caps:supported>""

                // unsupported duplex mode
                + ""<caps:notsupported>""
                + ""<caps:"" + unSupportedDuplexMode + ""/>""
                + ""</caps:notsupported>""
                + ""</caps:duplex>""
                + ""</caps:servcaps>""
                + ""<contact>"" + contact + ""</contact>""
                + ""</tuple>""
                + ""</presence>"";
        return pidfBuilder;
    }

    private void verifyCapabilityResult(RcsContactUceCapability resultCapability,
            Uri expectedUri,
            String serviceDescription,
            String serviceStatus,
            int expectedResult,
            int expectedSourceType,
            boolean expectedAudioSupported,
            boolean expectedVideoSupported,
            String expectedSupportedDuplexMode,
            String expectedUnSupportedDuplexMode) {
        // Verify the contact URI
        assertEquals(expectedUri, resultCapability.getContactUri());

        // Verify the source type is the network type.
        assertEquals(expectedSourceType, resultCapability.getSourceType());

        // Verify the request result is expected.
        final int requestResult = resultCapability.getRequestResult();
        assertEquals(requestResult, expectedResult);

        // Verify the mechanism is presence
        assertEquals(RcsContactUceCapability.CAPABILITY_MECHANISM_PRESENCE,
                resultCapability.getCapabilityMechanism());

        RcsContactPresenceTuple presenceTuple =
                resultCapability.getCapabilityTuple(""service_id_01"");
        assertNotNull(""Contact Presence tuple should not be null!"", presenceTuple);

        RcsContactPresenceTuple.ServiceCapabilities capabilities =
                presenceTuple.getServiceCapabilities();
        assertNotNull(""Service capabilities should not be null!"", capabilities);

        // Verify timestamp
        assertNotNull(""Timestamp should not be null!"", presenceTuple.getTime());

        // Verify service id
        assertEquals(""service_id_01"", presenceTuple.getServiceId());

        // Verify service status
        assertEquals(serviceStatus, presenceTuple.getStatus());

        // Verify service description
        assertEquals(serviceDescription, presenceTuple.getServiceDescription());

        // Verify audio
        assertEquals(expectedAudioSupported, capabilities.isAudioCapable());

        // Verify video
        assertEquals(expectedVideoSupported, capabilities.isVideoCapable());

        // Verify Supported Duplex Mode
        assertEquals(expectedSupportedDuplexMode, capabilities.getSupportedDuplexModes().get(0));

        // Verify UnSupported Duplex Mode
        assertEquals(expectedUnSupportedDuplexMode,
                capabilities.getUnsupportedDuplexModes().get(0));
    }

    private <T> T waitForResult(BlockingQueue<T> queue) throws Exception {
        return queue.poll(ImsUtils.TEST_TIMEOUT_MS, TimeUnit.MILLISECONDS);
    }

    private static Context getContext() {
        return InstrumentationRegistry.getInstrumentation().getContext();
    }

    private static void connectTestImsService() throws Exception {
        assertTrue(sServiceConnector.connectCarrierImsService(new ImsFeatureConfiguration.Builder()
                .addFeature(sTestSlot, ImsFeature.FEATURE_RCS)
                .addFeature(sTestSlot, ImsFeature.FEATURE_MMTEL)
                .build()));

        // The RcsFeature is created when the ImsService is bound. If it wasn't created, then the
        // Framework did not call it.
        assertTrue(""Did not receive createRcsFeature"", sServiceConnector.getCarrierService()
                .waitForLatchCountdown(TestImsService.LATCH_CREATE_RCS));
        assertTrue(""Did not receive RcsFeature#onReady"", sServiceConnector.getCarrierService()
                .waitForLatchCountdown(TestImsService.LATCH_RCS_READY));
        // Make sure the RcsFeature was created in the test service.
        assertNotNull(""Device ImsService created, but TestDeviceImsService#createRcsFeature was not""
                + ""called!"", sServiceConnector.getCarrierService().getRcsFeature());
        assertTrue(""Did not receive RcsFeature#setCapabilityExchangeEventListener"",
                sServiceConnector.getCarrierService().waitForLatchCountdown(
                        TestImsService.LATCH_UCE_LISTENER_SET));
        int serviceSlot = sServiceConnector.getCarrierService().getRcsFeature().getSlotIndex();
        assertEquals(""The slot specified for the test ("" + sTestSlot + "") does not match the ""
                        + ""assigned slot ("" + serviceSlot + ""+ for the associated RcsFeature"",
                sTestSlot, serviceSlot);
    }

    private static void overrideCarrierConfig(PersistableBundle bundle) throws Exception {
        CarrierConfigManager carrierConfigManager = InstrumentationRegistry.getInstrumentation()
                .getContext().getSystemService(CarrierConfigManager.class);
        sReceiver.clearQueue();
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(carrierConfigManager,
                (m) -> m.overrideConfig(sTestSub, bundle));
        sReceiver.waitForCarrierConfigChanged();
    }

    private static void removeTestContactFromEab() {
        try {
            sServiceConnector.removeEabContacts(sTestSlot, sTestPhoneNumber);
        } catch (Exception e) {
            Log.w(""RcsUceAdapterTest"", ""Cannot remove test contacts from eab database: "" + e);
        }
    }

    private static String formatNumber(Context context, String number) {
        TelephonyManager manager = context.getSystemService(TelephonyManager.class);
        String simCountryIso = manager.getSimCountryIso();
        if (simCountryIso != null) {
            simCountryIso = simCountryIso.toUpperCase();
            PhoneNumberUtil util = PhoneNumberUtil.getInstance();
            try {
                Phonenumber.PhoneNumber phoneNumber = util.parse(number, simCountryIso);
                return util.format(phoneNumber, PhoneNumberUtil.PhoneNumberFormat.E164);
            } catch (NumberParseException e) {
                Log.w(TAG, ""formatNumber: could not format "" + number + "", error: "" + e);
            }
        }
        return number;
    }

    private String getEabCapabilities(String phoneNum) throws Exception {
        StringBuilder cmdBuilder = new StringBuilder();
        cmdBuilder.append(COMMAND_BASE).append(COMMAND_GET_EAB_CONTACT)
                .append("" "").append(phoneNum);
        return TelephonyUtils.executeShellCommand(InstrumentationRegistry.getInstrumentation(),
                cmdBuilder.toString());
    }

    private void setProvisioningIntValue(int key, int value) {
        final UiAutomation automan = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            automan.adoptShellPermissionIdentity();
            ProvisioningManager provisioningManager =
                    ProvisioningManager.createForSubscriptionId(sTestSub);
            provisioningManager.setProvisioningIntValue(key, value);
        } finally {
            automan.dropShellPermissionIdentity();
        }
    }

    private void waitingEabCapabilityExpire() throws Exception {
        int retryTimes = POLLING_RETRY_TIMES;
        long expirationTime;
        do {
            String capabilities = getEabCapabilities(formatNumber(getContext(), sTestPhoneNumber));
            String[] capabilityInfo = capabilities.split("","");
            assertTrue(capabilityInfo.length > 4);
            Thread.sleep(WAITING_IN_MILLI_SEC);
            expirationTime = Long.parseLong(capabilityInfo[2]);
            retryTimes--;
        } while (retryTimes > 0 && Instant.now().getEpochSecond() < expirationTime);
    }
}"	""	""	"RCS MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.hdmicec.cts.tv.HdmiCecAudioReturnChannelControlTest"	"isTrue"	"CtsHdmiCecHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/hdmicec/src/android/hdmicec/cts/tv/HdmiCecAudioReturnChannelControlTest.java"	""	"public void cect_11_1_17_3_DutSendsRequestArcTermination() throws Exception {
        // Ensure that ARC is on.
        changeArcState(true);
        hdmiCecClient.broadcastReportPhysicalAddress(LogicalAddress.AUDIO_SYSTEM);
        assertWithMessage(""DUT does not send a <Request ARC Termination> message."")
                .that(changeArcState(false))
                .isTrue();
    }

    /**
     * Test 11.1.17-2,4
     *
     * <p>Tests that the DUT responds with a directly addressed {@code <Report ARC terminated>}
     * message to the Audio System when ARC is terminated.
     */
    @Ignore(""b/174813656"")"	""	""	"RCS RCS"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.cts.PhoneStateListenerTest"	"testOnBarringInfoChanged"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/PhoneStateListenerTest.java"	""	"public void testOnBarringInfoChanged() throws Throwable {
        if (mCm.getNetworkInfo(ConnectivityManager.TYPE_MOBILE) == null) {
            Log.d(TAG, ""Skipping test that requires ConnectivityManager.TYPE_MOBILE"");
            return;
        }

        assertFalse(mOnBarringInfoChangedCalled);
        mHandler.post(() -> {
            mListener = new PhoneStateListener() {
                @Override
                public void onBarringInfoChanged(BarringInfo barringInfo) {
                    synchronized (mLock) {
                        mOnBarringInfoChangedCalled = true;
                        mBarringInfo = barringInfo;
                        mLock.notify();
                    }
                }
            };
            ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mTelephonyManager,
                    (tm) -> tm.listen(mListener, PhoneStateListener.LISTEN_BARRING_INFO));
        });

        synchronized (mLock) {
            if (!mOnBarringInfoChangedCalled) {
                mLock.wait(WAIT_TIME);
            }
        }
        assertTrue(mOnBarringInfoChangedCalled);

        assertBarringInfoSane(mBarringInfo);
    }

    private static final int[] sBarringServiceInfoTypes = new int[]{
            BarringInfo.BARRING_SERVICE_TYPE_CS_SERVICE,
            BarringInfo.BARRING_SERVICE_TYPE_PS_SERVICE,
            BarringInfo.BARRING_SERVICE_TYPE_CS_VOICE,
            BarringInfo.BARRING_SERVICE_TYPE_MO_SIGNALLING,
            BarringInfo.BARRING_SERVICE_TYPE_MO_DATA,
            BarringInfo.BARRING_SERVICE_TYPE_CS_FALLBACK,
            BarringInfo.BARRING_SERVICE_TYPE_MMTEL_VOICE,
            BarringInfo.BARRING_SERVICE_TYPE_MMTEL_VIDEO,
            BarringInfo.BARRING_SERVICE_TYPE_EMERGENCY,
            BarringInfo.BARRING_SERVICE_TYPE_SMS
    };

    private static void assertBarringInfoSane(BarringInfo barringInfo) {
        assertNotNull(barringInfo);

        // Flags to track whether we have had unknown and known barring types reported
        boolean hasBarringTypeUnknown = false;
        boolean hasBarringTypeKnown = false;

        for (int bsiType : sBarringServiceInfoTypes) {
            BarringInfo.BarringServiceInfo bsi = barringInfo.getBarringServiceInfo(bsiType);
            assertNotNull(bsi);
            switch (bsi.getBarringType()) {
                case BarringInfo.BarringServiceInfo.BARRING_TYPE_UNKNOWN:
                    hasBarringTypeUnknown = true;
                    assertFalse(bsi.isConditionallyBarred());
                    assertEquals(0, bsi.getConditionalBarringFactor());
                    assertEquals(0, bsi.getConditionalBarringTimeSeconds());
                    assertFalse(bsi.isBarred());
                    break;

                case BarringInfo.BarringServiceInfo.BARRING_TYPE_NONE:
                    hasBarringTypeKnown = true;
                    // Unless conditional barring is active, all conditional barring fields
                    // should be ""unset"".
                    assertFalse(bsi.isConditionallyBarred());
                    assertEquals(0, bsi.getConditionalBarringFactor());
                    assertEquals(0, bsi.getConditionalBarringTimeSeconds());
                    assertFalse(bsi.isBarred());
                    break;

                case BarringInfo.BarringServiceInfo.BARRING_TYPE_UNCONDITIONAL:
                    hasBarringTypeKnown = true;
                    // Unless conditional barring is active, all conditional barring fields
                    // should be ""unset"".
                    assertFalse(bsi.isConditionallyBarred());
                    assertEquals(0, bsi.getConditionalBarringFactor());
                    assertEquals(0, bsi.getConditionalBarringTimeSeconds());
                    assertTrue(bsi.isBarred());
                    break;

                case BarringInfo.BarringServiceInfo.BARRING_TYPE_CONDITIONAL:
                    hasBarringTypeKnown = true;
                    // If conditional barring is active, then the barring time and factor must
                    // be known (set), but the device may or may not be barred at the moment,
                    // so isConditionallyBarred() can be either true or false (hence not checked).
                    assertNotEquals(0, bsi.getConditionalBarringFactor());
                    assertNotEquals(0, bsi.getConditionalBarringTimeSeconds());
                    assertEquals(bsi.isBarred(), bsi.isConditionallyBarred());
                    break;
            }
        }
        // If any barring type is unknown, then barring is not supported so all must be
        // unknown. If any type is known, then all that are not reported are assumed to
        // be not barred.
        assertNotEquals(hasBarringTypeUnknown, hasBarringTypeKnown);
    }"	""	""	"MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.ImsServiceTest"	"beforeAllTests"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	"/*
 *.
 */

package android.telephony.ims.cts;

import static junit.framework.Assert.assertFalse;
import static junit.framework.Assert.assertNotNull;
import static junit.framework.Assert.assertNull;
import static junit.framework.Assert.assertTrue;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotEquals;
import static org.junit.Assert.fail;

import android.app.Activity;
import android.app.UiAutomation;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.net.Uri;
import android.os.PersistableBundle;
import android.telecom.PhoneAccount;
import android.telephony.AccessNetworkConstants;
import android.telephony.CarrierConfigManager;
import android.telephony.SmsManager;
import android.telephony.SmsMessage;
import android.telephony.SubscriptionManager;
import android.telephony.TelephonyManager;
import android.telephony.cts.AsyncSmsMessageListener;
import android.telephony.cts.SmsReceiverHelper;
import android.telephony.ims.ImsException;
import android.telephony.ims.ImsManager;
import android.telephony.ims.ImsMmTelManager;
import android.telephony.ims.ImsRcsManager;
import android.telephony.ims.ImsReasonInfo;
import android.telephony.ims.ImsRegistrationAttributes;
import android.telephony.ims.ImsStateCallback;
import android.telephony.ims.ProvisioningManager;
import android.telephony.ims.RcsClientConfiguration;
import android.telephony.ims.RcsContactUceCapability;
import android.telephony.ims.RcsUceAdapter;
import android.telephony.ims.RegistrationManager;
import android.telephony.ims.RtpHeaderExtensionType;
import android.telephony.ims.SipDelegateManager;
import android.telephony.ims.feature.ImsFeature;
import android.telephony.ims.feature.MmTelFeature;
import android.telephony.ims.feature.RcsFeature.RcsImsCapabilities;
import android.telephony.ims.stub.CapabilityExchangeEventListener;
import android.telephony.ims.stub.ImsConfigImplBase;
import android.telephony.ims.stub.ImsFeatureConfiguration;
import android.telephony.ims.stub.ImsRegistrationImplBase;
import android.util.ArraySet;
import android.util.Base64;
import android.util.Pair;

import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.platform.app.InstrumentationRegistry;

import com.android.compatibility.common.util.ShellIdentityUtils;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Assert;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Ignore;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Set;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;

/**
 * CTS tests for ImsService API.
 */
@RunWith(AndroidJUnit4.class)
public class ImsServiceTest {

    private static ImsServiceConnector sServiceConnector;

    private static final int RCS_CAP_NONE = RcsImsCapabilities.CAPABILITY_TYPE_NONE;
    private static final int RCS_CAP_OPTIONS = RcsImsCapabilities.CAPABILITY_TYPE_OPTIONS_UCE;
    private static final int RCS_CAP_PRESENCE = RcsImsCapabilities.CAPABILITY_TYPE_PRESENCE_UCE;

    private static final String MSG_CONTENTS = ""hi"";
    private static final String EXPECTED_RECEIVED_MESSAGE = ""foo5"";
    private static final String DEST_NUMBER = ""5555554567"";
    private static final String SRC_NUMBER = ""5555551234"";
    private static final byte[] EXPECTED_PDU =
            new byte[]{1, 0, 10, -127, 85, 85, 85, 33, 67, 0, 0, 2, -24, 52};
    private static final String RECEIVED_MESSAGE = ""B5EhYBMDIPgEC5FhBWKFkPEAAEGQQlGDUooE5ve7Bg=="";
    private static final byte[] STATUS_REPORT_PDU =
            hexStringToByteArray(""0006000681214365919061800000639190618000006300"");

    private static int sTestSlot = 0;
    private static int sTestSub = SubscriptionManager.INVALID_SUBSCRIPTION_ID;
    private static boolean sDeviceUceEnabled;

    private static final int TEST_CONFIG_KEY = 1000;
    private static final int TEST_CONFIG_VALUE_INT = 0xDEADBEEF;
    private static final String TEST_CONFIG_VALUE_STRING = ""DEADBEEF"";

    private static final String TEST_RCS_CONFIG_DEFAULT = ""<?xml version=\""1.0\""?>\n""
            + ""<wap-provisioningdoc version=\""1.1\"">\n""
            + ""\t<characteristic type=\""APPLICATION\"">\n""
            + ""\t\t<parm name=\""AppID\"" value=\""urn:oma:mo:ext-3gpp-ims:1.0\""/>\n""
            + ""\t\t<characteristic type=\""3GPP_IMS\"">\n""
            + ""\t\t\t<parm name=\""AppID\"" value=\""ap2001\""/>\n""
            + ""\t\t\t<parm name=\""Name\"" value=\""RCS IMS Settings\""/>\n""
            + ""\t\t\t<characteristic type=\""Ext\"">\n""
            + ""\t\t\t\t<characteristic type=\""GSMA\"">\n""
            + ""\t\t\t\t\t<parm name=\""AppRef\"" value=\""IMS-Setting\""/>\n""
            + ""\t\t\t\t\t<parm name=\""rcsVolteSingleRegistration\"" value=\""1\""/>\n""
            + ""\t\t\t\t</characteristic>\n""
            + ""\t\t\t</characteristic>\n""
            + ""\t\t</characteristic>\n""
            + ""\t\t<characteristic type=\""SERVICES\"">\n""
            + ""\t\t\t<parm name=\""SupportedRCSProfileVersions\"" value=\""UP2.3\""/>\n""
            + ""\t\t\t<parm name=\""ChatAuth\"" value=\""1\""/>\n""
            + ""\t\t\t<parm name=\""GroupChatAuth\"" value=\""1\""/>\n""
            + ""\t\t\t<parm name=\""ftAuth\"" value=\""1\""/>\n""
            + ""\t\t\t<parm name=\""standaloneMsgAuth\"" value=\""1\""/>\n""
            + ""\t\t\t<parm name=\""geolocPushAuth\"" value=\""1\""/>\n""
            + ""\t\t\t<characteristic type=\""Ext\"">\n""
            + ""\t\t\t\t<characteristic type=\""DataOff\"">\n""
            + ""\t\t\t\t\t<parm name=\""rcsMessagingDataOff\"" value=\""1\""/>\n""
            + ""\t\t\t\t\t<parm name=\""fileTransferDataOff\"" value=\""1\""/>\n""
            + ""\t\t\t\t\t<parm name=\""mmsDataOff\"" value=\""1\""/>\n""
            + ""\t\t\t\t\t<parm name=\""syncDataOff\"" value=\""1\""/>\n""
            + ""\t\t\t\t\t<characteristic type=\""Ext\""/>\n""
            + ""\t\t\t\t</characteristic>\n""
            + ""\t\t\t</characteristic>\n""
            + ""\t\t</characteristic>\n""
            + ""\t</characteristic>\n""
            + ""</wap-provisioningdoc>\n"";

    private static final String TEST_RCS_CONFIG_SINGLE_REGISTRATION_DISABLED =
            ""<?xml version=\""1.0\""?>\n""
            + ""<wap-provisioningdoc version=\""1.1\"">\n""
            + ""\t<characteristic type=\""APPLICATION\"">\n""
            + ""\t\t<parm name=\""AppID\"" value=\""urn:oma:mo:ext-3gpp-ims:1.0\""/>\n""
            + ""\t\t<characteristic type=\""3GPP_IMS\"">\n""
            + ""\t\t\t<parm name=\""AppID\"" value=\""ap2001\""/>\n""
            + ""\t\t\t<parm name=\""Name\"" value=\""RCS IMS Settings\""/>\n""
            + ""\t\t\t<characteristic type=\""Ext\"">\n""
            + ""\t\t\t\t<characteristic type=\""GSMA\"">\n""
            + ""\t\t\t\t\t<parm name=\""AppRef\"" value=\""IMS-Setting\""/>\n""
            + ""\t\t\t\t\t<parm name=\""rcsVolteSingleRegistration\"" value=\""0\""/>\n""
            + ""\t\t\t\t</characteristic>\n""
            + ""\t\t\t</characteristic>\n""
            + ""\t\t</characteristic>\n""
            + ""\t</characteristic>\n""
            + ""</wap-provisioningdoc>\n"";
    private static final String TEST_RCS_PRE_CONFIG = ""<RCSPreProvisiniongConfig>\n""
            + ""\t<VERS>\n""
            + ""\t\t<version>1</version>\n""
            + ""\t\t<validity>1728000</validity>\n""
            + ""\t</VERS>\n""
            + ""\t<TOKEN>\n""
            + ""\t\t<token>X</token>\n""
            + ""\t</TOKEN>\n""
            + ""\t<EXT>\n""
            + ""\t\t<url>https://rcs.mnc123.mcc456.pub.3gppnetwork.org</url>\n""
            + ""\t</EXT>\n""
            + ""</RCSPreProvisiniongConfig>"";
    private static final int RCS_CONFIG_CB_UNKNOWN = Integer.MAX_VALUE;
    private static final int RCS_CONFIG_CB_CHANGED = 0;
    private static final int RCS_CONFIG_CB_ERROR   = 1;
    private static final int RCS_CONFIG_CB_RESET   = 2;
    private static final int RCS_CONFIG_CB_DELETE  = 3;
    private static final int RCS_CONFIG_CB_PREPROV = 4;

    private static final String CHAT_FEATURE_TAG =
            ""+g.3gpp.icsi-ref=\""urn%3Aurn-7%3A3gpp-service.ims.icsi.oma.cpm.session\"""";
    public static final String FILE_TRANSFER_FEATURE_TAG =
            ""+g.3gpp.iari-ref=\""urn%3Aurn-7%3A3gpp-application.ims.iari.rcs.fthttp\"""";
    private static final String CHAT_SERVICE_ID =
            ""org.openmobilealliance:ChatSession"";
    private static final String FILE_TRANSFER_SERVICE_ID =
            ""org.openmobilealliance:File-Transfer-HTTP"";

    private static final int FEATURE_STATE_READY = 0;

    private static CarrierConfigReceiver sReceiver;
    private static SingleRegistrationCapabilityReceiver sSrcReceiver;

    private abstract static class BaseReceiver extends BroadcastReceiver {
        protected CountDownLatch mLatch = new CountDownLatch(1);

        void clearQueue() {
            mLatch = new CountDownLatch(1);
        }

        void waitForChanged() throws Exception {
            mLatch.await(5000, TimeUnit.MILLISECONDS);
        }
    }

    private static class CarrierConfigReceiver extends BaseReceiver {
        private final int mSubId;

        CarrierConfigReceiver(int subId) {
            mSubId = subId;
        }

        @Override
        public void onReceive(Context context, Intent intent) {
            if (CarrierConfigManager.ACTION_CARRIER_CONFIG_CHANGED.equals(intent.getAction())) {
                int subId = intent.getIntExtra(CarrierConfigManager.EXTRA_SUBSCRIPTION_INDEX, -1);
                if (mSubId == subId) {
                    mLatch.countDown();
                }
            }
        }
    }

    private static class SingleRegistrationCapabilityReceiver extends BaseReceiver {
        private int mCapability;

        @Override
        public void onReceive(Context context, Intent intent) {
            if (ProvisioningManager.ACTION_RCS_SINGLE_REGISTRATION_CAPABILITY_UPDATE
                    .equals(intent.getAction())) {
                mCapability = intent.getIntExtra(ProvisioningManager.EXTRA_STATUS,
                        ProvisioningManager.STATUS_DEVICE_NOT_CAPABLE
                        | ProvisioningManager.STATUS_CARRIER_NOT_CAPABLE);
                mLatch.countDown();
            }
        }

        int getCapability() {
            return mCapability;
        }
    }

    private static class RcsProvisioningCallbackParams {
        byte[] mConfig;
        Integer mErrorCode;
        String mErrorString;
    }

    @BeforeClass
    public static void beforeAllTests() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }

        TelephonyManager tm = (TelephonyManager) getContext()
                .getSystemService(Context.TELEPHONY_SERVICE);
        sTestSub = ImsUtils.getPreferredActiveSubId();
        sTestSlot = SubscriptionManager.getSlotIndex(sTestSub);
        if (tm.getSimState(sTestSlot) != TelephonyManager.SIM_STATE_READY) {
            return;
        }
        sServiceConnector = new ImsServiceConnector(InstrumentationRegistry.getInstrumentation());
        // Remove all live ImsServices until after these tests are done
        sServiceConnector.clearAllActiveImsServices(sTestSlot);
        // Configure SMS receiver based on the Android version.
        sServiceConnector.setDefaultSmsApp();

        // Save the original device uce enabled config and override it.
        sDeviceUceEnabled = sServiceConnector.getDeviceUceEnabled();
        sServiceConnector.setDeviceUceEnabled(true);

        sReceiver = new CarrierConfigReceiver(sTestSub);
        IntentFilter filter = new IntentFilter(CarrierConfigManager.ACTION_CARRIER_CONFIG_CHANGED);
        // ACTION_CARRIER_CONFIG_CHANGED is sticky, so we will get a callback right away.
        InstrumentationRegistry.getInstrumentation().getContext()
                .registerReceiver(sReceiver, filter);

        sSrcReceiver = new SingleRegistrationCapabilityReceiver();
        InstrumentationRegistry.getInstrumentation().getContext()
                .registerReceiver(sSrcReceiver, new IntentFilter(
                        ProvisioningManager.ACTION_RCS_SINGLE_REGISTRATION_CAPABILITY_UPDATE));
    }

    @AfterClass
    public static void afterAllTests() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        // Restore all ImsService configurations that existed before the test.
        if (sServiceConnector != null) {
            sServiceConnector.disconnectServices();
            sServiceConnector.setDeviceUceEnabled(sDeviceUceEnabled);
        }
        sServiceConnector = null;

        // Ensure there are no CarrierConfig overrides as well as reset the ImsResolver in case the
        // ImsService override changed in CarrierConfig while we were overriding it.
        overrideCarrierConfig(null);

        if (sReceiver != null) {
            InstrumentationRegistry.getInstrumentation().getContext().unregisterReceiver(sReceiver);
            sReceiver = null;
        }

        if (sSrcReceiver != null) {
            InstrumentationRegistry.getInstrumentation()
                    .getContext().unregisterReceiver(sSrcReceiver);
            sSrcReceiver = null;
        }
    }

    @Before
    public void beforeTest() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        TelephonyManager tm = (TelephonyManager) InstrumentationRegistry.getInstrumentation()
                .getContext().getSystemService(Context.TELEPHONY_SERVICE);
        if (tm.getSimState(sTestSlot) != TelephonyManager.SIM_STATE_READY) {
            fail(""This test requires that there is a SIM in the device!"");
        }
        // Correctness check: ensure that the subscription hasn't changed between tests.
        int[] subs = SubscriptionManager.getSubId(sTestSlot);

        if (subs == null) {
            fail(""This test requires there is an active subscription in slot "" + sTestSlot);
        }
        boolean isFound = false;
        for (int sub : subs) {
            isFound |= (sTestSub == sub);
        }
        if (!isFound) {
            fail(""Invalid state found: the test subscription in slot "" + sTestSlot + "" changed ""
                    + ""during this test."");
        }

        TestAcsClient.getInstance().reset();
        sServiceConnector.setSingleRegistrationTestModeEnabled(true);
    }

    @After
    public void afterTest() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        // Unbind the GTS ImsService after the test completes.
        if (sServiceConnector != null) {
            sServiceConnector.setSingleRegistrationTestModeEnabled(false);
            sServiceConnector.disconnectCarrierImsService();
            sServiceConnector.disconnectDeviceImsService();
        }
    }"	""	""	"RCS MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.ImsServiceTest"	"testCarrierImsServiceBindRcsFeature"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	"public void testCarrierImsServiceBindRcsFeature() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        // Connect to the ImsService with the RCS feature.
        assertTrue(sServiceConnector.connectCarrierImsService(new ImsFeatureConfiguration.Builder()
                .addFeature(sTestSlot, ImsFeature.FEATURE_RCS)
                .build()));
        // The RcsFeature is created when the ImsService is bound. If it wasn't created, then the
        // Framework did not call it.
        sServiceConnector.getCarrierService().waitForLatchCountdown(
                TestImsService.LATCH_CREATE_RCS);
        assertNotNull(""ImsService created, but ImsService#createRcsFeature was not called!"",
                sServiceConnector.getCarrierService().getRcsFeature());
    }"	""	""	"RCS"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.ImsServiceTest"	"testCarrierImsServiceBindRcsFeatureEnableDisableIms"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	"public void testCarrierImsServiceBindRcsFeatureEnableDisableIms() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        // Connect to the ImsService with the RCS feature.
        assertTrue(sServiceConnector.connectCarrierImsService(new ImsFeatureConfiguration.Builder()
                .addFeature(sTestSlot, ImsFeature.FEATURE_RCS)
                .build()));
        // The RcsFeature is created when the ImsService is bound. If it wasn't created, then the
        // Framework did not call it.
        assertTrue(sServiceConnector.getCarrierService().waitForLatchCountdown(
                TestImsService.LATCH_CREATE_RCS));

        //Enable IMS and ensure that we receive the call to enable IMS in the ImsService.
        sServiceConnector.enableImsService(sTestSlot);
        // Wait for command in ImsService
        assertTrue(sServiceConnector.getCarrierService().waitForLatchCountdown(
                TestImsService.LATCH_ENABLE_IMS));
        assertTrue(sServiceConnector.getCarrierService().isEnabled());

        //Disable IMS and ensure that we receive the call to enable IMS in the ImsService.
        sServiceConnector.disableImsService(sTestSlot);
        // Wait for command in ImsService
        assertTrue(sServiceConnector.getCarrierService().waitForLatchCountdown(
                TestImsService.LATCH_DISABLE_IMS));
        assertFalse(sServiceConnector.getCarrierService().isEnabled());
    }"	""	""	"RCS"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	Test Available	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.ImsServiceTest"	"testCarrierImsServiceBindRcsChangeToMmtel"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	"public void testCarrierImsServiceBindRcsChangeToMmtel() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        // Connect to the ImsService with the RCS feature.
        assertTrue(sServiceConnector.connectCarrierImsService(new ImsFeatureConfiguration.Builder()
                .addFeature(sTestSlot, ImsFeature.FEATURE_RCS)
                .build()));
        // The RcsFeature is created when the ImsService is bound. If it wasn't created, then the
        // Framework did not call it.
        assertTrue(sServiceConnector.getCarrierService().waitForLatchCountdown(
                TestImsService.LATCH_CREATE_RCS));

        // Change the supported feature to MMTEl
        sServiceConnector.getCarrierService().getImsService().onUpdateSupportedImsFeatures(
                new ImsFeatureConfiguration.Builder()
                .addFeature(sTestSlot, ImsFeature.FEATURE_MMTEL).build());

        // createMmTelFeature should be called.
        assertTrue(sServiceConnector.getCarrierService().waitForLatchCountdown(
                TestImsService.LATCH_CREATE_MMTEL));

        // Wait for the framework to set the capabilities on the ImsService
        sServiceConnector.getCarrierService().waitForLatchCountdown(
                TestImsService.LATCH_MMTEL_CAP_SET);
    }"	""	""	"RCS MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.ImsServiceTest"	"testCarrierImsServiceBindNullRcsFeature"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	"public void testCarrierImsServiceBindNullRcsFeature() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        // Connect to the ImsService with the RCS feature.
        ImsFeatureConfiguration config = new ImsFeatureConfiguration.Builder()
                .addFeature(sTestSlot, ImsFeature.FEATURE_RCS)
                .build();
        assertTrue(sServiceConnector.connectCarrierImsServiceLocally());
        sServiceConnector.getCarrierService().resetState();
        sServiceConnector.getCarrierService().setNullRcsBinding();
        assertTrue(sServiceConnector.triggerFrameworkConnectionToCarrierImsService(config));

        // The RcsFeature is created when the ImsService is bound. If it wasn't created, then the
        // Framework did not call it.
        assertTrue(sServiceConnector.getCarrierService().waitForLatchCountdown(
                TestImsService.LATCH_CREATE_RCS));
        // Check to see if telephony state was reset at some point due to a crash and fail if so
        assertFalse(""ImsService should not crash if there is a null ImsFeature returned"",
                ImsUtils.retryUntilTrue(() ->
                        !sServiceConnector.isCarrierServiceStillConfigured(),
                5000 /*test timeout*/, 5 /*num times*/));
    }"	""	""	"RCS"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.ImsServiceTest"	"testDeviceImsServiceBindRcsFeature"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	"public void testDeviceImsServiceBindRcsFeature() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        // Connect to the ImsService with the RCS feature.
        assertTrue(sServiceConnector.connectDeviceImsService(new ImsFeatureConfiguration.Builder()
                .addFeature(sTestSlot, ImsFeature.FEATURE_RCS)
                .build()));
        // The RcsFeature is created when the ImsService is bound. If it wasn't created, then the
        // Framework did not call it.
        assertTrue(sServiceConnector.getExternalService().waitForLatchCountdown(
                TestImsService.LATCH_CREATE_RCS));
        // Make sure the RcsFeature was created in the test service.
        assertTrue(""Device ImsService created, but TestDeviceImsService#createRcsFeature was not""
                        + ""called!"", sServiceConnector.getExternalService().isRcsFeatureCreated());
    }"	""	""	"RCS"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.ImsServiceTest"	"testBindDeviceAndCarrierDifferentFeatures"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	"public void testBindDeviceAndCarrierDifferentFeatures() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        // Connect to Device the ImsService with the MMTEL/EMERGENCY_MMTEL feature.
        assertTrue(sServiceConnector.connectDeviceImsService(new ImsFeatureConfiguration.Builder()
                .addFeature(sTestSlot, ImsFeature.FEATURE_EMERGENCY_MMTEL)
                .addFeature(sTestSlot, ImsFeature.FEATURE_MMTEL)
                .build()));
        // Connect to Device the ImsService with the RCS feature.
        assertTrue(sServiceConnector.connectCarrierImsService(new ImsFeatureConfiguration.Builder()
                .addFeature(sTestSlot, ImsFeature.FEATURE_RCS)
                .build()));
        // The MmTelFeature is created when the ImsService is bound. If it wasn't created, then the
        // Framework did not call it.
        assertTrue(sServiceConnector.getExternalService().waitForLatchCountdown(
                TestImsService.LATCH_CREATE_MMTEL));
        // Make sure the MmTelFeature was created in the test service.
        assertTrue(""Device ImsService created, but TestDeviceImsService#createMmTelFeature was""
                + ""not called!"", sServiceConnector.getExternalService().isMmTelFeatureCreated());

        assertTrue(sServiceConnector.getCarrierService().waitForLatchCountdown(
                TestImsService.LATCH_CREATE_RCS));
        assertNotNull(""ImsService created, but ImsService#createRcsFeature was not called!"",
                sServiceConnector.getCarrierService().getRcsFeature());
    }"	""	""	"RCS MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.ImsServiceTest"	"testBindDeviceAndCarrierSameFeature"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	"public void testBindDeviceAndCarrierSameFeature() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        // Connect to Device the ImsService with the RCS feature.
        assertTrue(sServiceConnector.connectDeviceImsService(new ImsFeatureConfiguration.Builder()
                .addFeature(sTestSlot, ImsFeature.FEATURE_MMTEL)
                .build()));

        //First MMTEL feature is created on device ImsService.
        assertTrue(sServiceConnector.getExternalService().waitForLatchCountdown(
                TestImsService.LATCH_CREATE_MMTEL));
        assertTrue(""Device ImsService created, but TestDeviceImsService#createMmTelFeature was ""
                + ""not called!"", sServiceConnector.getExternalService().isMmTelFeatureCreated());

        // Connect to Device the ImsService with the MMTEL feature.
        assertTrue(sServiceConnector.connectCarrierImsService(new ImsFeatureConfiguration.Builder()
                .addFeature(sTestSlot, ImsFeature.FEATURE_MMTEL)
                .addFeature(sTestSlot, ImsFeature.FEATURE_EMERGENCY_MMTEL)
                .build()));

        // Next MMTEL feature is created on carrier ImsService (and unbound on device)
        assertTrue(sServiceConnector.getCarrierService().waitForLatchCountdown(
                TestImsService.LATCH_CREATE_MMTEL));
        assertNotNull(""ImsService created, but ImsService#createRcsFeature was not called!"",
                sServiceConnector.getCarrierService().getMmTelFeature());

        // Ensure that the MmTelFeature was removed on the device ImsService.
        assertTrue(sServiceConnector.getExternalService().waitForLatchCountdown(
                TestImsService.LATCH_REMOVE_MMTEL));
        assertFalse(""Device ImsService was never removed when carrier ImsService took MMTEL.""
                + ""feature."", sServiceConnector.getExternalService().isMmTelFeatureCreated());
    }"	""	""	"RCS MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.ImsServiceTest"	"testBindDeviceAndCarrierUpdateToSameFeature"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	"public void testBindDeviceAndCarrierUpdateToSameFeature() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        // Connect to Device the ImsService with the MMTEL feature.
        assertTrue(sServiceConnector.connectDeviceImsService(new ImsFeatureConfiguration.Builder()
                .addFeature(sTestSlot, ImsFeature.FEATURE_MMTEL)
                .build()));

        //First MMTEL feature is created on device ImsService.
        assertTrue(sServiceConnector.getExternalService().waitForLatchCountdown(
                TestImsService.LATCH_CREATE_MMTEL));
        assertTrue(""Device ImsService created, but TestDeviceImsService#createMmTelFeature was""
                + ""not called!"", sServiceConnector.getExternalService().isMmTelFeatureCreated());

        // Connect to Device the ImsService with the RCS feature.
        assertTrue(sServiceConnector.connectCarrierImsService(new ImsFeatureConfiguration.Builder()
                .addFeature(sTestSlot, ImsFeature.FEATURE_RCS)
                .build()));

        // Next Rcs feature is created on carrier ImsService
        assertTrue(sServiceConnector.getCarrierService().waitForLatchCountdown(
                TestImsService.LATCH_CREATE_RCS));
        assertNotNull(""ImsService created, but ImsService#createRcsFeature was not called!"",
                sServiceConnector.getCarrierService().getRcsFeature());

        // Change the supported feature to MMTEl
        sServiceConnector.getCarrierService().getImsService().onUpdateSupportedImsFeatures(
                new ImsFeatureConfiguration.Builder()
                        .addFeature(sTestSlot, ImsFeature.FEATURE_MMTEL)
                        .addFeature(sTestSlot, ImsFeature.FEATURE_EMERGENCY_MMTEL)
                        .build());

        // MMTEL feature is created on carrier ImsService
        assertTrue(sServiceConnector.getCarrierService().waitForLatchCountdown(
                TestImsService.LATCH_CREATE_MMTEL));
        assertNotNull(""ImsService created, but ImsService#createMmTelFeature was not called!"",
                sServiceConnector.getCarrierService().getMmTelFeature());

        // Ensure that the MmTelFeature was removed on the device ImsService.
        assertTrue(sServiceConnector.getExternalService().waitForLatchCountdown(
                TestImsService.LATCH_REMOVE_MMTEL));
        assertFalse(""Device ImsService was never removed when carrier ImsService took MMTEL.""
                + ""feature."", sServiceConnector.getExternalService().isMmTelFeatureCreated());

        // Ensure that the RcsFeature was removed on the carrier ImsService.
        assertTrue(sServiceConnector.getCarrierService().waitForLatchCountdown(
                TestImsService.LATCH_REMOVE_RCS));
        assertNull(sServiceConnector.getCarrierService().getRcsFeature());
    }"	""	""	"RCS MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.ImsServiceTest"	"testRcsDeviceCapabilitiesPublish"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	"public void testRcsDeviceCapabilitiesPublish() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        // Trigger carrier config changed
        PersistableBundle bundle = new PersistableBundle();
        bundle.putBoolean(CarrierConfigManager.KEY_CARRIER_VOLTE_PROVISIONED_BOOL, false);
        bundle.putBoolean(CarrierConfigManager.Ims.KEY_ENABLE_PRESENCE_PUBLISH_BOOL, true);
        overrideCarrierConfig(bundle);

        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        if (imsManager == null) {
            fail(""Cannot find IMS service"");
        }

        ImsRcsManager imsRcsManager = imsManager.getImsRcsManager(sTestSub);
        RcsUceAdapter uceAdapter = imsRcsManager.getUceAdapter();

        // Connect to device ImsService with MmTel feature and RCS feature
        triggerFrameworkConnectToImsServiceBindMmTelAndRcsFeature();

        TestRcsCapabilityExchangeImpl capExchangeImpl = sServiceConnector.getCarrierService()
                .getRcsFeature().getRcsCapabilityExchangeImpl();

        // Register the callback to listen to the publish state changed
        LinkedBlockingQueue<Integer> publishStateQueue = new LinkedBlockingQueue<>();
        RcsUceAdapter.OnPublishStateChangedListener publishStateCallback =
                new RcsUceAdapter.OnPublishStateChangedListener() {
                    public void onPublishStateChange(int state) {
                        publishStateQueue.offer(state);
                    }
                };

        // Another publish register callback to verify the API
        // RcsUceAdapter#removeOnPublishStateChangedListener
        LinkedBlockingQueue<Integer> unregisteredPublishStateQueue = new LinkedBlockingQueue<>();
        RcsUceAdapter.OnPublishStateChangedListener unregisteredPublishStateCallback =
                new RcsUceAdapter.OnPublishStateChangedListener() {
                    public void onPublishStateChange(int state) {
                        unregisteredPublishStateQueue.offer(state);
                    }
                };

        final UiAutomation automan = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            automan.adoptShellPermissionIdentity();
            // register two publish state callback
            uceAdapter.addOnPublishStateChangedListener(getContext().getMainExecutor(),
                    publishStateCallback);
            uceAdapter.addOnPublishStateChangedListener(getContext().getMainExecutor(),
                    unregisteredPublishStateCallback);
        } finally {
            automan.dropShellPermissionIdentity();
        }

        // Verify receiving the publish state callback immediately after registering the callback.
        assertEquals(RcsUceAdapter.PUBLISH_STATE_NOT_PUBLISHED,
                waitForIntResult(publishStateQueue));
        assertEquals(RcsUceAdapter.PUBLISH_STATE_NOT_PUBLISHED,
                waitForIntResult(unregisteredPublishStateQueue));
        publishStateQueue.clear();
        unregisteredPublishStateQueue.clear();

        // Verify the value of getting from the API is NOT_PUBLISHED
        try {
            automan.adoptShellPermissionIdentity();
            int publishState = uceAdapter.getUcePublishState();
            assertEquals(RcsUceAdapter.PUBLISH_STATE_NOT_PUBLISHED, publishState);
        } finally {
            automan.dropShellPermissionIdentity();
        }

        // Setup the operation of the publish request.
        capExchangeImpl.setPublishOperator((listener, pidfXml, cb) -> {
            int networkResp = 200;
            String reason = """";
            cb.onNetworkResponse(networkResp, reason);
            listener.onPublish();
        });

        // Unregister the publish state callback
        try {
            automan.adoptShellPermissionIdentity();
            uceAdapter.removeOnPublishStateChangedListener(unregisteredPublishStateCallback);
        } finally {
            automan.dropShellPermissionIdentity();
        }

        // IMS registers
        sServiceConnector.getCarrierService().getImsRegistration().onRegistered(
                ImsRegistrationImplBase.REGISTRATION_TECH_LTE);

        // Framework should not trigger the device capabilities publish when the framework doesn't
        // receive that the RcsUceAdapter.CAPABILITY_TYPE_PRESENCE_UCE is enabled.
        if (publishStateQueue.poll() != null) {
            fail(""The publish callback should not be called because presence uce is not ready"");
        }
        if (unregisteredPublishStateQueue.poll() != null) {
            fail(""The de-registered publish callback should not be called"");
        }

        // Notify framework that the RCS capability status is changed and PRESENCE UCE is enabled.
        RcsImsCapabilities capabilities =
                new RcsImsCapabilities(RcsUceAdapter.CAPABILITY_TYPE_PRESENCE_UCE);
        sServiceConnector.getCarrierService().getRcsFeature()
                .notifyCapabilitiesStatusChanged(capabilities);

        CapabilityExchangeEventListener eventListener =
                sServiceConnector.getCarrierService().getRcsFeature().getEventListener();

        // ImsService triggers to notify framework publish device's capabilities.
        eventListener.onRequestPublishCapabilities(
                RcsUceAdapter.CAPABILITY_UPDATE_TRIGGER_MOVE_TO_WLAN);

        // Verify ImsService receive the publish request from framework.
        assertTrue(sServiceConnector.getCarrierService().waitForLatchCountdown(
                TestImsService.LATCH_UCE_REQUEST_PUBLISH));
        assertEquals(RcsUceAdapter.PUBLISH_STATE_OK, waitForIntResult(publishStateQueue));
        publishStateQueue.clear();

        // Verify the value of getting from the API is PUBLISH_STATE_OK
        try {
            automan.adoptShellPermissionIdentity();
            int publishState = uceAdapter.getUcePublishState();
            assertEquals(RcsUceAdapter.PUBLISH_STATE_OK, publishState);
        } finally {
            automan.dropShellPermissionIdentity();
        }

        // ImsService triggers to notify framework publish device's capabilities.
        eventListener.onRequestPublishCapabilities(
                RcsUceAdapter.CAPABILITY_UPDATE_TRIGGER_MOVE_TO_WLAN);

        // Verify ImsService receive the publish request from framework.
        assertTrue(sServiceConnector.getCarrierService().waitForLatchCountdown(
                TestImsService.LATCH_UCE_REQUEST_PUBLISH));

        // ImsService triggers the unpublish notification
        eventListener.onUnpublish();

        // Verify the publish state callback will be called with the state ""NOT_PUBLISHED""
        assertEquals(RcsUceAdapter.PUBLISH_STATE_NOT_PUBLISHED,
                waitForIntResult(publishStateQueue));
        publishStateQueue.clear();

        // The unregistered callback should not be called.
        if (unregisteredPublishStateQueue.poll() != null) {
            fail(""The de-registered publish callback should not be called when unpublish"");
        }

        // Verify the value of getting from the API is NOT_PUBLISHED
        try {
            automan.adoptShellPermissionIdentity();
            int publishState = uceAdapter.getUcePublishState();
            assertEquals(RcsUceAdapter.PUBLISH_STATE_NOT_PUBLISHED, publishState);
        } finally {
            automan.dropShellPermissionIdentity();
        }

        // Trigger RcsFeature is unavailable
        sServiceConnector.getCarrierService().getRcsFeature()
                .setFeatureState(ImsFeature.STATE_UNAVAILABLE);

        // Verify the RcsCapabilityExchangeImplBase will be removed.
        assertTrue(sServiceConnector.getCarrierService().waitForLatchCountdown(
                TestImsService.LATCH_UCE_LISTENER_SET));

        overrideCarrierConfig(null);
    }"	""	""	"RCS MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.ImsServiceTest"	"testPublishImsReg"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	"public void testPublishImsReg() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        // Trigger carrier config changed
        PersistableBundle bundle = new PersistableBundle();
        bundle.putBoolean(CarrierConfigManager.KEY_CARRIER_VOLTE_PROVISIONED_BOOL, false);
        bundle.putBoolean(CarrierConfigManager.Ims.KEY_ENABLE_PRESENCE_PUBLISH_BOOL, true);
        overrideCarrierConfig(bundle);

        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        if (imsManager == null) {
            fail(""Cannot find IMS service"");
        }

        ImsRcsManager imsRcsManager = imsManager.getImsRcsManager(sTestSub);
        RcsUceAdapter uceAdapter = imsRcsManager.getUceAdapter();

        // Connect to device ImsService with MmTel feature and RCS feature
        triggerFrameworkConnectToImsServiceBindMmTelAndRcsFeature();

        TestRcsCapabilityExchangeImpl capExchangeImpl = sServiceConnector.getCarrierService()
                .getRcsFeature().getRcsCapabilityExchangeImpl();

        // Register the callback to listen to the publish state changed
        LinkedBlockingQueue<Integer> publishStateQueue = new LinkedBlockingQueue<>();
        RcsUceAdapter.OnPublishStateChangedListener publishStateCallback =
                publishStateQueue::offer;

        final UiAutomation automan = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            automan.adoptShellPermissionIdentity();
            uceAdapter.addOnPublishStateChangedListener(getContext().getMainExecutor(),
                    publishStateCallback);
        } finally {
            automan.dropShellPermissionIdentity();
        }

        // Verify receiving the publish state callback immediately after registering the callback.
        assertEquals(RcsUceAdapter.PUBLISH_STATE_NOT_PUBLISHED,
                waitForIntResult(publishStateQueue));
        publishStateQueue.clear();

        LinkedBlockingQueue<String> pidfQueue = new LinkedBlockingQueue<>();
        // Setup the operation of the publish request.
        capExchangeImpl.setPublishOperator((listener, pidfXml, cb) -> {
            pidfQueue.offer(pidfXml);
            int networkResp = 200;
            String reason = """";
            cb.onNetworkResponse(networkResp, reason);
            listener.onPublish();
        });

        LinkedBlockingQueue<ImsRegistrationAttributes> mQueue = new LinkedBlockingQueue<>();
        RegistrationManager.RegistrationCallback callback =
                new RegistrationManager.RegistrationCallback() {
                    @Override
                    public void onRegistered(ImsRegistrationAttributes attr) {
                        mQueue.offer(attr);
                    }

                    @Override
                    public void onRegistering(ImsRegistrationAttributes attr) {}

                    @Override
                    public void onUnregistered(ImsReasonInfo info) {}

                    @Override
                    public void onTechnologyChangeFailed(int type, ImsReasonInfo info) {}
                };
        ShellIdentityUtils.invokeThrowableMethodWithShellPermissionsNoReturn(imsRcsManager,
                (m) -> m.registerImsRegistrationCallback(getContext().getMainExecutor(), callback),
                ImsException.class);

        // IMS registers
        ArraySet<String> featureTags = new ArraySet<>();
        // Chat Session
        featureTags.add(CHAT_FEATURE_TAG);
        featureTags.add(FILE_TRANSFER_FEATURE_TAG);
        ImsRegistrationAttributes attr = new ImsRegistrationAttributes.Builder(
                ImsRegistrationImplBase.REGISTRATION_TECH_LTE).setFeatureTags(featureTags).build();
        sServiceConnector.getCarrierService().getImsRegistration().onRegistered(attr);
        waitForParam(mQueue, attr);

        // Notify framework that the RCS capability status is changed and PRESENCE UCE is enabled.
        RcsImsCapabilities capabilities =
                new RcsImsCapabilities(RcsUceAdapter.CAPABILITY_TYPE_PRESENCE_UCE);
        sServiceConnector.getCarrierService().getRcsFeature()
                .notifyCapabilitiesStatusChanged(capabilities);

        CapabilityExchangeEventListener eventListener =
                sServiceConnector.getCarrierService().getRcsFeature().getEventListener();

        // ImsService triggers to notify framework publish device's capabilities.
        eventListener.onRequestPublishCapabilities(
                RcsUceAdapter.CAPABILITY_UPDATE_TRIGGER_MOVE_TO_WLAN);

        // Verify that the publish is triggered and receive the publish state changed callback.
        assertTrue(sServiceConnector.getCarrierService().waitForLatchCountdown(
                TestImsService.LATCH_UCE_REQUEST_PUBLISH));
        assertEquals(RcsUceAdapter.PUBLISH_STATE_OK, waitForIntResult(publishStateQueue));
        publishStateQueue.clear();

        // Can not verify the pidf fully, but we can ensure that the service id for the feature is
        // contained in the XML. Multible PUBLISH requests may occur based on the state of the stack
        // at the time of this call, retry to get correct PIDF up to 5 times.
        boolean containsChatServiceId = false;
        boolean containsFileTransferServiceId = false;
        for (int retry = 0; retry < 5; retry++) {
            String pidf = waitForResult(pidfQueue);
            if (pidf == null) break;
            containsChatServiceId = pidf.contains(CHAT_SERVICE_ID);
            containsFileTransferServiceId  = pidf.contains(FILE_TRANSFER_SERVICE_ID);
            if (containsChatServiceId && containsFileTransferServiceId) break;
        }
        assertTrue(""PIDF XML doesn't contain chat service-id"", containsChatServiceId);
        assertTrue(""PIDF XML doesn't contain FT service-id"",
                containsFileTransferServiceId);

        // Trigger RcsFeature is unavailable
        sServiceConnector.getCarrierService().getRcsFeature()
                .setFeatureState(ImsFeature.STATE_UNAVAILABLE);

        // Verify the RcsCapabilityExchangeImplBase will be removed.
        assertTrue(sServiceConnector.getCarrierService().waitForLatchCountdown(
                TestImsService.LATCH_UCE_LISTENER_SET));

        overrideCarrierConfig(null);
    }"	""	""	"RCS MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.ImsServiceTest"	"testPublishWithImsAssociatedUri"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	"public void testPublishWithImsAssociatedUri() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        // Trigger carrier config changed
        PersistableBundle bundle = new PersistableBundle();
        bundle.putBoolean(CarrierConfigManager.KEY_CARRIER_VOLTE_PROVISIONED_BOOL, false);
        bundle.putBoolean(CarrierConfigManager.Ims.KEY_ENABLE_PRESENCE_PUBLISH_BOOL, true);
        overrideCarrierConfig(bundle);

        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        if (imsManager == null) {
            fail(""Cannot find IMS service"");
        }

        ImsRcsManager imsRcsManager = imsManager.getImsRcsManager(sTestSub);
        RcsUceAdapter uceAdapter = imsRcsManager.getUceAdapter();

        // Connect to device ImsService with MmTel feature and RCS feature
        triggerFrameworkConnectToImsServiceBindMmTelAndRcsFeature();

        TestRcsCapabilityExchangeImpl capExchangeImpl = sServiceConnector.getCarrierService()
                .getRcsFeature().getRcsCapabilityExchangeImpl();

        // Setup the operation of the publish request.
        List<String> receivedPidfXml = new ArrayList<>();
        capExchangeImpl.setPublishOperator((listener, pidfXml, cb) -> {
            int networkResp = 200;
            String reason = """";
            cb.onNetworkResponse(networkResp, reason);
            listener.onPublish();
            receivedPidfXml.add(pidfXml);
        });

        final Uri imsUri = Uri.fromParts(PhoneAccount.SCHEME_SIP, ""test"", null);
        StringBuilder expectedUriBuilder = new StringBuilder();
        expectedUriBuilder.append(""<contact>"").append(imsUri.toString()).append(""</contact>"");

        final String expectedUriString = expectedUriBuilder.toString();

        // IMS registers
        sServiceConnector.getCarrierService().getImsRegistration().onRegistered(
                ImsRegistrationImplBase.REGISTRATION_TECH_LTE);

        // Notify framework that the RCS capability status is changed and PRESENCE UCE is enabled.
        RcsImsCapabilities capabilities =
                new RcsImsCapabilities(RcsUceAdapter.CAPABILITY_TYPE_PRESENCE_UCE);
        sServiceConnector.getCarrierService().getRcsFeature()
                .notifyCapabilitiesStatusChanged(capabilities);

        // ImsService triggers to notify framework publish device's capabilities.
        CapabilityExchangeEventListener eventListener =
                sServiceConnector.getCarrierService().getRcsFeature().getEventListener();
        eventListener.onRequestPublishCapabilities(
                RcsUceAdapter.CAPABILITY_UPDATE_TRIGGER_MOVE_TO_WLAN);

        // Verify ImsService receive the publish request from framework.
        assertTrue(sServiceConnector.getCarrierService().waitForLatchCountdown(
                TestImsService.LATCH_UCE_REQUEST_PUBLISH));

        // Verify that the ImsService has received the publish request and the received PIDF does
        // not contain the associated URI.
        assertFalse(receivedPidfXml.isEmpty());
        assertFalse(receivedPidfXml.get(0).contains(expectedUriString));

        // Reset the received pidf xml data
        receivedPidfXml.clear();

        // Notify the associated URI has changed.
        sServiceConnector.getCarrierService().getImsRegistration().onSubscriberAssociatedUriChanged(
                new Uri[] { imsUri });

        // Verify the ImsService does not receive the PUBLISH request because we just finish a
        // publish request a moment ago.
        assertFalse(sServiceConnector.getCarrierService().waitForLatchCountdown(
                TestImsService.LATCH_UCE_REQUEST_PUBLISH, 2000 /* 2 seconds */));

        // Trigger a new publish request
        eventListener.onRequestPublishCapabilities(
                RcsUceAdapter.CAPABILITY_UPDATE_TRIGGER_MOVE_TO_WLAN);

        // Verify ImsService receive the publish request from framework.
        assertTrue(sServiceConnector.getCarrierService().waitForLatchCountdown(
                TestImsService.LATCH_UCE_REQUEST_PUBLISH));

        // Verify that the ImsService has received the publish request and the received PIDF
        // contains the associated URI.
        assertFalse(receivedPidfXml.isEmpty());
        assertTrue(receivedPidfXml.get(0).contains(expectedUriString));

        overrideCarrierConfig(null);
    }"	""	""	"RCS MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.ImsServiceTest"	"testRcsCapabilitiesPublishNetworkResponseWithReasonHeader"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	"public void testRcsCapabilitiesPublishNetworkResponseWithReasonHeader() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }

        // Trigger carrier config changed
        PersistableBundle bundle = new PersistableBundle();
        bundle.putBoolean(CarrierConfigManager.KEY_CARRIER_VOLTE_PROVISIONED_BOOL, false);
        bundle.putBoolean(CarrierConfigManager.Ims.KEY_ENABLE_PRESENCE_PUBLISH_BOOL, true);
        overrideCarrierConfig(bundle);

        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        if (imsManager == null) {
            fail(""Cannot find IMS service"");
        }

        ImsRcsManager imsRcsManager = imsManager.getImsRcsManager(sTestSub);
        RcsUceAdapter uceAdapter = imsRcsManager.getUceAdapter();

        // Connect to device ImsService with MmTel feature and RCS feature
        triggerFrameworkConnectToImsServiceBindMmTelAndRcsFeature();

        TestRcsCapabilityExchangeImpl capExchangeImpl = sServiceConnector.getCarrierService()
                .getRcsFeature().getRcsCapabilityExchangeImpl();

        // Register the callback to listen to the publish state changed
        LinkedBlockingQueue<Integer> publishStateQueue = new LinkedBlockingQueue<>();
        RcsUceAdapter.OnPublishStateChangedListener callback =
                new RcsUceAdapter.OnPublishStateChangedListener() {
                    public void onPublishStateChange(int state) {
                        publishStateQueue.offer(state);
                    }
                };

        // register the publish state callback
        ShellIdentityUtils.invokeThrowableMethodWithShellPermissionsNoReturn(uceAdapter,
                a -> a.addOnPublishStateChangedListener(getContext().getMainExecutor(), callback),
                ImsException.class,
                ""android.permission.READ_PRIVILEGED_PHONE_STATE"");

        // Verify receiving the publish state callback immediately after registering the callback.
        assertEquals(RcsUceAdapter.PUBLISH_STATE_NOT_PUBLISHED,
                waitForIntResult(publishStateQueue));
        publishStateQueue.clear();

        // Setup the operation of the publish request.
        capExchangeImpl.setPublishOperator((listener, pidfXml, cb) -> {
            int networkResp = 200;
            String reason = ""OK"";
            cb.onNetworkResponse(networkResp, reason);
            listener.onPublish();
        });

        // IMS registers
        sServiceConnector.getCarrierService().getImsRegistration().onRegistered(
                ImsRegistrationImplBase.REGISTRATION_TECH_LTE);

        // Notify framework that the RCS capability status is changed and PRESENCE UCE is enabled.
        RcsImsCapabilities capabilities =
                new RcsImsCapabilities(RcsUceAdapter.CAPABILITY_TYPE_PRESENCE_UCE);
        sServiceConnector.getCarrierService().getRcsFeature()
                .notifyCapabilitiesStatusChanged(capabilities);

        CapabilityExchangeEventListener eventListener =
                sServiceConnector.getCarrierService().getRcsFeature().getEventListener();

        // ImsService triggers to notify framework publish device's capabilities.
        eventListener.onRequestPublishCapabilities(
                RcsUceAdapter.CAPABILITY_UPDATE_TRIGGER_MOVE_TO_WLAN);

        // Verify the ImsService receive the publish request from framework.
        assertTrue(sServiceConnector.getCarrierService().waitForLatchCountdown(
                TestImsService.LATCH_UCE_REQUEST_PUBLISH));
        assertEquals(RcsUceAdapter.PUBLISH_STATE_OK, waitForIntResult(publishStateQueue));
        publishStateQueue.clear();

        // Verify it is getUcePublishState for the API ""getUcePublishState"".
        int publishState = ShellIdentityUtils.invokeThrowableMethodWithShellPermissions(uceAdapter,
                a -> a.getUcePublishState(),
                ImsException.class,
                ""android.permission.READ_PRIVILEGED_PHONE_STATE"");
        assertEquals(RcsUceAdapter.PUBLISH_STATE_OK, publishState);

        // Set the publish request fail (Reason header)
        capExchangeImpl.setPublishOperator((listener, pidfXml, cb) -> {
            int networkResp = 200;
            String reason = """";
            int reasonHeaderCause = 400;
            String reasonHeaderText = ""Bad Request"";
            cb.onNetworkResponse(networkResp, reason, reasonHeaderCause, reasonHeaderText);
            listener.onPublish();
        });

        // ImsService triggers to notify framework publish device's capabilities.
        eventListener.onRequestPublishCapabilities(
                RcsUceAdapter.CAPABILITY_UPDATE_TRIGGER_MOVE_TO_WLAN);

        // Verify ImsService receive the publish request from framework.
        assertTrue(sServiceConnector.getCarrierService().waitForLatchCountdown(
                TestImsService.LATCH_UCE_REQUEST_PUBLISH));

        // Verify that receive the publish failed callback
        assertEquals(RcsUceAdapter.PUBLISH_STATE_OTHER_ERROR,
                waitForIntResult(publishStateQueue));
        publishStateQueue.clear();

        publishState = ShellIdentityUtils.invokeThrowableMethodWithShellPermissions(uceAdapter,
                a -> a.getUcePublishState(),
                ImsException.class,
                ""android.permission.READ_PRIVILEGED_PHONE_STATE"");
        assertEquals(RcsUceAdapter.PUBLISH_STATE_OTHER_ERROR, publishState);

        overrideCarrierConfig(null);
    }"	""	""	"RCS MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.ImsServiceTest"	"testRcsPublishThrottle"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	"public void testRcsPublishThrottle() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }

        // Trigger carrier config change
        PersistableBundle bundle = new PersistableBundle();
        bundle.putBoolean(CarrierConfigManager.KEY_CARRIER_VOLTE_PROVISIONED_BOOL, false);
        bundle.putBoolean(CarrierConfigManager.Ims.KEY_ENABLE_PRESENCE_PUBLISH_BOOL, true);
        overrideCarrierConfig(bundle);

        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        if (imsManager == null) {
            fail(""Cannot get the ImsManager"");
        }
        ImsRcsManager imsRcsManager = imsManager.getImsRcsManager(sTestSub);
        RcsUceAdapter uceAdapter = imsRcsManager.getUceAdapter();

        // Connect to the ImsService
        triggerFrameworkConnectToImsServiceBindMmTelAndRcsFeature();

        TestRcsCapabilityExchangeImpl capExchangeImpl = sServiceConnector.getCarrierService()
                .getRcsFeature().getRcsCapabilityExchangeImpl();

        // Setup the response of the publish request.
        capExchangeImpl.setPublishOperator((listener, pidfXml, cb) -> {
            int networkResp = 200;
            String reason = ""OK"";
            cb.onNetworkResponse(networkResp, reason);
            listener.onPublish();
        });

        // Register the callback to listen to the publish state changed
        LinkedBlockingQueue<Integer> publishStateQueue = new LinkedBlockingQueue<>();
        RcsUceAdapter.OnPublishStateChangedListener publishStateCallback =
                new RcsUceAdapter.OnPublishStateChangedListener() {
                    public void onPublishStateChange(int state) {
                        publishStateQueue.offer(state);
                    }
                };

        final UiAutomation automation = InstrumentationRegistry.getInstrumentation()
                .getUiAutomation();
        try {
            automation.adoptShellPermissionIdentity();
            uceAdapter.addOnPublishStateChangedListener(getContext().getMainExecutor(),
                    publishStateCallback);
        } finally {
            automation.dropShellPermissionIdentity();
        }

        // Verify receiving the publish state callback immediately after registering the callback.
        assertEquals(RcsUceAdapter.PUBLISH_STATE_NOT_PUBLISHED,
                waitForIntResult(publishStateQueue));
        publishStateQueue.clear();

        // IMS registers
        sServiceConnector.getCarrierService().getImsRegistration().onRegistered(
                ImsRegistrationImplBase.REGISTRATION_TECH_LTE);

        // Verify the PUBLISH request should not be triggered and the publish state is still
        // NOT_PUBLISHED even the IMS is registered.
        if (publishStateQueue.poll() != null) {
            fail(""The PUBLISH request should not be triggered."");
        }
        try {
            automation.adoptShellPermissionIdentity();
            int publishState = uceAdapter.getUcePublishState();
            assertEquals(RcsUceAdapter.PUBLISH_STATE_NOT_PUBLISHED, publishState);
        } finally {
            automation.dropShellPermissionIdentity();
        }

        // Notify framework that the RCS capability status is changed and PRESENCE UCE is enabled.
        RcsImsCapabilities capabilities =
                new RcsImsCapabilities(RcsUceAdapter.CAPABILITY_TYPE_PRESENCE_UCE);
        sServiceConnector.getCarrierService().getRcsFeature()
                .notifyCapabilitiesStatusChanged(capabilities);

        CapabilityExchangeEventListener eventListener =
                sServiceConnector.getCarrierService().getRcsFeature().getEventListener();

        // Notify framework to send the PUBLISH request to the ImsService.
        eventListener.onRequestPublishCapabilities(
                RcsUceAdapter.CAPABILITY_UPDATE_TRIGGER_MOVE_TO_WLAN);

        // Verify that ImsService received the first PUBLISH
        assertTrue(sServiceConnector.getCarrierService().waitForLatchCountdown(
                TestImsService.LATCH_UCE_REQUEST_PUBLISH));
        assertEquals(RcsUceAdapter.PUBLISH_STATE_OK, waitForIntResult(publishStateQueue));
        publishStateQueue.clear();
        try {
            automation.adoptShellPermissionIdentity();
            int publishState = uceAdapter.getUcePublishState();
            assertEquals(RcsUceAdapter.PUBLISH_STATE_OK, publishState);
        } finally {
            automation.dropShellPermissionIdentity();
        }

        // Now enable voice availability
        sServiceConnector.getCarrierService().getMmTelFeature()
                .notifyCapabilitiesStatusChanged(new MmTelFeature.MmTelCapabilities(
                        MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VOICE));

        // The published just succeeded. The next publish should not be triggered immediately even
        // the device capabilities has changed. Wait 3 seconds to verify the ImsService does not
        // receive the publish request from the framework.
        assertFalse(sServiceConnector.getCarrierService().waitForLatchCountdown(
                TestImsService.LATCH_UCE_REQUEST_PUBLISH, 3000 /* 3 seconds */));

        // However, if the request is triggered from the service, a new publish request should be
        // sent immediately.
        eventListener.onRequestPublishCapabilities(
                RcsUceAdapter.CAPABILITY_UPDATE_TRIGGER_MOVE_TO_WLAN);

        // Verify the ImsService receive the publish request
        assertTrue(sServiceConnector.getCarrierService().waitForLatchCountdown(
                TestImsService.LATCH_UCE_REQUEST_PUBLISH, 3000 /* Wait up to 3 seconds */));

        overrideCarrierConfig(null);
    }"	""	""	"RCS MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.ImsServiceTest"	"testRcsPublishWithSipOptions"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	"public void testRcsPublishWithSipOptions() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }

        // Override the carrier config to support SIP OPTIONS
        PersistableBundle bundle = new PersistableBundle();
        bundle.putBoolean(CarrierConfigManager.KEY_CARRIER_VOLTE_PROVISIONED_BOOL, false);
        bundle.putBoolean(CarrierConfigManager.Ims.KEY_ENABLE_PRESENCE_PUBLISH_BOOL, false);
        bundle.putBoolean(CarrierConfigManager.KEY_USE_RCS_SIP_OPTIONS_BOOL, true);
        overrideCarrierConfig(bundle);

        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        if (imsManager == null) {
            fail(""Cannot get the ImsManager"");
        }
        ImsRcsManager imsRcsManager = imsManager.getImsRcsManager(sTestSub);
        RcsUceAdapter uceAdapter = imsRcsManager.getUceAdapter();

        // Connect to the ImsService
        triggerFrameworkConnectToImsServiceBindMmTelAndRcsFeature();

        TestRcsCapabilityExchangeImpl capExchangeImpl = sServiceConnector.getCarrierService()
                .getRcsFeature().getRcsCapabilityExchangeImpl();

        // Setup the response of the publish request. In SIP OPTIONS mechanism, ImsService
        // should not receive any publish requests.
        capExchangeImpl.setPublishOperator((listener, pidfXml, cb) -> {
            fail(""ImsService should not receive the PUBLISH request"");
        });

        // Register the callback to listen to the publish state changed
        LinkedBlockingQueue<Integer> publishStateQueue = new LinkedBlockingQueue<>();
        RcsUceAdapter.OnPublishStateChangedListener publishStateCallback =
                new RcsUceAdapter.OnPublishStateChangedListener() {
                    public void onPublishStateChange(int state) {
                        publishStateQueue.offer(state);
                    }
                };

        final UiAutomation automation = InstrumentationRegistry.getInstrumentation()
                .getUiAutomation();

        // Verify receiving the publish state callback immediately after registering the callback
        // and the PUBLISH state is OK because the capability mechanism is SIP OPTIONS.
        try {
            automation.adoptShellPermissionIdentity();
            uceAdapter.addOnPublishStateChangedListener(getContext().getMainExecutor(),
                    publishStateCallback);
            assertEquals(RcsUceAdapter.PUBLISH_STATE_OK, waitForIntResult(publishStateQueue));
        } finally {
            automation.dropShellPermissionIdentity();
            publishStateQueue.clear();
        }

        // IMS registers
        sServiceConnector.getCarrierService().getImsRegistration().onRegistered(
                ImsRegistrationImplBase.REGISTRATION_TECH_LTE);

        // Verify the PUBLISH request should not be triggered and the publish state is still
        // OK even the IMS is registered.
        if (publishStateQueue.poll() != null) {
            fail(""The PUBLISH request should not be triggered."");
        }
        try {
            automation.adoptShellPermissionIdentity();
            int publishState = uceAdapter.getUcePublishState();
            assertEquals(RcsUceAdapter.PUBLISH_STATE_OK, publishState);
        } finally {
            automation.dropShellPermissionIdentity();
        }

        // Override the carrier config from SIP OPTIONS to PRESENCE.
        bundle = new PersistableBundle();
        bundle.putBoolean(CarrierConfigManager.KEY_CARRIER_VOLTE_PROVISIONED_BOOL, false);
        bundle.putBoolean(CarrierConfigManager.Ims.KEY_ENABLE_PRESENCE_PUBLISH_BOOL, true);
        bundle.putBoolean(CarrierConfigManager.KEY_USE_RCS_SIP_OPTIONS_BOOL, false);
        overrideCarrierConfig(bundle);

        // When the capability type is changed from SIP OPTIONS to PRESENCE, the publish state
        // should be re-initialized to NOT_PUBLISHED
        try {
            // Verify receiving the callback that the publish state has changed from OK
            // to NOT_PUBLISH
            assertEquals(RcsUceAdapter.PUBLISH_STATE_NOT_PUBLISHED,
                    waitForIntResult(publishStateQueue));
            // Verify it by calling the API getPucePublishState
            automation.adoptShellPermissionIdentity();
            int publishState = uceAdapter.getUcePublishState();
            assertEquals(RcsUceAdapter.PUBLISH_STATE_NOT_PUBLISHED, publishState);
        } finally {
            publishStateQueue.clear();
            automation.dropShellPermissionIdentity();
        }

        // Notify framework that the RCS capability status is changed and PRESENCE UCE is enabled.
        RcsImsCapabilities capabilities =
                new RcsImsCapabilities(RcsUceAdapter.CAPABILITY_TYPE_PRESENCE_UCE);
        sServiceConnector.getCarrierService().getRcsFeature()
                .notifyCapabilitiesStatusChanged(capabilities);

        CapabilityExchangeEventListener eventListener =
                sServiceConnector.getCarrierService().getRcsFeature().getEventListener();

        // Setup the operation of the publish request.
        capExchangeImpl.setPublishOperator((listener, pidfXml, cb) -> {
            int networkResp = 200;
            String reason = ""OK"";
            cb.onNetworkResponse(networkResp, reason);
            listener.onPublish();
        });

        // Notify framework to send the PUBLISH request to the ImsService.
        eventListener.onRequestPublishCapabilities(
                RcsUceAdapter.CAPABILITY_UPDATE_TRIGGER_MOVE_TO_WLAN);

        // Verify that ImsService received the first PUBLISH
        assertTrue(sServiceConnector.getCarrierService().waitForLatchCountdown(
                TestImsService.LATCH_UCE_REQUEST_PUBLISH));

        // Verify that the publish state should be changed from NOT_PUBLISHED to OK
        try {
            assertEquals(RcsUceAdapter.PUBLISH_STATE_OK, waitForIntResult(publishStateQueue));
            automation.adoptShellPermissionIdentity();
            assertEquals(RcsUceAdapter.PUBLISH_STATE_OK, uceAdapter.getUcePublishState());
        } finally {
            publishStateQueue.clear();
            automation.dropShellPermissionIdentity();
        }

        overrideCarrierConfig(null);
    }"	""	""	"RCS MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.ImsServiceTest"	"testRcsPublishWithAuthorizedErrorResponse"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	"public void testRcsPublishWithAuthorizedErrorResponse() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }

        // Trigger carrier config change
        PersistableBundle bundle = new PersistableBundle();
        bundle.putBoolean(CarrierConfigManager.KEY_CARRIER_VOLTE_PROVISIONED_BOOL, false);
        bundle.putBoolean(CarrierConfigManager.Ims.KEY_ENABLE_PRESENCE_PUBLISH_BOOL, true);
        overrideCarrierConfig(bundle);

        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        if (imsManager == null) {
            fail(""Cannot get the ImsManager"");
        }
        ImsRcsManager imsRcsManager = imsManager.getImsRcsManager(sTestSub);
        RcsUceAdapter uceAdapter = imsRcsManager.getUceAdapter();

        // Connect to the ImsService
        triggerFrameworkConnectToImsServiceBindMmTelAndRcsFeature();

        // Register the callback to listen to the publish state changed
        LinkedBlockingQueue<Integer> publishStateQueue = new LinkedBlockingQueue<>();
        RcsUceAdapter.OnPublishStateChangedListener publishStateCallback =
                new RcsUceAdapter.OnPublishStateChangedListener() {
                    public void onPublishStateChange(int state) {
                        publishStateQueue.offer(state);
                    }
                };

        final UiAutomation automation = InstrumentationRegistry.getInstrumentation()
                .getUiAutomation();
        try {
            automation.adoptShellPermissionIdentity();
            uceAdapter.addOnPublishStateChangedListener(getContext().getMainExecutor(),
                    publishStateCallback);
            // Verify receiving the publish state callback after registering the callback.
            assertEquals(RcsUceAdapter.PUBLISH_STATE_NOT_PUBLISHED,
                    waitForIntResult(publishStateQueue));
        } finally {
            publishStateQueue.clear();
            automation.dropShellPermissionIdentity();
        }

        TestRcsCapabilityExchangeImpl capExchangeImpl = sServiceConnector.getCarrierService()
                .getRcsFeature().getRcsCapabilityExchangeImpl();

        // Setup the response of the publish request.
        capExchangeImpl.setPublishOperator((listener, pidfXml, cb) -> {
            int networkResp = 200;
            String reason = ""OK"";
            cb.onNetworkResponse(networkResp, reason);
            listener.onPublish();
        });

        // IMS registers
        sServiceConnector.getCarrierService().getImsRegistration().onRegistered(
                ImsRegistrationImplBase.REGISTRATION_TECH_LTE);

        // Notify framework that the RCS capability status is changed and PRESENCE UCE is enabled.
        RcsImsCapabilities capabilities =
                new RcsImsCapabilities(RcsUceAdapter.CAPABILITY_TYPE_PRESENCE_UCE);
        sServiceConnector.getCarrierService().getRcsFeature()
                .notifyCapabilitiesStatusChanged(capabilities);

        CapabilityExchangeEventListener eventListener =
                sServiceConnector.getCarrierService().getRcsFeature().getEventListener();

        // Notify framework to send the PUBLISH request to the ImsService.
        eventListener.onRequestPublishCapabilities(
                RcsUceAdapter.CAPABILITY_UPDATE_TRIGGER_MOVE_TO_WLAN);

        // Verify ImsService receive the publish request from framework.
        assertTrue(sServiceConnector.getCarrierService().waitForLatchCountdown(
                TestImsService.LATCH_UCE_REQUEST_PUBLISH));

        try {
            // Verify the publish state callback is received.
            assertEquals(RcsUceAdapter.PUBLISH_STATE_OK, waitForIntResult(publishStateQueue));
            // Verify the value of getting from the API is PUBLISH_STATE_OK
            automation.adoptShellPermissionIdentity();
            int publishState = uceAdapter.getUcePublishState();
            assertEquals(RcsUceAdapter.PUBLISH_STATE_OK, publishState);
        } finally {
            publishStateQueue.clear();
            automation.dropShellPermissionIdentity();
        }

        // Reply the SIP code 403 FORBIDDEN
        capExchangeImpl.setPublishOperator((listener, pidfXml, cb) -> {
            int networkResp = 403;
            String reason = ""FORBIDDEN"";
            cb.onNetworkResponse(networkResp, reason);
            listener.onPublish();
        });

        // Notify framework to send the PUBLISH request to the ImsService.
        eventListener.onRequestPublishCapabilities(
                RcsUceAdapter.CAPABILITY_UPDATE_TRIGGER_MOVE_TO_WLAN);

        try {
            // Verify the publish state callback is received.
            assertEquals(RcsUceAdapter.PUBLISH_STATE_RCS_PROVISION_ERROR,
                    waitForIntResult(publishStateQueue));
            // Verify the value of getting from the API is PUBLISH_STATE_RCS_PROVISION_ERROR
            automation.adoptShellPermissionIdentity();
            int publishState = uceAdapter.getUcePublishState();
            assertEquals(RcsUceAdapter.PUBLISH_STATE_RCS_PROVISION_ERROR, publishState);
        } finally {
            publishStateQueue.clear();
            automation.dropShellPermissionIdentity();
        }

        LinkedBlockingQueue<Integer> errorQueue = new LinkedBlockingQueue<>();
        LinkedBlockingQueue<Long> errorRetryQueue = new LinkedBlockingQueue<>();
        LinkedBlockingQueue<Boolean> completeQueue = new LinkedBlockingQueue<>();
        LinkedBlockingQueue<RcsContactUceCapability> capabilityQueue = new LinkedBlockingQueue<>();
        RcsUceAdapter.CapabilitiesCallback callback = new RcsUceAdapter.CapabilitiesCallback() {
            @Override
            public void onCapabilitiesReceived(List<RcsContactUceCapability> capabilities) {
                capabilities.forEach(c -> capabilityQueue.offer(c));
            }
            @Override
            public void onComplete() {
                completeQueue.offer(true);
            }
            @Override
            public void onError(int errorCode, long retryAfterMilliseconds) {
                errorQueue.offer(errorCode);
                errorRetryQueue.offer(retryAfterMilliseconds);
            }
        };

        capExchangeImpl.setSubscribeOperation((uris, cb) -> {
            fail(""Should not received the SUBSCRIBE request"");
        });

        Collection<Uri> contacts = Collections.singletonList(
                Uri.fromParts(PhoneAccount.SCHEME_SIP, ""test"", null));

        try {
            ShellIdentityUtils.invokeThrowableMethodWithShellPermissionsNoReturn(
                    uceAdapter,
                    adapter -> adapter.requestCapabilities(contacts, Runnable::run, callback),
                    ImsException.class,
                    ""android.permission.ACCESS_RCS_USER_CAPABILITY_EXCHANGE"");
        } catch (SecurityException e) {
            fail(""requestCapabilities should succeed with ACCESS_RCS_USER_CAPABILITY_EXCHANGE. ""
                    + ""Exception: "" + e);
        } catch (ImsException e) {
            fail(""requestCapabilities failed "" + e);
        }

        // Verify the capability request should fail
        try {
            assertEquals(RcsUceAdapter.ERROR_NOT_AUTHORIZED, waitForIntResult(errorQueue));
            assertEquals(Long.valueOf(0L), waitForResult(errorRetryQueue));
        } catch (Exception e) {
            fail(""requestCapabilities with command error failed: "" + e);
        } finally {
            errorQueue.clear();
            errorRetryQueue.clear();
        }

        // Reset the UCE device state
        try {
            sServiceConnector.removeUceRequestDisallowedStatus(sTestSlot);
        } catch (Exception e) {
            fail(""Cannot remove request disallowed status: "" + e);
        }

        // Reply the SIP code 404 NOT FOUND
        capExchangeImpl.setPublishOperator((listener, pidfXml, cb) -> {
            int networkResp = 404;
            String reason = ""NOT FOUND"";
            cb.onNetworkResponse(networkResp, reason);
            listener.onPublish();
        });

        // Notify framework to send the PUBLISH request to the ImsService.
        eventListener.onRequestPublishCapabilities(
                RcsUceAdapter.CAPABILITY_UPDATE_TRIGGER_MOVE_TO_WLAN);

        try {
            // Verify the value of getting from the API is PUBLISH_STATE_RCS_PROVISION_ERROR
            automation.adoptShellPermissionIdentity();
            int publishState = uceAdapter.getUcePublishState();
            assertEquals(RcsUceAdapter.PUBLISH_STATE_RCS_PROVISION_ERROR, publishState);
        } finally {
            publishStateQueue.clear();
            automation.dropShellPermissionIdentity();
        }

        try {
            ShellIdentityUtils.invokeThrowableMethodWithShellPermissionsNoReturn(
                    uceAdapter,
                    adapter -> adapter.requestCapabilities(contacts, Runnable::run, callback),
                    ImsException.class,
                    ""android.permission.ACCESS_RCS_USER_CAPABILITY_EXCHANGE"");
        } catch (SecurityException e) {
            fail(""requestCapabilities should succeed with ACCESS_RCS_USER_CAPABILITY_EXCHANGE. ""
                    + ""Exception: "" + e);
        } catch (ImsException e) {
            fail(""requestCapabilities failed "" + e);
        }

        // Reset the UCE device state
        try {
            sServiceConnector.removeUceRequestDisallowedStatus(sTestSlot);
        } catch (Exception e) {
            fail(""Cannot remove request disallowed status: "" + e);
        }

        overrideCarrierConfig(null);
    }"	""	""	"RCS MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.ImsServiceTest"	"testRcsManagerRegistrationCallback"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	"public void testRcsManagerRegistrationCallback() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }

        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        if (imsManager == null) {
            fail(""Cannot find IMS service"");
        }

        // Connect to device ImsService with RcsFeature
        triggerFrameworkConnectToLocalImsServiceBindRcsFeature();
        ImsRcsManager imsRcsManager = imsManager.getImsRcsManager(sTestSub);

        // Override the carrier config
        PersistableBundle bundle = new PersistableBundle();
        bundle.putBoolean(CarrierConfigManager.Ims.KEY_ENABLE_PRESENCE_PUBLISH_BOOL, true);
        overrideCarrierConfig(bundle);

        // Wait for the framework to set the capabilities on the ImsService
        sServiceConnector.getCarrierService().waitForLatchCountdown(
                TestImsService.LATCH_RCS_CAP_SET);

        // Start de-registered
        sServiceConnector.getCarrierService().getImsRegistration().onDeregistered(
                new ImsReasonInfo(ImsReasonInfo.CODE_LOCAL_NOT_REGISTERED,
                        ImsReasonInfo.CODE_UNSPECIFIED, """"));

        LinkedBlockingQueue<Integer> mQueue = new LinkedBlockingQueue<>();
        RegistrationManager.RegistrationCallback callback =
                new RegistrationManager.RegistrationCallback() {
                    @Override
                    public void onRegistered(int imsTransportType) {
                        mQueue.offer(imsTransportType);
                    }

                    @Override
                    public void onRegistering(int imsTransportType) {
                        mQueue.offer(imsTransportType);
                    }

                    @Override
                    public void onUnregistered(ImsReasonInfo info) {
                        mQueue.offer(info.getCode());
                    }

                    @Override
                    public void onTechnologyChangeFailed(int imsTransportType, ImsReasonInfo info) {
                        mQueue.offer(imsTransportType);
                        mQueue.offer(info.getCode());
                    }
                };

        // Verify the registerImsRegistrationCallback should fail without the required permission
        try {
            imsRcsManager.registerImsRegistrationCallback(getContext().getMainExecutor(), callback);
            fail(""registerImsRegistrationCallback requires READ_PRECISE_PHONE_STATE permission."");
        } catch (SecurityException e) {
            //expected
        }

        ShellIdentityUtils.invokeThrowableMethodWithShellPermissionsNoReturn(imsRcsManager,
                m -> m.registerImsRegistrationCallback(getContext().getMainExecutor(), callback),
                ImsException.class,
                ""android.permission.READ_PRECISE_PHONE_STATE"");

        // Verify it's not registered
        assertEquals(ImsReasonInfo.CODE_LOCAL_NOT_REGISTERED, waitForIntResult(mQueue));

        // Start registration
        sServiceConnector.getCarrierService().getImsRegistration().onRegistering(
                ImsRegistrationImplBase.REGISTRATION_TECH_LTE);
        assertEquals(AccessNetworkConstants.TRANSPORT_TYPE_WWAN, waitForIntResult(mQueue));

        // Complete registration
        sServiceConnector.getCarrierService().getImsRegistration().onRegistered(
                ImsRegistrationImplBase.REGISTRATION_TECH_LTE);
        assertEquals(AccessNetworkConstants.TRANSPORT_TYPE_WWAN, waitForIntResult(mQueue));

        // Fail handover to IWLAN
        sServiceConnector.getCarrierService().getImsRegistration().onTechnologyChangeFailed(
                ImsRegistrationImplBase.REGISTRATION_TECH_IWLAN,
                new ImsReasonInfo(ImsReasonInfo.CODE_LOCAL_HO_NOT_FEASIBLE,
                        ImsReasonInfo.CODE_UNSPECIFIED, """"));
        assertEquals(AccessNetworkConstants.TRANSPORT_TYPE_WLAN, waitForIntResult(mQueue));
        assertEquals(ImsReasonInfo.CODE_LOCAL_HO_NOT_FEASIBLE, waitForIntResult(mQueue));

        // Verify the unregisterImsRegistrationCallback should failure without the permission.
        try {
            imsRcsManager.unregisterImsRegistrationCallback(callback);
            fail(""unregisterImsRegistrationCallback requires READ_PRECISE_PHONE_STATE permission"");
        } catch (SecurityException e) {
            //expected
        }

        ShellIdentityUtils.invokeThrowableMethodWithShellPermissionsNoReturn(imsRcsManager,
                m -> m.unregisterImsRegistrationCallback(callback),
                ImsException.class,
                ""android.permission.READ_PRECISE_PHONE_STATE"");

        overrideCarrierConfig(null);
    }"	""	""	"RCS"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.ImsServiceTest"	"testRcsManagerRegistrationState"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	"public void testRcsManagerRegistrationState() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }

        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        if (imsManager == null) {
            fail(""Cannot find IMS service"");
        }

        // Connect to device ImsService with RcsFeature
        triggerFrameworkConnectToLocalImsServiceBindRcsFeature();

        // Override the carrier config
        PersistableBundle bundle = new PersistableBundle();
        bundle.putBoolean(CarrierConfigManager.Ims.KEY_ENABLE_PRESENCE_PUBLISH_BOOL, true);
        overrideCarrierConfig(bundle);

        sServiceConnector.getCarrierService().waitForLatchCountdown(
                TestImsService.LATCH_RCS_CAP_SET);

        // Start de-registered
        sServiceConnector.getCarrierService().getImsRegistration().onDeregistered(
                new ImsReasonInfo(ImsReasonInfo.CODE_LOCAL_NOT_REGISTERED,
                        ImsReasonInfo.CODE_UNSPECIFIED, """"));

        LinkedBlockingQueue<Integer> mQueue = new LinkedBlockingQueue<>();
        RegistrationManager.RegistrationCallback callback =
                new RegistrationManager.RegistrationCallback() {
                    @Override
                    public void onRegistered(int imsTransportType) {
                        mQueue.offer(imsTransportType);
                    }

                    @Override
                    public void onRegistering(int imsTransportType) {
                        mQueue.offer(imsTransportType);
                    }

                    @Override
                    public void onUnregistered(ImsReasonInfo info) {
                        mQueue.offer(info.getCode());
                    }

                    @Override
                    public void onTechnologyChangeFailed(int imsTransportType, ImsReasonInfo info) {
                        mQueue.offer(imsTransportType);
                        mQueue.offer(info.getCode());
                    }
                };

        ImsRcsManager imsRcsManager = imsManager.getImsRcsManager(sTestSub);
        ShellIdentityUtils.invokeThrowableMethodWithShellPermissionsNoReturn(imsRcsManager,
                (m) -> m.registerImsRegistrationCallback(getContext().getMainExecutor(), callback),
                ImsException.class);
        assertEquals(ImsReasonInfo.CODE_LOCAL_NOT_REGISTERED, waitForIntResult(mQueue));

        // Verify the getRegistrationState should fail without the required permission
        try {
            imsRcsManager.getRegistrationState(getContext().getMainExecutor(), mQueue::offer);
            fail(""getRegistrationState requires READ_PRECISE_PHONE_STATE permission."");
        } catch (SecurityException e) {
            //expected
        }

        // Verify the getRegistrationTransportType should fail without the required permission
        try {
            imsRcsManager.getRegistrationTransportType(getContext().getMainExecutor(),
                    mQueue::offer);
            fail(""getRegistrationTransportType requires READ_PRECISE_PHONE_STATE permission."");
        } catch (SecurityException e) {
            //expected
        }

        // Ensure that the Framework reports Deregistered correctly
        verifyRegistrationState(imsRcsManager,
                RegistrationManager.REGISTRATION_STATE_NOT_REGISTERED);
        verifyRegistrationTransportType(imsRcsManager,
                AccessNetworkConstants.TRANSPORT_TYPE_INVALID);

        // Start registration
        sServiceConnector.getCarrierService().getImsRegistration().onRegistering(
                ImsRegistrationImplBase.REGISTRATION_TECH_LTE);
        assertEquals(AccessNetworkConstants.TRANSPORT_TYPE_WWAN, waitForIntResult(mQueue));
        verifyRegistrationState(imsRcsManager, RegistrationManager.REGISTRATION_STATE_REGISTERING);
        verifyRegistrationTransportType(imsRcsManager, AccessNetworkConstants.TRANSPORT_TYPE_WWAN);

        // Complete registration
        sServiceConnector.getCarrierService().getImsRegistration().onRegistered(
                ImsRegistrationImplBase.REGISTRATION_TECH_LTE);
        assertEquals(AccessNetworkConstants.TRANSPORT_TYPE_WWAN, waitForIntResult(mQueue));
        verifyRegistrationState(imsRcsManager, RegistrationManager.REGISTRATION_STATE_REGISTERED);
        verifyRegistrationTransportType(imsRcsManager, AccessNetworkConstants.TRANSPORT_TYPE_WWAN);

        // Start registration over NR
        sServiceConnector.getCarrierService().getImsRegistration().onRegistering(
                ImsRegistrationImplBase.REGISTRATION_TECH_NR);
        assertEquals(AccessNetworkConstants.TRANSPORT_TYPE_WWAN, waitForIntResult(mQueue));
        verifyRegistrationState(imsRcsManager, RegistrationManager.REGISTRATION_STATE_REGISTERING);
        verifyRegistrationTransportType(imsRcsManager, AccessNetworkConstants.TRANSPORT_TYPE_WWAN);

        // Complete registration over NR
        sServiceConnector.getCarrierService().getImsRegistration().onRegistered(
                ImsRegistrationImplBase.REGISTRATION_TECH_NR);
        assertEquals(AccessNetworkConstants.TRANSPORT_TYPE_WWAN, waitForIntResult(mQueue));
        verifyRegistrationState(imsRcsManager, RegistrationManager.REGISTRATION_STATE_REGISTERED);
        verifyRegistrationTransportType(imsRcsManager, AccessNetworkConstants.TRANSPORT_TYPE_WWAN);

        // Fail handover to IWLAN
        sServiceConnector.getCarrierService().getImsRegistration().onTechnologyChangeFailed(
                ImsRegistrationImplBase.REGISTRATION_TECH_IWLAN,
                new ImsReasonInfo(ImsReasonInfo.CODE_LOCAL_HO_NOT_FEASIBLE,
                        ImsReasonInfo.CODE_UNSPECIFIED, """"));
        assertEquals(AccessNetworkConstants.TRANSPORT_TYPE_WLAN, waitForIntResult(mQueue));
        assertEquals(ImsReasonInfo.CODE_LOCAL_HO_NOT_FEASIBLE, waitForIntResult(mQueue));
        verifyRegistrationTransportType(imsRcsManager, AccessNetworkConstants.TRANSPORT_TYPE_WWAN);

        // handover to IWLAN
        sServiceConnector.getCarrierService().getImsRegistration().onRegistered(
                ImsRegistrationImplBase.REGISTRATION_TECH_IWLAN);
        assertEquals(AccessNetworkConstants.TRANSPORT_TYPE_WLAN, waitForIntResult(mQueue));
        verifyRegistrationTransportType(imsRcsManager, AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(imsRcsManager,
                (m) -> m.unregisterImsRegistrationCallback(callback));

        overrideCarrierConfig(null);
    }"	""	""	"RCS"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.ImsServiceTest"	"testRcsCapabilityStatusCallback"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	"public void testRcsCapabilityStatusCallback() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }

        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        if (imsManager == null) {
            fail(""Cannot find IMS service"");
        }

        // Connect to device ImsService with RcsFeature
        triggerFrameworkConnectToLocalImsServiceBindRcsFeature();

        int registrationTech = ImsRegistrationImplBase.REGISTRATION_TECH_LTE;
        ImsRcsManager imsRcsManager = imsManager.getImsRcsManager(sTestSub);

        // Make sure we start off with none-capability
        sServiceConnector.getCarrierService().getImsRegistration().onRegistered(
                ImsRegistrationImplBase.REGISTRATION_TECH_LTE);
        RcsImsCapabilities noCapabilities = new RcsImsCapabilities(RCS_CAP_NONE);
        sServiceConnector.getCarrierService().getRcsFeature()
                .notifyCapabilitiesStatusChanged(noCapabilities);

        // Make sure the capabilities match the API getter for capabilities
        final UiAutomation automan = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        // Latch will count down here (we callback on the state during registration).
        try {
            automan.adoptShellPermissionIdentity();
            // Make sure we are tracking voice capability over LTE properly.
            RcsImsCapabilities availability = sServiceConnector.getCarrierService()
                    .getRcsFeature().queryCapabilityStatus();
            assertFalse(availability.isCapable(RCS_CAP_OPTIONS));
            assertFalse(availability.isCapable(RCS_CAP_PRESENCE));
        } finally {
            automan.dropShellPermissionIdentity();
        }

        // Trigger carrier config changed
        PersistableBundle bundle = new PersistableBundle();
        bundle.putBoolean(CarrierConfigManager.KEY_USE_RCS_SIP_OPTIONS_BOOL, true);
        bundle.putBoolean(CarrierConfigManager.Ims.KEY_ENABLE_PRESENCE_PUBLISH_BOOL, true);
        overrideCarrierConfig(bundle);

        sServiceConnector.getCarrierService().waitForLatchCountdown(
                TestImsService.LATCH_RCS_CAP_SET);

        // The carrier config changed should trigger RcsFeature#changeEnabledCapabilities
        try {
            automan.adoptShellPermissionIdentity();
            // Checked by isCapable api to make sure RcsFeature#changeEnabledCapabilities is called
            assertTrue(ImsUtils.retryUntilTrue(() ->
                    imsRcsManager.isCapable(RCS_CAP_OPTIONS, registrationTech)));
            assertTrue(ImsUtils.retryUntilTrue(() ->
                    imsRcsManager.isCapable(RCS_CAP_PRESENCE, registrationTech)));
        } finally {
            automan.dropShellPermissionIdentity();
        }

        // A queue to receive capability changed
        LinkedBlockingQueue<Integer> availabilityChanged = new LinkedBlockingQueue<>();
        ImsRcsManager.OnAvailabilityChangedListener callback =
                new ImsRcsManager.OnAvailabilityChangedListener() {
            @Override
            public void onAvailabilityChanged(
                    @RcsUceAdapter.RcsImsCapabilityFlag int capabilities) {
                availabilityChanged.offer(capabilities);
            }
        };

        // Latch will count down here (we callback on the state during registration).
        try {
            automan.adoptShellPermissionIdentity();
            imsRcsManager.addOnAvailabilityChangedListener(
                    getContext().getMainExecutor(), callback);
        } finally {
            automan.dropShellPermissionIdentity();
        }

        // Verify the callback and the api isAvailable that the capabilities is NONE in the
        // beginning.
        int radioTechLTE = ImsRegistrationImplBase.REGISTRATION_TECH_LTE;
        int capCb = waitForResult(availabilityChanged);
        assertEquals(capCb, RCS_CAP_NONE);
        availabilityChanged.clear();
        try {
            automan.adoptShellPermissionIdentity();
            assertFalse(imsRcsManager.isAvailable(RCS_CAP_OPTIONS, radioTechLTE));
            assertFalse(imsRcsManager.isAvailable(RCS_CAP_PRESENCE, radioTechLTE));
        } finally {
            automan.dropShellPermissionIdentity();
        }

        // Notify capabilities status change to OPTIONS
        RcsImsCapabilities optionsCap = new RcsImsCapabilities(RCS_CAP_OPTIONS);
        sServiceConnector.getCarrierService().getRcsFeature()
                .notifyCapabilitiesStatusChanged(optionsCap);

        // Verify that the callback onAvailabilityChanged is called with OPTIONS
        capCb = waitForResult(availabilityChanged);
        assertEquals(capCb, RCS_CAP_OPTIONS);
        availabilityChanged.clear();
        try {
            automan.adoptShellPermissionIdentity();
            assertTrue(imsRcsManager.isAvailable(RCS_CAP_OPTIONS, radioTechLTE));
        } finally {
            automan.dropShellPermissionIdentity();
        }

        // Notify capabilities status change to PRESENCE
        RcsImsCapabilities presenceCap = new RcsImsCapabilities(RCS_CAP_PRESENCE);
        sServiceConnector.getCarrierService().getRcsFeature()
                .notifyCapabilitiesStatusChanged(presenceCap);

        // Verify that the callback onAvailabilityChanged is called with PRESENCE
        capCb = waitForResult(availabilityChanged);
        assertEquals(capCb, RCS_CAP_PRESENCE);
        availabilityChanged.clear();
        try {
            automan.adoptShellPermissionIdentity();
            assertTrue(imsRcsManager.isAvailable(RCS_CAP_PRESENCE, radioTechLTE));
        } finally {
            automan.dropShellPermissionIdentity();
        }

        // Remove availability changed listener
        try {
            automan.adoptShellPermissionIdentity();
            imsRcsManager.removeOnAvailabilityChangedListener(callback);
        } finally {
            automan.dropShellPermissionIdentity();
        }

        // Notify capabilities status changes again.
        sServiceConnector.getCarrierService().getRcsFeature()
                .notifyCapabilitiesStatusChanged(optionsCap);

        // The callback should not be called because the listener is removed.
        assertTrue(availabilityChanged.isEmpty());

        overrideCarrierConfig(null);
    }"	""	""	"RCS"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.ImsServiceTest"	"testProvisioningManagerConstants"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	"public void testProvisioningManagerConstants() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }

        triggerFrameworkConnectToCarrierImsService();

        ProvisioningManager provisioningManager =
                ProvisioningManager.createForSubscriptionId(sTestSub);

        // This is a little bit gross looking, but on P devices, I can not define classes that
        // extend ProvisioningManager.Callback (because it doesn't exist), so this has to
        // happen as an anon class here.
        LinkedBlockingQueue<Pair<Integer, Integer>> mIntQueue = new LinkedBlockingQueue<>();
        LinkedBlockingQueue<Pair<Integer, String>> mStringQueue = new LinkedBlockingQueue<>();
        ProvisioningManager.Callback callback = new ProvisioningManager.Callback() {
            @Override
            public void onProvisioningIntChanged(int item, int value) {
                mIntQueue.offer(new Pair<>(item, value));
            }

            @Override
            public void onProvisioningStringChanged(int item, String value) {
                mStringQueue.offer(new Pair<>(item, value));
            }
        };

        final UiAutomation automan = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            automan.adoptShellPermissionIdentity();
            provisioningManager.registerProvisioningChangedCallback(getContext().getMainExecutor(),
                    callback);

            verifyStringKey(provisioningManager, mStringQueue,
                    ProvisioningManager.KEY_AMR_CODEC_MODE_SET_VALUES, ""1,2"");
            verifyStringKey(provisioningManager, mStringQueue,
                    ProvisioningManager.KEY_AMR_WB_CODEC_MODE_SET_VALUES, ""1,2"");
            verifyIntKey(provisioningManager, mIntQueue,
                    ProvisioningManager.KEY_SIP_SESSION_TIMER_SEC, 5);
            verifyIntKey(provisioningManager, mIntQueue,
                    ProvisioningManager.KEY_MINIMUM_SIP_SESSION_EXPIRATION_TIMER_SEC, 5);
            verifyIntKey(provisioningManager, mIntQueue,
                    ProvisioningManager.KEY_SIP_INVITE_CANCELLATION_TIMER_MS, 5);
            verifyIntKey(provisioningManager, mIntQueue,
                    ProvisioningManager.KEY_TRANSITION_TO_LTE_DELAY_MS, 5);
            verifyIntKey(provisioningManager, mIntQueue,
                    ProvisioningManager.KEY_ENABLE_SILENT_REDIAL, 0);
            verifyIntKey(provisioningManager, mIntQueue,
                    ProvisioningManager.KEY_T1_TIMER_VALUE_MS, 500);
            verifyIntKey(provisioningManager, mIntQueue,
                    ProvisioningManager.KEY_T2_TIMER_VALUE_MS, 500);
            verifyIntKey(provisioningManager, mIntQueue,
                    ProvisioningManager.KEY_TF_TIMER_VALUE_MS, 500);
            verifyIntKey(provisioningManager, mIntQueue,
                    ProvisioningManager.KEY_VOLTE_PROVISIONING_STATUS, 0);
            verifyIntKey(provisioningManager, mIntQueue,
                    ProvisioningManager.KEY_VT_PROVISIONING_STATUS, 0);
            verifyStringKey(provisioningManager, mStringQueue,
                    ProvisioningManager.KEY_REGISTRATION_DOMAIN_NAME, ""test.com"");
            verifyIntKey(provisioningManager, mIntQueue,
                    ProvisioningManager.KEY_SMS_FORMAT, ProvisioningManager.SMS_FORMAT_3GPP);
            verifyIntKey(provisioningManager, mIntQueue,
                    ProvisioningManager.KEY_SMS_FORMAT, ProvisioningManager.SMS_FORMAT_3GPP2);
            verifyIntKey(provisioningManager, mIntQueue,
                    ProvisioningManager.KEY_SMS_OVER_IP_ENABLED, 0);
            verifyIntKey(provisioningManager, mIntQueue,
                    ProvisioningManager.KEY_RCS_PUBLISH_TIMER_SEC, 5);
            verifyIntKey(provisioningManager, mIntQueue,
                    ProvisioningManager.KEY_RCS_PUBLISH_OFFLINE_AVAILABILITY_TIMER_SEC, 5);
            verifyIntKey(provisioningManager, mIntQueue,
                    ProvisioningManager.KEY_RCS_CAPABILITY_DISCOVERY_ENABLED, 0);
            verifyIntKey(provisioningManager, mIntQueue,
                    ProvisioningManager.KEY_RCS_CAPABILITIES_CACHE_EXPIRATION_SEC, 5);
            verifyIntKey(provisioningManager, mIntQueue,
                    ProvisioningManager.KEY_RCS_CAPABILITIES_CACHE_EXPIRATION_SEC, 5);
            verifyIntKey(provisioningManager, mIntQueue,
                    ProvisioningManager.KEY_RCS_AVAILABILITY_CACHE_EXPIRATION_SEC, 5);
            verifyIntKey(provisioningManager, mIntQueue,
                    ProvisioningManager.KEY_RCS_CAPABILITIES_POLL_INTERVAL_SEC, 5);
            verifyIntKey(provisioningManager, mIntQueue,
                    ProvisioningManager.KEY_RCS_PUBLISH_SOURCE_THROTTLE_MS, 1000);
            verifyIntKey(provisioningManager, mIntQueue,
                    ProvisioningManager.KEY_RCS_MAX_NUM_ENTRIES_IN_RCL, 50);
            verifyIntKey(provisioningManager, mIntQueue,
                    ProvisioningManager.KEY_RCS_CAPABILITY_POLL_LIST_SUB_EXP_SEC, 5);
            verifyIntKey(provisioningManager, mIntQueue,
                    ProvisioningManager.KEY_USE_GZIP_FOR_LIST_SUBSCRIPTION, 0);
            verifyIntKey(provisioningManager, mIntQueue,
                    ProvisioningManager.KEY_EAB_PROVISIONING_STATUS, 0);
            verifyIntKey(provisioningManager, mIntQueue,
                    ProvisioningManager.KEY_VOICE_OVER_WIFI_ROAMING_ENABLED_OVERRIDE, 0);
            verifyIntKey(provisioningManager, mIntQueue,
                    ProvisioningManager.KEY_VOICE_OVER_WIFI_MODE_OVERRIDE, 0);
            verifyIntKey(provisioningManager, mIntQueue,
                    ProvisioningManager.KEY_VOICE_OVER_WIFI_ENABLED_OVERRIDE, 0);
            verifyIntKey(provisioningManager, mIntQueue,
                    ProvisioningManager.KEY_MOBILE_DATA_ENABLED, 0);
            verifyIntKey(provisioningManager, mIntQueue,
                    ProvisioningManager.KEY_VOLTE_USER_OPT_IN_STATUS, 0);
            verifyStringKey(provisioningManager, mStringQueue,
                    ProvisioningManager.KEY_LOCAL_BREAKOUT_PCSCF_ADDRESS, ""local.fun.com"");
            verifyIntKey(provisioningManager, mIntQueue,
                    ProvisioningManager.KEY_SIP_KEEP_ALIVE_ENABLED, 0);
            verifyIntKey(provisioningManager, mIntQueue,
                    ProvisioningManager.KEY_REGISTRATION_RETRY_BASE_TIME_SEC, 0);
            verifyIntKey(provisioningManager, mIntQueue,
                    ProvisioningManager.KEY_REGISTRATION_RETRY_MAX_TIME_SEC, 5);
            verifyIntKey(provisioningManager, mIntQueue,
                    ProvisioningManager.KEY_RTP_SPEECH_START_PORT, 500);
            verifyIntKey(provisioningManager, mIntQueue,
                    ProvisioningManager.KEY_RTP_SPEECH_END_PORT, 600);
            verifyIntKey(provisioningManager, mIntQueue,
                    ProvisioningManager.KEY_SIP_INVITE_REQUEST_TRANSMIT_INTERVAL_MS, 500);
            verifyIntKey(provisioningManager, mIntQueue,
                    ProvisioningManager.KEY_SIP_INVITE_ACK_WAIT_TIME_MS, 500);
            verifyIntKey(provisioningManager, mIntQueue,
                    ProvisioningManager.KEY_SIP_INVITE_RESPONSE_RETRANSMIT_WAIT_TIME_MS, 500);
            verifyIntKey(provisioningManager, mIntQueue,
                    ProvisioningManager.KEY_SIP_NON_INVITE_TRANSACTION_TIMEOUT_TIMER_MS, 500);
            verifyIntKey(provisioningManager, mIntQueue,
                    ProvisioningManager.KEY_SIP_INVITE_RESPONSE_RETRANSMIT_INTERVAL_MS, 500);
            verifyIntKey(provisioningManager, mIntQueue,
                    ProvisioningManager.KEY_SIP_ACK_RECEIPT_WAIT_TIME_MS, 500);
            verifyIntKey(provisioningManager, mIntQueue,
                    ProvisioningManager.KEY_SIP_ACK_RETRANSMIT_WAIT_TIME_MS, 500);
            verifyIntKey(provisioningManager, mIntQueue,
                    ProvisioningManager.KEY_SIP_NON_INVITE_REQUEST_RETRANSMISSION_WAIT_TIME_MS, 500);
            verifyIntKey(provisioningManager, mIntQueue,
                    ProvisioningManager.KEY_SIP_NON_INVITE_RESPONSE_RETRANSMISSION_WAIT_TIME_MS,
                    500);
            verifyIntKey(provisioningManager, mIntQueue,
                    ProvisioningManager.KEY_AMR_WB_OCTET_ALIGNED_PAYLOAD_TYPE, 0);
            verifyIntKey(provisioningManager, mIntQueue,
                    ProvisioningManager.KEY_AMR_WB_BANDWIDTH_EFFICIENT_PAYLOAD_TYPE, 0);
            verifyIntKey(provisioningManager, mIntQueue,
                    ProvisioningManager.KEY_AMR_OCTET_ALIGNED_PAYLOAD_TYPE, 0);
            verifyIntKey(provisioningManager, mIntQueue,
                    ProvisioningManager.KEY_AMR_BANDWIDTH_EFFICIENT_PAYLOAD_TYPE, 0);
            verifyIntKey(provisioningManager, mIntQueue,
                    ProvisioningManager.KEY_DTMF_WB_PAYLOAD_TYPE, 0);
            verifyIntKey(provisioningManager, mIntQueue,
                    ProvisioningManager.KEY_DTMF_NB_PAYLOAD_TYPE, 0);
            verifyIntKey(provisioningManager, mIntQueue,
                    ProvisioningManager.KEY_AMR_DEFAULT_ENCODING_MODE, 0);
            verifyIntKey(provisioningManager, mIntQueue,
                    ProvisioningManager.KEY_SMS_PUBLIC_SERVICE_IDENTITY, 0);
            verifyStringKey(provisioningManager, mStringQueue,
                    ProvisioningManager.KEY_SMS_PUBLIC_SERVICE_IDENTITY, ""local.fun.com"");
            verifyIntKey(provisioningManager, mIntQueue,
                    ProvisioningManager.KEY_VIDEO_QUALITY, ProvisioningManager.VIDEO_QUALITY_HIGH);
            verifyIntKey(provisioningManager, mIntQueue,
                    ProvisioningManager.KEY_VIDEO_QUALITY, ProvisioningManager.VIDEO_QUALITY_LOW);
            verifyIntKey(provisioningManager, mIntQueue,
                    ProvisioningManager.KEY_LTE_THRESHOLD_1, 0);
            verifyIntKey(provisioningManager, mIntQueue,
                    ProvisioningManager.KEY_LTE_THRESHOLD_2, 0);
            verifyIntKey(provisioningManager, mIntQueue,
                    ProvisioningManager.KEY_LTE_THRESHOLD_3, 0);
            verifyIntKey(provisioningManager, mIntQueue,
                    ProvisioningManager.KEY_1X_THRESHOLD, 0);
            verifyIntKey(provisioningManager, mIntQueue,
                    ProvisioningManager.KEY_WIFI_THRESHOLD_A, 0);
            verifyIntKey(provisioningManager, mIntQueue,
                    ProvisioningManager.KEY_WIFI_THRESHOLD_B, 0);
            verifyIntKey(provisioningManager, mIntQueue,
                    ProvisioningManager.KEY_LTE_EPDG_TIMER_SEC, 5);
            verifyIntKey(provisioningManager, mIntQueue,
                    ProvisioningManager.KEY_WIFI_EPDG_TIMER_SEC, 5);
            verifyIntKey(provisioningManager, mIntQueue,
                    ProvisioningManager.KEY_1X_EPDG_TIMER_SEC, 5);
            verifyIntKey(provisioningManager, mIntQueue,
                    ProvisioningManager.KEY_MULTIENDPOINT_ENABLED, 0);
            verifyIntKey(provisioningManager, mIntQueue,
                    ProvisioningManager.KEY_RTT_ENABLED, 0);
            verifyStringKey(provisioningManager, mStringQueue,
                    ProvisioningManager.KEY_VOICE_OVER_WIFI_ENTITLEMENT_ID, ""carrier_spec"");

            automan.adoptShellPermissionIdentity();
            provisioningManager.unregisterProvisioningChangedCallback(callback);
        } finally {
            automan.dropShellPermissionIdentity();
        }
    }"	""	""	"RCS"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.ImsServiceTest"	"testProvisioningManagerRcsProvisioningCaps"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	"public void testProvisioningManagerRcsProvisioningCaps() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }

        triggerFrameworkConnectToCarrierImsService();

        PersistableBundle bundle = new PersistableBundle();
        bundle.putBoolean(CarrierConfigManager.Ims.KEY_ENABLE_PRESENCE_PUBLISH_BOOL, true);
        bundle.putBoolean(CarrierConfigManager.Ims.KEY_ENABLE_PRESENCE_CAPABILITY_EXCHANGE_BOOL,
                true);
        bundle.putBoolean(CarrierConfigManager.Ims.KEY_RCS_BULK_CAPABILITY_EXCHANGE_BOOL, true);
        bundle.putBoolean(CarrierConfigManager.KEY_CARRIER_RCS_PROVISIONING_REQUIRED_BOOL, true);
        overrideCarrierConfig(bundle);

        ProvisioningManager provisioningManager =
                ProvisioningManager.createForSubscriptionId(sTestSub);

        final UiAutomation automan = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            automan.adoptShellPermissionIdentity();
            boolean provisioningStatus = provisioningManager.getRcsProvisioningStatusForCapability(
                    RCS_CAP_PRESENCE);
            provisioningManager.setRcsProvisioningStatusForCapability(RCS_CAP_PRESENCE,
                    !provisioningStatus);
            // Make sure the change in provisioning status is correctly returned.
            assertEquals(!provisioningStatus,
                    provisioningManager.getRcsProvisioningStatusForCapability(RCS_CAP_PRESENCE));
            // TODO: Enhance test to make sure the provisioning change is also sent to the
            // ImsService

            // set back to current status
            provisioningManager.setRcsProvisioningStatusForCapability(RCS_CAP_PRESENCE,
                    provisioningStatus);
        } finally {
            automan.dropShellPermissionIdentity();
        }

        overrideCarrierConfig(null);
    }"	""	""	"RCS"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.ImsServiceTest"	"testProvisioningManagerRcsProvisioningChangedCallback"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	"public void testProvisioningManagerRcsProvisioningChangedCallback() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }

        triggerFrameworkConnectToLocalImsServiceBindRcsFeature();

        final int errorCode = 403;
        final String errorString = ""Forbidden"";
        final UiAutomation automan = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        LinkedBlockingQueue<Integer> actionQueue = new LinkedBlockingQueue<>();
        LinkedBlockingQueue<RcsProvisioningCallbackParams> paramsQueue =
                new LinkedBlockingQueue<>();
        ProvisioningManager.RcsProvisioningCallback cb =
                buildRcsProvisioningCallback(actionQueue, paramsQueue);
        ProvisioningManager provisioningManager =
                ProvisioningManager.createForSubscriptionId(sTestSub);
        ImsConfigImplBase config = sServiceConnector.getCarrierService().getConfig();

        //notify rcs configuration received, wait rcs gets ready and receives notification
        try {
            automan.adoptShellPermissionIdentity();
            provisioningManager.notifyRcsAutoConfigurationReceived(
                    TEST_RCS_CONFIG_DEFAULT.getBytes(), false);
        } finally {
            automan.dropShellPermissionIdentity();
        }

        int res = waitForIntResult(TestAcsClient.getInstance().getActionQueue());
        assertEquals(res, TestAcsClient.ACTION_CONFIG_CHANGED);

        try {
            automan.adoptShellPermissionIdentity();
            provisioningManager.registerRcsProvisioningCallback(
                    getContext().getMainExecutor(), cb);
        } finally {
            automan.dropShellPermissionIdentity();
        }

        //callback is expected immediately
        res = waitForIntResult(actionQueue);
        assertEquals(res, RCS_CONFIG_CB_CHANGED);
        RcsProvisioningCallbackParams params = waitForResult(paramsQueue);
        assertNotNull(params);
        assertTrue(Arrays.equals(params.mConfig, TEST_RCS_CONFIG_DEFAULT.getBytes()));

        //verify callback when rcs configuration removed
        config.getIImsConfig().notifyRcsAutoConfigurationRemoved();
        res = waitForIntResult(actionQueue);
        assertEquals(res, RCS_CONFIG_CB_RESET);

        //verify callback when rcs configuration received, compressed
        config.getIImsConfig().notifyRcsAutoConfigurationReceived(
                ImsUtils.compressGzip(TEST_RCS_CONFIG_DEFAULT.getBytes()), true);

        res = waitForIntResult(actionQueue);
        assertEquals(res, RCS_CONFIG_CB_CHANGED);
        params = waitForResult(paramsQueue);
        assertNotNull(params);
        assertTrue(Arrays.equals(params.mConfig, TEST_RCS_CONFIG_DEFAULT.getBytes()));

        //verify callback when auto config error received
        config.notifyAutoConfigurationErrorReceived(errorCode, errorString);
        res = waitForIntResult(actionQueue);
        assertEquals(res, RCS_CONFIG_CB_ERROR);
        params = waitForResult(paramsQueue);
        assertNotNull(params);
        assertTrue(params.mErrorCode != null && params.mErrorCode == errorCode);
        assertTrue(errorString.equals(params.mErrorString));

        //verify callback when config removed
        config.getIImsConfig().notifyRcsAutoConfigurationRemoved();
        res = waitForIntResult(actionQueue);
        assertEquals(res, RCS_CONFIG_CB_RESET);

        //verify callback when rcs pre-provisioning configuration received
        TestAcsClient.getInstance().notifyPreProvisioning(TEST_RCS_PRE_CONFIG.getBytes());

        res = waitForIntResult(actionQueue);
        assertEquals(res, RCS_CONFIG_CB_PREPROV);
        params = waitForResult(paramsQueue);
        assertNotNull(params);
        assertTrue(Arrays.equals(params.mConfig, TEST_RCS_PRE_CONFIG.getBytes()));

        //unregister callback and verify not to receive callback any more
        try {
            automan.adoptShellPermissionIdentity();
            provisioningManager.unregisterRcsProvisioningCallback(cb);
        } finally {
            automan.dropShellPermissionIdentity();
        }
        res = waitForIntResult(actionQueue);
        assertEquals(res, RCS_CONFIG_CB_DELETE);

        config.notifyAutoConfigurationErrorReceived(errorCode, errorString);
        res = waitForIntResult(actionQueue, 500);
        assertEquals(res, Integer.MAX_VALUE);
    }"	""	""	"RCS"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.ImsServiceTest"	"testProvisioningManagerNotifyRcsAutoConfigurationReceived"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	"public void testProvisioningManagerNotifyRcsAutoConfigurationReceived() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }

        triggerFrameworkConnectToLocalImsServiceBindRcsFeature();

        final UiAutomation automan = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        LinkedBlockingQueue<Integer> clientQueue = new LinkedBlockingQueue<>();
        LinkedBlockingQueue<RcsProvisioningCallbackParams> paramsQueue =
                new LinkedBlockingQueue<>();
        ProvisioningManager.RcsProvisioningCallback cb =
                buildRcsProvisioningCallback(clientQueue, paramsQueue);
        ProvisioningManager provisioningManager =
                ProvisioningManager.createForSubscriptionId(sTestSub);
        String configStr = TEST_RCS_CONFIG_DEFAULT;

        //notify rcs configuration received, wait rcs gets ready and receives notification
        try {
            automan.adoptShellPermissionIdentity();
            provisioningManager.notifyRcsAutoConfigurationReceived(
                    configStr.getBytes(), false);
        } finally {
            automan.dropShellPermissionIdentity();
        }

        int res = waitForIntResult(TestAcsClient.getInstance().getActionQueue());
        assertEquals(res, TestAcsClient.ACTION_CONFIG_CHANGED);

        try {
            automan.adoptShellPermissionIdentity();
            provisioningManager.registerRcsProvisioningCallback(
                    getContext().getMainExecutor(), cb);
        } finally {
            automan.dropShellPermissionIdentity();
        }

        res = waitForIntResult(clientQueue);
        assertEquals(res, RCS_CONFIG_CB_CHANGED);
        RcsProvisioningCallbackParams params = waitForResult(paramsQueue);
        assertNotNull(params);
        assertTrue(Arrays.equals(params.mConfig, configStr.getBytes()));
        assertTrue(Arrays.equals(
                configStr.getBytes(), TestAcsClient.getInstance().getConfig()));

        configStr = TEST_RCS_CONFIG_SINGLE_REGISTRATION_DISABLED;
        try {
            automan.adoptShellPermissionIdentity();
            provisioningManager.notifyRcsAutoConfigurationReceived(
                    ImsUtils.compressGzip(configStr.getBytes()), true);
        } finally {
            automan.dropShellPermissionIdentity();
        }

        res = waitForIntResult(clientQueue);
        assertEquals(res, RCS_CONFIG_CB_CHANGED);
        params = waitForResult(paramsQueue);
        assertNotNull(params);
        assertTrue(Arrays.equals(params.mConfig, configStr.getBytes()));

        res = waitForIntResult(TestAcsClient.getInstance().getActionQueue());
        assertEquals(res, TestAcsClient.ACTION_CONFIG_CHANGED);
        assertTrue(Arrays.equals(
                configStr.getBytes(), TestAcsClient.getInstance().getConfig()));
    }"	""	""	"RCS"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.ImsServiceTest"	"testProvisioningManagerTriggerRcsReconfiguration"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	"public void testProvisioningManagerTriggerRcsReconfiguration() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }

        triggerFrameworkConnectToLocalImsServiceBindRcsFeature();

        final UiAutomation automan = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        LinkedBlockingQueue<Integer> clientQueue = new LinkedBlockingQueue<>();
        ProvisioningManager.RcsProvisioningCallback cb =
                buildRcsProvisioningCallback(clientQueue, null);

        ProvisioningManager provisioningManager =
                ProvisioningManager.createForSubscriptionId(sTestSub);

        //notify rcs configuration received, wait rcs gets ready and receives notification
        try {
            automan.adoptShellPermissionIdentity();
            provisioningManager.notifyRcsAutoConfigurationReceived(
                    TEST_RCS_CONFIG_DEFAULT.getBytes(), false);
        } finally {
            automan.dropShellPermissionIdentity();
        }

        int res = waitForIntResult(TestAcsClient.getInstance().getActionQueue());
        assertEquals(res, TestAcsClient.ACTION_CONFIG_CHANGED);

        //set default rcs config
        try {
            automan.adoptShellPermissionIdentity();
            provisioningManager.registerRcsProvisioningCallback(
                    getContext().getMainExecutor(), cb);
        } finally {
            automan.dropShellPermissionIdentity();
        }

        res = waitForIntResult(clientQueue);
        assertEquals(res, RCS_CONFIG_CB_CHANGED);

        //test triggerRcsReconfiguration
        try {
            automan.adoptShellPermissionIdentity();
            provisioningManager.triggerRcsReconfiguration();
        } finally {
            automan.dropShellPermissionIdentity();
        }

        res = waitForIntResult(clientQueue);
        assertEquals(res, RCS_CONFIG_CB_RESET);

        res = waitForIntResult(TestAcsClient.getInstance().getActionQueue());
        assertEquals(res, TestAcsClient.ACTION_CONFIG_REMOVED);

        res = waitForIntResult(TestAcsClient.getInstance().getActionQueue());
        assertEquals(res, TestAcsClient.ACTION_TRIGGER_AUTO_CONFIG);
    }"	""	""	"RCS"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.ImsServiceTest"	"testProvisioningManagerSetRcsClientConfiguration"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	"public void testProvisioningManagerSetRcsClientConfiguration() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        RcsClientConfiguration rcc = new RcsClientConfiguration(
                ""1.0"", ""UP_1.0"", ""Android"", ""RCSAndrd-1.0"");
        triggerFrameworkConnectToLocalImsServiceBindRcsFeature();

        final UiAutomation automan = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        ProvisioningManager provisioningManager =
                ProvisioningManager.createForSubscriptionId(sTestSub);

        //notify rcs configuration received, wait rcs gets ready and receives notification
        try {
            automan.adoptShellPermissionIdentity();
            provisioningManager.notifyRcsAutoConfigurationReceived(
                    TEST_RCS_CONFIG_DEFAULT.getBytes(), false);
        } finally {
            automan.dropShellPermissionIdentity();
        }

        int res = waitForIntResult(TestAcsClient.getInstance().getActionQueue());
        assertEquals(res, TestAcsClient.ACTION_CONFIG_CHANGED);

        try {
            automan.adoptShellPermissionIdentity();
            provisioningManager.setRcsClientConfiguration(rcc);
        } finally {
            automan.dropShellPermissionIdentity();
        }

        res = waitForIntResult(TestAcsClient.getInstance().getActionQueue());
        assertEquals(res, TestAcsClient.ACTION_SET_RCS_CLIENT_CONFIG);
        assertEquals(rcc, TestAcsClient.getInstance().getRcc());
    }"	""	""	"RCS"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.ImsServiceTest"	"testProvisioningManagerRcsVolteSingleRegistrationCapable"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	"public void testProvisioningManagerRcsVolteSingleRegistrationCapable() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        triggerFrameworkConnectToLocalImsServiceBindRcsFeature();

        final UiAutomation automan = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        boolean isSingleRegistrationEnabledOnDevice =
                sServiceConnector.getDeviceSingleRegistrationEnabled();
        boolean isSingleRegistrationEnabledByCarrier =
                sServiceConnector.getCarrierSingleRegistrationEnabled();

        ProvisioningManager provisioningManager =
                ProvisioningManager.createForSubscriptionId(sTestSub);
        PersistableBundle bundle = new PersistableBundle();
        bundle.putBoolean(
                CarrierConfigManager.Ims.KEY_IMS_SINGLE_REGISTRATION_REQUIRED_BOOL,
                !isSingleRegistrationEnabledByCarrier);
        sSrcReceiver.clearQueue();
        overrideCarrierConfig(bundle);
        sSrcReceiver.waitForChanged();
        int capability = sSrcReceiver.getCapability();

        assertEquals(!isSingleRegistrationEnabledByCarrier,
                (ProvisioningManager.STATUS_CARRIER_NOT_CAPABLE & capability) == 0);
        try {
            automan.adoptShellPermissionIdentity();
            assertEquals(provisioningManager.isRcsVolteSingleRegistrationCapable(),
                    isSingleRegistrationEnabledOnDevice && !isSingleRegistrationEnabledByCarrier);
        } finally {
            automan.dropShellPermissionIdentity();
        }

        bundle = new PersistableBundle();
        bundle.putBoolean(CarrierConfigManager.Ims.KEY_IMS_SINGLE_REGISTRATION_REQUIRED_BOOL,
                isSingleRegistrationEnabledByCarrier);
        sSrcReceiver.clearQueue();
        overrideCarrierConfig(bundle);
        sSrcReceiver.waitForChanged();
        capability = sSrcReceiver.getCapability();

        assertEquals(isSingleRegistrationEnabledByCarrier,
                (ProvisioningManager.STATUS_CARRIER_NOT_CAPABLE & capability) == 0);
        try {
            automan.adoptShellPermissionIdentity();
            assertEquals(provisioningManager.isRcsVolteSingleRegistrationCapable(),
                    isSingleRegistrationEnabledOnDevice && isSingleRegistrationEnabledByCarrier);
        } finally {
            automan.dropShellPermissionIdentity();
        }

        sSrcReceiver.clearQueue();
        sServiceConnector.setDeviceSingleRegistrationEnabled(!isSingleRegistrationEnabledOnDevice);
        sSrcReceiver.waitForChanged();
        capability = sSrcReceiver.getCapability();

        assertEquals(!isSingleRegistrationEnabledOnDevice,
                (ProvisioningManager.STATUS_DEVICE_NOT_CAPABLE & capability) == 0);
        try {
            automan.adoptShellPermissionIdentity();
            assertEquals(provisioningManager.isRcsVolteSingleRegistrationCapable(),
                    !isSingleRegistrationEnabledOnDevice && isSingleRegistrationEnabledByCarrier);
        } finally {
            automan.dropShellPermissionIdentity();
        }

        sSrcReceiver.clearQueue();
        sServiceConnector.setDeviceSingleRegistrationEnabled(isSingleRegistrationEnabledOnDevice);
        sSrcReceiver.waitForChanged();
        capability = sSrcReceiver.getCapability();

        assertEquals(isSingleRegistrationEnabledOnDevice,
                (ProvisioningManager.STATUS_DEVICE_NOT_CAPABLE & capability) == 0);
        try {
            automan.adoptShellPermissionIdentity();
            assertEquals(provisioningManager.isRcsVolteSingleRegistrationCapable(),
                    isSingleRegistrationEnabledOnDevice && isSingleRegistrationEnabledByCarrier);
        } finally {
            automan.dropShellPermissionIdentity();
        }

        sServiceConnector.setDeviceSingleRegistrationEnabled(null);
        overrideCarrierConfig(null);
        sSrcReceiver.waitForChanged();
        capability = sSrcReceiver.getCapability();

        assertEquals(isSingleRegistrationEnabledOnDevice,
                (ProvisioningManager.STATUS_DEVICE_NOT_CAPABLE & capability) == 0);
        assertEquals(isSingleRegistrationEnabledByCarrier,
                (ProvisioningManager.STATUS_CARRIER_NOT_CAPABLE & capability) == 0);
    }

    /**
     * Verifies that the RTP header extensions are set as expected when D2D communication is
     * available on the device and for the current carrier.
     * @throws Exception
     */"	""	""	"RCS"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.ImsServiceTest"	"testImsRcsManagerImsStateCallback"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	"public void testImsRcsManagerImsStateCallback() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }

        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        if (imsManager == null) {
            fail(""Cannot find IMS service"");
        }

        LinkedBlockingQueue<Integer> rcsQueue = new LinkedBlockingQueue<>();
        ImsStateCallback rcsCallback = buildImsStateCallback(rcsQueue);

        LinkedBlockingQueue<Integer> sipQueue = new LinkedBlockingQueue<>();
        ImsStateCallback sipCallback = buildImsStateCallback(sipQueue);

        ImsRcsManager imsRcsManager;
        SipDelegateManager imsSipManager;
        final UiAutomation automan = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            automan.adoptShellPermissionIdentity();
            imsRcsManager = imsManager.getImsRcsManager(sTestSub);
            imsRcsManager.registerImsStateCallback(getContext().getMainExecutor(), rcsCallback);
            imsSipManager = imsManager.getSipDelegateManager(sTestSub);
            imsSipManager.registerImsStateCallback(getContext().getMainExecutor(), sipCallback);
        } finally {
            automan.dropShellPermissionIdentity();
        }

        int reason = waitForIntResult(rcsQueue);
        assertTrue(reason == ImsStateCallback.REASON_UNKNOWN_TEMPORARY_ERROR
                || reason == ImsStateCallback.REASON_UNKNOWN_PERMANENT_ERROR
                || reason == ImsStateCallback.REASON_IMS_SERVICE_DISCONNECTED
                || reason == ImsStateCallback.REASON_NO_IMS_SERVICE_CONFIGURED
                || reason == ImsStateCallback.REASON_SUBSCRIPTION_INACTIVE
                || reason == ImsStateCallback.REASON_IMS_SERVICE_NOT_READY);

        reason = waitForIntResult(sipQueue);
        assertTrue(reason == ImsStateCallback.REASON_UNKNOWN_TEMPORARY_ERROR
                || reason == ImsStateCallback.REASON_UNKNOWN_PERMANENT_ERROR
                || reason == ImsStateCallback.REASON_IMS_SERVICE_DISCONNECTED
                || reason == ImsStateCallback.REASON_NO_IMS_SERVICE_CONFIGURED
                || reason == ImsStateCallback.REASON_SUBSCRIPTION_INACTIVE
                || reason == ImsStateCallback.REASON_IMS_SERVICE_NOT_READY);

        imsRcsManager.unregisterImsStateCallback(rcsCallback);
        imsSipManager.unregisterImsStateCallback(sipCallback);

        // Override the carrier config
        PersistableBundle bundle = new PersistableBundle();
        bundle.putBoolean(CarrierConfigManager.Ims.KEY_ENABLE_PRESENCE_PUBLISH_BOOL, false);
        bundle.putBoolean(
                CarrierConfigManager.Ims.KEY_IMS_SINGLE_REGISTRATION_REQUIRED_BOOL, false);
        overrideCarrierConfig(bundle);

        // Connect to device ImsService with RcsFeature
        triggerFrameworkConnectToLocalImsServiceBindRcsFeature();

        rcsQueue = new LinkedBlockingQueue<>();
        rcsCallback = buildImsStateCallback(rcsQueue);

        sipQueue = new LinkedBlockingQueue<>();
        sipCallback = buildImsStateCallback(sipQueue);

        try {
            automan.adoptShellPermissionIdentity();
            imsRcsManager.registerImsStateCallback(getContext().getMainExecutor(), rcsCallback);
            imsSipManager.registerImsStateCallback(getContext().getMainExecutor(), sipCallback);
        } finally {
            automan.dropShellPermissionIdentity();
        }

        // expects FEATURE_RCS, NO_IMS_SERVICE_CONFIGURED
        assertEquals(ImsStateCallback.REASON_NO_IMS_SERVICE_CONFIGURED,
                waitForIntResult(rcsQueue));
        assertEquals(ImsStateCallback.REASON_NO_IMS_SERVICE_CONFIGURED,
                waitForIntResult(sipQueue));

        // Override the carrier config
        bundle = new PersistableBundle();
        bundle.putBoolean(CarrierConfigManager.Ims.KEY_ENABLE_PRESENCE_PUBLISH_BOOL, true);
        overrideCarrierConfig(bundle);

        // Wait for the framework to set the capabilities on the ImsService
        sServiceConnector.getCarrierService().waitForLatchCountdown(
                TestImsService.LATCH_RCS_CAP_SET);

        // expects FEATURE_RCS, STATE_READY
        assertEquals(FEATURE_STATE_READY, waitForIntResult(rcsQueue));
        assertEquals(FEATURE_STATE_READY, waitForIntResult(sipQueue));

        bundle = new PersistableBundle();
        bundle.putBoolean(CarrierConfigManager.Ims.KEY_ENABLE_PRESENCE_PUBLISH_BOOL, false);
        overrideCarrierConfig(bundle);

        // expects FEATURE_RCS, NO_IMS_SERVICE_CONFIGURED
        assertEquals(ImsStateCallback.REASON_NO_IMS_SERVICE_CONFIGURED,
                waitForIntResult(rcsQueue));
        assertEquals(ImsStateCallback.REASON_NO_IMS_SERVICE_CONFIGURED,
                waitForIntResult(sipQueue));

        // Override the carrier config
        bundle = new PersistableBundle();
        bundle.putBoolean(
                CarrierConfigManager.Ims.KEY_IMS_SINGLE_REGISTRATION_REQUIRED_BOOL, true);
        overrideCarrierConfig(bundle);

        // expects FEATURE_RCS, STATE_READY
        assertEquals(FEATURE_STATE_READY, waitForIntResult(rcsQueue));
        assertEquals(FEATURE_STATE_READY, waitForIntResult(sipQueue));

        bundle = new PersistableBundle();
        bundle.putBoolean(
                CarrierConfigManager.Ims.KEY_IMS_SINGLE_REGISTRATION_REQUIRED_BOOL, false);
        overrideCarrierConfig(bundle);

        // expects FEATURE_RCS, NO_IMS_SERVICE_CONFIGURED
        assertEquals(ImsStateCallback.REASON_NO_IMS_SERVICE_CONFIGURED,
                waitForIntResult(rcsQueue));
        assertEquals(ImsStateCallback.REASON_NO_IMS_SERVICE_CONFIGURED,
                waitForIntResult(sipQueue));

        // Override the carrier config
        bundle = new PersistableBundle();
        bundle.putBoolean(CarrierConfigManager.Ims.KEY_ENABLE_PRESENCE_PUBLISH_BOOL, true);
        bundle.putBoolean(
                CarrierConfigManager.Ims.KEY_IMS_SINGLE_REGISTRATION_REQUIRED_BOOL, true);
        overrideCarrierConfig(bundle);

        // expects FEATURE_RCS, STATE_READY
        assertEquals(FEATURE_STATE_READY, waitForIntResult(rcsQueue));
        assertEquals(FEATURE_STATE_READY, waitForIntResult(sipQueue));

        bundle = new PersistableBundle();
        bundle.putBoolean(
                CarrierConfigManager.Ims.KEY_IMS_SINGLE_REGISTRATION_REQUIRED_BOOL, false);
        overrideCarrierConfig(bundle);

        // ensure no change in state since having one active feature
        reason = waitForIntResult(rcsQueue, 3000);
        assertEquals(Integer.MAX_VALUE, reason);
        reason = waitForIntResult(sipQueue, 1000);
        assertEquals(Integer.MAX_VALUE, reason);

        bundle = new PersistableBundle();
        bundle.putBoolean(CarrierConfigManager.Ims.KEY_ENABLE_PRESENCE_PUBLISH_BOOL, false);
        overrideCarrierConfig(bundle);

        // expects FEATURE_RCS, NO_IMS_SERVICE_CONFIGURED
        assertEquals(ImsStateCallback.REASON_NO_IMS_SERVICE_CONFIGURED,
                waitForIntResult(rcsQueue));
        assertEquals(ImsStateCallback.REASON_NO_IMS_SERVICE_CONFIGURED,
                waitForIntResult(sipQueue));

        // Override the carrier config
        bundle = new PersistableBundle();
        bundle.putBoolean(CarrierConfigManager.Ims.KEY_ENABLE_PRESENCE_PUBLISH_BOOL, true);
        overrideCarrierConfig(bundle);

        // expects FEATURE_RCS, STATE_READY
        assertEquals(FEATURE_STATE_READY, waitForIntResult(rcsQueue));
        assertEquals(FEATURE_STATE_READY, waitForIntResult(sipQueue));

        if (sServiceConnector != null) {
            sServiceConnector.getCarrierService().getRcsFeature().setFeatureState(
                    ImsFeature.STATE_INITIALIZING);
        }

        // expects NOT_READY
        assertEquals(ImsStateCallback.REASON_IMS_SERVICE_NOT_READY,
                waitForIntResult(rcsQueue));
        assertEquals(ImsStateCallback.REASON_IMS_SERVICE_NOT_READY,
                waitForIntResult(sipQueue));

        // Unbind the GTS ImsService
        if (sServiceConnector != null) {
            sServiceConnector.disconnectCarrierImsService();
        }

        // expects DISCONNECTED
        assertEquals(ImsStateCallback.REASON_IMS_SERVICE_DISCONNECTED,
                waitForIntResult(rcsQueue));
        assertEquals(ImsStateCallback.REASON_IMS_SERVICE_DISCONNECTED,
                waitForIntResult(sipQueue));

        imsRcsManager.unregisterImsStateCallback(rcsCallback);
        imsSipManager.unregisterImsStateCallback(sipCallback);
    }

    private void verifyIntKey(ProvisioningManager pm,
            LinkedBlockingQueue<Pair<Integer, Integer>> intQueue, int key, int value)
            throws Exception {
        pm.setProvisioningIntValue(key, value);
        assertTrue(waitForParam(intQueue, new Pair<>(key, value)));
        assertEquals(value, pm.getProvisioningIntValue(key));
    }

    private void verifyStringKey(ProvisioningManager pm,
            LinkedBlockingQueue<Pair<Integer, String>> strQueue, int key, String value)
            throws Exception {
        pm.setProvisioningStringValue(key, value);
        assertTrue(waitForParam(strQueue, new Pair<>(key, value)));
        assertEquals(value, pm.getProvisioningStringValue(key));
    }

    private void setupImsServiceForSms() throws Exception {
        MmTelFeature.MmTelCapabilities capabilities = new MmTelFeature.MmTelCapabilities(
                MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_SMS);
        // Set up MMTEL
        assertTrue(sServiceConnector.connectCarrierImsService(new ImsFeatureConfiguration.Builder()
                .addFeature(sTestSlot, ImsFeature.FEATURE_MMTEL)
                .build()));
        // Wait until MMTEL is created and onFeatureReady is called
        assertTrue(sServiceConnector.getCarrierService().waitForLatchCountdown(
                TestImsService.LATCH_CREATE_MMTEL));
        assertTrue(sServiceConnector.getCarrierService().waitForLatchCountdown(
                TestImsService.LATCH_MMTEL_READY));
        int serviceSlot = sServiceConnector.getCarrierService().getMmTelFeature().getSlotIndex();
        assertEquals(""The slot specified for the test ("" + sTestSlot + "") does not match the ""
                        + ""assigned slot ("" + serviceSlot + ""+ for the associated MmTelFeature"",
                sTestSlot, serviceSlot);
        // Wait until ImsSmsDispatcher connects and calls onReady.
        assertTrue(sServiceConnector.getCarrierService().getMmTelFeature().getSmsImplementation()
                .waitForOnReadyLatch());
        // Set Registered and SMS capable
        sServiceConnector.getCarrierService().getMmTelFeature().setCapabilities(capabilities);
        sServiceConnector.getCarrierService().getImsService().getRegistration(0).onRegistered(1);
        sServiceConnector.getCarrierService().getMmTelFeature()
                .notifyCapabilitiesStatusChanged(capabilities);

        // Wait a second for the notifyCapabilitiesStatusChanged indication to be processed on the
        // main telephony thread - currently no better way of knowing that telephony has processed
        // this command. SmsManager#isImsSmsSupported() is @hide and must be updated to use new API.
        Thread.sleep(1000);
    }

    private void triggerFrameworkConnectToLocalImsServiceBindRcsFeature() throws Exception {
        // Connect to the ImsService with the RCS feature.
        assertTrue(sServiceConnector.connectCarrierImsService(new ImsFeatureConfiguration.Builder()
                .addFeature(sTestSlot, ImsFeature.FEATURE_RCS)
                .build()));
        // The RcsFeature is created when the ImsService is bound. If it wasn't created, then the
        // Framework did not call it.
        assertTrue(""Did not receive createRcsFeature"", sServiceConnector.getCarrierService()
                .waitForLatchCountdown(TestImsService.LATCH_CREATE_RCS));
        assertTrue(""Did not receive RcsFeature#onReady"", sServiceConnector.getCarrierService()
                .waitForLatchCountdown(TestImsService.LATCH_RCS_READY));
        // Make sure the RcsFeature was created in the test service.
        assertNotNull(""Device ImsService created, but TestDeviceImsService#createRcsFeature was not""
                + ""called!"", sServiceConnector.getCarrierService().getRcsFeature());
        int serviceSlot = sServiceConnector.getCarrierService().getRcsFeature().getSlotIndex();
        assertEquals(""The slot specified for the test ("" + sTestSlot + "") does not match the ""
                        + ""assigned slot ("" + serviceSlot + ""+ for the associated RcsFeature"",
                sTestSlot, serviceSlot);
    }

    private void triggerFrameworkConnectToImsServiceBindMmTelAndRcsFeature() throws Exception {
        // Connect to the ImsService with the RCS feature.
        assertTrue(sServiceConnector.connectCarrierImsService(new ImsFeatureConfiguration.Builder()
                .addFeature(sTestSlot, ImsFeature.FEATURE_MMTEL)
                .addFeature(sTestSlot, ImsFeature.FEATURE_RCS)
                .build()));

        // The MmTelFeature is created when the ImsService is bound. If it wasn't created, then the
        // Framework did not call it.
        assertTrue(""Did not receive createMmTelFeature"", sServiceConnector.getCarrierService()
                .waitForLatchCountdown(TestImsService.LATCH_CREATE_MMTEL));
        assertTrue(""Did not receive MmTelFeature#onReady"", sServiceConnector.getCarrierService()
                .waitForLatchCountdown(TestImsService.LATCH_MMTEL_READY));
        assertNotNull(""ImsService created, but ImsService#createMmTelFeature was not called!"",
                sServiceConnector.getCarrierService().getMmTelFeature());
        int serviceSlot = sServiceConnector.getCarrierService().getMmTelFeature().getSlotIndex();
        assertEquals(""The slot specified for the test ("" + sTestSlot + "") does not match the ""
                        + ""assigned slot ("" + serviceSlot + ""+ for the associated MmTelFeature"",
                sTestSlot, serviceSlot);

        // The RcsFeature is created when the ImsService is bound. If it wasn't created, then the
        // Framework did not call it.
        assertTrue(""Did not receive createRcsFeature"", sServiceConnector.getCarrierService()
                .waitForLatchCountdown(TestImsService.LATCH_CREATE_RCS));
        assertTrue(""Did not receive RcsFeature#onReady"", sServiceConnector.getCarrierService()
                .waitForLatchCountdown(TestImsService.LATCH_RCS_READY));
        // Make sure the RcsFeature was created in the test service.
        assertNotNull(""Device ImsService created, but TestDeviceImsService#createRcsFeature was not""
                + ""called!"", sServiceConnector.getCarrierService().getRcsFeature());
        assertTrue(""Did not receive RcsFeature#setCapabilityExchangeEventListener"",
                sServiceConnector.getCarrierService().waitForLatchCountdown(
                        TestImsService.LATCH_UCE_LISTENER_SET));
        serviceSlot = sServiceConnector.getCarrierService().getRcsFeature().getSlotIndex();
        assertEquals(""The slot specified for the test ("" + sTestSlot + "") does not match the ""
                        + ""assigned slot ("" + serviceSlot + ""+ for the associated RcsFeature"",
                sTestSlot, serviceSlot);
    }

    private void triggerFrameworkConnectToCarrierImsService() throws Exception {
        // Connect to the ImsService with the MmTel feature.
        assertTrue(sServiceConnector.connectCarrierImsService(new ImsFeatureConfiguration.Builder()
                .addFeature(sTestSlot, ImsFeature.FEATURE_MMTEL)
                .build()));
        // The MmTelFeature is created when the ImsService is bound. If it wasn't created, then the
        // Framework did not call it.
        assertTrue(""Did not receive createMmTelFeature"", sServiceConnector.getCarrierService()
                .waitForLatchCountdown(TestImsService.LATCH_CREATE_MMTEL));
        assertTrue(""Did not receive MmTelFeature#onReady"", sServiceConnector.getCarrierService()
                .waitForLatchCountdown(TestImsService.LATCH_MMTEL_READY));
        assertNotNull(""ImsService created, but ImsService#createMmTelFeature was not called!"",
                sServiceConnector.getCarrierService().getMmTelFeature());
        int serviceSlot = sServiceConnector.getCarrierService().getMmTelFeature().getSlotIndex();
        assertEquals(""The slot specified for the test ("" + sTestSlot + "") does not match the ""
                        + ""assigned slot ("" + serviceSlot + ""+ for the associated MmTelFeature"",
                sTestSlot, serviceSlot);
    }

    private ImsStateCallback buildImsStateCallback(final LinkedBlockingQueue<Integer> stateQueue) {
        return new ImsStateCallback() {
            @Override
            public void onUnavailable(int reason) {
                stateQueue.offer(reason);
            }

            @Override
            public void onAvailable() {
                stateQueue.offer(FEATURE_STATE_READY);
            }

            @Override
            public void onError() {
                stateQueue.offer(-1);
            }
        };
    }

    private ProvisioningManager.RcsProvisioningCallback buildRcsProvisioningCallback(
            LinkedBlockingQueue<Integer> actionQueue,
            LinkedBlockingQueue<RcsProvisioningCallbackParams> paramQueue) {
        return new ProvisioningManager.RcsProvisioningCallback() {
            @Override
            public void onConfigurationChanged(byte[] configXml) {
                super.onConfigurationChanged(configXml);
                actionQueue.offer(RCS_CONFIG_CB_CHANGED);
                if (paramQueue != null) {
                    RcsProvisioningCallbackParams params = new RcsProvisioningCallbackParams();
                    params.mConfig = configXml;
                    paramQueue.offer(params);
                }
            }

            @Override
            public void onAutoConfigurationErrorReceived(int code, String str) {
                super.onAutoConfigurationErrorReceived(code, str);
                actionQueue.offer(RCS_CONFIG_CB_ERROR);
                if (paramQueue != null) {
                    RcsProvisioningCallbackParams params = new RcsProvisioningCallbackParams();
                    params.mErrorCode = code;
                    params.mErrorString = str;
                    paramQueue.offer(params);
                }
            }

            @Override
            public void onConfigurationReset() {
                super.onConfigurationReset();
                actionQueue.offer(RCS_CONFIG_CB_RESET);
            }

            @Override
            public void onRemoved() {
                super.onRemoved();
                actionQueue.offer(RCS_CONFIG_CB_DELETE);
            }

            @Override
            public void onPreProvisioningReceived(byte[] configXml) {
                super.onPreProvisioningReceived(configXml);
                actionQueue.offer(RCS_CONFIG_CB_PREPROV);
                if (paramQueue != null) {
                    RcsProvisioningCallbackParams params = new RcsProvisioningCallbackParams();
                    params.mConfig = configXml;
                    paramQueue.offer(params);
                }
            }
        };
    }
    // Waiting for ImsRcsManager to become public before implementing RegistrationManager,
    // Duplicate these methods for now.
    private void verifyRegistrationState(ImsRcsManager regManager, int expectedState)
            throws Exception {
        LinkedBlockingQueue<Integer> mQueue = new LinkedBlockingQueue<>();
        assertTrue(ImsUtils.retryUntilTrue(() -> {
            ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(regManager,
                    (m) -> m.getRegistrationState(getContext().getMainExecutor(), mQueue::offer),
                    ""android.permission.READ_PRECISE_PHONE_STATE"");
            return waitForIntResult(mQueue) == expectedState;
        }));
    }

    // Waiting for ImsRcsManager to become public before implementing RegistrationManager,
    // Duplicate these methods for now.
    private void verifyRegistrationTransportType(ImsRcsManager regManager,
            int expectedTransportType) throws Exception {
        LinkedBlockingQueue<Integer> mQueue = new LinkedBlockingQueue<>();
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(regManager,
                (m) -> m.getRegistrationTransportType(getContext().getMainExecutor(),
                        mQueue::offer),
                ""android.permission.READ_PRECISE_PHONE_STATE"");
        assertEquals(expectedTransportType, waitForIntResult(mQueue));
    }

    private void verifyRegistrationState(RegistrationManager regManager, int expectedState)
            throws Exception {
        LinkedBlockingQueue<Integer> mQueue = new LinkedBlockingQueue<>();
        assertTrue(ImsUtils.retryUntilTrue(() -> {
            ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(regManager,
                    (m) -> m.getRegistrationState(getContext().getMainExecutor(), mQueue::offer));
            return waitForIntResult(mQueue) == expectedState;
        }));
    }

    private void verifyRegistrationTransportType(RegistrationManager regManager,
            int expectedTransportType) throws Exception {
        LinkedBlockingQueue<Integer> mQueue = new LinkedBlockingQueue<>();
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(regManager,
                (m) -> m.getRegistrationTransportType(getContext().getMainExecutor(),
                        mQueue::offer));
        assertEquals(expectedTransportType, waitForIntResult(mQueue));
    }

    private void verifyRegistering(int tech, ArraySet<String> featureTags,
            LinkedBlockingQueue<ImsRegistrationAttributes> attrQueue, int expectedTransport,
            int expectedAttrFlags) throws Exception {
        ImsRegistrationAttributes attr = new ImsRegistrationAttributes.Builder(tech)
                .setFeatureTags(featureTags).build();
        sServiceConnector.getCarrierService().getImsRegistration().onRegistering(attr);
        ImsRegistrationAttributes attrResult = waitForResult(attrQueue);
        assertNotNull(attrResult);
        assertEquals(tech, attrResult.getRegistrationTechnology());
        assertEquals(expectedTransport, attrResult.getTransportType());
        assertEquals(expectedAttrFlags, attrResult.getAttributeFlags());
        assertEquals(featureTags, attrResult.getFeatureTags());
    }

    private void verifyRegistered(int tech, ArraySet<String> featureTags,
            LinkedBlockingQueue<ImsRegistrationAttributes> attrQueue, int expectedTransport,
            int expectedAttrFlags) throws Exception {
        ImsRegistrationAttributes attr = new ImsRegistrationAttributes.Builder(tech)
                .setFeatureTags(featureTags).build();
        sServiceConnector.getCarrierService().getImsRegistration().onRegistered(attr);
        ImsRegistrationAttributes attrResult = waitForResult(attrQueue);
        assertNotNull(attrResult);
        assertEquals(tech, attrResult.getRegistrationTechnology());
        assertEquals(expectedTransport, attrResult.getTransportType());
        assertEquals(expectedAttrFlags, attrResult.getAttributeFlags());
        assertEquals(featureTags, attrResult.getFeatureTags());
    }

    private <T> boolean waitForParam(LinkedBlockingQueue<T> queue, T waitParam) throws Exception {
        T result;
        while ((result = waitForResult(queue)) != null) {
            if (waitParam.equals(result)) {
                return true;
            }
        }
        return false;
    }

    private <T> T waitForResult(LinkedBlockingQueue<T> queue) throws Exception {
        return queue.poll(ImsUtils.TEST_TIMEOUT_MS, TimeUnit.MILLISECONDS);
    }

    private int waitForIntResult(LinkedBlockingQueue<Integer> queue) throws Exception {
        Integer result = queue.poll(ImsUtils.TEST_TIMEOUT_MS, TimeUnit.MILLISECONDS);
        return result != null ? result : Integer.MAX_VALUE;
    }

    private int waitForIntResult(LinkedBlockingQueue<Integer> queue, int timeout)
            throws Exception {
        Integer result = queue.poll(timeout, TimeUnit.MILLISECONDS);
        return result != null ? result : Integer.MAX_VALUE;
    }

    private static void overrideCarrierConfig(PersistableBundle bundle) throws Exception {
        CarrierConfigManager carrierConfigManager = InstrumentationRegistry.getInstrumentation()
                .getContext().getSystemService(CarrierConfigManager.class);
        sReceiver.clearQueue();
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(carrierConfigManager,
                (m) -> m.overrideConfig(sTestSub, bundle));
        sReceiver.waitForChanged();
    }

    private static Context getContext() {
        return InstrumentationRegistry.getInstrumentation().getContext();
    }

    // Copied from com.android.internal.util.HexDump
    private static byte[] hexStringToByteArray(String hexString) {
        int length = hexString.length();
        byte[] buffer = new byte[length / 2];

        for (int i = 0; i < length; i += 2) {
            buffer[i / 2] =
                    (byte) ((toByte(hexString.charAt(i)) << 4) | toByte(hexString.charAt(i + 1)));
        }

        return buffer;
    }

    // Copied from com.android.internal.util.HexDump
    private static int toByte(char c) {
        if (c >= '0' && c <= '9') return (c - '0');
        if (c >= 'A' && c <= 'F') return (c - 'A' + 10);
        if (c >= 'a' && c <= 'f') return (c - 'a' + 10);

        throw new RuntimeException(""Invalid hex char '"" + c + ""'"");
    }
}"	""	""	"RCS MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.ImsServiceTest"	"testCarrierImsServiceBindMmTelFeature"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	"public void testCarrierImsServiceBindMmTelFeature() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        // Connect to the ImsService with the MmTel feature.
        assertTrue(sServiceConnector.connectCarrierImsService(new ImsFeatureConfiguration.Builder()
                .addFeature(sTestSlot, ImsFeature.FEATURE_MMTEL)
                .build()));
        // The MmTelFeature is created when the ImsService is bound. If it wasn't created, then the
        // Framework did not call it.
        sServiceConnector.getCarrierService().waitForLatchCountdown(
                TestImsService.LATCH_CREATE_MMTEL);
        assertNotNull(""ImsService created, but ImsService#createMmTelFeature was not called!"",
                sServiceConnector.getCarrierService().getMmTelFeature());
        // Wait for the framework to set the capabilities on the ImsService
        sServiceConnector.getCarrierService().waitForLatchCountdown(
                TestImsService.LATCH_MMTEL_CAP_SET);
    }"	""	""	"MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.ImsServiceTest"	"testCarrierImsServiceBindMmTelNoEmergency"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	"public void testCarrierImsServiceBindMmTelNoEmergency() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        // Connect to the ImsService with the MMTEL feature.
        assertTrue(sServiceConnector.connectCarrierImsService(new ImsFeatureConfiguration.Builder()
                .addFeature(sTestSlot, ImsFeature.FEATURE_MMTEL)
                .build()));
        // The MmTelFeature is created when the ImsService is bound. If it wasn't created, then the
        // Framework did not call it.
        assertTrue(sServiceConnector.getCarrierService().waitForLatchCountdown(
                TestImsService.LATCH_CREATE_MMTEL));
        // Wait for the framework to set the capabilities on the ImsService
        sServiceConnector.getCarrierService().waitForLatchCountdown(
                TestImsService.LATCH_MMTEL_CAP_SET);
    }"	""	""	"MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.ImsServiceTest"	"testCarrierImsServiceBindMmTelEmergencyEnabled"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	"public void testCarrierImsServiceBindMmTelEmergencyEnabled() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        // Connect to the ImsService with the MMTEL feature.
        assertTrue(sServiceConnector.connectCarrierImsService(new ImsFeatureConfiguration.Builder()
                .addFeature(sTestSlot, ImsFeature.FEATURE_MMTEL)
                .addFeature(sTestSlot, ImsFeature.FEATURE_EMERGENCY_MMTEL)
                .build()));
        // The MmTelFeature is created when the ImsService is bound. If it wasn't created, then the
        // Framework did not call it.
        assertTrue(sServiceConnector.getCarrierService().waitForLatchCountdown(
                TestImsService.LATCH_CREATE_MMTEL));
        // Wait for the framework to set the capabilities on the ImsService
        sServiceConnector.getCarrierService().waitForLatchCountdown(
                TestImsService.LATCH_MMTEL_CAP_SET);
    }"	""	""	"MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.ImsServiceTest"	"testMmTelSendSms"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	"public void testMmTelSendSms() throws Exception {
        if (!ImsUtils.shouldRunSmsImsTests(sTestSub)) {
            return;
        }

        setupImsServiceForSms();
        // Send Message with sent PendingIntent requested
        SmsManager.getSmsManagerForSubscriptionId(sTestSub).sendTextMessage(SRC_NUMBER,
                DEST_NUMBER, MSG_CONTENTS, SmsReceiverHelper.getMessageSentPendingIntent(
                        InstrumentationRegistry.getInstrumentation().getTargetContext()), null);
        assertTrue(sServiceConnector.getCarrierService().getMmTelFeature()
                .getSmsImplementation().waitForMessageSentLatch());

        // Wait for send PendingIntent
        Intent intent = AsyncSmsMessageListener.getInstance().waitForMessageSentIntent(
                ImsUtils.TEST_TIMEOUT_MS);
        assertNotNull(""SMS send PendingIntent never received"", intent);
        assertEquals(""SMS send PendingIntent should have result RESULT_OK"",
                Activity.RESULT_OK, intent.getIntExtra(SmsReceiverHelper.EXTRA_RESULT_CODE,
                        Activity.RESULT_CANCELED));

        // Ensure we receive correct PDU on the other side.
        Assert.assertArrayEquals(EXPECTED_PDU, sServiceConnector.getCarrierService()
                .getMmTelFeature().getSmsImplementation().sentPdu);
    }"	""	""	"MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.ImsServiceTest"	"testMmTelSendSmsDeliveryReportQCompat"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	"public void testMmTelSendSmsDeliveryReportQCompat() throws Exception {
        if (!ImsUtils.shouldRunSmsImsTests(sTestSub)) {
            return;
        }

        setupImsServiceForSms();
        // Send Message with sent PendingIntent requested
        SmsManager.getSmsManagerForSubscriptionId(sTestSub).sendTextMessage(SRC_NUMBER,
                DEST_NUMBER, MSG_CONTENTS, null, SmsReceiverHelper.getMessageDeliveredPendingIntent(
                        InstrumentationRegistry.getInstrumentation().getTargetContext()));
        assertTrue(sServiceConnector.getCarrierService().getMmTelFeature()
                .getSmsImplementation().waitForMessageSentLatch());

        // Ensure we receive correct PDU on the other side.
        // Set TP-Status-Report-Request bit as well for this case.
        byte[] pduWithStatusReport = EXPECTED_PDU.clone();
        pduWithStatusReport[0] |= 0x20;
        Assert.assertArrayEquals(pduWithStatusReport, sServiceConnector.getCarrierService()
                .getMmTelFeature().getSmsImplementation().sentPdu);

        // Ensure the API works on Q as well as in R+, where it was deprecated.
        sServiceConnector.getCarrierService().getMmTelFeature().getSmsImplementation()
                .sendReportWaitForAcknowledgeSmsReportPQ(0, SmsMessage.FORMAT_3GPP,
                        STATUS_REPORT_PDU);

        // Wait for delivered PendingIntent
        Intent intent = AsyncSmsMessageListener.getInstance().waitForMessageDeliveredIntent(
                ImsUtils.TEST_TIMEOUT_MS);
        assertNotNull(""SMS delivered PendingIntent never received"", intent);
        assertEquals(""SMS delivered PendingIntent should have result RESULT_OK"",
                Activity.RESULT_OK, intent.getIntExtra(SmsReceiverHelper.EXTRA_RESULT_CODE,
                        Activity.RESULT_CANCELED));
    }"	""	""	"MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.ImsServiceTest"	"testMmTelSendSmsDeliveryReportR"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	"public void testMmTelSendSmsDeliveryReportR() throws Exception {
        if (!ImsUtils.shouldRunSmsImsTests(sTestSub)) {
            return;
        }

        setupImsServiceForSms();
        // Send Message with sent PendingIntent requested
        SmsManager.getSmsManagerForSubscriptionId(sTestSub).sendTextMessage(SRC_NUMBER,
                DEST_NUMBER, MSG_CONTENTS, null, SmsReceiverHelper.getMessageDeliveredPendingIntent(
                        InstrumentationRegistry.getInstrumentation().getTargetContext()));
        assertTrue(sServiceConnector.getCarrierService().getMmTelFeature()
                .getSmsImplementation().waitForMessageSentLatch());

        // Ensure we receive correct PDU on the other side.
        // Set TP-Status-Report-Request bit as well for this case.
        byte[] pduWithStatusReport = EXPECTED_PDU.clone();
        pduWithStatusReport[0] |= 0x20;
        Assert.assertArrayEquals(pduWithStatusReport, sServiceConnector.getCarrierService()
                .getMmTelFeature().getSmsImplementation().sentPdu);

        sServiceConnector.getCarrierService().getMmTelFeature().getSmsImplementation()
                .sendReportWaitForAcknowledgeSmsReportR(123456789, SmsMessage.FORMAT_3GPP,
                        STATUS_REPORT_PDU);

        // Wait for delivered PendingIntent
        Intent intent = AsyncSmsMessageListener.getInstance().waitForMessageDeliveredIntent(
                ImsUtils.TEST_TIMEOUT_MS);
        assertNotNull(""SMS delivered PendingIntent never received"", intent);
        assertEquals(""SMS delivered PendingIntent should have result RESULT_OK"",
                Activity.RESULT_OK, intent.getIntExtra(SmsReceiverHelper.EXTRA_RESULT_CODE,
                        Activity.RESULT_CANCELED));
    }"	""	""	"MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.ImsServiceTest"	"testMmTelSendSmsRSuccess"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	"public void testMmTelSendSmsRSuccess() throws Exception {
        if (!ImsUtils.shouldRunSmsImsTests(sTestSub)) {
            return;
        }

        setupImsServiceForSms();

        // Send Message
        SmsManager.getSmsManagerForSubscriptionId(sTestSub).sendTextMessage(SRC_NUMBER,
                DEST_NUMBER, MSG_CONTENTS, SmsReceiverHelper.getMessageSentPendingIntent(
                        InstrumentationRegistry.getInstrumentation().getTargetContext()), null);
        // Use R specific API for sending SMS result
        assertTrue(sServiceConnector.getCarrierService().getMmTelFeature()
                .getSmsImplementation().waitForMessageSentLatchSuccess());
        Intent intent = AsyncSmsMessageListener.getInstance().waitForMessageSentIntent(
                ImsUtils.TEST_TIMEOUT_MS);
        assertNotNull(intent);
        assertEquals(Activity.RESULT_OK, intent.getIntExtra(SmsReceiverHelper.EXTRA_RESULT_CODE,
                    Activity.RESULT_CANCELED));

        // Ensure we receive correct PDU on the other side.
        Assert.assertArrayEquals(EXPECTED_PDU, sServiceConnector.getCarrierService()
                .getMmTelFeature().getSmsImplementation().sentPdu);
    }"	""	""	"MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.ImsServiceTest"	"testMmTelSendSmsNetworkError"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	"public void testMmTelSendSmsNetworkError() throws Exception {
        if (!ImsUtils.shouldRunSmsImsTests(sTestSub)) {
            return;
        }

        setupImsServiceForSms();

        // Send Message
        SmsManager.getSmsManagerForSubscriptionId(sTestSub).sendTextMessage(SRC_NUMBER,
                DEST_NUMBER, MSG_CONTENTS, SmsReceiverHelper.getMessageSentPendingIntent(
                        InstrumentationRegistry.getInstrumentation().getContext()), null);
        assertTrue(sServiceConnector.getCarrierService().getMmTelFeature()
                .getSmsImplementation().waitForMessageSentLatchError(
                        SmsManager.RESULT_ERROR_GENERIC_FAILURE, 41));
        Intent intent = AsyncSmsMessageListener.getInstance().waitForMessageSentIntent(
                ImsUtils.TEST_TIMEOUT_MS);
        assertNotNull(intent);
        // In the case of error, the PendingIntent result will not report OK
        assertNotEquals(Activity.RESULT_OK, intent.getIntExtra(SmsReceiverHelper.EXTRA_RESULT_CODE,
                Activity.RESULT_OK));
        // make sure the ""errorCode"" extra contains the network error code returned by the
        // ImsService.
        assertEquals(41, intent.getIntExtra(""errorCode"", 0));

        // Ensure we receive correct PDU on the other side.
        Assert.assertArrayEquals(EXPECTED_PDU, sServiceConnector.getCarrierService()
                .getMmTelFeature().getSmsImplementation().sentPdu);
    }"	""	""	"MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.ImsServiceTest"	"testMmTelReceiveSms"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	"public void testMmTelReceiveSms() throws Exception {
        if (!ImsUtils.shouldRunSmsImsTests(sTestSub)) {
            return;
        }

        setupImsServiceForSms();

        // Message received
        sServiceConnector.getCarrierService().getMmTelFeature().getSmsImplementation()
                .receiveSmsWaitForAcknowledge(123456789, SmsMessage.FORMAT_3GPP,
                        Base64.decode(RECEIVED_MESSAGE, Base64.DEFAULT));

        // Wait for SMS received intent and ensure it is correct.
        String receivedMessage = AsyncSmsMessageListener.getInstance()
                .waitForSmsMessage(ImsUtils.TEST_TIMEOUT_MS);
        assertEquals(EXPECTED_RECEIVED_MESSAGE, receivedMessage);
    }"	""	""	"MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.ImsServiceTest"	"testGetFeatureState"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	"public void testGetFeatureState() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        // This will set feature state to ready
        triggerFrameworkConnectToCarrierImsService();

        Integer result = getFeatureState();
        assertNotNull(result);
        assertEquals(""ImsService state should be STATE_READY"",
                sServiceConnector.getCarrierService().getMmTelFeature().getFeatureState(),
                ImsFeature.STATE_READY);
        assertTrue(""ImsService state is ready, but STATE_READY is not reported."",
                ImsUtils.retryUntilTrue(() -> (getFeatureState() == ImsFeature.STATE_READY)));

        sServiceConnector.getCarrierService().getMmTelFeature().setFeatureState(
                ImsFeature.STATE_INITIALIZING);
        result = getFeatureState();
        assertNotNull(result);
        assertEquals(""ImsService state should be STATE_INITIALIZING"",
                sServiceConnector.getCarrierService().getMmTelFeature().getFeatureState(),
                ImsFeature.STATE_INITIALIZING);
        assertTrue(""ImsService state is initializing, but STATE_INITIALIZING is not reported."",
                ImsUtils.retryUntilTrue(
                        () -> (getFeatureState() == ImsFeature.STATE_INITIALIZING)));

        sServiceConnector.getCarrierService().getMmTelFeature().setFeatureState(
                ImsFeature.STATE_UNAVAILABLE);
        result = getFeatureState();
        assertNotNull(result);
        assertEquals(""ImsService state should be STATE_UNAVAILABLE"",
                sServiceConnector.getCarrierService().getMmTelFeature().getFeatureState(),
                ImsFeature.STATE_UNAVAILABLE);
        assertTrue(""ImsService state is unavailable, but STATE_UNAVAILABLE is not reported."",
                ImsUtils.retryUntilTrue(
                        () -> (getFeatureState() == ImsFeature.STATE_UNAVAILABLE)));
    }

    private Integer getFeatureState() throws Exception {
        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        ImsMmTelManager mmTelManager = imsManager.getImsMmTelManager(sTestSub);
        LinkedBlockingQueue<Integer> state = new LinkedBlockingQueue<>(1);
        ShellIdentityUtils.invokeThrowableMethodWithShellPermissionsNoReturn(mmTelManager,
                (m) -> m.getFeatureState(Runnable::run, state::offer), ImsException.class);
        return state.poll(ImsUtils.TEST_TIMEOUT_MS, TimeUnit.MILLISECONDS);
    }"	""	""	"MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.ImsServiceTest"	"testMmTelManagerRegistrationCallbackS"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	"public void testMmTelManagerRegistrationCallbackS() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }

        final ArraySet<String> featureTags = new ArraySet<>();
        featureTags.add(""featureTag1"");
        featureTags.add(""featureTag2"");

        triggerFrameworkConnectToCarrierImsService();

        // Start deregistered
        sServiceConnector.getCarrierService().getImsRegistration().onDeregistered(
                new ImsReasonInfo(ImsReasonInfo.CODE_LOCAL_NOT_REGISTERED,
                        ImsReasonInfo.CODE_UNSPECIFIED, """"));

        LinkedBlockingQueue<ImsRegistrationAttributes> mRegQueue =
                new LinkedBlockingQueue<>();
        LinkedBlockingQueue<ImsReasonInfo> mDeregQueue =
                new LinkedBlockingQueue<>();
        RegistrationManager.RegistrationCallback callback =
                new RegistrationManager.RegistrationCallback() {
            @Override
            public void onRegistered(ImsRegistrationAttributes attributes) {
                mRegQueue.offer(attributes);
            }

            @Override
            public void onRegistering(ImsRegistrationAttributes attributes) {
                mRegQueue.offer(attributes);
            }

            @Override
            public void onUnregistered(ImsReasonInfo info) {
                mDeregQueue.offer(info);
            }
        };

        final UiAutomation automan = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            // First try without the correct permissions.
            ImsManager imsManager = getContext().getSystemService(ImsManager.class);
            ImsMmTelManager mmTelManager = imsManager.getImsMmTelManager(sTestSub);
            mmTelManager.registerImsRegistrationCallback(getContext().getMainExecutor(), callback);
            fail(""registerImsRegistrationCallback requires READ_PRECISE_PHONE_STATE permission."");
        } catch (SecurityException e) {
            //expected
        }

        // Latch will count down here (we callback on the state during registration).
        try {
            automan.adoptShellPermissionIdentity();
            ImsManager imsManager = getContext().getSystemService(ImsManager.class);
            ImsMmTelManager mmTelManager = imsManager.getImsMmTelManager(sTestSub);
            mmTelManager.registerImsRegistrationCallback(getContext().getMainExecutor(), callback);
        } finally {
            automan.dropShellPermissionIdentity();
        }
        ImsReasonInfo deregResult = waitForResult(mDeregQueue);
        assertNotNull(deregResult);
        assertEquals(ImsReasonInfo.CODE_LOCAL_NOT_REGISTERED, deregResult.getCode());

        // Start registration
        verifyRegistering(ImsRegistrationImplBase.REGISTRATION_TECH_LTE, featureTags, mRegQueue,
                AccessNetworkConstants.TRANSPORT_TYPE_WWAN, 0 /*expected flags*/);

        // move to NR
        verifyRegistering(ImsRegistrationImplBase.REGISTRATION_TECH_NR, featureTags, mRegQueue,
                AccessNetworkConstants.TRANSPORT_TYPE_WWAN, 0 /*expected flags*/);

        // move to cross sim
        verifyRegistering(ImsRegistrationImplBase.REGISTRATION_TECH_CROSS_SIM, featureTags,
                mRegQueue, AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
                ImsRegistrationAttributes.ATTR_EPDG_OVER_CELL_INTERNET);

        // Complete registration
        verifyRegistered(ImsRegistrationImplBase.REGISTRATION_TECH_LTE, featureTags, mRegQueue,
                AccessNetworkConstants.TRANSPORT_TYPE_WWAN, 0 /*expected flags*/);

        // move to NR
        verifyRegistered(ImsRegistrationImplBase.REGISTRATION_TECH_NR, featureTags, mRegQueue,
                AccessNetworkConstants.TRANSPORT_TYPE_WWAN, 0 /*expected flags*/);

        // move to cross sim
        verifyRegistered(ImsRegistrationImplBase.REGISTRATION_TECH_CROSS_SIM, featureTags,
                mRegQueue, AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
                ImsRegistrationAttributes.ATTR_EPDG_OVER_CELL_INTERNET);

        try {
            automan.adoptShellPermissionIdentity();
            ImsManager imsManager = getContext().getSystemService(ImsManager.class);
            ImsMmTelManager mmTelManager = imsManager.getImsMmTelManager(sTestSub);
            mmTelManager.unregisterImsRegistrationCallback(callback);
        } finally {
            automan.dropShellPermissionIdentity();
        }

        try {
            ImsManager imsManager = getContext().getSystemService(ImsManager.class);
            ImsMmTelManager mmTelManager = imsManager.getImsMmTelManager(sTestSub);
            mmTelManager.unregisterImsRegistrationCallback(callback);
            fail(""unregisterImsRegistrationCallback requires READ_PRECISE_PHONE_STATE permission."");
        } catch (SecurityException e) {
            //expected
        }
    }"	""	""	"MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.ImsServiceTest"	"testMmTelManagerRegistrationCallback"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	"public void testMmTelManagerRegistrationCallback() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }

        triggerFrameworkConnectToCarrierImsService();

        // Start deregistered
        sServiceConnector.getCarrierService().getImsRegistration().onDeregistered(
                new ImsReasonInfo(ImsReasonInfo.CODE_LOCAL_NOT_REGISTERED,
                        ImsReasonInfo.CODE_UNSPECIFIED, """"));

        // This is a little bit gross looking, but on P devices, I can not define classes that
        // extend ImsMmTelManager.RegistrationCallback (because it doesn't exist), so this has to
        // happen as an anon class here.
        LinkedBlockingQueue<Integer> mQueue = new LinkedBlockingQueue<>();
        ImsMmTelManager.RegistrationCallback callback = new ImsMmTelManager.RegistrationCallback() {
            @Override
            public void onRegistered(int imsTransportType) {
                mQueue.offer(imsTransportType);
            }

            @Override
            public void onRegistering(int imsTransportType) {
                mQueue.offer(imsTransportType);
            }

            @Override
            public void onUnregistered(ImsReasonInfo info) {
                mQueue.offer(info.getCode());
            }

            @Override
            public void onTechnologyChangeFailed(int imsTransportType, ImsReasonInfo info) {
                mQueue.offer(imsTransportType);
                mQueue.offer(info.getCode());
            }
        };

        final UiAutomation automan = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            // First try without the correct permissions.
            ImsManager imsManager = getContext().getSystemService(ImsManager.class);
            ImsMmTelManager mmTelManager = imsManager.getImsMmTelManager(sTestSub);
            mmTelManager.registerImsRegistrationCallback(getContext().getMainExecutor(), callback);
            fail(""registerImsRegistrationCallback requires READ_PRECISE_PHONE_STATE permission."");
        } catch (SecurityException e) {
            //expected
        }

        // Latch will count down here (we callback on the state during registration).
        try {
            automan.adoptShellPermissionIdentity();
            ImsManager imsManager = getContext().getSystemService(ImsManager.class);
            ImsMmTelManager mmTelManager = imsManager.getImsMmTelManager(sTestSub);
            mmTelManager.registerImsRegistrationCallback(getContext().getMainExecutor(), callback);
        } finally {
            automan.dropShellPermissionIdentity();
        }
        assertEquals(ImsReasonInfo.CODE_LOCAL_NOT_REGISTERED, waitForIntResult(mQueue));


        // Start registration
        sServiceConnector.getCarrierService().getImsRegistration().onRegistering(
                ImsRegistrationImplBase.REGISTRATION_TECH_LTE);
        assertEquals(AccessNetworkConstants.TRANSPORT_TYPE_WWAN, waitForIntResult(mQueue));

        // Complete registration
        sServiceConnector.getCarrierService().getImsRegistration().onRegistered(
                ImsRegistrationImplBase.REGISTRATION_TECH_LTE);
        assertEquals(AccessNetworkConstants.TRANSPORT_TYPE_WWAN, waitForIntResult(mQueue));

        // Fail handover to IWLAN
        sServiceConnector.getCarrierService().getImsRegistration().onTechnologyChangeFailed(
                ImsRegistrationImplBase.REGISTRATION_TECH_IWLAN,
                new ImsReasonInfo(ImsReasonInfo.CODE_LOCAL_HO_NOT_FEASIBLE,
                        ImsReasonInfo.CODE_UNSPECIFIED, """"));
        assertEquals(AccessNetworkConstants.TRANSPORT_TYPE_WLAN, waitForIntResult(mQueue));
        assertEquals(ImsReasonInfo.CODE_LOCAL_HO_NOT_FEASIBLE, waitForIntResult(mQueue));

        // Ensure null ImsReasonInfo still results in non-null callback value.
        sServiceConnector.getCarrierService().getImsRegistration().onTechnologyChangeFailed(
                ImsRegistrationImplBase.REGISTRATION_TECH_IWLAN, null);
        assertEquals(AccessNetworkConstants.TRANSPORT_TYPE_WLAN, waitForIntResult(mQueue));
        assertEquals(ImsReasonInfo.CODE_UNSPECIFIED, waitForIntResult(mQueue));

        // Ensure null ImsReasonInfo still results in non-null callback.
        sServiceConnector.getCarrierService().getImsRegistration().onDeregistered(null);
        assertEquals(ImsReasonInfo.CODE_UNSPECIFIED, waitForIntResult(mQueue));

        try {
            automan.adoptShellPermissionIdentity();
            ImsManager imsManager = getContext().getSystemService(ImsManager.class);
            ImsMmTelManager mmTelManager = imsManager.getImsMmTelManager(sTestSub);
            mmTelManager.unregisterImsRegistrationCallback(callback);
        } finally {
            automan.dropShellPermissionIdentity();
        }

        try {
            ImsManager imsManager = getContext().getSystemService(ImsManager.class);
            ImsMmTelManager mmTelManager = imsManager.getImsMmTelManager(sTestSub);
            mmTelManager.unregisterImsRegistrationCallback(callback);
            fail(""unregisterImsRegistrationCallback requires READ_PRECISE_PHONE_STATE permission."");
        } catch (SecurityException e) {
            //expected
        }
    }"	""	""	"MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.ImsServiceTest"	"testMmTelManagerRegistrationStateR"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	"public void testMmTelManagerRegistrationStateR() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        RegistrationManager regManager = imsManager.getImsMmTelManager(sTestSub);
        LinkedBlockingQueue<Integer> mQueue = new LinkedBlockingQueue<>();

        triggerFrameworkConnectToCarrierImsService();

        // Start deregistered
        sServiceConnector.getCarrierService().getImsRegistration().onDeregistered(
                new ImsReasonInfo(ImsReasonInfo.CODE_LOCAL_NOT_REGISTERED,
                        ImsReasonInfo.CODE_UNSPECIFIED, """"));

        RegistrationManager.RegistrationCallback callback =
                new RegistrationManager.RegistrationCallback() {
                    @Override
                    public void onRegistered(int imsTransportType) {
                        mQueue.offer(imsTransportType);
                    }

                    @Override
                    public void onRegistering(int imsTransportType) {
                        mQueue.offer(imsTransportType);
                    }

                    @Override
                    public void onUnregistered(ImsReasonInfo info) {
                        mQueue.offer(info.getCode());
                    }

                    @Override
                    public void onTechnologyChangeFailed(int imsTransportType, ImsReasonInfo info) {
                        mQueue.offer(imsTransportType);
                        mQueue.offer(info.getCode());
                    }
                };

        ImsMmTelManager mmTelManager = imsManager.getImsMmTelManager(sTestSub);
        ShellIdentityUtils.invokeThrowableMethodWithShellPermissionsNoReturn(mmTelManager,
                (m) -> m.registerImsRegistrationCallback(getContext().getMainExecutor(), callback),
                ImsException.class);
        assertEquals(ImsReasonInfo.CODE_LOCAL_NOT_REGISTERED, waitForIntResult(mQueue));

        // Ensure that the Framework reports Deregistered correctly
        verifyRegistrationState(regManager, RegistrationManager.REGISTRATION_STATE_NOT_REGISTERED);
        verifyRegistrationTransportType(regManager, AccessNetworkConstants.TRANSPORT_TYPE_INVALID);

        // Start registration
        sServiceConnector.getCarrierService().getImsRegistration().onRegistering(
                ImsRegistrationImplBase.REGISTRATION_TECH_LTE);
        assertEquals(AccessNetworkConstants.TRANSPORT_TYPE_WWAN, waitForIntResult(mQueue));
        verifyRegistrationState(regManager, RegistrationManager.REGISTRATION_STATE_REGISTERING);
        verifyRegistrationTransportType(regManager, AccessNetworkConstants.TRANSPORT_TYPE_WWAN);

        // Complete registration
        sServiceConnector.getCarrierService().getImsRegistration().onRegistered(
                ImsRegistrationImplBase.REGISTRATION_TECH_LTE);
        assertEquals(AccessNetworkConstants.TRANSPORT_TYPE_WWAN, waitForIntResult(mQueue));
        verifyRegistrationState(regManager, RegistrationManager.REGISTRATION_STATE_REGISTERED);
        verifyRegistrationTransportType(regManager, AccessNetworkConstants.TRANSPORT_TYPE_WWAN);


        // Fail handover to IWLAN
        sServiceConnector.getCarrierService().getImsRegistration().onTechnologyChangeFailed(
                ImsRegistrationImplBase.REGISTRATION_TECH_IWLAN,
                new ImsReasonInfo(ImsReasonInfo.CODE_LOCAL_HO_NOT_FEASIBLE,
                        ImsReasonInfo.CODE_UNSPECIFIED, """"));
        assertEquals(AccessNetworkConstants.TRANSPORT_TYPE_WLAN, waitForIntResult(mQueue));
        assertEquals(ImsReasonInfo.CODE_LOCAL_HO_NOT_FEASIBLE, waitForIntResult(mQueue));
        verifyRegistrationTransportType(regManager, AccessNetworkConstants.TRANSPORT_TYPE_WWAN);

        // handover to IWLAN
        sServiceConnector.getCarrierService().getImsRegistration().onRegistered(
                ImsRegistrationImplBase.REGISTRATION_TECH_IWLAN);
        assertEquals(AccessNetworkConstants.TRANSPORT_TYPE_WLAN, waitForIntResult(mQueue));
        verifyRegistrationTransportType(regManager, AccessNetworkConstants.TRANSPORT_TYPE_WLAN);

        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mmTelManager,
                (m) -> m.unregisterImsRegistrationCallback(callback));
    }"	""	""	"MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.ImsServiceTest"	"testCapabilityStatusCallback"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	"public void testCapabilityStatusCallback() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }

        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        ImsMmTelManager mmTelManager = imsManager.getImsMmTelManager(sTestSub);

        triggerFrameworkConnectToCarrierImsService();

        // Wait for the framework to set the capabilities on the ImsService
        sServiceConnector.getCarrierService().waitForLatchCountdown(
                TestImsService.LATCH_MMTEL_CAP_SET);
        MmTelFeature.MmTelCapabilities fwCaps = sServiceConnector.getCarrierService()
                .getMmTelFeature().getCapabilities();
        // Make sure we start off with every capability unavailable
        sServiceConnector.getCarrierService().getImsRegistration().onRegistered(
                ImsRegistrationImplBase.REGISTRATION_TECH_LTE);
        sServiceConnector.getCarrierService().getMmTelFeature()
                .notifyCapabilitiesStatusChanged(new MmTelFeature.MmTelCapabilities());

        // Make sure the capabilities match the API getter for capabilities
        final UiAutomation automan = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        // Latch will count down here (we callback on the state during registration).
        try {
            automan.adoptShellPermissionIdentity();
            // Make sure we are tracking voice capability over LTE properly.
            assertEquals(fwCaps.isCapable(MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VOICE),
                    mmTelManager.isCapable(MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VOICE,
                            ImsRegistrationImplBase.REGISTRATION_TECH_LTE));
        } finally {
            automan.dropShellPermissionIdentity();
        }

        // This is a little bit gross looking, but on P devices, I can not define classes that
        // extend ImsMmTelManager.CapabilityCallback (because it doesn't exist), so this has to
        // happen as an anon class here.
        LinkedBlockingQueue<MmTelFeature.MmTelCapabilities> mQueue = new LinkedBlockingQueue<>();
        ImsMmTelManager.CapabilityCallback callback = new ImsMmTelManager.CapabilityCallback() {

            @Override
            public void onCapabilitiesStatusChanged(MmTelFeature.MmTelCapabilities capabilities) {
                mQueue.offer(capabilities);
            }
        };

        // Latch will count down here (we callback on the state during registration).
        try {
            automan.adoptShellPermissionIdentity();
            mmTelManager.registerMmTelCapabilityCallback(getContext().getMainExecutor(), callback);
        } finally {
            automan.dropShellPermissionIdentity();
        }

        try {
            mmTelManager.registerMmTelCapabilityCallback(getContext().getMainExecutor(), callback);
            fail(""registerMmTelCapabilityCallback requires READ_PRECISE_PHONE_STATE permission."");
        } catch (SecurityException e) {
            //expected
        }

        // We should not have voice availability here, we notified the framework earlier.
        MmTelFeature.MmTelCapabilities capCb = waitForResult(mQueue);
        assertNotNull(capCb);
        assertFalse(capCb.isCapable(MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VOICE));

        // Now enable voice availability
        sServiceConnector.getCarrierService().getMmTelFeature()
                .notifyCapabilitiesStatusChanged(new MmTelFeature.MmTelCapabilities(
                        MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VOICE));
        capCb = waitForResult(mQueue);
        assertNotNull(capCb);
        assertTrue(capCb.isCapable(MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VOICE));

        try {
            automan.adoptShellPermissionIdentity();
            assertTrue(ImsUtils.retryUntilTrue(() -> mmTelManager.isAvailable(
                    MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VOICE,
                    ImsRegistrationImplBase.REGISTRATION_TECH_LTE)));

            mmTelManager.unregisterMmTelCapabilityCallback(callback);
        } finally {
            automan.dropShellPermissionIdentity();
        }

        try {
            mmTelManager.unregisterMmTelCapabilityCallback(callback);
            fail(""unregisterMmTelCapabilityCallback requires READ_PRECISE_PHONE_STATE permission."");
        } catch (SecurityException e) {
            //expected
        }
    }"	""	""	"MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.ImsServiceTest"	"testCallComposerCapabilityStatusCallback"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	"public void testCallComposerCapabilityStatusCallback() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }

        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        ImsMmTelManager mmTelManager = imsManager.getImsMmTelManager(sTestSub);

        triggerFrameworkConnectToCarrierImsService();

        // Wait for the framework to set the capabilities on the ImsService
        sServiceConnector.getCarrierService().waitForLatchCountdown(
                TestImsService.LATCH_MMTEL_CAP_SET);
        MmTelFeature.MmTelCapabilities fwCaps = sServiceConnector.getCarrierService()
                .getMmTelFeature().getCapabilities();
        // Make sure we start off with every capability unavailable
        sServiceConnector.getCarrierService().getImsRegistration().onRegistered(
                ImsRegistrationImplBase.REGISTRATION_TECH_LTE);
        sServiceConnector.getCarrierService().getMmTelFeature()
                .notifyCapabilitiesStatusChanged(new MmTelFeature.MmTelCapabilities());

        // Make sure the capabilities match the API getter for capabilities
        final UiAutomation automan = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        // Latch will count down here (we callback on the state during registration).
        try {
            automan.adoptShellPermissionIdentity();
            // Make sure we are tracking voice capability over LTE properly.
            assertEquals(fwCaps.isCapable(MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VOICE),
                    mmTelManager.isCapable(MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VOICE,
                    ImsRegistrationImplBase.REGISTRATION_TECH_LTE));
        } finally {
            automan.dropShellPermissionIdentity();
        }

        LinkedBlockingQueue<MmTelFeature.MmTelCapabilities> mQueue = new LinkedBlockingQueue<>();
        ImsMmTelManager.CapabilityCallback callback = new ImsMmTelManager.CapabilityCallback() {

            @Override
            public void onCapabilitiesStatusChanged(MmTelFeature.MmTelCapabilities capabilities) {
                mQueue.offer(capabilities);
            }
        };

        // Latch will count down here (we callback on the state during registration).
        try {
            automan.adoptShellPermissionIdentity();
            mmTelManager.registerMmTelCapabilityCallback(getContext().getMainExecutor(), callback);
        } finally {
            automan.dropShellPermissionIdentity();
        }

        try {
            mmTelManager.registerMmTelCapabilityCallback(getContext().getMainExecutor(), callback);
            fail(""registerMmTelCapabilityCallback requires READ_PRECISE_PHONE_STATE permission."");
        } catch (SecurityException e) {
            //expected
        }

        // We should not have voice availability here, we notified the framework earlier.
        MmTelFeature.MmTelCapabilities capCb = waitForResult(mQueue);
        assertFalse(capCb.isCapable(MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_CALL_COMPOSER));

        // Now enable call composer availability
        sServiceConnector.getCarrierService().getMmTelFeature()
                .notifyCapabilitiesStatusChanged(new MmTelFeature.MmTelCapabilities(
                MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_CALL_COMPOSER));
        capCb = waitForResult(mQueue);
        assertNotNull(capCb);
        assertTrue(capCb.isCapable(MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_CALL_COMPOSER));

        try {
            automan.adoptShellPermissionIdentity();
            assertTrue(ImsUtils.retryUntilTrue(() -> mmTelManager.isAvailable(
                    MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_CALL_COMPOSER,
                    ImsRegistrationImplBase.REGISTRATION_TECH_LTE)));

            mmTelManager.unregisterMmTelCapabilityCallback(callback);
        } finally {
            automan.dropShellPermissionIdentity();
        }

        try {
            mmTelManager.unregisterMmTelCapabilityCallback(callback);
            fail(""unregisterMmTelCapabilityCallback requires READ_PRECISE_PHONE_STATE permission."");
        } catch (SecurityException e) {
            //expected
        }
    }

    /**
     * We are specifically testing a race case here such that IsAvailable returns the correct
     * capability status during the callback.
     */"	""	""	"MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.ImsServiceTest"	"testCapabilityStatusWithIsAvailableDuringCallback"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	"public void testCapabilityStatusWithIsAvailableDuringCallback() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }

        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        ImsMmTelManager mmTelManager = imsManager.getImsMmTelManager(sTestSub);

        triggerFrameworkConnectToCarrierImsService();

        // Wait for the framework to set the capabilities on the ImsService
        sServiceConnector.getCarrierService().waitForLatchCountdown(
                TestImsService.LATCH_MMTEL_CAP_SET);


        // Make sure we start off with every capability unavailable
        sServiceConnector.getCarrierService().getImsRegistration().onRegistered(
                ImsRegistrationImplBase.REGISTRATION_TECH_LTE);
        MmTelFeature.MmTelCapabilities stdCapabilities = new MmTelFeature.MmTelCapabilities();
        sServiceConnector.getCarrierService().getMmTelFeature()
                .notifyCapabilitiesStatusChanged(stdCapabilities);


        // Make sure the capabilities match the API getter for capabilities
        final UiAutomation automan = InstrumentationRegistry.getInstrumentation().getUiAutomation();

        //This lock is to keep the shell permissions from being dropped on a different thread
        //causing a permission error.
        Object lockObj = new Object();

        synchronized (lockObj) {
            try {
                automan.adoptShellPermissionIdentity();
                boolean isAvailableBeforeStatusChange = mmTelManager.isAvailable(
                        MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VOICE,
                        ImsRegistrationImplBase.REGISTRATION_TECH_LTE);
                assertFalse(isAvailableBeforeStatusChange);
            } finally {
                automan.dropShellPermissionIdentity();
            }
        }

        LinkedBlockingQueue<Boolean> voiceIsAvailable = new LinkedBlockingQueue<>();
        ImsMmTelManager.CapabilityCallback verifyCapabilityStatusCallaback =
                new ImsMmTelManager.CapabilityCallback() {
            @Override
            public void onCapabilitiesStatusChanged(MmTelFeature.MmTelCapabilities capabilities) {
                synchronized (lockObj) {
                    try {
                        automan.adoptShellPermissionIdentity();
                        boolean isVoiceAvailable = mmTelManager
                                .isAvailable(MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VOICE,
                                        ImsRegistrationImplBase.REGISTRATION_TECH_LTE);

                        voiceIsAvailable.offer(isVoiceAvailable);
                    } finally {
                        automan.dropShellPermissionIdentity();
                    }
                }
            }
        };

        synchronized (lockObj) {
            // Latch will count down here (we callback on the state during registration).
            try {
                automan.adoptShellPermissionIdentity();
                mmTelManager.registerMmTelCapabilityCallback(getContext().getMainExecutor(),
                        verifyCapabilityStatusCallaback);
            } finally {
                automan.dropShellPermissionIdentity();
            }
        }

        // Now enable voice availability
        Boolean isAvailableDuringRegister = waitForResult(voiceIsAvailable);
        assertNotNull(isAvailableDuringRegister);
        assertFalse(isAvailableDuringRegister);
        sServiceConnector.getCarrierService().getMmTelFeature()
                .notifyCapabilitiesStatusChanged(new MmTelFeature.MmTelCapabilities(
                        MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VOICE));
        Boolean isAvailableAfterStatusChange = waitForResult(voiceIsAvailable);
        assertNotNull(isAvailableAfterStatusChange);
        assertTrue(isAvailableAfterStatusChange);

        synchronized (lockObj) {
            try {
                automan.adoptShellPermissionIdentity();
                mmTelManager.unregisterMmTelCapabilityCallback(verifyCapabilityStatusCallaback);
            } finally {
                automan.dropShellPermissionIdentity();
            }
        }
    }"	""	""	"MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.ImsServiceTest"	"testProvisioningManagerProvisioningCaps"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	"public void testProvisioningManagerProvisioningCaps() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }

        triggerFrameworkConnectToCarrierImsService();

        PersistableBundle bundle = new PersistableBundle();
        bundle.putBoolean(CarrierConfigManager.KEY_CARRIER_SUPPORTS_SS_OVER_UT_BOOL, true);
        bundle.putBoolean(CarrierConfigManager.KEY_CARRIER_UT_PROVISIONING_REQUIRED_BOOL, true);
        overrideCarrierConfig(bundle);

        ProvisioningManager provisioningManager =
                ProvisioningManager.createForSubscriptionId(sTestSub);

        final UiAutomation automan = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            automan.adoptShellPermissionIdentity();
            boolean provisioningStatus = provisioningManager.getProvisioningStatusForCapability(
                    MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_UT,
                    ImsRegistrationImplBase.REGISTRATION_TECH_LTE);
            provisioningManager.setProvisioningStatusForCapability(
                    MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_UT,
                    ImsRegistrationImplBase.REGISTRATION_TECH_LTE, !provisioningStatus);
            // Make sure the change in provisioning status is correctly returned.
            assertEquals(!provisioningStatus,
                    provisioningManager.getProvisioningStatusForCapability(
                            MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_UT,
                            ImsRegistrationImplBase.REGISTRATION_TECH_LTE));
            // TODO: Enhance test to make sure the provisioning change is also sent to the
            // ImsService

            // set back to current status
            provisioningManager.setProvisioningStatusForCapability(
                    MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_UT,
                    ImsRegistrationImplBase.REGISTRATION_TECH_LTE, provisioningStatus);
        } finally {
            automan.dropShellPermissionIdentity();
        }

        overrideCarrierConfig(null);
    }"	""	""	"MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.ImsServiceTest"	"testSetRtpHeaderExtensions"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	"public void testSetRtpHeaderExtensions() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        sServiceConnector.setDeviceToDeviceCommunicationEnabled(true);
        try {
            PersistableBundle bundle = new PersistableBundle();
            bundle.putBoolean(
                    CarrierConfigManager.KEY_SUPPORTS_DEVICE_TO_DEVICE_COMMUNICATION_USING_RTP_BOOL,
                    true);
            bundle.putBoolean(CarrierConfigManager
                    .KEY_SUPPORTS_SDP_NEGOTIATION_OF_D2D_RTP_HEADER_EXTENSIONS_BOOL, true);
            overrideCarrierConfig(bundle);

            triggerFrameworkConnectToCarrierImsService();

            sServiceConnector.getCarrierService().getMmTelFeature()
                    .getOfferedRtpHeaderExtensionLatch().await(5000, TimeUnit.MILLISECONDS);
            Set<RtpHeaderExtensionType> extensions = sServiceConnector.getCarrierService()
                    .getMmTelFeature().getOfferedRtpHeaderExtensionTypes();

            assertTrue(extensions.size() > 0);
        } finally {
            sServiceConnector.setDeviceToDeviceCommunicationEnabled(false);
            overrideCarrierConfig(null);
        }
    }"	""	""	"MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.ImsServiceTest"	"testImsMmTelManagerImsStateCallback"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	"public void testImsMmTelManagerImsStateCallback() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }

        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        if (imsManager == null) {
            fail(""Cannot find IMS service"");
        }

        LinkedBlockingQueue<Integer> stateQueue = new LinkedBlockingQueue<>();
        ImsStateCallback callback = buildImsStateCallback(stateQueue);

        ImsMmTelManager mmTelManager = null;
        final UiAutomation automan = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            automan.adoptShellPermissionIdentity();
            mmTelManager = imsManager.getImsMmTelManager(sTestSub);
            mmTelManager.registerImsStateCallback(getContext().getMainExecutor(), callback);
        } finally {
            automan.dropShellPermissionIdentity();
        }

        int reason = waitForIntResult(stateQueue);
        assertTrue(reason == ImsStateCallback.REASON_UNKNOWN_TEMPORARY_ERROR
                || reason == ImsStateCallback.REASON_UNKNOWN_PERMANENT_ERROR
                || reason == ImsStateCallback.REASON_IMS_SERVICE_DISCONNECTED
                || reason == ImsStateCallback.REASON_NO_IMS_SERVICE_CONFIGURED
                || reason == ImsStateCallback.REASON_SUBSCRIPTION_INACTIVE
                || reason == ImsStateCallback.REASON_IMS_SERVICE_NOT_READY);

        mmTelManager.unregisterImsStateCallback(callback);

        // Connect to device ImsService with MmTelFeature
        triggerFrameworkConnectToCarrierImsService();

        stateQueue = new LinkedBlockingQueue<>();
        callback = buildImsStateCallback(stateQueue);

        try {
            automan.adoptShellPermissionIdentity();
            mmTelManager.registerImsStateCallback(getContext().getMainExecutor(), callback);
        } finally {
            automan.dropShellPermissionIdentity();
        }

        // expects FEATURE_MMTEL STATE_READY
        assertEquals(FEATURE_STATE_READY, waitForIntResult(stateQueue));

        if (sServiceConnector != null) {
            sServiceConnector.getCarrierService().getMmTelFeature().setFeatureState(
                    ImsFeature.STATE_INITIALIZING);
        }

        // expects NOT_READY
        assertEquals(ImsStateCallback.REASON_IMS_SERVICE_NOT_READY,
                waitForIntResult(stateQueue));

        // Unbind the GTS ImsService
        if (sServiceConnector != null) {
            sServiceConnector.disconnectCarrierImsService();
        }

        // expects DISCONNECTED
        assertEquals(ImsStateCallback.REASON_IMS_SERVICE_DISCONNECTED,
                waitForIntResult(stateQueue));

        mmTelManager.unregisterImsStateCallback(callback);
    }"	""	""	"MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.RcsClientConfigurationTest"	"testRcsClientConfigurationApi"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/RcsClientConfigurationTest.java"	""	"public void testRcsClientConfigurationApi() {
        RcsClientConfiguration rcc = new RcsClientConfiguration(
                RCS_VERSION, RCS_PROFILE, CLIENT_VENDOR, CLIENT_VERSION);

        assertEquals(RCS_VERSION, rcc.getRcsVersion());
        assertEquals(RCS_PROFILE, rcc.getRcsProfile());
        assertEquals(CLIENT_VENDOR, rcc.getClientVendor());
        assertEquals(CLIENT_VERSION, rcc.getClientVersion());
    }"	""	""	"RCS"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.RcsClientConfigurationTest"	"testRcsClientConfigurationParcel"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/RcsClientConfigurationTest.java"	""	"public void testRcsClientConfigurationParcel() {
        RcsClientConfiguration rcc = new RcsClientConfiguration(
                RCS_VERSION, RCS_PROFILE, CLIENT_VENDOR, CLIENT_VERSION);
        Parcel rccParcel = Parcel.obtain();
        rcc.writeToParcel(rccParcel, 0);
        rccParcel.setDataPosition(0);
        RcsClientConfiguration checkRcc =
                RcsClientConfiguration.CREATOR.createFromParcel(rccParcel);

        assertEquals(0, rcc.describeContents());
        assertEquals(rcc, checkRcc);
    }
}"	""	""	"RCS"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.RcsUceAdapterTest"	"beforeAllTests"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/RcsUceAdapterTest.java"	""	"/*
 *.
 */

package android.telephony.ims.cts;

import static android.telephony.ims.RcsContactUceCapability.REQUEST_RESULT_FOUND;
import static android.telephony.ims.RcsContactUceCapability.REQUEST_RESULT_NOT_FOUND;
import static android.telephony.ims.RcsContactUceCapability.SOURCE_TYPE_CACHED;
import static android.telephony.ims.RcsContactUceCapability.SOURCE_TYPE_NETWORK;
import static android.telephony.ims.stub.RcsCapabilityExchangeImplBase.COMMAND_CODE_FETCH_ERROR;
import static android.telephony.ims.stub.RcsCapabilityExchangeImplBase.COMMAND_CODE_GENERIC_FAILURE;
import static android.telephony.ims.stub.RcsCapabilityExchangeImplBase.COMMAND_CODE_INSUFFICIENT_MEMORY;
import static android.telephony.ims.stub.RcsCapabilityExchangeImplBase.COMMAND_CODE_INVALID_PARAM;
import static android.telephony.ims.stub.RcsCapabilityExchangeImplBase.COMMAND_CODE_LOST_NETWORK_CONNECTION;
import static android.telephony.ims.stub.RcsCapabilityExchangeImplBase.COMMAND_CODE_NOT_FOUND;
import static android.telephony.ims.stub.RcsCapabilityExchangeImplBase.COMMAND_CODE_NOT_SUPPORTED;
import static android.telephony.ims.stub.RcsCapabilityExchangeImplBase.COMMAND_CODE_NO_CHANGE;
import static android.telephony.ims.stub.RcsCapabilityExchangeImplBase.COMMAND_CODE_REQUEST_TIMEOUT;
import static android.telephony.ims.stub.RcsCapabilityExchangeImplBase.COMMAND_CODE_SERVICE_UNAVAILABLE;
import static android.telephony.ims.stub.RcsCapabilityExchangeImplBase.COMMAND_CODE_SERVICE_UNKNOWN;

import static junit.framework.Assert.assertTrue;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.fail;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageManager;
import android.content.pm.ResolveInfo;
import android.database.ContentObserver;
import android.net.Uri;
import android.os.Handler;
import android.os.HandlerThread;
import android.os.Looper;
import android.os.PersistableBundle;
import android.provider.Telephony;
import android.telecom.PhoneAccount;
import android.telephony.CarrierConfigManager;
import android.telephony.SubscriptionManager;
import android.telephony.ims.ImsException;
import android.telephony.ims.ImsManager;
import android.telephony.ims.ImsRcsManager;
import android.telephony.ims.RcsContactPresenceTuple;
import android.telephony.ims.RcsContactPresenceTuple.ServiceCapabilities;
import android.telephony.ims.RcsContactUceCapability;
import android.telephony.ims.RcsUceAdapter;
import android.telephony.ims.feature.ImsFeature;
import android.telephony.ims.stub.CapabilityExchangeEventListener;
import android.telephony.ims.stub.CapabilityExchangeEventListener.OptionsRequestCallback;
import android.telephony.ims.stub.ImsFeatureConfiguration;
import android.util.ArraySet;
import android.util.Log;
import android.util.Pair;

import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.platform.app.InstrumentationRegistry;

import com.android.compatibility.common.util.BlockedNumberUtil;
import com.android.compatibility.common.util.ShellIdentityUtils;
import com.android.internal.os.SomeArgs;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Random;
import java.util.Set;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.Consumer;

@RunWith(AndroidJUnit4.class)
public class RcsUceAdapterTest {

    private static final String FEATURE_TAG_CHAT =
            ""+g.3gpp.icsi-ref=\""urn%3Aurn-7%3A3gpp-service.ims.icsi.oma.cpm.session\"""";
    private static final String FEATURE_TAG_FILE_TRANSFER =
            ""+g.3gpp.iari-ref=\""urn%3Aurn-7%3A3gpp-application.ims.iari.rcs.fthttp\"""";
    private static final String FEATURE_TAG_MMTEL_AUDIO_CALL =
            ""+g.3gpp.icsi-ref=\""urn%3Aurn-7%3A3gpp-service.ims.icsi.mmtel\"""";
    private static final String FEATURE_TAG_MMTEL_VIDEO_CALL =
            ""+g.3gpp.icsi-ref=\""urn%3Aurn-7%3A3gpp-service.ims.icsi.mmtel\"";video"";

    private static int sTestSlot = 0;
    private static int sTestSub = SubscriptionManager.INVALID_SUBSCRIPTION_ID;
    private static final Uri LISTENER_URI = Uri.withAppendedPath(Telephony.SimInfo.CONTENT_URI,
            Telephony.SimInfo.COLUMN_IMS_RCS_UCE_ENABLED);
    private static HandlerThread sHandlerThread;
    private static ImsServiceConnector sServiceConnector;
    private static CarrierConfigReceiver sReceiver;
    private static boolean sDeviceUceEnabled;

    private static String sTestPhoneNumber;
    private static String sTestContact2;
    private static String sTestContact3;
    private static Uri sTestNumberUri;
    private static Uri sTestContact2Uri;
    private static Uri sTestContact3Uri;

    private ContentObserver mUceObserver;

    private static class CarrierConfigReceiver extends BroadcastReceiver {
        private CountDownLatch mLatch = new CountDownLatch(1);
        private final int mSubId;

        CarrierConfigReceiver(int subId) {
            mSubId = subId;
        }

        @Override
        public void onReceive(Context context, Intent intent) {
            if (CarrierConfigManager.ACTION_CARRIER_CONFIG_CHANGED.equals(intent.getAction())) {
                int subId = intent.getIntExtra(CarrierConfigManager.EXTRA_SUBSCRIPTION_INDEX, -1);
                if (mSubId == subId) {
                    mLatch.countDown();
                }
            }
        }

        void clearQueue() {
            mLatch = new CountDownLatch(1);
        }

        void waitForCarrierConfigChanged() throws Exception {
            mLatch.await(5000, TimeUnit.MILLISECONDS);
        }
    }

    @BeforeClass
    public static void beforeAllTests() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }

        sTestSub = ImsUtils.getPreferredActiveSubId();
        sTestSlot = SubscriptionManager.getSlotIndex(sTestSub);

        if (Looper.getMainLooper() == null) {
            Looper.prepareMainLooper();
        }
        sHandlerThread = new HandlerThread(""CtsTelephonyTestCases"");
        sHandlerThread.start();

        sServiceConnector = new ImsServiceConnector(InstrumentationRegistry.getInstrumentation());
        sServiceConnector.clearAllActiveImsServices(sTestSlot);

        // Save the original config of device uce enabled and override it.
        sDeviceUceEnabled = sServiceConnector.getDeviceUceEnabled();
        sServiceConnector.setDeviceUceEnabled(true);

        sReceiver = new RcsUceAdapterTest.CarrierConfigReceiver(sTestSub);
        IntentFilter filter = new IntentFilter(CarrierConfigManager.ACTION_CARRIER_CONFIG_CHANGED);
        // ACTION_CARRIER_CONFIG_CHANGED is sticky, so we will get a callback right away.
        InstrumentationRegistry.getInstrumentation().getContext()
                .registerReceiver(sReceiver, filter);

        // Initialize the test phone numbers
        initPhoneNumbers();
    }

    @AfterClass
    public static void afterAllTests() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        // // Restore all ImsService configurations that existed before the test.
        if (sServiceConnector != null) {
            sServiceConnector.disconnectServices();
            sServiceConnector.setDeviceUceEnabled(sDeviceUceEnabled);
        }
        sServiceConnector = null;

        // Ensure there are no CarrierConfig overrides as well as reset the ImsResolver in case the
        // ImsService override changed in CarrierConfig while we were overriding it.
        overrideCarrierConfig(null);

        if (sReceiver != null) {
            InstrumentationRegistry.getInstrumentation().getContext().unregisterReceiver(sReceiver);
            sReceiver = null;
        }

        if (sHandlerThread != null) {
            sHandlerThread.quit();
        }
    }

    @Before
    public void beforeTest() {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        if (!SubscriptionManager.isValidSubscriptionId(sTestSub)) {
            fail(""This test requires that there is a SIM in the device!"");
        }
    }

    @After
    public void afterTest() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        // Unbind the ImsService after the test completes.
        if (sServiceConnector != null) {
            sServiceConnector.disconnectCarrierImsService();
            sServiceConnector.disconnectDeviceImsService();
        }
        overrideCarrierConfig(null);
        // Remove all the test contacts from EAB database
        removeTestContactFromEab();

        removeUceRequestDisallowedStatus();
    }"	""	""	"RCS MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.RcsUceAdapterTest"	"testCapabilityDiscoveryIntentReceiverExists"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/RcsUceAdapterTest.java"	""	"public void testCapabilityDiscoveryIntentReceiverExists() {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }

        PackageManager packageManager = getContext().getPackageManager();
        ResolveInfo info = packageManager.resolveActivity(
                new Intent(ImsRcsManager.ACTION_SHOW_CAPABILITY_DISCOVERY_OPT_IN),
                PackageManager.MATCH_DEFAULT_ONLY);
        assertNotNull(ImsRcsManager.ACTION_SHOW_CAPABILITY_DISCOVERY_OPT_IN
                + "" Intent action must be handled by an appropriate settings application."", info);
        assertNotEquals(ImsRcsManager.ACTION_SHOW_CAPABILITY_DISCOVERY_OPT_IN
                + "" activity intent filter must have a > 0 priority."", 0, info.priority);
    }"	""	""	"RCS"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.RcsUceAdapterTest"	"testGetAndSetUceSetting"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/RcsUceAdapterTest.java"	""	"public void testGetAndSetUceSetting() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }

        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        RcsUceAdapter adapter = imsManager.getImsRcsManager(sTestSub).getUceAdapter();
        assertNotNull(""RcsUceAdapter can not be null!"", adapter);

        Boolean isEnabled = null;
        try {
            isEnabled = ShellIdentityUtils.invokeThrowableMethodWithShellPermissions(
                    adapter, RcsUceAdapter::isUceSettingEnabled, ImsException.class,
                    ""android.permission.READ_PHONE_STATE"");
            assertNotNull(isEnabled);

            // Ensure the ContentObserver gets the correct callback based on the change.
            LinkedBlockingQueue<Uri> queue = new LinkedBlockingQueue<>(1);
            registerUceObserver(queue::offer);
            boolean userSetIsEnabled = isEnabled;
            ShellIdentityUtils.invokeThrowableMethodWithShellPermissionsNoReturn(
                    adapter, a -> a.setUceSettingEnabled(!userSetIsEnabled), ImsException.class,
                    ""android.permission.MODIFY_PHONE_STATE"");
            Uri result = queue.poll(ImsUtils.TEST_TIMEOUT_MS, TimeUnit.MILLISECONDS);
            assertNotNull(result);
            assertTrue(""Unexpected URI, should only receive URIs with prefix "" + LISTENER_URI,
                    result.isPathPrefixMatch(LISTENER_URI));
            // Verify the subId associated with the Observer is correct.
            List<String> pathSegments = result.getPathSegments();
            String subId = pathSegments.get(pathSegments.size() - 1);
            assertEquals(""Subscription ID contained in ContentObserver URI doesn't match the ""
                            + ""subscription that has changed."",
                    String.valueOf(sTestSub), subId);

            Boolean setResult = ShellIdentityUtils.invokeThrowableMethodWithShellPermissions(
                    adapter, RcsUceAdapter::isUceSettingEnabled, ImsException.class,
                    ""android.permission.READ_PHONE_STATE"");
            assertNotNull(setResult);
            assertEquals(""Incorrect setting!"", !userSetIsEnabled, setResult);
        } catch (ImsException e) {
            if (e.getCode() != ImsException.CODE_ERROR_UNSUPPORTED_OPERATION) {
                fail(""failed getting UCE setting with code: "" + e.getCode());
            }
        } finally {
            if (isEnabled != null) {
                boolean userSetIsEnabled = isEnabled;
                // set back to user preference
                ShellIdentityUtils.invokeThrowableMethodWithShellPermissionsNoReturn(
                        adapter, a -> a.setUceSettingEnabled(userSetIsEnabled), ImsException.class,
                        ""android.permission.MODIFY_PHONE_STATE"");
            }
            unregisterUceObserver();
        }
    }"	""	""	"RCS"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.RcsUceAdapterTest"	"testMethodPermissions"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/RcsUceAdapterTest.java"	""	"public void testMethodPermissions() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        RcsUceAdapter uceAdapter = imsManager.getImsRcsManager(sTestSub).getUceAdapter();
        assertNotNull(""UCE adapter should not be null!"", uceAdapter);
        Collection<Uri> numbers = new ArrayList<>(1);
        numbers.add(sTestNumberUri);

        // isUceSettingEnabled - read
        Boolean isUceSettingEnabledResult = null;
        try {
            isUceSettingEnabledResult =
                    ShellIdentityUtils.invokeThrowableMethodWithShellPermissions(
                    uceAdapter, RcsUceAdapter::isUceSettingEnabled, ImsException.class,
                    ""android.permission.READ_PHONE_STATE"");
            assertNotNull(""result from isUceSettingEnabled should not be null"",
                    isUceSettingEnabledResult);
        } catch (SecurityException e) {
            fail(""isUceSettingEnabled should succeed with READ_PHONE_STATE."");
        } catch (ImsException e) {
            // unsupported is a valid fail cause.
            if (e.getCode() != ImsException.CODE_ERROR_UNSUPPORTED_OPERATION) {
                fail(""isUceSettingEnabled failed with code "" + e.getCode());
            }
        }

        // isUceSettingEnabled - read_privileged
        try {
            isUceSettingEnabledResult =
                    ShellIdentityUtils.invokeThrowableMethodWithShellPermissions(
                            uceAdapter, RcsUceAdapter::isUceSettingEnabled, ImsException.class,
                            ""android.permission.READ_PRIVILEGED_PHONE_STATE"");
            assertNotNull(""result from isUceSettingEnabled should not be null"",
                    isUceSettingEnabledResult);
        } catch (SecurityException e) {
            fail(""isUceSettingEnabled should succeed with READ_PRIVILEGED_PHONE_STATE."");
        } catch (ImsException e) {
            // unsupported is a valid fail cause.
            if (e.getCode() != ImsException.CODE_ERROR_UNSUPPORTED_OPERATION) {
                fail(""isUceSettingEnabled failed with code "" + e.getCode());
            }
        }

        // setUceSettingEnabled
        boolean isUceSettingEnabled =
                (isUceSettingEnabledResult == null ? false : isUceSettingEnabledResult);
        try {
            ShellIdentityUtils.invokeThrowableMethodWithShellPermissionsNoReturn(uceAdapter,
                    (m) -> m.setUceSettingEnabled(isUceSettingEnabled), ImsException.class,
                    ""android.permission.MODIFY_PHONE_STATE"");
        } catch (SecurityException e) {
            fail(""setUceSettingEnabled should succeed with MODIFY_PHONE_STATE."");
        } catch (ImsException e) {
            // unsupported is a valid fail cause.
            if (e.getCode() != ImsException.CODE_ERROR_UNSUPPORTED_OPERATION) {
                fail(""setUceSettingEnabled failed with code "" + e.getCode());
            }
        }

        // getUcePublishState without permission
        try {
            uceAdapter.getUcePublishState();
            fail(""getUcePublishState should require READ_PRIVILEGED_PHONE_STATE permission."");
        } catch (SecurityException e) {
            //expected
        }

        // getUcePublishState with permission
        try {
            ShellIdentityUtils.invokeThrowableMethodWithShellPermissionsNoReturn(uceAdapter,
                    RcsUceAdapter::getUcePublishState, ImsException.class,
                    ""android.permission.READ_PRIVILEGED_PHONE_STATE"");
        } catch (SecurityException e) {
            fail(""getUcePublishState should succeed with READ_PRIVILEGED_PHONE_STATE."");
        } catch (ImsException e) {
            // ImsExceptions are still valid because it means the permission check passed.
        }

        final RcsUceAdapter.OnPublishStateChangedListener publishStateListener = (state) -> { };

        // addOnPublishStateChangedListener without permission
        try {
            uceAdapter.addOnPublishStateChangedListener(Runnable::run, publishStateListener);
            fail(""addOnPublishStateChangedListener should require ""
                    + ""READ_PRIVILEGED_PHONE_STATE"");
        } catch (SecurityException e) {
            // expected
        }

        // addOnPublishStateChangedListener with permission.
        try {
            ShellIdentityUtils.invokeThrowableMethodWithShellPermissionsNoReturn(uceAdapter,
                    (m) -> m.addOnPublishStateChangedListener(Runnable::run, publishStateListener),
                    ImsException.class,
                    ""android.permission.READ_PRIVILEGED_PHONE_STATE"");
        } catch (SecurityException e) {
            fail(""addOnPublishStateChangedListener should succeed with ""
                    + ""READ_PRIVILEGED_PHONE_STATE."");
        } catch (ImsException e) {
            // ImsExceptions are still valid because it means the permission check passed.
        }

        // removeOnPublishStateChangedListener without permission
        try {
            uceAdapter.removeOnPublishStateChangedListener(publishStateListener);
            fail(""removeOnPublishStateChangedListener should require ""
                    + ""READ_PRIVILEGED_PHONE_STATE"");
        } catch (SecurityException e) {
            // expected
        }

        // Prepare the callback of the capability request
        RcsUceAdapter.CapabilitiesCallback callback = new RcsUceAdapter.CapabilitiesCallback() {
            @Override
            public void onCapabilitiesReceived(List<RcsContactUceCapability> capabilities) {
            }
            @Override
            public void onComplete() {
            }
            @Override
            public void onError(int errorCode, long retryAfterMilliseconds) {
            }
        };

        // requestCapabilities without permission
        try {
            uceAdapter.requestCapabilities(numbers, Runnable::run , callback);
            fail(""requestCapabilities should require ACCESS_RCS_USER_CAPABILITY_EXCHANGE."");
        } catch (SecurityException e) {
            //expected
        }

        // requestAvailability without permission
        try {
            uceAdapter.requestAvailability(sTestNumberUri, Runnable::run, callback);
            fail(""requestAvailability should require ACCESS_RCS_USER_CAPABILITY_EXCHANGE."");
        } catch (SecurityException e) {
            //expected
        }

        // requestCapabilities in the foreground
        try {
            ShellIdentityUtils.invokeThrowableMethodWithShellPermissionsNoReturn(uceAdapter,
                    (m) -> m.requestCapabilities(numbers, Runnable::run, callback),
                    ImsException.class,
                    ""android.permission.ACCESS_RCS_USER_CAPABILITY_EXCHANGE"");
        } catch (SecurityException e) {
            fail(""requestCapabilities should succeed with ACCESS_RCS_USER_CAPABILITY_EXCHANGE."");
        } catch (ImsException e) {
            // ImsExceptions are still valid because it means the permission check passed.
        }

        // requestAvailability in the foreground
        try {
            ShellIdentityUtils.invokeThrowableMethodWithShellPermissionsNoReturn(uceAdapter,
                    (m) -> m.requestAvailability(sTestNumberUri, Runnable::run, callback),
                    ImsException.class,
                    ""android.permission.ACCESS_RCS_USER_CAPABILITY_EXCHANGE"");
        } catch (SecurityException e) {
            fail(""requestAvailability should succeed with ACCESS_RCS_USER_CAPABILITY_EXCHANGE."");
        } catch (ImsException e) {
            // ImsExceptions are still valid because it means the permission check passed.
        }

        overrideCarrierConfig(null);
    }"	""	""	"RCS"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.RcsUceAdapterTest"	"testCapabilitiesRequestAllowed"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/RcsUceAdapterTest.java"	""	"public void testCapabilitiesRequestAllowed() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        // Start cap exchange disabled and enable later.
        PersistableBundle bundle = new PersistableBundle();
        bundle.putBoolean(CarrierConfigManager.Ims.KEY_ENABLE_PRESENCE_CAPABILITY_EXCHANGE_BOOL,
                false);
        overrideCarrierConfig(bundle);

        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        RcsUceAdapter uceAdapter = imsManager.getImsRcsManager(sTestSub).getUceAdapter();
        assertNotNull(""UCE adapter should not be null!"", uceAdapter);

        // Prepare the test contact and the callback
        Collection<Uri> numbers = new ArrayList<>(1);
        numbers.add(sTestNumberUri);

        ArrayList<String> pidfXmlList = new ArrayList<>(1);
        pidfXmlList.add(getPidfXmlData(sTestNumberUri, true, true));

        BlockingQueue<Boolean> completeQueue = new LinkedBlockingQueue<>();
        BlockingQueue<RcsContactUceCapability> capabilityQueue = new LinkedBlockingQueue<>();
        BlockingQueue<Integer> errorQueue = new LinkedBlockingQueue<>();
        RcsUceAdapter.CapabilitiesCallback callback = new RcsUceAdapter.CapabilitiesCallback() {
            @Override
            public void onCapabilitiesReceived(List<RcsContactUceCapability> capabilities) {
                capabilities.forEach(c -> capabilityQueue.offer(c));
            }
            @Override
            public void onComplete() {
                completeQueue.offer(true);
            }
            @Override
            public void onError(int errorCode, long retryAfterMilliseconds) {
                errorQueue.offer(errorCode);
            }
        };

        // The API requestCapabilities should fail when it doesn't grant the permission.
        try {
            uceAdapter.requestCapabilities(numbers, Runnable::run, callback);
            fail(""requestCapabilities requires ACCESS_RCS_USER_CAPABILITY_EXCHANGE permission."");
        } catch (SecurityException e) {
            //expected
        }

        // The API requestAvailability should fail when it doesn't grant the permission.
        try {
            uceAdapter.requestAvailability(sTestNumberUri, Runnable::run, callback);
            fail(""requestAvailability requires ACCESS_RCS_USER_CAPABILITY_EXCHANGE permission."");
        } catch (SecurityException e) {
            //expected
        }

        // Trigger carrier config changed
        bundle.putBoolean(CarrierConfigManager.Ims.KEY_ENABLE_PRESENCE_PUBLISH_BOOL, true);
        overrideCarrierConfig(bundle);

        // Connect to the TestImsService
        connectTestImsService();

        TestRcsCapabilityExchangeImpl capabilityExchangeImpl = sServiceConnector
                .getCarrierService().getRcsFeature().getRcsCapabilityExchangeImpl();

        requestCapabilities(uceAdapter, numbers, callback);

        // Verify that the callback ""onError"" is called with the error code NOT_ENABLED because
        // the carrier config KEY_ENABLE_PRESENCE_CAPABILITY_EXCHANGE_BOOL is still false.
        try {
            assertEquals(RcsUceAdapter.ERROR_NOT_ENABLED, waitForIntResult(errorQueue));
        } catch (Exception e) {
            fail(""requestCapabilities with command error failed: "" + e);
        } finally {
            capabilityQueue.clear();
            completeQueue.clear();
            errorQueue.clear();
        }

        requestAvailability(uceAdapter, sTestNumberUri, callback);

        // Verify that the callback ""onError"" is called with the error code NOT_ENABLED because
        // the carrier config KEY_ENABLE_PRESENCE_CAPABILITY_EXCHANGE_BOOL is still false.
        try {
            assertEquals(RcsUceAdapter.ERROR_NOT_ENABLED, waitForIntResult(errorQueue));
        } catch (Exception e) {
            fail(""requestAvailability with command error failed: "" + e);
        } finally {
            capabilityQueue.clear();
            completeQueue.clear();
            errorQueue.clear();
        }

        // Override another carrier config KEY_ENABLE_PRESENCE_CAPABILITY_EXCHANGE_BOOL
        bundle.putBoolean(CarrierConfigManager.Ims.KEY_ENABLE_PRESENCE_CAPABILITY_EXCHANGE_BOOL,
                true);
        overrideCarrierConfig(bundle);

        // Prepare the network response is 200 OK and the capabilities update
        int networkRespCode = 200;
        String networkRespReason = ""OK"";
        capabilityExchangeImpl.setSubscribeOperation((uris, cb) -> {
            cb.onNetworkResponse(networkRespCode, networkRespReason);
            cb.onNotifyCapabilitiesUpdate(pidfXmlList);
            cb.onTerminated("""", 0L);
        });

        requestCapabilities(uceAdapter, numbers, callback);

        // Verify that the contact capability is received and the onCompleted is called.
        RcsContactUceCapability capability = waitForResult(capabilityQueue);
        assertNotNull(""Capabilities were not received for contact: "" + sTestNumberUri, capability);
        verifyCapabilityResult(capability, sTestNumberUri, SOURCE_TYPE_NETWORK,
                REQUEST_RESULT_FOUND, true, true);
        waitForResult(completeQueue);

        errorQueue.clear();
        completeQueue.clear();
        capabilityQueue.clear();
        removeTestContactFromEab();

        requestAvailability(uceAdapter, sTestNumberUri, callback);

        // Verify that the contact capability is received and the onCompleted is called.
        capability = waitForResult(capabilityQueue);
        verifyCapabilityResult(capability, sTestNumberUri, SOURCE_TYPE_NETWORK,
                REQUEST_RESULT_FOUND, true, true);
        waitForResult(completeQueue);

        overrideCarrierConfig(null);
    }"	""	""	"RCS"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.RcsUceAdapterTest"	"testCapabilitiesRequestWithCmdError"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/RcsUceAdapterTest.java"	""	"public void testCapabilitiesRequestWithCmdError() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        RcsUceAdapter uceAdapter = imsManager.getImsRcsManager(sTestSub).getUceAdapter();
        assertNotNull(""UCE adapter should not be null!"", uceAdapter);

        // Connect to the TestImsService
        setupTestImsService(uceAdapter, true, true, false);

        Collection<Uri> contacts = Collections.singletonList(sTestNumberUri);

        TestRcsCapabilityExchangeImpl capabilityExchangeImpl = sServiceConnector
                .getCarrierService().getRcsFeature().getRcsCapabilityExchangeImpl();

        // Prepare queues to receive the callback
        BlockingQueue<Integer> errorQueue = new LinkedBlockingQueue<>();
        BlockingQueue<Long> retryAfterQueue = new LinkedBlockingQueue<>();
        RcsUceAdapter.CapabilitiesCallback callback = new RcsUceAdapter.CapabilitiesCallback() {
            @Override
            public void onCapabilitiesReceived(List<RcsContactUceCapability> capabilities) {
            }
            @Override
            public void onComplete() {
            }
            @Override
            public void onError(int errorCode, long retryAfterMilliseconds) {
                errorQueue.offer(errorCode);
                retryAfterQueue.offer(retryAfterMilliseconds);
            }
        };

        // Prepare a map and define each command error code and its associated result.
        Map<Integer, Integer> cmdErrorMap = new HashMap<>();
        cmdErrorMap.put(COMMAND_CODE_SERVICE_UNKNOWN, RcsUceAdapter.ERROR_GENERIC_FAILURE);
        cmdErrorMap.put(COMMAND_CODE_GENERIC_FAILURE, RcsUceAdapter.ERROR_GENERIC_FAILURE);
        cmdErrorMap.put(COMMAND_CODE_INVALID_PARAM, RcsUceAdapter.ERROR_GENERIC_FAILURE);
        cmdErrorMap.put(COMMAND_CODE_FETCH_ERROR, RcsUceAdapter.ERROR_GENERIC_FAILURE);
        cmdErrorMap.put(COMMAND_CODE_REQUEST_TIMEOUT, RcsUceAdapter.ERROR_REQUEST_TIMEOUT);
        cmdErrorMap.put(COMMAND_CODE_INSUFFICIENT_MEMORY, RcsUceAdapter.ERROR_INSUFFICIENT_MEMORY);
        cmdErrorMap.put(COMMAND_CODE_LOST_NETWORK_CONNECTION, RcsUceAdapter.ERROR_LOST_NETWORK);
        cmdErrorMap.put(COMMAND_CODE_NOT_SUPPORTED, RcsUceAdapter.ERROR_GENERIC_FAILURE);
        cmdErrorMap.put(COMMAND_CODE_NOT_FOUND, RcsUceAdapter.ERROR_NOT_FOUND);
        cmdErrorMap.put(COMMAND_CODE_SERVICE_UNAVAILABLE, RcsUceAdapter.ERROR_SERVER_UNAVAILABLE);
        cmdErrorMap.put(COMMAND_CODE_NO_CHANGE, RcsUceAdapter.ERROR_GENERIC_FAILURE);

        // Verify each command error code and the expected callback result
        cmdErrorMap.forEach((cmdError, expectedCallbackResult) -> {
            // Setup the capabilities request that will be failed with the given command error code
            capabilityExchangeImpl.setSubscribeOperation((uris, cb) -> {
                cb.onCommandError(cmdError);
            });

            requestCapabilities(uceAdapter, contacts, callback);

            // Verify that the callback ""onError"" is called with the expected error code.
            try {
                assertEquals(expectedCallbackResult.intValue(), waitForIntResult(errorQueue));
                assertEquals(0L, waitForLongResult(retryAfterQueue));
            } catch (Exception e) {
                fail(""requestCapabilities with command error failed: "" + e);
            } finally {
                errorQueue.clear();
                retryAfterQueue.clear();
            }

            requestAvailability(uceAdapter, sTestNumberUri, callback);

            // Verify that the callback ""onError"" is called with the expected error code.
            try {
                assertEquals(expectedCallbackResult.intValue(), waitForIntResult(errorQueue));
                assertEquals(0L, waitForLongResult(retryAfterQueue));
            } catch (Exception e) {
                fail(""requestAvailability with command error failed: "" + e);
            } finally {
                errorQueue.clear();
                retryAfterQueue.clear();
            }
        });

        overrideCarrierConfig(null);
    }"	""	""	"RCS"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.RcsUceAdapterTest"	"testCapabilitiesRequestWithResponseError"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/RcsUceAdapterTest.java"	""	"public void testCapabilitiesRequestWithResponseError() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        RcsUceAdapter uceAdapter = imsManager.getImsRcsManager(sTestSub).getUceAdapter();
        assertNotNull(""UCE adapter should not be null!"", uceAdapter);

        // Connect to the ImsService
        setupTestImsService(uceAdapter, true, true /* presence cap */, false /* options */);

        Collection<Uri> numbers = new ArrayList<>(1);
        numbers.add(sTestNumberUri);

        BlockingQueue<Integer> errorQueue = new LinkedBlockingQueue<>();
        BlockingQueue<Long> retryAfterQueue = new LinkedBlockingQueue<>();
        RcsUceAdapter.CapabilitiesCallback callback = new RcsUceAdapter.CapabilitiesCallback() {
            @Override
            public void onCapabilitiesReceived(List<RcsContactUceCapability> capabilities) {
            }
            @Override
            public void onComplete() {
            }
            @Override
            public void onError(int errorCode, long retryAfterMilliseconds) {
                errorQueue.offer(errorCode);
                retryAfterQueue.offer(retryAfterMilliseconds);
            }
        };

        Map<Entry<Integer, String>, Integer> networkRespError = new HashMap<>();
        // 408 Request Timeout
        networkRespError.put(new Entry<Integer, String>() {
            @Override
            public Integer getKey() {
                return 408;
            }
            @Override
            public String getValue() {
                return ""Request Timeout"";
            }
            @Override
            public String setValue(String value) {
                return value;
            }
        }, RcsUceAdapter.ERROR_REQUEST_TIMEOUT);

        // 423 Interval Too Short
        networkRespError.put(new Entry<Integer, String>() {
            @Override
            public Integer getKey() {
                return 423;
            }
            @Override
            public String getValue() {
                return ""Interval Too Short"";
            }
            @Override
            public String setValue(String value) {
                return value;
            }
        }, RcsUceAdapter.ERROR_GENERIC_FAILURE);

        // 500 Server Internal Error
        networkRespError.put(new Entry<Integer, String>() {
            @Override
            public Integer getKey() {
                return 500;
            }
            @Override
            public String getValue() {
                return ""Service Unavailable"";
            }
            @Override
            public String setValue(String value) {
                return value;
            }
        }, RcsUceAdapter.ERROR_SERVER_UNAVAILABLE);

        // 503 Service Unavailable
        networkRespError.put(new Entry<Integer, String>() {
            @Override
            public Integer getKey() {
                return 503;
            }
            @Override
            public String getValue() {
                return ""Service Unavailable"";
            }
            @Override
            public String setValue(String value) {
                return value;
            }
        }, RcsUceAdapter.ERROR_SERVER_UNAVAILABLE);

        TestRcsCapabilityExchangeImpl capabilityExchangeImpl = sServiceConnector
                .getCarrierService().getRcsFeature().getRcsCapabilityExchangeImpl();

        networkRespError.forEach((networkResp, expectedCallbackResult) -> {
            // Set the capabilities request failed with the given SIP code (without Reason header)
            capabilityExchangeImpl.setSubscribeOperation((uris, cb) -> {
                cb.onNetworkResponse(networkResp.getKey(), networkResp.getValue());
            });

            requestCapabilities(uceAdapter, numbers, callback);
            // Verify that the callback ""onError"" is called with the expected error code.
            try {
                assertEquals(expectedCallbackResult.intValue(), waitForIntResult(errorQueue));
                assertEquals(0L, waitForLongResult(retryAfterQueue));
            } catch (Exception e) {
                fail(""requestCapabilities with command error failed: "" + e);
            } finally {
                errorQueue.clear();
                retryAfterQueue.clear();
            }

            requestAvailability(uceAdapter, sTestNumberUri, callback);

            // Verify that the callback ""onError"" is called with the expected error code.
            try {
                assertEquals(expectedCallbackResult.intValue(), waitForIntResult(errorQueue));
                assertEquals(0L, waitForLongResult(retryAfterQueue));
            } catch (Exception e) {
                fail(""requestAvailability with command error failed: "" + e);
            } finally {
                errorQueue.clear();
                retryAfterQueue.clear();
            }

            /*
             * Set the capabilities request failed with the given SIP code (with Reason header)
             */
            capabilityExchangeImpl.setSubscribeOperation((uris, cb) -> {
                int networkRespCode = 200;
                String networkReason = ""OK"";
                cb.onNetworkResponse(networkRespCode, networkReason,
                        networkResp.getKey(), networkResp.getValue());
            });

            requestCapabilities(uceAdapter, numbers, callback);

            // Verify that the callback ""onError"" is called with the expected error code.
            try {
                assertEquals(expectedCallbackResult.intValue(), waitForIntResult(errorQueue));
                assertEquals(0L, waitForLongResult(retryAfterQueue));
            } catch (Exception e) {
                fail(""requestCapabilities with command error failed: "" + e);
            } finally {
                errorQueue.clear();
                retryAfterQueue.clear();
            }

            requestAvailability(uceAdapter, sTestNumberUri, callback);

            // Verify that the callback ""onError"" is called with the expected error code.
            try {
                assertEquals(expectedCallbackResult.intValue(), waitForIntResult(errorQueue));
                assertEquals(0L, waitForLongResult(retryAfterQueue));
            } catch (Exception e) {
                fail(""requestAvailability with command error failed: "" + e);
            } finally {
                errorQueue.clear();
                retryAfterQueue.clear();
            }
        });

        // Set the capabilities request will be failed with the 403 sip code
        int networkResp = 403;
        String networkRespReason = """";
        capabilityExchangeImpl.setSubscribeOperation((uris, cb) -> {
            cb.onNetworkResponse(networkResp, networkRespReason);
        });

        requestAvailability(uceAdapter, sTestNumberUri, callback);

        // Verify that the callback ""onError"" is called with the error code FORBIDDEN
        try {
            assertEquals(RcsUceAdapter.ERROR_FORBIDDEN, waitForIntResult(errorQueue));
            assertEquals(0L, waitForLongResult(retryAfterQueue));
        } catch (Exception e) {
            fail(""requestAvailability with command error failed: "" + e);
        } finally {
            errorQueue.clear();
            retryAfterQueue.clear();
        }

        requestCapabilities(uceAdapter, numbers, callback);

        // Verify that the capabilities request is sill failed because the ImsService has returned
        // the 403 error before.
        try {
            assertEquals(RcsUceAdapter.ERROR_FORBIDDEN, waitForIntResult(errorQueue));
            assertEquals(0L, waitForLongResult(retryAfterQueue));
        } catch (Exception e) {
            fail(""requestCapabilities with command error failed: "" + e);
        } finally {
            errorQueue.clear();
            retryAfterQueue.clear();
        }

        overrideCarrierConfig(null);
    }"	""	""	"RCS"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.RcsUceAdapterTest"	"testRequestCapabilitiesWithPresenceMechanism"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/RcsUceAdapterTest.java"	""	"public void testRequestCapabilitiesWithPresenceMechanism() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        RcsUceAdapter uceAdapter = imsManager.getImsRcsManager(sTestSub).getUceAdapter();
        assertNotNull(""UCE adapter should not be null!"", uceAdapter);

        // Remove the test contact capabilities
        removeTestContactFromEab();

        // Override the carrier config to support group subscribe.
        PersistableBundle bundle = new PersistableBundle();
        bundle.putBoolean(CarrierConfigManager.Ims.KEY_ENABLE_PRESENCE_GROUP_SUBSCRIBE_BOOL, true);
        overrideCarrierConfig(bundle);

        // Connect to the ImsService
        setupTestImsService(uceAdapter, true, true /* presence cap */, false /* OPTIONS */);

        TestRcsCapabilityExchangeImpl capabilityExchangeImpl = sServiceConnector
                .getCarrierService().getRcsFeature().getRcsCapabilityExchangeImpl();

        BlockingQueue<Integer> errorQueue = new LinkedBlockingQueue<>();
        BlockingQueue<Long> errorRetryQueue = new LinkedBlockingQueue<>();
        BlockingQueue<Boolean> completeQueue = new LinkedBlockingQueue<>();
        BlockingQueue<RcsContactUceCapability> capabilityQueue = new LinkedBlockingQueue<>();
        RcsUceAdapter.CapabilitiesCallback callback = new RcsUceAdapter.CapabilitiesCallback() {
            @Override
            public void onCapabilitiesReceived(List<RcsContactUceCapability> capabilities) {
                capabilities.forEach(c -> capabilityQueue.offer(c));
            }
            @Override
            public void onComplete() {
                completeQueue.offer(true);
            }
            @Override
            public void onError(int errorCode, long retryAfterMilliseconds) {
                errorQueue.offer(errorCode);
                errorRetryQueue.offer(retryAfterMilliseconds);
            }
        };

        // Prepare three contacts
        final Uri contact1 = sTestNumberUri;
        final Uri contact2 = sTestContact2Uri;
        final Uri contact3 = sTestContact3Uri;

        Collection<Uri> contacts = new ArrayList<>(3);
        contacts.add(contact1);
        contacts.add(contact2);
        contacts.add(contact3);

        ArrayList<String> pidfXmlList = new ArrayList<>(3);
        pidfXmlList.add(getPidfXmlData(contact1, true, true));
        pidfXmlList.add(getPidfXmlData(contact2, true, false));
        pidfXmlList.add(getPidfXmlData(contact3, false, false));

        // Setup the network response is 200 OK and notify capabilities update
        int networkRespCode = 200;
        String networkRespReason = ""OK"";
        capabilityExchangeImpl.setSubscribeOperation((uris, cb) -> {
            cb.onNetworkResponse(networkRespCode, networkRespReason);
            cb.onNotifyCapabilitiesUpdate(pidfXmlList);
            cb.onTerminated("""", 0L);
        });

        requestCapabilities(uceAdapter, contacts, callback);

        // Verify that all the three contact's capabilities are received
        RcsContactUceCapability capability = waitForResult(capabilityQueue);
        assertNotNull(""Capabilities were not received for contact: "" + contact1, capability);
        verifyCapabilityResult(capability, contact1, SOURCE_TYPE_NETWORK, REQUEST_RESULT_FOUND,
                true, true);

        capability = waitForResult(capabilityQueue);
        assertNotNull(""Capabilities were not received for contact: "" + contact2, capability);
        verifyCapabilityResult(capability, contact2, SOURCE_TYPE_NETWORK, REQUEST_RESULT_FOUND,
                true, false);

        capability = waitForResult(capabilityQueue);
        assertNotNull(""Capabilities were not received for contact: "" + contact3, capability);
        verifyCapabilityResult(capability, contact3, SOURCE_TYPE_NETWORK, REQUEST_RESULT_FOUND,
                false, false);

        // Verify the onCompleted is called
        waitForResult(completeQueue);

        errorQueue.clear();
        errorRetryQueue.clear();
        completeQueue.clear();
        capabilityQueue.clear();
        removeTestContactFromEab();

        // Setup the callback that some of the contacts are terminated.
        capabilityExchangeImpl.setSubscribeOperation((uris, cb) -> {
            cb.onNetworkResponse(404, ""NOT FOUND"");
        });

        requestCapabilities(uceAdapter, contacts, callback);

        // Verify the contacts are not found.
        capability = waitForResult(capabilityQueue);
        verifyCapabilityResult(capability, contact1, SOURCE_TYPE_NETWORK, REQUEST_RESULT_NOT_FOUND,
                false, false);

        capability = waitForResult(capabilityQueue);
        verifyCapabilityResult(capability, contact2, SOURCE_TYPE_NETWORK, REQUEST_RESULT_NOT_FOUND,
                false, false);

        capability = waitForResult(capabilityQueue);
        verifyCapabilityResult(capability, contact3, SOURCE_TYPE_NETWORK, REQUEST_RESULT_NOT_FOUND,
                false, false);

        // Verify the onCompleted is called
        waitForResult(completeQueue);

        errorQueue.clear();
        errorRetryQueue.clear();
        completeQueue.clear();
        capabilityQueue.clear();
        removeTestContactFromEab();

        // Setup the callback that some of the contacts are terminated.
        capabilityExchangeImpl.setSubscribeOperation((uris, cb) -> {
            List<Uri> uriList = new ArrayList(uris);
            cb.onNetworkResponse(networkRespCode, networkRespReason);
            // Notify capabilities updated for the first contact
            String pidfXml = pidfXmlList.get(0);
            cb.onNotifyCapabilitiesUpdate(Collections.singletonList(pidfXml));

            List<Pair<Uri, String>> terminatedResources = new ArrayList<>();
            for (int i = 1; i < uriList.size(); i++) {
                Pair<Uri, String> pair = Pair.create(uriList.get(i), ""noresource"");
                terminatedResources.add(pair);
            }
            cb.onResourceTerminated(terminatedResources);
            cb.onTerminated("""", 0L);
        });

        requestCapabilities(uceAdapter, contacts, callback);

        // Verify the first contact is found.
        capability = waitForResult(capabilityQueue);
        verifyCapabilityResult(capability, contact1, SOURCE_TYPE_NETWORK, REQUEST_RESULT_FOUND,
                true, true);

        // Verify the reset contacts are not found.
        capability = waitForResult(capabilityQueue);
        verifyCapabilityResult(capability, contact2, SOURCE_TYPE_NETWORK, REQUEST_RESULT_NOT_FOUND,
                true, false);

        capability = waitForResult(capabilityQueue);
        verifyCapabilityResult(capability, contact3, SOURCE_TYPE_NETWORK, REQUEST_RESULT_NOT_FOUND,
                false, false);

        // Verify the onCompleted is called
        waitForResult(completeQueue);

        overrideCarrierConfig(null);
    }"	""	""	"RCS"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.RcsUceAdapterTest"	"testRequestCapabilitiesFromCacheWithPresenceMechanism"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/RcsUceAdapterTest.java"	""	"public void testRequestCapabilitiesFromCacheWithPresenceMechanism() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        RcsUceAdapter uceAdapter = imsManager.getImsRcsManager(sTestSub).getUceAdapter();
        assertNotNull(""UCE adapter should not be null!"", uceAdapter);

        // Remove the test contact capabilities
        removeTestContactFromEab();

        // Connect to the ImsService
        setupTestImsService(uceAdapter, true, true /* presence cap */, false /* OPTIONS */);

        TestRcsCapabilityExchangeImpl capabilityExchangeImpl = sServiceConnector
                .getCarrierService().getRcsFeature().getRcsCapabilityExchangeImpl();

        BlockingQueue<Integer> errorQueue = new LinkedBlockingQueue<>();
        BlockingQueue<Long> errorRetryQueue = new LinkedBlockingQueue<>();
        BlockingQueue<Boolean> completeQueue = new LinkedBlockingQueue<>();
        BlockingQueue<RcsContactUceCapability> capabilityQueue = new LinkedBlockingQueue<>();
        RcsUceAdapter.CapabilitiesCallback callback = new RcsUceAdapter.CapabilitiesCallback() {
            @Override
            public void onCapabilitiesReceived(List<RcsContactUceCapability> capabilities) {
                capabilities.forEach(c -> capabilityQueue.offer(c));
            }
            @Override
            public void onComplete() {
                completeQueue.offer(true);
            }
            @Override
            public void onError(int errorCode, long retryAfterMilliseconds) {
                errorQueue.offer(errorCode);
                errorRetryQueue.offer(retryAfterMilliseconds);
            }
        };

        // Prepare three contacts
        final Uri contact1 = sTestNumberUri;
        final Uri contact2 = sTestContact2Uri;
        final Uri contact3 = sTestContact3Uri;

        Collection<Uri> contacts = new ArrayList<>(3);
        contacts.add(contact1);
        contacts.add(contact2);
        contacts.add(contact3);

        ArrayList<String> pidfXmlList = new ArrayList<>(3);
        pidfXmlList.add(getPidfXmlData(contact1, true, true));
        pidfXmlList.add(getPidfXmlData(contact2, true, false));
        pidfXmlList.add(getPidfXmlData(contact3, false, false));

        // Setup the network response is 200 OK and notify capabilities update
        int networkRespCode = 200;
        String networkRespReason = ""OK"";
        capabilityExchangeImpl.setSubscribeOperation((uris, cb) -> {
            cb.onNetworkResponse(networkRespCode, networkRespReason);
            cb.onNotifyCapabilitiesUpdate(pidfXmlList);
            cb.onTerminated("""", 0L);
        });

        requestCapabilities(uceAdapter, contacts, callback);

        // Verify that all the three contact's capabilities are received
        RcsContactUceCapability capability = waitForResult(capabilityQueue);
        assertNotNull(""Capabilities were not received for contact: "" + contact1, capability);
        verifyCapabilityResult(capability, contact1, SOURCE_TYPE_NETWORK, REQUEST_RESULT_FOUND,
                true, true);

        capability = waitForResult(capabilityQueue);
        assertNotNull(""Capabilities were not received for contact: "" + contact2, capability);
        verifyCapabilityResult(capability, contact2, SOURCE_TYPE_NETWORK, REQUEST_RESULT_FOUND,
                true, false);

        capability = waitForResult(capabilityQueue);
        assertNotNull(""Capabilities were not received for contact: "" + contact3, capability);
        verifyCapabilityResult(capability, contact3, SOURCE_TYPE_NETWORK, REQUEST_RESULT_FOUND,
                false, false);

        // Verify the onCompleted is called
        waitForResult(completeQueue);

        errorQueue.clear();
        errorRetryQueue.clear();
        completeQueue.clear();
        capabilityQueue.clear();

        // The request should not be called because the capabilities should be retrieved from cache.
        capabilityExchangeImpl.setSubscribeOperation((uris, cb) -> {
            fail(""The request should not be called."");
        });

        requestCapabilities(uceAdapter, contacts, callback);

        // Verify that all the three contact's capabilities are received
        capability = waitForResult(capabilityQueue);
        assertNotNull(""Capabilities were not received for contact: "" + contact1, capability);
        verifyCapabilityResult(capability, contact1, SOURCE_TYPE_CACHED, REQUEST_RESULT_FOUND,
                true, true);

        capability = waitForResult(capabilityQueue);
        assertNotNull(""Capabilities were not received for contact: "" + contact2, capability);
        verifyCapabilityResult(capability, contact2, SOURCE_TYPE_CACHED, REQUEST_RESULT_FOUND,
                true, false);

        capability = waitForResult(capabilityQueue);
        assertNotNull(""Capabilities were not received for contact: "" + contact3, capability);
        verifyCapabilityResult(capability, contact3, SOURCE_TYPE_CACHED, REQUEST_RESULT_FOUND,
                false, false);

        // Verify the onCompleted is called
        waitForResult(completeQueue);

        errorQueue.clear();
        errorRetryQueue.clear();
        completeQueue.clear();
        capabilityQueue.clear();
        removeTestContactFromEab();

        overrideCarrierConfig(null);
    }"	""	""	"RCS"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.RcsUceAdapterTest"	"testIndividualRequestCapabilities"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/RcsUceAdapterTest.java"	""	"public void testIndividualRequestCapabilities() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        RcsUceAdapter uceAdapter = imsManager.getImsRcsManager(sTestSub).getUceAdapter();
        assertNotNull(""UCE adapter should not be null!"", uceAdapter);

        // Remove the test contact capabilities
        removeTestContactFromEab();

        // Override the carrier config to not support group subscribe.
        PersistableBundle bundle = new PersistableBundle();
        bundle.putBoolean(CarrierConfigManager.Ims.KEY_ENABLE_PRESENCE_GROUP_SUBSCRIBE_BOOL, false);
        overrideCarrierConfig(bundle);

        // Connect to the ImsService
        setupTestImsService(uceAdapter, true, true /* presence cap */, false /* OPTIONS */);

        TestRcsCapabilityExchangeImpl capabilityExchangeImpl = sServiceConnector
                .getCarrierService().getRcsFeature().getRcsCapabilityExchangeImpl();

        BlockingQueue<Long> errorQueue = new LinkedBlockingQueue<>();
        BlockingQueue<Boolean> completeQueue = new LinkedBlockingQueue<>();
        List<RcsContactUceCapability> capabilityQueue = new ArrayList<>();
        RcsUceAdapter.CapabilitiesCallback callback = new RcsUceAdapter.CapabilitiesCallback() {
            @Override
            public void onCapabilitiesReceived(List<RcsContactUceCapability> capabilities) {
                capabilities.forEach(c -> capabilityQueue.add(c));
            }
            @Override
            public void onComplete() {
                completeQueue.offer(true);
            }
            @Override
            public void onError(int errorCode, long retryAfterMilliseconds) {
                errorQueue.offer(new Long(errorCode));
                errorQueue.offer(retryAfterMilliseconds);
            }
        };

        // Prepare three contacts
        final Uri contact1 = sTestNumberUri;
        final Uri contact2 = sTestContact2Uri;
        final Uri contact3 = sTestContact3Uri;

        Collection<Uri> contacts = new ArrayList<>(3);
        contacts.add(contact1);
        contacts.add(contact2);
        contacts.add(contact3);

        List<String> pidfXml1 = Collections.singletonList(getPidfXmlData(contact1, true, true));
        List<String> pidfXml2 = Collections.singletonList(getPidfXmlData(contact2, true, false));
        List<String> pidfXml3 = Collections.singletonList(getPidfXmlData(contact3, false, false));

        // Setup the network response is 200 OK and notify capabilities update
        int networkRespCode = 200;
        String networkRespReason = ""OK"";
        AtomicInteger receiveRequestCount = new AtomicInteger(0);
        capabilityExchangeImpl.setSubscribeOperation((uris, cb) -> {
            receiveRequestCount.incrementAndGet();
            cb.onNetworkResponse(networkRespCode, networkRespReason);
            assertEquals(1, uris.size());
            String uriPart = uris.iterator().next().getSchemeSpecificPart();
            if (contact1.getSchemeSpecificPart().equalsIgnoreCase(uriPart)) {
                cb.onNotifyCapabilitiesUpdate(pidfXml1);
            } else if (contact2.getSchemeSpecificPart().equalsIgnoreCase(uriPart)) {
                cb.onNotifyCapabilitiesUpdate(pidfXml2);
            } else if (contact3.getSchemeSpecificPart().equalsIgnoreCase(uriPart)) {
                cb.onNotifyCapabilitiesUpdate(pidfXml3);
            }
            cb.onTerminated("""", 0L);
        });

        requestCapabilities(uceAdapter, contacts, callback);

        // Verify the onCompleted is called
        waitForResult(completeQueue);

        // Verify the capability request has been split to individual requests.
        assertEquals(contacts.size(), receiveRequestCount.get());

        // verify the capabilities result
        assertEquals(contacts.size(), capabilityQueue.size());
        for (RcsContactUceCapability capability : capabilityQueue) {
            Uri contact = capability.getContactUri();
            if (contact1.equals(contact)) {
                verifyCapabilityResult(capability, contact1, SOURCE_TYPE_NETWORK,
                        REQUEST_RESULT_FOUND, true, true);
            } else if (contact2.equals(contact)) {
                verifyCapabilityResult(capability, contact2, SOURCE_TYPE_NETWORK,
                        REQUEST_RESULT_FOUND, true, false);
            } else if (contact3.equals(contact)) {
                verifyCapabilityResult(capability, contact3, SOURCE_TYPE_NETWORK,
                        REQUEST_RESULT_FOUND, false, false);
            } else {
                fail(""The contact of the capabilities result is invalid."");
            }
        }

        errorQueue.clear();
        completeQueue.clear();
        capabilityQueue.clear();
        removeTestContactFromEab();
        receiveRequestCount.set(0);

        // Setup the callback that some of the contacts are terminated.
        capabilityExchangeImpl.setSubscribeOperation((uris, cb) -> {
            receiveRequestCount.incrementAndGet();
            cb.onNetworkResponse(networkRespCode, networkRespReason);
            assertEquals(1, uris.size());
            String uriPart = uris.iterator().next().getSchemeSpecificPart();
            if (contact1.getSchemeSpecificPart().equalsIgnoreCase(uriPart)) {
                cb.onNotifyCapabilitiesUpdate(pidfXml1);
            } else {
                // Notify resources terminated for the reset contacts
                List<Uri> uriList = new ArrayList(uris);
                List<Pair<Uri, String>> terminatedResources = new ArrayList<>();
                for (int i = 0; i < uriList.size(); i++) {
                    Pair<Uri, String> pair = Pair.create(uriList.get(i), ""noresource"");
                    terminatedResources.add(pair);
                }
                cb.onResourceTerminated(terminatedResources);
            }
            cb.onTerminated("""", 0L);
        });

        requestCapabilities(uceAdapter, contacts, callback);

        // Verify the onCompleted is called
        waitForResult(completeQueue);

        // Verify the capability request has been split to individual requests.
        assertEquals(contacts.size(), receiveRequestCount.get());

        // verify the capabilities result
        assertEquals(contacts.size(), capabilityQueue.size());
        for (RcsContactUceCapability capability : capabilityQueue) {
            Uri contact = capability.getContactUri();
            if (contact1.equals(contact)) {
                verifyCapabilityResult(capability, contact1, SOURCE_TYPE_NETWORK,
                        REQUEST_RESULT_FOUND, true, true);
            } else if (contact2.equals(contact)) {
                verifyCapabilityResult(capability, contact2, SOURCE_TYPE_NETWORK,
                        REQUEST_RESULT_NOT_FOUND, true, false);
            } else if (contact3.equals(contact)) {
                verifyCapabilityResult(capability, contact3, SOURCE_TYPE_NETWORK,
                        REQUEST_RESULT_NOT_FOUND, false,
                        false);
            } else {
                fail(""The contact of the capabilities result is invalid."");
            }
        }
        overrideCarrierConfig(null);
    }"	""	""	"RCS"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.RcsUceAdapterTest"	"testRequestCapabilitiesWithOptionsMechanism"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/RcsUceAdapterTest.java"	""	"public void testRequestCapabilitiesWithOptionsMechanism() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        RcsUceAdapter uceAdapter = imsManager.getImsRcsManager(sTestSub).getUceAdapter();
        assertNotNull(""UCE adapter should not be null!"", uceAdapter);

        // Remove the test contact capabilities
        removeTestContactFromEab();

        // Connect to the ImsService
        setupTestImsService(uceAdapter, true, false, true /* OPTIONS enabled */);

        TestRcsCapabilityExchangeImpl capabilityExchangeImpl = sServiceConnector
                .getCarrierService().getRcsFeature().getRcsCapabilityExchangeImpl();

        // The test contact
        Collection<Uri> contacts = new ArrayList<>(3);
        contacts.add(sTestNumberUri);

        // The result callback
        BlockingQueue<Long> errorQueue = new LinkedBlockingQueue<>();
        BlockingQueue<Boolean> completeQueue = new LinkedBlockingQueue<>();
        BlockingQueue<RcsContactUceCapability> capabilityQueue = new LinkedBlockingQueue<>();
        RcsUceAdapter.CapabilitiesCallback callback = new RcsUceAdapter.CapabilitiesCallback() {
            @Override
            public void onCapabilitiesReceived(List<RcsContactUceCapability> capabilities) {
                capabilities.forEach(c -> capabilityQueue.offer(c));
            }
            @Override
            public void onComplete() {
                completeQueue.offer(true);
            }
            @Override
            public void onError(int errorCode, long retryAfterMilliseconds) {
                errorQueue.offer(new Long(errorCode));
                errorQueue.offer(retryAfterMilliseconds);
            }
        };

        // Set the result of the network response is 200 OK.
        final List<String> featureTags = new ArrayList<>();
        featureTags.add(FEATURE_TAG_CHAT);
        featureTags.add(FEATURE_TAG_FILE_TRANSFER);
        featureTags.add(FEATURE_TAG_MMTEL_AUDIO_CALL);
        featureTags.add(FEATURE_TAG_MMTEL_VIDEO_CALL);
        capabilityExchangeImpl.setOptionsOperation((contact, myCapabilities, optionsCallback) -> {
            int sipCode = 200;
            String reason = ""OK"";
            optionsCallback.onNetworkResponse(sipCode, reason, featureTags);
        });

        // Request capabilities by calling the API requestCapabilities.
        requestCapabilities(uceAdapter, contacts, callback);

        // Verify the callback ""onCapabilitiesReceived"" is called.
        RcsContactUceCapability capability = waitForResult(capabilityQueue);
        assertNotNull(""RcsContactUceCapability should not be null"", capability);
        // Verify the callback ""onComplete"" is called.
        assertNotNull(waitForResult(completeQueue));
        assertEquals(RcsContactUceCapability.SOURCE_TYPE_NETWORK, capability.getSourceType());
        assertEquals(sTestNumberUri, capability.getContactUri());
        assertEquals(RcsContactUceCapability.REQUEST_RESULT_FOUND, capability.getRequestResult());
        assertEquals(RcsContactUceCapability.CAPABILITY_MECHANISM_OPTIONS,
                capability.getCapabilityMechanism());
        Set<String> resultFeatureTags = capability.getFeatureTags();
        assertEquals(featureTags.size(), resultFeatureTags.size());
        for (String featureTag : featureTags) {
            if (!resultFeatureTags.contains(featureTag)) {
                fail(""Cannot find feature tag in the result"");
            }
        }
        errorQueue.clear();
        completeQueue.clear();
        capabilityQueue.clear();
        // Remove the test contact capabilities
        removeTestContactFromEab();

        // Request capabilities by calling the API requestAvailability.
        requestAvailability(uceAdapter, sTestContact2Uri, callback);

        // Verify the callback ""onCapabilitiesReceived"" is called.
        capability = waitForResult(capabilityQueue);
        // Verify the callback ""onComplete"" is called.
        waitForResult(completeQueue);
        assertNotNull(""RcsContactUceCapability should not be null"", capability);
        assertEquals(RcsContactUceCapability.SOURCE_TYPE_NETWORK, capability.getSourceType());
        assertEquals(sTestContact2Uri, capability.getContactUri());
        assertEquals(RcsContactUceCapability.REQUEST_RESULT_FOUND, capability.getRequestResult());
        assertEquals(RcsContactUceCapability.CAPABILITY_MECHANISM_OPTIONS,
                capability.getCapabilityMechanism());
        resultFeatureTags = capability.getFeatureTags();
        assertEquals(featureTags.size(), resultFeatureTags.size());
        for (String featureTag : featureTags) {
            if (!resultFeatureTags.contains(featureTag)) {
                fail(""Cannot find feature tag in the result"");
            }
        }
        errorQueue.clear();
        completeQueue.clear();
        capabilityQueue.clear();
        // Remove the test contact capabilities
        removeTestContactFromEab();

        // Set the OPTIONS result is failed.
        capabilityExchangeImpl.setOptionsOperation((contact, myCapabilities, optionsCallback) -> {
            int sipCode = 400;
            String reason = ""Bad Request"";
            optionsCallback.onNetworkResponse(sipCode, reason, Collections.EMPTY_LIST);
        });

        // Request capabilities by calling the API requestCapabilities.
        requestCapabilities(uceAdapter, contacts, callback);

        // Verify the callback ""onError"" is called.
        assertEquals(RcsUceAdapter.ERROR_GENERIC_FAILURE, waitForLongResult(errorQueue));

        // The callback ""onCapabilitiesReceived"" should be called with NOT FOUND
        capability = waitForResult(capabilityQueue);
        assertEquals(RcsContactUceCapability.REQUEST_RESULT_NOT_FOUND,
                capability.getRequestResult());

        overrideCarrierConfig(null);
    }"	""	""	"RCS MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.RcsUceAdapterTest"	"testRequestCapabilitiesFromCacheWithOptionsMechanism"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/RcsUceAdapterTest.java"	""	"public void testRequestCapabilitiesFromCacheWithOptionsMechanism() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        RcsUceAdapter uceAdapter = imsManager.getImsRcsManager(sTestSub).getUceAdapter();
        assertNotNull(""UCE adapter should not be null!"", uceAdapter);

        // Remove the test contact capabilities
        removeTestContactFromEab();

        // Connect to the ImsService
        setupTestImsService(uceAdapter, true, false, true /* OPTIONS enabled */);

        TestRcsCapabilityExchangeImpl capabilityExchangeImpl = sServiceConnector
                .getCarrierService().getRcsFeature().getRcsCapabilityExchangeImpl();

        // The result callback
        BlockingQueue<Integer> errorQueue = new LinkedBlockingQueue<>();
        BlockingQueue<Long> retryAfterQueue = new LinkedBlockingQueue<>();
        BlockingQueue<Boolean> completeQueue = new LinkedBlockingQueue<>();
        BlockingQueue<RcsContactUceCapability> capabilityQueue = new LinkedBlockingQueue<>();
        RcsUceAdapter.CapabilitiesCallback callback = new RcsUceAdapter.CapabilitiesCallback() {
            @Override
            public void onCapabilitiesReceived(List<RcsContactUceCapability> capabilities) {
                capabilities.forEach(c -> capabilityQueue.offer(c));
            }
            @Override
            public void onComplete() {
                completeQueue.offer(true);
            }
            @Override
            public void onError(int errorCode, long retryAfterMilliseconds) {
                errorQueue.offer(errorCode);
                retryAfterQueue.offer(retryAfterMilliseconds);
            }
        };

        // Set the result of the network response is 200 OK.
        final List<String> featureTags = new ArrayList<>();
        featureTags.add(FEATURE_TAG_CHAT);
        featureTags.add(FEATURE_TAG_FILE_TRANSFER);
        featureTags.add(FEATURE_TAG_MMTEL_AUDIO_CALL);
        featureTags.add(FEATURE_TAG_MMTEL_VIDEO_CALL);
        capabilityExchangeImpl.setOptionsOperation((contact, myCapabilities, optionsCallback) -> {
            int sipCode = 200;
            String reason = ""OK"";
            optionsCallback.onNetworkResponse(sipCode, reason, featureTags);
        });

        // Request capabilities with the for the first time.
        requestCapabilities(uceAdapter, Collections.singletonList(sTestNumberUri), callback);

        // Verify the callback ""onCapabilitiesReceived"" is called.
        RcsContactUceCapability capability = waitForResult(capabilityQueue);
        assertNotNull(""RcsContactUceCapability should not be null"", capability);
        // Verify the callback ""onComplete"" is called.
        assertNotNull(waitForResult(completeQueue));
        assertEquals(RcsContactUceCapability.SOURCE_TYPE_NETWORK, capability.getSourceType());
        assertEquals(sTestNumberUri, capability.getContactUri());
        assertEquals(RcsContactUceCapability.REQUEST_RESULT_FOUND, capability.getRequestResult());
        assertEquals(RcsContactUceCapability.CAPABILITY_MECHANISM_OPTIONS,
                capability.getCapabilityMechanism());
        Set<String> resultFeatureTags = capability.getFeatureTags();
        assertEquals(featureTags.size(), resultFeatureTags.size());
        for (String featureTag : featureTags) {
            if (!resultFeatureTags.contains(featureTag)) {
                fail(""Cannot find feature tag in the result"");
            }
        }
        errorQueue.clear();
        retryAfterQueue.clear();
        completeQueue.clear();
        capabilityQueue.clear();

        // Request capabilities for the second time.
        requestAvailability(uceAdapter, sTestContact2Uri, callback);

        // Verify the callback ""onCapabilitiesReceived"" is called.
        capability = waitForResult(capabilityQueue);
        // Verify the callback ""onComplete"" is called.
        waitForResult(completeQueue);
        assertNotNull(""RcsContactUceCapability should not be null"", capability);
        assertEquals(RcsContactUceCapability.SOURCE_TYPE_NETWORK, capability.getSourceType());
        assertEquals(sTestContact2Uri, capability.getContactUri());
        assertEquals(RcsContactUceCapability.REQUEST_RESULT_FOUND, capability.getRequestResult());
        assertEquals(RcsContactUceCapability.CAPABILITY_MECHANISM_OPTIONS,
                capability.getCapabilityMechanism());
        resultFeatureTags = capability.getFeatureTags();
        assertEquals(featureTags.size(), resultFeatureTags.size());
        for (String featureTag : featureTags) {
            if (!resultFeatureTags.contains(featureTag)) {
                fail(""Cannot find feature tag in the result"");
            }
        }
        errorQueue.clear();
        retryAfterQueue.clear();
        completeQueue.clear();
        capabilityQueue.clear();

        // Set the OPTIONS result is failed because the capabilities should be retrieved from cache.
        capabilityExchangeImpl.setOptionsOperation((contact, myCapabilities, optionsCallback) -> {
            fail(""The Options request should not be called."");
        });

        // The contact to requeste the capabilities is the same as the first time.
        requestCapabilities(uceAdapter, Collections.singletonList(sTestNumberUri), callback);

        // Verify the callback ""onCapabilitiesReceived"" is called.
        capability = waitForResult(capabilityQueue);
        assertNotNull(""RcsContactUceCapability should not be null"", capability);
        // Verify the callback ""onComplete"" is called.
        assertNotNull(waitForResult(completeQueue));
        // Verify the capabilities are retrieved from the cache.
        assertEquals(RcsContactUceCapability.SOURCE_TYPE_CACHED, capability.getSourceType());
        assertEquals(sTestNumberUri, capability.getContactUri());
        assertEquals(RcsContactUceCapability.REQUEST_RESULT_FOUND, capability.getRequestResult());
        assertEquals(RcsContactUceCapability.CAPABILITY_MECHANISM_OPTIONS,
                capability.getCapabilityMechanism());
        resultFeatureTags = capability.getFeatureTags();
        assertEquals(featureTags.size(), resultFeatureTags.size());
        for (String featureTag : featureTags) {
            if (!resultFeatureTags.contains(featureTag)) {
                fail(""Cannot find feature tag in the result"");
            }
        }
        errorQueue.clear();
        retryAfterQueue.clear();
        completeQueue.clear();
        capabilityQueue.clear();
        removeTestContactFromEab();

        overrideCarrierConfig(null);
    }"	""	""	"RCS MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.RcsUceAdapterTest"	"testIndividualRequestCapabilitiesWithOptionsMechanism"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/RcsUceAdapterTest.java"	""	"public void testIndividualRequestCapabilitiesWithOptionsMechanism() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        RcsUceAdapter uceAdapter = imsManager.getImsRcsManager(sTestSub).getUceAdapter();
        assertNotNull(""UCE adapter should not be null!"", uceAdapter);

        // Remove the test contact capabilities
        removeTestContactFromEab();

        // Connect to the ImsService
        setupTestImsService(uceAdapter, true, false, true /* OPTIONS enabled */);

        TestRcsCapabilityExchangeImpl capabilityExchangeImpl = sServiceConnector
                .getCarrierService().getRcsFeature().getRcsCapabilityExchangeImpl();

        // Prepare three test contacts
        Collection<Uri> contacts = new ArrayList<>(3);
        contacts.add(sTestNumberUri);
        contacts.add(sTestContact2Uri);
        contacts.add(sTestContact3Uri);

        // The result callback
        BlockingQueue<Long> errorQueue = new LinkedBlockingQueue<>();
        BlockingQueue<Boolean> completeQueue = new LinkedBlockingQueue<>();
        List<RcsContactUceCapability> capabilityQueue = new ArrayList<>();
        RcsUceAdapter.CapabilitiesCallback callback = new RcsUceAdapter.CapabilitiesCallback() {
            @Override
            public void onCapabilitiesReceived(List<RcsContactUceCapability> capabilities) {
                capabilities.forEach(c -> capabilityQueue.add(c));
            }
            @Override
            public void onComplete() {
                completeQueue.offer(true);
            }
            @Override
            public void onError(int errorCode, long retryAfterMilliseconds) {
                errorQueue.offer(new Long(errorCode));
                errorQueue.offer(retryAfterMilliseconds);
            }
        };

        // Set the result of the network response is 200 OK.
        final List<String> featureTags = new ArrayList<>();
        featureTags.add(FEATURE_TAG_CHAT);
        featureTags.add(FEATURE_TAG_FILE_TRANSFER);
        featureTags.add(FEATURE_TAG_MMTEL_AUDIO_CALL);
        featureTags.add(FEATURE_TAG_MMTEL_VIDEO_CALL);

        AtomicInteger receiveRequestCount = new AtomicInteger(0);

        capabilityExchangeImpl.setOptionsOperation((contact, myCapabilities, optionsCallback) -> {
            receiveRequestCount.incrementAndGet();
            int sipCode = 200;
            String reason = ""OK"";
            optionsCallback.onNetworkResponse(sipCode, reason, featureTags);
        });

        // Request capabilities by calling the API requestCapabilities.
        requestCapabilities(uceAdapter, contacts, callback);

        // Verify the callback ""onComplete"" is called.
        assertNotNull(waitForResult(completeQueue));

        // Verify the capability request has been split to individual requests.
        assertEquals(contacts.size(), receiveRequestCount.get());

        // Verify the result
        verifyOptionsCapabilityResult(capabilityQueue, contacts,
                RcsContactUceCapability.SOURCE_TYPE_NETWORK,
                RcsContactUceCapability.CAPABILITY_MECHANISM_OPTIONS,
                RcsContactUceCapability.REQUEST_RESULT_FOUND, featureTags);

        errorQueue.clear();
        completeQueue.clear();
        capabilityQueue.clear();
        receiveRequestCount.set(0);
        removeTestContactFromEab();

        // Set the OPTIONS result is failed.
        capabilityExchangeImpl.setOptionsOperation((contact, myCapabilities, optionsCallback) -> {
            receiveRequestCount.incrementAndGet();
            int sipCode = 400;
            String reason = ""Bad Request"";
            optionsCallback.onNetworkResponse(sipCode, reason, Collections.EMPTY_LIST);
        });

        // Request capabilities by calling the API requestCapabilities.
        requestCapabilities(uceAdapter, contacts, callback);

        // Verify the callback ""onError"" is called.
        assertEquals(RcsUceAdapter.ERROR_GENERIC_FAILURE, waitForLongResult(errorQueue));

        // Verify the result
        verifyOptionsCapabilityResult(capabilityQueue, contacts,
                RcsContactUceCapability.SOURCE_TYPE_NETWORK,
                RcsContactUceCapability.CAPABILITY_MECHANISM_OPTIONS,
                RcsContactUceCapability.REQUEST_RESULT_NOT_FOUND, Collections.EMPTY_LIST);

        errorQueue.clear();
        completeQueue.clear();
        capabilityQueue.clear();
        receiveRequestCount.set(0);
        removeTestContactFromEab();

        overrideCarrierConfig(null);
    }"	""	""	"RCS MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.RcsUceAdapterTest"	"testOptionsRequestFromNetwork"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/RcsUceAdapterTest.java"	""	"public void testOptionsRequestFromNetwork() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        RcsUceAdapter uceAdapter = imsManager.getImsRcsManager(sTestSub).getUceAdapter();
        assertNotNull(""UCE adapter should not be null!"", uceAdapter);

        // Remove the test contact capabilities
        removeTestContactFromEab();

        // Connect to the ImsService
        setupTestImsService(uceAdapter, true, false, true /* OPTIONS enabled */);

        CapabilityExchangeEventListener eventListener =
                sServiceConnector.getCarrierService().getRcsFeature().getEventListener();

        final Uri contact = sTestContact2Uri;
        Set<String> remoteCapabilities = new ArraySet<>();
        remoteCapabilities.add(FEATURE_TAG_CHAT);
        remoteCapabilities.add(FEATURE_TAG_FILE_TRANSFER);
        remoteCapabilities.add(FEATURE_TAG_MMTEL_AUDIO_CALL);
        remoteCapabilities.add(FEATURE_TAG_MMTEL_VIDEO_CALL);
        BlockingQueue<Pair<RcsContactUceCapability, Boolean>> respToCapRequestQueue =
                new LinkedBlockingQueue<>();
        OptionsRequestCallback callback = new OptionsRequestCallback() {
            @Override
            public void onRespondToCapabilityRequest(RcsContactUceCapability capabilities,
                    boolean isBlocked) {
                respToCapRequestQueue.offer(new Pair<>(capabilities, isBlocked));
            }
            @Override
            public void onRespondToCapabilityRequestWithError(int sipCode, String reason) {
            }
        };

        // Notify the remote capability request
        eventListener.onRemoteCapabilityRequest(contact, remoteCapabilities, callback);

        // Verify receive the result
        Pair<RcsContactUceCapability, Boolean> capability = waitForResult(respToCapRequestQueue);
        assertNotNull(""RcsContactUceCapability should not be null"", capability);
        assertEquals(RcsContactUceCapability.SOURCE_TYPE_CACHED, capability.first.getSourceType());
        assertEquals(RcsContactUceCapability.REQUEST_RESULT_FOUND,
                capability.first.getRequestResult());
        assertEquals(RcsContactUceCapability.CAPABILITY_MECHANISM_OPTIONS,
                capability.first.getCapabilityMechanism());
        // Should not report blocked
        assertFalse(""This number is not blocked, so the API should not report blocked"",
                capability.second);

        overrideCarrierConfig(null);
    }"	""	""	"RCS MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.RcsUceAdapterTest"	"testOptionsRequestFromNetworkBlocked"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/RcsUceAdapterTest.java"	""	"public void testOptionsRequestFromNetworkBlocked() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        RcsUceAdapter uceAdapter = imsManager.getImsRcsManager(sTestSub).getUceAdapter();
        assertNotNull(""UCE adapter should not be null!"", uceAdapter);

        // Remove the test contact capabilities
        removeTestContactFromEab();

        // Connect to the ImsService
        setupTestImsService(uceAdapter, true, false, true /* OPTIONS enabled */);

        CapabilityExchangeEventListener eventListener =
                sServiceConnector.getCarrierService().getRcsFeature().getEventListener();

        final Uri contact = sTestNumberUri;
        Set<String> remoteCapabilities = new ArraySet<>();
        remoteCapabilities.add(FEATURE_TAG_CHAT);
        remoteCapabilities.add(FEATURE_TAG_FILE_TRANSFER);
        remoteCapabilities.add(FEATURE_TAG_MMTEL_AUDIO_CALL);
        remoteCapabilities.add(FEATURE_TAG_MMTEL_VIDEO_CALL);

        BlockingQueue<Pair<RcsContactUceCapability, Boolean>> respToCapRequestQueue =
                new LinkedBlockingQueue<>();
        OptionsRequestCallback callback = new OptionsRequestCallback() {
            @Override
            public void onRespondToCapabilityRequest(RcsContactUceCapability capabilities,
                    boolean isBlocked) {
                respToCapRequestQueue.offer(new Pair<>(capabilities, isBlocked));
            }
            @Override
            public void onRespondToCapabilityRequestWithError(int sipCode, String reason) {
            }
        };

        // Must be default SMS app to block numbers
        sServiceConnector.setDefaultSmsApp();
        Uri blockedUri = BlockedNumberUtil.insertBlockedNumber(getContext(), sTestPhoneNumber);
        assertNotNull(""could not block number"", blockedUri);
        try {
            // Notify the remote capability request
            eventListener.onRemoteCapabilityRequest(contact, remoteCapabilities, callback);

            // Verify receive the result
            Pair<RcsContactUceCapability, Boolean> capability =
                    waitForResult(respToCapRequestQueue);
            assertNotNull(""RcsContactUceCapability should not be null"", capability);
            assertEquals(RcsContactUceCapability.SOURCE_TYPE_CACHED,
                    capability.first.getSourceType());
            assertEquals(RcsContactUceCapability.REQUEST_RESULT_FOUND,
                    capability.first.getRequestResult());
            assertEquals(RcsContactUceCapability.CAPABILITY_MECHANISM_OPTIONS,
                    capability.first.getCapabilityMechanism());
            // Should report blocked
            assertTrue(""this number is blocked, so API should report blocked"",
                    capability.second);
        } finally {
            BlockedNumberUtil.deleteBlockedNumber(getContext(), blockedUri);
            sServiceConnector.restoreDefaultSmsApp();
        }

        overrideCarrierConfig(null);
    }"	""	""	"RCS MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.RcsUceAdapterTest"	"testForbidCapabilitiesRequest"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/RcsUceAdapterTest.java"	""	"public void testForbidCapabilitiesRequest() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        RcsUceAdapter uceAdapter = imsManager.getImsRcsManager(sTestSub).getUceAdapter();
        assertNotNull(""UCE adapter should not be null!"", uceAdapter);

        // Remove the test contact capabilities
        removeTestContactFromEab();

        // Override the carrier config of SIP 489 request forbidden.
        PersistableBundle bundle = new PersistableBundle();
        bundle.putBoolean(CarrierConfigManager.Ims.KEY_RCS_REQUEST_FORBIDDEN_BY_SIP_489_BOOL, true);
        overrideCarrierConfig(bundle);

        // Connect to the ImsService
        setupTestImsService(uceAdapter, true, true /* presence cap */, false /* OPTIONS */);

        TestRcsCapabilityExchangeImpl capabilityExchangeImpl = sServiceConnector
                .getCarrierService().getRcsFeature().getRcsCapabilityExchangeImpl();

        BlockingQueue<Integer> errorQueue = new LinkedBlockingQueue<>();
        BlockingQueue<Long> retryAfterQueue = new LinkedBlockingQueue<>();
        BlockingQueue<Boolean> completeQueue = new LinkedBlockingQueue<>();
        List<RcsContactUceCapability> capabilityQueue = new ArrayList<>();
        RcsUceAdapter.CapabilitiesCallback callback = new RcsUceAdapter.CapabilitiesCallback() {
            @Override
            public void onCapabilitiesReceived(List<RcsContactUceCapability> capabilities) {
                capabilities.forEach(c -> capabilityQueue.add(c));
            }

            @Override
            public void onComplete() {
                completeQueue.offer(true);
            }

            @Override
            public void onError(int errorCode, long retryAfterMillis) {
                errorQueue.offer(errorCode);
                retryAfterQueue.offer(retryAfterMillis);
            }
        };

        // Prepare two contacts
        final Uri contact1 = sTestNumberUri;
        final Uri contact2 = sTestContact2Uri;
        Collection<Uri> contacts = new ArrayList<>(2);
        contacts.add(contact1);
        contacts.add(contact2);

        // Prepare the network response.
        final int sipCodeBadEvent = 489;
        final int sipCodeForbidden = 403;
        AtomicInteger subscribeRequestCount = new AtomicInteger(0);

        // Prepare a map to define the sip code and its associated result.
        Map<Integer, Integer> networkSipCodeMap = new HashMap<>();
        networkSipCodeMap.put(sipCodeBadEvent, RcsUceAdapter.ERROR_FORBIDDEN);
        networkSipCodeMap.put(sipCodeForbidden, RcsUceAdapter.ERROR_FORBIDDEN);

        // Verify each command error code and the expected callback result
        networkSipCodeMap.forEach((sipCode, expectedCallbackResult) -> {
            // Setup the capabilities request response with the given sip code.
            capabilityExchangeImpl.setSubscribeOperation((uris, cb) -> {
                subscribeRequestCount.incrementAndGet();
                cb.onNetworkResponse(sipCode, """");
            });

            try {
                // Request contact uce capabilities
                requestCapabilities(uceAdapter, contacts, callback);

                // Verify that the callback ""onError"" is called with the error code FORBIDDEN
                assertEquals(RcsUceAdapter.ERROR_FORBIDDEN, waitForIntResult(errorQueue));
                // Verify the retryAfter value
                long retryAfterMillis = waitForLongResult(retryAfterQueue);
                if (sipCode == sipCodeForbidden) {
                    assertEquals(0L, retryAfterMillis);
                } else if (sipCode == sipCodeBadEvent) {
                    assertTrue(retryAfterMillis > 0L);
                }

                // Verify the ImsService received the capabilities request.
                assertEquals(1, subscribeRequestCount.get());
            } catch (Exception e) {
                fail(""testForbiddenResponseToCapabilitiesRequest with command error failed: "" + e);
            } finally {
                errorQueue.clear();
                retryAfterQueue.clear();
                subscribeRequestCount.set(0);
            }

            // Prepare the network response with sip code 200 OK
            capabilityExchangeImpl.setSubscribeOperation((uris, cb) -> {
                subscribeRequestCount.incrementAndGet();
                cb.onNetworkResponse(200, ""OK"");
            });

            try {
                // Request contact uce capabilities again.
                requestCapabilities(uceAdapter, contacts, callback);

                // Verify that the callback ""onError"" is called with the error code FORBIDDEN
                assertEquals(RcsUceAdapter.ERROR_FORBIDDEN, waitForIntResult(errorQueue));
                // Verify the retryAfter value
                long retryAfterMillis = waitForLongResult(retryAfterQueue);
                if (sipCode == sipCodeForbidden) {
                    assertEquals(0L, retryAfterMillis);
                } else if (sipCode == sipCodeBadEvent) {
                    assertTrue(retryAfterMillis > 0L);
                }

                // Verify that the capabilities won't be send to the ImsService because the
                // uce request is forbidden.
                assertEquals(0, subscribeRequestCount.get());
            } catch (Exception e) {
                fail(""testForbiddenResponseToCapabilitiesRequest with command error failed: "" + e);
            } finally {
                errorQueue.clear();
                retryAfterQueue.clear();
                subscribeRequestCount.set(0);
            }

            // Reset the device status
            removeUceRequestDisallowedStatus();
        });

        overrideCarrierConfig(null);
    }"	""	""	"RCS"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.RcsUceAdapterTest"	"testTerminatedCallbackWithCapabilitiesRequest"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/RcsUceAdapterTest.java"	""	"public void testTerminatedCallbackWithCapabilitiesRequest() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }

        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        RcsUceAdapter uceAdapter = imsManager.getImsRcsManager(sTestSub).getUceAdapter();
        assertNotNull(""UCE adapter should not be null!"", uceAdapter);

        // Remove the test contact capabilities
        removeTestContactFromEab();

        // Connect to the ImsService
        setupTestImsService(uceAdapter, true, true /* presence cap */, false /* OPTIONS */);

        ArrayList<String> pidfXmlList = new ArrayList<>(1);
        pidfXmlList.add(getPidfXmlData(sTestNumberUri, true, true));

        TestRcsCapabilityExchangeImpl capabilityExchangeImpl = sServiceConnector
                .getCarrierService().getRcsFeature().getRcsCapabilityExchangeImpl();

        BlockingQueue<Integer> errorQueue = new LinkedBlockingQueue<>();
        BlockingQueue<Long> errorRetryQueue = new LinkedBlockingQueue<>();
        BlockingQueue<Boolean> completeQueue = new LinkedBlockingQueue<>();
        BlockingQueue<RcsContactUceCapability> capabilityQueue = new LinkedBlockingQueue<>();
        RcsUceAdapter.CapabilitiesCallback callback = new RcsUceAdapter.CapabilitiesCallback() {
            @Override
            public void onCapabilitiesReceived(List<RcsContactUceCapability> capabilities) {
                capabilities.forEach(c -> capabilityQueue.offer(c));
            }
            @Override
            public void onComplete() {
                completeQueue.offer(true);
            }
            @Override
            public void onError(int errorCode, long retryAfterMillis) {
                errorQueue.offer(errorCode);
                errorRetryQueue.offer(retryAfterMillis);
            }
        };

        // Prepare the test contact and the callback
        Collection<Uri> numbers = new ArrayList<>(1);
        numbers.add(sTestNumberUri);

        // Prepare the network response is 200 OK and the capabilities update
        int networkRespCode = 200;
        String networkRespReason = ""OK"";

        Map<SomeArgs, SomeArgs> terminatedMap = new HashMap<>();
        SomeArgs deactivatedArgs = SomeArgs.obtain();
        deactivatedArgs.arg1 = ""deactivated"";
        deactivatedArgs.arg2 = Long.valueOf(3000L);
        SomeArgs deactivatedExpectedArgs = SomeArgs.obtain();
        deactivatedExpectedArgs.argi1 = RcsUceAdapter.ERROR_GENERIC_FAILURE;
        deactivatedExpectedArgs.arg1 = Long.valueOf(3000L);
        terminatedMap.put(deactivatedArgs, deactivatedExpectedArgs);

        SomeArgs probationArgs = SomeArgs.obtain();
        probationArgs.arg1 = ""probation"";
        probationArgs.arg2 = Long.valueOf(4000L);
        SomeArgs probationExpectedArgs = SomeArgs.obtain();
        probationExpectedArgs.argi1 = RcsUceAdapter.ERROR_GENERIC_FAILURE;
        probationExpectedArgs.arg1 = Long.valueOf(4000L);
        terminatedMap.put(probationArgs, probationExpectedArgs);

        SomeArgs rejectedArgs = SomeArgs.obtain();
        rejectedArgs.arg1 = ""rejected"";
        rejectedArgs.arg2 = Long.valueOf(5000L);
        SomeArgs rejectedExpectedArgs = SomeArgs.obtain();
        rejectedExpectedArgs.argi1 = RcsUceAdapter.ERROR_NOT_AUTHORIZED;
        rejectedExpectedArgs.arg1 = Long.valueOf(0L);
        terminatedMap.put(rejectedArgs, rejectedExpectedArgs);

        SomeArgs timeoutArgs = SomeArgs.obtain();
        timeoutArgs.arg1 = ""timeout"";
        timeoutArgs.arg2 = Long.valueOf(6000L);
        SomeArgs timeoutExpectedArgs = SomeArgs.obtain();
        timeoutExpectedArgs.argi1 = RcsUceAdapter.ERROR_REQUEST_TIMEOUT;
        timeoutExpectedArgs.arg1 = Long.valueOf(6000L);
        terminatedMap.put(timeoutArgs, timeoutExpectedArgs);

        SomeArgs giveupArgs = SomeArgs.obtain();
        giveupArgs.arg1 = ""giveup"";
        giveupArgs.arg2 = Long.valueOf(7000L);
        SomeArgs giveupExpectedArgs = SomeArgs.obtain();
        giveupExpectedArgs.argi1 = RcsUceAdapter.ERROR_NOT_AUTHORIZED;
        giveupExpectedArgs.arg1 = Long.valueOf(7000L);
        terminatedMap.put(giveupArgs, giveupExpectedArgs);

        SomeArgs noresourceArgs = SomeArgs.obtain();
        noresourceArgs.arg1 = ""noresource"";
        noresourceArgs.arg2 = Long.valueOf(8000L);
        SomeArgs noresourceExpectedArgs = SomeArgs.obtain();
        noresourceExpectedArgs.argi1 = RcsUceAdapter.ERROR_NOT_FOUND;
        noresourceExpectedArgs.arg1 = Long.valueOf(0L);
        terminatedMap.put(giveupArgs, giveupExpectedArgs);

        SomeArgs emptyReasonArgs = SomeArgs.obtain();
        emptyReasonArgs.arg1 = """";
        emptyReasonArgs.arg2 = Long.valueOf(9000L);
        SomeArgs emptyReasonExpectedArgs = SomeArgs.obtain();
        emptyReasonExpectedArgs.argi1 = RcsUceAdapter.ERROR_GENERIC_FAILURE;
        emptyReasonExpectedArgs.arg1 = Long.valueOf(9000L);
        terminatedMap.put(emptyReasonArgs, emptyReasonExpectedArgs);

        // Verify each subscription terminated and the expected result
        terminatedMap.forEach((reason, expectedResult) -> {
            String terminatedReason = (String) reason.arg1;
            Long terminatedRetryAfterMillis = (Long) reason.arg2;
            capabilityExchangeImpl.setSubscribeOperation((uris, cb) -> {
                cb.onNetworkResponse(networkRespCode, networkRespReason);
                cb.onNotifyCapabilitiesUpdate(pidfXmlList);
                cb.onTerminated(terminatedReason, terminatedRetryAfterMillis);
            });

            requestCapabilities(uceAdapter, numbers, callback);

            try {
                // Verify that the contact capability is received and the onCompleted is called.
                RcsContactUceCapability capability = waitForResult(capabilityQueue);
                assertNotNull(""Capabilities were not received for contact: "" + sTestNumberUri,
                        capability);
                verifyCapabilityResult(capability, sTestNumberUri, SOURCE_TYPE_NETWORK,
                        REQUEST_RESULT_FOUND, true, true);

                int expectedErrorCode = expectedResult.argi1;
                Long expectedRetryAfter = (Long) expectedResult.arg1;
                assertEquals(expectedErrorCode, waitForIntResult(errorQueue));
                assertEquals(expectedRetryAfter.longValue(), (waitForLongResult(errorRetryQueue)));
            } catch (Exception e) {
                fail(""Unexpected exception "" + e);
            }

            reason.recycle();
            expectedResult.recycle();
            errorQueue.clear();
            errorRetryQueue.clear();
            completeQueue.clear();
            capabilityQueue.clear();
            removeTestContactFromEab();
        });

        /*
         * Verify the subscribe request is successful when: A) The terminated is timeout and
         * B) The retryAfter is 0L and C) All the capabilities have been received.
         */
        String terminatedReason = ""timeout"";
        long terminatedRetryAfterMillis = 0L;
        capabilityExchangeImpl.setSubscribeOperation((uris, cb) -> {
            cb.onNetworkResponse(networkRespCode, networkRespReason);
            cb.onNotifyCapabilitiesUpdate(pidfXmlList);
            cb.onTerminated(terminatedReason, terminatedRetryAfterMillis);
        });

        requestCapabilities(uceAdapter, numbers, callback);

        // Verify that the contact capability is received and the onCompleted is called.
        RcsContactUceCapability capability = waitForResult(capabilityQueue);
        assertNotNull(""Capabilities were not received for contact: "" + sTestNumberUri, capability);
        verifyCapabilityResult(capability, sTestNumberUri, SOURCE_TYPE_NETWORK,
                REQUEST_RESULT_FOUND, true, true);
        assertTrue(waitForResult(completeQueue));

        errorQueue.clear();
        errorRetryQueue.clear();
        completeQueue.clear();
        capabilityQueue.clear();
        removeTestContactFromEab();

        /*
         * Set the subscribe request is failed because NOT all of the capabilities have been
         * received.
         */
        capabilityExchangeImpl.setSubscribeOperation((uris, cb) -> {
            cb.onNetworkResponse(networkRespCode, networkRespReason);
            cb.onTerminated(terminatedReason, terminatedRetryAfterMillis);
        });

        requestCapabilities(uceAdapter, numbers, callback);

        /*
         * Verify the request is failed because NOT all of the capabilities have been received.
         */
        assertEquals(RcsUceAdapter.ERROR_REQUEST_TIMEOUT, waitForIntResult(errorQueue));
        assertEquals(0L, (waitForLongResult(errorRetryQueue)));

        errorQueue.clear();
        errorRetryQueue.clear();
        completeQueue.clear();
        capabilityQueue.clear();
        removeTestContactFromEab();
        overrideCarrierConfig(null);
    }"	""	""	"RCS"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.RcsUceAdapterTest"	"testTimeoutToRequestCapabilitiesWithPresenceMechanism"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/RcsUceAdapterTest.java"	""	"public void testTimeoutToRequestCapabilitiesWithPresenceMechanism() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        RcsUceAdapter uceAdapter = imsManager.getImsRcsManager(sTestSub).getUceAdapter();
        assertNotNull(""UCE adapter should not be null!"", uceAdapter);

        // Remove the test contact capabilities
        removeTestContactFromEab();

        // Connect to the ImsService
        setupTestImsService(uceAdapter, true, true /* presence cap */, false /* OPTIONS */);

        TestRcsCapabilityExchangeImpl capabilityExchangeImpl = sServiceConnector
                .getCarrierService().getRcsFeature().getRcsCapabilityExchangeImpl();

        BlockingQueue<Integer> errorQueue = new LinkedBlockingQueue<>();
        BlockingQueue<Long> errorRetryQueue = new LinkedBlockingQueue<>();
        BlockingQueue<Boolean> completeQueue = new LinkedBlockingQueue<>();
        BlockingQueue<RcsContactUceCapability> capabilityQueue = new LinkedBlockingQueue<>();
        RcsUceAdapter.CapabilitiesCallback callback = new RcsUceAdapter.CapabilitiesCallback() {
            @Override
            public void onCapabilitiesReceived(List<RcsContactUceCapability> capabilities) {
                capabilities.forEach(c -> capabilityQueue.offer(c));
            }
            @Override
            public void onComplete() {
                completeQueue.offer(true);
            }
            @Override
            public void onError(int errorCode, long retryAfterMilliseconds) {
                errorQueue.offer(errorCode);
                errorRetryQueue.offer(retryAfterMilliseconds);
            }
        };

        // Prepare three contacts
        final Uri contact1 = sTestNumberUri;
        final Uri contact2 = sTestContact2Uri;
        final Uri contact3 = sTestContact3Uri;

        Collection<Uri> contacts = new ArrayList<>(3);
        contacts.add(contact1);
        contacts.add(contact2);
        contacts.add(contact3);

        // Setup the ImsService doesn't trigger any callbacks.
        capabilityExchangeImpl.setSubscribeOperation((uris, cb) -> {
            // It won't trigger any callbacks.
        });

        try {
            setCapabilitiesRequestTimeout(3000L);

            requestCapabilities(uceAdapter, contacts, callback);

            // Verify that the clients receive the TIMEOUT error code.
            assertEquals(RcsUceAdapter.ERROR_REQUEST_TIMEOUT, waitForIntResult(errorQueue));
            assertEquals(0L, (waitForLongResult(errorRetryQueue)));
        } finally {
            errorQueue.clear();
            errorRetryQueue.clear();
            completeQueue.clear();
            capabilityQueue.clear();
            removeTestContactFromEab();
            setCapabilitiesRequestTimeout(-1L);
        }

        // Setup the ImsService only trigger the network response callback. However it doesn't
        // trigger the onTerminated callback
        int networkRespCode = 200;
        String networkRespReason = ""OK"";
        capabilityExchangeImpl.setSubscribeOperation((uris, cb) -> {
            cb.onNetworkResponse(networkRespCode, networkRespReason);
        });

        try {
            setCapabilitiesRequestTimeout(3000L);

            requestCapabilities(uceAdapter, contacts, callback);

            // Verify that the clients receive the TIMEOUT error code.
            assertEquals(RcsUceAdapter.ERROR_REQUEST_TIMEOUT, waitForIntResult(errorQueue));
            assertEquals(0L, (waitForLongResult(errorRetryQueue)));
        } finally {
            errorQueue.clear();
            errorRetryQueue.clear();
            completeQueue.clear();
            capabilityQueue.clear();
            removeTestContactFromEab();
            setCapabilitiesRequestTimeout(-1L);
        }

        overrideCarrierConfig(null);
    }"	""	""	"RCS"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.RcsUceAdapterTest"	"testTimeoutToRequestCapabilitiesWithOptionsMechanism"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/RcsUceAdapterTest.java"	""	"public void testTimeoutToRequestCapabilitiesWithOptionsMechanism() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        RcsUceAdapter uceAdapter = imsManager.getImsRcsManager(sTestSub).getUceAdapter();
        assertNotNull(""UCE adapter should not be null!"", uceAdapter);

        // Remove the test contact capabilities
        removeTestContactFromEab();

        // Connect to the ImsService
        setupTestImsService(uceAdapter, true, false, true /* OPTIONS enabled */);

        TestRcsCapabilityExchangeImpl capabilityExchangeImpl = sServiceConnector
                .getCarrierService().getRcsFeature().getRcsCapabilityExchangeImpl();

        // The test contact
        Collection<Uri> contacts = new ArrayList<>(3);
        contacts.add(sTestNumberUri);

        // The result callback
        BlockingQueue<Integer> errorQueue = new LinkedBlockingQueue<>();
        BlockingQueue<Long> errorRetryQueue = new LinkedBlockingQueue<>();
        BlockingQueue<Boolean> completeQueue = new LinkedBlockingQueue<>();
        BlockingQueue<RcsContactUceCapability> capabilityQueue = new LinkedBlockingQueue<>();
        RcsUceAdapter.CapabilitiesCallback callback = new RcsUceAdapter.CapabilitiesCallback() {
            @Override
            public void onCapabilitiesReceived(List<RcsContactUceCapability> capabilities) {
                capabilities.forEach(c -> capabilityQueue.offer(c));
            }
            @Override
            public void onComplete() {
                completeQueue.offer(true);
            }
            @Override
            public void onError(int errorCode, long retryAfterMilliseconds) {
                errorQueue.offer(errorCode);
                errorRetryQueue.offer(retryAfterMilliseconds);
            }
        };

        // Setup the ImsService doesn't trigger any callbacks.
        capabilityExchangeImpl.setOptionsOperation((contact, myCapabilities, optionsCallback) -> {
            // It won't trigger any callbacks.
        });

        try {
            setCapabilitiesRequestTimeout(3000L);

            requestCapabilities(uceAdapter, contacts, callback);

            // Verify that the clients receive the TIMEOUT error code.
            assertEquals(RcsUceAdapter.ERROR_REQUEST_TIMEOUT, waitForIntResult(errorQueue));
            assertEquals(0L, (waitForLongResult(errorRetryQueue)));
        } finally {
            errorQueue.clear();
            errorRetryQueue.clear();
            completeQueue.clear();
            capabilityQueue.clear();
            removeTestContactFromEab();
            setCapabilitiesRequestTimeout(-1L);
        }

        overrideCarrierConfig(null);
    }"	""	""	"RCS"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.RcsUceAdapterTest"	"testRequestCapabilitiesWithUriFormatChanged"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/RcsUceAdapterTest.java"	""	"public void testRequestCapabilitiesWithUriFormatChanged() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        RcsUceAdapter uceAdapter = imsManager.getImsRcsManager(sTestSub).getUceAdapter();
        assertNotNull(""UCE adapter should not be null!"", uceAdapter);

        // Remove the test contact capabilities
        removeTestContactFromEab();

        // Override the carrier config to support group subscribe.
        PersistableBundle bundle = new PersistableBundle();
        bundle.putBoolean(CarrierConfigManager.Ims.KEY_ENABLE_PRESENCE_GROUP_SUBSCRIBE_BOOL, true);
        overrideCarrierConfig(bundle);

        // Connect to the ImsService
        setupTestImsService(uceAdapter, true, true /* presence cap */, false /* OPTIONS */);

        TestRcsCapabilityExchangeImpl capabilityExchangeImpl = sServiceConnector
                .getCarrierService().getRcsFeature().getRcsCapabilityExchangeImpl();

        BlockingQueue<Integer> errorQueue = new LinkedBlockingQueue<>();
        BlockingQueue<Long> errorRetryQueue = new LinkedBlockingQueue<>();
        BlockingQueue<Boolean> completeQueue = new LinkedBlockingQueue<>();
        BlockingQueue<RcsContactUceCapability> capabilityQueue = new LinkedBlockingQueue<>();
        RcsUceAdapter.CapabilitiesCallback callback = new RcsUceAdapter.CapabilitiesCallback() {
            @Override
            public void onCapabilitiesReceived(List<RcsContactUceCapability> capabilities) {
                capabilities.forEach(c -> capabilityQueue.offer(c));
            }
            @Override
            public void onComplete() {
                completeQueue.offer(true);
            }
            @Override
            public void onError(int errorCode, long retryAfterMilliseconds) {
                errorQueue.offer(errorCode);
                errorRetryQueue.offer(retryAfterMilliseconds);
            }
        };

        // Prepare three contacts
        final Uri contact1TelScheme = sTestNumberUri;
        final Uri contact1SipScheme = Uri.fromParts(PhoneAccount.SCHEME_SIP,
                sTestPhoneNumber + ""@test.cts;user=phone"", null);
        final Uri contact2 = sTestContact2Uri;
        final Uri contact3 = sTestContact3Uri;

        Collection<Uri> contacts = new ArrayList<>(3);
        // The first contact is using the tel scheme
        contacts.add(contact1TelScheme);
        contacts.add(contact2);
        contacts.add(contact3);

        ArrayList<String> pidfXmlList = new ArrayList<>(3);
        // ImsService replies the pidf xml data with the SIP scheme
        pidfXmlList.add(getPidfXmlData(contact1SipScheme, true, true));
        pidfXmlList.add(getPidfXmlData(contact2, true, false));
        pidfXmlList.add(getPidfXmlData(contact3, false, false));

        // Setup the network response is 200 OK and notify capabilities update
        int networkRespCode = 200;
        String networkRespReason = ""OK"";
        capabilityExchangeImpl.setSubscribeOperation((uris, cb) -> {
            cb.onNetworkResponse(networkRespCode, networkRespReason);
            cb.onNotifyCapabilitiesUpdate(pidfXmlList);
            cb.onTerminated("""", 0L);
        });

        requestCapabilities(uceAdapter, contacts, callback);

        // Verify that all the three contact's capabilities are received
        RcsContactUceCapability capability = waitForResult(capabilityQueue);
        assertNotNull(""Capabilities were not received for contact: "" + contact1SipScheme,
                capability);
        verifyCapabilityResult(capability, contact1SipScheme, SOURCE_TYPE_NETWORK,
                REQUEST_RESULT_FOUND, true, true);

        capability = waitForResult(capabilityQueue);
        assertNotNull(""Capabilities were not received for contact: "" + contact2, capability);
        verifyCapabilityResult(capability, contact2, SOURCE_TYPE_NETWORK, REQUEST_RESULT_FOUND,
                true, false);

        capability = waitForResult(capabilityQueue);
        assertNotNull(""Capabilities were not received for contact: "" + contact3, capability);
        verifyCapabilityResult(capability, contact3, SOURCE_TYPE_NETWORK, REQUEST_RESULT_FOUND,
                false, false);

        // Verify the onCompleted is called
        waitForResult(completeQueue);

        errorQueue.clear();
        errorRetryQueue.clear();
        completeQueue.clear();
        capabilityQueue.clear();
        removeTestContactFromEab();

        // Setup the callback that some of the contacts are terminated.
        capabilityExchangeImpl.setSubscribeOperation((uris, cb) -> {
            cb.onNetworkResponse(404, ""NOT FOUND"");
        });

        requestCapabilities(uceAdapter, contacts, callback);

        // Verify the contacts are not found.
        capability = waitForResult(capabilityQueue);
        verifyCapabilityResult(capability, contact1TelScheme, SOURCE_TYPE_NETWORK,
                REQUEST_RESULT_NOT_FOUND, false, false);

        capability = waitForResult(capabilityQueue);
        verifyCapabilityResult(capability, contact2, SOURCE_TYPE_NETWORK, REQUEST_RESULT_NOT_FOUND,
                false, false);

        capability = waitForResult(capabilityQueue);
        verifyCapabilityResult(capability, contact3, SOURCE_TYPE_NETWORK, REQUEST_RESULT_NOT_FOUND,
                false, false);

        // Verify the onCompleted is called
        waitForResult(completeQueue);

        errorQueue.clear();
        errorRetryQueue.clear();
        completeQueue.clear();
        capabilityQueue.clear();
        removeTestContactFromEab();

        // Setup the callback that some of the contacts are terminated.
        capabilityExchangeImpl.setSubscribeOperation((uris, cb) -> {
            List<Uri> uriList = new ArrayList(uris);
            cb.onNetworkResponse(networkRespCode, networkRespReason);
            // Notify capabilities updated for the first contact
            String pidfXml = pidfXmlList.get(0);
            cb.onNotifyCapabilitiesUpdate(Collections.singletonList(pidfXml));

            List<Pair<Uri, String>> terminatedResources = new ArrayList<>();
            for (int i = 1; i < uriList.size(); i++) {
                Pair<Uri, String> pair = Pair.create(uriList.get(i), ""noresource"");
                terminatedResources.add(pair);
            }
            cb.onResourceTerminated(terminatedResources);
            cb.onTerminated("""", 0L);
        });

        requestCapabilities(uceAdapter, contacts, callback);

        // Verify the first contact is found.
        capability = waitForResult(capabilityQueue);
        verifyCapabilityResult(capability, contact1SipScheme, SOURCE_TYPE_NETWORK,
                REQUEST_RESULT_FOUND, true, true);

        // Verify the reset contacts are not found.
        capability = waitForResult(capabilityQueue);
        verifyCapabilityResult(capability, contact2, SOURCE_TYPE_NETWORK, REQUEST_RESULT_NOT_FOUND,
                true, false);

        capability = waitForResult(capabilityQueue);
        verifyCapabilityResult(capability, contact3, SOURCE_TYPE_NETWORK, REQUEST_RESULT_NOT_FOUND,
                false, false);

        // Verify the onCompleted is called
        waitForResult(completeQueue);

        overrideCarrierConfig(null);
    }"	""	""	"RCS"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.RcsUceAdapterTest"	"testReceivingEmptyPidfXml"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/RcsUceAdapterTest.java"	""	"public void testReceivingEmptyPidfXml() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        RcsUceAdapter uceAdapter = imsManager.getImsRcsManager(sTestSub).getUceAdapter();
        assertNotNull(""UCE adapter should not be null!"", uceAdapter);

        // Remove the test contact capabilities
        removeTestContactFromEab();

        // Connect to the ImsService
        setupTestImsService(uceAdapter, true, true /* presence cap */, false /* OPTIONS */);

        TestRcsCapabilityExchangeImpl capabilityExchangeImpl = sServiceConnector
                .getCarrierService().getRcsFeature().getRcsCapabilityExchangeImpl();

        BlockingQueue<Integer> errorQueue = new LinkedBlockingQueue<>();
        BlockingQueue<Long> errorRetryQueue = new LinkedBlockingQueue<>();
        BlockingQueue<Boolean> completeQueue = new LinkedBlockingQueue<>();
        BlockingQueue<RcsContactUceCapability> capabilityQueue = new LinkedBlockingQueue<>();
        RcsUceAdapter.CapabilitiesCallback callback = new RcsUceAdapter.CapabilitiesCallback() {
            @Override
            public void onCapabilitiesReceived(List<RcsContactUceCapability> capabilities) {
                capabilities.forEach(c -> capabilityQueue.offer(c));
            }
            @Override
            public void onComplete() {
                completeQueue.offer(true);
            }
            @Override
            public void onError(int errorCode, long retryAfterMilliseconds) {
                errorQueue.offer(errorCode);
                errorRetryQueue.offer(retryAfterMilliseconds);
            }
        };

        // Prepare the test contact
        Collection<Uri> contacts = new ArrayList<>(1);
        contacts.add(sTestNumberUri);

        // Prepare the empty PIDF xml
        ArrayList<String> pidfXmlList = new ArrayList<>(1);
        pidfXmlList.add("""");

        // Setup the network response is 200 OK, empty PIDF data and the reason of onTerminated
        // is ""TIMEOUT""
        int networkRespCode = 200;
        String networkRespReason = ""OK"";
        capabilityExchangeImpl.setSubscribeOperation((uris, cb) -> {
            cb.onNetworkResponse(networkRespCode, networkRespReason);
            cb.onNotifyCapabilitiesUpdate(pidfXmlList);
            cb.onTerminated(""TIMEOUT"", 0L);
        });

        requestCapabilities(uceAdapter, contacts, callback);
        try {
            // Verify the contact capabilities is received and the result is NOT FOUND.
            RcsContactUceCapability capability = waitForResult(capabilityQueue);
            assertNotNull(""Capabilities were not received."", capability);
            verifyCapabilityResult(capability, sTestNumberUri, SOURCE_TYPE_NETWORK,
                    REQUEST_RESULT_NOT_FOUND, false, false);

            // Verify the callback ""onCompleted"" is called
            waitForResult(completeQueue);
        } finally {
            errorQueue.clear();
            errorRetryQueue.clear();
            completeQueue.clear();
            capabilityQueue.clear();
            removeTestContactFromEab();
        }

        // Setup the network response is 404 NOT FOUND
        capabilityExchangeImpl.setSubscribeOperation((uris, cb) -> {
            cb.onNetworkResponse(404, ""NOT FOUND"");
        });

        requestCapabilities(uceAdapter, contacts, callback);
        try {
            // Verify the contact capabilities is received and the result is NOT FOUND.
            RcsContactUceCapability capability = waitForResult(capabilityQueue);
            assertNotNull(""Capabilities is not received."", capability);
            verifyCapabilityResult(capability, sTestNumberUri, SOURCE_TYPE_NETWORK,
                    REQUEST_RESULT_NOT_FOUND, false, false);

            // Verify that the callback ""onComplete"" is called
            waitForResult(completeQueue);
        } catch (Exception e) {
            fail(""requestCapabilities is failed: "" + e);
        } finally {
            errorQueue.clear();
            errorRetryQueue.clear();
            completeQueue.clear();
            capabilityQueue.clear();
            removeTestContactFromEab();
        }

        // Setup the network response is 405 Method Not Allowed
        capabilityExchangeImpl.setSubscribeOperation((uris, cb) -> {
            cb.onNetworkResponse(405, ""Method Not Allowed"");
        });

        requestCapabilities(uceAdapter, contacts, callback);
        try {
            // Verify the contact capabilities is received and the result is NOT FOUND.
            RcsContactUceCapability capability = waitForResult(capabilityQueue);
            assertNotNull(""Capabilities is not received."", capability);
            verifyCapabilityResult(capability, sTestNumberUri, SOURCE_TYPE_NETWORK,
                    REQUEST_RESULT_NOT_FOUND, false, false);

            // Verify that the callback ""onComplete"" is called
            waitForResult(completeQueue);
        } catch (Exception e) {
            fail(""requestCapabilities is failed: "" + e);
        } finally {
            errorQueue.clear();
            errorRetryQueue.clear();
            completeQueue.clear();
            capabilityQueue.clear();
            removeTestContactFromEab();
        }

        overrideCarrierConfig(null);
    }

    private void setupTestImsService(RcsUceAdapter uceAdapter, boolean presencePublishEnabled,
            boolean presenceCapExchangeEnabled, boolean sipOptionsEnabled) throws Exception {
        // Trigger carrier config changed
        PersistableBundle bundle = new PersistableBundle();
        bundle.putBoolean(CarrierConfigManager.Ims.KEY_ENABLE_PRESENCE_PUBLISH_BOOL,
                presencePublishEnabled);
        bundle.putBoolean(CarrierConfigManager.Ims.KEY_ENABLE_PRESENCE_CAPABILITY_EXCHANGE_BOOL,
                presenceCapExchangeEnabled);
        bundle.putBoolean(CarrierConfigManager.KEY_USE_RCS_SIP_OPTIONS_BOOL, sipOptionsEnabled);
        overrideCarrierConfig(bundle);

        // Connect to the TestImsService
        connectTestImsService();
    }

    private String getPidfXmlData(Uri contact, boolean audioSupported, boolean videoSupported) {
        StringBuilder pidfBuilder = new StringBuilder();
        pidfBuilder.append(""<?xml version='1.0' encoding='utf-8' standalone='yes' ?>"")
                .append(""<presence entity=\"""").append(contact).append(""\"""")
                .append("" xmlns=\""urn:ietf:params:xml:ns:pidf\"""")
                .append("" xmlns:op=\""urn:oma:xml:prs:pidf:oma-pres\"""")
                .append("" xmlns:caps=\""urn:ietf:params:xml:ns:pidf:caps\"">"")
                .append(""<tuple id=\""tid0\""><status><basic>open</basic></status>"")
                .append(""<op:service-description>"")
                .append(""<op:service-id>service_id_01</op:service-id>"")
                .append(""<op:version>1.0</op:version>"")
                .append(""<op:description>description_test1</op:description>"")
                .append(""</op:service-description>"")
                .append(""<caps:servcaps>"")
                .append(""<caps:audio>"").append(audioSupported).append(""</caps:audio>"")
                .append(""<caps:video>"").append(videoSupported).append(""</caps:video>"")
                .append(""</caps:servcaps>"")
                .append(""<contact>"").append(contact).append(""</contact>"")
                .append(""</tuple></presence>"");
        return pidfBuilder.toString();
    }

    private void verifyCapabilityResult(RcsContactUceCapability resultCapability, Uri expectedUri,
            int expectedSourceType, int expectedResult, boolean expectedAudioSupported,
            boolean expectedVideoSupported) {
        // Verify the contact URI
        assertEquals(expectedUri, resultCapability.getContactUri());

        // Verify the source type is the network type.
        assertEquals(expectedSourceType,
                resultCapability.getSourceType());

        // Verify the request result is expected.
        final int requestResult = resultCapability.getRequestResult();
        assertEquals(expectedResult, requestResult);

        // Return directly if the result is not found.
        if (requestResult == REQUEST_RESULT_NOT_FOUND) {
            return;
        }

        // Verify the mechanism is presence
        assertEquals(RcsContactUceCapability.CAPABILITY_MECHANISM_PRESENCE,
                resultCapability.getCapabilityMechanism());

        RcsContactPresenceTuple presenceTuple =
                resultCapability.getCapabilityTuple(""service_id_01"");
        assertNotNull(""Contact Presence tuple should not be null!"", presenceTuple);

        ServiceCapabilities capabilities = presenceTuple.getServiceCapabilities();
        assertNotNull(""Service capabilities should not be null!"", capabilities);

        // Verify if the audio is supported
        assertEquals(expectedAudioSupported, capabilities.isAudioCapable());

        // Verify if the video is supported
        assertEquals(expectedVideoSupported, capabilities.isVideoCapable());
    }

    private void verifyOptionsCapabilityResult(List<RcsContactUceCapability> resultCapList,
            Collection<Uri> expectedUriList, int expectedSourceType, int expectedMechanism,
            int expectedResult, List<String> expectedFeatureTags) {
        assertEquals(resultCapList.size(), expectedUriList.size());

        assertTrue(resultCapList.stream().map(capability -> capability.getContactUri())
                .anyMatch(expectedUriList::contains));

        resultCapList.stream().map(capability -> capability.getSourceType())
                .forEach(sourceType -> assertEquals((int) sourceType, (int) expectedSourceType));

        resultCapList.stream().map(capability -> capability.getCapabilityMechanism())
                .forEach(mechanism -> assertEquals((int) mechanism, (int) expectedMechanism));

        resultCapList.stream().map(capability -> capability.getRequestResult())
                .forEach(result -> assertEquals((int) result, (int) expectedResult));

        resultCapList.stream().map(capability -> capability.getFeatureTags())
                .forEach(featureTags -> {
                    assertEquals((int) featureTags.size(), (int) expectedFeatureTags.size());
                    assertTrue(featureTags.containsAll(expectedFeatureTags));
                });
    }

    private void registerUceObserver(Consumer<Uri> resultConsumer) {
        mUceObserver = new ContentObserver(new Handler(sHandlerThread.getLooper())) {
            @Override
            public void onChange(boolean selfChange, Uri uri) {
                resultConsumer.accept(uri);
            }
        };
        getContext().getContentResolver().registerContentObserver(LISTENER_URI,
                true /*notifyForDecendents*/, mUceObserver);
    }

    private void unregisterUceObserver() {
        if (mUceObserver != null) {
            getContext().getContentResolver().unregisterContentObserver(mUceObserver);
        }
    }

    private int waitForIntResult(BlockingQueue<Integer> queue) throws Exception {
        Integer result = queue.poll(ImsUtils.TEST_TIMEOUT_MS, TimeUnit.MILLISECONDS);
        return result != null ? result : Integer.MAX_VALUE;
    }

    private long waitForLongResult(BlockingQueue<Long> queue) throws Exception {
        Long result = queue.poll(ImsUtils.TEST_TIMEOUT_MS, TimeUnit.MILLISECONDS);
        return result != null ? result : Long.MAX_VALUE;
    }

    private <T> T waitForResult(BlockingQueue<T> queue) throws Exception {
        return queue.poll(ImsUtils.TEST_TIMEOUT_MS, TimeUnit.MILLISECONDS);
    }

    private static Context getContext() {
        return InstrumentationRegistry.getInstrumentation().getContext();
    }

    private void connectTestImsService() throws Exception {
        assertTrue(sServiceConnector.connectCarrierImsService(new ImsFeatureConfiguration.Builder()
                .addFeature(sTestSlot, ImsFeature.FEATURE_MMTEL)
                .addFeature(sTestSlot, ImsFeature.FEATURE_RCS)
                .build()));

        // The RcsFeature is created when the ImsService is bound. If it wasn't created, then the
        // Framework did not call it.
        assertTrue(""Did not receive createRcsFeature"", sServiceConnector.getCarrierService()
                .waitForLatchCountdown(TestImsService.LATCH_CREATE_RCS));
        assertTrue(""Did not receive RcsFeature#onReady"", sServiceConnector.getCarrierService()
                .waitForLatchCountdown(TestImsService.LATCH_RCS_READY));
        // Make sure the RcsFeature was created in the test service.
        assertNotNull(""Device ImsService created, but TestDeviceImsService#createRcsFeature was not""
                + ""called!"", sServiceConnector.getCarrierService().getRcsFeature());
        assertTrue(""Did not receive RcsFeature#setCapabilityExchangeEventListener"",
                sServiceConnector.getCarrierService().waitForLatchCountdown(
                        TestImsService.LATCH_UCE_LISTENER_SET));
        int serviceSlot = sServiceConnector.getCarrierService().getRcsFeature().getSlotIndex();
        assertEquals(""The slot specified for the test ("" + sTestSlot + "") does not match the ""
                        + ""assigned slot ("" + serviceSlot + ""+ for the associated RcsFeature"",
                sTestSlot, serviceSlot);
    }

    private static void initPhoneNumbers() {
        // Generate a random phone number
        sTestPhoneNumber = generateRandomPhoneNumber();
        sTestNumberUri = Uri.fromParts(PhoneAccount.SCHEME_TEL, sTestPhoneNumber, null);

        sTestContact2 = generateRandomContact(5);
        sTestContact2Uri = Uri.fromParts(PhoneAccount.SCHEME_SIP, sTestContact2, null);

        sTestContact3 = generateRandomContact(6);
        sTestContact3Uri = Uri.fromParts(PhoneAccount.SCHEME_SIP, sTestContact3, null);
    }

    private static String generateRandomPhoneNumber() {
        Random random = new Random();
        StringBuilder builder = new StringBuilder();
        for (int i = 0; i < 10; i++) {
            builder.append(random.nextInt(10));
        }
        return builder.toString();
    }

    private static String generateRandomContact(int length) {
        Random random = new Random();
        StringBuilder builder = new StringBuilder(""TestContact"");
        for (int i = 0; i < length; i++) {
            int asciiNum = random.nextInt(26) + 65;  // ascii 65
            builder.append((char) asciiNum);
        }
        return builder.toString();
    }

    private static void overrideCarrierConfig(PersistableBundle bundle) throws Exception {
        CarrierConfigManager carrierConfigManager = InstrumentationRegistry.getInstrumentation()
                .getContext().getSystemService(CarrierConfigManager.class);
        sReceiver.clearQueue();
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(carrierConfigManager,
                (m) -> m.overrideConfig(sTestSub, bundle));
        sReceiver.waitForCarrierConfigChanged();
    }

    private static void removeTestContactFromEab() {
        try {
            StringBuilder builder = new StringBuilder();
            builder.append(sTestPhoneNumber)
                    .append("","").append(sTestContact2)
                    .append("","").append(sTestContact3);
            sServiceConnector.removeEabContacts(sTestSlot, builder.toString());
        } catch (Exception e) {
            Log.w(""RcsUceAdapterTest"", ""Cannot remove test contacts from eab database: "" + e);
        }
    }

    private static void removeUceRequestDisallowedStatus() {
        try {
            sServiceConnector.removeUceRequestDisallowedStatus(sTestSlot);
        } catch (Exception e) {
            Log.w(""RcsUceAdapterTest"", ""Cannot remove request disallowed status: "" + e);
        }
    }

    private static void setCapabilitiesRequestTimeout(long timeoutAfterMillis) {
        try {
            sServiceConnector.setCapabilitiesRequestTimeout(sTestSlot, timeoutAfterMillis);
        } catch (Exception e) {
            Log.w(""RcsUceAdapterTest"", ""Cannot set capabilities request timeout: "" + e);
        }
    }

    private void requestCapabilities(RcsUceAdapter uceAdapter, Collection<Uri> numbers,
            RcsUceAdapter.CapabilitiesCallback callback) {
        try {
            ShellIdentityUtils.invokeThrowableMethodWithShellPermissionsNoReturn(
                    uceAdapter,
                    adapter -> adapter.requestCapabilities(numbers, Runnable::run, callback),
                    ImsException.class,
                    ""android.permission.ACCESS_RCS_USER_CAPABILITY_EXCHANGE"");
        } catch (SecurityException e) {
            fail(""requestCapabilities should succeed with ACCESS_RCS_USER_CAPABILITY_EXCHANGE. ""
                    + ""Exception: "" + e);
        } catch (ImsException e) {
            fail(""requestCapabilities failed "" + e);
        }
    }

    private void requestAvailability(RcsUceAdapter uceAdapter, Uri number,
            RcsUceAdapter.CapabilitiesCallback callback) {
        try {
            ShellIdentityUtils.invokeThrowableMethodWithShellPermissionsNoReturn(
                    uceAdapter,
                    adapter -> adapter.requestAvailability(number, Runnable::run, callback),
                    ImsException.class,
                    ""android.permission.ACCESS_RCS_USER_CAPABILITY_EXCHANGE"");
        } catch (SecurityException e) {
            fail(""requestAvailability should succeed with ACCESS_RCS_USER_CAPABILITY_EXCHANGE. ""
                    + ""Exception: "" + e);
        } catch (ImsException e) {
            fail(""requestAvailability failed "" + e);
        }
    }
}"	""	""	"RCS MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.TestAcsClient"	"TestAcsClient"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/TestAcsClient.java"	""	"public void test/*
 *.
 */

package android.telephony.ims.cts;

import android.telephony.ims.RcsClientConfiguration;
import android.telephony.ims.stub.ImsConfigImplBase;

import java.util.concurrent.LinkedBlockingQueue;

public class TestAcsClient {
    public static int ACTION_SET_RCS_CLIENT_CONFIG = 1;
    public static int ACTION_TRIGGER_AUTO_CONFIG = 2;
    public static int ACTION_CONFIG_CHANGED = 3;
    public static int ACTION_CONFIG_REMOVED = 4;

    private LinkedBlockingQueue<Integer> mActionQueue = new LinkedBlockingQueue<>();
    private RcsClientConfiguration mRcc;
    private byte[] mConfig;
    private ImsConfigImplBase mImsConfigImpl;

    private static TestAcsClient sInstance;

    private TestAcsClient() {}

    public static TestAcsClient getInstance() {
        if (sInstance == null) {
            sInstance = new TestAcsClient();
        }
        return sInstance;
    }

    public void onSetRcsClientConfiguration(RcsClientConfiguration rcc) {
        mActionQueue.offer(ACTION_SET_RCS_CLIENT_CONFIG);
        mRcc = rcc;
    }

    public void onTriggerAutoConfiguration() {
        mActionQueue.offer(ACTION_TRIGGER_AUTO_CONFIG);
    }

    public void onConfigChanged(byte[] config, boolean isCompressed) {
        mActionQueue.offer(ACTION_CONFIG_CHANGED);
        mConfig = isCompressed ? ImsUtils.decompressGzip(config) : config;
    }

    public void onConfigRemoved() {
        mActionQueue.offer(ACTION_CONFIG_REMOVED);
        mConfig = null;
    }

    public LinkedBlockingQueue<Integer> getActionQueue() {
        return mActionQueue;
    }

    public RcsClientConfiguration getRcc() {
        return mRcc;
    }

    public byte[] getConfig() {
        return mConfig;
    }

    public void reset() {
        mActionQueue.clear();
        mRcc = null;
        mConfig = null;
    }

    public void setImsConfigImpl(ImsConfigImplBase impl) {
        mImsConfigImpl = impl;
    }

    public void notifyPreProvisioning(byte[] conf) {
        mImsConfigImpl.notifyPreProvisioningReceived(conf);
    }
}"	""	""	"RCS"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.mediav2.cts.CodecTestBase"	"isEmpty"	"CtsMediaV2TestCases"	"/home/gpoor/cts-12-source/cts/tests/media/src/android/mediav2/cts/CodecTestBase.java"	""	"public void test/*
 *.
 */

package android.mediav2.cts;

import android.content.Context;
import android.content.pm.PackageManager;
import android.graphics.ImageFormat;
import android.graphics.Rect;
import android.hardware.display.DisplayManager;
import android.media.Image;
import android.media.MediaCodec;
import android.media.MediaCodecInfo;
import android.media.MediaCodecList;
import android.media.MediaExtractor;
import android.media.MediaFormat;
import android.os.Build;
import android.os.PersistableBundle;
import android.util.Log;
import android.util.Pair;
import android.view.Display;
import android.view.Surface;

import androidx.annotation.NonNull;
import androidx.test.platform.app.InstrumentationRegistry;

import org.junit.Assert;
import org.junit.Before;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.zip.CRC32;

import com.android.compatibility.common.util.ApiLevelUtil;

import static android.media.MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface;
import static android.media.MediaCodecInfo.CodecCapabilities.COLOR_FormatYUV420Flexible;
import static android.media.MediaCodecInfo.CodecProfileLevel.*;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

class CodecAsyncHandler extends MediaCodec.Callback {
    private static final String LOG_TAG = CodecAsyncHandler.class.getSimpleName();
    private final Lock mLock = new ReentrantLock();
    private final Condition mCondition = mLock.newCondition();
    private final LinkedList<Pair<Integer, MediaCodec.BufferInfo>> mCbInputQueue;
    private final LinkedList<Pair<Integer, MediaCodec.BufferInfo>> mCbOutputQueue;
    private MediaFormat mOutFormat;
    private boolean mSignalledOutFormatChanged;
    private volatile boolean mSignalledError;

    CodecAsyncHandler() {
        mCbInputQueue = new LinkedList<>();
        mCbOutputQueue = new LinkedList<>();
        mSignalledError = false;
        mSignalledOutFormatChanged = false;
    }

    void clearQueues() {
        mLock.lock();
        mCbInputQueue.clear();
        mCbOutputQueue.clear();
        mLock.unlock();
    }

    void resetContext() {
        clearQueues();
        mOutFormat = null;
        mSignalledOutFormatChanged = false;
        mSignalledError = false;
    }

    @Override
    public void onInputBufferAvailable(@NonNull MediaCodec codec, int bufferIndex) {
        assertTrue(bufferIndex >= 0);
        mLock.lock();
        mCbInputQueue.add(new Pair<>(bufferIndex, (MediaCodec.BufferInfo) null));
        mCondition.signalAll();
        mLock.unlock();
    }

    @Override
    public void onOutputBufferAvailable(@NonNull MediaCodec codec, int bufferIndex,
            @NonNull MediaCodec.BufferInfo info) {
        assertTrue(bufferIndex >= 0);
        mLock.lock();
        mCbOutputQueue.add(new Pair<>(bufferIndex, info));
        mCondition.signalAll();
        mLock.unlock();
    }

    @Override
    public void onError(@NonNull MediaCodec codec, MediaCodec.CodecException e) {
        mLock.lock();
        mSignalledError = true;
        mCondition.signalAll();
        mLock.unlock();
        Log.e(LOG_TAG, ""received media codec error : "" + e.getMessage());
    }

    @Override
    public void onOutputFormatChanged(@NonNull MediaCodec codec, @NonNull MediaFormat format) {
        mOutFormat = format;
        mSignalledOutFormatChanged = true;
        Log.i(LOG_TAG, ""Output format changed: "" + format.toString());
    }

    void setCallBack(MediaCodec codec, boolean isCodecInAsyncMode) {
        if (isCodecInAsyncMode) {
            codec.setCallback(this);
        } else {
            codec.setCallback(null);
        }
    }

    Pair<Integer, MediaCodec.BufferInfo> getInput() throws InterruptedException {
        Pair<Integer, MediaCodec.BufferInfo> element = null;
        mLock.lock();
        while (!mSignalledError) {
            if (mCbInputQueue.isEmpty()) {
                mCondition.await();
            } else {
                element = mCbInputQueue.remove(0);
                break;
            }
        }
        mLock.unlock();
        return element;
    }

    Pair<Integer, MediaCodec.BufferInfo> getOutput() throws InterruptedException {
        Pair<Integer, MediaCodec.BufferInfo> element = null;
        mLock.lock();
        while (!mSignalledError) {
            if (mCbOutputQueue.isEmpty()) {
                mCondition.await();
            } else {
                element = mCbOutputQueue.remove(0);
                break;
            }
        }
        mLock.unlock();
        return element;
    }

    Pair<Integer, MediaCodec.BufferInfo> getWork() throws InterruptedException {
        Pair<Integer, MediaCodec.BufferInfo> element = null;
        mLock.lock();
        while (!mSignalledError) {
            if (mCbInputQueue.isEmpty() && mCbOutputQueue.isEmpty()) {
                mCondition.await();
            } else {
                if (!mCbOutputQueue.isEmpty()) {
                    element = mCbOutputQueue.remove(0);
                    break;
                }
                if (!mCbInputQueue.isEmpty()) {
                    element = mCbInputQueue.remove(0);
                    break;
                }
            }
        }
        mLock.unlock();
        return element;
    }

    boolean isInputQueueEmpty() {
        mLock.lock();
        boolean isEmpty = mCbInputQueue.isEmpty();
        mLock.unlock();
        return isEmpty;
    }

    boolean hasSeenError() {
        return mSignalledError;
    }

    boolean hasOutputFormatChanged() {
        return mSignalledOutFormatChanged;
    }

    MediaFormat getOutputFormat() {
        return mOutFormat;
    }
}

class OutputManager {
    private static final String LOG_TAG = OutputManager.class.getSimpleName();
    private byte[] memory;
    private int memIndex;
    private CRC32 mCrc32UsingImage;
    private CRC32 mCrc32UsingBuffer;
    private ArrayList<Long> inpPtsList;
    private ArrayList<Long> outPtsList;

    OutputManager() {
        memory = new byte[1024];
        memIndex = 0;
        mCrc32UsingImage = new CRC32();
        mCrc32UsingBuffer = new CRC32();
        inpPtsList = new ArrayList<>();
        outPtsList = new ArrayList<>();
    }

    void saveInPTS(long pts) {
        // Add only Unique timeStamp, discarding any duplicate frame / non-display frame
        if (!inpPtsList.contains(pts)) {
            inpPtsList.add(pts);
        }
    }

    void saveOutPTS(long pts) {
        outPtsList.add(pts);
    }

    boolean isPtsStrictlyIncreasing(long lastPts) {
        boolean res = true;
        for (int i = 0; i < outPtsList.size(); i++) {
            if (lastPts < outPtsList.get(i)) {
                lastPts = outPtsList.get(i);
            } else {
                Log.e(LOG_TAG, ""Timestamp ordering check failed: last timestamp: "" + lastPts +
                        "" current timestamp:"" + outPtsList.get(i));
                res = false;
                break;
            }
        }
        return res;
    }

    boolean isOutPtsListIdenticalToInpPtsList(boolean requireSorting) {
        boolean res;
        Collections.sort(inpPtsList);
        if (requireSorting) {
            Collections.sort(outPtsList);
        }
        if (outPtsList.size() != inpPtsList.size()) {
            Log.e(LOG_TAG, ""input and output presentation timestamp list sizes are not identical"" +
                    ""exp/rec"" + inpPtsList.size() + '/' + outPtsList.size());
            return false;
        } else {
            int count = 0;
            for (int i = 0; i < outPtsList.size(); i++) {
                if (!outPtsList.get(i).equals(inpPtsList.get(i))) {
                    count ++;
                    Log.e(LOG_TAG, ""input output pts mismatch, exp/rec "" + outPtsList.get(i) + '/' +
                            inpPtsList.get(i));
                    if (count == 20) {
                        Log.e(LOG_TAG, ""stopping after 20 mismatches, ..."");
                        break;
                    }
                }
            }
            res = (count == 0);
        }
        return res;
    }

    int getOutStreamSize() {
        return memIndex;
    }

    void checksum(ByteBuffer buf, int size) {
        checksum(buf, size, 0, 0, 0);
    }

    void checksum(ByteBuffer buf, int size, int width, int height, int stride) {
        int cap = buf.capacity();
        assertTrue(""checksum() params are invalid: size = "" + size + "" cap = "" + cap,
                size > 0 && size <= cap);
        if (buf.hasArray()) {
            if (width > 0 && height > 0 && stride > 0) {
                int offset = buf.position() + buf.arrayOffset();
                byte[] bb = new byte[width * height];
                for (int i = 0; i < height; ++i) {
                    System.arraycopy(buf.array(), offset, bb, i * width, width);
                    offset += stride;
                }
                mCrc32UsingBuffer.update(bb, 0, width * height);
            } else {
                mCrc32UsingBuffer.update(buf.array(), buf.position() + buf.arrayOffset(), size);
            }
        } else if (width > 0 && height > 0 && stride > 0) {
            // Checksum only the Y plane
            int pos = buf.position();
            int offset = pos;
            byte[] bb = new byte[width * height];
            for (int i = 0; i < height; ++i) {
                buf.position(offset);
                buf.get(bb, i * width, width);
                offset += stride;
            }
            mCrc32UsingBuffer.update(bb, 0, width * height);
            buf.position(pos);
        } else {
            int pos = buf.position();
            final int rdsize = Math.min(4096, size);
            byte[] bb = new byte[rdsize];
            int chk;
            for (int i = 0; i < size; i += chk) {
                chk = Math.min(rdsize, size - i);
                buf.get(bb, 0, chk);
                mCrc32UsingBuffer.update(bb, 0, chk);
            }
            buf.position(pos);
        }
    }

    void checksum(Image image) {
        int format = image.getFormat();
        assertEquals(""unexpected image format"", ImageFormat.YUV_420_888, format);

        Rect cropRect = image.getCropRect();
        int imageWidth = cropRect.width();
        int imageHeight = cropRect.height();
        assertTrue(""unexpected image dimensions"", imageWidth > 0 && imageHeight > 0);

        int imageLeft = cropRect.left;
        int imageTop = cropRect.top;
        Image.Plane[] planes = image.getPlanes();
        for (int i = 0; i < planes.length; ++i) {
            ByteBuffer buf = planes[i].getBuffer();
            int width, height, rowStride, pixelStride, x, y, left, top;
            rowStride = planes[i].getRowStride();
            pixelStride = planes[i].getPixelStride();
            if (i == 0) {
                width = imageWidth;
                height = imageHeight;
                left = imageLeft;
                top = imageTop;
            } else {
                width = imageWidth / 2;
                height = imageHeight / 2;
                left = imageLeft / 2;
                top = imageTop / 2;
            }
            int cropOffset = left + top * rowStride;
            // local contiguous pixel buffer
            byte[] bb = new byte[width * height];
            if (buf.hasArray()) {
                byte[] b = buf.array();
                int offs = buf.arrayOffset() + cropOffset;
                if (pixelStride == 1) {
                    for (y = 0; y < height; ++y) {
                        System.arraycopy(b, offs + y * rowStride, bb, y * width, width);
                    }
                } else {
                    // do it pixel-by-pixel
                    for (y = 0; y < height; ++y) {
                        int lineOffset = offs + y * rowStride;
                        for (x = 0; x < width; ++x) {
                            bb[y * width + x] = b[lineOffset + x * pixelStride];
                        }
                    }
                }
            } else { // almost always ends up here due to direct buffers
                int base = buf.position();
                int pos = base + cropOffset;
                if (pixelStride == 1) {
                    for (y = 0; y < height; ++y) {
                        buf.position(pos + y * rowStride);
                        buf.get(bb, y * width, width);
                    }
                } else {
                    // local line buffer
                    byte[] lb = new byte[rowStride];
                    // do it pixel-by-pixel
                    for (y = 0; y < height; ++y) {
                        buf.position(pos + y * rowStride);
                        // we're only guaranteed to have pixelStride * (width - 1) + 1 bytes
                        buf.get(lb, 0, pixelStride * (width - 1) + 1);
                        for (x = 0; x < width; ++x) {
                            bb[y * width + x] = lb[x * pixelStride];
                        }
                    }
                }
                buf.position(base);
            }
            mCrc32UsingImage.update(bb, 0, width * height);
        }
    }

    void saveToMemory(ByteBuffer buf, MediaCodec.BufferInfo info) {
        if (memIndex + info.size >= memory.length) {
            memory = Arrays.copyOf(memory, memIndex + info.size);
        }
        buf.position(info.offset);
        buf.get(memory, memIndex, info.size);
        memIndex += info.size;
    }

    void position(int index) {
        if (index < 0 || index >= memory.length) index = 0;
        memIndex = index;
    }

    ByteBuffer getBuffer() {
        return ByteBuffer.wrap(memory);
    }

    void reset() {
        position(0);
        mCrc32UsingImage.reset();
        mCrc32UsingBuffer.reset();
        inpPtsList.clear();
        outPtsList.clear();
    }

    float getRmsError(short[] refData) {
        long totalErrorSquared = 0;
        assertTrue(0 == (memIndex & 1));
        short[] shortData = new short[memIndex / 2];
        ByteBuffer.wrap(memory, 0, memIndex).order(ByteOrder.LITTLE_ENDIAN).asShortBuffer()
                .get(shortData);
        if (refData.length != shortData.length) return Float.MAX_VALUE;
        for (int i = 0; i < shortData.length; i++) {
            int d = shortData[i] - refData[i];
            totalErrorSquared += d * d;
        }
        long avgErrorSquared = (totalErrorSquared / shortData.length);
        return (float) Math.sqrt(avgErrorSquared);
    }

    long getCheckSumImage() {
        return mCrc32UsingImage.getValue();
    }

    long getCheckSumBuffer() {
        return mCrc32UsingBuffer.getValue();
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        OutputManager that = (OutputManager) o;
        // TODO: Timestamps for deinterlaced content are under review. (E.g. can decoders
        // produce multiple progressive frames?) For now, do not verify timestamps.
        boolean isEqual = this.equalsInterlaced(o);
        if (!outPtsList.equals(that.outPtsList)) {
            isEqual = false;
            Log.e(LOG_TAG, ""ref and test presentation timestamp mismatch"");
        }
        return isEqual;
    }

    public boolean equalsInterlaced(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        OutputManager that = (OutputManager) o;
        boolean isEqual = true;
        if (mCrc32UsingImage.getValue() != that.mCrc32UsingImage.getValue()) {
            isEqual = false;
            Log.e(LOG_TAG, ""ref and test crc32 checksums calculated using image mismatch "" +
                          mCrc32UsingImage.getValue() + '/' + that.mCrc32UsingImage.getValue());
        }
        if (mCrc32UsingBuffer.getValue() != that.mCrc32UsingBuffer.getValue()) {
            isEqual = false;
            Log.e(LOG_TAG, ""ref and test crc32 checksums calculated using buffer mismatch "" +
                          mCrc32UsingBuffer.getValue() + '/' + that.mCrc32UsingBuffer.getValue());
            if (memIndex == that.memIndex) {
                int count = 0;
                for (int i = 0; i < memIndex; i++) {
                    if (memory[i] != that.memory[i]) {
                        count++;
                        if (count < 20) {
                            Log.d(LOG_TAG, ""sample at "" + i + "" exp/got:: "" + memory[i] + '/' +
                                    that.memory[i]);
                        }
                    }
                }
                if (count != 0) {
                    Log.e(LOG_TAG, ""ref and test o/p samples mismatch "" + count);
                }
            } else {
                Log.e(LOG_TAG, ""ref and test o/p sizes mismatch "" + memIndex + '/' + that.memIndex);
            }
        }
        return isEqual;
    }
}

abstract class CodecTestBase {
    public static final boolean IS_AT_LEAST_R = ApiLevelUtil.isAtLeast(Build.VERSION_CODES.R);
    private static final String LOG_TAG = CodecTestBase.class.getSimpleName();

    static final String CODEC_PREFIX_KEY = ""codec-prefix"";
    static final String MIME_SEL_KEY = ""mime-sel"";
    static final Map<String, String> codecSelKeyMimeMap = new HashMap<>();
    static final Map<String, String> mDefaultEncoders = new HashMap<>();
    static final Map<String, String> mDefaultDecoders = new HashMap<>();
    static final boolean ENABLE_LOGS = false;
    static final int PER_TEST_TIMEOUT_LARGE_TEST_MS = 300000;
    static final int PER_TEST_TIMEOUT_SMALL_TEST_MS = 60000;
    static final int UNSPECIFIED = 0;
    static final int CODEC_ALL = 0; // All codecs must support
    static final int CODEC_ANY = 1; // At least one codec must support
    static final int CODEC_DEFAULT = 2; // Default codec must support
    static final int CODEC_OPTIONAL = 3; // Codec support is optional
    // Maintain Timeouts in sync with their counterpart in NativeMediaCommon.h
    static final long Q_DEQ_TIMEOUT_US = 5000; // block at most 5ms while looking for io buffers
    static final int RETRY_LIMIT = 100; // max poll counter before test aborts and returns error
    static final String INVALID_CODEC = ""unknown.codec_"";
    static final String mInpPrefix = WorkDir.getMediaDirString();
    static final Context mContext = InstrumentationRegistry.getInstrumentation().getTargetContext();
    static final PackageManager pm = mContext.getPackageManager();
    static String mimeSelKeys;
    static String codecPrefix;

    CodecAsyncHandler mAsyncHandle;
    boolean mIsCodecInAsyncMode;
    boolean mSawInputEOS;
    boolean mSawOutputEOS;
    boolean mSignalEOSWithLastFrame;
    int mInputCount;
    int mOutputCount;
    long mPrevOutputPts;
    boolean mSignalledOutFormatChanged;
    MediaFormat mOutFormat;
    boolean mIsAudio;

    boolean mSaveToMem;
    OutputManager mOutputBuff;

    String mCodecName;
    MediaCodec mCodec;
    Surface mSurface;

    static {
        System.loadLibrary(""ctsmediav2codec_jni"");

        codecSelKeyMimeMap.put(""vp8"", MediaFormat.MIMETYPE_VIDEO_VP8);
        codecSelKeyMimeMap.put(""vp9"", MediaFormat.MIMETYPE_VIDEO_VP9);
        codecSelKeyMimeMap.put(""av1"", MediaFormat.MIMETYPE_VIDEO_AV1);
        codecSelKeyMimeMap.put(""avc"", MediaFormat.MIMETYPE_VIDEO_AVC);
        codecSelKeyMimeMap.put(""hevc"", MediaFormat.MIMETYPE_VIDEO_HEVC);
        codecSelKeyMimeMap.put(""mpeg4"", MediaFormat.MIMETYPE_VIDEO_MPEG4);
        codecSelKeyMimeMap.put(""h263"", MediaFormat.MIMETYPE_VIDEO_H263);
        codecSelKeyMimeMap.put(""mpeg2"", MediaFormat.MIMETYPE_VIDEO_MPEG2);
        codecSelKeyMimeMap.put(""vraw"", MediaFormat.MIMETYPE_VIDEO_RAW);
        codecSelKeyMimeMap.put(""amrnb"", MediaFormat.MIMETYPE_AUDIO_AMR_NB);
        codecSelKeyMimeMap.put(""amrwb"", MediaFormat.MIMETYPE_AUDIO_AMR_WB);
        codecSelKeyMimeMap.put(""mp3"", MediaFormat.MIMETYPE_AUDIO_MPEG);
        codecSelKeyMimeMap.put(""aac"", MediaFormat.MIMETYPE_AUDIO_AAC);
        codecSelKeyMimeMap.put(""vorbis"", MediaFormat.MIMETYPE_AUDIO_VORBIS);
        codecSelKeyMimeMap.put(""opus"", MediaFormat.MIMETYPE_AUDIO_OPUS);
        codecSelKeyMimeMap.put(""g711alaw"", MediaFormat.MIMETYPE_AUDIO_G711_ALAW);
        codecSelKeyMimeMap.put(""g711mlaw"", MediaFormat.MIMETYPE_AUDIO_G711_MLAW);
        codecSelKeyMimeMap.put(""araw"", MediaFormat.MIMETYPE_AUDIO_RAW);
        codecSelKeyMimeMap.put(""flac"", MediaFormat.MIMETYPE_AUDIO_FLAC);
        codecSelKeyMimeMap.put(""gsm"", MediaFormat.MIMETYPE_AUDIO_MSGSM);

        android.os.Bundle args = InstrumentationRegistry.getArguments();
        mimeSelKeys = args.getString(MIME_SEL_KEY);
        codecPrefix = args.getString(CODEC_PREFIX_KEY);
    }

    static boolean isTv() {
        return pm.hasSystemFeature(PackageManager.FEATURE_LEANBACK);
    }

    static boolean hasMicrophone() {
        return pm.hasSystemFeature(PackageManager.FEATURE_MICROPHONE);
    }

    static boolean hasCamera() {
        return pm.hasSystemFeature(PackageManager.FEATURE_CAMERA_ANY);
    }

    static boolean isWatch() {
        return pm.hasSystemFeature(PackageManager.FEATURE_WATCH);
    }

    static boolean isAutomotive() {
        return pm.hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE);
    }

    static boolean isPc() {
        return pm.hasSystemFeature(PackageManager.FEATURE_PC);
    }

    static boolean hasAudioOutput() {
        return pm.hasSystemFeature(PackageManager.FEATURE_AUDIO_OUTPUT);
    }

    static boolean isHandheld() {
        // handheld nature is not exposed to package manager, for now
        // we check for touchscreen and NOT watch and NOT tv and NOT pc
        return pm.hasSystemFeature(PackageManager.FEATURE_TOUCHSCREEN) && !isWatch() && !isTv() &&
                !isAutomotive() && !isPc();
    }

    static boolean hasDecoder(String mime) {
        return CodecTestBase.selectCodecs(mime, null, null, false).size() != 0;
    }

    static boolean hasEncoder(String mime) {
        return CodecTestBase.selectCodecs(mime, null, null, true).size() != 0;
    }

    static boolean isFeatureSupported(String name, String mime, String feature) throws IOException {
        MediaCodec codec = MediaCodec.createByCodecName(name);
        MediaCodecInfo.CodecCapabilities codecCapabilities =
                codec.getCodecInfo().getCapabilitiesForType(mime);
        boolean isSupported = codecCapabilities.isFeatureSupported(feature);
        codec.release();
        return isSupported;
    }

    static boolean doesAnyFormatHaveHDRProfile(String mime, ArrayList<MediaFormat> formats) {
        boolean isHDR = false;
        for (MediaFormat format : formats) {
            assertEquals(mime, format.getString(MediaFormat.KEY_MIME));
            if (mime.equals(MediaFormat.MIMETYPE_VIDEO_AVC)) {
                int profile = format.getInteger(MediaFormat.KEY_PROFILE);
                if (profile == AVCProfileHigh10 || profile == AVCProfileHigh422 ||
                        profile == AVCProfileHigh444) {
                    isHDR = true;
                    break;
                }
            } else if (mime.equals(MediaFormat.MIMETYPE_VIDEO_VP9)) {
                int profile = format.getInteger(MediaFormat.KEY_PROFILE, VP9Profile0);
                if (profile == VP9Profile2HDR || profile == VP9Profile3HDR ||
                        profile == VP9Profile2HDR10Plus || profile == VP9Profile3HDR10Plus) {
                    isHDR = true;
                    break;
                }
            } else if (mime.equals(MediaFormat.MIMETYPE_VIDEO_HEVC)) {
                int profile = format.getInteger(MediaFormat.KEY_PROFILE, HEVCProfileMain);
                if (profile == HEVCProfileMain10HDR10 || profile == HEVCProfileMain10HDR10Plus) {
                    isHDR = true;
                    break;
                }
            } else if (mime.equals(MediaFormat.MIMETYPE_VIDEO_AV1)) {
                int profile = format.getInteger(MediaFormat.KEY_PROFILE, AV1ProfileMain8);
                if (profile == AV1ProfileMain10HDR10 || profile == AV1ProfileMain10HDR10Plus) {
                    isHDR = true;
                    break;
                }
            }
        }
        return isHDR;
    }

    static boolean canDisplaySupportHDRContent() {
        DisplayManager displayManager = mContext.getSystemService(DisplayManager.class);
        return displayManager.getDisplay(Display.DEFAULT_DISPLAY).getHdrCapabilities()
                .getSupportedHdrTypes().length != 0;
    }

    static boolean areFormatsSupported(String name, String mime, ArrayList<MediaFormat> formats)
            throws IOException {
        MediaCodec codec = MediaCodec.createByCodecName(name);
        MediaCodecInfo.CodecCapabilities codecCapabilities =
                codec.getCodecInfo().getCapabilitiesForType(mime);
        boolean isSupported = true;
        if (formats != null) {
            for (int i = 0; i < formats.size() && isSupported; i++) {
                isSupported = codecCapabilities.isFormatSupported(formats.get(i));
            }
        }
        codec.release();
        return isSupported;
    }

    static boolean isDefaultCodec(String codecName, String mime, boolean isEncoder)
            throws IOException {
        Map<String,String> mDefaultCodecs = isEncoder ? mDefaultEncoders:  mDefaultDecoders;
        if (mDefaultCodecs.containsKey(mime)) {
            return mDefaultCodecs.get(mime).equalsIgnoreCase(codecName);
        }
        MediaCodec codec = isEncoder ? MediaCodec.createEncoderByType(mime)
                : MediaCodec.createDecoderByType(mime);
        boolean isDefault = codec.getName().equalsIgnoreCase(codecName);
        mDefaultCodecs.put(mime, codec.getName());
        codec.release();
        return isDefault;
    }

    static ArrayList<String> compileRequiredMimeList(boolean isEncoder, boolean needAudio,
            boolean needVideo) {
        Set<String> list = new HashSet<>();
        if (!isEncoder) {
            if (hasAudioOutput() && needAudio) {
                // sec 5.1.2
                list.add(MediaFormat.MIMETYPE_AUDIO_AAC);
                list.add(MediaFormat.MIMETYPE_AUDIO_FLAC);
                list.add(MediaFormat.MIMETYPE_AUDIO_MPEG);
                list.add(MediaFormat.MIMETYPE_AUDIO_VORBIS);
                list.add(MediaFormat.MIMETYPE_AUDIO_RAW);
                list.add(MediaFormat.MIMETYPE_AUDIO_OPUS);
            }
            if (isHandheld() || isTv() || isAutomotive()) {
                // sec 2.2.2, 2.3.2, 2.5.2
                if (needAudio) {
                    list.add(MediaFormat.MIMETYPE_AUDIO_AAC);
                }
                if (needVideo) {
                    list.add(MediaFormat.MIMETYPE_VIDEO_AVC);
                    list.add(MediaFormat.MIMETYPE_VIDEO_MPEG4);
                    list.add(MediaFormat.MIMETYPE_VIDEO_H263);
                    list.add(MediaFormat.MIMETYPE_VIDEO_VP8);
                    list.add(MediaFormat.MIMETYPE_VIDEO_VP9);
                }
            }
            if (isHandheld()) {
                // sec 2.2.2
                if (needAudio) {
                    list.add(MediaFormat.MIMETYPE_AUDIO_AMR_NB);
                    list.add(MediaFormat.MIMETYPE_AUDIO_AMR_WB);
                }
                if (needVideo) {
                    list.add(MediaFormat.MIMETYPE_VIDEO_HEVC);
                }
            }
            if (isTv() && needVideo) {
                // sec 2.3.2
                list.add(MediaFormat.MIMETYPE_VIDEO_HEVC);
                list.add(MediaFormat.MIMETYPE_VIDEO_MPEG2);
            }
        } else {
            if (hasMicrophone() && needAudio) {
                // sec 5.1.1
                // TODO(b/154423550)
                // list.add(MediaFormat.MIMETYPE_AUDIO_RAW);
                list.add(MediaFormat.MIMETYPE_AUDIO_FLAC);
                list.add(MediaFormat.MIMETYPE_AUDIO_OPUS);
            }
            if (isHandheld() || isTv() || isAutomotive()) {
                // sec 2.2.2, 2.3.2, 2.5.2
                if (needAudio) {
                    list.add(MediaFormat.MIMETYPE_AUDIO_AAC);
                }
                if (needVideo) {
                    list.add(MediaFormat.MIMETYPE_VIDEO_AVC);
                    list.add(MediaFormat.MIMETYPE_VIDEO_VP8);
                }
            }
            if (isHandheld() && needAudio) {
                // sec 2.2.2
                list.add(MediaFormat.MIMETYPE_AUDIO_AMR_NB);
                list.add(MediaFormat.MIMETYPE_AUDIO_AMR_WB);
            }
        }
        return new ArrayList<>(list);
    }

    static ArrayList<String> compileCompleteTestMimeList(boolean isEncoder, boolean needAudio,
            boolean needVideo) {
        ArrayList<String> mimes = new ArrayList<>();
        if (mimeSelKeys == null) {
            ArrayList<String> cddRequiredMimeList =
                    compileRequiredMimeList(isEncoder, needAudio, needVideo);
            MediaCodecList codecList = new MediaCodecList(MediaCodecList.REGULAR_CODECS);
            MediaCodecInfo[] codecInfos = codecList.getCodecInfos();
            for (MediaCodecInfo codecInfo : codecInfos) {
                if (codecInfo.isEncoder() != isEncoder) continue;
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q && codecInfo.isAlias()) continue;
                String[] types = codecInfo.getSupportedTypes();
                for (String type : types) {
                    if (!needAudio && type.startsWith(""audio/"")) continue;
                    if (!needVideo && type.startsWith(""video/"")) continue;
                    if (!mimes.contains(type)) {
                        mimes.add(type);
                    }
                }
            }
            // TODO(b/154423708): add checks for video o/p port and display length >= 2.5""
            /* sec 5.2: device implementations include an embedded screen display with the
            diagonal length of at least 2.5inches or include a video output port or declare the
            support of a camera */
            if (isEncoder && hasCamera() && needVideo &&
                    !mimes.contains(MediaFormat.MIMETYPE_VIDEO_AVC) &&
                    !mimes.contains(MediaFormat.MIMETYPE_VIDEO_VP8)) {
                // Add required cdd mimes here so that respective codec tests fail.
                mimes.add(MediaFormat.MIMETYPE_VIDEO_AVC);
                mimes.add(MediaFormat.MIMETYPE_VIDEO_VP8);
                Log.e(LOG_TAG,""device must support at least one of VP8 or AVC video encoders"");
            }
            for (String mime : cddRequiredMimeList) {
                if (!mimes.contains(mime)) {
                    // Add required cdd mimes here so that respective codec tests fail.
                    mimes.add(mime);
                    Log.e(LOG_TAG, ""no codec found for mime "" + mime + "" as required by cdd"");
                }
            }
        } else {
            for (Map.Entry<String, String> entry : codecSelKeyMimeMap.entrySet()) {
                String key = entry.getKey();
                String value = entry.getValue();
                if (mimeSelKeys.contains(key) && !mimes.contains(value)) mimes.add(value);
            }
        }
        return mimes;
    }

    static List<Object[]> prepareParamList(List<Object[]> exhaustiveArgsList, boolean isEncoder,
            boolean needAudio, boolean needVideo, boolean mustTestAllCodecs) {
        ArrayList<String> mimes = compileCompleteTestMimeList(isEncoder, needAudio, needVideo);
        ArrayList<String> cddRequiredMimeList =
                compileRequiredMimeList(isEncoder, needAudio, needVideo);
        final List<Object[]> argsList = new ArrayList<>();
        int argLength = exhaustiveArgsList.get(0).length;
        for (String mime : mimes) {
            ArrayList<String> totalListOfCodecs = selectCodecs(mime, null, null, isEncoder);
            ArrayList<String> listOfCodecs = new ArrayList<>();
            if (codecPrefix != null) {
                for (String codec : totalListOfCodecs) {
                    if (codec.startsWith(codecPrefix)) {
                        listOfCodecs.add(codec);
                    }
                }
            } else {
                listOfCodecs = totalListOfCodecs;
            }
            if (mustTestAllCodecs && listOfCodecs.size() == 0 && codecPrefix == null) {
                listOfCodecs.add(INVALID_CODEC + mime);
            }
            boolean miss = true;
            for (Object[] arg : exhaustiveArgsList) {
                if (mime.equals(arg[0])) {
                    for (String codec : listOfCodecs) {
                        Object[] arg_ = new Object[argLength + 1];
                        arg_[0] = codec;
                        System.arraycopy(arg, 0, arg_, 1, argLength);
                        argsList.add(arg_);
                    }
                    miss = false;
                }
            }
            if (miss && mustTestAllCodecs) {
                if (!cddRequiredMimeList.contains(mime)) {
                    Log.w(LOG_TAG, ""no test vectors available for optional mime type "" + mime);
                    continue;
                }
                for (String codec : listOfCodecs) {
                    Object[] arg_ = new Object[argLength + 1];
                    arg_[0] = codec;
                    arg_[1] = mime;
                    System.arraycopy(exhaustiveArgsList.get(0), 1, arg_, 2, argLength - 1);
                    argsList.add(arg_);
                }
            }
        }
        return argsList;
    }

    abstract void enqueueInput(int bufferIndex) throws IOException;

    abstract void dequeueOutput(int bufferIndex, MediaCodec.BufferInfo info);

    void configureCodec(MediaFormat format, boolean isAsync, boolean signalEOSWithLastFrame,
            boolean isEncoder) {
        resetContext(isAsync, signalEOSWithLastFrame);
        mAsyncHandle.setCallBack(mCodec, isAsync);
        // signalEOS flag has nothing to do with configure. We are using this flag to try all
        // available configure apis
        if (signalEOSWithLastFrame) {
            mCodec.configure(format, mSurface, null,
                    isEncoder ? MediaCodec.CONFIGURE_FLAG_ENCODE : 0);
        } else {
            mCodec.configure(format, mSurface, isEncoder ? MediaCodec.CONFIGURE_FLAG_ENCODE : 0,
                    null);
        }
        if (ENABLE_LOGS) {
            Log.v(LOG_TAG, ""codec configured"");
        }
    }

    void flushCodec() {
        mCodec.flush();
        // TODO(b/147576107): is it ok to clearQueues right away or wait for some signal
        mAsyncHandle.clearQueues();
        mSawInputEOS = false;
        mSawOutputEOS = false;
        mInputCount = 0;
        mOutputCount = 0;
        mPrevOutputPts = Long.MIN_VALUE;
        if (ENABLE_LOGS) {
            Log.v(LOG_TAG, ""codec flushed"");
        }
    }

    void reConfigureCodec(MediaFormat format, boolean isAsync, boolean signalEOSWithLastFrame,
            boolean isEncoder) {
        /* TODO(b/147348711) */
        if (false) mCodec.stop();
        else mCodec.reset();
        configureCodec(format, isAsync, signalEOSWithLastFrame, isEncoder);
    }

    void resetContext(boolean isAsync, boolean signalEOSWithLastFrame) {
        mAsyncHandle.resetContext();
        mIsCodecInAsyncMode = isAsync;
        mSawInputEOS = false;
        mSawOutputEOS = false;
        mSignalEOSWithLastFrame = signalEOSWithLastFrame;
        mInputCount = 0;
        mOutputCount = 0;
        mPrevOutputPts = Long.MIN_VALUE;
        mSignalledOutFormatChanged = false;
    }

    void enqueueEOS(int bufferIndex) {
        if (!mSawInputEOS) {
            mCodec.queueInputBuffer(bufferIndex, 0, 0, 0, MediaCodec.BUFFER_FLAG_END_OF_STREAM);
            mSawInputEOS = true;
            if (ENABLE_LOGS) {
                Log.v(LOG_TAG, ""Queued End of Stream"");
            }
        }
    }

    void doWork(int frameLimit) throws InterruptedException, IOException {
        int frameCount = 0;
        if (mIsCodecInAsyncMode) {
            // dequeue output after inputEOS is expected to be done in waitForAllOutputs()
            while (!mAsyncHandle.hasSeenError() && !mSawInputEOS && frameCount < frameLimit) {
                Pair<Integer, MediaCodec.BufferInfo> element = mAsyncHandle.getWork();
                if (element != null) {
                    int bufferID = element.first;
                    MediaCodec.BufferInfo info = element.second;
                    if (info != null) {
                        // <id, info> corresponds to output callback. Handle it accordingly
                        dequeueOutput(bufferID, info);
                    } else {
                        // <id, null> corresponds to input callback. Handle it accordingly
                        enqueueInput(bufferID);
                        frameCount++;
                    }
                }
            }
        } else {
            MediaCodec.BufferInfo outInfo = new MediaCodec.BufferInfo();
            // dequeue output after inputEOS is expected to be done in waitForAllOutputs()
            while (!mSawInputEOS && frameCount < frameLimit) {
                int outputBufferId = mCodec.dequeueOutputBuffer(outInfo, Q_DEQ_TIMEOUT_US);
                if (outputBufferId >= 0) {
                    dequeueOutput(outputBufferId, outInfo);
                } else if (outputBufferId == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {
                    mOutFormat = mCodec.getOutputFormat();
                    mSignalledOutFormatChanged = true;
                }
                int inputBufferId = mCodec.dequeueInputBuffer(Q_DEQ_TIMEOUT_US);
                if (inputBufferId != -1) {
                    enqueueInput(inputBufferId);
                    frameCount++;
                }
            }
        }
    }

    void queueEOS() throws InterruptedException {
        if (mIsCodecInAsyncMode) {
            while (!mAsyncHandle.hasSeenError() && !mSawInputEOS) {
                Pair<Integer, MediaCodec.BufferInfo> element = mAsyncHandle.getWork();
                if (element != null) {
                    int bufferID = element.first;
                    MediaCodec.BufferInfo info = element.second;
                    if (info != null) {
                        dequeueOutput(bufferID, info);
                    } else {
                        enqueueEOS(element.first);
                    }
                }
            }
        } else {
            MediaCodec.BufferInfo outInfo = new MediaCodec.BufferInfo();
            while (!mSawInputEOS) {
                int outputBufferId = mCodec.dequeueOutputBuffer(outInfo, Q_DEQ_TIMEOUT_US);
                if (outputBufferId >= 0) {
                    dequeueOutput(outputBufferId, outInfo);
                } else if (outputBufferId == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {
                    mOutFormat = mCodec.getOutputFormat();
                    mSignalledOutFormatChanged = true;
                }
                int inputBufferId = mCodec.dequeueInputBuffer(Q_DEQ_TIMEOUT_US);
                if (inputBufferId != -1) {
                    enqueueEOS(inputBufferId);
                }
            }
        }
    }

    void waitForAllOutputs() throws InterruptedException {
        if (mIsCodecInAsyncMode) {
            while (!mAsyncHandle.hasSeenError() && !mSawOutputEOS) {
                Pair<Integer, MediaCodec.BufferInfo> element = mAsyncHandle.getOutput();
                if (element != null) {
                    dequeueOutput(element.first, element.second);
                }
            }
        } else {
            MediaCodec.BufferInfo outInfo = new MediaCodec.BufferInfo();
            while (!mSawOutputEOS) {
                int outputBufferId = mCodec.dequeueOutputBuffer(outInfo, Q_DEQ_TIMEOUT_US);
                if (outputBufferId >= 0) {
                    dequeueOutput(outputBufferId, outInfo);
                } else if (outputBufferId == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {
                    mOutFormat = mCodec.getOutputFormat();
                    mSignalledOutFormatChanged = true;
                }
            }
        }
    }

    static ArrayList<String> selectCodecs(String mime, ArrayList<MediaFormat> formats,
            String[] features, boolean isEncoder) {
        MediaCodecList codecList = new MediaCodecList(MediaCodecList.REGULAR_CODECS);
        MediaCodecInfo[] codecInfos = codecList.getCodecInfos();
        ArrayList<String> listOfCodecs = new ArrayList<>();
        for (MediaCodecInfo codecInfo : codecInfos) {
            if (codecInfo.isEncoder() != isEncoder) continue;
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q && codecInfo.isAlias()) continue;
            String[] types = codecInfo.getSupportedTypes();
            for (String type : types) {
                if (type.equalsIgnoreCase(mime)) {
                    boolean isOk = true;
                    MediaCodecInfo.CodecCapabilities codecCapabilities =
                            codecInfo.getCapabilitiesForType(type);
                    if (formats != null) {
                        for (MediaFormat format : formats) {
                            if (!codecCapabilities.isFormatSupported(format)) {
                                isOk = false;
                                break;
                            }
                        }
                    }
                    if (features != null) {
                        for (String feature : features) {
                            if (!codecCapabilities.isFeatureSupported(feature)) {
                                isOk = false;
                                break;
                            }
                        }
                    }
                    if (isOk) listOfCodecs.add(codecInfo.getName());
                }
            }
        }
        return listOfCodecs;
    }

    static int getWidth(MediaFormat format) {
        int width = format.getInteger(MediaFormat.KEY_WIDTH, -1);
        if (format.containsKey(""crop-left"") && format.containsKey(""crop-right"")) {
            width = format.getInteger(""crop-right"") + 1 - format.getInteger(""crop-left"");
        }
        return width;
    }

    static int getHeight(MediaFormat format) {
        int height = format.getInteger(MediaFormat.KEY_HEIGHT, -1);
        if (format.containsKey(""crop-top"") && format.containsKey(""crop-bottom"")) {
            height = format.getInteger(""crop-bottom"") + 1 - format.getInteger(""crop-top"");
        }
        return height;
    }

    boolean isFormatSimilar(MediaFormat inpFormat, MediaFormat outFormat) {
        if (inpFormat == null || outFormat == null) return false;
        String inpMime = inpFormat.getString(MediaFormat.KEY_MIME);
        String outMime = outFormat.getString(MediaFormat.KEY_MIME);
        // not comparing input and output mimes because for a codec, mime is raw on one side and
        // encoded type on the other
        if (outMime.startsWith(""audio/"")) {
            return inpFormat.getInteger(MediaFormat.KEY_CHANNEL_COUNT, -1) ==
                    outFormat.getInteger(MediaFormat.KEY_CHANNEL_COUNT, -2) &&
                    inpFormat.getInteger(MediaFormat.KEY_SAMPLE_RATE, -1) ==
                            outFormat.getInteger(MediaFormat.KEY_SAMPLE_RATE, -2) &&
                    inpMime.startsWith(""audio/"");
        } else if (outMime.startsWith(""video/"")) {
            return getWidth(inpFormat) == getWidth(outFormat) &&
                    getHeight(inpFormat) == getHeight(outFormat) && inpMime.startsWith(""video/"");
        }
        return true;
    }

    PersistableBundle validateMetrics(String codec) {
        PersistableBundle metrics = mCodec.getMetrics();
        assertTrue(""metrics is null"", metrics != null);
        assertTrue(metrics.getString(MediaCodec.MetricsConstants.CODEC).equals(codec));
        if (mIsAudio) {
            assertTrue(metrics.getString(MediaCodec.MetricsConstants.MODE)
                    .equals(MediaCodec.MetricsConstants.MODE_AUDIO));
        } else {
            assertTrue(metrics.getString(MediaCodec.MetricsConstants.MODE)
                    .equals(MediaCodec.MetricsConstants.MODE_VIDEO));
        }
        return metrics;
    }

    PersistableBundle validateMetrics(String codec, MediaFormat format) {
        PersistableBundle metrics = validateMetrics(codec);
        if (!mIsAudio) {
            assertTrue(metrics.getInt(MediaCodec.MetricsConstants.WIDTH) == getWidth(format));
            assertTrue(metrics.getInt(MediaCodec.MetricsConstants.HEIGHT) == getHeight(format));
        }
        assertTrue(metrics.getInt(MediaCodec.MetricsConstants.SECURE) == 0);
        return metrics;
    }

    void validateColorAspects(MediaFormat fmt, int range, int standard, int transfer) {
        int colorRange = fmt.getInteger(MediaFormat.KEY_COLOR_RANGE, UNSPECIFIED);
        int colorStandard = fmt.getInteger(MediaFormat.KEY_COLOR_STANDARD, UNSPECIFIED);
        int colorTransfer = fmt.getInteger(MediaFormat.KEY_COLOR_TRANSFER, UNSPECIFIED);
        if (range > UNSPECIFIED) {
            assertEquals(""color range mismatch "", range, colorRange);
        }
        if (standard > UNSPECIFIED) {
            assertEquals(""color standard mismatch "", standard, colorStandard);
        }
        if (transfer > UNSPECIFIED) {
            assertEquals(""color transfer mismatch "", transfer, colorTransfer);
        }
    }

    public void setUpSurface(CodecTestActivity activity) throws InterruptedException {
        activity.waitTillSurfaceIsCreated();
        mSurface = activity.getSurface();
        assertTrue(""Surface created is null."", mSurface != null);
        assertTrue(""Surface created is invalid."", mSurface.isValid());
    }

    public void tearDownSurface() {
        if (mSurface != null) {
            mSurface.release();
            mSurface = null;
        }
    }

    @Before
    public void isCodecNameValid() {
        if (mCodecName != null && mCodecName.startsWith(INVALID_CODEC)) {
            fail(""no valid component available for current test "");
        }
    }
}

class CodecDecoderTestBase extends CodecTestBase {
    private static final String LOG_TAG = CodecDecoderTestBase.class.getSimpleName();

    String mMime;
    String mTestFile;
    boolean mIsInterlaced;

    ArrayList<ByteBuffer> mCsdBuffers;
    private int mCurrCsdIdx;

    private ByteBuffer flatBuffer = ByteBuffer.allocate(4 * Integer.BYTES);

    MediaExtractor mExtractor;

    CodecDecoderTestBase(String codecName, String mime, String testFile) {
        mCodecName = codecName;
        mMime = mime;
        mTestFile = testFile;
        mAsyncHandle = new CodecAsyncHandler();
        mCsdBuffers = new ArrayList<>();
        mIsAudio = mMime.startsWith(""audio/"");
    }

    MediaFormat setUpSource(String srcFile) throws IOException {
        return setUpSource(mInpPrefix, srcFile);
    }

    MediaFormat setUpSource(String prefix, String srcFile) throws IOException {
        mExtractor = new MediaExtractor();
        mExtractor.setDataSource(prefix + srcFile);
        for (int trackID = 0; trackID < mExtractor.getTrackCount(); trackID++) {
            MediaFormat format = mExtractor.getTrackFormat(trackID);
            if (mMime.equalsIgnoreCase(format.getString(MediaFormat.KEY_MIME))) {
                mExtractor.selectTrack(trackID);
                if (!mIsAudio) {
                    if (mSurface == null) {
                        // COLOR_FormatYUV420Flexible must be supported by all components
                        format.setInteger(MediaFormat.KEY_COLOR_FORMAT, COLOR_FormatYUV420Flexible);
                    } else {
                        format.setInteger(MediaFormat.KEY_COLOR_FORMAT, COLOR_FormatSurface);
                    }
                }
                // TODO: determine this from the extractor format when it becomes exposed.
                mIsInterlaced = srcFile.contains(""_interlaced_"");
                return format;
            }
        }
        fail(""No track with mime: "" + mMime + "" found in file: "" + srcFile);
        return null;
    }

    boolean hasCSD(MediaFormat format) {
        return format.containsKey(""csd-0"");
    }

    void flattenBufferInfo(MediaCodec.BufferInfo info, boolean isAudio) {
        if (isAudio) {
            flatBuffer.putInt(info.size);
        }
        flatBuffer.putInt(info.flags & ~MediaCodec.BUFFER_FLAG_END_OF_STREAM)
                .putLong(info.presentationTimeUs);
        flatBuffer.flip();
    }

    void enqueueCodecConfig(int bufferIndex) {
        ByteBuffer inputBuffer = mCodec.getInputBuffer(bufferIndex);
        ByteBuffer csdBuffer = mCsdBuffers.get(mCurrCsdIdx);
        inputBuffer.put((ByteBuffer) csdBuffer.rewind());
        mCodec.queueInputBuffer(bufferIndex, 0, csdBuffer.limit(), 0,
                MediaCodec.BUFFER_FLAG_CODEC_CONFIG);
        if (ENABLE_LOGS) {
            Log.v(LOG_TAG, ""queued csd: id: "" + bufferIndex + "" size: "" + csdBuffer.limit());
        }
    }

    void enqueueInput(int bufferIndex) {
        if (mExtractor.getSampleSize() < 0) {
            enqueueEOS(bufferIndex);
        } else {
            ByteBuffer inputBuffer = mCodec.getInputBuffer(bufferIndex);
            mExtractor.readSampleData(inputBuffer, 0);
            int size = (int) mExtractor.getSampleSize();
            long pts = mExtractor.getSampleTime();
            int extractorFlags = mExtractor.getSampleFlags();
            int codecFlags = 0;
            if ((extractorFlags & MediaExtractor.SAMPLE_FLAG_SYNC) != 0) {
                codecFlags |= MediaCodec.BUFFER_FLAG_KEY_FRAME;
            }
            if ((extractorFlags & MediaExtractor.SAMPLE_FLAG_PARTIAL_FRAME) != 0) {
                codecFlags |= MediaCodec.BUFFER_FLAG_PARTIAL_FRAME;
            }
            if (!mExtractor.advance() && mSignalEOSWithLastFrame) {
                codecFlags |= MediaCodec.BUFFER_FLAG_END_OF_STREAM;
                mSawInputEOS = true;
            }
            if (ENABLE_LOGS) {
                Log.v(LOG_TAG, ""input: id: "" + bufferIndex + "" size: "" + size + "" pts: "" + pts +
                        "" flags: "" + codecFlags);
            }
            mCodec.queueInputBuffer(bufferIndex, 0, size, pts, codecFlags);
            if (size > 0 && (codecFlags & (MediaCodec.BUFFER_FLAG_CODEC_CONFIG |
                    MediaCodec.BUFFER_FLAG_PARTIAL_FRAME)) == 0) {
                mOutputBuff.saveInPTS(pts);
                mInputCount++;
            }
        }
    }

    void enqueueInput(int bufferIndex, ByteBuffer buffer, MediaCodec.BufferInfo info) {
        ByteBuffer inputBuffer = mCodec.getInputBuffer(bufferIndex);
        buffer.position(info.offset);
        for (int i = 0; i < info.size; i++) {
            inputBuffer.put(buffer.get());
        }
        if (ENABLE_LOGS) {
            Log.v(LOG_TAG, ""input: id: "" + bufferIndex + "" flags: "" + info.flags + "" size: "" +
                    info.size + "" timestamp: "" + info.presentationTimeUs);
        }
        mCodec.queueInputBuffer(bufferIndex, 0, info.size, info.presentationTimeUs,
                info.flags);
        if (info.size > 0 && ((info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) == 0) &&
                ((info.flags & MediaCodec.BUFFER_FLAG_PARTIAL_FRAME) == 0)) {
            mOutputBuff.saveInPTS(info.presentationTimeUs);
            mInputCount++;
        }
        if ((info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {
            mSawInputEOS = true;
        }
    }

    void dequeueOutput(int bufferIndex, MediaCodec.BufferInfo info) {
        if (info.size > 0 && mSaveToMem) {
            ByteBuffer buf = mCodec.getOutputBuffer(bufferIndex);
            flattenBufferInfo(info, mIsAudio);
            mOutputBuff.checksum(flatBuffer, flatBuffer.limit());
            if (mIsAudio) {
                mOutputBuff.checksum(buf, info.size);
                mOutputBuff.saveToMemory(buf, info);
            } else {
                // tests both getOutputImage and getOutputBuffer. Can do time division
                // multiplexing but lets allow it for now
                MediaFormat format = mCodec.getOutputFormat();
                int width = format.getInteger(MediaFormat.KEY_WIDTH);
                int height = format.getInteger(MediaFormat.KEY_HEIGHT);
                int stride = format.getInteger(MediaFormat.KEY_STRIDE);
                mOutputBuff.checksum(buf, info.size, width, height, stride);

                Image img = mCodec.getOutputImage(bufferIndex);
                assertTrue(img != null);
                mOutputBuff.checksum(img);
            }
        }
        if ((info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {
            mSawOutputEOS = true;
        }
        if (ENABLE_LOGS) {
            Log.v(LOG_TAG, ""output: id: "" + bufferIndex + "" flags: "" + info.flags + "" size: "" +
                    info.size + "" timestamp: "" + info.presentationTimeUs);
        }
        if (info.size > 0 && (info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) == 0) {
            mOutputBuff.saveOutPTS(info.presentationTimeUs);
            mOutputCount++;
        }
        mCodec.releaseOutputBuffer(bufferIndex, false);
    }

    void doWork(ByteBuffer buffer, ArrayList<MediaCodec.BufferInfo> list)
            throws InterruptedException {
        int frameCount = 0;
        if (mIsCodecInAsyncMode) {
            // output processing after queuing EOS is done in waitForAllOutputs()
            while (!mAsyncHandle.hasSeenError() && !mSawInputEOS && frameCount < list.size()) {
                Pair<Integer, MediaCodec.BufferInfo> element = mAsyncHandle.getWork();
                if (element != null) {
                    int bufferID = element.first;
                    MediaCodec.BufferInfo info = element.second;
                    if (info != null) {
                        dequeueOutput(bufferID, info);
                    } else {
                        enqueueInput(bufferID, buffer, list.get(frameCount));
                        frameCount++;
                    }
                }
            }
        } else {
            MediaCodec.BufferInfo outInfo = new MediaCodec.BufferInfo();
            // output processing after queuing EOS is done in waitForAllOutputs()
            while (!mSawInputEOS && frameCount < list.size()) {
                int outputBufferId = mCodec.dequeueOutputBuffer(outInfo, Q_DEQ_TIMEOUT_US);
                if (outputBufferId >= 0) {
                    dequeueOutput(outputBufferId, outInfo);
                } else if (outputBufferId == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {
                    mOutFormat = mCodec.getOutputFormat();
                    mSignalledOutFormatChanged = true;
                }
                int inputBufferId = mCodec.dequeueInputBuffer(Q_DEQ_TIMEOUT_US);
                if (inputBufferId != -1) {
                    enqueueInput(inputBufferId, buffer, list.get(frameCount));
                    frameCount++;
                }
            }
        }
    }

    void queueCodecConfig() throws InterruptedException {
        if (mIsCodecInAsyncMode) {
            for (mCurrCsdIdx = 0; !mAsyncHandle.hasSeenError() && mCurrCsdIdx < mCsdBuffers.size();
                 mCurrCsdIdx++) {
                Pair<Integer, MediaCodec.BufferInfo> element = mAsyncHandle.getInput();
                if (element != null) {
                    enqueueCodecConfig(element.first);
                }
            }
        } else {
            for (mCurrCsdIdx = 0; mCurrCsdIdx < mCsdBuffers.size(); mCurrCsdIdx++) {
                enqueueCodecConfig(mCodec.dequeueInputBuffer(-1));
            }
        }
    }

    void decodeToMemory(String file, String decoder, long pts, int mode, int frameLimit)
            throws IOException, InterruptedException {
        mSaveToMem = true;
        mOutputBuff = new OutputManager();
        mCodec = MediaCodec.createByCodecName(decoder);
        MediaFormat format = setUpSource(file);
        configureCodec(format, false, true, false);
        mCodec.start();
        mExtractor.seekTo(pts, mode);
        doWork(frameLimit);
        queueEOS();
        waitForAllOutputs();
        mCodec.stop();
        mCodec.release();
        mExtractor.release();
        mSaveToMem = false;
    }

    @Override
    PersistableBundle validateMetrics(String decoder, MediaFormat format) {
        PersistableBundle metrics = super.validateMetrics(decoder, format);
        assertTrue(metrics.getString(MediaCodec.MetricsConstants.MIME_TYPE).equals(mMime));
        assertTrue(metrics.getInt(MediaCodec.MetricsConstants.ENCODER) == 0);
        return metrics;
    }

    void validateColorAspects(String decoder, String parent, String name, int range, int standard,
            int transfer, boolean ignoreColorBox)
            throws IOException, InterruptedException {
        mOutputBuff = new OutputManager();
        MediaFormat format = setUpSource(parent, name);
        if (ignoreColorBox) {
            format.removeKey(MediaFormat.KEY_COLOR_RANGE);
            format.removeKey(MediaFormat.KEY_COLOR_STANDARD);
            format.removeKey(MediaFormat.KEY_COLOR_TRANSFER);
        }
        if (decoder == null) {
            MediaCodecList codecList = new MediaCodecList(MediaCodecList.REGULAR_CODECS);
            decoder = codecList.findDecoderForFormat(format);
        }
        mCodec = MediaCodec.createByCodecName(decoder);
        configureCodec(format, true, true, false);
        mCodec.start();
        doWork(1);
        queueEOS();
        waitForAllOutputs();
        validateColorAspects(mCodec.getOutputFormat(), range, standard, transfer);
        mCodec.stop();
        mCodec.release();
        mExtractor.release();
    }
}

class CodecEncoderTestBase extends CodecTestBase {
    private static final String LOG_TAG = CodecEncoderTestBase.class.getSimpleName();

    // files are in WorkDir.getMediaDirString();
    private static final String mInputAudioFile = ""bbb_2ch_44kHz_s16le.raw"";
    private static final String mInputVideoFile = ""bbb_cif_yuv420p_30fps.yuv"";
    private final int INP_FRM_WIDTH = 352;
    private final int INP_FRM_HEIGHT = 288;

    final String mMime;
    final int[] mBitrates;
    final int[] mEncParamList1;
    final int[] mEncParamList2;

    final String mInputFile;
    byte[] mInputData;
    int mNumBytesSubmitted;
    long mInputOffsetPts;

    ArrayList<MediaFormat> mFormats;
    ArrayList<MediaCodec.BufferInfo> mInfoList;

    int mWidth, mHeight;
    int mFrameRate;
    int mMaxBFrames;
    int mChannels;
    int mSampleRate;

    CodecEncoderTestBase(String encoder, String mime, int[] bitrates, int[] encoderInfo1,
            int[] encoderInfo2) {
        mMime = mime;
        mCodecName = encoder;
        mBitrates = bitrates;
        mEncParamList1 = encoderInfo1;
        mEncParamList2 = encoderInfo2;
        mFormats = new ArrayList<>();
        mInfoList = new ArrayList<>();
        mWidth = INP_FRM_WIDTH;
        mHeight = INP_FRM_HEIGHT;
        if (mime.equals(MediaFormat.MIMETYPE_VIDEO_MPEG4)) mFrameRate = 12;
        else if (mime.equals(MediaFormat.MIMETYPE_VIDEO_H263)) mFrameRate = 12;
        else mFrameRate = 30;
        mMaxBFrames = 0;
        mChannels = 1;
        mSampleRate = 8000;
        mAsyncHandle = new CodecAsyncHandler();
        mIsAudio = mMime.startsWith(""audio/"");
        mInputFile = mIsAudio ? mInputAudioFile : mInputVideoFile;
    }

    /**
     * Selects encoder input color format in byte buffer mode. As of now ndk tests support only
     * 420p, 420sp. COLOR_FormatYUV420Flexible although can represent any form of yuv, it doesn't
     * work in ndk due to lack of AMediaCodec_GetInputImage()
     */
    static int findByteBufferColorFormat(String encoder, String mime) throws IOException {
        MediaCodec codec = MediaCodec.createByCodecName(encoder);
        MediaCodecInfo.CodecCapabilities cap = codec.getCodecInfo().getCapabilitiesForType(mime);
        int colorFormat = -1;
        for (int c : cap.colorFormats) {
            if (c == MediaCodecInfo.CodecCapabilities.COLOR_FormatYUV420SemiPlanar ||
                    c == MediaCodecInfo.CodecCapabilities.COLOR_FormatYUV420Planar) {
                Log.v(LOG_TAG, ""selecting color format: "" + c);
                colorFormat = c;
                break;
            }
        }
        codec.release();
        return colorFormat;
    }

    @Override
    void resetContext(boolean isAsync, boolean signalEOSWithLastFrame) {
        super.resetContext(isAsync, signalEOSWithLastFrame);
        mNumBytesSubmitted = 0;
        mInputOffsetPts = 0;
    }

    @Override
    void flushCodec() {
        super.flushCodec();
        if (mIsAudio) {
            mInputOffsetPts =
                    (mNumBytesSubmitted + 1024) * 1000000L / (2 * mChannels * mSampleRate);
        } else {
            mInputOffsetPts = (mInputCount + 5) * 1000000L / mFrameRate;
        }
        mPrevOutputPts = mInputOffsetPts - 1;
        mNumBytesSubmitted = 0;
    }

    void setUpSource(String srcFile) throws IOException {
        String inpPath = mInpPrefix + srcFile;
        try (FileInputStream fInp = new FileInputStream(inpPath)) {
            int size = (int) new File(inpPath).length();
            mInputData = new byte[size];
            fInp.read(mInputData, 0, size);
        }
    }

    void fillImage(Image image) {
        Assert.assertTrue(image.getFormat() == ImageFormat.YUV_420_888);
        int imageWidth = image.getWidth();
        int imageHeight = image.getHeight();
        Image.Plane[] planes = image.getPlanes();
        int offset = mNumBytesSubmitted;
        for (int i = 0; i < planes.length; ++i) {
            ByteBuffer buf = planes[i].getBuffer();
            int width = imageWidth;
            int height = imageHeight;
            int tileWidth = INP_FRM_WIDTH;
            int tileHeight = INP_FRM_HEIGHT;
            int rowStride = planes[i].getRowStride();
            int pixelStride = planes[i].getPixelStride();
            if (i != 0) {
                width = imageWidth / 2;
                height = imageHeight / 2;
                tileWidth = INP_FRM_WIDTH / 2;
                tileHeight = INP_FRM_HEIGHT / 2;
            }
            if (pixelStride == 1) {
                if (width == rowStride && width == tileWidth && height == tileHeight) {
                    buf.put(mInputData, offset, width * height);
                } else {
                    for (int z = 0; z < height; z += tileHeight) {
                        int rowsToCopy = Math.min(height - z, tileHeight);
                        for (int y = 0; y < rowsToCopy; y++) {
                            for (int x = 0; x < width; x += tileWidth) {
                                int colsToCopy = Math.min(width - x, tileWidth);
                                buf.position((z + y) * rowStride + x);
                                buf.put(mInputData, offset + y * tileWidth, colsToCopy);
                            }
                        }
                    }
                }
            } else {
                // do it pixel-by-pixel
                for (int z = 0; z < height; z += tileHeight) {
                    int rowsToCopy = Math.min(height - z, tileHeight);
                    for (int y = 0; y < rowsToCopy; y++) {
                        int lineOffset = (z + y) * rowStride;
                        for (int x = 0; x < width; x += tileWidth) {
                            int colsToCopy = Math.min(width - x, tileWidth);
                            for (int w = 0; w < colsToCopy; w++) {
                                buf.position(lineOffset + (x + w) * pixelStride);
                                buf.put(mInputData[offset + y * tileWidth + w]);
                            }
                        }
                    }
                }
            }
            offset += tileWidth * tileHeight;
        }
    }

    void fillByteBuffer(ByteBuffer inputBuffer) {
        int offset = 0, frmOffset = mNumBytesSubmitted;
        for (int plane = 0; plane < 3; plane++) {
            int width = mWidth;
            int height = mHeight;
            int tileWidth = INP_FRM_WIDTH;
            int tileHeight = INP_FRM_HEIGHT;
            if (plane != 0) {
                width = mWidth / 2;
                height = mHeight / 2;
                tileWidth = INP_FRM_WIDTH / 2;
                tileHeight = INP_FRM_HEIGHT / 2;
            }
            for (int k = 0; k < height; k += tileHeight) {
                int rowsToCopy = Math.min(height - k, tileHeight);
                for (int j = 0; j < rowsToCopy; j++) {
                    for (int i = 0; i < width; i += tileWidth) {
                        int colsToCopy = Math.min(width - i, tileWidth);
                        inputBuffer.position(offset + (k + j) * width + i);
                        inputBuffer.put(mInputData, frmOffset + j * tileWidth, colsToCopy);
                    }
                }
            }
            offset += width * height;
            frmOffset += tileWidth * tileHeight;
        }
    }

    void enqueueInput(int bufferIndex) {
        ByteBuffer inputBuffer = mCodec.getInputBuffer(bufferIndex);
        if (mNumBytesSubmitted >= mInputData.length) {
            enqueueEOS(bufferIndex);
        } else {
            int size;
            int flags = 0;
            long pts = mInputOffsetPts;
            if (mIsAudio) {
                pts += mNumBytesSubmitted * 1000000L / (2 * mChannels * mSampleRate);
                size = Math.min(inputBuffer.capacity(), mInputData.length - mNumBytesSubmitted);
                inputBuffer.put(mInputData, mNumBytesSubmitted, size);
                if (mNumBytesSubmitted + size >= mInputData.length && mSignalEOSWithLastFrame) {
                    flags |= MediaCodec.BUFFER_FLAG_END_OF_STREAM;
                    mSawInputEOS = true;
                }
                mNumBytesSubmitted += size;
            } else {
                pts += mInputCount * 1000000L / mFrameRate;
                size = mWidth * mHeight * 3 / 2;
                int frmSize = INP_FRM_WIDTH * INP_FRM_HEIGHT * 3 / 2;
                if (mNumBytesSubmitted + frmSize > mInputData.length) {
                    fail(""received partial frame to encode"");
                } else {
                    Image img = mCodec.getInputImage(bufferIndex);
                    if (img != null) {
                        fillImage(img);
                    } else {
                        if (mWidth == INP_FRM_WIDTH && mHeight == INP_FRM_HEIGHT) {
                            inputBuffer.put(mInputData, mNumBytesSubmitted, size);
                        } else {
                            fillByteBuffer(inputBuffer);
                        }
                    }
                }
                if (mNumBytesSubmitted + frmSize >= mInputData.length && mSignalEOSWithLastFrame) {
                    flags |= MediaCodec.BUFFER_FLAG_END_OF_STREAM;
                    mSawInputEOS = true;
                }
                mNumBytesSubmitted += frmSize;
            }
            if (ENABLE_LOGS) {
                Log.v(LOG_TAG, ""input: id: "" + bufferIndex + "" size: "" + size + "" pts: "" + pts +
                        "" flags: "" + flags);
            }
            mCodec.queueInputBuffer(bufferIndex, 0, size, pts, flags);
            mOutputBuff.saveInPTS(pts);
            mInputCount++;
        }
    }

    void dequeueOutput(int bufferIndex, MediaCodec.BufferInfo info) {
        if (ENABLE_LOGS) {
            Log.v(LOG_TAG, ""output: id: "" + bufferIndex + "" flags: "" + info.flags + "" size: "" +
                    info.size + "" timestamp: "" + info.presentationTimeUs);
        }
        if ((info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {
            mSawOutputEOS = true;
        }
        if (info.size > 0) {
            if (mSaveToMem) {
                MediaCodec.BufferInfo copy = new MediaCodec.BufferInfo();
                copy.set(mOutputBuff.getOutStreamSize(), info.size, info.presentationTimeUs,
                        info.flags);
                mInfoList.add(copy);

                ByteBuffer buf = mCodec.getOutputBuffer(bufferIndex);
                mOutputBuff.saveToMemory(buf, info);
            }
            if ((info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) == 0) {
                mOutputBuff.saveOutPTS(info.presentationTimeUs);
                mOutputCount++;
            }
        }
        mCodec.releaseOutputBuffer(bufferIndex, false);
    }

    @Override
    PersistableBundle validateMetrics(String codec, MediaFormat format) {
        PersistableBundle metrics = super.validateMetrics(codec, format);
        assertTrue(metrics.getString(MediaCodec.MetricsConstants.MIME_TYPE).equals(mMime));
        assertTrue(metrics.getInt(MediaCodec.MetricsConstants.ENCODER) == 1);
        return metrics;
    }

    void setUpParams(int limit) {
        int count = 0;
        for (int bitrate : mBitrates) {
            if (mIsAudio) {
                for (int rate : mEncParamList1) {
                    for (int channels : mEncParamList2) {
                        MediaFormat format = new MediaFormat();
                        format.setString(MediaFormat.KEY_MIME, mMime);
                        if (mMime.equals(MediaFormat.MIMETYPE_AUDIO_FLAC)) {
                            format.setInteger(MediaFormat.KEY_FLAC_COMPRESSION_LEVEL, bitrate);
                        } else {
                            format.setInteger(MediaFormat.KEY_BIT_RATE, bitrate);
                        }
                        format.setInteger(MediaFormat.KEY_SAMPLE_RATE, rate);
                        format.setInteger(MediaFormat.KEY_CHANNEL_COUNT, channels);
                        mFormats.add(format);
                        count++;
                        if (count >= limit) return;
                    }
                }
            } else {
                assertTrue(""Wrong number of height, width parameters"",
                        mEncParamList1.length == mEncParamList2.length);
                for (int i = 0; i < mEncParamList1.length; i++) {
                    MediaFormat format = new MediaFormat();
                    format.setString(MediaFormat.KEY_MIME, mMime);
                    format.setInteger(MediaFormat.KEY_BIT_RATE, bitrate);
                    format.setInteger(MediaFormat.KEY_WIDTH, mEncParamList1[i]);
                    format.setInteger(MediaFormat.KEY_HEIGHT, mEncParamList2[i]);
                    format.setInteger(MediaFormat.KEY_FRAME_RATE, mFrameRate);
                    format.setInteger(MediaFormat.KEY_MAX_B_FRAMES, mMaxBFrames);
                    format.setFloat(MediaFormat.KEY_I_FRAME_INTERVAL, 1.0f);
                    format.setInteger(MediaFormat.KEY_COLOR_FORMAT,
                            MediaCodecInfo.CodecCapabilities.COLOR_FormatYUV420Flexible);
                    mFormats.add(format);
                    count++;
                    if (count >= limit) return;
                }
            }
        }
    }

    void encodeToMemory(String file, String encoder, int frameLimit, MediaFormat format,
            boolean saveToMem) throws IOException, InterruptedException {
        mSaveToMem = saveToMem;
        mOutputBuff = new OutputManager();
        mInfoList.clear();
        mCodec = MediaCodec.createByCodecName(encoder);
        setUpSource(file);
        configureCodec(format, false, true, true);
        if (mIsAudio) {
            mSampleRate = format.getInteger(MediaFormat.KEY_SAMPLE_RATE);
            mChannels = format.getInteger(MediaFormat.KEY_CHANNEL_COUNT);
        } else {
            mWidth = format.getInteger(MediaFormat.KEY_WIDTH);
            mHeight = format.getInteger(MediaFormat.KEY_HEIGHT);
        }
        mCodec.start();
        doWork(frameLimit);
        queueEOS();
        waitForAllOutputs();
        mCodec.stop();
        mCodec.release();
        mSaveToMem = false;
    }

    ByteBuffer decodeElementaryStream(String decoder, MediaFormat format,
            ByteBuffer elementaryStream, ArrayList<MediaCodec.BufferInfo> infos)
            throws IOException, InterruptedException {
        String mime = format.getString(MediaFormat.KEY_MIME);
        CodecDecoderTestBase cdtb = new CodecDecoderTestBase(decoder, mime, null);
        cdtb.mOutputBuff = new OutputManager();
        cdtb.mSaveToMem = true;
        cdtb.mCodec = MediaCodec.createByCodecName(decoder);
        cdtb.mCodec.configure(format, null, null, 0);
        cdtb.mCodec.start();
        cdtb.doWork(elementaryStream, infos);
        cdtb.queueEOS();
        cdtb.waitForAllOutputs();
        cdtb.mCodec.stop();
        cdtb.mCodec.release();
        return cdtb.mOutputBuff.getBuffer();
    }
}"	""	""	"RCS"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.TestImsConfig"	"TestImsConfig"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/TestImsConfig.java"	""	"public void test/*
 *.
 */

package android.telephony.ims.cts;

import android.telephony.ims.RcsClientConfiguration;
import android.telephony.ims.stub.ImsConfigImplBase;

import java.util.HashMap;

public class TestImsConfig extends ImsConfigImplBase {

    private HashMap<Integer, Integer> mIntHashMap = new HashMap<>();
    private HashMap<Integer, String> mStringHashMap = new HashMap<>();

    TestImsConfig() {
        TestAcsClient.getInstance().setImsConfigImpl(this);
    }

    @Override
    public int setConfig(int item, int value) {
        mIntHashMap.put(item, value);
        return ImsConfigImplBase.CONFIG_RESULT_SUCCESS;
    }

    @Override
    public int setConfig(int item, String value) {
        mStringHashMap.put(item, value);
        return ImsConfigImplBase.CONFIG_RESULT_SUCCESS;
    }

    @Override
    public int getConfigInt(int item) {
        Integer result = mIntHashMap.get(item);
        return result != null ? result : ImsConfigImplBase.CONFIG_RESULT_UNKNOWN;
    }

    @Override
    public String getConfigString(int item) {
        return mStringHashMap.get(item);
    }

    @Override
    public void notifyRcsAutoConfigurationReceived(byte[] content, boolean isCompressed) {
        TestAcsClient.getInstance().onConfigChanged(content, isCompressed);
    }

    @Override
    public void notifyRcsAutoConfigurationRemoved() {
        super.notifyRcsAutoConfigurationRemoved();
        TestAcsClient.getInstance().onConfigRemoved();
    }

    @Override
    public void setRcsClientConfiguration(RcsClientConfiguration rcc) {
        super.setRcsClientConfiguration(rcc);
        TestAcsClient.getInstance().onSetRcsClientConfiguration(rcc);
    }

    @Override
    public void triggerAutoConfiguration() {
        super.triggerAutoConfiguration();
        TestAcsClient.getInstance().onTriggerAutoConfiguration();
    }
}"	""	""	"RCS"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.hardware.camera2.cts.CameraTestUtils"	"ImageDropperListener"	""	"/home/gpoor/cts-12-source/cts/tests/camera/utils/src/android/hardware/camera2/cts/CameraTestUtils.java"	""	"public void test/*
 *.
 */

package android.hardware.camera2.cts;

import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.ImageFormat;
import android.graphics.PointF;
import android.graphics.Rect;
import android.graphics.SurfaceTexture;
import android.hardware.camera2.CameraAccessException;
import android.hardware.camera2.CameraCaptureSession;
import android.hardware.camera2.CameraConstrainedHighSpeedCaptureSession;
import android.hardware.camera2.CameraDevice;
import android.hardware.camera2.CameraManager;
import android.hardware.camera2.CameraMetadata;
import android.hardware.camera2.CameraCharacteristics;
import android.hardware.camera2.CaptureFailure;
import android.hardware.camera2.CaptureRequest;
import android.hardware.camera2.CaptureResult;
import android.hardware.camera2.MultiResolutionImageReader;
import android.hardware.camera2.cts.helpers.CameraErrorCollector;
import android.hardware.camera2.cts.helpers.StaticMetadata;
import android.hardware.camera2.params.InputConfiguration;
import android.hardware.camera2.TotalCaptureResult;
import android.hardware.cts.helpers.CameraUtils;
import android.hardware.camera2.params.MeteringRectangle;
import android.hardware.camera2.params.MandatoryStreamCombination;
import android.hardware.camera2.params.MandatoryStreamCombination.MandatoryStreamInformation;
import android.hardware.camera2.params.MultiResolutionStreamConfigurationMap;
import android.hardware.camera2.params.MultiResolutionStreamInfo;
import android.hardware.camera2.params.OutputConfiguration;
import android.hardware.camera2.params.SessionConfiguration;
import android.hardware.camera2.params.StreamConfigurationMap;
import android.location.Location;
import android.location.LocationManager;
import android.media.ExifInterface;
import android.media.Image;
import android.media.ImageReader;
import android.media.ImageWriter;
import android.media.Image.Plane;
import android.os.Build;
import android.os.ConditionVariable;
import android.os.Handler;
import android.util.Log;
import android.util.Pair;
import android.util.Size;
import android.util.Range;
import android.view.Display;
import android.view.Surface;
import android.view.WindowManager;

import com.android.ex.camera2.blocking.BlockingCameraManager;
import com.android.ex.camera2.blocking.BlockingCameraManager.BlockingOpenException;
import com.android.ex.camera2.blocking.BlockingSessionCallback;
import com.android.ex.camera2.blocking.BlockingStateCallback;
import com.android.ex.camera2.exceptions.TimeoutRuntimeException;

import junit.framework.Assert;

import org.mockito.Mockito;

import java.io.FileOutputStream;
import java.io.IOException;
import java.lang.reflect.Array;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.Executor;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;
import java.text.ParseException;
import java.text.SimpleDateFormat;

/**
 * A package private utility class for wrapping up the camera2 cts test common utility functions
 */
public class CameraTestUtils extends Assert {
    private static final String TAG = ""CameraTestUtils"";
    private static final boolean VERBOSE = Log.isLoggable(TAG, Log.VERBOSE);
    private static final boolean DEBUG = Log.isLoggable(TAG, Log.DEBUG);
    public static final Size SIZE_BOUND_720P = new Size(1280, 720);
    public static final Size SIZE_BOUND_1080P = new Size(1920, 1088);
    public static final Size SIZE_BOUND_2K = new Size(2048, 1088);
    public static final Size SIZE_BOUND_QHD = new Size(2560, 1440);
    public static final Size SIZE_BOUND_2160P = new Size(3840, 2160);
    // Only test the preview size that is no larger than 1080p.
    public static final Size PREVIEW_SIZE_BOUND = SIZE_BOUND_1080P;
    // Default timeouts for reaching various states
    public static final int CAMERA_OPEN_TIMEOUT_MS = 3000;
    public static final int CAMERA_CLOSE_TIMEOUT_MS = 3000;
    public static final int CAMERA_IDLE_TIMEOUT_MS = 3000;
    public static final int CAMERA_ACTIVE_TIMEOUT_MS = 1000;
    public static final int CAMERA_BUSY_TIMEOUT_MS = 1000;
    public static final int CAMERA_UNCONFIGURED_TIMEOUT_MS = 1000;
    public static final int CAMERA_CONFIGURE_TIMEOUT_MS = 3000;
    public static final int CAPTURE_RESULT_TIMEOUT_MS = 3000;
    public static final int CAPTURE_IMAGE_TIMEOUT_MS = 3000;

    public static final int SESSION_CONFIGURE_TIMEOUT_MS = 3000;
    public static final int SESSION_CLOSE_TIMEOUT_MS = 3000;
    public static final int SESSION_READY_TIMEOUT_MS = 5000;
    public static final int SESSION_ACTIVE_TIMEOUT_MS = 1000;

    public static final int MAX_READER_IMAGES = 5;

    // Compensate for the loss of ""sensitivity"" and ""sensitivityBoost""
    public static final int MAX_ISO_MISMATCH = 3;

    public static final String OFFLINE_CAMERA_ID = ""offline_camera_id"";
    public static final String REPORT_LOG_NAME = ""CtsCameraTestCases"";

    private static final int EXIF_DATETIME_LENGTH = 19;
    private static final int EXIF_DATETIME_ERROR_MARGIN_SEC = 60;
    private static final float EXIF_FOCAL_LENGTH_ERROR_MARGIN = 0.001f;
    private static final float EXIF_EXPOSURE_TIME_ERROR_MARGIN_RATIO = 0.05f;
    private static final float EXIF_EXPOSURE_TIME_MIN_ERROR_MARGIN_SEC = 0.002f;
    private static final float EXIF_APERTURE_ERROR_MARGIN = 0.001f;

    private static final float ZOOM_RATIO_THRESHOLD = 0.01f;

    private static final Location sTestLocation0 = new Location(LocationManager.GPS_PROVIDER);
    private static final Location sTestLocation1 = new Location(LocationManager.GPS_PROVIDER);
    private static final Location sTestLocation2 = new Location(LocationManager.NETWORK_PROVIDER);

    static {
        sTestLocation0.setTime(1199145600000L);
        sTestLocation0.setLatitude(37.736071);
        sTestLocation0.setLongitude(-122.441983);
        sTestLocation0.setAltitude(21.0);

        sTestLocation1.setTime(1199145601000L);
        sTestLocation1.setLatitude(0.736071);
        sTestLocation1.setLongitude(0.441983);
        sTestLocation1.setAltitude(1.0);

        sTestLocation2.setTime(1199145602000L);
        sTestLocation2.setLatitude(-89.736071);
        sTestLocation2.setLongitude(-179.441983);
        sTestLocation2.setAltitude(100000.0);
    }

    // Exif test data vectors.
    public static final ExifTestData[] EXIF_TEST_DATA = {
            new ExifTestData(
                    /*gpsLocation*/ sTestLocation0,
                    /* orientation */90,
                    /* jpgQuality */(byte) 80,
                    /* thumbQuality */(byte) 75),
            new ExifTestData(
                    /*gpsLocation*/ sTestLocation1,
                    /* orientation */180,
                    /* jpgQuality */(byte) 90,
                    /* thumbQuality */(byte) 85),
            new ExifTestData(
                    /*gpsLocation*/ sTestLocation2,
                    /* orientation */270,
                    /* jpgQuality */(byte) 100,
                    /* thumbQuality */(byte) 100)
    };

    /**
     * Create an {@link android.media.ImageReader} object and get the surface.
     *
     * @param size The size of this ImageReader to be created.
     * @param format The format of this ImageReader to be created
     * @param maxNumImages The max number of images that can be acquired simultaneously.
     * @param listener The listener used by this ImageReader to notify callbacks.
     * @param handler The handler to use for any listener callbacks.
     */
    public static ImageReader makeImageReader(Size size, int format, int maxNumImages,
            ImageReader.OnImageAvailableListener listener, Handler handler) {
        ImageReader reader;
        reader = ImageReader.newInstance(size.getWidth(), size.getHeight(), format,
                maxNumImages);
        reader.setOnImageAvailableListener(listener, handler);
        if (VERBOSE) Log.v(TAG, ""Created ImageReader size "" + size);
        return reader;
    }

    /**
     * Create an ImageWriter and hook up the ImageListener.
     *
     * @param inputSurface The input surface of the ImageWriter.
     * @param maxImages The max number of Images that can be dequeued simultaneously.
     * @param listener The listener used by this ImageWriter to notify callbacks
     * @param handler The handler to post listener callbacks.
     * @return ImageWriter object created.
     */
    public static ImageWriter makeImageWriter(
            Surface inputSurface, int maxImages,
            ImageWriter.OnImageReleasedListener listener, Handler handler) {
        ImageWriter writer = ImageWriter.newInstance(inputSurface, maxImages);
        writer.setOnImageReleasedListener(listener, handler);
        return writer;
    }

    /**
     * Utility class to store the targets for mandatory stream combination test.
     */
    public static class StreamCombinationTargets {
        public List<SurfaceTexture> mPrivTargets = new ArrayList<>();
        public List<ImageReader> mJpegTargets = new ArrayList<>();
        public List<ImageReader> mYuvTargets = new ArrayList<>();
        public List<ImageReader> mY8Targets = new ArrayList<>();
        public List<ImageReader> mRawTargets = new ArrayList<>();
        public List<ImageReader> mHeicTargets = new ArrayList<>();
        public List<ImageReader> mDepth16Targets = new ArrayList<>();

        public List<MultiResolutionImageReader> mPrivMultiResTargets = new ArrayList<>();
        public List<MultiResolutionImageReader> mJpegMultiResTargets = new ArrayList<>();
        public List<MultiResolutionImageReader> mYuvMultiResTargets = new ArrayList<>();
        public List<MultiResolutionImageReader> mRawMultiResTargets = new ArrayList<>();

        public void close() {
            for (SurfaceTexture target : mPrivTargets) {
                target.release();
            }
            for (ImageReader target : mJpegTargets) {
                target.close();
            }
            for (ImageReader target : mYuvTargets) {
                target.close();
            }
            for (ImageReader target : mY8Targets) {
                target.close();
            }
            for (ImageReader target : mRawTargets) {
                target.close();
            }
            for (ImageReader target : mHeicTargets) {
                target.close();
            }
            for (ImageReader target : mDepth16Targets) {
                target.close();
            }

            for (MultiResolutionImageReader target : mPrivMultiResTargets) {
                target.close();
            }
            for (MultiResolutionImageReader target : mJpegMultiResTargets) {
                target.close();
            }
            for (MultiResolutionImageReader target : mYuvMultiResTargets) {
                target.close();
            }
            for (MultiResolutionImageReader target : mRawMultiResTargets) {
                target.close();
            }
        }
    }

    private static void configureTarget(StreamCombinationTargets targets,
            List<OutputConfiguration> outputConfigs, List<Surface> outputSurfaces,
            int format, Size targetSize, int numBuffers, String overridePhysicalCameraId,
            MultiResolutionStreamConfigurationMap multiResStreamConfig,
            boolean createMultiResiStreamConfig, ImageDropperListener listener, Handler handler) {
        if (createMultiResiStreamConfig) {
            Collection<MultiResolutionStreamInfo> multiResolutionStreams =
                    multiResStreamConfig.getOutputInfo(format);
            MultiResolutionImageReader multiResReader = new MultiResolutionImageReader(
                    multiResolutionStreams, format, numBuffers);
            multiResReader.setOnImageAvailableListener(listener, new HandlerExecutor(handler));
            Collection<OutputConfiguration> configs =
                    OutputConfiguration.createInstancesForMultiResolutionOutput(multiResReader);
            outputConfigs.addAll(configs);
            outputSurfaces.add(multiResReader.getSurface());
            switch (format) {
                case ImageFormat.PRIVATE:
                    targets.mPrivMultiResTargets.add(multiResReader);
                    break;
                case ImageFormat.JPEG:
                    targets.mJpegMultiResTargets.add(multiResReader);
                    break;
                case ImageFormat.YUV_420_888:
                    targets.mYuvMultiResTargets.add(multiResReader);
                    break;
                case ImageFormat.RAW_SENSOR:
                    targets.mRawMultiResTargets.add(multiResReader);
                    break;
                default:
                    fail(""Unknown/Unsupported output format "" + format);
            }
        } else {
            if (format == ImageFormat.PRIVATE) {
                SurfaceTexture target = new SurfaceTexture(/*random int*/1);
                target.setDefaultBufferSize(targetSize.getWidth(), targetSize.getHeight());
                OutputConfiguration config = new OutputConfiguration(new Surface(target));
                if (overridePhysicalCameraId != null) {
                    config.setPhysicalCameraId(overridePhysicalCameraId);
                }
                outputConfigs.add(config);
                outputSurfaces.add(config.getSurface());
                targets.mPrivTargets.add(target);
            } else {
                ImageReader target = ImageReader.newInstance(targetSize.getWidth(),
                        targetSize.getHeight(), format, numBuffers);
                target.setOnImageAvailableListener(listener, handler);
                OutputConfiguration config = new OutputConfiguration(target.getSurface());
                if (overridePhysicalCameraId != null) {
                    config.setPhysicalCameraId(overridePhysicalCameraId);
                }
                outputConfigs.add(config);
                outputSurfaces.add(config.getSurface());

                switch (format) {
                    case ImageFormat.JPEG:
                      targets.mJpegTargets.add(target);
                      break;
                    case ImageFormat.YUV_420_888:
                      targets.mYuvTargets.add(target);
                      break;
                    case ImageFormat.Y8:
                      targets.mY8Targets.add(target);
                      break;
                    case ImageFormat.RAW_SENSOR:
                      targets.mRawTargets.add(target);
                      break;
                    case ImageFormat.HEIC:
                      targets.mHeicTargets.add(target);
                      break;
                    case ImageFormat.DEPTH16:
                      targets.mDepth16Targets.add(target);
                      break;
                    default:
                      fail(""Unknown/Unsupported output format "" + format);
                }
            }
        }
    }

    public static void setupConfigurationTargets(List<MandatoryStreamInformation> streamsInfo,
            StreamCombinationTargets targets,
            List<OutputConfiguration> outputConfigs,
            List<Surface> outputSurfaces, int numBuffers,
            boolean substituteY8, boolean substituteHeic, String overridenPhysicalCameraId,
            MultiResolutionStreamConfigurationMap multiResStreamConfig, Handler handler) {
            List<Surface> uhSurfaces = new ArrayList<Surface>();
        setupConfigurationTargets(streamsInfo, targets, outputConfigs, outputSurfaces, uhSurfaces,
            numBuffers, substituteY8, substituteHeic, overridenPhysicalCameraId,
            multiResStreamConfig, handler);
    }

    public static void setupConfigurationTargets(List<MandatoryStreamInformation> streamsInfo,
            StreamCombinationTargets targets,
            List<OutputConfiguration> outputConfigs,
            List<Surface> outputSurfaces, List<Surface> uhSurfaces, int numBuffers,
            boolean substituteY8, boolean substituteHeic, String overridePhysicalCameraId,
            MultiResolutionStreamConfigurationMap multiResStreamConfig, Handler handler) {

        ImageDropperListener imageDropperListener = new ImageDropperListener();
        List<Surface> chosenSurfaces;
        for (MandatoryStreamInformation streamInfo : streamsInfo) {
            if (streamInfo.isInput()) {
                continue;
            }
            chosenSurfaces = outputSurfaces;
            if (streamInfo.isUltraHighResolution()) {
                chosenSurfaces = uhSurfaces;
            }
            int format = streamInfo.getFormat();
            if (substituteY8 && (format == ImageFormat.YUV_420_888)) {
                format = ImageFormat.Y8;
            } else if (substituteHeic && (format == ImageFormat.JPEG)) {
                format = ImageFormat.HEIC;
            }
            Size[] availableSizes = new Size[streamInfo.getAvailableSizes().size()];
            availableSizes = streamInfo.getAvailableSizes().toArray(availableSizes);
            Size targetSize = CameraTestUtils.getMaxSize(availableSizes);
            boolean createMultiResReader =
                    (multiResStreamConfig != null &&
                     !multiResStreamConfig.getOutputInfo(format).isEmpty() &&
                     streamInfo.isMaximumSize());
            switch (format) {
                case ImageFormat.PRIVATE:
                case ImageFormat.JPEG:
                case ImageFormat.YUV_420_888:
                case ImageFormat.Y8:
                case ImageFormat.HEIC:
                case ImageFormat.DEPTH16:
                {
                    configureTarget(targets, outputConfigs, chosenSurfaces, format,
                            targetSize, numBuffers, overridePhysicalCameraId, multiResStreamConfig,
                            createMultiResReader, imageDropperListener, handler);
                    break;
                }
                case ImageFormat.RAW_SENSOR: {
                    // targetSize could be null in the logical camera case where only
                    // physical camera supports RAW stream.
                    if (targetSize != null) {
                        configureTarget(targets, outputConfigs, chosenSurfaces, format,
                                targetSize, numBuffers, overridePhysicalCameraId,
                                multiResStreamConfig, createMultiResReader, imageDropperListener,
                                handler);
                    }
                    break;
                }
                default:
                    fail(""Unknown output format "" + format);
            }
        }
    }

    /**
     * Close pending images and clean up an {@link android.media.ImageReader} object.
     * @param reader an {@link android.media.ImageReader} to close.
     */
    public static void closeImageReader(ImageReader reader) {
        if (reader != null) {
            reader.close();
        }
    }

    /**
     * Close the pending images then close current active {@link ImageReader} objects.
     */
    public static void closeImageReaders(ImageReader[] readers) {
        if ((readers != null) && (readers.length > 0)) {
            for (ImageReader reader : readers) {
                CameraTestUtils.closeImageReader(reader);
            }
        }
    }

    /**
     * Close pending images and clean up an {@link android.media.ImageWriter} object.
     * @param writer an {@link android.media.ImageWriter} to close.
     */
    public static void closeImageWriter(ImageWriter writer) {
        if (writer != null) {
            writer.close();
        }
    }

    /**
     * Dummy listener that release the image immediately once it is available.
     *
     * <p>
     * It can be used for the case where we don't care the image data at all.
     * </p>
     */
    public static class ImageDropperListener implements ImageReader.OnImageAvailableListener {
        @Override
        public synchronized void onImageAvailable(ImageReader reader) {
            Image image = null;
            try {
                image = reader.acquireNextImage();
            } finally {
                if (image != null) {
                    image.close();
                    mImagesDropped++;
                }
            }
        }

        public synchronized int getImageCount() {
            return mImagesDropped;
        }

        public synchronized void resetImageCount() {
            mImagesDropped = 0;
        }

        private int mImagesDropped = 0;
    }

    /**
     * Image listener that release the image immediately after validating the image
     */
    public static class ImageVerifierListener implements ImageReader.OnImageAvailableListener {
        private Size mSize;
        private int mFormat;
        // Whether the parent ImageReader is valid or not. If the parent ImageReader
        // is destroyed, the acquired Image may become invalid.
        private boolean mReaderIsValid;

        public ImageVerifierListener(Size sz, int format) {
            mSize = sz;
            mFormat = format;
            mReaderIsValid = true;
        }

        public synchronized void onReaderDestroyed() {
            mReaderIsValid = false;
        }

        @Override
        public synchronized void onImageAvailable(ImageReader reader) {
            Image image = null;
            try {
                image = reader.acquireNextImage();
            } finally {
                if (image != null) {
                    // Should only do some quick validity checks in callback, as the ImageReader
                    // could be closed asynchronously, which will close all images acquired from
                    // this ImageReader.
                    checkImage(image, mSize.getWidth(), mSize.getHeight(), mFormat);
                    // checkAndroidImageFormat calls into underlying Image object, which could
                    // become invalid if the ImageReader is destroyed.
                    if (mReaderIsValid) {
                        checkAndroidImageFormat(image);
                    }
                    image.close();
                }
            }
        }
    }

    public static class SimpleImageReaderListener
            implements ImageReader.OnImageAvailableListener {
        private final LinkedBlockingQueue<Image> mQueue =
                new LinkedBlockingQueue<Image>();
        // Indicate whether this listener will drop images or not,
        // when the queued images reaches the reader maxImages
        private final boolean mAsyncMode;
        // maxImages held by the queue in async mode.
        private final int mMaxImages;

        /**
         * Create a synchronous SimpleImageReaderListener that queues the images
         * automatically when they are available, no image will be dropped. If
         * the caller doesn't call getImage(), the producer will eventually run
         * into buffer starvation.
         */
        public SimpleImageReaderListener() {
            mAsyncMode = false;
            mMaxImages = 0;
        }

        /**
         * Create a synchronous/asynchronous SimpleImageReaderListener that
         * queues the images automatically when they are available. For
         * asynchronous listener, image will be dropped if the queued images
         * reach to maxImages queued. If the caller doesn't call getImage(), the
         * producer will not be blocked. For synchronous listener, no image will
         * be dropped. If the caller doesn't call getImage(), the producer will
         * eventually run into buffer starvation.
         *
         * @param asyncMode If the listener is operating at asynchronous mode.
         * @param maxImages The max number of images held by this listener.
         */
        /**
         *
         * @param asyncMode
         */
        public SimpleImageReaderListener(boolean asyncMode, int maxImages) {
            mAsyncMode = asyncMode;
            mMaxImages = maxImages;
        }

        @Override
        public void onImageAvailable(ImageReader reader) {
            try {
                Image imge = reader.acquireNextImage();
                if (imge == null) {
                    return;
                }
                mQueue.put(imge);
                if (mAsyncMode && mQueue.size() >= mMaxImages) {
                    Image img = mQueue.poll();
                    img.close();
                }
            } catch (InterruptedException e) {
                throw new UnsupportedOperationException(
                        ""Can't handle InterruptedException in onImageAvailable"");
            }
        }

        /**
         * Get an image from the image reader.
         *
         * @param timeout Timeout value for the wait.
         * @return The image from the image reader.
         */
        public Image getImage(long timeout) throws InterruptedException {
            Image image = mQueue.poll(timeout, TimeUnit.MILLISECONDS);
            assertNotNull(""Wait for an image timed out in "" + timeout + ""ms"", image);
            return image;
        }

        /**
         * Drain the pending images held by this listener currently.
         *
         */
        public void drain() {
            while (!mQueue.isEmpty()) {
                Image image = mQueue.poll();
                assertNotNull(""Unable to get an image"", image);
                image.close();
            }
        }
    }

    public static class SimpleImageWriterListener implements ImageWriter.OnImageReleasedListener {
        private final Semaphore mImageReleasedSema = new Semaphore(0);
        private final ImageWriter mWriter;
        @Override
        public void onImageReleased(ImageWriter writer) {
            if (writer != mWriter) {
                return;
            }

            if (VERBOSE) {
                Log.v(TAG, ""Input image is released"");
            }
            mImageReleasedSema.release();
        }

        public SimpleImageWriterListener(ImageWriter writer) {
            if (writer == null) {
                throw new IllegalArgumentException(""writer cannot be null"");
            }
            mWriter = writer;
        }

        public void waitForImageReleased(long timeoutMs) throws InterruptedException {
            if (!mImageReleasedSema.tryAcquire(timeoutMs, TimeUnit.MILLISECONDS)) {
                fail(""wait for image available timed out after "" + timeoutMs + ""ms"");
            }
        }
    }

    public static class ImageAndMultiResStreamInfo {
        public final Image image;
        public final MultiResolutionStreamInfo streamInfo;

        public ImageAndMultiResStreamInfo(Image image, MultiResolutionStreamInfo streamInfo) {
            this.image = image;
            this.streamInfo = streamInfo;
        }
    }

    public static class SimpleMultiResolutionImageReaderListener
            implements ImageReader.OnImageAvailableListener {
        public SimpleMultiResolutionImageReaderListener(MultiResolutionImageReader owner,
                int maxBuffers, boolean acquireLatest) {
            mOwner = owner;
            mMaxBuffers = maxBuffers;
            mAcquireLatest = acquireLatest;
        }

        @Override
        public void onImageAvailable(ImageReader reader) {
            if (VERBOSE) Log.v(TAG, ""new image available"");

            if (mAcquireLatest) {
                mLastReader = reader;
                mImageAvailable.open();
            } else {
                if (mQueue.size() < mMaxBuffers) {
                    Image image = reader.acquireNextImage();
                    MultiResolutionStreamInfo multiResStreamInfo =
                            mOwner.getStreamInfoForImageReader(reader);
                    mQueue.offer(new ImageAndMultiResStreamInfo(image, multiResStreamInfo));
                }
            }
        }

        public ImageAndMultiResStreamInfo getAnyImageAndInfoAvailable(long timeoutMs)
                throws Exception {
            if (mAcquireLatest) {
                Image image = null;
                if (mImageAvailable.block(timeoutMs)) {
                    if (mLastReader != null) {
                        image = mLastReader.acquireLatestImage();
                        if (VERBOSE) Log.v(TAG, ""acquireLatestImage"");
                    } else {
                        fail(""invalid image reader"");
                    }
                    mImageAvailable.close();
                } else {
                    fail(""wait for image available time out after "" + timeoutMs + ""ms"");
                }
                return new ImageAndMultiResStreamInfo(image,
                        mOwner.getStreamInfoForImageReader(mLastReader));
            } else {
                ImageAndMultiResStreamInfo imageAndInfo = mQueue.poll(timeoutMs,
                        java.util.concurrent.TimeUnit.MILLISECONDS);
                if (imageAndInfo == null) {
                    fail(""wait for image available timed out after "" + timeoutMs + ""ms"");
                }
                return imageAndInfo;
            }
        }

        public void reset() {
            while (!mQueue.isEmpty()) {
                ImageAndMultiResStreamInfo imageAndInfo = mQueue.poll();
                assertNotNull(""Acquired image is not valid"", imageAndInfo.image);
                imageAndInfo.image.close();
            }
            mImageAvailable.close();
            mLastReader = null;
        }

        private LinkedBlockingQueue<ImageAndMultiResStreamInfo> mQueue =
                new LinkedBlockingQueue<ImageAndMultiResStreamInfo>();
        private final MultiResolutionImageReader mOwner;
        private final int mMaxBuffers;
        private final boolean mAcquireLatest;
        private ConditionVariable mImageAvailable = new ConditionVariable();
        private ImageReader mLastReader = null;
    }

    public static class SimpleCaptureCallback extends CameraCaptureSession.CaptureCallback {
        private final LinkedBlockingQueue<TotalCaptureResult> mQueue =
                new LinkedBlockingQueue<TotalCaptureResult>();
        private final LinkedBlockingQueue<CaptureFailure> mFailureQueue =
                new LinkedBlockingQueue<>();
        // (Surface, framenumber) pair for lost buffers
        private final LinkedBlockingQueue<Pair<Surface, Long>> mBufferLostQueue =
                new LinkedBlockingQueue<>();
        private final LinkedBlockingQueue<Integer> mAbortQueue =
                new LinkedBlockingQueue<>();
        // Pair<CaptureRequest, Long> is a pair of capture request and timestamp.
        private final LinkedBlockingQueue<Pair<CaptureRequest, Long>> mCaptureStartQueue =
                new LinkedBlockingQueue<>();
        // Pair<Int, Long> is a pair of sequence id and frame number
        private final LinkedBlockingQueue<Pair<Integer, Long>> mCaptureSequenceCompletedQueue =
                new LinkedBlockingQueue<>();

        private AtomicLong mNumFramesArrived = new AtomicLong(0);

        @Override
        public void onCaptureStarted(CameraCaptureSession session, CaptureRequest request,
                long timestamp, long frameNumber) {
            try {
                mCaptureStartQueue.put(new Pair(request, timestamp));
            } catch (InterruptedException e) {
                throw new UnsupportedOperationException(
                        ""Can't handle InterruptedException in onCaptureStarted"");
            }
        }

        @Override
        public void onCaptureCompleted(CameraCaptureSession session, CaptureRequest request,
                TotalCaptureResult result) {
            try {
                mNumFramesArrived.incrementAndGet();
                mQueue.put(result);
            } catch (InterruptedException e) {
                throw new UnsupportedOperationException(
                        ""Can't handle InterruptedException in onCaptureCompleted"");
            }
        }

        @Override
        public void onCaptureFailed(CameraCaptureSession session, CaptureRequest request,
                CaptureFailure failure) {
            try {
                mFailureQueue.put(failure);
            } catch (InterruptedException e) {
                throw new UnsupportedOperationException(
                        ""Can't handle InterruptedException in onCaptureFailed"");
            }
        }

        @Override
        public void onCaptureSequenceAborted(CameraCaptureSession session, int sequenceId) {
            try {
                mAbortQueue.put(sequenceId);
            } catch (InterruptedException e) {
                throw new UnsupportedOperationException(
                        ""Can't handle InterruptedException in onCaptureAborted"");
            }
        }

        @Override
        public void onCaptureSequenceCompleted(CameraCaptureSession session, int sequenceId,
                long frameNumber) {
            try {
                mCaptureSequenceCompletedQueue.put(new Pair(sequenceId, frameNumber));
            } catch (InterruptedException e) {
                throw new UnsupportedOperationException(
                        ""Can't handle InterruptedException in onCaptureSequenceCompleted"");
            }
        }

        @Override
        public void onCaptureBufferLost(CameraCaptureSession session,
                CaptureRequest request, Surface target, long frameNumber) {
            try {
                mBufferLostQueue.put(new Pair<>(target, frameNumber));
            } catch (InterruptedException e) {
                throw new UnsupportedOperationException(
                        ""Can't handle InterruptedException in onCaptureBufferLost"");
            }
        }

        public long getTotalNumFrames() {
            return mNumFramesArrived.get();
        }

        public CaptureResult getCaptureResult(long timeout) {
            return getTotalCaptureResult(timeout);
        }

        public TotalCaptureResult getCaptureResult(long timeout, long timestamp) {
            try {
                long currentTs = -1L;
                TotalCaptureResult result;
                while (true) {
                    result = mQueue.poll(timeout, TimeUnit.MILLISECONDS);
                    if (result == null) {
                        throw new RuntimeException(
                                ""Wait for a capture result timed out in "" + timeout + ""ms"");
                    }
                    currentTs = result.get(CaptureResult.SENSOR_TIMESTAMP);
                    if (currentTs == timestamp) {
                        return result;
                    }
                }

            } catch (InterruptedException e) {
                throw new UnsupportedOperationException(""Unhandled interrupted exception"", e);
            }
        }

        public TotalCaptureResult getTotalCaptureResult(long timeout) {
            try {
                TotalCaptureResult result = mQueue.poll(timeout, TimeUnit.MILLISECONDS);
                assertNotNull(""Wait for a capture result timed out in "" + timeout + ""ms"", result);
                return result;
            } catch (InterruptedException e) {
                throw new UnsupportedOperationException(""Unhandled interrupted exception"", e);
            }
        }

        /**
         * Get the {@link #CaptureResult capture result} for a given
         * {@link #CaptureRequest capture request}.
         *
         * @param myRequest The {@link #CaptureRequest capture request} whose
         *            corresponding {@link #CaptureResult capture result} was
         *            being waited for
         * @param numResultsWait Number of frames to wait for the capture result
         *            before timeout.
         * @throws TimeoutRuntimeException If more than numResultsWait results are
         *            seen before the result matching myRequest arrives, or each
         *            individual wait for result times out after
         *            {@value #CAPTURE_RESULT_TIMEOUT_MS}ms.
         */
        public CaptureResult getCaptureResultForRequest(CaptureRequest myRequest,
                int numResultsWait) {
            return getTotalCaptureResultForRequest(myRequest, numResultsWait);
        }

        /**
         * Get the {@link #TotalCaptureResult total capture result} for a given
         * {@link #CaptureRequest capture request}.
         *
         * @param myRequest The {@link #CaptureRequest capture request} whose
         *            corresponding {@link #TotalCaptureResult capture result} was
         *            being waited for
         * @param numResultsWait Number of frames to wait for the capture result
         *            before timeout.
         * @throws TimeoutRuntimeException If more than numResultsWait results are
         *            seen before the result matching myRequest arrives, or each
         *            individual wait for result times out after
         *            {@value #CAPTURE_RESULT_TIMEOUT_MS}ms.
         */
        public TotalCaptureResult getTotalCaptureResultForRequest(CaptureRequest myRequest,
                int numResultsWait) {
            ArrayList<CaptureRequest> captureRequests = new ArrayList<>(1);
            captureRequests.add(myRequest);
            return getTotalCaptureResultsForRequests(captureRequests, numResultsWait)[0];
        }

        /**
         * Get an array of {@link #TotalCaptureResult total capture results} for a given list of
         * {@link #CaptureRequest capture requests}. This can be used when the order of results
         * may not the same as the order of requests.
         *
         * @param captureRequests The list of {@link #CaptureRequest capture requests} whose
         *            corresponding {@link #TotalCaptureResult capture results} are
         *            being waited for.
         * @param numResultsWait Number of frames to wait for the capture results
         *            before timeout.
         * @throws TimeoutRuntimeException If more than numResultsWait results are
         *            seen before all the results matching captureRequests arrives.
         */
        public TotalCaptureResult[] getTotalCaptureResultsForRequests(
                List<CaptureRequest> captureRequests, int numResultsWait) {
            if (numResultsWait < 0) {
                throw new IllegalArgumentException(""numResultsWait must be no less than 0"");
            }
            if (captureRequests == null || captureRequests.size() == 0) {
                throw new IllegalArgumentException(""captureRequests must have at least 1 request."");
            }

            // Create a request -> a list of result indices map that it will wait for.
            HashMap<CaptureRequest, ArrayList<Integer>> remainingResultIndicesMap = new HashMap<>();
            for (int i = 0; i < captureRequests.size(); i++) {
                CaptureRequest request = captureRequests.get(i);
                ArrayList<Integer> indices = remainingResultIndicesMap.get(request);
                if (indices == null) {
                    indices = new ArrayList<>();
                    remainingResultIndicesMap.put(request, indices);
                }
                indices.add(i);
            }

            TotalCaptureResult[] results = new TotalCaptureResult[captureRequests.size()];
            int i = 0;
            do {
                TotalCaptureResult result = getTotalCaptureResult(CAPTURE_RESULT_TIMEOUT_MS);
                CaptureRequest request = result.getRequest();
                ArrayList<Integer> indices = remainingResultIndicesMap.get(request);
                if (indices != null) {
                    results[indices.get(0)] = result;
                    indices.remove(0);

                    // Remove the entry if all results for this request has been fulfilled.
                    if (indices.isEmpty()) {
                        remainingResultIndicesMap.remove(request);
                    }
                }

                if (remainingResultIndicesMap.isEmpty()) {
                    return results;
                }
            } while (i++ < numResultsWait);

            throw new TimeoutRuntimeException(""Unable to get the expected capture result after ""
                    + ""waiting for "" + numResultsWait + "" results"");
        }

        /**
         * Get an array list of {@link #CaptureFailure capture failure} with maxNumFailures entries
         * at most. If it times out before maxNumFailures failures are received, return the failures
         * received so far.
         *
         * @param maxNumFailures The maximal number of failures to return. If it times out before
         *                       the maximal number of failures are received, return the received
         *                       failures so far.
         * @throws UnsupportedOperationException If an error happens while waiting on the failure.
         */
        public ArrayList<CaptureFailure> getCaptureFailures(long maxNumFailures) {
            ArrayList<CaptureFailure> failures = new ArrayList<>();
            try {
                for (int i = 0; i < maxNumFailures; i++) {
                    CaptureFailure failure = mFailureQueue.poll(CAPTURE_RESULT_TIMEOUT_MS,
                            TimeUnit.MILLISECONDS);
                    if (failure == null) {
                        // If waiting on a failure times out, return the failures so far.
                        break;
                    }
                    failures.add(failure);
                }
            }  catch (InterruptedException e) {
                throw new UnsupportedOperationException(""Unhandled interrupted exception"", e);
            }

            return failures;
        }

        /**
         * Get an array list of lost buffers with maxNumLost entries at most.
         * If it times out before maxNumLost buffer lost callbacks are received, return the
         * lost callbacks received so far.
         *
         * @param maxNumLost The maximal number of buffer lost failures to return. If it times out
         *                   before the maximal number of failures are received, return the received
         *                   buffer lost failures so far.
         * @throws UnsupportedOperationException If an error happens while waiting on the failure.
         */
        public ArrayList<Pair<Surface, Long>> getLostBuffers(long maxNumLost) {
            ArrayList<Pair<Surface, Long>> failures = new ArrayList<>();
            try {
                for (int i = 0; i < maxNumLost; i++) {
                    Pair<Surface, Long> failure = mBufferLostQueue.poll(CAPTURE_RESULT_TIMEOUT_MS,
                            TimeUnit.MILLISECONDS);
                    if (failure == null) {
                        // If waiting on a failure times out, return the failures so far.
                        break;
                    }
                    failures.add(failure);
                }
            }  catch (InterruptedException e) {
                throw new UnsupportedOperationException(""Unhandled interrupted exception"", e);
            }

            return failures;
        }

        /**
         * Get an array list of aborted capture sequence ids with maxNumAborts entries
         * at most. If it times out before maxNumAborts are received, return the aborted sequences
         * received so far.
         *
         * @param maxNumAborts The maximal number of aborted sequences to return. If it times out
         *                     before the maximal number of aborts are received, return the received
         *                     failed sequences so far.
         * @throws UnsupportedOperationException If an error happens while waiting on the failed
         *                                       sequences.
         */
        public ArrayList<Integer> geAbortedSequences(long maxNumAborts) {
            ArrayList<Integer> abortList = new ArrayList<>();
            try {
                for (int i = 0; i < maxNumAborts; i++) {
                    Integer abortSequence = mAbortQueue.poll(CAPTURE_RESULT_TIMEOUT_MS,
                            TimeUnit.MILLISECONDS);
                    if (abortSequence == null) {
                        break;
                    }
                    abortList.add(abortSequence);
                }
            }  catch (InterruptedException e) {
                throw new UnsupportedOperationException(""Unhandled interrupted exception"", e);
            }

            return abortList;
        }

        /**
         * Wait until the capture start of a request and expected timestamp arrives or it times
         * out after a number of capture starts.
         *
         * @param request The request for the capture start to wait for.
         * @param timestamp The timestamp for the capture start to wait for.
         * @param numCaptureStartsWait The number of capture start events to wait for before timing
         *                             out.
         */
        public void waitForCaptureStart(CaptureRequest request, Long timestamp,
                int numCaptureStartsWait) throws Exception {
            Pair<CaptureRequest, Long> expectedShutter = new Pair<>(request, timestamp);

            int i = 0;
            do {
                Pair<CaptureRequest, Long> shutter = mCaptureStartQueue.poll(
                        CAPTURE_RESULT_TIMEOUT_MS, TimeUnit.MILLISECONDS);

                if (shutter == null) {
                    throw new TimeoutRuntimeException(""Unable to get any more capture start "" +
                            ""event after waiting for "" + CAPTURE_RESULT_TIMEOUT_MS + "" ms."");
                } else if (expectedShutter.equals(shutter)) {
                    return;
                }

            } while (i++ < numCaptureStartsWait);

            throw new TimeoutRuntimeException(""Unable to get the expected capture start "" +
                    ""event after waiting for "" + numCaptureStartsWait + "" capture starts"");
        }

        /**
         * Wait until it receives capture sequence completed callback for a given squence ID.
         *
         * @param sequenceId The sequence ID of the capture sequence completed callback to wait for.
         * @param timeoutMs Time to wait for each capture sequence complete callback before
         *                  timing out.
         */
        public long getCaptureSequenceLastFrameNumber(int sequenceId, long timeoutMs) {
            try {
                while (true) {
                    Pair<Integer, Long> completedSequence =
                            mCaptureSequenceCompletedQueue.poll(timeoutMs, TimeUnit.MILLISECONDS);
                    assertNotNull(""Wait for a capture sequence completed timed out in "" +
                            timeoutMs + ""ms"", completedSequence);

                    if (completedSequence.first.equals(sequenceId)) {
                        return completedSequence.second.longValue();
                    }
                }
            } catch (InterruptedException e) {
                throw new UnsupportedOperationException(""Unhandled interrupted exception"", e);
            }
        }

        public boolean hasMoreResults()
        {
            return !mQueue.isEmpty();
        }

        public boolean hasMoreFailures()
        {
            return !mFailureQueue.isEmpty();
        }

        public int getNumLostBuffers()
        {
            return mBufferLostQueue.size();
        }

        public boolean hasMoreAbortedSequences()
        {
            return !mAbortQueue.isEmpty();
        }

        public void drain() {
            mQueue.clear();
            mNumFramesArrived.getAndSet(0);
            mFailureQueue.clear();
            mBufferLostQueue.clear();
            mCaptureStartQueue.clear();
            mAbortQueue.clear();
        }
    }

    public static boolean hasCapability(CameraCharacteristics characteristics, int capability) {
        int [] capabilities =
                characteristics.get(CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES);
        for (int c : capabilities) {
            if (c == capability) {
                return true;
            }
        }
        return false;
    }

    public static boolean isSystemCamera(CameraManager manager, String cameraId)
            throws CameraAccessException {
        CameraCharacteristics characteristics = manager.getCameraCharacteristics(cameraId);
        return hasCapability(characteristics,
                CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_SYSTEM_CAMERA);
    }

    public static String[] getCameraIdListForTesting(CameraManager manager,
            boolean getSystemCameras)
            throws CameraAccessException {
        String [] ids = manager.getCameraIdListNoLazy();
        List<String> idsForTesting = new ArrayList<String>();
        for (String id : ids) {
            boolean isSystemCamera = isSystemCamera(manager, id);
            if (getSystemCameras == isSystemCamera) {
                idsForTesting.add(id);
            }
        }
        return idsForTesting.toArray(new String[idsForTesting.size()]);
    }

    public static Set<Set<String>> getConcurrentCameraIds(CameraManager manager,
            boolean getSystemCameras)
            throws CameraAccessException {
        Set<String> cameraIds = new HashSet<String>(Arrays.asList(getCameraIdListForTesting(manager, getSystemCameras)));
        Set<Set<String>> combinations =  manager.getConcurrentCameraIds();
        Set<Set<String>> correctComb = new HashSet<Set<String>>();
        for (Set<String> comb : combinations) {
            Set<String> filteredIds = new HashSet<String>();
            for (String id : comb) {
                if (cameraIds.contains(id)) {
                    filteredIds.add(id);
                }
            }
            if (filteredIds.isEmpty()) {
                continue;
            }
            correctComb.add(filteredIds);
        }
        return correctComb;
    }

    /**
     * Block until the camera is opened.
     *
     * <p>Don't use this to test #onDisconnected/#onError since this will throw
     * an AssertionError if it fails to open the camera device.</p>
     *
     * @return CameraDevice opened camera device
     *
     * @throws IllegalArgumentException
     *            If the handler is null, or if the handler's looper is current.
     * @throws CameraAccessException
     *            If open fails immediately.
     * @throws BlockingOpenException
     *            If open fails after blocking for some amount of time.
     * @throws TimeoutRuntimeException
     *            If opening times out. Typically unrecoverable.
     */
    public static CameraDevice openCamera(CameraManager manager, String cameraId,
            CameraDevice.StateCallback listener, Handler handler) throws CameraAccessException,
            BlockingOpenException {

        /**
         * Although camera2 API allows 'null' Handler (it will just use the current
         * thread's Looper), this is not what we want for CTS.
         *
         * In CTS the default looper is used only to process events in between test runs,
         * so anything sent there would not be executed inside a test and the test would fail.
         *
         * In this case, BlockingCameraManager#openCamera performs the check for us.
         */
        return (new BlockingCameraManager(manager)).openCamera(cameraId, listener, handler);
    }


    /**
     * Block until the camera is opened.
     *
     * <p>Don't use this to test #onDisconnected/#onError since this will throw
     * an AssertionError if it fails to open the camera device.</p>
     *
     * @throws IllegalArgumentException
     *            If the handler is null, or if the handler's looper is current.
     * @throws CameraAccessException
     *            If open fails immediately.
     * @throws BlockingOpenException
     *            If open fails after blocking for some amount of time.
     * @throws TimeoutRuntimeException
     *            If opening times out. Typically unrecoverable.
     */
    public static CameraDevice openCamera(CameraManager manager, String cameraId, Handler handler)
            throws CameraAccessException,
            BlockingOpenException {
        return openCamera(manager, cameraId, /*listener*/null, handler);
    }

    /**
     * Configure a new camera session with output surfaces and type.
     *
     * @param camera The CameraDevice to be configured.
     * @param outputSurfaces The surface list that used for camera output.
     * @param listener The callback CameraDevice will notify when capture results are available.
     */
    public static CameraCaptureSession configureCameraSession(CameraDevice camera,
            List<Surface> outputSurfaces, boolean isHighSpeed,
            CameraCaptureSession.StateCallback listener, Handler handler)
            throws CameraAccessException {
        BlockingSessionCallback sessionListener = new BlockingSessionCallback(listener);
        if (isHighSpeed) {
            camera.createConstrainedHighSpeedCaptureSession(outputSurfaces,
                    sessionListener, handler);
        } else {
            camera.createCaptureSession(outputSurfaces, sessionListener, handler);
        }
        CameraCaptureSession session =
                sessionListener.waitAndGetSession(SESSION_CONFIGURE_TIMEOUT_MS);
        assertFalse(""Camera session should not be a reprocessable session"",
                session.isReprocessable());
        String sessionType = isHighSpeed ? ""High Speed"" : ""Normal"";
        assertTrue(""Capture session type must be "" + sessionType,
                isHighSpeed ==
                CameraConstrainedHighSpeedCaptureSession.class.isAssignableFrom(session.getClass()));

        return session;
    }

    /**
     * Build a new constrained camera session with output surfaces, type and recording session
     * parameters.
     *
     * @param camera The CameraDevice to be configured.
     * @param outputSurfaces The surface list that used for camera output.
     * @param listener The callback CameraDevice will notify when capture results are available.
     * @param initialRequest Initial request settings to use as session parameters.
     */
    public static CameraCaptureSession buildConstrainedCameraSession(CameraDevice camera,
            List<Surface> outputSurfaces, CameraCaptureSession.StateCallback listener,
            Handler handler, CaptureRequest initialRequest) throws CameraAccessException {
        BlockingSessionCallback sessionListener = new BlockingSessionCallback(listener);

        List<OutputConfiguration> outConfigurations = new ArrayList<>(outputSurfaces.size());
        for (Surface surface : outputSurfaces) {
            outConfigurations.add(new OutputConfiguration(surface));
        }
        SessionConfiguration sessionConfig = new SessionConfiguration(
                SessionConfiguration.SESSION_HIGH_SPEED, outConfigurations,
                new HandlerExecutor(handler), sessionListener);
        sessionConfig.setSessionParameters(initialRequest);
        camera.createCaptureSession(sessionConfig);

        CameraCaptureSession session =
                sessionListener.waitAndGetSession(SESSION_CONFIGURE_TIMEOUT_MS);
        assertFalse(""Camera session should not be a reprocessable session"",
                session.isReprocessable());
        assertTrue(""Capture session type must be High Speed"",
                CameraConstrainedHighSpeedCaptureSession.class.isAssignableFrom(
                        session.getClass()));

        return session;
    }

    /**
     * Configure a new camera session with output configurations.
     *
     * @param camera The CameraDevice to be configured.
     * @param outputs The OutputConfiguration list that is used for camera output.
     * @param listener The callback CameraDevice will notify when capture results are available.
     */
    public static CameraCaptureSession configureCameraSessionWithConfig(CameraDevice camera,
            List<OutputConfiguration> outputs,
            CameraCaptureSession.StateCallback listener, Handler handler)
            throws CameraAccessException {
        BlockingSessionCallback sessionListener = new BlockingSessionCallback(listener);
        camera.createCaptureSessionByOutputConfigurations(outputs, sessionListener, handler);
        CameraCaptureSession session =
                sessionListener.waitAndGetSession(SESSION_CONFIGURE_TIMEOUT_MS);
        assertFalse(""Camera session should not be a reprocessable session"",
                session.isReprocessable());
        return session;
    }

    /**
     * Try configure a new camera session with output configurations.
     *
     * @param camera The CameraDevice to be configured.
     * @param outputs The OutputConfiguration list that is used for camera output.
     * @param initialRequest The session parameters passed in during stream configuration
     * @param listener The callback CameraDevice will notify when capture results are available.
     */
    public static CameraCaptureSession tryConfigureCameraSessionWithConfig(CameraDevice camera,
            List<OutputConfiguration> outputs, CaptureRequest initialRequest,
            CameraCaptureSession.StateCallback listener, Handler handler)
            throws CameraAccessException {
        BlockingSessionCallback sessionListener = new BlockingSessionCallback(listener);
        SessionConfiguration sessionConfig = new SessionConfiguration(
                SessionConfiguration.SESSION_REGULAR, outputs, new HandlerExecutor(handler),
                sessionListener);
        sessionConfig.setSessionParameters(initialRequest);
        camera.createCaptureSession(sessionConfig);

        Integer[] sessionStates = {BlockingSessionCallback.SESSION_READY,
                                   BlockingSessionCallback.SESSION_CONFIGURE_FAILED};
        int state = sessionListener.getStateWaiter().waitForAnyOfStates(
                Arrays.asList(sessionStates), SESSION_CONFIGURE_TIMEOUT_MS);

        CameraCaptureSession session = null;
        if (state == BlockingSessionCallback.SESSION_READY) {
            session = sessionListener.waitAndGetSession(SESSION_CONFIGURE_TIMEOUT_MS);
            assertFalse(""Camera session should not be a reprocessable session"",
                    session.isReprocessable());
        }
        return session;
    }

    /**
     * Configure a new camera session with output surfaces and initial session parameters.
     *
     * @param camera The CameraDevice to be configured.
     * @param outputSurfaces The surface list that used for camera output.
     * @param listener The callback CameraDevice will notify when session is available.
     * @param handler The handler used to notify callbacks.
     * @param initialRequest Initial request settings to use as session parameters.
     */
    public static CameraCaptureSession configureCameraSessionWithParameters(CameraDevice camera,
            List<Surface> outputSurfaces, BlockingSessionCallback listener,
            Handler handler, CaptureRequest initialRequest) throws CameraAccessException {
        List<OutputConfiguration> outConfigurations = new ArrayList<>(outputSurfaces.size());
        for (Surface surface : outputSurfaces) {
            outConfigurations.add(new OutputConfiguration(surface));
        }
        SessionConfiguration sessionConfig = new SessionConfiguration(
                SessionConfiguration.SESSION_REGULAR, outConfigurations,
                new HandlerExecutor(handler), listener);
        sessionConfig.setSessionParameters(initialRequest);
        camera.createCaptureSession(sessionConfig);

        CameraCaptureSession session = listener.waitAndGetSession(SESSION_CONFIGURE_TIMEOUT_MS);
        assertFalse(""Camera session should not be a reprocessable session"",
                session.isReprocessable());
        assertFalse(""Capture session type must be regular"",
                CameraConstrainedHighSpeedCaptureSession.class.isAssignableFrom(
                        session.getClass()));

        return session;
    }

    /**
     * Configure a new camera session with output surfaces.
     *
     * @param camera The CameraDevice to be configured.
     * @param outputSurfaces The surface list that used for camera output.
     * @param listener The callback CameraDevice will notify when capture results are available.
     */
    public static CameraCaptureSession configureCameraSession(CameraDevice camera,
            List<Surface> outputSurfaces,
            CameraCaptureSession.StateCallback listener, Handler handler)
            throws CameraAccessException {

        return configureCameraSession(camera, outputSurfaces, /*isHighSpeed*/false,
                listener, handler);
    }

    public static CameraCaptureSession configureReprocessableCameraSession(CameraDevice camera,
            InputConfiguration inputConfiguration, List<Surface> outputSurfaces,
            CameraCaptureSession.StateCallback listener, Handler handler)
            throws CameraAccessException {
        List<OutputConfiguration> outputConfigs = new ArrayList<OutputConfiguration>();
        for (Surface surface : outputSurfaces) {
            outputConfigs.add(new OutputConfiguration(surface));
        }
        CameraCaptureSession session = configureReprocessableCameraSessionWithConfigurations(
                camera, inputConfiguration, outputConfigs, listener, handler);

        return session;
    }

    public static CameraCaptureSession configureReprocessableCameraSessionWithConfigurations(
            CameraDevice camera, InputConfiguration inputConfiguration,
            List<OutputConfiguration> outputConfigs, CameraCaptureSession.StateCallback listener,
            Handler handler) throws CameraAccessException {
        BlockingSessionCallback sessionListener = new BlockingSessionCallback(listener);
        SessionConfiguration sessionConfig = new SessionConfiguration(
                SessionConfiguration.SESSION_REGULAR, outputConfigs, new HandlerExecutor(handler),
                sessionListener);
        sessionConfig.setInputConfiguration(inputConfiguration);
        camera.createCaptureSession(sessionConfig);

        Integer[] sessionStates = {BlockingSessionCallback.SESSION_READY,
                                   BlockingSessionCallback.SESSION_CONFIGURE_FAILED};
        int state = sessionListener.getStateWaiter().waitForAnyOfStates(
                Arrays.asList(sessionStates), SESSION_CONFIGURE_TIMEOUT_MS);

        assertTrue(""Creating a reprocessable session failed."",
                state == BlockingSessionCallback.SESSION_READY);
        CameraCaptureSession session =
                sessionListener.waitAndGetSession(SESSION_CONFIGURE_TIMEOUT_MS);
        assertTrue(""Camera session should be a reprocessable session"", session.isReprocessable());

        return session;
    }

    /**
     * Create a reprocessable camera session with input and output configurations.
     *
     * @param camera The CameraDevice to be configured.
     * @param inputConfiguration The input configuration used to create this session.
     * @param outputs The output configurations used to create this session.
     * @param listener The callback CameraDevice will notify when capture results are available.
     * @param handler The handler used to notify callbacks.
     * @return The session ready to use.
     * @throws CameraAccessException
     */
    public static CameraCaptureSession configureReprocCameraSessionWithConfig(CameraDevice camera,
            InputConfiguration inputConfiguration, List<OutputConfiguration> outputs,
            CameraCaptureSession.StateCallback listener, Handler handler)
            throws CameraAccessException {
        BlockingSessionCallback sessionListener = new BlockingSessionCallback(listener);
        camera.createReprocessableCaptureSessionByConfigurations(inputConfiguration, outputs,
                sessionListener, handler);

        Integer[] sessionStates = {BlockingSessionCallback.SESSION_READY,
                                   BlockingSessionCallback.SESSION_CONFIGURE_FAILED};
        int state = sessionListener.getStateWaiter().waitForAnyOfStates(
                Arrays.asList(sessionStates), SESSION_CONFIGURE_TIMEOUT_MS);

        assertTrue(""Creating a reprocessable session failed."",
                state == BlockingSessionCallback.SESSION_READY);

        CameraCaptureSession session =
                sessionListener.waitAndGetSession(SESSION_CONFIGURE_TIMEOUT_MS);
        assertTrue(""Camera session should be a reprocessable session"", session.isReprocessable());

        return session;
    }

    public static <T> void assertArrayNotEmpty(T arr, String message) {
        assertTrue(message, arr != null && Array.getLength(arr) > 0);
    }

    /**
     * Check if the format is a legal YUV format camera supported.
     */
    public static void checkYuvFormat(int format) {
        if ((format != ImageFormat.YUV_420_888) &&
                (format != ImageFormat.NV21) &&
                (format != ImageFormat.YV12)) {
            fail(""Wrong formats: "" + format);
        }
    }

    /**
     * Check if image size and format match given size and format.
     */
    public static void checkImage(Image image, int width, int height, int format) {
        // Image reader will wrap YV12/NV21 image by YUV_420_888
        if (format == ImageFormat.NV21 || format == ImageFormat.YV12) {
            format = ImageFormat.YUV_420_888;
        }
        assertNotNull(""Input image is invalid"", image);
        assertEquals(""Format doesn't match"", format, image.getFormat());
        assertEquals(""Width doesn't match"", width, image.getWidth());
        assertEquals(""Height doesn't match"", height, image.getHeight());
    }

    /**
     * <p>Read data from all planes of an Image into a contiguous unpadded, unpacked
     * 1-D linear byte array, such that it can be write into disk, or accessed by
     * software conveniently. It supports YUV_420_888/NV21/YV12 and JPEG input
     * Image format.</p>
     *
     * <p>For YUV_420_888/NV21/YV12/Y8/Y16, it returns a byte array that contains
     * the Y plane data first, followed by U(Cb), V(Cr) planes if there is any
     * (xstride = width, ystride = height for chroma and luma components).</p>
     *
     * <p>For JPEG, it returns a 1-D byte array contains a complete JPEG image.</p>
     *
     * <p>For YUV P010, it returns a byte array that contains Y plane first, followed
     * by the interleaved U(Cb)/V(Cr) plane.</p>
     */
    public static byte[] getDataFromImage(Image image) {
        assertNotNull(""Invalid image:"", image);
        int format = image.getFormat();
        int width = image.getWidth();
        int height = image.getHeight();
        int rowStride, pixelStride;
        byte[] data = null;

        // Read image data
        Plane[] planes = image.getPlanes();
        assertTrue(""Fail to get image planes"", planes != null && planes.length > 0);

        // Check image validity
        checkAndroidImageFormat(image);

        ByteBuffer buffer = null;
        // JPEG doesn't have pixelstride and rowstride, treat it as 1D buffer.
        // Same goes for DEPTH_POINT_CLOUD, RAW_PRIVATE, DEPTH_JPEG, and HEIC
        if (format == ImageFormat.JPEG || format == ImageFormat.DEPTH_POINT_CLOUD ||
                format == ImageFormat.RAW_PRIVATE || format == ImageFormat.DEPTH_JPEG ||
                format == ImageFormat.HEIC) {
            buffer = planes[0].getBuffer();
            assertNotNull(""Fail to get jpeg/depth/heic ByteBuffer"", buffer);
            data = new byte[buffer.remaining()];
            buffer.get(data);
            buffer.rewind();
            return data;
        } else if (format == ImageFormat.YCBCR_P010) {
            // P010 samples are stored within 16 bit values
            int offset = 0;
            int bytesPerPixelRounded = (ImageFormat.getBitsPerPixel(format) + 7) / 8;
            data = new byte[width * height * bytesPerPixelRounded];
            assertTrue(""Unexpected number of planes, expected "" + 3 + "" actual "" + planes.length,
                    planes.length == 3);
            for (int i = 0; i < 2; i++) {
                buffer = planes[i].getBuffer();
                assertNotNull(""Fail to get bytebuffer from plane"", buffer);
                buffer.rewind();
                rowStride = planes[i].getRowStride();
                if (VERBOSE) {
                    Log.v(TAG, ""rowStride "" + rowStride);
                    Log.v(TAG, ""width "" + width);
                    Log.v(TAG, ""height "" + height);
                }
                int h = (i == 0) ? height : height / 2;
                for (int row = 0; row < h; row++) {
                    int length = rowStride;
                    buffer.get(data, offset, length);
                    offset += length;
                }
                if (VERBOSE) Log.v(TAG, ""Finished reading data from plane "" + i);
                buffer.rewind();
            }
            return data;
        }

        int offset = 0;
        data = new byte[width * height * ImageFormat.getBitsPerPixel(format) / 8];
        int maxRowSize = planes[0].getRowStride();
        for (int i = 0; i < planes.length; i++) {
            if (maxRowSize < planes[i].getRowStride()) {
                maxRowSize = planes[i].getRowStride();
            }
        }
        byte[] rowData = new byte[maxRowSize];
        if(VERBOSE) Log.v(TAG, ""get data from "" + planes.length + "" planes"");
        for (int i = 0; i < planes.length; i++) {
            buffer = planes[i].getBuffer();
            assertNotNull(""Fail to get bytebuffer from plane"", buffer);
            buffer.rewind();
            rowStride = planes[i].getRowStride();
            pixelStride = planes[i].getPixelStride();
            assertTrue(""pixel stride "" + pixelStride + "" is invalid"", pixelStride > 0);
            if (VERBOSE) {
                Log.v(TAG, ""pixelStride "" + pixelStride);
                Log.v(TAG, ""rowStride "" + rowStride);
                Log.v(TAG, ""width "" + width);
                Log.v(TAG, ""height "" + height);
            }
            // For multi-planar yuv images, assuming yuv420 with 2x2 chroma subsampling.
            int w = (i == 0) ? width : width / 2;
            int h = (i == 0) ? height : height / 2;
            assertTrue(""rowStride "" + rowStride + "" should be >= width "" + w , rowStride >= w);
            for (int row = 0; row < h; row++) {
                int bytesPerPixel = ImageFormat.getBitsPerPixel(format) / 8;
                int length;
                if (pixelStride == bytesPerPixel) {
                    // Special case: optimized read of the entire row
                    length = w * bytesPerPixel;
                    buffer.get(data, offset, length);
                    offset += length;
                } else {
                    // Generic case: should work for any pixelStride but slower.
                    // Use intermediate buffer to avoid read byte-by-byte from
                    // DirectByteBuffer, which is very bad for performance
                    length = (w - 1) * pixelStride + bytesPerPixel;
                    buffer.get(rowData, 0, length);
                    for (int col = 0; col < w; col++) {
                        data[offset++] = rowData[col * pixelStride];
                    }
                }
                // Advance buffer the remainder of the row stride
                if (row < h - 1) {
                    buffer.position(buffer.position() + rowStride - length);
                }
            }
            if (VERBOSE) Log.v(TAG, ""Finished reading data from plane "" + i);
            buffer.rewind();
        }
        return data;
    }

    /**
     * <p>Check android image format validity for an image, only support below formats:</p>
     *
     * <p>YUV_420_888/NV21/YV12, can add more for future</p>
     */
    public static void checkAndroidImageFormat(Image image) {
        int format = image.getFormat();
        Plane[] planes = image.getPlanes();
        switch (format) {
            case ImageFormat.YUV_420_888:
            case ImageFormat.NV21:
            case ImageFormat.YV12:
            case ImageFormat.YCBCR_P010:
                assertEquals(""YUV420 format Images should have 3 planes"", 3, planes.length);
                break;
            case ImageFormat.JPEG:
            case ImageFormat.RAW_SENSOR:
            case ImageFormat.RAW_PRIVATE:
            case ImageFormat.DEPTH16:
            case ImageFormat.DEPTH_POINT_CLOUD:
            case ImageFormat.DEPTH_JPEG:
            case ImageFormat.Y8:
            case ImageFormat.HEIC:
                assertEquals(""JPEG/RAW/depth/Y8 Images should have one plane"", 1, planes.length);
                break;
            default:
                fail(""Unsupported Image Format: "" + format);
        }
    }

    public static void dumpFile(String fileName, Bitmap data) {
        FileOutputStream outStream;
        try {
            Log.v(TAG, ""output will be saved as "" + fileName);
            outStream = new FileOutputStream(fileName);
        } catch (IOException ioe) {
            throw new RuntimeException(""Unable to create debug output file "" + fileName, ioe);
        }

        try {
            data.compress(Bitmap.CompressFormat.JPEG, /*quality*/90, outStream);
            outStream.close();
        } catch (IOException ioe) {
            throw new RuntimeException(""failed writing data to file "" + fileName, ioe);
        }
    }

    public static void dumpFile(String fileName, byte[] data) {
        FileOutputStream outStream;
        try {
            Log.v(TAG, ""output will be saved as "" + fileName);
            outStream = new FileOutputStream(fileName);
        } catch (IOException ioe) {
            throw new RuntimeException(""Unable to create debug output file "" + fileName, ioe);
        }

        try {
            outStream.write(data);
            outStream.close();
        } catch (IOException ioe) {
            throw new RuntimeException(""failed writing data to file "" + fileName, ioe);
        }
    }

    /**
     * Get the available output sizes for the user-defined {@code format}.
     *
     * <p>Note that implementation-defined/hidden formats are not supported.</p>
     */
    public static Size[] getSupportedSizeForFormat(int format, String cameraId,
            CameraManager cameraManager) throws CameraAccessException {
        CameraCharacteristics properties = cameraManager.getCameraCharacteristics(cameraId);
        assertNotNull(""Can't get camera characteristics!"", properties);
        if (VERBOSE) {
            Log.v(TAG, ""get camera characteristics for camera: "" + cameraId);
        }
        StreamConfigurationMap configMap =
                properties.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);
        Size[] availableSizes = configMap.getOutputSizes(format);
        assertArrayNotEmpty(availableSizes, ""availableSizes should not be empty for format: ""
                + format);
        Size[] highResAvailableSizes = configMap.getHighResolutionOutputSizes(format);
        if (highResAvailableSizes != null && highResAvailableSizes.length > 0) {
            Size[] allSizes = new Size[availableSizes.length + highResAvailableSizes.length];
            System.arraycopy(availableSizes, 0, allSizes, 0,
                    availableSizes.length);
            System.arraycopy(highResAvailableSizes, 0, allSizes, availableSizes.length,
                    highResAvailableSizes.length);
            availableSizes = allSizes;
        }
        if (VERBOSE) Log.v(TAG, ""Supported sizes are: "" + Arrays.deepToString(availableSizes));
        return availableSizes;
    }

    /**
     * Get the available output sizes for the given class.
     *
     */
    public static Size[] getSupportedSizeForClass(Class klass, String cameraId,
            CameraManager cameraManager) throws CameraAccessException {
        CameraCharacteristics properties = cameraManager.getCameraCharacteristics(cameraId);
        assertNotNull(""Can't get camera characteristics!"", properties);
        if (VERBOSE) {
            Log.v(TAG, ""get camera characteristics for camera: "" + cameraId);
        }
        StreamConfigurationMap configMap =
                properties.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);
        Size[] availableSizes = configMap.getOutputSizes(klass);
        assertArrayNotEmpty(availableSizes, ""availableSizes should not be empty for class: ""
                + klass);
        Size[] highResAvailableSizes = configMap.getHighResolutionOutputSizes(ImageFormat.PRIVATE);
        if (highResAvailableSizes != null && highResAvailableSizes.length > 0) {
            Size[] allSizes = new Size[availableSizes.length + highResAvailableSizes.length];
            System.arraycopy(availableSizes, 0, allSizes, 0,
                    availableSizes.length);
            System.arraycopy(highResAvailableSizes, 0, allSizes, availableSizes.length,
                    highResAvailableSizes.length);
            availableSizes = allSizes;
        }
        if (VERBOSE) Log.v(TAG, ""Supported sizes are: "" + Arrays.deepToString(availableSizes));
        return availableSizes;
    }

    /**
     * Size comparator that compares the number of pixels it covers.
     *
     * <p>If two the areas of two sizes are same, compare the widths.</p>
     */
    public static class SizeComparator implements Comparator<Size> {
        @Override
        public int compare(Size lhs, Size rhs) {
            return CameraUtils
                    .compareSizes(lhs.getWidth(), lhs.getHeight(), rhs.getWidth(), rhs.getHeight());
        }
    }

    /**
     * Get sorted size list in descending order. Remove the sizes larger than
     * the bound. If the bound is null, don't do the size bound filtering.
     */
    static public List<Size> getSupportedPreviewSizes(String cameraId,
            CameraManager cameraManager, Size bound) throws CameraAccessException {

        Size[] rawSizes = getSupportedSizeForClass(android.view.SurfaceHolder.class, cameraId,
                cameraManager);
        assertArrayNotEmpty(rawSizes,
                ""Available sizes for SurfaceHolder class should not be empty"");
        if (VERBOSE) {
            Log.v(TAG, ""Supported sizes are: "" + Arrays.deepToString(rawSizes));
        }

        if (bound == null) {
            return getAscendingOrderSizes(Arrays.asList(rawSizes), /*ascending*/false);
        }

        List<Size> sizes = new ArrayList<Size>();
        for (Size sz: rawSizes) {
            if (sz.getWidth() <= bound.getWidth() && sz.getHeight() <= bound.getHeight()) {
                sizes.add(sz);
            }
        }
        return getAscendingOrderSizes(sizes, /*ascending*/false);
    }

    /**
     * Get a sorted list of sizes from a given size list.
     *
     * <p>
     * The size is compare by area it covers, if the areas are same, then
     * compare the widths.
     * </p>
     *
     * @param sizeList The input size list to be sorted
     * @param ascending True if the order is ascending, otherwise descending order
     * @return The ordered list of sizes
     */
    static public List<Size> getAscendingOrderSizes(final List<Size> sizeList, boolean ascending) {
        if (sizeList == null) {
            throw new IllegalArgumentException(""sizeList shouldn't be null"");
        }

        Comparator<Size> comparator = new SizeComparator();
        List<Size> sortedSizes = new ArrayList<Size>();
        sortedSizes.addAll(sizeList);
        Collections.sort(sortedSizes, comparator);
        if (!ascending) {
            Collections.reverse(sortedSizes);
        }

        return sortedSizes;
    }

    /**
     * Get sorted (descending order) size list for given format. Remove the sizes larger than
     * the bound. If the bound is null, don't do the size bound filtering.
     */
    static public List<Size> getSortedSizesForFormat(String cameraId,
            CameraManager cameraManager, int format, Size bound) throws CameraAccessException {
        Comparator<Size> comparator = new SizeComparator();
        Size[] sizes = getSupportedSizeForFormat(format, cameraId, cameraManager);
        List<Size> sortedSizes = null;
        if (bound != null) {
            sortedSizes = new ArrayList<Size>(/*capacity*/1);
            for (Size sz : sizes) {
                if (comparator.compare(sz, bound) <= 0) {
                    sortedSizes.add(sz);
                }
            }
        } else {
            sortedSizes = Arrays.asList(sizes);
        }
        assertTrue(""Supported size list should have at least one element"",
                sortedSizes.size() > 0);

        Collections.sort(sortedSizes, comparator);
        // Make it in descending order.
        Collections.reverse(sortedSizes);
        return sortedSizes;
    }

    /**
     * Get supported video size list for a given camera device.
     *
     * <p>
     * Filter out the sizes that are larger than the bound. If the bound is
     * null, don't do the size bound filtering.
     * </p>
     */
    static public List<Size> getSupportedVideoSizes(String cameraId,
            CameraManager cameraManager, Size bound) throws CameraAccessException {

        Size[] rawSizes = getSupportedSizeForClass(android.media.MediaRecorder.class,
                cameraId, cameraManager);
        assertArrayNotEmpty(rawSizes,
                ""Available sizes for MediaRecorder class should not be empty"");
        if (VERBOSE) {
            Log.v(TAG, ""Supported sizes are: "" + Arrays.deepToString(rawSizes));
        }

        if (bound == null) {
            return getAscendingOrderSizes(Arrays.asList(rawSizes), /*ascending*/false);
        }

        List<Size> sizes = new ArrayList<Size>();
        for (Size sz: rawSizes) {
            if (sz.getWidth() <= bound.getWidth() && sz.getHeight() <= bound.getHeight()) {
                sizes.add(sz);
            }
        }
        return getAscendingOrderSizes(sizes, /*ascending*/false);
    }

    /**
     * Get supported video size list (descending order) for a given camera device.
     *
     * <p>
     * Filter out the sizes that are larger than the bound. If the bound is
     * null, don't do the size bound filtering.
     * </p>
     */
    static public List<Size> getSupportedStillSizes(String cameraId,
            CameraManager cameraManager, Size bound) throws CameraAccessException {
        return getSortedSizesForFormat(cameraId, cameraManager, ImageFormat.JPEG, bound);
    }

    static public List<Size> getSupportedHeicSizes(String cameraId,
            CameraManager cameraManager, Size bound) throws CameraAccessException {
        return getSortedSizesForFormat(cameraId, cameraManager, ImageFormat.HEIC, bound);
    }

    static public Size getMinPreviewSize(String cameraId, CameraManager cameraManager)
            throws CameraAccessException {
        List<Size> sizes = getSupportedPreviewSizes(cameraId, cameraManager, null);
        return sizes.get(sizes.size() - 1);
    }

    /**
     * Get max supported preview size for a camera device.
     */
    static public Size getMaxPreviewSize(String cameraId, CameraManager cameraManager)
            throws CameraAccessException {
        return getMaxPreviewSize(cameraId, cameraManager, /*bound*/null);
    }

    /**
     * Get max preview size for a camera device in the supported sizes that are no larger
     * than the bound.
     */
    static public Size getMaxPreviewSize(String cameraId, CameraManager cameraManager, Size bound)
            throws CameraAccessException {
        List<Size> sizes = getSupportedPreviewSizes(cameraId, cameraManager, bound);
        return sizes.get(0);
    }

    /**
     * Get max depth size for a camera device.
     */
    static public Size getMaxDepthSize(String cameraId, CameraManager cameraManager)
            throws CameraAccessException {
        List<Size> sizes = getSortedSizesForFormat(cameraId, cameraManager, ImageFormat.DEPTH16,
                /*bound*/ null);
        return sizes.get(0);
    }

    /**
     * Get the largest size by area.
     *
     * @param sizes an array of sizes, must have at least 1 element
     *
     * @return Largest Size
     *
     * @throws IllegalArgumentException if sizes was null or had 0 elements
     */
    public static Size getMaxSize(Size... sizes) {
        if (sizes == null || sizes.length == 0) {
            throw new IllegalArgumentException(""sizes was empty"");
        }

        Size sz = sizes[0];
        for (Size size : sizes) {
            if (size.getWidth() * size.getHeight() > sz.getWidth() * sz.getHeight()) {
                sz = size;
            }
        }

        return sz;
    }

    /**
     * Get the largest size by area within (less than) bound
     *
     * @param sizes an array of sizes, must have at least 1 element
     *
     * @return Largest Size. Null if no such size exists within bound.
     *
     * @throws IllegalArgumentException if sizes was null or had 0 elements, or bound is invalid.
     */
    public static Size getMaxSizeWithBound(Size[] sizes, int bound) {
        if (sizes == null || sizes.length == 0) {
            throw new IllegalArgumentException(""sizes was empty"");
        }
        if (bound <= 0) {
            throw new IllegalArgumentException(""bound is invalid"");
        }

        Size sz = null;
        for (Size size : sizes) {
            if (size.getWidth() * size.getHeight() >= bound) {
                continue;
            }

            if (sz == null ||
                    size.getWidth() * size.getHeight() > sz.getWidth() * sz.getHeight()) {
                sz = size;
            }
        }

        return sz;
    }

    /**
     * Returns true if the given {@code array} contains the given element.
     *
     * @param array {@code array} to check for {@code elem}
     * @param elem {@code elem} to test for
     * @return {@code true} if the given element is contained
     */
    public static boolean contains(int[] array, int elem) {
        if (array == null) return false;
        for (int i = 0; i < array.length; i++) {
            if (elem == array[i]) return true;
        }
        return false;
    }

    /**
     * Get object array from byte array.
     *
     * @param array Input byte array to be converted
     * @return Byte object array converted from input byte array
     */
    public static Byte[] toObject(byte[] array) {
        return convertPrimitiveArrayToObjectArray(array, Byte.class);
    }

    /**
     * Get object array from int array.
     *
     * @param array Input int array to be converted
     * @return Integer object array converted from input int array
     */
    public static Integer[] toObject(int[] array) {
        return convertPrimitiveArrayToObjectArray(array, Integer.class);
    }

    /**
     * Get object array from float array.
     *
     * @param array Input float array to be converted
     * @return Float object array converted from input float array
     */
    public static Float[] toObject(float[] array) {
        return convertPrimitiveArrayToObjectArray(array, Float.class);
    }

    /**
     * Get object array from double array.
     *
     * @param array Input double array to be converted
     * @return Double object array converted from input double array
     */
    public static Double[] toObject(double[] array) {
        return convertPrimitiveArrayToObjectArray(array, Double.class);
    }

    /**
     * Convert a primitive input array into its object array version (e.g. from int[] to Integer[]).
     *
     * @param array Input array object
     * @param wrapperClass The boxed class it converts to
     * @return Boxed version of primitive array
     */
    private static <T> T[] convertPrimitiveArrayToObjectArray(final Object array,
            final Class<T> wrapperClass) {
        // getLength does the null check and isArray check already.
        int arrayLength = Array.getLength(array);
        if (arrayLength == 0) {
            throw new IllegalArgumentException(""Input array shouldn't be empty"");
        }

        @SuppressWarnings(""unchecked"")
        final T[] result = (T[]) Array.newInstance(wrapperClass, arrayLength);
        for (int i = 0; i < arrayLength; i++) {
            Array.set(result, i, Array.get(array, i));
        }
        return result;
    }

    /**
     * Validate image based on format and size.
     *
     * @param image The image to be validated.
     * @param width The image width.
     * @param height The image height.
     * @param format The image format.
     * @param filePath The debug dump file path, null if don't want to dump to
     *            file.
     * @throws UnsupportedOperationException if calling with an unknown format
     */
    public static void validateImage(Image image, int width, int height, int format,
            String filePath) {
        checkImage(image, width, height, format);

        /**
         * TODO: validate timestamp:
         * 1. capture result timestamp against the image timestamp (need
         * consider frame drops)
         * 2. timestamps should be monotonically increasing for different requests
         */
        if(VERBOSE) Log.v(TAG, ""validating Image"");
        byte[] data = getDataFromImage(image);
        assertTrue(""Invalid image data"", data != null && data.length > 0);

        switch (format) {
            // Clients must be able to process and handle depth jpeg images like any other
            // regular jpeg.
            case ImageFormat.DEPTH_JPEG:
            case ImageFormat.JPEG:
                validateJpegData(data, width, height, filePath);
                break;
            case ImageFormat.YCBCR_P010:
                validateP010Data(data, width, height, format, image.getTimestamp(), filePath);
                break;
            case ImageFormat.YUV_420_888:
            case ImageFormat.YV12:
                validateYuvData(data, width, height, format, image.getTimestamp(), filePath);
                break;
            case ImageFormat.RAW_SENSOR:
                validateRaw16Data(data, width, height, format, image.getTimestamp(), filePath);
                break;
            case ImageFormat.DEPTH16:
                validateDepth16Data(data, width, height, format, image.getTimestamp(), filePath);
                break;
            case ImageFormat.DEPTH_POINT_CLOUD:
                validateDepthPointCloudData(data, width, height, format, image.getTimestamp(), filePath);
                break;
            case ImageFormat.RAW_PRIVATE:
                validateRawPrivateData(data, width, height, image.getTimestamp(), filePath);
                break;
            case ImageFormat.Y8:
                validateY8Data(data, width, height, format, image.getTimestamp(), filePath);
                break;
            case ImageFormat.HEIC:
                validateHeicData(data, width, height, filePath);
                break;
            default:
                throw new UnsupportedOperationException(""Unsupported format for validation: ""
                        + format);
        }
    }

    public static class HandlerExecutor implements Executor {
        private final Handler mHandler;

        public HandlerExecutor(Handler handler) {
            assertNotNull(""handler must be valid"", handler);
            mHandler = handler;
        }

        @Override
        public void execute(Runnable runCmd) {
            mHandler.post(runCmd);
        }
    }

    /**
     * Provide a mock for {@link CameraDevice.StateCallback}.
     *
     * <p>Only useful because mockito can't mock {@link CameraDevice.StateCallback} which is an
     * abstract class.</p>
     *
     * <p>
     * Use this instead of other classes when needing to verify interactions, since
     * trying to spy on {@link BlockingStateCallback} (or others) will cause unnecessary extra
     * interactions which will cause false test failures.
     * </p>
     *
     */
    public static class MockStateCallback extends CameraDevice.StateCallback {

        @Override
        public void onOpened(CameraDevice camera) {
        }

        @Override
        public void onDisconnected(CameraDevice camera) {
        }

        @Override
        public void onError(CameraDevice camera, int error) {
        }

        private MockStateCallback() {}

        /**
         * Create a Mockito-ready mocked StateCallback.
         */
        public static MockStateCallback mock() {
            return Mockito.spy(new MockStateCallback());
        }
    }

    public static void validateJpegData(byte[] jpegData, int width, int height, String filePath) {
        BitmapFactory.Options bmpOptions = new BitmapFactory.Options();
        // DecodeBound mode: only parse the frame header to get width/height.
        // it doesn't decode the pixel.
        bmpOptions.inJustDecodeBounds = true;
        BitmapFactory.decodeByteArray(jpegData, 0, jpegData.length, bmpOptions);
        assertEquals(width, bmpOptions.outWidth);
        assertEquals(height, bmpOptions.outHeight);

        // Pixel decoding mode: decode whole image. check if the image data
        // is decodable here.
        assertNotNull(""Decoding jpeg failed"",
                BitmapFactory.decodeByteArray(jpegData, 0, jpegData.length));
        if (DEBUG && filePath != null) {
            String fileName =
                    filePath + ""/"" + width + ""x"" + height + "".jpeg"";
            dumpFile(fileName, jpegData);
        }
    }

    private static void validateYuvData(byte[] yuvData, int width, int height, int format,
            long ts, String filePath) {
        checkYuvFormat(format);
        if (VERBOSE) Log.v(TAG, ""Validating YUV data"");
        int expectedSize = width * height * ImageFormat.getBitsPerPixel(format) / 8;
        assertEquals(""Yuv data doesn't match"", expectedSize, yuvData.length);

        // TODO: Can add data validation for test pattern.

        if (DEBUG && filePath != null) {
            String fileName =
                    filePath + ""/"" + width + ""x"" + height + ""_"" + ts / 1e6 + "".yuv"";
            dumpFile(fileName, yuvData);
        }
    }

    private static void validateP010Data(byte[] p010Data, int width, int height, int format,
            long ts, String filePath) {
        if (VERBOSE) Log.v(TAG, ""Validating P010 data"");
        // The P010 10 bit samples are stored in two bytes so the size needs to be adjusted
        // accordingly.
        int bytesPerPixelRounded = (ImageFormat.getBitsPerPixel(format) + 7) / 8;
        int expectedSize = width * height * bytesPerPixelRounded;
        assertEquals(""P010 data doesn't match"", expectedSize, p010Data.length);

        if (DEBUG && filePath != null) {
            String fileName =
                    filePath + ""/"" + width + ""x"" + height + ""_"" + ts / 1e6 + "".p010"";
            dumpFile(fileName, p010Data);
        }
    }
    private static void validateRaw16Data(byte[] rawData, int width, int height, int format,
            long ts, String filePath) {
        if (VERBOSE) Log.v(TAG, ""Validating raw data"");
        int expectedSize = width * height * ImageFormat.getBitsPerPixel(format) / 8;
        assertEquals(""Raw data doesn't match"", expectedSize, rawData.length);

        // TODO: Can add data validation for test pattern.

        if (DEBUG && filePath != null) {
            String fileName =
                    filePath + ""/"" + width + ""x"" + height + ""_"" + ts / 1e6 + "".raw16"";
            dumpFile(fileName, rawData);
        }

        return;
    }

    private static void validateY8Data(byte[] rawData, int width, int height, int format,
            long ts, String filePath) {
        if (VERBOSE) Log.v(TAG, ""Validating Y8 data"");
        int expectedSize = width * height * ImageFormat.getBitsPerPixel(format) / 8;
        assertEquals(""Y8 data doesn't match"", expectedSize, rawData.length);

        // TODO: Can add data validation for test pattern.

        if (DEBUG && filePath != null) {
            String fileName =
                    filePath + ""/"" + width + ""x"" + height + ""_"" + ts / 1e6 + "".y8"";
            dumpFile(fileName, rawData);
        }

        return;
    }

    private static void validateRawPrivateData(byte[] rawData, int width, int height,
            long ts, String filePath) {
        if (VERBOSE) Log.v(TAG, ""Validating private raw data"");
        // Expect each RAW pixel should occupy at least one byte and no more than 30 bytes
        int expectedSizeMin = width * height;
        int expectedSizeMax = width * height * 30;

        assertTrue(""Opaque RAW size "" + rawData.length + ""out of normal bound ["" +
                expectedSizeMin + "","" + expectedSizeMax + ""]"",
                expectedSizeMin <= rawData.length && rawData.length <= expectedSizeMax);

        if (DEBUG && filePath != null) {
            String fileName =
                    filePath + ""/"" + width + ""x"" + height + ""_"" + ts / 1e6 + "".rawPriv"";
            dumpFile(fileName, rawData);
        }

        return;
    }

    private static void validateDepth16Data(byte[] depthData, int width, int height, int format,
            long ts, String filePath) {

        if (VERBOSE) Log.v(TAG, ""Validating depth16 data"");
        int expectedSize = width * height * ImageFormat.getBitsPerPixel(format) / 8;
        assertEquals(""Depth data doesn't match"", expectedSize, depthData.length);


        if (DEBUG && filePath != null) {
            String fileName =
                    filePath + ""/"" + width + ""x"" + height + ""_"" + ts / 1e6 + "".depth16"";
            dumpFile(fileName, depthData);
        }

        return;

    }

    private static void validateDepthPointCloudData(byte[] depthData, int width, int height, int format,
            long ts, String filePath) {

        if (VERBOSE) Log.v(TAG, ""Validating depth point cloud data"");

        // Can't validate size since it is variable

        if (DEBUG && filePath != null) {
            String fileName =
                    filePath + ""/"" + width + ""x"" + height + ""_"" + ts / 1e6 + "".depth_point_cloud"";
            dumpFile(fileName, depthData);
        }

        return;

    }

    private static void validateHeicData(byte[] heicData, int width, int height, String filePath) {
        BitmapFactory.Options bmpOptions = new BitmapFactory.Options();
        // DecodeBound mode: only parse the frame header to get width/height.
        // it doesn't decode the pixel.
        bmpOptions.inJustDecodeBounds = true;
        BitmapFactory.decodeByteArray(heicData, 0, heicData.length, bmpOptions);
        assertEquals(width, bmpOptions.outWidth);
        assertEquals(height, bmpOptions.outHeight);

        // Pixel decoding mode: decode whole image. check if the image data
        // is decodable here.
        assertNotNull(""Decoding heic failed"",
                BitmapFactory.decodeByteArray(heicData, 0, heicData.length));
        if (DEBUG && filePath != null) {
            String fileName =
                    filePath + ""/"" + width + ""x"" + height + "".heic"";
            dumpFile(fileName, heicData);
        }
    }

    public static <T> T getValueNotNull(CaptureResult result, CaptureResult.Key<T> key) {
        if (result == null) {
            throw new IllegalArgumentException(""Result must not be null"");
        }

        T value = result.get(key);
        assertNotNull(""Value of Key "" + key.getName() + ""shouldn't be null"", value);
        return value;
    }

    public static <T> T getValueNotNull(CameraCharacteristics characteristics,
            CameraCharacteristics.Key<T> key) {
        if (characteristics == null) {
            throw new IllegalArgumentException(""Camera characteristics must not be null"");
        }

        T value = characteristics.get(key);
        assertNotNull(""Value of Key "" + key.getName() + ""shouldn't be null"", value);
        return value;
    }

    /**
     * Get a crop region for a given zoom factor and center position.
     * <p>
     * The center position is normalized position in range of [0, 1.0], where
     * (0, 0) represents top left corner, (1.0. 1.0) represents bottom right
     * corner. The center position could limit the effective minimal zoom
     * factor, for example, if the center position is (0.75, 0.75), the
     * effective minimal zoom position becomes 2.0. If the requested zoom factor
     * is smaller than 2.0, a crop region with 2.0 zoom factor will be returned.
     * </p>
     * <p>
     * The aspect ratio of the crop region is maintained the same as the aspect
     * ratio of active array.
     * </p>
     *
     * @param zoomFactor The zoom factor to generate the crop region, it must be
     *            >= 1.0
     * @param center The normalized zoom center point that is in the range of [0, 1].
     * @param maxZoom The max zoom factor supported by this device.
     * @param activeArray The active array size of this device.
     * @return crop region for the given normalized center and zoom factor.
     */
    public static Rect getCropRegionForZoom(float zoomFactor, final PointF center,
            final float maxZoom, final Rect activeArray) {
        if (zoomFactor < 1.0) {
            throw new IllegalArgumentException(""zoom factor "" + zoomFactor + "" should be >= 1.0"");
        }
        if (center.x > 1.0 || center.x < 0) {
            throw new IllegalArgumentException(""center.x "" + center.x
                    + "" should be in range of [0, 1.0]"");
        }
        if (center.y > 1.0 || center.y < 0) {
            throw new IllegalArgumentException(""center.y "" + center.y
                    + "" should be in range of [0, 1.0]"");
        }
        if (maxZoom < 1.0) {
            throw new IllegalArgumentException(""max zoom factor "" + maxZoom + "" should be >= 1.0"");
        }
        if (activeArray == null) {
            throw new IllegalArgumentException(""activeArray must not be null"");
        }

        float minCenterLength = Math.min(Math.min(center.x, 1.0f - center.x),
                Math.min(center.y, 1.0f - center.y));
        float minEffectiveZoom =  0.5f / minCenterLength;
        if (minEffectiveZoom > maxZoom) {
            throw new IllegalArgumentException(""Requested center "" + center.toString() +
                    "" has minimal zoomable factor "" + minEffectiveZoom + "", which exceeds max""
                            + "" zoom factor "" + maxZoom);
        }

        if (zoomFactor < minEffectiveZoom) {
            Log.w(TAG, ""Requested zoomFactor "" + zoomFactor + "" < minimal zoomable factor ""
                    + minEffectiveZoom + "". It will be overwritten by "" + minEffectiveZoom);
            zoomFactor = minEffectiveZoom;
        }

        int cropCenterX = (int)(activeArray.width() * center.x);
        int cropCenterY = (int)(activeArray.height() * center.y);
        int cropWidth = (int) (activeArray.width() / zoomFactor);
        int cropHeight = (int) (activeArray.height() / zoomFactor);

        return new Rect(
                /*left*/cropCenterX - cropWidth / 2,
                /*top*/cropCenterY - cropHeight / 2,
                /*right*/ cropCenterX + cropWidth / 2,
                /*bottom*/cropCenterY + cropHeight / 2);
    }

    /**
     * Get AeAvailableTargetFpsRanges and sort them in descending order by max fps
     *
     * @param staticInfo camera static metadata
     * @return AeAvailableTargetFpsRanges in descending order by max fps
     */
    public static Range<Integer>[] getDescendingTargetFpsRanges(StaticMetadata staticInfo) {
        Range<Integer>[] fpsRanges = staticInfo.getAeAvailableTargetFpsRangesChecked();
        Arrays.sort(fpsRanges, new Comparator<Range<Integer>>() {
            public int compare(Range<Integer> r1, Range<Integer> r2) {
                return r2.getUpper() - r1.getUpper();
            }
        });
        return fpsRanges;
    }

    /**
     * Get AeAvailableTargetFpsRanges with max fps not exceeding 30
     *
     * @param staticInfo camera static metadata
     * @return AeAvailableTargetFpsRanges with max fps not exceeding 30
     */
    public static List<Range<Integer>> getTargetFpsRangesUpTo30(StaticMetadata staticInfo) {
        Range<Integer>[] fpsRanges = staticInfo.getAeAvailableTargetFpsRangesChecked();
        ArrayList<Range<Integer>> fpsRangesUpTo30 = new ArrayList<Range<Integer>>();
        for (Range<Integer> fpsRange : fpsRanges) {
            if (fpsRange.getUpper() <= 30) {
                fpsRangesUpTo30.add(fpsRange);
            }
        }
        return fpsRangesUpTo30;
    }

    /**
     * Get AeAvailableTargetFpsRanges with max fps greater than 30
     *
     * @param staticInfo camera static metadata
     * @return AeAvailableTargetFpsRanges with max fps greater than 30
     */
    public static List<Range<Integer>> getTargetFpsRangesGreaterThan30(StaticMetadata staticInfo) {
        Range<Integer>[] fpsRanges = staticInfo.getAeAvailableTargetFpsRangesChecked();
        ArrayList<Range<Integer>> fpsRangesGreaterThan30 = new ArrayList<Range<Integer>>();
        for (Range<Integer> fpsRange : fpsRanges) {
            if (fpsRange.getUpper() > 30) {
                fpsRangesGreaterThan30.add(fpsRange);
            }
        }
        return fpsRangesGreaterThan30;
    }

    /**
     * Calculate output 3A region from the intersection of input 3A region and cropped region.
     *
     * @param requestRegions The input 3A regions
     * @param cropRect The cropped region
     * @return expected 3A regions output in capture result
     */
    public static MeteringRectangle[] getExpectedOutputRegion(
            MeteringRectangle[] requestRegions, Rect cropRect){
        MeteringRectangle[] resultRegions = new MeteringRectangle[requestRegions.length];
        for (int i = 0; i < requestRegions.length; i++) {
            Rect requestRect = requestRegions[i].getRect();
            Rect resultRect = new Rect();
            boolean intersect = resultRect.setIntersect(requestRect, cropRect);
            resultRegions[i] = new MeteringRectangle(
                    resultRect,
                    intersect ? requestRegions[i].getMeteringWeight() : 0);
        }
        return resultRegions;
    }

    /**
     * Copy source image data to destination image.
     *
     * @param src The source image to be copied from.
     * @param dst The destination image to be copied to.
     * @throws IllegalArgumentException If the source and destination images have
     *             different format, size, or one of the images is not copyable.
     */
    public static void imageCopy(Image src, Image dst) {
        if (src == null || dst == null) {
            throw new IllegalArgumentException(""Images should be non-null"");
        }
        if (src.getFormat() != dst.getFormat()) {
            throw new IllegalArgumentException(""Src and dst images should have the same format"");
        }
        if (src.getFormat() == ImageFormat.PRIVATE ||
                dst.getFormat() == ImageFormat.PRIVATE) {
            throw new IllegalArgumentException(""PRIVATE format images are not copyable"");
        }

        Size srcSize = new Size(src.getWidth(), src.getHeight());
        Size dstSize = new Size(dst.getWidth(), dst.getHeight());
        if (!srcSize.equals(dstSize)) {
            throw new IllegalArgumentException(""source image size "" + srcSize + "" is different""
                    + "" with "" + ""destination image size "" + dstSize);
        }

        // TODO: check the owner of the dst image, it must be from ImageWriter, other source may
        // not be writable. Maybe we should add an isWritable() method in image class.

        Plane[] srcPlanes = src.getPlanes();
        Plane[] dstPlanes = dst.getPlanes();
        ByteBuffer srcBuffer = null;
        ByteBuffer dstBuffer = null;
        for (int i = 0; i < srcPlanes.length; i++) {
            srcBuffer = srcPlanes[i].getBuffer();
            dstBuffer = dstPlanes[i].getBuffer();
            int srcPos = srcBuffer.position();
            srcBuffer.rewind();
            dstBuffer.rewind();
            int srcRowStride = srcPlanes[i].getRowStride();
            int dstRowStride = dstPlanes[i].getRowStride();
            int srcPixStride = srcPlanes[i].getPixelStride();
            int dstPixStride = dstPlanes[i].getPixelStride();

            if (srcPixStride > 2 || dstPixStride > 2) {
                throw new IllegalArgumentException(""source pixel stride "" + srcPixStride +
                        "" with destination pixel stride "" + dstPixStride +
                        "" is not supported"");
            }

            if (srcRowStride == dstRowStride && srcPixStride == dstPixStride &&
                    srcPixStride == 1) {
                // Fast path, just copy the content in the byteBuffer all together.
                dstBuffer.put(srcBuffer);
            } else {
                Size effectivePlaneSize = getEffectivePlaneSizeForImage(src, i);
                int srcRowByteCount = srcRowStride;
                int dstRowByteCount = dstRowStride;
                byte[] srcDataRow = new byte[Math.max(srcRowStride, dstRowStride)];

                if (srcPixStride == dstPixStride && srcPixStride == 1) {
                    // Row by row copy case
                    for (int row = 0; row < effectivePlaneSize.getHeight(); row++) {
                        if (row == effectivePlaneSize.getHeight() - 1) {
                            // Special case for interleaved planes: need handle the last row
                            // carefully to avoid memory corruption. Check if we have enough bytes
                            // to copy.
                            srcRowByteCount = Math.min(srcRowByteCount, srcBuffer.remaining());
                            dstRowByteCount = Math.min(dstRowByteCount, dstBuffer.remaining());
                        }
                        srcBuffer.get(srcDataRow, /*offset*/0, srcRowByteCount);
                        dstBuffer.put(srcDataRow, /*offset*/0, dstRowByteCount);
                    }
                } else {
                    // Row by row per pixel copy case
                    byte[] dstDataRow = new byte[dstRowByteCount];
                    for (int row = 0; row < effectivePlaneSize.getHeight(); row++) {
                        if (row == effectivePlaneSize.getHeight() - 1) {
                            // Special case for interleaved planes: need handle the last row
                            // carefully to avoid memory corruption. Check if we have enough bytes
                            // to copy.
                            int remainingBytes = srcBuffer.remaining();
                            if (srcRowByteCount > remainingBytes) {
                                srcRowByteCount = remainingBytes;
                            }
                            remainingBytes = dstBuffer.remaining();
                            if (dstRowByteCount > remainingBytes) {
                                dstRowByteCount = remainingBytes;
                            }
                        }
                        srcBuffer.get(srcDataRow, /*offset*/0, srcRowByteCount);
                        int pos = dstBuffer.position();
                        dstBuffer.get(dstDataRow, /*offset*/0, dstRowByteCount);
                        dstBuffer.position(pos);
                        for (int x = 0; x < effectivePlaneSize.getWidth(); x++) {
                            dstDataRow[x * dstPixStride] = srcDataRow[x * srcPixStride];
                        }
                        dstBuffer.put(dstDataRow, /*offset*/0, dstRowByteCount);
                    }
                }
            }
            srcBuffer.position(srcPos);
            dstBuffer.rewind();
        }
    }

    private static Size getEffectivePlaneSizeForImage(Image image, int planeIdx) {
        switch (image.getFormat()) {
            case ImageFormat.YUV_420_888:
                if (planeIdx == 0) {
                    return new Size(image.getWidth(), image.getHeight());
                } else {
                    return new Size(image.getWidth() / 2, image.getHeight() / 2);
                }
            case ImageFormat.JPEG:
            case ImageFormat.RAW_SENSOR:
            case ImageFormat.RAW10:
            case ImageFormat.RAW12:
            case ImageFormat.DEPTH16:
                return new Size(image.getWidth(), image.getHeight());
            case ImageFormat.PRIVATE:
                return new Size(0, 0);
            default:
                throw new UnsupportedOperationException(
                        String.format(""Invalid image format %d"", image.getFormat()));
        }
    }

    /**
     * <p>
     * Checks whether the two images are strongly equal.
     * </p>
     * <p>
     * Two images are strongly equal if and only if the data, formats, sizes,
     * and timestamps are same. For {@link ImageFormat#PRIVATE PRIVATE} format
     * images, the image data is not not accessible thus the data comparison is
     * effectively skipped as the number of planes is zero.
     * </p>
     * <p>
     * Note that this method compares the pixel data even outside of the crop
     * region, which may not be necessary for general use case.
     * </p>
     *
     * @param lhsImg First image to be compared with.
     * @param rhsImg Second image to be compared with.
     * @return true if the two images are equal, false otherwise.
     * @throws IllegalArgumentException If either of image is null.
     */
    public static boolean isImageStronglyEqual(Image lhsImg, Image rhsImg) {
        if (lhsImg == null || rhsImg == null) {
            throw new IllegalArgumentException(""Images should be non-null"");
        }

        if (lhsImg.getFormat() != rhsImg.getFormat()) {
            Log.i(TAG, ""lhsImg format "" + lhsImg.getFormat() + "" is different with rhsImg format ""
                    + rhsImg.getFormat());
            return false;
        }

        if (lhsImg.getWidth() != rhsImg.getWidth()) {
            Log.i(TAG, ""lhsImg width "" + lhsImg.getWidth() + "" is different with rhsImg width ""
                    + rhsImg.getWidth());
            return false;
        }

        if (lhsImg.getHeight() != rhsImg.getHeight()) {
            Log.i(TAG, ""lhsImg height "" + lhsImg.getHeight() + "" is different with rhsImg height ""
                    + rhsImg.getHeight());
            return false;
        }

        if (lhsImg.getTimestamp() != rhsImg.getTimestamp()) {
            Log.i(TAG, ""lhsImg timestamp "" + lhsImg.getTimestamp()
                    + "" is different with rhsImg timestamp "" + rhsImg.getTimestamp());
            return false;
        }

        if (!lhsImg.getCropRect().equals(rhsImg.getCropRect())) {
            Log.i(TAG, ""lhsImg crop rect "" + lhsImg.getCropRect()
                    + "" is different with rhsImg crop rect "" + rhsImg.getCropRect());
            return false;
        }

        // Compare data inside of the image.
        Plane[] lhsPlanes = lhsImg.getPlanes();
        Plane[] rhsPlanes = rhsImg.getPlanes();
        ByteBuffer lhsBuffer = null;
        ByteBuffer rhsBuffer = null;
        for (int i = 0; i < lhsPlanes.length; i++) {
            lhsBuffer = lhsPlanes[i].getBuffer();
            rhsBuffer = rhsPlanes[i].getBuffer();
            lhsBuffer.rewind();
            rhsBuffer.rewind();
            // Special case for YUV420_888 buffer with different layout or
            // potentially differently interleaved U/V planes.
            if (lhsImg.getFormat() == ImageFormat.YUV_420_888 &&
                    (lhsPlanes[i].getPixelStride() != rhsPlanes[i].getPixelStride() ||
                     lhsPlanes[i].getRowStride() != rhsPlanes[i].getRowStride() ||
                     (lhsPlanes[i].getPixelStride() != 1))) {
                int width = getEffectivePlaneSizeForImage(lhsImg, i).getWidth();
                int height = getEffectivePlaneSizeForImage(lhsImg, i).getHeight();
                int rowSizeL = lhsPlanes[i].getRowStride();
                int rowSizeR = rhsPlanes[i].getRowStride();
                byte[] lhsRow = new byte[rowSizeL];
                byte[] rhsRow = new byte[rowSizeR];
                int pixStrideL = lhsPlanes[i].getPixelStride();
                int pixStrideR = rhsPlanes[i].getPixelStride();
                for (int r = 0; r < height; r++) {
                    if (r == height -1) {
                        rowSizeL = lhsBuffer.remaining();
                        rowSizeR = rhsBuffer.remaining();
                    }
                    lhsBuffer.get(lhsRow, /*offset*/0, rowSizeL);
                    rhsBuffer.get(rhsRow, /*offset*/0, rowSizeR);
                    for (int c = 0; c < width; c++) {
                        if (lhsRow[c * pixStrideL] != rhsRow[c * pixStrideR]) {
                            Log.i(TAG, String.format(
                                    ""byte buffers for plane %d row %d col %d don't match."",
                                    i, r, c));
                            return false;
                        }
                    }
                }
            } else {
                // Compare entire buffer directly
                if (!lhsBuffer.equals(rhsBuffer)) {
                    Log.i(TAG, ""byte buffers for plane "" +  i + "" don't match."");
                    return false;
                }
            }
        }

        return true;
    }

    /**
     * Set jpeg related keys in a capture request builder.
     *
     * @param builder The capture request builder to set the keys inl
     * @param exifData The exif data to set.
     * @param thumbnailSize The thumbnail size to set.
     * @param collector The camera error collector to collect errors.
     */
    public static void setJpegKeys(CaptureRequest.Builder builder, ExifTestData exifData,
            Size thumbnailSize, CameraErrorCollector collector) {
        builder.set(CaptureRequest.JPEG_THUMBNAIL_SIZE, thumbnailSize);
        builder.set(CaptureRequest.JPEG_GPS_LOCATION, exifData.gpsLocation);
        builder.set(CaptureRequest.JPEG_ORIENTATION, exifData.jpegOrientation);
        builder.set(CaptureRequest.JPEG_QUALITY, exifData.jpegQuality);
        builder.set(CaptureRequest.JPEG_THUMBNAIL_QUALITY,
                exifData.thumbnailQuality);

        // Validate request set and get.
        collector.expectEquals(""JPEG thumbnail size request set and get should match"",
                thumbnailSize, builder.get(CaptureRequest.JPEG_THUMBNAIL_SIZE));
        collector.expectTrue(""GPS locations request set and get should match."",
                areGpsFieldsEqual(exifData.gpsLocation,
                builder.get(CaptureRequest.JPEG_GPS_LOCATION)));
        collector.expectEquals(""JPEG orientation request set and get should match"",
                exifData.jpegOrientation,
                builder.get(CaptureRequest.JPEG_ORIENTATION));
        collector.expectEquals(""JPEG quality request set and get should match"",
                exifData.jpegQuality, builder.get(CaptureRequest.JPEG_QUALITY));
        collector.expectEquals(""JPEG thumbnail quality request set and get should match"",
                exifData.thumbnailQuality,
                builder.get(CaptureRequest.JPEG_THUMBNAIL_QUALITY));
    }

    /**
     * Simple validation of JPEG"	""	""	"RCS"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.graphics.drawable.shapes.cts.ArcShapeTest"	"testConstructor"	"CtsGraphicsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/graphics/src/android/graphics/drawable/shapes/cts/ArcShapeTest.java"	""	"public void testConstructor() {
        new ArcShape(1f, 5f);

        new ArcShape(0f, 0f);

        new ArcShape(-1f, -1f);
    }"	""	""	"RCS"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.graphics.drawable.shapes.cts.ArcShapeTest"	"testGetSweepAngle"	"CtsGraphicsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/graphics/src/android/graphics/drawable/shapes/cts/ArcShapeTest.java"	""	"public void testGetSweepAngle() {
        ArcShape shape = new ArcShape(100.0f, 360.0f);
        assertEquals(360.0f, shape.getSweepAngle(), 0.0f);
    }"	""	""	"RCS"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.graphics.drawable.shapes.cts.ArcShapeTest"	"testGetStartAngle"	"CtsGraphicsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/graphics/src/android/graphics/drawable/shapes/cts/ArcShapeTest.java"	""	"public void testGetStartAngle() {
        ArcShape shape = new ArcShape(100.0f, 360.0f);
        assertEquals(100.0f, shape.getStartAngle(), 0.0f);
    }"	""	""	"RCS"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.graphics.drawable.shapes.cts.ArcShapeTest"	"testDraw"	"CtsGraphicsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/graphics/src/android/graphics/drawable/shapes/cts/ArcShapeTest.java"	""	"public void testDraw() {
        // draw completely.
        ArcShape arcShape = new ArcShape(0.0f, 360.0f);
        Bitmap bitmap = Bitmap.createBitmap(TEST_WIDTH, TEST_HEIGHT, Config.ARGB_8888);
        Canvas canvas = new Canvas(bitmap);
        Paint paint = new Paint();
        paint.setStyle(Style.FILL);
        paint.setColor(TEST_COLOR_1);
        arcShape.resize(TEST_WIDTH, TEST_HEIGHT);

        arcShape.draw(canvas, paint);
        // check the color at the center of bitmap
        assertEquals(TEST_COLOR_1, bitmap.getPixel(TEST_WIDTH / 2, TEST_HEIGHT / 2));

        final int SQUARE = Math.min(TEST_WIDTH, TEST_HEIGHT);
        paint.setColor(TEST_COLOR_2);
        arcShape = new ArcShape(0.0f, 180.0f);
        arcShape.resize(SQUARE, SQUARE); // half circle
        arcShape.draw(canvas, paint);
        // count number of pixels with TEST_COLOR_2 along diagonal
        int count = 0;
        for (int i = 0; i < SQUARE; i++) {
            if (bitmap.getPixel(i, i) == TEST_COLOR_2) {
                count += 1;
            }
        }
        assertEquals((double) SQUARE / 2 / Math.sqrt(2), count, TOLERANCE);
    }"	""	""	"RCS"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.graphics.drawable.shapes.cts.ArcShapeTest"	"testGetOutline"	"CtsGraphicsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/graphics/src/android/graphics/drawable/shapes/cts/ArcShapeTest.java"	""	"public void testGetOutline() {
        Outline outline = new Outline();
        ArcShape shape;

        // This is a no-op. Just make sure it doesn't crash.
        outline.setEmpty();
        shape = new ArcShape(0.0f, 360.0f);
        shape.getOutline(outline);
        assertTrue(outline.isEmpty());
    }"	""	""	"RCS"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.graphics.drawable.shapes.cts.ArcShapeTest"	"testClone"	"CtsGraphicsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/graphics/src/android/graphics/drawable/shapes/cts/ArcShapeTest.java"	""	"public void testClone() throws Exception {
        ArcShape shape = new ArcShape(0.0f, 360.0f);
        ArcShape clone = shape.clone();
        assertNotNull(clone);
        assertEquals(0.0f, clone.getStartAngle(), 0.0f);
        assertEquals(360.0f, clone.getSweepAngle(), 0.0f);
    }
}"	""	""	"RCS"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.cts.SubscriptionManagerTest"	"isSupported"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/SubscriptionManagerTest.java"	""	"/*
 *.
 */

package android.telephony.cts;

import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_NOT_CONGESTED;
import static android.net.NetworkCapabilities.NET_CAPABILITY_NOT_RESTRICTED;
import static android.net.NetworkCapabilities.NET_CAPABILITY_TEMPORARILY_NOT_METERED;
import static android.net.NetworkCapabilities.TRANSPORT_CELLULAR;
import static android.telephony.TelephonyManager.SET_OPPORTUNISTIC_SUB_SUCCESS;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import android.annotation.Nullable;
import android.app.UiAutomation;
import android.content.pm.PackageManager;
import android.content.res.Resources;
import android.net.ConnectivityManager;
import android.net.ConnectivityManager.NetworkCallback;
import android.net.Network;
import android.net.NetworkCapabilities;
import android.net.NetworkRequest;
import android.net.Uri;
import android.os.Looper;
import android.os.ParcelUuid;
import android.os.PersistableBundle;
import android.telephony.CarrierConfigManager;
import android.telephony.SubscriptionInfo;
import android.telephony.SubscriptionManager;
import android.telephony.SubscriptionPlan;
import android.telephony.TelephonyManager;
import android.telephony.ims.ImsException;
import android.telephony.ims.ImsManager;
import android.telephony.ims.ImsMmTelManager;
import android.telephony.ims.ImsRcsManager;
import android.telephony.ims.RcsUceAdapter;
import android.util.Log;

import androidx.test.InstrumentationRegistry;

import com.android.compatibility.common.util.ShellIdentityUtils;
import com.android.compatibility.common.util.SystemUtil;
import com.android.compatibility.common.util.TestThread;
import com.android.internal.util.ArrayUtils;

import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.time.Period;
import java.time.ZonedDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.UUID;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executor;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Consumer;
import java.util.function.Predicate;
import java.util.stream.Collectors;


public class SubscriptionManagerTest {
    private static final String TAG = ""SubscriptionManagerTest"";
    private static final String MODIFY_PHONE_STATE = ""android.permission.MODIFY_PHONE_STATE"";
    private static final List<Uri> CONTACTS = new ArrayList<>();
    static {
        CONTACTS.add(Uri.fromParts(""tel"", ""+16505551212"", null));
        CONTACTS.add(Uri.fromParts(""tel"", ""+16505552323"", null));
    }

    private int mSubId;
    private int mDefaultVoiceSubId;
    private String mPackageName;
    private SubscriptionManager mSm;

    /**
     * Callback used in testRegisterNetworkCallback that allows caller to block on
     * {@code onAvailable}.
     */
    private static class TestNetworkCallback extends ConnectivityManager.NetworkCallback {
        private final CountDownLatch mAvailableLatch = new CountDownLatch(1);

        public void waitForAvailable() throws InterruptedException {
            assertTrue(""Cellular network did not come up after 5 seconds"",
                    mAvailableLatch.await(5, TimeUnit.SECONDS));
        }

        @Override
        public void onAvailable(Network network) {
            mAvailableLatch.countDown();
        }
    }

    @BeforeClass
    public static void setUpClass() throws Exception {
        if (!isSupported()) return;

        final TestNetworkCallback callback = new TestNetworkCallback();
        final ConnectivityManager cm = InstrumentationRegistry.getContext()
                .getSystemService(ConnectivityManager.class);
        cm.registerNetworkCallback(new NetworkRequest.Builder()
                .addTransportType(TRANSPORT_CELLULAR)
                .addCapability(NET_CAPABILITY_INTERNET)
                .build(), callback);
        try {
            // Wait to get callback for availability of internet
            callback.waitForAvailable();
        } catch (InterruptedException e) {
            fail(""NetworkCallback wait was interrupted."");
        } finally {
            cm.unregisterNetworkCallback(callback);
        }
    }

    @AfterClass
    public static void tearDownClass() throws Exception {
        if (!isSupported()) return;
        TelephonyUtils.flushTelephonyMetrics(InstrumentationRegistry.getInstrumentation());
    }

    @Before
    public void setUp() throws Exception {
        if (!isSupported()) return;

        mSm = InstrumentationRegistry.getContext().getSystemService(SubscriptionManager.class);
        mSubId = SubscriptionManager.getDefaultDataSubscriptionId();
        mDefaultVoiceSubId = SubscriptionManager.getDefaultVoiceSubscriptionId();
        mPackageName = InstrumentationRegistry.getContext().getPackageName();
    }

    /**
     * Correctness check that both {@link PackageManager#FEATURE_TELEPHONY} and
     * {@link NetworkCapabilities#TRANSPORT_CELLULAR} network must both be
     * either defined or undefined; you can't cross the streams.
     */"	""	""	"RCS MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.cts.SubscriptionManagerTest"	"testRestoreAllSimSpecificSettingsFromBackup"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/SubscriptionManagerTest.java"	""	"public void testRestoreAllSimSpecificSettingsFromBackup() throws Exception {
        if (!isSupported()) return;

        int activeDataSubId = ShellIdentityUtils.invokeMethodWithShellPermissions(mSm,
                (sm) -> sm.getActiveDataSubscriptionId());
        assertNotEquals(activeDataSubId, SubscriptionManager.INVALID_SUBSCRIPTION_ID);
        SubscriptionInfo activeSubInfo = ShellIdentityUtils.invokeMethodWithShellPermissions(mSm,
                (sm) -> sm.getActiveSubscriptionInfo(activeDataSubId));
        String isoCountryCode = activeSubInfo.getCountryIso();

        byte[] backupData = ShellIdentityUtils.invokeMethodWithShellPermissions(mSm,
                (sm) -> sm.getAllSimSpecificSettingsForBackup());
        assertTrue(backupData.length > 0);

        PersistableBundle bundle = new PersistableBundle();
        bundle.putBoolean(CarrierConfigManager.KEY_EDITABLE_ENHANCED_4G_LTE_BOOL, true);
        bundle.putBoolean(CarrierConfigManager.KEY_HIDE_ENHANCED_4G_LTE_BOOL, false);
        overrideCarrierConfig(bundle, activeDataSubId);

        // Get the original ims values.
        ImsManager imsManager = InstrumentationRegistry.getContext().getSystemService(
                ImsManager.class);
        ImsMmTelManager mMmTelManager = imsManager.getImsMmTelManager(activeDataSubId);
        boolean isVolteVtEnabledOriginal = ShellIdentityUtils.invokeMethodWithShellPermissions(
                mMmTelManager, (m) -> m.isAdvancedCallingSettingEnabled());
        boolean isVtImsEnabledOriginal = ShellIdentityUtils.invokeMethodWithShellPermissions(
                mMmTelManager, (m) -> m.isVtSettingEnabled());
        boolean isVoWiFiSettingEnabledOriginal =
                ShellIdentityUtils.invokeMethodWithShellPermissions(
                        mMmTelManager, (m) -> m.isVoWiFiSettingEnabled());
        int voWifiModeOriginal = ShellIdentityUtils.invokeMethodWithShellPermissions(
                mMmTelManager, (m) -> m.getVoWiFiModeSetting());
        int voWiFiRoamingModeOriginal = ShellIdentityUtils.invokeMethodWithShellPermissions(
                mMmTelManager, (m) -> m.getVoWiFiRoamingModeSetting());

        // Get the original RcsUce values.
        ImsRcsManager imsRcsManager = imsManager.getImsRcsManager(activeDataSubId);
        RcsUceAdapter rcsUceAdapter = imsRcsManager.getUceAdapter();
        boolean isImsRcsUceEnabledOriginal =
                ShellIdentityUtils.invokeThrowableMethodWithShellPermissions(
                rcsUceAdapter, (a) -> a.isUceSettingEnabled(), ImsException.class,
                android.Manifest.permission.READ_PHONE_STATE);

        //Change values in DB.
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mMmTelManager,
                (m) -> m.setAdvancedCallingSettingEnabled(!isVolteVtEnabledOriginal));
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mMmTelManager,
                (m) -> m.setVtSettingEnabled(!isVtImsEnabledOriginal));
        ShellIdentityUtils.invokeThrowableMethodWithShellPermissionsNoReturn(
                rcsUceAdapter, (a) -> a.setUceSettingEnabled(!isImsRcsUceEnabledOriginal),
                ImsException.class);
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mMmTelManager,
                (m) -> m.setVoWiFiSettingEnabled(!isVoWiFiSettingEnabledOriginal));
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mMmTelManager,
                (m) -> m.setVoWiFiModeSetting((voWifiModeOriginal + 1) % 3));
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mMmTelManager,
                (m) -> m.setVoWiFiRoamingModeSetting((voWiFiRoamingModeOriginal + 1) % 3));

        // Restore back to original values.
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mSm,
                (sm) -> sm.restoreAllSimSpecificSettingsFromBackup(backupData));

        // Get ims values to verify with.
        boolean isVolteVtEnabledAfterRestore = ShellIdentityUtils.invokeMethodWithShellPermissions(
                mMmTelManager, (m) -> m.isAdvancedCallingSettingEnabled());
        boolean isVtImsEnabledAfterRestore = ShellIdentityUtils.invokeMethodWithShellPermissions(
                mMmTelManager, (m) -> m.isVtSettingEnabled());
        boolean isVoWiFiSettingEnabledAfterRestore =
                ShellIdentityUtils.invokeMethodWithShellPermissions(
                        mMmTelManager, (m) -> m.isVoWiFiSettingEnabled());
        int voWifiModeAfterRestore = ShellIdentityUtils.invokeMethodWithShellPermissions(
                mMmTelManager, (m) -> m.getVoWiFiModeSetting());
        int voWiFiRoamingModeAfterRestore = ShellIdentityUtils.invokeMethodWithShellPermissions(
                mMmTelManager, (m) -> m.getVoWiFiRoamingModeSetting());
        // Get RcsUce values to verify with.
        boolean isImsRcsUceEnabledAfterRestore =
                ShellIdentityUtils.invokeThrowableMethodWithShellPermissions(
                        rcsUceAdapter, (a) -> a.isUceSettingEnabled(), ImsException.class,
                        android.Manifest.permission.READ_PHONE_STATE);

        assertEquals(isVolteVtEnabledOriginal, isVolteVtEnabledAfterRestore);
        if (isoCountryCode == null || isoCountryCode.equals(""us"") || isoCountryCode.equals(""ca"")) {
            assertEquals(!isVoWiFiSettingEnabledOriginal, isVoWiFiSettingEnabledAfterRestore);
        } else {
            assertEquals(isVoWiFiSettingEnabledOriginal, isVoWiFiSettingEnabledAfterRestore);
        }
        assertEquals(voWifiModeOriginal, voWifiModeAfterRestore);
        assertEquals(voWiFiRoamingModeOriginal, voWiFiRoamingModeAfterRestore);
        assertEquals(isVtImsEnabledOriginal, isVtImsEnabledAfterRestore);
        assertEquals(isImsRcsUceEnabledOriginal, isImsRcsUceEnabledAfterRestore);

        // restore original carrier config.
        overrideCarrierConfig(null, activeDataSubId);


        try {
            // Check api call will fail without proper permissions.
            mSm.restoreAllSimSpecificSettingsFromBackup(backupData);
            fail(""SecurityException expected"");
        } catch (SecurityException e) {
            // expected
        }
    }"	""	""	"RCS MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.ImsMmTelManagerTest"	"beforeAllTests"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsMmTelManagerTest.java"	""	"/*
 *.
 */

package android.telephony.ims.cts;

import static junit.framework.TestCase.assertEquals;

import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.fail;
import static org.junit.Assume.assumeTrue;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.database.ContentObserver;
import android.net.Uri;
import android.os.Handler;
import android.os.Looper;
import android.os.PersistableBundle;
import android.telephony.AccessNetworkConstants;
import android.telephony.CarrierConfigManager;
import android.telephony.SubscriptionManager;
import android.telephony.ims.ImsException;
import android.telephony.ims.ImsManager;
import android.telephony.ims.ImsMmTelManager;
import android.telephony.ims.ImsStateCallback;
import android.telephony.ims.feature.MmTelFeature;

import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.platform.app.InstrumentationRegistry;

import com.android.compatibility.common.util.ShellIdentityUtils;

import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;

@RunWith(AndroidJUnit4.class)
public class ImsMmTelManagerTest {

    // Copied from CarrierConfigManager, since these keys is inappropriately marked as @hide
    private static final String KEY_CARRIER_VOLTE_OVERRIDE_WFC_PROVISIONING_BOOL =
            ""carrier_volte_override_wfc_provisioning_bool"";
    private static final String KEY_EDITABLE_WFC_MODE_BOOL = ""editable_wfc_mode_bool"";
    private static final String KEY_USE_WFC_HOME_NETWORK_MODE_IN_ROAMING_NETWORK_BOOL =
            ""use_wfc_home_network_mode_in_roaming_network_bool"";
    private static final String KEY_EDITABLE_WFC_ROAMING_MODE_BOOL =
            ""editable_wfc_roaming_mode_bool"";

    private static int sTestSub = SubscriptionManager.INVALID_SUBSCRIPTION_ID;
    private static Handler sHandler;
    private static CarrierConfigReceiver sReceiver;

    private static class CarrierConfigReceiver extends BroadcastReceiver {
        private CountDownLatch mLatch = new CountDownLatch(1);
        private final int mSubId;

        CarrierConfigReceiver(int subId) {
            mSubId = subId;
        }

        @Override
        public void onReceive(Context context, Intent intent) {
            if (CarrierConfigManager.ACTION_CARRIER_CONFIG_CHANGED.equals(intent.getAction())) {
                int subId = intent.getIntExtra(CarrierConfigManager.EXTRA_SUBSCRIPTION_INDEX, -1);
                if (mSubId == subId) {
                    mLatch.countDown();
                }
            }
        }

        void clearQueue() {
            mLatch = new CountDownLatch(1);
        }

        void waitForCarrierConfigChanged() throws Exception {
            mLatch.await(5000, TimeUnit.MILLISECONDS);
        }
    }

    @BeforeClass
    public static void beforeAllTests() {
        // assumeTrue() in @BeforeClass is not supported by our test runner.
        // Resort to the early exit.
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }

        sTestSub = ImsUtils.getPreferredActiveSubId();

        if (Looper.getMainLooper() == null) {
            Looper.prepareMainLooper();
        }
        sHandler = new Handler(Looper.getMainLooper());

        sReceiver = new CarrierConfigReceiver(sTestSub);
        IntentFilter filter = new IntentFilter(CarrierConfigManager.ACTION_CARRIER_CONFIG_CHANGED);
        // ACTION_CARRIER_CONFIG_CHANGED is sticky, so we will get a callback right away.
        getContext().registerReceiver(sReceiver, filter);
    }

    @AfterClass
    public static void afterAllTests() {
        // assumeTrue() in @AfterClass is not supported by our test runner.
        // Resort to the early exit.
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }

        if (sReceiver != null) {
            getContext().unregisterReceiver(sReceiver);
            sReceiver = null;
        }
    }

    @Before
    public void beforeTest() {
        assumeTrue(ImsUtils.shouldTestImsService());

        if (!SubscriptionManager.isValidSubscriptionId(sTestSub)) {
            fail(""This test requires that there is a SIM in the device!"");
        }
    }"	""	""	"MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.ImsMmTelManagerTest"	"testGetVoWiFiSetting_noPermission"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsMmTelManagerTest.java"	""	"public void testGetVoWiFiSetting_noPermission() {
        try {
            ImsManager imsManager = getContext().getSystemService(ImsManager.class);
            ImsMmTelManager mMmTelManager = imsManager.getImsMmTelManager(sTestSub);
            boolean isEnabled = mMmTelManager.isVoWiFiSettingEnabled();
            fail(""Expected SecurityException for missing permissions"");
        } catch (SecurityException ex) {
            /* Expected */
        }
    }

    /**
     * Given the advanced calling setting is editable and not hidden
     * (see {@link CarrierConfigManager#KEY_EDITABLE_ENHANCED_4G_LTE_BOOL}, and
     * {@link CarrierConfigManager#KEY_HIDE_ENHANCED_4G_LTE_BOOL}), set the advanced
     * calling setting and ensure the correct calling setting is returned. Also ensure the
     * ContentObserver is triggered properly.
     */"	""	""	"MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.ImsMmTelManagerTest"	"testAdvancedCallingSetting"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsMmTelManagerTest.java"	""	"public void testAdvancedCallingSetting() throws Exception {
        // Ensure advanced calling setting is editable.
        PersistableBundle bundle = new PersistableBundle();
        bundle.putBoolean(CarrierConfigManager.KEY_EDITABLE_ENHANCED_4G_LTE_BOOL, true);
        bundle.putBoolean(CarrierConfigManager.KEY_HIDE_ENHANCED_4G_LTE_BOOL, false);
        overrideCarrierConfig(bundle);
        // Register Observer
        Uri callingUri = Uri.withAppendedPath(
                SubscriptionManager.ADVANCED_CALLING_ENABLED_CONTENT_URI, """" + sTestSub);
        CountDownLatch contentObservedLatch = new CountDownLatch(1);
        ContentObserver observer = createObserver(callingUri, contentObservedLatch);

        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        ImsMmTelManager mMmTelManager = imsManager.getImsMmTelManager(sTestSub);
        boolean isEnabled = ShellIdentityUtils.invokeMethodWithShellPermissions(mMmTelManager,
                ImsMmTelManager::isAdvancedCallingSettingEnabled);
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mMmTelManager,
                (m) -> m.setAdvancedCallingSettingEnabled(!isEnabled));

        waitForLatch(contentObservedLatch, observer);
        boolean isEnabledResult = ShellIdentityUtils.invokeMethodWithShellPermissions(mMmTelManager,
                ImsMmTelManager::isAdvancedCallingSettingEnabled);
        assertEquals(""isAdvancedCallingSettingEnabled does not reflect the new value set by ""
                        + ""setAdvancedCallingSettingEnabled"", !isEnabled, isEnabledResult);

        // Set back to default
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mMmTelManager,
                (m) -> m.setAdvancedCallingSettingEnabled(isEnabled));
        // restore original carrier config.
        overrideCarrierConfig(null);
    }

    /**
     * Set the VT setting and ensure it is queried successfully. Also ensure the ContentObserver
     * is triggered properly.
     */"	""	""	"MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.ImsMmTelManagerTest"	"testVtSetting"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsMmTelManagerTest.java"	""	"public void testVtSetting() throws Exception {
        // Register Observer
        Uri callingUri = Uri.withAppendedPath(
                SubscriptionManager.VT_ENABLED_CONTENT_URI, """" + sTestSub);
        CountDownLatch contentObservedLatch = new CountDownLatch(1);
        ContentObserver observer = createObserver(callingUri, contentObservedLatch);

        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        ImsMmTelManager mMmTelManager = imsManager.getImsMmTelManager(sTestSub);
        boolean isEnabled = ShellIdentityUtils.invokeMethodWithShellPermissions(mMmTelManager,
                ImsMmTelManager::isVtSettingEnabled);
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mMmTelManager,
                (m) -> m.setVtSettingEnabled(!isEnabled));

        waitForLatch(contentObservedLatch, observer);
        boolean isEnabledResult = ShellIdentityUtils.invokeMethodWithShellPermissions(mMmTelManager,
                ImsMmTelManager::isVtSettingEnabled);
        assertEquals(""isVtSettingEnabled does not match the value set by setVtSettingEnabled"",
                !isEnabled, isEnabledResult);

        // Set back to default
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mMmTelManager,
                (m) -> m.setVtSettingEnabled(isEnabled));
    }

    /**
     * Set the VoWiFi setting and ensure it is queried successfully. Also ensure the ContentObserver
     * is triggered properly.
     */"	""	""	"MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.ImsMmTelManagerTest"	"testVoWiFiSetting"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsMmTelManagerTest.java"	""	"public void testVoWiFiSetting() throws Exception {
        PersistableBundle bundle = new PersistableBundle();
        // Do not worry about provisioning for this test
        bundle.putBoolean(KEY_CARRIER_VOLTE_OVERRIDE_WFC_PROVISIONING_BOOL, false);
        bundle.putBoolean(CarrierConfigManager.KEY_CARRIER_VOLTE_PROVISIONING_REQUIRED_BOOL, false);
        overrideCarrierConfig(bundle);
        // Register Observer
        Uri callingUri = Uri.withAppendedPath(
                SubscriptionManager.WFC_ENABLED_CONTENT_URI, """" + sTestSub);
        CountDownLatch contentObservedLatch = new CountDownLatch(1);
        ContentObserver observer = createObserver(callingUri, contentObservedLatch);

        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        ImsMmTelManager mMmTelManager = imsManager.getImsMmTelManager(sTestSub);

        boolean isEnabled = ShellIdentityUtils.invokeMethodWithShellPermissions(mMmTelManager,
                ImsMmTelManager::isVoWiFiSettingEnabled);
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mMmTelManager,
                (m) -> m.setVoWiFiSettingEnabled(!isEnabled));

        waitForLatch(contentObservedLatch, observer);
        boolean isEnabledResult = ShellIdentityUtils.invokeMethodWithShellPermissions(mMmTelManager,
                ImsMmTelManager::isVoWiFiSettingEnabled);
        assertEquals(""isVoWiFiSettingEnabled did not match value set by setVoWiFiSettingEnabled"",
                !isEnabled, isEnabledResult);

        // Set back to default
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mMmTelManager,
                (m) -> m.setVoWiFiSettingEnabled(isEnabled));
        overrideCarrierConfig(null);
    }

    /**
     * Set the cross SIM setting and ensure it is queried successfully.
     * Also ensure the ContentObserver is triggered properly.
     */"	""	""	"MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.ImsMmTelManagerTest"	"testCrossSIMSetting"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsMmTelManagerTest.java"	""	"public void testCrossSIMSetting() throws Exception {
        PersistableBundle bundle = new PersistableBundle();
        // Do not worry about provisioning for this test
        bundle.putBoolean(KEY_CARRIER_VOLTE_OVERRIDE_WFC_PROVISIONING_BOOL, false);
        bundle.putBoolean(CarrierConfigManager.KEY_CARRIER_VOLTE_PROVISIONING_REQUIRED_BOOL, false);
        overrideCarrierConfig(bundle);
        // Register Observer
        Uri callingUri = Uri.withAppendedPath(
                SubscriptionManager.CROSS_SIM_ENABLED_CONTENT_URI, """" + sTestSub);
        CountDownLatch contentObservedLatch = new CountDownLatch(1);
        ContentObserver observer = createObserver(callingUri, contentObservedLatch);

        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        ImsMmTelManager mMmTelManager = imsManager.getImsMmTelManager(sTestSub);

        boolean isEnabled = ShellIdentityUtils.invokeThrowableMethodWithShellPermissions(
                mMmTelManager, ImsMmTelManager::isCrossSimCallingEnabled, ImsException.class,
                ""android.permission.READ_PRIVILEGED_PHONE_STATE"");
        ShellIdentityUtils.invokeThrowableMethodWithShellPermissionsNoReturn(mMmTelManager,
                (m) -> m.setCrossSimCallingEnabled(!isEnabled),  ImsException.class,
                ""android.permission.MODIFY_PHONE_STATE"");

        waitForLatch(contentObservedLatch, observer);
        boolean isEnabledResult = ShellIdentityUtils.invokeThrowableMethodWithShellPermissions(
                mMmTelManager,
                ImsMmTelManager::isCrossSimCallingEnabled,
                ImsException.class,
                ""android.permission.READ_PRIVILEGED_PHONE_STATE"");
        assertEquals(""isCrossSimCallingEnabled did not match""
                        + ""value set by setCrossSimCallingEnabled"",
                !isEnabled, isEnabledResult);

        // Set back to default
        ShellIdentityUtils.invokeThrowableMethodWithShellPermissionsNoReturn(mMmTelManager,
                (m) -> m.setCrossSimCallingEnabled(isEnabled),
                ImsException.class,
                ""android.permission.MODIFY_PHONE_STATE"");
        overrideCarrierConfig(null);
    }

    /**
     * Set the VoWiFi roaming setting and ensure it is queried successfully. Also ensure the
     * ContentObserver is triggered properly.
     */"	""	""	"MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.ImsMmTelManagerTest"	"testVoWiFiRoamingSetting"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsMmTelManagerTest.java"	""	"public void testVoWiFiRoamingSetting() throws Exception {
        Uri callingUri = Uri.withAppendedPath(
                SubscriptionManager.WFC_ROAMING_ENABLED_CONTENT_URI, """" + sTestSub);
        CountDownLatch contentObservedLatch = new CountDownLatch(1);
        ContentObserver observer = createObserver(callingUri, contentObservedLatch);

        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        ImsMmTelManager mMmTelManager = imsManager.getImsMmTelManager(sTestSub);
        boolean isEnabled = ShellIdentityUtils.invokeMethodWithShellPermissions(mMmTelManager,
                ImsMmTelManager::isVoWiFiRoamingSettingEnabled);
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mMmTelManager,
                (m) -> m.setVoWiFiRoamingSettingEnabled(!isEnabled));

        waitForLatch(contentObservedLatch, observer);
        boolean isEnabledResult = ShellIdentityUtils.invokeMethodWithShellPermissions(mMmTelManager,
                ImsMmTelManager::isVoWiFiRoamingSettingEnabled);
        assertEquals(""isVoWiFiRoamingSettingEnabled result does not match the value set by ""
                + ""setVoWiFiRoamingSettingEnabled"", !isEnabled, isEnabledResult);

        // Set back to default
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mMmTelManager,
                (m) -> m.setVoWiFiRoamingSettingEnabled(isEnabled));
    }

    /**
     * Expect to fail when Set the VoWiFi Mode setting withour proper permission
     */"	""	""	"MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.ImsMmTelManagerTest"	"testGetVoWiFiModeSetting_noPermission"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsMmTelManagerTest.java"	""	"public void testGetVoWiFiModeSetting_noPermission() throws Exception {
        try {
            ImsManager imsManager = getContext().getSystemService(ImsManager.class);
            ImsMmTelManager mMmTelManager = imsManager.getImsMmTelManager(sTestSub);
            int oldMode = mMmTelManager.getVoWiFiModeSetting();
            fail(""Expected SecurityException for missing permissoins"");
        } catch (SecurityException ex) {
            /* Expected */
        }

    }

    /**
     * Expect to fail when Set the VoWiFi Mode setting withour proper permission
     */"	""	""	"MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.ImsMmTelManagerTest"	"testGetVoWiFiRoamingModeSetting_noPermission"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsMmTelManagerTest.java"	""	"public void testGetVoWiFiRoamingModeSetting_noPermission() throws Exception {
        try {
            ImsManager imsManager = getContext().getSystemService(ImsManager.class);
            ImsMmTelManager mMmTelManager = imsManager.getImsMmTelManager(sTestSub);
            int oldMode = mMmTelManager.getVoWiFiRoamingModeSetting();
            fail(""Expected SecurityException for missing permissoins"");
        } catch (SecurityException ex) {
            /* Expected */
        }

    }


    /**
     * Set the VoWiFi Mode setting and ensure the ContentResolver is triggered as well.
     */"	""	""	"MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.ImsMmTelManagerTest"	"testVoWiFiModeSetting"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsMmTelManagerTest.java"	""	"public void testVoWiFiModeSetting() throws Exception {
        PersistableBundle bundle = new PersistableBundle();
        bundle.putBoolean(KEY_EDITABLE_WFC_MODE_BOOL, true);
        overrideCarrierConfig(bundle);
        // Register Observer
        Uri callingUri = Uri.withAppendedPath(
                SubscriptionManager.WFC_MODE_CONTENT_URI, """" + sTestSub);
        CountDownLatch contentObservedLatch = new CountDownLatch(1);
        ContentObserver observer = createObserver(callingUri, contentObservedLatch);

        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        ImsMmTelManager mMmTelManager = imsManager.getImsMmTelManager(sTestSub);
        int oldMode = ShellIdentityUtils.invokeMethodWithShellPermissions(mMmTelManager,
                ImsMmTelManager::getVoWiFiModeSetting);
        // Keep the mode in the bounds 0-2
        int newMode = (oldMode + 1) % 3;
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mMmTelManager,
                (m) -> m.setVoWiFiModeSetting(newMode));

        waitForLatch(contentObservedLatch, observer);
        int newModeResult = ShellIdentityUtils.invokeMethodWithShellPermissions(mMmTelManager,
                ImsMmTelManager::getVoWiFiModeSetting);
        assertEquals(newMode, newModeResult);

        // Set back to default
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mMmTelManager,
                (m) -> m.setVoWiFiModeSetting(oldMode));
        overrideCarrierConfig(null);
    }

    /**
     * Set the VoWiFi Mode setting and ensure the ContentResolver is triggered as well.
     */"	""	""	"MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.ImsMmTelManagerTest"	"testVoWiFiRoamingModeSetting"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsMmTelManagerTest.java"	""	"public void testVoWiFiRoamingModeSetting() throws Exception {
        PersistableBundle bundle = new PersistableBundle();
        // Ensure the WFC roaming mode will be changed properly
        bundle.putBoolean(KEY_USE_WFC_HOME_NETWORK_MODE_IN_ROAMING_NETWORK_BOOL, false);
        bundle.putBoolean(KEY_EDITABLE_WFC_ROAMING_MODE_BOOL, true);
        overrideCarrierConfig(bundle);
        // Register Observer
        Uri callingUri = Uri.withAppendedPath(
                SubscriptionManager.WFC_ROAMING_MODE_CONTENT_URI, """" + sTestSub);
        CountDownLatch contentObservedLatch = new CountDownLatch(1);
        ContentObserver observer = createObserver(callingUri, contentObservedLatch);

        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        ImsMmTelManager mMmTelManager = imsManager.getImsMmTelManager(sTestSub);
        int oldMode = ShellIdentityUtils.invokeMethodWithShellPermissions(mMmTelManager,
                ImsMmTelManager::getVoWiFiRoamingModeSetting);
        // Keep the mode in the bounds 0-2
        int newMode = (oldMode + 1) % 3;
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mMmTelManager,
                (m) -> m.setVoWiFiRoamingModeSetting(newMode));

        waitForLatch(contentObservedLatch, observer);
        int newModeResult = ShellIdentityUtils.invokeMethodWithShellPermissions(mMmTelManager,
                ImsMmTelManager::getVoWiFiRoamingModeSetting);
        assertEquals(""getVoWiFiRoamingModeSetting was not set to value set by""
                + ""setVoWiFiRoamingModeSetting"", newMode, newModeResult);

        // Set back to default
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mMmTelManager,
                (m) -> m.setVoWiFiRoamingModeSetting(oldMode));
        overrideCarrierConfig(null);
    }

    /**
     * Test Permissions on various APIs.
     */"	""	""	"MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.ImsMmTelManagerTest"	"testMethodPermissions"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsMmTelManagerTest.java"	""	"public void testMethodPermissions() throws Exception {
        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        ImsMmTelManager mMmTelManager = imsManager.getImsMmTelManager(sTestSub);
        // setRttCapabilitySetting
        try {
            mMmTelManager.setRttCapabilitySetting(false);
            fail(""setRttCapabilitySetting requires MODIFY_PHONE_STATE permission."");
        } catch (SecurityException e) {
            //expected
        }
        try {
            ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mMmTelManager,
                    (m) -> m.setRttCapabilitySetting(false),
                    ""android.permission.MODIFY_PHONE_STATE"");
        } catch (SecurityException e) {
            fail(""setRttCapabilitySetting requires MODIFY_PHONE_STATE permission."");
        }
        // setVoWiFiNonPersistent
        try {
            mMmTelManager.setVoWiFiNonPersistent(true,
                    ImsMmTelManager.WIFI_MODE_CELLULAR_PREFERRED);
            fail(""setVoWiFiNonPersistent requires MODIFY_PHONE_STATE permission."");
        } catch (SecurityException e) {
            //expected
        }
        try {
            ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mMmTelManager,
                    (m) -> m.setVoWiFiNonPersistent(true,
                            ImsMmTelManager.WIFI_MODE_CELLULAR_PREFERRED),
                    ""android.permission.MODIFY_PHONE_STATE"");
        } catch (SecurityException e) {
            fail(""setVoWiFiNonPersistent requires MODIFY_PHONE_STATE permission."");
        }

        try {
            mMmTelManager.isVtSettingEnabled();
            fail(""isVtSettingEnabled requires READ_PRECISE_PHONE_STATE permission."");
        } catch (SecurityException e) {
            //expected
        }

        try {
            mMmTelManager.isAdvancedCallingSettingEnabled();
            fail(""isAdvancedCallingSettingEnabled requires READ_PRECISE_PHONE_STATE."");
        } catch (SecurityException e) {
            //expected
        }

        try {
            mMmTelManager.isVoWiFiRoamingSettingEnabled();
            fail(""isVoWiFiRoamingSettingEnabled requires READ_PRECISE_PHONE_STATE permission."");
        } catch (SecurityException e) {
            //expected
        }

        try {
            mMmTelManager.isVoWiFiSettingEnabled();
            fail(""isVoWiFiSettingEnabled requires READ_PRECISE_PHONE_STATE permission."");
        } catch (SecurityException e) {
            //expected
        }

        try {
            mMmTelManager.isTtyOverVolteEnabled();
            fail(""isTtyOverVolteEnabled requires READ_PRIVILEGED_PHONE_STATE permission."");
        } catch (SecurityException e) {
            //expected
        }
        try {
            mMmTelManager.isSupported(MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VOICE,
                    AccessNetworkConstants.TRANSPORT_TYPE_WWAN, Runnable::run, (result) -> { });
            fail(""isSupported requires READ_PRIVILEGED_PHONE_STATE permission."");
        } catch (SecurityException e) {
            //expected
        }
        try {
            mMmTelManager.getRegistrationState(Runnable::run, (result) -> { });
            fail(""getRegistrationState requires READ_PRECISE_PHONE_STATE permission."");
        } catch (SecurityException e) {
            //expected
        }
        try {
            mMmTelManager.getRegistrationTransportType(Runnable::run, (result) -> { });
            fail(""getRegistrationTransportType requires READ_PRIVILEGED_PHONE_STATE permission."");
        } catch (SecurityException e) {
            //expected
        }

        try {
            mMmTelManager.isSupported(MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VOICE,
                    AccessNetworkConstants.TRANSPORT_TYPE_WWAN, Runnable::run, (result) -> { });
            fail(""isSupported requires READ_PRIVILEGED_PHONE_STATE permission."");
        } catch (SecurityException e) {
            //expected
        }

        try {
            ShellIdentityUtils.invokeMethodWithShellPermissions(mMmTelManager,
                    ImsMmTelManager::isTtyOverVolteEnabled,
                    ""android.permission.READ_PRIVILEGED_PHONE_STATE"");
        } catch (SecurityException e) {
            fail(""isTtyOverVolteEnabled requires READ_PRIVILEGED_PHONE_STATE permission."");
        }
        try {
            LinkedBlockingQueue<Boolean> resultQueue = new LinkedBlockingQueue<>(1);
            ShellIdentityUtils.invokeThrowableMethodWithShellPermissionsNoReturn(mMmTelManager,
                    (m) -> m.isSupported(MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VOICE,
                            AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
                            // Run on the binder thread.
                            Runnable::run,
                            resultQueue::offer), ImsException.class,
                    ""android.permission.READ_PRIVILEGED_PHONE_STATE"");
            assertNotNull(resultQueue.poll(ImsUtils.TEST_TIMEOUT_MS, TimeUnit.MILLISECONDS));
        } catch (SecurityException e) {
            fail(""isSupported requires READ_PRIVILEGED_PHONE_STATE permission."");
        }
        try {
            LinkedBlockingQueue<Integer> resultQueue = new LinkedBlockingQueue<>(1);
            ShellIdentityUtils.invokeThrowableMethodWithShellPermissionsNoReturn(mMmTelManager,
                    (m) -> m.getRegistrationState(Runnable::run, resultQueue::offer),
                    ImsException.class, ""android.permission.READ_PRIVILEGED_PHONE_STATE"");
            assertNotNull(resultQueue.poll(ImsUtils.TEST_TIMEOUT_MS, TimeUnit.MILLISECONDS));
        } catch (SecurityException e) {
            fail(""getRegistrationState requires READ_PRIVILEGED_PHONE_STATE permission."");
        }
        try {
            LinkedBlockingQueue<Integer> resultQueue = new LinkedBlockingQueue<>(1);
            ShellIdentityUtils.invokeThrowableMethodWithShellPermissionsNoReturn(mMmTelManager,
                    (m) -> m.getRegistrationTransportType(Runnable::run, resultQueue::offer),
                    ImsException.class, ""android.permission.READ_PRIVILEGED_PHONE_STATE"");
            assertNotNull(resultQueue.poll(ImsUtils.TEST_TIMEOUT_MS, TimeUnit.MILLISECONDS));
        } catch (SecurityException e) {
            fail(""getRegistrationTransportType requires READ_PRIVILEGED_PHONE_STATE permission."");
        }

        ImsStateCallback callback = new ImsStateCallback() {
            @Override
            public void onUnavailable(int reason) { }
            @Override
            public void onAvailable() { }
            @Override
            public void onError() { }
        };

        try {
            mMmTelManager.registerImsStateCallback(Runnable::run, callback);
            fail(""registerImsStateCallback requires READ_PRECISE_PHONE_STATE or ""
                    + ""READ_PRIVILEGED_PHONE_STATE permission."");
        } catch (SecurityException e) {
            //expected
        } catch (ImsException ie) {
            fail(""registerImsStateCallback requires READ_PRECISE_PHONE_STATE or ""
                    + ""READ_PRIVILEGED_PHONE_STATE permission."");
        }

        try {
            ShellIdentityUtils.invokeThrowableMethodWithShellPermissionsNoReturn(mMmTelManager,
                    m -> m.registerImsStateCallback(Runnable::run, callback),
                    ImsException.class, ""android.permission.READ_PRECISE_PHONE_STATE"");
        } catch (SecurityException e) {
            fail(""registerImsStateCallback requires READ_PRECISE_PHONE_STATE permission."");
        } catch (ImsException ignore) {
            // don't care, permission check passed
        }

        try {
            mMmTelManager.unregisterImsStateCallback(callback);
        } catch (SecurityException e) {
            fail(""uregisterImsStateCallback requires no permission."");
        }

        try {
            ShellIdentityUtils.invokeThrowableMethodWithShellPermissionsNoReturn(mMmTelManager,
                    m -> m.registerImsStateCallback(Runnable::run, callback),
                    ImsException.class, ""android.permission.READ_PRIVILEGED_PHONE_STATE"");
        } catch (SecurityException e) {
            fail(""registerImsStateCallback requires READ_PRIVILEGED_PHONE_STATE permission."");
        } catch (ImsException ignore) {
            // don't care, permission check passed
        }

        try {
            mMmTelManager.unregisterImsStateCallback(callback);
        } catch (SecurityException e) {
            // unreachable, already passed permission check
            fail(""uregisterImsStateCallback requires no permission."");
        }
    }

    private void overrideCarrierConfig(PersistableBundle bundle) throws Exception {
        CarrierConfigManager carrierConfigManager = getContext().getSystemService(
                CarrierConfigManager.class);
        sReceiver.clearQueue();
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(carrierConfigManager,
                (m) -> m.overrideConfig(sTestSub, bundle));
        sReceiver.waitForCarrierConfigChanged();
    }

    private ContentObserver createObserver(Uri observerUri, CountDownLatch latch) {
        ContentObserver observer = new ContentObserver(sHandler) {
            @Override
            public void onChange(boolean selfChange, Uri uri) {
                if (observerUri.equals(uri)) {
                    latch.countDown();
                }
            }
        };
        getContext().getContentResolver().registerContentObserver(observerUri, true, observer);
        return observer;
    }

    private void waitForLatch(CountDownLatch latch, ContentObserver observer) {
        try {
            // Wait for the ContentObserver to fire signalling the change.
            latch.await(ImsUtils.TEST_TIMEOUT_MS, TimeUnit.MILLISECONDS);
        } catch (InterruptedException e) {
            fail(""Interrupted Exception waiting for latch countdown:"" + e.getMessage());
        } finally {
            getContext().getContentResolver().unregisterContentObserver(observer);
        }
    }

    private static Context getContext() {
        return InstrumentationRegistry.getInstrumentation().getContext();
    }
}"	""	""	"MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.video.cts.VideoEncoderDecoderTest"	"testVp9Other3Perf3840x2160"	"CtsVideoTestCases"	"/home/gpoor/cts-12-source/cts/tests/video/src/android/video/cts/VideoEncoderDecoderTest.java"	""	"public void testVp9Other3Perf3840x2160() throws Exception { perf(VP9, 3840, 2160, OTHER, 3); }

    private boolean isSrcSemiPlanar() {
        return mSrcColorFormat == CodecCapabilities.COLOR_FormatYUV420SemiPlanar;
    }

    private boolean isSrcFlexYUV() {
        return mSrcColorFormat == CodecCapabilities.COLOR_FormatYUV420Flexible;
    }

    private boolean isDstSemiPlanar() {
        return mDstColorFormat == CodecCapabilities.COLOR_FormatYUV420SemiPlanar;
    }

    private boolean isDstFlexYUV() {
        return mDstColorFormat == CodecCapabilities.COLOR_FormatYUV420Flexible;
    }

    private static int getColorFormat(CodecInfo info) {
        if (info.mSupportSemiPlanar) {
            return CodecCapabilities.COLOR_FormatYUV420SemiPlanar;
        } else if (info.mSupportPlanar) {
            return CodecCapabilities.COLOR_FormatYUV420Planar;
        } else {
            // FlexYUV must be supported
            return CodecCapabilities.COLOR_FormatYUV420Flexible;
        }
    }

    private static class RunResult {
        public final int mNumFrames;
        public final double mDurationMs;
        public final double mRmsError;

        RunResult() {
            mNumFrames = 0;
            mDurationMs = Double.NaN;
            mRmsError = Double.NaN;
        }

        RunResult(int numFrames, double durationMs) {
            mNumFrames = numFrames;
            mDurationMs = durationMs;
            mRmsError = Double.NaN;
        }

        RunResult(int numFrames, double durationMs, double rmsError) {
            mNumFrames = numFrames;
            mDurationMs = durationMs;
            mRmsError = rmsError;
        }
    }

    private void doTest(String mimeType, int w, int h, boolean isPerf, boolean isGoog, int ix)
            throws Exception {
        MediaFormat format = MediaFormat.createVideoFormat(mimeType, w, h);
        String[] encoderNames = MediaUtils.getEncoderNames(isGoog, format);
        String kind = isGoog ? ""Google"" : ""non-Google"";
        if (encoderNames.length == 0) {
            MediaUtils.skipTest(""No "" + kind + "" encoders for "" + format);
            return;
        } else if (encoderNames.length <= ix) {
            Log.i(TAG, ""No more "" + kind + "" encoders for "" + format);
            return;
        }

        if (isPerf) {
            mTestConfig.initPerfTest();
        }

        String encoderName = encoderNames[ix];

        CodecInfo infoEnc = CodecInfo.getSupportedFormatInfo(encoderName, mimeType, w, h, MAX_FPS);
        assertNotNull(infoEnc);

        // Skip decoding pass for performance tests as bitstream complexity is not representative
        String[] decoderNames = null;  // no decoding pass required by default
        int codingPasses = 1;  // used for time limit. 1 for encoding pass
        int numRuns = mTestConfig.mNumberOfRepeat;  // used for result array sizing
        if (!isPerf) {
            // consider all decoders for quality tests
            decoderNames = MediaUtils.getDecoderNames(format);
            if (decoderNames.length == 0) {
                MediaUtils.skipTest(""No decoders for "" + format);
                return;
            }
            numRuns *= decoderNames.length; // combine each decoder with the encoder
            codingPasses += decoderNames.length;
        }

        // be a bit conservative
        mTestConfig.mMaxTimeMs = Math.min(
                mTestConfig.mMaxTimeMs, MAX_TEST_TIMEOUT_MS / 5 * 4 / codingPasses
                        / mTestConfig.mNumberOfRepeat);
        // reduce test-run on non-real devices
        if (MediaUtils.onFrankenDevice()) {
            mTestConfig.mMaxTimeMs /= 10;
        }
        Log.i(TAG, ""current ABI is "" + (isPreferredAbi() ? """" : ""not "") + ""a preferred one"");

        mVideoWidth = w;
        mVideoHeight = h;
        mSrcColorFormat = getColorFormat(infoEnc);
        Log.i(TAG, ""Testing video resolution "" + w + ""x"" + h + "": enc format "" + mSrcColorFormat);

        initYUVPlane(w + YUV_PLANE_ADDITIONAL_LENGTH, h + YUV_PLANE_ADDITIONAL_LENGTH);

        // Adjust total number of frames to prevent OOM.
        Runtime rt = Runtime.getRuntime();
        long usedMemory = rt.totalMemory() - rt.freeMemory();
        mTestConfig.mTotalFrames = Math.min(mTestConfig.mTotalFrames,
                (int) (rt.maxMemory() - usedMemory) / 4 * 3 /
                (infoEnc.mBitRate / 8 / infoEnc.mFps + 1));
        Log.i(TAG, ""Total testing frames "" + mTestConfig.mTotalFrames);

        mEncoderFrameTimeUsDiff = new double[numRuns][mTestConfig.mTotalFrames - 1];
        mEncoderFpsResults = new double[numRuns];

        if (decoderNames != null) {
            mDecoderFrameTimeUsDiff = new double[numRuns][mTestConfig.mTotalFrames - 1];
            mDecoderFpsResults = new double[numRuns];
            mTotalFpsResults = new double[numRuns];
            mDecoderRmsErrorResults = new double[numRuns];
        }

        boolean success = true;
        int runIx = 0;
        for (int i = 0; i < mTestConfig.mNumberOfRepeat && success; i++) {
            mCurrentTestRound = runIx;
            format = new MediaFormat();
            format.setString(MediaFormat.KEY_MIME, mimeType);
            format.setInteger(MediaFormat.KEY_BIT_RATE, infoEnc.mBitRate);
            format.setInteger(MediaFormat.KEY_BITRATE_MODE,
                    MediaCodecInfo.EncoderCapabilities.BITRATE_MODE_VBR);
            format.setInteger(MediaFormat.KEY_WIDTH, w);
            format.setInteger(MediaFormat.KEY_HEIGHT, h);
            format.setInteger(MediaFormat.KEY_COLOR_FORMAT, mSrcColorFormat);
            format.setInteger(MediaFormat.KEY_FRAME_RATE, infoEnc.mFps);
            mFrameRate = infoEnc.mFps;
            format.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, KEY_I_FRAME_INTERVAL);

            RunResult encodingResult =
                runEncoder(encoderName, format, mTestConfig.mTotalFrames, i);
            double encodingTime = encodingResult.mDurationMs;
            int framesEncoded = encodingResult.mNumFrames;

            if (decoderNames != null && decoderNames.length > 0) {
                for (String decoderName : decoderNames) {
                    CodecInfo infoDec =
                        CodecInfo.getSupportedFormatInfo(decoderName, mimeType, w, h, MAX_FPS);
                    assertNotNull(infoDec);
                    mDstColorFormat = getColorFormat(infoDec);

                    // re-initialize format for decoder
                    format = new MediaFormat();
                    format.setString(MediaFormat.KEY_MIME, mimeType);
                    format.setInteger(MediaFormat.KEY_WIDTH, w);
                    format.setInteger(MediaFormat.KEY_HEIGHT, h);
                    format.setInteger(MediaFormat.KEY_COLOR_FORMAT, mDstColorFormat);
                    RunResult decoderResult = runDecoder(decoderName, format, i);
                    if (decoderResult == null) {
                        success = false;
                    } else {
                        double decodingTime = decoderResult.mDurationMs;
                        mDecoderRmsErrorResults[runIx] = decoderResult.mRmsError;
                        mEncoderFpsResults[runIx] = framesEncoded / encodingTime;
                        int framesDecoded = decoderResult.mNumFrames;
                        mDecoderFpsResults[runIx] = framesDecoded / decodingTime;
                        if (framesDecoded == framesEncoded) {
                            mTotalFpsResults[runIx] =
                                framesEncoded / (encodingTime + decodingTime);
                        }
                    }
                    ++runIx;
                }
            } else {
                mEncoderFpsResults[runIx] = mTestConfig.mTotalFrames / encodingTime;
                ++runIx;
            }

            // clear things for re-start
            mEncodedOutputBuffer.clear();
            // it will be good to clean everything to make every run the same.
            System.gc();
        }

        // log results before verification
        double[] measuredFps = new double[numRuns];
        if (isPerf) {
            for (int i = 0; i < numRuns; i++) {
                measuredFps[i] = logPerformanceResults(encoderName, i);
            }
        }
        if (mTestConfig.mTestPixels && decoderNames != null) {
            logQualityResults(mimeType, encoderName, decoderNames);
            for (int i = 0; i < numRuns; i++) {
                // make sure that rms error is not too big for all runs
                if (mDecoderRmsErrorResults[i] >= mRmsErrorMargin) {
                    fail(""rms error is bigger than the limit ""
                            + Arrays.toString(mDecoderRmsErrorResults) + "" vs "" + mRmsErrorMargin);
                }
            }
        }

        if (isPerf) {
            String error = MediaPerfUtils.verifyAchievableFrameRates(
                    encoderName, mimeType, w, h, measuredFps);
            // Performance numbers only make sense on real devices, so skip on non-real devices
            //
            // Also ignore verification on non-preferred ABIs due to the possibility of
            // this being emulated. On some CPU-s 32-bit mode is emulated using big cores
            // that results in the SW codecs also running much faster (perhaps they are
            // scheduled for the big cores as well)
            // TODO: still verify lower bound.
            if ((MediaUtils.onFrankenDevice() || (infoEnc.mIsSoftware && !isPreferredAbi()))
                    && error != null) {
                // ensure there is data, but don't insist that it is correct
                assertFalse(error, error.startsWith(""Failed to get ""));
            } else {
                assertNull(error, error);
            }
        }
        assertTrue(success);
    }

    private void logQualityResults(String mimeType, String encoderName, String[] decoderNames) {
        String streamName = ""video_encoder_decoder_quality"";
        DeviceReportLog log = new DeviceReportLog(REPORT_LOG_NAME, streamName);
        log.addValue(""encoder_name"", encoderName, ResultType.NEUTRAL, ResultUnit.NONE);
        log.addValues(""decoder_names"", Arrays.asList(decoderNames), ResultType.NEUTRAL, ResultUnit.NONE);
        log.addValue(""mime_type"", mimeType, ResultType.NEUTRAL, ResultUnit.NONE);
        log.addValue(""width"", mVideoWidth, ResultType.NEUTRAL, ResultUnit.NONE);
        log.addValue(""height"", mVideoHeight, ResultType.NEUTRAL, ResultUnit.NONE);
        log.addValues(""encoder_fps"", mEncoderFpsResults, ResultType.HIGHER_BETTER,
                ResultUnit.FPS);
        log.addValues(""rms_error"", mDecoderRmsErrorResults, ResultType.LOWER_BETTER,
                ResultUnit.NONE);
        log.addValues(""decoder_fps"", mDecoderFpsResults, ResultType.HIGHER_BETTER,
                ResultUnit.FPS);
        log.addValues(""encoder_decoder_fps"", mTotalFpsResults, ResultType.HIGHER_BETTER,
                ResultUnit.FPS);
        log.addValue(""encoder_average_fps"", Stat.getAverage(mEncoderFpsResults),
                ResultType.HIGHER_BETTER, ResultUnit.FPS);
        log.addValue(""decoder_average_fps"", Stat.getAverage(mDecoderFpsResults),
                ResultType.HIGHER_BETTER, ResultUnit.FPS);
        log.setSummary(""encoder_decoder_average_fps"", Stat.getAverage(mTotalFpsResults),
                ResultType.HIGHER_BETTER, ResultUnit.FPS);
        log.submit(getInstrumentation());
    }

    private double logPerformanceResults(String encoderName, int round) {
        String streamName = ""video_encoder_performance"";
        DeviceReportLog log = new DeviceReportLog(REPORT_LOG_NAME, streamName);
        String message = MediaPerfUtils.addPerformanceHeadersToLog(
                log, ""encoder stats:"", round, encoderName,
                mEncConfigFormat, mEncInputFormat, mEncOutputFormat);
        double[] frameTimeUsDiff = mEncoderFrameTimeUsDiff[round];
        double fps = MediaPerfUtils.addPerformanceStatsToLog(
                log, new MediaUtils.Stats(frameTimeUsDiff), message);

        if (mTestConfig.mReportFrameTime) {
            double[] msDiff = new double[frameTimeUsDiff.length];
            double nowUs = 0, lastMs = 0;
            for (int i = 0; i < frameTimeUsDiff.length; ++i) {
                nowUs += frameTimeUsDiff[i];
                double nowMs = Math.round(nowUs) / 1000.;
                msDiff[i] = Math.round((nowMs - lastMs) * 1000) / 1000.;
                lastMs = nowMs;
            }
            log.addValues(""encoder_raw_diff"", msDiff, ResultType.NEUTRAL, ResultUnit.MS);
        }

        log.submit(getInstrumentation());
        return fps;
    }

    /**
     * run encoder benchmarking
     * @param encoderName encoder name
     * @param format format of media to encode
     * @param totalFrames total number of frames to encode
     * @return time taken in ms to encode the frames. This does not include initialization time.
     */
    private RunResult runEncoder(
            String encoderName, MediaFormat format, int totalFrames, int runId) {
        MediaCodec codec = null;
        try {
            codec = MediaCodec.createByCodecName(encoderName);
            mEncConfigFormat = format;
            codec.configure(
                    format,
                    null /* surface */,
                    null /* crypto */,
                    MediaCodec.CONFIGURE_FLAG_ENCODE);
        } catch (IllegalStateException e) {
            Log.e(TAG, ""codec '"" + encoderName + ""' failed configuration."");
            codec.release();
            assertTrue(""codec '"" + encoderName + ""' failed configuration."", false);
        } catch (IOException | NullPointerException e) {
            Log.i(TAG, ""could not find codec for "" + format);
            return new RunResult();
        }
        codec.start();
        mEncInputFormat = codec.getInputFormat();
        ByteBuffer[] codecOutputBuffers = codec.getOutputBuffers();
        MediaFormat inputFormat = codec.getInputFormat();
        mVideoStride = inputFormat.containsKey(MediaFormat.KEY_STRIDE)
                ? inputFormat.getInteger(MediaFormat.KEY_STRIDE)
                : inputFormat.getInteger(MediaFormat.KEY_WIDTH);
        mVideoVStride = inputFormat.containsKey(MediaFormat.KEY_SLICE_HEIGHT)
                ? inputFormat.getInteger(MediaFormat.KEY_SLICE_HEIGHT)
                : inputFormat.getInteger(MediaFormat.KEY_HEIGHT);

        int numBytesSubmitted = 0;
        int numBytesDequeued = 0;
        int inFramesCount = 0;
        int outFramesCount = 0;
        long lastOutputTimeUs = 0;
        long start = System.currentTimeMillis();
        while (true) {
            int index;

            if (inFramesCount < totalFrames) {
                index = codec.dequeueInputBuffer(VIDEO_CODEC_WAIT_TIME_US /* timeoutUs */);
                if (index != MediaCodec.INFO_TRY_AGAIN_LATER) {
                    int size;
                    long elapsedMs = System.currentTimeMillis() - start;
                    boolean eos = (inFramesCount == totalFrames - 1
                            || elapsedMs > mTestConfig.mMaxTimeMs
                            || (elapsedMs > mTestConfig.mMinTimeMs
                                    && inFramesCount > mTestConfig.mMinNumFrames));

                    // when encoder only supports flexYUV, use Image only; otherwise,
                    // use ByteBuffer & Image each on half of the frames to test both
                    if (isSrcFlexYUV() || inFramesCount % 2 == 0) {
                        Image image = codec.getInputImage(index);
                        // image should always be available
                        assertTrue(image != null);
                        size = queueInputImageEncoder(
                                codec, image, index, inFramesCount,
                                eos ? MediaCodec.BUFFER_FLAG_END_OF_STREAM : 0, runId);
                    } else {
                        ByteBuffer buffer = codec.getInputBuffer(index);
                        size = queueInputBufferEncoder(
                                codec, buffer, index, inFramesCount,
                                eos ? MediaCodec.BUFFER_FLAG_END_OF_STREAM : 0, runId);
                    }
                    inFramesCount++;
                    numBytesSubmitted += size;
                    if (VERBOSE) {
                        Log.d(TAG, ""queued "" + size + "" bytes of input data, frame "" +
                                (inFramesCount - 1));
                    }
                }
            }
            MediaCodec.BufferInfo info = new MediaCodec.BufferInfo();
            index = codec.dequeueOutputBuffer(info, VIDEO_CODEC_WAIT_TIME_US /* timeoutUs */);
            if (index == MediaCodec.INFO_TRY_AGAIN_LATER) {
            } else if (index == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {
                mEncOutputFormat = codec.getOutputFormat();
            } else if (index == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {
                codecOutputBuffers = codec.getOutputBuffers();
            } else if (index >= 0) {
                long nowUs = (System.nanoTime() + 500) / 1000;
                dequeueOutputBufferEncoder(codec, codecOutputBuffers, index, info);
                if ((info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) == 0) {
                    int pos = outFramesCount - 1;
                    if (pos >= 0 && pos < mEncoderFrameTimeUsDiff[mCurrentTestRound].length) {
                        mEncoderFrameTimeUsDiff[mCurrentTestRound][pos] = nowUs - lastOutputTimeUs;
                    }
                    lastOutputTimeUs = nowUs;

                    numBytesDequeued += info.size;
                    ++outFramesCount;
                }
                if ((info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {
                    if (VERBOSE) {
                        Log.d(TAG, ""dequeued output EOS."");
                    }
                    break;
                }
                if (VERBOSE) {
                    Log.d(TAG, ""dequeued "" + info.size + "" bytes of output data."");
                }
            }
        }
        long finish = System.currentTimeMillis();
        int validDataNum = Math.min(mEncodedOutputBuffer.size() - 1,
                mEncoderFrameTimeUsDiff[mCurrentTestRound].length);
        mEncoderFrameTimeUsDiff[mCurrentTestRound] =
                Arrays.copyOf(mEncoderFrameTimeUsDiff[mCurrentTestRound], validDataNum);
        if (VERBOSE) {
            Log.d(TAG, ""queued a total of "" + numBytesSubmitted + ""bytes, ""
                    + ""dequeued "" + numBytesDequeued + "" bytes."");
        }
        codec.stop();
        codec.release();
        codec = null;

        mEncOutputFormat.setInteger(MediaFormat.KEY_BIT_RATE,
                format.getInteger(MediaFormat.KEY_BIT_RATE));
        mEncOutputFormat.setInteger(MediaFormat.KEY_FRAME_RATE,
                format.getInteger(MediaFormat.KEY_FRAME_RATE));
        if (outFramesCount > 0) {
            mEncOutputFormat.setInteger(
                    ""actual-bitrate"",
                    (int)(numBytesDequeued * 8. * format.getInteger(MediaFormat.KEY_FRAME_RATE)
                            / outFramesCount));
        }
        return new RunResult(outFramesCount, (finish - start) / 1000.);
    }

    /**
     * Fills input buffer for encoder from YUV buffers.
     * @return size of enqueued data.
     */
    private int queueInputBufferEncoder(
            MediaCodec codec, ByteBuffer buffer, int index, int frameCount, int flags, int runId) {
        buffer.clear();

        Point origin = getOrigin(frameCount, runId);
        // Y color first
        int srcOffsetY = origin.x + origin.y * mBufferWidth;
        final byte[] yBuffer = mYBuffer.array();
        for (int i = 0; i < mVideoHeight; i++) {
            buffer.position(i * mVideoStride);
            buffer.put(yBuffer, srcOffsetY, mVideoWidth);
            srcOffsetY += mBufferWidth;
        }
        if (isSrcSemiPlanar()) {
            int srcOffsetU = origin.y / 2 * mBufferWidth + origin.x / 2 * 2;
            final byte[] uvBuffer = mUVBuffer.array();
            for (int i = 0; i < mVideoHeight / 2; i++) {
                buffer.position(mVideoVStride * mVideoStride + i * mVideoStride);
                buffer.put(uvBuffer, srcOffsetU, mVideoWidth);
                srcOffsetU += mBufferWidth;
            }
        } else {
            int srcOffsetU = origin.y / 2 * mBufferWidth / 2 + origin.x / 2;
            int srcOffsetV = srcOffsetU + mBufferWidth / 2 * mBufferHeight / 2;
            final byte[] uvBuffer = mUVBuffer.array();
            for (int i = 0; i < mVideoHeight / 2; i++) { //U only
                buffer.position(mVideoVStride * mVideoStride + i * mVideoStride / 2);
                buffer.put(uvBuffer, srcOffsetU, mVideoWidth / 2);
                srcOffsetU += mBufferWidth / 2;
            }
            for (int i = 0; i < mVideoHeight / 2; i++) { //V only
                buffer.position(mVideoVStride * mVideoStride * 5 / 4 + i * mVideoStride / 2);
                buffer.put(uvBuffer, srcOffsetV, mVideoWidth / 2);
                srcOffsetV += mBufferWidth / 2;
            }
        }
        // submit till end of the data
        int size = buffer.position();
        long ptsUsec = computePresentationTime(frameCount);

        codec.queueInputBuffer(index, 0 /* offset */, size, ptsUsec /* timeUs */, flags);
        if (VERBOSE && (frameCount == 0)) {
            printByteArray(""Y "", mYBuffer.array(), 0, 20);
            printByteArray(""UV "", mUVBuffer.array(), 0, 20);
            printByteArray(""UV "", mUVBuffer.array(), mBufferWidth * 60, 20);
        }
        return size;
    }

    /**
     * Fills input image for encoder from YUV buffers.
     * @return size of enqueued data.
     */
    private int queueInputImageEncoder(
            MediaCodec codec, Image image, int index, int frameCount, int flags, int runId) {
        assertTrue(image.getFormat() == ImageFormat.YUV_420_888);


        Point origin = getOrigin(frameCount, runId);

        // Y color first
        CodecImage srcImage = new YUVImage(
                origin,
                mVideoWidth, mVideoHeight,
                mBufferWidth, mBufferHeight,
                isSrcSemiPlanar(),
                mYDirectBuffer, mUVDirectBuffer);

        CodecUtils.copyFlexYUVImage(image, srcImage);

        int size = mVideoHeight * mVideoWidth * 3 / 2;
        long ptsUsec = computePresentationTime(frameCount);

        codec.queueInputBuffer(index, 0 /* offset */, size, ptsUsec /* timeUs */, flags);
        if (VERBOSE && (frameCount == 0)) {
            printByteArray(""Y "", mYBuffer.array(), 0, 20);
            printByteArray(""UV "", mUVBuffer.array(), 0, 20);
            printByteArray(""UV "", mUVBuffer.array(), mBufferWidth * 60, 20);
        }
        return size;
    }

    /**
     * Dequeue encoded data from output buffer and store for later usage.
     */
    private void dequeueOutputBufferEncoder(
            MediaCodec codec, ByteBuffer[] outputBuffers,
            int index, MediaCodec.BufferInfo info) {
        ByteBuffer output = outputBuffers[index];
        int l = info.size;
        ByteBuffer copied = ByteBuffer.allocate(l);
        output.get(copied.array(), 0, l);
        BufferInfo savedInfo = new BufferInfo();
        savedInfo.set(0, l, info.presentationTimeUs, info.flags);
        mEncodedOutputBuffer.addLast(Pair.create(copied, savedInfo));
        codec.releaseOutputBuffer(index, false /* render */);
    }

    /**
     * run decoder benchmarking with encoded stream stored from encoding phase
     * @param decoderName decoder name
     * @param format format of media to decode
     * @return returns length-2 array with 0: time for decoding, 1 : rms error of pixels
     */
    private RunResult runDecoder(String decoderName, MediaFormat format, int runId) {
        MediaCodec codec = null;
        try {
            codec = MediaCodec.createByCodecName(decoderName);
        } catch (IOException | NullPointerException e) {
            Log.i(TAG, ""could not find decoder for "" + format);
            return null;
        }
        codec.configure(format, null /* surface */, null /* crypto */, 0 /* flags */);
        codec.start();
        ByteBuffer[] codecInputBuffers = codec.getInputBuffers();

        double totalErrorSquared = 0;

        MediaCodec.BufferInfo info = new MediaCodec.BufferInfo();
        boolean sawOutputEOS = false;
        int inputLeft = mEncodedOutputBuffer.size();
        int inputBufferCount = 0;
        int outFrameCount = 0;
        YUVValue expected = new YUVValue();
        YUVValue decoded = new YUVValue();
        long lastOutputTimeUs = 0;
        long start = System.currentTimeMillis();
        while (!sawOutputEOS) {
            if (inputLeft > 0) {
                int inputBufIndex = codec.dequeueInputBuffer(VIDEO_CODEC_WAIT_TIME_US);

                if (inputBufIndex >= 0) {
                    ByteBuffer dstBuf = codecInputBuffers[inputBufIndex];
                    dstBuf.clear();
                    ByteBuffer src = mEncodedOutputBuffer.get(inputBufferCount).first;
                    BufferInfo srcInfo = mEncodedOutputBuffer.get(inputBufferCount).second;
                    int writeSize = src.capacity();
                    dstBuf.put(src.array(), 0, writeSize);

                    int flags = srcInfo.flags;
                    if ((System.currentTimeMillis() - start) > mTestConfig.mMaxTimeMs) {
                        flags |= MediaCodec.BUFFER_FLAG_END_OF_STREAM;
                    }

                    codec.queueInputBuffer(
                            inputBufIndex,
                            0 /* offset */,
                            writeSize,
                            srcInfo.presentationTimeUs,
                            flags);
                    inputLeft --;
                    inputBufferCount ++;
                }
            }

            int res = codec.dequeueOutputBuffer(info, VIDEO_CODEC_WAIT_TIME_US);
            if (res >= 0) {
                int outputBufIndex = res;

                // only do YUV compare on EOS frame if the buffer size is none-zero
                if (info.size > 0) {
                    long nowUs = (System.nanoTime() + 500) / 1000;
                    int pos = outFrameCount - 1;
                    if (pos >= 0 && pos < mDecoderFrameTimeUsDiff[mCurrentTestRound].length) {
                        mDecoderFrameTimeUsDiff[mCurrentTestRound][pos] = nowUs - lastOutputTimeUs;
                    }
                    lastOutputTimeUs = nowUs;

                    if (mTestConfig.mTestPixels) {
                        Point origin = getOrigin(outFrameCount, runId);
                        int i;

                        // if decoder supports planar or semiplanar, check output with
                        // ByteBuffer & Image each on half of the points
                        int pixelCheckPerFrame = PIXEL_CHECK_PER_FRAME;
                        if (!isDstFlexYUV()) {
                            pixelCheckPerFrame /= 2;
                            ByteBuffer buf = codec.getOutputBuffer(outputBufIndex);
                            if (VERBOSE && (outFrameCount == 0)) {
                                printByteBuffer(""Y "", buf, 0, 20);
                                printByteBuffer(""UV "", buf, mVideoWidth * mVideoHeight, 20);
                                printByteBuffer(""UV "", buf,
                                        mVideoWidth * mVideoHeight + mVideoWidth * 60, 20);
                            }
                            for (i = 0; i < pixelCheckPerFrame; i++) {
                                int w = mRandom.nextInt(mVideoWidth);
                                int h = mRandom.nextInt(mVideoHeight);
                                getPixelValuesFromYUVBuffers(origin.x, origin.y, w, h, expected);
                                getPixelValuesFromOutputBuffer(buf, w, h, decoded);
                                if (VERBOSE) {
                                    Log.i(TAG, outFrameCount + ""-"" + i + ""- th round: ByteBuffer:""
                                            + "" expected ""
                                            + expected.mY + "","" + expected.mU + "","" + expected.mV
                                            + "" decoded ""
                                            + decoded.mY + "","" + decoded.mU + "","" + decoded.mV);
                                }
                                totalErrorSquared += expected.calcErrorSquared(decoded);
                            }
                        }

                        Image image = codec.getOutputImage(outputBufIndex);
                        assertTrue(image != null);
                        for (i = 0; i < pixelCheckPerFrame; i++) {
                            int w = mRandom.nextInt(mVideoWidth);
                            int h = mRandom.nextInt(mVideoHeight);
                            getPixelValuesFromYUVBuffers(origin.x, origin.y, w, h, expected);
                            getPixelValuesFromImage(image, w, h, decoded);
                            if (VERBOSE) {
                                Log.i(TAG, outFrameCount + ""-"" + i + ""- th round: FlexYUV:""
                                        + "" expcted ""
                                        + expected.mY + "","" + expected.mU + "","" + expected.mV
                                        + "" decoded ""
                                        + decoded.mY + "","" + decoded.mU + "","" + decoded.mV);
                            }
                            totalErrorSquared += expected.calcErrorSquared(decoded);
                        }
                    }
                    outFrameCount++;
                }
                codec.releaseOutputBuffer(outputBufIndex, false /* render */);
                if ((info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {
                    Log.d(TAG, ""saw output EOS."");
                    sawOutputEOS = true;
                }
            } else if (res == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {
                mDecOutputFormat = codec.getOutputFormat();
                Log.d(TAG, ""output format has changed to "" + mDecOutputFormat);
                int colorFormat = mDecOutputFormat.getInteger(MediaFormat.KEY_COLOR_FORMAT);
                if (colorFormat == CodecCapabilities.COLOR_FormatYUV420SemiPlanar
                        || colorFormat == CodecCapabilities.COLOR_FormatYUV420Planar) {
                    mDstColorFormat = colorFormat;
                } else {
                    mDstColorFormat = CodecCapabilities.COLOR_FormatYUV420Flexible;
                    Log.w(TAG, ""output format changed to unsupported one "" +
                            Integer.toHexString(colorFormat) + "", using FlexYUV"");
                }
                mVideoStride = mDecOutputFormat.containsKey(MediaFormat.KEY_STRIDE)
                        ? mDecOutputFormat.getInteger(MediaFormat.KEY_STRIDE)
                        : mDecOutputFormat.getInteger(MediaFormat.KEY_WIDTH);
                mVideoVStride = mDecOutputFormat.containsKey(MediaFormat.KEY_SLICE_HEIGHT)
                        ? mDecOutputFormat.getInteger(MediaFormat.KEY_SLICE_HEIGHT)
                        : mDecOutputFormat.getInteger(MediaFormat.KEY_HEIGHT);
            }
        }
        long finish = System.currentTimeMillis();
        int validDataNum = Math.min(outFrameCount - 1,
                mDecoderFrameTimeUsDiff[mCurrentTestRound].length);
        mDecoderFrameTimeUsDiff[mCurrentTestRound] =
                Arrays.copyOf(mDecoderFrameTimeUsDiff[mCurrentTestRound], validDataNum);
        codec.stop();
        codec.release();
        codec = null;

        // divide by 3 as sum is done for Y, U, V.
        double errorRms = Math.sqrt(totalErrorSquared / PIXEL_CHECK_PER_FRAME / outFrameCount / 3);
        return new RunResult(outFrameCount, (finish - start) / 1000., errorRms);
    }

    /**
     *  returns origin in the absolute frame for given frame count.
     *  The video scene is moving by moving origin per each frame.
     */
    private Point getOrigin(int frameCount, int runId) {
        // Translation is basically:
        //    x = A * sin(B * t) + C * t
        //    y = D * cos(E * t) + F * t
        //    'bouncing' in a [0, length] regions (constrained to [0, length] by mirroring at 0
        //    and length.)
        double x = (1 - Math.sin(frameCount / (7. + (runId % 2)))) * 0.1 + frameCount * 0.005;
        double y = (1 - Math.cos(frameCount / (10. + (runId & ~1))))
                + frameCount * (0.01 + runId / 1000.);

        // At every 32nd or 13th frame out of 32, an additional varying offset is added to
        // produce a jerk.
        if (frameCount % 32 == 0) {
            x += ((frameCount % 64) / 32) + 0.3 + y;
        }
        if (frameCount % 32 == 13) {
            y += ((frameCount % 64) / 32) + 0.6 + x;
        }

        // constrain to region
        int xi = (int)((x % 2) * YUV_PLANE_ADDITIONAL_LENGTH);
        int yi = (int)((y % 2) * YUV_PLANE_ADDITIONAL_LENGTH);
        if (xi > YUV_PLANE_ADDITIONAL_LENGTH) {
            xi = 2 * YUV_PLANE_ADDITIONAL_LENGTH - xi;
        }
        if (yi > YUV_PLANE_ADDITIONAL_LENGTH) {
            yi = 2 * YUV_PLANE_ADDITIONAL_LENGTH - yi;
        }
        return new Point(xi, yi);
    }

    /**
     * initialize reference YUV plane
     * @param w This should be YUV_PLANE_ADDITIONAL_LENGTH pixels bigger than video resolution
     *          to allow movements
     * @param h This should be YUV_PLANE_ADDITIONAL_LENGTH pixels bigger than video resolution
     *          to allow movements
     * @param semiPlanarEnc
     * @param semiPlanarDec
     */
    private void initYUVPlane(int w, int h) {
        int bufferSizeY = w * h;
        mYBuffer = ByteBuffer.allocate(bufferSizeY);
        mUVBuffer = ByteBuffer.allocate(bufferSizeY / 2);
        mYDirectBuffer = ByteBuffer.allocateDirect(bufferSizeY);
        mUVDirectBuffer = ByteBuffer.allocateDirect(bufferSizeY / 2);
        mBufferWidth = w;
        mBufferHeight = h;
        final byte[] yArray = mYBuffer.array();
        final byte[] uvArray = mUVBuffer.array();
        for (int i = 0; i < h; i++) {
            for (int j = 0; j < w; j++) {
                yArray[i * w + j]  = clampY((i + j) & 0xff);
            }
        }
        if (isSrcSemiPlanar()) {
            for (int i = 0; i < h/2; i++) {
                for (int j = 0; j < w/2; j++) {
                    uvArray[i * w + 2 * j]  = (byte) (i & 0xff);
                    uvArray[i * w + 2 * j + 1]  = (byte) (j & 0xff);
                }
            }
        } else { // planar, U first, then V
            int vOffset = bufferSizeY / 4;
            for (int i = 0; i < h/2; i++) {
                for (int j = 0; j < w/2; j++) {
                    uvArray[i * w/2 + j]  = (byte) (i & 0xff);
                    uvArray[i * w/2 + vOffset + j]  = (byte) (j & 0xff);
                }
            }
        }
        mYDirectBuffer.put(yArray);
        mUVDirectBuffer.put(uvArray);
        mYDirectBuffer.rewind();
        mUVDirectBuffer.rewind();
    }

    /**
     * class to store pixel values in YUV
     *
     */
    public class YUVValue {
        public byte mY;
        public byte mU;
        public byte mV;
        public YUVValue() {
        }

        public boolean equalTo(YUVValue other) {
            return (mY == other.mY) && (mU == other.mU) && (mV == other.mV);
        }

        public double calcErrorSquared(YUVValue other) {
            // Java's byte is signed but here we want to calculate difference in unsigned bytes.
            double yDelta = (mY & 0xFF) - (other.mY & 0xFF);
            double uDelta = (mU & 0xFF) - (other.mU & 0xFF);
            double vDelta = (mV & 0xFF) - (other.mV & 0xFF);
            return yDelta * yDelta + uDelta * uDelta + vDelta * vDelta;
        }
    }

    /**
     * Read YUV values from given position (x,y) for given origin (originX, originY)
     * The whole data is already available from YBuffer and UVBuffer.
     * @param result pass the result via this. This is for avoiding creating / destroying too many
     *               instances
     */
    private void getPixelValuesFromYUVBuffers(int originX, int originY, int x, int y,
            YUVValue result) {
        result.mY = mYBuffer.get((originY + y) * mBufferWidth + (originX + x));
        if (isSrcSemiPlanar()) {
            int index = (originY + y) / 2 * mBufferWidth + (originX + x) / 2 * 2;
            //Log.d(TAG, ""YUV "" + originX + "","" + originY + "","" + x + "","" + y + "","" + index);
            result.mU = mUVBuffer.get(index);
            result.mV = mUVBuffer.get(index + 1);
        } else {
            int vOffset = mBufferWidth * mBufferHeight / 4;
            int index = (originY + y) / 2 * mBufferWidth / 2 + (originX + x) / 2;
            result.mU = mUVBuffer.get(index);
            result.mV = mUVBuffer.get(vOffset + index);
        }
    }

    /**
     * Read YUV pixels from decoded output buffer for give (x, y) position
     * Output buffer is composed of Y parts followed by U/V
     * @param result pass the result via this. This is for avoiding creating / destroying too many
     *               instances
     */
    private void getPixelValuesFromOutputBuffer(ByteBuffer buffer, int x, int y, YUVValue result) {
        result.mY = buffer.get(y * mVideoStride + x);
        if (isDstSemiPlanar()) {
            int index = mVideoStride * mVideoVStride + y / 2 * mVideoStride + x / 2 * 2;
            //Log.d(TAG, ""Decoded "" + x + "","" + y + "","" + index);
            result.mU = buffer.get(index);
            result.mV = buffer.get(index + 1);
        } else {
            int vOffset = mVideoStride * mVideoVStride / 4;
            int index = mVideoStride * mVideoVStride + y / 2 * mVideoStride / 2 + x / 2;
            result.mU = buffer.get(index);
            result.mV = buffer.get(index + vOffset);
        }
    }

    private void getPixelValuesFromImage(Image image, int x, int y, YUVValue result) {
        assertTrue(image.getFormat() == ImageFormat.YUV_420_888);

        Plane[] planes = image.getPlanes();
        assertTrue(planes.length == 3);

        result.mY = getPixelFromPlane(planes[0], x, y);
        result.mU = getPixelFromPlane(planes[1], x / 2, y / 2);
        result.mV = getPixelFromPlane(planes[2], x / 2, y / 2);
    }

    private byte getPixelFromPlane(Plane plane, int x, int y) {
        ByteBuffer buf = plane.getBuffer();
        return buf.get(y * plane.getRowStride() + x * plane.getPixelStride());
    }

    /**
     * Y cannot have full range. clamp it to prevent invalid value.
     */
    private byte clampY(int y) {
        if (y < Y_CLAMP_MIN) {
            y = Y_CLAMP_MIN;
        } else if (y > Y_CLAMP_MAX) {
            y = Y_CLAMP_MAX;
        }
        return (byte) (y & 0xff);
    }

    // for debugging
    private void printByteArray(String msg, byte[] data, int offset, int len) {
        StringBuilder builder = new StringBuilder();
        builder.append(msg);
        builder.append("":"");
        for (int i = offset; i < offset + len; i++) {
            builder.append(Integer.toHexString(data[i]));
            builder.append("","");
        }
        builder.deleteCharAt(builder.length() - 1);
        Log.i(TAG, builder.toString());
    }

    // for debugging
    private void printByteBuffer(String msg, ByteBuffer data, int offset, int len) {
        StringBuilder builder = new StringBuilder();
        builder.append(msg);
        builder.append("":"");
        for (int i = offset; i < offset + len; i++) {
            builder.append(Integer.toHexString(data.get(i)));
            builder.append("","");
        }
        builder.deleteCharAt(builder.length() - 1);
        Log.i(TAG, builder.toString());
    }

    /**
     * Generates the presentation time for frame N, in microseconds.
     */
    private long computePresentationTime(int frameIndex) {
        return 132 + frameIndex * 1000000L / mFrameRate;
    }
}"	""	""	"RCS"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.RcsContactUceCapabilityTest"	"testParcelUnparcel"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/RcsContactUceCapabilityTest.java"	""	"public void testParcelUnparcel() {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }

        // Create two presence tuples for testing.
        RcsContactPresenceTuple mmtelTuple = createPresenceMmtelTuple();
        RcsContactPresenceTuple ftTuple = createPresenceFtTuple();

        PresenceBuilder presenceBuilder = new PresenceBuilder(TEST_CONTACT,
                RcsContactUceCapability.SOURCE_TYPE_CACHED,
                RcsContactUceCapability.REQUEST_RESULT_FOUND);
        presenceBuilder.addCapabilityTuple(mmtelTuple);
        presenceBuilder.addCapabilityTuples(Collections.singletonList(ftTuple));

        final RcsContactUceCapability testCapability = presenceBuilder.build();

        // parcel and unparcel
        Parcel infoParceled = Parcel.obtain();
        testCapability.writeToParcel(infoParceled, 0);
        infoParceled.setDataPosition(0);
        RcsContactUceCapability unparceledCapability =
                RcsContactUceCapability.CREATOR.createFromParcel(infoParceled);
        infoParceled.recycle();

        assertEquals(unparceledCapability.getContactUri(), testCapability.getContactUri());
        assertEquals(unparceledCapability.getSourceType(), testCapability.getSourceType());
        assertEquals(unparceledCapability.getRequestResult(), testCapability.getRequestResult());
        assertEquals(unparceledCapability.getCapabilityMechanism(),
                testCapability.getCapabilityMechanism());

        // Verify mmtel tuple
        RcsContactPresenceTuple unparceledMMtelTuple =
                unparceledCapability.getCapabilityTuple(RcsContactPresenceTuple.SERVICE_ID_MMTEL);
        verifyUnparceledTuple(unparceledMMtelTuple, mmtelTuple);

        // Verify File transfer tuple
        RcsContactPresenceTuple unparceledFtTuple =
                unparceledCapability.getCapabilityTuple(RcsContactPresenceTuple.SERVICE_ID_FT);
        verifyUnparceledTuple(unparceledFtTuple, ftTuple);

        // Verify all the tuples from the API getCapabilityTuples
        List<RcsContactPresenceTuple> unparceledTuples = unparceledCapability.getCapabilityTuples();
        assertNotNull(unparceledTuples);
        assertEquals(2, unparceledTuples.size());
        for (RcsContactPresenceTuple unparcelTuple : unparceledTuples) {
            String serverId = unparcelTuple.getServiceId();
            if (RcsContactPresenceTuple.SERVICE_ID_MMTEL.equals(serverId)) {
                verifyUnparceledTuple(unparcelTuple, mmtelTuple);
            } else if (RcsContactPresenceTuple.SERVICE_ID_FT.equals(serverId)) {
                verifyUnparceledTuple(unparcelTuple, ftTuple);
            } else {
                fail(""Invalid service ID: "" + serverId);
            }
        }
    }

    private RcsContactPresenceTuple createPresenceMmtelTuple() {
        ServiceCapabilities.Builder servCapsBuilder = new ServiceCapabilities.Builder(true, true);
        servCapsBuilder.addSupportedDuplexMode(ServiceCapabilities.DUPLEX_MODE_FULL);

        RcsContactPresenceTuple.Builder tupleBuilder = new RcsContactPresenceTuple.Builder(
                RcsContactPresenceTuple.TUPLE_BASIC_STATUS_OPEN,
                RcsContactPresenceTuple.SERVICE_ID_MMTEL, ""1.0"");
        tupleBuilder.setContactUri(TEST_CONTACT)
                .setTime(Instant.now())
                .setServiceDescription(""service description for contact 1"")
                .setServiceCapabilities(servCapsBuilder.build());
        return tupleBuilder.build();
    }

    private RcsContactPresenceTuple createPresenceFtTuple() {
        ServiceCapabilities.Builder servCapsBuilder = new ServiceCapabilities.Builder(true, true);
        servCapsBuilder.addSupportedDuplexMode(ServiceCapabilities.DUPLEX_MODE_FULL);

        RcsContactPresenceTuple.Builder tupleBuilder = new RcsContactPresenceTuple.Builder(
                RcsContactPresenceTuple.TUPLE_BASIC_STATUS_OPEN,
                RcsContactPresenceTuple.SERVICE_ID_FT, ""1.0"");
        tupleBuilder.setContactUri(TEST_CONTACT)
                .setServiceDescription(""service description for contact2"")
                .setServiceCapabilities(servCapsBuilder.build());
        return tupleBuilder.build();
    }

    private void verifyUnparceledTuple(RcsContactPresenceTuple unparceledTuple,
            RcsContactPresenceTuple expectedTuple) {
        assertNotNull(unparceledTuple);
        assertEquals(unparceledTuple.getStatus(), expectedTuple.getStatus());
        assertEquals(unparceledTuple.getServiceId(), expectedTuple.getServiceId());
        assertEquals(unparceledTuple.getServiceDescription(),
                expectedTuple.getServiceDescription());
        assertEquals(unparceledTuple.getServiceVersion(), expectedTuple.getServiceVersion());
        assertEquals(unparceledTuple.getContactUri(), expectedTuple.getContactUri());
        assertEquals(unparceledTuple.getTime(), expectedTuple.getTime());

        ServiceCapabilities unparceledServiceCaps = unparceledTuple.getServiceCapabilities();
        ServiceCapabilities expectedServiceCaps = unparceledTuple.getServiceCapabilities();
        assertNotNull(unparceledServiceCaps);
        assertEquals(unparceledServiceCaps.isAudioCapable(), expectedServiceCaps.isAudioCapable());
        assertEquals(unparceledServiceCaps.isVideoCapable(), expectedServiceCaps.isVideoCapable());

        List<String> unparceledDuplexModes = unparceledServiceCaps.getSupportedDuplexModes();
        List<String> expectedDuplexModes = expectedServiceCaps.getSupportedDuplexModes();
        assertEquals(unparceledDuplexModes.size(), expectedDuplexModes.size());
        assertTrue(unparceledDuplexModes.containsAll(expectedDuplexModes));

        List<String> unparceledUnsupportedModes = unparceledServiceCaps.getUnsupportedDuplexModes();
        List<String> expectedUnsupportedModes = expectedServiceCaps.getUnsupportedDuplexModes();
        assertEquals(unparceledUnsupportedModes.size(), expectedUnsupportedModes.size());
        assertTrue(unparceledUnsupportedModes.containsAll(expectedUnsupportedModes));
    }"	""	""	"RCS MMTEL"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.RcsContactUceCapabilityTest"	"testParcelUnparcelForOptions"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/RcsContactUceCapabilityTest.java"	""	"public void testParcelUnparcelForOptions() {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }

        final Set<String> featureTags = new HashSet<>();
        featureTags.add(FEATURE_TAG_CHAT_IM);
        featureTags.add(FEATURE_TAG_CHAT_SESSION);
        featureTags.add(FEATURE_TAG_FILE_TRANSFER);

        // Create an OptionsBuilder instance through the constructor OptionsBuilder(Uri, int)
        OptionsBuilder optionsBuilder = new OptionsBuilder(TEST_CONTACT,
                RcsContactUceCapability.SOURCE_TYPE_CACHED);
        optionsBuilder.addFeatureTags(featureTags);
        optionsBuilder.addFeatureTag(FEATURE_TAG_POST_CALL);
        optionsBuilder.setRequestResult(RcsContactUceCapability.REQUEST_RESULT_FOUND);
        RcsContactUceCapability testCapability = optionsBuilder.build();

        // parcel and unparcel
        Parcel infoParceled = Parcel.obtain();
        testCapability.writeToParcel(infoParceled, 0);
        infoParceled.setDataPosition(0);
        RcsContactUceCapability unparceledCapability =
                RcsContactUceCapability.CREATOR.createFromParcel(infoParceled);
        infoParceled.recycle();

        // Verify the unparceled capability
        verifyUnparceledCapability(testCapability, unparceledCapability);

        // Create an OptionsBuilder instance through the constructor OptionsBuilder(Uri)
        optionsBuilder = new OptionsBuilder(TEST_CONTACT);
        optionsBuilder.addFeatureTags(featureTags);
        optionsBuilder.addFeatureTag(FEATURE_TAG_POST_CALL);
        optionsBuilder.setRequestResult(RcsContactUceCapability.REQUEST_RESULT_FOUND);
        testCapability = optionsBuilder.build();

        // parcel and unparcel
        infoParceled = Parcel.obtain();
        testCapability.writeToParcel(infoParceled, 0);
        infoParceled.setDataPosition(0);
        unparceledCapability = RcsContactUceCapability.CREATOR.createFromParcel(infoParceled);
        infoParceled.recycle();

        // Verify the unparceled capability
        verifyUnparceledCapability(testCapability, unparceledCapability);
    }

    private void verifyUnparceledCapability(RcsContactUceCapability expectedCap,
            RcsContactUceCapability unparceledCapability) {
        assertEquals(expectedCap.getContactUri(), unparceledCapability.getContactUri());
        assertEquals(expectedCap.getSourceType(), unparceledCapability.getSourceType());
        assertEquals(expectedCap.getRequestResult(), unparceledCapability.getRequestResult());
        assertEquals(expectedCap.getCapabilityMechanism(),
                unparceledCapability.getCapabilityMechanism());

        Set<String> expectedFeatureTags = expectedCap.getFeatureTags();
        Set<String> unparceledFeatureTags = unparceledCapability.getFeatureTags();
        assertEquals(expectedFeatureTags.size(), unparceledFeatureTags.size());
        Iterator<String> expectedFeatureTag = expectedFeatureTags.iterator();
        while (expectedFeatureTag.hasNext()) {
            assertTrue(unparceledFeatureTags.contains(expectedFeatureTag.next()));
        }
    }
}"	""	""	"RCS"	""	""	""	""	""	""	""	""	""	""
"7.4.1  . Telephony"	"7.4.1"	"C-5-1"	"7.4.1/C-5-1"	"07040100.670501"	"""C-5-1] MUST declare the android.hardware.telephony.ims feature flag and provide a complete implementation of the ImsService API for both MMTEL and RCS User Capability Exchange API."""	""	""	"RCS MMTEL android.hardware.telephony.ims"	""	""	""	""	""	""	""	""	"android.telephony.cts.externalimsservice.TestExternalImsService"	"TestFrameworkConnection"	""	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/TestExternalImsServiceApp/src/android/telephony/cts/externalimsservice/TestExternalImsService.java"	""	"public void test/*
 *.
 */

package android.telephony.cts.externalimsservice;

import android.content.Intent;
import android.os.IBinder;
import android.telephony.ims.cts.ImsUtils;
import android.telephony.ims.cts.TestImsService;
import android.telephony.ims.stub.ImsFeatureConfiguration;
import android.util.Log;

/**
 * A test ImsService that is used for GTS Testing. This package is separate from the main test
 * package because we need to have two packages available.
 */

public class TestExternalImsService extends TestImsService {
    private static final String TAG = ""GtsImsTestDeviceImsService"";
    // TODO: Use ImsService.SERVICE_INTERFACE definition when it becomes public.
    private static final String ACTION_BIND_IMS_SERVICE = ""android.telephony.ims.ImsService"";

    private final TestFrameworkConnection mBinder = new TestFrameworkConnection();

    // For local access of this Service.
    public class TestFrameworkConnection extends ITestExternalImsService.Stub {
        public boolean waitForLatchCountdown(int latchIndex) {
            return TestExternalImsService.this.waitForLatchCountdown(latchIndex);
        }

        public void setFeatureConfig(ImsFeatureConfiguration f) {
            TestExternalImsService.this.setFeatureConfig(f);
        }

        public boolean isRcsFeatureCreated() {
            return (getRcsFeature() != null);
        }

        public boolean isMmTelFeatureCreated() {
            return (getMmTelFeature() != null);
        }

        public void resetState() {
            TestExternalImsService.this.resetState();
        }
    }

    @Override
    public IBinder onBind(Intent intent) {
        if (ACTION_BIND_IMS_SERVICE.equals(intent.getAction())) {
            if (ImsUtils.VDBG) {
                Log.i(TAG, ""onBind-Remote"");
            }
            return super.onBind(intent);
        }
        if (ImsUtils.VDBG) {
            Log.i(TAG, ""onBind-Local"");
        }
        return mBinder;
    }
}"	""	""	"RCS MMTEL MMTEL"	""	""	""	""	""	""	""	""	""	""
