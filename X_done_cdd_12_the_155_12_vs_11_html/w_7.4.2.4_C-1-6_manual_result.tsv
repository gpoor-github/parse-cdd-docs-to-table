Section	section_id	req_id	full_key	key_as_number	requirement	Test Availability	search_roots	search_terms	manual_search_terms	not_search_terms	not_files	max_matches	class_defs	methods	modules	protected	class_def	method	module	file_name	matched_files	methods_string	urls	method_text	matched_terms	qualified_method	Annotation?	New Req for S?	New CTS for S?	Comment(internal) e.g. why a test is not possible	CTS Bug Id	CDD Bug Id	Area	Shortened	Test Level
7.4.2.4  . Wi	7.4.2.4	C-1-6	7.4.2.4/C-1-6	07040204.670106	"""C-1-6] MUST support at least the following subset of device provisioning protocols as defined in the Wi-Fi Alliance Passpoint R2: EAP-TTLS authentication and SOAP-XML."""	Test Available	""	EAP passpoint XML TTLS SOAP	""	""	""	""	""	""	""	""	android.net.wifi.passpoint.cts.PasspointConfigurationTest	testSetGetDecoratedIdentityPrefix	CtsWifiTestCases	/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/passpoint/cts/PasspointConfigurationTest.java	""	"public void testSetGetDecoratedIdentityPrefix() throws Exception {
        PasspointConfiguration config = createConfig();
        assertNull(config.getDecoratedIdentityPrefix());
        config.setDecoratedIdentityPrefix(TEST_DECORATED_IDENTITY_PREFIX);
        assertEquals(TEST_DECORATED_IDENTITY_PREFIX, config.getDecoratedIdentityPrefix());

    }

    /**
     * Helper function for generating user credential for testing.
     *
     * @return {@link Credential}
     */
    private static Credential createCredentialWithUserCredential(String username, String password) {
        Credential.UserCredential userCred = new Credential.UserCredential();
        userCred.setUsername(username);
        userCred.setPassword(password);
        userCred.setEapType(EAP_TTLS);
        userCred.setNonEapInnerMethod(""MS-CHAP"");
        return createCredential(userCred, null, null, null, null, FakeKeys.CA_CERT0);
    }

    /**
     * Helper function for generating Credential for testing.
     *
     * @param userCred               Instance of UserCredential
     * @param certCred               Instance of CertificateCredential
     * @param simCred                Instance of SimCredential
     * @param clientCertificateChain Chain of client certificates
     * @param clientPrivateKey       Client private key
     * @param caCerts                CA certificates
     * @return {@link Credential}
     */
    private static Credential createCredential(Credential.UserCredential userCred,
            Credential.CertificateCredential certCred,
            Credential.SimCredential simCred,
            X509Certificate[] clientCertificateChain, PrivateKey clientPrivateKey,
            X509Certificate... caCerts) {
        Credential cred = new Credential();
        cred.setRealm(""realm"");
        cred.setUserCredential(userCred);
        cred.setCertCredential(certCred);
        cred.setSimCredential(simCred);
        cred.setCaCertificate(caCerts[0]);
        cred.setClientCertificateChain(clientCertificateChain);
        cred.setClientPrivateKey(clientPrivateKey);
        return cred;
    }

    /**
     * Helper function for generating certificate credential for testing.
     *
     * @return {@link Credential}
     */
    private static Credential createCredentialWithCertificateCredential(Boolean useCaCert0,
            Boolean useCert0)
            throws NoSuchAlgorithmException, CertificateEncodingException {
        Credential.CertificateCredential certCred = new Credential.CertificateCredential();
        certCred.setCertType(""x509v3"");
        if (useCert0) {
            certCred.setCertSha256Fingerprint(
                    MessageDigest.getInstance(""SHA-256"").digest(FakeKeys.CLIENT_CERT.getEncoded()));
        } else {
            certCred.setCertSha256Fingerprint(MessageDigest.getInstance(""SHA-256"")
                    .digest(FakeKeys.CLIENT_SUITE_B_RSA3072_CERT.getEncoded()));
        }
        return createCredential(null, certCred, null, new X509Certificate[]{FakeKeys.CLIENT_CERT},
                FakeKeys.RSA_KEY1, useCaCert0 ? FakeKeys.CA_CERT0 : FakeKeys.CA_CERT1);
    }

    /**
     * Helper function for creating a {@link PasspointConfiguration} for testing.
     *
     * @return {@link PasspointConfiguration}
     */
    private static PasspointConfiguration createConfig() {
        PasspointConfiguration config = new PasspointConfiguration();
        config.setHomeSp(createHomeSp());
        config.setCredential(createCredential());
        Map<String, byte[]> trustRootCertList = new HashMap<>();
        trustRootCertList.put(""trustRoot.cert1.com"",
                new byte[CERTIFICATE_FINGERPRINT_BYTES]);
        trustRootCertList.put(""trustRoot.cert2.com"",
                new byte[CERTIFICATE_FINGERPRINT_BYTES]);
        return config;
    }

    /**
     * Utility function for creating a {@link android.net.wifi.hotspot2.pps.HomeSp} for testing.
     *
     * @return {@link android.net.wifi.hotspot2.pps.HomeSp}
     */
    private static HomeSp createHomeSp() {
        HomeSp homeSp = new HomeSp();
        homeSp.setFqdn(""fqdn"");
        homeSp.setFriendlyName(""friendly name"");
        homeSp.setRoamingConsortiumOis(new long[]{0x55, 0x66});
        return homeSp;
    }

    /**
     * Utility function for creating a {@link android.net.wifi.hotspot2.pps.Credential} for
     * testing..
     *
     * @return {@link android.net.wifi.hotspot2.pps.Credential}
     */
    private static Credential createCredential() {
        Credential cred = new Credential();
        cred.setRealm(""realm"");
        cred.setUserCredential(null);
        cred.setCertCredential(null);
        cred.setSimCredential(new Credential.SimCredential());
        cred.getSimCredential().setImsi(""1234*"");
        cred.getSimCredential().setEapType(EAP_SIM);
        cred.setCaCertificate(null);
        cred.setClientCertificateChain(null);
        cred.setClientPrivateKey(null);
        return cred;
    }
}"	""	""	EAP passpoint TTLS	""	""	""	""	""	""	""	""	""	""
