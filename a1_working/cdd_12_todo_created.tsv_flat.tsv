"Section"	"section_id"	"req_id"	"full_key"	"key_as_number"	"requirement"	"Test Availability"	"search_roots"	"search_terms"	"manual_search_terms"	"not_search_terms"	"not_files"	"max_matches"	"class_defs"	"methods"	"modules"	"protected"	"Area"	"Shortened"	"Test Level"	"class_def"	"method"	"module"	"class_defs"	"methods"	"modules"	"file_name"	"matched_files"	"methods_string"	"urls"	"method_text"	"matched_terms"	"qualified_method"
"3.2.3.5  Conditional Application Intents"	"3.2.3.5"	"C-2-6"	"3.2.3.5/C-2-6"	""	"""C-2-6] MUST honor the [android.intent.action.SENDTO](https://developer.android.com/reference/android/content/Intent#ACTION_SENDTO) and [android.intent.action.VIEW](https://developer.android.com/reference/android/content/Intent#ACTION_VIEW) intents and provide an activity to send/display SMS messages. """	""	""	"SENDTO ACTION_SENDTO SMS ACTION_VIEW android.intent.action.SENDTO VIEW android.intent.action.VIEW"	""	""	""	""	""	""	""	""	""	""	""	"android.webkit.cts.WebViewTest"	"testWebViewClassLoaderReturnsNonNull"	"CtsWebkitTestCases"	""	""	""	"/home/gpoor/cts-12-source/cts/tests/tests/webkit/src/android/webkit/cts/WebViewTest.java"	""	"public void testWebViewClassLoaderReturnsNonNull() {
        if (!NullWebViewUtils.isWebViewAvailable()) {
            return;
        }

        assertNotNull(WebView.getWebViewClassLoader());
    }
}"	""	""	"VIEW"	""
"2.2.3  Software"	"3.2.3.1"	"H-0-2"	"3.2.3.1/H-0-2"	""	"""[3.2.3.1/H-0-2]*  MUST preload one or more applications or service components with an intent handler, for all the public intent filter patterns defined by the following application intents listed [here](https://developer.android.com/about/versions/11/reference/common-intents-30). *   [[3.2.3.1/H-SR] Are STRONGLY RECOMMENDED to preload an email application which can handle [ACTION_SENDTO](https://developer.android.com/reference/android/content/Intent#ACTION_SENDTO) or [ACTION_SEND](https://developer.android.com/reference/android/content/Intent#ACTION_SEND) or [ACTION_SEND_MULTIPLE](https://developer.android.com/reference/android/content/Intent#ACTION_SEND_MULTIPLE) intents to send an email. *   ["""	""	""	"ACTION_SEND ACTION_SEND_MULTIPLE ACTION_SENDTO RECOMMENDED"	""	""	""	""	""	""	""	""	""	""	""	"android.admin.cts.DevicePolicyManagerTest"	"testSetRecommendedGlobalProxy_failIfNotDeviceOwner"	"CtsAdminTestCases"	""	""	""	"/home/gpoor/cts-12-source/cts/tests/admin/src/android/admin/cts/DevicePolicyManagerTest.java"	""	"public void testSetRecommendedGlobalProxy_failIfNotDeviceOwner() {
        if (!mDeviceAdmin) {
            Log.w(TAG, ""Skipping testSetRecommendedGlobalProxy_failIfNotDeviceOwner"");
            return;
        }
        try {
            mDevicePolicyManager.setRecommendedGlobalProxy(mComponent, null);
            fail(""did not throw expected SecurityException"");
        } catch (SecurityException e) {
            assertDeviceOwnerMessage(e.getMessage());
        }
    }"	""	""	"RECOMMENDED"	""
"7.5.4  Camera API Behavior"	"7.5.4"	"C-0-12"	"7.5.4/C-0-12"	""	"""C-0-12] MUST ensure that the facial appearance is NOT altered, including     but not limited to altering facial geometry, facial skin tone, or facial     skin smoothening for any [`android.hardware.camera2`](https://developer.android.com/reference/android/hardware/camera2/package-summary)     or [`android.hardware.Camera`](https://developer.android.com/reference/android/hardware/Camera)     API. """	""	""	"android.hardware.Camera android.hardware.camera"	""	""	""	""	""	""	""	""	""	""	""	"android.camera.cts.api31test.SPerfClassTest"	"getCameraIdList"	"CtsCameraApi31TestCases"	""	""	""	"/home/gpoor/cts-12-source/cts/tests/camera/api31test/src/android/camera/cts/api31test/SPerfClassTest.java"	""	"public void test/*
 *.
 */

package android.camera.cts.api31test;

import static android.hardware.camera2.cts.CameraTestUtils.*;

import android.content.Context;
import android.graphics.ImageFormat;
import android.hardware.camera2.CameraDevice;
import android.hardware.camera2.CameraManager;
import android.hardware.camera2.CameraCaptureSession;
import android.hardware.camera2.CameraCharacteristics;
import android.hardware.camera2.CaptureFailure;
import android.hardware.camera2.CaptureRequest;
import android.hardware.camera2.cts.CameraTestUtils;
import android.hardware.camera2.cts.CameraTestUtils.SimpleImageReaderListener;
import android.hardware.camera2.cts.helpers.CameraErrorCollector;
import android.hardware.camera2.cts.helpers.StaticMetadata;
import android.hardware.camera2.cts.helpers.StaticMetadata.CheckLevel;
import android.hardware.camera2.params.OutputConfiguration;
import android.hardware.camera2.params.SessionConfiguration;
import android.hardware.camera2.TotalCaptureResult;
import android.media.Image;
import android.media.ImageReader;
import android.os.Handler;
import android.os.HandlerThread;
import android.test.AndroidTestCase;
import android.util.Log;
import android.util.Size;
import android.view.Surface;

import com.android.compatibility.common.util.CddTest;
import com.android.ex.camera2.blocking.BlockingSessionCallback;

import java.util.ArrayList;
import java.util.List;

import org.junit.Test;

import static junit.framework.Assert.*;
import static org.mockito.Mockito.*;

public class SPerfClassTest extends AndroidTestCase {
    private static final String TAG = ""SPerfClassTest"";
    private static final boolean VERBOSE = Log.isLoggable(TAG, Log.VERBOSE);

    private static final Size FULLHD = new Size(1920, 1080);
    private static final Size VGA = new Size(640, 480);
    private static final int CONFIGURE_TIMEOUT = 5000; //ms
    private static final int CAPTURE_TIMEOUT = 1500; //ms

    private CameraManager mCameraManager;
    private String[] mCameraIds;
    private Handler mHandler;
    private HandlerThread mHandlerThread;
    private CameraErrorCollector mCollector;

    @Override
    public void setContext(Context context) {
        super.setContext(context);
        mCameraManager = context.getSystemService(CameraManager.class);
        assertNotNull(""Can't connect to camera manager!"", mCameraManager);
    }

    @Override
    protected void setUp() throws Exception {
        super.setUp();

        mCameraIds = mCameraManager.getCameraIdList();
        assertNotNull(""Camera ids shouldn't be null"", mCameraIds);

        mHandlerThread = new HandlerThread(TAG);
        mHandlerThread.start();
        mHandler = new Handler(mHandlerThread.getLooper());

        mCollector = new CameraErrorCollector();
    }

    @Override
    protected void tearDown() throws Exception {
        mHandlerThread.quitSafely();
        mHandler = null;

        try {
            mCollector.verify();
        } catch (Throwable e) {
            // When new Exception(e) is used, exception info will be printed twice.
            throw new Exception(e.getMessage());
        } finally {
            super.tearDown();
        }
    }

    // Verify primary camera devices's supported JPEG sizes are at least 1080p.
    private void testSPerfClassJpegSizesByCamera(String cameraId) throws Exception {
        boolean isPrimaryRear = CameraTestUtils.isPrimaryRearFacingCamera(
                mCameraManager, cameraId);
        boolean isPrimaryFront = CameraTestUtils.isPrimaryFrontFacingCamera(
                mCameraManager, cameraId);
        if (!isPrimaryRear && !isPrimaryFront) {
            return;
        }

        CameraCharacteristics c = mCameraManager.getCameraCharacteristics(cameraId);
        StaticMetadata staticInfo = new StaticMetadata(c, CheckLevel.ASSERT, mCollector);

        Size[] jpegSizes = staticInfo.getJpegOutputSizesChecked();
        assertTrue(""Primary cameras must support JPEG formats"",
                jpegSizes != null && jpegSizes.length > 0);
        for (Size jpegSize : jpegSizes) {
            mCollector.expectTrue(
                    ""Primary camera's JPEG size must be at least 1080p, but is "" +
                    jpegSize,
                    jpegSize.getWidth() >= FULLHD.getWidth() &&
                    jpegSize.getHeight() >= FULLHD.getHeight());
        }

        CameraDevice camera = null;
        ImageReader jpegTarget = null;
        Image image = null;
        try {
            camera = CameraTestUtils.openCamera(mCameraManager, cameraId,
                    /*listener*/null, mHandler);

            List<OutputConfiguration> outputConfigs = new ArrayList<>();
            SimpleImageReaderListener imageListener = new SimpleImageReaderListener();
            jpegTarget = CameraTestUtils.makeImageReader(VGA,
                    ImageFormat.JPEG, 1 /*maxNumImages*/, imageListener, mHandler);
            Surface jpegSurface = jpegTarget.getSurface();
            outputConfigs.add(new OutputConfiguration(jpegSurface));

            // isSessionConfigurationSupported will return true for JPEG sizes smaller
            // than 1080P, due to framework rouding up to closest supported size (1080p).
            SessionConfigSupport sessionConfigSupport = isSessionConfigSupported(
                    camera, mHandler, outputConfigs, /*inputConfig*/ null,
                    SessionConfiguration.SESSION_REGULAR, true/*defaultSupport*/);
            mCollector.expectTrue(""isSessionConfiguration fails with error"",
                    !sessionConfigSupport.error);
            mCollector.expectTrue(""isSessionConfiguration returns false for JPEG < 1080p"",
                    sessionConfigSupport.configSupported);

            // Session creation for JPEG sizes smaller than 1080p will succeed, and the
            // result JPEG image dimension is rounded up to closest supported size (1080p).
            CaptureRequest.Builder request =
                    camera.createCaptureRequest(CameraDevice.TEMPLATE_STILL_CAPTURE);
            request.addTarget(jpegSurface);


            CameraCaptureSession.StateCallback sessionListener =
                    mock(CameraCaptureSession.StateCallback.class);
            CameraCaptureSession session = configureCameraSessionWithConfig(
                    camera, outputConfigs, sessionListener, mHandler);

            verify(sessionListener, timeout(CONFIGURE_TIMEOUT).atLeastOnce()).
                    onConfigured(any(CameraCaptureSession.class));
            verify(sessionListener, timeout(CONFIGURE_TIMEOUT).atLeastOnce()).
                    onReady(any(CameraCaptureSession.class));
            verify(sessionListener, never()).onConfigureFailed(any(CameraCaptureSession.class));
            verify(sessionListener, never()).onActive(any(CameraCaptureSession.class));
            verify(sessionListener, never()).onClosed(any(CameraCaptureSession.class));

            CameraCaptureSession.CaptureCallback captureListener =
                    mock(CameraCaptureSession.CaptureCallback.class);
            session.capture(request.build(), captureListener, mHandler);

            verify(captureListener, timeout(CAPTURE_TIMEOUT).atLeastOnce()).
                    onCaptureCompleted(any(CameraCaptureSession.class),
                            any(CaptureRequest.class), any(TotalCaptureResult.class));
            verify(captureListener, never()).onCaptureFailed(any(CameraCaptureSession.class),
                    any(CaptureRequest.class), any(CaptureFailure.class));

            image = imageListener.getImage(CAPTURE_TIMEOUT);
            assertNotNull(""Image must be valid"", image);
            assertEquals(""Image format isn't JPEG"", image.getFormat(), ImageFormat.JPEG);

            byte[] data = CameraTestUtils.getDataFromImage(image);
            assertTrue(""Invalid image data"", data != null && data.length > 0);

            CameraTestUtils.validateJpegData(data, FULLHD.getWidth(), FULLHD.getHeight(),
                    null /*filePath*/);
        } finally {
            if (camera != null) {
                camera.close();
            }
            if (jpegTarget != null) {
                jpegTarget.close();
            }
            if (image != null) {
                image.close();
            }
        }
    }

    /**
     * Check camera S Performance class requirement for JPEG sizes.
     */
    @CddTest(requirement=""7.5/H-1-8"")"	""	""	"android.hardware.camera"	""
"7.3.10  Biometric Sensors"	"7.3.10"	"C-4-2"	"7.3.10/C-4-2"	""	"""C-4-2] MUST recognize and honor each parameter name defined as a constant     in the [Authenticators](https://developer.android.com/reference/android/hardware/biometrics/BiometricManager.Authenticators)     class and any combinations thereof.     Conversely, MUST NOT honor or recognize integer constants passed to the     [canAuthenticate(int)](https://developer.android.com/reference/android/hardware/biometrics/BiometricManager#canAuthenticate%28int%29)     and [setAllowedAuthenticators(int)](https://developer.android.com/reference/android/hardware/biometrics/BiometricPrompt.Builder#setAllowedAuthenticators%28int%29)     methods other than those documented as public constants in     [Authenticators](https://developer.android.com/reference/android/hardware/biometrics/BiometricManager.Authenticators)     and any combinations thereof. """	""	""	"BiometricPrompt.Builder canAuthenticate(int) BiometricManager.Authenticators setAllowedAuthenticators(int)"	""	""	""	""	""	""	""	""	""	""	""	"android.hardware.biometrics.cts.BiometricPromptTest"	"onAuthenticationFailed"	"CtsHardwareTestCases"	""	""	""	"/home/gpoor/cts-12-source/cts/tests/tests/hardware/src/android/hardware/biometrics/cts/BiometricPromptTest.java"	""	"public void test/*
 *
 */

package android.hardware.biometrics.cts;

import android.content.pm.PackageManager;
import android.hardware.biometrics.BiometricManager.Authenticators;
import android.hardware.biometrics.BiometricPrompt;
import android.os.CancellationSignal;
import android.os.Handler;
import android.os.Looper;
import android.platform.test.annotations.Presubmit;
import android.test.AndroidTestCase;
import android.text.TextUtils;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executor;
import java.util.concurrent.TimeUnit;

/**
 * Basic test cases for BiometricPrompt
 */
public class BiometricPromptTest extends AndroidTestCase {

    private static final int AWAIT_TIMEOUT_MS = 3000;

    private final Handler mHandler = new Handler(Looper.getMainLooper());
    private final CountDownLatch mLatch = new CountDownLatch(1);

    private int mErrorReceived;

    private final Executor mExecutor = runnable -> mHandler.post(runnable);

    private final BiometricPrompt.AuthenticationCallback mAuthenticationCallback
            = new BiometricPrompt.AuthenticationCallback() {
        @Override
        public void onAuthenticationError(int errorCode, CharSequence errString) {
            mErrorReceived = errorCode;
            mLatch.countDown();
        }

        @Override
        public void onAuthenticationHelp(int helpCode, CharSequence helpString) {}

        @Override
        public void onAuthenticationFailed() {}

        @Override
        public void onAuthenticationSucceeded(BiometricPrompt.AuthenticationResult result) {}
    };

    /**
     * Test that we can try to start fingerprint authentication. It won't actually start since
     * there are no fingers enrolled. Cts-verifier will check the implementation.
     */
    @Presubmit"	""	""	"BiometricManager.Authenticators"	""
"7.1.4.2 Vulkan"	"7.1.4.2"	"C-1-10"	"7.1.4.2/C-1-10"	""	"""C-1-10] MUST pass all Vulkan dEQP Tests in the test lists between     version `132317953` and the version specified in the     `android.software.vulkan.deqp.level` feature flag. """	""	""	"EQP android.software.vulkan.deqp.level"	""	""	""	""	""	""	""	""	""	""	""	"android.midi.cts.MidiEchoTest"	"currentTimeMillis"	"CtsMidiTestCases"	""	""	""	"/home/gpoor/cts-12-source/cts/tests/tests/midi/src/android/midi/cts/MidiEchoTest.java"	""	"public void test/*
 *.
 */

package android.midi.cts;

import android.content.Context;
import android.content.pm.PackageManager;
import android.media.midi.MidiManager;
import android.media.midi.MidiOutputPort;
import android.media.midi.MidiDevice;
import android.media.midi.MidiDevice.MidiConnection;
import android.media.midi.MidiDeviceInfo;
import android.media.midi.MidiDeviceInfo.PortInfo;
import android.media.midi.MidiDeviceStatus;
import android.media.midi.MidiInputPort;
import android.media.midi.MidiReceiver;
import android.media.midi.MidiSender;
import android.os.Bundle;
import android.util.Log;
import android.test.AndroidTestCase;

import com.android.midi.CTSMidiEchoTestService;
import com.android.midi.MidiEchoTestService;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Random;

/**
 * Test MIDI using a virtual MIDI device that echos input to output.
 */
public class MidiEchoTest extends AndroidTestCase {
    private static final String TAG = ""MidiEchoTest"";
    private static final boolean DEBUG = false;

    // I am overloading the timestamp for some tests. It is passed
    // directly through the Echo server unchanged.
    // The high 32-bits has a recognizable value.
    // The low 32-bits can contain data used to identify messages.
    private static final long TIMESTAMP_MARKER = 0x1234567800000000L;
    private static final long TIMESTAMP_MARKER_MASK = 0xFFFFFFFF00000000L;
    private static final long TIMESTAMP_DATA_MASK = 0x00000000FFFFFFFFL;
    private static final long NANOS_PER_MSEC = 1000L * 1000L;

    // On a fast device in 2016, the test fails if timeout is 3 but works if it is 4.
    // So this timeout value is very generous.
    private static final int TIMEOUT_OPEN_MSEC = 1000; // arbitrary
    // On a fast device in 2016, the test fails if timeout is 0 but works if it is 1.
    // So this timeout value is very generous.
    private static final int TIMEOUT_STATUS_MSEC = 500; // arbitrary

    // This is defined in MidiPortImpl.java as the maximum payload that
    // can be sent internally by MidiInputPort in a
    // SOCK_SEQPACKET datagram.
    private static final int MAX_PACKET_DATA_SIZE = 1024 - 9;

    // Store device and ports related to the Echo service.
    static class MidiTestContext {
        MidiDeviceInfo echoInfo;
        MidiDevice echoDevice;
        MidiInputPort echoInputPort;
        MidiOutputPort echoOutputPort;
    }

    // Store complete MIDI message so it can be put in an array.
    static class MidiMessage {
        public final byte[] data;
        public final long timestamp;
        public final long timeReceived;

        MidiMessage(byte[] buffer, int offset, int length, long timestamp) {
            timeReceived = System.nanoTime();
            data = new byte[length];
            System.arraycopy(buffer, offset, data, 0, length);
            this.timestamp = timestamp;
        }
    }

    // Listens for an asynchronous device open and notifies waiting foreground
    // test.
    class MyTestOpenCallback implements MidiManager.OnDeviceOpenedListener {
        MidiDevice mDevice;

        @Override
        public synchronized void onDeviceOpened(MidiDevice device) {
            mDevice = device;
            notifyAll();
        }

        public synchronized MidiDevice waitForOpen(int msec)
                throws InterruptedException {
            long deadline = System.currentTimeMillis() + msec;
            long timeRemaining = msec;
            while (mDevice == null && timeRemaining > 0) {
                wait(timeRemaining);
                timeRemaining = deadline - System.currentTimeMillis();
            }
            return mDevice;
        }
    }

    // Store received messages in an array.
    class MyLoggingReceiver extends MidiReceiver {
        ArrayList<MidiMessage> messages = new ArrayList<MidiMessage>();
        int mByteCount;

        @Override
        public synchronized void onSend(byte[] data, int offset, int count,
                long timestamp) {
            messages.add(new MidiMessage(data, offset, count, timestamp));
            mByteCount += count;
            notifyAll();
        }

        public synchronized int getMessageCount() {
            return messages.size();
        }

        public synchronized int getByteCount() {
            return mByteCount;
        }

        public synchronized MidiMessage getMessage(int index) {
            return messages.get(index);
        }

        /**
         * Wait until count messages have arrived. This is a cumulative total.
         *
         * @param count
         * @param timeoutMs
         * @throws InterruptedException
         */
        public synchronized void waitForMessages(int count, int timeoutMs)
                throws InterruptedException {
            long endTimeMs = System.currentTimeMillis() + timeoutMs + 1;
            long timeToWait = timeoutMs + 1;
            while ((getMessageCount() < count)
                    && (timeToWait > 0)) {
                wait(timeToWait);
                timeToWait = endTimeMs - System.currentTimeMillis();
            }
        }

        /**
         * Wait until count bytes have arrived. This is a cumulative total.
         *
         * @param count
         * @param timeoutMs
         * @throws InterruptedException
         */
        public synchronized void waitForBytes(int count, int timeoutMs)
                throws InterruptedException {
            long endTimeMs = System.currentTimeMillis() + timeoutMs + 1;
            long timeToWait = timeoutMs + 1;
            while ((getByteCount() < count)
                    && (timeToWait > 0)) {
                wait(timeToWait);
                timeToWait = endTimeMs - System.currentTimeMillis();
            }
        }
    }

    @Override
    protected void setUp() throws Exception {
        super.setUp();
    }

    @Override
    protected void tearDown() throws Exception {
        super.tearDown();
    }

    protected MidiTestContext setUpEchoServer() throws Exception {
        if (DEBUG) {
            Log.i(TAG, ""setUpEchoServer()"");
        }
        MidiManager midiManager = (MidiManager) mContext.getSystemService(
                Context.MIDI_SERVICE);

        MidiDeviceInfo echoInfo = CTSMidiEchoTestService.findEchoDevice(mContext);

        // Open device.
        MyTestOpenCallback callback = new MyTestOpenCallback();
        midiManager.openDevice(echoInfo, callback, null);
        MidiDevice echoDevice = callback.waitForOpen(TIMEOUT_OPEN_MSEC);
        assertTrue(""could not open ""
                + CTSMidiEchoTestService.getEchoServerName(), echoDevice != null);

        // Query echo service directly to see if it is getting status updates.
        MidiEchoTestService echoService = CTSMidiEchoTestService.getInstance();
        assertEquals(""virtual device status, input port before open"", false,
                echoService.inputOpened);
        assertEquals(""virtual device status, output port before open"", 0,
                echoService.outputOpenCount);

        // Open input port.
        MidiInputPort echoInputPort = echoDevice.openInputPort(0);
        assertTrue(""could not open input port"", echoInputPort != null);
        assertEquals(""input port number"", 0, echoInputPort.getPortNumber());
        assertEquals(""virtual device status, input port after open"", true,
                echoService.inputOpened);
        assertEquals(""virtual device status, output port before open"", 0,
                echoService.outputOpenCount);

        // Open output port.
        MidiOutputPort echoOutputPort = echoDevice.openOutputPort(0);
        assertTrue(""could not open output port"", echoOutputPort != null);
        assertEquals(""output port number"", 0, echoOutputPort.getPortNumber());
        assertEquals(""virtual device status, input port after open"", true,
                echoService.inputOpened);
        assertEquals(""virtual device status, output port after open"", 1,
                echoService.outputOpenCount);

        MidiTestContext mc = new MidiTestContext();
        mc.echoInfo = echoInfo;
        mc.echoDevice = echoDevice;
        mc.echoInputPort = echoInputPort;
        mc.echoOutputPort = echoOutputPort;
        return mc;
    }

    /**
     * Close ports and check device status.
     *
     * @param mc
     */
    protected void tearDownEchoServer(MidiTestContext mc) throws IOException {
        // Query echo service directly to see if it is getting status updates.
        MidiEchoTestService echoService = CTSMidiEchoTestService.getInstance();
        assertEquals(""virtual device status, input port before close"", true,
                echoService.inputOpened);
        assertEquals(""virtual device status, output port before close"", 1,
                echoService.outputOpenCount);

        // Close output port.
        mc.echoOutputPort.close();
        assertEquals(""virtual device status, input port before close"", true,
                echoService.inputOpened);
        assertEquals(""virtual device status, output port after close"", 0,
                echoService.outputOpenCount);
        mc.echoOutputPort.close();
        mc.echoOutputPort.close(); // should be safe to close twice

        // Close input port.
        mc.echoInputPort.close();
        assertEquals(""virtual device status, input port after close"", false,
                echoService.inputOpened);
        assertEquals(""virtual device status, output port after close"", 0,
                echoService.outputOpenCount);
        mc.echoInputPort.close();
        mc.echoInputPort.close(); // should be safe to close twice

        mc.echoDevice.close();
        mc.echoDevice.close(); // should be safe to close twice
    }

    /**
     * @param mc
     * @param echoInfo
     */
    protected void checkEchoDeviceInfo(MidiTestContext mc,
            MidiDeviceInfo echoInfo) {
        assertEquals(""echo input port count wrong"", 1,
                echoInfo.getInputPortCount());
        assertEquals(""echo output port count wrong"", 1,
                echoInfo.getOutputPortCount());

        Bundle properties = echoInfo.getProperties();
        String tags = (String) properties.get(""tags"");
        assertEquals(""attributes from device XML"", ""echo,test"", tags);

        PortInfo[] ports = echoInfo.getPorts();
        assertEquals(""port info array size"", 2, ports.length);

        boolean foundInput = false;
        boolean foundOutput = false;
        for (PortInfo portInfo : ports) {
            if (portInfo.getType() == PortInfo.TYPE_INPUT) {
                foundInput = true;
                assertEquals(""input port name"", ""input"", portInfo.getName());

                assertEquals(""info port number"", portInfo.getPortNumber(),
                        mc.echoInputPort.getPortNumber());
            } else if (portInfo.getType() == PortInfo.TYPE_OUTPUT) {
                foundOutput = true;
                assertEquals(""output port name"", ""output"", portInfo.getName());
                assertEquals(""info port number"", portInfo.getPortNumber(),
                        mc.echoOutputPort.getPortNumber());
            }
        }
        assertTrue(""found input port info"", foundInput);
        assertTrue(""found output port info"", foundOutput);

        assertEquals(""MIDI device type"", MidiDeviceInfo.TYPE_VIRTUAL,
                echoInfo.getType());
    }

    // Is the MidiManager supported?"	""	""	"EQP"	""
"3.2.3.5  Conditional Application Intents"	"3.2.3.5"	"C-12-3"	"3.2.3.5/C-12-3"	""	"""C-12-3] MUST honor only allow preinstalled Android applications to handle the following intents [`MediaStore.ACTION_IMAGE_CAPTURE`](https://developer.android.com/reference/android/provider/MediaStore.html#ACTION_IMAGE_CAPTURE), [`MediaStore.ACTION_IMAGE_CAPTURE_SECURE`](https://developer.android.com/reference/android/provider/MediaStore.html#ACTION_IMAGE_CAPTURE_SECURE), and [`MediaStore.ACTION_VIDEO_CAPTURE`](https://developer.android.com/reference/android/provider/MediaStore.html#ACTION_VIDEO_CAPTURE) as described in the [SDK document](https://developer.android.com/preview/behavior-changes-11?hl=zh-tw#media-capture).  If device implementations report `android.software.device_admin`, they:  """	""	""	"android.software.device MediaStore.html MediaStore.ACTION ACTION_VIDEO_CAPTURE ACTION_IMAGE_CAPTURE_SECURE ACTION_IMAGE_CAPTURE"	""	""	""	""	""	""	""	""	""	""	""	"android.appsecurity.cts.DirectBootHostTest"	"getDevice"	"CtsAppSecurityHostTestCases"	""	""	""	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/DirectBootHostTest.java"	""	"/*
 *.
 */

package android.appsecurity.cts;

import static android.appsecurity.cts.Utils.waitForBootCompleted;

import static com.android.compatibility.common.util.PropertyUtil.getFirstApiLevel;
import static com.android.compatibility.common.util.PropertyUtil.getVendorApiLevel;

import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assume.assumeFalse;
import static org.junit.Assume.assumeTrue;

import android.platform.test.annotations.RequiresDevice;

import com.android.tradefed.device.DeviceNotAvailableException;
import com.android.tradefed.testtype.DeviceJUnit4ClassRunner;
import com.android.tradefed.testtype.junit4.BaseHostJUnit4Test;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

/**
 * Set of tests that verify behavior of direct boot, if supported.
 * <p>
 * Note that these tests drive PIN setup manually instead of relying on device
 * administrators, which are not supported by all devices.
 */
@RunWith(DeviceJUnit4ClassRunner.class)
public class DirectBootHostTest extends BaseHostJUnit4Test {
    private static final String TAG = ""DirectBootHostTest"";

    private static final String PKG = ""com.android.cts.encryptionapp"";
    private static final String CLASS = PKG + "".EncryptionAppTest"";
    private static final String APK = ""CtsEncryptionApp.apk"";

    private static final String OTHER_APK = ""CtsSplitApp.apk"";
    private static final String OTHER_PKG = ""com.android.cts.splitapp"";

    private static final String MODE_NATIVE = ""native"";
    private static final String MODE_EMULATED = ""emulated"";
    private static final String MODE_NONE = ""none"";

    private static final String FEATURE_DEVICE_ADMIN = ""feature:android.software.device_admin"";
    private static final String FEATURE_SECURE_LOCK_SCREEN =
            ""feature:android.software.secure_lock_screen"";
    private static final String FEATURE_AUTOMOTIVE = ""feature:android.hardware.type.automotive"";
    private static final String FEATURE_SECURITY_MODEL_COMPATIBLE =
            ""feature:android.hardware.security.model.compatible"";

    private static final long SHUTDOWN_TIME_MS = 30 * 1000;

    @Before
    public void setUp() throws Exception {
        Utils.prepareSingleUser(getDevice());
        assertNotNull(getAbi());
        assertNotNull(getBuild());

        getDevice().uninstallPackage(PKG);
        getDevice().uninstallPackage(OTHER_PKG);
    }

    @After
    public void tearDown() throws Exception {
        getDevice().uninstallPackage(PKG);
        getDevice().uninstallPackage(OTHER_PKG);
    }

    /**
     * Automotive devices MUST support native FBE.
     */"	""	""	"android.software.device"	""
"3.2.3.5  Conditional Application Intents"	"3.2.3.5"	"C-12-2"	"3.2.3.5/C-12-2"	""	"""C-12-2] MUST honor the [`android.media.action.VIDEO_CAMERA`](https://developer.android.com/reference/android/provider/MediaStore#INTENT_ACTION_VIDEO_CAMERA) intent to launch the camera in video mode as described in the SDK. """	""	""	"VIDEO_CAMERA INTENT_ACTION_VIDEO_CAMERA android.media.action.VIDEO"	""	""	""	""	""	""	""	""	""	""	""	"android.appsecurity.cts.EphemeralTest"	"isDeviceUnsupported"	"CtsAppSecurityHostTestCases"	""	""	""	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/EphemeralTest.java"	""	"/*
 *
 */

package android.appsecurity.cts;

import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.fail;
import static org.junit.Assume.assumeFalse;

import android.platform.test.annotations.AppModeFull;
import android.platform.test.annotations.AsbSecurityTest;

import com.android.tradefed.log.LogUtil.CLog;
import com.android.tradefed.testtype.DeviceJUnit4ClassRunner;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Tests for ephemeral packages.
 */
@RunWith(DeviceJUnit4ClassRunner.class)
@AppModeFull(reason = ""Already handles instant installs when needed"")
public class EphemeralTest extends BaseAppSecurityTest {

    // a normally installed application
    private static final String NORMAL_APK = ""CtsEphemeralTestsNormalApp.apk"";
    private static final String NORMAL_PKG = ""com.android.cts.normalapp"";

    // the first ephemerally installed application
    private static final String EPHEMERAL_1_APK = ""CtsEphemeralTestsEphemeralApp1.apk"";
    private static final String EPHEMERAL_1_PKG = ""com.android.cts.ephemeralapp1"";

    // the second ephemerally installed application
    private static final String EPHEMERAL_2_APK = ""CtsEphemeralTestsEphemeralApp2.apk"";
    private static final String EPHEMERAL_2_PKG = ""com.android.cts.ephemeralapp2"";

    // a normally installed application with implicitly exposed components
    private static final String IMPLICIT_APK = ""CtsEphemeralTestsImplicitApp.apk"";
    private static final String IMPLICIT_PKG = ""com.android.cts.implicitapp"";

    // a normally installed application with no exposed components
    private static final String UNEXPOSED_APK = ""CtsEphemeralTestsUnexposedApp.apk"";
    private static final String UNEXPOSED_PKG = ""com.android.cts.unexposedapp"";

    // an application that gets upgraded from 'instant' to 'full'
    private static final String UPGRADED_APK = ""CtsInstantUpgradeApp.apk"";
    private static final String UPGRADED_PKG = ""com.android.cts.instantupgradeapp"";

    private static final String TEST_CLASS = "".ClientTest"";
    private static final String WEBVIEW_TEST_CLASS = "".WebViewTest"";

    private static final List<Map<String, String>> EXPECTED_EXPOSED_INTENTS =
            new ArrayList<>();
    static {
        // Framework intents we expect the system to expose to instant applications
        EXPECTED_EXPOSED_INTENTS.add(makeArgs(
                ""android.intent.action.CHOOSER"",
                null, null));
        // Contact intents we expect the system to expose to instant applications
        EXPECTED_EXPOSED_INTENTS.add(makeArgs(
                ""android.intent.action.PICK"", null, ""vnd.android.cursor.dir/contact""));
        EXPECTED_EXPOSED_INTENTS.add(makeArgs(
                ""android.intent.action.PICK"", null, ""vnd.android.cursor.dir/phone_v2""));
        EXPECTED_EXPOSED_INTENTS.add(makeArgs(
                ""android.intent.action.PICK"", null, ""vnd.android.cursor.dir/email_v2""));
        EXPECTED_EXPOSED_INTENTS.add(makeArgs(
                ""android.intent.action.PICK"", null, ""vnd.android.cursor.dir/postal-address_v2""));
        // Storage intents we expect the system to expose to instant applications
        EXPECTED_EXPOSED_INTENTS.add(makeArgs(
                ""android.intent.action.OPEN_DOCUMENT"",
                ""android.intent.category.OPENABLE"", ""\\*/\\*""));
        EXPECTED_EXPOSED_INTENTS.add(makeArgs(
                ""android.intent.action.OPEN_DOCUMENT"", null, ""\\*/\\*""));
        EXPECTED_EXPOSED_INTENTS.add(makeArgs(
                ""android.intent.action.GET_CONTENT"",
                ""android.intent.category.OPENABLE"", ""\\*/\\*""));
        EXPECTED_EXPOSED_INTENTS.add(makeArgs(
                ""android.intent.action.GET_CONTENT"", null, ""\\*/\\*""));
        EXPECTED_EXPOSED_INTENTS.add(makeArgs(
                ""android.intent.action.OPEN_DOCUMENT_TREE"", null, null));
        EXPECTED_EXPOSED_INTENTS.add(makeArgs(
                ""android.intent.action.CREATE_DOCUMENT"",
                ""android.intent.category.OPENABLE"", ""text/plain""));
        EXPECTED_EXPOSED_INTENTS.add(makeArgs(
                ""android.intent.action.CREATE_DOCUMENT"", null, ""text/plain""));
        /** Camera intents we expect the system to expose to instant applications */
        EXPECTED_EXPOSED_INTENTS.add(makeArgs(
                ""android.media.action.IMAGE_CAPTURE"", null, null));
        EXPECTED_EXPOSED_INTENTS.add(makeArgs(
                ""android.media.action.VIDEO_CAPTURE"", null, null));
    }

    private String mOldVerifierValue;
    private Boolean mIsUnsupportedDevice;

    @Before
    public void setUp() throws Exception {
        mIsUnsupportedDevice = isDeviceUnsupported();
        if (mIsUnsupportedDevice) {
            return;
        }

        Utils.prepareSingleUser(getDevice());
        assertNotNull(getAbi());
        assertNotNull(getBuild());

        uninstallTestPackages();
        installTestPackages();
    }

    @After
    public void tearDown() throws Exception {
        if (mIsUnsupportedDevice) {
            return;
        }
        uninstallTestPackages();
    }"	""	""	"android.media.action.VIDEO"	""
"3.2.3.5  Conditional Application Intents"	"3.2.3.5"	"C-15-1"	"3.2.3.5/C-15-1"	""	"""C-15-1] MUST still have an activity that handles the [android.settings.ACTION_USAGE_ACCESS_SETTINGS](https://developer.android.com/reference/android/provider/Settings.html#ACTION&lowbar;USAGE&lowbar;ACCESS&lowbar;SETTINGS) intent pattern but MUST implement it as a no-op, that is to have an equivalent behavior as when the user is declined for access.  If device implementations report the feature `android.hardware.audio.output`, they:  """	""	""	"USAGE ACTION ACCESS SETTINGS ACTION_USAGE_ACCESS_SETTINGS Settings.html android.hardware.audio.output android.settings.ACTION"	""	""	""	""	""	""	""	""	""	""	""	"android.view.accessibility.cts.AccessibilityManagerTest"	"testGetRecommendedTimeoutMillis"	"CtsAccessibilityTestCases"	""	""	""	"/home/gpoor/cts-12-source/cts/tests/accessibility/src/android/view/accessibility/cts/AccessibilityManagerTest.java"	""	"public void testGetRecommendedTimeoutMillis() throws Exception {
        mSpeakingAccessibilityServiceRule.enableService();
        mVibratingAccessibilityServiceRule.enableService();
        waitForAccessibilityEnabled();
        UiAutomation automan = sInstrumentation.getUiAutomation(
                UiAutomation.FLAG_DONT_SUPPRESS_ACCESSIBILITY_SERVICES);
        try {
            // SpeakingA11yService interactive/nonInteractive timeout is 6000/1000
            // vibratingA11yService interactive/nonInteractive timeout is 5000/2000
            turnOffRecommendedUiTimoutSettings(automan);
            PollingCheck.waitFor(() -> sameRecommendedTimeout(6000, 2000));
            turnOnRecommendedUiTimoutSettings(automan, 7000, 0);
            PollingCheck.waitFor(() -> sameRecommendedTimeout(7000, 2000));
            turnOnRecommendedUiTimoutSettings(automan, 0, 4000);
            PollingCheck.waitFor(() -> sameRecommendedTimeout(6000, 4000));
            turnOnRecommendedUiTimoutSettings(automan, 9000, 8000);
            PollingCheck.waitFor(() -> sameRecommendedTimeout(9000, 8000));
            turnOffRecommendedUiTimoutSettings(automan);
            PollingCheck.waitFor(() -> sameRecommendedTimeout(6000, 2000));
            assertEquals(""Should return original timeout"", 3000,
                    mAccessibilityManager.getRecommendedTimeoutMillis(3000,
                            AccessibilityManager.FLAG_CONTENT_ICONS));
            assertEquals(""Should return original timeout"", 7000,
                    mAccessibilityManager.getRecommendedTimeoutMillis(7000,
                            AccessibilityManager.FLAG_CONTENT_CONTROLS));
        } finally {
            automan.destroy();
        }
    }

    private void assertAtomicBooleanBecomes(AtomicBoolean atomicBoolean,
            boolean expectedValue, Object waitObject, String message)
            throws Exception {
        long timeoutTime =
                System.currentTimeMillis() + TIMEOUT_SERVICE_ENABLE;
        synchronized (waitObject) {
            while ((atomicBoolean.get() != expectedValue)
                    && (System.currentTimeMillis() < timeoutTime)) {
                waitObject.wait(timeoutTime - System.currentTimeMillis());
            }
        }
        assertTrue(message, atomicBoolean.get() == expectedValue);
    }

    private void waitForAccessibilityEnabled() throws InterruptedException {
        final Object waitObject = new Object();

        AccessibilityStateChangeListener listener = (boolean b) -> {
            synchronized (waitObject) {
                waitObject.notifyAll();
            }
        };
        mAccessibilityManager.addAccessibilityStateChangeListener(listener);
        long timeoutTime =
                System.currentTimeMillis() + TIMEOUT_SERVICE_ENABLE;
        synchronized (waitObject) {
            while (!mAccessibilityManager.isEnabled()
                    && (System.currentTimeMillis() < timeoutTime)) {
                waitObject.wait(timeoutTime - System.currentTimeMillis());
            }
        }
        mAccessibilityManager.removeAccessibilityStateChangeListener(listener);
        assertTrue(""Timed out enabling accessibility"", mAccessibilityManager.isEnabled());
    }

    private void turnOffRecommendedUiTimoutSettings(UiAutomation automan) {
        putSecureSetting(automan, ACCESSIBILITY_INTERACTIVE_UI_TIMEOUT_MS, null);
        putSecureSetting(automan, ACCESSIBILITY_NON_INTERACTIVE_UI_TIMEOUT_MS, null);
    }

    private void turnOnRecommendedUiTimoutSettings(UiAutomation automan,
            int interactiveUiTimeout, int nonInteractiveUiTimeout) {
        putSecureSetting(automan, ACCESSIBILITY_INTERACTIVE_UI_TIMEOUT_MS,
                Integer.toString(interactiveUiTimeout));
        putSecureSetting(automan, ACCESSIBILITY_NON_INTERACTIVE_UI_TIMEOUT_MS,
                Integer.toString(nonInteractiveUiTimeout));
    }

    private boolean sameRecommendedTimeout(int interactiveUiTimeout,
            int nonInteractiveUiTimeout) {
        final int currentInteractiveUiTimeout = mAccessibilityManager
                .getRecommendedTimeoutMillis(0, AccessibilityManager.FLAG_CONTENT_CONTROLS);
        final int currentNonInteractiveUiTimeout = mAccessibilityManager
                .getRecommendedTimeoutMillis(0, AccessibilityManager.FLAG_CONTENT_ICONS);
        return (currentInteractiveUiTimeout == interactiveUiTimeout
                && currentNonInteractiveUiTimeout == nonInteractiveUiTimeout);
    }

    private void putSecureSetting(UiAutomation automan, String name, String value) {
        final StringBuilder cmd = new StringBuilder(""settings put secure "")
                .append(name).append("" "")
                .append(value);
        try {
            SystemUtil.runShellCommand(automan, cmd.toString());
        } catch (IOException e) {
            fail(""Fail to run shell command"");
        }
    }
}"	""	""	"SETTINGS"	""
"2.2.3  Software"	"3.8.4"	"H-1-1"	"3.8.4/H-1-1"	""	"""[3.8.4/H-1-1]* MUST display     conversation notifications ahead of non conversation notifications with     the exception of ongoing foreground service notifications and     [importance:high](https://developer.android.com/reference/android/app/NotificationManager#IMPORTANCE_HIGH)     notifications.  If Android Handheld device implementations support a lock screen, they:  *   ["""	""	""	"IMPORTANCE_HIGH"	""	""	""	""	""	""	""	""	""	""	""	"android.app.cts.NotificationManagerTest"	"testOriginalChannelImportance"	"CtsAppTestCases"	""	""	""	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/NotificationManagerTest.java"	""	"public void testOriginalChannelImportance() {
        NotificationChannel channel = new NotificationChannel(mId, ""my channel"", IMPORTANCE_HIGH);

        mNotificationManager.createNotificationChannel(channel);

        NotificationChannel actual = mNotificationManager.getNotificationChannel(channel.getId());
        assertEquals(IMPORTANCE_HIGH, actual.getImportance());
        assertEquals(IMPORTANCE_HIGH, actual.getOriginalImportance());

        // Apps are allowed to downgrade channel importance if the user has not changed any
        // fields on this channel yet.
        channel.setImportance(IMPORTANCE_DEFAULT);
        mNotificationManager.createNotificationChannel(channel);

        actual = mNotificationManager.getNotificationChannel(channel.getId());
        assertEquals(IMPORTANCE_DEFAULT, actual.getImportance());
        assertEquals(IMPORTANCE_HIGH, actual.getOriginalImportance());
    }"	""	""	"IMPORTANCE_HIGH"	""
"3.2.3.5  Conditional Application Intents"	"3.2.3.5"	"C-14-1"	"3.2.3.5/C-14-1"	""	"""C-14-1] MUST fully implement the [`AutofillService`](https://developer.android.com/reference/android/service/autofill/AutofillService.html) and [`AutofillManager`](https://developer.android.com/reference/android/view/autofill/AutofillManager.html) APIs and honor the [android.settings.REQUEST_SET_AUTOFILL_SERVICE](https://developer.android.com/reference/android/provider/Settings.html#ACTION_REQUEST_SET_AUTOFILL_SERVICE) intent to show a default app settings menu to enable and disable autofill and change the default autofill service for the user.  If device implementations include a pre-installed app or wish to allow third-party apps to access the usage statistics, they:  """	""	""	"android.settings.REQUEST REQUEST_SET_AUTOFILL_SERVICE Settings.html AutofillManager.html ACTION_REQUEST_SET_AUTOFILL_SERVICE AutofillService.html"	""	""	""	""	""	""	""	""	""	""	""	"android.autofillservice.cts.servicebehavior.SettingsIntentTest"	"testWarningShown_userRejectsByTappingBack"	"CtsAutoFillServiceTestCases"	""	""	""	"/home/gpoor/cts-12-source/cts/tests/autofillservice/src/android/autofillservice/cts/servicebehavior/SettingsIntentTest.java"	""	"public void testWarningShown_userRejectsByTappingBack() throws Exception {
        disableService();

        // Launches Settings.
        mActivity.startForResult(newSettingsIntent(), MY_REQUEST_CODE);

        // Asserts services are shown.
        final UiObject2 object = mUiBot
                .assertShownByText(InstrumentedAutoFillService.sServiceLabel);
        object.click();

        // TODO(b/79615759): should assert that ""autofill_confirmation_message"" is shown, but that
        // string belongs to Settings - we need to move it to frameworks/base first (and/or use
        // a resource id, also on framework).
        // So, for now, just asserts the service name is showing again (in the popup), and the other
        // services are not showing (because the popup hides then).

        final UiObject2 msgObj = mUiBot.assertShownById(""android:id/message"");
        final String msg = msgObj.getText();
        assertWithMessage(""Wrong warning message"").that(msg)
                .contains(InstrumentedAutoFillService.sServiceLabel);

        // NOTE: assertion below is fine because it looks for the full text, not a substring
        mUiBot.assertNotShowingForSure(InstrumentedAutoFillService.sServiceLabel);
        mUiBot.assertNotShowingForSure(InstrumentedAutoFillServiceCompatMode.sServiceLabel);
        mUiBot.assertNotShowingForSure(NoOpAutofillService.SERVICE_LABEL);
        mUiBot.assertNotShowingForSure(BadAutofillService.SERVICE_LABEL);

        // Finishes and asserts result.
        mUiBot.pressBack();
        mActivity.assertResult(Activity.RESULT_CANCELED);
    }

    // TODO(b/79615759): add testWarningShown_userRejectsByTappingCancel() and
    // testWarningShown_userAccepts() - these tests would require adding the strings and resource
    // ids to frameworks/base

    private Intent newSettingsIntent() {
        return new Intent(Settings.ACTION_REQUEST_SET_AUTOFILL_SERVICE)
                .setFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                .setData(Uri.parse(""package:"" + Helper.MY_PACKAGE));
    }
}"	""	""	"ACTION_REQUEST_SET_AUTOFILL_SERVICE"	""
"3.2.3.5  Conditional Application Intents"	"3.2.3.5"	"C-10-1"	"3.2.3.5/C-10-1"	""	"""C-10-1] MUST provide a user interface in the settings, that handles the [`Settings.ACTION_IGNORE_BACKGROUND_DATA_RESTRICTIONS_SETTINGS`](https://developer.android.com/reference/android/provider/Settings.html#ACTION_IGNORE_BACKGROUND_DATA_RESTRICTIONS_SETTINGS) intent, allowing users to add applications to or remove applications from the allow list.  If device implementations do not provide the data saver mode, they:  """	""	""	"Settings.html Settings.ACTION TINGS ACTION_IGNORE_BACKGROUND_DATA_RESTRICTIONS_SET"	""	""	""	""	""	""	""	""	""	""	""	"android.hardware.hdmi.cts.HdmiControlManagerTest"	"testHdmiCecConfig_TvTvSendStandbyOnSleep"	"CtsHardwareTestCases"	""	""	""	"/home/gpoor/cts-12-source/cts/tests/tests/hardware/src/android/hardware/hdmi/cts/HdmiControlManagerTest.java"	""	"public void testHdmiCecConfig_TvTvSendStandbyOnSleep() throws Exception {
        // Save original value
        int originalValue = mHdmiControlManager.getTvSendStandbyOnSleep();
        if (!mHdmiControlManager.getUserCecSettings().contains(
                HdmiControlManager.CEC_SETTING_NAME_TV_SEND_STANDBY_ON_SLEEP)) {
            return;
        }
        try {
            for (int value : mHdmiControlManager.getAllowedCecSettingIntValues(
                    HdmiControlManager.CEC_SETTING_NAME_TV_SEND_STANDBY_ON_SLEEP)) {
                mHdmiControlManager.setTvSendStandbyOnSleep(value);
                assertThat(mHdmiControlManager.getTvSendStandbyOnSleep()).isEqualTo(value);
            }
        } finally {
            // Restore original value
            mHdmiControlManager.setTvSendStandbyOnSleep(originalValue);
            assertThat(mHdmiControlManager.getTvSendStandbyOnSleep()).isEqualTo(
                    originalValue);
        }
    }
}"	""	""	"TINGS"	""
"3.18  Contacts"	"3.18"	"C-1-3"	"3.18/C-1-3"	""	"""C-1-3] Raw contacts that are inserted by third party applications with      the **default local account** (i.e. by setting null values for      `ACCOUNT_NAME` and `ACCOUNT_TYPE`) MUST be inserted to the **custom local      account**. """	""	""	"ACCOUNT_NAME ACCOUNT_TYPE"	""	""	""	""	""	""	""	""	""	""	""	"android.accounts.cts.AbstractAuthenticatorTests"	"testFinishSessionAndStartUpdateCredentialsSessionDefaultImpl"	"CtsAccountManagerTestCases"	""	""	""	"/home/gpoor/cts-12-source/cts/tests/tests/accounts/src/android/accounts/cts/AbstractAuthenticatorTests.java"	""	"public void testFinishSessionAndStartUpdateCredentialsSessionDefaultImpl()
            throws OperationCanceledException, AuthenticatorException, IOException,
            RemoteException {
        Bundle options = new Bundle();
        String accountName = Fixtures.PREFIX_NAME_SUCCESS + ""@"" + Fixtures.SUFFIX_NAME_FIXTURE;
        options.putString(Fixtures.KEY_ACCOUNT_NAME, accountName);

        // First obtain an encrypted session bundle from startUpdateCredentialsSession(...) default
        // implementation.
        AccountManagerFuture<Bundle> future = mAccountManager.startUpdateCredentialsSession(
                Fixtures.ACCOUNT_DEFAULT,
                null /* authTokenTYpe */,
                options,
                null /* activity */,
                null /* callback */,
                null /* handler */);

        Bundle result = future.getResult();
        assertTrue(future.isDone());
        assertNotNull(result);

        // Assert that result contains a non-null session bundle.
        Bundle escrowBundle = result.getBundle(AccountManager.KEY_ACCOUNT_SESSION_BUNDLE);
        assertNotNull(escrowBundle);

        // Now call finishSession(...) with the session bundle we just obtained.
        future = mAccountManager.finishSession(
                escrowBundle,
                null /* activity */,
                null /* callback */,
                null /* handler */);

        result = future.getResult();
        assertTrue(future.isDone());
        assertNotNull(result);

        // Validate that parameters are passed to updateCredentials(...) correctly in default
        // finishSession implementation.
        Bundle providerBundle = mProviderClient.call(
                AuthenticatorContentProvider.METHOD_GET,
                null /* arg */,
                null /* extras */);
        providerBundle.setClassLoader(UpdateCredentialsTx.class.getClassLoader());
        UpdateCredentialsTx updateCredentialsTx = providerBundle
                .getParcelable(AuthenticatorContentProvider.KEY_TX);
        assertNotNull(updateCredentialsTx);

        // Assert parameters has been passed to updateCredentials(...) correctly
        assertEquals(Fixtures.ACCOUNT_DEFAULT, updateCredentialsTx.account);
        assertNull(updateCredentialsTx.authTokenType);

        validateSystemOptions(updateCredentialsTx.options);
        // Validate options
        assertNotNull(updateCredentialsTx.options);
        assertEquals(accountName, updateCredentialsTx.options.getString(Fixtures.KEY_ACCOUNT_NAME));

        // Assert returned result contains correct account name, account type and null auth token.
        assertEquals(accountName, result.get(AccountManager.KEY_ACCOUNT_NAME));
        assertEquals(Fixtures.TYPE_DEFAULT, result.get(AccountManager.KEY_ACCOUNT_TYPE));
        assertNull(result.get(AccountManager.KEY_AUTHTOKEN));
    }

    private void validateSystemOptions(Bundle options) {
        assertNotNull(options.getString(AccountManager.KEY_ANDROID_PACKAGE_NAME));
        assertTrue(options.containsKey(AccountManager.KEY_CALLER_UID));
        assertTrue(options.containsKey(AccountManager.KEY_CALLER_PID));
    }

    private void validateNullPasswordAndStatusToken(Bundle result) {
        assertNull(result.getString(AccountManager.KEY_PASSWORD));
        assertNull(result.getString(AccountManager.KEY_ACCOUNT_STATUS_TOKEN));
    }

    /**
     * Tests isCredentialsUpdateSuggested default implementation.
     * A bundle with boolean false should be returned.
     */"	""	""	"ACCOUNT_TYPE"	""
"3.2.3.5  Conditional Application Intents"	"3.2.3.5"	"C-9-1"	"3.2.3.5/C-9-1"	""	"""C-9-1] MUST implement the [Settings#ACTION_PROCESS_WIFI_EASY_CONNECT_URI](https://developer.android.com/reference/android/provider/Settings.html#ACTION_PROCESS_WIFI_EASY_CONNECT_URI) Intent APIs as described in the SDK documentation.  If device implementations provide the data saver mode, they: """	""	""	"Settings.html ACTION_PROCESS_WIFI_EASY_CONNECT_URI"	""	""	""	""	""	""	""	""	""	""	""	"android.content.cts.AvailableIntentsTest"	"testEasyConnectIntent"	"CtsContentTestCases"	""	""	""	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/AvailableIntentsTest.java"	""	"public void testEasyConnectIntent() {
        // Android only supports Initiator-... modes right now, which require the device to
        // have a QR-code capture mechanism. Therefore this feature does not make sense on
        // non-handheld devices.
        if (!isHandheld()) {
            return;
        }
        WifiManager manager = mContext.getSystemService(WifiManager.class);

        if (manager.isEasyConnectSupported()) {
            Intent intent = new Intent(Settings.ACTION_PROCESS_WIFI_EASY_CONNECT_URI);
            intent.setData(Uri.parse(QRCODE));
            assertCanBeHandled(intent);
        }
    }"	""	""	"ACTION_PROCESS_WIFI_EASY_CONNECT_URI"	""
"7.4.3  Bluetooth"	"7.4.3"	"C-3-5"	"7.4.3/C-3-5"	""	"""C-3-5] MUST implement a Resolvable Private Address (RPA) timeout no longer     than 15 minutes and rotate the address at timeout to protect user privacy     when device is actively using BLE for scanning or advertising.     To prevent timing attacks, timeout intervals MUST also be randomized     between 5 and 15 minutes. *   SHOULD support offloading of the filtering logic to the bluetooth chipset when implementing the [ScanFilter API]( https://developer.android.com/reference/android/bluetooth/le/ScanFilter.html). *   SHOULD support offloading of the batched scanning to the bluetooth chipset. *   SHOULD support multi advertisement with at least 4 slots.  If device implementations support Bluetooth LE and use Bluetooth LE for location scanning, they:  """	""	""	"ScanFilter.html RPA BLE"	""	""	""	""	""	""	""	""	""	""	""	"test.java.com.android.queryable.queries.SerializableQueryHelperTest"	"matches_isEqualTo_doesNotMeetRestriction_returnsFalse"	""	""	""	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/queryable/src/test/java/com/android/queryable/queries/SerializableQueryHelperTest.java"	""	"public void matches_isEqualTo_doesNotMeetRestriction_returnsFalse() {
        SerializableQueryHelper<Queryable> serializableQueryHelper =
                new SerializableQueryHelper<>(mQuery);

        serializableQueryHelper.isEqualTo(mDifferentSerializable);

        assertThat(serializableQueryHelper.matches(mSerializable)).isFalse();
    }
}"	""	""	"BLE"	""
"2.5.1  Hardware"	"7.3.3"	"A-3-1"	"7.3.3/A-3-1"	""	"""[7.3.3/A-3-1] MUST determine location the very first time      the GPS/GNSS receiver is turned on or after 4+ days within 60 seconds. *    ["""	""	""	"GNSS GPS"	""	""	""	""	""	""	""	""	""	""	""	"android.location.cts.privileged.GnssCapabilitiesTest"	"testWriteToParcel"	"CtsLocationPrivilegedTestCases"	""	""	""	"/home/gpoor/cts-12-source/cts/tests/location/location_privileged/src/android/location/cts/privileged/GnssCapabilitiesTest.java"	""	"public void testWriteToParcel() {
        GnssCapabilities gnssCapabilities = getTestGnssCapabilities();
        Parcel parcel = Parcel.obtain();
        gnssCapabilities.writeToParcel(parcel, 0);
        parcel.setDataPosition(0);
        GnssCapabilities newGnssCapabilities = GnssCapabilities.CREATOR.createFromParcel(parcel);
        verifyTestValues(newGnssCapabilities);
        parcel.recycle();
    }

    private static GnssCapabilities getTestGnssCapabilities() {
        GnssCapabilities.Builder builder = new GnssCapabilities.Builder();
        builder.setHasAntennaInfo(true);
        builder.setHasGeofencing(true);
        builder.setHasLowPowerMode(true);
        builder.setHasMeasurements(true);
        builder.setHasMeasurementCorrections(true);
        builder.setHasMeasurementCorrectionsExcessPathLength(true);
        builder.setHasMeasurementCorrectionsForDriving(true);
        builder.setHasMeasurementCorrectionsLosSats(true);
        builder.setHasMeasurementCorrectionsReflectingPlane(true);
        builder.setHasMeasurementCorrelationVectors(true);
        builder.setHasNavigationMessages(true);
        builder.setHasSatelliteBlocklist(true);
        builder.setHasSatellitePvt(true);
        return builder.build();
    }

    private static void verifyTestValues(GnssCapabilities gnssCapabilities) {
        assertEquals(true, gnssCapabilities.hasAntennaInfo());
        assertEquals(true, gnssCapabilities.hasGeofencing());
        assertEquals(true, gnssCapabilities.hasLowPowerMode());
        assertEquals(true, gnssCapabilities.hasMeasurements());
        assertEquals(true, gnssCapabilities.hasMeasurementCorrections());
        assertEquals(true, gnssCapabilities.hasMeasurementCorrectionsExcessPathLength());
        assertEquals(true, gnssCapabilities.hasMeasurementCorrectionsForDriving());
        assertEquals(true, gnssCapabilities.hasMeasurementCorrectionsLosSats());
        assertEquals(true, gnssCapabilities.hasMeasurementCorrectionsReflectingPlane());
        assertEquals(true, gnssCapabilities.hasMeasurementCorrelationVectors());
        assertEquals(true, gnssCapabilities.hasNavigationMessages());
        assertEquals(true, gnssCapabilities.hasSatelliteBlocklist());
        assertEquals(true, gnssCapabilities.hasSatellitePvt());
    }
}"	""	""	"GNSS"	""
"7.3  Sensors"	"7.3"	"C-3-1"	"7.3/C-3-1"	""	"""C-3-1] MUST set the resolution to 1 for the sensor and report the value     via the [`Sensor.getResolution()`](https://developer.android.com/reference/android/hardware/Sensor#getResolution%28%29)     API method.  If device implementations include a particular sensor type which supports [SensorAdditionalInfo#TYPE_VEC3_CALIBRATION](https://developer.android.com/reference/android/hardware/SensorAdditionalInfo#TYPE_VEC3_CALIBRATION) and the sensor is exposed to third-party developers, they:  """	""	""	"TYPE_VEC3_CALIBRATION getResolution() Sensor.getResolution"	""	""	""	""	""	""	""	""	""	""	""	"android.print.cts.PrinterCapabilitiesTest"	"onPrinterDiscoverySessionCreateCalled"	"CtsPrintTestCases"	""	""	""	"/home/gpoor/cts-12-source/cts/tests/tests/print/src/android/print/cts/PrinterCapabilitiesTest.java"	""	"public void sanePrinterCapabilityInfos() throws Exception {
        final PrinterDiscoverySessionCallbacks firstSessionCallbacks =
                createMockPrinterDiscoverySessionCallbacks(invocation -> {
                    StubbablePrinterDiscoverySession session =
                            ((PrinterDiscoverySessionCallbacks)
                                    invocation.getMock()).getSession();

                    MediaSize[] mediaSizes = {MediaSize.ISO_A0, MediaSize.ISO_A0,
                            MediaSize.ISO_A1};
                    Resolution[] resolutions = {RESOLUTION_300, RESOLUTION_300,
                            RESOLUTION_600};
                    int[] colorModes = {PrintAttributes.COLOR_MODE_MONOCHROME,
                            PrintAttributes.COLOR_MODE_COLOR};
                    int[] duplexModes = {PrintAttributes.DUPLEX_MODE_NONE,
                            PrintAttributes.DUPLEX_MODE_LONG_EDGE,
                            PrintAttributes.DUPLEX_MODE_SHORT_EDGE};

                    ArrayList<PrinterInfo> printers = new ArrayList<>();
                    for (int mediaSizeIndex = 1; mediaSizeIndex < mediaSizes.length;
                         mediaSizeIndex++) {
                        for (int resolutionIndex = 1; resolutionIndex < mediaSizes.length;
                             resolutionIndex++) {
                            for (int colorIndex = 1; colorIndex < colorModes.length;
                                 colorIndex++) {
                                for (int duplexIndex = 1; duplexIndex < duplexModes.length;
                                     duplexIndex++) {
                                    PrinterId printerId = session.getService()
                                            .generatePrinterId(Integer.valueOf(printers.size())
                                                    .toString());

                                    // Setup capabilities
                                    PrinterCapabilitiesInfo.Builder b =
                                            new PrinterCapabilitiesInfo.Builder(printerId);

                                    for (int i = 0; i < mediaSizeIndex; i++) {
                                        b.addMediaSize(mediaSizes[i], i == mediaSizeIndex - 1);
                                    }

                                    for (int i = 0; i < resolutionIndex; i++) {
                                        b.addResolution(resolutions[i],
                                                i == resolutionIndex - 1);
                                    }

                                    int allColors = 0;
                                    for (int i = 0; i < colorIndex; i++) {
                                        allColors |= colorModes[i];
                                    }
                                    b.setColorModes(allColors, colorModes[colorIndex - 1]);

                                    int allDuplexModes = 0;
                                    for (int i = 0; i < duplexIndex; i++) {
                                        allDuplexModes |= duplexModes[i];
                                    }
                                    b.setDuplexModes(allDuplexModes,
                                            duplexModes[duplexIndex - 1]);

                                    b.setMinMargins(DEFAULT_MARGINS);

                                    // Create printer
                                    PrinterInfo printer = (new PrinterInfo.Builder(printerId,
                                            Integer.valueOf(printers.size()).toString(),
                                            PrinterInfo.STATUS_IDLE)).setCapabilities(b.build())
                                            .build();

                                    // Verify capabilities
                                    PrinterCapabilitiesInfo cap = printer.getCapabilities();

                                    assertEquals(mediaSizeIndex, cap.getMediaSizes().size());
                                    assertEquals(mediaSizes[mediaSizeIndex - 1],
                                            cap.getDefaults().getMediaSize());
                                    for (int i = 0; i < mediaSizeIndex; i++) {
                                        assertTrue(cap.getMediaSizes().contains(mediaSizes[i]));
                                    }

                                    assertEquals(resolutionIndex, cap.getResolutions().size());
                                    assertEquals(resolutions[resolutionIndex - 1],
                                            cap.getDefaults().getResolution());
                                    for (int i = 0; i < resolutionIndex; i++) {
                                        assertTrue(cap.getResolutions().contains(resolutions[i]));
                                    }

                                    assertEquals(allColors, cap.getColorModes());
                                    assertEquals(colorModes[colorIndex - 1],
                                            cap.getDefaults().getColorMode());

                                    assertEquals(allDuplexModes, cap.getDuplexModes());
                                    assertEquals(duplexModes[duplexIndex - 1],
                                            cap.getDefaults().getDuplexMode());

                                    assertEquals(DEFAULT_MARGINS, cap.getMinMargins());

                                    // Add printer
                                    printers.add(printer);
                                }
                            }
                        }
                    }

                    session.addPrinters(printers);

                    onPrinterDiscoverySessionCreateCalled();
                    return null;
                }, null, null, null, null, null, invocation -> {
                    onPrinterDiscoverySessionDestroyCalled();
                    return null;
                });

        // Create the service callbacks for the first print service.
        PrintServiceCallbacks firstServiceCallbacks = createMockPrintServiceCallbacks(
                invocation -> firstSessionCallbacks, null, null);

        // Configure the print services.
        FirstPrintService.setCallbacks(firstServiceCallbacks);
        SecondPrintService.setCallbacks(createMockPrintServiceCallbacks(null, null, null));

        PrintDocumentAdapter adapter = createMockPrintDocumentAdapter(null, null, null);

        // Start printing.
        print(adapter);

        waitForPrinterDiscoverySessionCreateCallbackCalled();

        mPrintHelper.cancelPrinting();

        waitForPrinterDiscoverySessionDestroyCallbackCalled(1);
    }

    /**
     * Base test that performs a print operation with a give PrinterCapabilityInfo and run a test
     * function before finishing.
     *
     * @throws Exception
     */
    private void testPrinterCapabilityInfo(final Function<PrinterId, PrinterCapabilitiesInfo>
            capBuilder, Consumer<PrintAttributes> test) throws Exception {
        final PrinterDiscoverySessionCallbacks firstSessionCallbacks =
                createMockPrinterDiscoverySessionCallbacks(invocation -> {
                    StubbablePrinterDiscoverySession session =
                            ((PrinterDiscoverySessionCallbacks)
                                    invocation.getMock()).getSession();

                    PrinterId printerId = session.getService()
                            .generatePrinterId(PRINTER_NAME);

                    ArrayList<PrinterInfo> printers = new ArrayList<>();
                    printers.add((new PrinterInfo.Builder(printerId, PRINTER_NAME,
                            PrinterInfo.STATUS_IDLE))
                            .setCapabilities(capBuilder.apply(printerId)).build());

                    session.addPrinters(printers);

                    onPrinterDiscoverySessionCreateCalled();
                    return null;
                }, null, null, null, null, null, invocation -> {
                    onPrinterDiscoverySessionDestroyCalled();
                    return null;
                });

        // Create the service callbacks for the first print service.
        PrintServiceCallbacks firstServiceCallbacks = createMockPrintServiceCallbacks(
                invocation -> firstSessionCallbacks, null, null);

        // Configure the print services.
        FirstPrintService.setCallbacks(firstServiceCallbacks);
        SecondPrintService.setCallbacks(createMockPrintServiceCallbacks(null, null, null));

        final PrintAttributes[] layoutAttributes = new PrintAttributes[1];

        PrintDocumentAdapter adapter = createMockPrintDocumentAdapter(
                invocation -> {
                    LayoutResultCallback callback = (LayoutResultCallback) invocation
                            .getArguments()[3];
                    PrintDocumentInfo info = new PrintDocumentInfo.Builder(PRINT_JOB_NAME)
                            .setPageCount(1)
                            .build();
                    layoutAttributes[0] = (PrintAttributes) invocation.getArguments()[1];

                    callback.onLayoutFinished(info, true);
                    return null;
                },
                invocation -> {
                    Object[] args = invocation.getArguments();
                    PageRange[] pages = (PageRange[]) args[0];
                    ParcelFileDescriptor fd = (ParcelFileDescriptor) args[1];
                    WriteResultCallback callback = (WriteResultCallback) args[3];

                    writeBlankPages(layoutAttributes[0], fd, pages[0].getStart(),
                            pages[0].getEnd());
                    fd.close();

                    callback.onWriteFinished(pages);
                    return null;
                }, null);

        // Start printing.
        print(adapter);

        // make sure that options does not crash
        openPrintOptions();

        if (!sDefaultPrinterBeenSet) {
            // Select printer under test
            selectPrinter(PRINTER_NAME);
        }

        mPrintHelper.submitPrintJob();

        if (!sDefaultPrinterBeenSet) {
            answerPrintServicesWarning(true);
            sDefaultPrinterBeenSet = true;
        }

        test.accept(layoutAttributes[0]);

        waitForPrinterDiscoverySessionDestroyCallbackCalled(1);
    }

    /**
     * That that you use a default color that is not in the allowed colors. This is allowed because
     * of historical reasons.
     *
     * @throws Exception If anything is unexpected
     */"	""	""	"getResolution()"	""
"7.4.5.3  Captive Portals"	"7.4.5.3"	"C-1-5"	"7.4.5.3/C-1-5"	""	"""C-1-5] MUST ensure that, while the user is logging in to a captive     portal, the default network used by applications (as returned by     [`ConnectivityManager.getActiveNetwork`](https://developer.android.com/reference/android/net/ConnectivityManager#getActiveNetwork%28%29),     [`ConnectivityManager.registerDefaultNetworkCallback`](https://developer.android.com/reference/android/net/ConnectivityManager#registerDefaultNetworkCallback%28android.net.ConnectivityManager.NetworkCallback%29),     and used by default by Java networking APIs such as java.net.Socket,     and native APIs such as connect()) is any other available network     that provides internet access, if available.  """	""	""	"ConnectivityManager.getActiveNetwork android.net.ConnectivityManager.NetworkCallback java.net.Socket ConnectivityManager.registerDefaultNetworkCallback connect()"	""	""	""	""	""	""	""	""	""	""	""	"android.net.cts.network.permission.InternetPermissionTest"	""	"CtsNetTestCases"	""	""	""	"/home/gpoor/cts-12-source/cts/tests/tests/netpermission/internetpermission/src/android/net/cts/network/permission/InternetPermissionTest.java"	""	"/*
 *.
 */

package android.net.cts.networkpermission.internetpermission;

import static org.junit.Assert.fail;

import androidx.test.filters.SmallTest;
import androidx.test.runner.AndroidJUnit4;

import org.junit.Test;
import org.junit.runner.RunWith;

import java.net.Socket;
/**
* Test that protected android.net.ConnectivityManager methods cannot be called without
* permissions
*/
@RunWith(AndroidJUnit4.class)
public class InternetPermissionTest {

    /**
     * Verify that create inet socket failed because of the permission is missing.
     * <p>Tests Permission:
     *   {@link android.Manifest.permission#INTERNET}.
     */
    @SmallTest"	""	""	"java.net.Socket"	""
"7.3.6  Thermometer"	"7.3.6"	"C-2-1"	"7.3.6/C-2-1"	""	"""C-2-1] MUST NOT define [`SENSOR_TYPE_AMBIENT_TEMPERATURE`](https://developer.android.com/reference/android/hardware/Sensor#TYPE_AMBIENT_TEMPERATURE)     for the temperature sensor.  """	""	""	"TYPE_AMBIENT_TEMPERATURE SENSOR_TYPE_AMBIENT_TEMPERATURE"	""	""	""	""	""	""	""	""	""	""	""	"android.app.cts.SystemFeaturesTest"	"testSensorFeatures"	"CtsAppTestCases"	""	""	""	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/SystemFeaturesTest.java"	""	"public void testSensorFeatures() throws Exception {
        Set<String> featuresLeft = getFeatureConstantsNames(""FEATURE_SENSOR_"");

        assertFeatureForSensor(featuresLeft, PackageManager.FEATURE_SENSOR_ACCELEROMETER,
                Sensor.TYPE_ACCELEROMETER);
        assertFeatureForSensor(featuresLeft, PackageManager.FEATURE_SENSOR_BAROMETER,
                Sensor.TYPE_PRESSURE);
        assertFeatureForSensor(featuresLeft, PackageManager.FEATURE_SENSOR_COMPASS,
                Sensor.TYPE_MAGNETIC_FIELD);
        assertFeatureForSensor(featuresLeft, PackageManager.FEATURE_SENSOR_GYROSCOPE,
                Sensor.TYPE_GYROSCOPE);
        assertFeatureForSensor(featuresLeft, PackageManager.FEATURE_SENSOR_LIGHT,
                Sensor.TYPE_LIGHT);
        assertFeatureForSensor(featuresLeft, PackageManager.FEATURE_SENSOR_PROXIMITY,
                Sensor.TYPE_PROXIMITY);
        assertFeatureForSensor(featuresLeft, PackageManager.FEATURE_SENSOR_STEP_COUNTER,
                Sensor.TYPE_STEP_COUNTER);
        assertFeatureForSensor(featuresLeft, PackageManager.FEATURE_SENSOR_STEP_DETECTOR,
                Sensor.TYPE_STEP_DETECTOR);
        assertFeatureForSensor(featuresLeft, PackageManager.FEATURE_SENSOR_AMBIENT_TEMPERATURE,
                Sensor.TYPE_AMBIENT_TEMPERATURE);
        assertFeatureForSensor(featuresLeft, PackageManager.FEATURE_SENSOR_RELATIVE_HUMIDITY,
                Sensor.TYPE_RELATIVE_HUMIDITY);
        assertFeatureForSensor(featuresLeft, PackageManager.FEATURE_SENSOR_HINGE_ANGLE,
                Sensor.TYPE_HINGE_ANGLE);


        /*
         * We have three cases to test for :
         * Case 1:  Device does not have an HRM
         * FEATURE_SENSOR_HEART_RATE               false
         * FEATURE_SENSOR_HEART_RATE_ECG           false
         * assertFeatureForSensor(TYPE_HEART_RATE) false
         *
         * Case 2:  Device has a PPG HRM
         * FEATURE_SENSOR_HEART_RATE               true
         * FEATURE_SENSOR_HEART_RATE_ECG           false
         * assertFeatureForSensor(TYPE_HEART_RATE) true
         *
         * Case 3:  Device has an ECG HRM
         * FEATURE_SENSOR_HEART_RATE               false
         * FEATURE_SENSOR_HEART_RATE_ECG           true
         * assertFeatureForSensor(TYPE_HEART_RATE) true
         */

        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_SENSOR_HEART_RATE_ECG)) {
                /* Case 3 for FEATURE_SENSOR_HEART_RATE_ECG true case */
                assertFeatureForSensor(featuresLeft, PackageManager.FEATURE_SENSOR_HEART_RATE_ECG,
                        Sensor.TYPE_HEART_RATE);

                /* Remove HEART_RATE from featuresLeft, no way to test that one */
                assertTrue(""Features left "" + featuresLeft + "" to check did not include ""
                        + PackageManager.FEATURE_SENSOR_HEART_RATE,
                        featuresLeft.remove(PackageManager.FEATURE_SENSOR_HEART_RATE));
        } else if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_SENSOR_HEART_RATE)) {
                /* Case 1 & 2 for FEATURE_SENSOR_HEART_RATE_ECG false case */
                assertFeatureForSensor(featuresLeft, PackageManager.FEATURE_SENSOR_HEART_RATE_ECG,
                        Sensor.TYPE_HEART_RATE);

                /* Case 1 & 3 for FEATURE_SENSOR_HEART_RATE false case */
                assertFeatureForSensor(featuresLeft, PackageManager.FEATURE_SENSOR_HEART_RATE,
                        Sensor.TYPE_HEART_RATE);
        } else {
                /* Case 2 for FEATURE_SENSOR_HEART_RATE true case */
                assertFeatureForSensor(featuresLeft, PackageManager.FEATURE_SENSOR_HEART_RATE,
                        Sensor.TYPE_HEART_RATE);

                /* Remove HEART_RATE_ECG from featuresLeft, no way to test that one */
                assertTrue(""Features left "" + featuresLeft + "" to check did not include ""
                        + PackageManager.FEATURE_SENSOR_HEART_RATE_ECG,
                        featuresLeft.remove(PackageManager.FEATURE_SENSOR_HEART_RATE_ECG));
        }

        assertTrue(""Assertions need to be added to this test for "" + featuresLeft,
                featuresLeft.isEmpty());
    }

    /** Get a list of feature constants in PackageManager matching a prefix. */
    private static Set<String> getFeatureConstantsNames(String prefix)
            throws IllegalArgumentException, IllegalAccessException {
        Set<String> features = new HashSet<String>();
        Field[] fields = PackageManager.class.getFields();
        for (Field field : fields) {
            if (field.getName().startsWith(prefix)) {
                String feature = (String) field.get(null);
                features.add(feature);
            }
        }
        return features;
    }"	""	""	"TYPE_AMBIENT_TEMPERATURE"	""
"3.2.3.5  Conditional Application Intents"	"3.2.3.5"	"C-3-2"	"3.2.3.5/C-3-2"	""	"""C-3-2] MUST honor [android.nfc.cardemulation.action.ACTION_CHANGE_DEFAULT](https://developer.android.com/reference/android/nfc/cardemulation/CardEmulation#ACTION_CHANGE_DEFAULT) intent to show an activity which opens a dialog to ask the user to change the default card emulation service for a certain category as described in the SDK.  If device implementations report `android.hardware.nfc`, they:  """	""	""	"android.nfc.cardemulation.action.ACTION ACTION_CHANGE_DEFAULT android.hardware.nfc"	""	""	""	""	""	""	""	""	""	""	""	"android.content.cts.AvailableIntentsTest"	"testChangeDefaultDialer"	"CtsContentTestCases"	""	""	""	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/AvailableIntentsTest.java"	""	"public void testChangeDefaultDialer() {
        PackageManager packageManager = mContext.getPackageManager();
        if (packageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            assertCanBeHandled(new Intent(TelecomManager.ACTION_CHANGE_DEFAULT_DIALER));
        }
    }"	""	""	"ACTION_CHANGE_DEFAULT"	""
"7.2.4  Touchscreen Input"	"7.2.4"	"C-3-2"	"7.2.4/C-3-2"	""	"""C-3-2] MUST report only `android.hardware.faketouch`. """	""	""	"android.hardware.faketouch"	""	""	""	""	""	""	""	""	""	""	""	"android.app.cts.SystemFeaturesTest"	"testFakeTouchFeatures"	"CtsAppTestCases"	""	""	""	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/SystemFeaturesTest.java"	""	"public void testFakeTouchFeatures() {
        // If device implementations declare support for android.hardware.faketouch, they:
        // [C-1-7] MUST report TOUCHSCREEN_NOTOUCH for the Configuration.touchscreen API field
        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_FAKETOUCH) &&
                !mPackageManager.hasSystemFeature(PackageManager.FEATURE_TOUCHSCREEN)) {
            // The device *only* supports faketouch, and does not have a touchscreen
            Configuration configuration = mContext.getResources().getConfiguration();
            assertEquals(configuration.touchscreen, Configuration.TOUCHSCREEN_NOTOUCH);
        }

        // If device implementations declare support for
        // android.hardware.faketouch.multitouch.distinct, they:
        // [C-2-1] MUST declare support for android.hardware.faketouch
        if (mPackageManager.hasSystemFeature(
                PackageManager.FEATURE_FAKETOUCH_MULTITOUCH_DISTINCT)) {
            assertAvailable(PackageManager.FEATURE_FAKETOUCH);
        }

        // If device implementations declare support for
        // android.hardware.faketouch.multitouch.jazzhand, they:
        // [C-3-1] MUST declare support for android.hardware.faketouch
        if (mPackageManager.hasSystemFeature(
                PackageManager.FEATURE_FAKETOUCH_MULTITOUCH_JAZZHAND)) {
            assertAvailable(PackageManager.FEATURE_FAKETOUCH);
        }
    }"	""	""	"android.hardware.faketouch"	""
"2.2.1  Hardware"	"7.1.4.6"	"H-1-3"	"7.1.4.6/H-1-3"	""	"""[7.1.4.6/H-1-3] MUST report conformant values      for the device’s GPU RenderStages following the      [render stage trace packet proto](https://android.googlesource.com/platform/external/perfetto/+/refs/heads/master/protos/perfetto/trace/gpu/gpu_render_stage_event.proto). *    ["""	""	""	"GPU gpu_render_stage_event.proto android.googlesource.com"	""	""	""	""	""	""	""	""	""	""	""	"android.dumpsys.cts.GfxInfoDumpsysTest"	"testGfxinfoFramestats"	"CtsDumpsysHostTestCases"	""	""	""	"/home/gpoor/cts-12-source/cts/hostsidetests/dumpsys/src/android/dumpsys/cts/GfxInfoDumpsysTest.java"	""	"public void testGfxinfoFramestats() throws Exception {
        final String MARKER = ""---PROFILEDATA---"";

        try {
            // cleanup test apps that might be installed from previous partial test run
            getDevice().uninstallPackage(TEST_PKG);

            // install the test app
            CompatibilityBuildHelper buildHelper = new CompatibilityBuildHelper(mCtsBuild);
            File testAppFile = buildHelper.getTestFile(TEST_APK);
            String installResult = getDevice().installPackage(testAppFile, false);
            assertNull(
                    String.format(""failed to install atrace test app. Reason: %s"", installResult),
                    installResult);

            getDevice().executeShellCommand(""am start -W "" + TEST_PKG);

            String frameinfo = mDevice.executeShellCommand(""dumpsys gfxinfo "" +
                    TEST_PKG + "" framestats"");
            assertNotNull(frameinfo);
            assertTrue(frameinfo.length() > 0);
            int profileStart = frameinfo.indexOf(MARKER);
            int profileEnd = frameinfo.indexOf(MARKER, profileStart + 1);
            assertTrue(profileStart >= 0);
            assertTrue(profileEnd > profileStart);
            String profileData = frameinfo.substring(profileStart + MARKER.length(), profileEnd);
            assertTrue(profileData.length() > 0);
            validateProfileData(profileData);
        } finally {
            getDevice().uninstallPackage(TEST_PKG);
        }
    }

    private void validateProfileData(String profileData) throws IOException {
        final int TIMESTAMP_COUNT = 22;
        boolean foundAtLeastOneRow = false;
        try (BufferedReader reader = new BufferedReader(
                new StringReader(profileData))) {
            String line;
            // First line needs to be the headers
            while ((line = reader.readLine()) != null && line.isEmpty()) {}

            assertNotNull(line);
            assertTrue(""First line was not the expected header: "" + line,
                    line.startsWith(""Flags,FrameTimelineVsyncId,IntendedVsync,Vsync""
                            + "",InputEventId,HandleInputStart,AnimationStart,PerformTraversalsStart""
                            + "",DrawStart,FrameDeadline,FrameInterval,FrameStartTime""
                            + "",SyncQueued,SyncStart,IssueDrawCommandsStart,SwapBuffers""
                            + "",FrameCompleted,DequeueBufferDuration,QueueBufferDuration""
                            + "",GpuCompleted,SwapBuffersCompleted,DisplayPresentTime""));

            long[] numparts = new long[TIMESTAMP_COUNT];
            while ((line = reader.readLine()) != null && !line.isEmpty()) {

                String[] parts = line.split("","");
                assertTrue(parts.length >= TIMESTAMP_COUNT);
                for (int i = 0; i < TIMESTAMP_COUNT; i++) {
                    numparts[i] = assertInteger(parts[i]);
                }

                final long flags = numparts[0];
                // Flags = 1 just means the first frame of the window
                if (flags != 0 && flags != 1) {
                    continue;
                }

                final long timestampIntendedVsync = numparts[2];
                final long timestampVsync = numparts[3];
                // skip InputEventId, since it's a randomly assigned id
                final long timestampHandleInputStart = numparts[5];
                final long timestampAnimationStart = numparts[6];
                final long timestampPerformTraversalsStart = numparts[7];
                final long timestampDrawStart = numparts[8];
                // skip FrameDeadline, FrameInterval,FrameStartTime
                final long timestampSyncQueued = numparts[12];
                final long timestampSyncStart = numparts[13];
                final long timestampIssueDrawCommandsStart = numparts[14];
                final long timestampSwapBuffers = numparts[15];
                final long timestampFrameCompleted = numparts[16];

                // assert time is flowing forwards. we need to check each entry explicitly
                // as some entries do not represent a flow of events.
                assertTrue(""VSYNC happened before INTENDED_VSYNC"",
                        timestampVsync >= timestampIntendedVsync);
                assertTrue(""HandleInputStart happened before VSYNC"",
                        timestampHandleInputStart >= timestampVsync);
                assertTrue(""AnimationStart happened before HandleInputStart"",
                        timestampAnimationStart >= timestampHandleInputStart);
                assertTrue(""PerformTraversalsStart happened before AnimationStart"",
                        timestampPerformTraversalsStart >= timestampAnimationStart);
                assertTrue(""DrawStart happened before PerformTraversalsStart"",
                        timestampDrawStart >= timestampPerformTraversalsStart);
                assertTrue(""SyncQueued happened before DrawStart"",
                        timestampSyncQueued >= timestampDrawStart);
                assertTrue(""SyncStart happened before SyncQueued"",
                        timestampSyncStart >= timestampSyncQueued);
                assertTrue(""IssueDrawCommandsStart happened before SyncStart"",
                        timestampIssueDrawCommandsStart >= timestampSyncStart);
                assertTrue(""SwapBuffers happened before IssueDrawCommandsStart"",
                        timestampSwapBuffers >= timestampIssueDrawCommandsStart);
                assertTrue(""FrameCompleted happened before SwapBuffers"",
                        timestampFrameCompleted >= timestampSwapBuffers);

                // total duration is from IntendedVsync to FrameCompleted
                long totalDuration = timestampFrameCompleted - timestampIntendedVsync;
                assertTrue(""Frame did not take a positive amount of time to process"",
                        totalDuration > 0);
                assertTrue(""Bogus frame duration, exceeds 100 seconds"",
                        totalDuration < TimeUnit.SECONDS.toNanos(100));
                foundAtLeastOneRow = true;
            }
        }
        assertTrue(foundAtLeastOneRow);
    }
}"	""	""	"GPU"	""
"7.4.5.1  Minimum Network Capability"	"7.4.5.1"	"C-0-1"	"7.4.5.1/C-0-1"	""	"""C-0-1] MUST include support for one or more forms of data networking. Specifically, device implementations MUST include support for at least one data standard capable of 200 Kbit/sec or greater. Examples of     technologies that satisfy this requirement include EDGE, HSPA, EV-DO,     802.11g, Ethernet and Bluetooth PAN. *   SHOULD also include support for at least one common wireless data standard, such as 802.11 (Wi-Fi), when a physical networking standard (such as Ethernet) is the primary data connection. *   MAY implement more than one form of data connectivity.  """	""	""	"PAN EDGE HSPA"	""	""	""	""	""	""	""	""	""	""	""	"android.widget.cts.ExpandableListViewTest"	"testDispatchDraw"	"CtsWidgetTestCases"	""	""	""	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/ExpandableListViewTest.java"	""	"public void testDispatchDraw() {
        MockExpandableListView expandableListView = new MockExpandableListView(mActivity);
        expandableListView.dispatchDraw(new Canvas());
    }

    private class MockExpandableListAdapter implements ExpandableListAdapter {
        private final LayoutInflater mLayoutInflater;

        public MockExpandableListAdapter() {
            mLayoutInflater = LayoutInflater.from(mActivity);
        }

        public void registerDataSetObserver(DataSetObserver observer) {
        }

        public void unregisterDataSetObserver(DataSetObserver observer) {
        }

        public int getGroupCount() {
            return 1;
        }

        public int getChildrenCount(int groupPosition) {
            switch (groupPosition) {
            case 0:
                return 1;
            default:
                return 0;
            }
        }

        public Object getGroup(int groupPosition) {
            switch (groupPosition) {
            case 0:
                return ""Data"";
            default:
                return null;
            }
        }

        public Object getChild(int groupPosition, int childPosition) {
            if (groupPosition == 0 && childPosition == 0)
                return ""child data"";
            else
                return null;
        }

        public long getGroupId(int groupPosition) {
            return 0;
        }

        public long getChildId(int groupPosition, int childPosition) {
            return 0;
        }

        public boolean hasStableIds() {
            return true;
        }

        public View getGroupView(int groupPosition, boolean isExpanded,
                View convertView, ViewGroup parent) {
            TextView result = (TextView) convertView;
            if (result == null) {
                result = (TextView) mLayoutInflater.inflate(
                        R.layout.expandablelistview_group, parent, false);
            }
            result.setText(""Group "" + groupPosition);
            return result;
        }

        public View getChildView(int groupPosition, int childPosition,
                boolean isLastChild, View convertView, ViewGroup parent) {
            TextView result = (TextView) convertView;
            if (result == null) {
                result = (TextView) mLayoutInflater.inflate(
                        R.layout.expandablelistview_child, parent, false);
            }
            result.setText(""Child "" + childPosition);
            return result;
        }

        public boolean isChildSelectable(int groupPosition, int childPosition) {
            return true;
        }

        public boolean areAllItemsEnabled() {
            return true;
        }

        public boolean isEmpty() {
            return true;
        }

        public void onGroupExpanded(int groupPosition) {
        }

        public void onGroupCollapsed(int groupPosition) {
        }

        public long getCombinedChildId(long groupId, long childId) {
            return 0;
        }

        public long getCombinedGroupId(long groupId) {
            return 0;
        }
    }

    private class MockExpandableListView extends ExpandableListView {
        public MockExpandableListView(Context context) {
            super(context);
        }

        public MockExpandableListView(Context context, AttributeSet attrs) {
            super(context, attrs);
        }

        public MockExpandableListView(Context context, AttributeSet attrs, int defStyle) {
            super(context, attrs, defStyle);
        }

        @Override
        protected void dispatchDraw(Canvas canvas) {
            super.dispatchDraw(canvas);
        }
    }
}"	""	""	"PAN"	""
"9.8.11  Data blobs sharing"	"9.8.11"	"C-1-1"	"9.8.11/C-1-1"	""	"""C-1-1] MUST NOT share data blobs belonging to apps beyond what they     intended to allow (i.e. the scope of default access and the other access     modes that can be specified using     [BlobStoreManager.session#allowPackageAccess()](     https://developer.android.com/reference/android/app/blob/BlobStoreManager.Session#allowPackageAccess%28java.lang.String%2C%2520byte%5B%5D%29),     [BlobStoreManager.session#allowSameSignatureAccess()](     https://developer.android.com/reference/android/app/blob/BlobStoreManager.Session#allowSameSignatureAccess%28%29),     or [BlobStoreManager.session#allowPublicAccess()](     https://developer.android.com/reference/android/app/blob/BlobStoreManager.Session#allowPublicAccess%28%29)     MUST NOT be modified). The AOSP reference implementation meets these     requirements.   """	""	""	"allowPackageAccess() BlobStoreManager.session BlobStoreManager.Session allowSameSignatureAccess() java.lang.String allowPublicAccess()"	""	""	""	""	""	""	""	""	""	""	""	"com.android.cts.device.blob.DataPersistenceTest"	"testCommitSession"	""	""	""	""	"/home/gpoor/cts-12-source/cts/hostsidetests/blobstore/test-apps/BlobStoreHostTestHelper/src/com/android/cts/device/blob/DataPersistenceTest.java"	""	"public void testCommitSession() throws Exception {
        final long sessionId = readSessionIdFromDisk();
        try (BlobStoreManager.Session session = mBlobStoreManager.openSession(sessionId)) {
            final CompletableFuture<Integer> callback = new CompletableFuture<>();
            session.commit(mContext.getMainExecutor(), callback::complete);
            assertThat(callback.get(TIMEOUT_COMMIT_CALLBACK_MS, TimeUnit.MILLISECONDS))
                    .isEqualTo(0);
        }
    }"	""	""	"BlobStoreManager.Session"	""
"3.2.3.5  Conditional Application Intents"	"3.2.3.5"	"C-13-1"	"3.2.3.5/C-13-1"	""	"""C-13-1] MUST honor the intent [`android.app.action.ADD_DEVICE_ADMIN`](https://developer.android.com/reference/android/app/admin/DevicePolicyManager#ACTION_ADD_DEVICE_ADMIN) to invoke a UI to bring the user through adding the device administrator to the system (or allowing them to reject it).  """	""	""	"ACTION_ADD_DEVICE_ADMIN android.app.action.ADD ADD_DEVICE_ADMIN"	""	""	""	""	""	""	""	""	""	""	""	"android.admin.cts.DeviceAdminActivationTest"	"testActivateBrokenReceiver5Fails"	"CtsAdminTestCases"	""	""	""	"/home/gpoor/cts-12-source/cts/tests/admin/src/android/admin/cts/DeviceAdminActivationTest.java"	""	"public void testActivateBrokenReceiver5Fails() throws Exception {
        if (!mDeviceAdmin) {
            Log.w(TAG, ""Skipping testActivateBrokenReceiver5Fails"");
            return;
        }
        assertDeviceAdminDeactivated(CtsDeviceAdminBrokenReceiver5.class);
        startAddDeviceAdminActivityForResult(CtsDeviceAdminBrokenReceiver5.class);
        assertWithTimeoutOnActivityResultInvokedWithResultCode(Activity.RESULT_CANCELED);
        assertDeviceAdminDeactivated(CtsDeviceAdminBrokenReceiver5.class);
    }

    private void startAddDeviceAdminActivityForResult(Class<?> receiverClass) {
        getActivity().startActivityForResult(
                getAddDeviceAdminIntent(receiverClass),
                REQUEST_CODE_ACTIVATE_ADMIN);
    }

    private Intent getAddDeviceAdminIntent(Class<?> receiverClass) {
        return new Intent(DevicePolicyManager.ACTION_ADD_DEVICE_ADMIN)
            .putExtra(
                    DevicePolicyManager.EXTRA_DEVICE_ADMIN,
                    new ComponentName(
                            getInstrumentation().getTargetContext(),
                            receiverClass));
    }

    private void assertWithTimeoutOnActivityResultNotInvoked() {
        SystemClock.sleep(UI_EFFECT_TIMEOUT_MILLIS);
        Mockito.verify(mMockOnActivityResultListener, Mockito.never())
                .onActivityResult(
                        Mockito.eq(REQUEST_CODE_ACTIVATE_ADMIN),
                        Mockito.anyInt(),
                        Mockito.nullable(Intent.class));
    }

    private void assertWithTimeoutOnActivityResultInvokedWithResultCode(int expectedResultCode) {
        ArgumentCaptor<Integer> resultCodeCaptor = ArgumentCaptor.forClass(int.class);
        Mockito.verify(mMockOnActivityResultListener, Mockito.timeout(UI_EFFECT_TIMEOUT_MILLIS))
                .onActivityResult(
                        Mockito.eq(REQUEST_CODE_ACTIVATE_ADMIN),
                        resultCodeCaptor.capture(),
                        Mockito.nullable(Intent.class));
        assertEquals(expectedResultCode, (int) resultCodeCaptor.getValue());
    }

    private void finishActivateDeviceAdminActivity() {
        getActivity().finishActivity(REQUEST_CODE_ACTIVATE_ADMIN);
    }

    private void assertDeviceAdminDeactivated(Class<?> receiverClass) {
        DevicePolicyManager devicePolicyManager =
                (DevicePolicyManager) getActivity().getSystemService(
                        Context.DEVICE_POLICY_SERVICE);
        assertFalse(devicePolicyManager.isAdminActive(
                new ComponentName(getInstrumentation().getTargetContext(), receiverClass)));
    }
}"	""	""	"ADD_DEVICE_ADMIN"	""
"9.8.10  Connectivity Bug Report"	"9.8.10"	"C-1-1"	"9.8.10/C-1-1"	""	"""C-1-1] MUST obtain user consent every time the System API     `BUGREPORT_MODE_TELEPHONY` is called to generate a report and MUST NOT     prompt the user to consent to all future requests from the application. """	""	""	"BUGREPORT_MODE_TELEPHONY"	""	""	""	""	""	""	""	""	""	""	""	"android.carrierapi.cts.BugreportManagerTest"	"hasEarlyReportFinished"	"CtsCarrierApiTestCases"	""	""	""	"/home/gpoor/cts-12-source/cts/tests/tests/carrierapi/src/android/carrierapi/cts/BugreportManagerTest.java"	""	"public void startBugreport_connectivityBugreport() throws Exception {
        BugreportCallbackImpl callback = new BugreportCallbackImpl();

        assertThat(callback.hasEarlyReportFinished()).isFalse();
        // Carrier apps that compile with the system SDK have visibility to use this API, so we need
        // to enforce that the additional parameters can't be abused to e.g. surreptitiously capture
        // screenshots.
        mBugreportManager.startBugreport(
                mBugreportFd,
                mScreenshotFd,
                new BugreportParams(BugreportParams.BUGREPORT_MODE_TELEPHONY),
                Runnable::run,
                callback);
        setConsentDialogReply(ConsentReply.ALLOW);
        waitUntilDoneOrTimeout(callback);

        assertThat(callback.isSuccess()).isTrue();
        assertThat(callback.hasEarlyReportFinished()).isTrue();
        assertThat(callback.hasReceivedProgress()).isTrue();
        assertThat(mBugreportFile.length()).isGreaterThan(0L);
        assertFdIsClosed(mBugreportFd);
        // Screenshots are never captured for connectivity bugreports, even if an FD is passed in.
        assertThat(mScreenshotFile.length()).isEqualTo(0L);
        assertFdIsClosed(mScreenshotFd);
    }"	""	""	"BUGREPORT_MODE_TELEPHONY"	""
"3.2.3.5  Conditional Application Intents"	"3.2.3.5"	"C-5-2"	"3.2.3.5/C-5-2"	""	"""C-5-2] MUST honor the [‘android.bluetooth.adapter.action.REQUEST_DISCOVERABLE’](https://developer.android.com/reference/android/bluetooth/BluetoothAdapter#ACTION_REQUEST_DISCOVERABLE) intent and show a system activity that requests discoverable mode.  If device implementations support the DND feature, they:  """	""	""	"REQUEST_DISCOVERABLE ACTION_REQUEST_DISCOVERABLE android.bluetooth.adapter.action.REQUEST DND"	""	""	""	""	""	""	""	""	""	""	""	"android.app.cts.NotificationManagerTest"	"testSetAutomaticZenRuleState_multipleRules"	"CtsAppTestCases"	""	""	""	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/NotificationManagerTest.java"	""	"public void testSetAutomaticZenRuleState_multipleRules() throws Exception {
        toggleNotificationPolicyAccess(mContext.getPackageName(),
                InstrumentationRegistry.getInstrumentation(), true);

        AutomaticZenRule ruleToCreate = createRule(""Rule"");
        String id = mNotificationManager.addAutomaticZenRule(ruleToCreate);
        mRuleIds.add(id);

        AutomaticZenRule secondRuleToCreate = createRule(""Rule 2"");
        secondRuleToCreate.setInterruptionFilter(INTERRUPTION_FILTER_NONE);
        String secondId = mNotificationManager.addAutomaticZenRule(secondRuleToCreate);
        mRuleIds.add(secondId);

        // make sure DND is off
        assertExpectedDndState(INTERRUPTION_FILTER_ALL);

        // enable DND
        Condition condition =
                new Condition(ruleToCreate.getConditionId(), ""summary"", Condition.STATE_TRUE);
        mNotificationManager.setAutomaticZenRuleState(id, condition);
        Condition secondCondition =
                new Condition(secondRuleToCreate.getConditionId(), ""summary"", Condition.STATE_TRUE);
        mNotificationManager.setAutomaticZenRuleState(secondId, secondCondition);

        // the second rule has a 'more silent' DND filter, so the system wide DND should be
        // using its filter
        assertExpectedDndState(secondRuleToCreate.getInterruptionFilter());

        // remove intense rule, system should fallback to other rule
        mNotificationManager.removeAutomaticZenRule(secondId);
        assertExpectedDndState(ruleToCreate.getInterruptionFilter());
    }"	""	""	"DND"	""
"3.18  Contacts"	"3.18"	"C-1-2"	"3.18/C-1-2"	""	"""C-1-2] The      [`ACCOUNT_TYPE`](https://developer.android.com/reference/android/provider/ContactsContract.SyncColumns.html#ACCOUNT_TYPE),      of the **custom local account** MUST be returned by      [`ContactsContract.RawContacts.getLocalAccountType`](https://developer.android.com/reference/android/provider/ContactsContract.RawContacts.html#getLocalAccountType\(\)) """	""	""	"ContactsContract.RawContacts.getLocalAccountType ContactsContract.SyncColumns.html ContactsContract.RawContacts.html ACCOUNT_TYPE"	""	""	""	""	""	""	""	""	""	""	""	"android.accounts.cts.AbstractAuthenticatorTests"	"testFinishSessionAndStartUpdateCredentialsSessionDefaultImpl"	"CtsAccountManagerTestCases"	""	""	""	"/home/gpoor/cts-12-source/cts/tests/tests/accounts/src/android/accounts/cts/AbstractAuthenticatorTests.java"	""	"public void testFinishSessionAndStartUpdateCredentialsSessionDefaultImpl()
            throws OperationCanceledException, AuthenticatorException, IOException,
            RemoteException {
        Bundle options = new Bundle();
        String accountName = Fixtures.PREFIX_NAME_SUCCESS + ""@"" + Fixtures.SUFFIX_NAME_FIXTURE;
        options.putString(Fixtures.KEY_ACCOUNT_NAME, accountName);

        // First obtain an encrypted session bundle from startUpdateCredentialsSession(...) default
        // implementation.
        AccountManagerFuture<Bundle> future = mAccountManager.startUpdateCredentialsSession(
                Fixtures.ACCOUNT_DEFAULT,
                null /* authTokenTYpe */,
                options,
                null /* activity */,
                null /* callback */,
                null /* handler */);

        Bundle result = future.getResult();
        assertTrue(future.isDone());
        assertNotNull(result);

        // Assert that result contains a non-null session bundle.
        Bundle escrowBundle = result.getBundle(AccountManager.KEY_ACCOUNT_SESSION_BUNDLE);
        assertNotNull(escrowBundle);

        // Now call finishSession(...) with the session bundle we just obtained.
        future = mAccountManager.finishSession(
                escrowBundle,
                null /* activity */,
                null /* callback */,
                null /* handler */);

        result = future.getResult();
        assertTrue(future.isDone());
        assertNotNull(result);

        // Validate that parameters are passed to updateCredentials(...) correctly in default
        // finishSession implementation.
        Bundle providerBundle = mProviderClient.call(
                AuthenticatorContentProvider.METHOD_GET,
                null /* arg */,
                null /* extras */);
        providerBundle.setClassLoader(UpdateCredentialsTx.class.getClassLoader());
        UpdateCredentialsTx updateCredentialsTx = providerBundle
                .getParcelable(AuthenticatorContentProvider.KEY_TX);
        assertNotNull(updateCredentialsTx);

        // Assert parameters has been passed to updateCredentials(...) correctly
        assertEquals(Fixtures.ACCOUNT_DEFAULT, updateCredentialsTx.account);
        assertNull(updateCredentialsTx.authTokenType);

        validateSystemOptions(updateCredentialsTx.options);
        // Validate options
        assertNotNull(updateCredentialsTx.options);
        assertEquals(accountName, updateCredentialsTx.options.getString(Fixtures.KEY_ACCOUNT_NAME));

        // Assert returned result contains correct account name, account type and null auth token.
        assertEquals(accountName, result.get(AccountManager.KEY_ACCOUNT_NAME));
        assertEquals(Fixtures.TYPE_DEFAULT, result.get(AccountManager.KEY_ACCOUNT_TYPE));
        assertNull(result.get(AccountManager.KEY_AUTHTOKEN));
    }

    private void validateSystemOptions(Bundle options) {
        assertNotNull(options.getString(AccountManager.KEY_ANDROID_PACKAGE_NAME));
        assertTrue(options.containsKey(AccountManager.KEY_CALLER_UID));
        assertTrue(options.containsKey(AccountManager.KEY_CALLER_PID));
    }

    private void validateNullPasswordAndStatusToken(Bundle result) {
        assertNull(result.getString(AccountManager.KEY_PASSWORD));
        assertNull(result.getString(AccountManager.KEY_ACCOUNT_STATUS_TOKEN));
    }

    /**
     * Tests isCredentialsUpdateSuggested default implementation.
     * A bundle with boolean false should be returned.
     */"	""	""	"ACCOUNT_TYPE"	""
"7.3  Sensors"	"7.3"	"C-1-6"	"7.3/C-1-6"	""	"""C-1-6] MUST [report the event time]( http://developer.android.com/reference/android/hardware/SensorEvent.html#timestamp) in nanoseconds as defined in the Android SDK documentation, representing the time the event happened and synchronized with the SystemClock.elapsedRealtimeNano() clock.  | C-1-6] MUST set a non-zero resolution for all sensors, and report the value     via the [`Sensor.getResolution()`](https://developer.android.com/reference/android/hardware/Sensor#getResolution%28%29)     API method.  Some sensor types are composite, meaning they can be derived from data provided by one or more other sensors. (Examples include the orientation sensor and the linear acceleration sensor.)  Device implementations:  *   SHOULD implement these sensor types, when they include the prerequisite physical sensors as described in [sensor types](https://source.android.com/devices/sensors/sensor-types.html).  If device implementations include a composite sensor, they:  """	""	""	"SensorEvent.html Sensor.getResolution types.html getResolution() elapsedRealtimeNano() SystemClock.elapsedRealtimeNano"	""	""	""	""	""	""	""	""	""	""	""	"android.telephony.cts.SmsManagerTest"	"testSmsBlocking"	"CtsTelephonyTestCases"	""	""	""	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/SmsManagerTest.java"	""	"public void testSmsBlocking() throws Exception {
        assertFalse(""[RERUN] SIM card does not provide phone number. Use a suitable SIM Card."",
                TextUtils.isEmpty(mDestAddr));

        // disable suppressing blocking.
        TelephonyUtils.endBlockSuppression(getInstrumentation());

        String mccmnc = mTelephonyManager.getSimOperator();
        // Setting default SMS App is needed to be able to block numbers.
        setDefaultSmsApp(true);
        blockNumber(mDestAddr);

        // single-part SMS blocking
        init();
        sendTextMessage(mDestAddr, String.valueOf(SystemClock.elapsedRealtimeNanos()),
                mSentIntent, mDeliveredIntent);
        assertTrue(""[RERUN] Could not send SMS. Check signal."",
                mSendReceiver.waitForCalls(1, TIME_OUT));
        assertTrue(""Expected no messages to be received due to number blocking."",
                mSmsReceivedReceiver.verifyNoCalls(NO_CALLS_TIMEOUT_MILLIS));
        assertTrue(""Expected no messages to be delivered due to number blocking."",
                mSmsDeliverReceiver.verifyNoCalls(NO_CALLS_TIMEOUT_MILLIS));

        // send data sms
        if (!sendDataMessageIfSupported(mccmnc)) {
            assertTrue(""[RERUN] Could not send data SMS. Check signal."",
                    mSendReceiver.waitForCalls(1, TIME_OUT));
            if (mDeliveryReportSupported) {
                assertTrue(""[RERUN] Data SMS message delivery notification not received. "" +
                        ""Check signal."", mDeliveryReceiver.waitForCalls(1, TIME_OUT));
            }
            assertTrue(""Expected no messages to be delivered due to number blocking."",
                    mSmsDeliverReceiver.verifyNoCalls(NO_CALLS_TIMEOUT_MILLIS));
        } else {
            // This GSM network doesn't support Data(binary) SMS message.
            // Skip the test.
        }

        // multi-part SMS blocking
        int numPartsSent = sendMultipartTextMessageIfSupported(mccmnc, /* addMessageId= */ false);
        if (numPartsSent > 0) {
            assertTrue(""[RERUN] Could not send multi part SMS. Check signal."",
                    mSendReceiver.waitForCalls(numPartsSent, TIME_OUT));

            assertTrue(""Expected no messages to be received due to number blocking."",
                    mSmsReceivedReceiver.verifyNoCalls(NO_CALLS_TIMEOUT_MILLIS));
            assertTrue(""Expected no messages to be delivered due to number blocking."",
                    mSmsDeliverReceiver.verifyNoCalls(NO_CALLS_TIMEOUT_MILLIS));
        } else {
            // This GSM network doesn't support Multipart SMS message.
            // Skip the test.
        }
    }"	""	""	"SystemClock.elapsedRealtimeNano"	""
"4  Application Packaging Compatibility"	"4"	"C-0-9"	"4/C-0-9"	""	"""C-0-9] MUST support verifying .apk files using the      [APK Signature Scheme v4](https://source.android.com/security/apksigning/v4.html).  *    If device implementations are already launched on an earlier Android      version and cannot meet the requirements [C-0-8] and [C-0-9] through a      system software update, they MAY be exempted from these requirements. """	""	""	"v4.html APK"	""	""	""	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.CrossProfileAppsPermissionHostSideTest"	"testCreateRequestInteractAcrossProfilesIntent_canNotRequestInteraction_throwsSecurityException"	"CtsDevicePolicyManagerTestCases"	""	""	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/CrossProfileAppsPermissionHostSideTest.java"	""	"public void testCreateRequestInteractAcrossProfilesIntent_canNotRequestInteraction_throwsSecurityException()
            throws Exception {
        installAppAsUser(TEST_WITH_REQUESTED_PERMISSION_APK, mPrimaryUserId);

        runDeviceTestsAsUser(
                TEST_WITH_REQUESTED_PERMISSION_PACKAGE,
                TEST_WITH_REQUESTED_PERMISSION_CLASS,
                ""testCreateRequestInteractAcrossProfilesIntent_canNotRequestInteraction_throwsSecurityException"",
                mProfileId,
                Collections.EMPTY_MAP);
    }

    private void addManagedProfileAndInstallRequiredPackages(String testPackage) throws Exception {
        mProfileId = createManagedProfile(mPrimaryUserId);
        getDevice().startUser(mProfileId, /*waitFlag= */true);

        installAppAsUser(testPackage, mProfileId);

        installAppAsUser(MANAGED_PROFILE_APK, mProfileId);
        setProfileOwnerOrFail(MANAGED_PROFILE_PKG + ""/"" + ADMIN_RECEIVER_TEST_CLASS,
                mProfileId);
    }

    private void addDefaultCrossProfilePackage(int userId, String packageName)
            throws Exception {
        runDeviceTestsAsUser(
                MANAGED_PROFILE_PKG,
                "".CrossProfileUtils"",
                ""testSetCrossProfilePackages"",
                userId,
                createCrossProfilePackageParam(packageName));
    }

    private Map<String, String> createCrossProfilePackageParam(String packageName) {
        return Collections.singletonMap(PARAM_CROSS_PROFILE_PACKAGE, packageName);
    }
}"	""	""	"APK"	""
"9.10  Device Integrity"	"9.10"	"C-0-5"	"9.10/C-0-5"	""	"""C-0-5] MUST enable the above-described cryptographic file verification      protection for all files for the package that is installed      with trusted signature files as described [here](      https://developer.android.com/preview/security/features/apk-verity).  If device implementations are already launched without the ability to verify file content against a trusted key on an earlier Android version and can not add support for this feature with a system software update, they MAY be exempted from the requirement. The upstream Android Open Source project provides a preferred implementation of this feature based on the Linux kernel [fs-verity]( https://www.kernel.org/doc/html/latest/filesystems/fsverity.html) feature.  Device implementations:  """	""	""	"www.kernel.org fsverity.html"	""	""	""	""	""	""	""	""	""	""	""	"android.security.cts.HwRngTest"	"testConfigurationIfFilePresent"	"CtsSecurityTestCases"	""	""	""	"/home/gpoor/cts-12-source/cts/tests/tests/security/src/android/security/cts/HwRngTest.java"	""	"public void testConfigurationIfFilePresent() throws Exception {
        if (!DEV_HW_RANDOM.exists()) {
            // The device is not present
            return;
        }

        // Quick check based on https://www.kernel.org/doc/Documentation/hw_random.txt.

        // In short, assert that:
        // 1. hwrng kernel driver is using MAJOR 10 and MINOR 183,
        // 2. a driver is selected in the hrwng framework, and
        // 3. /dev/hw_random references a character device with the above MAJOR and MINOR.

        // 1. Assert that the hwrng driver is using MAJOR 10 and MINOR 183.
        //    We achieve this by inspecting /sys/class/misc/hw_random/dev and uevent.
        assertTrue(SYSFS_HW_RANDOM + "" not found"", SYSFS_HW_RANDOM.isDirectory());
        assertEquals(
                ""Driver major:minor"",
                HWRNG_DRIVER_MAJOR + "":"" + HWRNG_DRIVER_MINOR,
                readyFullyAsciiFile(new File(SYSFS_HW_RANDOM, ""dev"")).trim());

        Map<String, String> ueventVars = parseUeventFile(new File(SYSFS_HW_RANDOM, ""uevent""));
        assertEquals(""uevent MAJOR"", String.valueOf(HWRNG_DRIVER_MAJOR), ueventVars.get(""MAJOR""));
        assertEquals(""uevent MINOR"", String.valueOf(HWRNG_DRIVER_MINOR), ueventVars.get(""MINOR""));
        assertEquals(""uevent DEVNAME"", HWRNG_DRIVER_NAME, ueventVars.get(""DEVNAME""));

        // 2. Assert that a driver is selected in the hrwng framework.
        //    We achieve this by inspecting /sys/class/misc/hw_random/rng_current.
        File rngCurrentFile = new File(SYSFS_HW_RANDOM, ""rng_current"");
        String rngCurrent = readyFullyAsciiFile(rngCurrentFile);
        assertFalse(
                ""No driver selected according to "" + rngCurrentFile,
                rngCurrent.trim().isEmpty());

        // 3. Assert that /dev/hw_random references a character device with the above MAJOR+MINOR.
        try {
            int major = LinuxRngTest.getCharDeviceMajor(DEV_HW_RANDOM.getCanonicalPath());
            int minor = LinuxRngTest.getCharDeviceMinor(DEV_HW_RANDOM.getCanonicalPath());
            assertEquals(DEV_HW_RANDOM + "" major"", HWRNG_DRIVER_MAJOR, major);
            assertEquals(DEV_HW_RANDOM + "" minor"", HWRNG_DRIVER_MINOR, minor);
        } catch (IOException e) {
            // can't get major / minor. Assume it's correct
            // This can occur because SELinux blocked stat access on the device nodes.
        }
    }

    private static String readyFullyAsciiFile(File file) throws IOException {
        InputStream in = null;
        try {
            in = new FileInputStream(file);
            return new String(readyFully(in), ""US-ASCII"");
        } finally {
            closeSilently(in);
        }
    }

    private static byte[] readyFully(InputStream in) throws IOException {
        ByteArrayOutputStream result = new ByteArrayOutputStream();
        byte[] buffer = new byte[16 * 1024];
        int chunkSize;
        while ((chunkSize = in.read(buffer)) != -1) {
            result.write(buffer, 0, chunkSize);
        }
        return result.toByteArray();
    }

    private static Map<String, String> parseUeventFile(File file) throws IOException {
        // The format of the file is line-oriented.
        // Each variable takes up one line.
        // The typical format of a variable is KEY=VALUE

        Map<String, String> result = new HashMap<String, String>();
        BufferedReader in = null;
        try {
            in = new BufferedReader(new InputStreamReader(new FileInputStream(file), ""US-ASCII""));
            String line;
            while ((line = in.readLine()) != null) {
                if (line.trim().length() == 0) {
                    // Ignore empty lines
                    continue;
                }

                String key;
                String value;
                int delimiterIndex = line.indexOf('=');
                if (delimiterIndex != -1) {
                    key = line.substring(0, delimiterIndex);
                    value = line.substring(delimiterIndex + 1);
                } else {
                    key = line;
                    value = """";
                }

                if (result.containsKey(key)) {
                    throw new IllegalArgumentException(""Multiple values for key: "" + key);
                }
                result.put(key, value);
            }
            return result;
        } finally {
            closeSilently(in);
        }
    }

    private static void closeSilently(Closeable in) {
        if (in != null) {
            try {
                in.close();
            } catch (IOException ignored) {}
        }
    }
}"	""	""	"www.kernel.org"	""
"3.2.3.5  Conditional Application Intents"	"3.2.3.5"	"C-5-1"	"3.2.3.5/C-5-1"	""	"""C-5-1] MUST honor the [‘android.bluetooth.adapter.action.REQUEST_ENABLE’](https://developer.android.com/reference/kotlin/android/bluetooth/BluetoothAdapter#action_request_enable) intent and show a system activity to allow the user to turn on Bluetooth.  """	""	""	"REQUEST_ENABLE android.bluetooth.adapter.action.REQUEST"	""	""	""	""	""	""	""	""	""	""	""	"android.content.cts.AvailableIntentsTest"	"testRequestEnableContentCaptureIntent"	"CtsContentTestCases"	""	""	""	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/AvailableIntentsTest.java"	""	"public void testRequestEnableContentCaptureIntent() {
        if (!hasService(Context.CONTENT_CAPTURE_MANAGER_SERVICE)) return;

        Intent intent = new Intent(Settings.ACTION_REQUEST_ENABLE_CONTENT_CAPTURE);
        assertCanBeHandled(intent);
    }"	""	""	"REQUEST_ENABLE"	""
"7.3.10  Biometric Sensors"	"7.3.10"	"C-5-2"	"7.3.10/C-5-2"	""	"""C-5-2] MUST additionally implement an implicit authentication flow     (without confirmation step) corresponding to     [setConfirmationRequired(boolean)](https://developer.android.com/reference/android/hardware/biometrics/BiometricPrompt.Builder#setConfirmationRequired%28boolean%29),     which applications can set to utilize for sign-in flows.  If device implementations have multiple biometric sensors, they:  """	""	""	"setConfirmationRequired(boolean) BiometricPrompt.Builder"	""	""	""	""	""	""	""	""	""	""	""	"android.hardware.biometrics.cts.BiometricPromptTest"	"test_setAllowedAuthenticators_withDeviceCredential"	"CtsHardwareTestCases"	""	""	""	"/home/gpoor/cts-12-source/cts/tests/tests/hardware/src/android/hardware/biometrics/cts/BiometricPromptTest.java"	""	"public void test_setAllowedAuthenticators_withDeviceCredential() {
        final BiometricPrompt.Builder promptBuilder = new BiometricPrompt.Builder(getContext())
                .setTitle(""Title"");

        final int[] authenticatorCombinations = {
                Authenticators.DEVICE_CREDENTIAL,
                Authenticators.BIOMETRIC_WEAK | Authenticators.DEVICE_CREDENTIAL,
                Authenticators.BIOMETRIC_STRONG | Authenticators.DEVICE_CREDENTIAL
        };
        for (final int authenticators : authenticatorCombinations) {
            final BiometricPrompt prompt = promptBuilder
                    .setAllowedAuthenticators(authenticators)
                    .build();
            assertEquals(authenticators, prompt.getAllowedAuthenticators());
        }
    }
}"	""	""	"BiometricPrompt.Builder"	""
"9.11.3  Identity Credential"	"9.11.3"	"C-0-1"	"9.11.3/C-0-1"	""	"""C-0-1] MUST return non-null for the [IdentityCredentialStore#getInstance()](      https://developer.android.com/reference/android/security/identity/IdentityCredentialStore#getInstance%28android.content.Context%29)      method.  """	""	""	"getInstance() android.content.Context"	""	""	""	""	""	""	""	""	""	""	""	"android.net.wifi.cts.MultiStaConcurrencyWifiNetworkSpecifierTest"	"isStaConcurrencyForLocalOnlyConnectionsSupported"	"CtsWifiTestCases"	""	""	""	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/MultiStaConcurrencyWifiNetworkSpecifierTest.java"	""	"/*
 *.
 */

package android.net.wifi.cts;

import static android.os.Process.myUid;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import static org.junit.Assume.assumeTrue;

import android.content.Context;
import android.content.pm.PackageManager;
import android.location.LocationManager;
import android.net.ConnectivityManager;
import android.net.NetworkRequest;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiManager;
import android.net.wifi.WifiNetworkSpecifier;
import android.os.Build;
import android.platform.test.annotations.AppModeFull;
import android.support.test.uiautomator.UiDevice;

import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.filters.LargeTest;
import androidx.test.filters.SdkSuppress;
import androidx.test.platform.app.InstrumentationRegistry;

import com.android.compatibility.common.util.PollingCheck;
import com.android.compatibility.common.util.ShellIdentityUtils;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.List;

/**
 * Tests multiple concurrent connection flow on devices that support multi STA concurrency
 * (indicated via {@link WifiManager#isStaConcurrencyForLocalOnlyConnectionsSupported()}.
 *
 * Tests the entire connection flow using {@link WifiNetworkSpecifier} embedded in a
 * {@link NetworkRequest} & passed into {@link ConnectivityManager#requestNetwork(NetworkRequest,
 * ConnectivityManager.NetworkCallback)} along with a concurrent internet connection using
 * {@link WifiManager#connect(int, WifiManager.ActionListener)}.
 *
 * Assumes that all the saved networks is either open/WPA1/WPA2/WPA3 authenticated network.
 *
 * TODO(b/177591382): Refactor some of the utilities to a separate file that are copied over from
 * WifiManagerTest & WifiNetworkSpecifierTest.
 */
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)
@AppModeFull(reason = ""Cannot get WifiManager in instant app mode"")
@LargeTest
@RunWith(AndroidJUnit4.class)
public class MultiStaConcurrencyWifiNetworkSpecifierTest extends WifiJUnit4TestBase {
    private static final String TAG = ""MultiStaConcurrencyWifiNetworkSpecifierTest"";
    private static boolean sWasVerboseLoggingEnabled;
    private static boolean sWasScanThrottleEnabled;
    private static boolean sWasWifiEnabled;

    private Context mContext;
    private WifiManager mWifiManager;
    private ConnectivityManager mConnectivityManager;
    private UiDevice mUiDevice;
    private WifiConfiguration mTestNetworkForPeerToPeer;
    private WifiConfiguration mTestNetworkForInternetConnection;
    private ConnectivityManager.NetworkCallback mNetworkCallback;
    private ConnectivityManager.NetworkCallback mNrNetworkCallback;
    private TestHelper mTestHelper;

    private static final int DURATION = 10_000;
    private static final int DURATION_UI_INTERACTION = 25_000;
    private static final int DURATION_NETWORK_CONNECTION = 60_000;
    private static final int DURATION_SCREEN_TOGGLE = 2000;
    private static final int SCAN_RETRY_CNT_TO_FIND_MATCHING_BSSID = 3;

    @BeforeClass
    public static void setUpClass() throws Exception {
        Context context = InstrumentationRegistry.getInstrumentation().getContext();
        // skip the test if WiFi is not supported. Don't use assumeTrue in @BeforeClass
        if (!WifiFeature.isWifiSupported(context)) return;

        WifiManager wifiManager = context.getSystemService(WifiManager.class);
        assertThat(wifiManager).isNotNull();

        // turn on verbose logging for tests
        sWasVerboseLoggingEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.isVerboseLoggingEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setVerboseLoggingEnabled(true));
        // Disable scan throttling for tests.
        sWasScanThrottleEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.isScanThrottleEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setScanThrottleEnabled(false));

        // enable Wifi
        sWasWifiEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.isWifiEnabled());
        if (!wifiManager.isWifiEnabled()) {
            ShellIdentityUtils.invokeWithShellPermissions(() -> wifiManager.setWifiEnabled(true));
        }
        PollingCheck.check(""Wifi not enabled"", DURATION, () -> wifiManager.isWifiEnabled());
    }

    @AfterClass
    public static void tearDownClass() throws Exception {
        Context context = InstrumentationRegistry.getInstrumentation().getContext();
        if (!WifiFeature.isWifiSupported(context)) return;

        WifiManager wifiManager = context.getSystemService(WifiManager.class);
        assertThat(wifiManager).isNotNull();

        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setScanThrottleEnabled(sWasScanThrottleEnabled));
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setVerboseLoggingEnabled(sWasVerboseLoggingEnabled));
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setWifiEnabled(sWasWifiEnabled));
    }

    @Before
    public void setUp() throws Exception {
        mContext = InstrumentationRegistry.getInstrumentation().getContext();
        mWifiManager = mContext.getSystemService(WifiManager.class);
        mConnectivityManager = mContext.getSystemService(ConnectivityManager.class);
        mUiDevice = UiDevice.getInstance(InstrumentationRegistry.getInstrumentation());
        mTestHelper = new TestHelper(mContext, mUiDevice);

        // skip the test if WiFi is not supported
        assumeTrue(WifiFeature.isWifiSupported(mContext));
        // skip the test if location is not supported
        assumeTrue(mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_LOCATION));
        // skip if multi STA not supported.
        assumeTrue(mWifiManager.isStaConcurrencyForLocalOnlyConnectionsSupported());

        assertWithMessage(""Please enable location for this test!"")
                .that(mContext.getSystemService(LocationManager.class).isLocationEnabled())
                .isTrue();

        // turn screen on
        mTestHelper.turnScreenOn();

        // Clear any existing app state before each test.
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.removeAppState(myUid(), mContext.getPackageName()));

        // We need 2 AP's for the test. If there are 2 networks saved on the device and in range,
        // use those. Otherwise, check if there are 2 BSSID's in range for the only saved network.
        // This assumes a CTS test environment with at least 2 connectable bssid's (Is that ok?).
        List<WifiConfiguration> savedNetworks = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.getPrivilegedConfiguredNetworks());
        List<WifiConfiguration> matchingNetworksWithBssid =
                TestHelper.findMatchingSavedNetworksWithBssid(mWifiManager, savedNetworks);
        assertWithMessage(""Need at least 2 saved network bssids in range"")
                .that(matchingNetworksWithBssid.size()).isAtLeast(2);
        // Pick any 2 bssid for test.
        mTestNetworkForPeerToPeer = matchingNetworksWithBssid.get(0);
        // Try to find a bssid for another saved network in range. If none exists, fallback
        // to using 2 bssid's for the same network.
        mTestNetworkForInternetConnection = matchingNetworksWithBssid.stream()
                .filter(w -> !w.SSID.equals(mTestNetworkForPeerToPeer.SSID))
                .findAny()
                .orElse(matchingNetworksWithBssid.get(1));

        // Disconnect & disable auto-join on the saved network to prevent auto-connect from
        // interfering with the test.
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> {
                    for (WifiConfiguration savedNetwork : savedNetworks) {
                        mWifiManager.disableNetwork(savedNetwork.networkId);
                    }
                    mWifiManager.disconnect();
                });

        // Wait for Wifi to be disconnected.
        PollingCheck.check(
                ""Wifi not disconnected"",
                20_000,
                () -> mWifiManager.getConnectionInfo().getNetworkId() == -1);
    }

    @After
    public void tearDown() throws Exception {
        // Re-enable networks.
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> {
                    for (WifiConfiguration savedNetwork : mWifiManager.getConfiguredNetworks()) {
                        mWifiManager.enableNetwork(savedNetwork.networkId, false);
                    }
                });
        // Release the requests after the test.
        if (mNetworkCallback != null) {
            mConnectivityManager.unregisterNetworkCallback(mNetworkCallback);
        }
        if (mNrNetworkCallback != null) {
            mConnectivityManager.unregisterNetworkCallback(mNrNetworkCallback);
        }
        // Clear any existing app state after each test.
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.removeAppState(myUid(), mContext.getPackageName()));
        mTestHelper.turnScreenOff();
    }

    private void testSuccessfulConnectionWithSpecifier(
            WifiConfiguration network, WifiNetworkSpecifier specifier) throws Exception {
        mNrNetworkCallback = mTestHelper.testConnectionFlowWithSpecifier(
                network, specifier, false);
    }

    private void testUserRejectionWithSpecifier(
            WifiConfiguration network, WifiNetworkSpecifier specifier) throws Exception {
        mNrNetworkCallback = mTestHelper.testConnectionFlowWithSpecifier(
                network, specifier, true);
    }

    /**
     * Tests the concurrent connection flow.
     * 1. Connect to a network using internet connectivity API.
     * 2. Connect to a network using peer to peer API.
     * 3. Verify that both connections are active.
     */"	""	""	"android.content.Context"	""
"2.2.1  Hardware"	"7.1.4.6"	"H-0-1"	"7.1.4.6/H-0-1"	""	"""[7.1.4.6/H-0-1] MUST report whether the device     supports the GPU profiling capability via a system property     `graphics.gpu.profiler.support`.  If Handheld device implementations declare support via a system property `graphics.gpu.profiler.support`, they:  *    ["""	""	""	"GPU graphics.gpu.profiler.support"	""	""	""	""	""	""	""	""	""	""	""	"android.dumpsys.cts.GfxInfoDumpsysTest"	"testGfxinfoFramestats"	"CtsDumpsysHostTestCases"	""	""	""	"/home/gpoor/cts-12-source/cts/hostsidetests/dumpsys/src/android/dumpsys/cts/GfxInfoDumpsysTest.java"	""	"public void testGfxinfoFramestats() throws Exception {
        final String MARKER = ""---PROFILEDATA---"";

        try {
            // cleanup test apps that might be installed from previous partial test run
            getDevice().uninstallPackage(TEST_PKG);

            // install the test app
            CompatibilityBuildHelper buildHelper = new CompatibilityBuildHelper(mCtsBuild);
            File testAppFile = buildHelper.getTestFile(TEST_APK);
            String installResult = getDevice().installPackage(testAppFile, false);
            assertNull(
                    String.format(""failed to install atrace test app. Reason: %s"", installResult),
                    installResult);

            getDevice().executeShellCommand(""am start -W "" + TEST_PKG);

            String frameinfo = mDevice.executeShellCommand(""dumpsys gfxinfo "" +
                    TEST_PKG + "" framestats"");
            assertNotNull(frameinfo);
            assertTrue(frameinfo.length() > 0);
            int profileStart = frameinfo.indexOf(MARKER);
            int profileEnd = frameinfo.indexOf(MARKER, profileStart + 1);
            assertTrue(profileStart >= 0);
            assertTrue(profileEnd > profileStart);
            String profileData = frameinfo.substring(profileStart + MARKER.length(), profileEnd);
            assertTrue(profileData.length() > 0);
            validateProfileData(profileData);
        } finally {
            getDevice().uninstallPackage(TEST_PKG);
        }
    }

    private void validateProfileData(String profileData) throws IOException {
        final int TIMESTAMP_COUNT = 22;
        boolean foundAtLeastOneRow = false;
        try (BufferedReader reader = new BufferedReader(
                new StringReader(profileData))) {
            String line;
            // First line needs to be the headers
            while ((line = reader.readLine()) != null && line.isEmpty()) {}

            assertNotNull(line);
            assertTrue(""First line was not the expected header: "" + line,
                    line.startsWith(""Flags,FrameTimelineVsyncId,IntendedVsync,Vsync""
                            + "",InputEventId,HandleInputStart,AnimationStart,PerformTraversalsStart""
                            + "",DrawStart,FrameDeadline,FrameInterval,FrameStartTime""
                            + "",SyncQueued,SyncStart,IssueDrawCommandsStart,SwapBuffers""
                            + "",FrameCompleted,DequeueBufferDuration,QueueBufferDuration""
                            + "",GpuCompleted,SwapBuffersCompleted,DisplayPresentTime""));

            long[] numparts = new long[TIMESTAMP_COUNT];
            while ((line = reader.readLine()) != null && !line.isEmpty()) {

                String[] parts = line.split("","");
                assertTrue(parts.length >= TIMESTAMP_COUNT);
                for (int i = 0; i < TIMESTAMP_COUNT; i++) {
                    numparts[i] = assertInteger(parts[i]);
                }

                final long flags = numparts[0];
                // Flags = 1 just means the first frame of the window
                if (flags != 0 && flags != 1) {
                    continue;
                }

                final long timestampIntendedVsync = numparts[2];
                final long timestampVsync = numparts[3];
                // skip InputEventId, since it's a randomly assigned id
                final long timestampHandleInputStart = numparts[5];
                final long timestampAnimationStart = numparts[6];
                final long timestampPerformTraversalsStart = numparts[7];
                final long timestampDrawStart = numparts[8];
                // skip FrameDeadline, FrameInterval,FrameStartTime
                final long timestampSyncQueued = numparts[12];
                final long timestampSyncStart = numparts[13];
                final long timestampIssueDrawCommandsStart = numparts[14];
                final long timestampSwapBuffers = numparts[15];
                final long timestampFrameCompleted = numparts[16];

                // assert time is flowing forwards. we need to check each entry explicitly
                // as some entries do not represent a flow of events.
                assertTrue(""VSYNC happened before INTENDED_VSYNC"",
                        timestampVsync >= timestampIntendedVsync);
                assertTrue(""HandleInputStart happened before VSYNC"",
                        timestampHandleInputStart >= timestampVsync);
                assertTrue(""AnimationStart happened before HandleInputStart"",
                        timestampAnimationStart >= timestampHandleInputStart);
                assertTrue(""PerformTraversalsStart happened before AnimationStart"",
                        timestampPerformTraversalsStart >= timestampAnimationStart);
                assertTrue(""DrawStart happened before PerformTraversalsStart"",
                        timestampDrawStart >= timestampPerformTraversalsStart);
                assertTrue(""SyncQueued happened before DrawStart"",
                        timestampSyncQueued >= timestampDrawStart);
                assertTrue(""SyncStart happened before SyncQueued"",
                        timestampSyncStart >= timestampSyncQueued);
                assertTrue(""IssueDrawCommandsStart happened before SyncStart"",
                        timestampIssueDrawCommandsStart >= timestampSyncStart);
                assertTrue(""SwapBuffers happened before IssueDrawCommandsStart"",
                        timestampSwapBuffers >= timestampIssueDrawCommandsStart);
                assertTrue(""FrameCompleted happened before SwapBuffers"",
                        timestampFrameCompleted >= timestampSwapBuffers);

                // total duration is from IntendedVsync to FrameCompleted
                long totalDuration = timestampFrameCompleted - timestampIntendedVsync;
                assertTrue(""Frame did not take a positive amount of time to process"",
                        totalDuration > 0);
                assertTrue(""Bogus frame duration, exceeds 100 seconds"",
                        totalDuration < TimeUnit.SECONDS.toNanos(100));
                foundAtLeastOneRow = true;
            }
        }
        assertTrue(foundAtLeastOneRow);
    }
}"	""	""	"GPU"	""
"7.4.5.3  Captive Portals"	"7.4.5.3"	"C-1-1"	"7.4.5.3/C-1-1"	""	"""C-1-1] MUST provide a captive portal application to handle the intent     [`ACTION_CAPTIVE_PORTAL_SIGN_IN`](https://developer.android.com/reference/android/net/ConnectivityManager#ACTION_CAPTIVE_PORTAL_SIGN_IN)     and display the captive portal login page, by sending that intent, on     call to the System API     `ConnectivityManager#startCaptivePortalApp(Network, Bundle)`. """	""	""	"ACTION_CAPTIVE_PORTAL_SIGN_IN"	""	""	""	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testNetworkSettingsPermission"	"CtsWifiTestCases"	""	""	""	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testNetworkSettingsPermission() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        final PackageManager pm = getContext().getPackageManager();

        final ArraySet<String> allowedPackages = new ArraySet();
        final ArraySet<Integer> allowedUIDs = new ArraySet();
        // explicitly add allowed UIDs
        allowedUIDs.add(Process.SYSTEM_UID);
        allowedUIDs.add(Process.SHELL_UID);
        allowedUIDs.add(Process.PHONE_UID);
        allowedUIDs.add(Process.NETWORK_STACK_UID);
        allowedUIDs.add(Process.NFC_UID);

        // only quick settings is allowed to bind to the BIND_QUICK_SETTINGS_TILE permission, using
        // this fact to determined allowed package name for sysui. This is a signature permission,
        // so allow any package with this permission.
        final List<PackageInfo> sysuiPackages = pm.getPackagesHoldingPermissions(new String[] {
                android.Manifest.permission.BIND_QUICK_SETTINGS_TILE
        }, PackageManager.MATCH_UNINSTALLED_PACKAGES);
        for (PackageInfo info : sysuiPackages) {
            allowedPackages.add(info.packageName);
        }

        // the captive portal flow also currently holds the NETWORK_SETTINGS permission
        final Intent intent = new Intent(ConnectivityManager.ACTION_CAPTIVE_PORTAL_SIGN_IN);
        final ResolveInfo ri = pm.resolveActivity(intent, PackageManager.MATCH_DISABLED_COMPONENTS);
        if (ri != null) {
            allowedPackages.add(ri.activityInfo.packageName);
        }

        final List<PackageInfo> holding = pm.getPackagesHoldingPermissions(new String[] {
                android.Manifest.permission.NETWORK_SETTINGS
        }, PackageManager.MATCH_UNINSTALLED_PACKAGES);
        StringBuilder stringBuilder = new StringBuilder();
        for (PackageInfo pi : holding) {
            String packageName = pi.packageName;

            // this is an explicitly allowed package
            if (allowedPackages.contains(packageName)) continue;

            // now check if the packages are from allowed UIDs
            int uid = -1;
            try {
                uid = pm.getPackageUidAsUser(packageName, UserHandle.USER_SYSTEM);
            } catch (PackageManager.NameNotFoundException e) {
                continue;
            }
            if (!allowedUIDs.contains(uid)) {
                stringBuilder.append(""The NETWORK_SETTINGS permission must not be held by ""
                    + packageName + "":"" + uid + "" and must be revoked for security reasons\n"");
            }
        }
        if (stringBuilder.length() > 0) {
            fail(stringBuilder.toString());
        }
    }

    /**
     * Verify that the {@link android.Manifest.permission#NETWORK_SETUP_WIZARD} permission is
     * only held by the device setup wizard application.
     * <p>
     * Only the SetupWizard app should <em>ever</em> attempt to acquire this
     * permission, since it would give those apps extremely broad access to connectivity
     * functionality.  The permission is intended to be granted to only the device setup wizard.
     */"	""	""	"ACTION_CAPTIVE_PORTAL_SIGN_IN"	""
"2.2.1  Hardware"	"7.1.1.1"	"H-2-1"	"7.1.1.1/H-2-1"	""	"""[7.1.1.1/H-2-1]* MUST make the logical screen that is made available for third party applications be at least 2.7 inches on the short edge(s). Devices which launched on an API level earlier than that of this document are exempted from this requirement.  If Handheld device implementations claim support for high dynamic range displays through [`Configuration.isScreenHdr()` ](https://developer.android.com/reference/android/content/res/Configuration.html#isScreenHdr%28%29) , they:  *   ["""	""	""	"isScreenHdr() edge(s) Configuration.isScreenHdr Configuration.html"	""	""	""	""	""	""	""	""	""	""	""	"android.opengl.cts.OpenGlEsVersionTest"	"testRequiredEglExtensionsForHdrCapableDisplay"	"CtsOpenGLTestCases"	""	""	""	"/home/gpoor/cts-12-source/cts/tests/tests/opengl/src/android/opengl/cts/OpenGlEsVersionTest.java"	""	"public void testRequiredEglExtensionsForHdrCapableDisplay() {
        // See CDD section 7.1.4
        // This test covers the EGL portion of the CDD requirement. The VK portion of the
        // requirement is covered elsewhere.
        final String requiredEglList[] = {
            ""EGL_EXT_gl_colorspace_bt2020_pq"",
            ""EGL_EXT_surface_SMPTE2086_metadata"",
            ""EGL_EXT_surface_CTA861_3_metadata"",
        };

        // This requirement only applies if device is handheld and claims to be HDR capable.
        boolean isHdrCapable = mActivity.getResources().getConfiguration().isScreenHdr();
        if (!isHdrCapable || !isHandheld())
            return;

        EGL10 egl = (EGL10) EGLContext.getEGL();
        EGLDisplay display = egl.eglGetDisplay(EGL10.EGL_DEFAULT_DISPLAY);

        if (egl.eglInitialize(display, null)) {
            try {
                String eglExtensions = egl.eglQueryString(display, EGL10.EGL_EXTENSIONS);
                for (int i = 0; i < requiredEglList.length; ++i) {
                    assertTrue(""EGL extension required by CDD section 7.1.4.5 missing: "" +
                        requiredEglList[i], hasExtension(eglExtensions, requiredEglList[i]));
                }
            } finally {
                egl.eglTerminate(display);
            }
        } else {
            Log.e(TAG, ""Couldn't initialize EGL."");
        }
    }

    @CddTest(requirement=""7.1.4.5/C-1-4"")"	""	""	"isScreenHdr()"	""
"9.11.3  Identity Credential"	"9.11.3"	"C-0-2"	"9.11.3/C-0-2"	""	"""C-0-2] MUST implement the Identity Credential System (e.g. the      `android.security.identity.*` APIs) with code communicating with a trusted      application in an area that is securely isolated from the code running on      the kernel and above. Secure isolation MUST block all potential mechanisms      by which kernel or userspace code might access the internal state of the      isolated environment, including DMA.  """	""	""	"DMA android.security.identity"	""	""	""	""	""	""	""	""	""	""	""	"android.inputmethodservice.cts.devicetest.InputMethodManagerDeviceTest"	"testIme1ImplicitlyEnabledSubtypeExists"	""	""	""	""	"/home/gpoor/cts-12-source/cts/hostsidetests/inputmethodservice/deviceside/devicetest/src/android/inputmethodservice/cts/devicetest/InputMethodManagerDeviceTest.java"	""	"public void testIme1ImplicitlyEnabledSubtypeExists() throws Throwable {
        pollingCheck(() -> mImm.getInputMethodList().stream()
                        .filter(imi -> TextUtils.equals(imi.getId(), Ime1Constants.IME_ID))
                        .flatMap(imi -> mImm.getEnabledInputMethodSubtypeList(imi, true).stream())
                        .anyMatch(InputMethodSubtype::overridesImplicitlyEnabledSubtype),
                TIMEOUT, ""Implicitly enabled Subtype must exist for IME1."");
    }

    /**
     * Make sure
     * {@link InputMethodManager#getEnabledInputMethodSubtypeList(InputMethodInfo, boolean)} for
     * {@link Ime1Constants#IME_ID} does not return the implicitly enabled subtype.
     */"	""	""	"DMA"	""
"6.1  Developer Tools"	"6.1"	"C-4-1"	"6.1/C-4-1"	""	"""C-4-1] MUST have the `AdbManager#isAdbWifiSupported()` method     return `true`.      If device implementations support adb connections to a host machine via     Wi-Fi and includes at least one camera, they:      """	""	""	"isAdbWifiSupported()"	""	""	""	""	""	""	""	""	""	""	""	"android.adbmanager.cts.AdbManagerHostDeviceTest"	"test_isadbWifiSupported"	"CtsAdbManagerHostTestCases"	""	""	""	"/home/gpoor/cts-12-source/cts/hostsidetests/adbmanager/src/android/adbmanager/cts/AdbManagerHostDeviceTest.java"	""	"@CddTest(requirement=""6.1/C-1-1"")
    public void test_isadbWifiSupported() throws Exception {
        boolean expected = hasFeature(FEATURE_WIFI);

        CommandResult result = getDevice().executeShellV2Command(""cmd adb is-wifi-supported"");

        Assert.assertTrue(new Integer(0).equals(result.getExitCode()));
        Assert.assertEquals(expected, Boolean.parseBoolean(result.getStdout().trim()));
    }"	""	""	"isAdbWifiSupported()"	""
"7.4.5.3  Captive Portals"	"7.4.5.3"	"C-1-4"	"7.4.5.3/C-1-4"	""	"""C-1-4] MUST use encrypted DNS as per the SDK documentation for     [`android.net.LinkProperties.getPrivateDnsServerName`](https://developer.android.com/reference/android/net/LinkProperties.html#getPrivateDnsServerName%28%29)     and [`android.net.LinkProperties.isPrivateDnsActive`](https://developer.android.com/reference/android/net/LinkProperties#isPrivateDnsActive%28%29)     for all network traffic that is not explicitly communicating with the     captive portal. """	""	""	"DNS android.net.LinkProperties.getPrivateDnsServerName LinkProperties.html android.net.LinkProperties.isPrivateDnsActive"	""	""	""	""	""	""	""	""	""	""	""	"android.security.SELinuxTargetSdkTest"	"testNoDns"	"CtsSelinuxTargetSdk29TestCases"	""	""	""	"/home/gpoor/cts-12-source/cts/tests/tests/selinux/selinuxTargetSdk29/src/android/security/SELinuxTargetSdkTest.java"	""	"public void testNoDns() throws IOException {
        noDns();
    }"	""	""	"DNS"	""
"7.1.4.2 Vulkan"	"7.1.4.2"	"C-1-8"	"7.1.4.2/C-1-8"	""	"""C-1-8] MUST report the maximum version of the Vulkan dEQP Tests     supported via the `android.software.vulkan.deqp.level` feature flag. """	""	""	"EQP android.software.vulkan.deqp.level"	""	""	""	""	""	""	""	""	""	""	""	"android.midi.cts.MidiEchoTest"	"currentTimeMillis"	"CtsMidiTestCases"	""	""	""	"/home/gpoor/cts-12-source/cts/tests/tests/midi/src/android/midi/cts/MidiEchoTest.java"	""	"public void test/*
 *.
 */

package android.midi.cts;

import android.content.Context;
import android.content.pm.PackageManager;
import android.media.midi.MidiManager;
import android.media.midi.MidiOutputPort;
import android.media.midi.MidiDevice;
import android.media.midi.MidiDevice.MidiConnection;
import android.media.midi.MidiDeviceInfo;
import android.media.midi.MidiDeviceInfo.PortInfo;
import android.media.midi.MidiDeviceStatus;
import android.media.midi.MidiInputPort;
import android.media.midi.MidiReceiver;
import android.media.midi.MidiSender;
import android.os.Bundle;
import android.util.Log;
import android.test.AndroidTestCase;

import com.android.midi.CTSMidiEchoTestService;
import com.android.midi.MidiEchoTestService;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Random;

/**
 * Test MIDI using a virtual MIDI device that echos input to output.
 */
public class MidiEchoTest extends AndroidTestCase {
    private static final String TAG = ""MidiEchoTest"";
    private static final boolean DEBUG = false;

    // I am overloading the timestamp for some tests. It is passed
    // directly through the Echo server unchanged.
    // The high 32-bits has a recognizable value.
    // The low 32-bits can contain data used to identify messages.
    private static final long TIMESTAMP_MARKER = 0x1234567800000000L;
    private static final long TIMESTAMP_MARKER_MASK = 0xFFFFFFFF00000000L;
    private static final long TIMESTAMP_DATA_MASK = 0x00000000FFFFFFFFL;
    private static final long NANOS_PER_MSEC = 1000L * 1000L;

    // On a fast device in 2016, the test fails if timeout is 3 but works if it is 4.
    // So this timeout value is very generous.
    private static final int TIMEOUT_OPEN_MSEC = 1000; // arbitrary
    // On a fast device in 2016, the test fails if timeout is 0 but works if it is 1.
    // So this timeout value is very generous.
    private static final int TIMEOUT_STATUS_MSEC = 500; // arbitrary

    // This is defined in MidiPortImpl.java as the maximum payload that
    // can be sent internally by MidiInputPort in a
    // SOCK_SEQPACKET datagram.
    private static final int MAX_PACKET_DATA_SIZE = 1024 - 9;

    // Store device and ports related to the Echo service.
    static class MidiTestContext {
        MidiDeviceInfo echoInfo;
        MidiDevice echoDevice;
        MidiInputPort echoInputPort;
        MidiOutputPort echoOutputPort;
    }

    // Store complete MIDI message so it can be put in an array.
    static class MidiMessage {
        public final byte[] data;
        public final long timestamp;
        public final long timeReceived;

        MidiMessage(byte[] buffer, int offset, int length, long timestamp) {
            timeReceived = System.nanoTime();
            data = new byte[length];
            System.arraycopy(buffer, offset, data, 0, length);
            this.timestamp = timestamp;
        }
    }

    // Listens for an asynchronous device open and notifies waiting foreground
    // test.
    class MyTestOpenCallback implements MidiManager.OnDeviceOpenedListener {
        MidiDevice mDevice;

        @Override
        public synchronized void onDeviceOpened(MidiDevice device) {
            mDevice = device;
            notifyAll();
        }

        public synchronized MidiDevice waitForOpen(int msec)
                throws InterruptedException {
            long deadline = System.currentTimeMillis() + msec;
            long timeRemaining = msec;
            while (mDevice == null && timeRemaining > 0) {
                wait(timeRemaining);
                timeRemaining = deadline - System.currentTimeMillis();
            }
            return mDevice;
        }
    }

    // Store received messages in an array.
    class MyLoggingReceiver extends MidiReceiver {
        ArrayList<MidiMessage> messages = new ArrayList<MidiMessage>();
        int mByteCount;

        @Override
        public synchronized void onSend(byte[] data, int offset, int count,
                long timestamp) {
            messages.add(new MidiMessage(data, offset, count, timestamp));
            mByteCount += count;
            notifyAll();
        }

        public synchronized int getMessageCount() {
            return messages.size();
        }

        public synchronized int getByteCount() {
            return mByteCount;
        }

        public synchronized MidiMessage getMessage(int index) {
            return messages.get(index);
        }

        /**
         * Wait until count messages have arrived. This is a cumulative total.
         *
         * @param count
         * @param timeoutMs
         * @throws InterruptedException
         */
        public synchronized void waitForMessages(int count, int timeoutMs)
                throws InterruptedException {
            long endTimeMs = System.currentTimeMillis() + timeoutMs + 1;
            long timeToWait = timeoutMs + 1;
            while ((getMessageCount() < count)
                    && (timeToWait > 0)) {
                wait(timeToWait);
                timeToWait = endTimeMs - System.currentTimeMillis();
            }
        }

        /**
         * Wait until count bytes have arrived. This is a cumulative total.
         *
         * @param count
         * @param timeoutMs
         * @throws InterruptedException
         */
        public synchronized void waitForBytes(int count, int timeoutMs)
                throws InterruptedException {
            long endTimeMs = System.currentTimeMillis() + timeoutMs + 1;
            long timeToWait = timeoutMs + 1;
            while ((getByteCount() < count)
                    && (timeToWait > 0)) {
                wait(timeToWait);
                timeToWait = endTimeMs - System.currentTimeMillis();
            }
        }
    }

    @Override
    protected void setUp() throws Exception {
        super.setUp();
    }

    @Override
    protected void tearDown() throws Exception {
        super.tearDown();
    }

    protected MidiTestContext setUpEchoServer() throws Exception {
        if (DEBUG) {
            Log.i(TAG, ""setUpEchoServer()"");
        }
        MidiManager midiManager = (MidiManager) mContext.getSystemService(
                Context.MIDI_SERVICE);

        MidiDeviceInfo echoInfo = CTSMidiEchoTestService.findEchoDevice(mContext);

        // Open device.
        MyTestOpenCallback callback = new MyTestOpenCallback();
        midiManager.openDevice(echoInfo, callback, null);
        MidiDevice echoDevice = callback.waitForOpen(TIMEOUT_OPEN_MSEC);
        assertTrue(""could not open ""
                + CTSMidiEchoTestService.getEchoServerName(), echoDevice != null);

        // Query echo service directly to see if it is getting status updates.
        MidiEchoTestService echoService = CTSMidiEchoTestService.getInstance();
        assertEquals(""virtual device status, input port before open"", false,
                echoService.inputOpened);
        assertEquals(""virtual device status, output port before open"", 0,
                echoService.outputOpenCount);

        // Open input port.
        MidiInputPort echoInputPort = echoDevice.openInputPort(0);
        assertTrue(""could not open input port"", echoInputPort != null);
        assertEquals(""input port number"", 0, echoInputPort.getPortNumber());
        assertEquals(""virtual device status, input port after open"", true,
                echoService.inputOpened);
        assertEquals(""virtual device status, output port before open"", 0,
                echoService.outputOpenCount);

        // Open output port.
        MidiOutputPort echoOutputPort = echoDevice.openOutputPort(0);
        assertTrue(""could not open output port"", echoOutputPort != null);
        assertEquals(""output port number"", 0, echoOutputPort.getPortNumber());
        assertEquals(""virtual device status, input port after open"", true,
                echoService.inputOpened);
        assertEquals(""virtual device status, output port after open"", 1,
                echoService.outputOpenCount);

        MidiTestContext mc = new MidiTestContext();
        mc.echoInfo = echoInfo;
        mc.echoDevice = echoDevice;
        mc.echoInputPort = echoInputPort;
        mc.echoOutputPort = echoOutputPort;
        return mc;
    }

    /**
     * Close ports and check device status.
     *
     * @param mc
     */
    protected void tearDownEchoServer(MidiTestContext mc) throws IOException {
        // Query echo service directly to see if it is getting status updates.
        MidiEchoTestService echoService = CTSMidiEchoTestService.getInstance();
        assertEquals(""virtual device status, input port before close"", true,
                echoService.inputOpened);
        assertEquals(""virtual device status, output port before close"", 1,
                echoService.outputOpenCount);

        // Close output port.
        mc.echoOutputPort.close();
        assertEquals(""virtual device status, input port before close"", true,
                echoService.inputOpened);
        assertEquals(""virtual device status, output port after close"", 0,
                echoService.outputOpenCount);
        mc.echoOutputPort.close();
        mc.echoOutputPort.close(); // should be safe to close twice

        // Close input port.
        mc.echoInputPort.close();
        assertEquals(""virtual device status, input port after close"", false,
                echoService.inputOpened);
        assertEquals(""virtual device status, output port after close"", 0,
                echoService.outputOpenCount);
        mc.echoInputPort.close();
        mc.echoInputPort.close(); // should be safe to close twice

        mc.echoDevice.close();
        mc.echoDevice.close(); // should be safe to close twice
    }

    /**
     * @param mc
     * @param echoInfo
     */
    protected void checkEchoDeviceInfo(MidiTestContext mc,
            MidiDeviceInfo echoInfo) {
        assertEquals(""echo input port count wrong"", 1,
                echoInfo.getInputPortCount());
        assertEquals(""echo output port count wrong"", 1,
                echoInfo.getOutputPortCount());

        Bundle properties = echoInfo.getProperties();
        String tags = (String) properties.get(""tags"");
        assertEquals(""attributes from device XML"", ""echo,test"", tags);

        PortInfo[] ports = echoInfo.getPorts();
        assertEquals(""port info array size"", 2, ports.length);

        boolean foundInput = false;
        boolean foundOutput = false;
        for (PortInfo portInfo : ports) {
            if (portInfo.getType() == PortInfo.TYPE_INPUT) {
                foundInput = true;
                assertEquals(""input port name"", ""input"", portInfo.getName());

                assertEquals(""info port number"", portInfo.getPortNumber(),
                        mc.echoInputPort.getPortNumber());
            } else if (portInfo.getType() == PortInfo.TYPE_OUTPUT) {
                foundOutput = true;
                assertEquals(""output port name"", ""output"", portInfo.getName());
                assertEquals(""info port number"", portInfo.getPortNumber(),
                        mc.echoOutputPort.getPortNumber());
            }
        }
        assertTrue(""found input port info"", foundInput);
        assertTrue(""found output port info"", foundOutput);

        assertEquals(""MIDI device type"", MidiDeviceInfo.TYPE_VIRTUAL,
                echoInfo.getType());
    }

    // Is the MidiManager supported?"	""	""	"EQP"	""
"9.9.4  Resume on Reboot"	"9.9.4"	"C-0-1"	"9.9.4/C-0-1"	""	"""C-0-1] CE storage MUST NOT be readable even for the attacker who physically has the device and then has these capabilities and limitations:      *   Can use the signing key of any vendor or company to sign arbitrary         messages.     *   Can cause an OTA to be received by the device.     *   Can modify the operation of any hardware (AP, flash etc) except as         detailed below, but such modification involves a delay of at least an         hour and a power cycle that destroys RAM contents.     *   Cannot modify the operation of tamper-resistant hardware (eg Titan M).     *   Cannot read the RAM of the live device.     *   Cannot obtain the user’s credential (PIN, pattern, password) or         otherwise cause it to be entered.  By way of example, a device implementation that implements and complies with all of the descriptions found [here](https://source.android.com/devices/tech/ota/resume-on-reboot) will be compliant with [C-0-1]. """	""	""	"OTA PIN RAM"	""	""	""	""	""	""	""	""	""	""	""	"android.content.pm.cts.shortcut.backup.publisher1.ShortcutManagerPreBackupTest"	"testPreBackup"	""	""	""	""	"/home/gpoor/cts-12-source/cts/hostsidetests/shortcuts/deviceside/backup/publisher1/src/android/content/pm/cts/shortcut/backup/publisher1/ShortcutManagerPreBackupTest.java"	""	"public void testPreBackup() {
        final Icon icon1 = Icon.createWithBitmap(BitmapFactory.decodeResource(
                getContext().getResources(), R.drawable.black_16x64));
        final Icon icon3 = Icon.createWithResource(getContext(), R.drawable.black_64x16);

        final ShortcutInfo s1 = new ShortcutInfo.Builder(getContext(), ""s1"")
                .setShortLabel(""shortlabel1"")
                .setLongLabel(""longlabel1"")
                .setIcon(icon1)
                .setActivity(getActivity(""MainActivity""))
                .setDisabledMessage(""disabledmessage1"")
                .setIntents(new Intent[]{new Intent(""view"").putExtra(""k1"", ""v1"")})
                .setExtras(makePersistableBundle(""ek1"", ""ev1""))
                .setCategories(set(""cat1""))
                .build();

        final ShortcutInfo s2 = new ShortcutInfo.Builder(getContext(), ""s2"")
                .setShortLabel(""shortlabel2"")
                .setActivity(getActivity(""MainActivity2""))
                .setIntents(new Intent[]{new Intent(""main"")})
                .build();

        final ShortcutInfo s3 = new ShortcutInfo.Builder(getContext(), ""s3"")
                .setShortLabel(""shortlabel2"")
                .setIcon(icon3)
                .setActivity(getActivity(""MainActivity2""))
                .setIntents(new Intent[]{new Intent(""main"")})
                .build();

        assertTrue(getManager().setDynamicShortcuts(list(s1, s2, s3)));

        assertWith(getManager().getDynamicShortcuts())
                .haveIds(""s1"", ""s2"", ""s3"")
                .areAllNotPinned();

        assertWith(getManager().getManifestShortcuts())
                .haveIds(""ms1"", ""ms2"")
                .areAllNotPinned();
   }
}"	""	""	"PIN"	""
"3.8.15  Display Cutout"	"3.8.15"	"C-1-5"	"3.8.15/C-1-5"	""	"""C-1-5] MUST NOT have cutout(s) if the device's aspect ratio is 1.0(1:1). """	""	""	"cutout(s)"	""	""	""	""	""	""	""	""	""	""	""	"android.server.wm.ConfigChangeTests"	"testRotation180_NoRelaunchActivity"	"CtsWindowManagerDeviceTestCases"	""	""	""	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/ConfigChangeTests.java"	""	"public void testRotation180_NoRelaunchActivity() {
        assumeTrue(""Skipping test: no rotation support"", supportsRotation());
        assumeFalse(""Skipping test: display cutout present, can't predict exact lifecycle"",
                hasDisplayCutout());

        // Should receive nothing
        testRotation(NO_RELAUNCH_ACTIVITY, 2, 0, 0);
    }

    /**
     * Test activity configuration changes for devices with cutout(s). Landscape and
     * reverse-landscape rotations should result in same screen space available for apps.
     */"	""	""	"cutout(s)"	""
"7.2.4  Touchscreen Input"	"7.2.4"	"C-3-3"	"7.2.4/C-3-3"	""	"""C-3-3] MUST report `TOUCHSCREEN_NOTOUCH` for the [`Configuration.touchscreen`](https://developer.android.com/reference/android/content/res/Configuration.html#touchscreen) API field.  """	""	""	"Configuration.html TOUCHSCREEN_NOTOUCH Configuration.touchscreen"	""	""	""	""	""	""	""	""	""	""	""	"android.server.wm.ActivityManagerGetConfigTests"	"isLowRamDevice"	"CtsWindowManagerDeviceTestCases"	""	""	""	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/ActivityManagerGetConfigTests.java"	""	"/*
 *.
 */

package android.server.wm;

import static androidx.test.InstrumentationRegistry.getInstrumentation;

import static org.junit.Assert.assertArrayEquals;
import static org.junit.Assert.assertEquals;

import android.app.ActivityManager;
import android.app.KeyguardManager;
import android.content.Context;
import android.content.nano.DeviceConfigurationProto;
import android.content.nano.GlobalConfigurationProto;
import android.content.nano.LocaleProto;
import android.content.nano.ResourcesConfigurationProto;
import android.content.pm.ConfigurationInfo;
import android.content.pm.FeatureInfo;
import android.content.pm.PackageManager;
import android.content.pm.SharedLibraryInfo;
import android.content.res.Configuration;
import android.hardware.display.DisplayManager;
import android.opengl.GLES10;
import android.os.Build;
import android.os.LocaleList;
import android.os.ParcelFileDescriptor;
import android.platform.test.annotations.Presubmit;
import android.text.TextUtils;
import android.util.DisplayMetrics;
import android.view.Display;

import com.google.protobuf.nano.InvalidProtocolBufferNanoException;

import org.junit.Before;
import org.junit.Test;

import java.io.ByteArrayOutputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import javax.microedition.khronos.egl.EGL10;
import javax.microedition.khronos.egl.EGLConfig;
import javax.microedition.khronos.egl.EGLContext;
import javax.microedition.khronos.egl.EGLDisplay;
import javax.microedition.khronos.egl.EGLSurface;

@Presubmit
public class ActivityManagerGetConfigTests {
    Context mContext;
    ActivityManager mAm;
    PackageManager mPm;

    @Before
    public void setUp() throws Exception {
        mContext = getInstrumentation().getTargetContext();
        mAm = mContext.getSystemService(ActivityManager.class);
        mPm = mContext.getPackageManager();
    }

    private byte[] executeShellCommand(String cmd) {
        try {
            ParcelFileDescriptor pfd = getInstrumentation().getUiAutomation()
                    .executeShellCommand(cmd);
            byte[] buf = new byte[512];
            int bytesRead;
            FileInputStream fis = new ParcelFileDescriptor.AutoCloseInputStream(pfd);
            ByteArrayOutputStream stdout = new ByteArrayOutputStream();
            while ((bytesRead = fis.read(buf)) != -1) {
                stdout.write(buf, 0, bytesRead);
            }
            fis.close();
            return stdout.toByteArray();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * Adds all supported GL extensions for a provided EGLConfig to a set by creating an EGLContext
     * and EGLSurface and querying extensions.
     *
     * @param egl An EGL API object
     * @param display An EGLDisplay to create a context and surface with
     * @param config The EGLConfig to get the extensions for
     * @param surfaceSize eglCreatePbufferSurface generic parameters
     * @param contextAttribs eglCreateContext generic parameters
     * @param glExtensions A Set<String> to add GL extensions to
     */
    private static void addExtensionsForConfig(
            EGL10 egl,
            EGLDisplay display,
            EGLConfig config,
            int[] surfaceSize,
            int[] contextAttribs,
            Set<String> glExtensions) {
        // Create a context.
        EGLContext context =
                egl.eglCreateContext(display, config, EGL10.EGL_NO_CONTEXT, contextAttribs);
        // No-op if we can't create a context.
        if (context == EGL10.EGL_NO_CONTEXT) {
            return;
        }

        // Create a surface.
        EGLSurface surface = egl.eglCreatePbufferSurface(display, config, surfaceSize);
        if (surface == EGL10.EGL_NO_SURFACE) {
            egl.eglDestroyContext(display, context);
            return;
        }

        // Update the current surface and context.
        egl.eglMakeCurrent(display, surface, surface, context);

        // Get the list of extensions.
        String extensionList = GLES10.glGetString(GLES10.GL_EXTENSIONS);
        if (!TextUtils.isEmpty(extensionList)) {
            // The list of extensions comes from the driver separated by spaces.
            // Split them apart and add them into a Set for deduping purposes.
            for (String extension : extensionList.split("" "")) {
                glExtensions.add(extension);
            }
        }

        // Tear down the context and surface for this config.
        egl.eglMakeCurrent(display, EGL10.EGL_NO_SURFACE, EGL10.EGL_NO_SURFACE, EGL10.EGL_NO_CONTEXT);
        egl.eglDestroySurface(display, surface);
        egl.eglDestroyContext(display, context);
    }


    Set<String> getGlExtensionsFromDriver() {
        Set<String> glExtensions = new HashSet<>();

        // Get the EGL implementation.
        EGL10 egl = (EGL10) EGLContext.getEGL();
        if (egl == null) {
            throw new RuntimeException(""Warning: couldn't get EGL"");
        }

        // Get the default display and initialize it.
        EGLDisplay display = egl.eglGetDisplay(EGL10.EGL_DEFAULT_DISPLAY);
        int[] version = new int[2];
        egl.eglInitialize(display, version);

        // Call getConfigs() in order to find out how many there are.
        int[] numConfigs = new int[1];
        if (!egl.eglGetConfigs(display, null, 0, numConfigs)) {
            throw new RuntimeException(""Warning: couldn't get EGL config count"");
        }

        // Allocate space for all configs and ask again.
        EGLConfig[] configs = new EGLConfig[numConfigs[0]];
        if (!egl.eglGetConfigs(display, configs, numConfigs[0], numConfigs)) {
            throw new RuntimeException(""Warning: couldn't get EGL configs"");
        }

        // Allocate surface size parameters outside of the main loop to cut down
        // on GC thrashing.  1x1 is enough since we are only using it to get at
        // the list of extensions.
        int[] surfaceSize =
                new int[] {
                        EGL10.EGL_WIDTH, 1,
                        EGL10.EGL_HEIGHT, 1,
                        EGL10.EGL_NONE
                };

        // For when we need to create a GLES2.0 context.
        final int EGL_CONTEXT_CLIENT_VERSION = 0x3098;
        int[] gles2 = new int[] {EGL_CONTEXT_CLIENT_VERSION, 2, EGL10.EGL_NONE};

        // For getting return values from eglGetConfigAttrib
        int[] attrib = new int[1];

        for (int i = 0; i < numConfigs[0]; i++) {
            // Get caveat for this config in order to skip slow (i.e. software) configs.
            egl.eglGetConfigAttrib(display, configs[i], EGL10.EGL_CONFIG_CAVEAT, attrib);
            if (attrib[0] == EGL10.EGL_SLOW_CONFIG) {
                continue;
            }

            // If the config does not support pbuffers we cannot do an eglMakeCurrent
            // on it in addExtensionsForConfig(), so skip it here. Attempting to make
            // it current with a pbuffer will result in an EGL_BAD_MATCH error
            egl.eglGetConfigAttrib(display, configs[i], EGL10.EGL_SURFACE_TYPE, attrib);
            if ((attrib[0] & EGL10.EGL_PBUFFER_BIT) == 0) {
                continue;
            }

            final int EGL_OPENGL_ES_BIT = 0x0001;
            final int EGL_OPENGL_ES2_BIT = 0x0004;
            egl.eglGetConfigAttrib(display, configs[i], EGL10.EGL_RENDERABLE_TYPE, attrib);
            if ((attrib[0] & EGL_OPENGL_ES_BIT) != 0) {
                addExtensionsForConfig(egl, display, configs[i], surfaceSize, null, glExtensions);
            }
            if ((attrib[0] & EGL_OPENGL_ES2_BIT) != 0) {
                addExtensionsForConfig(egl, display, configs[i], surfaceSize, gles2, glExtensions);
            }
        }

        // Release all EGL resources.
        egl.eglTerminate(display);

        return glExtensions;
    }

    private void checkResourceConfig(Configuration config, DisplayMetrics metrics,
            ResourcesConfigurationProto resConfig) {
        final int width, height;
        if (metrics.widthPixels >= metrics.heightPixels) {
            width = metrics.widthPixels;
            height = metrics.heightPixels;
        } else {
            //noinspection SuspiciousNameCombination
            width = metrics.heightPixels;
            //noinspection SuspiciousNameCombination
            height = metrics.widthPixels;
        }

        assertEquals(""Expected SDK version does not match"",
                Build.VERSION.RESOURCES_SDK_INT, resConfig.sdkVersion);
        assertEquals(""Expected screen width px does not match"",
                width, resConfig.screenWidthPx);
        assertEquals(""Expected screen width px does not match"",
                height, resConfig.screenHeightPx);

        assertEquals(""Expected font scale does not match"",
                config.fontScale, resConfig.configuration.fontScale, Float.MIN_VALUE*5);
        assertEquals(""Expected mcc does not match"",
                config.mcc, resConfig.configuration.mcc);
        assertEquals(""Expected mnc does not match"",
                config.mnc, resConfig.configuration.mnc);
        LocaleList llist = config.getLocales();
        LocaleList lprotos = LocaleList.forLanguageTags(resConfig.configuration.localeList);
        assertEquals(""Expected number of locales does not match"", llist.size(), lprotos.size());
        for (int i = 0; i < llist.size(); i++) {
            assertEquals(""Expected locale #"" + i + "" does not match"",
                    llist.get(i).toLanguageTag(), lprotos.get(i).toLanguageTag());
        }
        assertEquals(""Expected screen layout does not match"",
                config.screenLayout, resConfig.configuration.screenLayout);
        assertEquals(""Expected color mode does not match"",
                config.colorMode, resConfig.configuration.colorMode);
        assertEquals(""Expected touchscreen does not match"",
                config.touchscreen, resConfig.configuration.touchscreen);
        assertEquals(""Expected keyboard does not match"",
                config.keyboard, resConfig.configuration.keyboard);
        assertEquals(""Expected keyboard hidden does not match"",
                config.keyboardHidden, resConfig.configuration.keyboardHidden);
        assertEquals(""Expected hard keyboard hidden does not match"",
                config.hardKeyboardHidden, resConfig.configuration.hardKeyboardHidden);
        assertEquals(""Expected navigation does not match"",
                config.navigation, resConfig.configuration.navigation);
        assertEquals(""Expected navigation hidden does not match"",
                config.navigationHidden, resConfig.configuration.navigationHidden);
        assertEquals(""Expected orientation does not match"",
                config.orientation, resConfig.configuration.orientation);
        assertEquals(""Expected UI mode does not match"",
                config.uiMode, resConfig.configuration.uiMode);
        assertEquals(""Expected screen width dp does not match"",
                config.screenWidthDp, resConfig.configuration.screenWidthDp);
        assertEquals(""Expected screen hight dp does not match"",
                config.screenHeightDp, resConfig.configuration.screenHeightDp);
        assertEquals(""Expected smallest screen width dp does not match"",
                config.smallestScreenWidthDp, resConfig.configuration.smallestScreenWidthDp);
        assertEquals(""Expected density dpi does not match"",
                config.densityDpi, resConfig.configuration.densityDpi);
        // XXX not comparing windowConfiguration, since by definition this is contextual.
    }

    private void checkDeviceConfig(DisplayMetrics displayMetrics,
            DeviceConfigurationProto deviceConfig) {
        assertEquals(""Expected stable screen width does not match"",
                displayMetrics.widthPixels, deviceConfig.stableScreenWidthPx);
        assertEquals(""Expected stable screen height does not match"",
                displayMetrics.heightPixels, deviceConfig.stableScreenHeightPx);
        assertEquals(""Expected stable screen density does not match"",
                DisplayMetrics.DENSITY_DEVICE_STABLE, deviceConfig.stableDensityDpi);

        assertEquals(""Expected total RAM does not match"",
                mAm.getTotalRam(), deviceConfig.totalRam);
        assertEquals(""Expected low RAM does not match"",
                mAm.isLowRamDevice(), deviceConfig.lowRam);
        assertEquals(""Expected max cores does not match"",
                Runtime.getRuntime().availableProcessors(), deviceConfig.maxCores);
        KeyguardManager kgm = mContext.getSystemService(KeyguardManager.class);
        assertEquals(""Expected has secure screen lock does not match"",
                kgm.isDeviceSecure(), deviceConfig.hasSecureScreenLock);

        ConfigurationInfo configInfo = mAm.getDeviceConfigurationInfo();
        if (configInfo.reqGlEsVersion != ConfigurationInfo.GL_ES_VERSION_UNDEFINED) {
            assertEquals(""Expected opengl version does not match"",
                    configInfo.reqGlEsVersion, deviceConfig.openglVersion);
        }

        Set<String> glExtensionsSet = getGlExtensionsFromDriver();
        String[] glExtensions = new String[glExtensionsSet.size()];
        glExtensions = glExtensionsSet.toArray(glExtensions);
        Arrays.sort(glExtensions);
        assertArrayEquals(""Expected opengl extensions does not match"",
                glExtensions, deviceConfig.openglExtensions);

        List<SharedLibraryInfo> slibs = mPm.getSharedLibraries(0);
        Collections.sort(slibs, Comparator.comparing(SharedLibraryInfo::getName));
        String[] slibNames = new String[slibs.size()];
        for (int i = 0; i < slibs.size(); i++) {
            slibNames[i] = slibs.get(i).getName();
        }
        assertArrayEquals(""Expected shared libraries does not match"",
                slibNames, deviceConfig.sharedLibraries);

        FeatureInfo[] features = mPm.getSystemAvailableFeatures();
        Arrays.sort(features, (o1, o2) -> {
            if (o1.name == o2.name) return 0;
            if (o1.name == null) return -1;
            if (o2.name == null) return 1;
            return o1.name.compareTo(o2.name);
        });

        int size = 0;
        for (int i = 0; i < features.length; i++) {
            if (features[i].name != null) {
                size++;
            }
        }
        String[] featureNames = new String[size];
        for (int i = 0, j = 0; i < features.length; i++) {
            if (features[i].name != null) {
                featureNames[j] = features[i].name;
                j++;
            }
        }
        assertArrayEquals(""Expected features does not match"",
                featureNames, deviceConfig.features);
    }"	""	""	"Configuration.touchscreen"	""
"2.2.1  Hardware"	"7.1.4.6"	"H-1-4"	"7.1.4.6/H-1-4"	""	"""[7.1.4.6/H-1-4] MUST report a GPU Frequency      tracepoint as specified by the format: [power/gpu_frequency](https://android.googlesource.com/platform/external/perfetto/+/refs/heads/master/protos/perfetto/trace/ftrace/power.proto).  Handheld device implementations:  *   ["""	""	""	"GPU android.googlesource.com power.proto"	""	""	""	""	""	""	""	""	""	""	""	"android.dumpsys.cts.GfxInfoDumpsysTest"	"testGfxinfoFramestats"	"CtsDumpsysHostTestCases"	""	""	""	"/home/gpoor/cts-12-source/cts/hostsidetests/dumpsys/src/android/dumpsys/cts/GfxInfoDumpsysTest.java"	""	"public void testGfxinfoFramestats() throws Exception {
        final String MARKER = ""---PROFILEDATA---"";

        try {
            // cleanup test apps that might be installed from previous partial test run
            getDevice().uninstallPackage(TEST_PKG);

            // install the test app
            CompatibilityBuildHelper buildHelper = new CompatibilityBuildHelper(mCtsBuild);
            File testAppFile = buildHelper.getTestFile(TEST_APK);
            String installResult = getDevice().installPackage(testAppFile, false);
            assertNull(
                    String.format(""failed to install atrace test app. Reason: %s"", installResult),
                    installResult);

            getDevice().executeShellCommand(""am start -W "" + TEST_PKG);

            String frameinfo = mDevice.executeShellCommand(""dumpsys gfxinfo "" +
                    TEST_PKG + "" framestats"");
            assertNotNull(frameinfo);
            assertTrue(frameinfo.length() > 0);
            int profileStart = frameinfo.indexOf(MARKER);
            int profileEnd = frameinfo.indexOf(MARKER, profileStart + 1);
            assertTrue(profileStart >= 0);
            assertTrue(profileEnd > profileStart);
            String profileData = frameinfo.substring(profileStart + MARKER.length(), profileEnd);
            assertTrue(profileData.length() > 0);
            validateProfileData(profileData);
        } finally {
            getDevice().uninstallPackage(TEST_PKG);
        }
    }

    private void validateProfileData(String profileData) throws IOException {
        final int TIMESTAMP_COUNT = 22;
        boolean foundAtLeastOneRow = false;
        try (BufferedReader reader = new BufferedReader(
                new StringReader(profileData))) {
            String line;
            // First line needs to be the headers
            while ((line = reader.readLine()) != null && line.isEmpty()) {}

            assertNotNull(line);
            assertTrue(""First line was not the expected header: "" + line,
                    line.startsWith(""Flags,FrameTimelineVsyncId,IntendedVsync,Vsync""
                            + "",InputEventId,HandleInputStart,AnimationStart,PerformTraversalsStart""
                            + "",DrawStart,FrameDeadline,FrameInterval,FrameStartTime""
                            + "",SyncQueued,SyncStart,IssueDrawCommandsStart,SwapBuffers""
                            + "",FrameCompleted,DequeueBufferDuration,QueueBufferDuration""
                            + "",GpuCompleted,SwapBuffersCompleted,DisplayPresentTime""));

            long[] numparts = new long[TIMESTAMP_COUNT];
            while ((line = reader.readLine()) != null && !line.isEmpty()) {

                String[] parts = line.split("","");
                assertTrue(parts.length >= TIMESTAMP_COUNT);
                for (int i = 0; i < TIMESTAMP_COUNT; i++) {
                    numparts[i] = assertInteger(parts[i]);
                }

                final long flags = numparts[0];
                // Flags = 1 just means the first frame of the window
                if (flags != 0 && flags != 1) {
                    continue;
                }

                final long timestampIntendedVsync = numparts[2];
                final long timestampVsync = numparts[3];
                // skip InputEventId, since it's a randomly assigned id
                final long timestampHandleInputStart = numparts[5];
                final long timestampAnimationStart = numparts[6];
                final long timestampPerformTraversalsStart = numparts[7];
                final long timestampDrawStart = numparts[8];
                // skip FrameDeadline, FrameInterval,FrameStartTime
                final long timestampSyncQueued = numparts[12];
                final long timestampSyncStart = numparts[13];
                final long timestampIssueDrawCommandsStart = numparts[14];
                final long timestampSwapBuffers = numparts[15];
                final long timestampFrameCompleted = numparts[16];

                // assert time is flowing forwards. we need to check each entry explicitly
                // as some entries do not represent a flow of events.
                assertTrue(""VSYNC happened before INTENDED_VSYNC"",
                        timestampVsync >= timestampIntendedVsync);
                assertTrue(""HandleInputStart happened before VSYNC"",
                        timestampHandleInputStart >= timestampVsync);
                assertTrue(""AnimationStart happened before HandleInputStart"",
                        timestampAnimationStart >= timestampHandleInputStart);
                assertTrue(""PerformTraversalsStart happened before AnimationStart"",
                        timestampPerformTraversalsStart >= timestampAnimationStart);
                assertTrue(""DrawStart happened before PerformTraversalsStart"",
                        timestampDrawStart >= timestampPerformTraversalsStart);
                assertTrue(""SyncQueued happened before DrawStart"",
                        timestampSyncQueued >= timestampDrawStart);
                assertTrue(""SyncStart happened before SyncQueued"",
                        timestampSyncStart >= timestampSyncQueued);
                assertTrue(""IssueDrawCommandsStart happened before SyncStart"",
                        timestampIssueDrawCommandsStart >= timestampSyncStart);
                assertTrue(""SwapBuffers happened before IssueDrawCommandsStart"",
                        timestampSwapBuffers >= timestampIssueDrawCommandsStart);
                assertTrue(""FrameCompleted happened before SwapBuffers"",
                        timestampFrameCompleted >= timestampSwapBuffers);

                // total duration is from IntendedVsync to FrameCompleted
                long totalDuration = timestampFrameCompleted - timestampIntendedVsync;
                assertTrue(""Frame did not take a positive amount of time to process"",
                        totalDuration > 0);
                assertTrue(""Bogus frame duration, exceeds 100 seconds"",
                        totalDuration < TimeUnit.SECONDS.toNanos(100));
                foundAtLeastOneRow = true;
            }
        }
        assertTrue(foundAtLeastOneRow);
    }
}"	""	""	"GPU"	""
"3.18  Contacts"	"3.18"	"C-1-1"	"3.18/C-1-1"	""	"""C-1-1] The      [`ACCOUNT_NAME`](https://developer.android.com/reference/android/provider/ContactsContract.SyncColumns.html#ACCOUNT_NAME),      of the **custom local account** MUST be returned by      [`ContactsContract.RawContacts.getLocalAccountName`](https://developer.android.com/reference/android/provider/ContactsContract.RawContacts.html#getLocalAccountName\(\)) """	""	""	"ContactsContract.RawContacts.getLocalAccountName ContactsContract.SyncColumns.html ACCOUNT_NAME ContactsContract.RawContacts.html"	""	""	""	""	""	""	""	""	""	""	""	"android.accounts.cts.AbstractAuthenticatorTests"	"testFinishSessionAndStartUpdateCredentialsSessionDefaultImpl"	"CtsAccountManagerTestCases"	""	""	""	"/home/gpoor/cts-12-source/cts/tests/tests/accounts/src/android/accounts/cts/AbstractAuthenticatorTests.java"	""	"public void testFinishSessionAndStartUpdateCredentialsSessionDefaultImpl()
            throws OperationCanceledException, AuthenticatorException, IOException,
            RemoteException {
        Bundle options = new Bundle();
        String accountName = Fixtures.PREFIX_NAME_SUCCESS + ""@"" + Fixtures.SUFFIX_NAME_FIXTURE;
        options.putString(Fixtures.KEY_ACCOUNT_NAME, accountName);

        // First obtain an encrypted session bundle from startUpdateCredentialsSession(...) default
        // implementation.
        AccountManagerFuture<Bundle> future = mAccountManager.startUpdateCredentialsSession(
                Fixtures.ACCOUNT_DEFAULT,
                null /* authTokenTYpe */,
                options,
                null /* activity */,
                null /* callback */,
                null /* handler */);

        Bundle result = future.getResult();
        assertTrue(future.isDone());
        assertNotNull(result);

        // Assert that result contains a non-null session bundle.
        Bundle escrowBundle = result.getBundle(AccountManager.KEY_ACCOUNT_SESSION_BUNDLE);
        assertNotNull(escrowBundle);

        // Now call finishSession(...) with the session bundle we just obtained.
        future = mAccountManager.finishSession(
                escrowBundle,
                null /* activity */,
                null /* callback */,
                null /* handler */);

        result = future.getResult();
        assertTrue(future.isDone());
        assertNotNull(result);

        // Validate that parameters are passed to updateCredentials(...) correctly in default
        // finishSession implementation.
        Bundle providerBundle = mProviderClient.call(
                AuthenticatorContentProvider.METHOD_GET,
                null /* arg */,
                null /* extras */);
        providerBundle.setClassLoader(UpdateCredentialsTx.class.getClassLoader());
        UpdateCredentialsTx updateCredentialsTx = providerBundle
                .getParcelable(AuthenticatorContentProvider.KEY_TX);
        assertNotNull(updateCredentialsTx);

        // Assert parameters has been passed to updateCredentials(...) correctly
        assertEquals(Fixtures.ACCOUNT_DEFAULT, updateCredentialsTx.account);
        assertNull(updateCredentialsTx.authTokenType);

        validateSystemOptions(updateCredentialsTx.options);
        // Validate options
        assertNotNull(updateCredentialsTx.options);
        assertEquals(accountName, updateCredentialsTx.options.getString(Fixtures.KEY_ACCOUNT_NAME));

        // Assert returned result contains correct account name, account type and null auth token.
        assertEquals(accountName, result.get(AccountManager.KEY_ACCOUNT_NAME));
        assertEquals(Fixtures.TYPE_DEFAULT, result.get(AccountManager.KEY_ACCOUNT_TYPE));
        assertNull(result.get(AccountManager.KEY_AUTHTOKEN));
    }

    private void validateSystemOptions(Bundle options) {
        assertNotNull(options.getString(AccountManager.KEY_ANDROID_PACKAGE_NAME));
        assertTrue(options.containsKey(AccountManager.KEY_CALLER_UID));
        assertTrue(options.containsKey(AccountManager.KEY_CALLER_PID));
    }

    private void validateNullPasswordAndStatusToken(Bundle result) {
        assertNull(result.getString(AccountManager.KEY_PASSWORD));
        assertNull(result.getString(AccountManager.KEY_ACCOUNT_STATUS_TOKEN));
    }

    /**
     * Tests isCredentialsUpdateSuggested default implementation.
     * A bundle with boolean false should be returned.
     */"	""	""	"ACCOUNT_NAME"	""
"3.2.3.5  Conditional Application Intents"	"3.2.3.5"	"C-11-1"	"3.2.3.5/C-11-1"	""	"""C-11-1] MUST have an activity that handles the [`Settings.ACTION_IGNORE_BACKGROUND_DATA_RESTRICTIONS_SETTINGS`](https://developer.android.com/reference/android/provider/Settings#ACTION_IGNORE_BACKGROUND_DATA_RESTRICTIONS_SETTINGS) intent but MAY implement it as a no-op.  If device implementations declare the support for camera via `android.hardware.camera.any` they:  """	""	""	"android.hardware.camera.any Settings.ACTION TINGS ACTION_IGNORE_BACKGROUND_DATA_RESTRICTIONS_SET"	""	""	""	""	""	""	""	""	""	""	""	"android.hardware.hdmi.cts.HdmiControlManagerTest"	"testHdmiCecConfig_TvTvSendStandbyOnSleep"	"CtsHardwareTestCases"	""	""	""	"/home/gpoor/cts-12-source/cts/tests/tests/hardware/src/android/hardware/hdmi/cts/HdmiControlManagerTest.java"	""	"public void testHdmiCecConfig_TvTvSendStandbyOnSleep() throws Exception {
        // Save original value
        int originalValue = mHdmiControlManager.getTvSendStandbyOnSleep();
        if (!mHdmiControlManager.getUserCecSettings().contains(
                HdmiControlManager.CEC_SETTING_NAME_TV_SEND_STANDBY_ON_SLEEP)) {
            return;
        }
        try {
            for (int value : mHdmiControlManager.getAllowedCecSettingIntValues(
                    HdmiControlManager.CEC_SETTING_NAME_TV_SEND_STANDBY_ON_SLEEP)) {
                mHdmiControlManager.setTvSendStandbyOnSleep(value);
                assertThat(mHdmiControlManager.getTvSendStandbyOnSleep()).isEqualTo(value);
            }
        } finally {
            // Restore original value
            mHdmiControlManager.setTvSendStandbyOnSleep(originalValue);
            assertThat(mHdmiControlManager.getTvSendStandbyOnSleep()).isEqualTo(
                    originalValue);
        }
    }
}"	""	""	"TINGS"	""
"7.4.5.2  IPv6"	"7.4.5.2"	"C-0-2"	"7.4.5.2/C-0-2"	""	"""C-0-2] MUST include an IPv6 networking stack and support IPv6 communication using the managed APIs, such as `java.net.Socket` and `java.net.URLConnection`, as well as the native APIs, such as `AF_INET6` sockets. """	""	""	"INET6 java.net.Socket java.net.URLConnection URLC"	""	""	""	""	""	""	""	""	""	""	""	"android.net.cts.network.permission.InternetPermissionTest"	""	"CtsNetTestCases"	""	""	""	"/home/gpoor/cts-12-source/cts/tests/tests/netpermission/internetpermission/src/android/net/cts/network/permission/InternetPermissionTest.java"	""	"/*
 *.
 */

package android.net.cts.networkpermission.internetpermission;

import static org.junit.Assert.fail;

import androidx.test.filters.SmallTest;
import androidx.test.runner.AndroidJUnit4;

import org.junit.Test;
import org.junit.runner.RunWith;

import java.net.Socket;
/**
* Test that protected android.net.ConnectivityManager methods cannot be called without
* permissions
*/
@RunWith(AndroidJUnit4.class)
public class InternetPermissionTest {

    /**
     * Verify that create inet socket failed because of the permission is missing.
     * <p>Tests Permission:
     *   {@link android.Manifest.permission#INTERNET}.
     */
    @SmallTest"	""	""	"java.net.Socket"	""
"3.2.3.5  Conditional Application Intents"	"3.2.3.5"	"C-6-1"	"3.2.3.5/C-6-1"	""	"""C-6-1] MUST implement an activity that would respond to the intent [`ACTION_NOTIFICATION_POLICY_ACCESS_SETTINGS`](https://developer.android.com/reference/android/provider/Settings#ACTION_NOTIFICATION_POLICY_ACCESS_SETTINGS), which for implementations with UI_MODE_TYPE_NORMAL it MUST be an activity where the user can grant or deny the app access to DND policy configurations.  If device implementations allow users to use third-party input methods on the device, they:  """	""	""	"ACTION_NOTIFICATION_POLICY_ACCESS_SETTINGS DND MODE_TYPE_NORMAL"	""	""	""	""	""	""	""	""	""	""	""	"android.app.cts.NotificationManagerTest"	"testSetAutomaticZenRuleState_multipleRules"	"CtsAppTestCases"	""	""	""	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/NotificationManagerTest.java"	""	"public void testSetAutomaticZenRuleState_multipleRules() throws Exception {
        toggleNotificationPolicyAccess(mContext.getPackageName(),
                InstrumentationRegistry.getInstrumentation(), true);

        AutomaticZenRule ruleToCreate = createRule(""Rule"");
        String id = mNotificationManager.addAutomaticZenRule(ruleToCreate);
        mRuleIds.add(id);

        AutomaticZenRule secondRuleToCreate = createRule(""Rule 2"");
        secondRuleToCreate.setInterruptionFilter(INTERRUPTION_FILTER_NONE);
        String secondId = mNotificationManager.addAutomaticZenRule(secondRuleToCreate);
        mRuleIds.add(secondId);

        // make sure DND is off
        assertExpectedDndState(INTERRUPTION_FILTER_ALL);

        // enable DND
        Condition condition =
                new Condition(ruleToCreate.getConditionId(), ""summary"", Condition.STATE_TRUE);
        mNotificationManager.setAutomaticZenRuleState(id, condition);
        Condition secondCondition =
                new Condition(secondRuleToCreate.getConditionId(), ""summary"", Condition.STATE_TRUE);
        mNotificationManager.setAutomaticZenRuleState(secondId, secondCondition);

        // the second rule has a 'more silent' DND filter, so the system wide DND should be
        // using its filter
        assertExpectedDndState(secondRuleToCreate.getInterruptionFilter());

        // remove intense rule, system should fallback to other rule
        mNotificationManager.removeAutomaticZenRule(secondId);
        assertExpectedDndState(ruleToCreate.getInterruptionFilter());
    }"	""	""	"DND"	""
"3.2.3.5  Conditional Application Intents"	"3.2.3.5"	"C-12-1"	"3.2.3.5/C-12-1"	""	"""C-12-1] MUST honor the [`android.media.action.STILL_IMAGE_CAMERA`](https://developer.android.com/reference/android/provider/MediaStore#INTENT_ACTION_STILL_IMAGE_CAMERA) and [`android.media.action.STILL_IMAGE_CAMERA_SECURE`](https://developer.android.com/reference/android/provider/MediaStore#INTENT_ACTION_STILL_IMAGE_CAMERA_SECURE) intent and launch the camera in still image mode as described in the SDK. """	""	""	"STILL_IMAGE_CAMERA STILL_IMAGE_CAMERA_SECURE INTENT_ACTION_STILL_IMAGE_CAMERA android.media.action.STILL INTENT_ACTION_STILL_IMAGE_CAMERA_SECURE"	""	""	""	""	""	""	""	""	""	""	""	"com.android.cts.managedprofile.DisallowSharingIntoProfileTest"	"getContext"	""	""	""	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/ManagedProfile/src/com/android/cts/managedprofile/DisallowSharingIntoProfileTest.java"	""	"public void test/*
 *.
 */

package com.android.cts.managedprofile;

import static com.android.cts.managedprofile.BaseManagedProfileTest.ADMIN_RECEIVER_COMPONENT;
import static java.util.concurrent.TimeUnit.SECONDS;

import android.app.admin.DevicePolicyManager;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageManager;
import android.content.pm.ResolveInfo;
import android.os.UserManager;
import android.provider.MediaStore;
import android.test.InstrumentationTestCase;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.CountDownLatch;

/**
 * Verify that certain cross profile intent filters are disallowed when the device admin sets
 * DISALLOW_SHARE_INTO_MANAGED_PROFILE restriction.
 * <p>
 * The way we check if a particular cross profile intent filter is disallowed is by trying to
 * resolve an example intent that matches the intent filter. The cross profile filter functions
 * correctly if and only if the resolution result contains a system intent forwarder activity
 * (com.android.internal.app.IntentForwarderActivity), which is the framework's mechanism to
 * trampoline intents across profiles. Instead of hardcoding the system's intent forwarder activity,
 * we retrieve it programmatically by resolving known cross profile intents specifically set up for
 * this purpose: {@link #KNOWN_ACTION_TO_PROFILE} and {@link #KNOWN_ACTION_TO_PERSONAL}
 */
public class DisallowSharingIntoProfileTest extends InstrumentationTestCase {

    // These are the data sharing intents which can be forwarded to the managed profile.
    private final List<Intent> sharingIntentsToProfile = Arrays.asList(
            new Intent(Intent.ACTION_SEND).setType(""*/*""),
            new Intent(Intent.ACTION_SEND_MULTIPLE).setType(""*/*""));

    // These are the data sharing intents which can be forwarded to the primary profile.
    private final List<Intent> sharingIntentsToPersonal = new ArrayList<>(Arrays.asList(
            new Intent(Intent.ACTION_GET_CONTENT).setType(""*/*"").addCategory(
                    Intent.CATEGORY_OPENABLE),
            new Intent(Intent.ACTION_OPEN_DOCUMENT).setType(""*/*"").addCategory(
                    Intent.CATEGORY_OPENABLE),
            new Intent(Intent.ACTION_PICK).setType(""*/*"").addCategory(
                    Intent.CATEGORY_DEFAULT),
            new Intent(Intent.ACTION_PICK).addCategory(Intent.CATEGORY_DEFAULT)));

    // These are the data sharing intents which can be forwarded to the primary profile,
    // if the device supports FEATURE_CAMERA
    private final List<Intent> sharingIntentsToPersonalIfCameraExists = Arrays.asList(
            new Intent(MediaStore.ACTION_IMAGE_CAPTURE),
            new Intent(MediaStore.ACTION_VIDEO_CAPTURE),
            new Intent(MediaStore.INTENT_ACTION_STILL_IMAGE_CAMERA),
            new Intent(MediaStore.INTENT_ACTION_VIDEO_CAMERA),
            new Intent(MediaStore.ACTION_IMAGE_CAPTURE_SECURE),
            new Intent(MediaStore.INTENT_ACTION_STILL_IMAGE_CAMERA_SECURE));

    private static final String KNOWN_ACTION_TO_PROFILE = ManagedProfileActivity.ACTION;
    private static final String KNOWN_ACTION_TO_PERSONAL = PrimaryUserActivity.ACTION;

    protected Context mContext;
    protected DevicePolicyManager mDevicePolicyManager;

    @Override
    public void setUp() throws Exception {
        super.setUp();

        mContext = getInstrumentation().getContext();
        mDevicePolicyManager = mContext.getSystemService(DevicePolicyManager.class);
        assertNotNull(mDevicePolicyManager);
    }"	""	""	"INTENT_ACTION_STILL_IMAGE_CAMERA_SECURE"	""
"7.4.8  Secure Elements"	"7.4.8"	"C-1-2"	"7.4.8/C-1-2"	""	"""C-1-2] MUST declare the correct feature flags via     [`android.hardware.se.omapi.uicc`](     https://developer.android.com/reference/android/content/pm/PackageManager#FEATURE_SE_OMAPI_UICC)     for the device with UICC-based secure elements,     [`android.hardware.se.omapi.ese`](     https://developer.android.com/reference/android/content/pm/PackageManager#FEATURE_SE_OMAPI_ESE)     for the device with eSE-based secure elements and     [`android.hardware.se.omapi.sd`](     https://developer.android.com/reference/android/content/pm/PackageManager#FEATURE_SE_OMAPI_SD)     for the device with SD-based secure elements."""	""	""	"android.hardware.se.omapi.sd FEATURE_SE_OMAPI_SD android.hardware.se.omapi.ese FEATURE_SE_OMAPI_ESE FEATURE_SE_OMAPI_UICC UICC android.hardware.se.omapi.uicc"	""	""	""	""	""	""	""	""	""	""	""	"android.telephony.euicc.cts.GetEuiccProfileInfoListResultTest"	"testWriteToParcel"	"CtsTelephonyTestCases"	""	""	""	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/euicc/cts/GetEuiccProfileInfoListResultTest.java"	""	"public void testWriteToParcel() {
        assertNotNull(mProfileListResult);

        Parcel parcel = Parcel.obtain();
        assertTrue(parcel != null);
        mProfileListResult.writeToParcel(parcel, 0);

        parcel.setDataPosition(0);
        GetEuiccProfileInfoListResult fromParcel =
                GetEuiccProfileInfoListResult.CREATOR.createFromParcel(parcel);

        assertEquals(EuiccService.RESULT_RESOLVABLE_ERRORS, fromParcel.getResult());
        assertNull(mProfileListResult.getProfiles());
        assertFalse(mProfileListResult.getIsRemovable());
    }
}"	""	""	"UICC"	""
"9.1  Permissions"	"9.1"	"C-2-1"	"9.1/C-2-1"	""	"""C-2-1] MUST ensure that all activities with intent filters for the     [`ACTION_MANAGE_OVERLAY_PERMISSION`](     https://developer.android.com/reference/android/provider/Settings.html#ACTION_MANAGE_OVERLAY_PERMISSION)     intent have the same UI screen, regardless of the initiating app or any     information it provides."""	""	""	"Settings.html ACTION_MANAGE_OVERLAY_PERMISSION"	""	""	""	""	""	""	""	""	""	""	""	"com.android.cts.verifier.net.MultiNetworkConnectivityTestActivity"	"startTest"	""	""	""	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/net/MultiNetworkConnectivityTestActivity.java"	""	"public void testCompleted(MultiNetworkValidator validator) {
                    if (validator == mMultiNetworkValidators.get(mMultiNetworkValidators.size()
                            - 1)) {
                        // Done all tests.
                        boolean passed = true;
                        for (MultiNetworkValidator multiNetworkValidator :
                                mMultiNetworkValidators) {
                            passed = passed && multiNetworkValidator.mTestResult;
                        }
                        setTestResultAndFinish(passed);
                    } else if (!validator.mTestResult) {
                        setTestResultAndFinish(false);
                    } else {
                        for (int i = 0; i < mMultiNetworkValidators.size(); i++) {
                            if (mMultiNetworkValidators.get(i) == validator) {
                                mCurrentValidator = mMultiNetworkValidators.get(i + 1);
                                mTestNameView.setText(mCurrentValidator.mTestDescription);
                                mCurrentValidator.startTest();
                                break;
                            }
                        }
                    }
                }
            };
    private List<MultiNetworkValidator> mMultiNetworkValidators = Collections.emptyList();
    private final Runnable mTimeToCompletionRunnable = new Runnable() {
        @Override
        public void run() {
            mSecondsToCompletion--;
            if (mSecondsToCompletion > 0) {
                mStartButton.setText("""" + mSecondsToCompletion);
                mMainHandler.postDelayed(this, 1000);
            }
        }
    };

    // User interface elements.
    private Button mStartButton;
    private TextView mTestNameView;
    private TextView mTestInfoView;
    private EditText mAccessPointSsidEditText;
    private EditText mPskEditText;

    // Current state memebers.
    private MultiNetworkValidator mCurrentValidator;
    private int mSecondsToCompletion;
    private String mAccessPointSsid = """";
    private String mPskValue = """";
    private ConnectivityManager mConnectivityManager;
    private WifiManager mWifiManager;

    private int mRecordedWifiConfiguration = -1;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        mConnectivityManager = (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE);
        mWifiManager = (WifiManager) getSystemService(Context.WIFI_SERVICE);
        mMultiNetworkValidators = createMultiNetworkValidators();

        recordCurrentWifiState();
        setupUserInterface();
        setupBroadcastReceivers();
    }

    @Override
    protected void onResume() {
        super.onResume();
        setupCurrentTestStateOnResume();
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        destroyBroadcastReceivers();
        restoreOriginalWifiState();
    }

    private void recordCurrentWifiState() {
        if (!mWifiManager.isWifiEnabled()) {
            return;
        }
        WifiInfo wifiInfo = mWifiManager.getConnectionInfo();
        if (wifiInfo != null && SupplicantState.COMPLETED.equals(wifiInfo.getSupplicantState())) {
            mRecordedWifiConfiguration = wifiInfo.getNetworkId();
        }
    }

    private List<MultiNetworkValidator> createMultiNetworkValidators() {
        MultiNetworkValidator[] allValidators = {
            new ConnectToWifiWithNoInternetValidator(
                    R.string.multinetwork_connectivity_test_1_desc),
            new LegacyConnectToWifiWithNoInternetValidator(
                    R.string.multinetwork_connectivity_test_2_desc),
            new LegacyConnectToWifiWithIntermittentInternetValidator(
                    R.string.multinetwork_connectivity_test_3_desc)
        };

        List<MultiNetworkValidator> result = new ArrayList<>();
        boolean isLowRamDevice = isLowRamDevice();
        for (MultiNetworkValidator validator : allValidators) {
          if (!isLowRamDevice || validator.shouldRunOnLowRamDevice()) {
            result.add(validator);
          }
        }
        return result;
    }

    private void restoreOriginalWifiState() {
        if (mRecordedWifiConfiguration >= 0) {
            mWifiManager.enableNetwork(mRecordedWifiConfiguration, true);
        }
    }

    private boolean requestSystemAlertWindowPerimissionIfRequired() {
        if (isLowRamDevice()) {
          // For low ram devices, we won't run tests that depend on this permission.
          return true;
        }

        boolean hadPermission = false;
        if (!Settings.canDrawOverlays(this)) {
            AlertDialog alertDialog = new AlertDialog.Builder(this)
                .setMessage(R.string.multinetwork_connectivity_overlay_permission_message)
                .setPositiveButton(
                  R.string.multinetwork_connectivity_overlay_permission_positive,
                  (a, b) -> {
                      Intent myIntent = new Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION);
                      startActivity(myIntent);
                  })
                .setNegativeButton(
                  R.string.multinetwork_connectivity_overlay_permission_negative,
                  (a, b) -> {})
                .create();
            alertDialog.show();
        } else {
          hadPermission = true;
        }

        return hadPermission;
    }

    private void requestUserEnableWifiAsync(boolean enableWifi, SetWifiCallback callback) {
        if (isWifiEnabled() == enableWifi) {
          callback.onComplete(/* isSuccess = */ true);
          return;
        }

        int wifiEnableMessage = enableWifi ? R.string.multinetwork_connectivity_turn_wifi_on :
                                             R.string.multinetwork_connectivity_turn_wifi_off;

        AlertDialog alertDialog = new AlertDialog.Builder(this)
            .setMessage(wifiEnableMessage)
            .setPositiveButton(R.string.multinetwork_connectivity_turn_wifi_positive,
                (a, b) -> requestUserEnableWifiAsync(enableWifi, callback))
            .setNegativeButton(R.string.multinetwork_connectivity_turn_wifi_negative,
                (a, b) -> callback.onComplete(/* isSuccess = */ false))
            .create();
        alertDialog.show();
    }

    private void toggleWifiAsync(SetWifiCallback callback) {
        // Turn off WiFi.
        requestUserEnableWifiAsync(false, (isSuccess) -> {
          if (isSuccess) {
              // Turn on WiFi.
              requestUserEnableWifiAsync(true, callback);
          } else {
              callback.onComplete(/* isSuccess = */ false);
          }
        });
    }

    private boolean isWifiEnabled() {
      WifiManager wifiManager = (WifiManager)getSystemService(Context.WIFI_SERVICE);
      int wifiState = wifiManager.getWifiState();
      return wifiState == WifiManager.WIFI_STATE_ENABLED
          || wifiState == WifiManager.WIFI_STATE_ENABLING;
    }

    private void setupUserInterface() {
        setContentView(R.layout.multinetwork_connectivity);
        setInfoResources(
                R.string.multinetwork_connectivity_test,
                R.string.multinetwork_connectivity_test_instructions,
                -1);
        mStartButton = findViewById(R.id.start_multinet_btn);
        mTestNameView = findViewById(R.id.current_test);
        mTestInfoView = findViewById(R.id.test_progress_info);
        mAccessPointSsidEditText = findViewById(R.id.test_ap_ssid);
        mPskEditText = findViewById(R.id.test_ap_psk);
        mAccessPointSsidEditText.addTextChangedListener(new TextWatcher() {
            @Override
            public void beforeTextChanged(CharSequence charSequence, int i, int i1, int i2) {}

            @Override
            public void onTextChanged(CharSequence charSequence, int i, int i1, int i2) {}

            @Override
            public void afterTextChanged(Editable editable) {
                mAccessPointSsid = editable.toString();
                Log.i(TAG, ""Connecting to "" + mAccessPointSsid);
                mStartButton.setEnabled(isReadyToStart());
            }
        });
        mPskEditText.addTextChangedListener(new TextWatcher() {
            @Override
            public void beforeTextChanged(CharSequence charSequence, int i, int i1, int i2) {}

            @Override
            public void onTextChanged(CharSequence charSequence, int i, int i1, int i2) {}

            @Override
            public void afterTextChanged(Editable editable) {
                mPskValue = editable.toString();
                mStartButton.setEnabled(isReadyToStart());
            }
        });
        mStartButton.setOnClickListener(view -> processStartClicked());
    }

    private void setupBroadcastReceivers() {
        IntentFilter intentFilter = new IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION);
        intentFilter.addAction(WifiManager.NETWORK_STATE_CHANGED_ACTION);
        intentFilter.addAction(WifiManager.SUPPLICANT_CONNECTION_CHANGE_ACTION);
        intentFilter.addAction(WifiManager.SUPPLICANT_STATE_CHANGED_ACTION);
        registerReceiver(mMultiNetConnectivityReceiver, intentFilter);
    }

    private void destroyBroadcastReceivers() {
        unregisterReceiver(mMultiNetConnectivityReceiver);
    }

    private boolean isReadyToStart() {
        return !(TextUtils.isEmpty(mAccessPointSsid) || TextUtils.isEmpty(mPskValue));
    }

    private static boolean isNetworkCellularAndHasInternet(ConnectivityManager connectivityManager,
            Network network) {
        NetworkCapabilities capabilities = connectivityManager.getNetworkCapabilities(network);
        return capabilities.hasTransport(TRANSPORT_CELLULAR)
                && capabilities.hasCapability(NET_CAPABILITY_INTERNET);
    }

    private boolean isMobileDataEnabled(TelephonyManager telephonyManager) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            return telephonyManager.isDataEnabled();
        }
        Network[] allNetworks = mConnectivityManager.getAllNetworks();
        for (Network network : allNetworks) {
            if (isNetworkCellularAndHasInternet(mConnectivityManager, network)) {
                return true;
            }
        }
        return false;
    }

    private boolean checkPreRequisites() {
        TelephonyManager telephonyManager =
                (TelephonyManager) getSystemService(Context.TELEPHONY_SERVICE);
        if (telephonyManager == null) {
            Log.e(TAG, ""Device does not have telephony manager"");
            mTestInfoView.setText(R.string.multinetwork_connectivity_test_all_prereq_1);
            return false;
        } else if (!isMobileDataEnabled(telephonyManager)) {
            Log.e(TAG, ""Device mobile data is not available"");
            mTestInfoView.setText(R.string.multinetwork_connectivity_test_all_prereq_2);
            return false;
        }
        return true;
    }

    /**
     * If tester went back and came in again, make sure that test resumes from the previous state.
     */
    private void setupCurrentTestStateOnResume() {
        mCurrentValidator = null;
        mStartButton.setEnabled(false);

        if (!checkPreRequisites()) {
            return;
        }

        for (MultiNetworkValidator multiNetworkValidator : mMultiNetworkValidators) {
          if (multiNetworkValidator.mValidatorState != COMPLETED) {
            mCurrentValidator = multiNetworkValidator;
            break;
          }
        }
        if (mCurrentValidator != null) {
            mTestNameView.setText(mCurrentValidator.mTestDescription);

            switch (mCurrentValidator.mValidatorState) {
                case NOT_STARTED:
                    mStartButton.setText(R.string.multinetwork_connectivity_test_start);
                    mStartButton.setEnabled(isReadyToStart());
                    break;
                case STARTED:
                    mTestInfoView.setText(getResources().getString(
                            mCurrentValidator.mTestProgressMessage));
                    break;
                case WAITING_FOR_USER_INPUT:
                    mStartButton.setText(R.string.multinetwork_connectivity_test_continue);
                    mStartButton.setEnabled(true);
                    mTestInfoView.setText(getResources().getString(
                            mCurrentValidator.mTestProgressMessage));
                case COMPLETED:
                    break;
            }
            mTestNameView.setText(mCurrentValidator.mTestDescription);
        } else {
            // All tests completed, so need to re run. It's not likely to get here as
            // the default action when all test completes is to mark success and finish.
            mStartButton.setText(R.string.multinetwork_connectivity_test_rerun);
            mStartButton.setEnabled(true);
            rerunMultinetworkTests();
            mCurrentValidator = mMultiNetworkValidators.get(0);
        }
    }

    private void rerunMultinetworkTests() {
        for (MultiNetworkValidator validator : mMultiNetworkValidators) {
            validator.reset();
        }
    }

    private void requestUserConfirmation() {
        mMainHandler.post(() -> {
            mStartButton.setText(R.string.multinetwork_connectivity_test_continue);
            mStartButton.setEnabled(true);
        });
    }

    private void processStartClicked() {
        if (!requestSystemAlertWindowPerimissionIfRequired()) {
          Log.e(TAG, ""System alert dialog permission not granted to CTSVerifier"");
          return;
        }

        if (mCurrentValidator == null) {
            rerunMultinetworkTests();
            setupCurrentTestStateOnResume();
        }
        mStartButton.setEnabled(false);
        if (mCurrentValidator.mValidatorState == NOT_STARTED) {
            mCurrentValidator.startTest();
        } else if (mCurrentValidator.mValidatorState == WAITING_FOR_USER_INPUT) {
            mStartButton.setEnabled(false);
            mCurrentValidator.continueWithTest();
        }
    }

    private WifiConfiguration buildWifiConfiguration() {
        WifiConfiguration wifiConfiguration = new WifiConfiguration();
        wifiConfiguration.SSID = ""\"""" + mAccessPointSsid + ""\"""";
        wifiConfiguration.preSharedKey = ""\"""" + mPskValue + ""\"""";
        wifiConfiguration.status = WifiConfiguration.Status.ENABLED;
        wifiConfiguration.allowedGroupCiphers.set(WifiConfiguration.GroupCipher.TKIP);
        wifiConfiguration.allowedGroupCiphers.set(WifiConfiguration.GroupCipher.CCMP);
        wifiConfiguration.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.WPA_PSK);
        wifiConfiguration.allowedPairwiseCiphers.set(WifiConfiguration.PairwiseCipher.TKIP);
        wifiConfiguration.allowedPairwiseCiphers.set(WifiConfiguration.PairwiseCipher.CCMP);
        wifiConfiguration.allowedProtocols.set(WifiConfiguration.Protocol.RSN);
        return wifiConfiguration;
    }

    private int getOrAddLegacyNetwork() {
        List<WifiConfiguration> availableConfigurations = mWifiManager.getConfiguredNetworks();
        for (WifiConfiguration configuration : availableConfigurations) {
            if (mAccessPointSsid.equals(configuration.SSID)) {
                return configuration.networkId;
            }
        }
        int newNetwork = mWifiManager.addNetwork(buildWifiConfiguration());
        return newNetwork;
    }

    private boolean isConnectedToExpectedWifiNetwork() {
        WifiInfo wifiInfo = mWifiManager.getConnectionInfo();
        DhcpInfo dhcpInfo = mWifiManager.getDhcpInfo();
        Log.i(TAG, ""Checking connected to expected "" + mAccessPointSsid);
        if (wifiInfo != null
                && wifiInfo.getSupplicantState().equals(SupplicantState.COMPLETED)
                && dhcpInfo != null) {
            String failsafeSsid = String.format(""\""%s\"""", mAccessPointSsid);
            Log.i(TAG, ""Connected to "" + wifiInfo.getSSID() + "" expected "" + mAccessPointSsid);
            return mAccessPointSsid.equals(wifiInfo.getSSID())
                    || failsafeSsid.equals(wifiInfo.getSSID());
        }
        return false;
    }

    private void startTimerCountdownDisplay(int timeoutInSeconds) {
        mMainHandler.post(() -> mSecondsToCompletion = timeoutInSeconds);
        mMainHandler.post(mTimeToCompletionRunnable);
    }

    private void stopTimerCountdownDisplay() {
        mMainHandler.removeCallbacks(mTimeToCompletionRunnable);
        mStartButton.setText(""--"");
    }

    private boolean isLowRamDevice() {
        ActivityManager activityManager =
            (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE);
        return activityManager.isLowRamDevice();
    }

    /**
     * Manage the connectivity state for each MultinetworkValidation.
     */
    private class TestConnectivityState {
        private final MultiNetworkValidator mMultiNetworkValidator;

        final NetworkCallback mWifiNetworkCallback = new NetworkCallback() {
            @Override
            public void onAvailable(Network network) {
                Log.i(TAG, ""Wifi network available "" + network);
                stopTimerDisplayIfRequested();
                mMultiNetworkValidator.onWifiNetworkConnected(network);
            }

            @Override
            public void onUnavailable() {
                Log.e(TAG, ""Failed to connect to wifi"");
                stopTimerDisplayIfRequested();
                mMultiNetworkValidator.onWifiNetworkUnavailable();
            }
        };
        final NetworkCallback mCellularNetworkCallback = new NetworkCallback() {
            @Override
            public void onAvailable(Network network) {
                Log.i(TAG, ""Cellular network available "" + network);
                stopTimerDisplayIfRequested();
                mMultiNetworkValidator.onCellularNetworkConnected(network);
            }

            @Override
            public void onUnavailable() {
                Log.e(TAG, ""Cellular network unavailable "");
                stopTimerDisplayIfRequested();
                mMultiNetworkValidator.onCellularNetworkUnavailable();
            }
        };
        boolean mCellularNetworkRequested;
        boolean mWifiNetworkRequested;
        boolean mTimerStartRequested;

        TestConnectivityState(MultiNetworkValidator validator) {
            mMultiNetworkValidator = validator;
        }

        void reset() {
            mMainHandler.post(() -> stopTimerDisplayIfRequested());
            if (mWifiNetworkRequested) {
                mConnectivityManager.unregisterNetworkCallback(mWifiNetworkCallback);
                mWifiNetworkRequested = false;
            }
            if (mCellularNetworkRequested) {
                mConnectivityManager.unregisterNetworkCallback(mCellularNetworkCallback);
                mCellularNetworkRequested = false;
            }
        }

        private void legacyConnectToWifiNetwork(boolean requireInternet) {
            // If device is not connected to the expected WifiNetwork, connect to the wifi Network.
            // Timeout with failure if it can't connect.
            if (!isConnectedToExpectedWifiNetwork()) {
                int network = getOrAddLegacyNetwork();
                WifiManager wifiManager = (WifiManager) getApplicationContext()
                        .getSystemService(Context.WIFI_SERVICE);
                wifiManager.enableNetwork(network, true);
            }
            startTimerDisplay(WIFI_NETWORK_CONNECT_TIMEOUT_MS / 1000);
            NetworkRequest.Builder networkRequestBuilder = new NetworkRequest.Builder()
                    .addTransportType(TRANSPORT_WIFI);
            if (requireInternet) {
                networkRequestBuilder.addCapability(NET_CAPABILITY_INTERNET);
            }
            NetworkRequest networkRequest = networkRequestBuilder.build();
            mWifiNetworkRequested = true;
            mConnectivityManager.requestNetwork(networkRequest, mWifiNetworkCallback,
                    mMainHandler, WIFI_NETWORK_CONNECT_TIMEOUT_MS);
        }

        private void connectToWifiNetworkWithNoInternet() {
            NetworkSpecifier specifier =
                new WifiNetworkSpecifier.Builder()
                  .setSsid(mAccessPointSsid)
                  .setWpa2Passphrase(mPskValue)
                  .build();

            NetworkRequest networkRequest = new NetworkRequest.Builder()
                    .addTransportType(TRANSPORT_WIFI)
                    .setNetworkSpecifier(specifier)
                    .removeCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
                    .build();

            mWifiNetworkRequested = true;
            mConnectivityManager.requestNetwork(networkRequest, mWifiNetworkCallback,
                    mMainHandler);
        }

        private void connectToCellularNetwork() {
            NetworkRequest networkRequest = new NetworkRequest.Builder()
                    .addTransportType(TRANSPORT_CELLULAR)
                    .addCapability(NET_CAPABILITY_INTERNET)
                    .build();
            startTimerDisplay(CELLULAR_NETWORK_CONNECT_TIMEOUT_MS / 1000);
            mCellularNetworkRequested = true;
            mConnectivityManager.requestNetwork(networkRequest, mCellularNetworkCallback,
                    mMainHandler, CELLULAR_NETWORK_CONNECT_TIMEOUT_MS);
        }

        private void startTimerDisplay(int timeInSeconds) {
            startTimerCountdownDisplay(timeInSeconds);
            mTimerStartRequested = true;
        }

        /** Timer is a shared resource, change the state only if it's started in a request. */
        private void stopTimerDisplayIfRequested() {
            if (mTimerStartRequested) {
                mTimerStartRequested = false;
                stopTimerCountdownDisplay();
            }
        }
    }

    /**
     * Manage the lifecycle of each test to be run in the validator.
     *
     * Each test goes through this cycle
     * - Start
     * - Connect to cellular network
     * - Connect to wifi network
     * - Check expectation
     * - End test
     */
    private abstract class MultiNetworkValidator {
        final String mTestName;
        final MultinetworkTestCallback mTestCallback;
        final TestConnectivityState mConnectivityState;
        final boolean mRunTestOnLowMemoryDevices;

        int mTestDescription;
        boolean mTestResult = false;
        ValidatorState mValidatorState;
        int mTestResultMessage = -1;
        int mTestProgressMessage;

        MultiNetworkValidator(MultinetworkTestCallback testCallback,
                String testName,
                int testDescription,
                boolean runTestOnLowMemoryDevices) {
            mTestCallback = testCallback;
            mTestName = testName;
            mTestDescription = testDescription;
            mConnectivityState = new TestConnectivityState(this);
            mValidatorState = NOT_STARTED;
            mRunTestOnLowMemoryDevices = runTestOnLowMemoryDevices;
        }

        /** Start test if not started. */
        void startTest() {
            Handler uiThreadHandler = new Handler(Looper.getMainLooper());
            if (mValidatorState == NOT_STARTED) {
                mTestCallback.testStarted();
                toggleWifiAsync(hasToggled -> {
                    if (!hasToggled) {
                        onUnableToSetWifi();
                        return;
                    }
                    mTestCallback.testProgress(
                        R.string.multinetwork_connectivity_test_connect_cellular);
                    mConnectivityState.connectToCellularNetwork();
                });
            }
        }

        /** Make sure that the state is restored for re-running the test. */
        void reset() {
            mValidatorState = NOT_STARTED;
            mTestResultMessage = -1;
            mTestProgressMessage = -1;
        }

        /** Called when user has requested to continue with the test */
        void continueWithTest() {
            mValidatorState = STARTED;
        }

        void onCellularNetworkUnavailable() {
            endTest(false, R.string.multinetwork_status_mobile_connect_timed_out);
        }

        void onUnableToSetWifi() {
            endTest(false, R.string.multinetwork_status_unable_to_toggle_wifi);
        }

        void endTest(boolean status, int messageResId) {
            Log.i(TAG, ""Ending test with status "" + status + "" message "" +
                MultiNetworkConnectivityTestActivity.this.getResources().getString(messageResId));
            mMainHandler.post(() -> {
                mTestResult = status;
                mTestResultMessage = messageResId;
                mValidatorState = COMPLETED;
                mTestCallback.testCompleted(MultiNetworkValidator.this);
                mConnectivityState.reset();
            });
        }

        /** Called when cellular network is connected. */
        void onCellularNetworkConnected(Network network) {
            onContinuePreWifiConnect();
        }

        /**
         * @param transport The active network has this transport type
         * @return
         */
        boolean isExpectedTransportForActiveNetwork(int transport) {
            Network activeNetwork = mConnectivityManager.getActiveNetwork();
            NetworkCapabilities activeNetworkCapabilities =
                    mConnectivityManager.getNetworkCapabilities(activeNetwork);
            Log.i(TAG, ""Network capabilities for "" + activeNetwork + "" ""
                    + activeNetworkCapabilities.hasCapability(NET_CAPABILITY_INTERNET));
            return activeNetworkCapabilities.hasTransport(transport)
                    && activeNetworkCapabilities.hasCapability(NET_CAPABILITY_INTERNET);
        }

        /**
         * @param network to check if connected or not.
         * @return
         */
        boolean isNetworkConnected(Network network) {
            NetworkInfo networkInfo = mConnectivityManager.getNetworkInfo(network);
            boolean status = networkInfo != null && networkInfo.isConnectedOrConnecting();
            Log.i(TAG, ""Network connection status "" + network + "" "" + status);
            return status;
        }

        /**
         * Called before connecting to wifi. Specially if the concrete validator wants to
         * prompt a message
         */
        abstract void onContinuePreWifiConnect();

        /** Called when a wifi network is connected and available */
        void onWifiNetworkConnected(Network network) {
            Log.i(TAG, ""Wifi network connected "" + network);
        }

        void onWifiNetworkUnavailable() {
            endTest(false, R.string.multinetwork_status_wifi_connect_timed_out);
        }

        boolean shouldRunOnLowRamDevice() {
          return mRunTestOnLowMemoryDevices;
        }
    }

    /**
     * Test that device does not lose cellular connectivity when it's connected to an access
     * point with no connectivity using legacy API's.
     */
    private class LegacyConnectToWifiWithNoInternetValidator extends MultiNetworkValidator {

        LegacyConnectToWifiWithNoInternetValidator(int description) {
            super(mMultinetworkTestCallback,
                ""legacy_no_internet_test"",
                description,
                /* runTestOnLowMemoryDevices = */ false);
        }


        @Override
        void continueWithTest() {
            super.continueWithTest();
            connectToWifi();
        }

        @Override
        void onContinuePreWifiConnect() {
            mTestProgressMessage = R.string.multinetwork_connectivity_test_1_prereq;
            mTestCallback.testProgress(mTestProgressMessage);
            mValidatorState = WAITING_FOR_USER_INPUT;
            requestUserConfirmation();
        }

        @Override
        void onWifiNetworkConnected(Network wifiNetwork) {
            super.onWifiNetworkConnected(wifiNetwork);
            if (isConnectedToExpectedWifiNetwork()) {
                startTimerCountdownDisplay(CELLULAR_NETWORK_RESTORE_TIMEOUT_MS / 1000);
                mTestCallback.testProgress(R.string.multinetwork_connectivity_test_progress_2);

                // Wait for CELLULAR_NETWORK_RESTORE_TIMEOUT_MS, before checking if there is still
                // the active network as the cell network.
                mMainHandler.postDelayed(() -> {
                    stopTimerCountdownDisplay();
                    mMainHandler.post(() -> {
                        if (isExpectedTransportForActiveNetwork(TRANSPORT_CELLULAR)
                                && isNetworkConnected(wifiNetwork)) {
                            Log.d(TAG, ""PASS test as device has connectivity"");
                            endTest(true, R.string.multinetwork_status_mobile_restore_success);
                        } else {
                            Log.d(TAG, ""Fail test as device didn't have connectivity"");
                            endTest(false, R.string.multinetwork_status_mobile_restore_failed);
                        }
                    });
                }, CELLULAR_NETWORK_RESTORE_TIMEOUT_MS);
            } else {
                endTest(false, R.string.multinetwork_status_wifi_connect_wrong_ap);
            }
        }

        void connectToWifi() {
            mTestCallback.testProgress(R.string.multinetwork_connectivity_test_connect_wifi);
            mConnectivityState.legacyConnectToWifiNetwork(false);
        }
    }

    /**
     * Test that device restores lost cellular connectivity when it's connected to an access
     * point which loses internet connectivity using legacy API's.
     */
    private class LegacyConnectToWifiWithIntermittentInternetValidator
        extends MultiNetworkValidator {
        boolean mWaitingForWifiConnect = false;
        boolean mWaitingForCelluarToConnectBack = false;
        Network mWifiNetwork;

        LegacyConnectToWifiWithIntermittentInternetValidator(int description) {
            super(mMultinetworkTestCallback,
                ""legacy_no_internet_test"",
                description,
                /* runTestOnLowMemoryDevices = */ false);
        }

        @Override
        void continueWithTest() {
            super.continueWithTest();
            if (mWaitingForWifiConnect) {
                connectToWifi();
            } else if (mWaitingForCelluarToConnectBack) {
                mWaitingForCelluarToConnectBack = false;
                waitForConnectivityRestore();
            }
        }

        @Override
        void onContinuePreWifiConnect() {
            mTestProgressMessage = R.string.multinetwork_connectivity_test_2_prereq_1;
            mTestCallback.testProgress(mTestProgressMessage);
            mValidatorState = WAITING_FOR_USER_INPUT;
            mWaitingForWifiConnect = true;
            requestUserConfirmation();
        }

        void connectToWifi() {
            mTestCallback.testProgress(R.string.multinetwork_connectivity_test_connect_wifi);
            mConnectivityState.legacyConnectToWifiNetwork(true);
        }

        @Override
        void onWifiNetworkConnected(Network wifiNetwork) {
            super.onWifiNetworkConnected(wifiNetwork);
            if (isConnectedToExpectedWifiNetwork()) {
                // If the device is connected to the expected network, then update the wifi
                // network to the latest.
                mWifiNetwork = wifiNetwork;
                // Do further processing only when the test is requesting and waiting for a wifi
                // connection.
                if (mWaitingForWifiConnect) {
                    mWaitingForWifiConnect = false;
                    startTimerCountdownDisplay(WIFI_NETWORK_CONNECT_TO_BE_ACTIVE_MS / 1000);

                    // Wait for WIFI_NETWORK_CONNECT_TO_BE_ACTIVE_MS, before checking
                    // if device has the active network as wifi network..
                    mTestCallback.testProgress(R.string.multinetwork_connectivity_test_progress_2);
                    mMainHandler.postDelayed(() -> {
                        stopTimerCountdownDisplay();
                        // In this case both active and peer are same as Wifi has internet access.
                        if (isExpectedTransportForActiveNetwork(TRANSPORT_WIFI)
                                && isNetworkConnected(mWifiNetwork)) {
                            // Ask the user to turn off wifi on the router and check connectivity.
                            mTestProgressMessage =
                                    R.string.multinetwork_connectivity_test_2_prereq_2;
                            mValidatorState = WAITING_FOR_USER_INPUT;
                            mTestCallback.testProgress(mTestProgressMessage);
                            mWaitingForCelluarToConnectBack = true;
                            requestUserConfirmation();
                        } else {
                            Log.d(TAG, ""Fail test as device didn't have connectivity"");
                            endTest(false, R.string.multinetwork_status_wifi_connectivity_failed);
                        }
                    }, WIFI_NETWORK_CONNECT_TO_BE_ACTIVE_MS);
                }
            } else {
                endTest(false, R.string.multinetwork_status_wifi_connect_wrong_ap);
            }
        }

        @Override
        void reset() {
            super.reset();
            mWaitingForCelluarToConnectBack = false;
            mWaitingForWifiConnect = false;
            mWifiNetwork = null;
        }

        @Override
        void onWifiNetworkUnavailable() {
            if (mWaitingForWifiConnect) {
                super.onWifiNetworkUnavailable();
            }
        }

        void waitForConnectivityRestore() {
            mTestCallback.testProgress(R.string.multinetwork_connectivity_test_progress_1);
            mConnectivityManager.reportNetworkConnectivity(mWifiNetwork, false);
            startTimerCountdownDisplay(
                    CELLULAR_NETWORK_RESTORE_AFTER_WIFI_INTERNET_LOST_TIMEOUT_MS / 1000);
            // Wait for CELLULAR_NETWORK_RESTORE_AFTER_WIFI_INTERNET_LOST_TIMEOUT_MS,
            // before checking if device now has the active network as cell network.
            mMainHandler.postDelayed(() -> {
                stopTimerCountdownDisplay();
                // Check if device has fallen back to cellular network when it loses internet access
                // in the wifi network.
                if (isExpectedTransportForActiveNetwork(TRANSPORT_CELLULAR)
                        && isNetworkConnected(mWifiNetwork)) {
                    Log.d(TAG, ""PASS test as device has connectivity"");
                    endTest(true, R.string.multinetwork_status_mobile_restore_success);
                } else {
                    Log.d(TAG, ""Fail test as device didn't have connectivity"");
                    endTest(false, R.string.multinetwork_status_mobile_restore_failed);
                }
            }, CELLULAR_NETWORK_RESTORE_AFTER_WIFI_INTERNET_LOST_TIMEOUT_MS);
        }
    }

    /**
     * Test that device does not lose cellular connectivity when it's connected to an access
     * point with no connectivity using the new API's.
     */
    private class ConnectToWifiWithNoInternetValidator extends MultiNetworkValidator {

        ConnectToWifiWithNoInternetValidator(int description) {
            super(mMultinetworkTestCallback,
                ""no_internet_test"",
                description,
                /* runTestOnLowMemoryDevices = */ true);
        }


        @Override
        void continueWithTest() {
            super.continueWithTest();
            connectToWifi();
        }

        @Override
        void onContinuePreWifiConnect() {
            mTestProgressMessage = R.string.multinetwork_connectivity_test_1_prereq;
            mTestCallback.testProgress(mTestProgressMessage);
            mValidatorState = WAITING_FOR_USER_INPUT;
            requestUserConfirmation();
        }

        void connectToWifi() {
            mTestCallback.testProgress(R.string.multinetwork_connectivity_test_connect_wifi);
            mConnectivityState.connectToWifiNetworkWithNoInternet();
        }

        @Override
        void onWifiNetworkConnected(Network wifiNetwork) {
            super.onWifiNetworkConnected(wifiNetwork);
            if (isConnectedToExpectedWifiNetwork()) {
                startTimerCountdownDisplay(CELLULAR_NETWORK_RESTORE_TIMEOUT_MS / 1000);
                mTestCallback.testProgress(R.string.multinetwork_connectivity_test_progress_2);

                // Wait for CELLULAR_NETWORK_RESTORE_TIMEOUT_MS, before checking if there is still
                // the active network as the cell network.
                mMainHandler.postDelayed(() -> {
                    stopTimerCountdownDisplay();
                    mMainHandler.post(() -> {
                        if (isExpectedTransportForActiveNetwork(TRANSPORT_CELLULAR)
                                && isNetworkConnected(wifiNetwork)) {
                            Log.d(TAG, ""PASS test as device has connectivity"");
                            endTest(true, R.string.multinetwork_status_mobile_restore_success);
                        } else {
                            Log.d(TAG, ""Fail test as device didn't have connectivity"");
                            endTest(false, R.string.multinetwork_status_mobile_restore_failed);
                        }
                    });
                }, CELLULAR_NETWORK_RESTORE_TIMEOUT_MS);
            } else {
                endTest(false, R.string.multinetwork_status_wifi_connect_wrong_ap);
            }
        }
    }

    private interface SetWifiCallback {
        void onComplete(boolean isSuccess);
    }
}"	""	""	"ACTION_MANAGE_OVERLAY_PERMISSION"	""
"2.2.1  Hardware"	"7.1.4.6"	"H-1-2"	"7.1.4.6/H-1-2"	""	"""[7.1.4.6/H-1-2] MUST report conformant values      for the device’s GPU counters following the      [gpu counter trace packet proto](https://android.googlesource.com/platform/external/perfetto/+/refs/heads/master/protos/perfetto/trace/gpu/gpu_counter_event.proto). *    ["""	""	""	"gpu_counter_event.proto GPU android.googlesource.com"	""	""	""	""	""	""	""	""	""	""	""	"android.dumpsys.cts.GfxInfoDumpsysTest"	"testGfxinfoFramestats"	"CtsDumpsysHostTestCases"	""	""	""	"/home/gpoor/cts-12-source/cts/hostsidetests/dumpsys/src/android/dumpsys/cts/GfxInfoDumpsysTest.java"	""	"public void testGfxinfoFramestats() throws Exception {
        final String MARKER = ""---PROFILEDATA---"";

        try {
            // cleanup test apps that might be installed from previous partial test run
            getDevice().uninstallPackage(TEST_PKG);

            // install the test app
            CompatibilityBuildHelper buildHelper = new CompatibilityBuildHelper(mCtsBuild);
            File testAppFile = buildHelper.getTestFile(TEST_APK);
            String installResult = getDevice().installPackage(testAppFile, false);
            assertNull(
                    String.format(""failed to install atrace test app. Reason: %s"", installResult),
                    installResult);

            getDevice().executeShellCommand(""am start -W "" + TEST_PKG);

            String frameinfo = mDevice.executeShellCommand(""dumpsys gfxinfo "" +
                    TEST_PKG + "" framestats"");
            assertNotNull(frameinfo);
            assertTrue(frameinfo.length() > 0);
            int profileStart = frameinfo.indexOf(MARKER);
            int profileEnd = frameinfo.indexOf(MARKER, profileStart + 1);
            assertTrue(profileStart >= 0);
            assertTrue(profileEnd > profileStart);
            String profileData = frameinfo.substring(profileStart + MARKER.length(), profileEnd);
            assertTrue(profileData.length() > 0);
            validateProfileData(profileData);
        } finally {
            getDevice().uninstallPackage(TEST_PKG);
        }
    }

    private void validateProfileData(String profileData) throws IOException {
        final int TIMESTAMP_COUNT = 22;
        boolean foundAtLeastOneRow = false;
        try (BufferedReader reader = new BufferedReader(
                new StringReader(profileData))) {
            String line;
            // First line needs to be the headers
            while ((line = reader.readLine()) != null && line.isEmpty()) {}

            assertNotNull(line);
            assertTrue(""First line was not the expected header: "" + line,
                    line.startsWith(""Flags,FrameTimelineVsyncId,IntendedVsync,Vsync""
                            + "",InputEventId,HandleInputStart,AnimationStart,PerformTraversalsStart""
                            + "",DrawStart,FrameDeadline,FrameInterval,FrameStartTime""
                            + "",SyncQueued,SyncStart,IssueDrawCommandsStart,SwapBuffers""
                            + "",FrameCompleted,DequeueBufferDuration,QueueBufferDuration""
                            + "",GpuCompleted,SwapBuffersCompleted,DisplayPresentTime""));

            long[] numparts = new long[TIMESTAMP_COUNT];
            while ((line = reader.readLine()) != null && !line.isEmpty()) {

                String[] parts = line.split("","");
                assertTrue(parts.length >= TIMESTAMP_COUNT);
                for (int i = 0; i < TIMESTAMP_COUNT; i++) {
                    numparts[i] = assertInteger(parts[i]);
                }

                final long flags = numparts[0];
                // Flags = 1 just means the first frame of the window
                if (flags != 0 && flags != 1) {
                    continue;
                }

                final long timestampIntendedVsync = numparts[2];
                final long timestampVsync = numparts[3];
                // skip InputEventId, since it's a randomly assigned id
                final long timestampHandleInputStart = numparts[5];
                final long timestampAnimationStart = numparts[6];
                final long timestampPerformTraversalsStart = numparts[7];
                final long timestampDrawStart = numparts[8];
                // skip FrameDeadline, FrameInterval,FrameStartTime
                final long timestampSyncQueued = numparts[12];
                final long timestampSyncStart = numparts[13];
                final long timestampIssueDrawCommandsStart = numparts[14];
                final long timestampSwapBuffers = numparts[15];
                final long timestampFrameCompleted = numparts[16];

                // assert time is flowing forwards. we need to check each entry explicitly
                // as some entries do not represent a flow of events.
                assertTrue(""VSYNC happened before INTENDED_VSYNC"",
                        timestampVsync >= timestampIntendedVsync);
                assertTrue(""HandleInputStart happened before VSYNC"",
                        timestampHandleInputStart >= timestampVsync);
                assertTrue(""AnimationStart happened before HandleInputStart"",
                        timestampAnimationStart >= timestampHandleInputStart);
                assertTrue(""PerformTraversalsStart happened before AnimationStart"",
                        timestampPerformTraversalsStart >= timestampAnimationStart);
                assertTrue(""DrawStart happened before PerformTraversalsStart"",
                        timestampDrawStart >= timestampPerformTraversalsStart);
                assertTrue(""SyncQueued happened before DrawStart"",
                        timestampSyncQueued >= timestampDrawStart);
                assertTrue(""SyncStart happened before SyncQueued"",
                        timestampSyncStart >= timestampSyncQueued);
                assertTrue(""IssueDrawCommandsStart happened before SyncStart"",
                        timestampIssueDrawCommandsStart >= timestampSyncStart);
                assertTrue(""SwapBuffers happened before IssueDrawCommandsStart"",
                        timestampSwapBuffers >= timestampIssueDrawCommandsStart);
                assertTrue(""FrameCompleted happened before SwapBuffers"",
                        timestampFrameCompleted >= timestampSwapBuffers);

                // total duration is from IntendedVsync to FrameCompleted
                long totalDuration = timestampFrameCompleted - timestampIntendedVsync;
                assertTrue(""Frame did not take a positive amount of time to process"",
                        totalDuration > 0);
                assertTrue(""Bogus frame duration, exceeds 100 seconds"",
                        totalDuration < TimeUnit.SECONDS.toNanos(100));
                foundAtLeastOneRow = true;
            }
        }
        assertTrue(foundAtLeastOneRow);
    }
}"	""	""	"GPU"	""
"7.3.10  Biometric Sensors"	"7.3.10"	"C-3-4"	"7.3.10/C-3-4"	""	"""C-3-4] MUST challenge the user for the recommended primary     authentication (e.g. PIN, pattern, password) once every 72 hours     or less.  """	""	""	"PIN"	""	""	""	""	""	""	""	""	""	""	""	"android.media.cts.bitstreams.MediaBitstreamsTest"	"testBitstreamsConformance"	"CtsMediaBitstreamsTestCases"	""	""	""	"/home/gpoor/cts-12-source/cts/hostsidetests/media/bitstreams/src/android/media/cts/bitstreams/MediaBitstreamsTest.java"	""	"public void testBitstreamsConformance() {
        File bitstreamFile = new File(mHostBitstreamsPath, mPath);
        if (!bitstreamFile.exists()) {
            // todo(b/65165250): throw Exception once MediaPreparer can auto-download
            CLog.w(bitstreamFile + "" not found; skipping"");
            return;
        }

        if (!mResults.containsKey(mPath)) {
            try {
                testBitstreamsConformance(mPrefix);
            } catch (DeviceNotAvailableException | IOException e) {
                String curMethod = getCurrentMethod();
                addConformanceEntry(curMethod, mPath, MediaBitstreams.K_UNAVAILABLE, e.toString());
            }
        }

        if (mEnforce) {
            if (!mResults.containsKey(mPath)) {
                Assert.fail(""no results captured for "" + mPath);
            }
            List<ConformanceEntry> entries = mResults.get(mPath);
            for (ConformanceEntry ce : entries) {
                if (!""true"".equals(ce.mStatus) && !""unsupported"".equals(ce.mStatus)) {
                    Assert.fail(ce.toString());
                }
            }
        }

    }

    private void testBitstreamsConformance(String prefix)
            throws DeviceNotAvailableException, IOException {

        ITestDevice device = getDevice();
        SupportedBitstreamsProcessor preparer;
        preparer = new SupportedBitstreamsProcessor(prefix, mDebugTargetDevice);
        preparer.processDeviceReport(
                getTestInformation(),
                device,
                MediaBitstreams.K_TEST_GET_SUPPORTED_BITSTREAMS,
                MediaBitstreams.KEY_SUPPORTED_BITSTREAMS_TXT);
        Collection<Object[]> bitstreams = bitstreams(mPrefix, mPackageToRun);
        Set<String> supportedBitstreams = preparer.getSupportedBitstreams();
        CLog.i(""%d supported bitstreams under %s"", supportedBitstreams.size(), prefix);

        int n = 0;
        long size = 0;
        long limit = device.getExternalStoreFreeSpace() * mUtilizationRate * 1024 / 100;

        String curMethod = getCurrentMethod();
        Set<String> toPush = new LinkedHashSet<>();
        Iterator<Object[]> iter = bitstreams.iterator();

        for (int i = 0; i < bitstreams.size(); i++) {

            if (n >= mNumBatches) {
                break;
            }

            String p = (String) iter.next()[1];
            Map<String, Boolean> decoderCapabilities;
            decoderCapabilities = preparer.getDecoderCapabilitiesForPath(p);
            if (decoderCapabilities.isEmpty()) {
                addConformanceEntry(
                        curMethod, p,
                        MediaBitstreams.K_UNAVAILABLE,
                        MediaBitstreams.K_UNSUPPORTED);
            }
            for (Entry<String, Boolean> entry : decoderCapabilities.entrySet()) {
                Boolean supported = entry.getValue();
                if (supported) {
                    File bitstreamFile = new File(mHostBitstreamsPath, p);
                    String md5Path = MediaBitstreams.getMd5Path(p);
                    File md5File = new File(mHostBitstreamsPath, md5Path);
                    if (md5File.exists() && bitstreamFile.exists() && toPush.add(p)) {
                        size += md5File.length();
                        size += bitstreamFile.length();
                    }
                } else {
                    String d = entry.getKey();
                    addConformanceEntry(curMethod, p, d, MediaBitstreams.K_UNSUPPORTED);
                }
            }

            if (size > limit || i + 1 == bitstreams.size()) {
                ReportProcessor processor;
                processor = new ProcessBitstreamsValidation(toPush, curMethod);
                processor.processDeviceReport(
                        getTestInformation(),
                        device,
                        curMethod,
                        MediaBitstreams.KEY_BITSTREAMS_VALIDATION_TXT);
                toPush.clear();
                size = 0;
                n++;
            }

        }

    }


}"	""	""	"PIN"	""
"6.1  Developer Tools"	"6.1"	"C-5-1"	"6.1/C-5-1"	""	"""C-5-1] MUST have the `AdbManager#isAdbWifiQrSupported()` method      return `true`.  """	""	""	"isAdbWifiQrSupported()"	""	""	""	""	""	""	""	""	""	""	""	"android.adbmanager.cts.AdbManagerHostDeviceTest"	"test_isadbWifiQrSupported"	"CtsAdbManagerHostTestCases"	""	""	""	"/home/gpoor/cts-12-source/cts/hostsidetests/adbmanager/src/android/adbmanager/cts/AdbManagerHostDeviceTest.java"	""	"@CddTest(requirement=""6.1/C-1-2"")
    public void test_isadbWifiQrSupported() throws Exception {
        boolean expected = hasFeature(FEATURE_WIFI) && hasFeature(FEATURE_CAMERA_ANY);

        CommandResult result = getDevice().executeShellV2Command(""cmd adb is-wifi-qr-supported"");

        Assert.assertTrue(new Integer(0).equals(result.getExitCode()));
        Assert.assertEquals(expected, Boolean.parseBoolean(result.getStdout().trim()));
    }
}"	""	""	"isAdbWifiQrSupported()"	""
"3.2.3.5  Conditional Application Intents"	"3.2.3.5"	"C-8-1"	"3.2.3.5/C-8-1"	""	"""C-8-1] MUST honor the [`android.settings.ACCESSIBILITY_SETTINGS`](https://developer.android.com/reference/android/provider/Settings#ACTION_ACCESSIBILITY_SETTINGS) intent to provide a user-accessible mechanism to enable and disable the third-party accessibility services alongside the preloaded accessibility services.  If device implementations include support for Wi-Fi Easy Connect and expose the functionality to third-party apps, they:  """	""	""	"ACTION_ACCESSIBILITY_SETTINGS android.settings.ACCESSIBILITY ACCESSIBILITY_SETTINGS"	""	""	""	""	""	""	""	""	""	""	""	"android.accessibilityservice.cts.AccessibilitySettingsTest"	"testAccessibilitySettingsIntentHandled"	"CtsAccessibilityServiceTestCases"	""	""	""	"/home/gpoor/cts-12-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilitySettingsTest.java"	""	"public void testAccessibilitySettingsIntentHandled() throws Throwable {
        PackageManager packageManager = getContext().getPackageManager();
        Intent intent = new Intent(Settings.ACTION_ACCESSIBILITY_SETTINGS);
        List<ResolveInfo> resolvedActivities = packageManager.queryIntentActivities(intent,
                PackageManager.MATCH_DEFAULT_ONLY);

        // make sure accessibility settings exist
        String message = ""Accessibility settings activity must be launched via Intent "" +
                ""Settings.ACTION_ACCESSIBILITY_SETTINGS"";
        assertTrue(message, !resolvedActivities.isEmpty());
    }
}"	""	""	"ACCESSIBILITY_SETTINGS"	""
"2.2.1  Hardware"	"7.1.4.6"	"H-1-1"	"7.1.4.6/H-1-1"	""	"""[7.1.4.6/H-1-1] MUST report as output a      protobuf trace that complies with the schema for GPU counters and GPU      renderstages defined in the [Perfetto documentation](https://developer.android.com/studio/command-line/perfetto). *    ["""	""	""	"GPU"	""	""	""	""	""	""	""	""	""	""	""	"android.dumpsys.cts.GfxInfoDumpsysTest"	"testGfxinfoFramestats"	"CtsDumpsysHostTestCases"	""	""	""	"/home/gpoor/cts-12-source/cts/hostsidetests/dumpsys/src/android/dumpsys/cts/GfxInfoDumpsysTest.java"	""	"public void testGfxinfoFramestats() throws Exception {
        final String MARKER = ""---PROFILEDATA---"";

        try {
            // cleanup test apps that might be installed from previous partial test run
            getDevice().uninstallPackage(TEST_PKG);

            // install the test app
            CompatibilityBuildHelper buildHelper = new CompatibilityBuildHelper(mCtsBuild);
            File testAppFile = buildHelper.getTestFile(TEST_APK);
            String installResult = getDevice().installPackage(testAppFile, false);
            assertNull(
                    String.format(""failed to install atrace test app. Reason: %s"", installResult),
                    installResult);

            getDevice().executeShellCommand(""am start -W "" + TEST_PKG);

            String frameinfo = mDevice.executeShellCommand(""dumpsys gfxinfo "" +
                    TEST_PKG + "" framestats"");
            assertNotNull(frameinfo);
            assertTrue(frameinfo.length() > 0);
            int profileStart = frameinfo.indexOf(MARKER);
            int profileEnd = frameinfo.indexOf(MARKER, profileStart + 1);
            assertTrue(profileStart >= 0);
            assertTrue(profileEnd > profileStart);
            String profileData = frameinfo.substring(profileStart + MARKER.length(), profileEnd);
            assertTrue(profileData.length() > 0);
            validateProfileData(profileData);
        } finally {
            getDevice().uninstallPackage(TEST_PKG);
        }
    }

    private void validateProfileData(String profileData) throws IOException {
        final int TIMESTAMP_COUNT = 22;
        boolean foundAtLeastOneRow = false;
        try (BufferedReader reader = new BufferedReader(
                new StringReader(profileData))) {
            String line;
            // First line needs to be the headers
            while ((line = reader.readLine()) != null && line.isEmpty()) {}

            assertNotNull(line);
            assertTrue(""First line was not the expected header: "" + line,
                    line.startsWith(""Flags,FrameTimelineVsyncId,IntendedVsync,Vsync""
                            + "",InputEventId,HandleInputStart,AnimationStart,PerformTraversalsStart""
                            + "",DrawStart,FrameDeadline,FrameInterval,FrameStartTime""
                            + "",SyncQueued,SyncStart,IssueDrawCommandsStart,SwapBuffers""
                            + "",FrameCompleted,DequeueBufferDuration,QueueBufferDuration""
                            + "",GpuCompleted,SwapBuffersCompleted,DisplayPresentTime""));

            long[] numparts = new long[TIMESTAMP_COUNT];
            while ((line = reader.readLine()) != null && !line.isEmpty()) {

                String[] parts = line.split("","");
                assertTrue(parts.length >= TIMESTAMP_COUNT);
                for (int i = 0; i < TIMESTAMP_COUNT; i++) {
                    numparts[i] = assertInteger(parts[i]);
                }

                final long flags = numparts[0];
                // Flags = 1 just means the first frame of the window
                if (flags != 0 && flags != 1) {
                    continue;
                }

                final long timestampIntendedVsync = numparts[2];
                final long timestampVsync = numparts[3];
                // skip InputEventId, since it's a randomly assigned id
                final long timestampHandleInputStart = numparts[5];
                final long timestampAnimationStart = numparts[6];
                final long timestampPerformTraversalsStart = numparts[7];
                final long timestampDrawStart = numparts[8];
                // skip FrameDeadline, FrameInterval,FrameStartTime
                final long timestampSyncQueued = numparts[12];
                final long timestampSyncStart = numparts[13];
                final long timestampIssueDrawCommandsStart = numparts[14];
                final long timestampSwapBuffers = numparts[15];
                final long timestampFrameCompleted = numparts[16];

                // assert time is flowing forwards. we need to check each entry explicitly
                // as some entries do not represent a flow of events.
                assertTrue(""VSYNC happened before INTENDED_VSYNC"",
                        timestampVsync >= timestampIntendedVsync);
                assertTrue(""HandleInputStart happened before VSYNC"",
                        timestampHandleInputStart >= timestampVsync);
                assertTrue(""AnimationStart happened before HandleInputStart"",
                        timestampAnimationStart >= timestampHandleInputStart);
                assertTrue(""PerformTraversalsStart happened before AnimationStart"",
                        timestampPerformTraversalsStart >= timestampAnimationStart);
                assertTrue(""DrawStart happened before PerformTraversalsStart"",
                        timestampDrawStart >= timestampPerformTraversalsStart);
                assertTrue(""SyncQueued happened before DrawStart"",
                        timestampSyncQueued >= timestampDrawStart);
                assertTrue(""SyncStart happened before SyncQueued"",
                        timestampSyncStart >= timestampSyncQueued);
                assertTrue(""IssueDrawCommandsStart happened before SyncStart"",
                        timestampIssueDrawCommandsStart >= timestampSyncStart);
                assertTrue(""SwapBuffers happened before IssueDrawCommandsStart"",
                        timestampSwapBuffers >= timestampIssueDrawCommandsStart);
                assertTrue(""FrameCompleted happened before SwapBuffers"",
                        timestampFrameCompleted >= timestampSwapBuffers);

                // total duration is from IntendedVsync to FrameCompleted
                long totalDuration = timestampFrameCompleted - timestampIntendedVsync;
                assertTrue(""Frame did not take a positive amount of time to process"",
                        totalDuration > 0);
                assertTrue(""Bogus frame duration, exceeds 100 seconds"",
                        totalDuration < TimeUnit.SECONDS.toNanos(100));
                foundAtLeastOneRow = true;
            }
        }
        assertTrue(foundAtLeastOneRow);
    }
}"	""	""	"GPU"	""
"7.1.1.1  Screen Size and Shape"	"7.1.1.1"	"C-2-1"	"7.1.1.1/C-2-1"	""	"""C-2-1] MUST implement the latest available stable version of the [extensions API]( https://developer.android.com/jetpack/androidx/releases/window-extensions) or the stable version of [sidecar API]( https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:window/window-sidecar/api/) to be used by [Window Manager Jetpack]( https://developer.android.com/jetpack/androidx/releases/window) library.  If device implementations include an Android-compatible display(s) that is foldable, or includes a folding hinge between multiple display panels and if the hinge or fold crosses a fullscreen application window, they:  """	""	""	"cs.android.com display(s)"	""	""	""	""	""	""	""	""	""	""	""	"android.jvmti.cts.JvmtiHostTest"	"getCurrentUser"	""	""	""	""	"/home/gpoor/cts-12-source/cts/hostsidetests/jvmti/base/host/src/android/jvmti/cts/JvmtiHostTest.java"	""	"public void test/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License""); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package android.jvmti.cts;

import com.android.compatibility.common.tradefed.build.CompatibilityBuildHelper;
import com.android.ddmlib.testrunner.RemoteAndroidTestRunner;
import com.android.tradefed.build.IBuildInfo;
import com.android.tradefed.config.Option;
import com.android.tradefed.device.ITestDevice;
import com.android.tradefed.log.LogUtil.CLog;
import com.android.tradefed.result.ITestLifeCycleReceiver;
import com.android.tradefed.result.TestDescription;
import com.android.tradefed.testtype.DeviceTestCase;
import com.android.tradefed.testtype.IAbi;
import com.android.tradefed.testtype.IAbiReceiver;
import com.android.tradefed.testtype.IBuildReceiver;
import com.android.tradefed.util.AbiUtils;
import com.android.tradefed.util.FileUtil;
import com.android.tradefed.util.ZipUtil;

import java.io.File;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.TimeUnit;
import java.util.zip.ZipFile;

/**
 * Test a JVMTI device test.
 *
 * Reads the configuration (APK and package name) out of the embedded config.properties file. Runs
 * the agent (expected to be packaged with the APK) into the app's /data/data directory, starts a
 * test run and attaches the agent.
 */
public class JvmtiHostTest extends DeviceTestCase implements IBuildReceiver, IAbiReceiver {
    private static final String RUNNER = ""androidx.test.runner.AndroidJUnitRunner"";
    // inject these options from HostTest directly using --set-option <option name>:<option value>
    @Option(name = ""package-name"",
            description = ""The package name of the device test"",
            mandatory = true)
    private String mTestPackageName = null;

    @Option(name = ""test-file-name"",
            description = ""the name of a test zip file to install on device."",
            mandatory = true)
    private String mTestApk = null;

    @Option(name = ""hidden-api-checks"",
            description = ""If we should enable hidden api checks. Default 'true'. Set to 'false' "" +
            ""to disable hiddenapi."",
            mandatory = false)
    private String mHiddenApiChecksEnabled = null;

    private CompatibilityBuildHelper mBuildHelper;
    private IAbi mAbi;
    private int mCurrentUser;

    @Override
    public void setBuild(IBuildInfo arg0) {
        mBuildHelper = new CompatibilityBuildHelper(arg0);
    }

    @Override
    public void setAbi(IAbi arg0) {
        mAbi = arg0;
    }

    // Constant returned to indicate get-current-user failed. See comment at/near
    // https://cs.android.com/android/_/android/platform/tools/tradefederation/+/android11-release:device_build_interfaces/com/android/tradefed/device/ITestDevice.java;l=780
    private static final int GET_USER_FAILURE = -10000;

    // Try getting current user and throw an exception immediately if we fail.
    @Override
    protected void setUp() throws Exception {
        mCurrentUser = getDevice().getCurrentUser();
        if (mCurrentUser == GET_USER_FAILURE) {
            throw new RuntimeException(""am get-current-user failed!"");
        }
    }"	""	""	"cs.android.com"	""
"7.3.10  Biometric Sensors"	"7.3.10"	"C-6-2"	"7.3.10/C-6-2"	""	"""C-6-2] MUST present only **Class 3** biometrics when the authentication     requires [BIOMETRIC_STRONG](https://developer.android.com/reference/android/hardware/biometrics/BiometricManager.Authenticators#BIOMETRIC_STRONG),     or the authentication is invoked with a     [CryptoObject](https://developer.android.com/reference/android/hardware/biometrics/BiometricPrompt.CryptoObject).  If device implementations wish to treat a biometric sensor as **Class 1** (formerly **Convenience**), they:  """	""	""	"BIOMETRIC_STRONG BiometricManager.Authenticators BiometricPrompt.CryptoObject"	""	""	""	""	""	""	""	""	""	""	""	"android.hardware.biometrics.cts.BiometricPromptTest"	"onAuthenticationFailed"	"CtsHardwareTestCases"	""	""	""	"/home/gpoor/cts-12-source/cts/tests/tests/hardware/src/android/hardware/biometrics/cts/BiometricPromptTest.java"	""	"public void test/*
 *
 */

package android.hardware.biometrics.cts;

import android.content.pm.PackageManager;
import android.hardware.biometrics.BiometricManager.Authenticators;
import android.hardware.biometrics.BiometricPrompt;
import android.os.CancellationSignal;
import android.os.Handler;
import android.os.Looper;
import android.platform.test.annotations.Presubmit;
import android.test.AndroidTestCase;
import android.text.TextUtils;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executor;
import java.util.concurrent.TimeUnit;

/**
 * Basic test cases for BiometricPrompt
 */
public class BiometricPromptTest extends AndroidTestCase {

    private static final int AWAIT_TIMEOUT_MS = 3000;

    private final Handler mHandler = new Handler(Looper.getMainLooper());
    private final CountDownLatch mLatch = new CountDownLatch(1);

    private int mErrorReceived;

    private final Executor mExecutor = runnable -> mHandler.post(runnable);

    private final BiometricPrompt.AuthenticationCallback mAuthenticationCallback
            = new BiometricPrompt.AuthenticationCallback() {
        @Override
        public void onAuthenticationError(int errorCode, CharSequence errString) {
            mErrorReceived = errorCode;
            mLatch.countDown();
        }

        @Override
        public void onAuthenticationHelp(int helpCode, CharSequence helpString) {}

        @Override
        public void onAuthenticationFailed() {}

        @Override
        public void onAuthenticationSucceeded(BiometricPrompt.AuthenticationResult result) {}
    };

    /**
     * Test that we can try to start fingerprint authentication. It won't actually start since
     * there are no fingers enrolled. Cts-verifier will check the implementation.
     */
    @Presubmit"	""	""	"BiometricManager.Authenticators"	""
"7.4.5.2  IPv6"	"7.4.5.2"	"C-0-6"	"7.4.5.2/C-0-6"	""	"""C-0-6] MUST provide third-party applications with direct IPv6 connectivity to the network when connected to an IPv6 network, without any form of address or port translation happening locally on the device. Both managed APIs such as [`Socket#getLocalAddress`]( https://developer.android.com/reference/java/net/Socket.html#getLocalAddress%28%29) or [`Socket#getLocalPort`]( https://developer.android.com/reference/java/net/Socket.html#getLocalPort%28%29)) and NDK APIs such as `getsockname()` or `IPV6_PKTINFO` MUST return the IP address and port that is actually used to send and receive packets on the network and is visible as the source ip and port to internet (web) servers.   The required level of IPv6 support depends on the network type, as shown in the following requirements.  If device implementations support Wi-Fi, they:  """	""	""	"NDK Socket.html getsockname() IPV6_PKTINFO"	""	""	""	""	""	""	""	""	""	""	""	"android.widget.cts.TextViewTest"	"testAccessTransformationMethod"	"CtsWidgetTestCases"	""	""	""	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	"public void testAccessTransformationMethod() throws Throwable {
        // check the password attribute in xml
        mTextView = findTextView(R.id.textview_password);
        assertNotNull(mTextView);
        assertSame(PasswordTransformationMethod.getInstance(),
                mTextView.getTransformationMethod());

        // check the singleLine attribute in xml
        mTextView = findTextView(R.id.textview_singleLine);
        assertNotNull(mTextView);
        assertSame(SingleLineTransformationMethod.getInstance(),
                mTextView.getTransformationMethod());

        final QwertyKeyListener qwertyKeyListener = QwertyKeyListener.getInstance(false,
                Capitalize.NONE);
        final TransformationMethod method = PasswordTransformationMethod.getInstance();
        // change transformation method by function
        mActivityRule.runOnUiThread(() -> {
            mTextView.setKeyListener(qwertyKeyListener);
            mTextView.setTransformationMethod(method);
            mTransformedText = method.getTransformation(mTextView.getText(), mTextView);

            mTextView.requestFocus();
        });
        mInstrumentation.waitForIdleSync();
        assertSame(PasswordTransformationMethod.getInstance(),
                mTextView.getTransformationMethod());

        CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, ""H E 2*L O"");
        mActivityRule.runOnUiThread(() -> mTextView.append("" ""));
        mInstrumentation.waitForIdleSync();

        // It will get transformed after a while
        // We're waiting for transformation to ""******""
        PollingCheck.waitFor(TIMEOUT, () -> mTransformedText.toString()
                .equals(""\u2022\u2022\u2022\u2022\u2022\u2022""));

        // set null
        mActivityRule.runOnUiThread(() -> mTextView.setTransformationMethod(null));
        mInstrumentation.waitForIdleSync();
        assertNull(mTextView.getTransformationMethod());
    }

    @UiThreadTest"	""	""	"NDK"	""
"9.11.3  Identity Credential"	"9.11.3"	"C-0-4"	"9.11.3/C-0-4"	""	"""C-0-4] The trusted application MUST be implemented in a way such that its      security properties  are not affected (e.g. credential data is not released unless access      control conditions are satisfied, MACs can't be produced for arbitrary      data) even if Android is misbehaving or compromised. """	""	""	"MAC"	""	""	""	""	""	""	""	""	""	""	""	"android.suspendapps.cts.DualSuspendTests"	"testCannotSuspendUnderDisallowUninstallApps"	"CtsSuspendAppsTestCases"	""	""	""	"/home/gpoor/cts-12-source/cts/tests/suspendapps/tests/src/android/suspendapps/cts/DualSuspendTests.java"	""	"public void testCannotSuspendUnderDisallowUninstallApps() throws Exception {
        assertCannotSuspendUnderUserRestriction(DISALLOW_UNINSTALL_APPS);
    }

    @After
    public void tearDown() throws Exception {
        if (mTestAppInterface != null) {
            mTestAppInterface.disconnect();
        }
        final DevicePolicyManager dpm = mContext.getSystemService(DevicePolicyManager.class);
        if (dpm.isAdminActive(ComponentName.unflattenFromString(DEVICE_ADMIN_COMPONENT))) {
            setSuspendViaDpm(false);
            final Bundle extras = createSingleKeyBundle(EXTRA_PACKAGE_NAME, TEST_APP_PACKAGE_NAME);
            requestDpmAction(ACTION_UNBLOCK_UNINSTALL, extras, mReceiverHandler);
        }
        removeDeviceAdmin();
        SuspendTestUtils.unsuspendAll();
    }
}"	""	""	"MAC"	""
"3.18  Contacts"	"3.18"	"C-1-5"	"3.18/C-1-5"	""	"""C-1-5] Delete operations performed against the **custom local account**      MUST result in raw contacts being purged immediately (as if the      [`CALLER_IS_SYNCADAPTER`](https://developer.android.com/reference/android/provider/ContactsContract.html#CALLER_IS_SYNCADAPTER)      param was set to true), even if the `CALLER\_IS\_SYNCADAPTER` param was set      to false or not specified."""	""	""	"CALLER_IS_SYNCADAPTER ContactsContract.html CALLER SYNCADAPTER"	""	""	""	""	""	""	""	""	""	""	""	"android.provider.cts.calendar.CalendarTest"	"testMutatorSetCorrectly"	"CtsCalendarProviderTestCases"	""	""	""	"/home/gpoor/cts-12-source/cts/tests/tests/calendarprovider/src/android/provider/cts/calendar/CalendarTest.java"	""	"public void testMutatorSetCorrectly() {
        String account = ""ec_account"";
        String packageName = ""android.provider.cts.calendar"";
        int seed = 0;

        // Clean up just in case
        CalendarHelper.deleteCalendarByAccount(mContentResolver, account);

        String mutator;
        Cursor cursor;
        ContentValues values = new ContentValues();
        final long calendarId = createAndVerifyCalendar(account, seed++, null);

        // Verify mutator is set to the package, via:
        // Create:
        final long eventId = createAndVerifyEvent(account, seed, calendarId, false, null);
        final Uri uri = ContentUris.withAppendedId(Events.CONTENT_URI, eventId);
        cursor = mContentResolver.query(uri, new String[] {Events.MUTATORS}, null, null, null);
        cursor.moveToFirst();
        mutator = cursor.getString(0);
        cursor.close();
        assertEquals(packageName, mutator);

        // Edit:
        // First clear the mutator column
        values.clear();
        values.putNull(Events.MUTATORS);
        mContentResolver.update(asSyncAdapter(uri, account, CTS_TEST_TYPE), values, null, null);
        cursor = mContentResolver.query(uri, new String[] {Events.MUTATORS}, null, null, null);
        cursor.moveToFirst();
        mutator = cursor.getString(0);
        cursor.close();
        assertNull(mutator);
        // Now edit the event and verify the mutator column
        values.clear();
        values.put(Events.TITLE, ""New title"");
        mContentResolver.update(uri, values, null, null);
        cursor = mContentResolver.query(uri, new String[] {Events.MUTATORS}, null, null, null);
        cursor.moveToFirst();
        mutator = cursor.getString(0);
        cursor.close();
        assertEquals(packageName, mutator);

        // Clean up the event
        assertEquals(1, EventHelper.deleteEventAsSyncAdapter(mContentResolver, uri, account));

        // Delete:
        // First create as sync adapter
        final long eventId2 = createAndVerifyEvent(account, seed, calendarId, true, null);
        final Uri uri2 = ContentUris.withAppendedId(Events.CONTENT_URI, eventId2);
        // Now delete the event and verify
        values.clear();
        values.put(Events.MUTATORS, packageName);
        removeAndVerifyEvent(uri2, values, account);


        // delete the calendar
        removeAndVerifyCalendar(account, calendarId);
    }

    /**
     * Acquires the set of instances that appear between the specified start and end points.
     *
     * @param timeZone Time zone to use when parsing startWhen and endWhen
     * @param startWhen Start date/time, in RFC 3339 format
     * @param endWhen End date/time, in RFC 3339 format
     * @param projection Array of desired column names
     * @return Cursor with instances (caller should close when done)
     */
    private Cursor getInstances(String timeZone, String startWhen, String endWhen,
            String[] projection, long[] calendarIds) {
        Time startTime = new Time(timeZone);
        startTime.parse3339(startWhen);
        long startMillis = startTime.toMillis(false);

        Time endTime = new Time(timeZone);
        endTime.parse3339(endWhen);
        long endMillis = endTime.toMillis(false);

        // We want a list of instances that occur between the specified dates.  Use the
        // ""instances/when"" URI.
        Uri uri = Uri.withAppendedPath(CalendarContract.Instances.CONTENT_URI,
                startMillis + ""/"" + endMillis);

        String where = null;
        for (int i = 0; i < calendarIds.length; i++) {
            if (i > 0) {
                where += "" OR "";
            } else {
                where = """";
            }
            where += (Instances.CALENDAR_ID + ""="" + calendarIds[i]);
        }
        Cursor instances = mContentResolver.query(uri, projection, where, null,
                projection[0] + "" ASC"");

        return instances;
    }

    /**
     * Acquires the set of instances that appear between the specified start and end points
     * that match the search terms.
     *
     * @param timeZone Time zone to use when parsing startWhen and endWhen
     * @param startWhen Start date/time, in RFC 3339 format
     * @param endWhen End date/time, in RFC 3339 format
     * @param search A collection of tokens to search for.  The columns searched are
     *   hard-coded in the provider (currently title, description, location, attendee
     *   name, attendee email).
     * @param searchByDay If set, adjust start/end to calendar day boundaries.
     * @param projection Array of desired column names
     * @return Cursor with instances (caller should close when done)
     */
    private Cursor getInstancesSearch(String timeZone, String startWhen, String endWhen,
            String search, boolean searchByDay, String[] projection, long[] calendarIds) {
        Time startTime = new Time(timeZone);
        startTime.parse3339(startWhen);
        long startMillis = startTime.toMillis(false);

        Time endTime = new Time(timeZone);
        endTime.parse3339(endWhen);
        long endMillis = endTime.toMillis(false);

        Uri uri;
        if (searchByDay) {
            // start/end are Julian day numbers rather than time in milliseconds
            int julianStart = Time.getJulianDay(startMillis, startTime.gmtoff);
            int julianEnd = Time.getJulianDay(endMillis, endTime.gmtoff);
            uri = Uri.withAppendedPath(CalendarContract.Instances.CONTENT_SEARCH_BY_DAY_URI,
                    julianStart + ""/"" + julianEnd + ""/"" + search);
        } else {
            uri = Uri.withAppendedPath(CalendarContract.Instances.CONTENT_SEARCH_URI,
                    startMillis + ""/"" + endMillis + ""/"" + search);
        }

        String where = null;
        for (int i = 0; i < calendarIds.length; i++) {
            if (i > 0) {
                where += "" OR "";
            } else {
                where = """";
            }
            where += (Instances.CALENDAR_ID + ""="" + calendarIds[i]);
        }
        // We want a list of instances that occur between the specified dates and that match
        // the search terms.

        Cursor instances = mContentResolver.query(uri, projection, where, null,
                projection[0] + "" ASC"");

        return instances;
    }

    /** debug -- dump instances cursor */
    private static void dumpInstances(Cursor instances, String timeZone, String msg) {
        Log.d(TAG, ""Instances ("" + msg + "")"");

        int posn = instances.getPosition();
        instances.moveToPosition(-1);

        //Log.d(TAG, ""+++ instances has "" + instances.getCount() + "" rows, "" +
        //        instances.getColumnCount() + "" columns"");
        while (instances.moveToNext()) {
            long beginMil = instances.getLong(0);
            Time beginT = new Time(timeZone);
            beginT.set(beginMil);
            String logMsg = ""--> begin="" + beginT.format3339(false) + "" ("" + beginMil + "")"";
            for (int i = 2; i < instances.getColumnCount(); i++) {
                logMsg += "" ["" + instances.getString(i) + ""]"";
            }
            Log.d(TAG, logMsg);
        }
        instances.moveToPosition(posn);
    }


    /**
     * Counts the number of instances that appear between the specified start and end times.
     */
    private int getInstanceCount(String timeZone, String startWhen, String endWhen,
                long[] calendarIds) {
        Cursor instances = getInstances(timeZone, startWhen, endWhen,
                new String[] { Instances._ID }, calendarIds);
        int count = instances.getCount();
        instances.close();
        return count;
    }

    /**
     * Deletes an event as app and sync adapter which removes it from the db and
     * verifies after each.
     *
     * @param eventUri The uri for the event to delete
     * @param accountName TODO
     */
    private void removeAndVerifyEvent(Uri eventUri, ContentValues eventValues, String accountName) {
        // Delete event
        EventHelper.deleteEvent(mContentResolver, eventUri, eventValues);
        // Verify
        verifyEvent(eventValues, ContentUris.parseId(eventUri));
        // Delete as sync adapter
        assertEquals(1,
                EventHelper.deleteEventAsSyncAdapter(mContentResolver, eventUri, accountName));
        // Verify
        Cursor c = EventHelper.getEventByUri(mContentResolver, eventUri);
        assertEquals(0, c.getCount());
        c.close();
    }

    /**
     * Creates an event on the given calendar and verifies it.
     *
     * @param account
     * @param seed
     * @param calendarId
     * @param asSyncAdapter
     * @param values optional pre created set of values; will have several new entries added
     * @return the _id for the new event
     */
    private long createAndVerifyEvent(String account, int seed, long calendarId,
            boolean asSyncAdapter, ContentValues values) {
        // Create an event
        if (values == null) {
            values = EventHelper.getNewEventValues(account, seed, calendarId, asSyncAdapter);
        }
        Uri insertUri = Events.CONTENT_URI;
        if (asSyncAdapter) {
            insertUri = asSyncAdapter(insertUri, account, CTS_TEST_TYPE);
        }
        Uri uri = mContentResolver.insert(insertUri, values);
        assertNotNull(uri);

        // Verify
        EventHelper.addDefaultReadOnlyValues(values, account, asSyncAdapter);
        long eventId = ContentUris.parseId(uri);
        assertTrue(eventId >= 0);

        verifyEvent(values, eventId);
        return eventId;
    }

    /**
     * Updates an event, and verifies that the updates took.
     */
    private void updateAndVerifyEvent(String account, long calendarId, long eventId,
            boolean asSyncAdapter, ContentValues updateValues) {
        Uri uri = Uri.withAppendedPath(Events.CONTENT_URI, String.valueOf(eventId));
        if (asSyncAdapter) {
            uri = asSyncAdapter(uri, account, CTS_TEST_TYPE);
        }
        int count = mContentResolver.update(uri, updateValues, null, null);

        // Verify
        assertEquals(1, count);
        verifyEvent(updateValues, eventId);
    }

    /**
     * Creates an exception to a recurring event, and verifies it.
     * @param account The account to use.
     * @param originalEventId The ID of the original event.
     * @param values Values for the exception; must include originalInstanceTime.
     * @return The _id for the new event.
     */
    private long createAndVerifyException(String account, long originalEventId,
            ContentValues values, boolean asSyncAdapter) {
        // Create the exception
        Uri uri = Uri.withAppendedPath(Events.CONTENT_EXCEPTION_URI,
                String.valueOf(originalEventId));
        if (asSyncAdapter) {
            uri = asSyncAdapter(uri, account, CTS_TEST_TYPE);
        }
        Uri resultUri = mContentResolver.insert(uri, values);
        assertNotNull(resultUri);
        long eventId = ContentUris.parseId(resultUri);
        assertTrue(eventId >= 0);
        return eventId;
    }

    /**
     * Deletes an exception to a recurring event.
     * @param account The account to use.
     * @param eventId The ID of the original recurring event.
     * @param excepId The ID of the exception event.
     * @return The number of rows deleted.
     */
    private int deleteException(String account, long eventId, long excepId) {
        Uri uri = Uri.withAppendedPath(Events.CONTENT_EXCEPTION_URI,
                eventId + ""/"" + excepId);
        uri = asSyncAdapter(uri, account, CTS_TEST_TYPE);
        return mContentResolver.delete(uri, null, null);
    }

    /**
     * Add some sample attendees to an event.
     */
    private void addAttendees(String account, long eventId, int seed) {
        assertTrue(eventId >= 0);
        AttendeeHelper.addAttendee(mContentResolver, eventId,
                ""Attender"" + seed,
                CalendarHelper.generateCalendarOwnerEmail(account),
                Attendees.ATTENDEE_STATUS_ACCEPTED,
                Attendees.RELATIONSHIP_ORGANIZER,
                Attendees.TYPE_NONE);
        seed++;

        AttendeeHelper.addAttendee(mContentResolver, eventId,
                ""Attender"" + seed,
                ""attender"" + seed + ""@example.com"",
                Attendees.ATTENDEE_STATUS_TENTATIVE,
                Attendees.RELATIONSHIP_NONE,
                Attendees.TYPE_NONE);
    }

    /**
     * Add some sample reminders to an event.
     */
    private void addReminders(String account, long eventId, int seed) {
        ReminderHelper.addReminder(mContentResolver, eventId, seed * 5, Reminders.METHOD_ALERT);
    }

    /**
     * Creates and removes an event that covers a specific range of dates.  Call this to
     * cause the provider to expand the CalendarMetaData min/max values to include the range.
     * Useful when you want to see the provider expand the instances as the events are added.
     */
    private void expandInstanceRange(String account, long calendarId, String testStart,
            String testEnd, String timeZone) {
        int seed = 0;

        // TODO: this should use an UNTIL rule based on testEnd, not a COUNT
        ContentValues eventValues = EventHelper.getNewRecurringEventValues(account, seed,
                calendarId, true, testStart, ""PT1H"", ""FREQ=DAILY;WKST=SU;COUNT=100"");

        /*
         * Some of the helper functions modify ""eventValues"", so we want to make sure we're
         * passing a copy of anything we want to re-use.
         */
        long eventId = createAndVerifyEvent(account, seed, calendarId, true,
                new ContentValues(eventValues));
        assertTrue(eventId >= 0);

        String[] projection = { Instances.BEGIN, Instances.START_MINUTE };
        Cursor instances = getInstances(timeZone, testStart, testEnd, projection,
                new long[] { calendarId });
        if (DEBUG_RECURRENCE) {
            dumpInstances(instances, timeZone, ""prep-create"");
        }
        assertEquals(""initial recurrence instance count"", 3, instances.getCount());
        instances.close();

        Uri eventUri = ContentUris.withAppendedId(Events.CONTENT_URI, eventId);
        removeAndVerifyEvent(eventUri, new ContentValues(eventValues), account);

        instances = getInstances(timeZone, testStart, testEnd, projection,
                new long[] { calendarId });
        if (DEBUG_RECURRENCE) {
            dumpInstances(instances, timeZone, ""prep-clear"");
        }
        assertEquals(""initial recurrence instance count"", 0, instances.getCount());
        instances.close();

    }

    /**
     * Inserts a new calendar with the given account and seed and verifies it.
     *
     * @param account The account to add the calendar to
     * @param seed A number to use to generate the values
     * @return the created calendar's id
     */
    private long createAndVerifyCalendar(String account, int seed, ContentValues values) {
        // Create a calendar
        if (values == null) {
            values = CalendarHelper.getNewCalendarValues(account, seed);
        }
        Uri syncUri = asSyncAdapter(Calendars.CONTENT_URI, account, CTS_TEST_TYPE);
        Uri uri = mContentResolver.insert(syncUri, values);
        long calendarId = ContentUris.parseId(uri);
        assertTrue(calendarId >= 0);

        verifyCalendar(account, values, calendarId, 1);
        return calendarId;
    }

    /**
     * Deletes a given calendar and verifies no calendars remain on that
     * account.
     *
     * @param account
     * @param id
     */
    private void removeAndVerifyCalendar(String account, long id) {
        // TODO Add code to delete as app and sync adapter and test both

        // Delete
        assertEquals(1, CalendarHelper.deleteCalendarById(mContentResolver, id));

        // Verify
        Cursor c = CalendarHelper.getCalendarsByAccount(mContentResolver, account);
        assertEquals(0, c.getCount());
        c.close();
    }

    /**
     * Check all the fields of a calendar contained in values + id.
     *
     * @param account the account of the calendar
     * @param values the values to check against the db
     * @param id the _id of the calendar
     * @param expectedCount the number of calendars expected on this account
     */
    private void verifyCalendar(String account, ContentValues values, long id, int expectedCount) {
        // Verify
        Cursor c = CalendarHelper.getCalendarsByAccount(mContentResolver, account);
        assertEquals(expectedCount, c.getCount());
        assertTrue(c.moveToFirst());
        while (c.getLong(0) != id) {
            assertTrue(c.moveToNext());
        }
        for (String key : values.keySet()) {
            int index = c.getColumnIndex(key);
            assertTrue(""Key "" + key + "" not in projection"", index >= 0);
            assertEquals(key, values.getAsString(key), c.getString(index));
        }
        c.close();
    }

    /**
     * Creates a new _sync_state entry and verifies the contents.
     */
    private long createAndVerifySyncState(String account, ContentValues values) {
        assertNotNull(values);
        Uri syncUri = asSyncAdapter(SyncState.CONTENT_URI, account, CTS_TEST_TYPE);
        Uri uri = mContentResolver.insert(syncUri, values);
        long syncStateId = ContentUris.parseId(uri);
        assertTrue(syncStateId >= 0);

        verifySyncState(account, values, syncStateId);
        return syncStateId;

    }

    /**
     * Removes the _sync_state entry with the specified id, then verifies that it's gone.
     */
    private void removeAndVerifySyncState(String account) {
        assertEquals(1, SyncStateHelper.deleteSyncStateByAccount(mContentResolver, account, true));

        // Verify
        Cursor c = SyncStateHelper.getSyncStateByAccount(mContentResolver, account);
        try {
            assertEquals(0, c.getCount());
        } finally {
            if (c != null) {
                c.close();
            }
        }
    }

    /**
     * Check all the fields of a _sync_state entry contained in values + id. This assumes
     * a single _sync_state has been created on the given account.
     */
    private void verifySyncState(String account, ContentValues values, long id) {
        // Verify
        Cursor c = SyncStateHelper.getSyncStateByAccount(mContentResolver, account);
        try {
            assertEquals(1, c.getCount());
            assertTrue(c.moveToFirst());
            assertEquals(id, c.getLong(0));
            for (String key : values.keySet()) {
                int index = c.getColumnIndex(key);
                if (key.equals(SyncState.DATA)) {
                    // TODO: can't compare as string, so compare as byte[]
                } else {
                    assertEquals(key, values.getAsString(key), c.getString(index));
                }
            }
        } finally {
            if (c != null) {
                c.close();
            }
        }
    }
}"	""	""	"SYNCADAPTER"	""
"9.8.10  Connectivity Bug Report"	"9.8.10"	"C-1-4"	"9.8.10/C-1-4"	""	"""C-1-4] MUST NOT include the following in the generated reports:     *   Any kind of information unrelated to connectivity debugging.     *   Any kind of user-installed application traffic logs or detailed profiles         of user-installed applications/packages (UIDs are okay, package names         are not). *   MAY include additional information that is not associated with any user     identity. (e.g. vendor logs).  If device implementations include additional information (e.g vendor logs) in the bug report and that information has privacy/security/battery/storage/memory impact, they:  """	""	""	"UID"	""	""	""	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.ManagedProfileTest"	"testNoDebuggingFeaturesRestriction"	"CtsDevicePolicyManagerTestCases"	""	""	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/ManagedProfileTest.java"	""	"public void testNoDebuggingFeaturesRestriction() throws Exception {
        // If adb is running as root, then the adb uid is 0 instead of SHELL_UID,
        // so the DISALLOW_DEBUGGING_FEATURES restriction does not work and this test
        // fails.
        if (getDevice().isAdbRoot()) {
            CLog.logAndDisplay(LogLevel.WARN,
                    ""Cannot test testNoDebuggingFeaturesRestriction() in eng/userdebug build"");
            return;
        }
        String restriction = ""no_debugging_features"";  // UserManager.DISALLOW_DEBUGGING_FEATURES

        changeUserRestrictionOrFail(restriction, true, mProfileUserId);


        // This should now fail, as the shell is not available to start activities under a different
        // user once the restriction is in place.
        String addRestrictionCommandOutput =
                changeUserRestriction(restriction, true, mProfileUserId);
        assertTrue(
                ""Expected SecurityException when starting the activity ""
                        + addRestrictionCommandOutput,
                addRestrictionCommandOutput.contains(""SecurityException""));
    }

    // Test the bluetooth API from a managed profile."	""	""	"UID"	""
"2.4.3  Software"	"3.2.3.1"	"W-0-1"	"3.2.3.1/W-0-1"	""	"""[3.2.3.1/W-0-1]  MUST preload one or more applications or service components with an intent handler, for all the public intent filter patterns defined by the following application intents listed [here](https://developer.android.com/about/versions/11/reference/common-intents-30).  Watch device implementations:  *   [[3.8.4/W-SR] Are STRONGLY RECOMMENDED to implement an assistant on the device to handle the [Assist action]( http://developer.android.com/reference/android/content/Intent.html#ACTION_ASSIST).  Watch device implementations that declare the `android.hardware.audio.output` feature flag:  *   ["""	""	""	"Intent.html ACTION_ASSIST android.hardware.audio.output RECOMMENDED"	""	""	""	""	""	""	""	""	""	""	""	"android.admin.cts.DevicePolicyManagerTest"	"testSetRecommendedGlobalProxy_failIfNotDeviceOwner"	"CtsAdminTestCases"	""	""	""	"/home/gpoor/cts-12-source/cts/tests/admin/src/android/admin/cts/DevicePolicyManagerTest.java"	""	"public void testSetRecommendedGlobalProxy_failIfNotDeviceOwner() {
        if (!mDeviceAdmin) {
            Log.w(TAG, ""Skipping testSetRecommendedGlobalProxy_failIfNotDeviceOwner"");
            return;
        }
        try {
            mDevicePolicyManager.setRecommendedGlobalProxy(mComponent, null);
            fail(""did not throw expected SecurityException"");
        } catch (SecurityException e) {
            assertDeviceOwnerMessage(e.getMessage());
        }
    }"	""	""	"RECOMMENDED"	""
"9.11.3  Identity Credential"	"9.11.3"	"C-0-3"	"9.11.3/C-0-3"	""	"""C-0-3] The cryptographic operations needed to implement the Identity      Credential System (e.g. the `android.security.identity.*` APIs) MUST be      performed entirely in the trusted application and private key material MUST      never leave the isolated execution environment unless specifically required      by higher-level APIs (e.g. the      [createEphemeralKeyPair()](https://developer.android.com/reference/android/security/identity/IdentityCredential#createEphemeralKeyPair%28%29)      method).  """	""	""	"createEphemeralKeyPair() android.security.identity"	""	""	""	""	""	""	""	""	""	""	""	"android.security.identity.cts.EphemeralKeyTest"	""	"CtsIdentityTestCases"	""	""	""	"/home/gpoor/cts-12-source/cts/tests/tests/identity/src/android/security/identity/cts/EphemeralKeyTest.java"	""	"/*
 *.
 */

package android.security.identity.cts;

import static junit.framework.TestCase.assertTrue;

import static org.junit.Assert.assertArrayEquals;
import static org.junit.Assert.assertNotEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assume.assumeTrue;

import android.content.Context;
import android.security.keystore.KeyProperties;

import android.security.identity.IdentityCredential;
import android.security.identity.IdentityCredentialException;
import android.security.identity.IdentityCredentialStore;
import androidx.test.InstrumentationRegistry;
import com.android.security.identity.internal.Util;

import org.junit.Test;

import java.nio.ByteBuffer;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.NoSuchAlgorithmException;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.security.cert.X509Certificate;
import java.security.spec.ECGenParameterSpec;
import java.util.Collection;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.KeyAgreement;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.spec.GCMParameterSpec;
import javax.crypto.spec.SecretKeySpec;

// TODO: For better coverage, use different ECDH and HKDF implementations in test code.
public class EphemeralKeyTest {
    private static final String TAG = ""EphemeralKeyTest"";"	""	""	"android.security.identity"	""
"3.2.3.5  Conditional Application Intents"	"3.2.3.5"	"C-7-1"	"3.2.3.5/C-7-1"	""	"""C-7-1] MUST provide a user-accessible mechanism to add and configure third-party input methods in response to the [`android.settings.INPUT_METHOD_SETTINGS`](https://developer.android.com/reference/android/provider/Settings#ACTION_INPUT_METHOD_SETTINGS) intent.  If device implementations support third-party accessibility services, they:  """	""	""	"ACTION_INPUT_METHOD_SETTINGS android.settings.INPUT INPUT_METHOD_SETTINGS"	""	""	""	""	""	""	""	""	""	""	""	"android.systemintents.cts.TestSystemIntents"	"getPackageManager"	"CtsSystemIntentTestCases"	""	""	""	"/home/gpoor/cts-12-source/cts/tests/tests/systemintents/src/android/systemintents/cts/TestSystemIntents.java"	""	"/*
 *.
 */

package android.systemintents.cts;

import static org.junit.Assert.assertTrue;

import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.content.pm.ResolveInfo;
import android.content.res.Configuration;
import android.net.Uri;
import android.provider.Settings;

import androidx.test.filters.MediumTest;
import androidx.test.platform.app.InstrumentationRegistry;
import androidx.test.runner.AndroidJUnit4;

import com.google.common.truth.Expect;

import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;

@MediumTest
@RunWith(AndroidJUnit4.class)
public class TestSystemIntents {
    private static final int EXCLUDE_TV = 1 << 0;
    private static final int EXCLUDE_WATCH = 1 << 1;
    private static final int EXCLUDE_NON_TELEPHONY = 1 << 2;
    private static final int EXCLUDE_NON_INSTALLABLE_IME = 1 << 3;

    private static class IntentEntry {
        public int flags;
        public Intent intent;

        public IntentEntry(int f, Intent i) {
            flags = f;
            intent = i;
        }
    }

    @Rule public final Expect mExpect = Expect.create();

    private Context mContext;
    private PackageManager mPackageManager;

    /*
     * List of activity intents defined by the system.  Activities to handle each of these
     * intents must all exist.
     *
     * They are Intents here rather than simply action strings so that the test can
     * easily accommodate data URIs or similar for correct resolution.
     *
     * The flags associated with each intent indicate kinds of device on which the given
     * UI intent is *not* applicable.
     */
    private final IntentEntry[] mTestIntents = {
            /* Settings-namespace intent actions */
            new IntentEntry(0, new Intent(Settings.ACTION_SETTINGS)),
            new IntentEntry(0, new Intent(Settings.ACTION_APPLICATION_DEVELOPMENT_SETTINGS)),
            new IntentEntry(0, new Intent(Settings.ACTION_IGNORE_BATTERY_OPTIMIZATION_SETTINGS)),
            new IntentEntry(0, new Intent(Settings.ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS)
                    .setData(Uri.parse(""package:android.systemintents.cts""))),
            new IntentEntry(0, new Intent(Settings.ACTION_IGNORE_BACKGROUND_DATA_RESTRICTIONS_SETTINGS)
                    .setData(Uri.parse(""package:android.systemintents.cts""))),
            new IntentEntry(0, new Intent(Settings.ACTION_HOME_SETTINGS)),
            new IntentEntry(EXCLUDE_NON_TELEPHONY,
                    new Intent(Settings.ACTION_APN_SETTINGS)),
            new IntentEntry(EXCLUDE_TV|EXCLUDE_WATCH,
                    new Intent(Settings.ACTION_NOTIFICATION_POLICY_ACCESS_SETTINGS)),
            new IntentEntry(EXCLUDE_NON_INSTALLABLE_IME,
                    new Intent(Settings.ACTION_INPUT_METHOD_SETTINGS))
    };

    @Before
    public void setUp() throws Exception {
        mContext = InstrumentationRegistry.getInstrumentation().getContext();
        mPackageManager = mContext.getPackageManager();
    }"	""	""	"INPUT_METHOD_SETTINGS"	""
"3.2.3.5  Conditional Application Intents"	"3.2.3.5"	"C-13-2"	"3.2.3.5/C-13-2"	""	"""C-13-2] MUST honor the  intents [android.app.action.ADMIN_POLICY_COMPLIANCE](https://developer.android.com/reference/android/app/admin/DevicePolicyManager#ACTION_ADMIN_POLICY_COMPLIANCE), [android.app.action.GET_PROVISIONING_MODE](https://developer.android.com/reference/android/app/admin/DevicePolicyManager#ACTION_GET_PROVISIONING_MODE), [android.app.action.PROVISIONING_SUCCESSFUL](https://developer.android.com/reference/android/app/admin/DevicePolicyManager#ACTION_PROVISIONING_SUCCESSFUL), [android.app.action.PROVISION_MANAGED_DEVICE](https://developer.android.com/reference/android/app/admin/DevicePolicyManager#ACTION_PROVISION_MANAGED_DEVICE), [android.app.action.PROVISION_MANAGED_PROFILE](https://developer.android.com/reference/android/app/admin/DevicePolicyManager#ACTION_PROVISION_MANAGED_PROFILE), [android.app.action.SET_NEW_PARENT_PROFILE_PASSWORD](https://developer.android.com/reference/android/app/admin/DevicePolicyManager#ACTION_SET_NEW_PARENT_PROFILE_PASSWORD), [android.app.action.SET_NEW_PASSWORD](https://developer.android.com/reference/android/app/admin/DevicePolicyManager#ACTION_SET_NEW_PASSWORD) & [android.app.action.START_ENCRYPTION](https://developer.android.com/reference/android/app/admin/DevicePolicyManager#ACTION_START_ENCRYPTION) and have an activity to provide fulfillment for these intents as described in SDK [here](https://developer.android.com/reference/android/app/admin/DevicePolicyManager).  If device implementations declare the [`android.software.autofill`](https://developer.android.com/reference/android/content/pm/PackageManager.html#FEATURE_AUTOFILL) feature flag, they:  """	""	""	"android.app.action.START PROVISION_MANAGED_PROFILE SET_NEW_PASSWORD PROVISIONING_SUCCESSFUL GET_PROVISIONING_MODE ACTION_START_ENCRYPTION FEATURE_AUTOFILL PROVISION_MANAGED_DEVICE android.software.autofill android.app.action.PROVISIONING android.app.action.ADMIN PackageManager.html ACTION_ADMIN_POLICY_COMPLIANCE SET_NEW_PARENT_PROFILE_PASSWORD android.app.action.PROVISION ACTION_PROVISIONING_SUCCESSFUL android.app.action.SET ACTION_GET_PROVISIONING_MODE ACTION_SET_NEW_PARENT_PROFILE_PASSWORD ACTION_PROVISION_MANAGED_PROFILE ACTION_SET_NEW_PASSWORD START_ENCRYPTION android.app.action.GET ACTION_PROVISION_MANAGED_DEVICE ADMIN_POLICY_COMPLIANCE"	""	""	""	""	""	""	""	""	""	""	""	"com.android.cts.comp.ManagementTest"	"testProvisionManagedProfileNotAllowed"	""	""	""	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/CorpOwnedManagedProfile/src/com/android/cts/comp/ManagementTest.java"	""	"public void testProvisionManagedProfileNotAllowed() {
        assertFalse(mDevicePolicyManager.isProvisioningAllowed(
                DevicePolicyManager.ACTION_PROVISION_MANAGED_PROFILE));
    }"	""	""	"ACTION_PROVISION_MANAGED_PROFILE"	""
"7.1.4.2 Vulkan"	"7.1.4.2"	"C-1-9"	"7.1.4.2/C-1-9"	""	"""C-1-9] MUST at least support version `132317953` (from Mar 1st, 2019) as     reported in the `android.software.vulkan.deqp.level` feature flag. """	""	""	"android.software.vulkan.deqp.level"	""	""	""	""	""	""	""	""	""	""	""	"android.graphics.cts.VulkanDeqpLevelTest"	"getSystemAvailableFeatures"	"CtsGraphicsTestCases"	""	""	""	"/home/gpoor/cts-12-source/cts/tests/tests/graphics/src/android/graphics/cts/VulkanDeqpLevelTest.java"	""	"/*
 *.
 */

package android.graphics.cts;

import static org.junit.Assert.assertTrue;
import static org.junit.Assume.assumeTrue;

import android.content.pm.FeatureInfo;
import android.content.pm.PackageManager;
import android.util.Log;

import androidx.test.InstrumentationRegistry;
import androidx.test.filters.SmallTest;
import androidx.test.runner.AndroidJUnit4;

import com.android.compatibility.common.util.CddTest;
import com.android.compatibility.common.util.PropertyUtil;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

/**
 * Test that feature flag android.software.vulkan.deqp.level is present and that it has an
 * acceptable value.
 */
@SmallTest
@RunWith(AndroidJUnit4.class)
public class VulkanDeqpLevelTest {

    private static final String TAG = VulkanDeqpLevelTest.class.getSimpleName();
    private static final boolean DEBUG = false;

    private static final int MINIMUM_VULKAN_DEQP_LEVEL = 0x07E30301; // Corresponds to 2019-03-01

    // Require patch version 3 for Vulkan 1.0: It was the first publicly available version,
    // and there was an important bugfix relative to 1.0.2.
    private static final int VULKAN_1_0 = 0x00400003; // 1.0.3

    private PackageManager mPm;
    private FeatureInfo mVulkanHardwareVersion = null;

    @Before
    public void setup() {
        mPm = InstrumentationRegistry.getTargetContext().getPackageManager();
        FeatureInfo[] features = mPm.getSystemAvailableFeatures();
        if (features != null) {
            for (FeatureInfo feature : features) {
                if (PackageManager.FEATURE_VULKAN_HARDWARE_VERSION.equals(feature.name)) {
                    mVulkanHardwareVersion = feature;
                    if (DEBUG) {
                        Log.d(TAG, feature.name + ""=0x"" + Integer.toHexString(feature.version));
                    }
                }
            }
        }
    }

    @CddTest(requirement = ""7.1.4.2/C-1-8,C-1-9"")"	""	""	"android.software.vulkan.deqp.level"	""
"7.4.5.3  Captive Portals"	"7.4.5.3"	"C-1-3"	"7.4.5.3/C-1-3"	""	"""C-1-3] MUST support logging in to captive portals using cleartext DNS     when the device is configured to use private DNS strict mode. """	""	""	"DNS"	""	""	""	""	""	""	""	""	""	""	""	"android.security.SELinuxTargetSdkTest"	"testNoDns"	"CtsSelinuxTargetSdk29TestCases"	""	""	""	"/home/gpoor/cts-12-source/cts/tests/tests/selinux/selinuxTargetSdk29/src/android/security/SELinuxTargetSdkTest.java"	""	"public void testNoDns() throws IOException {
        noDns();
    }"	""	""	"DNS"	""
