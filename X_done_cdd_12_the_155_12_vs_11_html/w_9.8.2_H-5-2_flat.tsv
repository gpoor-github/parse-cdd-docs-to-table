"Section"	"section_id"	"req_id"	"full_key"	"manual_search_terms"	"requirement"	"Test Availability"	"class_def"	"method"	"module"	"matched_terms"	"methods_string"	"file_name"	"Comment(internal) e.g. why a test is not possible"	"CTS Bug Id"	"Test Level"
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.compat.hiddenapi.cts.HostsideStatsdAtomTests"	"testHiddenApiUsed"	""	"1: attribution"	"public void testHiddenApiUsed() throws Exception {
        String oldRate = getDevice().executeShellCommand(
                ""device_config get app_compat hidden_api_access_statslog_sampling_rate"").trim();

        getDevice().executeShellCommand(
                ""device_config put app_compat hidden_api_access_statslog_sampling_rate 65536"");

        DeviceUtils.installTestApp(getDevice(), TEST_APK, TEST_PKG, mCtsBuild);

        try {
            final int atomTag = Atom.HIDDEN_API_USED_FIELD_NUMBER;

             // Upload the config.
            final StatsdConfig.Builder config = ConfigUtils.createConfigBuilder(TEST_PKG);
            ConfigUtils.addEventMetricForUidAtom(config,  Atom.HIDDEN_API_USED_FIELD_NUMBER,
                    /*uidInAttributionChain=*/false, TEST_PKG);
            ConfigUtils.uploadConfig(getDevice(), config);

            // Trigger hidden api event.
            runActivity(getDevice(), TEST_PKG, ""HiddenApiUsedActivity"",
                    /*actionKey=*/null, /*actionValue=*/null);
            Thread.sleep(AtomTestUtils.WAIT_TIME_SHORT);

            List<EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());
            assertThat(data).hasSize(1);

            HiddenApiUsed atom = data.get(0).getAtom().getHiddenApiUsed();

            final int appUid = DeviceUtils.getAppUid(getDevice(), TEST_PKG);
            assertThat(atom.getUid()).isEqualTo(appUid);
            assertThat(atom.getAccessDenied()).isFalse();
            assertThat(atom.getSignature())
                .isEqualTo(""Landroid/app/Activity;->mWindow:Landroid/view/Window;"");
        } finally {
            if (!oldRate.equals(""null"")) {
                getDevice().executeShellCommand(
                        ""device_config put app_compat hidden_api_access_statslog_sampling_rate ""
                        + oldRate);
            } else {
                getDevice().executeShellCommand(
                        ""device_config delete hidden_api_access_statslog_sampling_rate"");
            }
            DeviceUtils.uninstallTestApp(getDevice(), TEST_PKG);
        }
    }
        /**
     * Runs an activity in a particular app.
     */
    public static void runActivity(ITestDevice device, String pkgName, String activity,
            @Nullable String actionKey, @Nullable String actionValue) throws Exception {
        runActivity(device, pkgName, activity, actionKey, actionValue,
                AtomTestUtils.WAIT_TIME_LONG);
    }

    /**
     * Runs an activity in a particular app for a certain period of time.
     *
     * @param pkgName name of package that contains the Activity
     * @param activity name of the Activity class
     * @param actionKey key of extra data that is passed to the Activity via an Intent
     * @param actionValue value of extra data that is passed to the Activity via an Intent
     * @param waitTimeMs duration that the activity runs for
     */
    public static void runActivity(ITestDevice device, String pkgName, String activity,
            @Nullable String actionKey, @Nullable String actionValue, long waitTimeMs)
            throws Exception {
        try (AutoCloseable a = withActivity(device, pkgName, activity, actionKey, actionValue)) {
            Thread.sleep(waitTimeMs);
        }
    }

    /**
     * Starts the specified activity and returns an {@link AutoCloseable} that stops the activity
     * when closed.
     *
     * <p>Example usage:
     * <pre>
     *     try (AutoClosable a = withActivity(""activity"", ""action"", ""action-value"")) {
     *         doStuff();
     *     }
     * </pre>
     */
    public static AutoCloseable withActivity(ITestDevice device, String pkgName, String activity,
            @Nullable String actionKey, @Nullable String actionValue) throws Exception {
        String intentString;
        if (actionKey != null && actionValue != null) {
            intentString = actionKey + "" "" + actionValue;
        } else {
            intentString = null;
        }

        String cmd = ""am start -n "" + pkgName + ""/."" + activity;
        if (intentString != null) {
            cmd += "" -e "" + intentString;
        }
        device.executeShellCommand(cmd);

        return () -> {
            device.executeShellCommand(""am force-stop "" + pkgName);
            Thread.sleep(AtomTestUtils.WAIT_TIME_SHORT);
        };
    }

}"	"/home/gpoor/cts-12-source/cts/hostsidetests/appcompat/hiddenapi/src/android/compat/hiddenapi/cts/HostsideStatsdAtomTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"com.android.cts.host.blob.StatsdBlobStoreAtomTest"	"testPushedBlobStoreStats"	"CtsBlobStoreHostTestCases"	"1: attribution"	"public void testPushedBlobStoreStats() throws Exception {
        final StatsdConfigProto.StatsdConfig.Builder conf =
                ConfigUtils.createConfigBuilder(TARGET_PKG);
        ConfigUtils.addEventMetricForUidAtom(conf, AtomsProto.Atom.BLOB_COMMITTED_FIELD_NUMBER,
                /*useUidAttributionChain=*/ false, TARGET_PKG);
        ConfigUtils.addEventMetricForUidAtom(conf, AtomsProto.Atom.BLOB_LEASED_FIELD_NUMBER,
                /*useUidAttributionChain=*/ false, TARGET_PKG);
        ConfigUtils.addEventMetricForUidAtom(conf, AtomsProto.Atom.BLOB_OPENED_FIELD_NUMBER,
                /*useUidAttributionChain=*/ false, TARGET_PKG);
        ConfigUtils.uploadConfig(getDevice(), conf);

        runDeviceTest(TARGET_PKG, TEST_CLASS, ""testBlobStoreOps"");

        final List<StatsLog.EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());
        assertThat(data).hasSize(3);

        final AtomsProto.BlobCommitted blobCommitted = data.get(0).getAtom().getBlobCommitted();
        final long blobId = blobCommitted.getBlobId();
        final long blobSize = blobCommitted.getSize();
        assertThat(blobCommitted.getUid()).isEqualTo(mTestAppUid);
        assertThat(blobId).isGreaterThan(0L);
        assertThat(blobSize).isGreaterThan(0L);
        assertThat(blobCommitted.getResult()).isEqualTo(AtomsProto.BlobCommitted.Result.SUCCESS);

        final AtomsProto.BlobLeased blobLeased = data.get(1).getAtom().getBlobLeased();
        assertThat(blobLeased.getUid()).isEqualTo(mTestAppUid);
        assertThat(blobLeased.getBlobId()).isEqualTo(blobId);
        assertThat(blobLeased.getSize()).isEqualTo(blobSize);
        assertThat(blobLeased.getResult()).isEqualTo(AtomsProto.BlobLeased.Result.SUCCESS);

        final AtomsProto.BlobOpened blobOpened = data.get(2).getAtom().getBlobOpened();
        assertThat(blobOpened.getUid()).isEqualTo(mTestAppUid);
        assertThat(blobOpened.getBlobId()).isEqualTo(blobId);
        assertThat(blobOpened.getSize()).isEqualTo(blobSize);
        assertThat(blobOpened.getResult()).isEqualTo(AtomsProto.BlobOpened.Result.SUCCESS);
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/blobstore/src/com/android/cts/host/blob/StatsdBlobStoreAtomTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.media.metrics.cts.MediaMetricsAtomTests"	"testAttributionBlocklist"	"CtsMediaHostTestCases"	"1: attribution"	"public void testAttributionBlocklist() throws Exception {
        ConfigUtils.uploadConfigForPushedAtom(getDevice(), TEST_PKG,
                AtomsProto.Atom.MEDIAMETRICS_PLAYBACK_REPORTED_FIELD_NUMBER);
        DeviceUtils.runDeviceTests(
                getDevice(),
                TEST_PKG,
                ""android.media.metrics.cts.MediaMetricsAtomHostSideTests"",
                ""testAttributionBlocklist"");
        Thread.sleep(AtomTestUtils.WAIT_TIME_LONG);

        List<StatsLog.EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());

        assertThat(data.size()).isEqualTo(1);
        assertThat(data.get(0).getAtom().hasMediametricsPlaybackReported()).isTrue();
        AtomsProto.MediametricsPlaybackReported result =
                data.get(0).getAtom().getMediametricsPlaybackReported();

        assertThat(result.getUid()).isEqualTo(0); // UID is not logged. Should be 0.
        assertThat(result.getMediaDurationMillis()).isEqualTo(233L);
        assertThat(result.getStreamSource().toString()).isEqualTo(""STREAM_SOURCE_NETWORK"");
        assertThat(result.getStreamType().toString()).isEqualTo(""STREAM_TYPE_OTHER"");
        assertThat(result.getPlaybackType().toString()).isEqualTo(""PLAYBACK_TYPE_LIVE"");
        assertThat(result.getDrmType().toString()).isEqualTo(""DRM_TYPE_WV_L1"");
        assertThat(result.getContentType().toString()).isEqualTo(""CONTENT_TYPE_MAIN"");
        assertThat(result.getPlayerName()).isEqualTo(""ExoPlayer"");
        assertThat(result.getPlayerVersion()).isEqualTo(""1.01x"");
        assertThat(result.getVideoFramesPlayed()).isEqualTo(1024);
        assertThat(result.getVideoFramesDropped()).isEqualTo(32);
        assertThat(result.getAudioUnderrunCount()).isEqualTo(22);
        assertThat(result.getNetworkBytesRead()).isEqualTo(102400);
        assertThat(result.getLocalBytesRead()).isEqualTo(2000);
        assertThat(result.getNetworkTransferDurationMillis()).isEqualTo(6000);
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/media/src/android/media/metrics/cts/MediaMetricsAtomTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.media.metrics.cts.MediaMetricsAtomTests"	"testAttributionAllowlist"	"CtsMediaHostTestCases"	"1: attribution"	"public void testAttributionAllowlist() throws Exception {
        ConfigUtils.uploadConfigForPushedAtom(getDevice(), TEST_PKG,
                AtomsProto.Atom.MEDIAMETRICS_PLAYBACK_REPORTED_FIELD_NUMBER);
        DeviceUtils.runDeviceTests(
                getDevice(),
                TEST_PKG,
                ""android.media.metrics.cts.MediaMetricsAtomHostSideTests"",
                ""testAttributionAllowlist"");
        Thread.sleep(AtomTestUtils.WAIT_TIME_LONG);

        List<StatsLog.EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());

        assertThat(data.size()).isEqualTo(1);
        assertThat(data.get(0).getAtom().hasMediametricsPlaybackReported()).isTrue();
        AtomsProto.MediametricsPlaybackReported result =
                data.get(0).getAtom().getMediametricsPlaybackReported();

        assertThat(result.getUid()).isEqualTo(0); // UID is not logged. Should be 0.
        assertThat(result.getMediaDurationMillis()).isEqualTo(233L);
        assertThat(result.getStreamSource().toString()).isEqualTo(""STREAM_SOURCE_NETWORK"");
        assertThat(result.getStreamType().toString()).isEqualTo(""STREAM_TYPE_OTHER"");
        assertThat(result.getPlaybackType().toString()).isEqualTo(""PLAYBACK_TYPE_LIVE"");
        assertThat(result.getDrmType().toString()).isEqualTo(""DRM_TYPE_WV_L1"");
        assertThat(result.getContentType().toString()).isEqualTo(""CONTENT_TYPE_MAIN"");
        assertThat(result.getPlayerName()).isEqualTo(""ExoPlayer"");
        assertThat(result.getPlayerVersion()).isEqualTo(""1.01x"");
        assertThat(result.getVideoFramesPlayed()).isEqualTo(1024);
        assertThat(result.getVideoFramesDropped()).isEqualTo(32);
        assertThat(result.getAudioUnderrunCount()).isEqualTo(22);
        assertThat(result.getNetworkBytesRead()).isEqualTo(102400);
        assertThat(result.getLocalBytesRead()).isEqualTo(2000);
        assertThat(result.getNetworkTransferDurationMillis()).isEqualTo(6000);
    }

    private void validateAAudioStreamAtom(int direction) throws Exception {
        Set<Integer> directionSet = new HashSet<>(Arrays.asList(direction));
        List<Set<Integer>> directionList = Arrays.asList(directionSet);

        List<StatsLog.EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());
        AtomTestUtils.assertStatesOccurred(directionList, data, 0,
                atom -> atom.getMediametricsAaudiostreamReported().getDirection().getNumber());

        for (StatsLog.EventMetricData event : data) {
            AtomsProto.MediametricsAAudioStreamReported atom =
                    event.getAtom().getMediametricsAaudiostreamReported();
            assertThat(atom.getBufferCapacity()).isGreaterThan(0);
            assertThat(atom.getBufferCapacity()).isLessThan(MAX_BUFFER_CAPACITY);
            assertThat(atom.getBufferSize()).isGreaterThan(0);
            assertThat(atom.getBufferSize()).isAtMost(atom.getBufferCapacity());
            assertThat(atom.getFramesPerBurst()).isGreaterThan(0);
            assertThat(atom.getFramesPerBurst()).isLessThan(atom.getBufferCapacity());
        }
    }

    private void runAAudioTestAndValidate(
            String requiredFeature, int direction, String testFunctionName) throws Exception {
        if (!DeviceUtils.hasFeature(getDevice(), requiredFeature)) {
            return;
        }
        ConfigUtils.uploadConfigForPushedAtom(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                AtomsProto.Atom.MEDIAMETRICS_AAUDIOSTREAM_REPORTED_FIELD_NUMBER);

        DeviceUtils.runDeviceTests(
                getDevice(),
                TEST_PKG,
                ""android.media.metrics.cts.MediaMetricsAtomHostSideTests"",
                testFunctionName);
        Thread.sleep(AtomTestUtils.WAIT_TIME_LONG);

        validateAAudioStreamAtom(direction);
    }

    /**
     * The test try to create and then close aaudio input stream with mmap path via media metrics
     * atom host side test app on the DUT.
     * After that, the event metric data for MediametricsAAudioStreamReported is pushed to verify
     * the data is collected correctly.
     */"	"/home/gpoor/cts-12-source/cts/hostsidetests/media/src/android/media/metrics/cts/MediaMetricsAtomTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.media.metrics.cts.MediaMetricsAtomHostSideTests"	"turnOnForTesting"	""	"1: attribution"	"/*
 *.
 */

package android.media.metrics.cts;

import static com.google.common.truth.Truth.assertThat;

import android.content.Context;
import android.media.metrics.LogSessionId;
import android.media.metrics.MediaMetricsManager;
import android.media.metrics.NetworkEvent;
import android.media.metrics.PlaybackErrorEvent;
import android.media.metrics.PlaybackMetrics;
import android.media.metrics.PlaybackSession;
import android.media.metrics.PlaybackStateEvent;
import android.media.metrics.RecordingSession;
import android.media.metrics.TrackChangeEvent;
import android.os.Bundle;
import android.provider.DeviceConfig;

import androidx.test.InstrumentationRegistry;

import com.android.compatibility.common.util.SystemUtil;

import java.lang.InterruptedException;

import org.junit.Test;

public class MediaMetricsAtomHostSideTests {
    private static final String MEDIA_METRICS_MODE = ""media_metrics_mode"";
    private static final String PLAYER_METRICS_APP_ALLOWLIST = ""player_metrics_app_allowlist"";
    private static final String PLAYER_METRICS_APP_BLOCKLIST = ""player_metrics_app_blocklist"";
    private static final String PLAYER_METRICS_PER_APP_ATTRIBUTION_ALLOWLIST =
            ""player_metrics_per_app_attribution_allowlist"";
    private static final String PLAYER_METRICS_PER_APP_ATTRIBUTION_BLOCKLIST =
            ""player_metrics_per_app_attribution_blocklist"";
    private static final String MEDIA_METRICS_MODE_ON = ""1"";
    private static final String MEDIA_METRICS_MODE_BLOCKLIST = ""2"";
    private static final String MEDIA_METRICS_MODE_ALLOWLIST = ""3"";
    private static final String TEST_PKG = ""android.media.metrics.cts"";
    private static final int DEVICE_PROPERTY_PROPAGATION_DELAY_MICROSECONDS = 1000;

    static {
        System.loadLibrary(""CtsMediaMetricsHostTestAppJni"");
    }

    private static void resetProperties() throws InterruptedException {
        // ensure the event/metric is sent.
        Thread.sleep(1000);
        // see DeviceConfig#resetToDefaults(int, String).
        SystemUtil.runWithShellPermissionIdentity(() -> {
            DeviceConfig.setProperties(
                    new DeviceConfig.Properties.Builder(DeviceConfig.NAMESPACE_MEDIA).build());
        });
        // ensure the property is set.
        Thread.sleep(DEVICE_PROPERTY_PROPAGATION_DELAY_MICROSECONDS);
    }

    private static void turnOnForTesting() throws InterruptedException {
        SystemUtil.runWithShellPermissionIdentity(() -> {
            DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_MEDIA,
                    MEDIA_METRICS_MODE,
                    MEDIA_METRICS_MODE_ON,
                    /*makeDefault=*/ false);
        });
        // ensure the property is set.
        Thread.sleep(DEVICE_PROPERTY_PROPAGATION_DELAY_MICROSECONDS);
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/media/app/MediaMetricsTest/src/android/media/metrics/cts/MediaMetricsAtomHostSideTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.media.metrics.cts.MediaMetricsAtomHostSideTests"	"testAppBlocklist"	""	"1: attribution"	"public void testAppBlocklist() throws Exception {
        SystemUtil.runWithShellPermissionIdentity(() -> {
            DeviceConfig.setProperties(
                    new DeviceConfig.Properties.Builder(DeviceConfig.NAMESPACE_MEDIA)
                            .setString(MEDIA_METRICS_MODE, MEDIA_METRICS_MODE_BLOCKLIST)
                            .setString(PLAYER_METRICS_PER_APP_ATTRIBUTION_BLOCKLIST, """")
                            .setString(PLAYER_METRICS_APP_BLOCKLIST, TEST_PKG)
                            .build());
        });
        Thread.sleep(DEVICE_PROPERTY_PROPAGATION_DELAY_MICROSECONDS);
        Context context = InstrumentationRegistry.getContext();
        MediaMetricsManager manager = context.getSystemService(MediaMetricsManager.class);
        PlaybackSession s = manager.createPlaybackSession();
        PlaybackStateEvent e =
                new PlaybackStateEvent.Builder()
                        .setTimeSinceCreatedMillis(1763L)
                        .setState(PlaybackStateEvent.STATE_JOINING_FOREGROUND)
                        .setMetricsBundle(new Bundle())
                        .build();
        s.reportPlaybackStateEvent(e);
        resetProperties();
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/media/app/MediaMetricsTest/src/android/media/metrics/cts/MediaMetricsAtomHostSideTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.media.metrics.cts.MediaMetricsAtomHostSideTests"	"testAttributionBlocklist"	""	"1: attribution"	"public void testAttributionBlocklist() throws Exception {
        SystemUtil.runWithShellPermissionIdentity(() -> {
            DeviceConfig.setProperties(
                    new DeviceConfig.Properties.Builder(DeviceConfig.NAMESPACE_MEDIA)
                            .setString(MEDIA_METRICS_MODE, MEDIA_METRICS_MODE_BLOCKLIST)
                            .setString(PLAYER_METRICS_PER_APP_ATTRIBUTION_BLOCKLIST, TEST_PKG)
                            .setString(PLAYER_METRICS_APP_BLOCKLIST, """")
                            .build());
        });
        Thread.sleep(DEVICE_PROPERTY_PROPAGATION_DELAY_MICROSECONDS);
        Context context = InstrumentationRegistry.getContext();
        MediaMetricsManager manager = context.getSystemService(MediaMetricsManager.class);
        PlaybackSession s = manager.createPlaybackSession();
        PlaybackMetrics e =
                new PlaybackMetrics.Builder()
                        .setMediaDurationMillis(233L)
                        .setStreamSource(PlaybackMetrics.STREAM_SOURCE_NETWORK)
                        .setStreamType(PlaybackMetrics.STREAM_TYPE_OTHER)
                        .setPlaybackType(PlaybackMetrics.PLAYBACK_TYPE_LIVE)
                        .setDrmType(PlaybackMetrics.DRM_TYPE_WIDEVINE_L1)
                        .setContentType(PlaybackMetrics.CONTENT_TYPE_MAIN)
                        .setPlayerName(""ExoPlayer"")
                        .setPlayerVersion(""1.01x"")
                        .setVideoFramesPlayed(1024)
                        .setVideoFramesDropped(32)
                        .setAudioUnderrunCount(22)
                        .setNetworkBytesRead(102400)
                        .setLocalBytesRead(2000)
                        .setNetworkTransferDurationMillis(6000)
                        .setDrmSessionId(new byte[] {2, 3, 3, 10})
                        .setMetricsBundle(new Bundle())
                        .addExperimentId(123)
                        .build();
        s.reportPlaybackMetrics(e);
        resetProperties();
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/media/app/MediaMetricsTest/src/android/media/metrics/cts/MediaMetricsAtomHostSideTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.media.metrics.cts.MediaMetricsAtomHostSideTests"	"testAppAllowlist"	""	"1: attribution"	"public void testAppAllowlist() throws Exception {
        SystemUtil.runWithShellPermissionIdentity(() -> {
            DeviceConfig.setProperties(
                    new DeviceConfig.Properties.Builder(DeviceConfig.NAMESPACE_MEDIA)
                            .setString(MEDIA_METRICS_MODE, MEDIA_METRICS_MODE_ALLOWLIST)
                            .setString(PLAYER_METRICS_PER_APP_ATTRIBUTION_ALLOWLIST, """")
                            .setString(PLAYER_METRICS_APP_ALLOWLIST, TEST_PKG)
                            .build());
        });
        Thread.sleep(DEVICE_PROPERTY_PROPAGATION_DELAY_MICROSECONDS);
        Context context = InstrumentationRegistry.getContext();
        MediaMetricsManager manager = context.getSystemService(MediaMetricsManager.class);
        PlaybackSession s = manager.createPlaybackSession();
        PlaybackStateEvent e =
                new PlaybackStateEvent.Builder()
                        .setTimeSinceCreatedMillis(1763L)
                        .setState(PlaybackStateEvent.STATE_JOINING_FOREGROUND)
                        .setMetricsBundle(new Bundle())
                        .build();
        s.reportPlaybackStateEvent(e);
        resetProperties();
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/media/app/MediaMetricsTest/src/android/media/metrics/cts/MediaMetricsAtomHostSideTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.media.metrics.cts.MediaMetricsAtomHostSideTests"	"testAttributionAllowlist"	""	"1: attribution"	"public void testAttributionAllowlist() throws Exception {
        SystemUtil.runWithShellPermissionIdentity(() -> {
            DeviceConfig.setProperties(
                    new DeviceConfig.Properties.Builder(DeviceConfig.NAMESPACE_MEDIA)
                            .setString(MEDIA_METRICS_MODE, MEDIA_METRICS_MODE_ALLOWLIST)
                            .setString(PLAYER_METRICS_PER_APP_ATTRIBUTION_ALLOWLIST, TEST_PKG)
                            .setString(PLAYER_METRICS_APP_ALLOWLIST, """")
                            .build());
        });
        Thread.sleep(DEVICE_PROPERTY_PROPAGATION_DELAY_MICROSECONDS);
        Context context = InstrumentationRegistry.getContext();
        MediaMetricsManager manager = context.getSystemService(MediaMetricsManager.class);
        PlaybackSession s = manager.createPlaybackSession();
        PlaybackMetrics e =
                new PlaybackMetrics.Builder()
                        .setMediaDurationMillis(233L)
                        .setStreamSource(PlaybackMetrics.STREAM_SOURCE_NETWORK)
                        .setStreamType(PlaybackMetrics.STREAM_TYPE_OTHER)
                        .setPlaybackType(PlaybackMetrics.PLAYBACK_TYPE_LIVE)
                        .setDrmType(PlaybackMetrics.DRM_TYPE_WIDEVINE_L1)
                        .setContentType(PlaybackMetrics.CONTENT_TYPE_MAIN)
                        .setPlayerName(""ExoPlayer"")
                        .setPlayerVersion(""1.01x"")
                        .setVideoFramesPlayed(1024)
                        .setVideoFramesDropped(32)
                        .setAudioUnderrunCount(22)
                        .setNetworkBytesRead(102400)
                        .setLocalBytesRead(2000)
                        .setNetworkTransferDurationMillis(6000)
                        .setDrmSessionId(new byte[] {2, 3, 3, 10})
                        .setMetricsBundle(new Bundle())
                        .addExperimentId(123)
                        .build();
        s.reportPlaybackMetrics(e);
        resetProperties();
    }

    /**
     * Open aaudio mmap output stream and then close
     */"	"/home/gpoor/cts-12-source/cts/hostsidetests/media/app/MediaMetricsTest/src/android/media/metrics/cts/MediaMetricsAtomHostSideTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.cts.statsdatom.bluetooth.BluetoothStatsTests"	"testBleScan"	"CtsStatsdAtomHostTestCases"	"1: attribution"	"public void testBleScan() throws Exception {
        if (!DeviceUtils.hasFeature(getDevice(), FEATURE_BLUETOOTH_LE)) return;

        final int atomTag = AtomsProto.Atom.BLE_SCAN_STATE_CHANGED_FIELD_NUMBER;
        Set<Integer> onState = new HashSet<>(
                Collections.singletonList(AtomsProto.BleScanStateChanged.State.ON_VALUE));
        Set<Integer> offState = new HashSet<>(
                Collections.singletonList(AtomsProto.BleScanStateChanged.State.OFF_VALUE));
        final int expectedWait = 3_000;
        // Add state sets to the list in order.
        List<Set<Integer>> stateSet = Arrays.asList(onState, offState);
        ConfigUtils.uploadConfigForPushedAtomWithUid(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                atomTag, /*useAttributionChain=*/ true);

        DeviceUtils.runDeviceTestsOnStatsdApp(getDevice(), "".AtomTests"", ""testBleScanUnoptimized"");
        Thread.sleep(AtomTestUtils.WAIT_TIME_SHORT);

        List<StatsLog.EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());
        AtomTestUtils.assertStatesOccurred(stateSet, data, expectedWait,
                atom -> atom.getBleScanStateChanged().getState().getNumber());
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/bluetooth/BluetoothStatsTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.cts.statsdatom.bluetooth.BluetoothStatsTests"	"testBleUnoptimizedScan"	"CtsStatsdAtomHostTestCases"	"1: attribution"	"public void testBleUnoptimizedScan() throws Exception {
        if (!DeviceUtils.hasFeature(getDevice(), FEATURE_BLUETOOTH_LE)) return;

        final int atomTag = AtomsProto.Atom.BLE_SCAN_STATE_CHANGED_FIELD_NUMBER;
        Set<Integer> onState = new HashSet<>(
                Collections.singletonList(AtomsProto.BleScanStateChanged.State.ON_VALUE));
        Set<Integer> offState = new HashSet<>(
                Collections.singletonList(AtomsProto.BleScanStateChanged.State.OFF_VALUE));
        final int minTimeDiffMillis = 1_500;
        final int maxTimeDiffMillis = 3_000;
        // Add state sets to the list in order.
        List<Set<Integer>> stateSet = Arrays.asList(onState, offState);
        ConfigUtils.uploadConfigForPushedAtomWithUid(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                atomTag, /*useAttributionChain=*/ true);

        DeviceUtils.runDeviceTestsOnStatsdApp(getDevice(), "".AtomTests"", ""testBleScanUnoptimized"");
        Thread.sleep(AtomTestUtils.WAIT_TIME_SHORT);

        List<StatsLog.EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());
        AtomTestUtils.assertTimeDiffBetween(data.get(0), data.get(1), minTimeDiffMillis,
                maxTimeDiffMillis);
        AtomsProto.BleScanStateChanged a0 = data.get(0).getAtom().getBleScanStateChanged();
        assertThat(a0.getState().getNumber()).isEqualTo(
                AtomsProto.BleScanStateChanged.State.ON_VALUE);
        assertThat(a0.getIsFiltered()).isFalse();
        assertThat(a0.getIsFirstMatch()).isFalse();
        assertThat(a0.getIsOpportunistic()).isFalse();
        AtomsProto.BleScanStateChanged a1 = data.get(1).getAtom().getBleScanStateChanged();
        assertThat(a1.getState().getNumber()).isEqualTo(
                AtomsProto.BleScanStateChanged.State.OFF_VALUE);
        assertThat(a1.getIsFiltered()).isFalse();
        assertThat(a1.getIsFirstMatch()).isFalse();
        assertThat(a1.getIsOpportunistic()).isFalse();
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/bluetooth/BluetoothStatsTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.cts.statsdatom.bluetooth.BluetoothStatsTests"	"testBleOpportunisticScan"	"CtsStatsdAtomHostTestCases"	"1: attribution"	"public void testBleOpportunisticScan() throws Exception {
        if (!DeviceUtils.hasFeature(getDevice(), FEATURE_BLUETOOTH_LE)) return;

        final int atomTag = AtomsProto.Atom.BLE_SCAN_STATE_CHANGED_FIELD_NUMBER;
        Set<Integer> onState = new HashSet<>(
                Collections.singletonList(AtomsProto.BleScanStateChanged.State.ON_VALUE));
        Set<Integer> offState = new HashSet<>(
                Collections.singletonList(AtomsProto.BleScanStateChanged.State.OFF_VALUE));
        final int minTimeDiffMillis = 1_500;
        final int maxTimeDiffMillis = 3_000;
        // Add state sets to the list in order.
        List<Set<Integer>> stateSet = Arrays.asList(onState, offState);
        ConfigUtils.uploadConfigForPushedAtomWithUid(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                atomTag, /*useAttributionChain=*/ true);

        DeviceUtils.runDeviceTestsOnStatsdApp(getDevice(), "".AtomTests"",
                ""testBleScanOpportunistic"");

        List<StatsLog.EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());
        AtomTestUtils.assertTimeDiffBetween(data.get(0), data.get(1), minTimeDiffMillis,
                maxTimeDiffMillis);
        AtomsProto.BleScanStateChanged a0 = data.get(0).getAtom().getBleScanStateChanged();
        assertThat(a0.getState().getNumber()).isEqualTo(
                AtomsProto.BleScanStateChanged.State.ON_VALUE);
        assertThat(a0.getIsFiltered()).isFalse();
        assertThat(a0.getIsFirstMatch()).isFalse();
        assertThat(a0.getIsOpportunistic()).isTrue();  // This scan is opportunistic.
        AtomsProto.BleScanStateChanged a1 = data.get(1).getAtom().getBleScanStateChanged();
        assertThat(a1.getState().getNumber()).isEqualTo(
                AtomsProto.BleScanStateChanged.State.OFF_VALUE);
        assertThat(a1.getIsFiltered()).isFalse();
        assertThat(a1.getIsFirstMatch()).isFalse();
        assertThat(a1.getIsOpportunistic()).isTrue();
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/bluetooth/BluetoothStatsTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.cts.statsdatom.bluetooth.BluetoothStatsTests"	"testBleScanResult"	"CtsStatsdAtomHostTestCases"	"1: attribution"	"public void testBleScanResult() throws Exception {
        if (!DeviceUtils.hasFeature(getDevice(), FEATURE_BLUETOOTH_LE)) return;

        final int atom = AtomsProto.Atom.BLE_SCAN_RESULT_RECEIVED_FIELD_NUMBER;
        final int field = AtomsProto.BleScanResultReceived.NUM_RESULTS_FIELD_NUMBER;
        StatsdConfigProto.StatsdConfig.Builder config = ConfigUtils.createConfigBuilder(
                DeviceUtils.STATSD_ATOM_TEST_PKG);
        ConfigUtils.addEventMetric(config, atom, Arrays.asList(
                ConfigUtils.createUidFvm(/*useAttributionChain=*/ true,
                        DeviceUtils.STATSD_ATOM_TEST_PKG),
                ConfigUtils.createFvm(field).setGteInt(0)));
        ConfigUtils.uploadConfig(getDevice(), config);

        DeviceUtils.runDeviceTestsOnStatsdApp(getDevice(), "".AtomTests"", ""testBleScanResult"");

        List<StatsLog.EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());
        assertThat(data.size()).isAtLeast(1);
        AtomsProto.BleScanResultReceived a0 = data.get(0).getAtom().getBleScanResultReceived();
        assertThat(a0.getNumResults()).isAtLeast(1);
    }
}"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/bluetooth/BluetoothStatsTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.cts.statsdatom.appstart.AppStartStatsTests"	"testAppStartOccurred"	"CtsStatsdAtomHostTestCases"	"1: attribution"	"public void testAppStartOccurred() throws Exception {
        final int atomTag = AtomsProto.Atom.APP_START_OCCURRED_FIELD_NUMBER;
        ConfigUtils.uploadConfigForPushedAtomWithUid(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                atomTag,  /*uidInAttributionChain=*/false);
        getDevice().executeShellCommand(getGlobalHibernationCommand(
                DeviceUtils.STATSD_ATOM_TEST_PKG, false));

        DeviceUtils.runActivity(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                STATSD_CTS_FOREGROUND_ACTIVITY, ""action"", ""action.sleep_top"", WAIT_TIME_MS);

        // Sorted list of events in order in which they occurred.
        List<StatsLog.EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());

        assertThat(data).hasSize(1);
        AtomsProto.AppStartOccurred atom = data.get(0).getAtom().getAppStartOccurred();
        assertThat(atom.getPkgName()).isEqualTo(DeviceUtils.STATSD_ATOM_TEST_PKG);
        assertThat(atom.getActivityName())
                .isEqualTo(""com.android.server.cts.device.statsdatom.StatsdCtsForegroundActivity"");
        assertThat(atom.getIsInstantApp()).isFalse();
        assertThat(atom.getActivityStartTimestampMillis()).isGreaterThan(0L);
        assertThat(atom.getTransitionDelayMillis()).isGreaterThan(0);
        assertThat(atom.getIsHibernating()).isFalse();
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/appstart/AppStartStatsTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.cts.statsdatom.appstart.AppStartStatsTests"	"testHibernatingAppStartOccurred"	"CtsStatsdAtomHostTestCases"	"1: attribution"	"public void testHibernatingAppStartOccurred() throws Exception {
        final int atomTag = AtomsProto.Atom.APP_START_OCCURRED_FIELD_NUMBER;
        ConfigUtils.uploadConfigForPushedAtomWithUid(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                atomTag,  /*uidInAttributionChain=*/false);
        getDevice().executeShellCommand(COMMAND_ENABLE_APP_HIBERNATION);
        getDevice().executeShellCommand(getGlobalHibernationCommand(
                DeviceUtils.STATSD_ATOM_TEST_PKG, true));

        DeviceUtils.runActivity(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                STATSD_CTS_FOREGROUND_ACTIVITY, ""action"", ""action.sleep_top"", WAIT_TIME_MS);

        // Sorted list of events in order in which they occurred.
        List<StatsLog.EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());
        assertThat(data).hasSize(1);
        AtomsProto.AppStartOccurred atom = data.get(0).getAtom().getAppStartOccurred();
        assertThat(atom.getIsHibernating()).isTrue();
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/appstart/AppStartStatsTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.cts.statsdatom.appstart.AppStartStatsTests"	"testHibernatingAppStartOccurredTwice_isHibernatingShouldBeFalseSecondTime"	"CtsStatsdAtomHostTestCases"	"1: attribution"	"public void testHibernatingAppStartOccurredTwice_isHibernatingShouldBeFalseSecondTime()
            throws Exception {
        final int atomTag = AtomsProto.Atom.APP_START_OCCURRED_FIELD_NUMBER;
        ConfigUtils.uploadConfigForPushedAtomWithUid(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                atomTag,  /*uidInAttributionChain=*/false);
        getDevice().executeShellCommand(COMMAND_ENABLE_APP_HIBERNATION);
        getDevice().executeShellCommand(getGlobalHibernationCommand(
                DeviceUtils.STATSD_ATOM_TEST_PKG, true));

        DeviceUtils.runActivity(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                STATSD_CTS_FOREGROUND_ACTIVITY, ""action"", ""action.sleep_top"", WAIT_TIME_MS);
        DeviceUtils.runActivity(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                STATSD_CTS_FOREGROUND_ACTIVITY, ""action"", ""action.sleep_top"", WAIT_TIME_MS);

        // Sorted list of events in order in which they occurred.
        List<StatsLog.EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());

        assertThat(data).hasSize(2);
        AtomsProto.AppStartOccurred atom = data.get(1).getAtom().getAppStartOccurred();
        assertThat(atom.getIsHibernating()).isFalse();
    }

    private static String getGlobalHibernationCommand(String packageName, boolean isHibernating) {
        return CMD_APP_HIBERNATION_SET_STATE_GLOBAL + packageName + "" "" + isHibernating;
    }
}"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/appstart/AppStartStatsTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.cts.statsdatom.net.BytesTransferredTest"	"testBytesTransferByTagAndMetered"	"CtsStatsdAtomHostTestCases"	"1: attribution"	"public void testBytesTransferByTagAndMetered() throws Throwable {
        doTestMobileBytesTransferThat(Atom.BYTES_TRANSFER_BY_TAG_AND_METERED_FIELD_NUMBER,
                /*isUidAtom=*/true,
                (atom) -> {
                    final AtomsProto.BytesTransferByTagAndMetered data =
                            atom.getBytesTransferByTagAndMetered();
                    if (data.getTag() != 0 /*app traffic not generated on tag 0*/) {
                        return null;
                    }
                    return new TransferredBytes(data.getRxBytes(), data.getTxBytes(),
                            data.getRxPackets(), data.getTxPackets(), data.getUid());
                }
        );
    }

    private static class TransferredBytes {
        final long mRxBytes;
        final long mTxBytes;
        final long mRxPackets;
        final long mTxPackets;
        final long mAppUid;

        TransferredBytes(
                long rxBytes, long txBytes, long rxPackets, long txPackets, long appUid) {
            mRxBytes = rxBytes;
            mTxBytes = txBytes;
            mRxPackets = rxPackets;
            mTxPackets = txPackets;
            mAppUid = appUid;
        }

        TransferredBytes plus(TransferredBytes other) {
            return new TransferredBytes(this.mRxBytes + other.mRxBytes,
                    this.mTxBytes + other.mTxBytes, this.mRxPackets + other.mRxPackets,
                    this.mTxPackets + other.mTxPackets, other.mAppUid);
        }
    }

    @FunctionalInterface
    private interface ThrowingPredicate<S, T extends Throwable> {
        TransferredBytes accept(S s) throws T;
    }

    private void doTestDataUsageBytesTransferEnabled(boolean enable) throws Throwable {
        // Set value to enable/disable combine subtype.
        setNetworkStatsCombinedSubTypeEnabled(enable);

        doTestMobileBytesTransferThat(Atom.DATA_USAGE_BYTES_TRANSFER_FIELD_NUMBER, /*isUidAtom=*/
                false, (atom) -> {
                    final AtomsProto.DataUsageBytesTransfer data =
                            atom.getDataUsageBytesTransfer();
                    final boolean ratTypeEqualsToUnknown =
                            (data.getRatType() == NetworkTypeEnum.NETWORK_TYPE_UNKNOWN_VALUE);
                    final boolean ratTypeGreaterThanUnknown =
                            (data.getRatType() > NetworkTypeEnum.NETWORK_TYPE_UNKNOWN_VALUE);

                    if ((data.getState() == 1) // NetworkStats.SET_FOREGROUND
                            && ((enable && ratTypeEqualsToUnknown)
                            || (!enable && ratTypeGreaterThanUnknown))) {
                        // Assert that subscription info is valid.
                        assertSubscriptionInfo(data);
                        // DataUsageBytesTransferred atom does not report app uid.
                        return new TransferredBytes(data.getRxBytes(), data.getTxBytes(),
                                data.getRxPackets(), data.getTxPackets(), /*appUid=*/-1);
                    }
                    return null;
                });
    }

    private void doTestMobileBytesTransferThat(int atomId, boolean isUidAtom,
            ThrowingPredicate<Atom, Exception> p)
            throws Throwable {
        if (!DeviceUtils.hasFeature(getDevice(), FEATURE_TELEPHONY)) return;
        // Upload the config.
        final StatsdConfig.Builder config = ConfigUtils.createConfigBuilder(
                DeviceUtils.STATSD_ATOM_TEST_PKG);
        if (isUidAtom) {
            ConfigUtils.addGaugeMetricForUidAtom(config, atomId, /*uidInAttributionChain=*/false,
                    DeviceUtils.STATSD_ATOM_TEST_PKG);
        } else {
            ConfigUtils.addGaugeMetric(config, atomId);
        }
        ConfigUtils.uploadConfig(getDevice(), config);
        // Generate some mobile traffic.
        DeviceUtils.runDeviceTests(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG, "".AtomTests"",
                ""testGenerateMobileTraffic"");
        Thread.sleep(AtomTestUtils.WAIT_TIME_SHORT);
        // Force poll NetworkStatsService to get most updated network stats from lower layer.
        DeviceUtils.runActivity(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                ""PollNetworkStatsActivity"",
                /*actionKey=*/null, /*actionValue=*/null);
        Thread.sleep(AtomTestUtils.WAIT_TIME_SHORT);
        // Trigger atom pull.
        AtomTestUtils.sendAppBreadcrumbReportedAtom(getDevice());
        Thread.sleep(AtomTestUtils.WAIT_TIME_SHORT);
        final List<Atom> atoms = ReportUtils.getGaugeMetricAtoms(getDevice(),
                /*checkTimestampTruncated=*/true);
        assertThat(atoms.size()).isAtLeast(1);

        boolean foundAppStats = false;
        TransferredBytes transBytesSum = new TransferredBytes(0, 0, 0, 0, /*appUid=*/-1);

        for (final Atom atom : atoms) {
            TransferredBytes transferredBytes = p.accept(atom);
            if (transferredBytes != null) {
                foundAppStats = true;
                // Checks that the uid in the atom corresponds to the app uid and checks that the
                // bytes and packet data are as expected.
                if (isUidAtom) {
                    final int appUid = DeviceUtils.getAppUid(getDevice(),
                            DeviceUtils.STATSD_ATOM_TEST_PKG);
                    assertThat(transferredBytes.mAppUid).isEqualTo(appUid);
                }
                transBytesSum = transBytesSum.plus(transferredBytes);
            }
        }
        assertDataUsageAtomDataExpected(
                transBytesSum.mRxBytes, transBytesSum.mTxBytes,
                transBytesSum.mRxPackets, transBytesSum.mTxPackets);
        assertWithMessage(""Data for uid "" + DeviceUtils.getAppUid(getDevice(),
                DeviceUtils.STATSD_ATOM_TEST_PKG)
                + "" is not found in "" + atoms.size() + "" atoms."").that(foundAppStats).isTrue();
    }

    private void assertDataUsageAtomDataExpected(long rxb, long txb, long rxp, long txp) {
        assertThat(rxb).isGreaterThan(0L);
        assertThat(txb).isGreaterThan(0L);
        assertThat(rxp).isGreaterThan(0L);
        assertThat(txp).isGreaterThan(0L);
    }

    private void assertSubscriptionInfo(AtomsProto.DataUsageBytesTransfer data) {
        assertThat(data.getSimMcc()).matches(""^\\d{3}$"");
        assertThat(data.getSimMnc()).matches(""^\\d{2,3}$"");
        assertThat(data.getCarrierId()).isNotEqualTo(-1); // TelephonyManager#UNKNOWN_CARRIER_ID
    }

    private boolean getNetworkStatsCombinedSubTypeEnabled() throws Exception {
        final String output = getDevice().executeShellCommand(
                ""settings get global netstats_combine_subtype_enabled"").trim();
        return output.equals(""1"");
    }

    private void setNetworkStatsCombinedSubTypeEnabled(boolean enable) throws Exception {
        getDevice().executeShellCommand(""settings put global netstats_combine_subtype_enabled ""
                + (enable ? ""1"" : ""0""));
    }
}"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/net/BytesTransferredTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.cts.statsdatom.jobscheduler.JobSchedulerStatsTests"	"testScheduledJobState"	"CtsStatsdAtomHostTestCases"	"1: attribution"	"public void testScheduledJobState() throws Exception {
        final int atomTag = AtomsProto.Atom.SCHEDULED_JOB_STATE_CHANGED_FIELD_NUMBER;
        Set<Integer> jobSchedule = new HashSet<>(
                Arrays.asList(AtomsProto.ScheduledJobStateChanged.State.SCHEDULED_VALUE));
        Set<Integer> jobOn = new HashSet<>(
                Arrays.asList(AtomsProto.ScheduledJobStateChanged.State.STARTED_VALUE));
        Set<Integer> jobOff = new HashSet<>(
                Arrays.asList(AtomsProto.ScheduledJobStateChanged.State.FINISHED_VALUE));

        // Add state sets to the list in order.
        List<Set<Integer>> stateSet = Arrays.asList(jobSchedule, jobOn, jobOff);

        ConfigUtils.uploadConfigForPushedAtomWithUid(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                atomTag, /*useUidAttributionChain=*/true);
        DeviceUtils.allowImmediateSyncs(getDevice());
        DeviceUtils.runDeviceTestsOnStatsdApp(getDevice(), "".AtomTests"", ""testScheduledJob"");

        // Sorted list of events in order in which they occurred.
        List<StatsLog.EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());

        AtomTestUtils.assertStatesOccurred(stateSet, data, 0,
                atom -> atom.getScheduledJobStateChanged().getState().getNumber());

        for (StatsLog.EventMetricData e : data) {
            assertThat(e.getAtom().getScheduledJobStateChanged().getJobName())
                    .isEqualTo(JOB_NAME);
        }
    }
}"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/jobscheduler/JobSchedulerStatsTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.cts.statsdatom.statsd.ProcStateAtomTests"	"testForegroundService"	"CtsStatsdAtomHostTestCases"	"1: attribution"	"public void testForegroundService() throws Exception {
        Set<Integer> onStates = new HashSet<>(Arrays.asList(
                ProcessStateEnum.PROCESS_STATE_FOREGROUND_SERVICE_VALUE));
        Set<Integer> offStates = complement(onStates);

        List<Set<Integer>> stateSet = Arrays.asList(onStates, offStates); // state sets, in order
        ConfigUtils.uploadConfigForPushedAtomWithUid(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                PROC_STATE_ATOM_TAG, /*useUidAttributionChain=*/false);

        executeForegroundService(getDevice());
        final int waitTime = SLEEP_OF_FOREGROUND_SERVICE;
        Thread.sleep(waitTime + STATSD_REPORT_WAIT_TIME_MS + EXTRA_WAIT_TIME_MS);

        List<EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());
        AtomTestUtils.popUntilFind(data, onStates,
                PROC_STATE_FUNCTION); // clear out initial proc states.
        AtomTestUtils.assertStatesOccurred(stateSet, data, waitTime, PROC_STATE_FUNCTION);
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/statsd/ProcStateAtomTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.cts.statsdatom.statsd.ProcStateAtomTests"	"testForeground"	"CtsStatsdAtomHostTestCases"	"1: attribution"	"public void testForeground() throws Exception {
        Set<Integer> onStates = new HashSet<>(Arrays.asList(
                ProcessStateEnum.PROCESS_STATE_IMPORTANT_FOREGROUND_VALUE));
        // There are no offStates, since the app remains in foreground until killed.

        List<Set<Integer>> stateSet = Arrays.asList(onStates); // state sets, in order
        ConfigUtils.uploadConfigForPushedAtomWithUid(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                PROC_STATE_ATOM_TAG, /*useUidAttributionChain=*/false);

        executeForegroundActivity(getDevice(), ACTION_SHOW_APPLICATION_OVERLAY);
        final int waitTime = EXTRA_WAIT_TIME_MS + 5_000; // Overlay may need to sit there a while.
        Thread.sleep(waitTime + STATSD_REPORT_WAIT_TIME_MS);

        List<EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());
        AtomTestUtils.popUntilFind(data, onStates,
                PROC_STATE_FUNCTION); // clear out initial proc states.
        AtomTestUtils.assertStatesOccurred(stateSet, data, 0, PROC_STATE_FUNCTION);
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/statsd/ProcStateAtomTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.cts.statsdatom.statsd.ProcStateAtomTests"	"testBackground"	"CtsStatsdAtomHostTestCases"	"1: attribution"	"public void testBackground() throws Exception {
        Set<Integer> onStates = BG_STATES;
        Set<Integer> offStates = complement(onStates);

        List<Set<Integer>> stateSet = Arrays.asList(onStates, offStates); // state sets, in order
        ConfigUtils.uploadConfigForPushedAtomWithUid(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                PROC_STATE_ATOM_TAG, /*useUidAttributionChain=*/false);

        DeviceUtils.executeBackgroundService(getDevice(), ACTION_BACKGROUND_SLEEP);
        final int waitTime = SLEEP_OF_ACTION_BACKGROUND_SLEEP;
        Thread.sleep(waitTime + STATSD_REPORT_WAIT_TIME_MS + EXTRA_WAIT_TIME_MS);

        List<EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());
        AtomTestUtils.popUntilFind(data, onStates,
                PROC_STATE_FUNCTION); // clear out initial proc states.
        AtomTestUtils.assertStatesOccurred(stateSet, data, waitTime, PROC_STATE_FUNCTION);
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/statsd/ProcStateAtomTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.cts.statsdatom.statsd.ProcStateAtomTests"	"testTop"	"CtsStatsdAtomHostTestCases"	"1: attribution"	"public void testTop() throws Exception {
        Set<Integer> onStates = new HashSet<>(Arrays.asList(
                ProcessStateEnum.PROCESS_STATE_TOP_VALUE));
        Set<Integer> offStates = complement(onStates);

        List<Set<Integer>> stateSet = Arrays.asList(onStates, offStates); // state sets, in order
        ConfigUtils.uploadConfigForPushedAtomWithUid(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                PROC_STATE_ATOM_TAG, /*useUidAttributionChain=*/false);

        executeForegroundActivity(getDevice(), ACTION_SLEEP_WHILE_TOP);
        final int waitTime = SLEEP_OF_ACTION_SLEEP_WHILE_TOP;
        Thread.sleep(waitTime + STATSD_REPORT_WAIT_TIME_MS + EXTRA_WAIT_TIME_MS);

        List<EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());
        AtomTestUtils.popUntilFind(data, onStates,
                PROC_STATE_FUNCTION); // clear out initial proc states.
        AtomTestUtils.assertStatesOccurred(stateSet, data, waitTime, PROC_STATE_FUNCTION);
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/statsd/ProcStateAtomTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.cts.statsdatom.statsd.ProcStateAtomTests"	"testTopSleeping"	"CtsStatsdAtomHostTestCases"	"1: attribution"	"public void testTopSleeping() throws Exception {
        if (DeviceUtils.hasFeature(getDevice(), FEATURE_WATCH)) return;
        Set<Integer> onStates = new HashSet<>(Arrays.asList(
                ProcessStateEnum.PROCESS_STATE_TOP_SLEEPING_VALUE));
        Set<Integer> offStates = complement(onStates);

        List<Set<Integer>> stateSet = Arrays.asList(onStates, offStates); // state sets, in order
        ConfigUtils.uploadConfigForPushedAtomWithUid(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                PROC_STATE_ATOM_TAG, /*useUidAttributionChain=*/false);

        DeviceUtils.turnScreenOn(getDevice());
        Thread.sleep(WAIT_TIME_FOR_SCREEN_MS);

        executeForegroundActivity(getDevice(), ACTION_SLEEP_WHILE_TOP);
        // ASAP, turn off the screen to make proc state -> top_sleeping.
        DeviceUtils.turnScreenOff(getDevice());
        final int waitTime = SLEEP_OF_ACTION_SLEEP_WHILE_TOP + EXTRA_WAIT_TIME_MS;
        Thread.sleep(waitTime + STATSD_REPORT_WAIT_TIME_MS);

        List<EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());
        AtomTestUtils.popUntilFind(data,
                new HashSet<>(Arrays.asList(ProcessStateEnum.PROCESS_STATE_TOP_VALUE)),
                PROC_STATE_FUNCTION); // clear out anything prior to it entering TOP.
        AtomTestUtils.popUntilFind(data, onStates, PROC_STATE_FUNCTION); // clear out TOP itself.
        // reset screen back on
        DeviceUtils.turnScreenOn(getDevice());
        // Don't check the wait time, since it's up to the system how long top sleeping persists.
        AtomTestUtils.assertStatesOccurred(stateSet, data, 0, PROC_STATE_FUNCTION);
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/statsd/ProcStateAtomTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.cts.statsdatom.statsd.ProcStateAtomTests"	"testCached"	"CtsStatsdAtomHostTestCases"	"1: attribution"	"public void testCached() throws Exception {
        Set<Integer> onStates = CACHED_STATES;
        Set<Integer> offStates = complement(onStates);

        List<Set<Integer>> stateSet = Arrays.asList(onStates, offStates); // state sets, in order
        ConfigUtils.uploadConfigForPushedAtomWithUid(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                PROC_STATE_ATOM_TAG, /*useUidAttributionChain=*/false);

        // The schedule is as follows
        // #1. The system may do anything it wants, such as moving the app into a cache state.
        // #2. We move the app into the background.
        // #3. The background process ends, so the app definitely moves to a cache state
        //          (this is the ultimate goal of the test).
        // #4. We start a foreground activity, moving the app out of cache.

        // Start extremely short-lived activity, so app goes into cache state (#1 - #3 above).
        DeviceUtils.executeBackgroundService(getDevice(), ACTION_END_IMMEDIATELY);
        final int cacheTime = 2_000; // process should be in cached state for up to this long
        Thread.sleep(cacheTime);
        // Now forcibly bring the app out of cache (#4 above).
        executeForegroundActivity(getDevice(), ACTION_SHOW_APPLICATION_OVERLAY);
        // Now check the data *before* the app enters cache again (to avoid another cache event).

        List<EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());
        // First, clear out any incidental cached states of step #1, prior to step #2.
        AtomTestUtils.popUntilFind(data, BG_STATES, PROC_STATE_FUNCTION);
        // Now clear out the bg state from step #2 (since we are interested in the cache after it).
        AtomTestUtils.popUntilFind(data, onStates, PROC_STATE_FUNCTION);
        // The result is that data should start at step #3, definitively in a cached state.
        AtomTestUtils.assertStatesOccurred(stateSet, data, 1_000, PROC_STATE_FUNCTION);
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/statsd/ProcStateAtomTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.cts.statsdatom.statsd.UidAtomTests"	"isNotNull"	"CtsStatsdAtomHostTestCases"	"1: attribution"	"public void test/*
 *.
 */
package android.cts.statsdatom.statsd;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import android.app.AppOpEnum;
import android.cts.statsdatom.lib.AtomTestUtils;
import android.cts.statsdatom.lib.ConfigUtils;
import android.cts.statsdatom.lib.DeviceUtils;
import android.cts.statsdatom.lib.ReportUtils;
import android.os.WakeLockLevelEnum;
import android.server.ErrorSource;

import com.android.compatibility.common.util.PropertyUtil;
import com.android.internal.os.StatsdConfigProto.FieldValueMatcher;
import com.android.internal.os.StatsdConfigProto.StatsdConfig;
import com.android.os.AtomsProto.ANROccurred;
import com.android.os.AtomsProto.AppBreadcrumbReported;
import com.android.os.AtomsProto.AppCrashOccurred;
import com.android.os.AtomsProto.AppUsageEventOccurred;
import com.android.os.AtomsProto.Atom;
import com.android.os.AtomsProto.AttributionNode;
import com.android.os.AtomsProto.AudioStateChanged;
import com.android.os.AtomsProto.CameraStateChanged;
import com.android.os.AtomsProto.DeviceCalculatedPowerBlameUid;
import com.android.os.AtomsProto.FlashlightStateChanged;
import com.android.os.AtomsProto.ForegroundServiceAppOpSessionEnded;
import com.android.os.AtomsProto.ForegroundServiceStateChanged;
import com.android.os.AtomsProto.GpsScanStateChanged;
import com.android.os.AtomsProto.LmkKillOccurred;
import com.android.os.AtomsProto.MediaCodecStateChanged;
import com.android.os.AtomsProto.OverlayStateChanged;
import com.android.os.AtomsProto.SyncStateChanged;
import com.android.os.AtomsProto.TestAtomReported;
import com.android.os.AtomsProto.UiEventReported;
import com.android.os.AtomsProto.VibratorStateChanged;
import com.android.os.AtomsProto.WakelockStateChanged;
import com.android.os.StatsLog.EventMetricData;
import com.android.tradefed.build.IBuildInfo;
import com.android.tradefed.log.LogUtil;
import com.android.tradefed.testtype.DeviceTestCase;
import com.android.tradefed.testtype.IBuildReceiver;
import com.android.tradefed.util.Pair;

import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.function.Function;
import java.util.stream.Collectors;

/**
 * Statsd atom tests that are done via app, for atoms that report a uid.
 */
public class UidAtomTests extends DeviceTestCase implements IBuildReceiver {

    private static final String TAG = ""Statsd.UidAtomTests"";

    private static final String TEST_PACKAGE_NAME = ""com.android.server.cts.device.statsd"";

    private static final String ACTION_SHOW_APPLICATION_OVERLAY = ""action.show_application_overlay"";

    private static final String FEATURE_AUDIO_OUTPUT = ""android.hardware.audio.output"";
    private static final String FEATURE_CAMERA = ""android.hardware.camera"";
    private static final String FEATURE_CAMERA_FLASH = ""android.hardware.camera.flash"";
    private static final String FEATURE_CAMERA_FRONT = ""android.hardware.camera.front"";
    private static final String FEATURE_LEANBACK_ONLY = ""android.software.leanback_only"";
    private static final String FEATURE_LOCATION_GPS = ""android.hardware.location.gps"";
    private static final String FEATURE_PICTURE_IN_PICTURE = ""android.software.picture_in_picture"";
    private static final String FEATURE_TV = ""android.hardware.type.television"";

    private IBuildInfo mCtsBuild;

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        assertThat(mCtsBuild).isNotNull();
        ConfigUtils.removeConfig(getDevice());
        ReportUtils.clearReports(getDevice());
        DeviceUtils.installStatsdTestApp(getDevice(), mCtsBuild);
        Thread.sleep(AtomTestUtils.WAIT_TIME_LONG);
    }

    @Override
    protected void tearDown() throws Exception {
        ConfigUtils.removeConfig(getDevice());
        ReportUtils.clearReports(getDevice());
        DeviceUtils.uninstallStatsdTestApp(getDevice());
        super.tearDown();
    }

    @Override
    public void setBuild(IBuildInfo buildInfo) {
        mCtsBuild = buildInfo;
    }

    /**
     * Tests that statsd correctly maps isolated uids to host uids by verifying that atoms logged
     * from an isolated process are seen as coming from their host process.
     */"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/statsd/UidAtomTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.cts.statsdatom.statsd.UidAtomTests"	"testIsolatedToHostUidMapping"	"CtsStatsdAtomHostTestCases"	"1: attribution"	"public void testIsolatedToHostUidMapping() throws Exception {
        ConfigUtils.uploadConfigForPushedAtomWithUid(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                Atom.APP_BREADCRUMB_REPORTED_FIELD_NUMBER, /*uidInAttributionChain=*/false);

        // Create an isolated service from which an AppBreadcrumbReported atom is logged.
        DeviceUtils.runDeviceTestsOnStatsdApp(getDevice(), "".AtomTests"",
                ""testIsolatedProcessService"");

        // Verify correctness of data.
        List<EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());
        assertThat(data).hasSize(1);
        AppBreadcrumbReported atom = data.get(0).getAtom().getAppBreadcrumbReported();
        assertThat(atom.getUid()).isEqualTo(DeviceUtils.getStatsdTestAppUid(getDevice()));
        assertThat(atom.getLabel()).isEqualTo(0);
        assertThat(atom.getState()).isEqualTo(AppBreadcrumbReported.State.START);
    }

    private boolean shouldTestLmkdStats() throws Exception {
        boolean hasKernel = DeviceUtils.isKernelGreaterEqual(getDevice(), Pair.create(4, 19));
        boolean hasFirstApiLevel = PropertyUtil.getFirstApiLevel(getDevice()) > 30;
        return (hasKernel && hasFirstApiLevel)
                || ""true"".equals(DeviceUtils.getProperty(getDevice(), ""ro.lmk.log_stats""));
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/statsd/UidAtomTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.cts.statsdatom.statsd.UidAtomTests"	"testLmkKillOccurred"	"CtsStatsdAtomHostTestCases"	"1: attribution"	"public void testLmkKillOccurred() throws Exception {
        if (!shouldTestLmkdStats()) {
            LogUtil.CLog.d(""Skipping lmkd stats test."");
            return;
        }

        ConfigUtils.uploadConfigForPushedAtomWithUid(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                Atom.LMK_KILL_OCCURRED_FIELD_NUMBER,  /*uidInAttributionChain=*/false);
        int appUid = DeviceUtils.getStatsdTestAppUid(getDevice());

        // Start the victim process (service running in process :lmk_victim)
        // We rely on a victim process (instead of expecting the allocating process to die)
        // because 1. it is likely to be less flaky (higher oom score processes will be killed
        // faster, making less likely for the OOM reaper to trigger and 2. we need two processes
        // to be able to force evictions on 32-bit userspace devices with > 4 GB RAM.
        DeviceUtils.executeServiceAction(getDevice(), ""LmkVictimBackgroundService"",
                ""action.allocate_memory"");
        // Start fg activity and allocate
        try (AutoCloseable a = DeviceUtils.withActivity(
                getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                ""StatsdCtsForegroundActivity"", ""action"", ""action.lmk"")) {
            // Sorted list of events in order in which they occurred.
            List<LmkKillOccurred> atoms = null;
            for (int i = 0; i < 60; ++i) {
                Thread.sleep(1_000);
                atoms = ReportUtils.getEventMetricDataList(getDevice()).stream()
                        .map(EventMetricData::getAtom)
                        .filter(Atom::hasLmkKillOccurred)
                        .map(Atom::getLmkKillOccurred)
                        .filter(atom -> atom.getUid() == appUid)
                        .collect(Collectors.toList());
                if (!atoms.isEmpty()) {
                  break;
                }
            }

            assertThat(atoms).isNotEmpty();
            // Even though both processes might have died, the non-fg one (victim)
            // must have been first.
            assertThat(atoms.get(0).getProcessName())
                    .isEqualTo(DeviceUtils.STATSD_ATOM_TEST_PKG + "":lmk_victim"");
            assertThat(atoms.get(0).getOomAdjScore()).isGreaterThan(0);
            assertThat(atoms.get(0).getRssInBytes() + atoms.get(0).getSwapInBytes())
                    .isGreaterThan(0);
      }
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/statsd/UidAtomTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.cts.statsdatom.statsd.UidAtomTests"	"testAppCrashOccurred"	"CtsStatsdAtomHostTestCases"	"1: attribution"	"public void testAppCrashOccurred() throws Exception {
        final int atomTag = Atom.APP_CRASH_OCCURRED_FIELD_NUMBER;
        ConfigUtils.uploadConfigForPushedAtomWithUid(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                atomTag,  /*uidInAttributionChain=*/false);

        DeviceUtils.runActivity(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                ""StatsdCtsForegroundActivity"", ""action"", ""action.crash"");

        // Sorted list of events in order in which they occurred.
        List<EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());

        assertThat(data).hasSize(1);
        AppCrashOccurred atom = data.get(0).getAtom().getAppCrashOccurred();
        // UID should belong to the run activity, not any system service.
        assertThat(atom.getUid()).isGreaterThan(10000);
        assertThat(atom.getEventType()).isEqualTo(""crash"");
        assertThat(atom.getIsInstantApp().getNumber())
                .isEqualTo(AppCrashOccurred.InstantApp.FALSE_VALUE);
        assertThat(atom.getForegroundState().getNumber())
                .isEqualTo(AppCrashOccurred.ForegroundState.FOREGROUND_VALUE);
        assertThat(atom.getPackageName()).isEqualTo(DeviceUtils.STATSD_ATOM_TEST_PKG);
        assertThat(atom.getErrorSource()).isEqualTo(ErrorSource.DATA_APP);
        assertFalse(atom.getIsIncremental());
        assertTrue((1 - atom.getLoadingProgress()) < 0.001);
        assertEquals(-1, atom.getMillisSinceOldestPendingRead());
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/statsd/UidAtomTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.cts.statsdatom.statsd.UidAtomTests"	"testAppCrashOccurredNative"	"CtsStatsdAtomHostTestCases"	"1: attribution"	"public void testAppCrashOccurredNative() throws Exception {
        if (DeviceUtils.hasFeature(getDevice(), FEATURE_TV)
                && DeviceUtils.isDebuggable(getDevice())) {
            // Skip TVs that are debuggable because ActivityManager does not properly terminate
            // the activity in the event of a native crash.
            return;
        }
        final int atomTag = Atom.APP_CRASH_OCCURRED_FIELD_NUMBER;
        ConfigUtils.uploadConfigForPushedAtomWithUid(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                atomTag,  /*uidInAttributionChain=*/false);

        DeviceUtils.runActivity(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                ""StatsdCtsForegroundActivity"", ""action"", ""action.native_crash"");

        // Sorted list of events in order in which they occurred.
        List<EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());

        assertThat(data).hasSize(1);
        AppCrashOccurred atom = data.get(0).getAtom().getAppCrashOccurred();
        // UID should belong to the run activity, not any system service.
        assertThat(atom.getUid()).isGreaterThan(10000);
        assertThat(atom.getEventType()).isEqualTo(""native_crash"");
        assertThat(atom.getIsInstantApp().getNumber())
                .isEqualTo(AppCrashOccurred.InstantApp.FALSE_VALUE);
        assertThat(atom.getForegroundState().getNumber())
                .isEqualTo(AppCrashOccurred.ForegroundState.FOREGROUND_VALUE);
        assertThat(atom.getPackageName()).isEqualTo(DeviceUtils.STATSD_ATOM_TEST_PKG);
        assertThat(atom.getErrorSource()).isEqualTo(ErrorSource.DATA_APP);
        // TODO(b/172866626): add tests for incremental packages that crashed during loading
        assertFalse(atom.getIsIncremental());
        assertTrue((1 - atom.getLoadingProgress()) < 0.001);
        assertEquals(-1, atom.getMillisSinceOldestPendingRead());
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/statsd/UidAtomTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.cts.statsdatom.statsd.UidAtomTests"	"testAudioState"	"CtsStatsdAtomHostTestCases"	"1: attribution"	"public void testAudioState() throws Exception {
        if (!DeviceUtils.hasFeature(getDevice(), FEATURE_AUDIO_OUTPUT)) return;

        final int atomTag = Atom.AUDIO_STATE_CHANGED_FIELD_NUMBER;
        final String name = ""testAudioState"";

        Set<Integer> onState = new HashSet<>(
                Arrays.asList(AudioStateChanged.State.ON_VALUE));
        Set<Integer> offState = new HashSet<>(
                Arrays.asList(AudioStateChanged.State.OFF_VALUE));

        // Add state sets to the list in order.
        List<Set<Integer>> stateSet = Arrays.asList(onState, offState);

        ConfigUtils.uploadConfigForPushedAtomWithUid(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                atomTag,  /*uidInAttributionChain=*/true);

        DeviceUtils.runDeviceTestsOnStatsdApp(getDevice(), "".AtomTests"", name);

        Thread.sleep(AtomTestUtils.WAIT_TIME_SHORT);
        // Sorted list of events in order in which they occurred.
        List<EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());

        // Because the timestamp is truncated, we skip checking time differences between state
        // changes.
        AtomTestUtils.assertStatesOccurred(stateSet, data, 0,
                atom -> atom.getAudioStateChanged().getState().getNumber());

        // Check that timestamp is truncated
        for (EventMetricData metric : data) {
            long elapsedTimestampNs = metric.getElapsedTimestampNanos();
            AtomTestUtils.assertTimestampIsTruncated(elapsedTimestampNs);
        }
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/statsd/UidAtomTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.cts.statsdatom.statsd.UidAtomTests"	"testCameraState"	"CtsStatsdAtomHostTestCases"	"1: attribution"	"public void testCameraState() throws Exception {
        if (!DeviceUtils.hasFeature(getDevice(), FEATURE_CAMERA) && !DeviceUtils.hasFeature(
                getDevice(), FEATURE_CAMERA_FRONT)) {
            return;
        }

        final int atomTag = Atom.CAMERA_STATE_CHANGED_FIELD_NUMBER;
        Set<Integer> cameraOn = new HashSet<>(Arrays.asList(CameraStateChanged.State.ON_VALUE));
        Set<Integer> cameraOff = new HashSet<>(Arrays.asList(CameraStateChanged.State.OFF_VALUE));

        // Add state sets to the list in order.
        List<Set<Integer>> stateSet = Arrays.asList(cameraOn, cameraOff);
        ConfigUtils.uploadConfigForPushedAtomWithUid(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                atomTag, /*useAttributionChain=*/ true);

        DeviceUtils.runDeviceTestsOnStatsdApp(getDevice(), "".AtomTests"", ""testCameraState"");

        // Sorted list of events in order in which they occurred.
        List<EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());

        // Assert that the events happened in the expected order.
        AtomTestUtils.assertStatesOccurred(stateSet, data, AtomTestUtils.WAIT_TIME_LONG,
                atom -> atom.getCameraStateChanged().getState().getNumber());
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/statsd/UidAtomTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.cts.statsdatom.statsd.UidAtomTests"	"testFlashlightState"	"CtsStatsdAtomHostTestCases"	"1: attribution"	"public void testFlashlightState() throws Exception {
        if (!DeviceUtils.hasFeature(getDevice(), FEATURE_CAMERA_FLASH)) return;

        final int atomTag = Atom.FLASHLIGHT_STATE_CHANGED_FIELD_NUMBER;
        final String name = ""testFlashlight"";

        Set<Integer> flashlightOn = new HashSet<>(
                Arrays.asList(FlashlightStateChanged.State.ON_VALUE));
        Set<Integer> flashlightOff = new HashSet<>(
                Arrays.asList(FlashlightStateChanged.State.OFF_VALUE));

        // Add state sets to the list in order.
        List<Set<Integer>> stateSet = Arrays.asList(flashlightOn, flashlightOff);

        ConfigUtils.uploadConfigForPushedAtomWithUid(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                atomTag, /*useUidAttributionChain=*/true);

        DeviceUtils.runDeviceTestsOnStatsdApp(getDevice(), "".AtomTests"", name);

        // Sorted list of events in order in which they occurred.
        List<EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());

        // Assert that the events happened in the expected order.
        AtomTestUtils.assertStatesOccurred(stateSet, data, AtomTestUtils.WAIT_TIME_SHORT,
                atom -> atom.getFlashlightStateChanged().getState().getNumber());
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/statsd/UidAtomTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.cts.statsdatom.statsd.UidAtomTests"	"testForegroundServiceState"	"CtsStatsdAtomHostTestCases"	"1: attribution"	"public void testForegroundServiceState() throws Exception {
        final int atomTag = Atom.FOREGROUND_SERVICE_STATE_CHANGED_FIELD_NUMBER;
        final String name = ""testForegroundService"";

        Set<Integer> enterForeground = new HashSet<>(
                Arrays.asList(ForegroundServiceStateChanged.State.ENTER_VALUE));
        Set<Integer> exitForeground = new HashSet<>(
                Arrays.asList(ForegroundServiceStateChanged.State.EXIT_VALUE));

        // Add state sets to the list in order.
        List<Set<Integer>> stateSet = Arrays.asList(enterForeground, exitForeground);

        ConfigUtils.uploadConfigForPushedAtomWithUid(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                atomTag, /*useUidAttributionChain=*/false);

        DeviceUtils.runDeviceTestsOnStatsdApp(getDevice(), "".AtomTests"", name);

        // Sorted list of events in order in which they occurred.
        List<EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());

        // Assert that the events happened in the expected order.
        AtomTestUtils.assertStatesOccurred(stateSet, data, AtomTestUtils.WAIT_TIME_SHORT,
                atom -> atom.getForegroundServiceStateChanged().getState().getNumber());
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/statsd/UidAtomTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.cts.statsdatom.statsd.UidAtomTests"	"testForegroundServiceAccessAppOp"	"CtsStatsdAtomHostTestCases"	"1: attribution"	"public void testForegroundServiceAccessAppOp() throws Exception {
        final int atomTag = Atom.FOREGROUND_SERVICE_APP_OP_SESSION_ENDED_FIELD_NUMBER;
        final String name = ""testForegroundServiceAccessAppOp"";

        ConfigUtils.uploadConfigForPushedAtomWithUid(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                atomTag, /*useUidAttributionChain=*/false);

        DeviceUtils.runDeviceTestsOnStatsdApp(getDevice(), "".AtomTests"", name);

        // Sorted list of events in order in which they occurred.
        List<EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());

        assertWithMessage(""Wrong atom size"").that(data.size()).isEqualTo(3);
        for (int i = 0; i < data.size(); i++) {
            ForegroundServiceAppOpSessionEnded atom
                    = data.get(i).getAtom().getForegroundServiceAppOpSessionEnded();
            final int opName = atom.getAppOpName().getNumber();
            final int acceptances = atom.getCountOpsAccepted();
            final int rejections = atom.getCountOpsRejected();
            final int count = acceptances + rejections;
            int expectedCount = 0;
            switch (opName) {
                case AppOpEnum.APP_OP_CAMERA_VALUE:
                    expectedCount = 3;
                    break;
                case AppOpEnum.APP_OP_FINE_LOCATION_VALUE:
                    expectedCount = 1;
                    break;
                case AppOpEnum.APP_OP_RECORD_AUDIO_VALUE:
                    expectedCount = 2;
                    break;
                case AppOpEnum.APP_OP_COARSE_LOCATION_VALUE:
                    // fall-through
                default:
                    fail(""Unexpected opName "" + opName);
            }
            assertWithMessage(""Wrong count for "" + opName).that(count).isEqualTo(expectedCount);
        }
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/statsd/UidAtomTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.cts.statsdatom.statsd.UidAtomTests"	"testGpsScan"	"CtsStatsdAtomHostTestCases"	"1: attribution"	"public void testGpsScan() throws Exception {
        if (!DeviceUtils.hasFeature(getDevice(), FEATURE_LOCATION_GPS)) return;
        // Whitelist this app against background location request throttling
        String origWhitelist = getDevice().executeShellCommand(
                ""settings get global location_background_throttle_package_whitelist"").trim();
        getDevice().executeShellCommand(String.format(
                ""settings put global location_background_throttle_package_whitelist %s"",
                DeviceUtils.STATSD_ATOM_TEST_PKG));

        try {
            final int atom = Atom.GPS_SCAN_STATE_CHANGED_FIELD_NUMBER;
            final int key = GpsScanStateChanged.STATE_FIELD_NUMBER;
            final int stateOn = GpsScanStateChanged.State.ON_VALUE;
            final int stateOff = GpsScanStateChanged.State.OFF_VALUE;
            final int minTimeDiffMillis = 500;
            final int maxTimeDiffMillis = 60_000;

            ConfigUtils.uploadConfigForPushedAtomWithUid(getDevice(),
                    DeviceUtils.STATSD_ATOM_TEST_PKG,
                    atom, /*useUidAttributionChain=*/true);

            DeviceUtils.runDeviceTestsOnStatsdApp(getDevice(), "".AtomTests"",
                    ""testGpsScan"");

            List<EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());
            assertThat(data).hasSize(2);
            GpsScanStateChanged a0 = data.get(0).getAtom().getGpsScanStateChanged();
            GpsScanStateChanged a1 = data.get(1).getAtom().getGpsScanStateChanged();
            AtomTestUtils.assertTimeDiffBetween(data.get(0), data.get(1), minTimeDiffMillis,
                    maxTimeDiffMillis);
            assertThat(a0.getState().getNumber()).isEqualTo(stateOn);
            assertThat(a1.getState().getNumber()).isEqualTo(stateOff);
        } finally {
            if (""null"".equals(origWhitelist) || """".equals(origWhitelist)) {
                getDevice().executeShellCommand(
                        ""settings delete global location_background_throttle_package_whitelist"");
            } else {
                getDevice().executeShellCommand(String.format(
                        ""settings put global location_background_throttle_package_whitelist %s"",
                        origWhitelist));
            }
        }
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/statsd/UidAtomTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.cts.statsdatom.statsd.UidAtomTests"	"testMediaCodecActivity"	"CtsStatsdAtomHostTestCases"	"1: attribution"	"public void testMediaCodecActivity() throws Exception {
        if (DeviceUtils.hasFeature(getDevice(), DeviceUtils.FEATURE_WATCH)) return;
        final int atomTag = Atom.MEDIA_CODEC_STATE_CHANGED_FIELD_NUMBER;

        // 5 seconds. Starting video tends to be much slower than most other
        // tests on slow devices. This is unfortunate, because it leaves a
        // really big slop in assertStatesOccurred.  It would be better if
        // assertStatesOccurred had a tighter range on large timeouts.
        final int waitTime = 5000;

        // From {@link VideoPlayerActivity#DELAY_MILLIS}
        final int videoDuration = 2000;

        Set<Integer> onState = new HashSet<>(
                Arrays.asList(MediaCodecStateChanged.State.ON_VALUE));
        Set<Integer> offState = new HashSet<>(
                Arrays.asList(MediaCodecStateChanged.State.OFF_VALUE));

        // Add state sets to the list in order.
        List<Set<Integer>> stateSet = Arrays.asList(onState, offState);

        ConfigUtils.uploadConfigForPushedAtomWithUid(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                atomTag, /*useUidAttributionChain=*/true);

        DeviceUtils.runActivity(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                ""VideoPlayerActivity"", ""action"", ""action.play_video"",
                waitTime);

        // Sorted list of events in order in which they occurred.
        List<EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());

        // Assert that the events happened in the expected order.
        AtomTestUtils.assertStatesOccurred(stateSet, data, videoDuration,
                atom -> atom.getMediaCodecStateChanged().getState().getNumber());
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/statsd/UidAtomTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.cts.statsdatom.statsd.UidAtomTests"	"testOverlayState"	"CtsStatsdAtomHostTestCases"	"1: attribution"	"public void testOverlayState() throws Exception {
        if (DeviceUtils.hasFeature(getDevice(), DeviceUtils.FEATURE_WATCH)) return;
        final int atomTag = Atom.OVERLAY_STATE_CHANGED_FIELD_NUMBER;

        Set<Integer> entered = new HashSet<>(
                Arrays.asList(OverlayStateChanged.State.ENTERED_VALUE));
        Set<Integer> exited = new HashSet<>(
                Arrays.asList(OverlayStateChanged.State.EXITED_VALUE));

        // Add state sets to the list in order.
        List<Set<Integer>> stateSet = Arrays.asList(entered, exited);

        ConfigUtils.uploadConfigForPushedAtomWithUid(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                atomTag, /*useUidAttributionChain=*/false);

        DeviceUtils.runActivity(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                ""StatsdCtsForegroundActivity"", ""action"", ""action.show_application_overlay"",
                5_000);

        // Sorted list of events in order in which they occurred.
        List<EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());

        // Assert that the events happened in the expected order.
        // The overlay box should appear about 2sec after the app start
        AtomTestUtils.assertStatesOccurred(stateSet, data, 0,
                atom -> atom.getOverlayStateChanged().getState().getNumber());
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/statsd/UidAtomTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.cts.statsdatom.statsd.UidAtomTests"	"testPictureInPictureState"	"CtsStatsdAtomHostTestCases"	"1: attribution"	"public void testPictureInPictureState() throws Exception {
        String supported = getDevice().executeShellCommand(""am supports-multiwindow"");
        if (DeviceUtils.hasFeature(getDevice(), DeviceUtils.FEATURE_WATCH) ||
                !DeviceUtils.hasFeature(getDevice(), FEATURE_PICTURE_IN_PICTURE) ||
                !supported.contains(""true"")) {
            LogUtil.CLog.d(""Skipping picture in picture atom test."");
            return;
        }

        StatsdConfig.Builder config = ConfigUtils.createConfigBuilder(
                DeviceUtils.STATSD_ATOM_TEST_PKG);
        FieldValueMatcher.Builder uidFvm = ConfigUtils.createUidFvm(/*uidInAttributionChain=*/false,
                DeviceUtils.STATSD_ATOM_TEST_PKG);

        // PictureInPictureStateChanged atom is used prior to rvc-qpr
        ConfigUtils.addEventMetric(config, Atom.PICTURE_IN_PICTURE_STATE_CHANGED_FIELD_NUMBER,
                Collections.singletonList(uidFvm));
        // Picture-in-picture logs' been migrated to UiEvent since rvc-qpr
        FieldValueMatcher.Builder pkgMatcher = ConfigUtils.createFvm(
                UiEventReported.PACKAGE_NAME_FIELD_NUMBER)
                .setEqString(DeviceUtils.STATSD_ATOM_TEST_PKG);
        ConfigUtils.addEventMetric(config, Atom.UI_EVENT_REPORTED_FIELD_NUMBER,
                Arrays.asList(pkgMatcher));
        ConfigUtils.uploadConfig(getDevice(), config);

        LogUtil.CLog.d(""Playing video in Picture-in-Picture mode"");
        DeviceUtils.runActivity(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                ""VideoPlayerActivity"", ""action"", ""action.play_video_picture_in_picture_mode"");

        // Sorted list of events in order in which they occurred.
        List<EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());

        // Filter out the PictureInPictureStateChanged and UiEventReported atom
        List<EventMetricData> pictureInPictureStateChangedData = data.stream()
                .filter(e -> e.getAtom().hasPictureInPictureStateChanged())
                .collect(Collectors.toList());
        List<EventMetricData> uiEventReportedData = data.stream()
                .filter(e -> e.getAtom().hasUiEventReported())
                .collect(Collectors.toList());

        assertThat(pictureInPictureStateChangedData).isEmpty();
        assertThat(uiEventReportedData).isNotEmpty();

        // See PipUiEventEnum for definitions
        final int enterPipEventId = 603;
        // Assert that log for entering PiP happens exactly once, we do not use
        // assertStateOccurred here since PiP may log something else when activity finishes.
        List<EventMetricData> entered = uiEventReportedData.stream()
                .filter(e -> e.getAtom().getUiEventReported().getEventId() == enterPipEventId)
                .collect(Collectors.toList());
        assertThat(entered).hasSize(1);
    }

    //Note: this test does not have uid, but must run on the device"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/statsd/UidAtomTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.cts.statsdatom.statsd.UidAtomTests"	"testSyncState"	"CtsStatsdAtomHostTestCases"	"1: attribution"	"public void testSyncState() throws Exception {
        final int atomTag = Atom.SYNC_STATE_CHANGED_FIELD_NUMBER;
        Set<Integer> syncOn = new HashSet<>(Arrays.asList(SyncStateChanged.State.ON_VALUE));
        Set<Integer> syncOff = new HashSet<>(Arrays.asList(SyncStateChanged.State.OFF_VALUE));

        // Add state sets to the list in order.
        List<Set<Integer>> stateSet = Arrays.asList(syncOn, syncOff, syncOn, syncOff);

        ConfigUtils.uploadConfigForPushedAtomWithUid(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                atomTag, /*useUidAttributionChain=*/true);
        DeviceUtils.allowImmediateSyncs(getDevice());
        DeviceUtils.runDeviceTestsOnStatsdApp(getDevice(), "".AtomTests"", ""testSyncState"");

        // Sorted list of events in order in which they occurred.
        List<EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());

        // Assert that the events happened in the expected order.
        AtomTestUtils.assertStatesOccurred(stateSet, data,
                /* wait = */ 0 /* don't verify time differences between state changes */,
                atom -> atom.getSyncStateChanged().getState().getNumber());
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/statsd/UidAtomTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.cts.statsdatom.statsd.UidAtomTests"	"testVibratorState"	"CtsStatsdAtomHostTestCases"	"1: attribution"	"public void testVibratorState() throws Exception {
        if (!DeviceUtils.checkDeviceFor(getDevice(), ""checkVibratorSupported"")) return;

        final int atomTag = Atom.VIBRATOR_STATE_CHANGED_FIELD_NUMBER;
        final String name = ""testVibratorState"";

        Set<Integer> onState = new HashSet<>(
                Arrays.asList(VibratorStateChanged.State.ON_VALUE));
        Set<Integer> offState = new HashSet<>(
                Arrays.asList(VibratorStateChanged.State.OFF_VALUE));

        // Add state sets to the list in order.
        List<Set<Integer>> stateSet = Arrays.asList(onState, offState);

        ConfigUtils.uploadConfigForPushedAtomWithUid(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                atomTag, /*useUidAttributionChain=*/true);

        DeviceUtils.runDeviceTestsOnStatsdApp(getDevice(), "".AtomTests"", name);

        Thread.sleep(AtomTestUtils.WAIT_TIME_LONG);
        // Sorted list of events in order in which they occurred.
        List<EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());

        AtomTestUtils.assertStatesOccurred(stateSet, data, 300,
                atom -> atom.getVibratorStateChanged().getState().getNumber());
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/statsd/UidAtomTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.cts.statsdatom.statsd.UidAtomTests"	"testWakelockState"	"CtsStatsdAtomHostTestCases"	"1: attribution"	"public void testWakelockState() throws Exception {
        final int atomTag = Atom.WAKELOCK_STATE_CHANGED_FIELD_NUMBER;
        Set<Integer> wakelockOn = new HashSet<>(Arrays.asList(
                WakelockStateChanged.State.ACQUIRE_VALUE,
                WakelockStateChanged.State.CHANGE_ACQUIRE_VALUE));
        Set<Integer> wakelockOff = new HashSet<>(Arrays.asList(
                WakelockStateChanged.State.RELEASE_VALUE,
                WakelockStateChanged.State.CHANGE_RELEASE_VALUE));

        final String EXPECTED_TAG = ""StatsdPartialWakelock"";
        final WakeLockLevelEnum EXPECTED_LEVEL = WakeLockLevelEnum.PARTIAL_WAKE_LOCK;

        // Add state sets to the list in order.
        List<Set<Integer>> stateSet = Arrays.asList(wakelockOn, wakelockOff);

        ConfigUtils.uploadConfigForPushedAtomWithUid(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                atomTag, /*useUidAttributionChain=*/true);
        DeviceUtils.runDeviceTestsOnStatsdApp(getDevice(), "".AtomTests"", ""testWakelockState"");

        // Sorted list of events in order in which they occurred.
        List<EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());

        // Assert that the events happened in the expected order.
        AtomTestUtils.assertStatesOccurred(stateSet, data, AtomTestUtils.WAIT_TIME_SHORT,
                atom -> atom.getWakelockStateChanged().getState().getNumber());

        for (EventMetricData event : data) {
            String tag = event.getAtom().getWakelockStateChanged().getTag();
            WakeLockLevelEnum type = event.getAtom().getWakelockStateChanged().getType();
            assertThat(tag).isEqualTo(EXPECTED_TAG);
            assertThat(type).isEqualTo(EXPECTED_LEVEL);
        }
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/statsd/UidAtomTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.cts.statsdatom.statsd.UidAtomTests"	"testANROccurred"	"CtsStatsdAtomHostTestCases"	"1: attribution"	"public void testANROccurred() throws Exception {
        final int atomTag = Atom.ANR_OCCURRED_FIELD_NUMBER;
        ConfigUtils.uploadConfigForPushedAtomWithUid(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                atomTag, /*useUidAttributionChain=*/false);

        try (AutoCloseable a = DeviceUtils.withActivity(getDevice(),
                DeviceUtils.STATSD_ATOM_TEST_PKG, ""ANRActivity"", null, null)) {
            Thread.sleep(AtomTestUtils.WAIT_TIME_LONG * 2);
            getDevice().executeShellCommand(
                    ""am broadcast -a action_anr -p "" + DeviceUtils.STATSD_ATOM_TEST_PKG);
            Thread.sleep(20_000);
        }

        // Sorted list of events in order in which they occurred.
        List<EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());

        assertThat(data).hasSize(1);
        assertThat(data.get(0).getAtom().hasAnrOccurred()).isTrue();
        ANROccurred atom = data.get(0).getAtom().getAnrOccurred();
        assertThat(atom.getIsInstantApp().getNumber())
                .isEqualTo(ANROccurred.InstantApp.FALSE_VALUE);
        assertThat(atom.getForegroundState().getNumber())
                .isEqualTo(ANROccurred.ForegroundState.FOREGROUND_VALUE);
        assertThat(atom.getErrorSource()).isEqualTo(ErrorSource.DATA_APP);
        assertThat(atom.getPackageName()).isEqualTo(DeviceUtils.STATSD_ATOM_TEST_PKG);
        assertFalse(atom.getIsIncremental());
        assertTrue((1 - atom.getLoadingProgress()) < 0.001);
        assertEquals(-1, atom.getMillisSinceOldestPendingRead());
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/statsd/UidAtomTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.cts.statsdatom.statsd.UidAtomTests"	"testWriteRawTestAtom"	"CtsStatsdAtomHostTestCases"	"1: attribution"	"public void testWriteRawTestAtom() throws Exception {
        final int atomTag = Atom.TEST_ATOM_REPORTED_FIELD_NUMBER;
        ConfigUtils.uploadConfigForPushedAtomWithUid(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                atomTag, /*useUidAttributionChain=*/true);

        DeviceUtils.runDeviceTestsOnStatsdApp(getDevice(), "".AtomTests"", ""testWriteRawTestAtom"");

        Thread.sleep(AtomTestUtils.WAIT_TIME_SHORT);
        // Sorted list of events in order in which they occurred.
        List<EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());
        assertThat(data).hasSize(4);

        TestAtomReported atom = data.get(0).getAtom().getTestAtomReported();
        List<AttributionNode> attrChain = atom.getAttributionNodeList();
        assertThat(attrChain).hasSize(2);
        assertThat(attrChain.get(0).getUid()).isEqualTo(1234);
        assertThat(attrChain.get(0).getTag()).isEqualTo(""tag1"");
        assertThat(attrChain.get(1).getUid()).isEqualTo(
                DeviceUtils.getStatsdTestAppUid(getDevice()));
        assertThat(attrChain.get(1).getTag()).isEqualTo(""tag2"");

        assertThat(atom.getIntField()).isEqualTo(42);
        assertThat(atom.getLongField()).isEqualTo(Long.MAX_VALUE);
        assertThat(atom.getFloatField()).isEqualTo(3.14f);
        assertThat(atom.getStringField()).isEqualTo(""This is a basic test!"");
        assertThat(atom.getBooleanField()).isFalse();
        assertThat(atom.getState().getNumber()).isEqualTo(TestAtomReported.State.ON_VALUE);
        assertThat(atom.getBytesField().getExperimentIdList())
                .containsExactly(1L, 2L, 3L).inOrder();


        atom = data.get(1).getAtom().getTestAtomReported();
        attrChain = atom.getAttributionNodeList();
        assertThat(attrChain).hasSize(2);
        assertThat(attrChain.get(0).getUid()).isEqualTo(9999);
        assertThat(attrChain.get(0).getTag()).isEqualTo(""tag9999"");
        assertThat(attrChain.get(1).getUid()).isEqualTo(
                DeviceUtils.getStatsdTestAppUid(getDevice()));
        assertThat(attrChain.get(1).getTag()).isEmpty();

        assertThat(atom.getIntField()).isEqualTo(100);
        assertThat(atom.getLongField()).isEqualTo(Long.MIN_VALUE);
        assertThat(atom.getFloatField()).isEqualTo(-2.5f);
        assertThat(atom.getStringField()).isEqualTo(""Test null uid"");
        assertThat(atom.getBooleanField()).isTrue();
        assertThat(atom.getState().getNumber()).isEqualTo(TestAtomReported.State.UNKNOWN_VALUE);
        assertThat(atom.getBytesField().getExperimentIdList())
                .containsExactly(1L, 2L, 3L).inOrder();

        atom = data.get(2).getAtom().getTestAtomReported();
        attrChain = atom.getAttributionNodeList();
        assertThat(attrChain).hasSize(1);
        assertThat(attrChain.get(0).getUid()).isEqualTo(
                DeviceUtils.getStatsdTestAppUid(getDevice()));
        assertThat(attrChain.get(0).getTag()).isEqualTo(""tag1"");

        assertThat(atom.getIntField()).isEqualTo(-256);
        assertThat(atom.getLongField()).isEqualTo(-1234567890L);
        assertThat(atom.getFloatField()).isEqualTo(42.01f);
        assertThat(atom.getStringField()).isEqualTo(""Test non chained"");
        assertThat(atom.getBooleanField()).isTrue();
        assertThat(atom.getState().getNumber()).isEqualTo(TestAtomReported.State.OFF_VALUE);
        assertThat(atom.getBytesField().getExperimentIdList())
                .containsExactly(1L, 2L, 3L).inOrder();

        atom = data.get(3).getAtom().getTestAtomReported();
        attrChain = atom.getAttributionNodeList();
        assertThat(attrChain).hasSize(1);
        assertThat(attrChain.get(0).getUid()).isEqualTo(
                DeviceUtils.getStatsdTestAppUid(getDevice()));
        assertThat(attrChain.get(0).getTag()).isEmpty();

        assertThat(atom.getIntField()).isEqualTo(0);
        assertThat(atom.getLongField()).isEqualTo(0L);
        assertThat(atom.getFloatField()).isEqualTo(0f);
        assertThat(atom.getStringField()).isEmpty();
        assertThat(atom.getBooleanField()).isTrue();
        assertThat(atom.getState().getNumber()).isEqualTo(TestAtomReported.State.OFF_VALUE);
        assertThat(atom.getBytesField().getExperimentIdList()).isEmpty();
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/statsd/UidAtomTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.cts.statsdatom.statsd.UidAtomTests"	"testAppForegroundBackground"	"CtsStatsdAtomHostTestCases"	"1: attribution"	"public void testAppForegroundBackground() throws Exception {
        Set<Integer> onStates = new HashSet<>(Arrays.asList(
                AppUsageEventOccurred.EventType.MOVE_TO_FOREGROUND_VALUE));
        Set<Integer> offStates = new HashSet<>(Arrays.asList(
                AppUsageEventOccurred.EventType.MOVE_TO_BACKGROUND_VALUE));

        List<Set<Integer>> stateSet = Arrays.asList(onStates, offStates); // state sets, in order
        ConfigUtils.uploadConfigForPushedAtomWithUid(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                Atom.APP_USAGE_EVENT_OCCURRED_FIELD_NUMBER, /*useUidAttributionChain=*/false);

        // Overlay may need to sit there a while.
        final int waitTime = 10_500;
        DeviceUtils.runActivity(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                ""StatsdCtsForegroundActivity"", ""action"", ACTION_SHOW_APPLICATION_OVERLAY, waitTime);

        List<EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());
        Function<Atom, Integer> appUsageStateFunction =
                atom -> atom.getAppUsageEventOccurred().getEventType().getNumber();
        // clear out initial appusage states
        AtomTestUtils.popUntilFind(data, onStates, appUsageStateFunction);
        AtomTestUtils.assertStatesOccurred(stateSet, data, 0, appUsageStateFunction);
    }
/*"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/statsd/UidAtomTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.cts.statsdatom.statsd.DeviceAtomTestCase"	"installTestApp"	"CtsStatsdAtomHostTestCases"	"1: attribution"	"public void test/*
 *.
 */
package android.cts.statsdatom.statsd;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import com.android.internal.os.StatsdConfigProto.FieldValueMatcher;
import com.android.internal.os.StatsdConfigProto.MessageMatcher;
import com.android.internal.os.StatsdConfigProto.Position;
import com.android.internal.os.StatsdConfigProto.StatsdConfig;
import com.android.os.StatsLog.EventMetricData;
import com.android.tradefed.log.LogUtil;

import java.util.Arrays;
import java.util.List;

/**
 * Base class for testing Statsd atoms that report a uid. Tests are performed via a device-side app.
 */
public class DeviceAtomTestCase extends AtomTestCase {

    public static final String DEVICE_SIDE_TEST_APK = ""CtsStatsdApp.apk"";
    public static final String DEVICE_SIDE_TEST_PACKAGE =
            ""com.android.server.cts.device.statsd"";
    public static final long DEVICE_SIDE_TEST_PACKAGE_VERSION = 10;
    public static final String DEVICE_SIDE_TEST_FOREGROUND_SERVICE_NAME =
            ""com.android.server.cts.device.statsd.StatsdCtsForegroundService"";
    private static final String DEVICE_SIDE_BG_SERVICE_COMPONENT =
            ""com.android.server.cts.device.statsd/.StatsdCtsBackgroundService"";
    public static final long DEVICE_SIDE_TEST_PKG_HASH =
            Long.parseUnsignedLong(""15694052924544098582"");

    // Constants from device side tests (not directly accessible here).
    public static final String KEY_ACTION = ""action"";
    public static final String ACTION_LMK = ""action.lmk"";

    public static final String CONFIG_NAME = ""cts_config"";

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        getDevice().uninstallPackage(DEVICE_SIDE_TEST_PACKAGE);
        installTestApp();
        Thread.sleep(1000);
    }

    @Override
    protected void tearDown() throws Exception {
        getDevice().uninstallPackage(DEVICE_SIDE_TEST_PACKAGE);
        super.tearDown();
    }

    /**
     * Performs a device-side test by calling a method on the app and returns its stats events.
     * @param methodName the name of the method in the app's AtomTests to perform
     * @param atom atom tag (from atoms.proto)
     * @param key atom's field corresponding to state
     * @param stateOn 'on' value
     * @param stateOff 'off' value
     * @param minTimeDiffMs max allowed time between start and stop
     * @param maxTimeDiffMs min allowed time between start and stop
     * @param demandExactlyTwo whether there must be precisely two events logged (1 start, 1 stop)
     * @return list of events with the app's uid matching the configuration defined by the params.
     */
    protected List<EventMetricData> doDeviceMethodOnOff(
            String methodName, int atom, int key, int stateOn, int stateOff,
            int minTimeDiffMs, int maxTimeDiffMs, boolean demandExactlyTwo) throws Exception {
        StatsdConfig.Builder conf = createConfigBuilder();
        addAtomEvent(conf, atom, createFvm(key).setEqInt(stateOn));
        addAtomEvent(conf, atom, createFvm(key).setEqInt(stateOff));
        List<EventMetricData> data = doDeviceMethod(methodName, conf);

        if (demandExactlyTwo) {
            assertThat(data).hasSize(2);
        } else {
            assertThat(data.size()).isAtLeast(2);
        }
        assertTimeDiffBetween(data.get(0), data.get(1), minTimeDiffMs, maxTimeDiffMs);
        return data;
    }

    /**
     *
     * @param methodName the name of the method in the app's AtomTests to perform
     * @param cfg statsd configuration
     * @return list of events with the app's uid matching the configuration.
     */
    protected List<EventMetricData> doDeviceMethod(String methodName, StatsdConfig.Builder cfg)
            throws Exception {
        removeConfig(CONFIG_ID);
        getReportList();  // Clears previous data on disk.
        uploadConfig(cfg);
        int appUid = getUid();
        LogUtil.CLog.d(""\nPerforming device-side test of "" + methodName + "" for uid "" + appUid);
        runDeviceTests(DEVICE_SIDE_TEST_PACKAGE, "".AtomTests"", methodName);

        return getEventMetricDataList();
    }

    protected void createAndUploadConfig(int atomTag, boolean useAttribution) throws Exception {
        StatsdConfig.Builder conf = createConfigBuilder();
        addAtomEvent(conf, atomTag, useAttribution);
        uploadConfig(conf);
    }

    /**
     * Adds an event to the config for an atom that matches the given key AND has the app's uid.
     * @param conf configuration
     * @param atomTag atom tag (from atoms.proto)
     * @param fvm FieldValueMatcher.Builder for the relevant key
     */
    @Override
    protected void addAtomEvent(StatsdConfig.Builder conf, int atomTag, FieldValueMatcher.Builder fvm)
            throws Exception {

        final int UID_KEY = 1;
        FieldValueMatcher.Builder fvmUid = createAttributionFvm(UID_KEY);
        addAtomEvent(conf, atomTag, Arrays.asList(fvm, fvmUid));
    }

    /**
     * Adds an event to the config for an atom that matches the app's uid.
     * @param conf configuration
     * @param atomTag atom tag (from atoms.proto)
     * @param useAttribution If true, the atom has a uid within an attribution node. Else, the atom
     * has a uid but not in an attribution node.
     */
    protected void addAtomEvent(StatsdConfig.Builder conf, int atomTag,
            boolean useAttribution) throws Exception {
        final int UID_KEY = 1;
        FieldValueMatcher.Builder fvmUid;
        if (useAttribution) {
            fvmUid = createAttributionFvm(UID_KEY);
        } else {
            fvmUid = createFvm(UID_KEY).setEqString(DEVICE_SIDE_TEST_PACKAGE);
        }
        addAtomEvent(conf, atomTag, Arrays.asList(fvmUid));
    }

    /**
     * Creates a FieldValueMatcher for atoms that use AttributionNode
     */
    protected FieldValueMatcher.Builder createAttributionFvm(int field) {
        final int ATTRIBUTION_NODE_UID_KEY = 1;
        return createFvm(field).setPosition(Position.ANY)
                .setMatchesTuple(MessageMatcher.newBuilder()
                        .addFieldValueMatcher(createFvm(ATTRIBUTION_NODE_UID_KEY)
                                .setEqString(DEVICE_SIDE_TEST_PACKAGE)));
    }

    /**
     * Gets the uid of the test app.
     */
    protected int getUid() throws Exception {
        int currentUser = getDevice().getCurrentUser();
        String uidLine = getDevice().executeShellCommand(""cmd package list packages -U --user ""
                + currentUser + "" "" + DEVICE_SIDE_TEST_PACKAGE);
        String[] uidLineParts = uidLine.split(""[: ]"");
        int uid = 0;
        // Search for the correct package name. It is possible that both
        // com.android.server.cts.device.statsd and com.android.server.cts.device.statsdatom is
        // retrieved.
        for (int i = 0; i < uidLineParts.length; i++) {
            if (DEVICE_SIDE_TEST_PACKAGE.equals(uidLineParts[i])) {
                // the uid entry is the second entry after the package name.
                uid = Integer.parseInt(uidLineParts[i + 2].trim());
            }
        }
        assertThat(uidLineParts.length).isGreaterThan(2);
        assertThat(uid).isGreaterThan(10000);
        return uid;
    }

    /**
     * Installs the test apk.
     */
    protected void installTestApp() throws Exception {
        installPackage(DEVICE_SIDE_TEST_APK, true);
        LogUtil.CLog.i(""Installing device-side test app with uid "" + getUid());
        allowBackgroundServices();
    }

    /**
     * Uninstalls the test apk.
     */
    protected void uninstallPackage() throws Exception{
        getDevice().uninstallPackage(DEVICE_SIDE_TEST_PACKAGE);
    }

    /**
     * Required to successfully start a background service from adb in O.
     */
    protected void allowBackgroundServices() throws Exception {
        getDevice().executeShellCommand(String.format(
                ""cmd deviceidle tempwhitelist %s"", DEVICE_SIDE_TEST_PACKAGE));
    }

    /**
     * Runs a (background) service to perform the given action.
     * @param actionValue the action code constants indicating the desired action to perform.
     */
    protected void executeBackgroundService(String actionValue) throws Exception {
        allowBackgroundServices();
        getDevice().executeShellCommand(String.format(
                ""am startservice -n '%s' -e %s %s"",
                DEVICE_SIDE_BG_SERVICE_COMPONENT,
                KEY_ACTION, actionValue));
    }

    /**
     * Runs the specified activity.
     */
    protected void runActivity(String activity, String actionKey, String actionValue)
            throws Exception {
        runActivity(activity, actionKey, actionValue, WAIT_TIME_LONG);
    }

    /**
     * Runs the specified activity.
     */
    protected void runActivity(String activity, String actionKey, String actionValue,
            long waitTime) throws Exception {
        try (AutoCloseable a = withActivity(activity, actionKey, actionValue)) {
            Thread.sleep(waitTime);
        }
    }

    /**
     * Starts the specified activity and returns an {@link AutoCloseable} that stops the activity
     * when closed.
     *
     * <p>Example usage:
     * <pre>
     *     try (AutoClosable a = withActivity(""activity"", ""action"", ""action-value"")) {
     *         doStuff();
     *     }
     * </pre>
     */
    protected AutoCloseable withActivity(String activity, String actionKey, String actionValue)
            throws Exception {
        String intentString = null;
        if (actionKey != null && actionValue != null) {
            intentString = actionKey + "" "" + actionValue;
        }
        if (intentString == null) {
            getDevice().executeShellCommand(
                    ""am start -n "" + DEVICE_SIDE_TEST_PACKAGE + ""/."" + activity);
        } else {
            getDevice().executeShellCommand(
                    ""am start -n "" + DEVICE_SIDE_TEST_PACKAGE + ""/."" + activity + "" -e "" +
                            intentString);
        }
        return () -> {
            getDevice().executeShellCommand(
                    ""am force-stop "" + DEVICE_SIDE_TEST_PACKAGE);
            Thread.sleep(WAIT_TIME_SHORT);
        };
    }

    protected void resetBatteryStats() throws Exception {
        getDevice().executeShellCommand(""dumpsys batterystats --reset"");
    }

    protected void clearProcStats() throws Exception {
        getDevice().executeShellCommand(""dumpsys procstats --clear"");
    }

    protected void startProcStatsTesting() throws Exception {
        getDevice().executeShellCommand(""dumpsys procstats --start-testing"");
    }

    protected void stopProcStatsTesting() throws Exception {
        getDevice().executeShellCommand(""dumpsys procstats --stop-testing"");
    }

    protected void commitProcStatsToDisk() throws Exception {
        getDevice().executeShellCommand(""dumpsys procstats --commit"");
    }

    protected void rebootDeviceAndWaitUntilReady() throws Exception {
        rebootDevice();
        // Wait for 2 mins.
        assertWithMessage(""Device failed to boot"")
            .that(getDevice().waitForBootComplete(120_000)).isTrue();
        assertWithMessage(""Stats service failed to start"")
            .that(waitForStatsServiceStart(60_000)).isTrue();
        Thread.sleep(2_000);
    }

    protected boolean waitForStatsServiceStart(final long waitTime) throws Exception {
        LogUtil.CLog.i(""Waiting %d ms for stats service to start"", waitTime);
        int counter = 1;
        long startTime = System.currentTimeMillis();
        while ((System.currentTimeMillis() - startTime) < waitTime) {
            if (""running"".equals(getProperty(""init.svc.statsd""))) {
                return true;
            }
            Thread.sleep(Math.min(200 * counter, 2_000));
            counter++;
        }
        LogUtil.CLog.w(""Stats service did not start after %d ms"", waitTime);
        return false;
    }

    boolean getNetworkStatsCombinedSubTypeEnabled() throws Exception {
        final String output = getDevice().executeShellCommand(
                ""settings get global netstats_combine_subtype_enabled"").trim();
        return output.equals(""1"");
    }

    void setNetworkStatsCombinedSubTypeEnabled(boolean enable) throws Exception {
        getDevice().executeShellCommand(""settings put global netstats_combine_subtype_enabled ""
                + (enable ? ""1"" : ""0""));
    }
}"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/statsd/DeviceAtomTestCase.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.cts.statsdatom.cpu.CpuStatsTests"	"testCpuTimePerUid"	"CtsStatsdAtomHostTestCases"	"1: attribution"	"public void testCpuTimePerUid() throws Exception {
        if (DeviceUtils.hasFeature(getDevice(), DeviceUtils.FEATURE_WATCH)) return;

        ConfigUtils.uploadConfigForPulledAtomWithUid(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                AtomsProto.Atom.CPU_TIME_PER_UID_FIELD_NUMBER,  /*uidInAttributionChain=*/false);

        // Do some trivial work on the app
        DeviceUtils.runDeviceTestsOnStatsdApp(getDevice(), "".AtomTests"", ""testSimpleCpu"");
        Thread.sleep(AtomTestUtils.WAIT_TIME_SHORT);
        // Trigger atom pull
        AtomTestUtils.sendAppBreadcrumbReportedAtom(getDevice());
        Thread.sleep(AtomTestUtils.WAIT_TIME_LONG);

        // Verify correctness of data
        List<AtomsProto.Atom> atoms = ReportUtils.getGaugeMetricAtoms(getDevice());
        boolean found = false;
        int appUid = DeviceUtils.getStatsdTestAppUid(getDevice());
        for (AtomsProto.Atom atom : atoms) {
            assertThat(atom.getCpuTimePerUid().getUid()).isEqualTo(appUid);
            assertThat(atom.getCpuTimePerUid().getUserTimeMicros()).isGreaterThan(0L);
            assertThat(atom.getCpuTimePerUid().getSysTimeMicros()).isGreaterThan(0L);
            found = true;
        }
        assertWithMessage(""Found no CpuTimePerUid atoms from uid "" + appUid).that(found).isTrue();
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/cpu/CpuStatsTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.cts.statsdatom.binderstats.BinderStatsTests"	"testBinderStats"	"CtsStatsdAtomHostTestCases"	"1: attribution"	"public void testBinderStats() throws Exception {
        try {
            DeviceUtils.unplugDevice(getDevice());
            Thread.sleep(AtomTestUtils.WAIT_TIME_SHORT);

            enableBinderStats();
            binderStatsNoSampling();
            resetBinderStats();

            StatsdConfig.Builder config =
                    ConfigUtils.createConfigBuilder(DeviceUtils.STATSD_ATOM_TEST_PKG);
            ConfigUtils.addGaugeMetricForUidAtom(config, Atom.BINDER_CALLS_FIELD_NUMBER,
                    /*uidInAttributionChain=*/false, DeviceUtils.STATSD_ATOM_TEST_PKG);
            ConfigUtils.uploadConfig(getDevice(), config);

            DeviceUtils.runActivity(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                    ""StatsdCtsForegroundActivity"", ""action"", ""action.show_notification"", 3_000);
            AtomTestUtils.sendAppBreadcrumbReportedAtom(getDevice());
            Thread.sleep(AtomTestUtils.WAIT_TIME_SHORT);

            boolean found = false;
            int appUid = DeviceUtils.getAppUid(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG);
            for (Atom atom : ReportUtils.getGaugeMetricAtoms(getDevice())) {
                BinderCalls calls = atom.getBinderCalls();
                assertThat(calls.getUid()).isEqualTo(appUid);
                boolean classMatches = calls.getServiceClassName().contains(
                        ""com.android.server.notification.NotificationManagerService"");
                boolean methodMatches = calls.getServiceMethodName()
                        .equals(""createNotificationChannels"");
                if (classMatches && methodMatches) {
                    found = true;
                    assertThat(calls.getRecordedCallCount()).isGreaterThan(0L);
                    assertThat(calls.getCallCount()).isGreaterThan(0L);
                    assertThat(calls.getRecordedTotalLatencyMicros())
                        .isIn(Range.open(0L, 1000000L));
                    assertThat(calls.getRecordedTotalCpuMicros()).isIn(Range.open(0L, 1000000L));
                }
            }

            assertWithMessage(String.format(""Did not find a matching atom for uid %d"", appUid))
                .that(found).isTrue();
          } finally {
            disableBinderStats();
            plugInAc();
          }
    }

    private void enableBinderStats() throws Exception {
        getDevice().executeShellCommand(""dumpsys binder_calls_stats --enable"");
    }

    private void resetBinderStats() throws Exception {
        getDevice().executeShellCommand(""dumpsys binder_calls_stats --reset"");
    }

    private void disableBinderStats() throws Exception {
        getDevice().executeShellCommand(""dumpsys binder_calls_stats --disable"");
    }

    private void binderStatsNoSampling() throws Exception {
        getDevice().executeShellCommand(""dumpsys binder_calls_stats --no-sampling"");
    }

    private void plugInAc() throws Exception {
        getDevice().executeShellCommand(""cmd battery set ac 1"");
    }
}"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/binderstats/BinderStatsTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.cts.statsdatom.alarm.AlarmStatsTests"	"testWakeupAlarm"	"CtsStatsdAtomHostTestCases"	"1: attribution"	"public void testWakeupAlarm() throws Exception {
        // For automotive, all wakeup alarm becomes normal alarm. So this
        // test does not work.
        if (DeviceUtils.hasFeature(getDevice(), FEATURE_AUTOMOTIVE)) return;

        final int atomTag = AtomsProto.Atom.WAKEUP_ALARM_OCCURRED_FIELD_NUMBER;

        ConfigUtils.uploadConfigForPushedAtomWithUid(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                atomTag, /*useUidAttributionChain=*/true);
        DeviceUtils.runDeviceTestsOnStatsdApp(getDevice(), "".AtomTests"", ""testWakeupAlarm"");

        List<StatsLog.EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());
        assertThat(data.size()).isAtLeast(1);
        for (int i = 0; i < data.size(); i++) {
            AtomsProto.WakeupAlarmOccurred wao = data.get(i).getAtom().getWakeupAlarmOccurred();
            assertThat(wao.getTag()).isEqualTo(""*walarm*:android.cts.statsdatom.testWakeupAlarm"");
            assertThat(wao.getPackageName()).isEqualTo(DeviceUtils.STATSD_ATOM_TEST_PKG);
        }
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/alarm/AlarmStatsTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.cts.statsdatom.appexit.AppExitHostTest"	"testLogStatsdOther"	"CtsStatsdAtomHostTestCases"	"1: attribution"	"public void testLogStatsdOther() throws Exception {
        final String helperPackage = HELPER_PKG1;
        final int expectedUid = getAppUid(TEST_PKG);
        performLogStatsdTest(""testOther"", TEST_PKG, 2, appDied -> {
            assertThat(appDied.getUid()).isEqualTo(expectedUid);
            assertThat(appDied.getProcessName()).isEqualTo(
                    helperPackage + "":android.externalservice.service.ExternalServiceWithZygote"");
            assertThat(appDied.getReason()).isEqualTo(REASON_OTHER);
            assertThat(appDied.getSubReason()).isEqualTo(SUBREASON_ISOLATED_NOT_NEEDED);
            assertThat(appDied.getImportance()).isEqualTo(IMPORTANCE_SERVICE);
        });
    }

    private void performLogStatsdTest(String testMethod, String targetPackage, int expectedSize,
            Consumer<AtomsProto.AppProcessDied> verifier) throws Exception {
        final int atomTag = AtomsProto.Atom.APP_PROCESS_DIED_FIELD_NUMBER;

        ConfigUtils.removeConfig(getDevice());
        ReportUtils.clearReports(getDevice());
        ConfigUtils.uploadConfigForPushedAtomWithUid(getDevice(), targetPackage,
                atomTag, /* useUidAttributionChain= */ false);

        DeviceUtils.runDeviceTests(getDevice(), TEST_PKG, TEST_CLASS, testMethod);
        Thread.sleep(APP_EXIT_INFO_STATSD_LOG_DEBOUNCE_MSEC);

        List<StatsLog.EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());

        assertThat(data).isNotNull();
        assertThat(data.size()).isEqualTo(expectedSize);

        verifier.accept(data.get(0).getAtom().getAppProcessDied());
    }

    private int getAppUid(String pkgName) throws Exception {
        final int currentUser = getDevice().getCurrentUser();
        final String uidLine = getDevice().executeShellCommand(
                ""cmd package list packages -U --user "" + currentUser + "" "" + pkgName);
        final Pattern pattern = Pattern.compile(""package:"" + pkgName + "" uid:(\\d+)"");
        final Matcher matcher = pattern.matcher(uidLine);
        assertWithMessage(""Pkg not found: "" + pkgName).that(matcher.find()).isTrue();
        final int appUid = Integer.parseInt(matcher.group(1));
        return appUid;
    }
}"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/appexit/AppExitHostTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.cts.statsdatom.apphibernation.AppHibernationStatsTest"	"testUserLevelAppHibernationStateChanged_fromNotHibernatingToHibernating"	"CtsStatsdAtomHostTestCases"	"1: attribution"	"public void testUserLevelAppHibernationStateChanged_fromNotHibernatingToHibernating()
            throws Exception {
        getDevice().executeShellCommand(
                getHibernationCommand(DeviceUtils.STATSD_ATOM_TEST_PKG,
                        /* isGlobal */ false, /* isHibernating */ false));
        ConfigUtils.uploadConfigForPushedAtomWithUid(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                AtomsProto.Atom.USER_LEVEL_HIBERNATION_STATE_CHANGED_FIELD_NUMBER,
                /*uidInAttributionChain=*/false);

        getDevice().executeShellCommand(
                getHibernationCommand(DeviceUtils.STATSD_ATOM_TEST_PKG,
                        /* isGlobal */ false, /* isHibernating */ true));

        // Sorted list of events in order in which they occurred.
        final List<StatsLog.EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());
        assertThat(data.size()).isAtLeast(1);
        assertUserLevelHibernationStateChangedEvent(data, /* isHibernating */ true,
                getDevice().getCurrentUser());
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/apphibernation/AppHibernationStatsTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.cts.statsdatom.apphibernation.AppHibernationStatsTest"	"testUserLevelAppHibernationStateChanged_fromHibernatingToNotHibernating"	"CtsStatsdAtomHostTestCases"	"1: attribution"	"public void testUserLevelAppHibernationStateChanged_fromHibernatingToNotHibernating()
            throws Exception {
        getDevice().executeShellCommand(
                getHibernationCommand(DeviceUtils.STATSD_ATOM_TEST_PKG,
                        /* isGlobal */ false, /* isHibernating */ true));
        ConfigUtils.uploadConfigForPushedAtomWithUid(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                AtomsProto.Atom.USER_LEVEL_HIBERNATION_STATE_CHANGED_FIELD_NUMBER,
                /*uidInAttributionChain=*/false);

        getDevice().executeShellCommand(
                getHibernationCommand(DeviceUtils.STATSD_ATOM_TEST_PKG,
                        /* isGlobal */ false, /* isHibernating */ false));

        // Sorted list of events in order in which they occurred.
        final List<StatsLog.EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());
        assertThat(data.size()).isAtLeast(1);
        assertUserLevelHibernationStateChangedEvent(data, /* isHibernating */ false,
                getDevice().getCurrentUser());
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/apphibernation/AppHibernationStatsTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"com.android.server.cts.device.statsdatom.AtomTests"	"testBleScanInterrupted"	""	"1: attribution"	"public void testBleScanInterrupted() throws Exception {
        performBleAction((bluetoothAdapter, bleScanner) -> {
            ScanSettings scanSettings = new ScanSettings.Builder()
                    .setScanMode(ScanSettings.SCAN_MODE_LOW_LATENCY).build();
            ScanCallback scanCallback = new ScanCallback() {
                @Override
                public void onScanResult(int callbackType, ScanResult result) {
                    Log.v(TAG, ""called onScanResult"");
                }
                @Override
                public void onScanFailed(int errorCode) {
                    Log.v(TAG, ""called onScanFailed"");
                }
                @Override
                public void onBatchScanResults(List<ScanResult> results) {
                    Log.v(TAG, ""called onBatchScanResults"");
                }
            };

            int uid = Process.myUid();
            int whatAtomId = 9_999;

            // Get the current setting for bluetooth background scanning.
            // Set to 0 if the setting is not found or an error occurs.
            int initialBleScanGlobalSetting = Settings.Global.getInt(
                    InstrumentationRegistry.getTargetContext().getContentResolver(),
                    Settings.Global.BLE_SCAN_ALWAYS_AVAILABLE, 0);

            // Turn off bluetooth background scanning.
            Settings.Global.putInt(InstrumentationRegistry.getTargetContext().getContentResolver(),
                    Settings.Global.BLE_SCAN_ALWAYS_AVAILABLE, 0);

            // Change state to State.ON.
            bleScanner.startScan(null, scanSettings, scanCallback);
            sleep(6_000);
            writeSliceByBleScanStateChangedAtom(whatAtomId, uid, false, false, false);
            writeSliceByBleScanStateChangedAtom(whatAtomId, uid, false, false, false);

            bluetoothAdapter.disable();
            sleep(6_000);

            // Trigger State.RESET so that new state is State.OFF.
            if (!bluetoothAdapter.enable()) {
                Log.e(TAG, ""Could not enable bluetooth to trigger state reset"");
                return;
            }
            sleep(6_000); // Wait for Bluetooth to fully turn on.
            writeSliceByBleScanStateChangedAtom(whatAtomId, uid, false, false, false);
            writeSliceByBleScanStateChangedAtom(whatAtomId, uid, false, false, false);
            writeSliceByBleScanStateChangedAtom(whatAtomId, uid, false, false, false);

            // Set bluetooth background scanning to original setting.
            Settings.Global.putInt(InstrumentationRegistry.getTargetContext().getContentResolver(),
                    Settings.Global.BLE_SCAN_ALWAYS_AVAILABLE, initialBleScanGlobalSetting);
        });
    }

    private static void writeSliceByBleScanStateChangedAtom(int atomId, int firstUid,
                                                            boolean field2, boolean field3,
                                                            boolean field4) {
        final StatsEvent.Builder builder = StatsEvent.newBuilder()
                .setAtomId(atomId)
                .writeAttributionChain(new int[] {firstUid}, new String[] {""tag1""})
                .writeBoolean(field2)
                .writeBoolean(field3)
                .writeBoolean(field4)
                .usePooledBuffer();

        StatsLog.write(builder.build());
    }

    /**
     * Set up BluetoothLeScanner and perform the action in the callback.
     * Restore Bluetooth to original state afterwards.
     **/
    private static void performBleAction(BiConsumer<BluetoothAdapter, BluetoothLeScanner> actions) {
        BluetoothAdapter bluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
        if (bluetoothAdapter == null) {
            Log.e(TAG, ""Device does not support Bluetooth"");
            return;
        }
        boolean bluetoothEnabledByTest = false;
        if (!bluetoothAdapter.isEnabled()) {
            if (!bluetoothAdapter.enable()) {
                Log.e(TAG, ""Bluetooth is not enabled"");
                return;
            }
            sleep(2_000); // Wait for Bluetooth to fully turn on.
            bluetoothEnabledByTest = true;
        }
        BluetoothLeScanner bleScanner = bluetoothAdapter.getBluetoothLeScanner();
        if (bleScanner == null) {
            Log.e(TAG, ""Cannot access BLE scanner"");
            return;
        }

        actions.accept(bluetoothAdapter, bleScanner);

        // Restore adapter state
        if (bluetoothEnabledByTest) {
            bluetoothAdapter.disable();
        }
    }


    private static void performBleScan(ScanSettings scanSettings, List<ScanFilter> scanFilters, boolean waitForResult) {
        performBleAction((bluetoothAdapter, bleScanner) -> {
            CountDownLatch resultsLatch = new CountDownLatch(1);
            ScanCallback scanCallback = new ScanCallback() {
                @Override
                public void onScanResult(int callbackType, ScanResult result) {
                    Log.v(TAG, ""called onScanResult"");
                    resultsLatch.countDown();
                }
                @Override
                public void onScanFailed(int errorCode) {
                    Log.v(TAG, ""called onScanFailed"");
                }
                @Override
                public void onBatchScanResults(List<ScanResult> results) {
                    Log.v(TAG, ""called onBatchScanResults"");
                    resultsLatch.countDown();
                }
            };

            bleScanner.startScan(scanFilters, scanSettings, scanCallback);
            if (waitForResult) {
                waitForReceiver(InstrumentationRegistry.getContext(), 59_000, resultsLatch, null);
            } else {
                sleep(2_000);
            }
            bleScanner.stopScan(scanCallback);
        });
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/apps/statsdapp/src/com/android/server/cts/device/statsdatom/AtomTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"com.android.server.cts.device.statsdatom.AtomTests"	"testSliceByWakelockState"	""	"1: attribution"	"public void testSliceByWakelockState() {
        int uid = Process.myUid();
        int whatAtomId = 9_998;
        int wakelockType = PowerManager.PARTIAL_WAKE_LOCK;
        String tag = ""StatsdPartialWakelock"";

        Context context = InstrumentationRegistry.getContext();
        PowerManager pm = context.getSystemService(PowerManager.class);
        PowerManager.WakeLock wl = pm.newWakeLock(wakelockType, tag);

        wl.acquire();
        sleep(500);
        writeSliceByWakelockStateChangedAtom(whatAtomId, uid, wakelockType, tag);
        writeSliceByWakelockStateChangedAtom(whatAtomId, uid, wakelockType, tag);
        wl.acquire();
        sleep(500);
        writeSliceByWakelockStateChangedAtom(whatAtomId, uid, wakelockType, tag);
        writeSliceByWakelockStateChangedAtom(whatAtomId, uid, wakelockType, tag);
        writeSliceByWakelockStateChangedAtom(whatAtomId, uid, wakelockType, tag);
        wl.release();
        sleep(500);
        writeSliceByWakelockStateChangedAtom(whatAtomId, uid, wakelockType, tag);
        wl.release();
        sleep(500);
        writeSliceByWakelockStateChangedAtom(whatAtomId, uid, wakelockType, tag);
        writeSliceByWakelockStateChangedAtom(whatAtomId, uid, wakelockType, tag);
        writeSliceByWakelockStateChangedAtom(whatAtomId, uid, wakelockType, tag);
    }

    private static void writeSliceByWakelockStateChangedAtom(int atomId, int firstUid,
                                                            int field2, String field3) {
        final StatsEvent.Builder builder = StatsEvent.newBuilder()
                .setAtomId(atomId)
                .writeAttributionChain(new int[] {firstUid}, new String[] {""tag1""})
                .writeInt(field2)
                .writeString(field3)
                .usePooledBuffer();

        StatsLog.write(builder.build());
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/apps/statsdapp/src/com/android/server/cts/device/statsdatom/AtomTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"com.android.server.cts.device.statsdatom.AtomTests"	"testWriteRawTestAtom"	""	"1: attribution"	"public void testWriteRawTestAtom() throws Exception {
        Context context = InstrumentationRegistry.getTargetContext();
        ApplicationInfo appInfo = context.getPackageManager()
                .getApplicationInfo(context.getPackageName(), 0);
        int[] uids = {1234, appInfo.uid};
        String[] tags = {""tag1"", ""tag2""};
        byte[] experimentIds = {8, 1, 8, 2, 8, 3}; // Corresponds to 1, 2, 3.
        StatsLogStatsdCts.write(StatsLogStatsdCts.TEST_ATOM_REPORTED, uids, tags, 42,
                Long.MAX_VALUE, 3.14f, ""This is a basic test!"", false,
                StatsLogStatsdCts.TEST_ATOM_REPORTED__STATE__ON, experimentIds);

        // All nulls. Should get dropped since cts app is not in the attribution chain.
        StatsLogStatsdCts.write(StatsLogStatsdCts.TEST_ATOM_REPORTED, null, null, 0, 0,
                0f, null, false, StatsLogStatsdCts.TEST_ATOM_REPORTED__STATE__ON, null);

        // Null tag in attribution chain.
        int[] uids2 = {9999, appInfo.uid};
        String[] tags2 = {""tag9999"", null};
        StatsLogStatsdCts.write(StatsLogStatsdCts.TEST_ATOM_REPORTED, uids2, tags2, 100,
                Long.MIN_VALUE, -2.5f, ""Test null uid"", true,
                StatsLogStatsdCts.TEST_ATOM_REPORTED__STATE__UNKNOWN, experimentIds);

        // Non chained non-null
        StatsLogStatsdCts.write_non_chained(StatsLogStatsdCts.TEST_ATOM_REPORTED,
                appInfo.uid, ""tag1"", -256, -1234567890L, 42.01f, ""Test non chained"", true,
                StatsLogStatsdCts.TEST_ATOM_REPORTED__STATE__OFF, experimentIds);

        // Non chained all null
        StatsLogStatsdCts.write_non_chained(StatsLogStatsdCts.TEST_ATOM_REPORTED, appInfo.uid, null,
                0, 0, 0f, null, true, StatsLogStatsdCts.TEST_ATOM_REPORTED__STATE__OFF, null);

    }

    /**
     * Bring up and generate some traffic on cellular data connection.
     */"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/apps/statsdapp/src/com/android/server/cts/device/statsdatom/AtomTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"com.android.cts.packagemanager.stats.host.IncrementalAppErrorStatsTests"	"testAppCrashOnIncremental"	"CtsPackageManagerStatsHostTestCases"	"1: attribution"	"public void testAppCrashOnIncremental() throws Exception {
        if (!getDevice().hasFeature(FEATURE_INCREMENTAL_DELIVERY)) {
            return;
        }
        final int atomTag = AtomsProto.Atom.APP_CRASH_OCCURRED_FIELD_NUMBER;
        ConfigUtils.uploadConfigForPushedAtomWithUid(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                atomTag,  /*uidInAttributionChain=*/false);

        DeviceUtils.runActivity(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                ""StatsdCtsForegroundActivity"", ""action"", ""action.crash"");
        Thread.sleep(METRICS_WAIT_MILLISECONDS);
        // Sorted list of events in order in which they occurred.
        List<StatsLog.EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());

        assertThat(data).hasSize(1);
        AtomsProto.AppCrashOccurred atom = data.get(0).getAtom().getAppCrashOccurred();
        // UID should belong to the run activity, not any system service.
        assertThat(atom.getUid()).isGreaterThan(10000);
        assertThat(atom.getEventType()).isEqualTo(""crash"");
        assertThat(atom.getIsInstantApp().getNumber())
                .isEqualTo(AtomsProto.AppCrashOccurred.InstantApp.FALSE_VALUE);
        assertThat(atom.getForegroundState().getNumber())
                .isEqualTo(AtomsProto.AppCrashOccurred.ForegroundState.FOREGROUND_VALUE);
        assertThat(atom.getPackageName()).isEqualTo(DeviceUtils.STATSD_ATOM_TEST_PKG);
        assertThat(atom.getErrorSource()).isEqualTo(ErrorSource.DATA_APP);
        assertTrue(atom.getIsIncremental());
        assertFalse((1.0f - atom.getLoadingProgress()) < 0.0000001f);
        assertTrue(atom.getMillisSinceOldestPendingRead() > 0);
        assertEquals(3 /* HEALTH_STATUS_UNHEALTHY */, atom.getStorageHealthCode());
        assertEquals(6 /* DATA_LOADER_IMAGE_READY */, atom.getDataLoaderStatusCode());
        assertFalse(atom.getReadLogsEnabled());
        assertTrue(atom.getMillisSinceLastDataLoaderBind() > 0);
        assertEquals(0, atom.getDataLoaderBindDelayMillis());
        if (!hasIncrementalDeliveryV2Feature()) {
            // Skip kernel stats check if it's not supported
            return;
        }
        assertTrue(atom.getTotalDelayedReads() > 0);
        assertTrue(atom.getTotalFailedReads() > 0);
        assertTrue(atom.getLastReadErrorMillisSince() > 0);
        assertEquals(-62 /* -ETIME */, atom.getLastReadErrorCode());
        assertTrue(atom.getTotalDelayedReadsDurationMillis() > 0);
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/packagemanager/stats/src/com/android/cts/packagemanager/stats/host/IncrementalAppErrorStatsTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"com.android.cts.packagemanager.stats.host.IncrementalAppErrorStatsTests"	"testAppAnrIncremental"	"CtsPackageManagerStatsHostTestCases"	"1: attribution"	"public void testAppAnrIncremental() throws Exception {
        if (!getDevice().hasFeature(FEATURE_INCREMENTAL_DELIVERY)) {
            return;
        }
        final int atomTag = AtomsProto.Atom.ANR_OCCURRED_FIELD_NUMBER;
        ConfigUtils.uploadConfigForPushedAtomWithUid(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                atomTag, /*useUidAttributionChain=*/false);
        final int ANR_WAIT_MILLS = 15_000;

        try (AutoCloseable a = DeviceUtils.withActivity(getDevice(),
                DeviceUtils.STATSD_ATOM_TEST_PKG, ""ANRActivity"", null, null)) {
            Thread.sleep(AtomTestUtils.WAIT_TIME_LONG);
            getDevice().executeShellCommand(
                    ""am broadcast -a action_anr -p "" + DeviceUtils.STATSD_ATOM_TEST_PKG);
            Thread.sleep(ANR_WAIT_MILLS);
        }

        // Sorted list of events in order in which they occurred.
        List<StatsLog.EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());

        assertThat(data).hasSize(1);
        assertThat(data.get(0).getAtom().hasAnrOccurred()).isTrue();
        AtomsProto.ANROccurred atom = data.get(0).getAtom().getAnrOccurred();
        assertThat(atom.getIsInstantApp().getNumber())
                .isEqualTo(AtomsProto.ANROccurred.InstantApp.FALSE_VALUE);
        assertThat(atom.getForegroundState().getNumber())
                .isEqualTo(AtomsProto.ANROccurred.ForegroundState.FOREGROUND_VALUE);
        assertThat(atom.getErrorSource()).isEqualTo(ErrorSource.DATA_APP);
        assertThat(atom.getPackageName()).isEqualTo(DeviceUtils.STATSD_ATOM_TEST_PKG);
        assertTrue(atom.getIsIncremental());
        assertFalse((1.0f - atom.getLoadingProgress()) < 0.0000001f);
    }
}"	"/home/gpoor/cts-12-source/cts/hostsidetests/packagemanager/stats/src/com/android/cts/packagemanager/stats/host/IncrementalAppErrorStatsTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.uwb.cts.UwbManagerTest"	"isNotNull"	"CtsUwbTestCases"	"1: attribution"	"/*
 *.
 */

package android.uwb.cts;

import static android.Manifest.permission.UWB_PRIVILEGED;
import static android.Manifest.permission.UWB_RANGING;

import static androidx.test.platform.app.InstrumentationRegistry.getInstrumentation;

import static com.google.common.truth.Truth.assertThat;

import static org.junit.Assert.fail;
import static org.junit.Assume.assumeTrue;

import android.annotation.NonNull;
import android.annotation.Nullable;
import android.app.UiAutomation;
import android.content.AttributionSource;
import android.content.Context;
import android.content.ContextParams;
import android.os.CancellationSignal;
import android.os.PersistableBundle;
import android.os.Process;
import android.permission.PermissionManager;
import android.util.Log;
import android.uwb.RangingReport;
import android.uwb.RangingSession;
import android.uwb.UwbManager;

import androidx.test.InstrumentationRegistry;
import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.filters.SmallTest;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.Set;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

/**
 * Test of {@link UwbManager}.
 */
@SmallTest
@RunWith(AndroidJUnit4.class)
public class UwbManagerTest {
    private static final String TAG = ""UwbManagerTest"";

    private final Context mContext = InstrumentationRegistry.getContext();
    private UwbManager mUwbManager;

    @Before
    public void setup() {
        mUwbManager = mContext.getSystemService(UwbManager.class);
        assumeTrue(UwbTestUtils.isUwbSupported(mContext));
        assertThat(mUwbManager).isNotNull();
    }"	"/home/gpoor/cts-12-source/cts/tests/uwb/src/android/uwb/cts/UwbManagerTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.uwb.cts.UwbManagerTest"	"testOpenRangingSessionWithoutUwbRanging"	"CtsUwbTestCases"	"1: attribution"	"public void testOpenRangingSessionWithoutUwbRanging() {
        UiAutomation uiAutomation = getInstrumentation().getUiAutomation();
        try {
            // Needs UWB_PRIVILEGED permission which is held by shell.
            uiAutomation.adoptShellPermissionIdentity(UWB_PRIVILEGED);
            mUwbManager.openRangingSession(new PersistableBundle(),
                    Executors.newSingleThreadExecutor(),
                    new RangingSessionCallback(new CountDownLatch(1)));
            // should fail if the call was successful without UWB_RANGING permission.
            fail();
        } catch (SecurityException e) {
            /* pass */
            Log.i(TAG, ""Failed with expected security exception: "" + e);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    private AttributionSource getShellAttributionSourceWithRenouncedPermissions(
            @Nullable Set<String> renouncedPermissions) {
        try {
            AttributionSource shellAttributionSource =
                    new AttributionSource.Builder(Process.SHELL_UID)
                            .setPackageName(""com.android.shell"")
                            .setRenouncedPermissions(renouncedPermissions)
                            .build();
            PermissionManager permissionManager =
                    mContext.getSystemService(PermissionManager.class);
            permissionManager.registerAttributionSource(shellAttributionSource);
            return shellAttributionSource;
        } catch (SecurityException e) {
            fail(""Failed to create shell attribution source"" + e);
            return null;
        }
    }

    private Context createShellContextWithRenouncedPermissionsAndAttributionSource(
            @Nullable Set<String> renouncedPermissions) {
        return mContext.createContext(new ContextParams.Builder()
                .setRenouncedPermissions(renouncedPermissions)
                .setNextAttributionSource(
                        getShellAttributionSourceWithRenouncedPermissions(renouncedPermissions))
                .build());
    }

    /**
     * Simulates the calling app holding UWB_PRIVILEGED permission and UWB_RANGING permission, but
     * the proxied app not holding UWB_RANGING permission.
     */"	"/home/gpoor/cts-12-source/cts/tests/uwb/src/android/uwb/cts/UwbManagerTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.uwb.cts.UwbManagerTest"	"testOpenRangingSessionWithoutUwbRangingInNextAttributeSource"	"CtsUwbTestCases"	"1: attribution"	"public void testOpenRangingSessionWithoutUwbRangingInNextAttributeSource() {
        UiAutomation uiAutomation = getInstrumentation().getUiAutomation();
        try {
            // Only hold UWB_PRIVILEGED permission
            uiAutomation.adoptShellPermissionIdentity();
            Context shellContextWithUwbRangingRenounced =
                    createShellContextWithRenouncedPermissionsAndAttributionSource(
                            Set.of(UWB_RANGING));
            UwbManager uwbManagerWithUwbRangingRenounced =
                    shellContextWithUwbRangingRenounced.getSystemService(UwbManager.class);
            uwbManagerWithUwbRangingRenounced.openRangingSession(new PersistableBundle(),
                    Executors.newSingleThreadExecutor(),
                    new RangingSessionCallback(new CountDownLatch(1)));
            // should fail if the call was successful without UWB_RANGING permission.
            fail();
        } catch (SecurityException e) {
            /* pass */
            Log.i(TAG, ""Failed with expected security exception: "" + e);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }
}"	"/home/gpoor/cts-12-source/cts/tests/uwb/src/android/uwb/cts/UwbManagerTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"com.android.cts.blob.BlobStoreManagerTest"	"testStorageAttribution_acquireLease"	"CtsBlobStoreTestCases"	"1: attribution"	"public void testStorageAttribution_acquireLease() throws Exception {
        final FakeBlobData blobData = new FakeBlobData.Builder(mContext).build();
        blobData.prepare();

        final StorageStatsManager storageStatsManager = mContext.getSystemService(
                StorageStatsManager.class);
        StorageStats beforeStatsForPkg = storageStatsManager
                .queryStatsForPackage(UUID_DEFAULT, mContext.getPackageName(), mContext.getUser());
        StorageStats beforeStatsForUid = storageStatsManager
                .queryStatsForUid(UUID_DEFAULT, Process.myUid());

        final long sessionId = mBlobStoreManager.createSession(blobData.getBlobHandle());
        try (BlobStoreManager.Session session = mBlobStoreManager.openSession(sessionId)) {
            blobData.writeToSession(session);
            session.allowPublicAccess();

            commitSession(sessionId, session, blobData.getBlobHandle());
        }

        StorageStats afterStatsForPkg = storageStatsManager
                .queryStatsForPackage(UUID_DEFAULT, mContext.getPackageName(), mContext.getUser());
        StorageStats afterStatsForUid = storageStatsManager
                .queryStatsForUid(UUID_DEFAULT, Process.myUid());

        // No leases on the blob, so it should not be attributed.
        assertSizeBytesMostlyEquals(0L,
                afterStatsForPkg.getDataBytes() - beforeStatsForPkg.getDataBytes());
        assertSizeBytesMostlyEquals(0L,
                afterStatsForUid.getDataBytes() - beforeStatsForUid.getDataBytes());

        final TestServiceConnection serviceConnection = bindToHelperService(HELPER_PKG);
        final ICommandReceiver commandReceiver = serviceConnection.getCommandReceiver();
        try {
            StorageStats beforeStatsForHelperPkg = commandReceiver.queryStatsForPackage();
            StorageStats beforeStatsForHelperUid = commandReceiver.queryStatsForUid();

            commandReceiver.acquireLease(blobData.getBlobHandle());

            StorageStats afterStatsForHelperPkg = commandReceiver.queryStatsForPackage();
            StorageStats afterStatsForHelperUid = commandReceiver.queryStatsForUid();

            assertSizeBytesMostlyEquals(blobData.getFileSize(),
                    afterStatsForHelperPkg.getDataBytes() - beforeStatsForHelperPkg.getDataBytes());
            assertSizeBytesMostlyEquals(blobData.getFileSize(),
                    afterStatsForHelperUid.getDataBytes() - beforeStatsForHelperUid.getDataBytes());

            afterStatsForPkg = storageStatsManager
                    .queryStatsForPackage(UUID_DEFAULT, mContext.getPackageName(),
                            mContext.getUser());
            afterStatsForUid = storageStatsManager
                    .queryStatsForUid(UUID_DEFAULT, Process.myUid());

            // There shouldn't be no change in stats for this package
            assertSizeBytesMostlyEquals(0L,
                    afterStatsForPkg.getDataBytes() - beforeStatsForPkg.getDataBytes());
            assertSizeBytesMostlyEquals(0L,
                    afterStatsForUid.getDataBytes() - beforeStatsForUid.getDataBytes());

            commandReceiver.releaseLease(blobData.getBlobHandle());

            afterStatsForHelperPkg = commandReceiver.queryStatsForPackage();
            afterStatsForHelperUid = commandReceiver.queryStatsForUid();

            // Lease is released, so it should not be attributed anymore.
            assertSizeBytesMostlyEquals(0L,
                    afterStatsForHelperPkg.getDataBytes() - beforeStatsForHelperPkg.getDataBytes());
            assertSizeBytesMostlyEquals(0L,
                    afterStatsForHelperUid.getDataBytes() - beforeStatsForHelperUid.getDataBytes());
        } finally {
            serviceConnection.unbind();
        }
    }"	"/home/gpoor/cts-12-source/cts/tests/BlobStore/src/com/android/cts/blob/BlobStoreManagerTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"com.android.cts.blob.BlobStoreManagerTest"	"testStorageAttribution_withExpiredLease"	"CtsBlobStoreTestCases"	"1: attribution"	"public void testStorageAttribution_withExpiredLease() throws Exception {
        final FakeBlobData blobData = new FakeBlobData.Builder(mContext).build();
        blobData.prepare();

        final StorageStatsManager storageStatsManager = mContext.getSystemService(
                StorageStatsManager.class);
        StorageStats beforeStatsForPkg = storageStatsManager
                .queryStatsForPackage(UUID_DEFAULT, mContext.getPackageName(), mContext.getUser());
        StorageStats beforeStatsForUid = storageStatsManager
                .queryStatsForUid(UUID_DEFAULT, Process.myUid());

        commitBlob(blobData);

        StorageStats afterStatsForPkg = storageStatsManager
                .queryStatsForPackage(UUID_DEFAULT, mContext.getPackageName(), mContext.getUser());
        StorageStats afterStatsForUid = storageStatsManager
                .queryStatsForUid(UUID_DEFAULT, Process.myUid());

        // No leases on the blob, so it should not be attributed.
        assertSizeBytesMostlyEquals(0L,
                afterStatsForPkg.getDataBytes() - beforeStatsForPkg.getDataBytes());
        assertSizeBytesMostlyEquals(0L,
                afterStatsForUid.getDataBytes() - beforeStatsForUid.getDataBytes());

        final long leaseExpiryDurationMs = TimeUnit.SECONDS.toMillis(5);
        acquireLease(mContext, blobData.getBlobHandle(), R.string.test_desc,
                System.currentTimeMillis() + leaseExpiryDurationMs);

        final long startTimeMs = System.currentTimeMillis();
        afterStatsForPkg = storageStatsManager
                .queryStatsForPackage(UUID_DEFAULT, mContext.getPackageName(), mContext.getUser());
        afterStatsForUid = storageStatsManager
                .queryStatsForUid(UUID_DEFAULT, Process.myUid());

        assertSizeBytesMostlyEquals(blobData.getFileSize(),
                afterStatsForPkg.getDataBytes() - beforeStatsForPkg.getDataBytes());
        assertSizeBytesMostlyEquals(blobData.getFileSize(),
                afterStatsForUid.getDataBytes() - beforeStatsForUid.getDataBytes());

        waitForLeaseExpiration(
                Math.abs(leaseExpiryDurationMs - (System.currentTimeMillis() - startTimeMs)),
                blobData.getBlobHandle());

        afterStatsForPkg = storageStatsManager
                .queryStatsForPackage(UUID_DEFAULT, mContext.getPackageName(), mContext.getUser());
        afterStatsForUid = storageStatsManager
                .queryStatsForUid(UUID_DEFAULT, Process.myUid());

        // Lease is expired, so it should not be attributed anymore.
        assertSizeBytesMostlyEquals(0L,
                afterStatsForPkg.getDataBytes() - beforeStatsForPkg.getDataBytes());
        assertSizeBytesMostlyEquals(0L,
                afterStatsForUid.getDataBytes() - beforeStatsForUid.getDataBytes());

        blobData.delete();
    }"	"/home/gpoor/cts-12-source/cts/tests/BlobStore/src/com/android/cts/blob/BlobStoreManagerTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.musicrecognition.cts.MusicRecognitionManagerTest"	"testRecordAudioOpsAreTracked"	"CtsMusicRecognitionTestCases"	"1: attribution"	"public void testRecordAudioOpsAreTracked() {
        mWatcher.result = new MediaMetadata.Builder()
                .putString(MediaMetadata.METADATA_KEY_ARTIST, ""artist"")
                .putString(MediaMetadata.METADATA_KEY_TITLE, ""title"")
                .build();

        final String packageName = CtsMusicRecognitionService.SERVICE_PACKAGE;
        final int uid = Process.myUid();


        final Context context = getInstrumentation().getContext();

        final AppOpsManager appOpsManager = context.getSystemService(AppOpsManager.class);
        final AppOpsManager.OnOpActiveChangedListener listener = mock(
                AppOpsManager.OnOpActiveChangedListener.class);

        // Assert the app op is not started
        assertFalse(appOpsManager.isOpActive(AppOpsManager.OPSTR_RECORD_AUDIO, uid, packageName));

        // Start watching for record audio op
        appOpsManager.startWatchingActive(new String[] { AppOpsManager.OPSTR_RECORD_AUDIO },
                context.getMainExecutor(), listener);

        // Invoke API
        RecognitionRequest request = invokeMusicRecognitionApi();

        // The app op should start
        String expectedAttributionTag = ""CtsMusicRecognitionAttributionTag"";
        verify(listener, timeout(VERIFY_APPOP_CHANGE_TIMEOUT_MS))
                .onOpActiveChanged(eq(AppOpsManager.OPSTR_RECORD_AUDIO),
                eq(uid), eq(packageName), eq(expectedAttributionTag), eq(true),
                        anyInt(), anyInt());

        // Wait for streaming to finish.
        reset(listener);
        try {
            Thread.sleep(10000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        // The app op should finish
        verify(listener, timeout(VERIFY_APPOP_CHANGE_TIMEOUT_MS))
                .onOpActiveChanged(eq(AppOpsManager.OPSTR_RECORD_AUDIO),
                        eq(uid), eq(packageName), eq(expectedAttributionTag), eq(false),
                        anyInt(), anyInt());


        // Start with a clean slate
        reset(listener);

        // Stop watching for app op
        appOpsManager.stopWatchingActive(listener);

        // No other callbacks expected
        verify(listener, timeout(VERIFY_APPOP_CHANGE_TIMEOUT_MS).times(0))
                .onOpActiveChanged(eq(AppOpsManager.OPSTR_RECORD_AUDIO),
                        anyInt(), anyString(), anyBoolean());
    }


    private RecognitionRequest invokeMusicRecognitionApi() {
        Log.d(TAG, ""Invoking service."");

        AudioRecord record = new AudioRecord(MediaRecorder.AudioSource.MIC, 16_000,
                AudioFormat.CHANNEL_IN_MONO, AudioFormat.ENCODING_PCM_16BIT, 256_000);

        RecognitionRequest request = new RecognitionRequest.Builder()
                .setAudioAttributes(new AudioAttributes.Builder()
                        .setInternalCapturePreset(MediaRecorder.AudioSource.MIC)
                        .build())
                .setAudioFormat(record.getFormat())
                .setCaptureSession(record.getAudioSessionId())
                .setMaxAudioLengthSeconds(8)
                // Drop the first second of audio.
                .setIgnoreBeginningFrames(16_000)
                .build();
        mManager.beginStreamingSearch(
                request,
                MoreExecutors.directExecutor(),
                mCallback);
        Log.d(TAG, ""Invoking service done."");
        return request;
    }

    /**
     * Sets the music recognition service.
     */
    private static void setService(@NonNull String service) {
        Log.d(TAG, ""Setting music recognition service to "" + service);
        int userId = android.os.Process.myUserHandle().getIdentifier();
        runShellCommand(
                ""cmd music_recognition set temporary-service %d %s 60000"", userId, service);
    }

    private static void resetService() {
        Log.d(TAG, ""Resetting music recognition service"");
        int userId = android.os.Process.myUserHandle().getIdentifier();
        runShellCommand(""cmd music_recognition set temporary-service %d"", userId);
    }

    private static void escalateTestPermissions() {
        getInstrumentation().getUiAutomation().adoptShellPermissionIdentity(
                ""android.permission.MANAGE_MUSIC_RECOGNITION"");
    }
}"	"/home/gpoor/cts-12-source/cts/tests/musicrecognition/src/android/musicrecognition/cts/MusicRecognitionManagerTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.autofillservice.cts.inline.InlineLoginActivityTest"	"testLongClickAttribution"	"CtsAutoFillServiceTestCases"	"1: attribution"	"public void testLongClickAttribution() throws Exception {
        // Set service.
        enableService();

        Intent intent = new Intent(mContext, DummyActivity.class);
        PendingIntent pendingIntent =
                PendingIntent.getActivity(mContext, 0, intent, PendingIntent.FLAG_IMMUTABLE);

        final CannedFillResponse.Builder builder = new CannedFillResponse.Builder()
                .addDataset(new CannedFillResponse.CannedDataset.Builder()
                        .setField(ID_USERNAME, ""dude"")
                        .setPresentation(createPresentation(""The Username""))
                        .setInlinePresentation(
                                createInlinePresentation(""The Username"", pendingIntent))
                        .build());

        sReplier.addResponse(builder.build());
        mActivity.expectAutoFill(""dude"");

        // Trigger auto-fill.
        mUiBot.selectByRelativeId(ID_USERNAME);
        mUiBot.waitForIdleSync();

        mUiBot.assertDatasets(""The Username"");

        // Long click on suggestion
        mUiBot.longPressSuggestion(""The Username"");
        mUiBot.waitForIdleSync();

        // Make sure the attribution showed worked
        mUiBot.selectByText(""foo"");

        // Go back to the filled app.
        mUiBot.pressBack();

        sReplier.getNextFillRequest();
        mUiBot.waitForIdleSync();
    }"	"/home/gpoor/cts-12-source/cts/tests/autofillservice/src/android/autofillservice/cts/inline/InlineLoginActivityTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.os.cts.StrictModeTest"	"testIncorrectContextUse_UiDerivedContext_NoViolation"	""	"1: attribution"	"public void testIncorrectContextUse_UiDerivedContext_NoViolation() throws Exception {
        StrictMode.setVmPolicy(
                new StrictMode.VmPolicy.Builder()
                        .detectIncorrectContextUse()
                        .penaltyLog()
                        .build());

        final Configuration config = new Configuration();
        config.setToDefaults();
        final Context uiDerivedConfigContext =
                createWindowContext().createConfigurationContext(config);

        assertNoViolation(() -> uiDerivedConfigContext.getSystemService(WINDOW_SERVICE));

        assertNoViolation(() -> ViewConfiguration.get(uiDerivedConfigContext));

        mInstrumentation.runOnMainSync(() -> {
            try {
                assertNoViolation(() ->
                        new GestureDetector(uiDerivedConfigContext, mGestureListener));
            } catch (Exception e) {
                fail(""Failed because of "" + e);
            }
        });

        if (isWallpaperSupported()) {
            assertNoViolation(() -> uiDerivedConfigContext.getSystemService(WallpaperManager.class)
                    .getDesiredMinimumWidth());
        }

        final Context uiDerivedAttrContext = createWindowContext()
                .createAttributionContext(null /* attributeTag */);

        assertNoViolation(() -> uiDerivedAttrContext.getSystemService(WINDOW_SERVICE));

        assertNoViolation(() -> ViewConfiguration.get(uiDerivedAttrContext));

        mInstrumentation.runOnMainSync(() -> {
            try {
                assertNoViolation(() ->
                        new GestureDetector(uiDerivedAttrContext, mGestureListener));
            } catch (Exception e) {
                fail(""Failed because of "" + e);
            }
        });

        if (isWallpaperSupported()) {
            assertNoViolation(() -> uiDerivedAttrContext.getSystemService(WallpaperManager.class)
                    .getDesiredMinimumWidth());
        }
    }

    @Presubmit"	"/home/gpoor/cts-12-source/cts/tests/tests/os/src/android/os/cts/StrictModeTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.media.cts.MediaPlayerTest"	"exists"	"CtsMediaTestCases"	"1: attribution"	"public void test/*
 *.
 */
package android.media.cts;

import static junit.framework.TestCase.assertEquals;

import android.content.Context;
import android.content.pm.PackageManager;
import android.content.res.AssetFileDescriptor;
import android.graphics.Rect;
import android.hardware.Camera;
import android.media.AudioManager;
import android.media.CamcorderProfile;
import android.media.MediaDataSource;
import android.media.MediaFormat;
import android.media.MediaMetadataRetriever;
import android.media.MediaPlayer;
import android.media.MediaPlayer.OnSeekCompleteListener;
import android.media.MediaPlayer.OnTimedTextListener;
import android.media.MediaRecorder;
import android.media.MediaTimestamp;
import android.media.PlaybackParams;
import android.media.SyncParams;
import android.media.TimedText;
import android.media.audiofx.AudioEffect;
import android.media.audiofx.Visualizer;
import android.media.cts.TestUtils.Monitor;
import android.net.Uri;
import android.os.Bundle;
import android.os.Environment;
import android.os.ParcelFileDescriptor;
import android.os.PowerManager;
import android.os.SystemClock;
import android.platform.test.annotations.AppModeFull;
import android.platform.test.annotations.Presubmit;
import android.platform.test.annotations.RequiresDevice;
import android.util.Log;

import androidx.test.InstrumentationRegistry;
import androidx.test.filters.SmallTest;

import com.android.compatibility.common.util.MediaUtils;

import junit.framework.AssertionFailedError;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import java.util.UUID;
import java.util.Vector;
import java.util.concurrent.BlockingDeque;
import java.util.concurrent.Callable;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.LinkedBlockingDeque;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * Tests for the MediaPlayer API and local video/audio playback.
 *
 * The files in res/raw used by testLocalVideo* are (c) copyright 2008,
 * Blender Foundation / www.bigbuckbunny.org, and are licensed under the Creative Commons
 * Attribution 3.0 License at http://creativecommons.org/licenses/by/3.0/us/.
 */
@SmallTest
@RequiresDevice
@NonMediaMainlineTest
@AppModeFull(reason = ""TODO: evaluate and port to instant"")
public class MediaPlayerTest extends MediaPlayerTestBase {

    private String RECORDED_FILE;
    private static final String LOG_TAG = ""MediaPlayerTest"";

    static final String mInpPrefix = WorkDir.getMediaDirString();

    private static final int  RECORDED_VIDEO_WIDTH  = 176;
    private static final int  RECORDED_VIDEO_HEIGHT = 144;
    private static final long RECORDED_DURATION_MS  = 3000;
    private static final float FLOAT_TOLERANCE = .0001f;

    private final Vector<Integer> mTimedTextTrackIndex = new Vector<>();
    private final Monitor mOnTimedTextCalled = new Monitor();
    private int mSelectedTimedTextIndex;

    private final Vector<Integer> mSubtitleTrackIndex = new Vector<>();
    private final Monitor mOnSubtitleDataCalled = new Monitor();
    private int mSelectedSubtitleIndex;

    private final Monitor mOnMediaTimeDiscontinuityCalled = new Monitor();

    private File mOutFile;

    private int mBoundsCount;

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        RECORDED_FILE = new File(Environment.getExternalStorageDirectory(),
                ""mediaplayer_record.out"").getAbsolutePath();
        mOutFile = new File(RECORDED_FILE);
    }

    @Override
    protected void tearDown() throws Exception {
        super.tearDown();
        if (mOutFile != null && mOutFile.exists()) {
            mOutFile.delete();
        }
    }

    @Presubmit"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/MediaPlayerTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.media.cts.MediaSyncTest"	"MediaSyncTest"	"CtsMediaTestCases"	"1: attribution"	"public void test/*
 *.
 */
package android.media.cts;

import android.content.Context;
import android.content.pm.PackageManager;
import android.media.AudioFormat;
import android.media.AudioManager;
import android.media.AudioTrack;
import android.media.MediaCodec;
import android.media.MediaExtractor;
import android.media.MediaFormat;
import android.media.MediaSync;
import android.media.MediaTimestamp;
import android.media.PlaybackParams;
import android.media.SyncParams;
import android.os.Handler;
import android.os.HandlerThread;
import android.platform.test.annotations.AppModeFull;
import android.platform.test.annotations.RequiresDevice;
import android.test.ActivityInstrumentationTestCase2;
import android.util.Log;
import android.view.Surface;

import androidx.test.filters.SmallTest;

import com.android.compatibility.common.util.MediaUtils;

import java.io.IOException;
import java.lang.Long;
import java.lang.Math;
import java.nio.ByteBuffer;
import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * Tests for the MediaSync API and local video/audio playback.
 *
 * <p>The file in res/raw used by all tests are (c) copyright 2008,
 * Blender Foundation / www.bigbuckbunny.org, and are licensed under the Creative Commons
 * Attribution 3.0 License at http://creativecommons.org/licenses/by/3.0/us/.
 */
@NonMediaMainlineTest
@SmallTest
@RequiresDevice
@AppModeFull(reason = ""TODO: evaluate and port to instant"")
public class MediaSyncTest extends ActivityInstrumentationTestCase2<MediaStubActivity> {
    private static final String LOG_TAG = ""MediaSyncTest"";

    static final String mInpPrefix = WorkDir.getMediaDirString();
    private final long NO_TIMESTAMP = -1;
    private final float FLOAT_PLAYBACK_RATE_TOLERANCE = .02f;
    private final long TIME_MEASUREMENT_TOLERANCE_US = 20000;
    final String INPUT_RESOURCE =
            mInpPrefix + ""video_480x360_mp4_h264_1350kbps_30fps_aac_stereo_192kbps_44100hz.mp4"";
    private final int APPLICATION_AUDIO_PERIOD_MS = 200;
    private final int TEST_MAX_SPEED = 2;
    private static final float FLOAT_TOLERANCE = .00001f;

    private Context mContext;

    private MediaStubActivity mActivity;

    private MediaSync mMediaSync = null;
    private Surface mSurface = null;

    private Decoder mDecoderVideo = null;
    private Decoder mDecoderAudio = null;
    private boolean mHasAudio = false;
    private boolean mHasVideo = false;
    private boolean mEosAudio = false;
    private boolean mEosVideo = false;
    private int mTaggedAudioBufferIndex = -1;
    private final Object mConditionEos = new Object();
    private final Object mConditionEosAudio = new Object();
    private final Object mConditionTaggedAudioBufferIndex = new Object();

    private int mNumBuffersReturned = 0;

    public MediaSyncTest() {
        super(MediaStubActivity.class);
    }

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        mActivity = getActivity();
        getInstrumentation().waitForIdleSync();
        try {
            runTestOnUiThread(new Runnable() {
                public void run() {
                    mMediaSync = new MediaSync();
                }
            });
        } catch (Throwable e) {
            e.printStackTrace();
            fail();
        }
        mContext = getInstrumentation().getTargetContext();
        mDecoderVideo = new Decoder(this, mMediaSync, false);
        mDecoderAudio = new Decoder(this, mMediaSync, true);
    }

    @Override
    protected void tearDown() throws Exception {
        if (mMediaSync != null) {
            mMediaSync.release();
            mMediaSync = null;
        }
        if (mDecoderAudio != null) {
            mDecoderAudio.release();
            mDecoderAudio = null;
        }
        if (mDecoderVideo != null) {
            mDecoderVideo.release();
            mDecoderVideo = null;
        }
        if (mSurface != null) {
            mSurface.release();
            mSurface = null;
        }
        mActivity = null;
        mHasAudio = false;
        mHasVideo = false;
        mEosAudio = false;
        mEosVideo = false;
        mTaggedAudioBufferIndex = -1;
        super.tearDown();
    }

    private boolean reachedEos_l() {
        return ((!mHasVideo || mEosVideo) && (!mHasAudio || mEosAudio));
    }

    public void onTaggedAudioBufferIndex(Decoder decoder, int index) {
        synchronized (mConditionTaggedAudioBufferIndex) {
            if (decoder == mDecoderAudio) {
                mTaggedAudioBufferIndex = index;
            }
        }
    }

    public void onEos(Decoder decoder) {
        synchronized (mConditionEosAudio) {
            if (decoder == mDecoderAudio) {
                mEosAudio = true;
                mConditionEosAudio.notify();
            }
        }

        synchronized (mConditionEos) {
            if (decoder == mDecoderVideo) {
                mEosVideo = true;
            }
            if (reachedEos_l()) {
                mConditionEos.notify();
            }
        }
    }

    private boolean hasAudioOutput() {
        return mActivity.getPackageManager()
            .hasSystemFeature(PackageManager.FEATURE_AUDIO_OUTPUT);
    }

    /**
     * Tests setPlaybackParams is handled correctly for wrong rate.
     */"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/MediaSyncTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.telephony.cts.SmsManagerTest"	"testCreateForSubscriptionId"	"CtsTelephonyTestCases"	"1: attribution"	"public void testCreateForSubscriptionId() {
        int testSubId = 123;
        SmsManager smsManager = mContext.getSystemService(SmsManager.class)
                .createForSubscriptionId(testSubId);
        assertEquals(""getSubscriptionId() should be "" + testSubId, testSubId,
                smsManager.getSubscriptionId());
    }

    protected ArrayList<String> divideMessage(String text) {
        return getSmsManager().divideMessage(text);
    }

    private android.telephony.SmsManager getSmsManager() {
        return android.telephony.SmsManager.getDefault();
    }

    protected void sendMultiPartTextMessage(String destAddr, ArrayList<String> parts,
            ArrayList<PendingIntent> sentIntents, ArrayList<PendingIntent> deliveryIntents,
            boolean addMessageId) {
        if (addMessageId) {
            long fakeMessageId = 1278;
            getSmsManager().sendMultipartTextMessage(destAddr, null, parts, sentIntents,
                    deliveryIntents, fakeMessageId);
        } else if (mContext.getOpPackageName() != null) {
            getSmsManager().sendMultipartTextMessage(destAddr, null, parts, sentIntents,
                    deliveryIntents, mContext.getOpPackageName(), mContext.getAttributionTag());
        } else {
            getSmsManager().sendMultipartTextMessage(destAddr, null, parts, sentIntents,
                    deliveryIntents);
        }
    }

    protected void sendDataMessage(String destAddr,short port, byte[] data, PendingIntent sentIntent, PendingIntent deliveredIntent) {
        getSmsManager().sendDataMessage(destAddr, null, port, data, sentIntent, deliveredIntent);
    }

    protected void sendTextMessage(String destAddr, String text, PendingIntent sentIntent,
            PendingIntent deliveredIntent) {
        getSmsManager().sendTextMessage(destAddr, null, text, sentIntent, deliveredIntent);
    }

    protected void sendTextMessageWithMessageId(String destAddr, String text,
            PendingIntent sentIntent, PendingIntent deliveredIntent, long messageId) {
        getSmsManager().sendTextMessage(destAddr, null, text, sentIntent, deliveredIntent,
                messageId);
    }

    private void blockNumber(String number) {
        mBlockedNumberUri = insertBlockedNumber(mContext, number);
        if (mBlockedNumberUri == null) {
            fail(""Failed to insert into blocked number provider."");
        }
    }

    private void unblockNumber(Uri uri) {
        deleteBlockedNumber(mContext, uri);
    }

    private void setDefaultSmsApp(boolean setToSmsApp)
            throws Exception {
        String command = String.format(
                ""appops set --user 0 %s WRITE_SMS %s"",
                mContext.getPackageName(),
                setToSmsApp ? ""allow"" : ""default"");
        assertTrue(""Setting default SMS app failed : "" + setToSmsApp,
                executeShellCommand(command).isEmpty());
        mTestAppSetAsDefaultSmsApp = setToSmsApp;
    }

    private String executeShellCommand(String command)
            throws IOException {
        ParcelFileDescriptor pfd =
                getInstrumentation().getUiAutomation().executeShellCommand(command);
        BufferedReader br = null;
        try (InputStream in = new FileInputStream(pfd.getFileDescriptor());) {
            br = new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8));
            String str;
            StringBuilder out = new StringBuilder();
            while ((str = br.readLine()) != null) {
                out.append(str);
            }
            return out.toString();
        } finally {
            if (br != null) {
                br.close();
            }
        }
    }

    private static class SmsBroadcastReceiver extends BroadcastReceiver {
        private int mCalls;
        private int mExpectedCalls;
        private String mAction;
        private Object mLock;

        SmsBroadcastReceiver(String action) {
            mAction = action;
            reset();
            mLock = new Object();
        }

        void reset() {
            mExpectedCalls = Integer.MAX_VALUE;
            mCalls = 0;
        }

        @Override
        public void onReceive(Context context, Intent intent) {
            if(mAction.equals(DATA_SMS_RECEIVED_ACTION)){
                StringBuilder sb = new StringBuilder();
                Bundle bundle = intent.getExtras();
                if (bundle != null) {
                    Object[] obj = (Object[]) bundle.get(""pdus"");
                    String format = bundle.getString(""format"");
                    SmsMessage[] message = new SmsMessage[obj.length];
                    for (int i = 0; i < obj.length; i++) {
                        message[i] = SmsMessage.createFromPdu((byte[]) obj[i], format);
                    }

                    for (SmsMessage currentMessage : message) {
                        byte[] binaryContent = currentMessage.getUserData();
                        String readableContent = new String(binaryContent);
                        sb.append(readableContent);
                    }
                }
                mReceivedDataSms = true;
                mReceivedText=sb.toString();
            }
            if (mAction.equals(Telephony.Sms.Intents.SMS_RECEIVED_ACTION)) {
                sMessageId = intent.getLongExtra(""messageId"", 0L);
            }
            Log.i(TAG, ""onReceive "" + intent.getAction() + "" mAction "" + mAction);
            if (intent.getAction().equals(mAction)) {
                synchronized (mLock) {
                    mCalls += 1;
                    mLock.notify();
                }
            }
        }

        private boolean verifyNoCalls(long timeout) throws InterruptedException {
            synchronized(mLock) {
                mLock.wait(timeout);
                return mCalls == 0;
            }
        }

        public boolean waitForCalls(int expectedCalls, long timeout) throws InterruptedException {
            synchronized(mLock) {
                mExpectedCalls = expectedCalls;
                long startTime = SystemClock.elapsedRealtime();

                while (mCalls < mExpectedCalls) {
                    long waitTime = timeout - (SystemClock.elapsedRealtime() - startTime);
                    if (waitTime > 0) {
                        mLock.wait(waitTime);
                    } else {
                        return false;  // timed out
                    }
                }
                return true;  // success
            }
        }
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/SmsManagerTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.app.appops.cts.DiscreteAppopsTest.kt"	"testDeduplicationAttributions"	"CtsAppOpsTestCases"	"1: attribution"	"fun testDeduplicationAttributions() {
        setQuantization(SHORT_TIME_QUANT_MILLIS)
        waitUntilNextQuantStarts(SHORT_TIME_QUANT_MILLIS)
        val timestamp = System.currentTimeMillis() /
                SHORT_TIME_QUANT_MILLIS * SHORT_TIME_QUANT_MILLIS

        noteOp(OPSTR_CAMERA, uid, PACKAGE_NAME, TAG1)
        noteOp(OPSTR_CAMERA, uid, PACKAGE_NAME, TAG2)
        Thread.sleep(SHORT_TIME_QUANT_MILLIS)
        noteOp(OPSTR_CAMERA, uid, PACKAGE_NAME, TAG1)
        var allOps = getHistoricalOps(HISTORY_FLAG_DISCRETE)
        assertThat(allOps).isNotNull()
        assertThat(allOps!!.uidCount).isEqualTo(1)

        var uidOps = allOps.getUidOpsAt(0)
        assertThat(uidOps).isNotNull()
        assertThat(uidOps.uid).isEqualTo(uid)
        assertThat(uidOps.packageCount).isEqualTo(1)

        var packageOps = uidOps.getPackageOpsAt(0)
        assertThat(packageOps).isNotNull()
        assertThat(packageOps.packageName).isEqualTo(PACKAGE_NAME)
        assertThat(packageOps.opCount).isEqualTo(1)

        var op = packageOps.getOpAt(0)
        assertThat(op).isNotNull()
        assertThat(op.opName).isEqualTo(OPSTR_CAMERA)
        assertThat(op.discreteAccessCount).isEqualTo(2)
        var discrete = op.getDiscreteAccessAt(0)
        assertThat(discrete.getLastDuration(OP_FLAGS_ALL)).isEqualTo(-1)
        assertThat(discrete.getLastAccessTime(OP_FLAGS_ALL)).isEqualTo(timestamp)

        discrete = op.getDiscreteAccessAt(1)
        assertThat(discrete.getLastDuration(OP_FLAGS_ALL)).isEqualTo(-1)
        assertThat(discrete.getLastAccessTime(OP_FLAGS_ALL))
                .isEqualTo(timestamp + SHORT_TIME_QUANT_MILLIS)

        assertThat(packageOps.attributedOpsCount).isEqualTo(2)
        var attribution = packageOps.getAttributedOps(TAG1)
        assertThat(attribution).isNotNull()
        assertThat(attribution!!.opCount).isEqualTo(1)
        op = attribution.getOpAt(0)
        assertThat(op).isNotNull()
        assertThat(op.opName).isEqualTo(OPSTR_CAMERA)
        assertThat(op.discreteAccessCount).isEqualTo(2)
        discrete = op.getDiscreteAccessAt(0)
        assertThat(discrete.getLastDuration(OP_FLAGS_ALL)).isEqualTo(-1)
        assertThat(discrete.getLastAccessTime(OP_FLAGS_ALL)).isEqualTo(timestamp)

        discrete = op.getDiscreteAccessAt(1)
        assertThat(discrete.getLastDuration(OP_FLAGS_ALL)).isEqualTo(-1)
        assertThat(discrete.getLastAccessTime(OP_FLAGS_ALL))
                .isEqualTo(timestamp + SHORT_TIME_QUANT_MILLIS)

        attribution = packageOps.getAttributedOps(TAG2)
        assertThat(attribution).isNotNull()
        assertThat(attribution!!.opCount).isEqualTo(1)
        op = attribution.getOpAt(0)
        assertThat(op).isNotNull()
        assertThat(op.opName).isEqualTo(OPSTR_CAMERA)
        assertThat(op.discreteAccessCount).isEqualTo(1)
        discrete = op.getDiscreteAccessAt(0)
        assertThat(discrete.getLastDuration(OP_FLAGS_ALL)).isEqualTo(-1)
        assertThat(discrete.getLastAccessTime(OP_FLAGS_ALL)).isEqualTo(timestamp)
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/appop/src/android/app/appops/cts/DiscreteAppopsTest.kt"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.app.appops.cts.DiscreteAppopsTest.kt"	"testMixedDeduplication"	"CtsAppOpsTestCases"	"1: attribution"	"fun testMixedDeduplication() {
        setQuantization(SHORT_TIME_QUANT_MILLIS)
        waitUntilNextQuantStarts(SHORT_TIME_QUANT_MILLIS)
        makeTop() // pre-warm application uid state change to make it faster during test run
        makeBackground()
        val timestamp = System.currentTimeMillis() /
                SHORT_TIME_QUANT_MILLIS * SHORT_TIME_QUANT_MILLIS
        val timestamp2 = timestamp + SHORT_TIME_QUANT_MILLIS
        val timestamp3 = timestamp2 + SHORT_TIME_QUANT_MILLIS
        val timestamp4 = timestamp3 + SHORT_TIME_QUANT_MILLIS
        // first quant - foreground access in tag1, background in tag2
        noteOp(OPSTR_CAMERA, uid, PACKAGE_NAME, TAG2)
        makeTop()
        noteOp(OPSTR_CAMERA, uid, PACKAGE_NAME, TAG1)
        waitUntilNextQuantStarts(SHORT_TIME_QUANT_MILLIS)

        // second quant - background access in tag1, foreground in tag2
        noteOp(OPSTR_CAMERA, uid, PACKAGE_NAME, TAG2, null)
        makeBackground()
        noteOp(OPSTR_CAMERA, uid, PACKAGE_NAME, TAG1, null)
        makeTop()
        waitUntilNextQuantStarts(SHORT_TIME_QUANT_MILLIS)

        // third quant - single foreground access in tag1, nothing in tag2
        noteOp(OPSTR_CAMERA, uid, PACKAGE_NAME, TAG1, null)
        noteOp(OPSTR_CAMERA, uid, PACKAGE_NAME, TAG1, null)
        noteOp(OPSTR_CAMERA, uid, PACKAGE_NAME, TAG1, null)
        noteOp(OPSTR_CAMERA, uid, PACKAGE_NAME, TAG1, null)
        makeBackground()
        waitUntilNextQuantStarts(SHORT_TIME_QUANT_MILLIS)

        // fourth quant - single background access in tag2, nothing in tag1
        noteOp(OPSTR_CAMERA, uid, PACKAGE_NAME, TAG2, null)
        noteOp(OPSTR_CAMERA, uid, PACKAGE_NAME, TAG2, null)
        var allOps = getHistoricalOps(HISTORY_FLAG_DISCRETE)
        assertThat(allOps).isNotNull()
        assertThat(allOps!!.uidCount).isEqualTo(1)

        var uidOps = allOps.getUidOpsAt(0)
        assertThat(uidOps).isNotNull()
        assertThat(uidOps.uid).isEqualTo(uid)
        assertThat(uidOps.packageCount).isEqualTo(1)

        var packageOps = uidOps.getPackageOpsAt(0)
        assertThat(packageOps).isNotNull()
        assertThat(packageOps.packageName).isEqualTo(PACKAGE_NAME)

        var op = packageOps.getOp(OPSTR_CAMERA)
        assertThat(op).isNotNull()
        assertThat(op.discreteAccessCount).isEqualTo(4)
        var discrete = op.getDiscreteAccessAt(0)
        assertThat(discrete.getLastAccessForegroundTime(OP_FLAGS_ALL)).isEqualTo(timestamp)
        assertThat(discrete.getLastAccessBackgroundTime(OP_FLAGS_ALL)).isEqualTo(timestamp)

        discrete = op.getDiscreteAccessAt(1)
        assertThat(discrete.getLastAccessForegroundTime(OP_FLAGS_ALL)).isEqualTo(timestamp2)
        assertThat(discrete.getLastAccessBackgroundTime(OP_FLAGS_ALL)).isEqualTo(timestamp2)

        discrete = op.getDiscreteAccessAt(2)
        assertThat(discrete.getLastAccessForegroundTime(OP_FLAGS_ALL)).isEqualTo(timestamp3)
        assertThat(discrete.getLastAccessBackgroundTime(OP_FLAGS_ALL)).isEqualTo(-1)

        discrete = op.getDiscreteAccessAt(3)
        assertThat(discrete.getLastAccessForegroundTime(OP_FLAGS_ALL)).isEqualTo(-1)
        assertThat(discrete.getLastAccessBackgroundTime(OP_FLAGS_ALL)).isEqualTo(timestamp4)

        var attribution = packageOps.getAttributedOps(TAG1)
        assertThat(attribution).isNotNull()
        assertThat(attribution!!.opCount).isEqualTo(1)
        op = attribution.getOpAt(0)
        assertThat(op).isNotNull()
        assertThat(op.opName).isEqualTo(OPSTR_CAMERA)
        assertThat(op.discreteAccessCount).isEqualTo(3)
        discrete = op.getDiscreteAccessAt(0)
        assertThat(discrete.getLastAccessForegroundTime(OP_FLAGS_ALL)).isEqualTo(timestamp)
        assertThat(discrete.getLastAccessBackgroundTime(OP_FLAGS_ALL)).isEqualTo(-1)

        discrete = op.getDiscreteAccessAt(1)
        assertThat(discrete.getLastAccessForegroundTime(OP_FLAGS_ALL)).isEqualTo(-1)
        assertThat(discrete.getLastAccessBackgroundTime(OP_FLAGS_ALL)).isEqualTo(timestamp2)

        discrete = op.getDiscreteAccessAt(2)
        assertThat(discrete.getLastAccessForegroundTime(OP_FLAGS_ALL)).isEqualTo(timestamp3)
        assertThat(discrete.getLastAccessBackgroundTime(OP_FLAGS_ALL)).isEqualTo(-1)

        attribution = packageOps.getAttributedOps(TAG2)
        assertThat(attribution).isNotNull()
        assertThat(attribution!!.opCount).isEqualTo(1)
        op = attribution.getOpAt(0)
        assertThat(op).isNotNull()
        assertThat(op.opName).isEqualTo(OPSTR_CAMERA)
        assertThat(op.discreteAccessCount).isEqualTo(3)
        discrete = op.getDiscreteAccessAt(0)
        assertThat(discrete.getLastAccessForegroundTime(OP_FLAGS_ALL)).isEqualTo(-1)
        assertThat(discrete.getLastAccessBackgroundTime(OP_FLAGS_ALL)).isEqualTo(timestamp)

        discrete = op.getDiscreteAccessAt(1)
        assertThat(discrete.getLastAccessForegroundTime(OP_FLAGS_ALL)).isEqualTo(timestamp2)
        assertThat(discrete.getLastAccessBackgroundTime(OP_FLAGS_ALL)).isEqualTo(-1)

        discrete = op.getDiscreteAccessAt(2)
        assertThat(discrete.getLastAccessForegroundTime(OP_FLAGS_ALL)).isEqualTo(-1)
        assertThat(discrete.getLastAccessBackgroundTime(OP_FLAGS_ALL)).isEqualTo(timestamp4)

        // Test the same result using alternative accessors.
        var accesses = op.getBackgroundDiscreteAccesses(OP_FLAGS_ALL)
        assertThat(accesses.size).isEqualTo(2)
        assertThat(accesses[0].getLastAccessTime(OP_FLAGS_ALL)).isEqualTo(timestamp)
        assertThat(accesses[1].getLastAccessTime(OP_FLAGS_ALL)).isEqualTo(timestamp4)

        accesses = op.getForegroundDiscreteAccesses(OP_FLAGS_ALL)
        assertThat(accesses.size).isEqualTo(1)
        assertThat(accesses[0].getLastAccessTime(OP_FLAGS_ALL)).isEqualTo(timestamp2)

        accesses = op.getDiscreteAccesses(UID_STATE_PERSISTENT, UID_STATE_CACHED, OP_FLAGS_ALL)
        assertThat(accesses.size).isEqualTo(3)
        assertThat(accesses[0].getLastAccessTime(OP_FLAGS_ALL)).isEqualTo(timestamp)
        assertThat(accesses[1].getLastAccessTime(OP_FLAGS_ALL)).isEqualTo(timestamp2)
        assertThat(accesses[2].getLastAccessTime(OP_FLAGS_ALL)).isEqualTo(timestamp4)
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/appop/src/android/app/appops/cts/DiscreteAppopsTest.kt"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.app.appops.cts.HistoricalAppopsTest.kt"	"testGetHistoricalAggregationOverAttributions"	"CtsAppOpsTestCases"	"1: attribution"	"fun testGetHistoricalAggregationOverAttributions() {
        // Configure historical registry behavior.
        setHistoryParameters(
                AppOpsManager.HISTORICAL_MODE_ENABLED_ACTIVE,
                SNAPSHOT_INTERVAL_MILLIS,
                INTERVAL_COMPRESSION_MULTIPLIER)

        setUidMode(OPSTR_REQUEST_DELETE_PACKAGES, uid, AppOpsManager.MODE_ALLOWED)

        UidStateForceActivity.waitForResumed()

        appOpsManager.noteOp(OPSTR_REQUEST_DELETE_PACKAGES, uid, packageName, ""firstAttribution"",
                null)
        appOpsManager.noteOp(OPSTR_REQUEST_DELETE_PACKAGES, uid, packageName, ""secondAttribution"",
                null)
        var memOps: AppOpsManager.HistoricalOps? = null
        eventually(SNAPSHOT_INTERVAL_MILLIS / 2) {
            memOps = getHistoricalOps(appOpsManager, uid = uid)!!

            assertThat(memOps!!.getUidOpsAt(0).getPackageOpsAt(0)
                    .getOp(OPSTR_REQUEST_DELETE_PACKAGES)!!.getForegroundAccessCount(OP_FLAGS_ALL))
                    .isEqualTo(2)
            assertThat(memOps!!.getUidOpsAt(0).getPackageOpsAt(0)
                    .getAttributedOps(""firstAttribution"")!!.getOp(OPSTR_REQUEST_DELETE_PACKAGES)!!
                    .getForegroundAccessCount(OP_FLAGS_ALL)).isEqualTo(1)
            assertThat(memOps!!.getUidOpsAt(0).getPackageOpsAt(0)
                    .getAttributedOps(""secondAttribution"")!!.getOp(OPSTR_REQUEST_DELETE_PACKAGES)!!
                    .getForegroundAccessCount(OP_FLAGS_ALL)).isEqualTo(1)
        }

        // Wait until data is on disk and verify no entry got lost
        Thread.sleep(SNAPSHOT_INTERVAL_MILLIS)

        val diskOps = getHistoricalOps(appOpsManager, uid = uid)!!
        assertThat(diskOps.getUidOpsAt(0)).isEqualTo(memOps?.getUidOpsAt(0))
    }

    private fun testHistoricalAggregationSomeLevelsDeep(depth: Int) {
        // Configure historical registry behavior.
        setHistoryParameters(
                AppOpsManager.HISTORICAL_MODE_ENABLED_PASSIVE,
                SNAPSHOT_INTERVAL_MILLIS,
                INTERVAL_COMPRESSION_MULTIPLIER)

        // Add the data to the history
        val chunk = createDataChunk()
        val chunkCount = (computeSlotCount(depth + 1)
            .times(SNAPSHOT_INTERVAL_MILLIS) / chunk.endTimeMillis)
        for (i in 0 until chunkCount) {
            addHistoricalOps(chunk)
        }

        // Validate the data for the full interval
        val intervalBeginMillis = computeIntervalBeginRawMillis(depth)
        val intervalEndMillis = computeIntervalBeginRawMillis(depth + 1)
        val ops = getHistoricalOpsFromDiskRaw(uid, packageName, null /*opNames*/,
                intervalBeginMillis, intervalEndMillis)
        val expectedOpCount = ((computeSlotCount(depth + 1) - computeSlotCount(depth))
            .times(SNAPSHOT_INTERVAL_MILLIS) / chunk.endTimeMillis) * 10
        assertHasCounts(ops!!, expectedOpCount)
    }

    private fun testGetHistoricalPackageOpsForegroundAtDepth(depth: Int) {
        // Configure historical registry behavior.
        setHistoryParameters(
                AppOpsManager.HISTORICAL_MODE_ENABLED_ACTIVE,
                SNAPSHOT_INTERVAL_MILLIS,
                INTERVAL_COMPRESSION_MULTIPLIER)

        setUidMode(AppOpsManager.OPSTR_START_FOREGROUND, uid,
                AppOpsManager.MODE_ALLOWED)
        setUidMode(AppOpsManager.OPSTR_START_FOREGROUND, 2000,
                AppOpsManager.MODE_ALLOWED)

        UidStateForceActivity.waitForResumed()

        try {
            val noteCount = 5

            var beginTimeMillis = 0L
            var endTimeMillis = 0L

            // Note ops such that we have data at all levels
            for (d in depth downTo 0) {
                for (i in 0 until noteCount) {
                    appOpsManager.noteOp(AppOpsManager.OPSTR_START_FOREGROUND, uid, packageName)
                }

                if (d > 0) {
                    val previousIntervalDuration = computeIntervalDurationMillis(d - 2)
                    val currentIntervalDuration = computeIntervalDurationMillis(d - 1)

                    endTimeMillis -= previousIntervalDuration
                    beginTimeMillis -= currentIntervalDuration

                    val sleepDurationMillis = currentIntervalDuration / 2
                    SystemClock.sleep(sleepDurationMillis)
                }
            }

            val nowMillis = System.currentTimeMillis()
            if (depth > 0) {
                beginTimeMillis += nowMillis
                endTimeMillis += nowMillis
            } else {
                beginTimeMillis = nowMillis - SNAPSHOT_INTERVAL_MILLIS
                endTimeMillis = Long.MAX_VALUE
            }

            // Get all ops for the package
            val allOps = getHistoricalOps(appOpsManager, uid, packageName,
                    null, beginTimeMillis, endTimeMillis)

            assertThat(allOps).isNotNull()
            assertThat(allOps!!.uidCount).isEqualTo(1)
            assertThat(allOps.beginTimeMillis).isEqualTo(beginTimeMillis)
            assertThat(allOps.endTimeMillis).isGreaterThan(beginTimeMillis)

            val uidOps = allOps.getUidOpsAt(0)
            assertThat(uidOps).isNotNull()
            assertThat(uidOps.uid).isEqualTo(Process.myUid())
            assertThat(uidOps.packageCount).isEqualTo(1)

            val packageOps = uidOps.getPackageOpsAt(0)
            assertThat(packageOps).isNotNull()
            assertThat(packageOps.packageName).isEqualTo(packageName)
            assertThat(packageOps.opCount).isEqualTo(1)

            val op = packageOps.getOpAt(0)
            assertThat(op).isNotNull()
            assertThat(op.opName).isEqualTo(AppOpsManager.OPSTR_START_FOREGROUND)

            assertThat(op.getForegroundAccessCount(AppOpsManager.OP_FLAGS_ALL))
                    .isEqualTo(noteCount)
            assertThat(op.getBackgroundAccessCount(AppOpsManager.OP_FLAGS_ALL)).isEqualTo(0)
            assertThat(getAccessCount(op, AppOpsManager.UID_STATE_PERSISTENT)).isEqualTo(0)
            assertThat(getAccessCount(op, AppOpsManager.UID_STATE_TOP)).isEqualTo(noteCount)
            assertThat(getAccessCount(op, AppOpsManager.UID_STATE_FOREGROUND_SERVICE_LOCATION))
                    .isEqualTo(0)
            assertThat(getAccessCount(op, AppOpsManager.UID_STATE_FOREGROUND_SERVICE))
                    .isEqualTo(0)
            assertThat(getAccessCount(op, AppOpsManager.UID_STATE_FOREGROUND)).isEqualTo(0)
            assertThat(getAccessCount(op, AppOpsManager.UID_STATE_BACKGROUND)).isEqualTo(0)
            assertThat(getAccessCount(op, AppOpsManager.UID_STATE_CACHED)).isEqualTo(0)

            assertThat(op.getForegroundAccessDuration(AppOpsManager.OP_FLAGS_ALL)).isEqualTo(0)
            assertThat(op.getBackgroundAccessDuration(AppOpsManager.OP_FLAGS_ALL)).isEqualTo(0)
            assertThat(op.getAccessDuration(AppOpsManager.UID_STATE_TOP,
                    AppOpsManager.UID_STATE_BACKGROUND, AppOpsManager.OP_FLAGS_ALL))
                    .isEqualTo(0)
            assertThat(getAccessDuration(op, AppOpsManager.UID_STATE_PERSISTENT)).isEqualTo(0)
            assertThat(getAccessDuration(op, AppOpsManager.UID_STATE_TOP)).isEqualTo(0)
            assertThat(getAccessDuration(op, AppOpsManager.UID_STATE_FOREGROUND_SERVICE_LOCATION))
                    .isEqualTo(0)
            assertThat(getAccessDuration(op, AppOpsManager.UID_STATE_FOREGROUND_SERVICE))
                    .isEqualTo(0)
            assertThat(getAccessDuration(op, AppOpsManager.UID_STATE_FOREGROUND)).isEqualTo(0)
            assertThat(getAccessDuration(op, AppOpsManager.UID_STATE_BACKGROUND)).isEqualTo(0)
            assertThat(getAccessDuration(op, AppOpsManager.UID_STATE_CACHED)).isEqualTo(0)

            assertThat(op.getForegroundRejectCount(AppOpsManager.OP_FLAGS_ALL)).isEqualTo(0)
            assertThat(op.getBackgroundRejectCount(AppOpsManager.OP_FLAGS_ALL)).isEqualTo(0)
            assertThat(op.getRejectCount(AppOpsManager.UID_STATE_TOP,
                    AppOpsManager.UID_STATE_BACKGROUND, AppOpsManager.OP_FLAGS_ALL))
                    .isEqualTo(0)
            assertThat(getRejectCount(op, AppOpsManager.UID_STATE_PERSISTENT)).isEqualTo(0)
            assertThat(getRejectCount(op, AppOpsManager.UID_STATE_TOP)).isEqualTo(0)
            assertThat(getRejectCount(op, AppOpsManager.UID_STATE_FOREGROUND_SERVICE_LOCATION))
                    .isEqualTo(0)
            assertThat(getRejectCount(op, AppOpsManager.UID_STATE_FOREGROUND_SERVICE))
                    .isEqualTo(0)
            assertThat(getRejectCount(op, AppOpsManager.UID_STATE_FOREGROUND)).isEqualTo(0)
            assertThat(getRejectCount(op, AppOpsManager.UID_STATE_BACKGROUND)).isEqualTo(0)
            assertThat(getRejectCount(op, AppOpsManager.UID_STATE_CACHED)).isEqualTo(0)
        } finally {
            setUidMode(AppOpsManager.OPSTR_START_FOREGROUND, uid, AppOpsManager.MODE_FOREGROUND)
            setUidMode(AppOpsManager.OPSTR_START_FOREGROUND, 2000, AppOpsManager.MODE_FOREGROUND)
        }
    }

    private fun createDataChunk(): HistoricalOps {
        val chunk = HistoricalOps(SNAPSHOT_INTERVAL_MILLIS / 4,
                SNAPSHOT_INTERVAL_MILLIS / 2)
        chunk.increaseAccessCount(AppOpsManager.OP_START_FOREGROUND, uid, packageName, null,
                AppOpsManager.UID_STATE_TOP, AppOpsManager.OP_FLAG_SELF, 10)
        chunk.increaseAccessCount(AppOpsManager.OP_START_FOREGROUND, uid, packageName, null,
                AppOpsManager.UID_STATE_BACKGROUND, AppOpsManager.OP_FLAG_SELF, 10)
        chunk.increaseRejectCount(AppOpsManager.OP_START_FOREGROUND, uid, packageName, null,
                AppOpsManager.UID_STATE_TOP, AppOpsManager.OP_FLAG_SELF, 10)
        chunk.increaseRejectCount(AppOpsManager.OP_START_FOREGROUND, uid, packageName, null,
                AppOpsManager.UID_STATE_BACKGROUND, AppOpsManager.OP_FLAG_SELF, 10)
        chunk.increaseAccessDuration(AppOpsManager.OP_START_FOREGROUND, uid, packageName, null,
                AppOpsManager.UID_STATE_TOP, AppOpsManager.OP_FLAG_SELF, 10)
        chunk.increaseAccessDuration(AppOpsManager.OP_START_FOREGROUND, uid, packageName, null,
                AppOpsManager.UID_STATE_BACKGROUND, AppOpsManager.OP_FLAG_SELF, 10)
        return chunk
    }

    private fun setHistoryParameters(
        mode: Int,
        baseSnapshotInterval: Long,
        compressionStep: Int
    ) {
        runWithShellPermissionIdentity {
            appOpsManager.setHistoryParameters(mode, baseSnapshotInterval, compressionStep)
        }
    }

    private fun setUidMode(appOp: String, uid: Int, mode: Int) {
        runWithShellPermissionIdentity {
            appOpsManager.setUidMode(appOp, uid, mode)
        }
    }

    private fun addHistoricalOps(ops: AppOpsManager.HistoricalOps) {
        runWithShellPermissionIdentity {
            appOpsManager.addHistoricalOps(ops)
        }
    }

    private fun getHistoricalOps(
        appOpsManager: AppOpsManager,
        uid: Int = Process.INVALID_UID,
        packageName: String? = null,
        opNames: List<String>? = null,
        beginTimeMillis: Long = 0,
        endTimeMillis: Long = Long.MAX_VALUE
    ): HistoricalOps? {
        uiAutomation.adoptShellPermissionIdentity()
        val array = arrayOfNulls<HistoricalOps>(1)
        val lock = ReentrantLock()
        val condition = lock.newCondition()
        try {
            lock.lock()
            val request = AppOpsManager.HistoricalOpsRequest.Builder(
                    beginTimeMillis, endTimeMillis)
                    .setUid(uid)
                    .setPackageName(packageName)
                    .setOpNames(opNames?.toList())
                    .build()
            appOpsManager.getHistoricalOps(request, context.mainExecutor, Consumer { ops ->
                array[0] = ops
                try {
                    lock.lock()
                    condition.signalAll()
                } finally {
                    lock.unlock()
                }
            })
            condition.await(5, TimeUnit.SECONDS)
            return array[0]
        } finally {
            lock.unlock()
            uiAutomation.dropShellPermissionIdentity()
        }
    }

    private fun assertHasCounts(ops: HistoricalOps, count: Long) {
        assertThat(ops).isNotNull()

        if (count <= 0) {
            assertThat(ops.uidCount).isEqualTo(0)
            return
        }

        assertThat(ops.uidCount).isEqualTo(1)

        val uidOps = ops.getUidOpsAt(0)
        assertThat(uidOps).isNotNull()

        val packageOps = uidOps.getPackageOpsAt(0)
        assertThat(packageOps).isNotNull()

        val op = packageOps.getOpAt(0)
        assertThat(op).isNotNull()

        assertThat(op.getForegroundAccessCount(AppOpsManager.OP_FLAGS_ALL)).isEqualTo(count)
        assertThat(op.getBackgroundAccessCount(AppOpsManager.OP_FLAGS_ALL)).isEqualTo(count)
        assertThat(op.getForegroundRejectCount(AppOpsManager.OP_FLAGS_ALL)).isEqualTo(count)
        assertThat(op.getBackgroundRejectCount(AppOpsManager.OP_FLAGS_ALL)).isEqualTo(count)
        assertThat(op.getForegroundAccessDuration(AppOpsManager.OP_FLAGS_ALL)).isEqualTo(count)
        assertThat(op.getBackgroundAccessDuration(AppOpsManager.OP_FLAGS_ALL)).isEqualTo(count)
    }

    private fun getAccessCount(op: HistoricalOp, uidState: Int): Long {
        return op.getAccessCount(uidState, uidState, AppOpsManager.OP_FLAGS_ALL)
    }

    private fun getRejectCount(op: HistoricalOp, uidState: Int): Long {
        return op.getRejectCount(uidState, uidState, AppOpsManager.OP_FLAGS_ALL)
    }

    private fun getAccessDuration(op: HistoricalOp, uidState: Int): Long {
        return op.getAccessDuration(uidState, uidState, AppOpsManager.OP_FLAGS_ALL)
    }

    private fun getHistoricalOpsFromDiskRaw(
        uid: Int,
        packageName: String,
        opNames: List<String>?,
        beginTimeMillis: Long,
        endTimeMillis: Long
    ): HistoricalOps? {
        uiAutomation.adoptShellPermissionIdentity()
        val array = arrayOfNulls<HistoricalOps>(1)
        val lock = ReentrantLock()
        val condition = lock.newCondition()
        try {
            lock.lock()
            val request = AppOpsManager.HistoricalOpsRequest.Builder(
                    beginTimeMillis, endTimeMillis)
                    .setUid(uid)
                    .setPackageName(packageName)
                    .setOpNames(opNames?.toList())
                    .build()
            appOpsManager.getHistoricalOpsFromDiskRaw(request, context.mainExecutor,
                    Consumer { ops ->
                        array[0] = ops
                        try {
                            lock.lock()
                            condition.signalAll()
                        } finally {
                            lock.unlock()
                        }
                    })
            condition.await(5, TimeUnit.SECONDS)
            return array[0]
        } finally {
            lock.unlock()
            uiAutomation.dropShellPermissionIdentity()
        }
    }

    companion object {
        const val INTERVAL_COMPRESSION_MULTIPLIER = 10
        const val SNAPSHOT_INTERVAL_MILLIS = 1000L

        val instrumentation get() = InstrumentationRegistry.getInstrumentation()
        val context get() = instrumentation.context
        val uiAutomation get() = instrumentation.uiAutomation

        private fun computeIntervalDurationMillis(depth: Int): Long {
            return Math.pow(INTERVAL_COMPRESSION_MULTIPLIER.toDouble(),
                    (depth + 1).toDouble()).toLong() * SNAPSHOT_INTERVAL_MILLIS
        }

        private fun computeSlotCount(depth: Int): Int {
            var count = 0
            for (i in 1..depth) {
                count += Math.pow(INTERVAL_COMPRESSION_MULTIPLIER.toDouble(), i.toDouble()).toInt()
            }
            return count
        }

        private fun computeIntervalBeginRawMillis(depth: Int): Long {
            var beginTimeMillis: Long = 0
            for (i in 0 until depth + 1) {
                beginTimeMillis += Math.pow(INTERVAL_COMPRESSION_MULTIPLIER.toDouble(),
                        i.toDouble()).toLong()
            }
            return beginTimeMillis * SNAPSHOT_INTERVAL_MILLIS
        }
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/appop/src/android/app/appops/cts/HistoricalAppopsTest.kt"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.content.cts.ContextTest"	"getContextUnderTest"	"CtsContentTestCases"	"1: attribution"	"public void test/*
 *.
 */

package android.content.cts;

import static android.content.pm.PackageManager.PERMISSION_DENIED;
import static android.content.pm.PackageManager.PERMISSION_GRANTED;

import static androidx.test.platform.app.InstrumentationRegistry.getInstrumentation;

import android.app.Activity;
import android.app.AppOpsManager;
import android.app.Instrumentation;
import android.app.WallpaperManager;
import android.content.ActivityNotFoundException;
import android.content.AttributionSource;
import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.Context;
import android.content.ContextParams;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.ServiceConnection;
import android.content.SharedPreferences;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.content.res.ColorStateList;
import android.content.res.Resources.NotFoundException;
import android.content.res.Resources.Theme;
import android.content.res.TypedArray;
import android.content.res.XmlResourceParser;
import android.database.Cursor;
import android.database.sqlite.SQLiteCursorDriver;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteQuery;
import android.graphics.Bitmap;
import android.graphics.drawable.BitmapDrawable;
import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.os.Binder;
import android.os.Bundle;
import android.os.Handler;
import android.os.IBinder;
import android.os.Looper;
import android.os.Process;
import android.os.UserHandle;
import android.platform.test.annotations.AppModeFull;
import android.preference.PreferenceManager;
import android.test.AndroidTestCase;
import android.util.AttributeSet;
import android.util.Log;
import android.util.Xml;
import android.view.WindowManager;

import com.android.compatibility.common.util.PollingCheck;
import com.android.compatibility.common.util.ShellIdentityUtils;
import com.android.compatibility.common.util.SystemUtil;
import com.android.cts.IBinderPermissionTestService;

import org.xmlpull.v1.XmlPullParser;
import org.xmlpull.v1.XmlPullParserException;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

@AppModeFull // TODO(Instant) Figure out which APIs should work.
public class ContextTest extends AndroidTestCase {
    private static final String TAG = ""ContextTest"";
    private static final String ACTUAL_RESULT = ""ResultSetByReceiver"";

    private static final String INTIAL_RESULT = ""IntialResult"";

    private static final String VALUE_ADDED = ""ValueAdded"";
    private static final String KEY_ADDED = ""AddedByReceiver"";

    private static final String VALUE_REMOVED = ""ValueWillBeRemove"";
    private static final String KEY_REMOVED = ""ToBeRemoved"";

    private static final String VALUE_KEPT = ""ValueKept"";
    private static final String KEY_KEPT = ""ToBeKept"";

    private static final String MOCK_STICKY_ACTION = ""android.content.cts.ContextTest.""
            + ""STICKY_BROADCAST_RESULT"";

    private static final String ACTION_BROADCAST_TESTORDER =
            ""android.content.cts.ContextTest.BROADCAST_TESTORDER"";
    private final static String MOCK_ACTION1 = ACTION_BROADCAST_TESTORDER + ""1"";
    private final static String MOCK_ACTION2 = ACTION_BROADCAST_TESTORDER + ""2"";

    // Note: keep these constants in sync with the permissions used by BinderPermissionTestService.
    //
    // A permission that's granted to this test package.
    public static final String GRANTED_PERMISSION = ""android.permission.USE_CREDENTIALS"";
    // A permission that's not granted to this test package.
    public static final String NOT_GRANTED_PERMISSION = ""android.permission.HARDWARE_TEST"";

    private static final int BROADCAST_TIMEOUT = 10000;
    private static final int ROOT_UID = 0;

    private Object mLockObj;

    private ArrayList<BroadcastReceiver> mRegisteredReceiverList;

    private boolean mWallpaperChanged;
    private BitmapDrawable mOriginalWallpaper;
    private volatile IBinderPermissionTestService mBinderPermissionTestService;
    private ServiceConnection mBinderPermissionTestConnection;

    protected Context mContext;

    /**
     * Returns the Context object that's being tested.
     */
    protected Context getContextUnderTest() {
        return getContext();
    }

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        mContext = getContextUnderTest();
        mContext.setTheme(R.style.Test_Theme);

        mLockObj = new Object();

        mRegisteredReceiverList = new ArrayList<BroadcastReceiver>();

        mOriginalWallpaper = (BitmapDrawable) mContext.getWallpaper();
    }

    @Override
    protected void tearDown() throws Exception {
        if (mWallpaperChanged) {
            mContext.setWallpaper(mOriginalWallpaper.getBitmap());
        }

        for (BroadcastReceiver receiver : mRegisteredReceiverList) {
            mContext.unregisterReceiver(receiver);
        }

        super.tearDown();
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContextTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.content.cts.ContextTest"	"testCreateAttributionContext"	"CtsContentTestCases"	"1: attribution"	"public void testCreateAttributionContext() throws Exception {
        final String tag = ""testCreateAttributionContext"";
        final Context attrib = mContext.createAttributionContext(tag);
        assertEquals(tag, attrib.getAttributionTag());
        assertEquals(null, mContext.getAttributionTag());
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContextTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.content.cts.ContextTest"	"testCreateAttributionContextFromParams"	"CtsContentTestCases"	"1: attribution"	"public void testCreateAttributionContextFromParams() throws Exception {
        final ContextParams params = new ContextParams.Builder()
                .setAttributionTag(""foo"")
                .setNextAttributionSource(new AttributionSource.Builder(1)
                        .setPackageName(""bar"")
                        .setAttributionTag(""baz"")
                        .build())
                .build();
        final Context attributionContext = getContext().createContext(params);

        assertEquals(params, attributionContext.getParams());
        assertEquals(params.getNextAttributionSource(),
                attributionContext.getAttributionSource().getNext());
        assertEquals(params.getAttributionTag(),
                attributionContext.getAttributionSource().getAttributionTag());
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContextTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.content.cts.ContextTest"	"testContextParams"	"CtsContentTestCases"	"1: attribution"	"public void testContextParams() throws Exception {
        final ContextParams params = new ContextParams.Builder()
                .setAttributionTag(""foo"")
                .setNextAttributionSource(new AttributionSource.Builder(1)
                        .setPackageName(""bar"")
                        .setAttributionTag(""baz"")
                        .build())
                .build();

        assertEquals(""foo"", params.getAttributionTag());
        assertEquals(1, params.getNextAttributionSource().getUid());
        assertEquals(""bar"", params.getNextAttributionSource().getPackageName());
        assertEquals(""baz"", params.getNextAttributionSource().getAttributionTag());
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContextTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.content.cts.ContextTest"	"testAttributionSourceSetNext"	"CtsContentTestCases"	"1: attribution"	"public void testAttributionSourceSetNext() throws Exception {
        final AttributionSource next = new AttributionSource.Builder(2)
                .setPackageName(""nextBar"")
                .setAttributionTag(""nextBaz"")
                .build();
        final ContextParams params = new ContextParams.Builder()
                .setAttributionTag(""foo"")
                .setNextAttributionSource(new AttributionSource.Builder(1)
                        .setPackageName(""bar"")
                        .setAttributionTag(""baz"")
                        .setNext(next)
                        .build())
                .build();

        // Setting a 'next' should not affect prev.
        assertEquals(""foo"", params.getAttributionTag());
        assertEquals(1, params.getNextAttributionSource().getUid());
        assertEquals(""bar"", params.getNextAttributionSource().getPackageName());
        assertEquals(""baz"", params.getNextAttributionSource().getAttributionTag());

        final AttributionSource check =
                params.getNextAttributionSource().getNext();
        assertEquals(2, check.getUid());
        assertEquals(""nextBar"", check.getPackageName());
        assertEquals(""nextBaz"", check.getAttributionTag());
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContextTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.content.cts.ContextTest"	"testContextParams_Inherit"	"CtsContentTestCases"	"1: attribution"	"public void testContextParams_Inherit() throws Exception {
        final ContextParams orig = new ContextParams.Builder()
                .setAttributionTag(""foo"").build();
        {
            final ContextParams params = new ContextParams.Builder(orig).build();
            assertEquals(""foo"", params.getAttributionTag());
        }
        {
            final ContextParams params = new ContextParams.Builder(orig)
                    .setAttributionTag(""bar"").build();
            assertEquals(""bar"", params.getAttributionTag());
        }
        {
            final ContextParams params = new ContextParams.Builder(orig)
                    .setAttributionTag(null).build();
            assertEquals(null, params.getAttributionTag());
        }
    }

    /**
     * Ensure that default and device encrypted storage areas are stored
     * separately on disk. All devices must support these storage areas, even if
     * they don't have file-based encryption, so that apps can go through a
     * backup/restore cycle between FBE and non-FBE devices.
     */"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContextTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.content.cts.ContentProviderClientTest"	"isCanceled"	"CtsContentTestCases"	"1: attribution"	"public void test/*
 *.
 */

package android.content.cts;

import static org.mockito.Mockito.doAnswer;
import static org.mockito.Mockito.doReturn;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.spy;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.RETURNS_DEFAULTS;

import android.content.AttributionSource;
import android.content.ContentProvider;
import android.content.ContentProviderClient;
import android.content.ContentProviderOperation;
import android.content.ContentResolver;
import android.content.ContentValues;
import android.content.Context;
import android.content.ContextParams;
import android.content.IContentProvider;
import android.content.OperationApplicationException;
import android.net.Uri;
import android.os.Bundle;
import android.os.CancellationSignal;
import android.os.ICancellationSignal;
import android.os.OperationCanceledException;
import android.os.Process;
import android.os.RemoteException;
import android.test.AndroidTestCase;
import android.test.mock.MockContentResolver;

import org.mockito.stubbing.Answer;

import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

/**
 * Simple delegation test for {@link ContentProviderClient}, checking the right methods are called.
 * Actual {@link ContentProvider} functionality is tested in {@link ContentProviderTest}.
 */
public class ContentProviderClientTest extends AndroidTestCase {

    private static final Answer ANSWER_SLEEP = invocation -> {
        // Sleep long enough to trigger ANR
        Thread.sleep(100);
        return null;
    };

    private static final String PACKAGE_NAME = ""android.content.cts"";
    private static final String FEATURE_ID = ""testFeature"";
    private static final String MODE = ""mode"";
    private static final String AUTHORITY = ""authority"";
    private static final String METHOD = ""method"";
    private static final String ARG = ""arg"";
    private static final Uri URI = Uri.parse(""com.example.app://path"");
    private static final Bundle ARGS = new Bundle();
    private static final Bundle EXTRAS = new Bundle();
    private static final ContentValues VALUES = new ContentValues();
    private static final ContentValues[] VALUES_ARRAY = {VALUES};
    private static final ArrayList<ContentProviderOperation> OPS = new ArrayList<>();

    private ContentResolver mContentResolver;
    private IContentProvider mIContentProvider;
    private ContentProviderClient mContentProviderClient;
    private AttributionSource mAttributionSource;

    private CancellationSignal mCancellationSignal = new CancellationSignal();
    private ICancellationSignal mICancellationSignal;
    private boolean mCalledCancel = false;

    @Override
    public void setUp() throws Exception {
        super.setUp();

        mIContentProvider = mock(IContentProvider.class, RETURNS_DEFAULTS);
        mICancellationSignal = mock(ICancellationSignal.class);

        doReturn(mICancellationSignal).when(mIContentProvider).createCancellationSignal();

        final Context attributionContext = getContext().createContext(
                new ContextParams.Builder()
                        .setAttributionTag(FEATURE_ID)
                        .build());

        mAttributionSource = attributionContext.getAttributionSource();
        mContentResolver = spy(new MockContentResolver(attributionContext));
        mContentProviderClient = spy(new ContentProviderClient(mContentResolver, mIContentProvider,
                false));

        mCalledCancel = false;
    }

    @Override
    protected void tearDown() throws Exception {
        super.tearDown();
        if (!mCalledCancel) {
            // Client should never cancel unless the test called cancel
            assertFalse(mCancellationSignal.isCanceled());
            verify(mICancellationSignal, never()).cancel();
        }
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContentProviderClientTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.content.cts.ContentProviderClientTest"	"testQuery"	"CtsContentTestCases"	"1: attribution"	"public void testQuery() throws RemoteException {
        mContentProviderClient.query(URI, null, ARGS, mCancellationSignal);
        verify(mIContentProvider).query(mAttributionSource, URI, null, ARGS,
                mICancellationSignal);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContentProviderClientTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.content.cts.ContentProviderClientTest"	"testQueryTimeout"	"CtsContentTestCases"	"1: attribution"	"public void testQueryTimeout() throws RemoteException, InterruptedException {
        doAnswer(ANSWER_SLEEP).when(mIContentProvider).query(mAttributionSource, URI, null,
                ARGS, mICancellationSignal);

        testTimeout(() -> mContentProviderClient.query(URI, null, ARGS, mCancellationSignal));

        verify(mIContentProvider).query(mAttributionSource, URI, null, ARGS,
                mICancellationSignal);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContentProviderClientTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.content.cts.ContentProviderClientTest"	"testQueryAlreadyCancelled"	"CtsContentTestCases"	"1: attribution"	"public void testQueryAlreadyCancelled() throws Exception {
        testAlreadyCancelled(
                () -> mContentProviderClient.query(URI, null, ARGS, mCancellationSignal));
        verify(mIContentProvider, never()).query(mAttributionSource, URI, null, ARGS,
                mICancellationSignal);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContentProviderClientTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.content.cts.ContentProviderClientTest"	"testCanonicalize"	"CtsContentTestCases"	"1: attribution"	"public void testCanonicalize() throws RemoteException {
        mContentProviderClient.canonicalize(URI);
        verify(mIContentProvider).canonicalize(mAttributionSource, URI);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContentProviderClientTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.content.cts.ContentProviderClientTest"	"testCanonicalizeTimeout"	"CtsContentTestCases"	"1: attribution"	"public void testCanonicalizeTimeout() throws RemoteException, InterruptedException {
        doAnswer(ANSWER_SLEEP).when(mIContentProvider).canonicalize(mAttributionSource, URI);

        testTimeout(() -> mContentProviderClient.canonicalize(URI));

        verify(mIContentProvider).canonicalize(mAttributionSource, URI);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContentProviderClientTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.content.cts.ContentProviderClientTest"	"testUncanonicalize"	"CtsContentTestCases"	"1: attribution"	"public void testUncanonicalize() throws RemoteException {
        mContentProviderClient.uncanonicalize(URI);
        verify(mIContentProvider).uncanonicalize(mAttributionSource, URI);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContentProviderClientTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.content.cts.ContentProviderClientTest"	"testUncanonicalizeTimeout"	"CtsContentTestCases"	"1: attribution"	"public void testUncanonicalizeTimeout() throws RemoteException, InterruptedException {
        doAnswer(ANSWER_SLEEP).when(mIContentProvider).uncanonicalize(mAttributionSource, URI);

        testTimeout(() -> mContentProviderClient.uncanonicalize(URI));

        verify(mIContentProvider).uncanonicalize(mAttributionSource, URI);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContentProviderClientTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.content.cts.ContentProviderClientTest"	"testRefresh"	"CtsContentTestCases"	"1: attribution"	"public void testRefresh() throws RemoteException {
        mContentProviderClient.refresh(URI, ARGS, mCancellationSignal);
        verify(mIContentProvider).refresh(mAttributionSource, URI, ARGS,
                mICancellationSignal);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContentProviderClientTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.content.cts.ContentProviderClientTest"	"testRefreshTimeout"	"CtsContentTestCases"	"1: attribution"	"public void testRefreshTimeout() throws RemoteException, InterruptedException {
        doAnswer(ANSWER_SLEEP).when(mIContentProvider).refresh(mAttributionSource, URI, ARGS,
                mICancellationSignal);

        testTimeout(() -> mContentProviderClient.refresh(URI, ARGS, mCancellationSignal));

        verify(mIContentProvider).refresh(mAttributionSource, URI, ARGS,
                mICancellationSignal);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContentProviderClientTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.content.cts.ContentProviderClientTest"	"testRefreshAlreadyCancelled"	"CtsContentTestCases"	"1: attribution"	"public void testRefreshAlreadyCancelled() throws Exception {
        testAlreadyCancelled(() -> mContentProviderClient.refresh(URI, ARGS, mCancellationSignal));
        verify(mIContentProvider, never()).refresh(mAttributionSource, URI, ARGS,
                mICancellationSignal);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContentProviderClientTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.content.cts.ContentProviderClientTest"	"testInsert"	"CtsContentTestCases"	"1: attribution"	"public void testInsert() throws RemoteException {
        mContentProviderClient.insert(URI, VALUES, EXTRAS);
        verify(mIContentProvider).insert(mAttributionSource, URI, VALUES, EXTRAS);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContentProviderClientTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.content.cts.ContentProviderClientTest"	"testInsertTimeout"	"CtsContentTestCases"	"1: attribution"	"public void testInsertTimeout() throws RemoteException, InterruptedException {
        doAnswer(ANSWER_SLEEP).when(mIContentProvider).insert(mAttributionSource, URI,
                VALUES, EXTRAS);

        testTimeout(() -> mContentProviderClient.insert(URI, VALUES, EXTRAS));

        verify(mIContentProvider).insert(mAttributionSource, URI, VALUES, EXTRAS);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContentProviderClientTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.content.cts.ContentProviderClientTest"	"testBulkInsert"	"CtsContentTestCases"	"1: attribution"	"public void testBulkInsert() throws RemoteException {
        mContentProviderClient.bulkInsert(URI, VALUES_ARRAY);
        verify(mIContentProvider).bulkInsert(mAttributionSource, URI, VALUES_ARRAY);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContentProviderClientTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.content.cts.ContentProviderClientTest"	"testBulkInsertTimeout"	"CtsContentTestCases"	"1: attribution"	"public void testBulkInsertTimeout() throws RemoteException, InterruptedException {
        doAnswer(ANSWER_SLEEP).when(mIContentProvider).bulkInsert(mAttributionSource, URI,
                VALUES_ARRAY);

        testTimeout(() -> mContentProviderClient.bulkInsert(URI, VALUES_ARRAY));

        verify(mIContentProvider).bulkInsert(mAttributionSource, URI, VALUES_ARRAY);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContentProviderClientTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.content.cts.ContentProviderClientTest"	"testDelete"	"CtsContentTestCases"	"1: attribution"	"public void testDelete() throws RemoteException {
        mContentProviderClient.delete(URI, EXTRAS);
        verify(mIContentProvider).delete(mAttributionSource, URI, EXTRAS);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContentProviderClientTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.content.cts.ContentProviderClientTest"	"testDeleteTimeout"	"CtsContentTestCases"	"1: attribution"	"public void testDeleteTimeout() throws RemoteException, InterruptedException {
        doAnswer(ANSWER_SLEEP).when(mIContentProvider).delete(mAttributionSource, URI, EXTRAS);

        testTimeout(() -> mContentProviderClient.delete(URI, EXTRAS));

        verify(mIContentProvider).delete(mAttributionSource, URI, EXTRAS);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContentProviderClientTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.content.cts.ContentProviderClientTest"	"testUpdate"	"CtsContentTestCases"	"1: attribution"	"public void testUpdate() throws RemoteException {
        mContentProviderClient.update(URI, VALUES, EXTRAS);
        verify(mIContentProvider).update(mAttributionSource, URI, VALUES, EXTRAS);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContentProviderClientTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.content.cts.ContentProviderClientTest"	"testUpdateTimeout"	"CtsContentTestCases"	"1: attribution"	"public void testUpdateTimeout() throws RemoteException, InterruptedException {
        doAnswer(ANSWER_SLEEP).when(mIContentProvider).update(mAttributionSource, URI,
                VALUES, EXTRAS);

        testTimeout(() -> mContentProviderClient.update(URI, VALUES, EXTRAS));

        verify(mIContentProvider).update(mAttributionSource, URI, VALUES, EXTRAS);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContentProviderClientTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.content.cts.ContentProviderClientTest"	"testOpenFile"	"CtsContentTestCases"	"1: attribution"	"public void testOpenFile() throws RemoteException, FileNotFoundException {
        mContentProviderClient.openFile(URI, MODE, mCancellationSignal);

        verify(mIContentProvider).openFile(mAttributionSource, URI, MODE, mICancellationSignal);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContentProviderClientTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.content.cts.ContentProviderClientTest"	"testOpenFileTimeout"	"CtsContentTestCases"	"1: attribution"	"public void testOpenFileTimeout()
            throws RemoteException, InterruptedException, FileNotFoundException {
        doAnswer(ANSWER_SLEEP).when(mIContentProvider).openFile(mAttributionSource,
                URI, MODE, mICancellationSignal);

        testTimeout(() -> mContentProviderClient.openFile(URI, MODE, mCancellationSignal));

        verify(mIContentProvider).openFile(mAttributionSource, URI, MODE, mICancellationSignal);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContentProviderClientTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.content.cts.ContentProviderClientTest"	"testOpenFileAlreadyCancelled"	"CtsContentTestCases"	"1: attribution"	"public void testOpenFileAlreadyCancelled() throws Exception {
        testAlreadyCancelled(() -> mContentProviderClient.openFile(URI, MODE, mCancellationSignal));

        verify(mIContentProvider, never()).openFile(mAttributionSource, URI, MODE,
                mICancellationSignal);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContentProviderClientTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.content.cts.ContentProviderClientTest"	"testOpenAssetFile"	"CtsContentTestCases"	"1: attribution"	"public void testOpenAssetFile() throws RemoteException, FileNotFoundException {
        mContentProviderClient.openAssetFile(URI, MODE, mCancellationSignal);

        verify(mIContentProvider).openAssetFile(mAttributionSource, URI, MODE, mICancellationSignal);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContentProviderClientTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.content.cts.ContentProviderClientTest"	"testOpenAssetFileTimeout"	"CtsContentTestCases"	"1: attribution"	"public void testOpenAssetFileTimeout()
            throws RemoteException, InterruptedException, FileNotFoundException {
        doAnswer(ANSWER_SLEEP).when(mIContentProvider).openAssetFile(mAttributionSource,
                URI, MODE, mICancellationSignal);

        testTimeout(() -> mContentProviderClient.openAssetFile(URI, MODE, mCancellationSignal));

        verify(mIContentProvider).openAssetFile(mAttributionSource, URI, MODE,
                mICancellationSignal);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContentProviderClientTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.content.cts.ContentProviderClientTest"	"testOpenAssetFileAlreadyCancelled"	"CtsContentTestCases"	"1: attribution"	"public void testOpenAssetFileAlreadyCancelled() throws Exception {
        testAlreadyCancelled(
                () -> mContentProviderClient.openAssetFile(URI, MODE, mCancellationSignal));

        verify(mIContentProvider, never()).openAssetFile(mAttributionSource, URI, MODE,
                mICancellationSignal);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContentProviderClientTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.content.cts.ContentProviderClientTest"	"testOpenTypedAssetFileDescriptor"	"CtsContentTestCases"	"1: attribution"	"public void testOpenTypedAssetFileDescriptor() throws RemoteException, FileNotFoundException {
        mContentProviderClient.openTypedAssetFileDescriptor(URI, MODE, ARGS, mCancellationSignal);

        verify(mIContentProvider).openTypedAssetFile(mAttributionSource, URI, MODE, ARGS,
                mICancellationSignal);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContentProviderClientTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.content.cts.ContentProviderClientTest"	"testOpenTypedAssetFile"	"CtsContentTestCases"	"1: attribution"	"public void testOpenTypedAssetFile() throws RemoteException, FileNotFoundException {
        mContentProviderClient.openTypedAssetFile(URI, MODE, ARGS, mCancellationSignal);

        verify(mIContentProvider).openTypedAssetFile(mAttributionSource, URI, MODE, ARGS,
                mICancellationSignal);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContentProviderClientTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.content.cts.ContentProviderClientTest"	"testOpenTypedAssetFileTimeout"	"CtsContentTestCases"	"1: attribution"	"public void testOpenTypedAssetFileTimeout()
            throws RemoteException, InterruptedException, FileNotFoundException {
        doAnswer(ANSWER_SLEEP).when(mIContentProvider).openTypedAssetFile(mAttributionSource,
                URI, MODE, ARGS, mICancellationSignal);

        testTimeout(() -> mContentProviderClient.openTypedAssetFile(URI, MODE, ARGS,
                mCancellationSignal));

        verify(mIContentProvider).openTypedAssetFile(mAttributionSource, URI, MODE, ARGS,
                mICancellationSignal);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContentProviderClientTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.content.cts.ContentProviderClientTest"	"testOpenTypedAssetFileAlreadyCancelled"	"CtsContentTestCases"	"1: attribution"	"public void testOpenTypedAssetFileAlreadyCancelled() throws Exception {
        testAlreadyCancelled(
                () -> mContentProviderClient.openTypedAssetFile(URI, MODE, ARGS,
                        mCancellationSignal));

        verify(mIContentProvider, never()).openTypedAssetFile(mAttributionSource, URI, MODE,
                ARGS, mICancellationSignal);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContentProviderClientTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.content.cts.ContentProviderClientTest"	"testApplyBatch"	"CtsContentTestCases"	"1: attribution"	"public void testApplyBatch() throws RemoteException, OperationApplicationException {
        mContentProviderClient.applyBatch(AUTHORITY, OPS);

        verify(mIContentProvider).applyBatch(mAttributionSource, AUTHORITY, OPS);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContentProviderClientTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.content.cts.ContentProviderClientTest"	"testApplyBatchTimeout"	"CtsContentTestCases"	"1: attribution"	"public void testApplyBatchTimeout()
            throws RemoteException, InterruptedException, OperationApplicationException {
        doAnswer(ANSWER_SLEEP).when(mIContentProvider).applyBatch(mAttributionSource,
                AUTHORITY, OPS);

        testTimeout(() -> mContentProviderClient.applyBatch(AUTHORITY, OPS));

        verify(mIContentProvider).applyBatch(mAttributionSource, AUTHORITY, OPS);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContentProviderClientTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.content.cts.ContentProviderClientTest"	"testCall"	"CtsContentTestCases"	"1: attribution"	"public void testCall() throws RemoteException {
        mContentProviderClient.call(AUTHORITY, METHOD, ARG, ARGS);

        verify(mIContentProvider).call(mAttributionSource, AUTHORITY, METHOD, ARG, ARGS);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContentProviderClientTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.content.cts.ContentProviderClientTest"	"testCallTimeout"	"CtsContentTestCases"	"1: attribution"	"public void testCallTimeout() throws RemoteException, InterruptedException {
        doAnswer(ANSWER_SLEEP).when(mIContentProvider).call(mAttributionSource, AUTHORITY,
                METHOD, ARG, ARGS);

        testTimeout(() -> mContentProviderClient.call(AUTHORITY, METHOD, ARG, ARGS));

        verify(mIContentProvider).call(mAttributionSource, AUTHORITY, METHOD, ARG, ARGS);
    }

    private void testTimeout(Function function) throws InterruptedException {
        mContentProviderClient.setDetectNotResponding(1);
        CountDownLatch latch = new CountDownLatch(1);
        doAnswer(invocation -> {
            latch.countDown();
            return null;
        })
                .when(mContentResolver)
                .appNotRespondingViaProvider(mIContentProvider);

        new Thread(() -> {
            try {
                function.run();
            } catch (Exception ignored) {
            } finally {
                latch.countDown();
            }
        }).start();

        latch.await(100, TimeUnit.MILLISECONDS);
        assertEquals(0, latch.getCount());

        verify(mContentResolver).appNotRespondingViaProvider(mIContentProvider);
    }

    private void testAlreadyCancelled(Function function) throws Exception {
        mCancellationSignal.cancel();
        mCalledCancel = true;

        try {
            function.run();
            fail(""Expected OperationCanceledException"");
        } catch (OperationCanceledException expected) {
        }
    }

    private interface Function {
        void run() throws Exception;
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContentProviderClientTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.content.wm.cts.ContextIsUiContextTest"	"testIsUiContextOnDefaultDisplayContext"	"CtsContentTestCases"	"1: attribution"	"public void testIsUiContextOnDefaultDisplayContext() {
        final Context defaultDisplayContext =
                mApplicationContext.createDisplayContext(getDefaultDisplay());
        assertThat(defaultDisplayContext.isUiContext()).isFalse();

        final Context defaultDisplayDerivedContext = defaultDisplayContext
                .createAttributionContext(null /* attributionTag */);
        assertThat(defaultDisplayDerivedContext.isUiContext()).isFalse();
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/wm/cts/ContextIsUiContextTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.content.wm.cts.ContextIsUiContextTest"	"testIsUiContextOnSecondaryDisplayContext"	"CtsContentTestCases"	"1: attribution"	"public void testIsUiContextOnSecondaryDisplayContext() {
        final Context secondaryDisplayContext =
                mApplicationContext.createDisplayContext(getSecondaryDisplay());
        assertThat(secondaryDisplayContext.isUiContext()).isFalse();

        final Context secondaryDisplayDerivedContext = secondaryDisplayContext
                .createAttributionContext(null /* attributionTag */);
        assertThat(secondaryDisplayDerivedContext.isUiContext()).isFalse();
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/wm/cts/ContextIsUiContextTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.content.wm.cts.ContextIsUiContextTest"	"testIsUiContextOnUiDerivedContext"	"CtsContentTestCases"	"1: attribution"	"public void testIsUiContextOnUiDerivedContext() {
        final Context uiDerivedContext = createWindowContext()
                .createAttributionContext(null /* attributionTag */);
        assertThat(uiDerivedContext.isUiContext()).isTrue();
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/wm/cts/ContextIsUiContextTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.content.pm.cts.PackageInfoTest"	"testApplicationInfoSame"	"CtsContentTestCases"	"1: attribution"	"public void testApplicationInfoSame() {
        ApplicationInfo ai = mPackageInfo.applicationInfo;

        // Make sure all the components in it has the same ApplicationInfo.
        for (ComponentInfo[] ar : new ComponentInfo[][]{
                mPackageInfo.activities, mPackageInfo.services, mPackageInfo.providers,
                mPackageInfo.receivers}) {
            for (ComponentInfo ci : ar) {
                assertSame(""component="" + ci.getComponentName(), ai, ci.applicationInfo);
            }
        }
    }

    private void checkPkgInfoSame(PackageInfo expected, PackageInfo actual) {
        assertEquals(expected.packageName, actual.packageName);
        assertEquals(expected.getLongVersionCode(), actual.getLongVersionCode());
        assertEquals(expected.versionName, actual.versionName);
        assertEquals(expected.sharedUserId, actual.sharedUserId);
        assertEquals(expected.sharedUserLabel, actual.sharedUserLabel);
        if (expected.applicationInfo != null) {
            assertNotNull(actual.applicationInfo);
            checkAppInfo(expected.applicationInfo, actual.applicationInfo);
        } else {
            assertNull(actual.applicationInfo);
        }
        assertTrue(Arrays.equals(expected.gids, actual.gids));
        checkInfoArray(expected.activities, actual.activities);
        checkInfoArray(expected.receivers, actual.receivers);
        checkInfoArray(expected.services, actual.services);
        checkInfoArray(expected.providers, actual.providers);
        checkInfoArray(expected.instrumentation, actual.instrumentation);
        checkInfoArray(expected.permissions, actual.permissions);
        assertTrue(Arrays.equals(expected.requestedPermissions, actual.requestedPermissions));
        checkSignatureInfo(expected.signatures, actual.signatures);
        checkConfigInfo(expected.configPreferences, actual.configPreferences);
        checkAttributionInfo(expected.attributions, actual.attributions);
    }

    private void checkAppInfo(ApplicationInfo expected, ApplicationInfo actual) {
        assertEquals(expected.taskAffinity, actual.taskAffinity);
        assertEquals(expected.permission, actual.permission);
        assertEquals(expected.processName, actual.processName);
        assertEquals(expected.className, actual.className);
        assertEquals(expected.theme, actual.theme);
        assertEquals(expected.flags, actual.flags);
        assertEquals(expected.sourceDir, actual.sourceDir);
        assertEquals(expected.publicSourceDir, actual.publicSourceDir);
        assertArrayEquals(expected.sharedLibraryFiles, actual.sharedLibraryFiles);
        assertEquals(expected.dataDir, actual.dataDir);
        assertEquals(expected.uid, actual.uid);
        assertEquals(expected.enabled, actual.enabled);
        assertEquals(expected.manageSpaceActivityName, actual.manageSpaceActivityName);
        assertEquals(expected.descriptionRes, actual.descriptionRes);
    }

    private void checkInfoArray(PackageItemInfo[] expected, PackageItemInfo[] actual) {
        if (expected != null && expected.length > 0) {
            assertNotNull(actual);
            assertEquals(expected.length, actual.length);
            for (int i = 0; i < expected.length; i++) {
                assertEquals(expected[i].name, actual[i].name);
            }
        } else if (expected == null) {
            assertNull(actual);
        } else {
            assertEquals(0, actual.length);
        }
    }

    private void checkSignatureInfo(Signature[] expected, Signature[] actual) {
        if (expected != null && expected.length > 0) {
            assertNotNull(actual);
            assertEquals(expected.length, actual.length);
            for (int i = 0; i < expected.length; i++) {
                actual[i].equals(expected[i]);
            }
        } else if (expected == null) {
            assertNull(actual);
        } else {
            assertEquals(0, actual.length);
        }
    }

    private void checkConfigInfo(ConfigurationInfo[] expected, ConfigurationInfo[] actual) {
        if (expected != null && expected.length > 0) {
            assertNotNull(actual);
            assertEquals(expected.length, actual.length);
            for (int i = 0; i < expected.length; i++) {
                assertEquals(expected[i].reqKeyboardType, actual[i].reqKeyboardType);
                assertEquals(expected[i].reqTouchScreen, actual[i].reqTouchScreen);
                assertEquals(expected[i].reqInputFeatures, actual[i].reqInputFeatures);
                assertEquals(expected[i].reqNavigation, actual[i].reqNavigation);
            }
        } else if (expected == null) {
            assertNull(actual);
        } else {
            assertEquals(0, actual.length);
        }
    }

    private void checkAttributionInfo(Attribution[] expected, Attribution[] actual) {
        if (expected != null && expected.length > 0) {
            assertNotNull(actual);
            assertEquals(expected.length, actual.length);
            for (int i = 0; i < expected.length; i++) {
                assertEquals(actual[i].getTag(), expected[i].getTag());
                assertEquals(actual[i].getTag(), expected[i].getTag());
            }
        } else if (expected == null) {
            assertNull(actual);
        } else {
            assertEquals(0, actual.length);
        }
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/PackageInfoTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.app.usage.cts.UsageStatsTest"	"testUsageSourceAttribution"	"CtsUsageStatsTestCases"	"1: attribution"	"public void testUsageSourceAttribution() throws Exception {
        mUiDevice.wakeUp();
        dismissKeyguard(); // also want to start out with the keyguard dismissed.
        mUiDevice.pressHome();

        setUsageSourceSetting(Integer.toString(UsageStatsManager.USAGE_SOURCE_CURRENT_ACTIVITY));
        launchSubActivity(TaskRootActivity.class);
        // Usage should be attributed to the test app package
        assertAppOrTokenUsed(TaskRootActivity.TEST_APP_PKG, true, TIMEOUT);

        SystemUtil.runWithShellPermissionIdentity(() -> mAm.forceStopPackage(TEST_APP_PKG));

        setUsageSourceSetting(Integer.toString(UsageStatsManager.USAGE_SOURCE_TASK_ROOT_ACTIVITY));
        launchSubActivity(TaskRootActivity.class);
        // Usage should be attributed to this package
        assertAppOrTokenUsed(mTargetPackage, true, TIMEOUT);
    }

    @AppModeFull(reason = ""No usage events access in instant apps"")"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.app.usage.cts.UsageStatsTest"	"testTaskRootAttribution_finishingTaskRoot"	"CtsUsageStatsTestCases"	"1: attribution"	"public void testTaskRootAttribution_finishingTaskRoot() throws Exception {
        setUsageSourceSetting(Integer.toString(UsageStatsManager.USAGE_SOURCE_TASK_ROOT_ACTIVITY));
        mUiDevice.wakeUp();
        dismissKeyguard(); // also want to start out with the keyguard dismissed.

        launchTestActivity(TEST_APP2_PKG, TEST_APP2_CLASS_FINISHING_TASK_ROOT);
        // Wait until the nested activity gets started
        mUiDevice.wait(Until.hasObject(By.clazz(TEST_APP_PKG, TEST_APP_CLASS)), TIMEOUT);

        // Usage should be attributed to the task root app package
        assertAppOrTokenUsed(TEST_APP_PKG, false, TIMEOUT);
        assertAppOrTokenUsed(TEST_APP2_PKG, true, TIMEOUT);
        SystemUtil.runWithShellPermissionIdentity(() -> mAm.forceStopPackage(TEST_APP_PKG));
        mUiDevice.wait(Until.gone(By.clazz(TEST_APP_PKG, TEST_APP_CLASS)), TIMEOUT);

        // Usage should no longer be tracked
        assertAppOrTokenUsed(TEST_APP_PKG, false, TIMEOUT);
        assertAppOrTokenUsed(TEST_APP2_PKG, false, TIMEOUT);
    }

    @AppModeInstant"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.permission5.cts.RuntimePermissionsAppOpTrackingTest.kt"	"setUpTest"	"CtsPermission5TestCases"	"1: attribution"	"/*
 *.
 */
package android.permission5.cts

import android.Manifest
import android.app.AppOpsManager
import android.app.Instrumentation
import android.content.AttributionSource
import android.content.ComponentName
import android.content.ContentValues
import android.content.Context
import android.content.ContextParams
import android.content.Intent
import android.content.pm.PackageManager.FEATURE_LEANBACK
import android.net.Uri
import android.os.Bundle
import android.os.Process
import android.os.RemoteCallback
import android.os.SystemClock
import android.os.UserHandle
import android.permission.PermissionManager
import android.platform.test.annotations.AppModeFull
import android.provider.CalendarContract
import android.provider.CallLog
import android.provider.ContactsContract
import android.provider.Telephony
import android.speech.RecognitionListener
import android.speech.SpeechRecognizer
import androidx.test.platform.app.InstrumentationRegistry
import com.android.compatibility.common.util.SystemUtil
import com.google.common.truth.Truth.assertThat
import org.junit.After
import org.junit.Assume.assumeFalse
import org.junit.Before
import org.junit.Test
import org.mockito.ArgumentMatcher
import org.mockito.Mockito.eq
import org.mockito.Mockito.inOrder
import org.mockito.Mockito.intThat
import org.mockito.Mockito.isNull
import org.mockito.Mockito.mock
import java.util.concurrent.CountDownLatch
import java.util.concurrent.TimeUnit
import java.util.concurrent.atomic.AtomicReference
import java.util.concurrent.locks.ReentrantLock
import java.util.function.Consumer

@AppModeFull(reason = ""Instant apps cannot hold READ_CONTACTS/READ_CALENDAR/READ_SMS/READ_CALL_LOG"")
class RuntimePermissionsAppOpTrackingTest {

    @Before
    fun setUpTest() {
        val appOpsManager = context.getSystemService(AppOpsManager::class.java)!!
        SystemUtil.runWithShellPermissionIdentity {
            appOpsManager.clearHistory()
            appOpsManager.setHistoryParameters(
                    AppOpsManager.HISTORICAL_MODE_ENABLED_ACTIVE,
                    SNAPSHOT_INTERVAL_MILLIS,
                    INTERVAL_COMPRESSION_MULTIPLIER)

            appOpsManager.resetPackageOpsNoHistory(context.packageName)
            appOpsManager.resetPackageOpsNoHistory(SHELL_PACKAGE_NAME)
            appOpsManager.resetPackageOpsNoHistory(RECEIVER_PACKAGE_NAME)
            appOpsManager.resetPackageOpsNoHistory(RECEIVER2_PACKAGE_NAME)
        }
    }

    @After
    fun tearDownTest() {
        val appOpsManager = context.getSystemService(AppOpsManager::class.java)!!
        SystemUtil.runWithShellPermissionIdentity {
            appOpsManager.clearHistory()
            appOpsManager.resetHistoryParameters()
        }
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/permission5/src/android/permission5/cts/RuntimePermissionsAppOpTrackingTest.kt"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.permission5.cts.RuntimePermissionsAppOpTrackingTest.kt"	"testSelfCallLogAccess"	"CtsPermission5TestCases"	"1: attribution"	"@Throws(Exception::class)
    fun testSelfCallLogAccess() {
        testSelfAccess(CallLog.Calls.CONTENT_URI,
                Manifest.permission.READ_CALL_LOG)
    }

    @Throws(Exception::class)
    private fun testSelfAccess(uri: Uri, permission: String) {
        val context = createAttributionContext(ACCESSOR_ATTRIBUTION_TAG, null, null)
        val beginEndMillis = System.currentTimeMillis()
        context.contentResolver.query(uri, null, null, null)!!.close()
        val endTimeMillis = System.currentTimeMillis()

        assertNotRunningOpAccess(AppOpsManager.permissionToOp(permission)!!,
                beginEndMillis, endTimeMillis, context.attributionSource,
                /*accessorForeground*/ true, /*receiverForeground*/ false,
                /*accessorTrusted*/ true, /*accessorAccessCount*/ 1,
                /*receiverAccessCount*/ 0, /*checkAccessor*/ true,
                /*fromDatasource*/ false)
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/permission5/src/android/permission5/cts/RuntimePermissionsAppOpTrackingTest.kt"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.permission5.cts.RuntimePermissionsAppOpTrackingTest.kt"	"testSelfCallLogWrite"	"CtsPermission5TestCases"	"1: attribution"	"@Throws(Exception::class)
    fun testSelfCallLogWrite() {
        testSelfWrite(CallLog.Calls.CONTENT_URI,
                Manifest.permission.WRITE_CALL_LOG)
    }

    @Throws(Exception::class)
    private fun testSelfWrite(uri: Uri, permission: String) {
        val context = createAttributionContext(ACCESSOR_ATTRIBUTION_TAG, null, null)
        val beginEndMillis = System.currentTimeMillis()
        context.contentResolver.insert(uri, ContentValues())
        val endTimeMillis = System.currentTimeMillis()

        assertNotRunningOpAccess(AppOpsManager.permissionToOp(permission)!!,
                beginEndMillis, endTimeMillis, context.attributionSource,
                /*accessorForeground*/ true, /*receiverForeground*/ false,
                /*accessorTrusted*/ true, /*accessorAccessCount*/ 1,
                /*receiverAccessCount*/ 0, /*checkAccessor*/ true,
                /*fromDatasource*/ false)
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/permission5/src/android/permission5/cts/RuntimePermissionsAppOpTrackingTest.kt"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.permission5.cts.RuntimePermissionsAppOpTrackingTest.kt"	"testUntrustedCallLogAccessAttributeToAnother"	"CtsPermission5TestCases"	"1: attribution"	"@Throws(Exception::class)
    fun testUntrustedCallLogAccessAttributeToAnother() {
        testUntrustedAccessAttributeToAnother(CallLog.Calls.CONTENT_URI,
                Manifest.permission.READ_CALL_LOG)
    }

    @Throws(Exception::class)
    private fun testUntrustedAccessAttributeToAnother(uri: Uri, permission: String) {
        val context = createAttributionContext(ACCESSOR_ATTRIBUTION_TAG,
                RECEIVER_PACKAGE_NAME, RECEIVER_ATTRIBUTION_TAG)
        val beginEndMillis = System.currentTimeMillis()
        context.contentResolver.query(uri, null, null, null)!!.close()
        val endTimeMillis = System.currentTimeMillis()

        assertNotRunningOpAccess(AppOpsManager.permissionToOp(permission)!!,
                beginEndMillis, endTimeMillis, context.attributionSource,
                /*accessorForeground*/ true, /*receiverForeground*/ false,
                /*accessorTrusted*/ false, /*accessorAccessCount*/ 1,
                /*receiverAccessCount*/ 1, /*checkAccessor*/ false,
                /*fromDatasource*/ false)
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/permission5/src/android/permission5/cts/RuntimePermissionsAppOpTrackingTest.kt"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.permission5.cts.RuntimePermissionsAppOpTrackingTest.kt"	"testUntrustedCallLogAccessAttributeToAnotherThroughIntermediary"	"CtsPermission5TestCases"	"1: attribution"	"@Throws(Exception::class)
    fun testUntrustedCallLogAccessAttributeToAnotherThroughIntermediary() {
        testUntrustedAccessAttributeToAnotherThroughIntermediary(
                CallLog.Calls.CONTENT_URI,
                Manifest.permission.READ_CALL_LOG)
    }

    @Throws(Exception::class)
    private fun testUntrustedAccessAttributeToAnotherThroughIntermediary(
        uri: Uri,
        permission: String
    ) {
        runWithAuxiliaryApps {
            val nextAttributionSource = startBlamedAppActivity()

            val intermediaryContext = context.createContext(ContextParams.Builder()
                    .setNextAttributionSource(nextAttributionSource)
                    .setAttributionTag(ACCESSOR_ATTRIBUTION_TAG)
                    .build())

            val beginEndMillis = System.currentTimeMillis()
            intermediaryContext.contentResolver.query(uri, null, null, null)!!.close()
            val endTimeMillis = System.currentTimeMillis()

            // Assert first stage access
            assertNotRunningOpAccess(AppOpsManager.permissionToOp(permission)!!,
                    beginEndMillis, endTimeMillis, intermediaryContext.attributionSource,
                    /*accessorForeground*/ true, /*receiverForeground*/ true,
                    /*accessorTrusted*/ false, /*accessorAccessCount*/ 1,
                    /*receiverAccessCount*/ 1, /*checkAccessor*/ false,
                    /*fromDatasource*/ false)

            // Assert second stage access
            assertNotRunningOpAccess(AppOpsManager.permissionToOp(permission)!!,
                    beginEndMillis, endTimeMillis, nextAttributionSource,
                    /*accessorForeground*/ true, /*receiverForeground*/ false,
                    /*accessorTrusted*/ false, /*accessorAccessCount*/ 1,
                    /*receiverAccessCount*/ 1, /*checkAccessor*/ false,
                    /*fromDatasource*/ false)
        }
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/permission5/src/android/permission5/cts/RuntimePermissionsAppOpTrackingTest.kt"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.permission5.cts.RuntimePermissionsAppOpTrackingTest.kt"	"testCannotForgeAttributionSource"	"CtsPermission5TestCases"	"1: attribution"	"(expected = SecurityException::class)
    fun testCannotForgeAttributionSource() {
        val receiverSource = AttributionSource(context
                .packageManager.getPackageUid(RECEIVER2_PACKAGE_NAME, 0),
                RECEIVER2_PACKAGE_NAME, RECEIVER2_ATTRIBUTION_TAG, null, AttributionSource(
                context.packageManager.getPackageUid(RECEIVER_PACKAGE_NAME, 0),
                RECEIVER_PACKAGE_NAME, RECEIVER_ATTRIBUTION_TAG))
        val intermediaryContext = context.createContext(ContextParams.Builder()
            .setNextAttributionSource(receiverSource)
            .setAttributionTag(ACCESSOR_ATTRIBUTION_TAG)
            .build())
        intermediaryContext.contentResolver.query(CallLog.Calls.CONTENT_URI, null,
                null, null)!!.close()
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/permission5/src/android/permission5/cts/RuntimePermissionsAppOpTrackingTest.kt"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.permission5.cts.RuntimePermissionsAppOpTrackingTest.kt"	"testCannotAppendToForgeAttributionSource"	"CtsPermission5TestCases"	"1: attribution"	"(expected = SecurityException::class)
    fun testCannotAppendToForgeAttributionSource() {
        runWithAuxiliaryApps {
            val nextAttributionSource = startBlamedAppActivity()
            val untrustedAttributionSource = AttributionSource(context
                    .packageManager.getPackageUid(RECEIVER2_PACKAGE_NAME, 0),
                    RECEIVER2_PACKAGE_NAME, RECEIVER2_ATTRIBUTION_TAG, null,
                    nextAttributionSource)
            val intermediaryContext = context.createContext(ContextParams.Builder()
                    .setNextAttributionSource(untrustedAttributionSource)
                    .setAttributionTag(ACCESSOR_ATTRIBUTION_TAG)
                    .build())
            intermediaryContext.contentResolver.query(CallLog.Calls.CONTENT_URI, null,
                    null, null)!!.close()
        }
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/permission5/src/android/permission5/cts/RuntimePermissionsAppOpTrackingTest.kt"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.permission5.cts.RuntimePermissionsAppOpTrackingTest.kt"	"testTrustedAccessCallLogAttributeToAnother"	"CtsPermission5TestCases"	"1: attribution"	"@Throws(Exception::class)
    fun testTrustedAccessCallLogAttributeToAnother() {
        testTrustedAccessAttributeToAnother(CallLog.Calls.CONTENT_URI,
                Manifest.permission.READ_CALL_LOG)
    }

    @Throws(Exception::class)
    private fun testTrustedAccessAttributeToAnother(uri: Uri, permission: String) {
        val context = createAttributionContext(ACCESSOR_ATTRIBUTION_TAG,
                RECEIVER_PACKAGE_NAME, RECEIVER_ATTRIBUTION_TAG)
        val beginEndMillis = System.currentTimeMillis()
        SystemUtil.runWithShellPermissionIdentity {
            context.contentResolver.query(uri, null, null, null)!!.close()
        }
        val endTimeMillis = System.currentTimeMillis()

        // Calculate the shellUid to account for running this from a secondary user.
        val shellUid = UserHandle.getUid(Process.myUserHandle().identifier,
            UserHandle.getAppId(Process.SHELL_UID))
        // Since we use adopt the shell permission identity we need to adjust
        // the permission identity to have the shell as the accessor.
        assertNotRunningOpAccess(AppOpsManager.permissionToOp(permission)!!,
                beginEndMillis, endTimeMillis, AttributionSource(shellUid,
                SHELL_PACKAGE_NAME, context.attributionTag, null,
                context.attributionSource.next),
                /*accessorForeground*/ false, /*receiverForeground*/ false,
                /*accessorTrusted*/ true, /*accessorAccessCount*/ 1,
                /*receiverAccessCount*/ 1, /*checkAccessor*/ false,
                /*fromDatasource*/ false)
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/permission5/src/android/permission5/cts/RuntimePermissionsAppOpTrackingTest.kt"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.permission5.cts.RuntimePermissionsAppOpTrackingTest.kt"	"testMicRecognitionInjectRecoWithoutAttribution"	"CtsPermission5TestCases"	"1: attribution"	"@Throws(Exception::class)
    fun testMicRecognitionInjectRecoWithoutAttribution() {
        runWithAuxiliaryApps {
            startBlamedAppActivity()

            val context = createAttributionContext(ACCESSOR_ATTRIBUTION_TAG,
                    RECEIVER_PACKAGE_NAME, RECEIVER_ATTRIBUTION_TAG)

            val listener = mock(AppOpsManager.OnOpActiveChangedListener::class.java)
            val appopsManager = context.getSystemService(AppOpsManager::class.java)
            SystemUtil.runWithShellPermissionIdentity<Unit> {
                appopsManager!!.startWatchingActive(arrayOf(AppOpsManager.OPSTR_RECORD_AUDIO),
                        context.mainExecutor, listener)
            }

            val speechStartTime = System.currentTimeMillis()
            val recognizerRef = AtomicReference<SpeechRecognizer>()
            var currentOperationComplete = CountDownLatch(1)

            instrumentation.runOnMainSync {
                val recognizer = SpeechRecognizer.createSpeechRecognizer(context,
                        ComponentName(RECEIVER2_PACKAGE_NAME, RECOGNITION_SERVICE))

                recognizer.setRecognitionListener(object : RecognitionListener {
                    override fun onReadyForSpeech(params: Bundle?) {}
                    override fun onRmsChanged(rmsdB: Float) {}
                    override fun onBufferReceived(buffer: ByteArray?) {
                        currentOperationComplete.countDown()
                    }
                    override fun onPartialResults(partialResults: Bundle?) {}
                    override fun onEvent(eventType: Int, params: Bundle?) {}
                    override fun onError(error: Int) {}
                    override fun onResults(results: Bundle?) {}
                    override fun onBeginningOfSpeech() {}
                    override fun onEndOfSpeech() {}
                })

                val recoIntent = Intent()
                recoIntent.putExtra(OPERATION, OPERATION_INJECT_RECO_WITHOUT_ATTRIBUTION)
                recognizer.startListening(recoIntent)

                recognizerRef.set(recognizer)
            }

            try {
                currentOperationComplete.await(ASYNC_OPERATION_TIMEOUT_MILLIS,
                        TimeUnit.MILLISECONDS)

                val op = AppOpsManager.permissionToOp(Manifest.permission.RECORD_AUDIO)!!

                assertRunningOpAccess(op, speechStartTime, System.currentTimeMillis(),
                        AttributionSource(context.packageManager.getPackageUid(
                                RECEIVER2_PACKAGE_NAME, 0), RECEIVER2_PACKAGE_NAME,
                                /*attributionTag*/ null, null, context.attributionSource),
                        /*accessorForeground*/ true, /*receiverForeground*/ true,
                        /*accessorTrusted*/ false, /*accessorAccessCount*/ 1,
                        /*receiverAccessCount*/ 1, /*checkAccessor*/ true,
                        /*fromDatasource*/ false)

                assertRunningOpAccess(op, speechStartTime, System.currentTimeMillis(),
                        context.attributionSource, /*accessorForeground*/ true,
                        /*receiverForeground*/ true, /*accessorTrusted*/ false,
                        /*accessorAccessCount*/ 0, /*receiverAccessCount*/ 1,
                        /*checkAccessor*/ false, /*fromDatasource*/ false)

                // Finish recon and check if all ops are finished
                currentOperationComplete = CountDownLatch(1)
                instrumentation.runOnMainSync { recognizerRef.get().cancel() }
                currentOperationComplete.await(ASYNC_OPERATION_TIMEOUT_MILLIS,
                        TimeUnit.MILLISECONDS)

                val recognizerUid = context.packageManager.getPackageUid(
                        RECEIVER2_PACKAGE_NAME, 0)

                assertNotRunningOpAccess(op, speechStartTime, System.currentTimeMillis(),
                        AttributionSource(recognizerUid, RECEIVER2_PACKAGE_NAME,
                                /*attributionTag*/ null, null, context.attributionSource),
                        /*accessorForeground*/ true, /*receiverForeground*/ true,
                        /*accessorTrusted*/ false, /*accessorAccessCount*/ 1,
                        /*receiverAccessCount*/ 1, /*checkAccessor*/ true,
                        /*fromDatasource*/ false)

                assertNotRunningOpAccess(op, speechStartTime, System.currentTimeMillis(),
                        context.attributionSource, /*accessorForeground*/ true,
                        /*receiverForeground*/ true, /*accessorTrusted*/ false,
                        /*accessorAccessCount*/ 0, /*receiverAccessCount*/ 1,
                        /*checkAccessor*/ false, /*fromDatasource*/ false)

                var attributionChainId: Int? = null
                val inOrder = inOrder(listener)
                val attributionChainIdMatcher = ArgumentMatcher<Int> {
                    if (attributionChainId == null) {
                        attributionChainId = it
                        return@ArgumentMatcher true
                    } else {
                        return@ArgumentMatcher (attributionChainId == it)
                    }
                }
                val receiverUid = context.packageManager.getPackageUid(
                        RECEIVER_PACKAGE_NAME, 0)

                inOrder.verify(listener).onOpActiveChanged(eq(AppOpsManager.OPSTR_RECORD_AUDIO),
                        eq(recognizerUid), eq(RECEIVER2_PACKAGE_NAME), isNull(), eq(true),
                        eq(AppOpsManager.ATTRIBUTION_FLAG_ACCESSOR),
                        intThat(attributionChainIdMatcher))
                inOrder.verify(listener).onOpActiveChanged(eq(AppOpsManager.OPSTR_RECORD_AUDIO),
                        eq(Process.myUid()), eq(context.packageName), eq(ACCESSOR_ATTRIBUTION_TAG),
                        eq(true), eq(AppOpsManager.ATTRIBUTION_FLAG_INTERMEDIARY),
                        intThat(attributionChainIdMatcher))
                inOrder.verify(listener).onOpActiveChanged(eq(AppOpsManager.OPSTR_RECORD_AUDIO),
                        eq(receiverUid), eq(RECEIVER_PACKAGE_NAME), eq(RECEIVER_ATTRIBUTION_TAG),
                        eq(true), eq(AppOpsManager.ATTRIBUTION_FLAG_RECEIVER),
                        intThat(attributionChainIdMatcher))

                inOrder.verify(listener).onOpActiveChanged(eq(AppOpsManager.OPSTR_RECORD_AUDIO),
                        eq(recognizerUid), eq(RECEIVER2_PACKAGE_NAME), isNull(), eq(false),
                        eq(AppOpsManager.ATTRIBUTION_FLAG_ACCESSOR),
                        intThat(attributionChainIdMatcher))
                inOrder.verify(listener).onOpActiveChanged(eq(AppOpsManager.OPSTR_RECORD_AUDIO),
                        eq(Process.myUid()), eq(context.packageName), eq(ACCESSOR_ATTRIBUTION_TAG),
                        eq(false), eq(AppOpsManager.ATTRIBUTION_FLAG_INTERMEDIARY),
                        intThat(attributionChainIdMatcher))
                inOrder.verify(listener).onOpActiveChanged(eq(AppOpsManager.OPSTR_RECORD_AUDIO),
                        eq(receiverUid), eq(RECEIVER_PACKAGE_NAME), eq(RECEIVER_ATTRIBUTION_TAG),
                        eq(false), eq(AppOpsManager.ATTRIBUTION_FLAG_RECEIVER),
                        intThat(attributionChainIdMatcher))
            } finally {
                // Take down the recognition service
                instrumentation.runOnMainSync { recognizerRef.get().destroy() }
            }
        }
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/permission5/src/android/permission5/cts/RuntimePermissionsAppOpTrackingTest.kt"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.permission5.cts.RuntimePermissionsAppOpTrackingTest.kt"	"testMicRecognitionMicRecoWithAttribution"	"CtsPermission5TestCases"	"1: attribution"	"@Throws(Exception::class)
    fun testMicRecognitionMicRecoWithAttribution() {
        runWithAuxiliaryApps {
            startBlamedAppActivity()

            val context = createAttributionContext(ACCESSOR_ATTRIBUTION_TAG,
                    RECEIVER_PACKAGE_NAME, RECEIVER_ATTRIBUTION_TAG)

            val listener = mock(AppOpsManager.OnOpActiveChangedListener::class.java)
            val appopsManager = context.getSystemService(AppOpsManager::class.java)
            SystemUtil.runWithShellPermissionIdentity<Unit> {
                appopsManager!!.startWatchingActive(arrayOf(AppOpsManager.OPSTR_RECORD_AUDIO),
                        context.mainExecutor, listener)
            }

            val speechStartTime = System.currentTimeMillis()
            val recognizerRef = AtomicReference<SpeechRecognizer>()
            var currentOperationComplete = CountDownLatch(1)

            instrumentation.runOnMainSync {
                val recognizer = SpeechRecognizer.createSpeechRecognizer(context,
                        ComponentName(RECEIVER2_PACKAGE_NAME, RECOGNITION_SERVICE))

                recognizer.setRecognitionListener(object : RecognitionListener {
                    override fun onReadyForSpeech(params: Bundle?) {}
                    override fun onRmsChanged(rmsdB: Float) {}
                    override fun onBufferReceived(buffer: ByteArray?) {
                        currentOperationComplete.countDown()
                    }
                    override fun onPartialResults(partialResults: Bundle?) {}
                    override fun onEvent(eventType: Int, params: Bundle?) {}
                    override fun onError(error: Int) {}
                    override fun onResults(results: Bundle?) {}
                    override fun onBeginningOfSpeech() {}
                    override fun onEndOfSpeech() {}
                })

                val recoIntent = Intent()
                recoIntent.putExtra(OPERATION, OPERATION_MIC_RECO_WITH_ATTRIBUTION)
                recognizer.startListening(recoIntent)

                recognizerRef.set(recognizer)
            }

            try {
                currentOperationComplete.await(ASYNC_OPERATION_TIMEOUT_MILLIS,
                        TimeUnit.MILLISECONDS)

                val op = AppOpsManager.permissionToOp(Manifest.permission.RECORD_AUDIO)!!

                assertRunningOpAccess(op, speechStartTime, System.currentTimeMillis(),
                        AttributionSource(context.packageManager.getPackageUid(
                                RECEIVER2_PACKAGE_NAME, 0), RECEIVER2_PACKAGE_NAME,
                                /*attributionTag*/ null, null, context.attributionSource),
                        /*accessorForeground*/ true, /*receiverForeground*/ true,
                        /*accessorTrusted*/ true, /*accessorAccessCount*/ 1,
                        /*receiverAccessCount*/ 1, /*checkAccessor*/ true,
                        /*fromDatasource*/ true)

                assertRunningOpAccess(op, speechStartTime, System.currentTimeMillis(),
                        context.attributionSource, /*accessorForeground*/ true,
                        /*receiverForeground*/ true, /*accessorTrusted*/ true,
                        /*accessorAccessCount*/ 0, /*receiverAccessCount*/ 1,
                        /*checkAccessor*/ false, /*fromDatasource*/ true)

                // Finish recon and check if all ops are finished
                currentOperationComplete = CountDownLatch(1)
                instrumentation.runOnMainSync { recognizerRef.get().cancel() }
                currentOperationComplete.await(ASYNC_OPERATION_TIMEOUT_MILLIS,
                        TimeUnit.MILLISECONDS)

                val recognizerUid = context.packageManager.getPackageUid(
                        RECEIVER2_PACKAGE_NAME, 0)

                assertNotRunningOpAccess(op, speechStartTime, System.currentTimeMillis(),
                        AttributionSource(recognizerUid, RECEIVER2_PACKAGE_NAME,
                                /*attributionTag*/ null, null, context.attributionSource),
                        /*accessorForeground*/ true, /*receiverForeground*/ true,
                        /*accessorTrusted*/ true, /*accessorAccessCount*/ 1,
                        /*receiverAccessCount*/ 1, /*checkAccessor*/ true,
                        /*fromDatasource*/ true)

                assertNotRunningOpAccess(op, speechStartTime, System.currentTimeMillis(),
                        context.attributionSource, /*accessorForeground*/ true,
                        /*receiverForeground*/ true, /*accessorTrusted*/ true,
                        /*accessorAccessCount*/ 0, /*receiverAccessCount*/ 1,
                        /*checkAccessor*/ false, /*fromDatasource*/ true)

                var attributionChainId: Int? = null
                val inOrder = inOrder(listener)
                val attributionChainIdMatcher = ArgumentMatcher<Int> {
                    if (attributionChainId == null) {
                        attributionChainId = it
                        return@ArgumentMatcher true
                    } else {
                        return@ArgumentMatcher (attributionChainId == it)
                    }
                }
                val receiverUid = context.packageManager.getPackageUid(
                        RECEIVER_PACKAGE_NAME, 0)

                inOrder.verify(listener).onOpActiveChanged(eq(AppOpsManager.OPSTR_RECORD_AUDIO),
                        eq(recognizerUid), eq(RECEIVER2_PACKAGE_NAME), isNull(), eq(true),
                        eq(AppOpsManager.ATTRIBUTION_FLAG_ACCESSOR or ATTRIBUTION_FLAG_TRUSTED),
                        intThat(attributionChainIdMatcher))
                inOrder.verify(listener).onOpActiveChanged(eq(AppOpsManager.OPSTR_RECORD_AUDIO),
                        eq(Process.myUid()), eq(context.packageName), eq(ACCESSOR_ATTRIBUTION_TAG),
                        eq(true), eq(AppOpsManager.ATTRIBUTION_FLAG_INTERMEDIARY or
                        ATTRIBUTION_FLAG_TRUSTED), intThat(attributionChainIdMatcher))
                inOrder.verify(listener).onOpActiveChanged(eq(AppOpsManager.OPSTR_RECORD_AUDIO),
                        eq(receiverUid), eq(RECEIVER_PACKAGE_NAME), eq(RECEIVER_ATTRIBUTION_TAG),
                        eq(true), eq(AppOpsManager.ATTRIBUTION_FLAG_RECEIVER or
                        ATTRIBUTION_FLAG_TRUSTED), intThat(attributionChainIdMatcher))

                inOrder.verify(listener).onOpActiveChanged(eq(AppOpsManager.OPSTR_RECORD_AUDIO),
                        eq(recognizerUid), eq(RECEIVER2_PACKAGE_NAME), isNull(), eq(false),
                        eq(AppOpsManager.ATTRIBUTION_FLAG_ACCESSOR or ATTRIBUTION_FLAG_TRUSTED),
                        intThat(attributionChainIdMatcher))
                inOrder.verify(listener).onOpActiveChanged(eq(AppOpsManager.OPSTR_RECORD_AUDIO),
                        eq(Process.myUid()), eq(context.packageName), eq(ACCESSOR_ATTRIBUTION_TAG),
                        eq(false), eq(AppOpsManager.ATTRIBUTION_FLAG_INTERMEDIARY or
                        ATTRIBUTION_FLAG_TRUSTED), intThat(attributionChainIdMatcher))
                inOrder.verify(listener).onOpActiveChanged(eq(AppOpsManager.OPSTR_RECORD_AUDIO),
                        eq(receiverUid), eq(RECEIVER_PACKAGE_NAME), eq(RECEIVER_ATTRIBUTION_TAG),
                        eq(false), eq(AppOpsManager.ATTRIBUTION_FLAG_RECEIVER or
                        ATTRIBUTION_FLAG_TRUSTED), intThat(attributionChainIdMatcher))
            } finally {
                // Take down the recognition service
                instrumentation.runOnMainSync { recognizerRef.get().destroy() }
            }
        }
    }

    fun runWithAuxiliaryApps(worker: () -> Unit) {
        ensureAuxiliaryAppsNotRunningAndNoResidualProcessState()
        try {
            worker.invoke()
        } finally {
            ensureAuxiliaryAppsNotRunningAndNoResidualProcessState()
        }
    }

    companion object {
        private const val ASYNC_OPERATION_TIMEOUT_MILLIS: Long = 5000 // 5 sec
        private const val INTERVAL_COMPRESSION_MULTIPLIER = 10
        private const val SNAPSHOT_INTERVAL_MILLIS: Long = 1000

        val SHELL_PACKAGE_NAME = ""com.android.shell""
        val RECEIVER_PACKAGE_NAME = ""android.permission5.cts.blamed""
        val BRING_TO_FOREGROUND_ACTIVITY =
                ""android.permission5.cts.blamed.BringToForegroundActivity""
        val RECOGNITION_SERVICE = ""android.permission5.cts.blamed2.MyRecognitionService""
        val REMOTE_CALLBACK = ""remote_callback""
        val ATTRIBUTION_SOURCE = ""attribution_source""
        val ACCESSOR_ATTRIBUTION_TAG = ""accessor_attribution_tag""
        val RECEIVER2_PACKAGE_NAME = ""android.permission5.cts.blamed2""
        val RECEIVER_ATTRIBUTION_TAG = ""receiver_attribution_tag""
        val RECEIVER2_ATTRIBUTION_TAG = ""receiver2_attribution_tag""

        val OPERATION = ""operation""
        val OPERATION_MIC_RECO_WITH_ATTRIBUTION = ""operation:mic_reco_with_attribution""
        val OPERATION_INJECT_RECO_WITHOUT_ATTRIBUTION = ""operation:inject_reco_without_attribution""

        val ATTRIBUTION_FLAG_TRUSTED = 0x8

        private val context: Context
            get() = InstrumentationRegistry.getInstrumentation().getContext()

        private val instrumentation: Instrumentation
            get() = InstrumentationRegistry.getInstrumentation()

        private val isTv = context.packageManager.hasSystemFeature(FEATURE_LEANBACK)

        fun ensureAuxiliaryAppsNotRunningAndNoResidualProcessState() {
            SystemUtil.runShellCommand(""am force-stop $RECEIVER_PACKAGE_NAME"")
            SystemUtil.runShellCommand(""am force-stop $RECEIVER2_PACKAGE_NAME"")
            SystemClock.sleep(ASYNC_OPERATION_TIMEOUT_MILLIS)
        }

        @Throws(Exception::class)
        private fun assertRunningOpAccess(
            op: String,
            beginEndMillis: Long,
            endTimeMillis: Long,
            attributionSource: AttributionSource,
            accessorForeground: Boolean,
            receiverForeground: Boolean,
            accessorTrusted: Boolean,
            accessorAccessCount: Int,
            receiverAccessCount: Int,
            checkAccessor: Boolean,
            fromDatasource: Boolean
        ) {
            assertOpAccess(op, beginEndMillis, endTimeMillis, attributionSource,
                    accessorForeground, receiverForeground, accessorTrusted,
                    /*assertRunning*/ true, accessorAccessCount, receiverAccessCount,
                    checkAccessor, fromDatasource)
        }

        @Throws(Exception::class)
        private fun assertNotRunningOpAccess(
            op: String,
            beginEndMillis: Long,
            endTimeMillis: Long,
            attributionSource: AttributionSource,
            accessorForeground: Boolean,
            receiverForeground: Boolean,
            accessorTrusted: Boolean,
            accessorAccessCount: Int,
            receiverAccessCount: Int,
            checkAccessor: Boolean,
            fromDatasource: Boolean
        ) {
            assertOpAccess(op, beginEndMillis, endTimeMillis, attributionSource,
                    accessorForeground, receiverForeground, accessorTrusted,
                    /*assertRunning*/ false, accessorAccessCount, receiverAccessCount,
                    checkAccessor, fromDatasource)
        }

        @Throws(Exception::class)
        private fun assertOpAccess(
            op: String,
            beginEndMillis: Long,
            endTimeMillis: Long,
            attributionSource: AttributionSource,
            accessorForeground: Boolean,
            receiverForeground: Boolean,
            accessorTrusted: Boolean,
            assertRunning: Boolean,
            accessorAccessCount: Int,
            receiverAccessCount: Int,
            checkAccessor: Boolean,
            fromDatasource: Boolean
        ) {
            assertLastOpAccess(op, beginEndMillis, endTimeMillis, attributionSource,
                    accessorForeground, receiverForeground, accessorTrusted, assertRunning,
                    checkAccessor, fromDatasource)
            assertHistoricalOpAccess(op, attributionSource, accessorForeground,
                    receiverForeground, accessorTrusted, accessorAccessCount, receiverAccessCount,
                    checkAccessor, fromDatasource)
        }

        private fun assertLastOpAccess(
            op: String,
            beginEndMillis: Long,
            endTimeMillis: Long,
            attributionSource: AttributionSource,
            accessorForeground: Boolean,
            receiverForeground: Boolean,
            accessorTrusted: Boolean,
            assertRunning: Boolean,
            checkAccessor: Boolean,
            fromDatasource: Boolean
        ) {
            val appOpsManager = context.getSystemService(AppOpsManager::class.java)!!
            val allPackagesOps: MutableList<AppOpsManager.PackageOps?> = ArrayList()
            SystemUtil.runWithShellPermissionIdentity<Boolean> {
                allPackagesOps.addAll(appOpsManager.getPackagesForOps(arrayOf(op)))
            }
            if (checkAccessor) {
                assertLastAccessorOps(op, beginEndMillis, endTimeMillis, attributionSource,
                        accessorForeground, accessorTrusted, assertRunning, fromDatasource,
                        allPackagesOps)
            } else {
                assertNotLastAccessorOps(op, attributionSource, allPackagesOps)
            }
            if (attributionSource.next != null) {
                assertLastReceiverOps(op, beginEndMillis, endTimeMillis, attributionSource,
                        receiverForeground, accessorTrusted, assertRunning, allPackagesOps)
            }
        }

        @Throws(Exception::class)
        private fun assertHistoricalOpAccess(
            op: String,
            attributionSource: AttributionSource,
            accessorForeground: Boolean,
            receiverForeground: Boolean,
            accessorTrusted: Boolean,
            accessorAccessCount: Int,
            receiverAccessCount: Int,
            checkAccessor: Boolean,
            fromDatasource: Boolean
        ) {
            val appOpsManager = context.getSystemService(AppOpsManager::class.java)!!
            val request = AppOpsManager.HistoricalOpsRequest.Builder(0, Long.MAX_VALUE)
                    .setOpNames(listOf(op))
                    .build()
            val historicalOpsRef = AtomicReference<AppOpsManager.HistoricalOps>()
            val lock = ReentrantLock()
            val condition = lock.newCondition()
            SystemUtil.runWithShellPermissionIdentity {
                appOpsManager.getHistoricalOps(request, context.mainExecutor,
                        Consumer { historicalOps: AppOpsManager.HistoricalOps ->
                            historicalOpsRef.set(historicalOps)
                            lock.lock()
                            try {
                                condition.signalAll()
                            } finally {
                                lock.unlock()
                            }
                        })
            }
            lock.lock()
            try {
                condition.await(ASYNC_OPERATION_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS)
            } finally {
                lock.unlock()
            }

            val historicalOps = historicalOpsRef.get()
            if (checkAccessor) {
                assertHistoricalAccessorOps(op, attributionSource, accessorForeground,
                        accessorTrusted, fromDatasource, accessorAccessCount, historicalOps)
            } else {
                assertNoHistoricalAccessorOps(op, attributionSource, historicalOps)
            }
            if (attributionSource.next != null) {
                assertHistoricalReceiverOps(op, attributionSource, receiverForeground,
                        accessorTrusted, receiverAccessCount, historicalOps)
            }
        }

        private fun assertLastAccessorOps(
            op: String,
            beginEndMillis: Long,
            endTimeMillis: Long,
            attributionSource: AttributionSource,
            accessorForeground: Boolean,
            accessorTrusted: Boolean,
            assertRunning: Boolean,
            fromDatasource: Boolean,
            allPackagesOps: List<AppOpsManager.PackageOps?>
        ) {
            val accessorPackageOps = findPackageOps(attributionSource.uid,
                    attributionSource.packageName!!, allPackagesOps)
            for (opEntry in accessorPackageOps!!.ops) {
                if (!op.equals(opEntry.opStr)) {
                    continue
                }
                val attributedOpEntry = opEntry.attributedOpEntries[
                        attributionSource.attributionTag]
                if (attributionSource.next == null) {
                    // Access for ourselves
                    assertLastAccessInRange(attributedOpEntry!!, beginEndMillis, endTimeMillis,
                            AppOpsManager.OP_FLAG_SELF, accessorForeground, assertRunning)
                } else if (accessorTrusted) {
                    // Access for others and we are trusted. If we got the data from a datasource
                    // the latter is the proxy and we proxied, otherwise we are the proxy.
                    if (fromDatasource) {
                        assertLastAccessInRange(attributedOpEntry!!, beginEndMillis, endTimeMillis,
                                AppOpsManager.OP_FLAG_TRUSTED_PROXIED, accessorForeground,
                                assertRunning)
                    } else {
                        assertLastAccessInRange(attributedOpEntry!!, beginEndMillis, endTimeMillis,
                                AppOpsManager.OP_FLAG_TRUSTED_PROXY, accessorForeground,
                                assertRunning)
                    }
                } else {
                    // Access for others and we are not trusted.
                    assertLastAccessInRange(attributedOpEntry!!, beginEndMillis, endTimeMillis,
                            AppOpsManager.OP_FLAG_UNTRUSTED_PROXY, accessorForeground,
                            assertRunning)
                }
            }
        }

        private fun assertNotLastAccessorOps(
            op: String,
            attributionSource: AttributionSource,
            allPackagesOps: List<AppOpsManager.PackageOps?>
        ) {
            val accessorPackageOps = findPackageOps(attributionSource.uid,
                    attributionSource.packageName!!, allPackagesOps) ?: return
            for (opEntry in accessorPackageOps.ops) {
                if (!op.equals(opEntry.opStr)) {
                    continue
                }
                val attributedOpEntry = opEntry.attributedOpEntries[
                        attributionSource.attributionTag]
                if (attributedOpEntry != null) {
                    assertThat(attributedOpEntry.getLastAccessBackgroundTime(
                            AppOpsManager.OP_FLAG_SELF
                            or AppOpsManager.OP_FLAG_UNTRUSTED_PROXY
                            or AppOpsManager.OP_FLAG_TRUSTED_PROXY)).isEqualTo(-1)
                    assertThat(attributedOpEntry.getLastAccessBackgroundTime(
                            AppOpsManager.OP_FLAG_SELF
                            or AppOpsManager.OP_FLAG_UNTRUSTED_PROXY
                            or AppOpsManager.OP_FLAG_TRUSTED_PROXY)).isEqualTo(-1)
                }
            }
        }

        private fun assertHistoricalAccessorOps(
            op: String,
            attributionSource: AttributionSource,
            accessorForeground: Boolean,
            accessorTrusted: Boolean,
            fromDatasource: Boolean,
            assertedAccessCount: Int,
            historicalOps: AppOpsManager.HistoricalOps
        ) {
            val accessorPackageOps = findPackageOps(
                    attributionSource.uid, attributionSource.packageName!!,
                    historicalOps)
            val attributedPackageOps = accessorPackageOps?.getAttributedOps(
                    attributionSource.attributionTag)

            val attributedPackageOp = attributedPackageOps!!.getOp(op)
            if (attributionSource.next == null) {
                // Access for ourselves
                assertAccessCount(attributedPackageOp!!, AppOpsManager.OP_FLAG_SELF,
                        accessorForeground, assertedAccessCount)
            } else if (accessorTrusted) {
                // Access for others and we are trusted. If we got the data from a datasource it
                // would blame the accessor in a trusted way
                if (fromDatasource) {
                    assertAccessCount(attributedPackageOp!!, AppOpsManager.OP_FLAG_TRUSTED_PROXIED,
                            accessorForeground, assertedAccessCount)
                } else {
                    assertAccessCount(attributedPackageOp!!, AppOpsManager.OP_FLAG_TRUSTED_PROXY,
                            accessorForeground, assertedAccessCount)
                }
            } else {
                // Access for others and we are not trusted
                assertAccessCount(attributedPackageOp!!, AppOpsManager.OP_FLAG_UNTRUSTED_PROXY,
                        accessorForeground, assertedAccessCount)
            }
        }

        private fun assertNoHistoricalAccessorOps(
            op: String,
            attributionSource: AttributionSource,
            historicalOps: AppOpsManager.HistoricalOps
        ) {
            val accessorPackageOps = findPackageOps(
                    attributionSource.uid, attributionSource.packageName!!,
                    historicalOps)
            val attributedPackageOps = accessorPackageOps?.getAttributedOps(
                    attributionSource.attributionTag) ?: return
            val attributedPackageOp = attributedPackageOps.getOp(op)
            if (attributedPackageOp != null) {
                assertThat(attributedPackageOp.getBackgroundAccessCount(
                        AppOpsManager.OP_FLAG_SELF
                                or AppOpsManager.OP_FLAG_UNTRUSTED_PROXY
                                or AppOpsManager.OP_FLAG_TRUSTED_PROXY)).isEqualTo(0)
                assertThat(attributedPackageOp.getBackgroundAccessCount(
                        AppOpsManager.OP_FLAG_SELF
                                or AppOpsManager.OP_FLAG_UNTRUSTED_PROXY
                                or AppOpsManager.OP_FLAG_TRUSTED_PROXY)).isEqualTo(0)
            }
        }

        private fun assertLastReceiverOps(
            op: String,
            beginTimeMillis: Long,
            endTimeMillis: Long,
            attributionSource: AttributionSource,
            receiverForeground: Boolean,
            accessorTrusted: Boolean,
            assertRunning: Boolean,
            allPackagesOps: List<AppOpsManager.PackageOps?>
        ) {
            val receiverPackageOps = findPackageOps(
                    attributionSource.next!!.uid,
                    attributionSource.next!!.packageName!!,
                    allPackagesOps)
            for (opEntry in receiverPackageOps!!.ops) {
                if (op != opEntry.opStr) {
                    continue
                }
                val attributedOpEntry = opEntry.attributedOpEntries[
                        attributionSource.next!!.attributionTag]
                val opProxyInfo: AppOpsManager.OpEventProxyInfo?
                opProxyInfo = if (accessorTrusted) {
                    // Received from a trusted accessor. If we got the data from a datasource it
                    // would blame the accessor in a trusted way
                    assertLastAccessInRange(attributedOpEntry!!, beginTimeMillis, endTimeMillis,
                            AppOpsManager.OP_FLAG_TRUSTED_PROXIED, receiverForeground,
                            assertRunning)
                    attributedOpEntry.getLastProxyInfo(AppOpsManager.OP_FLAG_TRUSTED_PROXIED)
                } else {
                    // Received from an untrusted accessor
                    assertLastAccessInRange(attributedOpEntry!!, beginTimeMillis, endTimeMillis,
                            AppOpsManager.OP_FLAG_UNTRUSTED_PROXIED, receiverForeground,
                            assertRunning)
                    attributedOpEntry.getLastProxyInfo(
                            AppOpsManager.OP_FLAG_UNTRUSTED_PROXIED)
                }
                assertThat(opProxyInfo!!.uid).isEqualTo(attributionSource.uid)
                assertThat(opProxyInfo.packageName).isEqualTo(attributionSource.packageName)
                assertThat(opProxyInfo.attributionTag).isEqualTo(attributionSource.attributionTag)
            }
        }

        private fun assertHistoricalReceiverOps(
            op: String,
            attributionSource: AttributionSource,
            receiverForeground: Boolean,
            accessorTrusted: Boolean,
            assertedAccessCount: Int,
            historicalOps: AppOpsManager.HistoricalOps
        ) {
            val accessorPackageOps = findPackageOps(
                    attributionSource.next!!.uid,
                    attributionSource.next!!.packageName!!,
                    historicalOps)
            val attributedPackageOps = accessorPackageOps?.getAttributedOps(
                    attributionSource.next!!.attributionTag!!)
            val attributedPackageOp = attributedPackageOps!!.getOp(op)
            if (accessorTrusted) {
                // Received from a trusted accessor.
                    assertAccessCount(attributedPackageOp!!, AppOpsManager.OP_FLAG_TRUSTED_PROXIED,
                            receiverForeground, assertedAccessCount)
            } else {
                // Received from an untrusted accessor
                assertAccessCount(attributedPackageOp!!, AppOpsManager.OP_FLAG_UNTRUSTED_PROXIED,
                        receiverForeground, assertedAccessCount)
            }
        }

        private fun assertLastAccessInRange(
            opEntry: AppOpsManager.AttributedOpEntry,
            beginTimeMillis: Long,
            endTimeMillis: Long,
            assertedFlag: Int,
            assertForeground: Boolean,
            assertRunning: Boolean
        ) {
            assertThat(opEntry.isRunning).isEqualTo(assertRunning)
            assertTimeInRangeIfRequired(opEntry, assertedFlag,
                    AppOpsManager.OP_FLAG_SELF,
                    assertForeground, beginTimeMillis, endTimeMillis)
            assertTimeInRangeIfRequired(opEntry, assertedFlag,
                    AppOpsManager.OP_FLAG_TRUSTED_PROXY,
                    assertForeground, beginTimeMillis, endTimeMillis)
            assertTimeInRangeIfRequired(opEntry, assertedFlag,
                    AppOpsManager.OP_FLAG_UNTRUSTED_PROXY,
                    assertForeground, beginTimeMillis, endTimeMillis)
            assertTimeInRangeIfRequired(opEntry, assertedFlag,
                    AppOpsManager.OP_FLAG_TRUSTED_PROXIED,
                    assertForeground, beginTimeMillis, endTimeMillis)
            assertTimeInRangeIfRequired(opEntry, assertedFlag,
                    AppOpsManager.OP_FLAG_UNTRUSTED_PROXIED,
                    assertForeground, beginTimeMillis, endTimeMillis)
            if (assertForeground) {
                assertThat(opEntry.getLastAccessBackgroundTime(AppOpsManager.OP_FLAGS_ALL))
                        .isEqualTo(-1)
            } else {
                assertThat(opEntry.getLastAccessForegroundTime(AppOpsManager.OP_FLAGS_ALL))
                        .isEqualTo(-1)
            }
        }

        private fun assertTimeInRangeIfRequired(
            opEntry: AppOpsManager.AttributedOpEntry,
            assertedFlag: Int,
            accessedFlag: Int,
            assertForeground: Boolean,
            beginTimeMillis: Long,
            endTimeMillis: Long
        ) {
            if (assertedFlag != accessedFlag) {
                return
            }
            val accessTime: Long
            accessTime = if (assertForeground) {
                opEntry.getLastAccessForegroundTime(accessedFlag)
            } else {
                opEntry.getLastAccessBackgroundTime(accessedFlag)
            }
            assertThat(accessTime).isAtLeast(beginTimeMillis)
            assertThat(accessTime).isAtMost(endTimeMillis)
        }

        private fun assertAccessCount(
            historicalOp: AppOpsManager.HistoricalOp,
            assertedFlag: Int,
            assertForeground: Boolean,
            assertedAccessCount: Int
        ) {
            assertAccessCountIfRequired(historicalOp, AppOpsManager.OP_FLAG_SELF,
                    assertedFlag, assertForeground, assertedAccessCount)
            assertAccessCountIfRequired(historicalOp, AppOpsManager.OP_FLAG_TRUSTED_PROXY,
                    assertedFlag, assertForeground, assertedAccessCount)
            assertAccessCountIfRequired(historicalOp, AppOpsManager.OP_FLAG_UNTRUSTED_PROXY,
                    assertedFlag, assertForeground, assertedAccessCount)
            assertAccessCountIfRequired(historicalOp, AppOpsManager.OP_FLAG_TRUSTED_PROXIED,
                    assertedFlag, assertForeground, assertedAccessCount)
            assertAccessCountIfRequired(historicalOp, AppOpsManager.OP_FLAG_UNTRUSTED_PROXIED,
                    assertedFlag, assertForeground, assertedAccessCount)
            if (assertForeground) {
                assertThat(historicalOp.getBackgroundAccessCount(
                        AppOpsManager.OP_FLAGS_ALL)).isEqualTo(0)
            } else {
                assertThat(historicalOp.getForegroundAccessCount(
                        AppOpsManager.OP_FLAGS_ALL)).isEqualTo(0)
            }
        }

        private fun assertAccessCountIfRequired(
            historicalOp: AppOpsManager.HistoricalOp,
            assertedFlag: Int,
            accessedFlag: Int,
            assertForeground: Boolean,
            assertedAccessCount: Int
        ) {
            if (assertedFlag != accessedFlag) {
                return
            }
            val accessCount: Long
            accessCount = if (assertForeground) {
                historicalOp.getForegroundAccessCount(accessedFlag)
            } else {
                historicalOp.getBackgroundAccessCount(accessedFlag)
            }
            assertThat(accessCount).isEqualTo(assertedAccessCount)
        }

        private fun findPackageOps(
            uid: Int,
            packageName: String,
            searchedList: List<AppOpsManager.PackageOps?>
        ): AppOpsManager.PackageOps? {
            return searchedList.stream()
                    .filter { packageOps: AppOpsManager.PackageOps? ->
                        packageOps!!.uid == uid && packageOps.packageName == packageName
                    }
                    .findAny()
                    .orElse(null)
        }

        private fun findPackageOps(
            uid: Int,
            packageName: String,
            historicalOps: AppOpsManager.HistoricalOps
        ): AppOpsManager.HistoricalPackageOps? {
            val uidOps = historicalOps.getUidOps(uid)
            return uidOps?.getPackageOps(packageName)
        }

        fun createAttributionContext(
            attributionTag: String?,
            receiverPackageName: String?,
            receiverAttributionTag: String?
        ): Context {
            val attributionParamsBuilder = ContextParams.Builder()
            if (attributionTag != null) {
                attributionParamsBuilder.setAttributionTag(attributionTag)
            }
            if (receiverPackageName != null) {
                val attributionSourceBuilder = AttributionSource.Builder(
                        context.packageManager.getPackageUid(receiverPackageName, 0))
                attributionSourceBuilder.setPackageName(receiverPackageName)
                if (receiverAttributionTag != null) {
                    attributionSourceBuilder.setAttributionTag(receiverAttributionTag)
                }
                var receiverAttributionSource = attributionSourceBuilder.build()
                SystemUtil.runWithShellPermissionIdentity {
                    receiverAttributionSource = context.getSystemService(
                            PermissionManager::class.java)!!.registerAttributionSource(
                            receiverAttributionSource)
                }
                attributionParamsBuilder.setNextAttributionSource(receiverAttributionSource)
            }
            return context.createContext(attributionParamsBuilder.build())
        }

        fun startBlamedAppActivity(): AttributionSource {
            val activityStatedLatch = CountDownLatch(1)
            val attributionSourceRef = AtomicReference<AttributionSource>()
            val intent = Intent()
            intent.setClassName(RECEIVER_PACKAGE_NAME, BRING_TO_FOREGROUND_ACTIVITY)
            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_SINGLE_TOP)
            intent.putExtra(REMOTE_CALLBACK, RemoteCallback {
                attributionSourceRef.set(it?.getParcelable(ATTRIBUTION_SOURCE))
                activityStatedLatch.countDown()
            })
            context.startActivity(intent)
            activityStatedLatch.await(ASYNC_OPERATION_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS)
            return attributionSourceRef.get()
        }

        private fun assumeNotTv() = assumeFalse(isTv)
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/permission5/src/android/permission5/cts/RuntimePermissionsAppOpTrackingTest.kt"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.permission5.cts.RenouncedPermissionsTest.kt"	"testRenouncePermissionsChain"	"CtsPermission5TestCases"	"1: attribution"	"@Throws(Exception::class)
    @AppModeFull(reason=""Instant apps cannot hold READ_CALENDAR/READ_CONTACTS permissions"")
    fun testRenouncePermissionsChain() {
        val receiverAttributionSource = getShellAttributionSourceWithRenouncedPermissions()
        val activity = createActivityWithAttributionContext(receiverAttributionSource)

        // Out app has the permissions
        assertThat(activity.checkSelfPermission(Manifest.permission.READ_CALENDAR))
                .isEqualTo(PackageManager.PERMISSION_GRANTED)
        assertThat(activity.checkSelfPermission(Manifest.permission.READ_CONTACTS))
                .isEqualTo(PackageManager.PERMISSION_GRANTED)

        // Accessing the data should also fail (for us and next in the data flow)
        assertThrows(SecurityException::class.java, ThrowingRunnable{
            activity.contentResolver.query(CalendarContract.Calendars.CONTENT_URI,
                    null, null, null)!!.close()
        })
        assertThrows(SecurityException::class.java, ThrowingRunnable{
            activity.contentResolver.query(ContactsContract.Contacts.CONTENT_URI,
                    null, null, null)!!.close()
        })
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/permission5/src/android/permission5/cts/RenouncedPermissionsTest.kt"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.permission5.cts.RenouncedPermissionsTest.kt"	"testCannotRenouncePermissionsWithoutPermission"	"CtsPermission5TestCases"	"1: attribution"	"(expected = SecurityException::class)
    fun testCannotRenouncePermissionsWithoutPermission() {
        val renouncedPermissions = ArraySet<String>()
        renouncedPermissions.add(Manifest.permission.READ_CONTACTS);

        // Trying to renounce permissions with no permission throws
        createActivityWithAttributionContext(/*receiverAttributionSource*/ null,
                renouncedPermissions)
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/permission5/src/android/permission5/cts/RenouncedPermissionsTest.kt"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.permission5.cts.RenouncedPermissionsTest.kt"	"testCannotRequestRenouncePermissions"	"CtsPermission5TestCases"	"1: attribution"	"(expected = IllegalArgumentException::class)
    fun testCannotRequestRenouncePermissions() {
        val renouncedPermissions = ArraySet<String>()
        renouncedPermissions.add(Manifest.permission.READ_CONTACTS);
        val activity = createActivityWithAttributionSource(AttributionSource(Process.myUid(),
                context.packageName, null, renouncedPermissions, null))

        // Requesting renounced permissions throws
        activity.requestPermissions(arrayOf(Manifest.permission.READ_CONTACTS), 1)
    }

    fun createActivityWithAttributionContext(receiverAttributionSource: AttributionSource?,
            renouncedPermissions: Set<String>? = null) : Activity {
        val contextParams = ContextParams.Builder()
                .setRenouncedPermissions(renouncedPermissions)
                .setNextAttributionSource(receiverAttributionSource)
                .build()
        return createActivityWithContextParams(contextParams)
    }

    fun createActivityWithAttributionSource(attributionSource: AttributionSource) : Activity {
        val mockActivity = Mockito.mock(Activity::class.java)
        `when`(mockActivity.getAttributionSource()).thenReturn(attributionSource)
        return mockActivity
    }

    fun createActivityWithContextParams(contextParams: ContextParams) : Activity {
        val activityReference = AtomicReference<NoOpActivity>()
        instrumentation.runOnMainSync {
            activityReference.set(NoOpActivity())
        }
        val activity = activityReference.get()
        activity.attachBaseContext(context.createContext(contextParams))
        return activity
    }

    companion object {
        private val context: Context
            get () = InstrumentationRegistry.getInstrumentation().getContext()

        private val instrumentation: Instrumentation
            get () = InstrumentationRegistry.getInstrumentation()

        fun getShellAttributionSourceWithRenouncedPermissions() : AttributionSource {
            // Let's cook up an attribution source for the shell with its cooperation
            val renouncedPermissionsSet = ArraySet<String>();
            renouncedPermissionsSet.add(Manifest.permission.READ_CONTACTS)
            renouncedPermissionsSet.add(Manifest.permission.READ_CALENDAR)

            // Calculate the shellUid to account for running this from a secondary user.
            val shellUid = UserHandle.getUid(Process.myUserHandle().identifier,
                UserHandle.getAppId(Process.SHELL_UID))
            var shellAttributionSource = AttributionSource.Builder(shellUid)
                    .setPackageName(""com.android.shell"")
                    .setRenouncedPermissions(renouncedPermissionsSet)
                    .build()

            SystemUtil.runWithShellPermissionIdentity {
                val permissionManager = context.getSystemService(PermissionManager::class.java)!!
                shellAttributionSource = permissionManager.registerAttributionSource(
                        shellAttributionSource)
            }

            return shellAttributionSource
        }
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/permission5/src/android/permission5/cts/RenouncedPermissionsTest.kt"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.activityrecognition.cts.ActivityRecognizerAttributionTags.kt"	"testActivityRecognitionAttributionTagBlaming"	"CtsActivityRecognitionTestCases"	"1: attribution"	"fun testActivityRecognitionAttributionTagBlaming() {
        // Using an AR allow listed tag
        var timeBeforeArAccess = System.currentTimeMillis()
        accessActivityRecognition(VALID_AR_ATTRIBUTION_TAG)
        assertNotedOpsSinceLastArAccess(timeBeforeArAccess, /*expectedOp*/
                AppOpsManager.OPSTR_ACTIVITY_RECOGNITION_SOURCE, /*unexpectedOp*/
                AppOpsManager.OPSTR_ACTIVITY_RECOGNITION)

        // Using an AR not allow listed tag
        timeBeforeArAccess = System.currentTimeMillis()
        accessActivityRecognition(INVALID_AR_ATTRIBUTION_TAG)
        assertNotedOpsSinceLastArAccess(timeBeforeArAccess, /*expectedOp*/
                AppOpsManager.OPSTR_ACTIVITY_RECOGNITION, /*unexpectedOp*/
                AppOpsManager.OPSTR_ACTIVITY_RECOGNITION_SOURCE)
    }

    fun accessActivityRecognition(attributionTag: String) {
        val appOpsManager = context.getSystemService(AppOpsManager::class.java)
        appOpsManager?.noteOp(AppOpsManager.OPSTR_ACTIVITY_RECOGNITION, Process.myUid(),
                context.packageName, attributionTag, /*message*/ null)
    }

    fun assertNotedOpsSinceLastArAccess(timeBeforeArAccess: Long,
            expectedOp: String, unexpectedOp: String) {
        val automation: UiAutomation = instrumentation.getUiAutomation()
        automation.adoptShellPermissionIdentity(Manifest.permission.GET_APP_OPS_STATS)
        try {
            val appOpsManager: AppOpsManager = context.getSystemService(AppOpsManager::class.java)!!
            val affectedPackageOps = appOpsManager.getPackagesForOps(
                    arrayOf(expectedOp, unexpectedOp))
            val packageCount = affectedPackageOps.size
            for (i in 0 until packageCount) {
                val packageOps = affectedPackageOps[i]
                if (!context.getPackageName().equals(packageOps.packageName)) {
                    continue
                }
                // We are pulling stats only for one app op.
                val opEntries = packageOps.ops
                val opEntryCount = opEntries.size
                for (j in 0 until opEntryCount) {
                    val opEntry = opEntries[j]
                    if (unexpectedOp == opEntry.opStr) {
                        fail(""Unexpected access to $unexpectedOp"")
                    } else if (expectedOp == opEntry.opStr) {
                        if (opEntry.getLastAccessTime(AppOpsManager.OP_FLAGS_ALL_TRUSTED) >=
                                timeBeforeArAccess) {
                            return
                        }
                        break
                    }
                }
            }
            fail(""No expected access to $expectedOp"")
        } finally {
            automation.dropShellPermissionIdentity()
        }
    }

    companion object {
        val VALID_AR_ATTRIBUTION_TAG = ""valid_ar_attribution_tag""
        val INVALID_AR_ATTRIBUTION_TAG = ""invalid_ar_attribution_tag""

        private val context: Context
            get () = InstrumentationRegistry.getInstrumentation().getContext()

        private val instrumentation: Instrumentation
            get () = InstrumentationRegistry.getInstrumentation()
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/activityrecognition/src/android/activityrecognition/cts/ActivityRecognizerAttributionTags.kt"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.app.cts.AttributionTagsTest"	"testActivity"	"CtsAppTestCases"	"1: attribution"	"public void testActivity() throws Exception {
        // Verify manifest parsing
        final Intent intent = new Intent(mTargetContext, LocalActivity.class);
        assertEquals(""localActivity"",
                mPackageManager.getActivityInfo(intent.getComponent(), 0).attributionTags[0]);

        // Verify live behavior
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        mContext.startActivity(intent);
        assertAttributionTag(""activity"", ""localActivity"");
    }"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/AttributionTagsTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.app.cts.AttributionTagsTest"	"testActivityAlias"	"CtsAppTestCases"	"1: attribution"	"public void testActivityAlias() throws Exception {
        // Verify manifest parsing
        final Intent intent = new Intent();
        intent.setComponent(new ComponentName(mTargetContext.getPackageName(),
                ""android.app.stubs.LocalActivityAlias""));
        assertEquals(""localActivityAlias"",
                mPackageManager.getActivityInfo(intent.getComponent(), 0).attributionTags[0]);

        // Verify live behavior
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        mContext.startActivity(intent);
        assertAttributionTag(""activity"", ""localActivityAlias"");
    }"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/AttributionTagsTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.app.cts.AttributionTagsTest"	"testService"	"CtsAppTestCases"	"1: attribution"	"public void testService() throws Exception {
        // Verify manifest parsing
        final Intent intent = new Intent(mTargetContext, LocalService.class);
        assertEquals(""localService"",
                mPackageManager.getServiceInfo(intent.getComponent(), 0).attributionTags[0]);

        // Verify live behavior
        mContext.startService(intent);
        assertAttributionTag(""service"", ""localService"");
    }"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/AttributionTagsTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.app.cts.AttributionTagsTest"	"testProvider"	"CtsAppTestCases"	"1: attribution"	"public void testProvider() throws Exception {
        // Verify manifest parsing
        final Intent intent = new Intent(mTargetContext, LocalProvider.class);
        assertEquals(""localProvider"",
                mPackageManager.getProviderInfo(intent.getComponent(), 0).attributionTags[0]);

        // Probing for the attribution tag will itself spin up the provider as a
        // side-effect, so we have no special pre-work needed here
        assertAttributionTag(""provider"", ""localProvider"");
    }"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/AttributionTagsTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.app.cts.AttributionTagsTest"	"testReceiver"	"CtsAppTestCases"	"1: attribution"	"public void testReceiver() throws Exception {
        // Verify manifest parsing
        final Intent intent = new Intent(mTargetContext, LocalReceiver.class);
        assertEquals(""localReceiver"",
                mPackageManager.getReceiverInfo(intent.getComponent(), 0).attributionTags[0]);

        // Verify live behavior
        mContext.sendBroadcast(intent);
        assertAttributionTag(""receiver"", ""localReceiver"");
    }

    private void assertAttributionTag(String method, String expected) throws Exception {
        try (ContentProviderClient client = mContext.getContentResolver()
                .acquireContentProviderClient(TEST_AUTHORITY)) {
            for (int i = 0; i < 10; i++) {
                final Bundle res = client.call(TEST_AUTHORITY, method, null, null);
                final String actual = res.getString(Intent.EXTRA_TITLE);
                if (actual == null) {
                    Log.v(TAG, ""No attribution tag yet; waiting..."");
                    SystemClock.sleep(500);
                    continue;
                } else {
                    assertEquals(expected, actual);
                    break;
                }
            }
        }
    }
}"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/AttributionTagsTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.location.cts.fine.LocationManagerFineTest"	"currentTimeMillis"	"CtsLocationFineTestCases"	"1: attribution"	"/*
 *.
 */

package android.location.cts.fine;

import static android.Manifest.permission.WRITE_SECURE_SETTINGS;
import static android.content.pm.PackageManager.FEATURE_AUTOMOTIVE;
import static android.location.LocationManager.EXTRA_PROVIDER_ENABLED;
import static android.location.LocationManager.EXTRA_PROVIDER_NAME;
import static android.location.LocationManager.FUSED_PROVIDER;
import static android.location.LocationManager.GPS_PROVIDER;
import static android.location.LocationManager.NETWORK_PROVIDER;
import static android.location.LocationManager.PASSIVE_PROVIDER;
import static android.location.LocationManager.PROVIDERS_CHANGED_ACTION;
import static android.location.LocationRequest.PASSIVE_INTERVAL;
import static android.os.PowerManager.LOCATION_MODE_ALL_DISABLED_WHEN_SCREEN_OFF;
import static android.os.PowerManager.LOCATION_MODE_GPS_DISABLED_WHEN_SCREEN_OFF;
import static android.os.PowerManager.LOCATION_MODE_THROTTLE_REQUESTS_WHEN_SCREEN_OFF;

import static androidx.test.ext.truth.content.IntentSubject.assertThat;
import static androidx.test.ext.truth.location.LocationSubject.assertThat;
import static androidx.test.platform.app.InstrumentationRegistry.getInstrumentation;

import static com.android.compatibility.common.util.LocationUtils.createLocation;

import static com.google.common.truth.Truth.assertThat;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.junit.Assume.assumeFalse;
import static org.junit.Assume.assumeTrue;

import android.Manifest;
import android.annotation.NonNull;
import android.app.AppOpsManager;
import android.app.PendingIntent;
import android.app.UiAutomation;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.location.Criteria;
import android.location.GnssMeasurementsEvent;
import android.location.GnssNavigationMessage;
import android.location.GnssStatus;
import android.location.Location;
import android.location.LocationListener;
import android.location.LocationManager;
import android.location.LocationProvider;
import android.location.LocationRequest;
import android.location.OnNmeaMessageListener;
import android.location.cts.common.BroadcastCapture;
import android.location.cts.common.GetCurrentLocationCapture;
import android.location.cts.common.LocationListenerCapture;
import android.location.cts.common.LocationPendingIntentCapture;
import android.location.cts.common.ProviderRequestChangedListenerCapture;
import android.location.cts.common.gnss.GnssAntennaInfoCapture;
import android.location.cts.common.gnss.GnssMeasurementsCapture;
import android.location.cts.common.gnss.GnssNavigationMessageCapture;
import android.location.provider.ProviderProperties;
import android.os.HandlerThread;
import android.os.Looper;
import android.os.PowerManager;
import android.os.SystemClock;
import android.os.UserHandle;
import android.platform.test.annotations.AppModeFull;
import android.provider.DeviceConfig;
import android.util.ArraySet;
import android.util.Log;

import androidx.test.core.app.ApplicationProvider;
import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.platform.app.InstrumentationRegistry;

import com.android.compatibility.common.util.BatteryUtils;
import com.android.compatibility.common.util.DeviceConfigStateHelper;
import com.android.compatibility.common.util.LocationUtils;
import com.android.compatibility.common.util.ScreenUtils;
import com.android.compatibility.common.util.ScreenUtils.ScreenResetter;

import org.junit.After;
import org.junit.Before;
import org.junit.Ignore;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Objects;
import java.util.Random;
import java.util.concurrent.Executors;

@RunWith(AndroidJUnit4.class)
public class LocationManagerFineTest {

    private static final String TAG = ""LocationManagerFineTest"";

    private static final long TIMEOUT_MS = 5000;
    private static final long FAILURE_TIMEOUT_MS = 200;

    private static final String TEST_PROVIDER = ""test_provider"";

    private static final String VALID_LOCATION_ATTRIBUTION_TAG = ""valid_location_attribution_tag"";
    private static final String ANOTHER_VALID_LOCATION_ATTRIBUTION_TAG =
            ""another_valid_location_attribution_tag"";
    private static final String INVALID_LOCATION_ATTRIBUTION_TAG =
            ""invalid_location_attribution_tag"";

    private static final String IGNORE_SETTINGS_ALLOWLIST = ""ignore_settings_allowlist"";

    private Random mRandom;
    private Context mContext;
    private LocationManager mManager;

    @Before
    public void setUp() throws Exception {
        LocationUtils.registerMockLocationProvider(getInstrumentation(),
                true);

        long seed = System.currentTimeMillis();
        Log.i(TAG, ""location random seed: "" + seed);

        mRandom = new Random(seed);
        mContext = ApplicationProvider.getApplicationContext();
        mManager = Objects.requireNonNull(mContext.getSystemService(LocationManager.class));

        for (String provider : mManager.getAllProviders()) {
            mManager.removeTestProvider(provider);
        }

        mManager.addTestProvider(TEST_PROVIDER,
                true,
                false,
                true,
                false,
                false,
                false,
                false,
                Criteria.POWER_MEDIUM,
                Criteria.ACCURACY_FINE);
        mManager.setTestProviderEnabled(TEST_PROVIDER, true);
    }

    @After
    public void tearDown() throws Exception {
        if (mManager != null) {
            for (String provider : mManager.getAllProviders()) {
                mManager.removeTestProvider(provider);
            }
            mManager.removeTestProvider(FUSED_PROVIDER);
        }

        LocationUtils.registerMockLocationProvider(getInstrumentation(),
                false);
    }"	"/home/gpoor/cts-12-source/cts/tests/location/location_fine/src/android/location/cts/fine/LocationManagerFineTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.location.cts.fine.LocationManagerFineTest"	"testRegisterGnssNavigationMessageCallback"	"CtsLocationFineTestCases"	"1: attribution"	"public void testRegisterGnssNavigationMessageCallback() throws Exception {
        try (GnssNavigationMessageCapture capture = new GnssNavigationMessageCapture(mContext)) {
            mManager.registerGnssNavigationMessageCallback(Runnable::run, capture);

            // test deprecated status messages
            if (mManager.hasProvider(GPS_PROVIDER)) {
                Integer status = capture.getNextStatus(TIMEOUT_MS);
                assertThat(status).isNotNull();
                assertThat(status).isEqualTo(GnssNavigationMessage.Callback.STATUS_READY);
            }
        }
    }

    private void addTestProviderForAttributionTag(String... attributionTags) {
        mManager.removeTestProvider(TEST_PROVIDER);
        mManager.addTestProvider(TEST_PROVIDER,
                new ProviderProperties.Builder().build(), (attributionTags != null)
                        ? new ArraySet<>(attributionTags)
                        : Collections.emptySet());
        mManager.setTestProviderEnabled(TEST_PROVIDER, true);
    }

    @Ignore(""b/181693958"")"	"/home/gpoor/cts-12-source/cts/tests/location/location_fine/src/android/location/cts/fine/LocationManagerFineTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.location.cts.fine.LocationManagerFineTest"	"testLocationAttributionTagBlaming"	"CtsLocationFineTestCases"	"1: attribution"	"public void testLocationAttributionTagBlaming() {
        // No tag set
        addTestProviderForAttributionTag();
        long timeBeforeLocationAccess = System.currentTimeMillis();
        accessLocation(VALID_LOCATION_ATTRIBUTION_TAG);
        assertNotedOpsSinceLastLocationAccess(timeBeforeLocationAccess,
                /*expectedOp*/ AppOpsManager.OPSTR_FINE_LOCATION,
                /*unexpectedOp*/ AppOpsManager.OPSTR_FINE_LOCATION_SOURCE,
                VALID_LOCATION_ATTRIBUTION_TAG);

        // Tag set and using that correct tag
        addTestProviderForAttributionTag(VALID_LOCATION_ATTRIBUTION_TAG);
        timeBeforeLocationAccess = System.currentTimeMillis();
        accessLocation(VALID_LOCATION_ATTRIBUTION_TAG);
        assertNotedOpsSinceLastLocationAccess(timeBeforeLocationAccess,
                /*expectedOp*/ AppOpsManager.OPSTR_FINE_LOCATION_SOURCE,
                /*unexpectedOp*/ AppOpsManager.OPSTR_FINE_LOCATION,
                VALID_LOCATION_ATTRIBUTION_TAG);

        // Tag set and using a wrong tag
        timeBeforeLocationAccess = System.currentTimeMillis();
        accessLocation(INVALID_LOCATION_ATTRIBUTION_TAG);
        assertNotedOpsSinceLastLocationAccess(timeBeforeLocationAccess,
                /*expectedOp*/ AppOpsManager.OPSTR_FINE_LOCATION,
                /*unexpectedOp*/ AppOpsManager.OPSTR_FINE_LOCATION_SOURCE,
                INVALID_LOCATION_ATTRIBUTION_TAG);

        // Tag set and using that correct tag
        timeBeforeLocationAccess = System.currentTimeMillis();
        accessLocation(VALID_LOCATION_ATTRIBUTION_TAG);
        assertNotedOpsSinceLastLocationAccess(timeBeforeLocationAccess,
                /*expectedOp*/ AppOpsManager.OPSTR_FINE_LOCATION_SOURCE,
                /*unexpectedOp*/ AppOpsManager.OPSTR_FINE_LOCATION,
                VALID_LOCATION_ATTRIBUTION_TAG);

        // No tag set
        addTestProviderForAttributionTag();
        timeBeforeLocationAccess = System.currentTimeMillis();
        accessLocation(VALID_LOCATION_ATTRIBUTION_TAG);
        assertNotedOpsSinceLastLocationAccess(timeBeforeLocationAccess,
                /*expectedOp*/ AppOpsManager.OPSTR_FINE_LOCATION,
                /*unexpectedOp*/ AppOpsManager.OPSTR_FINE_LOCATION_SOURCE,
                VALID_LOCATION_ATTRIBUTION_TAG);
    }"	"/home/gpoor/cts-12-source/cts/tests/location/location_fine/src/android/location/cts/fine/LocationManagerFineTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-5-2"	"9.8.2/H-5-2"	"getIndicatorAppOpUsageData"	"""[9.8.2/H-5-2] MUST display Recent and Active apps using camera as returned from PermissionManager.getIndicatorAppOpUsageData(), along with any attribution messages associated with them. """	""	"android.location.cts.fine.LocationManagerFineTest"	"testRequestLocationUpdatesNoteOps_simultaneousRequests"	"CtsLocationFineTestCases"	"1: attribution attribution"	"public void testRequestLocationUpdatesNoteOps_simultaneousRequests() {
        Context attributionContextFast =
                mContext.createAttributionContext(VALID_LOCATION_ATTRIBUTION_TAG);
        Context attributionContextSlow =
                mContext.createAttributionContext(ANOTHER_VALID_LOCATION_ATTRIBUTION_TAG);
        Location loc1 = createLocation(TEST_PROVIDER, mRandom);
        Location loc2 = createLocation(TEST_PROVIDER, mRandom);

        try (LocationListenerCapture fastCapture =
                     new LocationListenerCapture(attributionContextFast);
             LocationListenerCapture slowCapture =
                     new LocationListenerCapture(attributionContextSlow)) {
            attributionContextFast
                    .getSystemService(LocationManager.class)
                    .requestLocationUpdates(
                            TEST_PROVIDER,
                            new LocationRequest.Builder(0).build(),
                            Runnable::run,
                            fastCapture);
            attributionContextSlow
                    .getSystemService(LocationManager.class)
                    .requestLocationUpdates(
                            TEST_PROVIDER,
                            new LocationRequest.Builder(600000).build(),
                            Runnable::run,
                            slowCapture);

            // Set initial location.
            long timeBeforeLocationAccess = System.currentTimeMillis();
            mManager.setTestProviderLocation(TEST_PROVIDER, loc1);
            assertNotedOpsSinceLastLocationAccess(
                    timeBeforeLocationAccess,
                    /* expectedOp */ AppOpsManager.OPSTR_FINE_LOCATION,
                    /* unexpectedOp */ AppOpsManager.OPSTR_FINE_LOCATION_SOURCE,
                   VALID_LOCATION_ATTRIBUTION_TAG);

            // Verify noteOp for the fast request.
            timeBeforeLocationAccess = System.currentTimeMillis();
            mManager.setTestProviderLocation(TEST_PROVIDER, loc2);
            assertNotedOpsSinceLastLocationAccess(
                    timeBeforeLocationAccess,
                    /* expectedOp */ AppOpsManager.OPSTR_FINE_LOCATION,
                    /* unexpectedOp */ AppOpsManager.OPSTR_FINE_LOCATION_SOURCE,
                    VALID_LOCATION_ATTRIBUTION_TAG);
            assertNoOpsNotedSinceLastLocationAccess(
                    timeBeforeLocationAccess,
                    AppOpsManager.OPSTR_FINE_LOCATION,
                    ANOTHER_VALID_LOCATION_ATTRIBUTION_TAG);

            // Verify noteOp for the slow request.
            timeBeforeLocationAccess = System.currentTimeMillis();
            Location loc3 = createLocation(TEST_PROVIDER, 0, 1, 10,
                    SystemClock.elapsedRealtimeNanos() + 600000000000L);
            mManager.setTestProviderLocation(TEST_PROVIDER, loc3);
            assertNotedOpsSinceLastLocationAccess(
                    timeBeforeLocationAccess,
                    /* expectedOp */ AppOpsManager.OPSTR_FINE_LOCATION,
                    /* unexpectedOp */ AppOpsManager.OPSTR_FINE_LOCATION_SOURCE,
                    ANOTHER_VALID_LOCATION_ATTRIBUTION_TAG);
        }
    }

    private void accessLocation(String attributionTag) {
        Context attributionContext = mContext.createAttributionContext(attributionTag);
        attributionContext.getSystemService(LocationManager.class).getLastKnownLocation(
                TEST_PROVIDER);
    }

    private void assertNotedOpsSinceLastLocationAccess(
            long timeBeforeLocationAccess,
            @NonNull String expectedOp,
            @NonNull String unexpectedOp,
            String attributionTag) {
        final UiAutomation automation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        automation.adoptShellPermissionIdentity(android.Manifest.permission.GET_APP_OPS_STATS);

        try {
            final AppOpsManager appOpsManager = mContext.getSystemService(AppOpsManager.class);
            final List<AppOpsManager.PackageOps> affectedPackageOps =
                    appOpsManager.getPackagesForOps(new String[]{expectedOp, unexpectedOp});
            for (AppOpsManager.PackageOps packageOps : affectedPackageOps) {
                if (mContext.getPackageName().equals(packageOps.getPackageName())) {
                    // We are pulling stats only for one app op.
                    for (AppOpsManager.OpEntry opEntry : packageOps.getOps()) {
                        if (unexpectedOp.equals(opEntry.getOpStr())) {
                            fail(""Unexpected access to "" + unexpectedOp);
                        } else if (expectedOp.equals(opEntry.getOpStr())
                                && opEntry.getAttributedOpEntries().containsKey(attributionTag)
                                && opEntry
                                .getAttributedOpEntries()
                                .get(attributionTag)
                                .getLastAccessTime(AppOpsManager.OP_FLAGS_ALL_TRUSTED)
                                >= timeBeforeLocationAccess) {
                            return;
                        }
                    }
                }
            }
            fail(""No expected access to "" + expectedOp);
        } finally {
            automation.dropShellPermissionIdentity();
        }
    }

    private void assertNoOpsNotedSinceLastLocationAccess(
            long timeBeforeLocationAccess, @NonNull String unexpectedOp, String attributionTag) {
        final UiAutomation automation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        automation.adoptShellPermissionIdentity(android.Manifest.permission.GET_APP_OPS_STATS);
        try {
            final AppOpsManager appOpsManager = mContext.getSystemService(AppOpsManager.class);
            final List<AppOpsManager.PackageOps> affectedPackageOps =
                    appOpsManager.getPackagesForOps(new String[]{unexpectedOp});
            for (AppOpsManager.PackageOps packageOps : affectedPackageOps) {
                if (mContext.getPackageName().equals(packageOps.getPackageName())) {
                    // We are pulling stats only for one app op.
                    for (AppOpsManager.OpEntry opEntry : packageOps.getOps()) {
                        if (unexpectedOp.equals(opEntry.getOpStr())
                                && opEntry.getAttributedOpEntries().containsKey(attributionTag)
                                && opEntry
                                .getAttributedOpEntries()
                                .get(attributionTag)
                                .getLastAccessTime(AppOpsManager.OP_FLAGS_ALL_TRUSTED)
                                >= timeBeforeLocationAccess) {
                            fail(""Unexpected access to "" + unexpectedOp);
                        }
                    }
                }
            }
        } finally {
            automation.dropShellPermissionIdentity();
        }
    }
}"	"/home/gpoor/cts-12-source/cts/tests/location/location_fine/src/android/location/cts/fine/LocationManagerFineTest.java"	""	""	""
