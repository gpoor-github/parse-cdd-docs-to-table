"Section"	"section_id"	"req_id"	"Test Availability"	"class_def"	"method"	"module"	"method_text"	"full_key"	"requirement"	"key_as_number"	"search_terms"	"manual_search_terms"	"not_search_terms"	"not_files"	"matched_terms"	"search_roots"	"qualified_method"	"max_matches"	"file_name"	"matched_files"	"methods_string"	"urls"	"protected"	"Area"	"Shortened"	"Test Level"
"174:551285) 7.3  . Sensors"	"7.3"	"C-1-6"	""	"android.database.cts.CursorWindowTest"	"testAccessDataValues"	"CtsDatabaseTestCases"	""	"7.3/C-1-6"	"""C-1-6] MUST report the event time in nanoseconds as defined in the Android SDK documentation, representing the time the event happened and synchronized with the SystemClock.elapsedRealtimeNano() clock.  | C-1-6] MUST set a non-zero resolution for all sensors, and report the value via the Sensor.getResolution() API method. Some sensor types are composite, meaning they can be derived from data provided by one or more other sensors. (Examples include the orientation sensor and the linear acceleration sensor.) Device implementations: SHOULD implement these sensor types, when they include the prerequisite physical sensors as described in sensor types. If device implementations include a composite sensor, they: """	""	"re_tag:(?<!/)C\-1\-6 7.3/C-1-6 7.3"	""	""	""	"7.3"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/database/src/android/database/cts/CursorWindowTest.java"	""	"public void testAccessDataValues() {         final long NUMBER_LONG_INTEGER = (long) 0xaabbccddffL;         final long NUMBER_INTEGER = (int) NUMBER_LONG_INTEGER;         final long NUMBER_SHORT = (short) NUMBER_INTEGER;         final float NUMBER_FLOAT_SCIENCE = 7.332952E11f;         final double NUMBER_DOUBLE_SCIENCE = 7.33295205887E11;         final String NUMBER_FLOAT_SCIENCE_STRING = ""7.332952E11"";         final String NUMBER_DOUBLE_SCIENCE_STRING = ""7.33295205887E11"";         final String NUMBER_FLOAT_SCIENCE_STRING2 = ""7.33295e+11"";          byte[] originalBlob = new byte[Byte.MAX_VALUE];         for (int i = 0; i < Byte.MAX_VALUE; i++) {             originalBlob[i] = (byte) i;         }          CursorWindow cursorWindow = new CursorWindow(true);         cursorWindow.setNumColumns(5);         cursorWindow.allocRow();          // Test putString, getString, getLong, getInt, isBlob         assertTrue(cursorWindow.putString(Long.toString(NUMBER_LONG_INTEGER), 0, 0));         assertEquals(Long.toString(NUMBER_LONG_INTEGER), cursorWindow.getString(0, 0));         assertEquals(NUMBER_LONG_INTEGER, cursorWindow.getLong(0, 0));         assertEquals(NUMBER_INTEGER, cursorWindow.getInt(0, 0));         assertEquals(NUMBER_SHORT, cursorWindow.getShort(0, 0));         // Converting of Float, there would be some little precision differences. So just compare         // first 6 digits.         assertEquals(NUMBER_FLOAT_SCIENCE_STRING.substring(0, 6), Float.toString(                 cursorWindow.getFloat(0, 0)).substring(0, 6));         assertEquals(NUMBER_DOUBLE_SCIENCE_STRING, Double.toString(cursorWindow.getDouble(0, 0)));         assertFalse(cursorWindow.isNull(0, 0));         assertFalse(cursorWindow.isBlob(0, 0));          // Test null String         assertTrue(cursorWindow.putString("""", 0, 0));         assertEquals("""", cursorWindow.getString(0, 0));         assertEquals(0, cursorWindow.getLong(0, 0));         assertEquals(0, cursorWindow.getInt(0, 0));         assertEquals(0, cursorWindow.getShort(0, 0));         assertEquals(0.0, cursorWindow.getDouble(0, 0), 0.0);         assertEquals(0.0f, cursorWindow.getFloat(0, 0), 0.0);         assertFalse(cursorWindow.isNull(0, 0));         assertFalse(cursorWindow.isBlob(0, 0));          // Test putNull, getString, getLong, getDouble, getBlob, getInd, getShort, getFloat,         // isBlob.         assertTrue(cursorWindow.putNull(0, 1));         assertNull(cursorWindow.getString(0, 1));         assertEquals(0, cursorWindow.getLong(0, 1));         assertEquals(0, cursorWindow.getInt(0, 1));         assertEquals(0, cursorWindow.getShort(0, 1));         assertEquals(0.0, cursorWindow.getDouble(0, 1), 0.0);         assertEquals(0.0f, cursorWindow.getFloat(0, 1), 0.0);         assertNull(cursorWindow.getBlob(0, 1));         assertTrue(cursorWindow.isNull(0, 1));         // If the field is null, isBlob will return true.         assertTrue(cursorWindow.isBlob(0, 1));          // Test putLong, getLong, getInt, getString , getShort, getFloat, getDouble, isBlob.         assertTrue(cursorWindow.putLong(NUMBER_LONG_INTEGER, 0, 2));         assertEquals(NUMBER_LONG_INTEGER, cursorWindow.getLong(0, 2));         assertEquals(NUMBER_INTEGER, cursorWindow.getInt(0, 2));         assertEquals(Long.toString(NUMBER_LONG_INTEGER), cursorWindow.getString(0, 2));         assertEquals(NUMBER_SHORT, cursorWindow.getShort(0, 2));         assertEquals(NUMBER_FLOAT_SCIENCE, cursorWindow.getFloat(0, 2), 0.0);         assertEquals(NUMBER_DOUBLE_SCIENCE, cursorWindow.getDouble(0, 2), 0.0);         try {             cursorWindow.getBlob(0, 2);             fail(""Can't get Blob from a Integer value."");         } catch (SQLiteException e) {             // expected         }         assertFalse(cursorWindow.isNull(0, 2));         assertFalse(cursorWindow.isBlob(0, 2));          // Test putDouble         assertTrue(cursorWindow.putDouble(NUMBER_DOUBLE_SCIENCE, 0, 3));         assertEquals(NUMBER_LONG_INTEGER, cursorWindow.getLong(0, 3));         assertEquals(NUMBER_INTEGER, cursorWindow.getInt(0, 3));         // Converting from Double to String, there would be some little precision differences. So         // Just compare first 6 digits.         assertEquals(NUMBER_FLOAT_SCIENCE_STRING2.substring(0, 6), cursorWindow.getString(0, 3)                 .substring(0, 6));         assertEquals(NUMBER_SHORT, cursorWindow.getShort(0, 3));         assertEquals(NUMBER_FLOAT_SCIENCE, cursorWindow.getFloat(0, 3), 0.0);         assertEquals(NUMBER_DOUBLE_SCIENCE, cursorWindow.getDouble(0, 3), 0.0);         try {             cursorWindow.getBlob(0, 3);             fail(""Can't get Blob from a Double value."");         } catch (SQLiteException e) {             // expected         }         assertFalse(cursorWindow.isNull(0, 3));         assertFalse(cursorWindow.isBlob(0, 3));          // Test putBlob         assertTrue(cursorWindow.putBlob(originalBlob, 0, 4));         byte[] targetBlob = cursorWindow.getBlob(0, 4);         assertTrue(Arrays.equals(originalBlob, targetBlob));         assertFalse(cursorWindow.isNull(0, 4));         // Test isBlob         assertTrue(cursorWindow.isBlob(0, 4));     }"	""	""	""	""	""
"174:551285) 7.3  . Sensors"	"7.3"	"C-1-6"	""	"android.location.cts.gnss.GnssPseudorangeVerificationTest"	"testPseudorangeValue"	"CtsLocationGnssTestCases"	""	"7.3/C-1-6"	"""C-1-6] MUST report the event time in nanoseconds as defined in the Android SDK documentation, representing the time the event happened and synchronized with the SystemClock.elapsedRealtimeNano() clock.  | C-1-6] MUST set a non-zero resolution for all sensors, and report the value via the Sensor.getResolution() API method. Some sensor types are composite, meaning they can be derived from data provided by one or more other sensors. (Examples include the orientation sensor and the linear acceleration sensor.) Device implementations: SHOULD implement these sensor types, when they include the prerequisite physical sensors as described in sensor types. If device implementations include a composite sensor, they: """	""	"re_tag:(?<!/)C\-1\-6 7.3/C-1-6 7.3"	""	""	""	"7.3"	""	""	""	"/home/gpoor/cts-source/cts/tests/location/location_gnss/src/android/location/cts/gnss/GnssPseudorangeVerificationTest.java"	""	"public void testPseudorangeValue() throws Exception {     // Checks if Gnss hardware feature is present, skips test (pass) if not     if (!TestMeasurementUtil.canTestRunOnCurrentDevice(Build.VERSION_CODES.N,           mTestLocationManager,           TAG)) {       return;     }      if (TestMeasurementUtil.isAutomotiveDevice(getContext())) {         Log.i(TAG, ""Test is being skipped because the system has the AUTOMOTIVE feature."");         return;     }      mLocationListener = new TestLocationListener(LOCATION_TO_COLLECT_COUNT);     mTestLocationManager.requestLocationUpdates(mLocationListener);      mMeasurementListener = new TestGnssMeasurementListener(TAG,                                                 MEASUREMENT_EVENTS_TO_COLLECT_COUNT, true);     mTestLocationManager.registerGnssMeasurementCallback(mMeasurementListener);      boolean success = mLocationListener.await();     success &= mMeasurementListener.await();     SoftAssert softAssert = new SoftAssert(TAG);     softAssert.assertTrue(         ""Time elapsed without getting enough location fixes.""             + "" Possibly, the test has been run deep indoors.""             + "" Consider retrying test outdoors."",         success);      Log.i(TAG, ""Location status received = "" + mLocationListener.isLocationReceived());      if (!mMeasurementListener.verifyStatus()) {       // If verifyStatus returns false, an assert exception happens and test fails.       return; // exit (with pass)     }      List<GnssMeasurementsEvent> events = mMeasurementListener.getEvents();     int eventCount = events.size();     Log.i(TAG, ""Number of GNSS measurement events received = "" + eventCount);     softAssert.assertTrue(         ""GnssMeasurementEvent count: expected > 0, received = "" + eventCount,         eventCount > 0);      boolean hasEventWithEnoughMeasurements = false;     // we received events, so perform a quick sanity check on mandatory fields     for (GnssMeasurementsEvent event : events) {       // Verify Gnss Event mandatory fields are in required ranges       assertNotNull(""GnssMeasurementEvent cannot be null."", event);        long timeInNs = event.getClock().getTimeNanos();       TestMeasurementUtil.assertGnssClockFields(event.getClock(), softAssert, timeInNs);        ArrayList<GnssMeasurement> filteredMeasurements = filterMeasurements(event.getMeasurements());       HashMap<Integer, ArrayList<GnssMeasurement>> measurementConstellationMap =           groupByConstellation(filteredMeasurements);       for (ArrayList<GnssMeasurement> measurements : measurementConstellationMap.values()) {         validatePseudorange(measurements, softAssert, timeInNs);       }        // we need at least 4 satellites to calculate the pseudorange       if(event.getMeasurements().size() >= MIN_SATELLITES_REQUIREMENT) {         hasEventWithEnoughMeasurements = true;       }     }      softAssert.assertTrue(         ""Should have at least one GnssMeasurementEvent with at least 4""             + ""GnssMeasurement. If failed, retry near window or outdoors?"",         hasEventWithEnoughMeasurements);      softAssert.assertAll();   }    private HashMap<Integer, ArrayList<GnssMeasurement>> groupByConstellation(       Collection<GnssMeasurement> measurements) {     HashMap<Integer, ArrayList<GnssMeasurement>> measurementConstellationMap = new HashMap<>();     for (GnssMeasurement measurement: measurements){       int constellationType = measurement.getConstellationType();       if (!measurementConstellationMap.containsKey(constellationType)) {         measurementConstellationMap.put(constellationType, new ArrayList<>());       }       measurementConstellationMap.get(constellationType).add(measurement);     }     return measurementConstellationMap;   }      private static ArrayList<GnssMeasurement> filterMeasurements(             Collection<GnssMeasurement> measurements) {         ArrayList<GnssMeasurement> filteredMeasurement = new ArrayList<>();         for (GnssMeasurement measurement : measurements) {             int constellationType = measurement.getConstellationType();             if ((measurement.getState() & GnssMeasurement.STATE_CODE_LOCK) == 0) {                 continue;             }             if (constellationType == GnssStatus.CONSTELLATION_GLONASS) {                 if ((measurement.getState()                         & (GnssMeasurement.STATE_GLO_TOD_DECODED                         | GnssMeasurement.STATE_GLO_TOD_KNOWN)) != 0) {                     filteredMeasurement.add(measurement);                 }             } else if ((measurement.getState() & (GnssMeasurement.STATE_TOW_DECODED                     | GnssMeasurement.STATE_TOW_KNOWN)) != 0) {                 filteredMeasurement.add(measurement);             }         }         return filteredMeasurement;     }    /**    * Uses the common reception time approach to calculate pseudorange time    * measurements reported by the receiver according to http://cdn.intechopen.com/pdfs-wm/27712.pdf.    */   private void validatePseudorange(Collection<GnssMeasurement> measurements,       SoftAssert softAssert, long timeInNs) {     long largestReceivedSvTimeNanosTod = 0;     // closest satellite has largest time (closest to now), as of nano secs of the day     // so the largestReceivedSvTimeNanosTod will be the svTime we got from one of the GPS/GLONASS sv     for(GnssMeasurement measurement : measurements) {       long receivedSvTimeNanosTod =  measurement.getReceivedSvTimeNanos()                                         % TimeUnit.DAYS.toNanos(1);       if (largestReceivedSvTimeNanosTod < receivedSvTimeNanosTod) {         largestReceivedSvTimeNanosTod = receivedSvTimeNanosTod;       }     }     for (GnssMeasurement measurement : measurements) {       double threshold = PSEUDORANGE_THRESHOLD_IN_SEC;       int constellationType = measurement.getConstellationType();       // BEIDOU and QZSS's Orbit are higher, so the value of ReceivedSvTimeNanos should be small       if (constellationType == GnssStatus.CONSTELLATION_BEIDOU           || constellationType == GnssStatus.CONSTELLATION_QZSS) {         threshold = PSEUDORANGE_THRESHOLD_BEIDOU_QZSS_IN_SEC;       }       double deltaiNanos = largestReceivedSvTimeNanosTod                           - (measurement.getReceivedSvTimeNanos() % TimeUnit.DAYS.toNanos(1));       double deltaiSeconds = deltaiNanos * SECONDS_PER_NANO;        softAssert.assertTrue(""deltaiSeconds in Seconds."",           timeInNs,           ""0.0 <= deltaiSeconds <= "" + String.valueOf(threshold),           String.valueOf(deltaiSeconds),           (deltaiSeconds >= 0.0 && deltaiSeconds <= threshold));     }   }      /*      * Use pseudorange calculation library to calculate position then compare to location from      * Location Manager.      */     @CddTest(requirement = ""7.3.3"")     @AppModeFull(reason = ""Flaky in instant mode"")     @RequiresDevice  // emulated devices do not support real measurements so far."	""	""	""	""	""
"174:551285) 7.3  . Sensors"	"7.3"	"C-1-6"	""	"android.hardware.cts.SensorSupportTest"	"testSupportsAccelerometer"	"CtsSensorTestCases"	""	"7.3/C-1-6"	"""C-1-6] MUST report the event time in nanoseconds as defined in the Android SDK documentation, representing the time the event happened and synchronized with the SystemClock.elapsedRealtimeNano() clock.  | C-1-6] MUST set a non-zero resolution for all sensors, and report the value via the Sensor.getResolution() API method. Some sensor types are composite, meaning they can be derived from data provided by one or more other sensors. (Examples include the orientation sensor and the linear acceleration sensor.) Device implementations: SHOULD implement these sensor types, when they include the prerequisite physical sensors as described in sensor types. If device implementations include a composite sensor, they: """	""	"re_tag:(?<!/)C\-1\-6 7.3/C-1-6 7.3"	""	""	""	"7.3"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorSupportTest.java"	""	"public void testSupportsAccelerometer() {         checkHifiVrSensorSupport(Sensor.TYPE_ACCELEROMETER);     }      @CddTest(requirement=""7.3.9/C-2-2"")"	""	""	""	""	""
"174:551285) 7.3  . Sensors"	"7.3"	"C-1-6"	""	"android.hardware.cts.SensorSupportTest"	"testSupportsAccelerometerUncalibrated"	"CtsSensorTestCases"	""	"7.3/C-1-6"	"""C-1-6] MUST report the event time in nanoseconds as defined in the Android SDK documentation, representing the time the event happened and synchronized with the SystemClock.elapsedRealtimeNano() clock.  | C-1-6] MUST set a non-zero resolution for all sensors, and report the value via the Sensor.getResolution() API method. Some sensor types are composite, meaning they can be derived from data provided by one or more other sensors. (Examples include the orientation sensor and the linear acceleration sensor.) Device implementations: SHOULD implement these sensor types, when they include the prerequisite physical sensors as described in sensor types. If device implementations include a composite sensor, they: """	""	"re_tag:(?<!/)C\-1\-6 7.3/C-1-6 7.3"	""	""	""	"7.3"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorSupportTest.java"	""	"public void testSupportsAccelerometerUncalibrated() {         // Uncalibrated accelerometer was not required before Android O         if (PropertyUtil.getFirstApiLevel() >= Build.VERSION_CODES.O) {             checkHifiVrSensorSupport(Sensor.TYPE_ACCELEROMETER_UNCALIBRATED);         }     }      @CddTest(requirement=""7.3.9/C-2-3"")"	""	""	""	""	""
"174:551285) 7.3  . Sensors"	"7.3"	"C-1-6"	""	"android.hardware.cts.SensorSupportTest"	"testSupportsGyroscope"	"CtsSensorTestCases"	""	"7.3/C-1-6"	"""C-1-6] MUST report the event time in nanoseconds as defined in the Android SDK documentation, representing the time the event happened and synchronized with the SystemClock.elapsedRealtimeNano() clock.  | C-1-6] MUST set a non-zero resolution for all sensors, and report the value via the Sensor.getResolution() API method. Some sensor types are composite, meaning they can be derived from data provided by one or more other sensors. (Examples include the orientation sensor and the linear acceleration sensor.) Device implementations: SHOULD implement these sensor types, when they include the prerequisite physical sensors as described in sensor types. If device implementations include a composite sensor, they: """	""	"re_tag:(?<!/)C\-1\-6 7.3/C-1-6 7.3"	""	""	""	"7.3"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorSupportTest.java"	""	"public void testSupportsGyroscope() {         checkHifiVrSensorSupport(Sensor.TYPE_GYROSCOPE);     }      @CddTest(requirement=""7.3.9/C-2-4"")"	""	""	""	""	""
"174:551285) 7.3  . Sensors"	"7.3"	"C-1-6"	""	"android.hardware.cts.SensorSupportTest"	"testSupportsGyroscopeUncalibrated"	"CtsSensorTestCases"	""	"7.3/C-1-6"	"""C-1-6] MUST report the event time in nanoseconds as defined in the Android SDK documentation, representing the time the event happened and synchronized with the SystemClock.elapsedRealtimeNano() clock.  | C-1-6] MUST set a non-zero resolution for all sensors, and report the value via the Sensor.getResolution() API method. Some sensor types are composite, meaning they can be derived from data provided by one or more other sensors. (Examples include the orientation sensor and the linear acceleration sensor.) Device implementations: SHOULD implement these sensor types, when they include the prerequisite physical sensors as described in sensor types. If device implementations include a composite sensor, they: """	""	"re_tag:(?<!/)C\-1\-6 7.3/C-1-6 7.3"	""	""	""	"7.3"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorSupportTest.java"	""	"public void testSupportsGyroscopeUncalibrated() {         checkHifiVrSensorSupport(Sensor.TYPE_GYROSCOPE_UNCALIBRATED);     }      @CddTest(requirement=""7.3.9/C-2-5"")"	""	""	""	""	""
"174:551285) 7.3  . Sensors"	"7.3"	"C-1-6"	""	"android.hardware.cts.SensorSupportTest"	"testSupportsGeoMagneticField"	"CtsSensorTestCases"	""	"7.3/C-1-6"	"""C-1-6] MUST report the event time in nanoseconds as defined in the Android SDK documentation, representing the time the event happened and synchronized with the SystemClock.elapsedRealtimeNano() clock.  | C-1-6] MUST set a non-zero resolution for all sensors, and report the value via the Sensor.getResolution() API method. Some sensor types are composite, meaning they can be derived from data provided by one or more other sensors. (Examples include the orientation sensor and the linear acceleration sensor.) Device implementations: SHOULD implement these sensor types, when they include the prerequisite physical sensors as described in sensor types. If device implementations include a composite sensor, they: """	""	"re_tag:(?<!/)C\-1\-6 7.3/C-1-6 7.3"	""	""	""	"7.3"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorSupportTest.java"	""	"public void testSupportsGeoMagneticField() {         checkHifiVrSensorSupport(Sensor.TYPE_MAGNETIC_FIELD);     }      @CddTest(requirement=""7.3.9/C-2-6"")"	""	""	""	""	""
"174:551285) 7.3  . Sensors"	"7.3"	"C-1-6"	""	"android.hardware.cts.SensorSupportTest"	"testSupportsMagneticFieldUncalibrated"	"CtsSensorTestCases"	""	"7.3/C-1-6"	"""C-1-6] MUST report the event time in nanoseconds as defined in the Android SDK documentation, representing the time the event happened and synchronized with the SystemClock.elapsedRealtimeNano() clock.  | C-1-6] MUST set a non-zero resolution for all sensors, and report the value via the Sensor.getResolution() API method. Some sensor types are composite, meaning they can be derived from data provided by one or more other sensors. (Examples include the orientation sensor and the linear acceleration sensor.) Device implementations: SHOULD implement these sensor types, when they include the prerequisite physical sensors as described in sensor types. If device implementations include a composite sensor, they: """	""	"re_tag:(?<!/)C\-1\-6 7.3/C-1-6 7.3"	""	""	""	"7.3"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorSupportTest.java"	""	"public void testSupportsMagneticFieldUncalibrated() {         checkHifiVrSensorSupport(Sensor.TYPE_MAGNETIC_FIELD_UNCALIBRATED);     }      @CddTest(requirement=""7.3.9/C-2-7"")"	""	""	""	""	""
"174:551285) 7.3  . Sensors"	"7.3"	"C-1-6"	""	"android.hardware.cts.SensorSupportTest"	"testSupportsPressure"	"CtsSensorTestCases"	""	"7.3/C-1-6"	"""C-1-6] MUST report the event time in nanoseconds as defined in the Android SDK documentation, representing the time the event happened and synchronized with the SystemClock.elapsedRealtimeNano() clock.  | C-1-6] MUST set a non-zero resolution for all sensors, and report the value via the Sensor.getResolution() API method. Some sensor types are composite, meaning they can be derived from data provided by one or more other sensors. (Examples include the orientation sensor and the linear acceleration sensor.) Device implementations: SHOULD implement these sensor types, when they include the prerequisite physical sensors as described in sensor types. If device implementations include a composite sensor, they: """	""	"re_tag:(?<!/)C\-1\-6 7.3/C-1-6 7.3"	""	""	""	"7.3"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorSupportTest.java"	""	"public void testSupportsPressure() {         checkHifiVrSensorSupport(Sensor.TYPE_PRESSURE);     }      @CddTest(requirement=""7.3.9/C-2-8"")"	""	""	""	""	""
"174:551285) 7.3  . Sensors"	"7.3"	"C-1-6"	""	"android.hardware.cts.SensorSupportTest"	"testSupportsGameRotationVector"	"CtsSensorTestCases"	""	"7.3/C-1-6"	"""C-1-6] MUST report the event time in nanoseconds as defined in the Android SDK documentation, representing the time the event happened and synchronized with the SystemClock.elapsedRealtimeNano() clock.  | C-1-6] MUST set a non-zero resolution for all sensors, and report the value via the Sensor.getResolution() API method. Some sensor types are composite, meaning they can be derived from data provided by one or more other sensors. (Examples include the orientation sensor and the linear acceleration sensor.) Device implementations: SHOULD implement these sensor types, when they include the prerequisite physical sensors as described in sensor types. If device implementations include a composite sensor, they: """	""	"re_tag:(?<!/)C\-1\-6 7.3/C-1-6 7.3"	""	""	""	"7.3"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorSupportTest.java"	""	"public void testSupportsGameRotationVector() {         checkHifiVrSensorSupport(Sensor.TYPE_GAME_ROTATION_VECTOR);     }      @CddTest(requirement=""7.3.9/C-2-9"")"	""	""	""	""	""
"174:551285) 7.3  . Sensors"	"7.3"	"C-1-6"	""	"android.hardware.cts.SensorSupportTest"	"testSupportsSignificantMotion"	"CtsSensorTestCases"	""	"7.3/C-1-6"	"""C-1-6] MUST report the event time in nanoseconds as defined in the Android SDK documentation, representing the time the event happened and synchronized with the SystemClock.elapsedRealtimeNano() clock.  | C-1-6] MUST set a non-zero resolution for all sensors, and report the value via the Sensor.getResolution() API method. Some sensor types are composite, meaning they can be derived from data provided by one or more other sensors. (Examples include the orientation sensor and the linear acceleration sensor.) Device implementations: SHOULD implement these sensor types, when they include the prerequisite physical sensors as described in sensor types. If device implementations include a composite sensor, they: """	""	"re_tag:(?<!/)C\-1\-6 7.3/C-1-6 7.3"	""	""	""	"7.3"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorSupportTest.java"	""	"public void testSupportsSignificantMotion() {         checkHifiVrSensorSupport(Sensor.TYPE_SIGNIFICANT_MOTION);     }      @CddTest(requirement=""7.3.9/C-2-10"")"	""	""	""	""	""
"174:551285) 7.3  . Sensors"	"7.3"	"C-1-6"	""	"android.hardware.cts.SensorSupportTest"	"testSupportsStepDetector"	"CtsSensorTestCases"	""	"7.3/C-1-6"	"""C-1-6] MUST report the event time in nanoseconds as defined in the Android SDK documentation, representing the time the event happened and synchronized with the SystemClock.elapsedRealtimeNano() clock.  | C-1-6] MUST set a non-zero resolution for all sensors, and report the value via the Sensor.getResolution() API method. Some sensor types are composite, meaning they can be derived from data provided by one or more other sensors. (Examples include the orientation sensor and the linear acceleration sensor.) Device implementations: SHOULD implement these sensor types, when they include the prerequisite physical sensors as described in sensor types. If device implementations include a composite sensor, they: """	""	"re_tag:(?<!/)C\-1\-6 7.3/C-1-6 7.3"	""	""	""	"7.3"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorSupportTest.java"	""	"public void testSupportsStepDetector() {         checkHifiVrSensorSupport(Sensor.TYPE_STEP_DETECTOR);     }      @CddTest(requirement=""7.3.9/C-2-11"")"	""	""	""	""	""
"174:551285) 7.3  . Sensors"	"7.3"	"C-1-6"	""	"android.hardware.cts.SensorSupportTest"	"testSupportsStepCounter"	"CtsSensorTestCases"	""	"7.3/C-1-6"	"""C-1-6] MUST report the event time in nanoseconds as defined in the Android SDK documentation, representing the time the event happened and synchronized with the SystemClock.elapsedRealtimeNano() clock.  | C-1-6] MUST set a non-zero resolution for all sensors, and report the value via the Sensor.getResolution() API method. Some sensor types are composite, meaning they can be derived from data provided by one or more other sensors. (Examples include the orientation sensor and the linear acceleration sensor.) Device implementations: SHOULD implement these sensor types, when they include the prerequisite physical sensors as described in sensor types. If device implementations include a composite sensor, they: """	""	"re_tag:(?<!/)C\-1\-6 7.3/C-1-6 7.3"	""	""	""	"7.3"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorSupportTest.java"	""	"public void testSupportsStepCounter() {         checkHifiVrSensorSupport(Sensor.TYPE_STEP_COUNTER);     }      @CddTest(requirement=""7.3.9/C-2-12"")"	""	""	""	""	""
"174:551285) 7.3  . Sensors"	"7.3"	"C-1-6"	""	"android.hardware.cts.SensorSupportTest"	"testSupportsTiltDetector"	"CtsSensorTestCases"	""	"7.3/C-1-6"	"""C-1-6] MUST report the event time in nanoseconds as defined in the Android SDK documentation, representing the time the event happened and synchronized with the SystemClock.elapsedRealtimeNano() clock.  | C-1-6] MUST set a non-zero resolution for all sensors, and report the value via the Sensor.getResolution() API method. Some sensor types are composite, meaning they can be derived from data provided by one or more other sensors. (Examples include the orientation sensor and the linear acceleration sensor.) Device implementations: SHOULD implement these sensor types, when they include the prerequisite physical sensors as described in sensor types. If device implementations include a composite sensor, they: """	""	"re_tag:(?<!/)C\-1\-6 7.3/C-1-6 7.3"	""	""	""	"7.3"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorSupportTest.java"	""	"public void testSupportsTiltDetector() {         final int TYPE_TILT_DETECTOR = 22;         checkHifiVrSensorSupport(TYPE_TILT_DETECTOR);     }      @CddTest(requirement=""7.3.1/C-3-1"")"	""	""	""	""	""
"174:551285) 7.3  . Sensors"	"7.3"	"C-1-6"	""	"android.hardware.cts.SensorSupportTest"	"testSupportsGravityAndLinearAccelIfHasAG"	"CtsSensorTestCases"	""	"7.3/C-1-6"	"""C-1-6] MUST report the event time in nanoseconds as defined in the Android SDK documentation, representing the time the event happened and synchronized with the SystemClock.elapsedRealtimeNano() clock.  | C-1-6] MUST set a non-zero resolution for all sensors, and report the value via the Sensor.getResolution() API method. Some sensor types are composite, meaning they can be derived from data provided by one or more other sensors. (Examples include the orientation sensor and the linear acceleration sensor.) Device implementations: SHOULD implement these sensor types, when they include the prerequisite physical sensors as described in sensor types. If device implementations include a composite sensor, they: """	""	"re_tag:(?<!/)C\-1\-6 7.3/C-1-6 7.3"	""	""	""	"7.3"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorSupportTest.java"	""	"public void testSupportsGravityAndLinearAccelIfHasAG() {         if (mHasAccel && mHasGyro) {             assertTrue(hasSensorType(Sensor.TYPE_GRAVITY));             assertTrue(hasSensorType(Sensor.TYPE_LINEAR_ACCELERATION));         }     }      @CddTest(requirement=""7.3.1/C-4-1"")"	""	""	""	""	""
"174:551285) 7.3  . Sensors"	"7.3"	"C-1-6"	""	"android.hardware.cts.helpers.sensorverification.InitialValueVerificationTest"	"testVerify"	"CtsSensorTestCases"	""	"7.3/C-1-6"	"""C-1-6] MUST report the event time in nanoseconds as defined in the Android SDK documentation, representing the time the event happened and synchronized with the SystemClock.elapsedRealtimeNano() clock.  | C-1-6] MUST set a non-zero resolution for all sensors, and report the value via the Sensor.getResolution() API method. Some sensor types are composite, meaning they can be derived from data provided by one or more other sensors. (Examples include the orientation sensor and the linear acceleration sensor.) Device implementations: SHOULD implement these sensor types, when they include the prerequisite physical sensors as described in sensor types. If device implementations include a composite sensor, they: """	""	"re_tag:(?<!/)C\-1\-6 7.3/C-1-6 7.3"	""	""	""	"7.3"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/helpers/sensorverification/InitialValueVerificationTest.java"	""	"public void testVerify() {         float[] initialValues = new float[] {80.4f, 12.3f, -67f};         verifyStatsWithTwoWindows(initialValues, initialValues, true);          // Only modify the first element in the array but close enough         float[] laterValues = new float[] {78.1f, 12.3f, -67f};         verifyStatsWithTwoWindows(initialValues, laterValues, true);         // Only modify the first element in the array but by more than the MAX_ABSOLUTE_DELTA         laterValues = new float[] {70.1f, 12.3f, -67f};         verifyStatsWithTwoWindows(initialValues, laterValues, false);          // Only modify the second element in the array but close enough         laterValues = new float[] {80.4f, 11.3f, -67f};         verifyStatsWithTwoWindows(initialValues, laterValues, true);         // Only modify the second element in the array but by more than the MAX_ABSOLUTE_DELTA         laterValues = new float[] {80.4f, 7.3f, -67f};         verifyStatsWithTwoWindows(initialValues, laterValues, false);          // Only modify the third element in the array but close enough         laterValues = new float[] {80.4f, 12.3f, -65f};         verifyStatsWithTwoWindows(initialValues, laterValues, true);         // Only modify the third element in the array but by more than the MAX_ABSOLUTE_DELTA         laterValues = new float[] {80.4f, 12.3f, 45f};         verifyStatsWithTwoWindows(initialValues, laterValues, false);     }      private static InitialValueVerification getVerification(Collection<TestSensorEvent> events,             float maxAbsoluteDelta, long initialWindowLength) {         InitialValueVerification verification =                 new InitialValueVerification(maxAbsoluteDelta, initialWindowLength);         verification.addSensorEvents(events);         return verification;     }      private static void verifyStatsWithTwoWindows(float[] initialValues, float[] laterValues,             boolean pass) {         List<TestSensorEvent> events = new ArrayList<>();         // Initial window         for (long timestamp = 0L; timestamp <= INITIAL_WINDOW_LENGTH; timestamp += SENSOR_PERIOD) {             float[] initialValuesWithNoise = addNoise(initialValues);             events.add(new TestSensorEvent(null /* sensor */, timestamp, 0 /* accuracy */,                     initialValuesWithNoise));         }         // Later window         for (long timestamp = INITIAL_WINDOW_LENGTH                 + SENSOR_PERIOD; timestamp <= TOTAL_WINDOW_LENGTH; timestamp += SENSOR_PERIOD) {             float[] laterValuesWithNoise = addNoise(laterValues);             events.add(new TestSensorEvent(null /* sensor */, timestamp, 0 /* accuracy */,                     laterValuesWithNoise));         }         SensorStats stats = new SensorStats();         InitialValueVerification verification =                 getVerification(events, MAX_ABSOLUTE_DELTA, INITIAL_WINDOW_LENGTH);          try {             verification.verify(stats);             assertTrue(pass);         } catch (AssertionError e) {             assertFalse(pass);         }         verifyStats(stats, pass, initialValues, laterValues);     }      private static float[] addNoise(float[] values) {         float[] valuesWithNoise = new float[values.length];         for(int i = 0; i < values.length; i++) {             valuesWithNoise[i] = values[i] + random.nextFloat() * NOISE_STD;         }         return valuesWithNoise;     }      private static void verifyStats(SensorStats stats, boolean passed, float[] initialMeans,             float[] laterMeans) {         assertEquals(passed, stats.getValue(InitialValueVerification.PASSED_KEY));         float[] actualInitialMeans = (float[]) stats.getValue(SensorStats.INITIAL_MEAN_KEY);         float[] actualLaterMeans = (float[]) stats.getValue(SensorStats.LATER_MEAN_KEY);         assertEquals(initialMeans.length, actualInitialMeans.length);         assertEquals(laterMeans.length, actualLaterMeans.length);         for (int i = 0; i < initialMeans.length; i++) {             assertEquals(initialMeans[i], actualInitialMeans[i], 0.1);             assertEquals(laterMeans[i], actualLaterMeans[i], 0.1);         }     } }"	""	""	""	""	""
"174:551285) 7.3  . Sensors"	"7.3"	"C-1-6"	""	"android.telephony.cts.CellInfoTest"	"testCellInfo"	"CtsTelephonyTestCases"	""	"7.3/C-1-6"	"""C-1-6] MUST report the event time in nanoseconds as defined in the Android SDK documentation, representing the time the event happened and synchronized with the SystemClock.elapsedRealtimeNano() clock.  | C-1-6] MUST set a non-zero resolution for all sensors, and report the value via the Sensor.getResolution() API method. Some sensor types are composite, meaning they can be derived from data provided by one or more other sensors. (Examples include the orientation sensor and the linear acceleration sensor.) Device implementations: SHOULD implement these sensor types, when they include the prerequisite physical sensors as described in sensor types. If device implementations include a composite sensor, they: """	""	"re_tag:(?<!/)C\-1\-6 7.3/C-1-6 7.3"	""	""	""	"7.3"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/telephony/current/src/android/telephony/cts/CellInfoTest.java"	""	"public void testCellInfo() throws Throwable {         if(!(mPm.hasSystemFeature(PackageManager.FEATURE_TELEPHONY))) {             Log.d(TAG, ""Skipping test that requires FEATURE_TELEPHONY"");             return;         }          if (!isCamped()) fail(""Device is not camped to a cell"");          // Make a blocking call to requestCellInfoUpdate for results (for simplicity of test).         CellInfoResultsCallback resultsCallback = new CellInfoResultsCallback();         mTm.requestCellInfoUpdate(mSimpleExecutor, resultsCallback);         resultsCallback.wait(MAX_CELLINFO_WAIT_MILLIS);         List<CellInfo> allCellInfo = resultsCallback.cellInfo;          assertNotNull(""TelephonyManager.getAllCellInfo() returned NULL!"", allCellInfo);         assertTrue(""TelephonyManager.getAllCellInfo() returned zero-length list!"",             allCellInfo.size() > 0);          int numRegisteredCells = 0;         for (CellInfo cellInfo : allCellInfo) {             if (cellInfo.isRegistered()) {                 ++numRegisteredCells;             }             verifyBaseCellInfo(cellInfo);             verifyBaseCellIdentity(cellInfo.getCellIdentity(), cellInfo.isRegistered());             if (cellInfo instanceof CellInfoLte) {                 verifyLteInfo((CellInfoLte) cellInfo);             } else if (cellInfo instanceof CellInfoWcdma) {                 verifyWcdmaInfo((CellInfoWcdma) cellInfo);             } else if (cellInfo instanceof CellInfoGsm) {                 verifyGsmInfo((CellInfoGsm) cellInfo);             } else if (cellInfo instanceof CellInfoCdma) {                 verifyCdmaInfo((CellInfoCdma) cellInfo);             } else if (cellInfo instanceof CellInfoTdscdma) {                 verifyTdscdmaInfo((CellInfoTdscdma) cellInfo);             } else if (cellInfo instanceof CellInfoNr) {                 verifyNrInfo((CellInfoNr) cellInfo);             } else {                 fail(""Unknown CellInfo Type reported."");             }         }          //FIXME: The maximum needs to be calculated based on the number of         //       radios and the technologies used (ex SRLTE); however, we have         //       not hit any of these cases yet.         assertTrue(""None or too many registered cells : "" + numRegisteredCells,                 numRegisteredCells > 0 && numRegisteredCells <= 2);     }      private void verifyBaseCellInfo(CellInfo info) {         assertTrue(""Invalid timestamp in CellInfo: "" + info.getTimeStamp(),                 info.getTimeStamp() > 0 && info.getTimeStamp() < Long.MAX_VALUE);          long curTime = SystemClock.elapsedRealtime();         assertTrue(""Invalid timestamp in CellInfo: "" + info.getTimestampMillis(),                 info.getTimestampMillis() > 0 && info.getTimestampMillis() <= curTime);          if (mRadioHalVersion >= RADIO_HAL_VERSION_1_2) {             // In HAL 1.2 or greater, the connection status must be reported             assertTrue(info.getCellConnectionStatus() != CellInfo.CONNECTION_UNKNOWN);         }     }      private void verifyBaseCellIdentity(CellIdentity id, boolean isRegistered) {         if (mRadioHalVersion >= RADIO_HAL_VERSION_1_2) {             if (isRegistered) {                 String alphaLong = (String) id.getOperatorAlphaLong();                 assertNotNull(""getOperatorAlphaLong() returns NULL!"", alphaLong);                  String alphaShort = (String) id.getOperatorAlphaShort();                 assertNotNull(""getOperatorAlphaShort() returns NULL!"", alphaShort);             }         }     }      private void verifyCdmaInfo(CellInfoCdma cdma) {         verifyCellConnectionStatus(cdma.getCellConnectionStatus());         verifyCellInfoCdmaParcelandHashcode(cdma);         verifyCellIdentityCdma(cdma.getCellIdentity(), cdma.isRegistered());         verifyCellIdentityCdmaParcel(cdma.getCellIdentity());         verifyCellSignalStrengthCdma(cdma.getCellSignalStrength());         verifyCellSignalStrengthCdmaParcel(cdma.getCellSignalStrength());     }      private void verifyCellInfoCdmaParcelandHashcode(CellInfoCdma cdma) {         Parcel p = Parcel.obtain();         cdma.writeToParcel(p, 0);         p.setDataPosition(0);          CellInfoCdma newCi = CellInfoCdma.CREATOR.createFromParcel(p);         assertTrue(cdma.equals(newCi));         assertEquals(""hashCode() did not get right hashCode"", cdma.hashCode(), newCi.hashCode());     }      private void verifyCellIdentityCdma(CellIdentityCdma cdma, boolean isRegistered) {         int networkId = cdma.getNetworkId();         assertTrue(""getNetworkId() out of range [0,65535], networkId="" + networkId,                 networkId == Integer.MAX_VALUE || (networkId >= 0 && networkId <= NETWORK_ID));          int systemId = cdma.getSystemId();         assertTrue(""getSystemId() out of range [0,32767], systemId="" + systemId,                 systemId == Integer.MAX_VALUE || (systemId >= 0 && systemId <= SYSTEM_ID));          int basestationId = cdma.getBasestationId();         assertTrue(""getBasestationId() out of range [0,65535], basestationId="" + basestationId,                 basestationId == Integer.MAX_VALUE                         || (basestationId >= 0 && basestationId <= BASESTATION_ID));          int longitude = cdma.getLongitude();         assertTrue(""getLongitude() out of range [-2592000,2592000], longitude="" + longitude,                 longitude == Integer.MAX_VALUE                         || (longitude >= -LONGITUDE && longitude <= LONGITUDE));          int latitude = cdma.getLatitude();         assertTrue(""getLatitude() out of range [-1296000,1296000], latitude="" + latitude,                 latitude == Integer.MAX_VALUE || (latitude >= -LATITUDE && latitude <= LATITUDE));          if (isRegistered) {             assertTrue(""SID is required for registered cells"", systemId != Integer.MAX_VALUE);             assertTrue(""NID is required for registered cells"", networkId != Integer.MAX_VALUE);             assertTrue(""BSID is required for registered cells"", basestationId != Integer.MAX_VALUE);         }          verifyCellIdentityCdmaLocationSanitation(cdma);     }      private void verifyCellIdentityCdmaLocationSanitation(CellIdentityCdma cdma) {         CellIdentityCdma sanitized = cdma.sanitizeLocationInfo();         assertEquals(CellInfo.UNAVAILABLE, sanitized.getNetworkId());         assertEquals(CellInfo.UNAVAILABLE, sanitized.getSystemId());         assertEquals(CellInfo.UNAVAILABLE, sanitized.getBasestationId());         assertEquals(CellInfo.UNAVAILABLE, sanitized.getLongitude());         assertEquals(CellInfo.UNAVAILABLE, sanitized.getLatitude());     }      private void verifyCellIdentityCdmaParcel(CellIdentityCdma cdma) {         Parcel p = Parcel.obtain();         cdma.writeToParcel(p, 0);         p.setDataPosition(0);          CellIdentityCdma newCi = CellIdentityCdma.CREATOR.createFromParcel(p);         assertTrue(cdma.equals(newCi));     }      private void verifyCellSignalStrengthCdma(CellSignalStrengthCdma cdma) {         int level = cdma.getLevel();         assertTrue(""getLevel() out of range [0,4], level="" + level,                 level >= 0 && level <= 4);          int asuLevel = cdma.getAsuLevel();         assertTrue(""getAsuLevel() out of range [0,97] (or 99 is unknown), asuLevel="" + asuLevel,                 asuLevel == 99 || (asuLevel >= 0 && asuLevel <= 97));          int cdmaLevel = cdma.getCdmaLevel();         assertTrue(""getCdmaLevel() out of range [0,4], cdmaLevel="" + cdmaLevel,                 cdmaLevel >= 0 && cdmaLevel <= 4);          int evdoLevel = cdma.getEvdoLevel();         assertTrue(""getEvdoLevel() out of range [0,4], evdoLevel="" + evdoLevel,                 evdoLevel >= 0 && evdoLevel <= 4);          // The following four fields do not have specific limits. So just calling to verify that         // they don't crash the phone.         int cdmaDbm = cdma.getCdmaDbm();         int evdoDbm = cdma.getEvdoDbm();         cdma.getCdmaEcio();         cdma.getEvdoEcio();          int dbm = (cdmaDbm < evdoDbm) ? cdmaDbm : evdoDbm;         assertEquals(""getDbm() did not get correct value"", dbm, cdma.getDbm());          int evdoSnr = cdma.getEvdoSnr();         assertTrue(""getEvdoSnr() out of range [0,8], evdoSnr="" + evdoSnr,                 (evdoSnr == Integer.MAX_VALUE) || (evdoSnr >= 0 && evdoSnr <= 8));     }      private void verifyCellSignalStrengthCdmaParcel(CellSignalStrengthCdma cdma) {         Parcel p = Parcel.obtain();         cdma.writeToParcel(p, 0);         p.setDataPosition(0);          CellSignalStrengthCdma newCss = CellSignalStrengthCdma.CREATOR.createFromParcel(p);         assertEquals(cdma, newCss);     }      private static void verifyPlmnInfo(String mccStr, String mncStr, int mcc, int mnc) {         // If either int value is invalid, all values must be invalid         if (mcc == Integer.MAX_VALUE) {             assertTrue(""MNC and MNC must always be reported together."",                     mnc == Integer.MAX_VALUE && mccStr == null && mncStr == null);             return;         }          assertTrue(""getMcc() out of range [0, 999], mcc="" + mcc, (mcc >= 0 && mcc <= 999));         assertTrue(""getMnc() out of range [0, 999], mnc="" + mnc, (mnc >= 0 && mnc <= 999));         assertTrue(""MCC and MNC Strings must always be reported together."",                 (mccStr == null) == (mncStr == null));          // For legacy compatibility, it's possible to have int values without valid string values         // but not the other way around.         // mccStr is set as NULL if empty, unknown or invalid.         assertTrue(""getMccString() out of range [0, 999], mcc="" + mccStr,                 mccStr == null || mccStr.matches(""^[0-9]{3}$""));         // mccStr must either be null or match mcc integer.         assertTrue(""MccString must match Mcc Integer, str="" + mccStr + "" int="" + mcc,                 mccStr == null || mcc == Integer.parseInt(mccStr));          // mncStr is set as NULL if empty, unknown or invalid.         assertTrue(""getMncString() out of range [0, 999], mnc="" + mncStr,                 mncStr == null || mncStr.matches(""^[0-9]{2,3}$""));         // mncStr must either be null or match mnc integer.         assertTrue(""MncString must match Mnc Integer, str="" + mncStr + "" int="" + mnc,                 mncStr == null || mnc == Integer.parseInt(mncStr));     }      // Verify lte cell information is within correct range.     private void verifyLteInfo(CellInfoLte lte) {         verifyCellConnectionStatus(lte.getCellConnectionStatus());         verifyCellInfoLteParcelandHashcode(lte);         verifyCellIdentityLte(lte.getCellIdentity(), lte.isRegistered());         verifyCellIdentityLteParcel(lte.getCellIdentity());         verifyCellSignalStrengthLte(lte.getCellSignalStrength());         verifyCellSignalStrengthLteParcel(lte.getCellSignalStrength());     }      // Verify NR 5G cell information is within correct range.     private void verifyNrInfo(CellInfoNr nr) {         verifyCellConnectionStatus(nr.getCellConnectionStatus());         verifyCellIdentityNr((CellIdentityNr) nr.getCellIdentity(), nr.isRegistered());         verifyCellIdentityNrParcel((CellIdentityNr) nr.getCellIdentity());         verifyCellSignalStrengthNr((CellSignalStrengthNr) nr.getCellSignalStrength());         verifyCellSignalStrengthNrParcel((CellSignalStrengthNr) nr.getCellSignalStrength());     }      private void verifyCellSignalStrengthNrParcel(CellSignalStrengthNr nr) {         Parcel p = Parcel.obtain();         nr.writeToParcel(p, 0);         p.setDataPosition(0);          CellSignalStrengthNr newCss = CellSignalStrengthNr.CREATOR.createFromParcel(p);         assertEquals(nr, newCss);     }      private void verifyCellIdentityNrParcel(CellIdentityNr nr) {         Parcel p = Parcel.obtain();         nr.writeToParcel(p, 0);         p.setDataPosition(0);          CellIdentityNr newCi = CellIdentityNr.CREATOR.createFromParcel(p);         assertEquals(nr, newCi);     }      private void verifyCellIdentityNr(CellIdentityNr nr, boolean isRegistered) {         // This class was added after numeric mcc/mncs were no longer provided, so it lacks the         // basic getMcc() and getMnc() - Dummy out those checks.         String mccStr = nr.getMccString();         String mncStr = nr.getMncString();         verifyPlmnInfo(mccStr, mncStr,                 mccStr != null ? Integer.parseInt(mccStr) : CellInfo.UNAVAILABLE,                 mncStr != null ? Integer.parseInt(mncStr) : CellInfo.UNAVAILABLE);          int pci = nr.getPci();         assertTrue(""getPci() out of range [0, 1007], pci = "" + pci, 0 <= pci && pci <= 1007);          int tac = nr.getTac();         assertTrue(""getTac() out of range [0, 16777215], tac = "" + tac,             (tac == Integer.MAX_VALUE) || (0 <= tac && tac <= 16777215));          int nrArfcn = nr.getNrarfcn();         assertTrue(""getNrarfcn() out of range [0, 3279165], nrarfcn = "" + nrArfcn,                 0 <= nrArfcn && nrArfcn <= 3279165);          for (String plmnId : nr.getAdditionalPlmns()) {             verifyPlmnId(plmnId);         }          if (mRadioHalVersion >= RADIO_HAL_VERSION_1_5) {             int[] bands = nr.getBands();             for (int band: bands) {                 assertTrue(""getBand out of range [1, 95] or [257, 261], band = "" + band,                         (band >= BAND_FR1_MIN_NR && band <= BAND_FR1_MAX_NR)                         || (band >= BAND_FR2_MIN_NR && band <= BAND_FR2_MAX_NR));             }         }          // If the cell is reported as registered, then all the logical cell info must be reported         if (isRegistered) {             assertTrue(""TAC is required for registered cells"", tac != Integer.MAX_VALUE);             assertTrue(""MCC is required for registered cells"", nr.getMccString() != null);             assertTrue(""MNC is required for registered cells"", nr.getMncString() != null);         }          verifyCellIdentityNrLocationSanitation(nr);     }      private void verifyCellIdentityNrLocationSanitation(CellIdentityNr nr) {         CellIdentityNr sanitized = nr.sanitizeLocationInfo();         assertEquals(CellInfo.UNAVAILABLE, sanitized.getPci());         assertEquals(CellInfo.UNAVAILABLE, sanitized.getTac());         assertEquals(CellInfo.UNAVAILABLE_LONG, sanitized.getNci());     }      private void verifyCellSignalStrengthNr(CellSignalStrengthNr nr) {         int csiRsrp = nr.getCsiRsrp();         int csiRsrq = nr.getCsiRsrq();         int csiSinr = nr.getSsSinr();         int ssRsrp = nr.getSsRsrp();         int ssRsrq = nr.getSsRsrq();         int ssSinr = nr.getSsSinr();          assertTrue(""getCsiRsrp() out of range [-140, -44] | Integer.MAX_INTEGER, csiRsrp = ""                         + csiRsrp, -140 <= csiRsrp && csiRsrp <= -44                 || csiRsrp == Integer.MAX_VALUE);         assertTrue(""getCsiRsrq() out of range [-20, -3] | Integer.MAX_INTEGER, csiRsrq = ""                 + csiRsrq, -20 <= csiRsrq && csiRsrq <= -3 || csiRsrq == Integer.MAX_VALUE);         assertTrue(""getCsiSinr() out of range [-23, 40] | Integer.MAX_INTEGER, csiSinr = ""                 + csiSinr, -23 <= csiSinr && csiSinr <= 40 || csiSinr == Integer.MAX_VALUE);         assertTrue(""getSsRsrp() out of range [-140, -44] | Integer.MAX_INTEGER, ssRsrp = ""                         + ssRsrp, -140 <= ssRsrp && ssRsrp <= -44 || ssRsrp == Integer.MAX_VALUE);         assertTrue(""getSsRsrq() out of range [-20, -3] | Integer.MAX_INTEGER, ssRsrq = ""                 + ssRsrq, -20 <= ssRsrq && ssRsrq <= -3 || ssRsrq == Integer.MAX_VALUE);         assertTrue(""getSsSinr() out of range [-23, 40] | Integer.MAX_INTEGER, ssSinr = ""                 + ssSinr, -23 <= ssSinr && ssSinr <= 40 || ssSinr == Integer.MAX_VALUE);     }      private void verifyCellInfoLteParcelandHashcode(CellInfoLte lte) {         Parcel p = Parcel.obtain();         lte.writeToParcel(p, 0);         p.setDataPosition(0);          CellInfoLte newCi = CellInfoLte.CREATOR.createFromParcel(p);         assertTrue(lte.equals(newCi));         assertEquals(""hashCode() did not get right hashCode"", lte.hashCode(), newCi.hashCode());     }      private void verifyCellIdentityLte(CellIdentityLte lte, boolean isRegistered) {         verifyPlmnInfo(lte.getMccString(), lte.getMncString(), lte.getMcc(), lte.getMnc());          // Cell identity ranges from 0 to 268435456.         int ci = lte.getCi();         assertTrue(""getCi() out of range [0,268435456], ci="" + ci,                 (ci == Integer.MAX_VALUE) || (ci >= 0 && ci <= CI));          // Verify LTE physical cell id information.         // Only physical cell id is available for LTE neighbor.         int pci = lte.getPci();         // Physical cell id should be within [0, 503].         assertTrue(""getPci() out of range [0, 503], pci="" + pci,                 (pci== Integer.MAX_VALUE) || (pci >= 0 && pci <= PCI));          // Tracking area code ranges from 0 to 65535.         int tac = lte.getTac();         assertTrue(""getTac() out of range [0,65535], tac="" + tac,                 (tac == Integer.MAX_VALUE) || (tac >= 0 && tac <= TAC));          int bw = lte.getBandwidth();         assertTrue(""getBandwidth out of range [1400, 20000] | Integer.Max_Value, bw="",                 bw == Integer.MAX_VALUE || bw >= BANDWIDTH_LOW && bw <= BANDWIDTH_HIGH);          int earfcn = lte.getEarfcn();         // Reference 3GPP 36.101 Table 5.7.3-1         // As per NOTE 1 in the table, although 0-6 are valid channel numbers for         // LTE, the reported EARFCN is the center frequency, rendering these channels         // out of the range of the narrowest 1.4Mhz deployment.         int minEarfcn = 7;         int maxEarfcn = EARFCN_MAX - 7;         if (bw != Integer.MAX_VALUE) {             // The number of channels used by a cell is equal to the cell bandwidth divided             // by the channel raster (bandwidth of a channel). The center channel is the channel             // the n/2-th channel where n is the number of channels, and since it is the center             // channel that is reported as the channel number for a cell, we can exclude any channel             // numbers within a band that would place the bottom of a cell's bandwidth below the             // edge of the band. For channel numbers in Band 1, the EARFCN numbering starts from             // channel 0, which means that we can exclude from the valid range channels starting             // from 0 and numbered less than half the total number of channels occupied by a cell.             minEarfcn = bw / CHANNEL_RASTER_EUTRAN / 2;             maxEarfcn = EARFCN_MAX - (bw / CHANNEL_RASTER_EUTRAN / 2);         }         assertTrue(                 ""getEarfcn() out of range ["" + minEarfcn + "","" + maxEarfcn + ""], earfcn="" + earfcn,                 earfcn == Integer.MAX_VALUE || (earfcn >= minEarfcn && earfcn <= maxEarfcn));          if (mRadioHalVersion >= RADIO_HAL_VERSION_1_5) {             int[] bands = lte.getBands();             for (int band: bands) {                 assertTrue(""getBand out of range [1, 88], band = "" + band,                         band >= BAND_MIN_LTE && band <= BAND_MAX_LTE);             }         }          String mobileNetworkOperator = lte.getMobileNetworkOperator();         assertTrue(""getMobileNetworkOperator() out of range [0, 999999], mobileNetworkOperator=""                         + mobileNetworkOperator,                 mobileNetworkOperator == null                         || mobileNetworkOperator.matches(""^[0-9]{5,6}$""));          for (String plmnId : lte.getAdditionalPlmns()) {             verifyPlmnId(plmnId);         }          verifyCsgInfo(lte.getClosedSubscriberGroupInfo());          verifyCellIdentityLteLocationSanitation(lte);          // If the cell is reported as registered, then all the logical cell info must be reported         if (isRegistered) {             assertTrue(""TAC is required for registered cells"", tac != Integer.MAX_VALUE);             assertTrue(""CID is required for registered cells"", ci != Integer.MAX_VALUE);             assertTrue(""MCC is required for registered cells"",                     lte.getMccString() != null || lte.getMcc() != Integer.MAX_VALUE);             assertTrue(""MNC is required for registered cells"",                     lte.getMncString() != null || lte.getMnc() != Integer.MAX_VALUE);         }     }      private void verifyCellIdentityLteLocationSanitation(CellIdentityLte lte) {         CellIdentityLte sanitized = lte.sanitizeLocationInfo();         assertEquals(CellInfo.UNAVAILABLE, sanitized.getCi());         assertEquals(CellInfo.UNAVAILABLE, sanitized.getEarfcn());         assertEquals(CellInfo.UNAVAILABLE, sanitized.getPci());         assertEquals(CellInfo.UNAVAILABLE, sanitized.getTac());     }      private void verifyCellIdentityLteParcel(CellIdentityLte lte) {         Parcel p = Parcel.obtain();         lte.writeToParcel(p, 0);         p.setDataPosition(0);          CellIdentityLte newci = CellIdentityLte.CREATOR.createFromParcel(p);         assertEquals(lte, newci);     }      private void verifyCellSignalStrengthLte(CellSignalStrengthLte cellSignalStrengthLte) {         verifyRssiDbm(cellSignalStrengthLte.getDbm());          //Integer.MAX_VALUE indicates an unavailable field         int rsrp = cellSignalStrengthLte.getRsrp();         // RSRP is being treated as RSSI in LTE (they are similar but not quite right)         // so reusing the constants here.         assertTrue(""getRsrp() out of range, rsrp="" + rsrp, rsrp >= MIN_RSRP && rsrp <= MAX_RSRP);          int rsrq = cellSignalStrengthLte.getRsrq();         assertTrue(""getRsrq() out of range | Integer.MAX_VALUE, rsrq="" + rsrq,             rsrq == Integer.MAX_VALUE || (rsrq >= MIN_RSRQ && rsrq <= MAX_RSRQ));          int rssi = cellSignalStrengthLte.getRssi();         assertTrue(""getRssi() out of range [-113, -51] or Integer.MAX_VALUE if unknown, rssi=""                 + rssi, rssi == CellInfo.UNAVAILABLE                 || (rssi >= MIN_LTE_RSSI && rssi <= MAX_LTE_RSSI));          int rssnr = cellSignalStrengthLte.getRssnr();         assertTrue(""getRssnr() out of range | Integer.MAX_VALUE, rssnr="" + rssnr,             rssnr == Integer.MAX_VALUE || (rssnr >= MIN_RSSNR && rssnr <= MAX_RSSNR));          int cqi = cellSignalStrengthLte.getCqi();         assertTrue(""getCqi() out of range | Integer.MAX_VALUE, cqi="" + cqi,             cqi == Integer.MAX_VALUE || (cqi >= MIN_CQI && cqi <= MAX_CQI));          int ta = cellSignalStrengthLte.getTimingAdvance();         assertTrue(""getTimingAdvance() invalid [0-1282] | Integer.MAX_VALUE, ta="" + ta,                 ta == Integer.MAX_VALUE || (ta >= 0 && ta <=1282));          int level = cellSignalStrengthLte.getLevel();         assertTrue(""getLevel() out of range [0,4], level="" + level, level >= 0 && level <= 4);          int asuLevel = cellSignalStrengthLte.getAsuLevel();         assertTrue(""getAsuLevel() out of range [0,97] (or 99 is unknown), asuLevel="" + asuLevel,                 (asuLevel == 99) || (asuLevel >= 0 && asuLevel <= 97));          int timingAdvance = cellSignalStrengthLte.getTimingAdvance();         assertTrue(""getTimingAdvance() out of range [0,1282], timingAdvance="" + timingAdvance,                 timingAdvance == Integer.MAX_VALUE || (timingAdvance >= 0 && timingAdvance <= 1282));          if (mRadioHalVersion >= RADIO_HAL_VERSION_1_2) {             assertTrue(""RSRP Must be valid for LTE"",                     cellSignalStrengthLte.getRsrp() != CellInfo.UNAVAILABLE);         }     }      private void verifyCellSignalStrengthLteParcel(CellSignalStrengthLte cellSignalStrengthLte) {         Parcel p = Parcel.obtain();         cellSignalStrengthLte.writeToParcel(p, 0);         p.setDataPosition(0);          CellSignalStrengthLte newCss = CellSignalStrengthLte.CREATOR.createFromParcel(p);         assertEquals(cellSignalStrengthLte, newCss);     }      // Verify wcdma cell information is within correct range.     private void verifyWcdmaInfo(CellInfoWcdma wcdma) {         verifyCellConnectionStatus(wcdma.getCellConnectionStatus());         verifyCellInfoWcdmaParcelandHashcode(wcdma);         verifyCellIdentityWcdma(wcdma.getCellIdentity(), wcdma.isRegistered());         verifyCellIdentityWcdmaParcel(wcdma.getCellIdentity());         verifyCellSignalStrengthWcdma(wcdma.getCellSignalStrength());         verifyCellSignalStrengthWcdmaParcel(wcdma.getCellSignalStrength());     }      private void verifyCellInfoWcdmaParcelandHashcode(CellInfoWcdma wcdma) {         Parcel p = Parcel.obtain();         wcdma.writeToParcel(p, 0);         p.setDataPosition(0);          CellInfoWcdma newCi = CellInfoWcdma.CREATOR.createFromParcel(p);         assertTrue(wcdma.equals(newCi));         assertEquals(""hashCode() did not get right hashCode"", wcdma.hashCode(), newCi.hashCode());     }      private void verifyCellIdentityWcdma(CellIdentityWcdma wcdma, boolean isRegistered) {         verifyPlmnInfo(wcdma.getMccString(), wcdma.getMncString(), wcdma.getMcc(), wcdma.getMnc());          int lac = wcdma.getLac();         assertTrue(""getLac() out of range [0, 65535], lac="" + lac,                 (lac >= 0 && lac <= LAC) || lac == Integer.MAX_VALUE);          int cid = wcdma.getCid();         assertTrue(""getCid() out of range [0, 268435455], cid="" + cid,                 (cid >= 0 && cid <= CID_UMTS) || cid == Integer.MAX_VALUE);          // Verify wcdma primary scrambling code information.         // Primary scrambling code should be within [0, 511].         int psc = wcdma.getPsc();         assertTrue(""getPsc() out of range [0, 511], psc="" + psc,                 (psc >= 0 && psc <= PSC) || psc == Integer.MAX_VALUE);          String mobileNetworkOperator = wcdma.getMobileNetworkOperator();         assertTrue(""getMobileNetworkOperator() out of range [0, 999999], mobileNetworkOperator=""                         + mobileNetworkOperator,                 mobileNetworkOperator == null                         || mobileNetworkOperator.matches(""^[0-9]{5,6}$""));          int uarfcn = wcdma.getUarfcn();         // Reference 3GPP 25.101 Table 5.2         // From Appendix E.1, even though UARFCN is numbered from 400, the minumum         // usable channel is 412 due to the fixed bandwidth of 5Mhz         assertTrue(""getUarfcn() out of range [412,11000], uarfcn="" + uarfcn,                 uarfcn >= 412 && uarfcn <= 11000);          for (String plmnId : wcdma.getAdditionalPlmns()) {             verifyPlmnId(plmnId);         }          verifyCsgInfo(wcdma.getClosedSubscriberGroupInfo());          // If the cell is reported as registered, then all the logical cell info must be reported         if (isRegistered) {             assertTrue(""LAC is required for registered cells"", lac != Integer.MAX_VALUE);             assertTrue(""CID is required for registered cells"", cid != Integer.MAX_VALUE);             assertTrue(""MCC is required for registered cells"",                     wcdma.getMccString() != null || wcdma.getMcc() != Integer.MAX_VALUE);             assertTrue(""MNC is required for registered cells"",                     wcdma.getMncString() != null || wcdma.getMnc() != Integer.MAX_VALUE);         }          verifyCellIdentityWcdmaLocationSanitation(wcdma);     }      private void verifyCellIdentityWcdmaLocationSanitation(CellIdentityWcdma wcdma) {         CellIdentityWcdma sanitized = wcdma.sanitizeLocationInfo();         assertEquals(CellInfo.UNAVAILABLE, sanitized.getLac());         assertEquals(CellInfo.UNAVAILABLE, sanitized.getCid());         assertEquals(CellInfo.UNAVAILABLE, sanitized.getPsc());         assertEquals(CellInfo.UNAVAILABLE, sanitized.getUarfcn());     }      private void verifyCellIdentityWcdmaParcel(CellIdentityWcdma wcdma) {         Parcel p = Parcel.obtain();         wcdma.writeToParcel(p, 0);         p.setDataPosition(0);          CellIdentityWcdma newci = CellIdentityWcdma.CREATOR.createFromParcel(p);         assertEquals(wcdma, newci);     }      private void verifyCellSignalStrengthWcdma(CellSignalStrengthWcdma wcdma) {         verifyRssiDbm(wcdma.getDbm());          // Dbm here does not have specific limits. So just calling to verify that it does not crash         // the phone         wcdma.getDbm();          int asuLevel = wcdma.getAsuLevel();         if (wcdma.getRscp() != CellInfo.UNAVAILABLE) {             assertTrue(""getAsuLevel() out of range 0..96, 255), asuLevel="" + asuLevel,                     asuLevel == 255 || (asuLevel >= 0 && asuLevel <= 96));         } else if (wcdma.getRssi() != CellInfo.UNAVAILABLE) {             assertTrue(""getAsuLevel() out of range 0..31, 99), asuLevel="" + asuLevel,                     asuLevel == 99 || (asuLevel >= 0 && asuLevel <= 31));         } else {             assertTrue(""getAsuLevel() out of range 0..96, 255), asuLevel="" + asuLevel,                     asuLevel == 255);         }          int level = wcdma.getLevel();         assertTrue(""getLevel() out of range [0,4], level="" + level, level >= 0 && level <= 4);          if (mRadioHalVersion >= RADIO_HAL_VERSION_1_2) {             assertTrue(""RSCP Must be valid for WCDMA"", wcdma.getRscp() != CellInfo.UNAVAILABLE);         }          int ecNo = wcdma.getEcNo();         assertTrue(""getEcNo() out of range [-24,1], EcNo="" + ecNo,                 (ecNo >= -24 && ecNo <= 1) || ecNo == CellInfo.UNAVAILABLE);     }      private void verifyCellSignalStrengthWcdmaParcel(CellSignalStrengthWcdma wcdma) {         Parcel p = Parcel.obtain();         wcdma.writeToParcel(p, 0);         p.setDataPosition(0);          CellSignalStrengthWcdma newCss = CellSignalStrengthWcdma.CREATOR.createFromParcel(p);         assertEquals(wcdma, newCss);     }      // Verify gsm cell information is within correct range.     private void verifyGsmInfo(CellInfoGsm gsm) {         verifyCellConnectionStatus(gsm.getCellConnectionStatus());         verifyCellInfoWcdmaParcelandHashcode(gsm);         verifyCellIdentityGsm(gsm.getCellIdentity(), gsm.isRegistered());         verifyCellIdentityGsmParcel(gsm.getCellIdentity());         verifyCellSignalStrengthGsm(gsm.getCellSignalStrength());         verifyCellSignalStrengthGsmParcel(gsm.getCellSignalStrength());     }      private void verifyCellInfoWcdmaParcelandHashcode(CellInfoGsm gsm) {         Parcel p = Parcel.obtain();         gsm.writeToParcel(p, 0);         p.setDataPosition(0);          CellInfoGsm newCi = CellInfoGsm.CREATOR.createFromParcel(p);         assertTrue(gsm.equals(newCi));         assertEquals(""hashCode() did not get right hashCode"", gsm.hashCode(), newCi.hashCode());     }      private void verifyCellIdentityGsm(CellIdentityGsm gsm, boolean isRegistered) {         verifyPlmnInfo(gsm.getMccString(), gsm.getMncString(), gsm.getMcc(), gsm.getMnc());          // Local area code and cellid should be with [0, 65535].         int lac = gsm.getLac();         assertTrue(""getLac() out of range [0, 65535], lac="" + lac,                 lac == Integer.MAX_VALUE || (lac >= 0 && lac <= LAC));         int cid = gsm.getCid();         assertTrue(""getCid() out range [0, 65535], cid="" + cid,                 cid== Integer.MAX_VALUE || (cid >= 0 && cid <= CID_GSM));          int arfcn = gsm.getArfcn();         // Reference 3GPP 45.005 Table 2-2         assertTrue(""getArfcn() out of range [0,1024], arfcn="" + arfcn,                 arfcn == Integer.MAX_VALUE || (arfcn >= 0 && arfcn <= ARFCN));          String mobileNetworkOperator = gsm.getMobileNetworkOperator();         assertTrue(""getMobileNetworkOperator() out of range [0, 999999], mobileNetworkOperator=""                         + mobileNetworkOperator,                 mobileNetworkOperator == null                         || mobileNetworkOperator.matches(""^[0-9]{5,6}$""));          int bsic = gsm.getBsic();         // TODO(b/32774471) - Bsic should always be valid         //assertTrue(""getBsic() out of range [0,63]"", bsic >= 0 && bsic <=63);          for (String plmnId : gsm.getAdditionalPlmns()) {             verifyPlmnId(plmnId);         }          // If the cell is reported as registered, then all the logical cell info must be reported         if (isRegistered) {             assertTrue(""LAC is required for registered cells"", lac != Integer.MAX_VALUE);             assertTrue(""CID is required for registered cells"", cid != Integer.MAX_VALUE);             assertTrue(""MCC is required for registered cells"",                     gsm.getMccString() != null || gsm.getMcc() != Integer.MAX_VALUE);             assertTrue(""MNC is required for registered cells"",                     gsm.getMncString() != null || gsm.getMnc() != Integer.MAX_VALUE);         }          verifyCellIdentityGsmLocationSanitation(gsm);     }      private void verifyCellIdentityGsmLocationSanitation(CellIdentityGsm gms) {         CellIdentityGsm sanitized = gms.sanitizeLocationInfo();         assertEquals(CellInfo.UNAVAILABLE, sanitized.getLac());         assertEquals(CellInfo.UNAVAILABLE, sanitized.getCid());         assertEquals(CellInfo.UNAVAILABLE, sanitized.getArfcn());         assertEquals(CellInfo.UNAVAILABLE, sanitized.getBsic());     }      private void verifyCellIdentityGsmParcel(CellIdentityGsm gsm) {         Parcel p = Parcel.obtain();         gsm.writeToParcel(p, 0);         p.setDataPosition(0);          CellIdentityGsm newci = CellIdentityGsm.CREATOR.createFromParcel(p);         assertEquals(gsm, newci);     }      private void verifyCellSignalStrengthGsm(CellSignalStrengthGsm gsm) {         verifyRssiDbm(gsm.getDbm());          int level = gsm.getLevel();         assertTrue(""getLevel() out of range [0,4], level="" + level, level >= 0 && level <= 4);          int ta = gsm.getTimingAdvance();         assertTrue(""getTimingAdvance() out of range [0,219] | Integer.MAX_VALUE, ta="" + ta,                 ta == Integer.MAX_VALUE || (ta >= 0 && ta <= 219));          assertEquals(gsm.getDbm(), gsm.getRssi());          int asuLevel = gsm.getAsuLevel();         assertTrue(""getLevel() out of range [0,31] (or 99 is unknown), level="" + asuLevel,                 asuLevel == 99 || (asuLevel >=0 && asuLevel <= 31));          int ber = gsm.getBitErrorRate();         assertTrue(""getBitErrorRate out of range [0,7], 99, or CellInfo.UNAVAILABLE, ber="" + ber,                 ber == 99 || ber == CellInfo.UNAVAILABLE || (ber >= 0 && ber <= 7));          if (mRadioHalVersion >= RADIO_HAL_VERSION_1_2) {             assertTrue(""RSSI Must be valid for GSM"", gsm.getDbm() != CellInfo.UNAVAILABLE);         }     }      private void verifyCellSignalStrengthGsmParcel(CellSignalStrengthGsm gsm) {         Parcel p = Parcel.obtain();         gsm.writeToParcel(p, 0);         p.setDataPosition(0);          CellSignalStrengthGsm newCss = CellSignalStrengthGsm.CREATOR.createFromParcel(p);         assertEquals(gsm, newCss);     }      // Verify tdscdma cell information is within correct range.     private void verifyTdscdmaInfo(CellInfoTdscdma tdscdma) {         verifyCellConnectionStatus(tdscdma.getCellConnectionStatus());         verifyCellInfoTdscdmaParcelandHashcode(tdscdma);         verifyCellIdentityTdscdma(tdscdma.getCellIdentity(), tdscdma.isRegistered());         verifyCellIdentityTdscdmaParcel(tdscdma.getCellIdentity());         verifyCellSignalStrengthTdscdma(tdscdma.getCellSignalStrength());         verifyCellSignalStrengthTdscdmaParcel(tdscdma.getCellSignalStrength());     }      private void verifyCellInfoTdscdmaParcelandHashcode(CellInfoTdscdma tdscdma) {         Parcel p = Parcel.obtain();         tdscdma.writeToParcel(p, 0);         p.setDataPosition(0);          CellInfoTdscdma newCi = CellInfoTdscdma.CREATOR.createFromParcel(p);         assertTrue(tdscdma.equals(newCi));         assertEquals(""hashCode() did not get right hashCode"", tdscdma.hashCode(), newCi.hashCode());     }      private void verifyCellIdentityTdscdma(CellIdentityTdscdma tdscdma, boolean isRegistered) {         String mccStr = tdscdma.getMccString();         String mncStr = tdscdma.getMncString();          // This class was added after numeric mcc/mncs were no longer provided, so it lacks the         // basic getMcc() and getMnc() - Dummy out those checks.         verifyPlmnInfo(tdscdma.getMccString(), tdscdma.getMncString(),                 mccStr != null ? Integer.parseInt(mccStr) : CellInfo.UNAVAILABLE,                 mncStr != null ? Integer.parseInt(mncStr) : CellInfo.UNAVAILABLE);          int lac = tdscdma.getLac();         assertTrue(""getLac() out of range [0, 65535], lac="" + lac,                 (lac >= 0 && lac <= LAC) || lac == Integer.MAX_VALUE);          int cid = tdscdma.getCid();         assertTrue(""getCid() out of range [0, 268435455], cid="" + cid,                 (cid >= 0 && cid <= CID_UMTS) || cid == Integer.MAX_VALUE);          // Verify tdscdma primary scrambling code information.         // Primary scrambling code should be within [0, 511].         int cpid = tdscdma.getCpid();         assertTrue(""getCpid() out of range [0, 127], cpid="" + cpid, (cpid >= 0 && cpid <= CPID));          String mobileNetworkOperator = tdscdma.getMobileNetworkOperator();         assertTrue(""getMobileNetworkOperator() out of range [0, 999999], mobileNetworkOperator=""                         + mobileNetworkOperator,                 mobileNetworkOperator == null                         || mobileNetworkOperator.matches(""^[0-9]{5,6}$""));          int uarfcn = tdscdma.getUarfcn();         // Reference 3GPP 25.101 Table 5.2         // From Appendix E.1, even though UARFCN is numbered from 400, the minumum         // usable channel is 412 due to the fixed bandwidth of 5Mhz         assertTrue(""getUarfcn() out of range [412,11000], uarfcn="" + uarfcn,                 uarfcn >= 412 && uarfcn <= 11000);          for (String plmnId : tdscdma.getAdditionalPlmns()) {             verifyPlmnId(plmnId);         }          verifyCsgInfo(tdscdma.getClosedSubscriberGroupInfo());          // If the cell is reported as registered, then all the logical cell info must be reported         if (isRegistered) {             assertTrue(""LAC is required for registered cells"", lac != Integer.MAX_VALUE);             assertTrue(""CID is required for registered cells"", cid != Integer.MAX_VALUE);             assertTrue(""MCC is required for registered cells"", tdscdma.getMccString() != null);             assertTrue(""MNC is required for registered cells"", tdscdma.getMncString() != null);         }          verifyCellIdentityTdscdmaLocationSanitation(tdscdma);     }      private void verifyCellIdentityTdscdmaLocationSanitation(CellIdentityTdscdma tdscdma) {         CellIdentityTdscdma sanitized = tdscdma.sanitizeLocationInfo();         assertEquals(CellInfo.UNAVAILABLE, sanitized.getLac());         assertEquals(CellInfo.UNAVAILABLE, sanitized.getCid());         assertEquals(CellInfo.UNAVAILABLE, sanitized.getCpid());         assertEquals(CellInfo.UNAVAILABLE, sanitized.getUarfcn());     }      private void verifyCellIdentityTdscdmaParcel(CellIdentityTdscdma tdscdma) {         Parcel p = Parcel.obtain();         tdscdma.writeToParcel(p, 0);         p.setDataPosition(0);          CellIdentityTdscdma newci = CellIdentityTdscdma.CREATOR.createFromParcel(p);         assertEquals(tdscdma, newci);     }      private void verifyCellSignalStrengthTdscdma(CellSignalStrengthTdscdma tdscdma) {         verifyRssiDbm(tdscdma.getDbm());          // Dbm here does not have specific limits. So just calling to verify that it does not crash         // the phone         tdscdma.getDbm();          int asuLevel = tdscdma.getAsuLevel();         assertTrue(""getLevel() out of range [0,31] (or 99 is unknown), level="" + asuLevel,                 asuLevel == 99 || (asuLevel >= 0 && asuLevel <= 31));          int level = tdscdma.getLevel();         assertTrue(""getLevel() out of range [0,4], level="" + level, level >= 0 && level <= 4);          if (mRadioHalVersion >= RADIO_HAL_VERSION_1_2) {             assertTrue(""RSCP Must be valid for TDSCDMA"", tdscdma.getRscp() != CellInfo.UNAVAILABLE);         }     }      private void verifyCellSignalStrengthTdscdmaParcel(CellSignalStrengthTdscdma tdscdma) {         Parcel p = Parcel.obtain();         tdscdma.writeToParcel(p, 0);         p.setDataPosition(0);          CellSignalStrengthTdscdma newCss = CellSignalStrengthTdscdma.CREATOR.createFromParcel(p);         assertEquals(tdscdma, newCss);     }      // Rssi(in dbm) should be within [MIN_RSSI, MAX_RSSI].     private static void verifyRssiDbm(int dbm) {         assertTrue(""getCellSignalStrength().getDbm() out of range, dbm="" + dbm,                 dbm >= MIN_RSSI && dbm <= MAX_RSSI);     }      private static void verifyCellConnectionStatus(int status) {         assertTrue(""getCellConnectionStatus() invalid [0,2] | Integer.MAX_VALUE, status="",             status == CellInfo.CONNECTION_NONE                 || status == CellInfo.CONNECTION_PRIMARY_SERVING                 || status == CellInfo.CONNECTION_SECONDARY_SERVING                 || status == CellInfo.CONNECTION_UNKNOWN);     }      private static void verifyPlmnId(String plmnId) {         if (TextUtils.isEmpty(plmnId)) return;          assertTrue(""PlmnId() out of range [00000 - 999999], PLMN ID="" + plmnId,                 plmnId.matches(""^[0-9]{5,6}$""));     }      private static void verifyCsgInfo(@Nullable ClosedSubscriberGroupInfo csgInfo) {         if (csgInfo == null) return;          // This is boolean, so as long as it doesn't crash, we're good.         csgInfo.getCsgIndicator();         // This is nullable, and it's free-form so all we can do is ensure it doesn't crash.         csgInfo.getHomeNodebName();          // It might be technically possible to have a CSG ID of zero, but if that's the case         // then let someone complain about it. It's far more likely that if it's '0', then there         // is a bug.         assertTrue(""CSG Identity out of range"", csgInfo.getCsgIdentity() > 0                 && csgInfo.getCsgIdentity() <= 0x7FFFFF);     } }"	""	""	""	""	""
"174:551285) 7.3  . Sensors"	"7.3"	"C-1-6"	""	"android.hardware.cts.GeomagneticFieldTest"	"testGeomagneticField"	"CtsHardwareTestCases"	""	"7.3/C-1-6"	"""C-1-6] MUST report the event time in nanoseconds as defined in the Android SDK documentation, representing the time the event happened and synchronized with the SystemClock.elapsedRealtimeNano() clock.  | C-1-6] MUST set a non-zero resolution for all sensors, and report the value via the Sensor.getResolution() API method. Some sensor types are composite, meaning they can be derived from data provided by one or more other sensors. (Examples include the orientation sensor and the linear acceleration sensor.) Device implementations: SHOULD implement these sensor types, when they include the prerequisite physical sensors as described in sensor types. If device implementations include a composite sensor, they: """	""	"re_tag:(?<!/)C\-1\-6 7.3/C-1-6 7.3"	""	""	""	"7.3"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/hardware/src/android/hardware/cts/GeomagneticFieldTest.java"	""	"public void testGeomagneticField() {         // Reference values calculated from NOAA online calculator for WMM 2015         // https://www.ngdc.noaa.gov/geomag-web/#igrfwmm         TestDataPoint testPoints[] = new TestDataPoint[] {             // Mountain View, CA, USA on 2017/1/1             new TestDataPoint(37.386f, -122.083f, 32, 2017, 1, 1,                     13.4589f, 60.9542f, 48168.0f),             // Chengdu, China on 2017/8/8             new TestDataPoint(30.658f, 103.935f, 500f, 2017, 8, 8,                     -1.9784f, 47.9723f, 50717.3f),             // Sao Paulo, Brazil on 2018/12/25             new TestDataPoint(-23.682f, -46.875f, 760f, 2018, 12, 25,                     -21.3130f, -37.9940f, 22832.3f),             // Boston, MA, USA on 2019/2/10             new TestDataPoint(42.313f, -71.127f, 43f, 2019, 2, 10,                     -14.5391f, 66.9693f, 51815.1f),             // Cape Town, South Africa on 2019/5/1             new TestDataPoint(-33.913f, 18.095f, 100f, 2019, 5, 1,                     -25.2454f, -65.8887f, 25369.2f),             // Sydney, Australia on 2020/1/1             new TestDataPoint(-33.847f, 150.791f, 19f, 2020, 1, 1,                     12.4469f, -64.3443f, 57087.9f)         };          for (TestDataPoint t : testPoints) {             GeomagneticField field =                     new GeomagneticField(t.latitude, t.longitude, t.altitude, t.epochTimeMillis);             assertEquals(t.declinationDegree,  field.getDeclination(), DECLINATION_THRESHOLD);             assertEquals(t.inclinationDegree,  field.getInclination(), INCLINATION_THRESHOLD);             assertEquals(t.fieldStrengthNanoTesla, field.getFieldStrength(),                     FIELD_STRENGTH_THRESHOLD);              float horizontalFieldStrengthNanoTesla = (float)(                     Math.cos(Math.toRadians(t.inclinationDegree)) * t.fieldStrengthNanoTesla);             assertEquals(horizontalFieldStrengthNanoTesla, field.getHorizontalStrength(),                     FIELD_STRENGTH_THRESHOLD);              float verticalFieldStrengthNanoTesla = (float)(                     Math.sin(Math.toRadians(t.inclinationDegree)) * t.fieldStrengthNanoTesla);             assertEquals(verticalFieldStrengthNanoTesla, field.getZ(), FIELD_STRENGTH_THRESHOLD);              float declinationDegree = (float)(                     Math.toDegrees(Math.atan2(field.getY(), field.getX())));             assertEquals(t.declinationDegree, declinationDegree, DECLINATION_THRESHOLD);             assertEquals(horizontalFieldStrengthNanoTesla,                     Math.sqrt(field.getX() * field.getX() + field.getY() * field.getY()),                     FIELD_STRENGTH_THRESHOLD);         }     }      private class TestDataPoint {         public final float latitude;         public final float longitude;         public final float altitude;         public final long epochTimeMillis;         public final float declinationDegree;         public final float inclinationDegree;         public final float fieldStrengthNanoTesla;          TestDataPoint(float lat, float lng, float alt, int year, int month, int day,                 float dec, float inc, float strength) {             latitude = lat;             longitude = lng;             altitude = alt;             epochTimeMillis = new GregorianCalendar(year, month, day).getTimeInMillis();             declinationDegree = dec;             inclinationDegree = inc;             fieldStrengthNanoTesla = strength;         }     } }"	""	""	""	""	""
