"Section"	"section_id"	"req_id"	"full_key"	"key_as_number"	"requirement"	"Test Availability"	"search_roots"	"search_terms"	"manual_search_terms"	"not_search_terms"	"not_files"	"max_matches"	"class_defs"	"methods"	"modules"	"protected"	"class_def"	"method"	"module"	"file_name"	"matched_files"	"methods_string"	"urls"	"method_text"	"matched_terms"	"qualified_method"	"Annotation?"	"New Req for S?"	"New CTS for S?"	"Comment(internal) e.g. why a test is not possible"	"CTS Bug Id"	"CDD Bug Id"	"Area"	"Shortened"	"Test Level"
"3.2.3.5  Conditional Application Intents"	"3.2.3.5"	"C-5-2"	"3.2.3.5/C-5-2"	"03020305.670502"	"""C-5-2] MUST honor the [‘android.bluetooth.adapter.action.REQUEST_DISCOVERABLE’](https://developer.android.com/reference/android/bluetooth/BluetoothAdapter#ACTION_REQUEST_DISCOVERABLE) intent and show a system activity that requests discoverable mode.  If device implementations support the DND feature, they:  """	Test Available	""	"REQUEST_DISCOVERABLE ACTION_REQUEST_DISCOVERABLE android.bluetooth.adapter.action.REQUEST"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.bluetooth.ConnectionAccessServerActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/bluetooth/ConnectionAccessServerActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.bluetooth;

import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;

import android.app.AlertDialog;
import android.bluetooth.BluetoothAdapter;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.provider.Settings;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.Window;
import android.widget.Button;
import android.widget.TextView;
import android.widget.Toast;

public class ConnectionAccessServerActivity extends PassFailButtons.Activity {

    private static final String ACTION_CONNECTION_ACCESS_REQUEST =
            ""android.bluetooth.device.action.CONNECTION_ACCESS_REQUEST"";

    private static final int ENABLE_BLUETOOTH_REQUEST = 1;

    private BluetoothAdapter mBluetoothAdapter;
    private ConnectionAccessRequestReceiver mConnectionAccessRequestReceiver;
    private BluetoothChatService mChatService;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);
        setContentView(R.layout.bt_connection_access);
        setInfoResources(R.string.bt_connection_access_server,
                R.string.bt_connection_access_server_info, 0);
        setPassFailButtonClickListeners();
        getPassButton().setEnabled(false);

        View settings = findViewById(R.id.bt_settings);
        settings.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View view) {
                startActivity(new Intent(Settings.ACTION_BLUETOOTH_SETTINGS));
            }
        });

        Button makeDiscoverableButton = (Button) findViewById(R.id.bt_make_discoverable_button);
        makeDiscoverableButton.setVisibility(View.VISIBLE);
        makeDiscoverableButton.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                makeDiscoverable();
            }
        });

        mConnectionAccessRequestReceiver = new ConnectionAccessRequestReceiver();
        IntentFilter intentFilter = new IntentFilter(ACTION_CONNECTION_ACCESS_REQUEST);
        registerReceiver(mConnectionAccessRequestReceiver, intentFilter);

        mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
        if (mBluetoothAdapter.isEnabled()) {
            startChatService();
        } else {
            Intent intent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);
            startActivityForResult(intent, ENABLE_BLUETOOTH_REQUEST);
        }
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        switch (requestCode) {
            case ENABLE_BLUETOOTH_REQUEST:
                if (resultCode == RESULT_OK) {
                    startChatService();
                } else {
                    setResult(RESULT_CANCELED);
                    finish();
                }
                break;
        }
    }

    private void startChatService() {
        mChatService = new BluetoothChatService(this, new ChatHandler(),
                BluetoothChatService.HANDSFREE_INSECURE_UUID);
        boolean secure = false;
        mChatService.start(secure);
    }

    private void makeDiscoverable() {
        if (mBluetoothAdapter.getScanMode() !=
                BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE) {
            Intent intent = new Intent(BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE);
            intent.putExtra(BluetoothAdapter.EXTRA_DISCOVERABLE_DURATION, 30);
            startActivity(intent);
        }
    }

    private class ChatHandler extends Handler {
        @Override
        public void handleMessage(Message msg) {
            super.handleMessage(msg);
            switch (msg.what) {
                case BluetoothChatService.MESSAGE_STATE_CHANGE:
                    handleStateChange(msg);
                    break;

                case BluetoothChatService.MESSAGE_TOAST:
                    handleToast(msg);
                    break;
            }
        }
    }

    private void handleStateChange(Message msg) {
        int state = msg.arg1;
        switch (state) {
            case BluetoothChatService.STATE_LISTEN:
                setProgressBarIndeterminateVisibility(true);
                Toast.makeText(this, R.string.bt_listening, Toast.LENGTH_SHORT).show();
                break;
        }
    }

    private void handleToast(Message msg) {
        String toast = msg.getData().getString(BluetoothChatService.TOAST);
        Toast.makeText(this, toast, Toast.LENGTH_LONG).show();
    }

    class ConnectionAccessRequestReceiver extends BroadcastReceiver {
        @Override
        public void onReceive(Context context, Intent intent) {
            new AlertDialog.Builder(ConnectionAccessServerActivity.this)
                    .setMessage(R.string.bt_ca_dialog)
                    .setPositiveButton(android.R.string.ok, new DialogInterface.OnClickListener() {
                        @Override
                        public void onClick(DialogInterface dialog, int which) {
                            getPassButton().setEnabled(true);
                        }
                    })
                    .setNegativeButton(android.R.string.cancel,
                            new DialogInterface.OnClickListener() {
                        @Override
                        public void onClick(DialogInterface dialog, int which) {
                            getPassButton().setEnabled(false);
                        }
                    })
                    .show();
        }
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        if (mChatService != null) {
            mChatService.stop();
        }
        unregisterReceiver(mConnectionAccessRequestReceiver);
    }
}"	""	""	"REQUEST_DISCOVERABLE"	""	""	""	""	Though maybe not targeted at this requirement it seems to test it fully.	""	""	""	""	""
"3.2.3.5  Conditional Application Intents"	"3.2.3.5"	"C-5-2"	"3.2.3.5/C-5-2"	"03020305.670502"	"""C-5-2] MUST honor the [‘android.bluetooth.adapter.action.REQUEST_DISCOVERABLE’](https://developer.android.com/reference/android/bluetooth/BluetoothAdapter#ACTION_REQUEST_DISCOVERABLE) intent and show a system activity that requests discoverable mode.  If device implementations support the DND feature, they:  """	""	""	"REQUEST_DISCOVERABLE ACTION_REQUEST_DISCOVERABLE android.bluetooth.adapter.action.REQUEST"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.bluetooth.ConnectionAccessServerActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/bluetooth/ConnectionAccessServerActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.bluetooth;

import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;

import android.app.AlertDialog;
import android.bluetooth.BluetoothAdapter;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.provider.Settings;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.Window;
import android.widget.Button;
import android.widget.TextView;
import android.widget.Toast;

public class ConnectionAccessServerActivity extends PassFailButtons.Activity {

    private static final String ACTION_CONNECTION_ACCESS_REQUEST =
            ""android.bluetooth.device.action.CONNECTION_ACCESS_REQUEST"";

    private static final int ENABLE_BLUETOOTH_REQUEST = 1;

    private BluetoothAdapter mBluetoothAdapter;
    private ConnectionAccessRequestReceiver mConnectionAccessRequestReceiver;
    private BluetoothChatService mChatService;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);
        setContentView(R.layout.bt_connection_access);
        setInfoResources(R.string.bt_connection_access_server,
                R.string.bt_connection_access_server_info, 0);
        setPassFailButtonClickListeners();
        getPassButton().setEnabled(false);

        View settings = findViewById(R.id.bt_settings);
        settings.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View view) {
                startActivity(new Intent(Settings.ACTION_BLUETOOTH_SETTINGS));
            }
        });

        Button makeDiscoverableButton = (Button) findViewById(R.id.bt_make_discoverable_button);
        makeDiscoverableButton.setVisibility(View.VISIBLE);
        makeDiscoverableButton.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                makeDiscoverable();
            }
        });

        mConnectionAccessRequestReceiver = new ConnectionAccessRequestReceiver();
        IntentFilter intentFilter = new IntentFilter(ACTION_CONNECTION_ACCESS_REQUEST);
        registerReceiver(mConnectionAccessRequestReceiver, intentFilter);

        mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
        if (mBluetoothAdapter.isEnabled()) {
            startChatService();
        } else {
            Intent intent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);
            startActivityForResult(intent, ENABLE_BLUETOOTH_REQUEST);
        }
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        switch (requestCode) {
            case ENABLE_BLUETOOTH_REQUEST:
                if (resultCode == RESULT_OK) {
                    startChatService();
                } else {
                    setResult(RESULT_CANCELED);
                    finish();
                }
                break;
        }
    }

    private void startChatService() {
        mChatService = new BluetoothChatService(this, new ChatHandler(),
                BluetoothChatService.HANDSFREE_INSECURE_UUID);
        boolean secure = false;
        mChatService.start(secure);
    }

    private void makeDiscoverable() {
        if (mBluetoothAdapter.getScanMode() !=
                BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE) {
            Intent intent = new Intent(BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE);
            intent.putExtra(BluetoothAdapter.EXTRA_DISCOVERABLE_DURATION, 30);
            startActivity(intent);
        }
    }

    private class ChatHandler extends Handler {
        @Override
        public void handleMessage(Message msg) {
            super.handleMessage(msg);
            switch (msg.what) {
                case BluetoothChatService.MESSAGE_STATE_CHANGE:
                    handleStateChange(msg);
                    break;

                case BluetoothChatService.MESSAGE_TOAST:
                    handleToast(msg);
                    break;
            }
        }
    }

    private void handleStateChange(Message msg) {
        int state = msg.arg1;
        switch (state) {
            case BluetoothChatService.STATE_LISTEN:
                setProgressBarIndeterminateVisibility(true);
                Toast.makeText(this, R.string.bt_listening, Toast.LENGTH_SHORT).show();
                break;
        }
    }

    private void handleToast(Message msg) {
        String toast = msg.getData().getString(BluetoothChatService.TOAST);
        Toast.makeText(this, toast, Toast.LENGTH_LONG).show();
    }

    class ConnectionAccessRequestReceiver extends BroadcastReceiver {
        @Override
        public void onReceive(Context context, Intent intent) {
            new AlertDialog.Builder(ConnectionAccessServerActivity.this)
                    .setMessage(R.string.bt_ca_dialog)
                    .setPositiveButton(android.R.string.ok, new DialogInterface.OnClickListener() {
                        @Override
                        public void onClick(DialogInterface dialog, int which) {
                            getPassButton().setEnabled(true);
                        }
                    })
                    .setNegativeButton(android.R.string.cancel,
                            new DialogInterface.OnClickListener() {
                        @Override
                        public void onClick(DialogInterface dialog, int which) {
                            getPassButton().setEnabled(false);
                        }
                    })
                    .show();
        }
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        if (mChatService != null) {
            mChatService.stop();
        }
        unregisterReceiver(mConnectionAccessRequestReceiver);
    }
}"	""	""	"ACTION_REQUEST_DISCOVERABLE"	""	""	""	""	""	""	""	""	""	""
"3.2.3.5  Conditional Application Intents"	"3.2.3.5"	"C-5-2"	"3.2.3.5/C-5-2"	"03020305.670502"	"""C-5-2] MUST honor the [‘android.bluetooth.adapter.action.REQUEST_DISCOVERABLE’](https://developer.android.com/reference/android/bluetooth/BluetoothAdapter#ACTION_REQUEST_DISCOVERABLE) intent and show a system activity that requests discoverable mode.  If device implementations support the DND feature, they:  """	""	""	"REQUEST_DISCOVERABLE ACTION_REQUEST_DISCOVERABLE android.bluetooth.adapter.action.REQUEST"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.bluetooth.HidDeviceActivity"	"ServiceListener"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/bluetooth/HidDeviceActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.bluetooth;

import android.bluetooth.BluetoothAdapter;
import android.bluetooth.BluetoothDevice;
import android.bluetooth.BluetoothHidDevice;
import android.bluetooth.BluetoothHidDeviceAppQosSettings;
import android.bluetooth.BluetoothHidDeviceAppSdpSettings;
import android.bluetooth.BluetoothProfile;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.os.Bundle;

import android.util.Log;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;

import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class HidDeviceActivity extends PassFailButtons.Activity {
    private static final String TAG = HidDeviceActivity.class.getSimpleName();
    private static final int MSG_APP_STATUS_CHANGED = 0;
    private static final String SDP_NAME = ""CtsVerifier"";
    private static final String SDP_DESCRIPTION = ""CtsVerifier HID Device test"";
    private static final String SDP_PROVIDER = ""Android"";
    private static final int QOS_TOKEN_RATE = 800; // 9 bytes * 1000000 us / 11250 us
    private static final int QOS_TOKEN_BUCKET_SIZE = 9;
    private static final int QOS_PEAK_BANDWIDTH = 0;
    private static final int QOS_LATENCY = 11250;
    static final String SAMPLE_INPUT = ""bluetooth"";

    private BluetoothAdapter mBluetoothAdapter;
    private BluetoothHidDevice mBluetoothHidDevice;
    private BluetoothDevice mHidHost;
    private ExecutorService mExecutor;

    private Button mRegisterAppButton;
    private Button mMakeDiscoverableButton;
    private Button mUnregisterAppButton;
    private Button mSendReportButton;
    private Button mReplyReportButton;
    private Button mReportErrorButton;

    private BluetoothProfile.ServiceListener mProfileListener =
            new BluetoothProfile.ServiceListener() {
        public void onServiceConnected(int profile, BluetoothProfile proxy) {
            if (profile == BluetoothProfile.HID_DEVICE) {
                mBluetoothHidDevice = (BluetoothHidDevice) proxy;
            }
        }

        public void onServiceDisconnected(int profile) {
            if (profile == BluetoothProfile.HID_DEVICE) {
                mBluetoothHidDevice = null;
            }
        }
    };

    private final BluetoothHidDeviceAppSdpSettings mSdpSettings =
            new BluetoothHidDeviceAppSdpSettings(
                    SDP_NAME,
                    SDP_DESCRIPTION,
                    SDP_PROVIDER,
                    BluetoothHidDevice.SUBCLASS1_COMBO,
                    HidConstants.HIDD_REPORT_DESC);

    private final BluetoothHidDeviceAppQosSettings mOutQos =
            new BluetoothHidDeviceAppQosSettings(
                    BluetoothHidDeviceAppQosSettings.SERVICE_BEST_EFFORT,
                    QOS_TOKEN_RATE,
                    QOS_TOKEN_BUCKET_SIZE,
                    QOS_PEAK_BANDWIDTH,
                    QOS_LATENCY,
                    BluetoothHidDeviceAppQosSettings.MAX);

    private BluetoothHidDevice.Callback mCallback = new BluetoothHidDevice.Callback() {
        @Override
        public void onAppStatusChanged(BluetoothDevice pluggedDevice, boolean registered) {
            Log.d(TAG, ""onAppStatusChanged: pluggedDevice="" + pluggedDevice + "" registered=""
                    + registered);
        }
    };

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.bt_hid_device);
        setPassFailButtonClickListeners();
        setInfoResources(R.string.bt_hid_device_test_name, R.string.bt_hid_device_test_info, -1);

        mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
        mBluetoothAdapter.getProfileProxy(getApplicationContext(), mProfileListener,
                BluetoothProfile.HID_DEVICE);
        mExecutor = Executors.newSingleThreadExecutor();

        mRegisterAppButton = (Button) findViewById(R.id.bt_hid_device_register_button);
        mRegisterAppButton.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                register();
            }
        });

        mUnregisterAppButton = (Button) findViewById(R.id.bt_hid_device_unregister_button);
        mUnregisterAppButton.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                unregister();
            }
        });

        mMakeDiscoverableButton = (Button) findViewById(R.id.bt_hid_device_discoverable_button);
        mMakeDiscoverableButton.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                makeDiscoverable();
            }
        });

        mSendReportButton = (Button) findViewById(R.id.bt_hid_device_send_report_button);
        mSendReportButton.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                testSendReport();
            }
        });

        mReplyReportButton = (Button) findViewById(R.id.bt_hid_device_reply_report_button);
        mReplyReportButton.setEnabled(false);
        mReplyReportButton.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                testReplyReport();
            }
        });

        mReportErrorButton = (Button) findViewById(R.id.bt_hid_device_report_error_button);
        mReportErrorButton.setEnabled(false);
        mReportErrorButton.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                testReportError();
            }
        });

        if (isAndroidTv()) {
            startForegroundService(new Intent(getApplication(),
                  FocusLossPreventionService.class));
        }
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        unregister();

        if (isAndroidTv()) {
            stopService(new Intent(getApplication(),
                  FocusLossPreventionService.class));
        }
    }

    private boolean register() {
        return mBluetoothHidDevice != null
                && mBluetoothHidDevice.registerApp(mSdpSettings, null, mOutQos, mExecutor,
                mCallback);
    }

    private void makeDiscoverable() {
        if (mBluetoothAdapter.getScanMode() !=
                BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE) {
            Intent intent = new Intent(BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE);
            intent.putExtra(BluetoothAdapter.EXTRA_DISCOVERABLE_DURATION, 30);
            startActivity(intent);
        }
    }

    private boolean unregister() {
        return mBluetoothHidDevice != null && mBluetoothHidDevice.unregisterApp();
    }


    private boolean getConnectedDevice() {
        if (mBluetoothHidDevice == null) {
            Log.w(TAG, ""mBluetoothHidDevice is null"");
            return false;
        }

        List<BluetoothDevice> connectedDevices = mBluetoothHidDevice.getConnectedDevices();
        if (connectedDevices.size() == 0) {
            return false;
        } else {
            return false;
        }
    }

    private void testSendReport() {
        if (mBluetoothHidDevice == null) {
            Log.w(TAG, ""mBluetoothHidDevice is null"");
            return;
        }

        if (mHidHost == null) {
            if (mBluetoothHidDevice.getConnectedDevices().size() == 0) {
                Log.w(TAG, ""HID host not connected"");
                return;
            } else {
                mHidHost = mBluetoothHidDevice.getConnectedDevices().get(0);
                Log.d(TAG, ""connected to: "" + mHidHost);
            }
        }
        for (char c : SAMPLE_INPUT.toCharArray()) {
            mBluetoothHidDevice.sendReport(mHidHost, BluetoothHidDevice.REPORT_TYPE_INPUT,
                    singleKeyHit(charToKeyCode(c)));
            mBluetoothHidDevice.sendReport(mHidHost, BluetoothHidDevice.REPORT_TYPE_INPUT,
                    singleKeyHit((byte) 0));
        }
        mReplyReportButton.setEnabled(true);

    }

    private void testReplyReport() {
        if (mBluetoothHidDevice == null) {
            Log.w(TAG, ""mBluetoothHidDevice is null"");
            return;
        }

        if (mHidHost == null) {
            if (mBluetoothHidDevice.getConnectedDevices().size() == 0) {
                Log.w(TAG, ""HID host not connected"");
                return;
            } else {
                mHidHost = mBluetoothHidDevice.getConnectedDevices().get(0);
                Log.d(TAG, ""connected to: "" + mHidHost);
            }
        }
        if (mBluetoothHidDevice.replyReport(mHidHost, (byte) 0, (byte) 0,
                singleKeyHit((byte) 0))) {
            mReportErrorButton.setEnabled(true);
        }
    }

    private void testReportError() {
        if (mBluetoothHidDevice == null) {
            Log.w(TAG, ""mBluetoothHidDevice is null"");
            return;
        }

        if (mHidHost == null) {
            if (mBluetoothHidDevice.getConnectedDevices().size() == 0) {
                Log.w(TAG, ""HID host not connected"");
                return;
            } else {
                mHidHost = mBluetoothHidDevice.getConnectedDevices().get(0);
                Log.d(TAG, ""connected to: "" + mHidHost);
            }
        }
        if (mBluetoothHidDevice.reportError(mHidHost, (byte) 0)) {
            getPassButton().setEnabled(true);
        }
    }


    private byte[] singleKeyHit(byte code) {
        byte[] keyboardData = new byte[8];
        keyboardData[0] = 0;
        keyboardData[1] = 0;
        keyboardData[2] = code;
        keyboardData[3] = 0;
        keyboardData[4] = 0;
        keyboardData[5] = 0;
        keyboardData[6] = 0;
        keyboardData[7] = 0;
        return keyboardData;
    }

    private byte charToKeyCode(char c) {
        if (c < 'a' || c > 'z') {
            return 0;
        }
        return (byte) (c - 'a' + 0x04);
    }

    private boolean isAndroidTv() {
        final PackageManager pm = getApplicationContext().getPackageManager();
        return pm.hasSystemFeature(PackageManager.FEATURE_TELEVISION)
                  || pm.hasSystemFeature(PackageManager.FEATURE_LEANBACK);
    }
}"	""	""	"REQUEST_DISCOVERABLE"	""	""	""	""	""	""	""	""	""	""
"3.2.3.5  Conditional Application Intents"	"3.2.3.5"	"C-5-2"	"3.2.3.5/C-5-2"	"03020305.670502"	"""C-5-2] MUST honor the [‘android.bluetooth.adapter.action.REQUEST_DISCOVERABLE’](https://developer.android.com/reference/android/bluetooth/BluetoothAdapter#ACTION_REQUEST_DISCOVERABLE) intent and show a system activity that requests discoverable mode.  If device implementations support the DND feature, they:  """	""	""	"REQUEST_DISCOVERABLE ACTION_REQUEST_DISCOVERABLE android.bluetooth.adapter.action.REQUEST"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.bluetooth.HidDeviceActivity"	"ServiceListener"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/bluetooth/HidDeviceActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.bluetooth;

import android.bluetooth.BluetoothAdapter;
import android.bluetooth.BluetoothDevice;
import android.bluetooth.BluetoothHidDevice;
import android.bluetooth.BluetoothHidDeviceAppQosSettings;
import android.bluetooth.BluetoothHidDeviceAppSdpSettings;
import android.bluetooth.BluetoothProfile;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.os.Bundle;

import android.util.Log;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;

import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class HidDeviceActivity extends PassFailButtons.Activity {
    private static final String TAG = HidDeviceActivity.class.getSimpleName();
    private static final int MSG_APP_STATUS_CHANGED = 0;
    private static final String SDP_NAME = ""CtsVerifier"";
    private static final String SDP_DESCRIPTION = ""CtsVerifier HID Device test"";
    private static final String SDP_PROVIDER = ""Android"";
    private static final int QOS_TOKEN_RATE = 800; // 9 bytes * 1000000 us / 11250 us
    private static final int QOS_TOKEN_BUCKET_SIZE = 9;
    private static final int QOS_PEAK_BANDWIDTH = 0;
    private static final int QOS_LATENCY = 11250;
    static final String SAMPLE_INPUT = ""bluetooth"";

    private BluetoothAdapter mBluetoothAdapter;
    private BluetoothHidDevice mBluetoothHidDevice;
    private BluetoothDevice mHidHost;
    private ExecutorService mExecutor;

    private Button mRegisterAppButton;
    private Button mMakeDiscoverableButton;
    private Button mUnregisterAppButton;
    private Button mSendReportButton;
    private Button mReplyReportButton;
    private Button mReportErrorButton;

    private BluetoothProfile.ServiceListener mProfileListener =
            new BluetoothProfile.ServiceListener() {
        public void onServiceConnected(int profile, BluetoothProfile proxy) {
            if (profile == BluetoothProfile.HID_DEVICE) {
                mBluetoothHidDevice = (BluetoothHidDevice) proxy;
            }
        }

        public void onServiceDisconnected(int profile) {
            if (profile == BluetoothProfile.HID_DEVICE) {
                mBluetoothHidDevice = null;
            }
        }
    };

    private final BluetoothHidDeviceAppSdpSettings mSdpSettings =
            new BluetoothHidDeviceAppSdpSettings(
                    SDP_NAME,
                    SDP_DESCRIPTION,
                    SDP_PROVIDER,
                    BluetoothHidDevice.SUBCLASS1_COMBO,
                    HidConstants.HIDD_REPORT_DESC);

    private final BluetoothHidDeviceAppQosSettings mOutQos =
            new BluetoothHidDeviceAppQosSettings(
                    BluetoothHidDeviceAppQosSettings.SERVICE_BEST_EFFORT,
                    QOS_TOKEN_RATE,
                    QOS_TOKEN_BUCKET_SIZE,
                    QOS_PEAK_BANDWIDTH,
                    QOS_LATENCY,
                    BluetoothHidDeviceAppQosSettings.MAX);

    private BluetoothHidDevice.Callback mCallback = new BluetoothHidDevice.Callback() {
        @Override
        public void onAppStatusChanged(BluetoothDevice pluggedDevice, boolean registered) {
            Log.d(TAG, ""onAppStatusChanged: pluggedDevice="" + pluggedDevice + "" registered=""
                    + registered);
        }
    };

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.bt_hid_device);
        setPassFailButtonClickListeners();
        setInfoResources(R.string.bt_hid_device_test_name, R.string.bt_hid_device_test_info, -1);

        mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
        mBluetoothAdapter.getProfileProxy(getApplicationContext(), mProfileListener,
                BluetoothProfile.HID_DEVICE);
        mExecutor = Executors.newSingleThreadExecutor();

        mRegisterAppButton = (Button) findViewById(R.id.bt_hid_device_register_button);
        mRegisterAppButton.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                register();
            }
        });

        mUnregisterAppButton = (Button) findViewById(R.id.bt_hid_device_unregister_button);
        mUnregisterAppButton.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                unregister();
            }
        });

        mMakeDiscoverableButton = (Button) findViewById(R.id.bt_hid_device_discoverable_button);
        mMakeDiscoverableButton.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                makeDiscoverable();
            }
        });

        mSendReportButton = (Button) findViewById(R.id.bt_hid_device_send_report_button);
        mSendReportButton.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                testSendReport();
            }
        });

        mReplyReportButton = (Button) findViewById(R.id.bt_hid_device_reply_report_button);
        mReplyReportButton.setEnabled(false);
        mReplyReportButton.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                testReplyReport();
            }
        });

        mReportErrorButton = (Button) findViewById(R.id.bt_hid_device_report_error_button);
        mReportErrorButton.setEnabled(false);
        mReportErrorButton.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                testReportError();
            }
        });

        if (isAndroidTv()) {
            startForegroundService(new Intent(getApplication(),
                  FocusLossPreventionService.class));
        }
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        unregister();

        if (isAndroidTv()) {
            stopService(new Intent(getApplication(),
                  FocusLossPreventionService.class));
        }
    }

    private boolean register() {
        return mBluetoothHidDevice != null
                && mBluetoothHidDevice.registerApp(mSdpSettings, null, mOutQos, mExecutor,
                mCallback);
    }

    private void makeDiscoverable() {
        if (mBluetoothAdapter.getScanMode() !=
                BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE) {
            Intent intent = new Intent(BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE);
            intent.putExtra(BluetoothAdapter.EXTRA_DISCOVERABLE_DURATION, 30);
            startActivity(intent);
        }
    }

    private boolean unregister() {
        return mBluetoothHidDevice != null && mBluetoothHidDevice.unregisterApp();
    }


    private boolean getConnectedDevice() {
        if (mBluetoothHidDevice == null) {
            Log.w(TAG, ""mBluetoothHidDevice is null"");
            return false;
        }

        List<BluetoothDevice> connectedDevices = mBluetoothHidDevice.getConnectedDevices();
        if (connectedDevices.size() == 0) {
            return false;
        } else {
            return false;
        }
    }

    private void testSendReport() {
        if (mBluetoothHidDevice == null) {
            Log.w(TAG, ""mBluetoothHidDevice is null"");
            return;
        }

        if (mHidHost == null) {
            if (mBluetoothHidDevice.getConnectedDevices().size() == 0) {
                Log.w(TAG, ""HID host not connected"");
                return;
            } else {
                mHidHost = mBluetoothHidDevice.getConnectedDevices().get(0);
                Log.d(TAG, ""connected to: "" + mHidHost);
            }
        }
        for (char c : SAMPLE_INPUT.toCharArray()) {
            mBluetoothHidDevice.sendReport(mHidHost, BluetoothHidDevice.REPORT_TYPE_INPUT,
                    singleKeyHit(charToKeyCode(c)));
            mBluetoothHidDevice.sendReport(mHidHost, BluetoothHidDevice.REPORT_TYPE_INPUT,
                    singleKeyHit((byte) 0));
        }
        mReplyReportButton.setEnabled(true);

    }

    private void testReplyReport() {
        if (mBluetoothHidDevice == null) {
            Log.w(TAG, ""mBluetoothHidDevice is null"");
            return;
        }

        if (mHidHost == null) {
            if (mBluetoothHidDevice.getConnectedDevices().size() == 0) {
                Log.w(TAG, ""HID host not connected"");
                return;
            } else {
                mHidHost = mBluetoothHidDevice.getConnectedDevices().get(0);
                Log.d(TAG, ""connected to: "" + mHidHost);
            }
        }
        if (mBluetoothHidDevice.replyReport(mHidHost, (byte) 0, (byte) 0,
                singleKeyHit((byte) 0))) {
            mReportErrorButton.setEnabled(true);
        }
    }

    private void testReportError() {
        if (mBluetoothHidDevice == null) {
            Log.w(TAG, ""mBluetoothHidDevice is null"");
            return;
        }

        if (mHidHost == null) {
            if (mBluetoothHidDevice.getConnectedDevices().size() == 0) {
                Log.w(TAG, ""HID host not connected"");
                return;
            } else {
                mHidHost = mBluetoothHidDevice.getConnectedDevices().get(0);
                Log.d(TAG, ""connected to: "" + mHidHost);
            }
        }
        if (mBluetoothHidDevice.reportError(mHidHost, (byte) 0)) {
            getPassButton().setEnabled(true);
        }
    }


    private byte[] singleKeyHit(byte code) {
        byte[] keyboardData = new byte[8];
        keyboardData[0] = 0;
        keyboardData[1] = 0;
        keyboardData[2] = code;
        keyboardData[3] = 0;
        keyboardData[4] = 0;
        keyboardData[5] = 0;
        keyboardData[6] = 0;
        keyboardData[7] = 0;
        return keyboardData;
    }

    private byte charToKeyCode(char c) {
        if (c < 'a' || c > 'z') {
            return 0;
        }
        return (byte) (c - 'a' + 0x04);
    }

    private boolean isAndroidTv() {
        final PackageManager pm = getApplicationContext().getPackageManager();
        return pm.hasSystemFeature(PackageManager.FEATURE_TELEVISION)
                  || pm.hasSystemFeature(PackageManager.FEATURE_LEANBACK);
    }
}"	""	""	"ACTION_REQUEST_DISCOVERABLE"	""	""	""	""	""	""	""	""	""	""
"3.2.3.5  Conditional Application Intents"	"3.2.3.5"	"C-5-2"	"3.2.3.5/C-5-2"	"03020305.670502"	"""C-5-2] MUST honor the [‘android.bluetooth.adapter.action.REQUEST_DISCOVERABLE’](https://developer.android.com/reference/android/bluetooth/BluetoothAdapter#ACTION_REQUEST_DISCOVERABLE) intent and show a system activity that requests discoverable mode.  If device implementations support the DND feature, they:  """	""	""	"REQUEST_DISCOVERABLE ACTION_REQUEST_DISCOVERABLE android.bluetooth.adapter.action.REQUEST"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.bluetooth.MessageTestActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/bluetooth/MessageTestActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.bluetooth;

import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;
import com.android.cts.verifier.TestResult;

import android.app.AlertDialog;
import android.bluetooth.BluetoothAdapter;
import android.bluetooth.BluetoothDevice;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.ArrayAdapter;
import android.widget.Button;
import android.widget.ListView;
import android.widget.ProgressBar;
import android.widget.TextView;
import android.widget.Toast;

import java.util.UUID;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

class MessageTestActivity extends PassFailButtons.Activity {

    /** Broadcast action that should only be fired when pairing for a secure connection. */
    private static final String ACTION_PAIRING_REQUEST =
            ""android.bluetooth.device.action.PAIRING_REQUEST"";

    private static final int ENABLE_BLUETOOTH_REQUEST = 1;
    private static final int PICK_SERVER_DEVICE_REQUEST = 2;

    private static final String MESSAGE_DELIMITER = ""\n"";
    private static final Pattern MESSAGE_PATTERN = Pattern.compile(""Message (\\d+) to .*"");

    private BluetoothAdapter mBluetoothAdapter;
    private PairingActionReceiver mPairingActionReceiver;
    private BluetoothChatService mChatService;

    private ArrayAdapter<String> mReceivedMessagesAdapter;
    private ArrayAdapter<String> mSentMessagesAdapter;

    private ListView mReceivedMessages;
    private ListView mSentMessages;

    private TextView mEmptyReceivedView;
    private TextView mEmptySentView;

    private AlertDialog mInstructionsDialog;

    private ProgressBar mProgressBar;

    private String mDeviceAddress;

    private final boolean mSecure;
    private final boolean mServer;
    private final UUID mUuid;

    private String mRemoteDeviceName = """";
    private StringBuilder mMessageBuffer = new StringBuilder();

    MessageTestActivity(boolean secure, boolean server, UUID uuid) {
        mSecure = secure;
        mServer = server;
        mUuid = uuid;
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.bt_messages);
        setPassFailButtonClickListeners();

        mProgressBar = (ProgressBar) findViewById(R.id.bt_progress_bar);

        if (mServer) {
            setTitle(mSecure ? R.string.bt_secure_server : R.string.bt_insecure_server);
        } else {
            setTitle(mSecure ? R.string.bt_secure_client : R.string.bt_insecure_client);
        }

        mReceivedMessages = (ListView) findViewById(R.id.bt_received_messages);
        mReceivedMessagesAdapter = new ArrayAdapter<String>(this, R.layout.bt_message_row);
        mReceivedMessages.setAdapter(mReceivedMessagesAdapter);

        mSentMessages = (ListView) findViewById(R.id.bt_sent_messages);
        mSentMessagesAdapter = new ArrayAdapter<String>(this, R.layout.bt_message_row);
        mSentMessages.setAdapter(mSentMessagesAdapter);

        mEmptyReceivedView = (TextView) findViewById(R.id.bt_empty_received_messages);
        mReceivedMessages.setEmptyView(mEmptyReceivedView);

        mEmptySentView = (TextView) findViewById(R.id.bt_empty_sent_messages);
        mSentMessages.setEmptyView(mEmptySentView);

        setEmptyViewText(R.string.bt_no_messages);

        Button makeDiscoverableButton = (Button) findViewById(R.id.bt_make_discoverable_button);
        makeDiscoverableButton.setVisibility(mServer ? View.VISIBLE : View.GONE);
        makeDiscoverableButton.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                makeDiscoverable();
            }
        });

        getPassButton().setEnabled(false);

        mPairingActionReceiver = new PairingActionReceiver();
        IntentFilter intentFilter = new IntentFilter(ACTION_PAIRING_REQUEST);
        registerReceiver(mPairingActionReceiver, intentFilter);

        mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
        if (!mServer) {
            Intent intent = new Intent(this, DevicePickerActivity.class);
            startActivityForResult(intent, PICK_SERVER_DEVICE_REQUEST);
        } else {
            if (mBluetoothAdapter.isEnabled()) {
                startChatService();
            } else {
                Intent intent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);
                startActivityForResult(intent, ENABLE_BLUETOOTH_REQUEST);
            }
        }
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        switch (requestCode) {
            case ENABLE_BLUETOOTH_REQUEST:
                if (resultCode == RESULT_OK) {
                    startChatService();
                } else {
                    setResult(RESULT_CANCELED);
                    finish();
                }
                break;

            case PICK_SERVER_DEVICE_REQUEST:
                if (resultCode == RESULT_OK) {
                    mDeviceAddress = data.getStringExtra(DevicePickerActivity.EXTRA_DEVICE_ADDRESS);
                    startChatService();
                } else {
                    setResult(RESULT_CANCELED);
                    finish();
                }
                break;
        }
    }

    private void startChatService() {
        mChatService = new BluetoothChatService(this, new ChatHandler(), mUuid);
        if (mServer) {
            mChatService.start(mSecure);
        } else {
            BluetoothDevice device = mBluetoothAdapter.getRemoteDevice(mDeviceAddress);
            mChatService.connect(device, mSecure);
        }
    }

    private void makeDiscoverable() {
        if (mBluetoothAdapter.getScanMode() !=
                BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE) {
            Intent intent = new Intent(BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE);
            intent.putExtra(BluetoothAdapter.EXTRA_DISCOVERABLE_DURATION, 30);
            startActivity(intent);
        }
    }

    private class ChatHandler extends Handler {
        @Override
        public void handleMessage(Message msg) {
            super.handleMessage(msg);
            switch (msg.what) {
                case BluetoothChatService.MESSAGE_STATE_CHANGE:
                    handleStateChange(msg);
                    break;
                case BluetoothChatService.MESSAGE_READ:
                    handleMessageRead(msg);
                    break;
                case BluetoothChatService.MESSAGE_WRITE:
                    handleMessageWrite(msg);
                    break;
                case BluetoothChatService.MESSAGE_DEVICE_NAME:
                    handleDeviceName(msg);
                    break;
                case BluetoothChatService.MESSAGE_TOAST:
                    handleToast(msg);
                    break;
            }
        }
    }

    private void handleStateChange(Message msg) {
        int state = msg.arg1;
        switch (state) {
            case BluetoothChatService.STATE_LISTEN:
                setEmptyViewText(R.string.bt_waiting);
                mProgressBar.setVisibility(View.VISIBLE);
                showInstructionsDialog();
                break;

            case BluetoothChatService.STATE_CONNECTING:
                setEmptyViewText(R.string.bt_connecting);
                mProgressBar.setVisibility(View.VISIBLE);
                break;

            case BluetoothChatService.STATE_CONNECTED:
                setEmptyViewText(R.string.bt_no_messages);
                mProgressBar.setVisibility(View.INVISIBLE);

                hideInstructionsDialog();
                sendInitialMessageFromClient();
                break;

            case BluetoothChatService.STATE_NONE:
                setEmptyViewText(R.string.bt_no_messages);
                mProgressBar.setVisibility(View.INVISIBLE);
                break;
        }
    }

    private void setEmptyViewText(int textId) {
        mEmptyReceivedView.setText(textId);
        mEmptySentView.setText(textId);
    }

    private void showInstructionsDialog() {
        if (mInstructionsDialog == null) {
            mInstructionsDialog = new AlertDialog.Builder(this)
                    .setIcon(android.R.drawable.ic_dialog_info)
                    .setTitle(getString(R.string.bt_waiting))
                    .setMessage(getString(mSecure
                            ? R.string.bt_secure_server_instructions
                            : R.string.bt_insecure_server_instructions))
                    .setPositiveButton(android.R.string.ok, null)
                    .create();
        }
        mInstructionsDialog.show();
    }

    private void hideInstructionsDialog() {
        if (mInstructionsDialog != null) {
            mInstructionsDialog.hide();
        }
    }

    private void sendInitialMessageFromClient() {
        if (!mServer) {
            sendMessage(0);
        }
    }

    private void sendMessage(int number) {
        String message = ""Message "" + number + "" to ""
                + (mRemoteDeviceName != null ? mRemoteDeviceName : """")
                + MESSAGE_DELIMITER;
        mChatService.write(message.getBytes());
    }

    private void handleMessageRead(Message msg) {
        String chunk = new String((byte[]) msg.obj, 0, msg.arg1);
        mMessageBuffer.append(chunk);

        int delimiterIndex = mMessageBuffer.indexOf(MESSAGE_DELIMITER);
        if (delimiterIndex != -1) {
            String message = mMessageBuffer.substring(0, delimiterIndex); // Chop off delimiter
            mMessageBuffer.delete(0, delimiterIndex + 1);
            addNewMessage(message);
        }
    }

    private void addNewMessage(String msg) {
        mReceivedMessagesAdapter.add(msg);
        Matcher matcher = MESSAGE_PATTERN.matcher(msg);
        if (matcher.matches()) {
            int number = Integer.valueOf(matcher.group(1));
            if (mServer && number == 10 || !mServer && number == 11) {
                getPassButton().setEnabled(true);
            }
            if (number <= 10) {
                sendMessage(number + 1);
            }
        }
    }

    private void handleMessageWrite(Message msg) {
        String sentMessage = new String((byte[]) msg.obj).trim(); // Chop off delimiter
        mSentMessagesAdapter.add(sentMessage);
    }

    private void handleDeviceName(Message msg) {
        mRemoteDeviceName = msg.getData().getString(BluetoothChatService.DEVICE_NAME);
    }

    private void handleToast(Message msg) {
        String toast = msg.getData().getString(BluetoothChatService.TOAST);
        Toast.makeText(this, toast, Toast.LENGTH_LONG).show();
    }

    class PairingActionReceiver extends BroadcastReceiver {
        @Override
        public void onReceive(Context context, Intent intent) {
            if (!mSecure && ACTION_PAIRING_REQUEST.equals(intent.getAction())) {
                runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        showPairingErrorDialog();
                    }
                });
            }
        }
    }

    private void showPairingErrorDialog() {
        new AlertDialog.Builder(MessageTestActivity.this)
            .setIcon(android.R.drawable.ic_dialog_alert)
            .setTitle(R.string.bt_insecure_pairing_error_title)
            .setMessage(R.string.bt_insecure_pairing_error_message)
            .setPositiveButton(android.R.string.ok,
                    new DialogInterface.OnClickListener() {
                @Override
                public void onClick(DialogInterface dialog, int which) {
                    TestResult.setFailedResult(MessageTestActivity.this, getTestId(), null);
                    finish();
                }
            })
            .setCancelable(false)
            .show();
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        if (mChatService != null) {
            mChatService.stop();
        }
        unregisterReceiver(mPairingActionReceiver);
    }
}"	""	""	"REQUEST_DISCOVERABLE"	""	""	""	""	""	""	""	""	""	""
"3.2.3.5  Conditional Application Intents"	"3.2.3.5"	"C-5-2"	"3.2.3.5/C-5-2"	"03020305.670502"	"""C-5-2] MUST honor the [‘android.bluetooth.adapter.action.REQUEST_DISCOVERABLE’](https://developer.android.com/reference/android/bluetooth/BluetoothAdapter#ACTION_REQUEST_DISCOVERABLE) intent and show a system activity that requests discoverable mode.  If device implementations support the DND feature, they:  """	""	""	"REQUEST_DISCOVERABLE ACTION_REQUEST_DISCOVERABLE android.bluetooth.adapter.action.REQUEST"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.bluetooth.MessageTestActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/bluetooth/MessageTestActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.bluetooth;

import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;
import com.android.cts.verifier.TestResult;

import android.app.AlertDialog;
import android.bluetooth.BluetoothAdapter;
import android.bluetooth.BluetoothDevice;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.ArrayAdapter;
import android.widget.Button;
import android.widget.ListView;
import android.widget.ProgressBar;
import android.widget.TextView;
import android.widget.Toast;

import java.util.UUID;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

class MessageTestActivity extends PassFailButtons.Activity {

    /** Broadcast action that should only be fired when pairing for a secure connection. */
    private static final String ACTION_PAIRING_REQUEST =
            ""android.bluetooth.device.action.PAIRING_REQUEST"";

    private static final int ENABLE_BLUETOOTH_REQUEST = 1;
    private static final int PICK_SERVER_DEVICE_REQUEST = 2;

    private static final String MESSAGE_DELIMITER = ""\n"";
    private static final Pattern MESSAGE_PATTERN = Pattern.compile(""Message (\\d+) to .*"");

    private BluetoothAdapter mBluetoothAdapter;
    private PairingActionReceiver mPairingActionReceiver;
    private BluetoothChatService mChatService;

    private ArrayAdapter<String> mReceivedMessagesAdapter;
    private ArrayAdapter<String> mSentMessagesAdapter;

    private ListView mReceivedMessages;
    private ListView mSentMessages;

    private TextView mEmptyReceivedView;
    private TextView mEmptySentView;

    private AlertDialog mInstructionsDialog;

    private ProgressBar mProgressBar;

    private String mDeviceAddress;

    private final boolean mSecure;
    private final boolean mServer;
    private final UUID mUuid;

    private String mRemoteDeviceName = """";
    private StringBuilder mMessageBuffer = new StringBuilder();

    MessageTestActivity(boolean secure, boolean server, UUID uuid) {
        mSecure = secure;
        mServer = server;
        mUuid = uuid;
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.bt_messages);
        setPassFailButtonClickListeners();

        mProgressBar = (ProgressBar) findViewById(R.id.bt_progress_bar);

        if (mServer) {
            setTitle(mSecure ? R.string.bt_secure_server : R.string.bt_insecure_server);
        } else {
            setTitle(mSecure ? R.string.bt_secure_client : R.string.bt_insecure_client);
        }

        mReceivedMessages = (ListView) findViewById(R.id.bt_received_messages);
        mReceivedMessagesAdapter = new ArrayAdapter<String>(this, R.layout.bt_message_row);
        mReceivedMessages.setAdapter(mReceivedMessagesAdapter);

        mSentMessages = (ListView) findViewById(R.id.bt_sent_messages);
        mSentMessagesAdapter = new ArrayAdapter<String>(this, R.layout.bt_message_row);
        mSentMessages.setAdapter(mSentMessagesAdapter);

        mEmptyReceivedView = (TextView) findViewById(R.id.bt_empty_received_messages);
        mReceivedMessages.setEmptyView(mEmptyReceivedView);

        mEmptySentView = (TextView) findViewById(R.id.bt_empty_sent_messages);
        mSentMessages.setEmptyView(mEmptySentView);

        setEmptyViewText(R.string.bt_no_messages);

        Button makeDiscoverableButton = (Button) findViewById(R.id.bt_make_discoverable_button);
        makeDiscoverableButton.setVisibility(mServer ? View.VISIBLE : View.GONE);
        makeDiscoverableButton.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                makeDiscoverable();
            }
        });

        getPassButton().setEnabled(false);

        mPairingActionReceiver = new PairingActionReceiver();
        IntentFilter intentFilter = new IntentFilter(ACTION_PAIRING_REQUEST);
        registerReceiver(mPairingActionReceiver, intentFilter);

        mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
        if (!mServer) {
            Intent intent = new Intent(this, DevicePickerActivity.class);
            startActivityForResult(intent, PICK_SERVER_DEVICE_REQUEST);
        } else {
            if (mBluetoothAdapter.isEnabled()) {
                startChatService();
            } else {
                Intent intent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);
                startActivityForResult(intent, ENABLE_BLUETOOTH_REQUEST);
            }
        }
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        switch (requestCode) {
            case ENABLE_BLUETOOTH_REQUEST:
                if (resultCode == RESULT_OK) {
                    startChatService();
                } else {
                    setResult(RESULT_CANCELED);
                    finish();
                }
                break;

            case PICK_SERVER_DEVICE_REQUEST:
                if (resultCode == RESULT_OK) {
                    mDeviceAddress = data.getStringExtra(DevicePickerActivity.EXTRA_DEVICE_ADDRESS);
                    startChatService();
                } else {
                    setResult(RESULT_CANCELED);
                    finish();
                }
                break;
        }
    }

    private void startChatService() {
        mChatService = new BluetoothChatService(this, new ChatHandler(), mUuid);
        if (mServer) {
            mChatService.start(mSecure);
        } else {
            BluetoothDevice device = mBluetoothAdapter.getRemoteDevice(mDeviceAddress);
            mChatService.connect(device, mSecure);
        }
    }

    private void makeDiscoverable() {
        if (mBluetoothAdapter.getScanMode() !=
                BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE) {
            Intent intent = new Intent(BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE);
            intent.putExtra(BluetoothAdapter.EXTRA_DISCOVERABLE_DURATION, 30);
            startActivity(intent);
        }
    }

    private class ChatHandler extends Handler {
        @Override
        public void handleMessage(Message msg) {
            super.handleMessage(msg);
            switch (msg.what) {
                case BluetoothChatService.MESSAGE_STATE_CHANGE:
                    handleStateChange(msg);
                    break;
                case BluetoothChatService.MESSAGE_READ:
                    handleMessageRead(msg);
                    break;
                case BluetoothChatService.MESSAGE_WRITE:
                    handleMessageWrite(msg);
                    break;
                case BluetoothChatService.MESSAGE_DEVICE_NAME:
                    handleDeviceName(msg);
                    break;
                case BluetoothChatService.MESSAGE_TOAST:
                    handleToast(msg);
                    break;
            }
        }
    }

    private void handleStateChange(Message msg) {
        int state = msg.arg1;
        switch (state) {
            case BluetoothChatService.STATE_LISTEN:
                setEmptyViewText(R.string.bt_waiting);
                mProgressBar.setVisibility(View.VISIBLE);
                showInstructionsDialog();
                break;

            case BluetoothChatService.STATE_CONNECTING:
                setEmptyViewText(R.string.bt_connecting);
                mProgressBar.setVisibility(View.VISIBLE);
                break;

            case BluetoothChatService.STATE_CONNECTED:
                setEmptyViewText(R.string.bt_no_messages);
                mProgressBar.setVisibility(View.INVISIBLE);

                hideInstructionsDialog();
                sendInitialMessageFromClient();
                break;

            case BluetoothChatService.STATE_NONE:
                setEmptyViewText(R.string.bt_no_messages);
                mProgressBar.setVisibility(View.INVISIBLE);
                break;
        }
    }

    private void setEmptyViewText(int textId) {
        mEmptyReceivedView.setText(textId);
        mEmptySentView.setText(textId);
    }

    private void showInstructionsDialog() {
        if (mInstructionsDialog == null) {
            mInstructionsDialog = new AlertDialog.Builder(this)
                    .setIcon(android.R.drawable.ic_dialog_info)
                    .setTitle(getString(R.string.bt_waiting))
                    .setMessage(getString(mSecure
                            ? R.string.bt_secure_server_instructions
                            : R.string.bt_insecure_server_instructions))
                    .setPositiveButton(android.R.string.ok, null)
                    .create();
        }
        mInstructionsDialog.show();
    }

    private void hideInstructionsDialog() {
        if (mInstructionsDialog != null) {
            mInstructionsDialog.hide();
        }
    }

    private void sendInitialMessageFromClient() {
        if (!mServer) {
            sendMessage(0);
        }
    }

    private void sendMessage(int number) {
        String message = ""Message "" + number + "" to ""
                + (mRemoteDeviceName != null ? mRemoteDeviceName : """")
                + MESSAGE_DELIMITER;
        mChatService.write(message.getBytes());
    }

    private void handleMessageRead(Message msg) {
        String chunk = new String((byte[]) msg.obj, 0, msg.arg1);
        mMessageBuffer.append(chunk);

        int delimiterIndex = mMessageBuffer.indexOf(MESSAGE_DELIMITER);
        if (delimiterIndex != -1) {
            String message = mMessageBuffer.substring(0, delimiterIndex); // Chop off delimiter
            mMessageBuffer.delete(0, delimiterIndex + 1);
            addNewMessage(message);
        }
    }

    private void addNewMessage(String msg) {
        mReceivedMessagesAdapter.add(msg);
        Matcher matcher = MESSAGE_PATTERN.matcher(msg);
        if (matcher.matches()) {
            int number = Integer.valueOf(matcher.group(1));
            if (mServer && number == 10 || !mServer && number == 11) {
                getPassButton().setEnabled(true);
            }
            if (number <= 10) {
                sendMessage(number + 1);
            }
        }
    }

    private void handleMessageWrite(Message msg) {
        String sentMessage = new String((byte[]) msg.obj).trim(); // Chop off delimiter
        mSentMessagesAdapter.add(sentMessage);
    }

    private void handleDeviceName(Message msg) {
        mRemoteDeviceName = msg.getData().getString(BluetoothChatService.DEVICE_NAME);
    }

    private void handleToast(Message msg) {
        String toast = msg.getData().getString(BluetoothChatService.TOAST);
        Toast.makeText(this, toast, Toast.LENGTH_LONG).show();
    }

    class PairingActionReceiver extends BroadcastReceiver {
        @Override
        public void onReceive(Context context, Intent intent) {
            if (!mSecure && ACTION_PAIRING_REQUEST.equals(intent.getAction())) {
                runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        showPairingErrorDialog();
                    }
                });
            }
        }
    }

    private void showPairingErrorDialog() {
        new AlertDialog.Builder(MessageTestActivity.this)
            .setIcon(android.R.drawable.ic_dialog_alert)
            .setTitle(R.string.bt_insecure_pairing_error_title)
            .setMessage(R.string.bt_insecure_pairing_error_message)
            .setPositiveButton(android.R.string.ok,
                    new DialogInterface.OnClickListener() {
                @Override
                public void onClick(DialogInterface dialog, int which) {
                    TestResult.setFailedResult(MessageTestActivity.this, getTestId(), null);
                    finish();
                }
            })
            .setCancelable(false)
            .show();
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        if (mChatService != null) {
            mChatService.stop();
        }
        unregisterReceiver(mPairingActionReceiver);
    }
}"	""	""	"ACTION_REQUEST_DISCOVERABLE"	""	""	""	""	""	""	""	""	""	""
"3.2.3.5  Conditional Application Intents"	"3.2.3.5"	"C-5-2"	"3.2.3.5/C-5-2"	"03020305.670502"	"""C-5-2] MUST honor the [‘android.bluetooth.adapter.action.REQUEST_DISCOVERABLE’](https://developer.android.com/reference/android/bluetooth/BluetoothAdapter#ACTION_REQUEST_DISCOVERABLE) intent and show a system activity that requests discoverable mode.  If device implementations support the DND feature, they:  """	""	""	"REQUEST_DISCOVERABLE ACTION_REQUEST_DISCOVERABLE android.bluetooth.adapter.action.REQUEST"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.bluetooth.MessageTestActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/bluetooth/MessageTestActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.bluetooth;

import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;
import com.android.cts.verifier.TestResult;

import android.app.AlertDialog;
import android.bluetooth.BluetoothAdapter;
import android.bluetooth.BluetoothDevice;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.ArrayAdapter;
import android.widget.Button;
import android.widget.ListView;
import android.widget.ProgressBar;
import android.widget.TextView;
import android.widget.Toast;

import java.util.UUID;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

class MessageTestActivity extends PassFailButtons.Activity {

    /** Broadcast action that should only be fired when pairing for a secure connection. */
    private static final String ACTION_PAIRING_REQUEST =
            ""android.bluetooth.device.action.PAIRING_REQUEST"";

    private static final int ENABLE_BLUETOOTH_REQUEST = 1;
    private static final int PICK_SERVER_DEVICE_REQUEST = 2;

    private static final String MESSAGE_DELIMITER = ""\n"";
    private static final Pattern MESSAGE_PATTERN = Pattern.compile(""Message (\\d+) to .*"");

    private BluetoothAdapter mBluetoothAdapter;
    private PairingActionReceiver mPairingActionReceiver;
    private BluetoothChatService mChatService;

    private ArrayAdapter<String> mReceivedMessagesAdapter;
    private ArrayAdapter<String> mSentMessagesAdapter;

    private ListView mReceivedMessages;
    private ListView mSentMessages;

    private TextView mEmptyReceivedView;
    private TextView mEmptySentView;

    private AlertDialog mInstructionsDialog;

    private ProgressBar mProgressBar;

    private String mDeviceAddress;

    private final boolean mSecure;
    private final boolean mServer;
    private final UUID mUuid;

    private String mRemoteDeviceName = """";
    private StringBuilder mMessageBuffer = new StringBuilder();

    MessageTestActivity(boolean secure, boolean server, UUID uuid) {
        mSecure = secure;
        mServer = server;
        mUuid = uuid;
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.bt_messages);
        setPassFailButtonClickListeners();

        mProgressBar = (ProgressBar) findViewById(R.id.bt_progress_bar);

        if (mServer) {
            setTitle(mSecure ? R.string.bt_secure_server : R.string.bt_insecure_server);
        } else {
            setTitle(mSecure ? R.string.bt_secure_client : R.string.bt_insecure_client);
        }

        mReceivedMessages = (ListView) findViewById(R.id.bt_received_messages);
        mReceivedMessagesAdapter = new ArrayAdapter<String>(this, R.layout.bt_message_row);
        mReceivedMessages.setAdapter(mReceivedMessagesAdapter);

        mSentMessages = (ListView) findViewById(R.id.bt_sent_messages);
        mSentMessagesAdapter = new ArrayAdapter<String>(this, R.layout.bt_message_row);
        mSentMessages.setAdapter(mSentMessagesAdapter);

        mEmptyReceivedView = (TextView) findViewById(R.id.bt_empty_received_messages);
        mReceivedMessages.setEmptyView(mEmptyReceivedView);

        mEmptySentView = (TextView) findViewById(R.id.bt_empty_sent_messages);
        mSentMessages.setEmptyView(mEmptySentView);

        setEmptyViewText(R.string.bt_no_messages);

        Button makeDiscoverableButton = (Button) findViewById(R.id.bt_make_discoverable_button);
        makeDiscoverableButton.setVisibility(mServer ? View.VISIBLE : View.GONE);
        makeDiscoverableButton.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                makeDiscoverable();
            }
        });

        getPassButton().setEnabled(false);

        mPairingActionReceiver = new PairingActionReceiver();
        IntentFilter intentFilter = new IntentFilter(ACTION_PAIRING_REQUEST);
        registerReceiver(mPairingActionReceiver, intentFilter);

        mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
        if (!mServer) {
            Intent intent = new Intent(this, DevicePickerActivity.class);
            startActivityForResult(intent, PICK_SERVER_DEVICE_REQUEST);
        } else {
            if (mBluetoothAdapter.isEnabled()) {
                startChatService();
            } else {
                Intent intent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);
                startActivityForResult(intent, ENABLE_BLUETOOTH_REQUEST);
            }
        }
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        switch (requestCode) {
            case ENABLE_BLUETOOTH_REQUEST:
                if (resultCode == RESULT_OK) {
                    startChatService();
                } else {
                    setResult(RESULT_CANCELED);
                    finish();
                }
                break;

            case PICK_SERVER_DEVICE_REQUEST:
                if (resultCode == RESULT_OK) {
                    mDeviceAddress = data.getStringExtra(DevicePickerActivity.EXTRA_DEVICE_ADDRESS);
                    startChatService();
                } else {
                    setResult(RESULT_CANCELED);
                    finish();
                }
                break;
        }
    }

    private void startChatService() {
        mChatService = new BluetoothChatService(this, new ChatHandler(), mUuid);
        if (mServer) {
            mChatService.start(mSecure);
        } else {
            BluetoothDevice device = mBluetoothAdapter.getRemoteDevice(mDeviceAddress);
            mChatService.connect(device, mSecure);
        }
    }

    private void makeDiscoverable() {
        if (mBluetoothAdapter.getScanMode() !=
                BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE) {
            Intent intent = new Intent(BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE);
            intent.putExtra(BluetoothAdapter.EXTRA_DISCOVERABLE_DURATION, 30);
            startActivity(intent);
        }
    }

    private class ChatHandler extends Handler {
        @Override
        public void handleMessage(Message msg) {
            super.handleMessage(msg);
            switch (msg.what) {
                case BluetoothChatService.MESSAGE_STATE_CHANGE:
                    handleStateChange(msg);
                    break;
                case BluetoothChatService.MESSAGE_READ:
                    handleMessageRead(msg);
                    break;
                case BluetoothChatService.MESSAGE_WRITE:
                    handleMessageWrite(msg);
                    break;
                case BluetoothChatService.MESSAGE_DEVICE_NAME:
                    handleDeviceName(msg);
                    break;
                case BluetoothChatService.MESSAGE_TOAST:
                    handleToast(msg);
                    break;
            }
        }
    }

    private void handleStateChange(Message msg) {
        int state = msg.arg1;
        switch (state) {
            case BluetoothChatService.STATE_LISTEN:
                setEmptyViewText(R.string.bt_waiting);
                mProgressBar.setVisibility(View.VISIBLE);
                showInstructionsDialog();
                break;

            case BluetoothChatService.STATE_CONNECTING:
                setEmptyViewText(R.string.bt_connecting);
                mProgressBar.setVisibility(View.VISIBLE);
                break;

            case BluetoothChatService.STATE_CONNECTED:
                setEmptyViewText(R.string.bt_no_messages);
                mProgressBar.setVisibility(View.INVISIBLE);

                hideInstructionsDialog();
                sendInitialMessageFromClient();
                break;

            case BluetoothChatService.STATE_NONE:
                setEmptyViewText(R.string.bt_no_messages);
                mProgressBar.setVisibility(View.INVISIBLE);
                break;
        }
    }

    private void setEmptyViewText(int textId) {
        mEmptyReceivedView.setText(textId);
        mEmptySentView.setText(textId);
    }

    private void showInstructionsDialog() {
        if (mInstructionsDialog == null) {
            mInstructionsDialog = new AlertDialog.Builder(this)
                    .setIcon(android.R.drawable.ic_dialog_info)
                    .setTitle(getString(R.string.bt_waiting))
                    .setMessage(getString(mSecure
                            ? R.string.bt_secure_server_instructions
                            : R.string.bt_insecure_server_instructions))
                    .setPositiveButton(android.R.string.ok, null)
                    .create();
        }
        mInstructionsDialog.show();
    }

    private void hideInstructionsDialog() {
        if (mInstructionsDialog != null) {
            mInstructionsDialog.hide();
        }
    }

    private void sendInitialMessageFromClient() {
        if (!mServer) {
            sendMessage(0);
        }
    }

    private void sendMessage(int number) {
        String message = ""Message "" + number + "" to ""
                + (mRemoteDeviceName != null ? mRemoteDeviceName : """")
                + MESSAGE_DELIMITER;
        mChatService.write(message.getBytes());
    }

    private void handleMessageRead(Message msg) {
        String chunk = new String((byte[]) msg.obj, 0, msg.arg1);
        mMessageBuffer.append(chunk);

        int delimiterIndex = mMessageBuffer.indexOf(MESSAGE_DELIMITER);
        if (delimiterIndex != -1) {
            String message = mMessageBuffer.substring(0, delimiterIndex); // Chop off delimiter
            mMessageBuffer.delete(0, delimiterIndex + 1);
            addNewMessage(message);
        }
    }

    private void addNewMessage(String msg) {
        mReceivedMessagesAdapter.add(msg);
        Matcher matcher = MESSAGE_PATTERN.matcher(msg);
        if (matcher.matches()) {
            int number = Integer.valueOf(matcher.group(1));
            if (mServer && number == 10 || !mServer && number == 11) {
                getPassButton().setEnabled(true);
            }
            if (number <= 10) {
                sendMessage(number + 1);
            }
        }
    }

    private void handleMessageWrite(Message msg) {
        String sentMessage = new String((byte[]) msg.obj).trim(); // Chop off delimiter
        mSentMessagesAdapter.add(sentMessage);
    }

    private void handleDeviceName(Message msg) {
        mRemoteDeviceName = msg.getData().getString(BluetoothChatService.DEVICE_NAME);
    }

    private void handleToast(Message msg) {
        String toast = msg.getData().getString(BluetoothChatService.TOAST);
        Toast.makeText(this, toast, Toast.LENGTH_LONG).show();
    }

    class PairingActionReceiver extends BroadcastReceiver {
        @Override
        public void onReceive(Context context, Intent intent) {
            if (!mSecure && ACTION_PAIRING_REQUEST.equals(intent.getAction())) {
                runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        showPairingErrorDialog();
                    }
                });
            }
        }
    }

    private void showPairingErrorDialog() {
        new AlertDialog.Builder(MessageTestActivity.this)
            .setIcon(android.R.drawable.ic_dialog_alert)
            .setTitle(R.string.bt_insecure_pairing_error_title)
            .setMessage(R.string.bt_insecure_pairing_error_message)
            .setPositiveButton(android.R.string.ok,
                    new DialogInterface.OnClickListener() {
                @Override
                public void onClick(DialogInterface dialog, int which) {
                    TestResult.setFailedResult(MessageTestActivity.this, getTestId(), null);
                    finish();
                }
            })
            .setCancelable(false)
            .show();
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        if (mChatService != null) {
            mChatService.stop();
        }
        unregisterReceiver(mPairingActionReceiver);
    }
}"	""	""	"ACTION_REQUEST_DISCOVERABLE"	""	""	""	""	""	""	""	""	""	""
