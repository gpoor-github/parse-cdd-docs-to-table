"Section"	"section_id"	"req_id"	"full_key"	"key_as_number"	"requirement"	"Test Availability"	"search_roots"	"search_terms"	"manual_search_terms"	"not_search_terms"	"not_files"	"max_matches"	"class_defs"	"methods"	"modules"	"protected"	"class_def"	"method"	"module"	"file_name"	"matched_files"	"methods_string"	"urls"	"method_text"	"matched_terms"	"qualified_method"	"Annotation?"	"New Req for S?"	"New CTS for S?"	"Comment(internal) e.g. why a test is not possible"	"CTS Bug Id"	"CDD Bug Id"	"Area"	"Shortened"	"Test Level"
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.passpoint.cts.PasspointConfigurationTest"	"testEqualUniqueId"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/passpoint/cts/PasspointConfigurationTest.java"	""	"public void testEqualUniqueId() throws Exception {
        PasspointConfiguration config1 = createConfig();
        PasspointConfiguration config2 = createConfig();

        assertEquals(config1.getUniqueId(), config2.getUniqueId());
    }

    /**
     * Verify that the unique identifier generated is the same for two instances with different
     * HomeSp node but same FQDN
     */"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.passpoint.cts.PasspointConfigurationTest"	"testUniqueIdSameHomeSpSameFqdn"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/passpoint/cts/PasspointConfigurationTest.java"	""	"public void testUniqueIdSameHomeSpSameFqdn() throws Exception {
        PasspointConfiguration config1 = createConfig();
        HomeSp homeSp = config1.getHomeSp();
        homeSp.setMatchAnyOis(new long[]{0x1000, 0x2000});

        // Modify config2's RCOIs and friendly name to a different set of values
        PasspointConfiguration config2 = createConfig();
        homeSp = config2.getHomeSp();

        homeSp.setRoamingConsortiumOis(new long[]{0xaa, 0xbb});
        homeSp.setFriendlyName(""Some other name"");
        homeSp.setOtherHomePartnersList(Arrays.asList(""other-provider1"", ""other-provider2""));
        homeSp.setMatchAllOis(new long[]{0x1000, 0x2000});
        config2.setHomeSp(homeSp);

        assertEquals(config1.getUniqueId(), config2.getUniqueId());
    }

    /**
     * Verify that the unique identifier generated is different for two instances with the same
     * HomeSp node but different FQDN
     */"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.passpoint.cts.PasspointConfigurationTest"	"testUniqueIdDifferentHomeSpDifferentFqdn"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/passpoint/cts/PasspointConfigurationTest.java"	""	"public void testUniqueIdDifferentHomeSpDifferentFqdn() throws Exception {
        PasspointConfiguration config1 = createConfig();

        // Modify config2's FQDN to a different value
        PasspointConfiguration config2 = createConfig();
        HomeSp homeSp = config2.getHomeSp();
        homeSp.setFqdn(""fqdn2.com"");
        config2.setHomeSp(homeSp);

        assertNotEquals(config1.getUniqueId(), config2.getUniqueId());
    }

    /**
     * Verify that the unique identifier generated is different for two instances with different
     * SIM Credential node
     */"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.passpoint.cts.PasspointConfigurationTest"	"testUniqueIdDifferentSimCredential"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/passpoint/cts/PasspointConfigurationTest.java"	""	"public void testUniqueIdDifferentSimCredential() throws Exception {
        PasspointConfiguration config1 = createConfig();

        // Modify config2's realm and SIM credential to a different set of values
        PasspointConfiguration config2 = createConfig();
        Credential credential = config2.getCredential();
        credential.setRealm(""realm2.example.com"");
        credential.getSimCredential().setImsi(""350460*"");
        config2.setCredential(credential);

        assertNotEquals(config1.getUniqueId(), config2.getUniqueId());
    }

    /**
     * Verify that the unique identifier generated is different for two instances with different
     * Realm in the Credential node
     */"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.passpoint.cts.PasspointConfigurationTest"	"testUniqueIdDifferentRealm"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/passpoint/cts/PasspointConfigurationTest.java"	""	"public void testUniqueIdDifferentRealm() throws Exception {
        PasspointConfiguration config1 = createConfig();

        // Modify config2's realm to a different set of values
        PasspointConfiguration config2 = createConfig();
        Credential credential = config2.getCredential();
        credential.setRealm(""realm2.example.com"");
        config2.setCredential(credential);

        assertNotEquals(config1.getUniqueId(), config2.getUniqueId());
    }

    /**
     * Verify that the unique identifier generated is the same for two instances with different
     * password and same username in the User Credential node
     */"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.passpoint.cts.PasspointConfigurationTest"	"testUniqueIdSameUserInUserCredential"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/passpoint/cts/PasspointConfigurationTest.java"	""	"public void testUniqueIdSameUserInUserCredential() throws Exception {
        PasspointConfiguration config1 = createConfig();
        Credential credential = createCredentialWithUserCredential(""user"", ""passwd"");
        config1.setCredential(credential);

        // Modify config2's Passpowrd to a different set of values
        PasspointConfiguration config2 = createConfig();
        credential = createCredentialWithUserCredential(""user"", ""newpasswd"");
        config2.setCredential(credential);

        assertEquals(config1.getUniqueId(), config2.getUniqueId());
    }

    /**
     * Verify that the unique identifier generated is different for two instances with different
     * username in the User Credential node
     */"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.passpoint.cts.PasspointConfigurationTest"	"testUniqueIdDifferentUserCredential"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/passpoint/cts/PasspointConfigurationTest.java"	""	"public void testUniqueIdDifferentUserCredential() throws Exception {
        PasspointConfiguration config1 = createConfig();
        Credential credential = createCredentialWithUserCredential(""user"", ""passwd"");
        config1.setCredential(credential);

        // Modify config2's username to a different value
        PasspointConfiguration config2 = createConfig();
        credential = createCredentialWithUserCredential(""user2"", ""passwd"");
        config2.setCredential(credential);

        assertNotEquals(config1.getUniqueId(), config2.getUniqueId());
    }

    /**
     * Verify that the unique identifier generated is different for two instances with different
     * Cert Credential node
     */"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.passpoint.cts.PasspointConfigurationTest"	"testUniqueIdDifferentCertCredential"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/passpoint/cts/PasspointConfigurationTest.java"	""	"public void testUniqueIdDifferentCertCredential() throws Exception {
        PasspointConfiguration config1 = createConfig();
        Credential credential = createCredentialWithCertificateCredential(true, true);
        config1.setCredential(credential);

        // Modify config2's cert credential to a different set of values
        PasspointConfiguration config2 = createConfig();
        credential = createCredentialWithCertificateCredential(false, false);
        config2.setCredential(credential);

        assertNotEquals(config1.getUniqueId(), config2.getUniqueId());
    }

    /**
     * Verify that the set and get decorated identity prefix methods work as expected.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.passpoint.cts.PasspointConfigurationTest"	"testSetGetDecoratedIdentityPrefix"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/passpoint/cts/PasspointConfigurationTest.java"	""	"public void testSetGetDecoratedIdentityPrefix() throws Exception {
        PasspointConfiguration config = createConfig();
        assertNull(config.getDecoratedIdentityPrefix());
        config.setDecoratedIdentityPrefix(TEST_DECORATED_IDENTITY_PREFIX);
        assertEquals(TEST_DECORATED_IDENTITY_PREFIX, config.getDecoratedIdentityPrefix());

    }

    /**
     * Helper function for generating user credential for testing.
     *
     * @return {@link Credential}
     */
    private static Credential createCredentialWithUserCredential(String username, String password) {
        Credential.UserCredential userCred = new Credential.UserCredential();
        userCred.setUsername(username);
        userCred.setPassword(password);
        userCred.setEapType(EAP_TTLS);
        userCred.setNonEapInnerMethod(""MS-CHAP"");
        return createCredential(userCred, null, null, null, null, FakeKeys.CA_CERT0);
    }

    /**
     * Helper function for generating Credential for testing.
     *
     * @param userCred               Instance of UserCredential
     * @param certCred               Instance of CertificateCredential
     * @param simCred                Instance of SimCredential
     * @param clientCertificateChain Chain of client certificates
     * @param clientPrivateKey       Client private key
     * @param caCerts                CA certificates
     * @return {@link Credential}
     */
    private static Credential createCredential(Credential.UserCredential userCred,
            Credential.CertificateCredential certCred,
            Credential.SimCredential simCred,
            X509Certificate[] clientCertificateChain, PrivateKey clientPrivateKey,
            X509Certificate... caCerts) {
        Credential cred = new Credential();
        cred.setRealm(""realm"");
        cred.setUserCredential(userCred);
        cred.setCertCredential(certCred);
        cred.setSimCredential(simCred);
        cred.setCaCertificate(caCerts[0]);
        cred.setClientCertificateChain(clientCertificateChain);
        cred.setClientPrivateKey(clientPrivateKey);
        return cred;
    }

    /**
     * Helper function for generating certificate credential for testing.
     *
     * @return {@link Credential}
     */
    private static Credential createCredentialWithCertificateCredential(Boolean useCaCert0,
            Boolean useCert0)
            throws NoSuchAlgorithmException, CertificateEncodingException {
        Credential.CertificateCredential certCred = new Credential.CertificateCredential();
        certCred.setCertType(""x509v3"");
        if (useCert0) {
            certCred.setCertSha256Fingerprint(
                    MessageDigest.getInstance(""SHA-256"").digest(FakeKeys.CLIENT_CERT.getEncoded()));
        } else {
            certCred.setCertSha256Fingerprint(MessageDigest.getInstance(""SHA-256"")
                    .digest(FakeKeys.CLIENT_SUITE_B_RSA3072_CERT.getEncoded()));
        }
        return createCredential(null, certCred, null, new X509Certificate[]{FakeKeys.CLIENT_CERT},
                FakeKeys.RSA_KEY1, useCaCert0 ? FakeKeys.CA_CERT0 : FakeKeys.CA_CERT1);
    }

    /**
     * Helper function for creating a {@link PasspointConfiguration} for testing.
     *
     * @return {@link PasspointConfiguration}
     */
    private static PasspointConfiguration createConfig() {
        PasspointConfiguration config = new PasspointConfiguration();
        config.setHomeSp(createHomeSp());
        config.setCredential(createCredential());
        Map<String, byte[]> trustRootCertList = new HashMap<>();
        trustRootCertList.put(""trustRoot.cert1.com"",
                new byte[CERTIFICATE_FINGERPRINT_BYTES]);
        trustRootCertList.put(""trustRoot.cert2.com"",
                new byte[CERTIFICATE_FINGERPRINT_BYTES]);
        return config;
    }

    /**
     * Utility function for creating a {@link android.net.wifi.hotspot2.pps.HomeSp} for testing.
     *
     * @return {@link android.net.wifi.hotspot2.pps.HomeSp}
     */
    private static HomeSp createHomeSp() {
        HomeSp homeSp = new HomeSp();
        homeSp.setFqdn(""fqdn"");
        homeSp.setFriendlyName(""friendly name"");
        homeSp.setRoamingConsortiumOis(new long[]{0x55, 0x66});
        return homeSp;
    }

    /**
     * Utility function for creating a {@link android.net.wifi.hotspot2.pps.Credential} for
     * testing..
     *
     * @return {@link android.net.wifi.hotspot2.pps.Credential}
     */
    private static Credential createCredential() {
        Credential cred = new Credential();
        cred.setRealm(""realm"");
        cred.setUserCredential(null);
        cred.setCertCredential(null);
        cred.setSimCredential(new Credential.SimCredential());
        cred.getSimCredential().setImsi(""1234*"");
        cred.getSimCredential().setEapType(EAP_SIM);
        cred.setCaCertificate(null);
        cred.setClientCertificateChain(null);
        cred.setClientPrivateKey(null);
        return cred;
    }
}"	""	""	"passpoint wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.p2p.cts.WifiP2pWfdInfoTest"	"testWifiP2pWfdInfo"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/p2p/cts/WifiP2pWfdInfoTest.java"	""	"public void testWifiP2pWfdInfo() {
        WifiP2pWfdInfo info = new WifiP2pWfdInfo();

        info.setDeviceType(TEST_DEVICE_TYPE);
        info.setEnabled(TEST_DEVICE_ENABLE_STATUS);
        info.setSessionAvailable(true);
        info.setControlPort(TEST_CONTROL_PORT);
        info.setMaxThroughput(TEST_MAX_THROUGHPUT);
        info.setContentProtectionSupported(true);

        WifiP2pWfdInfo copiedInfo = new WifiP2pWfdInfo(info);
        assertEquals(TEST_DEVICE_TYPE, copiedInfo.getDeviceType());
        assertEquals(TEST_DEVICE_ENABLE_STATUS, copiedInfo.isEnabled());
        assertEquals(TEST_SESSION_STATUS, copiedInfo.isSessionAvailable());
        assertEquals(TEST_CONTROL_PORT, copiedInfo.getControlPort());
        assertEquals(TEST_MAX_THROUGHPUT, copiedInfo.getMaxThroughput());
        assertEquals(TEST_CONTENT_PROTECTION_SUPPORTED_STATUS,
                copiedInfo.isContentProtectionSupported());
    }

    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.p2p.cts.WifiP2pWfdInfoTest"	"testWifiCoupledSink"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/p2p/cts/WifiP2pWfdInfoTest.java"	""	"public void testWifiCoupledSink() {
        WifiP2pWfdInfo info = new WifiP2pWfdInfo();

        assertFalse(info.isCoupledSinkSupportedAtSink());
        info.setCoupledSinkSupportAtSink(true);
        assertTrue(info.isCoupledSinkSupportedAtSink());

        assertFalse(info.isCoupledSinkSupportedAtSource());
        info.setCoupledSinkSupportAtSource(true);
        assertTrue(info.isCoupledSinkSupportedAtSource());
    }

    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.p2p.cts.WifiP2pWfdInfoTest"	"testWifiP2pWfdR2Info"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/p2p/cts/WifiP2pWfdInfoTest.java"	""	"public void testWifiP2pWfdR2Info() {
        WifiP2pWfdInfo info = new WifiP2pWfdInfo();

        info.setR2DeviceType(WifiP2pWfdInfo.DEVICE_TYPE_WFD_SOURCE);
        assertEquals(WifiP2pWfdInfo.DEVICE_TYPE_WFD_SOURCE, info.getR2DeviceType());
        assertTrue(info.isR2Supported());

        assertEquals(WifiP2pWfdInfo.DEVICE_TYPE_WFD_SOURCE, info.getR2DeviceInfo());
    }

    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.p2p.cts.WifiP2pWfdInfoTest"	"testWifiP2pWfdDeviceInfo"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/p2p/cts/WifiP2pWfdInfoTest.java"	""	"public void testWifiP2pWfdDeviceInfo() {
        WifiP2pWfdInfo info = new WifiP2pWfdInfo();
        info.setDeviceType(WifiP2pWfdInfo.DEVICE_TYPE_WFD_SOURCE);
        assertEquals(WifiP2pWfdInfo.DEVICE_TYPE_WFD_SOURCE, info.getDeviceInfo());
    }
}"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.wifiaware.testcase.DataPathOutOfBandTestCase"	"executeTest"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/wifiaware/testcase/DataPathOutOfBandTestCase.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.wifiaware.testcase;

import static com.android.cts.verifier.wifiaware.CallbackUtils.CALLBACK_TIMEOUT_SEC;

import android.content.Context;
import android.net.ConnectivityManager;
import android.net.Network;
import android.net.NetworkCapabilities;
import android.net.NetworkRequest;
import android.net.wifi.aware.DiscoverySession;
import android.net.wifi.aware.PeerHandle;
import android.net.wifi.aware.PublishConfig;
import android.net.wifi.aware.PublishDiscoverySession;
import android.net.wifi.aware.SubscribeConfig;
import android.net.wifi.aware.SubscribeDiscoverySession;
import android.net.wifi.aware.WifiAwareManager;
import android.net.wifi.aware.WifiAwareSession;
import android.util.Log;
import android.util.Pair;

import com.android.cts.verifier.R;
import com.android.cts.verifier.wifiaware.BaseTestCase;
import com.android.cts.verifier.wifiaware.CallbackUtils;

/**
 *Test case for data-path, out-of-band (OOB) test cases:
 * open/passphrase * responder/initiator.
 *
 * OOB assumes that there's an alternative channel over which to communicate the discovery MAC
 * address of the Aware interface. That channel (e.g. bluetooth or a host test device) is not
 * readily available (don't want to have Aware tests dependent on BLE). Instead will fake the OOB
 * channel using Aware itself: will do normal discovery during which the devices will exchange their
 * MAC addresses, then destroy the discovery sessions and use the MAC addresses to perform OOB data-
 * path requests.
 *
 * Responder test sequence:
 * 1. Attach (with identity listener)
 *    wait for results (session)
 *    wait for identity
 * 2. Publish
 *    wait for results (publish session)
 * 3. Wait for rx message (with MAC)
 * 4. Send message with MAC
 *    wait for success
 * 5. Destroy discovery session
 * 6. Request network (as Responder)
 *    wait for network
 *
 * Initiator test sequence:
 * 1. Attach (with identity listener)
 *    wait for results (session)
 *    wait for identity
 * 2. Subscribe
 *    wait for results (subscribe session)
 * 3. Wait for discovery
 * 4. Send message with MAC
 *    wait for success
 * 5. Wait for rx message (with MAC)
 * 6. Destroy discovery session
 * 7. Sleep for 5 seconds to let Responder time to set up
 * 8. Request network (as Initiator)
 *    wait for network
 */
public class DataPathOutOfBandTestCase extends BaseTestCase {
    private static final String TAG = ""DataPathOutOfBandTestCase"";
    private static final boolean DBG = true;

    private static final int MAC_BYTES_LEN = 6;

    private static final String SERVICE_NAME = ""CtsVerifierTestService"";
    private static final String PASSPHRASE = ""Some super secret password"";
    private static final int MESSAGE_ID = 1234;

    private boolean mIsSecurityOpen;
    private boolean mIsResponder;

    private final Object mLock = new Object();

    private String mFailureReason;
    private WifiAwareSession mWifiAwareSession;
    private DiscoverySession mWifiAwareDiscoverySession;
    private byte[] mDiscoveryMac;

    private static int sSDKLevel = android.os.Build.VERSION.SDK_INT;

    public DataPathOutOfBandTestCase(Context context, boolean isSecurityOpen,
            boolean isResponder) {
        super(context);
        mIsSecurityOpen = isSecurityOpen;
        mIsResponder = isResponder;
    }

    @Override
    protected boolean executeTest() throws InterruptedException {
        if (DBG) {
            Log.d(TAG, ""executeTest: mIsSecurityOpen="" + mIsSecurityOpen + "", mIsResponder=""
                    + mIsResponder);
        }

        // 1. attach (with identity listener)
        CallbackUtils.AttachCb attachCb = new CallbackUtils.AttachCb();
        CallbackUtils.IdentityListenerSingleShot identityL = new CallbackUtils
                .IdentityListenerSingleShot();
        mWifiAwareManager.attach(attachCb, identityL, mHandler);
        Pair<Integer, WifiAwareSession> results = attachCb.waitForAttach();
        switch (results.first) {
            case CallbackUtils.AttachCb.TIMEOUT:
                setFailureReason(mContext.getString(R.string.aware_status_attach_timeout));
                Log.e(TAG, ""executeTest: attach TIMEOUT"");
                return false;
            case CallbackUtils.AttachCb.ON_ATTACH_FAILED:
                setFailureReason(mContext.getString(R.string.aware_status_attach_fail));
                Log.e(TAG, ""executeTest: attach ON_ATTACH_FAILED"");
                return false;
        }
        mWifiAwareSession = results.second;
        if (mWifiAwareSession == null) {
            setFailureReason(mContext.getString(R.string.aware_status_attach_fail));
            Log.e(TAG, ""executeTest: attach callback succeeded but null session returned!?"");
            return false;
        }
        mListener.onTestMsgReceived(mContext.getString(R.string.aware_status_attached));
        if (DBG) {
            Log.d(TAG, ""executeTest: attach succeeded"");
        }
        mDiscoveryMac = identityL.waitForMac();
        if (mDiscoveryMac == null) {
            setFailureReason(mContext.getString(R.string.aware_status_identity_fail));
            Log.e(TAG, ""executeTest: identity callback not triggered"");
            return false;
        }
        mListener.onTestMsgReceived(mResources.getString(R.string.aware_status_identity,
                bytesToHex(mDiscoveryMac, ':')));
        if (DBG) {
            Log.d(TAG, ""executeTest: identity received: "" + bytesToHex(mDiscoveryMac, ':'));
        }

        if (mIsResponder) {
            return executeTestResponder();
        } else {
            return executeTestInitiator();
        }
    }

    private void setFailureReason(String reason) {
        synchronized (mLock) {
            mFailureReason = reason;
        }
    }

    @Override
    protected String getFailureReason() {
        synchronized (mLock) {
            return mFailureReason;
        }
    }

    @Override
    protected void tearDown() {
        if (mWifiAwareDiscoverySession != null) {
            mWifiAwareDiscoverySession.close();
            mWifiAwareDiscoverySession = null;
        }
        if (mWifiAwareSession != null) {
            mWifiAwareSession.close();
            mWifiAwareSession = null;
        }
        super.tearDown();
    }

    private boolean executeTestResponder() throws InterruptedException {
        if (DBG) Log.d(TAG, ""executeTestResponder"");
        CallbackUtils.DiscoveryCb discoveryCb = new CallbackUtils.DiscoveryCb();

        // 2. publish
        PublishConfig publishConfig = new PublishConfig.Builder().setServiceName(
                SERVICE_NAME).build();
        if (DBG) Log.d(TAG, ""executeTestResponder: publishConfig="" + publishConfig);
        mWifiAwareSession.publish(publishConfig, discoveryCb, mHandler);

        //    wait for results - publish session
        CallbackUtils.DiscoveryCb.CallbackData callbackData = discoveryCb.waitForCallbacks(
                CallbackUtils.DiscoveryCb.ON_PUBLISH_STARTED
                        | CallbackUtils.DiscoveryCb.ON_SESSION_CONFIG_FAILED);
        switch (callbackData.callback) {
            case CallbackUtils.DiscoveryCb.TIMEOUT:
                setFailureReason(mContext.getString(R.string.aware_status_publish_timeout));
                Log.e(TAG, ""executeTestResponder: publish TIMEOUT"");
                return false;
            case CallbackUtils.DiscoveryCb.ON_SESSION_CONFIG_FAILED:
                setFailureReason(mContext.getString(R.string.aware_status_publish_failed));
                Log.e(TAG, ""executeTestResponder: publish ON_SESSION_CONFIG_FAILED"");
                return false;
        }
        PublishDiscoverySession discoverySession = callbackData.publishDiscoverySession;
        mWifiAwareDiscoverySession = discoverySession;
        if (discoverySession == null) {
            setFailureReason(mContext.getString(R.string.aware_status_publish_null_session));
            Log.e(TAG, ""executeTestResponder: publish succeeded but null session returned"");
            return false;
        }
        mListener.onTestMsgReceived(mContext.getString(R.string.aware_status_publish_started));
        if (DBG) Log.d(TAG, ""executeTestResponder: publish succeeded"");

        // 3. Wait for rx message (with MAC)
        callbackData = discoveryCb.waitForCallbacks(CallbackUtils.DiscoveryCb.ON_MESSAGE_RECEIVED);
        switch (callbackData.callback) {
            case CallbackUtils.DiscoveryCb.TIMEOUT:
                setFailureReason(mContext.getString(R.string.aware_status_receive_timeout));
                Log.e(TAG, ""executeTestResponder: receive message TIMEOUT"");
                return false;
        }

        if (callbackData.serviceSpecificInfo == null
                || callbackData.serviceSpecificInfo.length != MAC_BYTES_LEN) {
            setFailureReason(mContext.getString(R.string.aware_status_receive_failure));
            Log.e(TAG, ""executeTestResponder: receive message message content mismatch: ""
                    + bytesToHex(callbackData.serviceSpecificInfo, ':'));
            return false;
        }

        PeerHandle peerHandle = callbackData.peerHandle;
        byte[] peerMac = callbackData.serviceSpecificInfo;

        mListener.onTestMsgReceived(mResources.getString(R.string.aware_status_received_mac,
                bytesToHex(peerMac, ':')));
        if (DBG) {
            Log.d(TAG, ""executeTestResponder: received MAC address: "" + bytesToHex(peerMac, ':'));
        }

        // 4. Send message with MAC and wait for success
        discoverySession.sendMessage(peerHandle, MESSAGE_ID, mDiscoveryMac);
        callbackData = discoveryCb.waitForCallbacks(
                CallbackUtils.DiscoveryCb.ON_MESSAGE_SEND_SUCCEEDED
                        | CallbackUtils.DiscoveryCb.ON_MESSAGE_SEND_FAILED);
        switch (callbackData.callback) {
            case CallbackUtils.DiscoveryCb.TIMEOUT:
                setFailureReason(mContext.getString(R.string.aware_status_send_timeout));
                Log.e(TAG, ""executeTestResponder: send message TIMEOUT"");
                return false;
            case CallbackUtils.DiscoveryCb.ON_MESSAGE_SEND_FAILED:
                setFailureReason(mContext.getString(R.string.aware_status_send_failed));
                Log.e(TAG, ""executeTestResponder: send message ON_MESSAGE_SEND_FAILED"");
                return false;
        }
        mListener.onTestMsgReceived(mContext.getString(R.string.aware_status_send_success));
        if (DBG) Log.d(TAG, ""executeTestResponder: send message succeeded"");

        if (callbackData.messageId != MESSAGE_ID) {
            setFailureReason(mContext.getString(R.string.aware_status_send_fail_parameter));
            Log.e(TAG, ""executeTestResponder: send message message ID mismatch: ""
                    + callbackData.messageId);
            return false;
        }

        // 5. Destroy discovery session
        discoverySession.close();
        mWifiAwareDiscoverySession = null;

        // 6. Request network (as Responder) and wait for network
        ConnectivityManager cm = (ConnectivityManager) mContext.getSystemService(
                Context.CONNECTIVITY_SERVICE);
        NetworkRequest nr = new NetworkRequest.Builder().addTransportType(
                NetworkCapabilities.TRANSPORT_WIFI_AWARE).setNetworkSpecifier(
                mIsSecurityOpen ? mWifiAwareSession.createNetworkSpecifierOpen(
                        WifiAwareManager.WIFI_AWARE_DATA_PATH_ROLE_RESPONDER, peerMac)
                        : mWifiAwareSession.createNetworkSpecifierPassphrase(
                                WifiAwareManager.WIFI_AWARE_DATA_PATH_ROLE_RESPONDER, peerMac,
                                PASSPHRASE)).build();
        CallbackUtils.NetworkCb networkCb = new CallbackUtils.NetworkCb();
        cm.requestNetwork(nr, networkCb, CALLBACK_TIMEOUT_SEC * 1000);
        mListener.onTestMsgReceived(mContext.getString(R.string.aware_status_network_requested));
        if (DBG) Log.d(TAG, ""executeTestResponder: requested network"");
        Pair<Network, NetworkCapabilities> info = networkCb.waitForNetworkCapabilities();

        // 7. Sleep for 5 second for Initiator to get NetworkCapabilities.
        Thread.sleep(5000);
        cm.unregisterNetworkCallback(networkCb);

        if (info == null) {
            setFailureReason(mContext.getString(R.string.aware_status_network_failed));
            Log.e(TAG, ""executeTestResponder: network request rejected - ON_UNAVAILABLE"");
            return false;
        }
        if (sSDKLevel <= android.os.Build.VERSION_CODES.P){
            if (info.second.getNetworkSpecifier() != null) {
                setFailureReason(mContext.getString(R.string.aware_status_network_failed_leak));
                Log.e(TAG, ""executeTestSubscriber: network request accepted - but leaks NS!"");
                return false;
            }
        }
        mListener.onTestMsgReceived(mContext.getString(R.string.aware_status_network_success));
        if (DBG) Log.d(TAG, ""executeTestResponder: network request granted - AVAILABLE"");

        mListener.onTestMsgReceived(mContext.getString(R.string.aware_status_lifecycle_ok));
        return true;
    }

    private boolean executeTestInitiator() throws InterruptedException {
        if (DBG) Log.d(TAG, ""executeTestInitiator"");
        CallbackUtils.DiscoveryCb discoveryCb = new CallbackUtils.DiscoveryCb();

        // 2. Subscribe
        SubscribeConfig subscribeConfig = new SubscribeConfig.Builder().setServiceName(
                SERVICE_NAME).build();
        if (DBG) Log.d(TAG, ""executeTestInitiator: subscribeConfig="" + subscribeConfig);
        mWifiAwareSession.subscribe(subscribeConfig, discoveryCb, mHandler);

        //    wait for results - subscribe session
        CallbackUtils.DiscoveryCb.CallbackData callbackData = discoveryCb.waitForCallbacks(
                CallbackUtils.DiscoveryCb.ON_SUBSCRIBE_STARTED
                        | CallbackUtils.DiscoveryCb.ON_SESSION_CONFIG_FAILED);
        switch (callbackData.callback) {
            case CallbackUtils.DiscoveryCb.TIMEOUT:
                setFailureReason(mContext.getString(R.string.aware_status_subscribe_timeout));
                Log.e(TAG, ""executeTestInitiator: subscribe TIMEOUT"");
                return false;
            case CallbackUtils.DiscoveryCb.ON_SESSION_CONFIG_FAILED:
                setFailureReason(mContext.getString(R.string.aware_status_subscribe_failed));
                Log.e(TAG, ""executeTestInitiator: subscribe ON_SESSION_CONFIG_FAILED"");
                return false;
        }
        SubscribeDiscoverySession discoverySession = callbackData.subscribeDiscoverySession;
        mWifiAwareDiscoverySession = discoverySession;
        if (discoverySession == null) {
            setFailureReason(mContext.getString(R.string.aware_status_subscribe_null_session));
            Log.e(TAG, ""executeTestInitiator: subscribe succeeded but null session returned"");
            return false;
        }
        mListener.onTestMsgReceived(mContext.getString(R.string.aware_status_subscribe_started));
        if (DBG) Log.d(TAG, ""executeTestInitiator: subscribe succeeded"");

        // 3. Wait for discovery
        callbackData = discoveryCb.waitForCallbacks(
                CallbackUtils.DiscoveryCb.ON_SERVICE_DISCOVERED);
        switch (callbackData.callback) {
            case CallbackUtils.DiscoveryCb.TIMEOUT:
                setFailureReason(mContext.getString(R.string.aware_status_discovery_timeout));
                Log.e(TAG, ""executeTestInitiator: waiting for discovery TIMEOUT"");
                return false;
        }
        PeerHandle peerHandle = callbackData.peerHandle;
        mListener.onTestMsgReceived(mContext.getString(R.string.aware_status_discovery));
        if (DBG) Log.d(TAG, ""executeTestInitiator: discovery"");

        // 4. Send message with MAC and wait for success
        discoverySession.sendMessage(peerHandle, MESSAGE_ID, mDiscoveryMac);
        callbackData = discoveryCb.waitForCallbacks(
                CallbackUtils.DiscoveryCb.ON_MESSAGE_SEND_SUCCEEDED
                        | CallbackUtils.DiscoveryCb.ON_MESSAGE_SEND_FAILED);
        switch (callbackData.callback) {
            case CallbackUtils.DiscoveryCb.TIMEOUT:
                setFailureReason(mContext.getString(R.string.aware_status_send_timeout));
                Log.e(TAG, ""executeTestInitiator: send message TIMEOUT"");
                return false;
            case CallbackUtils.DiscoveryCb.ON_MESSAGE_SEND_FAILED:
                setFailureReason(mContext.getString(R.string.aware_status_send_failed));
                Log.e(TAG, ""executeTestInitiator: send message ON_MESSAGE_SEND_FAILED"");
                return false;
        }
        mListener.onTestMsgReceived(mContext.getString(R.string.aware_status_send_success));
        if (DBG) Log.d(TAG, ""executeTestInitiator: send message succeeded"");

        if (callbackData.messageId != MESSAGE_ID) {
            setFailureReason(mContext.getString(R.string.aware_status_send_fail_parameter));
            Log.e(TAG, ""executeTestInitiator: send message message ID mismatch: ""
                    + callbackData.messageId);
            return false;
        }

        // 5. Wait for rx message (with MAC)
        callbackData = discoveryCb.waitForCallbacks(CallbackUtils.DiscoveryCb.ON_MESSAGE_RECEIVED);
        switch (callbackData.callback) {
            case CallbackUtils.DiscoveryCb.TIMEOUT:
                setFailureReason(mContext.getString(R.string.aware_status_receive_timeout));
                Log.e(TAG, ""executeTestInitiator: receive message TIMEOUT"");
                return false;
        }

        if (callbackData.serviceSpecificInfo == null
                || callbackData.serviceSpecificInfo.length != MAC_BYTES_LEN) {
            setFailureReason(mContext.getString(R.string.aware_status_receive_failure));
            Log.e(TAG, ""executeTestInitiator: receive message message content mismatch: ""
                    + bytesToHex(callbackData.serviceSpecificInfo, ':'));
            return false;
        }

        byte[] peerMac = callbackData.serviceSpecificInfo;

        mListener.onTestMsgReceived(mResources.getString(R.string.aware_status_received_mac,
                bytesToHex(peerMac, ':')));
        if (DBG) {
            Log.d(TAG, ""executeTestInitiator: received MAC address: "" + bytesToHex(peerMac, ':'));
        }

        // 6. Destroy discovery session
        discoverySession.close();
        mWifiAwareDiscoverySession = null;

        // 7. Sleep for 5 seconds to let Responder time to set up
        mListener.onTestMsgReceived(
                mContext.getString(R.string.aware_status_sleeping_wait_for_responder));
        Thread.sleep(5000);

        // 8. Request network (as Initiator) and wait for network
        ConnectivityManager cm = (ConnectivityManager) mContext.getSystemService(
                Context.CONNECTIVITY_SERVICE);
        NetworkRequest nr = new NetworkRequest.Builder().addTransportType(
                NetworkCapabilities.TRANSPORT_WIFI_AWARE).setNetworkSpecifier(
                mIsSecurityOpen ? mWifiAwareSession.createNetworkSpecifierOpen(
                        WifiAwareManager.WIFI_AWARE_DATA_PATH_ROLE_INITIATOR, peerMac)
                        : mWifiAwareSession.createNetworkSpecifierPassphrase(
                                WifiAwareManager.WIFI_AWARE_DATA_PATH_ROLE_INITIATOR, peerMac,
                                PASSPHRASE)).build();
        CallbackUtils.NetworkCb networkCb = new CallbackUtils.NetworkCb();
        cm.requestNetwork(nr, networkCb, CALLBACK_TIMEOUT_SEC * 1000);
        mListener.onTestMsgReceived(mContext.getString(R.string.aware_status_network_requested));
        if (DBG) Log.d(TAG, ""executeTestInitiator: requested network"");
        Pair<Network, NetworkCapabilities> info = networkCb.waitForNetworkCapabilities();

        // 9. Sleep for 5 second for Responder to get NetworkCapabilities.
        Thread.sleep(5000);
        cm.unregisterNetworkCallback(networkCb);

        if (info == null) {
            setFailureReason(mContext.getString(R.string.aware_status_network_failed));
            Log.e(TAG, ""executeTestInitiator: network request rejected - ON_UNAVAILABLE"");
            return false;
        }
        if (sSDKLevel <= android.os.Build.VERSION_CODES.P){
            if(info.second.getNetworkSpecifier() != null) {
                setFailureReason(mContext.getString(R.string.aware_status_network_failed_leak));
                Log.e(TAG, ""executeTestSubscriber: network request accepted - but leaks NS!"");
                return false;
            }
        }
        mListener.onTestMsgReceived(mContext.getString(R.string.aware_status_network_success));
        if (DBG) Log.d(TAG, ""executeTestInitiator: network request granted - AVAILABLE"");

        mListener.onTestMsgReceived(mContext.getString(R.string.aware_status_lifecycle_ok));
        return true;
    }
}"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.MulticastLockTest"	"testMulticastLock"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/MulticastLockTest.java"	""	"public void testMulticastLock() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        WifiManager wm = (WifiManager) getContext().getSystemService(Context.WIFI_SERVICE);
        MulticastLock mcl = wm.createMulticastLock(WIFI_TAG);

        mcl.setReferenceCounted(true);
        assertFalse(mcl.isHeld());
        mcl.acquire();
        assertTrue(mcl.isHeld());
        mcl.release();
        assertFalse(mcl.isHeld());
        mcl.acquire();
        mcl.acquire();
        assertTrue(mcl.isHeld());
        mcl.release();
        assertTrue(mcl.isHeld());
        mcl.release();
        assertFalse(mcl.isHeld());
        assertNotNull(mcl.toString());
        try {
            mcl.release();
            fail(""should throw out exception because release is called""
                    +"" a greater number of times than acquire"");
        } catch (RuntimeException e) {
            // expected
        }

        mcl = wm.createMulticastLock(WIFI_TAG);
        mcl.setReferenceCounted(false);
        assertFalse(mcl.isHeld());
        mcl.acquire();
        assertTrue(mcl.isHeld());
        mcl.release();
        assertFalse(mcl.isHeld());
        mcl.acquire();
        mcl.acquire();
        assertTrue(mcl.isHeld());
        mcl.release();
        assertFalse(mcl.isHeld());
        assertNotNull(mcl.toString());
        // releasing again after release: but ignored for non-referenced locks
        mcl.release();
    }
}"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.app.TriggerScanAndReturnStatusActivity"	"finish"	""	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/CtsWifiLocationTestApp/src/android/net/wifi/cts/app/TriggerScanAndReturnStatusActivity.java"	""	"public void test/*
 *.
 */

package android.net.wifi.cts.app;

import android.app.Activity;
import android.content.Intent;
import android.net.wifi.WifiManager;
import android.os.Bundle;
import android.util.Log;

/**
 * An activity that triggers a wifi scan and returns status.
 */
public class TriggerScanAndReturnStatusActivity extends Activity {
    private static final String TAG = ""TriggerScanAndReturnStatusActivity"";
    private static final String SCAN_STATUS_EXTRA = ""android.net.wifi.cts.app.extra.STATUS"";

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        WifiManager wifiManager = getSystemService(WifiManager.class);
        boolean succeeded;
        try {
            succeeded = wifiManager.startScan();
        } catch (SecurityException e) {
            succeeded = false;
        }
        if (succeeded) {
            Log.v(TAG, ""Scan trigger succeeded"");
        } else {
            Log.v(TAG, ""Failed to trigger scan"");
        }
        setResult(RESULT_OK, new Intent().putExtra(SCAN_STATUS_EXTRA, succeeded));
        finish();
    }
}"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"ProvisioningCallback"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void test/*
 *.
 */

package android.net.wifi.cts;

import static android.net.NetworkCapabilities.NET_CAPABILITY_NOT_METERED;
import static android.net.NetworkCapabilities.TRANSPORT_WIFI;
import static android.net.wifi.WifiAvailableChannel.OP_MODE_SAP;
import static android.net.wifi.WifiAvailableChannel.OP_MODE_STA;
import static android.net.wifi.WifiConfiguration.INVALID_NETWORK_ID;
import static android.net.wifi.WifiManager.COEX_RESTRICTION_SOFTAP;
import static android.net.wifi.WifiManager.COEX_RESTRICTION_WIFI_AWARE;
import static android.net.wifi.WifiManager.COEX_RESTRICTION_WIFI_DIRECT;
import static android.net.wifi.WifiScanner.WIFI_BAND_24_GHZ;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import static org.junit.Assert.assertNotEquals;

import android.annotation.NonNull;
import android.app.UiAutomation;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.content.pm.ResolveInfo;
import android.net.ConnectivityManager;
import android.net.MacAddress;
import android.net.Network;
import android.net.NetworkCapabilities;
import android.net.NetworkInfo;
import android.net.NetworkRequest;
import android.net.TetheringManager;
import android.net.Uri;
import android.net.wifi.CoexUnsafeChannel;
import android.net.wifi.ScanResult;
import android.net.wifi.SoftApCapability;
import android.net.wifi.SoftApConfiguration;
import android.net.wifi.SoftApInfo;
import android.net.wifi.WifiAvailableChannel;
import android.net.wifi.WifiClient;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiEnterpriseConfig;
import android.net.wifi.WifiInfo;
import android.net.wifi.WifiManager;
import android.net.wifi.WifiManager.SubsystemRestartTrackingCallback;
import android.net.wifi.WifiManager.WifiLock;
import android.net.wifi.WifiNetworkConnectionStatistics;
import android.net.wifi.WifiNetworkSuggestion;
import android.net.wifi.hotspot2.ConfigParser;
import android.net.wifi.hotspot2.OsuProvider;
import android.net.wifi.hotspot2.PasspointConfiguration;
import android.net.wifi.hotspot2.ProvisioningCallback;
import android.net.wifi.hotspot2.pps.Credential;
import android.net.wifi.hotspot2.pps.HomeSp;
import android.os.Build;
import android.os.Handler;
import android.os.HandlerExecutor;
import android.os.HandlerThread;
import android.os.Process;
import android.os.SystemClock;
import android.os.UserHandle;
import android.platform.test.annotations.AppModeFull;
import android.platform.test.annotations.AsbSecurityTest;
import android.provider.Settings;
import android.support.test.uiautomator.UiDevice;
import android.telephony.TelephonyManager;
import android.text.TextUtils;
import android.util.ArraySet;
import android.util.Log;
import android.util.SparseArray;
import android.util.SparseIntArray;

import androidx.test.filters.SdkSuppress;
import androidx.test.platform.app.InstrumentationRegistry;

import com.android.compatibility.common.util.ApiLevelUtil;
import com.android.compatibility.common.util.FeatureUtil;
import com.android.compatibility.common.util.PollingCheck;
import com.android.compatibility.common.util.PropertyUtil;
import com.android.compatibility.common.util.ShellIdentityUtils;
import com.android.compatibility.common.util.SystemUtil;
import com.android.compatibility.common.util.ThrowingRunnable;
import com.android.modules.utils.build.SdkLevel;
import com.android.net.module.util.MacAddressUtils;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.lang.reflect.Constructor;
import java.net.HttpURLConnection;
import java.net.InetAddress;
import java.net.URL;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

@AppModeFull(reason = ""Cannot get WifiManager in instant app mode"")
public class WifiManagerTest extends WifiJUnit3TestBase {
    private static class MySync {
        int expectedState = STATE_NULL;
    }

    private WifiManager mWifiManager;
    private ConnectivityManager mConnectivityManager;
    private TetheringManager mTetheringManager;
    private WifiLock mWifiLock;
    private static MySync mMySync;
    private List<ScanResult> mScanResults = null;
    private NetworkInfo mNetworkInfo =
            new NetworkInfo(ConnectivityManager.TYPE_WIFI, TelephonyManager.NETWORK_TYPE_UNKNOWN,
                    ""wifi"", ""unknown"");
    private final Object mLock = new Object();
    private UiDevice mUiDevice;
    private boolean mWasVerboseLoggingEnabled;
    private boolean mWasScanThrottleEnabled;
    private SoftApConfiguration mOriginalSoftApConfig = null;

    // Please refer to WifiManager
    private static final int MIN_RSSI = -100;
    private static final int MAX_RSSI = -55;

    private static final int STATE_NULL = 0;
    private static final int STATE_WIFI_CHANGING = 1;
    private static final int STATE_WIFI_ENABLED = 2;
    private static final int STATE_WIFI_DISABLED = 3;
    private static final int STATE_SCANNING = 4;
    private static final int STATE_SCAN_DONE = 5;

    private static final String TAG = ""WifiManagerTest"";
    private static final String SSID1 = ""\""WifiManagerTest\"""";
    // A full single scan duration is about 6-7 seconds if country code is set
    // to US. If country code is set to world mode (00), we would expect a scan
    // duration of roughly 8 seconds. So we set scan timeout as 9 seconds here.
    private static final int SCAN_TEST_WAIT_DURATION_MS = 9000;
    private static final int TEST_WAIT_DURATION_MS = 10_000;
    private static final int WIFI_CONNECT_TIMEOUT_MILLIS = 30_000;
    private static final int WAIT_MSEC = 60;
    private static final int DURATION_SCREEN_TOGGLE = 2000;
    private static final int DURATION_SETTINGS_TOGGLE = 1_000;
    private static final int WIFI_SCAN_TEST_CACHE_DELAY_MILLIS = 3 * 60 * 1000;

    private static final int ENFORCED_NUM_NETWORK_SUGGESTIONS_PER_APP = 50;

    private static final String TEST_PAC_URL = ""http://www.example.com/proxy.pac"";
    private static final String MANAGED_PROVISIONING_PACKAGE_NAME
            = ""com.android.managedprovisioning"";

    private static final String TEST_SSID_UNQUOTED = ""testSsid1"";
    private static final String TEST_IP_ADDRESS = ""192.168.5.5"";
    private static final String TEST_MAC_ADDRESS = ""aa:bb:cc:dd:ee:ff"";
    private static final MacAddress TEST_MAC = MacAddress.fromString(TEST_MAC_ADDRESS);
    private static final String TEST_PASSPHRASE = ""passphrase"";
    private static final String PASSPOINT_INSTALLATION_FILE_WITH_CA_CERT =
            ""assets/ValidPasspointProfile.base64"";
    private static final String TYPE_WIFI_CONFIG = ""application/x-wifi-config"";
    private static final String TEST_PSK_CAP = ""[RSN-PSK-CCMP]"";
    private static final String TEST_BSSID = ""00:01:02:03:04:05"";
    private static final String TEST_COUNTRY_CODE = ""JP"";
    private static final String TEST_DOM_SUBJECT_MATCH = ""domSubjectMatch"";
    private static final int TEST_SUB_ID = 2;

    private IntentFilter mIntentFilter;
    private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            final String action = intent.getAction();
            if (action.equals(WifiManager.SCAN_RESULTS_AVAILABLE_ACTION)) {

                synchronized (mMySync) {
                    if (intent.getBooleanExtra(WifiManager.EXTRA_RESULTS_UPDATED, false)) {
                        mScanResults = mWifiManager.getScanResults();
                    } else {
                        mScanResults = null;
                    }
                    mMySync.expectedState = STATE_SCAN_DONE;
                    mMySync.notifyAll();
                }
            } else if (action.equals(WifiManager.WIFI_STATE_CHANGED_ACTION)) {
                int newState = intent.getIntExtra(WifiManager.EXTRA_WIFI_STATE,
                        WifiManager.WIFI_STATE_UNKNOWN);
                synchronized (mMySync) {
                    if (newState == WifiManager.WIFI_STATE_ENABLED) {
                        Log.d(TAG, ""*** New WiFi state is ENABLED ***"");
                        mMySync.expectedState = STATE_WIFI_ENABLED;
                        mMySync.notifyAll();
                    } else if (newState == WifiManager.WIFI_STATE_DISABLED) {
                        Log.d(TAG, ""*** New WiFi state is DISABLED ***"");
                        mMySync.expectedState = STATE_WIFI_DISABLED;
                        mMySync.notifyAll();
                    }
                }
            } else if (action.equals(WifiManager.NETWORK_STATE_CHANGED_ACTION)) {
                synchronized (mMySync) {
                    mNetworkInfo =
                            (NetworkInfo) intent.getParcelableExtra(WifiManager.EXTRA_NETWORK_INFO);
                    if (mNetworkInfo.getState() == NetworkInfo.State.CONNECTED)
                        mMySync.notifyAll();
                }
            }
        }
    };
    // Initialize with an invalid status value (0)
    private int mProvisioningStatus = 0;
    // Initialize with an invalid status value (0)
    private int mProvisioningFailureStatus = 0;
    private boolean mProvisioningComplete = false;
    private ProvisioningCallback mProvisioningCallback = new ProvisioningCallback() {
        @Override
        public void onProvisioningFailure(int status) {
            synchronized (mLock) {
                mProvisioningFailureStatus = status;
                mLock.notify();
            }
        }

        @Override
        public void onProvisioningStatus(int status) {
            synchronized (mLock) {
                mProvisioningStatus = status;
                mLock.notify();
            }
        }

        @Override
        public void onProvisioningComplete() {
            mProvisioningComplete = true;
        }
    };
    private int mSubsystemRestartStatus = 0; // 0: nada, 1: restarting, 2: restarted
    private SubsystemRestartTrackingCallback mSubsystemRestartTrackingCallback =
            new SubsystemRestartTrackingCallback() {
                @Override
                public void onSubsystemRestarting() {
                    synchronized (mLock) {
                        mSubsystemRestartStatus = 1;
                        mLock.notify();
                    }
                }

                @Override
                public void onSubsystemRestarted() {
                    synchronized (mLock) {
                        mSubsystemRestartStatus = 2;
                        mLock.notify();
                    }
                }
            };
    private static final String TEST_SSID = ""TEST SSID"";
    private static final String TEST_FRIENDLY_NAME = ""Friendly Name"";
    private static final Map<String, String> TEST_FRIENDLY_NAMES =
            new HashMap<String, String>() {
                {
                    put(""en"", TEST_FRIENDLY_NAME);
                    put(""kr"", TEST_FRIENDLY_NAME + 2);
                    put(""jp"", TEST_FRIENDLY_NAME + 3);
                }
            };
    private static final String TEST_SERVICE_DESCRIPTION = ""Dummy Service"";
    private static final Uri TEST_SERVER_URI = Uri.parse(""https://test.com"");
    private static final String TEST_NAI = ""test.access.com"";
    private static final List<Integer> TEST_METHOD_LIST =
            Arrays.asList(1 /* METHOD_SOAP_XML_SPP */);
    private final HandlerThread mHandlerThread = new HandlerThread(""WifiManagerTest"");
    protected final Executor mExecutor;
    {
        mHandlerThread.start();
        mExecutor = new HandlerExecutor(new Handler(mHandlerThread.getLooper()));
    }

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        mMySync = new MySync();
        mIntentFilter = new IntentFilter();
        mIntentFilter.addAction(WifiManager.NETWORK_STATE_CHANGED_ACTION);
        mIntentFilter.addAction(WifiManager.SCAN_RESULTS_AVAILABLE_ACTION);
        mIntentFilter.addAction(WifiManager.SUPPLICANT_CONNECTION_CHANGE_ACTION);
        mIntentFilter.addAction(WifiManager.SUPPLICANT_STATE_CHANGED_ACTION);
        mIntentFilter.addAction(WifiManager.WIFI_STATE_CHANGED_ACTION);
        mIntentFilter.addAction(WifiManager.RSSI_CHANGED_ACTION);
        mIntentFilter.addAction(WifiManager.NETWORK_IDS_CHANGED_ACTION);
        mIntentFilter.addAction(WifiManager.ACTION_PICK_WIFI_NETWORK);

        mContext.registerReceiver(mReceiver, mIntentFilter);
        mWifiManager = (WifiManager) getContext().getSystemService(Context.WIFI_SERVICE);
        mConnectivityManager = getContext().getSystemService(ConnectivityManager.class);
        mTetheringManager = getContext().getSystemService(TetheringManager.class);
        assertNotNull(mWifiManager);
        assertNotNull(mTetheringManager);

        // turn on verbose logging for tests
        mWasVerboseLoggingEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.isVerboseLoggingEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setVerboseLoggingEnabled(true));
        // Disable scan throttling for tests.
        mWasScanThrottleEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.isScanThrottleEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setScanThrottleEnabled(false));

        mWifiLock = mWifiManager.createWifiLock(TAG);
        mWifiLock.acquire();
        // enable Wifi
        if (!mWifiManager.isWifiEnabled()) setWifiEnabled(true);
        PollingCheck.check(""Wifi not enabled"", TEST_WAIT_DURATION_MS,
                () -> mWifiManager.isWifiEnabled());

        mUiDevice = UiDevice.getInstance(InstrumentationRegistry.getInstrumentation());
        turnScreenOnNoDelay();

        synchronized (mMySync) {
            mMySync.expectedState = STATE_NULL;
        }

        List<WifiConfiguration> savedNetworks = ShellIdentityUtils.invokeWithShellPermissions(
                mWifiManager::getConfiguredNetworks);
        assertFalse(""Need at least one saved network"", savedNetworks.isEmpty());

        // Get original config for restore
        mOriginalSoftApConfig = ShellIdentityUtils.invokeWithShellPermissions(
                mWifiManager::getSoftApConfiguration);
    }

    @Override
    protected void tearDown() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            super.tearDown();
            return;
        }
        if (!mWifiManager.isWifiEnabled())
            setWifiEnabled(true);
        mWifiLock.release();
        mContext.unregisterReceiver(mReceiver);
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setScanThrottleEnabled(mWasScanThrottleEnabled));
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setVerboseLoggingEnabled(mWasVerboseLoggingEnabled));
        // restore original softap config
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setSoftApConfiguration(mOriginalSoftApConfig));
        Thread.sleep(TEST_WAIT_DURATION_MS);
        super.tearDown();
    }

    private void setWifiEnabled(boolean enable) throws Exception {
        synchronized (mMySync) {
            if (mWifiManager.isWifiEnabled() != enable) {
                // the new state is different, we expect it to change
                mMySync.expectedState = STATE_WIFI_CHANGING;
            } else {
                mMySync.expectedState = (enable ? STATE_WIFI_ENABLED : STATE_WIFI_DISABLED);
            }
            // now trigger the change using shell commands.
            SystemUtil.runShellCommand(""svc wifi "" + (enable ? ""enable"" : ""disable""));
            waitForExpectedWifiState(enable);
        }
    }

    private void waitForExpectedWifiState(boolean enabled) throws InterruptedException {
        synchronized (mMySync) {
            long timeout = System.currentTimeMillis() + TEST_WAIT_DURATION_MS;
            int expected = (enabled ? STATE_WIFI_ENABLED : STATE_WIFI_DISABLED);
            while (System.currentTimeMillis() < timeout
                    && mMySync.expectedState != expected) {
                mMySync.wait(WAIT_MSEC);
            }
        }
    }

    // Get the current scan status from sticky broadcast.
    private boolean isScanCurrentlyAvailable() {
        IntentFilter intentFilter = new IntentFilter();
        intentFilter.addAction(WifiManager.ACTION_WIFI_SCAN_AVAILABILITY_CHANGED);
        Intent intent = mContext.registerReceiver(null, intentFilter);
        assertNotNull(intent);
        if (intent.getAction().equals(WifiManager.ACTION_WIFI_SCAN_AVAILABILITY_CHANGED)) {
            return intent.getBooleanExtra(WifiManager.EXTRA_SCAN_AVAILABLE, false);
        }
        return false;
    }

    private void startScan() throws Exception {
        synchronized (mMySync) {
            mMySync.expectedState = STATE_SCANNING;
            mScanResults = null;
            assertTrue(mWifiManager.startScan());
            long timeout = System.currentTimeMillis() + SCAN_TEST_WAIT_DURATION_MS;
            while (System.currentTimeMillis() < timeout && mMySync.expectedState == STATE_SCANNING)
                mMySync.wait(WAIT_MSEC);
        }
    }

    private void waitForNetworkInfoState(NetworkInfo.State state, int timeoutMillis)
            throws Exception {
        synchronized (mMySync) {
            if (mNetworkInfo.getState() == state) return;
            long timeout = System.currentTimeMillis() + timeoutMillis;
            while (System.currentTimeMillis() < timeout
                    && mNetworkInfo.getState() != state)
                mMySync.wait(WAIT_MSEC);
            assertEquals(state, mNetworkInfo.getState());
        }
    }

    private void waitForConnection() throws Exception {
        waitForNetworkInfoState(NetworkInfo.State.CONNECTED, WIFI_CONNECT_TIMEOUT_MILLIS);
    }

    private void waitForDisconnection() throws Exception {
        waitForNetworkInfoState(NetworkInfo.State.DISCONNECTED, TEST_WAIT_DURATION_MS);
    }

    private void ensureNotNetworkInfoState(NetworkInfo.State state) throws Exception {
        synchronized (mMySync) {
            long timeout = System.currentTimeMillis() + TEST_WAIT_DURATION_MS + WAIT_MSEC;
            while (System.currentTimeMillis() < timeout) {
                assertNotEquals(state, mNetworkInfo.getState());
                mMySync.wait(WAIT_MSEC);
            }
        }
    }

    private void ensureNotConnected() throws Exception {
        ensureNotNetworkInfoState(NetworkInfo.State.CONNECTED);
    }

    private void ensureNotDisconnected() throws Exception {
        ensureNotNetworkInfoState(NetworkInfo.State.DISCONNECTED);
    }

    private boolean existSSID(String ssid) {
        for (final WifiConfiguration w : mWifiManager.getConfiguredNetworks()) {
            if (w.SSID.equals(ssid))
                return true;
        }
        return false;
    }

    private int findConfiguredNetworks(String SSID, List<WifiConfiguration> networks) {
        for (final WifiConfiguration w : networks) {
            if (w.SSID.equals(SSID))
                return networks.indexOf(w);
        }
        return -1;
    }

    /**
     * Test creation of WifiManager Lock.
     */"	""	""	"passpoint wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testStartLocalOnlyHotspotWithNullBssidConfig"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testStartLocalOnlyHotspotWithNullBssidConfig() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // check that softap mode is supported by the device
        if (!mWifiManager.isPortableHotspotSupported()) {
            return;
        }
        SoftApConfiguration customConfig = new SoftApConfiguration.Builder()
                .setSsid(TEST_SSID_UNQUOTED)
                .setPassphrase(TEST_PASSPHRASE, SoftApConfiguration.SECURITY_TYPE_WPA2_PSK)
                .build();
        TestExecutor executor = new TestExecutor();
        TestLocalOnlyHotspotCallback callback = new TestLocalOnlyHotspotCallback(mLock);
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        boolean wifiEnabled = mWifiManager.isWifiEnabled();
        try {
            uiAutomation.adoptShellPermissionIdentity();

            mWifiManager.startLocalOnlyHotspot(customConfig, executor, callback);
            // now wait for callback
            Thread.sleep(TEST_WAIT_DURATION_MS);

            // Verify callback is run on the supplied executor
            assertFalse(callback.onStartedCalled);
            executor.runAll();
            assertTrue(callback.onStartedCalled);

            assertNotNull(callback.reservation);
            SoftApConfiguration softApConfig = callback.reservation.getSoftApConfiguration();
            assertNotNull(softApConfig);
            assertEquals(TEST_SSID_UNQUOTED, softApConfig.getSsid());
            assertEquals(TEST_PASSPHRASE, softApConfig.getPassphrase());
        } finally {
            // clean up
            stopLocalOnlyHotspot(callback, wifiEnabled);
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Read the content of the given resource file into a String.
     *
     * @param filename String name of the file
     * @return String
     * @throws IOException
     */
    private String loadResourceFile(String filename) throws IOException {
        InputStream in = getClass().getClassLoader().getResourceAsStream(filename);
        BufferedReader reader = new BufferedReader(new InputStreamReader(in));
        StringBuilder builder = new StringBuilder();
        String line;
        while ((line = reader.readLine()) != null) {
            builder.append(line).append(""\n"");
        }
        return builder.toString();
    }

    /**
     * Verify that changing the mac randomization setting of a Passpoint configuration.
     */"	""	""	"passpoint wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testMacRandomizationSettingPasspoint"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testMacRandomizationSettingPasspoint() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        String configStr = loadResourceFile(PASSPOINT_INSTALLATION_FILE_WITH_CA_CERT);
        PasspointConfiguration config =
                ConfigParser.parsePasspointConfig(TYPE_WIFI_CONFIG, configStr.getBytes());
        String fqdn = config.getHomeSp().getFqdn();
        String uniqueId = config.getUniqueId();
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();

            mWifiManager.addOrUpdatePasspointConfiguration(config);
            PasspointConfiguration passpointConfig = getTargetPasspointConfiguration(
                    mWifiManager.getPasspointConfigurations(), uniqueId);
            assertNotNull(""The installed passpoint profile is missing"", passpointConfig);
            assertTrue(""Mac randomization should be enabled for passpoint networks by default."",
                    passpointConfig.isMacRandomizationEnabled());

            mWifiManager.setMacRandomizationSettingPasspointEnabled(fqdn, false);
            passpointConfig = getTargetPasspointConfiguration(
                    mWifiManager.getPasspointConfigurations(), uniqueId);
            assertNotNull(""The installed passpoint profile is missing"", passpointConfig);
            assertFalse(""Mac randomization should be disabled by the API call."",
                    passpointConfig.isMacRandomizationEnabled());
        } finally {
            // Clean up
            mWifiManager.removePasspointConfiguration(fqdn);
            uiAutomation.dropShellPermissionIdentity();
        }
    }
    /**
     * Verify that the {@link android.Manifest.permission#NETWORK_STACK} permission is never held by
     * any package.
     * <p>
     * No apps should <em>ever</em> attempt to acquire this permission, since it would give those
     * apps extremely broad access to connectivity functionality.
     */"	""	""	"passpoint wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testIsWifiStandardsSupported"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testIsWifiStandardsSupported() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }

        // Check for WiFi standards support with wifi enabled
        setWifiEnabled(true);
        PollingCheck.check(
                ""Wifi not enabled!"",
                20000,
                () -> mWifiManager.isWifiEnabled());
        boolean isLegacySupportedEnabled =
                mWifiManager.isWifiStandardSupported(ScanResult.WIFI_STANDARD_LEGACY);
        boolean is11nSupporedEnabled =
                mWifiManager.isWifiStandardSupported(ScanResult.WIFI_STANDARD_11N);
        boolean is11acSupportedEnabled =
                mWifiManager.isWifiStandardSupported(ScanResult.WIFI_STANDARD_11AC);
        boolean is11axSupportedEnabled =
                mWifiManager.isWifiStandardSupported(ScanResult.WIFI_STANDARD_11AX);

        // Check for WiFi standards support with wifi disabled
        setWifiEnabled(false);
        PollingCheck.check(
                ""Wifi not disabled!"",
                20000,
                () -> !mWifiManager.isWifiEnabled());

        boolean isLegacySupportedDisabled =
                mWifiManager.isWifiStandardSupported(ScanResult.WIFI_STANDARD_LEGACY);
        boolean is11nSupportedDisabled =
                mWifiManager.isWifiStandardSupported(ScanResult.WIFI_STANDARD_11N);
        boolean is11acSupportedDisabled =
                mWifiManager.isWifiStandardSupported(ScanResult.WIFI_STANDARD_11AC);
        boolean is11axSupportedDisabled =
                mWifiManager.isWifiStandardSupported(ScanResult.WIFI_STANDARD_11AX);

        if (isLegacySupportedDisabled) {
            assertTrue(isLegacySupportedEnabled);
        }

        if (is11nSupportedDisabled) {
            assertTrue(is11nSupporedEnabled);
        }

        if (is11acSupportedDisabled) {
            assertTrue(is11acSupportedEnabled);
        }

        if (is11axSupportedDisabled) {
            assertTrue(is11axSupportedEnabled);
        }
    }

    private static PasspointConfiguration createPasspointConfiguration() {
        PasspointConfiguration config = new PasspointConfiguration();
        HomeSp homeSp = new HomeSp();
        homeSp.setFqdn(""test.com"");
        homeSp.setFriendlyName(""friendly name"");
        homeSp.setRoamingConsortiumOis(new long[]{0x55, 0x66});
        config.setHomeSp(homeSp);
        Credential.SimCredential simCred = new Credential.SimCredential();
        simCred.setImsi(""123456*"");
        simCred.setEapType(23 /* EAP_AKA */);
        Credential cred = new Credential();
        cred.setRealm(""realm"");
        cred.setSimCredential(simCred);
        config.setCredential(cred);

        return config;
    }

    /**
     * Tests {@link WifiManager#addOrUpdatePasspointConfiguration(PasspointConfiguration)}
     * adds a Passpoint configuration correctly by getting it once it is added, and comparing it
     * to the local copy of the configuration.
     */"	""	""	"passpoint wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	Test Available	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testAddOrUpdatePasspointConfiguration"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testAddOrUpdatePasspointConfiguration() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }

        // Create and install a Passpoint configuration
        PasspointConfiguration passpointConfiguration = createPasspointConfiguration();
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            mWifiManager.addOrUpdatePasspointConfiguration(passpointConfiguration);

            // Compare configurations
            List<PasspointConfiguration> configurations = mWifiManager.getPasspointConfigurations();
            assertNotNull(""The installed passpoint profile is missing"", configurations);
            assertEquals(passpointConfiguration, getTargetPasspointConfiguration(configurations,
                    passpointConfiguration.getUniqueId()));
        } finally {
            // Clean up
            mWifiManager.removePasspointConfiguration(passpointConfiguration.getHomeSp().getFqdn());
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link WifiManager#setPasspointMeteredOverride(String, int)}
     * adds a Passpoint configuration correctly, check the default metered setting. Use API change
     * metered override, verify Passpoint configuration changes with it.
     */"	""	""	"passpoint wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testSetPasspointMeteredOverride"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testSetPasspointMeteredOverride() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // Create and install a Passpoint configuration
        PasspointConfiguration passpointConfiguration = createPasspointConfiguration();
        String fqdn = passpointConfiguration.getHomeSp().getFqdn();
        String uniqueId = passpointConfiguration.getUniqueId();
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();

        try {
            uiAutomation.adoptShellPermissionIdentity();
            mWifiManager.addOrUpdatePasspointConfiguration(passpointConfiguration);
            PasspointConfiguration saved = getTargetPasspointConfiguration(
                    mWifiManager.getPasspointConfigurations(), uniqueId);
            assertNotNull(""The installed passpoint profile is missing"", saved);
            // Verify meter override setting.
            assertEquals(""Metered overrider default should be none"",
                    WifiConfiguration.METERED_OVERRIDE_NONE, saved.getMeteredOverride());
            // Change the meter override setting.
            mWifiManager.setPasspointMeteredOverride(fqdn,
                    WifiConfiguration.METERED_OVERRIDE_METERED);
            // Verify passpoint config change with the new setting.
            saved = getTargetPasspointConfiguration(
                    mWifiManager.getPasspointConfigurations(), uniqueId);
            assertNotNull(""The installed passpoint profile is missing"", saved);
            assertEquals(""Metered override should be metered"",
                    WifiConfiguration.METERED_OVERRIDE_METERED, saved.getMeteredOverride());
        } finally {
            // Clean up
            mWifiManager.removePasspointConfiguration(fqdn);
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests that
     * {@link WifiManager#startSubscriptionProvisioning(OsuProvider, Executor, ProvisioningCallback)}
     * starts a subscription provisioning, and confirm a status callback invoked once.
     */"	""	""	"passpoint wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testStartSubscriptionProvisioning"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testStartSubscriptionProvisioning() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }

        // Using Java reflection to construct an OsuProvider instance because its constructor is
        // hidden and not available to apps.
        Class<?> osuProviderClass = Class.forName(""android.net.wifi.hotspot2.OsuProvider"");
        Constructor<?> osuProviderClassConstructor = osuProviderClass.getConstructor(String.class,
                Map.class, String.class, Uri.class, String.class, List.class);

        OsuProvider osuProvider = (OsuProvider) osuProviderClassConstructor.newInstance(TEST_SSID,
                TEST_FRIENDLY_NAMES, TEST_SERVICE_DESCRIPTION, TEST_SERVER_URI, TEST_NAI,
                TEST_METHOD_LIST);

        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            synchronized (mLock) {
                // Start a subscription provisioning for a non-existent Passpoint R2 AP
                mWifiManager.startSubscriptionProvisioning(osuProvider, mExecutor,
                        mProvisioningCallback);
                mLock.wait(TEST_WAIT_DURATION_MS);
            }
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }

        // Expect only a single callback event, connecting. Since AP doesn't exist, it ends here
        assertEquals(ProvisioningCallback.OSU_STATUS_AP_CONNECTING, mProvisioningStatus);
        // No failure callbacks expected
        assertEquals(0, mProvisioningFailureStatus);
        // No completion callback expected
        assertFalse(mProvisioningComplete);
    }

    /**
     * Tests {@link WifiManager#setTdlsEnabled(InetAddress, boolean)} does not crash.
     */"	""	""	"passpoint wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testAllowAutojoin"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testAllowAutojoin() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // Trigger a scan & wait for connection to one of the saved networks.
        mWifiManager.startScan();
        waitForConnection();

        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        List<WifiConfiguration> savedNetworks = null;
        try {
            uiAutomation.adoptShellPermissionIdentity();
            // disable autojoin on all networks.
            savedNetworks = mWifiManager.getConfiguredNetworks();
            for (WifiConfiguration network : savedNetworks) {
                mWifiManager.allowAutojoin(network.networkId, false);
            }
            // trigger a disconnect and wait for disconnect.
            mWifiManager.disconnect();
            waitForDisconnection();

            // Now trigger scan and ensure that the device does not connect to any networks.
            mWifiManager.startScan();
            ensureNotConnected();

            // Now enable autojoin on all networks.
            for (WifiConfiguration network : savedNetworks) {
                mWifiManager.allowAutojoin(network.networkId, true);
            }

            // Trigger a scan & wait for connection to one of the saved networks.
            mWifiManager.startScan();
            waitForConnection();
        } finally {
            // Restore auto join state.
            if (savedNetworks != null) {
                for (WifiConfiguration network : savedNetworks) {
                    mWifiManager.allowAutojoin(network.networkId, network.allowAutojoin);
                }
            }
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link WifiManager#allowAutojoinPasspoint(String, boolean)}.
     */"	""	""	"passpoint wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testAllowAutojoinPasspoint"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testAllowAutojoinPasspoint() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }

        PasspointConfiguration passpointConfiguration = createPasspointConfiguration();
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            mWifiManager.addOrUpdatePasspointConfiguration(passpointConfiguration);
            // Turn off auto-join
            mWifiManager.allowAutojoinPasspoint(
                    passpointConfiguration.getHomeSp().getFqdn(), false);
            // Turn on auto-join
            mWifiManager.allowAutojoinPasspoint(
                    passpointConfiguration.getHomeSp().getFqdn(), true);
        } finally {
            mWifiManager.removePasspointConfiguration(passpointConfiguration.getHomeSp().getFqdn());
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link WifiManager#allowAutojoinGlobal(boolean)}.
     */"	""	""	"passpoint wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testIsMultiStaConcurrencySupported"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testIsMultiStaConcurrencySupported() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // ensure no crash.
        mWifiManager.isStaApConcurrencySupported();
    }

    private PasspointConfiguration getTargetPasspointConfiguration(
            List<PasspointConfiguration> configurationList, String uniqueId) {
        if (configurationList == null || configurationList.isEmpty()) {
            return null;
        }
        for (PasspointConfiguration config : configurationList) {
            if (TextUtils.equals(config.getUniqueId(), uniqueId)) {
                return config;
            }
        }
        return null;
    }

    /**
     * Test that {@link WifiManager#is60GHzBandSupported()} throws UnsupportedOperationException
     * if the release is older than S.
     */
    @SdkSuppress(maxSdkVersion = Build.VERSION_CODES.R)"	""	""	"passpoint wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testInsecureEnterpriseConfigurationsRejected"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testInsecureEnterpriseConfigurationsRejected() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        WifiConfiguration wifiConfiguration = new WifiConfiguration();
        wifiConfiguration.SSID = SSID1;
        wifiConfiguration.setSecurityParams(WifiConfiguration.SECURITY_TYPE_EAP_WPA3_ENTERPRISE);
        wifiConfiguration.enterpriseConfig.setEapMethod(WifiEnterpriseConfig.Eap.TTLS);
        int networkId = INVALID_NETWORK_ID;

        // These below API's only work with privileged permissions (obtained via shell identity
        // for test)
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();

            // Verify that an insecure network is rejected
            assertEquals(INVALID_NETWORK_ID, mWifiManager.addNetwork(wifiConfiguration));

            // Now configure it correctly with a Root CA cert and domain name
            wifiConfiguration.enterpriseConfig.setCaCertificate(FakeKeys.CA_CERT0);
            wifiConfiguration.enterpriseConfig.setAltSubjectMatch(TEST_DOM_SUBJECT_MATCH);

            // Verify that the network is added
            networkId = mWifiManager.addNetwork(wifiConfiguration);
            assertNotEquals(INVALID_NETWORK_ID, networkId);

            // Verify that the update API accepts configurations configured securely
            wifiConfiguration.networkId = networkId;
            assertEquals(networkId, mWifiManager.updateNetwork(wifiConfiguration));

            // Now clear the security configuration
            wifiConfiguration.enterpriseConfig.setCaCertificate(null);
            wifiConfiguration.enterpriseConfig.setAltSubjectMatch(null);

            // Verify that the update API rejects insecure configurations
            assertEquals(INVALID_NETWORK_ID, mWifiManager.updateNetwork(wifiConfiguration));
        } finally {
            if (networkId != INVALID_NETWORK_ID) {
                // Clean up the previously added network
                mWifiManager.removeNetwork(networkId);
            }
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link WifiManager#isPasspointTermsAndConditionsSupported)} does not crash.
     */"	""	""	"passpoint wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testIsPasspointTermsAndConditionsSupported"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testIsPasspointTermsAndConditionsSupported() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        if (!WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(getContext())) {
            // Skip the test if wifi module version is older than S.
            return;
        }
        mWifiManager.isPasspointTermsAndConditionsSupported();
    }

    /**
     * Test that call to {@link WifiManager#setOverrideCountryCode()},
     * {@link WifiManager#clearOverrideCountryCode()} and
     * {@link WifiManager#setDefaultCountryCode()} need privileged permission
     * and the permission is not even given to shell user.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"passpoint wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testManageCountryCodeMethodsFailWithoutPermissions"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testManageCountryCodeMethodsFailWithoutPermissions() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        ShellIdentityUtils.invokeWithShellPermissions(() -> {
            try {
                mWifiManager.setOverrideCountryCode(TEST_COUNTRY_CODE);
                fail(""setOverrideCountryCode() expected to fail - privileged call"");
            } catch (SecurityException e) {
                // expected
            }

            try {
                mWifiManager.clearOverrideCountryCode();
                fail(""clearOverrideCountryCode() expected to fail - privileged call"");
            } catch (SecurityException e) {
                // expected
            }

            try {
                mWifiManager.setDefaultCountryCode(TEST_COUNTRY_CODE);
                fail(""setDefaultCountryCode() expected to fail - privileged call"");
            } catch (SecurityException e) {
                // expected
            }
        });
    }

    /**
     * Tests {@link WifiManager#flushPasspointAnqpCache)} does not crash.
     */"	""	""	"passpoint wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testFlushPasspointAnqpCache"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testFlushPasspointAnqpCache() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        if (!WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(getContext())) {
            // Skip the test if wifi module version is older than S.
            return;
        }
        // The below API only works with privileged permissions (obtained via shell identity
        // for test)
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            mWifiManager.flushPasspointAnqpCache();
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link WifiManager#isDecoratedIdentitySupported)} does not crash.
     */"	""	""	"passpoint wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testGetUsableChannels"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testGetUsableChannels() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // The below API only works with privileged permissions (obtained via shell identity
        // for test)
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            List<WifiAvailableChannel> usableChannels =
                mWifiManager.getUsableChannels(WIFI_BAND_24_GHZ, OP_MODE_STA);
            //There must be at least one usable channel in 2.4GHz band
            assertFalse(usableChannels.isEmpty());
        } catch (UnsupportedOperationException ex) {
            //expected if the device does not support this API
        } catch (Exception ex) {
            fail(""getUsableChannels unexpected Exception "" + ex);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Validate that the Passpoint feature is enabled on the device.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"passpoint wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testPasspointCapability"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testPasspointCapability() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        PackageManager packageManager = mContext.getPackageManager();
        assertTrue(""Passpoint must be supported"",
                packageManager.hasSystemFeature(PackageManager.FEATURE_WIFI_PASSPOINT));
    }

    /**
     * Validate add and remove SuggestionUserApprovalStatusListener. And verify the listener's
     * stickiness.
     */"	""	""	"passpoint wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testWifiManagerLock"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testWifiManagerLock() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        final String TAG = ""Test"";
        assertNotNull(mWifiManager.createWifiLock(TAG));
        assertNotNull(mWifiManager.createWifiLock(WifiManager.WIFI_MODE_FULL, TAG));
    }

    /**
     * Test wifi scanning when Wifi is off and location scanning is turned on.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testWifiManagerScanWhenWifiOffLocationTurnedOn"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testWifiManagerScanWhenWifiOffLocationTurnedOn() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        if (!hasLocationFeature()) {
            Log.d(TAG, ""Skipping test as location is not supported"");
            return;
        }
        if (!isLocationEnabled()) {
            fail(""Please enable location for this test - since Marshmallow WiFi scan results are""
                    + "" empty when location is disabled!"");
        }
        runWithScanningEnabled(() -> {
            setWifiEnabled(false);
            Thread.sleep(TEST_WAIT_DURATION_MS);
            startScan();
            if (mWifiManager.isScanAlwaysAvailable() && isScanCurrentlyAvailable()) {
                // Make sure at least one AP is found.
                assertNotNull(""mScanResult should not be null!"", mScanResults);
                assertFalse(""empty scan results!"", mScanResults.isEmpty());
            } else {
                // Make sure no scan results are available.
                assertNull(""mScanResult should be null!"", mScanResults);
            }
            final String TAG = ""Test"";
            assertNotNull(mWifiManager.createWifiLock(TAG));
            assertNotNull(mWifiManager.createWifiLock(WifiManager.WIFI_MODE_FULL, TAG));
        });
    }

    /**
     * Restart WiFi subsystem - verify that privileged call fails.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testRestartWifiSubsystemShouldFailNoPermission"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testRestartWifiSubsystemShouldFailNoPermission() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        try {
            mWifiManager.restartWifiSubsystem();
            fail(""The restartWifiSubsystem should not succeed - privileged call"");
        } catch (SecurityException e) {
            // expected
        }
    }

    /**
     * Restart WiFi subsystem and verify transition through states.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testRestartWifiSubsystem"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testRestartWifiSubsystem() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        mSubsystemRestartStatus = 0; // 0: uninitialized
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            mWifiManager.registerSubsystemRestartTrackingCallback(mExecutor,
                    mSubsystemRestartTrackingCallback);
            synchronized (mLock) {
                mWifiManager.restartWifiSubsystem();
                mLock.wait(TEST_WAIT_DURATION_MS);
            }
            assertEquals(mSubsystemRestartStatus, 1); // 1: restarting
            waitForExpectedWifiState(false);
            assertFalse(mWifiManager.isWifiEnabled());
            synchronized (mLock) {
                mLock.wait(TEST_WAIT_DURATION_MS);
                assertEquals(mSubsystemRestartStatus, 2); // 2: restarted
            }
            waitForExpectedWifiState(true);
            assertTrue(mWifiManager.isWifiEnabled());
        } finally {
            // cleanup
            mWifiManager.unregisterSubsystemRestartTrackingCallback(
                    mSubsystemRestartTrackingCallback);
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * test point of wifiManager properties:
     * 1.enable properties
     * 2.DhcpInfo properties
     * 3.wifi state
     * 4.ConnectionInfo
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testWifiManagerProperties"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testWifiManagerProperties() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        setWifiEnabled(true);
        assertTrue(mWifiManager.isWifiEnabled());
        assertNotNull(mWifiManager.getDhcpInfo());
        assertEquals(WifiManager.WIFI_STATE_ENABLED, mWifiManager.getWifiState());
        mWifiManager.getConnectionInfo();
        setWifiEnabled(false);
        assertFalse(mWifiManager.isWifiEnabled());
    }

    /**
     * Test WiFi scan timestamp - fails when WiFi scan timestamps are inconsistent with
     * {@link SystemClock#elapsedRealtime()} on device.<p>
     * To run this test in cts-tradefed:
     * run cts --class android.net.wifi.cts.WifiManagerTest --method testWifiScanTimestamp
     */
    @VirtualDeviceNotSupported"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testWifiScanTimestamp"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testWifiScanTimestamp() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            Log.d(TAG, ""Skipping test as WiFi is not supported"");
            return;
        }
        if (!hasLocationFeature()) {
            Log.d(TAG, ""Skipping test as location is not supported"");
            return;
        }
        if (!isLocationEnabled()) {
            fail(""Please enable location for this test - since Marshmallow WiFi scan results are""
                    + "" empty when location is disabled!"");
        }
        if (!mWifiManager.isWifiEnabled()) {
            setWifiEnabled(true);
        }
        // Make sure the scan timestamps are consistent with the device timestamp within the range
        // of WIFI_SCAN_TEST_CACHE_DELAY_MILLIS.
        startScan();
        // Make sure at least one AP is found.
        assertTrue(""mScanResult should not be null. This may be due to a scan timeout"",
                   mScanResults != null);
        assertFalse(""empty scan results!"", mScanResults.isEmpty());
        long nowMillis = SystemClock.elapsedRealtime();
        // Keep track of how many APs are fresh in one scan.
        int numFreshAps = 0;
        for (ScanResult result : mScanResults) {
            long scanTimeMillis = TimeUnit.MICROSECONDS.toMillis(result.timestamp);
            if (Math.abs(nowMillis - scanTimeMillis)  < WIFI_SCAN_TEST_CACHE_DELAY_MILLIS) {
                numFreshAps++;
            }
        }
        // At least half of the APs in the scan should be fresh.
        int numTotalAps = mScanResults.size();
        String msg = ""Stale AP count: "" + (numTotalAps - numFreshAps) + "", fresh AP count: ""
                + numFreshAps;
        assertTrue(msg, numFreshAps * 2 >= mScanResults.size());
    }"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testConvertBetweenChannelFrequencyMhz"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testConvertBetweenChannelFrequencyMhz() throws Exception {
        int[] testFrequency_2G = {2412, 2437, 2462, 2484};
        int[] testFrequency_5G = {5180, 5220, 5540, 5745};
        int[] testFrequency_6G = {5955, 6435, 6535, 7115};
        int[] testFrequency_60G = {58320, 64800};
        SparseArray<int[]> testData = new SparseArray<>() {{
            put(ScanResult.WIFI_BAND_24_GHZ, testFrequency_2G);
            put(ScanResult.WIFI_BAND_5_GHZ, testFrequency_5G);
            put(ScanResult.WIFI_BAND_6_GHZ, testFrequency_6G);
            put(ScanResult.WIFI_BAND_60_GHZ, testFrequency_60G);
        }};

        for (int i = 0; i < testData.size(); i++) {
            for (int frequency : testData.valueAt(i)) {
                assertEquals(frequency, ScanResult.convertChannelToFrequencyMhzIfSupported(
                      ScanResult.convertFrequencyMhzToChannelIfSupported(frequency), testData.keyAt(i)));
            }
        }
    }

    // Return true if location is enabled.
    private boolean isLocationEnabled() {
        return Settings.Secure.getInt(getContext().getContentResolver(),
                Settings.Secure.LOCATION_MODE, Settings.Secure.LOCATION_MODE_OFF) !=
                Settings.Secure.LOCATION_MODE_OFF;
    }

    // Returns true if the device has location feature.
    private boolean hasLocationFeature() {
        return getContext().getPackageManager().hasSystemFeature(PackageManager.FEATURE_LOCATION);
    }

    private boolean hasAutomotiveFeature() {
        return getContext().getPackageManager().hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE);
    }"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testSignal"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testSignal() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        final int numLevels = 9;
        int expectLevel = 0;
        assertEquals(expectLevel, WifiManager.calculateSignalLevel(MIN_RSSI, numLevels));
        assertEquals(numLevels - 1, WifiManager.calculateSignalLevel(MAX_RSSI, numLevels));
        expectLevel = 4;
        assertEquals(expectLevel, WifiManager.calculateSignalLevel((MIN_RSSI + MAX_RSSI) / 2,
                numLevels));
        int rssiA = 4;
        int rssiB = 5;
        assertTrue(WifiManager.compareSignalLevel(rssiA, rssiB) < 0);
        rssiB = 4;
        assertTrue(WifiManager.compareSignalLevel(rssiA, rssiB) == 0);
        rssiA = 5;
        rssiB = 4;
        assertTrue(WifiManager.compareSignalLevel(rssiA, rssiB) > 0);
    }

    /**
     * Test that {@link WifiManager#calculateSignalLevel(int)} returns a value in the range
     * [0, {@link WifiManager#getMaxSignalLevel()}], and its value is monotonically increasing as
     * the RSSI increases.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testCalculateSignalLevel"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testCalculateSignalLevel() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }

        int maxSignalLevel = mWifiManager.getMaxSignalLevel();

        int prevSignalLevel = 0;
        for (int rssi = -150; rssi <= 50; rssi++) {
            int signalLevel = mWifiManager.calculateSignalLevel(rssi);

            // between [0, maxSignalLevel]
            assertWithMessage(""For RSSI=%s"", rssi).that(signalLevel).isAtLeast(0);
            assertWithMessage(""For RSSI=%s"", rssi).that(signalLevel).isAtMost(maxSignalLevel);

            // calculateSignalLevel(rssi) <= calculateSignalLevel(rssi + 1)
            assertWithMessage(""For RSSI=%s"", rssi).that(signalLevel).isAtLeast(prevSignalLevel);
            prevSignalLevel = signalLevel;
        }
    }

    public class TestWifiVerboseLoggingStatusChangedListener implements
            WifiManager.WifiVerboseLoggingStatusChangedListener {
        public int numCalls;
        public boolean status;

        @Override
        public void onWifiVerboseLoggingStatusChanged(boolean enabled) {
            numCalls++;
            status = enabled;
        }
    }

    public class TestSoftApCallback implements WifiManager.SoftApCallback {
        Object softApLock;
        int currentState;
        int currentFailureReason;
        List<SoftApInfo> apInfoList = new ArrayList<>();
        SoftApInfo apInfoOnSingleApMode;
        Map<SoftApInfo, List<WifiClient>> apInfoClients = new HashMap<>();
        List<WifiClient> currentClientList;
        SoftApCapability currentSoftApCapability;
        MacAddress lastBlockedClientMacAddress;
        int lastBlockedClientReason;
        boolean onStateChangedCalled = false;
        boolean onSoftApCapabilityChangedCalled = false;
        boolean onConnectedClientCalled = false;
        boolean onConnectedClientChangedWithInfoCalled = false;
        boolean onBlockedClientConnectingCalled = false;
        int onSoftapInfoChangedCalledCount = 0;
        int onSoftapInfoChangedWithListCalledCount = 0;

        TestSoftApCallback(Object lock) {
            softApLock = lock;
        }

        public boolean getOnStateChangedCalled() {
            synchronized(softApLock) {
                return onStateChangedCalled;
            }
        }

        public int getOnSoftapInfoChangedCalledCount() {
            synchronized(softApLock) {
                return onSoftapInfoChangedCalledCount;
            }
        }

        public int getOnSoftApInfoChangedWithListCalledCount() {
            synchronized(softApLock) {
                return onSoftapInfoChangedWithListCalledCount;
            }
        }

        public boolean getOnSoftApCapabilityChangedCalled() {
            synchronized(softApLock) {
                return onSoftApCapabilityChangedCalled;
            }
        }

        public boolean getOnConnectedClientChangedWithInfoCalled() {
            synchronized(softApLock) {
                return onConnectedClientChangedWithInfoCalled;
            }
        }

        public boolean getOnConnectedClientCalled() {
            synchronized(softApLock) {
                return onConnectedClientCalled;
            }
        }

        public boolean getOnBlockedClientConnectingCalled() {
            synchronized(softApLock) {
                return onBlockedClientConnectingCalled;
            }
        }

        public int getCurrentState() {
            synchronized(softApLock) {
                return currentState;
            }
        }

        public int getCurrentStateFailureReason() {
            synchronized(softApLock) {
                return currentFailureReason;
            }
        }

        public List<WifiClient> getCurrentClientList() {
            synchronized(softApLock) {
                return new ArrayList<>(currentClientList);
            }
        }

        public SoftApInfo getCurrentSoftApInfo() {
            synchronized(softApLock) {
                return apInfoOnSingleApMode;
            }
        }

        public List<SoftApInfo> getCurrentSoftApInfoList() {
            synchronized(softApLock) {
                return new ArrayList<>(apInfoList);
            }
        }

        public SoftApCapability getCurrentSoftApCapability() {
            synchronized(softApLock) {
                return currentSoftApCapability;
            }
        }

        public MacAddress getLastBlockedClientMacAddress() {
            synchronized(softApLock) {
                return lastBlockedClientMacAddress;
            }
        }

        public int getLastBlockedClientReason() {
            synchronized(softApLock) {
                return lastBlockedClientReason;
            }
        }

        @Override
        public void onStateChanged(int state, int failureReason) {
            synchronized(softApLock) {
                currentState = state;
                currentFailureReason = failureReason;
                onStateChangedCalled = true;
            }
        }

        @Override
        public void onConnectedClientsChanged(List<WifiClient> clients) {
            synchronized(softApLock) {
                currentClientList = new ArrayList<>(clients);
                onConnectedClientCalled = true;
            }
        }

        @Override
        public void onConnectedClientsChanged(SoftApInfo info, List<WifiClient> clients) {
            synchronized(softApLock) {
                apInfoClients.put(info, clients);
                onConnectedClientChangedWithInfoCalled = true;
            }
        }

        @Override
        public void onInfoChanged(List<SoftApInfo> infoList) {
            synchronized(softApLock) {
                apInfoList = new ArrayList<>(infoList);
                onSoftapInfoChangedWithListCalledCount++;
            }
        }

        @Override
        public void onInfoChanged(SoftApInfo softApInfo) {
            synchronized(softApLock) {
                apInfoOnSingleApMode = softApInfo;
                onSoftapInfoChangedCalledCount++;
            }
        }

        @Override
        public void onCapabilityChanged(SoftApCapability softApCapability) {
            synchronized(softApLock) {
                currentSoftApCapability = softApCapability;
                onSoftApCapabilityChangedCalled = true;
            }
        }

        @Override
        public void onBlockedClientConnecting(WifiClient client, int blockedReason) {
            synchronized(softApLock) {
                lastBlockedClientMacAddress = client.getMacAddress();
                lastBlockedClientReason = blockedReason;
                onBlockedClientConnectingCalled = true;
            }
        }
    }

    private static class TestLocalOnlyHotspotCallback extends WifiManager.LocalOnlyHotspotCallback {
        Object hotspotLock;
        WifiManager.LocalOnlyHotspotReservation reservation = null;
        boolean onStartedCalled = false;
        boolean onStoppedCalled = false;
        boolean onFailedCalled = false;
        int failureReason = -1;

        TestLocalOnlyHotspotCallback(Object lock) {
            hotspotLock = lock;
        }

        @Override
        public void onStarted(WifiManager.LocalOnlyHotspotReservation r) {
            synchronized (hotspotLock) {
                reservation = r;
                onStartedCalled = true;
                hotspotLock.notify();
            }
        }

        @Override
        public void onStopped() {
            synchronized (hotspotLock) {
                onStoppedCalled = true;
                hotspotLock.notify();
            }
        }

        @Override
        public void onFailed(int reason) {
            synchronized (hotspotLock) {
                onFailedCalled = true;
                failureReason = reason;
                hotspotLock.notify();
            }
        }
    }

    private List<Integer> getSupportedSoftApBand(SoftApCapability capability) {
        List<Integer> supportedApBands = new ArrayList<>();
        if (mWifiManager.is24GHzBandSupported() &&
                capability.areFeaturesSupported(
                        SoftApCapability.SOFTAP_FEATURE_BAND_24G_SUPPORTED)) {
            supportedApBands.add(SoftApConfiguration.BAND_2GHZ);
        }
        if (mWifiManager.is5GHzBandSupported() &&
                capability.areFeaturesSupported(
                        SoftApCapability.SOFTAP_FEATURE_BAND_5G_SUPPORTED)) {
            supportedApBands.add(SoftApConfiguration.BAND_5GHZ);
        }
        if (mWifiManager.is6GHzBandSupported() &&
                capability.areFeaturesSupported(
                        SoftApCapability.SOFTAP_FEATURE_BAND_6G_SUPPORTED)) {
            supportedApBands.add(SoftApConfiguration.BAND_6GHZ);
        }
        if (mWifiManager.is60GHzBandSupported() &&
                capability.areFeaturesSupported(
                        SoftApCapability.SOFTAP_FEATURE_BAND_60G_SUPPORTED)) {
            supportedApBands.add(SoftApConfiguration.BAND_60GHZ);
        }
        return supportedApBands;
    }

    private TestLocalOnlyHotspotCallback startLocalOnlyHotspot() {
        // Location mode must be enabled for this test
        if (!isLocationEnabled()) {
            fail(""Please enable location for this test"");
        }

        TestExecutor executor = new TestExecutor();
        TestSoftApCallback capabilityCallback = new TestSoftApCallback(mLock);
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        List<Integer> supportedSoftApBands = new ArrayList<>();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            verifyRegisterSoftApCallback(executor, capabilityCallback);
            supportedSoftApBands = getSupportedSoftApBand(
                    capabilityCallback.getCurrentSoftApCapability());
        } catch (Exception ex) {
        } finally {
            // clean up
            mWifiManager.unregisterSoftApCallback(capabilityCallback);
            uiAutomation.dropShellPermissionIdentity();
        }
        TestLocalOnlyHotspotCallback callback = new TestLocalOnlyHotspotCallback(mLock);
        synchronized (mLock) {
            try {
                mWifiManager.startLocalOnlyHotspot(callback, null);
                // now wait for callback
                mLock.wait(TEST_WAIT_DURATION_MS);
            } catch (InterruptedException e) {
            }
            // check if we got the callback
            assertTrue(callback.onStartedCalled);

            SoftApConfiguration softApConfig = callback.reservation.getSoftApConfiguration();
            assertNotNull(softApConfig);
            int securityType = softApConfig.getSecurityType();
            if (securityType == SoftApConfiguration.SECURITY_TYPE_OPEN
                    || securityType == SoftApConfiguration.SECURITY_TYPE_WPA2_PSK
                    || securityType == SoftApConfiguration.SECURITY_TYPE_WPA3_SAE_TRANSITION) {
                assertNotNull(softApConfig.toWifiConfiguration());
            } else {
                assertNull(softApConfig.toWifiConfiguration());
            }
            if (!hasAutomotiveFeature()) {
                assertEquals(supportedSoftApBands.size() > 0 ? supportedSoftApBands.get(0)
                        : SoftApConfiguration.BAND_2GHZ,
                        callback.reservation.getSoftApConfiguration().getBand());
            }
            assertFalse(callback.onFailedCalled);
            assertFalse(callback.onStoppedCalled);
        }
        return callback;
    }

    private void stopLocalOnlyHotspot(TestLocalOnlyHotspotCallback callback, boolean wifiEnabled) {
       synchronized (mMySync) {
           // we are expecting a new state
           mMySync.expectedState = STATE_WIFI_CHANGING;

           // now shut down LocalOnlyHotspot
           callback.reservation.close();

           try {
               waitForExpectedWifiState(wifiEnabled);
           } catch (InterruptedException e) {}
        }
    }

    /**
     * Verify that calls to startLocalOnlyHotspot succeed with proper permissions.
     *
     * Note: Location mode must be enabled for this test.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testStartLocalOnlyHotspotSuccess"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testStartLocalOnlyHotspotSuccess() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // check that softap mode is supported by the device
        if (!mWifiManager.isPortableHotspotSupported()) {
            return;
        }

        boolean wifiEnabled = mWifiManager.isWifiEnabled();

        TestLocalOnlyHotspotCallback callback = startLocalOnlyHotspot();

        // add sleep to avoid calling stopLocalOnlyHotspot before TetherController initialization.
        // TODO: remove this sleep as soon as b/124330089 is fixed.
        Log.d(TAG, ""Sleeping for 2 seconds"");
        Thread.sleep(2000);

        stopLocalOnlyHotspot(callback, wifiEnabled);

        // wifi should either stay on, or come back on
        assertEquals(wifiEnabled, mWifiManager.isWifiEnabled());
    }

    /**
     * Verify calls to deprecated API's all fail for non-settings apps targeting >= Q SDK.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testDeprecatedApis"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testDeprecatedApis() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        setWifiEnabled(true);
        waitForConnection(); // ensures that there is at-least 1 saved network on the device.

        WifiConfiguration wifiConfiguration = new WifiConfiguration();
        wifiConfiguration.SSID = SSID1;
        wifiConfiguration.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.NONE);

        assertEquals(INVALID_NETWORK_ID,
                mWifiManager.addNetwork(wifiConfiguration));
        assertEquals(INVALID_NETWORK_ID,
                mWifiManager.updateNetwork(wifiConfiguration));
        assertFalse(mWifiManager.enableNetwork(0, true));
        assertFalse(mWifiManager.disableNetwork(0));
        assertFalse(mWifiManager.removeNetwork(0));
        assertFalse(mWifiManager.disconnect());
        assertFalse(mWifiManager.reconnect());
        assertFalse(mWifiManager.reassociate());
        assertTrue(mWifiManager.getConfiguredNetworks().isEmpty());

        boolean wifiEnabled = mWifiManager.isWifiEnabled();
        // now we should fail to toggle wifi state.
        assertFalse(mWifiManager.setWifiEnabled(!wifiEnabled));
        Thread.sleep(TEST_WAIT_DURATION_MS);
        assertEquals(wifiEnabled, mWifiManager.isWifiEnabled());
    }

    /**
     * Test the WifiManager APIs that return whether a feature is supported.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testGetSupportedFeatures"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testGetSupportedFeatures() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        if (!WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(mContext)) {
            // Skip the test if wifi module version is older than S.
            return;
        }
        mWifiManager.isMakeBeforeBreakWifiSwitchingSupported();
        mWifiManager.isStaBridgedApConcurrencySupported();
    }

    /**
     * Verify non DO apps cannot call removeNonCallerConfiguredNetworks.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testRemoveNonCallerConfiguredNetworksNotAllowed"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testRemoveNonCallerConfiguredNetworksNotAllowed() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        if (!WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(mContext)) {
            // Skip the test if wifi module version is older than S.
            return;
        }
        try {
            mWifiManager.removeNonCallerConfiguredNetworks();
            fail(""Expected security exception for non DO app"");
        } catch (SecurityException e) {
        }
    }

    /**
     * Test coverage for the constructor of AddNetworkResult.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testAddNetworkResultCreation"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testAddNetworkResultCreation() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        if (!WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(mContext)) {
            // Skip the test if wifi module version is older than S.
            return;
        }
        int statusCode = WifiManager.AddNetworkResult.STATUS_NO_PERMISSION;
        int networkId = 5;
        WifiManager.AddNetworkResult result = new WifiManager.AddNetworkResult(
            statusCode, networkId);
        assertEquals(""statusCode should match"", statusCode, result.statusCode);
        assertEquals(""networkId should match"", networkId, result.networkId);
    }

    /**
     * Verify that {@link WifiManager#addNetworkPrivileged(WifiConfiguration)} throws a
     * SecurityException when called by a normal app.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testAddNetworkPrivilegedNotAllowedForNormalApps"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testAddNetworkPrivilegedNotAllowedForNormalApps() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        if (!WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(mContext)) {
            // Skip the test if wifi module version is older than S.
            return;
        }
        try {
            WifiConfiguration newOpenNetwork = new WifiConfiguration();
            newOpenNetwork.SSID = ""\"""" + TEST_SSID_UNQUOTED + ""\"""";
            mWifiManager.addNetworkPrivileged(newOpenNetwork);
            fail(""A normal app should not be able to call this API."");
        } catch (SecurityException e) {
        }
    }

    /**
     * Verify {@link WifiManager#addNetworkPrivileged(WifiConfiguration)} throws an exception when
     * null is the input.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testAddNetworkPrivilegedBadInput"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testAddNetworkPrivilegedBadInput() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        if (!WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(mContext)) {
            // Skip the test if wifi module version is older than S.
            return;
        }
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            mWifiManager.addNetworkPrivileged(null);
            fail(""Expected IllegalArgumentException"");
        } catch (IllegalArgumentException e) {
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Verify {@link WifiManager#addNetworkPrivileged(WifiConfiguration)} returns the proper
     * failure status code when adding an enterprise config with mandatory fields not filled in.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testAddNetworkPrivilegedFailureBadEnterpriseConfig"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testAddNetworkPrivilegedFailureBadEnterpriseConfig() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        if (!WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(mContext)) {
            // Skip the test if wifi module version is older than S.
            return;
        }
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            WifiConfiguration wifiConfiguration = new WifiConfiguration();
            wifiConfiguration.SSID = SSID1;
            wifiConfiguration.setSecurityParams(WifiConfiguration.SECURITY_TYPE_EAP_WPA3_ENTERPRISE);
            wifiConfiguration.enterpriseConfig.setEapMethod(WifiEnterpriseConfig.Eap.TTLS);
            WifiManager.AddNetworkResult result =
                    mWifiManager.addNetworkPrivileged(wifiConfiguration);
            assertEquals(WifiManager.AddNetworkResult.STATUS_INVALID_CONFIGURATION_ENTERPRISE,
                    result.statusCode);
            assertEquals(-1, result.networkId);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Verify {@link WifiManager#addNetworkPrivileged(WifiConfiguration)} works properly when the
     * calling app has permissions.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testAddNetworkPrivilegedSuccess"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testAddNetworkPrivilegedSuccess() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        if (!WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(mContext)) {
            // Skip the test if wifi module version is older than S.
            return;
        }
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        WifiManager.AddNetworkResult result = null;
        try {
            uiAutomation.adoptShellPermissionIdentity();
            WifiConfiguration newOpenNetwork = new WifiConfiguration();
            newOpenNetwork.SSID = ""\"""" + TEST_SSID_UNQUOTED + ""\"""";
            result = mWifiManager.addNetworkPrivileged(newOpenNetwork);
            assertEquals(WifiManager.AddNetworkResult.STATUS_SUCCESS, result.statusCode);
            assertTrue(result.networkId >= 0);
            List<WifiConfiguration> configuredNetworks = mWifiManager.getConfiguredNetworks();
            boolean found = false;
            for (WifiConfiguration config : configuredNetworks) {
                if (config.networkId == result.networkId
                        && config.SSID.equals(newOpenNetwork.SSID)) {
                    found = true;
                    break;
                }
            }
            assertTrue(""addNetworkPrivileged returns success""
                    + ""but the network is not found in getConfiguredNetworks"", found);

            List<WifiConfiguration> privilegedConfiguredNetworks =
                    mWifiManager.getPrivilegedConfiguredNetworks();
            found = false;
            for (WifiConfiguration config : privilegedConfiguredNetworks) {
                if (config.networkId == result.networkId
                        && config.SSID.equals(newOpenNetwork.SSID)) {
                    found = true;
                    break;
                }
            }
            assertTrue(""addNetworkPrivileged returns success""
                    + ""but the network is not found in getPrivilegedConfiguredNetworks"", found);

            List<WifiConfiguration> callerConfiguredNetworks =
                    mWifiManager.getCallerConfiguredNetworks();
            found = false;
            for (WifiConfiguration config : callerConfiguredNetworks) {
                if (config.networkId == result.networkId
                        && config.SSID.equals(newOpenNetwork.SSID)) {
                    found = true;
                    break;
                }
            }
            assertTrue(""addNetworkPrivileged returns success""
                    + ""but the network is not found in getCallerConfiguredNetworks"", found);
        } finally {
            if (null != result) {
                mWifiManager.removeNetwork(result.networkId);
            }
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    private WifiConfiguration createConfig(
            String ssid, int type) {
        WifiConfiguration config = new WifiConfiguration();
        config.SSID = ""\"""" + ssid + ""\"""";
        config.setSecurityParams(type);
        // set necessary fields for different types.
        switch (type) {
            case WifiConfiguration.SECURITY_TYPE_OPEN:
            case WifiConfiguration.SECURITY_TYPE_OWE:
                break;
            case WifiConfiguration.SECURITY_TYPE_PSK:
            case WifiConfiguration.SECURITY_TYPE_SAE:
                config.preSharedKey = ""\""1qaz@WSX\"""";
                break;
            case WifiConfiguration.SECURITY_TYPE_EAP:
            case WifiConfiguration.SECURITY_TYPE_EAP_WPA3_ENTERPRISE:
            case WifiConfiguration.SECURITY_TYPE_EAP_WPA3_ENTERPRISE_192_BIT:
                config.enterpriseConfig.setEapMethod(WifiEnterpriseConfig.Eap.SIM);
                break;
        }
        return config;
    }

    private void assertConfigsAreFound(
            List<WifiConfiguration> expectedConfigs,
            List<WifiConfiguration> configs) {
        for (WifiConfiguration expectedConfig: expectedConfigs) {
            boolean found = false;
            for (WifiConfiguration config : configs) {
                if (config.networkId == expectedConfig.networkId
                        && config.getKey().equals(expectedConfig.getKey())) {
                    found = true;
                    break;
                }
            }
            assertTrue(""the network "" + expectedConfig.getKey() + "" is not found"", found);
        }
    }

    /**
     * Verify {@link WifiManager#addNetworkPrivileged(WifiConfiguration)} works
     * with merging types properly when the calling app has permissions.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testAddNetworkPrivilegedMergingTypeSuccess"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testAddNetworkPrivilegedMergingTypeSuccess() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        if (!WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(mContext)) {
            // Skip the test if wifi module version is older than S.
            return;
        }
        List<WifiConfiguration> testConfigs = new ArrayList<>();
        testConfigs.add(createConfig(""test-open-owe-jdur"", WifiConfiguration.SECURITY_TYPE_OPEN));
        testConfigs.add(createConfig(""test-open-owe-jdur"", WifiConfiguration.SECURITY_TYPE_OWE));
        testConfigs.add(createConfig(""test-psk-sae-ijfe"", WifiConfiguration.SECURITY_TYPE_PSK));
        testConfigs.add(createConfig(""test-psk-sae-ijfe"", WifiConfiguration.SECURITY_TYPE_SAE));
        testConfigs.add(createConfig(""test-wpa2e-wpa3e-plki"",
                WifiConfiguration.SECURITY_TYPE_EAP));
        testConfigs.add(createConfig(""test-wpa2e-wpa3e-plki"",
                WifiConfiguration.SECURITY_TYPE_EAP_WPA3_ENTERPRISE));
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            final int originalConfiguredNetworksNumber = mWifiManager.getConfiguredNetworks().size();
            final int originalPrivilegedConfiguredNetworksNumber =
                    mWifiManager.getPrivilegedConfiguredNetworks().size();
            final int originalCallerConfiguredNetworksNumber =
                mWifiManager.getCallerConfiguredNetworks().size();
            for (WifiConfiguration c: testConfigs) {
                WifiManager.AddNetworkResult result = mWifiManager.addNetworkPrivileged(c);
                assertEquals(WifiManager.AddNetworkResult.STATUS_SUCCESS, result.statusCode);
                assertTrue(result.networkId >= 0);
                c.networkId = result.networkId;
            }
            List<WifiConfiguration> expectedConfigs = testConfigs;
            if (SdkLevel.isAtLeastS()) {
                // open/owe, psk/sae, and wpa2e/wpa3e should be merged
                // so they should have the same network ID.
                assertEquals(testConfigs.get(0).networkId, testConfigs.get(1).networkId);
                assertEquals(testConfigs.get(2).networkId, testConfigs.get(3).networkId);
                assertEquals(testConfigs.get(4).networkId, testConfigs.get(5).networkId);
            } else {
                // Network IDs for different security types should be unique for R
                assertNotEquals(testConfigs.get(0).networkId, testConfigs.get(1).networkId);
                assertNotEquals(testConfigs.get(2).networkId, testConfigs.get(3).networkId);
                assertNotEquals(testConfigs.get(4).networkId, testConfigs.get(5).networkId);
                // WPA3-Enterprise is omitted when WPA2-Enterprise is present for R
                expectedConfigs = testConfigs.subList(0, 5);
            }
            List<WifiConfiguration> configuredNetworks = mWifiManager.getConfiguredNetworks();
            assertEquals(originalConfiguredNetworksNumber + expectedConfigs.size(),
                    configuredNetworks.size());
            assertConfigsAreFound(expectedConfigs, configuredNetworks);

            List<WifiConfiguration> privilegedConfiguredNetworks =
                    mWifiManager.getPrivilegedConfiguredNetworks();
            assertEquals(originalPrivilegedConfiguredNetworksNumber + expectedConfigs.size(),
                    privilegedConfiguredNetworks.size());
            assertConfigsAreFound(expectedConfigs, privilegedConfiguredNetworks);

            List<WifiConfiguration> callerConfiguredNetworks =
                    mWifiManager.getCallerConfiguredNetworks();
            assertEquals(originalCallerConfiguredNetworksNumber + expectedConfigs.size(),
                    callerConfiguredNetworks.size());
            assertConfigsAreFound(expectedConfigs, callerConfiguredNetworks);

        } finally {
            for (WifiConfiguration c: testConfigs) {
                if (c.networkId >= 0) {
                    mWifiManager.removeNetwork(c.networkId);
                }
            }
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Verify that applications can only have one registered LocalOnlyHotspot request at a time.
     *
     * Note: Location mode must be enabled for this test.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testStartLocalOnlyHotspotSingleRequestByApps"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testStartLocalOnlyHotspotSingleRequestByApps() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // check that softap mode is supported by the device
        if (!mWifiManager.isPortableHotspotSupported()) {
            return;
        }

        boolean caughtException = false;

        boolean wifiEnabled = mWifiManager.isWifiEnabled();

        TestLocalOnlyHotspotCallback callback = startLocalOnlyHotspot();

        // now make a second request - this should fail.
        TestLocalOnlyHotspotCallback callback2 = new TestLocalOnlyHotspotCallback(mLock);
        try {
            mWifiManager.startLocalOnlyHotspot(callback2, null);
        } catch (IllegalStateException e) {
            Log.d(TAG, ""Caught the IllegalStateException we expected: called startLOHS twice"");
            caughtException = true;
        }
        if (!caughtException) {
            // second start did not fail, should clean up the hotspot.

            // add sleep to avoid calling stopLocalOnlyHotspot before TetherController initialization.
            // TODO: remove this sleep as soon as b/124330089 is fixed.
            Log.d(TAG, ""Sleeping for 2 seconds"");
            Thread.sleep(2000);

            stopLocalOnlyHotspot(callback2, wifiEnabled);
        }
        assertTrue(caughtException);

        // add sleep to avoid calling stopLocalOnlyHotspot before TetherController initialization.
        // TODO: remove this sleep as soon as b/124330089 is fixed.
        Log.d(TAG, ""Sleeping for 2 seconds"");
        Thread.sleep(2000);

        stopLocalOnlyHotspot(callback, wifiEnabled);
    }

    private static class TestExecutor implements Executor {
        private ConcurrentLinkedQueue<Runnable> tasks = new ConcurrentLinkedQueue<>();

        @Override
        public void execute(Runnable task) {
            tasks.add(task);
        }

        private void runAll() {
            Runnable task = tasks.poll();
            while (task != null) {
                task.run();
                task = tasks.poll();
            }
        }
    }"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testStartLocalOnlyHotspotWithConfigBssid"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testStartLocalOnlyHotspotWithConfigBssid() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // check that softap mode is supported by the device
        if (!mWifiManager.isPortableHotspotSupported()) {
            return;
        }

        TestExecutor executor = new TestExecutor();
        TestLocalOnlyHotspotCallback callback = new TestLocalOnlyHotspotCallback(mLock);
        TestSoftApCallback capabilityCallback = new TestSoftApCallback(mLock);
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        boolean wifiEnabled = mWifiManager.isWifiEnabled();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            verifyRegisterSoftApCallback(executor, capabilityCallback);
            SoftApConfiguration.Builder customConfigBuilder = new SoftApConfiguration.Builder()
                    .setSsid(TEST_SSID_UNQUOTED)
                    .setPassphrase(TEST_PASSPHRASE, SoftApConfiguration.SECURITY_TYPE_WPA2_PSK);

            boolean isSupportCustomizedMac = capabilityCallback.getCurrentSoftApCapability()
                        .areFeaturesSupported(
                        SoftApCapability.SOFTAP_FEATURE_MAC_ADDRESS_CUSTOMIZATION)
                    && PropertyUtil.isVndkApiLevelNewerThan(Build.VERSION_CODES.S);
            if (isSupportCustomizedMac) {
                customConfigBuilder.setBssid(TEST_MAC);
            }
            SoftApConfiguration customConfig = customConfigBuilder.build();

            mWifiManager.startLocalOnlyHotspot(customConfig, executor, callback);
            // now wait for callback
            Thread.sleep(TEST_WAIT_DURATION_MS);

            // Verify callback is run on the supplied executor
            assertFalse(callback.onStartedCalled);
            executor.runAll();
            assertTrue(callback.onStartedCalled);

            assertNotNull(callback.reservation);
            SoftApConfiguration softApConfig = callback.reservation.getSoftApConfiguration();
            assertNotNull(softApConfig);
            if (isSupportCustomizedMac) {
                assertEquals(TEST_MAC, softApConfig.getBssid());
            }
            assertEquals(TEST_SSID_UNQUOTED, softApConfig.getSsid());
            assertEquals(TEST_PASSPHRASE, softApConfig.getPassphrase());
        } finally {
            // clean up
            stopLocalOnlyHotspot(callback, wifiEnabled);
            mWifiManager.unregisterSoftApCallback(capabilityCallback);
            uiAutomation.dropShellPermissionIdentity();
        }
    }"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testNetworkStackPermission"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testNetworkStackPermission() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        final PackageManager pm = getContext().getPackageManager();

        final List<PackageInfo> holding = pm.getPackagesHoldingPermissions(new String[] {
                android.Manifest.permission.NETWORK_STACK
        }, PackageManager.MATCH_UNINSTALLED_PACKAGES);
        for (PackageInfo pi : holding) {
            fail(""The NETWORK_STACK permission must not be held by "" + pi.packageName
                    + "" and must be revoked for security reasons"");
        }
    }

    /**
     * Verify that the {@link android.Manifest.permission#NETWORK_SETTINGS} permission is
     * never held by any package.
     * <p>
     * Only Settings, SysUi, NetworkStack and shell apps should <em>ever</em> attempt to acquire
     * this permission, since it would give those apps extremely broad access to connectivity
     * functionality.  The permission is intended to be granted to only those apps with direct user
     * access and no others.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testNetworkSettingsPermission"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testNetworkSettingsPermission() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        final PackageManager pm = getContext().getPackageManager();

        final ArraySet<String> allowedPackages = new ArraySet();
        final ArraySet<Integer> allowedUIDs = new ArraySet();
        // explicitly add allowed UIDs
        allowedUIDs.add(Process.SYSTEM_UID);
        allowedUIDs.add(Process.SHELL_UID);
        allowedUIDs.add(Process.PHONE_UID);
        allowedUIDs.add(Process.NETWORK_STACK_UID);
        allowedUIDs.add(Process.NFC_UID);

        // only quick settings is allowed to bind to the BIND_QUICK_SETTINGS_TILE permission, using
        // this fact to determined allowed package name for sysui. This is a signature permission,
        // so allow any package with this permission.
        final List<PackageInfo> sysuiPackages = pm.getPackagesHoldingPermissions(new String[] {
                android.Manifest.permission.BIND_QUICK_SETTINGS_TILE
        }, PackageManager.MATCH_UNINSTALLED_PACKAGES);
        for (PackageInfo info : sysuiPackages) {
            allowedPackages.add(info.packageName);
        }

        // the captive portal flow also currently holds the NETWORK_SETTINGS permission
        final Intent intent = new Intent(ConnectivityManager.ACTION_CAPTIVE_PORTAL_SIGN_IN);
        final ResolveInfo ri = pm.resolveActivity(intent, PackageManager.MATCH_DISABLED_COMPONENTS);
        if (ri != null) {
            allowedPackages.add(ri.activityInfo.packageName);
        }

        final List<PackageInfo> holding = pm.getPackagesHoldingPermissions(new String[] {
                android.Manifest.permission.NETWORK_SETTINGS
        }, PackageManager.MATCH_UNINSTALLED_PACKAGES);
        StringBuilder stringBuilder = new StringBuilder();
        for (PackageInfo pi : holding) {
            String packageName = pi.packageName;

            // this is an explicitly allowed package
            if (allowedPackages.contains(packageName)) continue;

            // now check if the packages are from allowed UIDs
            int uid = -1;
            try {
                uid = pm.getPackageUidAsUser(packageName, UserHandle.USER_SYSTEM);
            } catch (PackageManager.NameNotFoundException e) {
                continue;
            }
            if (!allowedUIDs.contains(uid)) {
                stringBuilder.append(""The NETWORK_SETTINGS permission must not be held by ""
                    + packageName + "":"" + uid + "" and must be revoked for security reasons\n"");
            }
        }
        if (stringBuilder.length() > 0) {
            fail(stringBuilder.toString());
        }
    }

    /**
     * Verify that the {@link android.Manifest.permission#NETWORK_SETUP_WIZARD} permission is
     * only held by the device setup wizard application.
     * <p>
     * Only the SetupWizard app should <em>ever</em> attempt to acquire this
     * permission, since it would give those apps extremely broad access to connectivity
     * functionality.  The permission is intended to be granted to only the device setup wizard.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testNetworkSetupWizardPermission"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testNetworkSetupWizardPermission() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        final ArraySet<String> allowedPackages = new ArraySet();

        final PackageManager pm = getContext().getPackageManager();

        final Intent intent = new Intent(Intent.ACTION_MAIN);
        intent.addCategory(Intent.CATEGORY_SETUP_WIZARD);
        final ResolveInfo ri = pm.resolveActivity(intent, PackageManager.MATCH_DISABLED_COMPONENTS);
        String validPkg = """";
        if (ri != null) {
            allowedPackages.add(ri.activityInfo.packageName);
            validPkg = ri.activityInfo.packageName;
        }

        final Intent preIntent = new Intent(""com.android.setupwizard.OEM_PRE_SETUP"");
        preIntent.addCategory(Intent.CATEGORY_DEFAULT);
        final ResolveInfo preRi = pm
            .resolveActivity(preIntent, PackageManager.MATCH_DISABLED_COMPONENTS);
        String prePackageName = """";
        if (null != preRi) {
            prePackageName = preRi.activityInfo.packageName;
        }

        final Intent postIntent = new Intent(""com.android.setupwizard.OEM_POST_SETUP"");
        postIntent.addCategory(Intent.CATEGORY_DEFAULT);
        final ResolveInfo postRi = pm
            .resolveActivity(postIntent, PackageManager.MATCH_DISABLED_COMPONENTS);
        String postPackageName = """";
        if (null != postRi) {
            postPackageName = postRi.activityInfo.packageName;
        }
        if (!TextUtils.isEmpty(prePackageName) && !TextUtils.isEmpty(postPackageName)
            && prePackageName.equals(postPackageName)) {
            allowedPackages.add(prePackageName);
        }

        final List<PackageInfo> holding = pm.getPackagesHoldingPermissions(new String[]{
            android.Manifest.permission.NETWORK_SETUP_WIZARD
        }, PackageManager.MATCH_UNINSTALLED_PACKAGES);
        for (PackageInfo pi : holding) {
            if (!allowedPackages.contains(pi.packageName)) {
                fail(""The NETWORK_SETUP_WIZARD permission must not be held by "" + pi.packageName
                    + "" and must be revoked for security reasons ["" + validPkg + ""]"");
            }
        }
    }

    /**
     * Verify that the {@link android.Manifest.permission#NETWORK_MANAGED_PROVISIONING} permission
     * is only held by the device managed provisioning application.
     * <p>
     * Only the ManagedProvisioning app should <em>ever</em> attempt to acquire this
     * permission, since it would give those apps extremely broad access to connectivity
     * functionality.  The permission is intended to be granted to only the device managed
     * provisioning.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testNetworkManagedProvisioningPermission"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testNetworkManagedProvisioningPermission() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        final PackageManager pm = getContext().getPackageManager();

        // TODO(b/115980767): Using hardcoded package name. Need a better mechanism to find the
        // managed provisioning app.
        // Ensure that the package exists.
        final Intent intent = new Intent(Intent.ACTION_MAIN);
        intent.setPackage(MANAGED_PROVISIONING_PACKAGE_NAME);
        final ResolveInfo ri = pm.resolveActivity(intent, PackageManager.MATCH_DISABLED_COMPONENTS);
        String validPkg = """";
        if (ri != null) {
            validPkg = ri.activityInfo.packageName;
        }

        final List<PackageInfo> holding = pm.getPackagesHoldingPermissions(new String[] {
                android.Manifest.permission.NETWORK_MANAGED_PROVISIONING
        }, PackageManager.MATCH_UNINSTALLED_PACKAGES);
        for (PackageInfo pi : holding) {
            if (!Objects.equals(pi.packageName, validPkg)) {
                fail(""The NETWORK_MANAGED_PROVISIONING permission must not be held by ""
                        + pi.packageName + "" and must be revoked for security reasons [""
                        + validPkg +""]"");
            }
        }
    }

    /**
     * Verify that the {@link android.Manifest.permission#WIFI_SET_DEVICE_MOBILITY_STATE} permission
     * is held by at most one application.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testWifiSetDeviceMobilityStatePermission"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testWifiSetDeviceMobilityStatePermission() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        final PackageManager pm = getContext().getPackageManager();

        final List<PackageInfo> holding = pm.getPackagesHoldingPermissions(new String[] {
                android.Manifest.permission.WIFI_SET_DEVICE_MOBILITY_STATE
        }, PackageManager.MATCH_UNINSTALLED_PACKAGES);

        List<String> uniquePackageNames = holding
                .stream()
                .map(pi -> pi.packageName)
                .distinct()
                .collect(Collectors.toList());

        if (uniquePackageNames.size() > 1) {
            fail(""The WIFI_SET_DEVICE_MOBILITY_STATE permission must not be held by more than one ""
                    + ""application, but is held by "" + uniquePackageNames.size() + "" applications: ""
                    + String.join("", "", uniquePackageNames));
        }
    }

    /**
     * Verify that the {@link android.Manifest.permission#NETWORK_CARRIER_PROVISIONING} permission
     * is held by at most one application.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testNetworkCarrierProvisioningPermission"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testNetworkCarrierProvisioningPermission() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        final PackageManager pm = getContext().getPackageManager();

        final List<PackageInfo> holding = pm.getPackagesHoldingPermissions(new String[] {
                android.Manifest.permission.NETWORK_CARRIER_PROVISIONING
        }, PackageManager.MATCH_UNINSTALLED_PACKAGES);

        List<String> uniquePackageNames = holding
                .stream()
                .map(pi -> pi.packageName)
                .distinct()
                .collect(Collectors.toList());

        if (uniquePackageNames.size() > 2) {
            fail(""The NETWORK_CARRIER_PROVISIONING permission must not be held by more than two ""
                    + ""applications, but is held by "" + uniquePackageNames.size() + "" applications: ""
                    + String.join("", "", uniquePackageNames));
        }
    }

    /**
     * Verify that the {@link android.Manifest.permission#WIFI_UPDATE_USABILITY_STATS_SCORE}
     * permission is held by at most one application.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testUpdateWifiUsabilityStatsScorePermission"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testUpdateWifiUsabilityStatsScorePermission() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        final PackageManager pm = getContext().getPackageManager();

        final List<PackageInfo> holding = pm.getPackagesHoldingPermissions(new String[] {
                android.Manifest.permission.WIFI_UPDATE_USABILITY_STATS_SCORE
        }, PackageManager.MATCH_UNINSTALLED_PACKAGES);

        Set<String> uniqueNonSystemPackageNames = new HashSet<>();
        for (PackageInfo pi : holding) {
            String packageName = pi.packageName;
            // Shell is allowed to hold this permission for testing.
            int uid = -1;
            try {
                uid = pm.getPackageUidAsUser(packageName, UserHandle.USER_SYSTEM);
            } catch (PackageManager.NameNotFoundException e) {
                continue;
            }
            if (uid == Process.SHELL_UID) continue;

            uniqueNonSystemPackageNames.add(packageName);
        }

        if (uniqueNonSystemPackageNames.size() > 1) {
            fail(""The WIFI_UPDATE_USABILITY_STATS_SCORE permission must not be held by more than ""
                + ""one application, but is held by "" + uniqueNonSystemPackageNames.size()
                + "" applications: "" + String.join("", "", uniqueNonSystemPackageNames));
        }
    }

    private void turnScreenOnNoDelay() throws Exception {
        mUiDevice.executeShellCommand(""input keyevent KEYCODE_WAKEUP"");
        mUiDevice.executeShellCommand(""wm dismiss-keyguard"");
    }

    private void turnScreenOn() throws Exception {
        turnScreenOnNoDelay();
        // Since the screen on/off intent is ordered, they will not be sent right now.
        Thread.sleep(DURATION_SCREEN_TOGGLE);
    }

    private void turnScreenOffNoDelay() throws Exception {
        mUiDevice.executeShellCommand(""input keyevent KEYCODE_SLEEP"");
    }

    private void turnScreenOff() throws Exception {
        turnScreenOffNoDelay();
        // Since the screen on/off intent is ordered, they will not be sent right now.
        Thread.sleep(DURATION_SCREEN_TOGGLE);
    }

    private void assertWifiScanningIsOn() {
        if (!mWifiManager.isScanAlwaysAvailable()) {
            fail(""Wi-Fi scanning should be on."");
        }
    }

    private void runWithScanningEnabled(ThrowingRunnable r) throws Exception {
        boolean wasScanEnabledForTest = false;
        if (!mWifiManager.isScanAlwaysAvailable()) {
            ShellIdentityUtils.invokeWithShellPermissions(
                    () -> mWifiManager.setScanAlwaysAvailable(true));
            wasScanEnabledForTest = true;
        }
        try {
            r.run();
        } finally {
            if (wasScanEnabledForTest) {
                ShellIdentityUtils.invokeWithShellPermissions(
                        () -> mWifiManager.setScanAlwaysAvailable(false));
            }
        }
    }

    /**
     * Verify that Wi-Fi scanning is not turned off when the screen turns off while wifi is disabled
     * but location is on.
     * @throws Exception
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testScreenOffDoesNotTurnOffWifiScanningWhenWifiDisabled"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testScreenOffDoesNotTurnOffWifiScanningWhenWifiDisabled() throws Exception {
        if (FeatureUtil.isTV() || FeatureUtil.isAutomotive()) {
            // TV and auto do not support the setting options of WIFI scanning and Bluetooth
            // scanning
            return;
        }
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        if (!hasLocationFeature()) {
            // skip the test if location is not supported
            return;
        }
        if (!isLocationEnabled()) {
            fail(""Please enable location for this test - since Marshmallow WiFi scan results are""
                    + "" empty when location is disabled!"");
        }
        runWithScanningEnabled(() -> {
            setWifiEnabled(false);
            turnScreenOn();
            assertWifiScanningIsOn();
            // Toggle screen and verify Wi-Fi scanning is still on.
            turnScreenOff();
            assertWifiScanningIsOn();
            turnScreenOn();
            assertWifiScanningIsOn();
        });
    }

    /**
     * Verify that Wi-Fi scanning is not turned off when the screen turns off while wifi is enabled.
     * @throws Exception
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testScreenOffDoesNotTurnOffWifiScanningWhenWifiEnabled"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testScreenOffDoesNotTurnOffWifiScanningWhenWifiEnabled() throws Exception {
        if (FeatureUtil.isTV() || FeatureUtil.isAutomotive()) {
            // TV and auto do not support the setting options of WIFI scanning and Bluetooth
            // scanning
            return;
        }
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        if (!hasLocationFeature()) {
            // skip the test if location is not supported
            return;
        }
        if (!isLocationEnabled()) {
            fail(""Please enable location for this test - since Marshmallow WiFi scan results are""
                    + "" empty when location is disabled!"");
        }
        runWithScanningEnabled(() -> {
            setWifiEnabled(true);
            turnScreenOn();
            assertWifiScanningIsOn();
            // Toggle screen and verify Wi-Fi scanning is still on.
            turnScreenOff();
            assertWifiScanningIsOn();
            turnScreenOn();
            assertWifiScanningIsOn();
        });
    }

    /**
     * Verify that the platform supports a reasonable number of suggestions per app.
     * @throws Exception
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testMaxNumberOfNetworkSuggestionsPerApp"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testMaxNumberOfNetworkSuggestionsPerApp() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        assertTrue(mWifiManager.getMaxNumberOfNetworkSuggestionsPerApp()
                > ENFORCED_NUM_NETWORK_SUGGESTIONS_PER_APP);
    }

    private void verifyRegisterSoftApCallback(TestExecutor executor, TestSoftApCallback callback)
            throws Exception {
        // Register callback to get SoftApCapability
        mWifiManager.registerSoftApCallback(executor, callback);
        PollingCheck.check(
                ""SoftAp register failed!"", 5_000,
                () -> {
                    executor.runAll();
                    // Verify callback is run on the supplied executor and called
                    return callback.getOnStateChangedCalled() &&
                            callback.getOnSoftapInfoChangedCalledCount() > 0 &&
                            callback.getOnSoftApCapabilityChangedCalled() &&
                            callback.getOnConnectedClientCalled();
                });
    }

    private void verifySetGetSoftApConfig(SoftApConfiguration targetConfig) {
        mWifiManager.setSoftApConfiguration(targetConfig);
        // Bssid set dodesn't support for tethered hotspot
        SoftApConfiguration currentConfig = mWifiManager.getSoftApConfiguration();
        compareSoftApConfiguration(targetConfig, currentConfig);
        if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
            assertTrue(currentConfig.isUserConfiguration());
        }
    }

    private void compareSoftApConfiguration(SoftApConfiguration currentConfig,
        SoftApConfiguration testSoftApConfig) {
        assertEquals(currentConfig.getSsid(), testSoftApConfig.getSsid());
        assertEquals(currentConfig.getBssid(), testSoftApConfig.getBssid());
        assertEquals(currentConfig.getSecurityType(), testSoftApConfig.getSecurityType());
        assertEquals(currentConfig.getPassphrase(), testSoftApConfig.getPassphrase());
        assertEquals(currentConfig.isHiddenSsid(), testSoftApConfig.isHiddenSsid());
        assertEquals(currentConfig.getBand(), testSoftApConfig.getBand());
        assertEquals(currentConfig.getChannel(), testSoftApConfig.getChannel());
        assertEquals(currentConfig.getMaxNumberOfClients(),
                testSoftApConfig.getMaxNumberOfClients());
        assertEquals(currentConfig.isAutoShutdownEnabled(),
                testSoftApConfig.isAutoShutdownEnabled());
        assertEquals(currentConfig.getShutdownTimeoutMillis(),
                testSoftApConfig.getShutdownTimeoutMillis());
        assertEquals(currentConfig.isClientControlByUserEnabled(),
                testSoftApConfig.isClientControlByUserEnabled());
        assertEquals(currentConfig.getAllowedClientList(),
                testSoftApConfig.getAllowedClientList());
        assertEquals(currentConfig.getBlockedClientList(),
                testSoftApConfig.getBlockedClientList());
        if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
            assertEquals(currentConfig.getMacRandomizationSetting(),
                    testSoftApConfig.getMacRandomizationSetting());
            assertEquals(currentConfig.getChannels().toString(),
                    testSoftApConfig.getChannels().toString());
            assertEquals(currentConfig.isBridgedModeOpportunisticShutdownEnabled(),
                    testSoftApConfig.isBridgedModeOpportunisticShutdownEnabled());
            assertEquals(currentConfig.isIeee80211axEnabled(),
                    testSoftApConfig.isIeee80211axEnabled());
        }
    }

    private void turnOffWifiAndTetheredHotspotIfEnabled() throws Exception {
        if (mWifiManager.isWifiEnabled()) {
            Log.d(TAG, ""Turn off WiFi"");
            mWifiManager.setWifiEnabled(false);
            PollingCheck.check(
                ""Wifi turn off failed!"", 2_000,
                () -> mWifiManager.isWifiEnabled() == false);
        }
        if (mWifiManager.isWifiApEnabled()) {
            mTetheringManager.stopTethering(ConnectivityManager.TETHERING_WIFI);
            Log.d(TAG, ""Turn off tethered Hotspot"");
            PollingCheck.check(
                ""SoftAp turn off failed!"", 2_000,
                () -> mWifiManager.isWifiApEnabled() == false);
            mTetheringManager.stopTethering(ConnectivityManager.TETHERING_WIFI);
        }
    }

    private void verifyBridgedModeSoftApCallback(TestExecutor executor,
            TestSoftApCallback callback, boolean shouldFallbackSingleApMode, boolean isEnabled)
            throws Exception {
            // Verify state and info callback value as expected
            PollingCheck.check(
                    ""SoftAp state and info on bridged AP mode are mismatch!!!""
                    + "" shouldFallbackSingleApMode = "" + shouldFallbackSingleApMode
                    + "", isEnabled = ""  + isEnabled, 10_000,
                    () -> {
                        executor.runAll();
                        int expectedState = isEnabled ? WifiManager.WIFI_AP_STATE_ENABLED
                                : WifiManager.WIFI_AP_STATE_DISABLED;
                        int expectedInfoSize = isEnabled
                                ? (shouldFallbackSingleApMode ? 1 : 2) : 0;
                        return expectedState == callback.getCurrentState()
                                && callback.getCurrentSoftApInfoList().size() == expectedInfoSize;
                    });
    }

    private boolean shouldFallbackToSingleAp(int[] bands, SoftApCapability capability) {
        for (int band : bands) {
            if (capability.getSupportedChannelList(band).length == 0) {
                return true;
            }
        }
        return false;
    }

    private SparseIntArray getAvailableBandAndChannelForTesting(SoftApCapability capability) {
        final int[] bands = {SoftApConfiguration.BAND_2GHZ, SoftApConfiguration.BAND_5GHZ,
              SoftApConfiguration.BAND_6GHZ, SoftApConfiguration.BAND_60GHZ};
        SparseIntArray testBandsAndChannels = new SparseIntArray();
        if (!ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
            testBandsAndChannels.put(SoftApConfiguration.BAND_2GHZ, 1);
            return testBandsAndChannels;
        }
        for (int band : bands) {
            int[] supportedList = capability.getSupportedChannelList(band);
            if (supportedList.length != 0) {
                testBandsAndChannels.put(band, supportedList[0]);
            }
        }
        return testBandsAndChannels;
    }


    /**
     * Test bridged AP enable succeeful when device supports it.
     * Also verify the callback info update correctly.
     * @throws Exception
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testTetheredBridgedAp"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testTetheredBridgedAp() throws Exception {
        // check that softap bridged mode is supported by the device
        if (!mWifiManager.isBridgedApConcurrencySupported()) {
            return;
        }
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        TestExecutor executor = new TestExecutor();
        TestSoftApCallback callback = new TestSoftApCallback(mLock);
        try {
            uiAutomation.adoptShellPermissionIdentity();
            // Off/On Wifi to make sure that we get the supported channel
            turnOffWifiAndTetheredHotspotIfEnabled();
            mWifiManager.setWifiEnabled(true);
            PollingCheck.check(
                ""Wifi turn on failed!"", 2_000,
                () -> mWifiManager.isWifiEnabled() == true);
            turnOffWifiAndTetheredHotspotIfEnabled();
            verifyRegisterSoftApCallback(executor, callback);
            int[] testBands = {SoftApConfiguration.BAND_2GHZ,
                    SoftApConfiguration.BAND_5GHZ};
            int[] expectedBands = {SoftApConfiguration.BAND_2GHZ,
                    SoftApConfiguration.BAND_2GHZ | SoftApConfiguration.BAND_5GHZ};
            // Test bridged SoftApConfiguration set and get (setBands)
            SoftApConfiguration testSoftApConfig = new SoftApConfiguration.Builder()
                    .setSsid(TEST_SSID_UNQUOTED)
                    .setPassphrase(TEST_PASSPHRASE, SoftApConfiguration.SECURITY_TYPE_WPA2_PSK)
                    .setBands(expectedBands)
                    .build();
            boolean shouldFallbackToSingleAp = shouldFallbackToSingleAp(testBands,
                    callback.getCurrentSoftApCapability());
            verifySetGetSoftApConfig(testSoftApConfig);

            // start tethering which used to verify startTetheredHotspot
            mTetheringManager.startTethering(ConnectivityManager.TETHERING_WIFI, executor,
                new TetheringManager.StartTetheringCallback() {
                    @Override
                    public void onTetheringFailed(final int result) {
                    }
                });
            verifyBridgedModeSoftApCallback(executor, callback,
                    shouldFallbackToSingleAp, true /* enabled */);
            // stop tethering which used to verify stopSoftAp
            mTetheringManager.stopTethering(ConnectivityManager.TETHERING_WIFI);
            verifyBridgedModeSoftApCallback(executor, callback,
                    shouldFallbackToSingleAp, false /* disabled */);
        } finally {
            mWifiManager.unregisterSoftApCallback(callback);
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Test bridged AP with forced channel config enable succeeful when device supports it.
     * Also verify the callback info update correctly.
     * @throws Exception
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testTetheredBridgedApWifiForcedChannel"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testTetheredBridgedApWifiForcedChannel() throws Exception {
        // check that softap bridged mode is supported by the device
        if (!mWifiManager.isBridgedApConcurrencySupported()) {
            return;
        }
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        TestExecutor executor = new TestExecutor();
        TestSoftApCallback callback = new TestSoftApCallback(mLock);
        try {
            uiAutomation.adoptShellPermissionIdentity();
            // Off/On Wifi to make sure that we get the supported channel
            turnOffWifiAndTetheredHotspotIfEnabled();
            mWifiManager.setWifiEnabled(true);
            PollingCheck.check(
                ""Wifi turn on failed!"", 2_000,
                () -> mWifiManager.isWifiEnabled() == true);
            turnOffWifiAndTetheredHotspotIfEnabled();
            verifyRegisterSoftApCallback(executor, callback);

            boolean shouldFallbackToSingleAp = shouldFallbackToSingleAp(
                    new int[] {SoftApConfiguration.BAND_2GHZ, SoftApConfiguration.BAND_5GHZ},
                    callback.getCurrentSoftApCapability());

            // Test when there are supported channels in both of the bands.
            if (!shouldFallbackToSingleAp) {
                // Test bridged SoftApConfiguration set and get (setChannels)
                SparseIntArray dual_channels = new SparseIntArray(2);
                dual_channels.put(SoftApConfiguration.BAND_2GHZ,
                        callback.getCurrentSoftApCapability()
                        .getSupportedChannelList(SoftApConfiguration.BAND_2GHZ)[0]);
                dual_channels.put(SoftApConfiguration.BAND_5GHZ,
                        callback.getCurrentSoftApCapability()
                        .getSupportedChannelList(SoftApConfiguration.BAND_5GHZ)[0]);
                SoftApConfiguration testSoftApConfig = new SoftApConfiguration.Builder()
                        .setSsid(TEST_SSID_UNQUOTED)
                        .setPassphrase(TEST_PASSPHRASE, SoftApConfiguration.SECURITY_TYPE_WPA2_PSK)
                        .setChannels(dual_channels)
                        .build();

                verifySetGetSoftApConfig(testSoftApConfig);

                // start tethering which used to verify startTetheredHotspot
                mTetheringManager.startTethering(ConnectivityManager.TETHERING_WIFI, executor,
                    new TetheringManager.StartTetheringCallback() {
                        @Override
                        public void onTetheringFailed(final int result) {
                        }
                    });
                verifyBridgedModeSoftApCallback(executor, callback,
                        shouldFallbackToSingleAp, true /* enabled */);
                // stop tethering which used to verify stopSoftAp
                mTetheringManager.stopTethering(ConnectivityManager.TETHERING_WIFI);
                verifyBridgedModeSoftApCallback(executor, callback,
                        shouldFallbackToSingleAp, false /* disabled */);
            }
        } finally {
            mWifiManager.unregisterSoftApCallback(callback);
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Verify that the configuration from getSoftApConfiguration is same as the configuration which
     * set by setSoftApConfiguration. And depends softap capability callback to test different
     * configuration.
     * @throws Exception
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testSetGetSoftApConfigurationAndSoftApCapabilityCallback"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testSetGetSoftApConfigurationAndSoftApCapabilityCallback() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // check that softap mode is supported by the device
        if (!mWifiManager.isPortableHotspotSupported()) {
            return;
        }
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        TestExecutor executor = new TestExecutor();
        TestSoftApCallback callback = new TestSoftApCallback(mLock);
        try {
            uiAutomation.adoptShellPermissionIdentity();
            turnOffWifiAndTetheredHotspotIfEnabled();
            verifyRegisterSoftApCallback(executor, callback);

            SoftApConfiguration.Builder softApConfigBuilder = new SoftApConfiguration.Builder()
                    .setSsid(TEST_SSID_UNQUOTED)
                    .setPassphrase(TEST_PASSPHRASE, SoftApConfiguration.SECURITY_TYPE_WPA2_PSK)
                    .setAutoShutdownEnabled(true)
                    .setShutdownTimeoutMillis(100000)
                    .setBand(getAvailableBandAndChannelForTesting(
                            callback.getCurrentSoftApCapability()).keyAt(0))
                    .setHiddenSsid(false);

            // Test SoftApConfiguration set and get
            verifySetGetSoftApConfig(softApConfigBuilder.build());

            boolean isSupportCustomizedMac = callback.getCurrentSoftApCapability()
                        .areFeaturesSupported(
                        SoftApCapability.SOFTAP_FEATURE_MAC_ADDRESS_CUSTOMIZATION)
                    && PropertyUtil.isVndkApiLevelNewerThan(Build.VERSION_CODES.S);

            //Test MAC_ADDRESS_CUSTOMIZATION supported config
            if (isSupportCustomizedMac) {
                softApConfigBuilder.setBssid(TEST_MAC)
                        .setMacRandomizationSetting(SoftApConfiguration.RANDOMIZATION_NONE);

                // Test SoftApConfiguration set and get
                verifySetGetSoftApConfig(softApConfigBuilder.build());
            }

            // Test CLIENT_FORCE_DISCONNECT supported config.
            if (callback.getCurrentSoftApCapability()
                    .areFeaturesSupported(
                    SoftApCapability.SOFTAP_FEATURE_CLIENT_FORCE_DISCONNECT)) {
                softApConfigBuilder.setMaxNumberOfClients(10);
                softApConfigBuilder.setClientControlByUserEnabled(true);
                softApConfigBuilder.setBlockedClientList(new ArrayList<>());
                softApConfigBuilder.setAllowedClientList(new ArrayList<>());
                verifySetGetSoftApConfig(softApConfigBuilder.build());
            }

            // Test SAE config
            if (callback.getCurrentSoftApCapability()
                    .areFeaturesSupported(SoftApCapability.SOFTAP_FEATURE_WPA3_SAE)) {
                softApConfigBuilder
                        .setPassphrase(TEST_PASSPHRASE,
                          SoftApConfiguration.SECURITY_TYPE_WPA3_SAE_TRANSITION);
                verifySetGetSoftApConfig(softApConfigBuilder.build());
                softApConfigBuilder
                        .setPassphrase(TEST_PASSPHRASE,
                        SoftApConfiguration.SECURITY_TYPE_WPA3_SAE);
                verifySetGetSoftApConfig(softApConfigBuilder.build());
            }

            // Test 11 AX control config.
            if (callback.getCurrentSoftApCapability()
                    .areFeaturesSupported(SoftApCapability.SOFTAP_FEATURE_IEEE80211_AX)) {
                softApConfigBuilder.setIeee80211axEnabled(true);
                verifySetGetSoftApConfig(softApConfigBuilder.build());
            }

            if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
                softApConfigBuilder.setBridgedModeOpportunisticShutdownEnabled(false);
                verifySetGetSoftApConfig(softApConfigBuilder.build());
            }

        } finally {
            mWifiManager.unregisterSoftApCallback(callback);
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Verify that startTetheredHotspot with specific channel config.
     * @throws Exception
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testStartTetheredHotspotWithChannelConfigAndSoftApStateAndInfoCallback"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testStartTetheredHotspotWithChannelConfigAndSoftApStateAndInfoCallback()
            throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // check that softap mode is supported by the device
        if (!mWifiManager.isPortableHotspotSupported()) {
            return;
        }
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        TestExecutor executor = new TestExecutor();
        TestSoftApCallback callback = new TestSoftApCallback(mLock);
        try {
            uiAutomation.adoptShellPermissionIdentity();
            // check that tethering is supported by the device
            if (!mTetheringManager.isTetheringSupported()) {
                return;
            }
            turnOffWifiAndTetheredHotspotIfEnabled();
            verifyRegisterSoftApCallback(executor, callback);

            SparseIntArray testBandsAndChannels = getAvailableBandAndChannelForTesting(
                    callback.getCurrentSoftApCapability());

            if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
                assertNotEquals(0, testBandsAndChannels.size());
            }
            boolean isSupportCustomizedMac = callback.getCurrentSoftApCapability()
                    .areFeaturesSupported(
                    SoftApCapability.SOFTAP_FEATURE_MAC_ADDRESS_CUSTOMIZATION)
                    && PropertyUtil.isVndkApiLevelNewerThan(Build.VERSION_CODES.S);

            SoftApConfiguration.Builder testSoftApConfigBuilder = new SoftApConfiguration.Builder()
                    .setSsid(TEST_SSID_UNQUOTED)
                    .setPassphrase(TEST_PASSPHRASE, SoftApConfiguration.SECURITY_TYPE_WPA2_PSK)
                    .setChannel(testBandsAndChannels.valueAt(0), testBandsAndChannels.keyAt(0));

            if (isSupportCustomizedMac) testSoftApConfigBuilder.setBssid(TEST_MAC);

            SoftApConfiguration testSoftApConfig = testSoftApConfigBuilder.build();

            mWifiManager.setSoftApConfiguration(testSoftApConfig);

            // start tethering which used to verify startTetheredHotspot
            mTetheringManager.startTethering(ConnectivityManager.TETHERING_WIFI, executor,
                new TetheringManager.StartTetheringCallback() {
                    @Override
                    public void onTetheringFailed(final int result) {
                    }
                });

            // Verify state and info callback value as expected
            PollingCheck.check(
                    ""SoftAp channel and state mismatch!!!"", 10_000,
                    () -> {
                        executor.runAll();
                        int sapChannel = ScanResult.convertFrequencyMhzToChannelIfSupported(
                                callback.getCurrentSoftApInfo().getFrequency());
                        boolean isInfoCallbackSupported =
                                callback.getOnSoftapInfoChangedCalledCount() > 1;
                        if (isInfoCallbackSupported) {
                            return WifiManager.WIFI_AP_STATE_ENABLED == callback.getCurrentState()
                                && testBandsAndChannels.valueAt(0) == sapChannel;
                        }
                        return WifiManager.WIFI_AP_STATE_ENABLED == callback.getCurrentState();
                    });
            // After Soft Ap enabled, check SoftAp info if it supported
            if (isSupportCustomizedMac && callback.getOnSoftapInfoChangedCalledCount() > 1) {
                assertEquals(callback.getCurrentSoftApInfo().getBssid(), TEST_MAC);
            }
            if (PropertyUtil.isVndkApiLevelNewerThan(Build.VERSION_CODES.S)
                    && callback.getOnSoftapInfoChangedCalledCount() > 1) {
                assertNotEquals(callback.getCurrentSoftApInfo().getWifiStandard(),
                        ScanResult.WIFI_STANDARD_UNKNOWN);
            }

            if (callback.getOnSoftapInfoChangedCalledCount() > 1) {
                assertTrue(callback.getCurrentSoftApInfo().getAutoShutdownTimeoutMillis() > 0);
            }
        } finally {
            // stop tethering which used to verify stopSoftAp
            mTetheringManager.stopTethering(ConnectivityManager.TETHERING_WIFI);

            // Verify clean up
            PollingCheck.check(
                    ""Stop Softap failed"", 3_000,
                    () -> {
                        executor.runAll();
                        return WifiManager.WIFI_AP_STATE_DISABLED == callback.getCurrentState() &&
                                0 == callback.getCurrentSoftApInfo().getBandwidth() &&
                                0 == callback.getCurrentSoftApInfo().getFrequency();
                    });
            if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
                assertEquals(callback.getCurrentSoftApInfo().getBssid(), null);
                assertEquals(ScanResult.WIFI_STANDARD_UNKNOWN,
                        callback.getCurrentSoftApInfo().getWifiStandard());
            }
            mWifiManager.unregisterSoftApCallback(callback);
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    private static class TestActionListener implements WifiManager.ActionListener {
        private final Object mLock;
        public boolean onSuccessCalled = false;
        public boolean onFailedCalled = false;
        public int failureReason = -1;

        TestActionListener(Object lock) {
            mLock = lock;
        }

        @Override
        public void onSuccess() {
            synchronized (mLock) {
                onSuccessCalled = true;
                mLock.notify();
            }
        }

        @Override
        public void onFailure(int reason) {
            synchronized (mLock) {
                onFailedCalled = true;
                failureReason = reason;
                mLock.notify();
            }
        }
    }

    /**
     * Triggers connection to one of the saved networks using {@link WifiManager#connect(
     * int, WifiManager.ActionListener)} or {@link WifiManager#connect(WifiConfiguration,
     * WifiManager.ActionListener)}
     *
     * @param withNetworkId Use networkId for triggering connection, false for using
     *                      WifiConfiguration.
     * @throws Exception
     */
    private void testConnect(boolean withNetworkId) throws Exception {
        TestActionListener actionListener = new TestActionListener(mLock);
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        List<WifiConfiguration> savedNetworks = null;
        try {
            uiAutomation.adoptShellPermissionIdentity();
            // These below API's only work with privileged permissions (obtained via shell identity
            // for test)
            savedNetworks = mWifiManager.getConfiguredNetworks();

            // Disable all the saved networks to trigger disconnect & disable autojoin.
            for (WifiConfiguration network : savedNetworks) {
                assertTrue(mWifiManager.disableNetwork(network.networkId));
            }
            waitForDisconnection();

            // Now trigger connection to the last saved network.
            WifiConfiguration savedNetworkToConnect =
                    savedNetworks.get(savedNetworks.size() - 1);
            synchronized (mLock) {
                try {
                    if (withNetworkId) {
                        mWifiManager.connect(savedNetworkToConnect.networkId, actionListener);
                    } else {
                        mWifiManager.connect(savedNetworkToConnect, actionListener);
                    }
                    // now wait for callback
                    mLock.wait(TEST_WAIT_DURATION_MS);
                } catch (InterruptedException e) {
                }
            }
            // check if we got the success callback
            assertTrue(actionListener.onSuccessCalled);
            // Wait for connection to complete & ensure we are connected to the saved network.
            waitForConnection();
            if (SdkLevel.isAtLeastS()) {
                assertEquals(savedNetworkToConnect.networkId,
                        mWifiManager.getConnectionInfo().getNetworkId());
            } else {
                // In R, auto-upgraded network IDs may be different from the original saved network.
                // Since we may end up selecting the auto-upgraded network ID for connection and end
                // up connected to the original saved network with a different network ID, we should
                // instead match by SSID.
                assertEquals(savedNetworkToConnect.SSID,
                        mWifiManager.getConnectionInfo().getSSID());
            }
        } finally {
            // Re-enable all saved networks before exiting.
            if (savedNetworks != null) {
                for (WifiConfiguration network : savedNetworks) {
                    mWifiManager.enableNetwork(network.networkId, true);
                }
            }
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link WifiManager#connect(int, WifiManager.ActionListener)} to an existing saved
     * network.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testConnectWithNetworkId"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testConnectWithNetworkId() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        testConnect(true);
    }

    /**
     * Tests {@link WifiManager#connect(WifiConfiguration, WifiManager.ActionListener)} to an
     * existing saved network.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testConnectWithWifiConfiguration"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testConnectWithWifiConfiguration() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        testConnect(false);

    }

    private static class TestNetworkCallback extends ConnectivityManager.NetworkCallback {
        private final Object mLock;
        public boolean onAvailableCalled = false;
        public Network network;
        public NetworkCapabilities networkCapabilities;

        TestNetworkCallback(Object lock) {
            mLock = lock;
        }

        @Override
        public void onAvailable(Network network) {
            synchronized (mLock) {
                onAvailableCalled = true;
                this.network = network;
            }
        }

        @Override
        public void onCapabilitiesChanged(Network network,
                NetworkCapabilities networkCapabilities) {
            synchronized (mLock) {
                this.networkCapabilities = networkCapabilities;
                mLock.notify();
            }
        }
    }

    private void waitForNetworkCallbackAndCheckForMeteredness(boolean expectMetered) {
        TestNetworkCallback networkCallbackListener = new TestNetworkCallback(mLock);
        synchronized (mLock) {
            try {
                NetworkRequest.Builder networkRequestBuilder = new NetworkRequest.Builder()
                        .addTransportType(TRANSPORT_WIFI);
                if (expectMetered) {
                    networkRequestBuilder.removeCapability(NET_CAPABILITY_NOT_METERED);
                } else {
                    networkRequestBuilder.addCapability(NET_CAPABILITY_NOT_METERED);
                }
                // File a request for wifi network.
                mConnectivityManager.registerNetworkCallback(
                        networkRequestBuilder.build(), networkCallbackListener);
                // now wait for callback
                mLock.wait(TEST_WAIT_DURATION_MS);
            } catch (InterruptedException e) {
            }
        }
        assertTrue(networkCallbackListener.onAvailableCalled);
    }

    /**
     * Tests {@link WifiManager#save(WifiConfiguration, WifiManager.ActionListener)} by marking
     * an existing saved network metered.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testSave"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testSave() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        TestActionListener actionListener = new TestActionListener(mLock);
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        List<WifiConfiguration> savedNetworks = null;
        WifiConfiguration currentConfig = null;
        try {
            uiAutomation.adoptShellPermissionIdentity();
            // These below API's only work with privileged permissions (obtained via shell identity
            // for test)

            // Trigger a scan & wait for connection to one of the saved networks.
            mWifiManager.startScan();
            waitForConnection();

            WifiInfo wifiInfo = mWifiManager.getConnectionInfo();

            // find the current network's WifiConfiguration
            currentConfig = mWifiManager.getConfiguredNetworks()
                    .stream()
                    .filter(config -> config.networkId == wifiInfo.getNetworkId())
                    .findAny()
                    .get();

            // Ensure that the current network is not metered.
            assertNotEquals(""Ensure that the saved network is configured as unmetered"",
                    currentConfig.meteredOverride,
                    WifiConfiguration.METERED_OVERRIDE_METERED);

            // Check the network capabilities to ensure that the network is marked not metered.
            waitForNetworkCallbackAndCheckForMeteredness(false);

            // Now mark the network metered and save.
            synchronized (mLock) {
                try {
                    WifiConfiguration modSavedNetwork = new WifiConfiguration(currentConfig);
                    modSavedNetwork.meteredOverride = WifiConfiguration.METERED_OVERRIDE_METERED;
                    mWifiManager.save(modSavedNetwork, actionListener);
                    // now wait for callback
                    mLock.wait(TEST_WAIT_DURATION_MS);
                } catch (InterruptedException e) {
                }
            }
            // check if we got the success callback
            assertTrue(actionListener.onSuccessCalled);
            // Ensure we disconnected on marking the network metered & connect back.
            waitForDisconnection();
            waitForConnection();
            // Check the network capabilities to ensure that the network is marked metered now.
            waitForNetworkCallbackAndCheckForMeteredness(true);

        } finally {
            // Restore original network config (restore the meteredness back);
            if (currentConfig != null) {
                mWifiManager.updateNetwork(currentConfig);
            }
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link WifiManager#forget(int, WifiManager.ActionListener)} by adding/removing a new
     * network.
     */
    @AsbSecurityTest(cveBugId = 159373687)"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testForget"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testForget() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        TestActionListener actionListener = new TestActionListener(mLock);
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        int newNetworkId = INVALID_NETWORK_ID;
        try {
            uiAutomation.adoptShellPermissionIdentity();
            // These below API's only work with privileged permissions (obtained via shell identity
            // for test)
            List<WifiConfiguration> savedNetworks = mWifiManager.getConfiguredNetworks();

            WifiConfiguration newOpenNetwork = new WifiConfiguration();
            newOpenNetwork.SSID = ""\"""" + TEST_SSID_UNQUOTED + ""\"""";
            newNetworkId = mWifiManager.addNetwork(newOpenNetwork);
            assertNotEquals(INVALID_NETWORK_ID, newNetworkId);

            // Multi-type configurations might be converted to more than 1 configuration.
            assertThat(savedNetworks.size() < mWifiManager.getConfiguredNetworks().size()).isTrue();

            // Need an effectively-final holder because we need to modify inner Intent in callback.
            class IntentHolder {
                Intent intent;
            }
            IntentHolder intentHolder = new IntentHolder();
            mContext.registerReceiver(new BroadcastReceiver() {
                @Override
                public void onReceive(Context context, Intent intent) {
                    Log.i(TAG, ""Received CONFIGURED_NETWORKS_CHANGED_ACTION broadcast: "" + intent);
                    intentHolder.intent = intent;
                }
            }, new IntentFilter(WifiManager.CONFIGURED_NETWORKS_CHANGED_ACTION));

            // Now remove the network
            synchronized (mLock) {
                try {
                    mWifiManager.forget(newNetworkId, actionListener);
                    // now wait for callback
                    mLock.wait(TEST_WAIT_DURATION_MS);
                } catch (InterruptedException e) {
                }
            }
            // check if we got the success callback
            assertTrue(actionListener.onSuccessCalled);

            PollingCheck.check(
                    ""Didn't receive CONFIGURED_NETWORKS_CHANGED_ACTION broadcast!"",
                    TEST_WAIT_DURATION_MS,
                    () -> intentHolder.intent != null);
            Intent intent = intentHolder.intent;
            assertEquals(WifiManager.CONFIGURED_NETWORKS_CHANGED_ACTION, intent.getAction());
            assertTrue(intent.getBooleanExtra(WifiManager.EXTRA_MULTIPLE_NETWORKS_CHANGED, false));
            assertEquals(WifiManager.CHANGE_REASON_REMOVED,
                    intent.getIntExtra(WifiManager.EXTRA_CHANGE_REASON, -1));
            assertNull(intent.getParcelableExtra(WifiManager.EXTRA_WIFI_CONFIGURATION));

            // Ensure that the new network has been successfully removed.
            assertEquals(savedNetworks.size(), mWifiManager.getConfiguredNetworks().size());
        } finally {
            // For whatever reason, if the forget fails, try removing using the public remove API.
            if (newNetworkId != INVALID_NETWORK_ID) mWifiManager.removeNetwork(newNetworkId);
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link WifiManager#getFactoryMacAddresses()} returns at least one valid MAC address.
     */
    @VirtualDeviceNotSupported"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testGetFactoryMacAddresses"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testGetFactoryMacAddresses() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        TestActionListener actionListener = new TestActionListener(mLock);
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        int newNetworkId = INVALID_NETWORK_ID;
        try {
            uiAutomation.adoptShellPermissionIdentity();
            // Obtain the factory MAC address
            String[] macAddresses = mWifiManager.getFactoryMacAddresses();
            assertTrue(""At list one MAC address should be returned."", macAddresses.length > 0);
            try {
                MacAddress mac = MacAddress.fromString(macAddresses[0]);
                assertNotEquals(WifiInfo.DEFAULT_MAC_ADDRESS, mac);
                assertFalse(MacAddressUtils.isMulticastAddress(mac));
            } catch (IllegalArgumentException e) {
                fail(""Factory MAC address is invalid"");
            }
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link WifiManager#isApMacRandomizationSupported()} does not crash.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testIsApMacRandomizationSupported"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testIsApMacRandomizationSupported() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        mWifiManager.isApMacRandomizationSupported();
    }

    /**
     * Tests {@link WifiManager#isConnectedMacRandomizationSupported()} does not crash.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testIsConnectedMacRandomizationSupported"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testIsConnectedMacRandomizationSupported() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        mWifiManager.isConnectedMacRandomizationSupported();
    }

    /**
     * Tests {@link WifiManager#isPreferredNetworkOffloadSupported()} does not crash.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testIsPreferredNetworkOffloadSupported"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testIsPreferredNetworkOffloadSupported() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        mWifiManager.isPreferredNetworkOffloadSupported();
    }

    /** Test that PNO scans reconnects us when the device is disconnected and the screen is off. */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testPnoScan"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testPnoScan() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        if (!mWifiManager.isPreferredNetworkOffloadSupported()) {
            // skip the test if PNO scanning is not supported
            return;
        }

        // make sure we're connected
        waitForConnection();

        WifiInfo currentNetwork = ShellIdentityUtils.invokeWithShellPermissions(
                mWifiManager::getConnectionInfo);

        // disable all networks that aren't already disabled
        List<WifiConfiguration> savedNetworks = ShellIdentityUtils.invokeWithShellPermissions(
                mWifiManager::getConfiguredNetworks);
        Set<Integer> disabledNetworkIds = new HashSet<>();
        for (WifiConfiguration config : savedNetworks) {
            if (config.getNetworkSelectionStatus().getNetworkSelectionDisableReason()
                    == WifiConfiguration.NetworkSelectionStatus.DISABLED_NONE) {
                ShellIdentityUtils.invokeWithShellPermissions(
                        () -> mWifiManager.disableNetwork(config.networkId));
                disabledNetworkIds.add(config.networkId);
            }
        }

        try {
            // wait for disconnection from current network
            waitForDisconnection();

            // turn screen off
            turnScreenOffNoDelay();

            // re-enable the current network - this will trigger PNO
            ShellIdentityUtils.invokeWithShellPermissions(
                    () -> mWifiManager.enableNetwork(currentNetwork.getNetworkId(), false));
            disabledNetworkIds.remove(currentNetwork.getNetworkId());

            // PNO should reconnect us back to the network we disconnected from
            waitForConnection();
        } finally {
            // re-enable disabled networks
            for (int disabledNetworkId : disabledNetworkIds) {
                ShellIdentityUtils.invokeWithShellPermissions(
                        () -> mWifiManager.enableNetwork(disabledNetworkId, true));
            }
        }
    }

    /**
     * Tests {@link WifiManager#isTdlsSupported()} does not crash.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testIsTdlsSupported"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testIsTdlsSupported() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        mWifiManager.isTdlsSupported();
    }

    /**
     * Tests {@link WifiManager#isStaApConcurrencySupported().
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testIsStaApConcurrencySupported"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testIsStaApConcurrencySupported() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // check that softap mode is supported by the device
        if (!mWifiManager.isPortableHotspotSupported()) {
            return;
        }
        assertTrue(mWifiManager.isWifiEnabled());

        boolean isStaApConcurrencySupported = mWifiManager.isStaApConcurrencySupported();
        // start local only hotspot.
        TestLocalOnlyHotspotCallback callback = startLocalOnlyHotspot();
        try {
            if (isStaApConcurrencySupported) {
                assertTrue(mWifiManager.isWifiEnabled());
            } else {
                // no concurrency, wifi should be disabled.
                assertFalse(mWifiManager.isWifiEnabled());
            }
        } finally {
            // clean up local only hotspot no matter if assertion passed or failed
            stopLocalOnlyHotspot(callback, true);
        }

        assertTrue(mWifiManager.isWifiEnabled());
    }

    /**
     * state is a bitset, where bit 0 indicates whether there was data in, and bit 1 indicates
     * whether there was data out. Only count down on the latch once there was both data in and out.
     */
    private static class TestTrafficStateCallback implements WifiManager.TrafficStateCallback {
        public final CountDownLatch latch = new CountDownLatch(1);
        private int mAccumulator = 0;

        @Override
        public void onStateChanged(int state) {
            mAccumulator |= state;
            if (mAccumulator == DATA_ACTIVITY_INOUT) {
                latch.countDown();
            }
        }
    }

    private void sendTraffic() {
        boolean didAnyConnectionSucceed = false;
        for (int i = 0; i < 10; i++) {
            // Do some network operations
            HttpURLConnection connection = null;
            try {
                URL url = new URL(""http://www.google.com/"");
                connection = (HttpURLConnection) url.openConnection();
                connection.setInstanceFollowRedirects(false);
                connection.setConnectTimeout(TEST_WAIT_DURATION_MS);
                connection.setReadTimeout(TEST_WAIT_DURATION_MS);
                connection.setUseCaches(false);
                InputStream stream = connection.getInputStream();
                byte[] bytes = new byte[100];
                int receivedBytes = stream.read(bytes);
                if (receivedBytes > 0) {
                    didAnyConnectionSucceed = true;
                }
            } catch (Exception e) {
                // ignore
            } finally {
                if (connection != null) connection.disconnect();
            }
        }
        assertTrue(""All connections failed!"", didAnyConnectionSucceed);
    }

    /**
     * Tests {@link WifiManager#registerTrafficStateCallback(Executor,
     * WifiManager.TrafficStateCallback)} by sending some traffic.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testTrafficStateCallback"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testTrafficStateCallback() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        TestTrafficStateCallback callback = new TestTrafficStateCallback();
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            // Trigger a scan & wait for connection to one of the saved networks.
            mWifiManager.startScan();
            waitForConnection();

            // Turn screen on for wifi traffic polling.
            turnScreenOn();
            mWifiManager.registerTrafficStateCallback(
                    Executors.newSingleThreadExecutor(), callback);
            // Send some traffic to trigger the traffic state change callbacks.
            sendTraffic();
            // now wait for callback
            boolean success = callback.latch.await(TEST_WAIT_DURATION_MS, TimeUnit.MILLISECONDS);
            // check if we got the state changed callback with both data in and out
            assertTrue(success);
        } finally {
            turnScreenOff();
            mWifiManager.unregisterTrafficStateCallback(callback);
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link WifiManager#setScanAlwaysAvailable(boolean)} &
     * {@link WifiManager#isScanAlwaysAvailable()}.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testScanAlwaysAvailable"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testScanAlwaysAvailable() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        Boolean currState = null;
        try {
            uiAutomation.adoptShellPermissionIdentity();
            currState = mWifiManager.isScanAlwaysAvailable();
            boolean newState = !currState;
            mWifiManager.setScanAlwaysAvailable(newState);
            PollingCheck.check(
                    ""Wifi settings toggle failed!"",
                    DURATION_SETTINGS_TOGGLE,
                    () -> mWifiManager.isScanAlwaysAvailable() == newState);
            assertEquals(newState, mWifiManager.isScanAlwaysAvailable());
        } finally {
            if (currState != null) mWifiManager.setScanAlwaysAvailable(currState);
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link WifiManager#setScanThrottleEnabled(boolean)} &
     * {@link WifiManager#isScanThrottleEnabled()}.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testScanThrottleEnabled"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testScanThrottleEnabled() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        Boolean currState = null;
        try {
            uiAutomation.adoptShellPermissionIdentity();
            currState = mWifiManager.isScanThrottleEnabled();
            boolean newState = !currState;
            mWifiManager.setScanThrottleEnabled(newState);
            PollingCheck.check(
                    ""Wifi settings toggle failed!"",
                    DURATION_SETTINGS_TOGGLE,
                    () -> mWifiManager.isScanThrottleEnabled() == newState);
            assertEquals(newState, mWifiManager.isScanThrottleEnabled());
        } finally {
            if (currState != null) mWifiManager.setScanThrottleEnabled(currState);
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link WifiManager#setAutoWakeupEnabled(boolean)} &
     * {@link WifiManager#isAutoWakeupEnabled()}.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testAutoWakeUpEnabled"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testAutoWakeUpEnabled() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        Boolean currState = null;
        try {
            uiAutomation.adoptShellPermissionIdentity();
            currState = mWifiManager.isAutoWakeupEnabled();
            boolean newState = !currState;
            mWifiManager.setAutoWakeupEnabled(newState);
            PollingCheck.check(
                    ""Wifi settings toggle failed!"",
                    DURATION_SETTINGS_TOGGLE,
                    () -> mWifiManager.isAutoWakeupEnabled() == newState);
            assertEquals(newState, mWifiManager.isAutoWakeupEnabled());
        } finally {
            if (currState != null) mWifiManager.setAutoWakeupEnabled(currState);
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link WifiManager#setVerboseLoggingEnabled(boolean)} &
     * {@link WifiManager#isVerboseLoggingEnabled()}.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testVerboseLoggingEnabled"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testVerboseLoggingEnabled() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        Boolean currState = null;
        TestWifiVerboseLoggingStatusChangedListener listener =
                WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(mContext) ?
                new TestWifiVerboseLoggingStatusChangedListener() : null;
        try {
            uiAutomation.adoptShellPermissionIdentity();
            if (listener != null) {
                mWifiManager.addWifiVerboseLoggingStatusChangedListener(mExecutor, listener);
            }
            currState = mWifiManager.isVerboseLoggingEnabled();
            boolean newState = !currState;
            if (listener != null) {
                assertEquals(0, listener.numCalls);
            }
            mWifiManager.setVerboseLoggingEnabled(newState);
            PollingCheck.check(
                    ""Wifi verbose logging toggle failed!"",
                    DURATION_SETTINGS_TOGGLE,
                    () -> mWifiManager.isVerboseLoggingEnabled() == newState);
            if (listener != null) {
                PollingCheck.check(
                        ""Verbose logging listener timeout"",
                        DURATION_SETTINGS_TOGGLE,
                        () -> listener.status == newState && listener.numCalls == 1);
            }
        } finally {
            if (currState != null) mWifiManager.setVerboseLoggingEnabled(currState);
            if (listener != null) {
                mWifiManager.removeWifiVerboseLoggingStatusChangedListener(listener);
            }
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link WifiManager#setVerboseLoggingLevel(int)}.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testSetVerboseLogging"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testSetVerboseLogging() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        Boolean currState = null;
        try {
            uiAutomation.adoptShellPermissionIdentity();
            currState = mWifiManager.isVerboseLoggingEnabled();

            mWifiManager.setVerboseLoggingLevel(WifiManager.VERBOSE_LOGGING_LEVEL_ENABLED);
            assertTrue(mWifiManager.isVerboseLoggingEnabled());
            assertEquals(WifiManager.VERBOSE_LOGGING_LEVEL_ENABLED,
                    mWifiManager.getVerboseLoggingLevel());

            mWifiManager.setVerboseLoggingLevel(WifiManager.VERBOSE_LOGGING_LEVEL_DISABLED);
            assertFalse(mWifiManager.isVerboseLoggingEnabled());
            assertEquals(WifiManager.VERBOSE_LOGGING_LEVEL_DISABLED,
                    mWifiManager.getVerboseLoggingLevel());
        } finally {
            if (currState != null) mWifiManager.setVerboseLoggingEnabled(currState);
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Test {@link WifiManager#setVerboseLoggingLevel(int)} for show key mode.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testSetVerboseLoggingShowKeyModeNonUserBuild"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testSetVerboseLoggingShowKeyModeNonUserBuild() throws Exception {
        if (Build.TYPE.equals(""user"")) return;
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        Boolean currState = null;
        try {
            uiAutomation.adoptShellPermissionIdentity();
            currState = mWifiManager.isVerboseLoggingEnabled();

            mWifiManager.setVerboseLoggingLevel(WifiManager.VERBOSE_LOGGING_LEVEL_ENABLED_SHOW_KEY);
            assertTrue(mWifiManager.isVerboseLoggingEnabled());
            assertEquals(WifiManager.VERBOSE_LOGGING_LEVEL_ENABLED_SHOW_KEY,
                    mWifiManager.getVerboseLoggingLevel());
        } finally {
            if (currState != null) mWifiManager.setVerboseLoggingEnabled(currState);
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Test {@link WifiManager#setVerboseLoggingLevel(int)} for show key mode.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testSetVerboseLoggingShowKeyModeUserBuild"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testSetVerboseLoggingShowKeyModeUserBuild() throws Exception {
        if (!Build.TYPE.equals(""user"")) return;
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        Boolean currState = null;
        try {
            uiAutomation.adoptShellPermissionIdentity();
            currState = mWifiManager.isVerboseLoggingEnabled();

            mWifiManager.setVerboseLoggingLevel(WifiManager.VERBOSE_LOGGING_LEVEL_ENABLED_SHOW_KEY);
            assertTrue(mWifiManager.isVerboseLoggingEnabled());
            assertEquals(WifiManager.VERBOSE_LOGGING_LEVEL_ENABLED_SHOW_KEY,
                    mWifiManager.getVerboseLoggingLevel());
            fail(""Verbosing logging show key mode should not be allowed for user build."");
        } catch (SecurityException e) {
            // expected
        } finally {
            if (currState != null) mWifiManager.setVerboseLoggingEnabled(currState);
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link WifiManager#factoryReset()} cannot be invoked from a non-privileged app.
     *
     * Note: This intentionally does not test the full reset functionality because it causes
     * the existing saved networks on the device to be lost after the test. If you add the
     * networks back after reset, the ownership of saved networks will change.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testFactoryReset"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testFactoryReset() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        List<WifiConfiguration> beforeSavedNetworks = ShellIdentityUtils.invokeWithShellPermissions(
                mWifiManager::getConfiguredNetworks);
        try {
            mWifiManager.factoryReset();
            fail(""Factory reset should not be allowed for non-privileged apps"");
        } catch (SecurityException e) {
            // expected
        }
        List<WifiConfiguration> afterSavedNetworks = ShellIdentityUtils.invokeWithShellPermissions(
                mWifiManager::getConfiguredNetworks);
        assertEquals(beforeSavedNetworks.size(), afterSavedNetworks.size());
    }

    /**
     * Test {@link WifiNetworkConnectionStatistics} does not crash.
     * TODO(b/150891569): deprecate it in Android S, this API is not used anywhere.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testWifiNetworkConnectionStatistics"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testWifiNetworkConnectionStatistics() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        new WifiNetworkConnectionStatistics();
        WifiNetworkConnectionStatistics stats = new WifiNetworkConnectionStatistics(0, 0);
        new WifiNetworkConnectionStatistics(stats);
    }

    /**
     * Verify that startRestrictingAutoJoinToSubscriptionId disconnects wifi and disables
     * auto-connect to non-carrier-merged networks. Then verify that
     * stopRestrictingAutoJoinToSubscriptionId makes the disabled networks clear to connect
     * again.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testStartAndStopRestrictingAutoJoinToSubscriptionId"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testStartAndStopRestrictingAutoJoinToSubscriptionId() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        startScan();
        waitForConnection();
        int fakeSubscriptionId = 5;
        ShellIdentityUtils.invokeWithShellPermissions(() ->
                mWifiManager.startRestrictingAutoJoinToSubscriptionId(fakeSubscriptionId));
        startScan();
        ensureNotConnected();
        ShellIdentityUtils.invokeWithShellPermissions(() ->
                mWifiManager.stopRestrictingAutoJoinToSubscriptionId());
        startScan();
        waitForConnection();
    }

    /**
     * Test that the wifi country code is either null, or a length-2 string.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testGetCountryCode"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testGetCountryCode() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }

        String wifiCountryCode = ShellIdentityUtils.invokeWithShellPermissions(
                mWifiManager::getCountryCode);

        if (wifiCountryCode == null) {
            return;
        }
        assertEquals(2, wifiCountryCode.length());

        // assert that the country code is all uppercase
        assertEquals(wifiCountryCode.toUpperCase(Locale.US), wifiCountryCode);

        // skip if Telephony is unsupported
        if (!WifiFeature.isTelephonySupported(getContext())) {
            return;
        }

        String telephonyCountryCode = getContext().getSystemService(TelephonyManager.class)
                .getNetworkCountryIso();

        // skip if Telephony country code is unavailable
        if (telephonyCountryCode == null || telephonyCountryCode.isEmpty()) {
            return;
        }

        assertEquals(telephonyCountryCode, wifiCountryCode.toLowerCase(Locale.US));
    }

    /**
     * Test that {@link WifiManager#getCurrentNetwork()} returns a Network obeject consistent
     * with {@link ConnectivityManager#registerNetworkCallback} when connected to a Wifi network,
     * and returns null when not connected.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testGetCurrentNetwork"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testGetCurrentNetwork() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }

        // ensure Wifi is connected
        ShellIdentityUtils.invokeWithShellPermissions(() -> mWifiManager.reconnect());
        PollingCheck.check(
                ""Wifi not connected - Please ensure there is a saved network in range of this ""
                        + ""device"",
                WIFI_CONNECT_TIMEOUT_MILLIS,
                () -> mWifiManager.getConnectionInfo().getNetworkId() != -1);

        Network wifiCurrentNetwork = ShellIdentityUtils.invokeWithShellPermissions(
                mWifiManager::getCurrentNetwork);
        assertNotNull(wifiCurrentNetwork);

        TestNetworkCallback networkCallbackListener = new TestNetworkCallback(mLock);
        synchronized (mLock) {
            try {
                // File a request for wifi network.
                mConnectivityManager.registerNetworkCallback(
                        new NetworkRequest.Builder()
                                .addTransportType(TRANSPORT_WIFI)
                                .build(),
                        networkCallbackListener);
                // now wait for callback
                mLock.wait(TEST_WAIT_DURATION_MS);
            } catch (InterruptedException e) {
            }
        }
        assertTrue(networkCallbackListener.onAvailableCalled);
        Network connectivityCurrentNetwork = networkCallbackListener.network;
        assertEquals(connectivityCurrentNetwork, wifiCurrentNetwork);

        setWifiEnabled(false);
        PollingCheck.check(
                ""Wifi not disconnected!"",
                20000,
                () -> mWifiManager.getConnectionInfo().getNetworkId() == -1);

        assertNull(ShellIdentityUtils.invokeWithShellPermissions(mWifiManager::getCurrentNetwork));
    }

    /**
     * Tests {@link WifiManager#isWpa3SaeSupported()} does not crash.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testIsWpa3SaeSupported"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testIsWpa3SaeSupported() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        mWifiManager.isWpa3SaeSupported();
    }

    /**
     * Tests {@link WifiManager#isWpa3SuiteBSupported()} does not crash.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testIsWpa3SuiteBSupported"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testIsWpa3SuiteBSupported() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        mWifiManager.isWpa3SuiteBSupported();
    }

    /**
     * Tests {@link WifiManager#isEnhancedOpenSupported()} does not crash.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testIsEnhancedOpenSupported"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testIsEnhancedOpenSupported() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        mWifiManager.isEnhancedOpenSupported();
    }

    /**
     * Test that {@link WifiManager#is5GHzBandSupported()} returns successfully in
     * both WiFi enabled/disabled states.
     * Note that the response depends on device support and hence both true/false
     * are valid responses.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testIs5GhzBandSupported"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testIs5GhzBandSupported() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }

        // Check for 5GHz support with wifi enabled
        setWifiEnabled(true);
        PollingCheck.check(
                ""Wifi not enabled!"",
                20000,
                () -> mWifiManager.isWifiEnabled());
        boolean isSupportedEnabled = mWifiManager.is5GHzBandSupported();

        // Check for 5GHz support with wifi disabled
        setWifiEnabled(false);
        PollingCheck.check(
                ""Wifi not disabled!"",
                20000,
                () -> !mWifiManager.isWifiEnabled());
        boolean isSupportedDisabled = mWifiManager.is5GHzBandSupported();

        // If Support is true when WiFi is disable, then it has to be true when it is enabled.
        // Note, the reverse is a valid case.
        if (isSupportedDisabled) {
            assertTrue(isSupportedEnabled);
        }
    }

    /**
     * Test that {@link WifiManager#is6GHzBandSupported()} returns successfully in
     * both Wifi enabled/disabled states.
     * Note that the response depends on device support and hence both true/false
     * are valid responses.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testIs6GhzBandSupported"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testIs6GhzBandSupported() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }

        // Check for 6GHz support with wifi enabled
        setWifiEnabled(true);
        PollingCheck.check(
                ""Wifi not enabled!"",
                20000,
                () -> mWifiManager.isWifiEnabled());
        boolean isSupportedEnabled = mWifiManager.is6GHzBandSupported();

        // Check for 6GHz support with wifi disabled
        setWifiEnabled(false);
        PollingCheck.check(
                ""Wifi not disabled!"",
                20000,
                () -> !mWifiManager.isWifiEnabled());
        boolean isSupportedDisabled = mWifiManager.is6GHzBandSupported();

        // If Support is true when WiFi is disable, then it has to be true when it is enabled.
        // Note, the reverse is a valid case.
        if (isSupportedDisabled) {
            assertTrue(isSupportedEnabled);
        }
    }

    /**
     * Test that {@link WifiManager#is60GHzBandSupported()} returns successfully in
     * both Wifi enabled/disabled states.
     * Note that the response depends on device support and hence both true/false
     * are valid responses.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testIs60GhzBandSupported"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testIs60GhzBandSupported() throws Exception {
        if (!(WifiFeature.isWifiSupported(getContext())
                && ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S))) {
            // skip the test if WiFi is not supported
            return;
        }

        // Check for 60GHz support with wifi enabled
        setWifiEnabled(true);
        PollingCheck.check(
                ""Wifi not enabled!"",
                20000,
                () -> mWifiManager.isWifiEnabled());
        boolean isSupportedEnabled = mWifiManager.is60GHzBandSupported();

        // Check for 60GHz support with wifi disabled
        setWifiEnabled(false);
        PollingCheck.check(
                ""Wifi not disabled!"",
                20000,
                () -> !mWifiManager.isWifiEnabled());
        boolean isSupportedDisabled = mWifiManager.is60GHzBandSupported();

        // If Support is true when WiFi is disable, then it has to be true when it is enabled.
        // Note, the reverse is a valid case.
        if (isSupportedDisabled) {
            assertTrue(isSupportedEnabled);
        }
    }

    /**
     * Test that {@link WifiManager#isWifiStandardSupported()} returns successfully in
     * both Wifi enabled/disabled states. The test is to be performed on
     * {@link WifiAnnotations}'s {@code WIFI_STANDARD_}
     * Note that the response depends on device support and hence both true/false
     * are valid responses.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testSetTdlsEnabled"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testSetTdlsEnabled() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // Trigger a scan & wait for connection to one of the saved networks.
        mWifiManager.startScan();
        waitForConnection();

        InetAddress inetAddress = InetAddress.getByName(TEST_IP_ADDRESS);

        mWifiManager.setTdlsEnabled(inetAddress, true);
        Thread.sleep(50);
        mWifiManager.setTdlsEnabled(inetAddress, false);
    }

    /**
     * Tests {@link WifiManager#setTdlsEnabledWithMacAddress(String, boolean)} does not crash.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testSetTdlsEnabledWithMacAddress"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testSetTdlsEnabledWithMacAddress() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // Trigger a scan & wait for connection to one of the saved networks.
        mWifiManager.startScan();
        waitForConnection();

        mWifiManager.setTdlsEnabledWithMacAddress(TEST_MAC_ADDRESS, true);
        Thread.sleep(50);
        mWifiManager.setTdlsEnabledWithMacAddress(TEST_MAC_ADDRESS, false);
    }

    /**
     * Verify WifiNetworkSuggestion.Builder.setMacRandomizationSetting(WifiNetworkSuggestion
     * .RANDOMIZATION_NON_PERSISTENT) creates a
     * WifiConfiguration with macRandomizationSetting == RANDOMIZATION_NON_PERSISTENT.
     * Then verify by default, a WifiConfiguration created by suggestions should have
     * macRandomizationSetting == RANDOMIZATION_PERSISTENT.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testSuggestionBuilderNonPersistentRandomization"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testSuggestionBuilderNonPersistentRandomization() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        WifiNetworkSuggestion suggestion = new WifiNetworkSuggestion.Builder()
                .setSsid(TEST_SSID).setWpa2Passphrase(TEST_PASSPHRASE)
                .setMacRandomizationSetting(WifiNetworkSuggestion.RANDOMIZATION_NON_PERSISTENT)
                .build();
        assertEquals(WifiManager.STATUS_NETWORK_SUGGESTIONS_SUCCESS,
                mWifiManager.addNetworkSuggestions(Arrays.asList(suggestion)));
        verifySuggestionFoundWithMacRandomizationSetting(TEST_SSID,
                WifiConfiguration.RANDOMIZATION_NON_PERSISTENT);

        suggestion = new WifiNetworkSuggestion.Builder()
                .setSsid(TEST_SSID).setWpa2Passphrase(TEST_PASSPHRASE)
                .build();
        assertEquals(WifiManager.STATUS_NETWORK_SUGGESTIONS_SUCCESS,
                mWifiManager.addNetworkSuggestions(Arrays.asList(suggestion)));
        verifySuggestionFoundWithMacRandomizationSetting(TEST_SSID,
                WifiConfiguration.RANDOMIZATION_PERSISTENT);
    }

    private void verifySuggestionFoundWithMacRandomizationSetting(String ssid,
            int macRandomizationSetting) {
        List<WifiNetworkSuggestion> retrievedSuggestions = mWifiManager.getNetworkSuggestions();
        for (WifiNetworkSuggestion entry : retrievedSuggestions) {
            if (entry.getSsid().equals(ssid)) {
                assertEquals(macRandomizationSetting,
                        entry.getWifiConfiguration().macRandomizationSetting);
                return; // pass test after the MAC randomization setting is verified.
            }
        }
        fail(""WifiNetworkSuggestion not found for SSID="" + ssid + "", macRandomizationSetting=""
                + macRandomizationSetting);
    }

    /**
     * Tests {@link WifiManager#getWifiConfigForMatchedNetworkSuggestionsSharedWithUser(List)}
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testGetAllWifiConfigForMatchedNetworkSuggestion"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testGetAllWifiConfigForMatchedNetworkSuggestion() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        ScanResult scanResult = new ScanResult();
        scanResult.SSID = TEST_SSID;
        scanResult.capabilities = TEST_PSK_CAP;
        scanResult.BSSID = TEST_BSSID;
        List<ScanResult> testList = Arrays.asList(scanResult);
        WifiNetworkSuggestion suggestion = new WifiNetworkSuggestion.Builder()
                .setSsid(TEST_SSID).setWpa2Passphrase(TEST_PASSPHRASE).build();

        assertEquals(WifiManager.STATUS_NETWORK_SUGGESTIONS_SUCCESS,
                mWifiManager.addNetworkSuggestions(Arrays.asList(suggestion)));
        List<WifiConfiguration> matchedResult;
        try {
            uiAutomation.adoptShellPermissionIdentity();
            matchedResult = mWifiManager
                    .getWifiConfigForMatchedNetworkSuggestionsSharedWithUser(testList);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
        // As suggestion is not approved, will return empty list.
        assertTrue(matchedResult.isEmpty());
    }

    /**
     * Tests {@link WifiManager#getMatchingScanResults(List, List)}
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testGetMatchingScanResults"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testGetMatchingScanResults() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // Create pair of ScanResult and WifiNetworkSuggestion
        ScanResult scanResult = new ScanResult();
        scanResult.SSID = TEST_SSID;
        scanResult.capabilities = TEST_PSK_CAP;
        scanResult.BSSID = TEST_BSSID;

        WifiNetworkSuggestion suggestion = new WifiNetworkSuggestion.Builder()
                .setSsid(TEST_SSID).setWpa2Passphrase(TEST_PASSPHRASE).build();

        Map<WifiNetworkSuggestion, List<ScanResult>> matchedResults = mWifiManager
                .getMatchingScanResults(Arrays.asList(suggestion), Arrays.asList(scanResult));
        // Verify result is matched pair of ScanResult and WifiNetworkSuggestion
        assertEquals(scanResult.SSID, matchedResults.get(suggestion).get(0).SSID);

        // Change ScanResult to unmatched should return empty result.
        scanResult.SSID = TEST_SSID_UNQUOTED;
        matchedResults = mWifiManager
                .getMatchingScanResults(Arrays.asList(suggestion), Arrays.asList(scanResult));
        assertTrue(matchedResults.get(suggestion).isEmpty());
    }

    /**
     * Tests {@link WifiManager#disableEphemeralNetwork(String)}.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testDisableEphemeralNetwork"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testDisableEphemeralNetwork() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // Trigger a scan & wait for connection to one of the saved networks.
        mWifiManager.startScan();
        waitForConnection();

        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        List<WifiConfiguration> savedNetworks = null;
        try {
            uiAutomation.adoptShellPermissionIdentity();
            // Temporarily disable on all networks.
            savedNetworks = mWifiManager.getConfiguredNetworks();
            for (WifiConfiguration network : savedNetworks) {
                mWifiManager.disableEphemeralNetwork(network.SSID);
            }
            // trigger a disconnect and wait for disconnect.
            mWifiManager.disconnect();
            waitForDisconnection();

            // Now trigger scan and ensure that the device does not connect to any networks.
            mWifiManager.startScan();
            ensureNotConnected();
        } finally {
            uiAutomation.dropShellPermissionIdentity();
            setWifiEnabled(false);
        }
    }

    /**
     * Tests {@link WifiManager#allowAutojoin(int, boolean)}.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testAllowAutojoinGlobal"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testAllowAutojoinGlobal() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // Trigger a scan & wait for connection to one of the saved networks.
        mWifiManager.startScan();
        waitForConnection();

        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            // disable autojoin on all networks.
            mWifiManager.allowAutojoinGlobal(false);

            // trigger a disconnect and wait for disconnect.
            mWifiManager.disconnect();
            waitForDisconnection();

            // Now trigger scan and ensure that the device does not connect to any networks.
            mWifiManager.startScan();
            ensureNotConnected();

            // Now enable autojoin on all networks.
            mWifiManager.allowAutojoinGlobal(true);

            // Trigger a scan & wait for connection to one of the saved networks.
            mWifiManager.startScan();
            waitForConnection();
        } finally {
            // Re-enable auto join if the test fails for some reason.
            mWifiManager.allowAutojoinGlobal(true);
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link WifiManager#isWapiSupported()} does not crash.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testIsWapiSupported"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testIsWapiSupported() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        mWifiManager.isWapiSupported();
    }

    /**
     * Tests {@link WifiManager#isWpa3SaePublicKeySupported()} does not crash.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testIsWpa3SaePublicKeySupported"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testIsWpa3SaePublicKeySupported() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        mWifiManager.isWpa3SaePublicKeySupported();
    }

    /**
     * Tests {@link WifiManager#isWpa3SaeH2eSupported()} does not crash.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testIsWpa3SaeH2eSupported"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testIsWpa3SaeH2eSupported() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        mWifiManager.isWpa3SaeH2eSupported();
    }

    /**
     * Tests {@link WifiManager#isWifiDisplayR2Supported()} does not crash.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testIsWifiDisplayR2Supported"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testIsWifiDisplayR2Supported() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        mWifiManager.isWifiDisplayR2Supported();
    }

    /**
     * Tests {@link WifiManager#isP2pSupported()} returns true
     * if this device supports it, otherwise, ensure no crash.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testIsP2pSupported"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testIsP2pSupported() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }

        if (WifiFeature.isP2pSupported(getContext())) {
            // if this device supports P2P, ensure hw capability is correct.
            assertTrue(mWifiManager.isP2pSupported());
        } else {
            // ensure no crash.
            mWifiManager.isP2pSupported();
        }

    }

    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testIs60GhzBandSupportedOnROrOlder"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testIs60GhzBandSupportedOnROrOlder() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }

        // check for 60ghz support with wifi enabled
        try {
            boolean isSupported = mWifiManager.is60GHzBandSupported();
            fail(""Expected UnsupportedOperationException"");
        } catch (UnsupportedOperationException ex) {
        }

    }

    /**
     * Test that {@link WifiManager#is60GHzBandSupported()} returns successfully in
     * both Wifi enabled/disabled states for release newer than R.
     * Note that the response depends on device support and hence both true/false
     * are valid responses.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testIs60GhzBandSupportedOnSOrNewer"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testIs60GhzBandSupportedOnSOrNewer() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }

        // check for 60ghz support with wifi enabled
        boolean isSupportedWhenWifiEnabled = mWifiManager.is60GHzBandSupported();

        // Check for 60GHz support with wifi disabled
        setWifiEnabled(false);
        PollingCheck.check(
                ""Wifi not disabled!"",
                20000,
                () -> !mWifiManager.isWifiEnabled());
        boolean isSupportedWhenWifiDisabled = mWifiManager.is60GHzBandSupported();

        // If Support is true when WiFi is disable, then it has to be true when it is enabled.
        // Note, the reverse is a valid case.
        if (isSupportedWhenWifiDisabled) {
            assertTrue(isSupportedWhenWifiEnabled);
        }
    }

    public class TestCoexCallback extends WifiManager.CoexCallback {
        private Object mCoexLock;
        private int mOnCoexUnsafeChannelChangedCount;
        private List<CoexUnsafeChannel> mCoexUnsafeChannels;
        private int mCoexRestrictions;

        TestCoexCallback(Object lock) {
            mCoexLock = lock;
        }

        @Override
        public void onCoexUnsafeChannelsChanged(
                    @NonNull List<CoexUnsafeChannel> unsafeChannels, int restrictions) {
            synchronized (mCoexLock) {
                mCoexUnsafeChannels = unsafeChannels;
                mCoexRestrictions = restrictions;
                mOnCoexUnsafeChannelChangedCount++;
                mCoexLock.notify();
            }
        }

        public int getOnCoexUnsafeChannelChangedCount() {
            synchronized (mCoexLock) {
                return mOnCoexUnsafeChannelChangedCount;
            }
        }

        public List<CoexUnsafeChannel> getCoexUnsafeChannels() {
            return mCoexUnsafeChannels;
        }

        public int getCoexRestrictions() {
            return mCoexRestrictions;
        }
    }

    /**
     * Test that coex-related methods fail without the needed privileged permissions
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testCoexMethodsShouldFailNoPermission"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testCoexMethodsShouldFailNoPermission() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }

        try {
            mWifiManager.setCoexUnsafeChannels(Collections.emptyList(), 0);
            fail(""setCoexUnsafeChannels should not succeed - privileged call"");
        } catch (SecurityException e) {
            // expected
        }
        final TestCoexCallback callback = new TestCoexCallback(mLock);
        try {
            mWifiManager.registerCoexCallback(mExecutor, callback);
            fail(""registerCoexCallback should not succeed - privileged call"");
        } catch (SecurityException e) {
            // expected
        }
        try {
            mWifiManager.unregisterCoexCallback(callback);
            fail(""unregisterCoexCallback should not succeed - privileged call"");
        } catch (SecurityException e) {
            // expected
        }
    }

    /**
     * Test that coex-related methods succeed in setting the current unsafe channels and notifying
     * the listener. Since the default coex algorithm may be enabled, no-op is also valid behavior.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testListenOnCoexUnsafeChannels"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testListenOnCoexUnsafeChannels() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }

        // These below API's only work with privileged permissions (obtained via shell identity
        // for test)
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        List<CoexUnsafeChannel> prevUnsafeChannels = null;
        int prevRestrictions = -1;
        try {
            uiAutomation.adoptShellPermissionIdentity();
            final TestCoexCallback callback = new TestCoexCallback(mLock);
            final List<CoexUnsafeChannel> testUnsafeChannels = new ArrayList<>();
            testUnsafeChannels.add(new CoexUnsafeChannel(WIFI_BAND_24_GHZ, 6));
            final int testRestrictions = COEX_RESTRICTION_WIFI_DIRECT
                    | COEX_RESTRICTION_SOFTAP | COEX_RESTRICTION_WIFI_AWARE;
            synchronized (mLock) {
                try {
                    mWifiManager.registerCoexCallback(mExecutor, callback);
                    // Callback should be called after registering
                    mLock.wait(TEST_WAIT_DURATION_MS);
                    assertEquals(1, callback.getOnCoexUnsafeChannelChangedCount());
                    // Store the previous coex channels and set new coex channels
                    prevUnsafeChannels = callback.getCoexUnsafeChannels();
                    prevRestrictions = callback.getCoexRestrictions();
                    mWifiManager.setCoexUnsafeChannels(testUnsafeChannels, testRestrictions);
                    mLock.wait(TEST_WAIT_DURATION_MS);
                    // Unregister callback and try setting again
                    mWifiManager.unregisterCoexCallback(callback);
                    mWifiManager.setCoexUnsafeChannels(testUnsafeChannels, testRestrictions);
                    // Callback should not be called here since it was unregistered.
                    mLock.wait(TEST_WAIT_DURATION_MS);
                } catch (InterruptedException e) {
                    fail(""Thread interrupted unexpectedly while waiting on mLock"");
                }
            }
            if (callback.getOnCoexUnsafeChannelChangedCount() == 2) {
                // Default algorithm disabled, setter should set the getter values.
                assertEquals(testUnsafeChannels, callback.getCoexUnsafeChannels());
                assertEquals(testRestrictions, callback.getCoexRestrictions());
            } else if (callback.getOnCoexUnsafeChannelChangedCount() != 1) {
                fail(""Coex callback called "" + callback.mOnCoexUnsafeChannelChangedCount
                        + "" times. Expected 0 or 1 calls."" );
            }
        } finally {
            // Reset the previous unsafe channels if we overrode them.
            if (prevRestrictions != -1) {
                mWifiManager.setCoexUnsafeChannels(prevUnsafeChannels, prevRestrictions);
            }
            uiAutomation.dropShellPermissionIdentity();
        }
    }


    /**
     * Verify that insecure WPA-Enterprise network configurations are rejected.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testIsDecoratedIdentitySupported"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testIsDecoratedIdentitySupported() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        if (!WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(getContext())) {
            // Skip the test if wifi module version is older than S.
            return;
        }
        mWifiManager.isDecoratedIdentitySupported();
    }

    /**
     * Tests {@link WifiManager#setCarrierNetworkOffloadEnabled)} and
     * {@link WifiManager#isCarrierNetworkOffloadEnabled} work as expected.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testSetCarrierNetworkOffloadEnabled"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testSetCarrierNetworkOffloadEnabled() {
        if (!WifiFeature.isWifiSupported(getContext())
                || !WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        assertTrue(mWifiManager.isCarrierNetworkOffloadEnabled(TEST_SUB_ID, false));
        // The below API only works with privileged permissions (obtained via shell identity
        // for test)
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            mWifiManager.setCarrierNetworkOffloadEnabled(TEST_SUB_ID, false, false);
            assertFalse(mWifiManager.isCarrierNetworkOffloadEnabled(TEST_SUB_ID, false));
        } finally {
            mWifiManager.setCarrierNetworkOffloadEnabled(TEST_SUB_ID, false, true);
            uiAutomation.dropShellPermissionIdentity();
        }
        assertTrue(mWifiManager.isCarrierNetworkOffloadEnabled(TEST_SUB_ID, false));
    }

   /**
     * Test that {@link WifiManager#getUsableChannels(int, int)},
     * {@link WifiManager#getAllowedChannels(int, int)}
     * throws UnsupportedOperationException if the release is older than S.
     */
    @SdkSuppress(maxSdkVersion = Build.VERSION_CODES.R)"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testGetAllowedUsableChannelsOnROrOlder"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testGetAllowedUsableChannelsOnROrOlder() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        try {
            mWifiManager.getAllowedChannels(WIFI_BAND_24_GHZ, OP_MODE_STA);
            fail(""getAllowedChannels Expected to fail - UnsupportedOperationException"");
        } catch (UnsupportedOperationException ex) {}

        try {
            mWifiManager.getUsableChannels(WIFI_BAND_24_GHZ, OP_MODE_STA);
            fail(""getUsableChannels Expected to fail - UnsupportedOperationException"");
        } catch (UnsupportedOperationException ex) {}
    }

    /**
     * Tests {@link WifiManager#getAllowedChannels(int, int))} does not crash
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testGetAllowedChannels"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testGetAllowedChannels() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // The below API only works with privileged permissions (obtained via shell identity
        // for test)
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {

            WifiAvailableChannel channel = new WifiAvailableChannel(2412, OP_MODE_SAP);
            assertEquals(channel.getFrequencyMhz(), 2412);
            assertEquals(channel.getOperationalModes(), OP_MODE_SAP);
            final List<Integer> valid24GhzFreqs = Arrays.asList(
                2412, 2417, 2422, 2427, 2432, 2437, 2442,
                2447, 2452, 2457, 2462, 2467, 2472, 2484);
            Set<Integer> supported24GhzFreqs = new HashSet<Integer>();
            uiAutomation.adoptShellPermissionIdentity();
            List<WifiAvailableChannel> allowedChannels =
                mWifiManager.getAllowedChannels(WIFI_BAND_24_GHZ, OP_MODE_STA);
            assertNotNull(allowedChannels);
            for (WifiAvailableChannel ch : allowedChannels) {
                //Must contain a valid 2.4GHz frequency
                assertTrue(valid24GhzFreqs.contains(ch.getFrequencyMhz()));
                if(ch.getFrequencyMhz() <= 2462) {
                    //Channels 1-11 are supported for STA in all countries
                    assertEquals(ch.getOperationalModes() & OP_MODE_STA, OP_MODE_STA);
                    supported24GhzFreqs.add(ch.getFrequencyMhz());
                }
            }
            //Channels 1-11 are supported for STA in all countries
            assertEquals(supported24GhzFreqs.size(), 11);
        } catch (UnsupportedOperationException ex) {
            //expected if the device does not support this API
        } catch (Exception ex) {
            fail(""getAllowedChannels unexpected Exception "" + ex);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link WifiManager#getUsableChannels(int, int))} does not crash.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testAddRemoveSuggestionUserApprovalStatusListener"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testAddRemoveSuggestionUserApprovalStatusListener() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())
                || !WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(getContext())) {
            return;
        }
        CountDownLatch countDownLatch = new CountDownLatch(1);
        TestUserApprovalStatusListener listener = new TestUserApprovalStatusListener(
                countDownLatch);
        try {
            mWifiManager.addSuggestionUserApprovalStatusListener(mExecutor, listener);
            assertTrue(countDownLatch.await(TEST_WAIT_DURATION_MS, TimeUnit.MILLISECONDS));
        } finally {
            mWifiManager.removeSuggestionUserApprovalStatusListener(listener);
        }
    }

    private static class TestUserApprovalStatusListener implements
            WifiManager.SuggestionUserApprovalStatusListener {
        private final CountDownLatch mBlocker;

        public TestUserApprovalStatusListener(CountDownLatch countDownLatch) {
            mBlocker = countDownLatch;
        }
        @Override
        public void onUserApprovalStatusChange(int status) {
            mBlocker.countDown();
        }
    }
}"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.wifiaware.BaseTestCase"	"executeTest"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/wifiaware/BaseTestCase.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.wifiaware;

import android.content.Context;
import android.content.res.Resources;
import android.net.wifi.aware.WifiAwareManager;
import android.os.Handler;
import android.os.HandlerThread;

import com.android.cts.verifier.R;

/**
 * Base class for all Aware test cases.
 */
public abstract class BaseTestCase {
    protected Context mContext;
    protected Resources mResources;
    protected Listener mListener;

    private Thread mThread;
    private HandlerThread mHandlerThread;
    protected Handler mHandler;

    protected WifiAwareManager mWifiAwareManager;

    public BaseTestCase(Context context) {
        mContext = context;
        mResources = mContext.getResources();
    }

    /**
     * Set up the test case. Executed once before test starts.
     */
    protected void setUp() {
        mWifiAwareManager = (WifiAwareManager) mContext.getSystemService(
                Context.WIFI_AWARE_SERVICE);
    }

    /**
     * Tear down the test case. Executed after test finishes - whether on success or failure.
     */
    protected void tearDown() {
        mWifiAwareManager = null;
    }

    /**
     * Execute test case.
     *
     * @return true on success, false on failure. In case of failure
     */
    protected abstract boolean executeTest() throws InterruptedException;

    /**
     * Returns a String describing the failure reason of the most recent test failure (not valid
     * in other scenarios). Override to customize the failure string.
     */
    protected String getFailureReason() {
        return mContext.getString(R.string.aware_unexpected_error);
    }

    /**
     * Start running the test case.
     *
     * Test case is executed in another thread.
     */
    public void start(Listener listener) {
        mListener = listener;

        stop();
        mHandlerThread = new HandlerThread(""CtsVerifier-Aware"");
        mHandlerThread.start();
        mHandler = new Handler(mHandlerThread.getLooper());
        mThread = new Thread(
                new Runnable() {
                    @Override
                    public void run() {
                        mListener.onTestStarted();
                        try {
                            setUp();
                        } catch (Exception e) {
                            mListener.onTestFailed(mContext.getString(R.string.aware_setup_error));
                            return;
                        }

                        try {
                            if (executeTest()) {
                                mListener.onTestSuccess();
                            } else {
                                mListener.onTestFailed(getFailureReason());
                            }
                        } catch (Exception e) {
                            e.printStackTrace();
                            mListener.onTestFailed(
                                    mContext.getString(R.string.aware_unexpected_error));
                        } finally {
                            tearDown();
                        }
                    }
                });
        mThread.start();
    }

    /**
     * Stop the currently running test case.
     */
    public void stop() {
        if (mThread != null) {
            mThread.interrupt();
            mThread = null;
        }
        if (mHandlerThread != null) {
            mHandlerThread.quitSafely();
            mHandlerThread = null;
            mHandler = null;
        }
    }

    /**
     * Listener interface used to communicate the state and status of the test case. It should
     * be implemented by any activity encompassing a test case.
     */
    public interface Listener {
        /**
         * This function is invoked when the test case starts.
         */
        void onTestStarted();

        /**
         * This function is invoked by the test to send a message to listener.
         */
        void onTestMsgReceived(String msg);

        /**
         * This function is invoked when the test finished successfully.
         */
        void onTestSuccess();

        /**
         * This function is invoked when the test failed (test is done).
         */
        void onTestFailed(String reason);
    }

    /**
     * Convert byte array to hex string representation utility.
     */
    public static String bytesToHex(byte[] bytes, Character separator) {
        final char[] hexArray = ""0123456789ABCDEF"".toCharArray();
        boolean useSeparator = separator != null;
        char sep = 0;
        if (useSeparator) {
            sep = separator;
        }
        char[] hexChars = new char[bytes.length * 2 + (useSeparator ? bytes.length - 1 : 0)];
        int base = 0;
        for (int j = 0; j < bytes.length; j++) {
            if (useSeparator && j != 0) {
                hexChars[base++] = sep;
            }
            int v = bytes[j] & 0xFF;
            hexChars[base++] = hexArray[v >> 4];
            hexChars[base++] = hexArray[v & 0x0F];
        }
        return new String(hexChars);
    }
}"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSpecifierTest"	"isNotNull"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSpecifierTest.java"	""	"/*
 *.
 */

package android.net.wifi.cts;

import static android.os.Process.myUid;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import static org.junit.Assume.assumeTrue;

import android.annotation.NonNull;
import android.content.Context;
import android.net.ConnectivityManager;
import android.net.ConnectivityManager.NetworkCallback;
import android.net.MacAddress;
import android.net.Network;
import android.net.NetworkCapabilities;
import android.net.NetworkRequest;
import android.net.NetworkSpecifier;
import android.net.wifi.ScanResult;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiEnterpriseConfig;
import android.net.wifi.WifiInfo;
import android.net.wifi.WifiManager;
import android.net.wifi.WifiNetworkSpecifier;
import android.os.Build;
import android.os.PatternMatcher;
import android.platform.test.annotations.AppModeFull;
import android.support.test.uiautomator.UiDevice;
import android.util.Pair;

import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.filters.LargeTest;
import androidx.test.filters.SdkSuppress;
import androidx.test.platform.app.InstrumentationRegistry;

import com.android.compatibility.common.util.ApiLevelUtil;
import com.android.compatibility.common.util.PollingCheck;
import com.android.compatibility.common.util.ShellIdentityUtils;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.security.KeyFactory;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.PKCS8EncodedKeySpec;
import java.util.List;
import java.util.ArrayList;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;

/**
 * Tests the entire connection flow using {@link WifiNetworkSpecifier} embedded in a
 * {@link NetworkRequest} & passed into {@link ConnectivityManager#requestNetwork(NetworkRequest,
 * ConnectivityManager.NetworkCallback)}.
 *
 * Assumes that all the saved networks is either open/WPA1/WPA2/WPA3 authenticated network.
 */
@AppModeFull(reason = ""Cannot get WifiManager in instant app mode"")
@LargeTest
@RunWith(AndroidJUnit4.class)
public class WifiNetworkSpecifierTest extends WifiJUnit4TestBase {
    private static final String TAG = ""WifiNetworkSpecifierTest"";

    private static final String CA_SUITE_B_ECDSA_CERT_STRING =
            ""-----BEGIN CERTIFICATE-----\n""
                    + ""MIICTzCCAdSgAwIBAgIUdnLttwNPnQzFufplGOr9bTrGCqMwCgYIKoZIzj0EAwMw\n""
                    + ""XjELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAkNBMQwwCgYDVQQHDANNVFYxEDAOBgNV\n""
                    + ""BAoMB0FuZHJvaWQxDjAMBgNVBAsMBVdpLUZpMRIwEAYDVQQDDAl1bml0ZXN0Q0Ew\n""
                    + ""HhcNMjAwNzIxMDIyNDA1WhcNMzAwNTMwMDIyNDA1WjBeMQswCQYDVQQGEwJVUzEL\n""
                    + ""MAkGA1UECAwCQ0ExDDAKBgNVBAcMA01UVjEQMA4GA1UECgwHQW5kcm9pZDEOMAwG\n""
                    + ""A1UECwwFV2ktRmkxEjAQBgNVBAMMCXVuaXRlc3RDQTB2MBAGByqGSM49AgEGBSuB\n""
                    + ""BAAiA2IABFmntXwk9icqhDQFUP1xy04WyEpaGW4q6Q+8pujlSl/X3iotPZ++GZfp\n""
                    + ""Mfv3YDHDBl6sELPQ2BEjyPXmpsKjOUdiUe69e88oGEdeqT2xXiQ6uzpTfJD4170i\n""
                    + ""O/TwLrQGKKNTMFEwHQYDVR0OBBYEFCjptsX3g4g5W0L4oEP6N3gfyiZXMB8GA1Ud\n""
                    + ""IwQYMBaAFCjptsX3g4g5W0L4oEP6N3gfyiZXMA8GA1UdEwEB/wQFMAMBAf8wCgYI\n""
                    + ""KoZIzj0EAwMDaQAwZgIxAK61brUYRbLmQKiaEboZgrHtnPAcGo7Yzx3MwHecx3Dm\n""
                    + ""5soIeLVYc8bPYN1pbhXW1gIxALdEe2sh03nBHyQH4adYoZungoCwt8mp/7sJFxou\n""
                    + ""9UnRegyBgGzf74ROWdpZHzh+Pg==\n""
                    + ""-----END CERTIFICATE-----\n"";
    public static final X509Certificate CA_SUITE_B_ECDSA_CERT =
            loadCertificate(CA_SUITE_B_ECDSA_CERT_STRING);

    private static final String CLIENT_SUITE_B_ECDSA_CERT_STRING =
            ""-----BEGIN CERTIFICATE-----\n""
                    + ""MIIB9zCCAX4CFDpfSZh3AH07BEfGWuMDa7Ynz6y+MAoGCCqGSM49BAMDMF4xCzAJ\n""
                    + ""BgNVBAYTAlVTMQswCQYDVQQIDAJDQTEMMAoGA1UEBwwDTVRWMRAwDgYDVQQKDAdB\n""
                    + ""bmRyb2lkMQ4wDAYDVQQLDAVXaS1GaTESMBAGA1UEAwwJdW5pdGVzdENBMB4XDTIw\n""
                    + ""MDcyMTAyMjk1MFoXDTMwMDUzMDAyMjk1MFowYjELMAkGA1UEBhMCVVMxCzAJBgNV\n""
                    + ""BAgMAkNBMQwwCgYDVQQHDANNVFYxEDAOBgNVBAoMB0FuZHJvaWQxDjAMBgNVBAsM\n""
                    + ""BVdpLUZpMRYwFAYDVQQDDA11bml0ZXN0Q2xpZW50MHYwEAYHKoZIzj0CAQYFK4EE\n""
                    + ""ACIDYgAEhxhVJ7dcSqrto0X+dgRxtd8BWG8cWmPjBji3MIxDLfpcMDoIB84ae1Ew\n""
                    + ""gJn4YUYHrWsUDiVNihv8j7a/Ol1qcIY2ybH7tbezefLmagqA4vXEUXZXoUyL4ZNC\n""
                    + ""DWcdw6LrMAoGCCqGSM49BAMDA2cAMGQCMH4aP73HrriRUJRguiuRic+X4Cqj/7YQ\n""
                    + ""ueJmP87KF92/thhoQ9OrRo8uJITPmNDswwIwP2Q1AZCSL4BI9dYrqu07Ar+pSkXE\n""
                    + ""R7oOqGdZR+d/MvXcFSrbIaLKEoHXmQamIHLe\n""
                    + ""-----END CERTIFICATE-----\n"";
    public static final X509Certificate CLIENT_SUITE_B_ECDSA_CERT =
            loadCertificate(CLIENT_SUITE_B_ECDSA_CERT_STRING);

    private static final byte[] CLIENT_SUITE_B_ECC_KEY_DATA = new byte[]{
            (byte) 0x30, (byte) 0x81, (byte) 0xb6, (byte) 0x02, (byte) 0x01, (byte) 0x00,
            (byte) 0x30, (byte) 0x10, (byte) 0x06, (byte) 0x07, (byte) 0x2a, (byte) 0x86,
            (byte) 0x48, (byte) 0xce, (byte) 0x3d, (byte) 0x02, (byte) 0x01, (byte) 0x06,
            (byte) 0x05, (byte) 0x2b, (byte) 0x81, (byte) 0x04, (byte) 0x00, (byte) 0x22,
            (byte) 0x04, (byte) 0x81, (byte) 0x9e, (byte) 0x30, (byte) 0x81, (byte) 0x9b,
            (byte) 0x02, (byte) 0x01, (byte) 0x01, (byte) 0x04, (byte) 0x30, (byte) 0xea,
            (byte) 0x6c, (byte) 0x4b, (byte) 0x6d, (byte) 0x43, (byte) 0xf9, (byte) 0x6c,
            (byte) 0x91, (byte) 0xdc, (byte) 0x2d, (byte) 0x6e, (byte) 0x87, (byte) 0x4f,
            (byte) 0x0a, (byte) 0x0b, (byte) 0x97, (byte) 0x25, (byte) 0x1c, (byte) 0x79,
            (byte) 0xa2, (byte) 0x07, (byte) 0xdc, (byte) 0x94, (byte) 0xc2, (byte) 0xee,
            (byte) 0x64, (byte) 0x51, (byte) 0x6d, (byte) 0x4e, (byte) 0x35, (byte) 0x1c,
            (byte) 0x22, (byte) 0x2f, (byte) 0xc0, (byte) 0xea, (byte) 0x09, (byte) 0x47,
            (byte) 0x3e, (byte) 0xb9, (byte) 0xb6, (byte) 0xb8, (byte) 0x83, (byte) 0x9e,
            (byte) 0xed, (byte) 0x59, (byte) 0xe5, (byte) 0xe7, (byte) 0x0f, (byte) 0xa1,
            (byte) 0x64, (byte) 0x03, (byte) 0x62, (byte) 0x00, (byte) 0x04, (byte) 0x87,
            (byte) 0x18, (byte) 0x55, (byte) 0x27, (byte) 0xb7, (byte) 0x5c, (byte) 0x4a,
            (byte) 0xaa, (byte) 0xed, (byte) 0xa3, (byte) 0x45, (byte) 0xfe, (byte) 0x76,
            (byte) 0x04, (byte) 0x71, (byte) 0xb5, (byte) 0xdf, (byte) 0x01, (byte) 0x58,
            (byte) 0x6f, (byte) 0x1c, (byte) 0x5a, (byte) 0x63, (byte) 0xe3, (byte) 0x06,
            (byte) 0x38, (byte) 0xb7, (byte) 0x30, (byte) 0x8c, (byte) 0x43, (byte) 0x2d,
            (byte) 0xfa, (byte) 0x5c, (byte) 0x30, (byte) 0x3a, (byte) 0x08, (byte) 0x07,
            (byte) 0xce, (byte) 0x1a, (byte) 0x7b, (byte) 0x51, (byte) 0x30, (byte) 0x80,
            (byte) 0x99, (byte) 0xf8, (byte) 0x61, (byte) 0x46, (byte) 0x07, (byte) 0xad,
            (byte) 0x6b, (byte) 0x14, (byte) 0x0e, (byte) 0x25, (byte) 0x4d, (byte) 0x8a,
            (byte) 0x1b, (byte) 0xfc, (byte) 0x8f, (byte) 0xb6, (byte) 0xbf, (byte) 0x3a,
            (byte) 0x5d, (byte) 0x6a, (byte) 0x70, (byte) 0x86, (byte) 0x36, (byte) 0xc9,
            (byte) 0xb1, (byte) 0xfb, (byte) 0xb5, (byte) 0xb7, (byte) 0xb3, (byte) 0x79,
            (byte) 0xf2, (byte) 0xe6, (byte) 0x6a, (byte) 0x0a, (byte) 0x80, (byte) 0xe2,
            (byte) 0xf5, (byte) 0xc4, (byte) 0x51, (byte) 0x76, (byte) 0x57, (byte) 0xa1,
            (byte) 0x4c, (byte) 0x8b, (byte) 0xe1, (byte) 0x93, (byte) 0x42, (byte) 0x0d,
            (byte) 0x67, (byte) 0x1d, (byte) 0xc3, (byte) 0xa2, (byte) 0xeb
    };
    public static final PrivateKey CLIENT_SUITE_B_ECC_KEY =
            loadPrivateKey(""EC"", CLIENT_SUITE_B_ECC_KEY_DATA);

    private static X509Certificate loadCertificate(String blob) {
        try {
            final CertificateFactory certFactory = CertificateFactory.getInstance(""X.509"");
            InputStream stream = new ByteArrayInputStream(blob.getBytes(StandardCharsets.UTF_8));

            return (X509Certificate) certFactory.generateCertificate(stream);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    private static PrivateKey loadPrivateKey(String algorithm, byte[] fakeKey) {
        try {
            KeyFactory kf = KeyFactory.getInstance(algorithm);
            return kf.generatePrivate(new PKCS8EncodedKeySpec(fakeKey));
        } catch (InvalidKeySpecException | NoSuchAlgorithmException e) {
            return null;
        }
    }

    private static boolean sWasVerboseLoggingEnabled;
    private static boolean sWasScanThrottleEnabled;
    private static WifiConfiguration sTestNetwork;

    private Context mContext;
    private WifiManager mWifiManager;
    private ConnectivityManager mConnectivityManager;
    private UiDevice mUiDevice;
    private ConnectivityManager.NetworkCallback mNrNetworkCallback;
    private TestHelper mTestHelper;

    private static final int DURATION = 10_000;

    @BeforeClass
    public static void setUpClass() throws Exception {
        Context context = InstrumentationRegistry.getInstrumentation().getContext();
        // skip the test if WiFi is not supported
        if (!WifiFeature.isWifiSupported(context)) return;

        WifiManager wifiManager = context.getSystemService(WifiManager.class);
        assertThat(wifiManager).isNotNull();

        // turn on verbose logging for tests
        sWasVerboseLoggingEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.isVerboseLoggingEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setVerboseLoggingEnabled(true));
        // Disable scan throttling for tests.
        sWasScanThrottleEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.isScanThrottleEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setScanThrottleEnabled(false));

        // enable Wifi
        if (!wifiManager.isWifiEnabled()) {
            ShellIdentityUtils.invokeWithShellPermissions(() -> wifiManager.setWifiEnabled(true));
        }
        PollingCheck.check(""Wifi not enabled"", DURATION, () -> wifiManager.isWifiEnabled());

        // check we have >= 1 saved network
        List<WifiConfiguration> savedNetworks = ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.getPrivilegedConfiguredNetworks());
        assertWithMessage(""Need at least one saved network"")
                .that(savedNetworks.isEmpty()).isFalse();

        // Pick any network in range.
        sTestNetwork = TestHelper.findMatchingSavedNetworksWithBssid(wifiManager, savedNetworks)
                .get(0);
    }

    private static void enableAllSavedNetworks(@NonNull WifiManager wifiManager) {
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> {
                    for (WifiConfiguration savedNetwork : wifiManager.getConfiguredNetworks()) {
                        wifiManager.enableNetwork(savedNetwork.networkId, false);
                    }
                });
    }

    private static void disableAllSavedNetworks(@NonNull WifiManager wifiManager) {
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> {
                    for (WifiConfiguration savedNetwork : wifiManager.getConfiguredNetworks()) {
                        wifiManager.disableNetwork(savedNetwork.networkId);
                    }
                });
    }

    @AfterClass
    public static void tearDownClass() throws Exception {
        Context context = InstrumentationRegistry.getInstrumentation().getContext();
        if (!WifiFeature.isWifiSupported(context)) return;

        WifiManager wifiManager = context.getSystemService(WifiManager.class);
        assertThat(wifiManager).isNotNull();

        if (!wifiManager.isWifiEnabled()) {
            ShellIdentityUtils.invokeWithShellPermissions(() -> wifiManager.setWifiEnabled(true));
        }

        // Re-enable networks.
        enableAllSavedNetworks(wifiManager);

        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setScanThrottleEnabled(sWasScanThrottleEnabled));
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setVerboseLoggingEnabled(sWasVerboseLoggingEnabled));
    }

    @Before
    public void setUp() throws Exception {
        mContext = InstrumentationRegistry.getInstrumentation().getContext();
        mWifiManager = (WifiManager) mContext.getSystemService(Context.WIFI_SERVICE);
        mConnectivityManager = mContext.getSystemService(ConnectivityManager.class);
        mUiDevice = UiDevice.getInstance(InstrumentationRegistry.getInstrumentation());
        mTestHelper = new TestHelper(mContext, mUiDevice);

        assumeTrue(WifiFeature.isWifiSupported(mContext));

        // turn screen on
        mTestHelper.turnScreenOn();

        // Clear any existing app state before each test.
        if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(mContext)) {
            ShellIdentityUtils.invokeWithShellPermissions(
                    () -> mWifiManager.removeAppState(myUid(), mContext.getPackageName()));
        }

        // Disconnect & disable auto-join on the saved network to prevent auto-connect from
        // interfering with the test.
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.allowAutojoinGlobal(false));
        disableAllSavedNetworks(mWifiManager);
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.allowAutojoinGlobal(true));

        // Wait for Wifi to be disconnected.
        PollingCheck.check(
                ""Wifi not disconnected"",
                20000,
                () -> mWifiManager.getConnectionInfo().getNetworkId() == -1);
    }

    @After
    public void tearDown() throws Exception {
        // If there is failure, ensure we unregister the previous request.
        if (mNrNetworkCallback != null) {
            mConnectivityManager.unregisterNetworkCallback(mNrNetworkCallback);
        }
        // Clear any existing app state after each test.
        if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(mContext)) {
            ShellIdentityUtils.invokeWithShellPermissions(
                    () -> mWifiManager.removeAppState(myUid(), mContext.getPackageName()));
        }
        mTestHelper.turnScreenOff();
    }

    private void testSuccessfulConnectionWithSpecifier(WifiNetworkSpecifier specifier)
            throws Exception {
        mNrNetworkCallback = mTestHelper.testConnectionFlowWithSpecifier(
                sTestNetwork, specifier, false);
    }

    private void testUserRejectionWithSpecifier(WifiNetworkSpecifier specifier)
            throws Exception {
        mNrNetworkCallback = mTestHelper.testConnectionFlowWithSpecifier(
                sTestNetwork, specifier, true);
    }

    /**
     * Tests the entire connection flow using a specific SSID in the specifier.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSpecifierTest"	"testConnectionWithSpecificSsid"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSpecifierTest.java"	""	"public void testConnectionWithSpecificSsid() throws Exception {
        WifiNetworkSpecifier specifier =
                TestHelper.createSpecifierBuilderWithCredentialFromSavedNetwork(
                        sTestNetwork)
                .build();
        testSuccessfulConnectionWithSpecifier(specifier);
    }

    /**
     * Tests the entire connection flow using a SSID pattern in the specifier.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSpecifierTest"	"testConnectionWithSsidPattern"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSpecifierTest.java"	""	"public void testConnectionWithSsidPattern() throws Exception {
        // Creates a ssid pattern by dropping the last char in the saved network & pass that
        // as a prefix match pattern in the request.
        String ssidUnquoted = WifiInfo.sanitizeSsid(sTestNetwork.SSID);
        assertThat(ssidUnquoted.length()).isAtLeast(2);
        String ssidPrefix = ssidUnquoted.substring(0, ssidUnquoted.length() - 1);
        // Note: The match may return more than 1 network in this case since we use a prefix match,
        // But, we will still ensure that the UI interactions in the test still selects the
        // saved network for connection.
        WifiNetworkSpecifier specifier =
                TestHelper.createSpecifierBuilderWithCredentialFromSavedNetwork(sTestNetwork)
                .setSsidPattern(new PatternMatcher(ssidPrefix, PatternMatcher.PATTERN_PREFIX))
                .build();
        testSuccessfulConnectionWithSpecifier(specifier);
    }

    /**
     * Tests the entire connection flow using a specific BSSID in the specifier.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSpecifierTest"	"testConnectionWithSpecificBssid"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSpecifierTest.java"	""	"public void testConnectionWithSpecificBssid() throws Exception {
        WifiNetworkSpecifier specifier =
                TestHelper.createSpecifierBuilderWithCredentialFromSavedNetworkWithBssid(
                        sTestNetwork)
                        .build();
        testSuccessfulConnectionWithSpecifier(specifier);
    }

    /**
     * Tests the entire connection flow using a BSSID pattern in the specifier.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSpecifierTest"	"testConnectionWithBssidPattern"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSpecifierTest.java"	""	"public void testConnectionWithBssidPattern() throws Exception {
        // Note: The match may return more than 1 network in this case since we use a prefix match,
        // But, we will still ensure that the UI interactions in the test still selects the
        // saved network for connection.
        WifiNetworkSpecifier specifier =
                TestHelper.createSpecifierBuilderWithCredentialFromSavedNetworkWithBssid(
                        sTestNetwork)
                        .setBssidPattern(MacAddress.fromString(sTestNetwork.BSSID),
                                MacAddress.fromString(""ff:ff:ff:00:00:00""))
                        .build();
        testSuccessfulConnectionWithSpecifier(specifier);
    }

    /**
     * Tests the entire connection flow using a BSSID pattern in the specifier.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSpecifierTest"	"testUserRejectionWithSpecificSsid"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSpecifierTest.java"	""	"public void testUserRejectionWithSpecificSsid() throws Exception {
        WifiNetworkSpecifier specifier =
                TestHelper.createSpecifierBuilderWithCredentialFromSavedNetwork(
                        sTestNetwork)
                        .build();
        testUserRejectionWithSpecifier(specifier);
    }

    /**
     * Tests using the specifier to set a band.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSpecifierTest"	"testWifiBandInNetworkCallback"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSpecifierTest.java"	""	"public void testWifiBandInNetworkCallback() throws Exception {
        // Enable all networks and wait for Internet connectivity to be restored.
        // The callbacks in this test will match the existing network as soon as they are filed.
        enableAllSavedNetworks(mWifiManager);
        mTestHelper.assertWifiInternetConnectionAvailable();

        final LinkedBlockingQueue<Pair<Integer, Integer>> results = new LinkedBlockingQueue<>();
        final int[] bands = { ScanResult.WIFI_BAND_24_GHZ, ScanResult.WIFI_BAND_5_GHZ,
                ScanResult.WIFI_BAND_6_GHZ, ScanResult.WIFI_BAND_60_GHZ };
        final ArrayList<NetworkCallback> registeredCallbacks = new ArrayList<>();
        for (final int band : bands) {
            final NetworkCallback callback = new NetworkCallback() {
                @Override public void onCapabilitiesChanged(final Network net,
                        final NetworkCapabilities caps) {
                    results.offer(new Pair(band, TestHelper.getBandFromFrequency(
                            ((WifiInfo) caps.getTransportInfo()).getFrequency())));
                }
            };

            final WifiNetworkSpecifier specifier =
                    new WifiNetworkSpecifier.Builder().setBand(band).build();
            assertThat(specifier.getBand()).isEqualTo(band);

            final NetworkRequest request = new NetworkRequest.Builder()
                .addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
                .addTransportType(NetworkCapabilities.TRANSPORT_WIFI)
                .setNetworkSpecifier(specifier)
                .build();
            mConnectivityManager.registerNetworkCallback(request, callback);
            registeredCallbacks.add(callback);
        }

        try {
            // There should be at least one network callback about availability of the wifi network
            // on the right band. If the device is currently connected to multiple WiFi networks,
            // there will be several. Wait for a relatively long time for any callback, but only
            // a short time for subsequent ones (as the last timeout will be incurred always).
            Pair<Integer, Integer> result = results.poll(10, TimeUnit.SECONDS);
            assertThat(result).isNotNull();
            while (null != result) {
                assertThat(result.first).isEqualTo(result.second);
                result = results.poll(200, TimeUnit.MILLISECONDS);
            }
        } finally {
            for (final NetworkCallback cb : registeredCallbacks) {
                mConnectivityManager.unregisterNetworkCallback(cb);
            }
        }
    }

    /**
     * Tests the entire connection flow using a specific SSID in the specifier and ensure that the
     * device auto connects back to some saved network or suggestions in range of the device (that
     * can provide internet connectivity) when the request is released.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSpecifierTest"	"testEnsureAutoConnectToInternetConnectionOnRelease"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSpecifierTest.java"	""	"public void testEnsureAutoConnectToInternetConnectionOnRelease() throws Exception {
        WifiNetworkSpecifier specifier =
                TestHelper.createSpecifierBuilderWithCredentialFromSavedNetwork(
                        sTestNetwork)
                        .build();
        testSuccessfulConnectionWithSpecifier(specifier);

        // Now release the network request.
        mConnectivityManager.unregisterNetworkCallback(mNrNetworkCallback);
        mNrNetworkCallback = null;

        // Enable all saved networks on the device
        enableAllSavedNetworks(mWifiManager);
        try {
            // Wait for the device to auto-connect back to some saved or suggested network (which
            // can provide internet connectivity.
            // Note: On devices with concurrency support, this may return true immediately (since
            // the internet connection may be present concurrently).
            mTestHelper.assertWifiInternetConnectionAvailable();
        } finally {
            // need to always disable saved networks again since the other tests in this class
            // assume it
            disableAllSavedNetworks(mWifiManager);
        }
    }

    /**
     * Tests the builder for WPA2 enterprise networks.
     * Note: Can't do end to end tests for such networks in CTS environment.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSpecifierTest"	"testBuilderForWpa2Enterprise"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSpecifierTest.java"	""	"public void testBuilderForWpa2Enterprise() {
        WifiNetworkSpecifier specifier1 = new WifiNetworkSpecifier.Builder()
                .setSsid(WifiInfo.sanitizeSsid(sTestNetwork.SSID))
                .setWpa2EnterpriseConfig(new WifiEnterpriseConfig())
                .build();
        WifiNetworkSpecifier specifier2 = new WifiNetworkSpecifier.Builder()
                .setSsid(WifiInfo.sanitizeSsid(sTestNetwork.SSID))
                .setWpa2EnterpriseConfig(new WifiEnterpriseConfig())
                .build();
        assertThat(specifier1.canBeSatisfiedBy(specifier2)).isTrue();
    }

    /**
     * Tests the builder for WPA3 enterprise networks.
     * Note: Can't do end to end tests for such networks in CTS environment.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSpecifierTest"	"testBuilderForWpa3Enterprise"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSpecifierTest.java"	""	"public void testBuilderForWpa3Enterprise() {
        WifiNetworkSpecifier specifier1 = new WifiNetworkSpecifier.Builder()
                .setSsid(WifiInfo.sanitizeSsid(sTestNetwork.SSID))
                .setWpa3EnterpriseConfig(new WifiEnterpriseConfig())
                .build();
        WifiNetworkSpecifier specifier2 = new WifiNetworkSpecifier.Builder()
                .setSsid(WifiInfo.sanitizeSsid(sTestNetwork.SSID))
                .setWpa3EnterpriseConfig(new WifiEnterpriseConfig())
                .build();
        assertThat(specifier1.canBeSatisfiedBy(specifier2)).isTrue();
    }

    /**
     * Tests the builder for WPA3 enterprise networks.
     * Note: Can't do end to end tests for such networks in CTS environment.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSpecifierTest"	"testBuilderForWpa3EnterpriseWithStandardApi"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSpecifierTest.java"	""	"public void testBuilderForWpa3EnterpriseWithStandardApi() {
        if (!WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(mContext)) {
            // Skip the test if wifi module version is older than S.
            return;
        }
        WifiNetworkSpecifier specifier1 = new WifiNetworkSpecifier.Builder()
                .setSsid(WifiInfo.sanitizeSsid(sTestNetwork.SSID))
                .setWpa3EnterpriseStandardModeConfig(new WifiEnterpriseConfig())
                .build();
        WifiNetworkSpecifier specifier2 = new WifiNetworkSpecifier.Builder()
                .setSsid(WifiInfo.sanitizeSsid(sTestNetwork.SSID))
                .setWpa3EnterpriseConfig(new WifiEnterpriseConfig())
                .build();
        assertThat(specifier1.canBeSatisfiedBy(specifier2)).isTrue();
    }

    /**
     * Tests the builder for WPA3 enterprise networks.
     * Note: Can't do end to end tests for such networks in CTS environment.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSpecifierTest"	"testBuilderForWpa3Enterprise192bit"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSpecifierTest.java"	""	"public void testBuilderForWpa3Enterprise192bit() {
        if (!WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(mContext)) {
            // Skip the test if wifi module version is older than S.
            return;
        }
        WifiEnterpriseConfig enterpriseConfig = new WifiEnterpriseConfig();
        enterpriseConfig.setEapMethod(WifiEnterpriseConfig.Eap.TLS);
        enterpriseConfig.setCaCertificate(CA_SUITE_B_ECDSA_CERT);
        enterpriseConfig.setClientKeyEntryWithCertificateChain(CLIENT_SUITE_B_ECC_KEY,
                new X509Certificate[] {CLIENT_SUITE_B_ECDSA_CERT});
        enterpriseConfig.setAltSubjectMatch(""domain.com"");

        WifiNetworkSpecifier specifier1 = new WifiNetworkSpecifier.Builder()
                .setSsid(WifiInfo.sanitizeSsid(sTestNetwork.SSID))
                .setWpa3Enterprise192BitModeConfig(enterpriseConfig)
                .build();
        WifiNetworkSpecifier specifier2 = new WifiNetworkSpecifier.Builder()
                .setSsid(WifiInfo.sanitizeSsid(sTestNetwork.SSID))
                .setWpa3Enterprise192BitModeConfig(enterpriseConfig)
                .build();
        assertThat(specifier1.canBeSatisfiedBy(specifier2)).isTrue();
    }

    /**
     * Test WifiNetworkSpecifier redaction.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSpecifierTest"	"testRedact"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSpecifierTest.java"	""	"public void testRedact() {
        if (!WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(mContext)) {
            // Skip the test if wifi module version is older than S.
            return;
        }
        WifiNetworkSpecifier specifier = TestHelper
                .createSpecifierBuilderWithCredentialFromSavedNetworkWithBssid(sTestNetwork)
                .setBssidPattern(MacAddress.fromString(sTestNetwork.BSSID),
                        MacAddress.fromString(""ff:ff:ff:00:00:00""))
                .setBand(ScanResult.WIFI_BAND_5_GHZ)
                .build();

        final NetworkSpecifier redacted = specifier.redact();
        if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
            assertThat(new WifiNetworkSpecifier.Builder().setBand(ScanResult.WIFI_BAND_5_GHZ)
                    .build().equals(redacted)).isTrue();
        } else {
            assertThat(redacted.equals(specifier)).isTrue();
        }
    }
}"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiEnterpriseConfigTest"	"testSettersAndGetters"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiEnterpriseConfigTest.java"	""	"public void testSettersAndGetters() throws Exception {
        if (!hasWifi()) {
            return;
        }

        WifiEnterpriseConfig config = new WifiEnterpriseConfig();
        assertTrue(config.getEapMethod() == Eap.NONE);
        config.setEapMethod(Eap.PEAP);
        assertTrue(config.getEapMethod() == Eap.PEAP);
        config.setEapMethod(Eap.PWD);
        assertTrue(config.getEapMethod() == Eap.PWD);
        config.setEapMethod(Eap.TLS);
        assertTrue(config.getEapMethod() == Eap.TLS);
        config.setEapMethod(Eap.TTLS);
        assertTrue(config.getEapMethod() == Eap.TTLS);
        assertTrue(config.getPhase2Method() == Phase2.NONE);
        config.setPhase2Method(Phase2.PAP);
        assertTrue(config.getPhase2Method() == Phase2.PAP);
        config.setPhase2Method(Phase2.MSCHAP);
        assertTrue(config.getPhase2Method() == Phase2.MSCHAP);
        config.setPhase2Method(Phase2.MSCHAPV2);
        assertTrue(config.getPhase2Method() == Phase2.MSCHAPV2);
        config.setPhase2Method(Phase2.GTC);
        assertTrue(config.getPhase2Method() == Phase2.GTC);
        config.setIdentity(IDENTITY);
        assertTrue(config.getIdentity().equals(IDENTITY));
        config.setAnonymousIdentity(ANON_IDENTITY);
        assertTrue(config.getAnonymousIdentity().equals(ANON_IDENTITY));
        config.setPassword(PASSWORD);
        assertTrue(config.getPassword().equals(PASSWORD));
        CertificateFactory factory = CertificateFactory.getInstance(""X.509"");
        X509Certificate cert1 = (X509Certificate) factory.generateCertificate(
                new ByteArrayInputStream(FAKE_EC_1));
        X509Certificate cert2 = (X509Certificate) factory.generateCertificate(
                new ByteArrayInputStream(FAKE_EC_2));
        config.setCaCertificate(cert1);
        assertTrue(config.getCaCertificate().getSerialNumber().equals(cert1.getSerialNumber()));
        config.setCaCertificates(new X509Certificate[]{cert1, cert2});
        X509Certificate[] certs = config.getCaCertificates();
        assertTrue(cert1.getSerialNumber().equals(certs[0].getSerialNumber()));
        assertTrue(cert2.getSerialNumber().equals(certs[1].getSerialNumber()));

        X509Certificate clientCert = (X509Certificate) factory.generateCertificate(
                new ByteArrayInputStream(FAKE_EC_3));
        KeyFactory kf = KeyFactory.getInstance(""RSA"");
        PrivateKey clientKey = kf.generatePrivate(new PKCS8EncodedKeySpec(FAKE_KEY_3));

        config.setClientKeyEntry(clientKey, clientCert);
        X509Certificate testClientCert = config.getClientCertificate();
        X509Certificate[] testClientCertChain = config.getClientCertificateChain();
        assertTrue(clientCert.getSerialNumber().equals(testClientCert.getSerialNumber()));
        assertTrue(testClientCertChain.length == 1);
        assertTrue(testClientCertChain[0] == testClientCert);

        config.setClientKeyEntry(null, null);
        assertTrue(config.getClientCertificate() == null);
        assertTrue(config.getClientCertificateChain() == null);

        config.setClientKeyEntryWithCertificateChain(clientKey,
                new X509Certificate[]{clientCert, cert1});
        testClientCert = config.getClientCertificate();
        testClientCertChain = config.getClientCertificateChain();
        assertTrue(clientCert.getSerialNumber().equals(testClientCert.getSerialNumber()));
        assertTrue(testClientCertChain.length == 2);
        assertTrue(testClientCertChain[0] == testClientCert);
        assertTrue(testClientCertChain[1] == cert1);
        assertSame(clientKey, config.getClientPrivateKey());

        config.setSubjectMatch(SUBJECT_MATCH);
        assertTrue(config.getSubjectMatch().equals(SUBJECT_MATCH));
        // Hotspot 2.0 related attributes
        config.setPlmn(PLMN);
        assertTrue(config.getPlmn().equals(PLMN));
        config.setRealm(REALM);
        assertTrue(config.getRealm().equals(REALM));
        config.setAltSubjectMatch(ALT_SUBJECT_MATCH);
        assertTrue(config.getAltSubjectMatch().equals(ALT_SUBJECT_MATCH));
        config.setDomainSuffixMatch(DOM_SUBJECT_MATCH);
        assertTrue(config.getDomainSuffixMatch().equals(DOM_SUBJECT_MATCH));
    }"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiEnterpriseConfigTest"	"testEnterpriseConfigDoesNotPrintPassword"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiEnterpriseConfigTest.java"	""	"public void testEnterpriseConfigDoesNotPrintPassword() {
        if(!hasWifi()) {
            return;
        }
        WifiEnterpriseConfig enterpriseConfig = new WifiEnterpriseConfig();
        final String identity = ""IdentityIsOkayToBeDisplayedHere"";
        final String password = ""PasswordIsNotOkayToBeDisplayedHere"";
        enterpriseConfig.setIdentity(identity);
        enterpriseConfig.setPassword(password);
        final String stringRepresentation = enterpriseConfig.toString();
        assertTrue(stringRepresentation.contains(identity));
        assertFalse(stringRepresentation.contains(password));
    }"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiEnterpriseConfigTest"	"testGetSetCaCertificateAliases"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiEnterpriseConfigTest.java"	""	"public void testGetSetCaCertificateAliases() {
        if (!hasWifi()) {
            return;
        }
        WifiEnterpriseConfig config = new WifiEnterpriseConfig();

        config.setCaCertificateAliases(null);
        assertThat(config.getCaCertificateAliases()).isNull();

        config.setCaCertificateAliases(new String[]{CERTIFICATE_ALIAS1});
        assertThat(config.getCaCertificateAliases()).isEqualTo(new String[]{CERTIFICATE_ALIAS1});

        config.setCaCertificateAliases(new String[]{CERTIFICATE_ALIAS1, CERTIFICATE_ALIAS2});
        assertThat(config.getCaCertificateAliases())
                .isEqualTo(new String[]{CERTIFICATE_ALIAS1, CERTIFICATE_ALIAS2});
    }"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiEnterpriseConfigTest"	"testGetSetCaPath"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiEnterpriseConfigTest.java"	""	"public void testGetSetCaPath() {
        if (!hasWifi()) {
            return;
        }
        WifiEnterpriseConfig config = new WifiEnterpriseConfig();

        config.setCaPath("""");
        assertThat(config.getCaPath()).isEmpty();

        config.setCaPath(CA_PATH);
        assertThat(config.getCaPath()).isEqualTo(CA_PATH);
    }"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiEnterpriseConfigTest"	"testGetSetClientCertificateAlias"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiEnterpriseConfigTest.java"	""	"public void testGetSetClientCertificateAlias() {
        if (!hasWifi()) {
            return;
        }
        WifiEnterpriseConfig config = new WifiEnterpriseConfig();

        config.setClientCertificateAlias("""");
        assertThat(config.getClientCertificateAlias()).isEmpty();

        config.setClientCertificateAlias(CLIENT_CERTIFICATE_ALIAS);
        assertThat(config.getClientCertificateAlias()).isEqualTo(CLIENT_CERTIFICATE_ALIAS);
    }

    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiEnterpriseConfigTest"	"testGetSetClientKeyPairAlias"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiEnterpriseConfigTest.java"	""	"public void testGetSetClientKeyPairAlias() {
        if (!hasWifi()) {
            return;
        }
        WifiEnterpriseConfig config = new WifiEnterpriseConfig();

        config.setClientKeyPairAlias("""");
        assertThat(config.getClientKeyPairAlias()).isEmpty();

        config.setClientKeyPairAlias(CLIENT_CERTIFICATE_ALIAS);
        assertThat(config.getClientKeyPairAlias()).isEqualTo(CLIENT_CERTIFICATE_ALIAS);
    }"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiEnterpriseConfigTest"	"testGetSetOcsp"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiEnterpriseConfigTest.java"	""	"public void testGetSetOcsp() {
        if (!hasWifi()) {
            return;
        }
        WifiEnterpriseConfig config = new WifiEnterpriseConfig();

        config.setOcsp(WifiEnterpriseConfig.OCSP_NONE);
        assertThat(config.getOcsp()).isEqualTo(WifiEnterpriseConfig.OCSP_NONE);

        config.setOcsp(WifiEnterpriseConfig.OCSP_REQUIRE_ALL_NON_TRUSTED_CERTS_STATUS);
        assertThat(config.getOcsp())
                .isEqualTo(WifiEnterpriseConfig.OCSP_REQUIRE_ALL_NON_TRUSTED_CERTS_STATUS);

        try {
            config.setOcsp(-1);
            fail(""WifiEnterpriseConfig.setOcsp(-1) did not throw an IllegalArgumentException!"");
        } catch (IllegalArgumentException expected) {}
    }"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiEnterpriseConfigTest"	"testGetSetWapiCertSuite"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiEnterpriseConfigTest.java"	""	"public void testGetSetWapiCertSuite() {
        if (!hasWifi()) {
            return;
        }
        WifiEnterpriseConfig config = new WifiEnterpriseConfig();

        config.setWapiCertSuite("""");
        assertThat(config.getWapiCertSuite()).isEmpty();

        config.setWapiCertSuite(WAPI_CERT_SUITE);
        assertThat(config.getWapiCertSuite()).isEqualTo(WAPI_CERT_SUITE);
    }"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiEnterpriseConfigTest"	"testIsAuthenticationSimBased"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiEnterpriseConfigTest.java"	""	"public void testIsAuthenticationSimBased() {
        if (!hasWifi()) {
            return;
        }
        WifiEnterpriseConfig config = new WifiEnterpriseConfig();

        config.setEapMethod(Eap.AKA);
        assertThat(config.isAuthenticationSimBased()).isTrue();

        config.setEapMethod(Eap.PWD);
        assertThat(config.isAuthenticationSimBased()).isFalse();

        config.setEapMethod(Eap.PEAP);
        config.setPhase2Method(Phase2.SIM);
        assertThat(config.isAuthenticationSimBased()).isTrue();

        config.setEapMethod(Eap.PEAP);
        config.setPhase2Method(Phase2.NONE);
        assertThat(config.isAuthenticationSimBased()).isFalse();
    }"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiEnterpriseConfigTest"	"testCopyConstructor"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiEnterpriseConfigTest.java"	""	"public void testCopyConstructor() {
        if (!hasWifi()) {
            return;
        }
        WifiEnterpriseConfig config = new WifiEnterpriseConfig();
        config.setEapMethod(Eap.WAPI_CERT);
        config.setWapiCertSuite(WAPI_CERT_SUITE);
        config.setOcsp(WifiEnterpriseConfig.OCSP_REQUIRE_ALL_NON_TRUSTED_CERTS_STATUS);
        config.setCaPath(CA_PATH);
        config.setPassword(PASSWORD);
        config.setRealm(REALM);

        WifiEnterpriseConfig copy = new WifiEnterpriseConfig(config);
        assertThat(copy.getEapMethod()).isEqualTo(Eap.WAPI_CERT);
        assertThat(copy.getWapiCertSuite()).isEqualTo(WAPI_CERT_SUITE);
        assertThat(copy.getOcsp())
                .isEqualTo(WifiEnterpriseConfig.OCSP_REQUIRE_ALL_NON_TRUSTED_CERTS_STATUS);
        assertThat(copy.getCaPath()).isEqualTo(CA_PATH);
        assertThat(copy.getPassword()).isEqualTo(PASSWORD);
        assertThat(copy.getRealm()).isEqualTo(REALM);
    }"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiEnterpriseConfigTest"	"testIsEnterpriseConfigServerCertNotEnabled"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiEnterpriseConfigTest.java"	""	"public void testIsEnterpriseConfigServerCertNotEnabled() {
        if (!hasWifi() || !WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(getContext())) {
            return;
        }
        WifiEnterpriseConfig baseConfig = new WifiEnterpriseConfig();
        baseConfig.setEapMethod(Eap.PEAP);
        baseConfig.setPhase2Method(Phase2.MSCHAPV2);
        assertTrue(baseConfig.isEapMethodServerCertUsed());
        assertFalse(baseConfig.isServerCertValidationEnabled());

        WifiEnterpriseConfig noMatchConfig = new WifiEnterpriseConfig(baseConfig);
        noMatchConfig.setCaCertificate(FakeKeys.CA_CERT0);
        // Missing match disables validation.
        assertTrue(baseConfig.isEapMethodServerCertUsed());
        assertFalse(baseConfig.isServerCertValidationEnabled());

        WifiEnterpriseConfig noCaConfig = new WifiEnterpriseConfig(baseConfig);
        noCaConfig.setDomainSuffixMatch(DOM_SUBJECT_MATCH);
        // Missing CA certificate disables validation.
        assertTrue(baseConfig.isEapMethodServerCertUsed());
        assertFalse(baseConfig.isServerCertValidationEnabled());

        WifiEnterpriseConfig noValidationConfig = new WifiEnterpriseConfig();
        noValidationConfig.setEapMethod(Eap.AKA);
        assertFalse(noValidationConfig.isEapMethodServerCertUsed());
    }"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiEnterpriseConfigTest"	"testIsEnterpriseConfigServerCertEnabledWithPeap"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiEnterpriseConfigTest.java"	""	"public void testIsEnterpriseConfigServerCertEnabledWithPeap() {
        if (!hasWifi() || !WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(getContext())) {
            return;
        }
        testIsEnterpriseConfigServerCertEnabled(Eap.PEAP);
    }"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiEnterpriseConfigTest"	"testIsEnterpriseConfigServerCertEnabledWithTls"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiEnterpriseConfigTest.java"	""	"public void testIsEnterpriseConfigServerCertEnabledWithTls() {
        if (!hasWifi() || !WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(getContext())) {
            return;
        }
        testIsEnterpriseConfigServerCertEnabled(Eap.TLS);
    }"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiEnterpriseConfigTest"	"testIsEnterpriseConfigServerCertEnabledWithTTLS"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiEnterpriseConfigTest.java"	""	"public void testIsEnterpriseConfigServerCertEnabledWithTTLS() {
        if (!hasWifi() || !WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(getContext())) {
            return;
        }
        testIsEnterpriseConfigServerCertEnabled(Eap.TTLS);
    }

    private void testIsEnterpriseConfigServerCertEnabled(int eapMethod) {
        WifiEnterpriseConfig configWithCertAndDomainSuffixMatch = createEnterpriseConfig(eapMethod,
                Phase2.NONE, FakeKeys.CA_CERT0, null, DOM_SUBJECT_MATCH, null);
        assertTrue(configWithCertAndDomainSuffixMatch.isEapMethodServerCertUsed());
        assertTrue(configWithCertAndDomainSuffixMatch.isServerCertValidationEnabled());

        WifiEnterpriseConfig configWithCertAndAltSubjectMatch = createEnterpriseConfig(eapMethod,
                Phase2.NONE, FakeKeys.CA_CERT0, null, null, ALT_SUBJECT_MATCH);
        assertTrue(configWithCertAndAltSubjectMatch.isEapMethodServerCertUsed());
        assertTrue(configWithCertAndAltSubjectMatch.isServerCertValidationEnabled());

        WifiEnterpriseConfig configWithAliasAndDomainSuffixMatch = createEnterpriseConfig(eapMethod,
                Phase2.NONE, null, new String[]{""alias1"", ""alisa2""}, DOM_SUBJECT_MATCH,
                null);
        assertTrue(configWithAliasAndDomainSuffixMatch.isEapMethodServerCertUsed());
        assertTrue(configWithAliasAndDomainSuffixMatch.isServerCertValidationEnabled());

        WifiEnterpriseConfig configWithAliasAndAltSubjectMatch = createEnterpriseConfig(eapMethod,
                Phase2.NONE, null, new String[]{""alias1"", ""alisa2""}, null, ALT_SUBJECT_MATCH);
        assertTrue(configWithAliasAndAltSubjectMatch.isEapMethodServerCertUsed());
        assertTrue(configWithAliasAndAltSubjectMatch.isServerCertValidationEnabled());
    }

    private WifiEnterpriseConfig createEnterpriseConfig(int eapMethod, int phase2Method,
            X509Certificate caCertificate, String[] aliases, String domainSuffixMatch,
            String altSubjectMatch) {
        WifiEnterpriseConfig config = new WifiEnterpriseConfig();
        config.setEapMethod(eapMethod);
        config.setPhase2Method(phase2Method);
        config.setCaCertificate(caCertificate);
        config.setCaCertificateAliases(aliases);
        config.setDomainSuffixMatch(domainSuffixMatch);
        config.setAltSubjectMatch(altSubjectMatch);
        return config;
    }

    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiEnterpriseConfigTest"	"testSetGetDecoratedIdentityPrefix"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiEnterpriseConfigTest.java"	""	"public void testSetGetDecoratedIdentityPrefix() {
        if (!hasWifi()) {
            return;
        }
        WifiEnterpriseConfig config = new WifiEnterpriseConfig();

        assertNull(config.getDecoratedIdentityPrefix());
        config.setDecoratedIdentityPrefix(TEST_DECORATED_IDENTITY_PREFIX);
        assertEquals(TEST_DECORATED_IDENTITY_PREFIX, config.getDecoratedIdentityPrefix());
    }
}"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.rtt.cts.WifiRttTest"	"testRangingToTest11mcAp"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/rtt/cts/WifiRttTest.java"	""	"public void testRangingToTest11mcAp() throws InterruptedException {
        if (!shouldTestWifiRtt(getContext())) {
            return;
        }

        // Scan for IEEE 802.11mc supporting APs
        ScanResult testAp = scanForTest11mcCapableAp(NUM_SCANS_SEARCHING_FOR_IEEE80211MC_AP);
        assertNotNull(
                ""Cannot find any test APs which support RTT / IEEE 802.11mc - please verify that ""
                        + ""your test setup includes them!"", testAp);

        // Perform RTT operations
        RangingRequest.Builder builder = new RangingRequest.Builder();
        builder.addAccessPoint(testAp);
        if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(getContext())) {
            builder.setRttBurstSize(RangingRequest.getMaxRttBurstSize());
            assertTrue(RangingRequest.getDefaultRttBurstSize()
                    >= RangingRequest.getMinRttBurstSize());
            assertTrue(RangingRequest.getDefaultRttBurstSize()
                    <= RangingRequest.getMaxRttBurstSize());
        }
        RangingRequest request = builder.build();
        if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(getContext())) {
            assertEquals(1, request.getRttResponders().size());
        }

        List<RangingResult> allResults = new ArrayList<>();
        int numFailures = 0;
        int distanceSum = 0;
        int distanceMin = 0;
        int distanceMax = 0;
        int[] statuses = new int[NUM_OF_RTT_ITERATIONS];
        int[] distanceMms = new int[NUM_OF_RTT_ITERATIONS];
        int[] distanceStdDevMms = new int[NUM_OF_RTT_ITERATIONS];
        int[] rssis = new int[NUM_OF_RTT_ITERATIONS];
        int[] numAttempted = new int[NUM_OF_RTT_ITERATIONS];
        int[] numSuccessful = new int[NUM_OF_RTT_ITERATIONS];
        long[] timestampsMs = new long[NUM_OF_RTT_ITERATIONS];
        byte[] lastLci = null;
        byte[] lastLcr = null;
        for (int i = 0; i < NUM_OF_RTT_ITERATIONS; ++i) {
            ResultCallback callback = new ResultCallback();
            mWifiRttManager.startRanging(request, mExecutor, callback);
            assertTrue(""Wi-Fi RTT results: no callback on iteration "" + i,
                    callback.waitForCallback());

            List<RangingResult> currentResults = callback.getResults();
            assertNotNull(""Wi-Fi RTT results: null results (onRangingFailure) on iteration "" + i,
                    currentResults);
            assertEquals(""Wi-Fi RTT results: unexpected # of results (expect 1) on iteration "" + i,
                    1, currentResults.size());
            RangingResult result = currentResults.get(0);
            assertEquals(""Wi-Fi RTT results: invalid result (wrong BSSID) entry on iteration "" + i,
                    result.getMacAddress().toString(), testAp.BSSID);
            assertNull(""Wi-Fi RTT results: invalid result (non-null PeerHandle) entry on iteration ""
                    + i, result.getPeerHandle());

            allResults.add(result);
            int status = result.getStatus();
            statuses[i] = status;
            if (status == RangingResult.STATUS_SUCCESS) {
                if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(getContext())) {
                    assertEquals(
                            ""Wi-Fi RTT results: invalid result (wrong rttBurstSize) entry on ""
                                    + ""iteration ""
                                    + i,
                            result.getNumAttemptedMeasurements(),
                            RangingRequest.getMaxRttBurstSize());
                    assertTrue(""Wi-Fi RTT results: should be a 802.11MC measurement"",
                            result.is80211mcMeasurement());
                }
                distanceSum += result.getDistanceMm();
                if (i == 0) {
                    distanceMin = result.getDistanceMm();
                    distanceMax = result.getDistanceMm();
                } else {
                    distanceMin = Math.min(distanceMin, result.getDistanceMm());
                    distanceMax = Math.max(distanceMax, result.getDistanceMm());
                }

                assertTrue(""Wi-Fi RTT results: invalid RSSI on iteration "" + i,
                        result.getRssi() >= MIN_VALID_RSSI);

                distanceMms[i - numFailures] = result.getDistanceMm();
                distanceStdDevMms[i - numFailures] = result.getDistanceStdDevMm();
                rssis[i - numFailures] = result.getRssi();
                numAttempted[i - numFailures] = result.getNumAttemptedMeasurements();
                numSuccessful[i - numFailures] = result.getNumSuccessfulMeasurements();
                timestampsMs[i - numFailures] = result.getRangingTimestampMillis();

                byte[] currentLci = result.getLci();
                byte[] currentLcr = result.getLcr();
                if (i - numFailures > 0) {
                    assertTrue(""Wi-Fi RTT results: invalid result (LCI mismatch) on iteration "" + i,
                            Arrays.equals(currentLci, lastLci));
                    assertTrue(""Wi-Fi RTT results: invalid result (LCR mismatch) on iteration "" + i,
                            Arrays.equals(currentLcr, lastLcr));
                }
                lastLci = currentLci;
                lastLcr = currentLcr;
            } else {
                numFailures++;
            }
            // Sleep a while to avoid stress AP.
            Thread.sleep(intervalMs);
        }

        // Save results to log
        int numGoodResults = NUM_OF_RTT_ITERATIONS - numFailures;
        DeviceReportLog reportLog = new DeviceReportLog(TAG, ""testRangingToTestAp"");
        reportLog.addValues(""status_codes"", statuses, ResultType.NEUTRAL, ResultUnit.NONE);
        reportLog.addValues(""distance_mm"", Arrays.copyOf(distanceMms, numGoodResults),
                ResultType.NEUTRAL, ResultUnit.NONE);
        reportLog.addValues(""distance_stddev_mm"", Arrays.copyOf(distanceStdDevMms, numGoodResults),
                ResultType.NEUTRAL, ResultUnit.NONE);
        reportLog.addValues(""rssi_dbm"", Arrays.copyOf(rssis, numGoodResults), ResultType.NEUTRAL,
                ResultUnit.NONE);
        reportLog.addValues(""num_attempted"", Arrays.copyOf(numAttempted, numGoodResults),
                ResultType.NEUTRAL, ResultUnit.NONE);
        reportLog.addValues(""num_successful"", Arrays.copyOf(numSuccessful, numGoodResults),
                ResultType.NEUTRAL, ResultUnit.NONE);
        reportLog.addValues(""timestamps"", Arrays.copyOf(timestampsMs, numGoodResults),
                ResultType.NEUTRAL, ResultUnit.NONE);
        reportLog.submit();

        // Analyze results
        assertTrue(""Wi-Fi RTT failure rate exceeds threshold: FAIL="" + numFailures + "", ITERATIONS=""
                        + NUM_OF_RTT_ITERATIONS + "", AP RSSI="" + testAp.level
                        + "", AP SSID="" + testAp.SSID,
                numFailures <= NUM_OF_RTT_ITERATIONS * MAX_FAILURE_RATE_PERCENT / 100);
        if (numFailures != NUM_OF_RTT_ITERATIONS) {
            double distanceAvg = (double) distanceSum / (NUM_OF_RTT_ITERATIONS - numFailures);
            assertTrue(""Wi-Fi RTT: Variation (max direction) exceeds threshold, Variation =""
                            + (distanceMax - distanceAvg),
                    (distanceMax - distanceAvg) <= MAX_VARIATION_FROM_AVERAGE_DISTANCE_MM);
            assertTrue(""Wi-Fi RTT: Variation (min direction) exceeds threshold, Variation =""
                            + (distanceAvg - distanceMin),
                    (distanceAvg - distanceMin) <= MAX_VARIATION_FROM_AVERAGE_DISTANCE_MM);
            for (int i = 0; i < numGoodResults; ++i) {
                assertNotSame(""Number of attempted measurements is 0"", 0, numAttempted[i]);
                assertNotSame(""Number of successful measurements is 0"", 0, numSuccessful[i]);
            }
        }
    }

    /**
     * Validate that when a request contains more range operations than allowed (by API) that we
     * get an exception.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.rtt.cts.WifiRttTest"	"testRequestTooLarge"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/rtt/cts/WifiRttTest.java"	""	"public void testRequestTooLarge() throws InterruptedException {
        if (!shouldTestWifiRtt(getContext())) {
            return;
        }
        ScanResult testAp = scanForTest11mcCapableAp(NUM_SCANS_SEARCHING_FOR_IEEE80211MC_AP);
        assertNotNull(
                ""Cannot find any test APs which support RTT / IEEE 802.11mc - please verify that ""
                        + ""your test setup includes them!"", testAp);

        RangingRequest.Builder builder = new RangingRequest.Builder();
        List<ScanResult> scanResults = new ArrayList<>();
        for (int i = 0; i < RangingRequest.getMaxPeers() - 2; ++i) {
            scanResults.add(testAp);
        }
        builder.addAccessPoints(scanResults);

        ScanResult testApNon80211mc = null;
        if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(getContext())) {
            testApNon80211mc = scanForTestNon11mcCapableAp(NUM_SCANS_SEARCHING_FOR_IEEE80211MC_AP);
        }
        if (testApNon80211mc == null) {
            builder.addAccessPoints(List.of(testAp, testAp, testAp));
        } else {
            builder.addNon80211mcCapableAccessPoints(List.of(testApNon80211mc, testApNon80211mc,
                    testApNon80211mc));
        }

        try {
            mWifiRttManager.startRanging(builder.build(), mExecutor, new ResultCallback());
        } catch (IllegalArgumentException e) {
            return;
        }

        fail(""Did not receive expected IllegalArgumentException when tried to range to too ""
                + ""many peers"");
    }

    /**
     * Verify ResponderLocation API
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.rtt.cts.WifiRttTest"	"testRangingToTestApWithResponderLocation"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/rtt/cts/WifiRttTest.java"	""	"public void testRangingToTestApWithResponderLocation() throws InterruptedException {
        if (!shouldTestWifiRtt(getContext())) {
            return;
        }
        // Scan for IEEE 802.11mc supporting APs
        ScanResult testAp = scanForTest11mcCapableAp(NUM_SCANS_SEARCHING_FOR_IEEE80211MC_AP);
        assertNotNull(
                ""Cannot find any test APs which support RTT / IEEE 802.11mc - please verify that ""
                        + ""your test setup includes them!"", testAp);

        // Perform RTT operations
        RangingRequest request = new RangingRequest.Builder().addAccessPoint(testAp).build();
        ResultCallback callback = new ResultCallback();
        mWifiRttManager.startRanging(request, mExecutor, callback);
        assertTrue(""Wi-Fi RTT results: no callback! "",
                callback.waitForCallback());

        RangingResult result = callback.getResults().get(0);
        assertEquals(""Ranging request not success"",
                result.getStatus(), RangingResult.STATUS_SUCCESS);
        ResponderLocation responderLocation = result.getUnverifiedResponderLocation();
        if (responderLocation == null) {
            return;
        }
        assertTrue(""ResponderLocation is not valid"", responderLocation.isLciSubelementValid());

        // Check LCI related APIs
        int exceptionCount = 0;
        int apiCount = 0;
        try {
            apiCount++;
            responderLocation.getLatitudeUncertainty();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }
        try {
            apiCount++;
            responderLocation.getLatitude();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }
        try {
            apiCount++;
            responderLocation.getLongitudeUncertainty();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }
        try {
            apiCount++;
            responderLocation.getLongitude();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }
        try {
            apiCount++;
            responderLocation.getAltitudeType();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }
        try {
            apiCount++;
            responderLocation.getAltitudeUncertainty();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }
        try {
            apiCount++;
            responderLocation.getAltitude();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }
        try {
            apiCount++;
            responderLocation.getDatum();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }
        try {
            apiCount++;
            responderLocation.getRegisteredLocationAgreementIndication();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }
        try {
            apiCount++;
            responderLocation.getLciVersion();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }
        try {
            apiCount++;
            assertNotNull(responderLocation.toLocation());
        } catch (IllegalStateException e) {
            exceptionCount++;
        }
        // If LCI is not valid, all APIs should throw exception, otherwise no exception.
        assertEquals(""Exception number should equal to API number"",
                responderLocation.isLciSubelementValid()? 0 : apiCount, exceptionCount);

        // Verify ZaxisSubelement APIs
        apiCount = 0;
        exceptionCount = 0;

        try {
            apiCount++;
            responderLocation.getExpectedToMove();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }

        try {
            apiCount++;
            responderLocation.getFloorNumber();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }

        try {
            apiCount++;
            responderLocation.getHeightAboveFloorMeters();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }

        try {
            apiCount++;
            responderLocation.getHeightAboveFloorUncertaintyMeters();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }
        // If Zaxis is not valid, all APIs should throw exception, otherwise no exception.
        assertEquals(""Exception number should equal to API number"",
                responderLocation.isZaxisSubelementValid() ? 0 : apiCount, exceptionCount);
        // Verify civic location
        if (responderLocation.toCivicLocationAddress() == null) {
            assertNull(responderLocation.toCivicLocationSparseArray());
        } else {
            assertNotNull(responderLocation.toCivicLocationSparseArray());
        }
        // Verify map image
        if (responderLocation.getMapImageUri() == null) {
            assertNull(responderLocation.getMapImageMimeType());
        } else {
            assertNotNull(responderLocation.getMapImageMimeType());
        }
        boolean extraInfoOnAssociationIndication =
                responderLocation.getExtraInfoOnAssociationIndication();
        assertNotNull(""ColocatedBSSID list should be nonNull"",
                responderLocation.getColocatedBssids());
    }

    /**
     * Verify ranging request with aware peer Mac address and peer handle.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.rtt.cts.WifiRttTest"	"testAwareRttWithMacAddress"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/rtt/cts/WifiRttTest.java"	""	"public void testAwareRttWithMacAddress() throws InterruptedException {
        if (!(shouldTestWifiRtt(getContext()) && shouldTestWifiAware(getContext()))) {
            return;
        }
        RangingRequest request = new RangingRequest.Builder()
                .addWifiAwarePeer(MAC).build();
        ResultCallback callback = new ResultCallback();
        mWifiRttManager.startRanging(request, mExecutor, callback);
        assertTrue(""Wi-Fi RTT results: no callback"",
                callback.waitForCallback());
        List<RangingResult> rangingResults = callback.getResults();
        assertNotNull(""Wi-Fi RTT results: null results"", rangingResults);
        assertEquals(1, rangingResults.size());
        assertEquals(RangingResult.STATUS_FAIL, rangingResults.get(0).getStatus());
    }

    /**
     * Verify ranging request with aware peer handle.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.rtt.cts.WifiRttTest"	"testAwareRttWithPeerHandle"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/rtt/cts/WifiRttTest.java"	""	"public void testAwareRttWithPeerHandle() throws InterruptedException {
        if (!(shouldTestWifiRtt(getContext()) && shouldTestWifiAware(getContext()))) {
            return;
        }
        PeerHandle peerHandle = mock(PeerHandle.class);
        RangingRequest request = new RangingRequest.Builder()
                .addWifiAwarePeer(peerHandle).build();
        ResultCallback callback = new ResultCallback();
        mWifiRttManager.startRanging(request, mExecutor, callback);
        assertTrue(""Wi-Fi RTT results: no callback"",
                callback.waitForCallback());
        List<RangingResult> rangingResults = callback.getResults();
        assertNotNull(""Wi-Fi RTT results: null results"", rangingResults);
        assertEquals(""Invalid peerHandle should return 0 result"", 0, rangingResults.size());
    }

    /**
     * Test Wi-Fi One-sided RTT ranging operation:
     * - Scan for visible APs for the test AP (which do not support IEEE 802.11mc) and are operating
     * - in the 5GHz band.
     * - Perform N (constant) RTT operations
     * - Remove outliers while insuring greater than 50% of the results still remain
     * - Validate:
     *   - Failure ratio < threshold (constant)
     *   - Result margin < threshold (constant)
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.rtt.cts.WifiRttTest"	"testRangingToTestNon11mcAp"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/rtt/cts/WifiRttTest.java"	""	"public void testRangingToTestNon11mcAp() throws InterruptedException {
        if (!shouldTestWifiRtt(getContext())
                || !WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(getContext())) {
            return;
        }

        // Scan for Non-IEEE 802.11mc supporting APs
        ScanResult testAp = scanForTestNon11mcCapableAp(NUM_SCANS_SEARCHING_FOR_IEEE80211MC_AP);
        assertNotNull(
                ""Cannot find any test APs which are Non-IEEE 802.11mc - please verify that""
                        + "" your test setup includes them!"", testAp);

        // Perform RTT operations
        RangingRequest.Builder builder = new RangingRequest.Builder();
        builder.addNon80211mcCapableAccessPoint(testAp);
        builder.setRttBurstSize(RangingRequest.getMaxRttBurstSize());
        RangingRequest request = builder.build();

        List<RangingResult> allResults = new ArrayList<>();
        int numFailures = 0;
        int distanceSum = 0;
        int distanceMin = 0;
        int distanceMax = 0;
        int[] statuses = new int[NUM_OF_RTT_ITERATIONS];
        int[] distanceMms = new int[NUM_OF_RTT_ITERATIONS];
        boolean[] distanceInclusionMap = new boolean[NUM_OF_RTT_ITERATIONS];
        int[] distanceStdDevMms = new int[NUM_OF_RTT_ITERATIONS];
        int[] rssis = new int[NUM_OF_RTT_ITERATIONS];
        int[] numAttempted = new int[NUM_OF_RTT_ITERATIONS];
        int[] numSuccessful = new int[NUM_OF_RTT_ITERATIONS];
        long[] timestampsMs = new long[NUM_OF_RTT_ITERATIONS];
        byte[] lastLci = null;
        byte[] lastLcr = null;
        for (int i = 0; i < NUM_OF_RTT_ITERATIONS; ++i) {
            ResultCallback callback = new ResultCallback();
            mWifiRttManager.startRanging(request, mExecutor, callback);
            assertTrue(""Wi-Fi RTT results: no callback on iteration "" + i,
                    callback.waitForCallback());

            List<RangingResult> currentResults = callback.getResults();
            assertNotNull(
                    ""Wi-Fi RTT results: null results (onRangingFailure) on iteration "" + i,
                    currentResults);
            assertEquals(
                    ""Wi-Fi RTT results: unexpected # of results (expect 1) on iteration "" + i,
                    1, currentResults.size());
            RangingResult result = currentResults.get(0);
            assertEquals(
                    ""Wi-Fi RTT results: invalid result (wrong BSSID) entry on iteration "" + i,
                    result.getMacAddress().toString(), testAp.BSSID);

            assertNull(
                    ""Wi-Fi RTT results: invalid result (non-null PeerHandle) entry on iteration ""
                            + i, result.getPeerHandle());

            allResults.add(result);
            int status = result.getStatus();
            statuses[i] = status;
            if (status == RangingResult.STATUS_SUCCESS) {
                assertFalse(""Wi-Fi RTT results: should not be a 802.11MC measurement"",
                        result.is80211mcMeasurement());
                distanceSum += result.getDistanceMm();

                assertTrue(""Wi-Fi RTT results: invalid RSSI on iteration "" + i,
                        result.getRssi() >= MIN_VALID_RSSI);

                distanceMms[i - numFailures] = result.getDistanceMm();
                distanceStdDevMms[i - numFailures] = result.getDistanceStdDevMm();
                rssis[i - numFailures] = result.getRssi();
                // For one-sided RTT the number of packets attempted in a burst is not available,
                // So we set the result to be the same as used in the request.
                numAttempted[i - numFailures] = request.getRttBurstSize();
                numSuccessful[i - numFailures] = result.getNumSuccessfulMeasurements();
                timestampsMs[i - numFailures] = result.getRangingTimestampMillis();

                byte[] currentLci = result.getLci();
                byte[] currentLcr = result.getLcr();
                if (i - numFailures > 0) {
                    assertTrue(""Wi-Fi RTT results: invalid result (LCI mismatch) on iteration "" + i,
                            Arrays.equals(currentLci, lastLci));
                    assertTrue(""Wi-Fi RTT results: invalid result (LCR mismatch) on iteration "" + i,
                            Arrays.equals(currentLcr, lastLcr));
                }
                lastLci = currentLci;
                lastLcr = currentLcr;
            } else {
                numFailures++;
            }
            // Sleep a while to avoid stress AP.
            Thread.sleep(intervalMs);
        }
        // Save results to log
        int numGoodResults = NUM_OF_RTT_ITERATIONS - numFailures;
        DeviceReportLog reportLog = new DeviceReportLog(TAG, ""testRangingToTestAp"");
        reportLog.addValues(""status_codes"", statuses, ResultType.NEUTRAL, ResultUnit.NONE);
        reportLog.addValues(""distance_mm"", Arrays.copyOf(distanceMms, numGoodResults),
                ResultType.NEUTRAL, ResultUnit.NONE);
        reportLog.addValues(""distance_stddev_mm"",
                Arrays.copyOf(distanceStdDevMms, numGoodResults),
                ResultType.NEUTRAL, ResultUnit.NONE);
        reportLog.addValues(""rssi_dbm"", Arrays.copyOf(rssis, numGoodResults),
                ResultType.NEUTRAL,
                ResultUnit.NONE);
        reportLog.addValues(""num_attempted"", Arrays.copyOf(numAttempted, numGoodResults),
                ResultType.NEUTRAL, ResultUnit.NONE);
        reportLog.addValues(""num_successful"", Arrays.copyOf(numSuccessful, numGoodResults),
                ResultType.NEUTRAL, ResultUnit.NONE);
        reportLog.addValues(""timestamps"", Arrays.copyOf(timestampsMs, numGoodResults),
                ResultType.NEUTRAL, ResultUnit.NONE);
        reportLog.submit();

        /** TODO(b/192909380): enable the performance verification after device fix.
            // Analyze results
            assertTrue(""Wi-Fi RTT failure rate exceeds threshold: FAIL="" + numFailures
                            + "", ITERATIONS=""
                            + NUM_OF_RTT_ITERATIONS + "", AP RSSI="" + testAp.level
                            + "", AP SSID="" + testAp.SSID,
                    numFailures <= NUM_OF_RTT_ITERATIONS * MAX_NON11MC_FAILURE_RATE_PERCENT / 100);

            if (numFailures != NUM_OF_RTT_ITERATIONS) {
                // Calculate an initial average using all measurements to determine distance outliers
                double distanceAvg = (double) distanceSum / (NUM_OF_RTT_ITERATIONS - numFailures);
                // Now figure out the distance outliers and mark them in the distance inclusion map
                int validDistances = 0;
                for (int i = 0; i < (NUM_OF_RTT_ITERATIONS - numFailures); i++) {
                    if (distanceMms[i] - MAX_VARIATION_FROM_AVERAGE_DISTANCE_MM < distanceAvg) {
                        // Distances that are in range for the distribution are included in the map
                        distanceInclusionMap[i] = true;
                        validDistances++;
                    } else {
                        // Distances that are out of range for the distribution are excluded in the map
                        distanceInclusionMap[i] = false;
                    }
                }

                assertTrue(""After fails+outlier removal greater that 50% distances must remain: "" +
                        NUM_OF_RTT_ITERATIONS / 2, validDistances > NUM_OF_RTT_ITERATIONS / 2);

                // Remove the distance outliers and find the new average, min and max.
                distanceSum = 0;
                distanceMax = Integer.MIN_VALUE;
                distanceMin = Integer.MAX_VALUE;
                for (int i = 0; i < (NUM_OF_RTT_ITERATIONS - numFailures); i++) {
                    if (distanceInclusionMap[i]) {
                        distanceSum += distanceMms[i];
                        distanceMin = Math.min(distanceMin, distanceMms[i]);
                        distanceMax = Math.max(distanceMax, distanceMms[i]);
                    }
                }
                distanceAvg = (double) distanceSum / validDistances;
                assertTrue(""Wi-Fi RTT: Variation (max direction) exceeds threshold, Variation =""
                                + (distanceMax - distanceAvg),
                        (distanceMax - distanceAvg) <= MAX_VARIATION_FROM_AVERAGE_DISTANCE_MM);
                assertTrue(""Wi-Fi RTT: Variation (min direction) exceeds threshold, Variation =""
                                + (distanceAvg - distanceMin),
                        (distanceAvg - distanceMin) <= MAX_VARIATION_FROM_AVERAGE_DISTANCE_MM);
                for (int i = 0; i < numGoodResults; ++i) {
                    assertNotSame(""Number of attempted measurements is 0"", 0, numAttempted[i]);
                    assertNotSame(""Number of successful measurements is 0"", 0, numSuccessful[i]);
                }
         */
    }
}"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"isLocationEnabled"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	"/*
 *.
 */

package android.net.wifi.cts;

import static android.net.NetworkCapabilities.NET_CAPABILITY_OEM_PAID;
import static android.net.NetworkCapabilities.NET_CAPABILITY_OEM_PRIVATE;
import static android.net.wifi.WifiEnterpriseConfig.Eap.AKA;
import static android.net.wifi.WifiEnterpriseConfig.Eap.WAPI_CERT;
import static android.os.Process.myUid;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.junit.Assume.assumeTrue;

import android.content.Context;
import android.content.pm.PackageManager;
import android.location.LocationManager;
import android.net.ConnectivityManager;
import android.net.MacAddress;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiEnterpriseConfig;
import android.net.wifi.WifiManager;
import android.net.wifi.WifiNetworkSuggestion;
import android.net.wifi.hotspot2.PasspointConfiguration;
import android.net.wifi.hotspot2.pps.Credential;
import android.net.wifi.hotspot2.pps.HomeSp;
import android.os.Build;
import android.platform.test.annotations.AppModeFull;
import android.support.test.uiautomator.UiDevice;
import android.telephony.TelephonyManager;

import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.filters.LargeTest;
import androidx.test.filters.SdkSuppress;
import androidx.test.platform.app.InstrumentationRegistry;

import com.android.compatibility.common.util.ApiLevelUtil;
import com.android.compatibility.common.util.PollingCheck;
import com.android.compatibility.common.util.ShellIdentityUtils;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.security.KeyFactory;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.PKCS8EncodedKeySpec;
import java.util.List;
import java.util.Set;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;

@AppModeFull(reason = ""Cannot get WifiManager in instant app mode"")
@LargeTest
@RunWith(AndroidJUnit4.class)
public class WifiNetworkSuggestionTest extends WifiJUnit4TestBase {
    private static final String TAG = ""WifiNetworkSuggestionTest"";

    private static final String TEST_SSID = ""testSsid"";
    private static final String TEST_BSSID = ""00:df:aa:bc:12:23"";
    private static final String TEST_PASSPHRASE = ""testPassword"";
    private static final int TEST_PRIORITY = 5;
    private static final int TEST_PRIORITY_GROUP = 1;
    private static final int TEST_SUB_ID = 1;

    private static boolean sWasVerboseLoggingEnabled;
    private static boolean sWasScanThrottleEnabled;
    private static boolean sWasWifiEnabled;

    private static Context sContext;
    private static WifiManager sWifiManager;
    private static ConnectivityManager sConnectivityManager;
    private static UiDevice sUiDevice;
    private static WifiConfiguration sTestNetwork;
    private static ConnectivityManager.NetworkCallback sNsNetworkCallback;
    private static TestHelper sTestHelper;

    private ScheduledExecutorService mExecutorService;

    private static final int DURATION_MILLIS = 10_000;

    @BeforeClass
    public static void setUpClass() throws Exception {
        sContext = InstrumentationRegistry.getInstrumentation().getContext();
        // skip the test if WiFi is not supported
        // Don't use assumeTrue in @BeforeClass
        if (!WifiFeature.isWifiSupported(sContext)) return;
        // skip the test if location is not supported
        if (!sContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_LOCATION)) return;
        // skip if the location is disabled
        if (!sContext.getSystemService(LocationManager.class).isLocationEnabled()) return;

        sWifiManager = sContext.getSystemService(WifiManager.class);
        assertThat(sWifiManager).isNotNull();
        sConnectivityManager = sContext.getSystemService(ConnectivityManager.class);
        sUiDevice = UiDevice.getInstance(InstrumentationRegistry.getInstrumentation());
        sTestHelper = new TestHelper(sContext, sUiDevice);

        // turn on verbose logging for tests
        sWasVerboseLoggingEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> sWifiManager.isVerboseLoggingEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> sWifiManager.setVerboseLoggingEnabled(true));
        // Disable scan throttling for tests.
        sWasScanThrottleEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> sWifiManager.isScanThrottleEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> sWifiManager.setScanThrottleEnabled(false));

        // enable Wifi
        sWasWifiEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> sWifiManager.isWifiEnabled());
        if (!sWifiManager.isWifiEnabled()) {
            ShellIdentityUtils.invokeWithShellPermissions(() -> sWifiManager.setWifiEnabled(true));
        }
        PollingCheck.check(""Wifi not enabled"", DURATION_MILLIS, () -> sWifiManager.isWifiEnabled());

        // check we have >= 1 saved network
        List<WifiConfiguration> savedNetworks = ShellIdentityUtils.invokeWithShellPermissions(
                () -> sWifiManager.getPrivilegedConfiguredNetworks());
        if (savedNetworks.isEmpty()) {
            return;
        }
        // Pick any network in range.

        List<WifiConfiguration> networks = TestHelper.findMatchingSavedNetworksWithBssid(
                sWifiManager, savedNetworks);
        if (!networks.isEmpty()) {
            sTestNetwork = networks.get(0);
        }

        // Disable auto-join on the saved network to prevent auto-connect from
        // interfering with the test.
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> {
                    for (WifiConfiguration savedNetwork : savedNetworks) {
                        sWifiManager.disableNetwork(savedNetwork.networkId);
                    }
                });
    }

    @AfterClass
    public static void tearDownClass() throws Exception {
        if (!WifiFeature.isWifiSupported(sContext)) return;

        ShellIdentityUtils.invokeWithShellPermissions(
                () -> sWifiManager.setScanThrottleEnabled(sWasScanThrottleEnabled));
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> sWifiManager.setVerboseLoggingEnabled(sWasVerboseLoggingEnabled));
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> sWifiManager.setWifiEnabled(sWasWifiEnabled));

        // Re-enable networks.
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> {
                    for (WifiConfiguration savedNetwork : sWifiManager.getConfiguredNetworks()) {
                        sWifiManager.enableNetwork(savedNetwork.networkId, false);
                    }
                });
    }

    @Before
    public void setUp() throws Exception {
        mExecutorService = Executors.newSingleThreadScheduledExecutor();
        // turn screen on
        sTestHelper.turnScreenOn();

        // Disconnect current network if any.
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> sWifiManager.disconnect());

        // Wait for Wifi to be disconnected.
        PollingCheck.check(
                ""Wifi not disconnected"",
                20_000,
                () -> sWifiManager.getConnectionInfo().getNetworkId() == -1);

        // Clear any existing app state before each test.
        if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(sContext)) {
            ShellIdentityUtils.invokeWithShellPermissions(
                    () -> sWifiManager.removeAppState(myUid(), sContext.getPackageName()));
        }
    }

    @After
    public void tearDown() throws Exception {
        // Release the requests after the test.
        if (sNsNetworkCallback != null) {
            sConnectivityManager.unregisterNetworkCallback(sNsNetworkCallback);
        }
        mExecutorService.shutdownNow();
        // Clear any existing app state after each test.
        if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(sContext)) {
            ShellIdentityUtils.invokeWithShellPermissions(
                    () -> sWifiManager.removeAppState(myUid(), sContext.getPackageName()));
        }
        sTestHelper.turnScreenOff();
    }

    private static final String CA_SUITE_B_RSA3072_CERT_STRING =
            ""-----BEGIN CERTIFICATE-----\n""
                    + ""MIIEnTCCAwWgAwIBAgIUD87Y8fFLzLr1HQ/64aEnjNq2R/4wDQYJKoZIhvcNAQEM\n""
                    + ""BQAwXjELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAkNBMQwwCgYDVQQHDANNVFYxEDAO\n""
                    + ""BgNVBAoMB0FuZHJvaWQxDjAMBgNVBAsMBVdpLUZpMRIwEAYDVQQDDAl1bml0ZXN0\n""
                    + ""Q0EwHhcNMjAwNzIxMDIxNzU0WhcNMzAwNTMwMDIxNzU0WjBeMQswCQYDVQQGEwJV\n""
                    + ""UzELMAkGA1UECAwCQ0ExDDAKBgNVBAcMA01UVjEQMA4GA1UECgwHQW5kcm9pZDEO\n""
                    + ""MAwGA1UECwwFV2ktRmkxEjAQBgNVBAMMCXVuaXRlc3RDQTCCAaIwDQYJKoZIhvcN\n""
                    + ""AQEBBQADggGPADCCAYoCggGBAMtrsT0otlxh0QS079KpRRbU1PQjCihSoltXnrxF\n""
                    + ""sTWZs2weVEeYVyYU5LaauCDDgISCMtjtfbfylMBeYjpWB5hYzYQOiTzo0anWhMyb\n""
                    + ""Ngb7gpMVZuIl6lwMYRyVRKwHWnTo2EUg1ZzW5rGe5fs/KHj6//hoNFm+3Oju0TQd\n""
                    + ""nraQULpoERPF5B7p85Cssk8uNbviBfZXvtCuJ4N6w7PNceOY/9bbwc1mC+pPZmzV\n""
                    + ""SOAg0vvbIQRzChm63C3jBC3xmxSOOZVrKN4zKDG2s8P0oCNGt0NlgRMrgbPRekzg\n""
                    + ""4avkbA0vTuc2AyriTEYkdea/Mt4EpRg9XuOb43U/GJ/d/vQv2/9fsxhXmsZrn8kr\n""
                    + ""Qo5MMHJFUd96GgHmvYSU3Mf/5r8gF626lvqHioGuTAuHUSnr02ri1WUxZ15LDRgY\n""
                    + ""quMjDCFZfucjJPDAdtiHcFSej/4SLJlN39z8oKKNPn3aL9Gv49oAKs9S8tfDVzMk\n""
                    + ""fDLROQFHFuW715GnnMgEAoOpRwIDAQABo1MwUTAdBgNVHQ4EFgQUeVuGmSVN4ARs\n""
                    + ""mesUMWSJ2qWLbxUwHwYDVR0jBBgwFoAUeVuGmSVN4ARsmesUMWSJ2qWLbxUwDwYD\n""
                    + ""VR0TAQH/BAUwAwEB/zANBgkqhkiG9w0BAQwFAAOCAYEAit1Lo/hegZpPuT9dlWZJ\n""
                    + ""bC8JvAf95O8lnn6LFb69pgYOHCLgCIlvYXu9rdBUJgZo+V1MzJJljiO6RxWRfKbQ\n""
                    + ""8WBYkoqR1EqriR3Kn8q/SjIZCdFSaznTyU1wQMveBQ6RJWXSUhYVfE9RjyFTp7B4\n""
                    + ""UyH2uCluR/0T06HQNGfH5XpIYQqCk1Zgng5lmEmheLDPoJpa92lKeQFJMC6eYz9g\n""
                    + ""lF1GHxPxkPfbMJ6ZDp5X6Yopu6Q6uEXhVKM/iQVcgzRkx9rid+xTYl+nOKyK/XfC\n""
                    + ""z8P0/TFIoPTW02DLge5wKagdoCpy1B7HdrAXyUjoH4B8MsUkq3kYPFSjPzScuTtV\n""
                    + ""kUuDw5ipCNeXCRnhbYqRDk6PX5GUu2cmN9jtaH3tbgm3fKNOsd/BO1fLIl7qjXlR\n""
                    + ""27HHbC0JXjNvlm2DLp23v4NTxS7WZGYsxyUj5DZrxBxqCsTXu/01w1BrQKWKh9FM\n""
                    + ""aVrlA8omfVODK2CSuw+KhEMHepRv/AUgsLl4L4+RMoa+\n""
                    + ""-----END CERTIFICATE-----\n"";
    private static final X509Certificate CA_SUITE_B_RSA3072_CERT =
            loadCertificate(CA_SUITE_B_RSA3072_CERT_STRING);

    private static final String CA_SUITE_B_ECDSA_CERT_STRING =
            ""-----BEGIN CERTIFICATE-----\n""
                    + ""MIICTzCCAdSgAwIBAgIUdnLttwNPnQzFufplGOr9bTrGCqMwCgYIKoZIzj0EAwMw\n""
                    + ""XjELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAkNBMQwwCgYDVQQHDANNVFYxEDAOBgNV\n""
                    + ""BAoMB0FuZHJvaWQxDjAMBgNVBAsMBVdpLUZpMRIwEAYDVQQDDAl1bml0ZXN0Q0Ew\n""
                    + ""HhcNMjAwNzIxMDIyNDA1WhcNMzAwNTMwMDIyNDA1WjBeMQswCQYDVQQGEwJVUzEL\n""
                    + ""MAkGA1UECAwCQ0ExDDAKBgNVBAcMA01UVjEQMA4GA1UECgwHQW5kcm9pZDEOMAwG\n""
                    + ""A1UECwwFV2ktRmkxEjAQBgNVBAMMCXVuaXRlc3RDQTB2MBAGByqGSM49AgEGBSuB\n""
                    + ""BAAiA2IABFmntXwk9icqhDQFUP1xy04WyEpaGW4q6Q+8pujlSl/X3iotPZ++GZfp\n""
                    + ""Mfv3YDHDBl6sELPQ2BEjyPXmpsKjOUdiUe69e88oGEdeqT2xXiQ6uzpTfJD4170i\n""
                    + ""O/TwLrQGKKNTMFEwHQYDVR0OBBYEFCjptsX3g4g5W0L4oEP6N3gfyiZXMB8GA1Ud\n""
                    + ""IwQYMBaAFCjptsX3g4g5W0L4oEP6N3gfyiZXMA8GA1UdEwEB/wQFMAMBAf8wCgYI\n""
                    + ""KoZIzj0EAwMDaQAwZgIxAK61brUYRbLmQKiaEboZgrHtnPAcGo7Yzx3MwHecx3Dm\n""
                    + ""5soIeLVYc8bPYN1pbhXW1gIxALdEe2sh03nBHyQH4adYoZungoCwt8mp/7sJFxou\n""
                    + ""9UnRegyBgGzf74ROWdpZHzh+Pg==\n""
                    + ""-----END CERTIFICATE-----\n"";
    private static final X509Certificate CA_SUITE_B_ECDSA_CERT =
            loadCertificate(CA_SUITE_B_ECDSA_CERT_STRING);

    private static final String CLIENT_SUITE_B_RSA3072_CERT_STRING =
            ""-----BEGIN CERTIFICATE-----\n""
                    + ""MIIERzCCAq8CFDopjyNgaj+c2TN2k06h7okEWpHJMA0GCSqGSIb3DQEBDAUAMF4x\n""
                    + ""CzAJBgNVBAYTAlVTMQswCQYDVQQIDAJDQTEMMAoGA1UEBwwDTVRWMRAwDgYDVQQK\n""
                    + ""DAdBbmRyb2lkMQ4wDAYDVQQLDAVXaS1GaTESMBAGA1UEAwwJdW5pdGVzdENBMB4X\n""
                    + ""DTIwMDcyMTAyMjkxMVoXDTMwMDUzMDAyMjkxMVowYjELMAkGA1UEBhMCVVMxCzAJ\n""
                    + ""BgNVBAgMAkNBMQwwCgYDVQQHDANNVFYxEDAOBgNVBAoMB0FuZHJvaWQxDjAMBgNV\n""
                    + ""BAsMBVdpLUZpMRYwFAYDVQQDDA11bml0ZXN0Q2xpZW50MIIBojANBgkqhkiG9w0B\n""
                    + ""AQEFAAOCAY8AMIIBigKCAYEAwSK3C5K5udtCKTnE14e8z2cZvwmB4Xe+a8+7QLud\n""
                    + ""Hooc/lQzClgK4MbVUC0D3FE+U32C78SxKoTaRWtvPmNm+UaFT8KkwyUno/dv+2XD\n""
                    + ""pd/zARQ+3FwAfWopAhEyCVSxwsCa+slQ4juRIMIuUC1Mm0NaptZyM3Tj/ICQEfpk\n""
                    + ""o9qVIbiK6eoJMTkY8EWfAn7RTFdfR1OLuO0mVOjgLW9/+upYv6hZ19nAMAxw4QTJ\n""
                    + ""x7lLwALX7B+tDYNEZHDqYL2zyvQWAj2HClere8QYILxkvktgBg2crEJJe4XbDH7L\n""
                    + ""A3rrXmsiqf1ZbfFFEzK9NFqovL+qGh+zIP+588ShJFO9H/RDnDpiTnAFTWXQdTwg\n""
                    + ""szSS0Vw2PB+JqEABAa9DeMvXT1Oy+NY3ItPHyy63nQZVI2rXANw4NhwS0Z6DF+Qs\n""
                    + ""TNrj+GU7e4SG/EGR8SvldjYfQTWFLg1l/UT1hOOkQZwdsaW1zgKyeuiFB2KdMmbA\n""
                    + ""Sq+Ux1L1KICo0IglwWcB/8nnAgMBAAEwDQYJKoZIhvcNAQEMBQADggGBAMYwJkNw\n""
                    + ""BaCviKFmReDTMwWPRy4AMNViEeqAXgERwDEKwM7efjsaj5gctWfKsxX6UdLzkhgg\n""
                    + ""6S/T6PxVWKzJ6l7SoOuTa6tMQOZp+h3R1mdfEQbw8B5cXBxZ+batzAai6Fiy1FKS\n""
                    + ""/ka3INbcGfYuIYghfTrb4/NJKN06ZaQ1bpPwq0e4gN7800T2nbawvSf7r+8ZLcG3\n""
                    + ""6bGCjRMwDSIipNvOwoj3TG315XC7TccX5difQ4sKOY+d2MkVJ3RiO0Ciw2ZbEW8d\n""
                    + ""1FH5vUQJWnBUfSFznosGzLwH3iWfqlP+27jNE+qB2igEwCRFgVAouURx5ou43xuX\n""
                    + ""qf6JkdI3HTJGLIWxkp7gOeln4dEaYzKjYw+P0VqJvKVqQ0IXiLjHgE0J9p0vgyD6\n""
                    + ""HVVcP7U8RgqrbIjL1QgHU4KBhGi+WSUh/mRplUCNvHgcYdcHi/gHpj/j6ubwqIGV\n""
                    + ""z4iSolAHYTmBWcLyE0NgpzE6ntp+53r2KaUJA99l2iGVzbWTwqPSm0XAVw==\n""
                    + ""-----END CERTIFICATE-----\n"";
    private static final X509Certificate CLIENT_SUITE_B_RSA3072_CERT =
            loadCertificate(CLIENT_SUITE_B_RSA3072_CERT_STRING);

    private static final byte[] CLIENT_SUITE_B_RSA3072_KEY_DATA = new byte[]{
            (byte) 0x30, (byte) 0x82, (byte) 0x06, (byte) 0xfe, (byte) 0x02, (byte) 0x01,
            (byte) 0x00, (byte) 0x30, (byte) 0x0d, (byte) 0x06, (byte) 0x09, (byte) 0x2a,
            (byte) 0x86, (byte) 0x48, (byte) 0x86, (byte) 0xf7, (byte) 0x0d, (byte) 0x01,
            (byte) 0x01, (byte) 0x01, (byte) 0x05, (byte) 0x00, (byte) 0x04, (byte) 0x82,
            (byte) 0x06, (byte) 0xe8, (byte) 0x30, (byte) 0x82, (byte) 0x06, (byte) 0xe4,
            (byte) 0x02, (byte) 0x01, (byte) 0x00, (byte) 0x02, (byte) 0x82, (byte) 0x01,
            (byte) 0x81, (byte) 0x00, (byte) 0xc1, (byte) 0x22, (byte) 0xb7, (byte) 0x0b,
            (byte) 0x92, (byte) 0xb9, (byte) 0xb9, (byte) 0xdb, (byte) 0x42, (byte) 0x29,
            (byte) 0x39, (byte) 0xc4, (byte) 0xd7, (byte) 0x87, (byte) 0xbc, (byte) 0xcf,
            (byte) 0x67, (byte) 0x19, (byte) 0xbf, (byte) 0x09, (byte) 0x81, (byte) 0xe1,
            (byte) 0x77, (byte) 0xbe, (byte) 0x6b, (byte) 0xcf, (byte) 0xbb, (byte) 0x40,
            (byte) 0xbb, (byte) 0x9d, (byte) 0x1e, (byte) 0x8a, (byte) 0x1c, (byte) 0xfe,
            (byte) 0x54, (byte) 0x33, (byte) 0x0a, (byte) 0x58, (byte) 0x0a, (byte) 0xe0,
            (byte) 0xc6, (byte) 0xd5, (byte) 0x50, (byte) 0x2d, (byte) 0x03, (byte) 0xdc,
            (byte) 0x51, (byte) 0x3e, (byte) 0x53, (byte) 0x7d, (byte) 0x82, (byte) 0xef,
            (byte) 0xc4, (byte) 0xb1, (byte) 0x2a, (byte) 0x84, (byte) 0xda, (byte) 0x45,
            (byte) 0x6b, (byte) 0x6f, (byte) 0x3e, (byte) 0x63, (byte) 0x66, (byte) 0xf9,
            (byte) 0x46, (byte) 0x85, (byte) 0x4f, (byte) 0xc2, (byte) 0xa4, (byte) 0xc3,
            (byte) 0x25, (byte) 0x27, (byte) 0xa3, (byte) 0xf7, (byte) 0x6f, (byte) 0xfb,
            (byte) 0x65, (byte) 0xc3, (byte) 0xa5, (byte) 0xdf, (byte) 0xf3, (byte) 0x01,
            (byte) 0x14, (byte) 0x3e, (byte) 0xdc, (byte) 0x5c, (byte) 0x00, (byte) 0x7d,
            (byte) 0x6a, (byte) 0x29, (byte) 0x02, (byte) 0x11, (byte) 0x32, (byte) 0x09,
            (byte) 0x54, (byte) 0xb1, (byte) 0xc2, (byte) 0xc0, (byte) 0x9a, (byte) 0xfa,
            (byte) 0xc9, (byte) 0x50, (byte) 0xe2, (byte) 0x3b, (byte) 0x91, (byte) 0x20,
            (byte) 0xc2, (byte) 0x2e, (byte) 0x50, (byte) 0x2d, (byte) 0x4c, (byte) 0x9b,
            (byte) 0x43, (byte) 0x5a, (byte) 0xa6, (byte) 0xd6, (byte) 0x72, (byte) 0x33,
            (byte) 0x74, (byte) 0xe3, (byte) 0xfc, (byte) 0x80, (byte) 0x90, (byte) 0x11,
            (byte) 0xfa, (byte) 0x64, (byte) 0xa3, (byte) 0xda, (byte) 0x95, (byte) 0x21,
            (byte) 0xb8, (byte) 0x8a, (byte) 0xe9, (byte) 0xea, (byte) 0x09, (byte) 0x31,
            (byte) 0x39, (byte) 0x18, (byte) 0xf0, (byte) 0x45, (byte) 0x9f, (byte) 0x02,
            (byte) 0x7e, (byte) 0xd1, (byte) 0x4c, (byte) 0x57, (byte) 0x5f, (byte) 0x47,
            (byte) 0x53, (byte) 0x8b, (byte) 0xb8, (byte) 0xed, (byte) 0x26, (byte) 0x54,
            (byte) 0xe8, (byte) 0xe0, (byte) 0x2d, (byte) 0x6f, (byte) 0x7f, (byte) 0xfa,
            (byte) 0xea, (byte) 0x58, (byte) 0xbf, (byte) 0xa8, (byte) 0x59, (byte) 0xd7,
            (byte) 0xd9, (byte) 0xc0, (byte) 0x30, (byte) 0x0c, (byte) 0x70, (byte) 0xe1,
            (byte) 0x04, (byte) 0xc9, (byte) 0xc7, (byte) 0xb9, (byte) 0x4b, (byte) 0xc0,
            (byte) 0x02, (byte) 0xd7, (byte) 0xec, (byte) 0x1f, (byte) 0xad, (byte) 0x0d,
            (byte) 0x83, (byte) 0x44, (byte) 0x64, (byte) 0x70, (byte) 0xea, (byte) 0x60,
            (byte) 0xbd, (byte) 0xb3, (byte) 0xca, (byte) 0xf4, (byte) 0x16, (byte) 0x02,
            (byte) 0x3d, (byte) 0x87, (byte) 0x0a, (byte) 0x57, (byte) 0xab, (byte) 0x7b,
            (byte) 0xc4, (byte) 0x18, (byte) 0x20, (byte) 0xbc, (byte) 0x64, (byte) 0xbe,
            (byte) 0x4b, (byte) 0x60, (byte) 0x06, (byte) 0x0d, (byte) 0x9c, (byte) 0xac,
            (byte) 0x42, (byte) 0x49, (byte) 0x7b, (byte) 0x85, (byte) 0xdb, (byte) 0x0c,
            (byte) 0x7e, (byte) 0xcb, (byte) 0x03, (byte) 0x7a, (byte) 0xeb, (byte) 0x5e,
            (byte) 0x6b, (byte) 0x22, (byte) 0xa9, (byte) 0xfd, (byte) 0x59, (byte) 0x6d,
            (byte) 0xf1, (byte) 0x45, (byte) 0x13, (byte) 0x32, (byte) 0xbd, (byte) 0x34,
            (byte) 0x5a, (byte) 0xa8, (byte) 0xbc, (byte) 0xbf, (byte) 0xaa, (byte) 0x1a,
            (byte) 0x1f, (byte) 0xb3, (byte) 0x20, (byte) 0xff, (byte) 0xb9, (byte) 0xf3,
            (byte) 0xc4, (byte) 0xa1, (byte) 0x24, (byte) 0x53, (byte) 0xbd, (byte) 0x1f,
            (byte) 0xf4, (byte) 0x43, (byte) 0x9c, (byte) 0x3a, (byte) 0x62, (byte) 0x4e,
            (byte) 0x70, (byte) 0x05, (byte) 0x4d, (byte) 0x65, (byte) 0xd0, (byte) 0x75,
            (byte) 0x3c, (byte) 0x20, (byte) 0xb3, (byte) 0x34, (byte) 0x92, (byte) 0xd1,
            (byte) 0x5c, (byte) 0x36, (byte) 0x3c, (byte) 0x1f, (byte) 0x89, (byte) 0xa8,
            (byte) 0x40, (byte) 0x01, (byte) 0x01, (byte) 0xaf, (byte) 0x43, (byte) 0x78,
            (byte) 0xcb, (byte) 0xd7, (byte) 0x4f, (byte) 0x53, (byte) 0xb2, (byte) 0xf8,
            (byte) 0xd6, (byte) 0x37, (byte) 0x22, (byte) 0xd3, (byte) 0xc7, (byte) 0xcb,
            (byte) 0x2e, (byte) 0xb7, (byte) 0x9d, (byte) 0x06, (byte) 0x55, (byte) 0x23,
            (byte) 0x6a, (byte) 0xd7, (byte) 0x00, (byte) 0xdc, (byte) 0x38, (byte) 0x36,
            (byte) 0x1c, (byte) 0x12, (byte) 0xd1, (byte) 0x9e, (byte) 0x83, (byte) 0x17,
            (byte) 0xe4, (byte) 0x2c, (byte) 0x4c, (byte) 0xda, (byte) 0xe3, (byte) 0xf8,
            (byte) 0x65, (byte) 0x3b, (byte) 0x7b, (byte) 0x84, (byte) 0x86, (byte) 0xfc,
            (byte) 0x41, (byte) 0x91, (byte) 0xf1, (byte) 0x2b, (byte) 0xe5, (byte) 0x76,
            (byte) 0x36, (byte) 0x1f, (byte) 0x41, (byte) 0x35, (byte) 0x85, (byte) 0x2e,
            (byte) 0x0d, (byte) 0x65, (byte) 0xfd, (byte) 0x44, (byte) 0xf5, (byte) 0x84,
            (byte) 0xe3, (byte) 0xa4, (byte) 0x41, (byte) 0x9c, (byte) 0x1d, (byte) 0xb1,
            (byte) 0xa5, (byte) 0xb5, (byte) 0xce, (byte) 0x02, (byte) 0xb2, (byte) 0x7a,
            (byte) 0xe8, (byte) 0x85, (byte) 0x07, (byte) 0x62, (byte) 0x9d, (byte) 0x32,
            (byte) 0x66, (byte) 0xc0, (byte) 0x4a, (byte) 0xaf, (byte) 0x94, (byte) 0xc7,
            (byte) 0x52, (byte) 0xf5, (byte) 0x28, (byte) 0x80, (byte) 0xa8, (byte) 0xd0,
            (byte) 0x88, (byte) 0x25, (byte) 0xc1, (byte) 0x67, (byte) 0x01, (byte) 0xff,
            (byte) 0xc9, (byte) 0xe7, (byte) 0x02, (byte) 0x03, (byte) 0x01, (byte) 0x00,
            (byte) 0x01, (byte) 0x02, (byte) 0x82, (byte) 0x01, (byte) 0x80, (byte) 0x04,
            (byte) 0xb1, (byte) 0xcc, (byte) 0x53, (byte) 0x3a, (byte) 0xb0, (byte) 0xcb,
            (byte) 0x04, (byte) 0xba, (byte) 0x59, (byte) 0xf8, (byte) 0x2e, (byte) 0x81,
            (byte) 0xb2, (byte) 0xa9, (byte) 0xf3, (byte) 0x3c, (byte) 0xa5, (byte) 0x52,
            (byte) 0x90, (byte) 0x6f, (byte) 0x98, (byte) 0xc4, (byte) 0x69, (byte) 0x5b,
            (byte) 0x83, (byte) 0x84, (byte) 0x20, (byte) 0xb1, (byte) 0xae, (byte) 0xc3,
            (byte) 0x04, (byte) 0x46, (byte) 0x6a, (byte) 0x24, (byte) 0x2f, (byte) 0xcd,
            (byte) 0x6b, (byte) 0x90, (byte) 0x70, (byte) 0x20, (byte) 0x45, (byte) 0x25,
            (byte) 0x1a, (byte) 0xc3, (byte) 0x02, (byte) 0x42, (byte) 0xf3, (byte) 0x49,
            (byte) 0xe2, (byte) 0x3e, (byte) 0x21, (byte) 0x87, (byte) 0xdd, (byte) 0x6a,
            (byte) 0x94, (byte) 0x2a, (byte) 0x1e, (byte) 0x0f, (byte) 0xdb, (byte) 0x77,
            (byte) 0x5f, (byte) 0xc1, (byte) 0x2c, (byte) 0x03, (byte) 0xfb, (byte) 0xcf,
            (byte) 0x91, (byte) 0x82, (byte) 0xa1, (byte) 0xbf, (byte) 0xb0, (byte) 0x73,
            (byte) 0xfa, (byte) 0xda, (byte) 0xbc, (byte) 0xf8, (byte) 0x9f, (byte) 0x45,
            (byte) 0xd3, (byte) 0xe8, (byte) 0xbb, (byte) 0x38, (byte) 0xfb, (byte) 0xc2,
            (byte) 0x2d, (byte) 0x76, (byte) 0x51, (byte) 0x96, (byte) 0x18, (byte) 0x03,
            (byte) 0x15, (byte) 0xd9, (byte) 0xea, (byte) 0x82, (byte) 0x25, (byte) 0x83,
            (byte) 0xff, (byte) 0x5c, (byte) 0x85, (byte) 0x06, (byte) 0x09, (byte) 0xb2,
            (byte) 0x46, (byte) 0x12, (byte) 0x64, (byte) 0x02, (byte) 0x74, (byte) 0x4f,
            (byte) 0xbc, (byte) 0x9a, (byte) 0x25, (byte) 0x18, (byte) 0x01, (byte) 0x07,
            (byte) 0x17, (byte) 0x25, (byte) 0x55, (byte) 0x7c, (byte) 0xdc, (byte) 0xe1,
            (byte) 0xd1, (byte) 0x5a, (byte) 0x2f, (byte) 0x25, (byte) 0xaf, (byte) 0xf6,
            (byte) 0x8f, (byte) 0xa4, (byte) 0x9a, (byte) 0x5a, (byte) 0x3a, (byte) 0xfe,
            (byte) 0x2e, (byte) 0x93, (byte) 0x24, (byte) 0xa0, (byte) 0x27, (byte) 0xac,
            (byte) 0x07, (byte) 0x75, (byte) 0x33, (byte) 0x01, (byte) 0x54, (byte) 0x23,
            (byte) 0x0f, (byte) 0xe8, (byte) 0x9f, (byte) 0xfa, (byte) 0x36, (byte) 0xe6,
            (byte) 0x3a, (byte) 0xd5, (byte) 0x78, (byte) 0xb0, (byte) 0xe4, (byte) 0x6a,
            (byte) 0x16, (byte) 0x50, (byte) 0xbd, (byte) 0x0f, (byte) 0x9f, (byte) 0x32,
            (byte) 0xa1, (byte) 0x6b, (byte) 0xf5, (byte) 0xa4, (byte) 0x34, (byte) 0x58,
            (byte) 0xb6, (byte) 0xa4, (byte) 0xb3, (byte) 0xc3, (byte) 0x83, (byte) 0x08,
            (byte) 0x18, (byte) 0xc7, (byte) 0xef, (byte) 0x95, (byte) 0xe2, (byte) 0x1b,
            (byte) 0xba, (byte) 0x35, (byte) 0x61, (byte) 0xa3, (byte) 0xb4, (byte) 0x30,
            (byte) 0xe0, (byte) 0xd1, (byte) 0xc1, (byte) 0xa2, (byte) 0x3a, (byte) 0xc6,
            (byte) 0xb4, (byte) 0xd2, (byte) 0x80, (byte) 0x5a, (byte) 0xaf, (byte) 0xa4,
            (byte) 0x54, (byte) 0x3c, (byte) 0x66, (byte) 0x5a, (byte) 0x1c, (byte) 0x4d,
            (byte) 0xe1, (byte) 0xd9, (byte) 0x98, (byte) 0x44, (byte) 0x01, (byte) 0x1b,
            (byte) 0x8c, (byte) 0xe9, (byte) 0x80, (byte) 0x54, (byte) 0x83, (byte) 0x3d,
            (byte) 0x96, (byte) 0x25, (byte) 0x41, (byte) 0x1c, (byte) 0xad, (byte) 0xae,
            (byte) 0x3b, (byte) 0x7a, (byte) 0xd7, (byte) 0x9d, (byte) 0x10, (byte) 0x7c,
            (byte) 0xd1, (byte) 0xa7, (byte) 0x96, (byte) 0x39, (byte) 0xa5, (byte) 0x2f,
            (byte) 0xbe, (byte) 0xc3, (byte) 0x2c, (byte) 0x64, (byte) 0x01, (byte) 0xfe,
            (byte) 0xa2, (byte) 0xd1, (byte) 0x6a, (byte) 0xcf, (byte) 0x4c, (byte) 0x76,
            (byte) 0x3b, (byte) 0xc8, (byte) 0x35, (byte) 0x21, (byte) 0xda, (byte) 0x98,
            (byte) 0xcf, (byte) 0xf9, (byte) 0x29, (byte) 0xff, (byte) 0x30, (byte) 0x59,
            (byte) 0x36, (byte) 0x53, (byte) 0x0b, (byte) 0xbb, (byte) 0xfa, (byte) 0xba,
            (byte) 0xc4, (byte) 0x03, (byte) 0x23, (byte) 0xe0, (byte) 0xd3, (byte) 0x33,
            (byte) 0xff, (byte) 0x32, (byte) 0xdb, (byte) 0x30, (byte) 0x64, (byte) 0xc7,
            (byte) 0x56, (byte) 0xca, (byte) 0x55, (byte) 0x14, (byte) 0xee, (byte) 0x58,
            (byte) 0xfe, (byte) 0x96, (byte) 0x7e, (byte) 0x1c, (byte) 0x34, (byte) 0x16,
            (byte) 0xeb, (byte) 0x76, (byte) 0x26, (byte) 0x48, (byte) 0xe2, (byte) 0xe5,
            (byte) 0x5c, (byte) 0xd5, (byte) 0x83, (byte) 0x37, (byte) 0xd9, (byte) 0x09,
            (byte) 0x71, (byte) 0xbc, (byte) 0x54, (byte) 0x25, (byte) 0xca, (byte) 0x2e,
            (byte) 0xdb, (byte) 0x36, (byte) 0x39, (byte) 0xcc, (byte) 0x3a, (byte) 0x81,
            (byte) 0x95, (byte) 0x9e, (byte) 0xf4, (byte) 0x01, (byte) 0xa7, (byte) 0xc0,
            (byte) 0x20, (byte) 0xce, (byte) 0x70, (byte) 0x55, (byte) 0x2c, (byte) 0xe0,
            (byte) 0x93, (byte) 0x72, (byte) 0xa6, (byte) 0x25, (byte) 0xda, (byte) 0x64,
            (byte) 0x19, (byte) 0x18, (byte) 0xd2, (byte) 0x31, (byte) 0xe2, (byte) 0x7c,
            (byte) 0xf2, (byte) 0x30, (byte) 0x9e, (byte) 0x8d, (byte) 0xc6, (byte) 0x14,
            (byte) 0x8a, (byte) 0x38, (byte) 0xf0, (byte) 0x94, (byte) 0xeb, (byte) 0xf4,
            (byte) 0x64, (byte) 0x92, (byte) 0x3d, (byte) 0x67, (byte) 0xa6, (byte) 0x2c,
            (byte) 0x52, (byte) 0xfc, (byte) 0x60, (byte) 0xca, (byte) 0x2a, (byte) 0xcf,
            (byte) 0x24, (byte) 0xd5, (byte) 0x42, (byte) 0x5f, (byte) 0xc7, (byte) 0x9f,
            (byte) 0xf3, (byte) 0xb4, (byte) 0xdf, (byte) 0x76, (byte) 0x6e, (byte) 0x53,
            (byte) 0xa1, (byte) 0x7b, (byte) 0xae, (byte) 0xa5, (byte) 0x84, (byte) 0x1f,
            (byte) 0xfa, (byte) 0xc0, (byte) 0xb4, (byte) 0x6c, (byte) 0xc9, (byte) 0x02,
            (byte) 0x81, (byte) 0xc1, (byte) 0x00, (byte) 0xf3, (byte) 0x17, (byte) 0xd9,
            (byte) 0x48, (byte) 0x17, (byte) 0x87, (byte) 0x84, (byte) 0x16, (byte) 0xea,
            (byte) 0x2d, (byte) 0x31, (byte) 0x1b, (byte) 0xce, (byte) 0xec, (byte) 0xaf,
            (byte) 0xdc, (byte) 0x6b, (byte) 0xaf, (byte) 0xc8, (byte) 0xf1, (byte) 0x40,
            (byte) 0xa7, (byte) 0x4f, (byte) 0xef, (byte) 0x48, (byte) 0x08, (byte) 0x5e,
            (byte) 0x9a, (byte) 0xd1, (byte) 0xc0, (byte) 0xb1, (byte) 0xfe, (byte) 0xe7,
            (byte) 0x03, (byte) 0xd5, (byte) 0x96, (byte) 0x01, (byte) 0xe8, (byte) 0x40,
            (byte) 0xca, (byte) 0x78, (byte) 0xcb, (byte) 0xb3, (byte) 0x28, (byte) 0x1a,
            (byte) 0xf0, (byte) 0xe5, (byte) 0xf6, (byte) 0x46, (byte) 0xef, (byte) 0xcd,
            (byte) 0x1a, (byte) 0x0f, (byte) 0x13, (byte) 0x2d, (byte) 0x38, (byte) 0xf8,
            (byte) 0xf7, (byte) 0x88, (byte) 0x21, (byte) 0x15, (byte) 0xce, (byte) 0x48,
            (byte) 0xf4, (byte) 0x92, (byte) 0x7e, (byte) 0x9b, (byte) 0x2e, (byte) 0x2f,
            (byte) 0x22, (byte) 0x3e, (byte) 0x5c, (byte) 0x67, (byte) 0xd7, (byte) 0x58,
            (byte) 0xf6, (byte) 0xef, (byte) 0x1f, (byte) 0xb4, (byte) 0x04, (byte) 0xc7,
            (byte) 0xfd, (byte) 0x8c, (byte) 0x4e, (byte) 0x27, (byte) 0x9e, (byte) 0xb9,
            (byte) 0xef, (byte) 0x0f, (byte) 0xf7, (byte) 0x4a, (byte) 0xc2, (byte) 0xf4,
            (byte) 0x64, (byte) 0x6b, (byte) 0xe0, (byte) 0xfb, (byte) 0xe3, (byte) 0x45,
            (byte) 0xd5, (byte) 0x37, (byte) 0xa0, (byte) 0x2a, (byte) 0xc6, (byte) 0xf3,
            (byte) 0xf6, (byte) 0xcc, (byte) 0xb5, (byte) 0x94, (byte) 0xbf, (byte) 0x56,
            (byte) 0xa0, (byte) 0x61, (byte) 0x36, (byte) 0x88, (byte) 0x35, (byte) 0xd5,
            (byte) 0xa5, (byte) 0xad, (byte) 0x20, (byte) 0x48, (byte) 0xda, (byte) 0x70,
            (byte) 0x35, (byte) 0xd9, (byte) 0x75, (byte) 0x66, (byte) 0xa5, (byte) 0xac,
            (byte) 0x86, (byte) 0x7a, (byte) 0x75, (byte) 0x49, (byte) 0x88, (byte) 0x40,
            (byte) 0xce, (byte) 0xb0, (byte) 0x6f, (byte) 0x57, (byte) 0x15, (byte) 0x54,
            (byte) 0xd3, (byte) 0x2f, (byte) 0x11, (byte) 0x9b, (byte) 0xe3, (byte) 0x87,
            (byte) 0xc8, (byte) 0x8d, (byte) 0x98, (byte) 0xc6, (byte) 0xe0, (byte) 0xbc,
            (byte) 0x85, (byte) 0xb9, (byte) 0x04, (byte) 0x43, (byte) 0xa9, (byte) 0x41,
            (byte) 0xce, (byte) 0x42, (byte) 0x1a, (byte) 0x57, (byte) 0x10, (byte) 0xd8,
            (byte) 0xe4, (byte) 0x6a, (byte) 0x51, (byte) 0x10, (byte) 0x0a, (byte) 0xec,
            (byte) 0xe4, (byte) 0x57, (byte) 0xc7, (byte) 0xee, (byte) 0xe9, (byte) 0xd6,
            (byte) 0xcb, (byte) 0x3e, (byte) 0xba, (byte) 0xfa, (byte) 0xe9, (byte) 0x0e,
            (byte) 0xed, (byte) 0x87, (byte) 0x04, (byte) 0x9a, (byte) 0x48, (byte) 0xba,
            (byte) 0xaf, (byte) 0x08, (byte) 0xf5, (byte) 0x02, (byte) 0x81, (byte) 0xc1,
            (byte) 0x00, (byte) 0xcb, (byte) 0x63, (byte) 0xd6, (byte) 0x54, (byte) 0xb6,
            (byte) 0xf3, (byte) 0xf3, (byte) 0x8c, (byte) 0xf8, (byte) 0xd0, (byte) 0xd2,
            (byte) 0x84, (byte) 0xc1, (byte) 0xf5, (byte) 0x12, (byte) 0xe0, (byte) 0x02,
            (byte) 0x80, (byte) 0x42, (byte) 0x92, (byte) 0x4e, (byte) 0xa4, (byte) 0x5c,
            (byte) 0xa5, (byte) 0x64, (byte) 0xec, (byte) 0xb7, (byte) 0xdc, (byte) 0xe0,
            (byte) 0x2d, (byte) 0x5d, (byte) 0xac, (byte) 0x0e, (byte) 0x24, (byte) 0x48,
            (byte) 0x13, (byte) 0x05, (byte) 0xe8, (byte) 0xff, (byte) 0x96, (byte) 0x93,
            (byte) 0xba, (byte) 0x3c, (byte) 0x88, (byte) 0xcc, (byte) 0x80, (byte) 0xf9,
            (byte) 0xdb, (byte) 0xa8, (byte) 0x4d, (byte) 0x86, (byte) 0x47, (byte) 0xc8,
            (byte) 0xbf, (byte) 0x34, (byte) 0x2d, (byte) 0xda, (byte) 0xb6, (byte) 0x28,
            (byte) 0xf0, (byte) 0x1e, (byte) 0xd2, (byte) 0x46, (byte) 0x0d, (byte) 0x6f,
            (byte) 0x36, (byte) 0x8e, (byte) 0x84, (byte) 0xd8, (byte) 0xaf, (byte) 0xf7,
            (byte) 0x69, (byte) 0x23, (byte) 0x77, (byte) 0xfb, (byte) 0xc5, (byte) 0x04,
            (byte) 0x08, (byte) 0x18, (byte) 0xac, (byte) 0x85, (byte) 0x80, (byte) 0x87,
            (byte) 0x1c, (byte) 0xfe, (byte) 0x8e, (byte) 0x5d, (byte) 0x00, (byte) 0x7f,
            (byte) 0x5b, (byte) 0x33, (byte) 0xf5, (byte) 0xdf, (byte) 0x70, (byte) 0x81,
            (byte) 0xad, (byte) 0x81, (byte) 0xf4, (byte) 0x5a, (byte) 0x37, (byte) 0x8a,
            (byte) 0x79, (byte) 0x09, (byte) 0xc5, (byte) 0x55, (byte) 0xab, (byte) 0x58,
            (byte) 0x7c, (byte) 0x47, (byte) 0xca, (byte) 0xa5, (byte) 0x80, (byte) 0x49,
            (byte) 0x5f, (byte) 0x71, (byte) 0x83, (byte) 0xfb, (byte) 0x3b, (byte) 0x06,
            (byte) 0xec, (byte) 0x75, (byte) 0x23, (byte) 0xc4, (byte) 0x32, (byte) 0xc7,
            (byte) 0x18, (byte) 0xf6, (byte) 0x82, (byte) 0x95, (byte) 0x98, (byte) 0x39,
            (byte) 0xf7, (byte) 0x92, (byte) 0x31, (byte) 0xc0, (byte) 0x89, (byte) 0xba,
            (byte) 0xd4, (byte) 0xd4, (byte) 0x58, (byte) 0x4e, (byte) 0x38, (byte) 0x35,
            (byte) 0x10, (byte) 0xb9, (byte) 0xf1, (byte) 0x27, (byte) 0xdc, (byte) 0xff,
            (byte) 0xc7, (byte) 0xb2, (byte) 0xba, (byte) 0x1f, (byte) 0x27, (byte) 0xaf,
            (byte) 0x99, (byte) 0xd5, (byte) 0xb0, (byte) 0x39, (byte) 0xe7, (byte) 0x43,
            (byte) 0x88, (byte) 0xd3, (byte) 0xce, (byte) 0x38, (byte) 0xc2, (byte) 0x99,
            (byte) 0x43, (byte) 0xfc, (byte) 0x8a, (byte) 0xe3, (byte) 0x60, (byte) 0x0d,
            (byte) 0x0a, (byte) 0xb8, (byte) 0xc4, (byte) 0x29, (byte) 0xca, (byte) 0x0d,
            (byte) 0x30, (byte) 0xaf, (byte) 0xca, (byte) 0xd0, (byte) 0xaa, (byte) 0x67,
            (byte) 0xb1, (byte) 0xdd, (byte) 0xdb, (byte) 0x7a, (byte) 0x11, (byte) 0xad,
            (byte) 0xeb, (byte) 0x02, (byte) 0x81, (byte) 0xc0, (byte) 0x71, (byte) 0xb8,
            (byte) 0xcf, (byte) 0x72, (byte) 0x35, (byte) 0x67, (byte) 0xb5, (byte) 0x38,
            (byte) 0x8f, (byte) 0x16, (byte) 0xd3, (byte) 0x29, (byte) 0x82, (byte) 0x35,
            (byte) 0x21, (byte) 0xd4, (byte) 0x49, (byte) 0x20, (byte) 0x74, (byte) 0x2d,
            (byte) 0xc0, (byte) 0xa4, (byte) 0x44, (byte) 0xf5, (byte) 0xd8, (byte) 0xc9,
            (byte) 0xe9, (byte) 0x90, (byte) 0x1d, (byte) 0xde, (byte) 0x3a, (byte) 0xa6,
            (byte) 0xd7, (byte) 0xe5, (byte) 0xe8, (byte) 0x4e, (byte) 0x83, (byte) 0xd7,
            (byte) 0xe6, (byte) 0x2f, (byte) 0x92, (byte) 0x31, (byte) 0x21, (byte) 0x3f,
            (byte) 0xfa, (byte) 0xd2, (byte) 0x85, (byte) 0x92, (byte) 0x1f, (byte) 0xff,
            (byte) 0x61, (byte) 0x00, (byte) 0xf6, (byte) 0xda, (byte) 0x6e, (byte) 0xc6,
            (byte) 0x7f, (byte) 0x5a, (byte) 0x35, (byte) 0x79, (byte) 0xdc, (byte) 0xdc,
            (byte) 0xa3, (byte) 0x2e, (byte) 0x9f, (byte) 0x35, (byte) 0xd1, (byte) 0x5c,
            (byte) 0xda, (byte) 0xb9, (byte) 0xf7, (byte) 0x58, (byte) 0x7d, (byte) 0x4f,
            (byte) 0xb6, (byte) 0x13, (byte) 0xd7, (byte) 0x2c, (byte) 0x0a, (byte) 0xa8,
            (byte) 0x4d, (byte) 0xf2, (byte) 0xe4, (byte) 0x67, (byte) 0x4f, (byte) 0x8b,
            (byte) 0xa6, (byte) 0xca, (byte) 0x1a, (byte) 0xbb, (byte) 0x02, (byte) 0x63,
            (byte) 0x8f, (byte) 0xb7, (byte) 0x46, (byte) 0xec, (byte) 0x7a, (byte) 0x8a,
            (byte) 0x09, (byte) 0x0a, (byte) 0x45, (byte) 0x3a, (byte) 0x8d, (byte) 0xa8,
            (byte) 0x83, (byte) 0x4b, (byte) 0x0a, (byte) 0xdb, (byte) 0x4b, (byte) 0x99,
            (byte) 0xf3, (byte) 0x69, (byte) 0x95, (byte) 0xf0, (byte) 0xcf, (byte) 0xe9,
            (byte) 0xf7, (byte) 0x67, (byte) 0xc9, (byte) 0x45, (byte) 0x18, (byte) 0x2f,
            (byte) 0xf0, (byte) 0x5c, (byte) 0x90, (byte) 0xbd, (byte) 0xa6, (byte) 0x66,
            (byte) 0x8c, (byte) 0xfe, (byte) 0x60, (byte) 0x5d, (byte) 0x6c, (byte) 0x27,
            (byte) 0xec, (byte) 0xc1, (byte) 0x84, (byte) 0xb2, (byte) 0xa1, (byte) 0x97,
            (byte) 0x9e, (byte) 0x16, (byte) 0x29, (byte) 0xa7, (byte) 0xe0, (byte) 0x38,
            (byte) 0xa2, (byte) 0x36, (byte) 0x05, (byte) 0x5f, (byte) 0xda, (byte) 0x72,
            (byte) 0x1a, (byte) 0x5f, (byte) 0xa8, (byte) 0x7d, (byte) 0x41, (byte) 0x35,
            (byte) 0xf6, (byte) 0x4e, (byte) 0x0a, (byte) 0x88, (byte) 0x8e, (byte) 0x00,
            (byte) 0x98, (byte) 0xa6, (byte) 0xca, (byte) 0xc1, (byte) 0xdf, (byte) 0x72,
            (byte) 0x6c, (byte) 0xfe, (byte) 0x29, (byte) 0xbe, (byte) 0xa3, (byte) 0x9b,
            (byte) 0x0b, (byte) 0x5c, (byte) 0x0b, (byte) 0x9d, (byte) 0xa7, (byte) 0x71,
            (byte) 0xce, (byte) 0x04, (byte) 0xfa, (byte) 0xac, (byte) 0x01, (byte) 0x8d,
            (byte) 0x52, (byte) 0xa0, (byte) 0x3d, (byte) 0xdd, (byte) 0x02, (byte) 0x81,
            (byte) 0xc1, (byte) 0x00, (byte) 0xc1, (byte) 0xc0, (byte) 0x2e, (byte) 0xa9,
            (byte) 0xee, (byte) 0xca, (byte) 0xff, (byte) 0xe4, (byte) 0xf8, (byte) 0x15,
            (byte) 0xfd, (byte) 0xa5, (byte) 0x68, (byte) 0x1b, (byte) 0x2d, (byte) 0x4a,
            (byte) 0xe6, (byte) 0x37, (byte) 0x06, (byte) 0xb3, (byte) 0xd7, (byte) 0x64,
            (byte) 0xad, (byte) 0xb9, (byte) 0x05, (byte) 0x26, (byte) 0x97, (byte) 0x94,
            (byte) 0x3a, (byte) 0x9e, (byte) 0x1c, (byte) 0xd0, (byte) 0xcd, (byte) 0x7b,
            (byte) 0xf4, (byte) 0x88, (byte) 0xe2, (byte) 0xa5, (byte) 0x6d, (byte) 0xed,
            (byte) 0x24, (byte) 0x77, (byte) 0x52, (byte) 0x39, (byte) 0x43, (byte) 0x0f,
            (byte) 0x4e, (byte) 0x75, (byte) 0xd8, (byte) 0xa3, (byte) 0x59, (byte) 0x5a,
            (byte) 0xc2, (byte) 0xba, (byte) 0x9a, (byte) 0x5b, (byte) 0x60, (byte) 0x31,
            (byte) 0x0d, (byte) 0x58, (byte) 0x89, (byte) 0x13, (byte) 0xe8, (byte) 0x95,
            (byte) 0xdd, (byte) 0xae, (byte) 0xcc, (byte) 0x1f, (byte) 0x73, (byte) 0x48,
            (byte) 0x55, (byte) 0xd8, (byte) 0xfb, (byte) 0x67, (byte) 0xce, (byte) 0x18,
            (byte) 0x85, (byte) 0x59, (byte) 0xad, (byte) 0x1f, (byte) 0x93, (byte) 0xe1,
            (byte) 0xb7, (byte) 0x54, (byte) 0x80, (byte) 0x8e, (byte) 0x5f, (byte) 0xbc,
            (byte) 0x1c, (byte) 0x96, (byte) 0x66, (byte) 0x2e, (byte) 0x40, (byte) 0x17,
            (byte) 0x2e, (byte) 0x01, (byte) 0x7a, (byte) 0x7d, (byte) 0xaa, (byte) 0xff,
            (byte) 0xa3, (byte) 0xd2, (byte) 0xdf, (byte) 0xe2, (byte) 0xf3, (byte) 0x54,
            (byte) 0x51, (byte) 0xeb, (byte) 0xba, (byte) 0x7c, (byte) 0x2a, (byte) 0x22,
            (byte) 0xc6, (byte) 0x42, (byte) 0xbc, (byte) 0xa1, (byte) 0x6c, (byte) 0xcf,
            (byte) 0x73, (byte) 0x2e, (byte) 0x07, (byte) 0xfc, (byte) 0xf5, (byte) 0x67,
            (byte) 0x25, (byte) 0xd0, (byte) 0xfa, (byte) 0xeb, (byte) 0xb4, (byte) 0xd4,
            (byte) 0x19, (byte) 0xcc, (byte) 0x64, (byte) 0xa1, (byte) 0x2e, (byte) 0x78,
            (byte) 0x45, (byte) 0xd9, (byte) 0x7f, (byte) 0x1b, (byte) 0x4c, (byte) 0x10,
            (byte) 0x31, (byte) 0x44, (byte) 0xe8, (byte) 0xcc, (byte) 0xf9, (byte) 0x1b,
            (byte) 0x87, (byte) 0x31, (byte) 0xd6, (byte) 0x69, (byte) 0x85, (byte) 0x4a,
            (byte) 0x49, (byte) 0xf6, (byte) 0xb2, (byte) 0xe0, (byte) 0xb8, (byte) 0x98,
            (byte) 0x3c, (byte) 0xf6, (byte) 0x78, (byte) 0x46, (byte) 0xc8, (byte) 0x3d,
            (byte) 0x60, (byte) 0xc1, (byte) 0xaa, (byte) 0x2f, (byte) 0x28, (byte) 0xa1,
            (byte) 0x14, (byte) 0x6b, (byte) 0x75, (byte) 0x4d, (byte) 0xb1, (byte) 0x3d,
            (byte) 0x80, (byte) 0x49, (byte) 0x33, (byte) 0xfd, (byte) 0x71, (byte) 0xc0,
            (byte) 0x13, (byte) 0x1e, (byte) 0x16, (byte) 0x69, (byte) 0x80, (byte) 0xa4,
            (byte) 0x9c, (byte) 0xd7, (byte) 0x02, (byte) 0x81, (byte) 0xc1, (byte) 0x00,
            (byte) 0x8c, (byte) 0x33, (byte) 0x2d, (byte) 0xd9, (byte) 0xf3, (byte) 0x42,
            (byte) 0x4d, (byte) 0xca, (byte) 0x5e, (byte) 0x60, (byte) 0x14, (byte) 0x10,
            (byte) 0xf6, (byte) 0xf3, (byte) 0x71, (byte) 0x15, (byte) 0x88, (byte) 0x54,
            (byte) 0x84, (byte) 0x21, (byte) 0x04, (byte) 0xb1, (byte) 0xaf, (byte) 0x02,
            (byte) 0x11, (byte) 0x7f, (byte) 0x42, (byte) 0x3e, (byte) 0x86, (byte) 0xcb,
            (byte) 0x6c, (byte) 0xf5, (byte) 0x57, (byte) 0x78, (byte) 0x4a, (byte) 0x03,
            (byte) 0x9b, (byte) 0x80, (byte) 0xc2, (byte) 0x04, (byte) 0x3a, (byte) 0x6b,
            (byte) 0xb3, (byte) 0x30, (byte) 0x31, (byte) 0x7e, (byte) 0xc3, (byte) 0x89,
            (byte) 0x09, (byte) 0x4e, (byte) 0x86, (byte) 0x59, (byte) 0x41, (byte) 0xb5,
            (byte) 0xae, (byte) 0xd5, (byte) 0xc6, (byte) 0x38, (byte) 0xbc, (byte) 0xd7,
            (byte) 0xd7, (byte) 0x8e, (byte) 0xa3, (byte) 0x1a, (byte) 0xde, (byte) 0x32,
            (byte) 0xad, (byte) 0x8d, (byte) 0x15, (byte) 0x81, (byte) 0xfe, (byte) 0xac,
            (byte) 0xbd, (byte) 0xd0, (byte) 0xca, (byte) 0xbc, (byte) 0xd8, (byte) 0x6a,
            (byte) 0xe1, (byte) 0xfe, (byte) 0xda, (byte) 0xc4, (byte) 0xd8, (byte) 0x62,
            (byte) 0x71, (byte) 0x20, (byte) 0xa3, (byte) 0xd3, (byte) 0x06, (byte) 0x11,
            (byte) 0xa9, (byte) 0x53, (byte) 0x7a, (byte) 0x44, (byte) 0x89, (byte) 0x3d,
            (byte) 0x28, (byte) 0x5e, (byte) 0x7d, (byte) 0xf0, (byte) 0x60, (byte) 0xeb,
            (byte) 0xb5, (byte) 0xdf, (byte) 0xed, (byte) 0x4f, (byte) 0x6d, (byte) 0x05,
            (byte) 0x59, (byte) 0x06, (byte) 0xb0, (byte) 0x62, (byte) 0x50, (byte) 0x1c,
            (byte) 0xb7, (byte) 0x2c, (byte) 0x44, (byte) 0xa4, (byte) 0x49, (byte) 0xf8,
            (byte) 0x4f, (byte) 0x4b, (byte) 0xab, (byte) 0x71, (byte) 0x5b, (byte) 0xcb,
            (byte) 0x31, (byte) 0x10, (byte) 0x41, (byte) 0xe0, (byte) 0x1a, (byte) 0x15,
            (byte) 0xdc, (byte) 0x4c, (byte) 0x5d, (byte) 0x4f, (byte) 0x62, (byte) 0x83,
            (byte) 0xa4, (byte) 0x80, (byte) 0x06, (byte) 0x36, (byte) 0xba, (byte) 0xc9,
            (byte) 0xe2, (byte) 0xa4, (byte) 0x11, (byte) 0x98, (byte) 0x6b, (byte) 0x4c,
            (byte) 0xe9, (byte) 0x90, (byte) 0x55, (byte) 0x18, (byte) 0xde, (byte) 0xe1,
            (byte) 0x42, (byte) 0x38, (byte) 0x28, (byte) 0xa3, (byte) 0x54, (byte) 0x56,
            (byte) 0x31, (byte) 0xaf, (byte) 0x5a, (byte) 0xd6, (byte) 0xf0, (byte) 0x26,
            (byte) 0xe0, (byte) 0x7a, (byte) 0xd9, (byte) 0x6c, (byte) 0x64, (byte) 0xca,
            (byte) 0x5d, (byte) 0x6d, (byte) 0x3d, (byte) 0x9a, (byte) 0xfe, (byte) 0x36,
            (byte) 0x93, (byte) 0x9e, (byte) 0x62, (byte) 0x94, (byte) 0xc6, (byte) 0x07,
            (byte) 0x83, (byte) 0x96, (byte) 0xd6, (byte) 0x27, (byte) 0xa6, (byte) 0xd8
    };
    private static final PrivateKey CLIENT_SUITE_B_RSA3072_KEY =
            loadPrivateKey(""RSA"", CLIENT_SUITE_B_RSA3072_KEY_DATA);

    private static final String CLIENT_SUITE_B_ECDSA_CERT_STRING =
            ""-----BEGIN CERTIFICATE-----\n""
                    + ""MIIB9zCCAX4CFDpfSZh3AH07BEfGWuMDa7Ynz6y+MAoGCCqGSM49BAMDMF4xCzAJ\n""
                    + ""BgNVBAYTAlVTMQswCQYDVQQIDAJDQTEMMAoGA1UEBwwDTVRWMRAwDgYDVQQKDAdB\n""
                    + ""bmRyb2lkMQ4wDAYDVQQLDAVXaS1GaTESMBAGA1UEAwwJdW5pdGVzdENBMB4XDTIw\n""
                    + ""MDcyMTAyMjk1MFoXDTMwMDUzMDAyMjk1MFowYjELMAkGA1UEBhMCVVMxCzAJBgNV\n""
                    + ""BAgMAkNBMQwwCgYDVQQHDANNVFYxEDAOBgNVBAoMB0FuZHJvaWQxDjAMBgNVBAsM\n""
                    + ""BVdpLUZpMRYwFAYDVQQDDA11bml0ZXN0Q2xpZW50MHYwEAYHKoZIzj0CAQYFK4EE\n""
                    + ""ACIDYgAEhxhVJ7dcSqrto0X+dgRxtd8BWG8cWmPjBji3MIxDLfpcMDoIB84ae1Ew\n""
                    + ""gJn4YUYHrWsUDiVNihv8j7a/Ol1qcIY2ybH7tbezefLmagqA4vXEUXZXoUyL4ZNC\n""
                    + ""DWcdw6LrMAoGCCqGSM49BAMDA2cAMGQCMH4aP73HrriRUJRguiuRic+X4Cqj/7YQ\n""
                    + ""ueJmP87KF92/thhoQ9OrRo8uJITPmNDswwIwP2Q1AZCSL4BI9dYrqu07Ar+pSkXE\n""
                    + ""R7oOqGdZR+d/MvXcFSrbIaLKEoHXmQamIHLe\n""
                    + ""-----END CERTIFICATE-----\n"";
    private static final X509Certificate CLIENT_SUITE_B_ECDSA_CERT =
            loadCertificate(CLIENT_SUITE_B_ECDSA_CERT_STRING);

    private static final byte[] CLIENT_SUITE_B_ECC_KEY_DATA = new byte[]{
            (byte) 0x30, (byte) 0x81, (byte) 0xb6, (byte) 0x02, (byte) 0x01, (byte) 0x00,
            (byte) 0x30, (byte) 0x10, (byte) 0x06, (byte) 0x07, (byte) 0x2a, (byte) 0x86,
            (byte) 0x48, (byte) 0xce, (byte) 0x3d, (byte) 0x02, (byte) 0x01, (byte) 0x06,
            (byte) 0x05, (byte) 0x2b, (byte) 0x81, (byte) 0x04, (byte) 0x00, (byte) 0x22,
            (byte) 0x04, (byte) 0x81, (byte) 0x9e, (byte) 0x30, (byte) 0x81, (byte) 0x9b,
            (byte) 0x02, (byte) 0x01, (byte) 0x01, (byte) 0x04, (byte) 0x30, (byte) 0xea,
            (byte) 0x6c, (byte) 0x4b, (byte) 0x6d, (byte) 0x43, (byte) 0xf9, (byte) 0x6c,
            (byte) 0x91, (byte) 0xdc, (byte) 0x2d, (byte) 0x6e, (byte) 0x87, (byte) 0x4f,
            (byte) 0x0a, (byte) 0x0b, (byte) 0x97, (byte) 0x25, (byte) 0x1c, (byte) 0x79,
            (byte) 0xa2, (byte) 0x07, (byte) 0xdc, (byte) 0x94, (byte) 0xc2, (byte) 0xee,
            (byte) 0x64, (byte) 0x51, (byte) 0x6d, (byte) 0x4e, (byte) 0x35, (byte) 0x1c,
            (byte) 0x22, (byte) 0x2f, (byte) 0xc0, (byte) 0xea, (byte) 0x09, (byte) 0x47,
            (byte) 0x3e, (byte) 0xb9, (byte) 0xb6, (byte) 0xb8, (byte) 0x83, (byte) 0x9e,
            (byte) 0xed, (byte) 0x59, (byte) 0xe5, (byte) 0xe7, (byte) 0x0f, (byte) 0xa1,
            (byte) 0x64, (byte) 0x03, (byte) 0x62, (byte) 0x00, (byte) 0x04, (byte) 0x87,
            (byte) 0x18, (byte) 0x55, (byte) 0x27, (byte) 0xb7, (byte) 0x5c, (byte) 0x4a,
            (byte) 0xaa, (byte) 0xed, (byte) 0xa3, (byte) 0x45, (byte) 0xfe, (byte) 0x76,
            (byte) 0x04, (byte) 0x71, (byte) 0xb5, (byte) 0xdf, (byte) 0x01, (byte) 0x58,
            (byte) 0x6f, (byte) 0x1c, (byte) 0x5a, (byte) 0x63, (byte) 0xe3, (byte) 0x06,
            (byte) 0x38, (byte) 0xb7, (byte) 0x30, (byte) 0x8c, (byte) 0x43, (byte) 0x2d,
            (byte) 0xfa, (byte) 0x5c, (byte) 0x30, (byte) 0x3a, (byte) 0x08, (byte) 0x07,
            (byte) 0xce, (byte) 0x1a, (byte) 0x7b, (byte) 0x51, (byte) 0x30, (byte) 0x80,
            (byte) 0x99, (byte) 0xf8, (byte) 0x61, (byte) 0x46, (byte) 0x07, (byte) 0xad,
            (byte) 0x6b, (byte) 0x14, (byte) 0x0e, (byte) 0x25, (byte) 0x4d, (byte) 0x8a,
            (byte) 0x1b, (byte) 0xfc, (byte) 0x8f, (byte) 0xb6, (byte) 0xbf, (byte) 0x3a,
            (byte) 0x5d, (byte) 0x6a, (byte) 0x70, (byte) 0x86, (byte) 0x36, (byte) 0xc9,
            (byte) 0xb1, (byte) 0xfb, (byte) 0xb5, (byte) 0xb7, (byte) 0xb3, (byte) 0x79,
            (byte) 0xf2, (byte) 0xe6, (byte) 0x6a, (byte) 0x0a, (byte) 0x80, (byte) 0xe2,
            (byte) 0xf5, (byte) 0xc4, (byte) 0x51, (byte) 0x76, (byte) 0x57, (byte) 0xa1,
            (byte) 0x4c, (byte) 0x8b, (byte) 0xe1, (byte) 0x93, (byte) 0x42, (byte) 0x0d,
            (byte) 0x67, (byte) 0x1d, (byte) 0xc3, (byte) 0xa2, (byte) 0xeb
    };
    private static final PrivateKey CLIENT_SUITE_B_ECC_KEY =
            loadPrivateKey(""EC"", CLIENT_SUITE_B_ECC_KEY_DATA);

    private static X509Certificate loadCertificate(String blob) {
        try {
            final CertificateFactory certFactory = CertificateFactory.getInstance(""X.509"");
            InputStream stream = new ByteArrayInputStream(blob.getBytes(StandardCharsets.UTF_8));

            return (X509Certificate) certFactory.generateCertificate(stream);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    private static PrivateKey loadPrivateKey(String algorithm, byte[] fakeKey) {
        try {
            KeyFactory kf = KeyFactory.getInstance(algorithm);
            return kf.generatePrivate(new PKCS8EncodedKeySpec(fakeKey));
        } catch (InvalidKeySpecException | NoSuchAlgorithmException e) {
            return null;
        }
    }

    private WifiNetworkSuggestion.Builder createBuilderWithCommonParams() {
        return createBuilderWithCommonParams(false);
    }

    private WifiNetworkSuggestion.Builder createBuilderWithCommonParams(boolean isPasspoint) {
        WifiNetworkSuggestion.Builder builder = new WifiNetworkSuggestion.Builder();
        if (!isPasspoint) {
            builder.setSsid(TEST_SSID);
            builder.setBssid(MacAddress.fromString(TEST_BSSID));
            builder.setIsEnhancedOpen(false);
            builder.setIsHiddenSsid(true);
        }
        builder.setPriority(TEST_PRIORITY);
        builder.setIsAppInteractionRequired(true);
        builder.setIsUserInteractionRequired(true);
        builder.setIsMetered(true);
        builder.setCarrierId(TelephonyManager.UNKNOWN_CARRIER_ID);
        builder.setCredentialSharedWithUser(true);
        builder.setIsInitialAutojoinEnabled(true);
        builder.setUntrusted(false);
        if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
            builder.setOemPaid(false);
            builder.setOemPrivate(false);
            builder.setSubscriptionId(TEST_SUB_ID);
        }
        if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(sContext)) {
            builder.setPriorityGroup(TEST_PRIORITY_GROUP);
        }
        return builder;
    }

    private void validateCommonParams(WifiNetworkSuggestion suggestion) {
        validateCommonParams(suggestion, false);
    }

    private void validateCommonParams(WifiNetworkSuggestion suggestion, boolean isPasspoint) {
        assertNotNull(suggestion);
        assertNotNull(suggestion.getWifiConfiguration());
        if (!isPasspoint) {
            assertEquals(TEST_SSID, suggestion.getSsid());
            assertEquals(TEST_BSSID, suggestion.getBssid().toString());
            assertFalse(suggestion.isEnhancedOpen());
            assertTrue(suggestion.isHiddenSsid());
        }
        assertEquals(TEST_PRIORITY, suggestion.getPriority());
        assertTrue(suggestion.isAppInteractionRequired());
        assertTrue(suggestion.isUserInteractionRequired());
        assertTrue(suggestion.isMetered());
        assertTrue(suggestion.isCredentialSharedWithUser());
        assertTrue(suggestion.isInitialAutojoinEnabled());
        assertFalse(suggestion.isUntrusted());
        if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
            assertFalse(suggestion.isOemPaid());
            assertFalse(suggestion.isOemPrivate());
            assertEquals(TEST_SUB_ID, suggestion.getSubscriptionId());
        }
        if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(sContext)) {
            assertEquals(TEST_PRIORITY_GROUP, suggestion.getPriorityGroup());
            assertEquals(TelephonyManager.UNKNOWN_CARRIER_ID, suggestion.getCarrierId());
        }
    }

    /**
     * Tests {@link android.net.wifi.WifiNetworkSuggestion.Builder} class.
     */"	""	""	"passpoint wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"testBuilderWithWpa2Passphrase"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	"public void testBuilderWithWpa2Passphrase() throws Exception {
        WifiNetworkSuggestion suggestion =
                createBuilderWithCommonParams()
                .setWpa2Passphrase(TEST_PASSPHRASE)
                .build();
        validateCommonParams(suggestion);
        assertEquals(TEST_PASSPHRASE, suggestion.getPassphrase());
        assertNull(suggestion.getEnterpriseConfig());
        assertNull(suggestion.getPasspointConfig());
    }

    /**
     * Tests {@link android.net.wifi.WifiNetworkSuggestion.Builder} class.
     */"	""	""	"passpoint wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"testBuilderWithWpa3Passphrase"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	"public void testBuilderWithWpa3Passphrase() throws Exception {
        WifiNetworkSuggestion suggestion =
                createBuilderWithCommonParams()
                        .setWpa3Passphrase(TEST_PASSPHRASE)
                        .build();
        validateCommonParams(suggestion);
        assertEquals(TEST_PASSPHRASE, suggestion.getPassphrase());
        assertNull(suggestion.getEnterpriseConfig());
        assertNull(suggestion.getPasspointConfig());
    }

    /**
     * Tests {@link android.net.wifi.WifiNetworkSuggestion.Builder} class.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"passpoint wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"testBuilderWithWpa3SaeH2eOnlyMode"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	"public void testBuilderWithWpa3SaeH2eOnlyMode() throws Exception {
        WifiNetworkSuggestion suggestion =
                createBuilderWithCommonParams()
                        .setWpa3Passphrase(TEST_PASSPHRASE)
                        .setIsWpa3SaeH2eOnlyModeEnabled(true)
                        .build();
        validateCommonParams(suggestion);
        assertEquals(TEST_PASSPHRASE, suggestion.getPassphrase());
        assertNull(suggestion.getEnterpriseConfig());
        assertNull(suggestion.getPasspointConfig());
    }

    /**
     * Tests {@link android.net.wifi.WifiNetworkSuggestion.Builder} class.
     */"	""	""	"passpoint wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"testBuilderWithWapiPassphrase"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	"public void testBuilderWithWapiPassphrase() throws Exception {
        WifiNetworkSuggestion suggestion =
                createBuilderWithCommonParams()
                        .setWapiPassphrase(TEST_PASSPHRASE)
                        .build();
        validateCommonParams(suggestion);
        assertEquals(TEST_PASSPHRASE, suggestion.getPassphrase());
        assertNull(suggestion.getEnterpriseConfig());
        assertNull(suggestion.getPasspointConfig());
    }

    private static WifiEnterpriseConfig createEnterpriseConfig() {
        WifiEnterpriseConfig config = new WifiEnterpriseConfig();
        config.setEapMethod(AKA);
        return config;
    }

    /**
     * Tests {@link android.net.wifi.WifiNetworkSuggestion.Builder} class.
     */"	""	""	"passpoint wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"testBuilderWithWpa2Enterprise"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	"public void testBuilderWithWpa2Enterprise() throws Exception {
        WifiEnterpriseConfig enterpriseConfig = createEnterpriseConfig();
        WifiNetworkSuggestion suggestion =
                createBuilderWithCommonParams()
                        .setWpa2EnterpriseConfig(enterpriseConfig)
                        .build();
        validateCommonParams(suggestion);
        assertNull(suggestion.getPassphrase());
        assertNotNull(suggestion.getEnterpriseConfig());
        assertEquals(enterpriseConfig.getEapMethod(),
                suggestion.getEnterpriseConfig().getEapMethod());
        assertNull(suggestion.getPasspointConfig());
    }

    /**
     * Tests {@link android.net.wifi.WifiNetworkSuggestion.Builder} class.
     */"	""	""	"passpoint wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"testBuilderWithWpa3Enterprise"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	"public void testBuilderWithWpa3Enterprise() throws Exception {
        WifiEnterpriseConfig enterpriseConfig = createEnterpriseConfig();
        WifiNetworkSuggestion suggestion =
                createBuilderWithCommonParams()
                        .setWpa3EnterpriseConfig(enterpriseConfig)
                        .build();
        validateCommonParams(suggestion);
        assertNull(suggestion.getPassphrase());
        assertNotNull(suggestion.getEnterpriseConfig());
        assertEquals(enterpriseConfig.getEapMethod(),
                suggestion.getEnterpriseConfig().getEapMethod());
        assertNull(suggestion.getPasspointConfig());
    }

    /**
     * Tests {@link android.net.wifi.WifiNetworkSuggestion.Builder} class.
     */"	""	""	"passpoint wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"testBuilderWithWpa3EnterpriseWithStandardApi"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	"public void testBuilderWithWpa3EnterpriseWithStandardApi() throws Exception {
        if (!WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(sContext)) {
            // Skip the test if wifi module version is older than S.
            return;
        }
        WifiEnterpriseConfig enterpriseConfig = createEnterpriseConfig();
        WifiNetworkSuggestion suggestion =
                createBuilderWithCommonParams()
                        .setWpa3EnterpriseStandardModeConfig(enterpriseConfig)
                        .build();
        validateCommonParams(suggestion);
        assertNull(suggestion.getPassphrase());
        assertNotNull(suggestion.getEnterpriseConfig());
        assertEquals(enterpriseConfig.getEapMethod(),
                suggestion.getEnterpriseConfig().getEapMethod());
        assertNull(suggestion.getPasspointConfig());
    }

    /**
     * Tests {@link android.net.wifi.WifiNetworkSuggestion.Builder} class.
     */"	""	""	"passpoint wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"testBuilderWithWpa3EnterpriseWithSuiteBRsaCerts"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	"public void testBuilderWithWpa3EnterpriseWithSuiteBRsaCerts() throws Exception {
        WifiEnterpriseConfig enterpriseConfig = new WifiEnterpriseConfig();
        enterpriseConfig.setEapMethod(WifiEnterpriseConfig.Eap.TLS);
        enterpriseConfig.setCaCertificate(CA_SUITE_B_RSA3072_CERT);
        enterpriseConfig.setClientKeyEntryWithCertificateChain(CLIENT_SUITE_B_RSA3072_KEY,
                new X509Certificate[] {CLIENT_SUITE_B_RSA3072_CERT});
        enterpriseConfig.setAltSubjectMatch(""domain.com"");
        WifiNetworkSuggestion suggestion =
                createBuilderWithCommonParams()
                        .setWpa3EnterpriseConfig(enterpriseConfig)
                        .build();
        validateCommonParams(suggestion);
        assertNull(suggestion.getPassphrase());
        assertNotNull(suggestion.getEnterpriseConfig());
        assertEquals(enterpriseConfig.getEapMethod(),
                suggestion.getEnterpriseConfig().getEapMethod());
        assertNull(suggestion.getPasspointConfig());
    }

    /**
     * Tests {@link android.net.wifi.WifiNetworkSuggestion.Builder} class.
     */"	""	""	"passpoint wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"testBuilderWithWpa3EnterpriseWithSuiteBEccCerts"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	"public void testBuilderWithWpa3EnterpriseWithSuiteBEccCerts() throws Exception {
        WifiEnterpriseConfig enterpriseConfig = new WifiEnterpriseConfig();
        enterpriseConfig.setEapMethod(WifiEnterpriseConfig.Eap.TLS);
        enterpriseConfig.setCaCertificate(CA_SUITE_B_ECDSA_CERT);
        enterpriseConfig.setClientKeyEntryWithCertificateChain(CLIENT_SUITE_B_ECC_KEY,
                new X509Certificate[] {CLIENT_SUITE_B_ECDSA_CERT});
        enterpriseConfig.setAltSubjectMatch(""domain.com"");
        WifiNetworkSuggestion suggestion =
                createBuilderWithCommonParams()
                        .setWpa3EnterpriseConfig(enterpriseConfig)
                        .build();
        validateCommonParams(suggestion);
        assertNull(suggestion.getPassphrase());
        assertNotNull(suggestion.getEnterpriseConfig());
        assertEquals(enterpriseConfig.getEapMethod(),
                suggestion.getEnterpriseConfig().getEapMethod());
        assertNull(suggestion.getPasspointConfig());
    }

    /**
     * Tests {@link android.net.wifi.WifiNetworkSuggestion.Builder} class.
     */"	""	""	"passpoint wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"testBuilderWithWpa3Enterprise192bitWithSuiteBRsaCerts"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	"public void testBuilderWithWpa3Enterprise192bitWithSuiteBRsaCerts() throws Exception {
        WifiEnterpriseConfig enterpriseConfig = new WifiEnterpriseConfig();
        enterpriseConfig.setEapMethod(WifiEnterpriseConfig.Eap.TLS);
        enterpriseConfig.setCaCertificate(CA_SUITE_B_RSA3072_CERT);
        enterpriseConfig.setClientKeyEntryWithCertificateChain(CLIENT_SUITE_B_RSA3072_KEY,
                new X509Certificate[] {CLIENT_SUITE_B_RSA3072_CERT});
        enterpriseConfig.setAltSubjectMatch(""domain.com"");
        WifiNetworkSuggestion suggestion =
                createBuilderWithCommonParams()
                        .setWpa3EnterpriseConfig(enterpriseConfig)
                        .build();
        validateCommonParams(suggestion);
        assertNull(suggestion.getPassphrase());
        assertNotNull(suggestion.getEnterpriseConfig());
        assertEquals(enterpriseConfig.getEapMethod(),
                suggestion.getEnterpriseConfig().getEapMethod());
        assertNull(suggestion.getPasspointConfig());
    }

    /**
     * Tests {@link android.net.wifi.WifiNetworkSuggestion.Builder} class.
     */"	""	""	"passpoint wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"testBuilderWithWpa3Enterprise192bitWithSuiteBEccCerts"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	"public void testBuilderWithWpa3Enterprise192bitWithSuiteBEccCerts() throws Exception {
        if (!WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(sContext)) {
            // Skip the test if wifi module version is older than S.
            return;
        }
        WifiEnterpriseConfig enterpriseConfig = new WifiEnterpriseConfig();
        enterpriseConfig.setEapMethod(WifiEnterpriseConfig.Eap.TLS);
        enterpriseConfig.setCaCertificate(CA_SUITE_B_ECDSA_CERT);
        enterpriseConfig.setClientKeyEntryWithCertificateChain(CLIENT_SUITE_B_ECC_KEY,
                new X509Certificate[] {CLIENT_SUITE_B_ECDSA_CERT});
        enterpriseConfig.setAltSubjectMatch(""domain.com"");
        WifiNetworkSuggestion suggestion =
                createBuilderWithCommonParams()
                        .setWpa3Enterprise192BitModeConfig(enterpriseConfig)
                        .build();
        validateCommonParams(suggestion);
        assertNull(suggestion.getPassphrase());
        assertNotNull(suggestion.getEnterpriseConfig());
        assertEquals(enterpriseConfig.getEapMethod(),
                suggestion.getEnterpriseConfig().getEapMethod());
        assertNull(suggestion.getPasspointConfig());
    }

    /**
     * Tests {@link android.net.wifi.WifiNetworkSuggestion.Builder} class.
     */"	""	""	"passpoint wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"testBuilderWithWapiEnterprise"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	"public void testBuilderWithWapiEnterprise() throws Exception {
        WifiEnterpriseConfig enterpriseConfig = new WifiEnterpriseConfig();
        enterpriseConfig.setEapMethod(WAPI_CERT);
        WifiNetworkSuggestion suggestion =
                createBuilderWithCommonParams()
                        .setWapiEnterpriseConfig(enterpriseConfig)
                        .build();
        validateCommonParams(suggestion);
        assertNull(suggestion.getPassphrase());
        assertNotNull(suggestion.getEnterpriseConfig());
        assertEquals(enterpriseConfig.getEapMethod(),
                suggestion.getEnterpriseConfig().getEapMethod());
        assertNull(suggestion.getPasspointConfig());
    }

    /**
     * Helper function for creating a {@link PasspointConfiguration} for testing.
     *
     * @return {@link PasspointConfiguration}
     */
    private static PasspointConfiguration createPasspointConfig() {
        HomeSp homeSp = new HomeSp();
        homeSp.setFqdn(""fqdn"");
        homeSp.setFriendlyName(""friendly name"");
        homeSp.setRoamingConsortiumOis(new long[] {0x55, 0x66});
        Credential cred = new Credential();
        cred.setRealm(""realm"");
        cred.setUserCredential(null);
        cred.setCertCredential(null);
        cred.setSimCredential(new Credential.SimCredential());
        cred.getSimCredential().setImsi(""1234*"");
        cred.getSimCredential().setEapType(23); // EAP-AKA
        cred.setCaCertificate(null);
        cred.setClientCertificateChain(null);
        cred.setClientPrivateKey(null);
        PasspointConfiguration config = new PasspointConfiguration();
        config.setHomeSp(homeSp);
        config.setCredential(cred);
        return config;
    }

    /**
     * Tests {@link android.net.wifi.WifiNetworkSuggestion.Builder} class.
     */"	""	""	"passpoint wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"testBuilderWithPasspointConfig"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	"public void testBuilderWithPasspointConfig() throws Exception {
        PasspointConfiguration passpointConfig = createPasspointConfig();
        WifiNetworkSuggestion suggestion =
                createBuilderWithCommonParams(true)
                        .setPasspointConfig(passpointConfig)
                        .build();
        validateCommonParams(suggestion, true);
        assertNull(suggestion.getPassphrase());
        assertNull(suggestion.getEnterpriseConfig());
        assertEquals(passpointConfig.getUniqueId(), suggestion.getPasspointConfig().getUniqueId());
    }

    /**
     * Tests {@link android.net.wifi.WifiNetworkSuggestion.Builder} class.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"passpoint wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"testBuilderWithCarrierMergedNetwork"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	"public void testBuilderWithCarrierMergedNetwork() throws Exception {
        WifiEnterpriseConfig enterpriseConfig = new WifiEnterpriseConfig();
        enterpriseConfig.setEapMethod(WifiEnterpriseConfig.Eap.TLS);
        enterpriseConfig.setCaCertificate(CA_SUITE_B_ECDSA_CERT);
        enterpriseConfig.setClientKeyEntryWithCertificateChain(CLIENT_SUITE_B_ECC_KEY,
                new X509Certificate[] {CLIENT_SUITE_B_ECDSA_CERT});
        enterpriseConfig.setAltSubjectMatch(""domain.com"");
        WifiNetworkSuggestion suggestion =
                createBuilderWithCommonParams()
                        .setWpa3Enterprise192BitModeConfig(enterpriseConfig)
                        .setCarrierMerged(true)
                        .build();
        validateCommonParams(suggestion);
        assertTrue(suggestion.isCarrierMerged());
    }

    /**
     * Tests {@link android.net.wifi.WifiNetworkSuggestion.Builder} class with non enterprise
     * network will fail.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"testBuilderWithCarrierMergedNetworkWithNonEnterpriseNetwork"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	"public void testBuilderWithCarrierMergedNetworkWithNonEnterpriseNetwork() throws Exception {
        try {
            createBuilderWithCommonParams()
                    .setWpa2Passphrase(TEST_PASSPHRASE)
                    .setCarrierMerged(true)
                    .build();
        } catch (IllegalStateException e) {
            return;
        }
        fail(""Did not receive expected IllegalStateException when tried to build a carrier merged ""
                + ""network suggestion with non enterprise config"");
    }

    /**
     * Tests {@link android.net.wifi.WifiNetworkSuggestion.Builder} class with unmetered network
     * will fail.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"testBuilderWithCarrierMergedNetworkWithUnmeteredNetwork"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	"public void testBuilderWithCarrierMergedNetworkWithUnmeteredNetwork() throws Exception {
        WifiEnterpriseConfig enterpriseConfig = new WifiEnterpriseConfig();
        enterpriseConfig.setEapMethod(WifiEnterpriseConfig.Eap.TLS);
        enterpriseConfig.setCaCertificate(CA_SUITE_B_ECDSA_CERT);
        enterpriseConfig.setClientKeyEntryWithCertificateChain(CLIENT_SUITE_B_ECC_KEY,
                new X509Certificate[] {CLIENT_SUITE_B_ECDSA_CERT});
        enterpriseConfig.setAltSubjectMatch(""domain.com"");
        try {
            createBuilderWithCommonParams()
                    .setWpa3Enterprise192BitModeConfig(enterpriseConfig)
                    .setCarrierMerged(true)
                    .setIsMetered(false)
                    .build();
        } catch (IllegalStateException e) {
            return;
        }
        fail(""Did not receive expected IllegalStateException when tried to build a carrier merged ""
                + ""network suggestion with unmetered config"");
    }

    /**
     * Connect to a network using suggestion API.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"testConnectToSuggestion"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	"public void testConnectToSuggestion() throws Exception {
        assertNotNull(sTestNetwork);
        WifiNetworkSuggestion suggestion =
                TestHelper.createSuggestionBuilderWithCredentialFromSavedNetworkWithBssid(
                        sTestNetwork)
                        .build();
        sNsNetworkCallback = sTestHelper.testConnectionFlowWithSuggestion(
                sTestNetwork, suggestion, mExecutorService,
                Set.of() /* restrictedNetworkCapability */);
    }

    /**
     * Connect to a network using restricted suggestion API.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"testConnectToOemPaidSuggestion"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	"public void testConnectToOemPaidSuggestion() throws Exception {
        assertNotNull(sTestNetwork);
        WifiNetworkSuggestion suggestion =
                TestHelper.createSuggestionBuilderWithCredentialFromSavedNetworkWithBssid(
                        sTestNetwork)
                        .setOemPaid(true)
                        .build();
        sNsNetworkCallback = sTestHelper.testConnectionFlowWithSuggestion(
                sTestNetwork, suggestion, mExecutorService, Set.of(NET_CAPABILITY_OEM_PAID));
    }

    /**
     * Connect to a network using restricted suggestion API.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"testConnectToOemPaidAndOemPrivateSuggestion"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	"public void testConnectToOemPaidAndOemPrivateSuggestion() throws Exception {
        assertNotNull(sTestNetwork);
        WifiNetworkSuggestion suggestion =
                TestHelper.createSuggestionBuilderWithCredentialFromSavedNetworkWithBssid(
                        sTestNetwork)
                        .setOemPaid(true)
                        .setOemPrivate(true)
                        .build();
        sNsNetworkCallback = sTestHelper.testConnectionFlowWithSuggestion(
                sTestNetwork, suggestion, mExecutorService,
                Set.of(NET_CAPABILITY_OEM_PAID, NET_CAPABILITY_OEM_PRIVATE));
    }

    /**
     * Connect to a network using restricted suggestion API.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"testConnectToOemPrivateSuggestion"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	"public void testConnectToOemPrivateSuggestion() throws Exception {
        assertNotNull(sTestNetwork);
        WifiNetworkSuggestion suggestion =
                TestHelper.createSuggestionBuilderWithCredentialFromSavedNetworkWithBssid(
                        sTestNetwork)
                        .setOemPrivate(true)
                        .build();
        sNsNetworkCallback = sTestHelper.testConnectionFlowWithSuggestion(
                sTestNetwork, suggestion, mExecutorService, Set.of(NET_CAPABILITY_OEM_PRIVATE));
    }

    /**
     * Simulate connection failure to a network using restricted suggestion API & different net
     * capability (need corresponding net capability requested for platform to connect).
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"testConnectToOemPaidSuggestionFailure"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	"public void testConnectToOemPaidSuggestionFailure() throws Exception {
        assertNotNull(sTestNetwork);
        WifiNetworkSuggestion suggestion =
                TestHelper.createSuggestionBuilderWithCredentialFromSavedNetworkWithBssid(
                        sTestNetwork)
                        .setOemPaid(true)
                        .build();
        sNsNetworkCallback = sTestHelper.testConnectionFailureFlowWithSuggestion(
                sTestNetwork, suggestion, mExecutorService, Set.of(NET_CAPABILITY_OEM_PRIVATE));
    }

    /**
     * Simulate connection failure to a network using restricted suggestion API & different net
     * capability (need corresponding net capability requested for platform to connect).
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"testConnectToOemPrivateSuggestionFailure"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	"public void testConnectToOemPrivateSuggestionFailure() throws Exception {
        assertNotNull(sTestNetwork);
        WifiNetworkSuggestion suggestion =
                TestHelper.createSuggestionBuilderWithCredentialFromSavedNetworkWithBssid(
                        sTestNetwork)
                        .setOemPrivate(true)
                        .build();
        sNsNetworkCallback = sTestHelper.testConnectionFailureFlowWithSuggestion(
                sTestNetwork, suggestion, mExecutorService, Set.of(NET_CAPABILITY_OEM_PAID));
    }

    /**
     * Simulate connection failure to a restricted network using suggestion API & restricted net
     * capability (need corresponding restricted bit set in suggestion for platform to connect).
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"testConnectSuggestionFailureWithOemPaidNetCapability"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	"public void testConnectSuggestionFailureWithOemPaidNetCapability() throws Exception {
        assertNotNull(sTestNetwork);
        WifiNetworkSuggestion suggestion =
                TestHelper.createSuggestionBuilderWithCredentialFromSavedNetworkWithBssid(
                        sTestNetwork)
                        .build();
        sNsNetworkCallback = sTestHelper.testConnectionFailureFlowWithSuggestion(
                sTestNetwork, suggestion, mExecutorService, Set.of(NET_CAPABILITY_OEM_PAID));
    }

    /**
     * Simulate connection failure to a restricted network using suggestion API & restricted net
     * capability (need corresponding restricted bit set in suggestion for platform to connect).
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"testConnectSuggestionFailureWithOemPrivateNetCapability"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	"public void testConnectSuggestionFailureWithOemPrivateNetCapability() throws Exception {
        assertNotNull(sTestNetwork);
        WifiNetworkSuggestion suggestion =
                TestHelper.createSuggestionBuilderWithCredentialFromSavedNetworkWithBssid(
                        sTestNetwork)
                        .build();
        sNsNetworkCallback = sTestHelper.testConnectionFailureFlowWithSuggestion(
                sTestNetwork, suggestion, mExecutorService, Set.of(NET_CAPABILITY_OEM_PRIVATE));
    }
}"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.wifi.BaseTestActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/wifi/BaseTestActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.wifi;

import android.content.Context;
import android.os.Bundle;
import android.os.Handler;
import android.text.Editable;
import android.text.TextWatcher;
import android.util.Log;
import android.view.View;
import android.view.WindowManager;
import android.widget.Button;
import android.widget.EditText;
import android.widget.ProgressBar;
import android.widget.TextView;

import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;

/**
 * Base class for Wifi tests.
 */
public abstract class BaseTestActivity extends PassFailButtons.Activity implements
        BaseTestCase.Listener {
    private static final String TAG = ""BaseTestActivity"";
    /*
     * Handles to GUI elements.
     */
    private TextView mWifiInfo;
    private ProgressBar mWifiProgress;
    private Button mStartButton;
    private EditText mSsidEditText;
    private EditText mPskEditText;

    /*
     * Test case to be executed
     */
    private BaseTestCase mTestCase;

    private Handler mHandler = new Handler();

    private String mSsidValue;
    private String mPskValue;

    protected abstract BaseTestCase getTestCase(Context context);

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.wifi_main);
        setPassFailButtonClickListeners();
        getPassButton().setEnabled(false);

        // Get UI component.
        mWifiInfo = (TextView) findViewById(R.id.wifi_info);
        mWifiProgress = (ProgressBar) findViewById(R.id.wifi_progress);
        mStartButton = findViewById(R.id.wifi_start_test_btn);
        mSsidEditText = findViewById(R.id.wifi_ssid);
        mPskEditText = findViewById(R.id.wifi_psk);
        mSsidEditText.addTextChangedListener(new TextWatcher() {
            @Override
            public void beforeTextChanged(CharSequence charSequence, int i, int i1, int i2) {}

            @Override
            public void onTextChanged(CharSequence charSequence, int i, int i1, int i2) {}

            @Override
            public void afterTextChanged(Editable editable) {
                mSsidValue = editable.toString();
                mStartButton.setEnabled(true);
            }
        });
        mPskEditText.addTextChangedListener(new TextWatcher() {
            @Override
            public void beforeTextChanged(CharSequence charSequence, int i, int i1, int i2) {}

            @Override
            public void onTextChanged(CharSequence charSequence, int i, int i1, int i2) {}

            @Override
            public void afterTextChanged(Editable editable) {
                mPskValue = editable.toString();
            }
        });
        mStartButton.setEnabled(false);
        mStartButton.setOnClickListener(view -> {
            mTestCase.start(this, mSsidValue, mPskValue == null ? """" : mPskValue);
            mWifiProgress.setVisibility(View.VISIBLE);
        });

        // Initialize test components.
        mTestCase = getTestCase(this);

        // keep screen on while this activity is front view.
        getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
    }

    @Override
    protected void onStop() {
        super.onStop();
        mTestCase.stop();
        mWifiProgress.setVisibility(View.GONE);
    }

    @Override
    public void onTestStarted() {
        // nop
    }

    @Override
    public void onTestMsgReceived(String msg) {
        if (msg == null) {
            return;
        }
        mHandler.post(new Runnable() {
            @Override
            public void run() {
                mWifiInfo.append(msg);
                mWifiInfo.append(""\n"");
            }
        });
    }

    @Override
    public void onTestSuccess() {
        mHandler.post(new Runnable() {
            @Override
            public void run() {
                getPassButton().setEnabled(true);
                mWifiInfo.append(getString(R.string.wifi_status_test_success));
                mWifiInfo.append(""\n"");
                mWifiProgress.setVisibility(View.GONE);
            }
        });
    }

    @Override
    public void onTestFailed(String reason) {
        mHandler.post(new Runnable() {
            @Override
            public void run() {
                if (reason != null) {
                    mWifiInfo.append(reason);
                    mWifiInfo.append(""\n"");
                }
                getPassButton().setEnabled(false);
                mWifiInfo.append(getString(R.string.wifi_status_test_failed));
                mWifiInfo.append(""\n"");
                mWifiProgress.setVisibility(View.GONE);
            }
        });
    }
}"	""	""	"view wifi button"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.app.RetrieveScanResultsAndReturnStatusActivity"	"isEmpty"	""	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/CtsWifiLocationTestApp/src/android/net/wifi/cts/app/RetrieveScanResultsAndReturnStatusActivity.java"	""	"public void test/*
 *.
 */

package android.net.wifi.cts.app;

import android.app.Activity;
import android.content.Intent;
import android.net.wifi.WifiManager;
import android.os.Bundle;
import android.util.Log;

/**
 * An activity that retrieves scan results and returns status.
 */
public class RetrieveScanResultsAndReturnStatusActivity extends Activity {
    private static final String TAG = ""RetrieveScanResultsAndReturnStatusActivity"";
    private static final String SCAN_STATUS_EXTRA = ""android.net.wifi.cts.app.extra.STATUS"";

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        WifiManager wifiManager = getSystemService(WifiManager.class);
        boolean succeeded;
        try {
            succeeded = !wifiManager.getScanResults().isEmpty();
        } catch (SecurityException e) {
            succeeded = false;
        }
        if (succeeded) {
            Log.v(TAG, ""Scan results retrieval succeeded"");
        } else {
            Log.v(TAG, ""Failed to retrieve scan results"");
        }
        setResult(RESULT_OK, new Intent().putExtra(SCAN_STATUS_EXTRA, succeeded));
        finish();
    }
}"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.p2p.cts.WifiP2pServiceRequestTest"	"testValidRawRequest"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/p2p/cts/WifiP2pServiceRequestTest.java"	""	"public void testValidRawRequest() throws IllegalArgumentException {
        StringBuffer sb = new StringBuffer();
        sb.append(String.format(Locale.US, ""%02x"", TEST_UPNP_VERSION));
        sb.append(bin2HexStr(TEST_UPNP_QUERY.getBytes()));

        WifiP2pServiceRequest rawRequest =
                WifiP2pServiceRequest.newInstance(
                        WifiP2pServiceInfo.SERVICE_TYPE_UPNP,
                        sb.toString());

        WifiP2pUpnpServiceRequest upnpRequest =
                WifiP2pUpnpServiceRequest.newInstance(
                        TEST_UPNP_QUERY);

        assertEquals(rawRequest, upnpRequest);
    }"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.p2p.cts.WifiP2pServiceRequestTest"	"testInvalidRawRequest"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/p2p/cts/WifiP2pServiceRequestTest.java"	""	"public void testInvalidRawRequest() {
        StringBuffer sb = new StringBuffer();
        sb.append(String.format(Locale.US, ""%02x"", TEST_UPNP_VERSION));
        sb.append(bin2HexStr(TEST_UPNP_QUERY.getBytes()));
        sb.append(""x"");

        try {
            WifiP2pServiceRequest request =
                    WifiP2pServiceRequest.newInstance(
                            WifiP2pServiceInfo.SERVICE_TYPE_UPNP, sb.toString());
            fail(""Expected IllegalArgumentException"");
        } catch (IllegalArgumentException ex) {
            return;
        }
    }
}"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.wifi.testcase.NetworkSuggestionTestCase"	"isEmpty"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/wifi/testcase/NetworkSuggestionTestCase.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.wifi.testcase;

import static android.net.NetworkCapabilities.NET_CAPABILITY_NOT_METERED;
import static android.net.NetworkCapabilities.TRANSPORT_WIFI;
import static android.net.wifi.WifiManager.STATUS_NETWORK_SUGGESTIONS_SUCCESS;

import static com.android.cts.verifier.wifi.TestUtils.SCAN_RESULT_TYPE_OPEN;
import static com.android.cts.verifier.wifi.TestUtils.SCAN_RESULT_TYPE_PSK;

import android.annotation.NonNull;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.net.ConnectivityManager;
import android.net.MacAddress;
import android.net.Network;
import android.net.NetworkRequest;
import android.net.wifi.ScanResult;
import android.net.wifi.WifiManager;
import android.net.wifi.WifiNetworkSuggestion;
import android.os.SystemClock;
import android.util.Log;
import android.util.Pair;

import androidx.core.os.BuildCompat;

import com.android.cts.verifier.R;
import com.android.cts.verifier.wifi.BaseTestCase;
import com.android.cts.verifier.wifi.CallbackUtils;
import com.android.cts.verifier.wifi.TestUtils;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

/**
 * Test cases for network suggestions {@link WifiNetworkSuggestion} added via
 * {@link WifiManager#addNetworkSuggestions(List)}.
 */
public class NetworkSuggestionTestCase extends BaseTestCase {
    private static final String TAG = ""NetworkSuggestionTestCase"";
    private static final boolean DBG = true;

    private static final int PERIODIC_SCAN_INTERVAL_MS = 10_000;
    private static final int CALLBACK_TIMEOUT_MS = 40_000;
    private static final int CAPABILITIES_CHANGED_FOR_METERED_TIMEOUT_MS = 80_000;

    private final Object mLock = new Object();
    private final ScheduledExecutorService mExecutorService;
    private final WifiNetworkSuggestion.Builder mNetworkSuggestionBuilder =
            new WifiNetworkSuggestion.Builder();

    private ConnectivityManager mConnectivityManager;
    private List<WifiNetworkSuggestion> mNetworkSuggestions;
    private NetworkRequest mNetworkRequest;
    private CallbackUtils.NetworkCallback mNetworkCallback;
    private ConnectionStatusListener mConnectionStatusListener;
    private UserApprovalStatusListener mUserApprovalStatusListener;
    private BroadcastReceiver mBroadcastReceiver;
    private String mFailureReason;
    private int mUserApprovedStatus = WifiManager.STATUS_SUGGESTION_APPROVAL_UNKNOWN;

    private final boolean mSetBssid;
    private final boolean mSetRequiresAppInteraction;
    private final boolean mSimulateConnectionFailure;
    private final boolean mSetMeteredPostConnection;

    public NetworkSuggestionTestCase(Context context, boolean setBssid,
            boolean setRequiresAppInteraction) {
        this(context, setBssid, setRequiresAppInteraction, false);
    }

    public NetworkSuggestionTestCase(Context context, boolean setBssid,
            boolean setRequiresAppInteraction, boolean simulateConnectionFailure) {
        this(context, setBssid, setRequiresAppInteraction, simulateConnectionFailure, false);
    }

    public NetworkSuggestionTestCase(Context context, boolean setBssid,
            boolean setRequiresAppInteraction, boolean simulateConnectionFailure,
            boolean setMeteredPostConnection) {
        super(context);
        mExecutorService = Executors.newSingleThreadScheduledExecutor();
        mSetBssid = setBssid;
        mSetRequiresAppInteraction = setRequiresAppInteraction;
        mSimulateConnectionFailure = simulateConnectionFailure;
        mSetMeteredPostConnection = setMeteredPostConnection;
    }

    // Create a network specifier based on the test type.
    private WifiNetworkSuggestion createNetworkSuggestion(@NonNull ScanResult scanResult) {
        mNetworkSuggestionBuilder.setSsid(scanResult.SSID);
        if (mSetBssid) {
            mNetworkSuggestionBuilder.setBssid(MacAddress.fromString(scanResult.BSSID));
        }
        if (mSetRequiresAppInteraction) {
            mNetworkSuggestionBuilder.setIsAppInteractionRequired(true);
        }
        if (mSimulateConnectionFailure) {
            // Use a random password to simulate connection failure.
            if (TestUtils.isScanResultForWpa2Network(scanResult)) {
                mNetworkSuggestionBuilder.setWpa2Passphrase(mTestUtils.generateRandomPassphrase());
            } else if (TestUtils.isScanResultForWpa3Network(scanResult)) {
                mNetworkSuggestionBuilder.setWpa3Passphrase(mTestUtils.generateRandomPassphrase());
            }
        } else if (!mPsk.isEmpty()) {
            if (TestUtils.isScanResultForWpa2Network(scanResult)) {
                mNetworkSuggestionBuilder.setWpa2Passphrase(mPsk);
            } else if (TestUtils.isScanResultForWpa3Network(scanResult)) {
                mNetworkSuggestionBuilder.setWpa3Passphrase(mPsk);
            }
        }
        mNetworkSuggestionBuilder.setIsMetered(false);
        return mNetworkSuggestionBuilder.build();
    }

    private void setFailureReason(String reason) {
        synchronized (mLock) {
            mFailureReason = reason;
        }
    }

    private static class ConnectionStatusListener implements
            WifiManager.SuggestionConnectionStatusListener {
        private final CountDownLatch mCountDownLatch;
        public WifiNetworkSuggestion wifiNetworkSuggestion = null;
        public int failureReason = -1;

        ConnectionStatusListener(CountDownLatch countDownLatch) {
            mCountDownLatch = countDownLatch;
        }

        @Override
        public void onConnectionStatus(
                WifiNetworkSuggestion wifiNetworkSuggestion, int failureReason) {
            this.wifiNetworkSuggestion = wifiNetworkSuggestion;
            this.failureReason = failureReason;
            mCountDownLatch.countDown();
        }
    }

    private class UserApprovalStatusListener implements
            WifiManager.SuggestionUserApprovalStatusListener{
        private final CountDownLatch mCountDownLatch;

        UserApprovalStatusListener(CountDownLatch countDownLatch) {
            mCountDownLatch = countDownLatch;
        }
        @Override
        public void onUserApprovalStatusChange(int status) {
            mUserApprovedStatus = status;
            if (status == WifiManager.STATUS_SUGGESTION_APPROVAL_PENDING
                    || status == WifiManager.STATUS_SUGGESTION_APPROVAL_UNKNOWN) {
                return;
            }
            mCountDownLatch.countDown();
        }
    }

    // TODO(b/150890482): Capabilities changed callback can occur multiple times (for ex: RSSI
    // change) & the sufficiency checks may result in ths change taking longer to take effect.
    // This method accounts for both of these situations.
    private boolean waitForNetworkToBeMetered() throws InterruptedException {
        long startTimeMillis = SystemClock.elapsedRealtime();
        while (SystemClock.elapsedRealtime()
                < startTimeMillis + CAPABILITIES_CHANGED_FOR_METERED_TIMEOUT_MS) {
            // Network marked metered.
            if (!mNetworkCallback.getNetworkCapabilities()
                    .hasCapability(NET_CAPABILITY_NOT_METERED)) {
                return true;
            } else {
                Log.w(TAG, ""Network meteredness check failed. ""
                        + mNetworkCallback.getNetworkCapabilities());
            }
            // Wait for the suggestion to be marked metered now.
            if (!mNetworkCallback.waitForCapabilitiesChanged()) {
                Log.w(TAG, ""Network capabilities did not change"");
            }
        }
        return false;
    }

    @Override
    protected boolean executeTest() throws InterruptedException {
        if (mSimulateConnectionFailure && mPsk.isEmpty()) {
            setFailureReason(mContext.getString(R.string.wifi_status_need_psk));
            return false;
        }
        // Step: Scan and find the network around.
        if (DBG) Log.v(TAG, ""Scan and find the network: "" + mSsid);
        ScanResult testNetwork = mTestUtils.startScanAndFindAnyMatchingNetworkInResults(
                mSsid, mPsk.isEmpty() ? SCAN_RESULT_TYPE_OPEN : SCAN_RESULT_TYPE_PSK);
        if (testNetwork == null) {
            setFailureReason(mContext.getString(R.string.wifi_status_scan_failure));
            return false;
        }

        // Step (Optional): Register for the post connection broadcast.
        final CountDownLatch countDownLatchForPostConnectionBcast = new CountDownLatch(1);
        IntentFilter intentFilter =
                new IntentFilter(WifiManager.ACTION_WIFI_NETWORK_SUGGESTION_POST_CONNECTION);
        // Post connection broadcast receiver.
        mBroadcastReceiver = new BroadcastReceiver() {
            @Override
            public void onReceive(Context context, Intent intent) {
                if (DBG) Log.v(TAG, ""Broadcast onReceive "" + intent);
                if (!intent.getAction().equals(
                        WifiManager.ACTION_WIFI_NETWORK_SUGGESTION_POST_CONNECTION)) {
                    return;
                }
                if (DBG) Log.v(TAG, ""Post connection broadcast received"");
                countDownLatchForPostConnectionBcast.countDown();
            }
        };
        // Register the receiver for post connection broadcast.
        mContext.registerReceiver(mBroadcastReceiver, intentFilter);
        final CountDownLatch countDownLatchForConnectionStatusListener = new CountDownLatch(1);
        mConnectionStatusListener =
                new ConnectionStatusListener(countDownLatchForConnectionStatusListener);
        mWifiManager.addSuggestionConnectionStatusListener(
                Executors.newSingleThreadExecutor(), mConnectionStatusListener);

        final CountDownLatch userApprovalCountDownLatch = new CountDownLatch(1);
        if (BuildCompat.isAtLeastS()) {
            mUserApprovalStatusListener = new UserApprovalStatusListener(
                    userApprovalCountDownLatch);
            mWifiManager.addSuggestionUserApprovalStatusListener(
                    Executors.newSingleThreadExecutor(), mUserApprovalStatusListener);

        }

        // Step: Register network callback to wait for connection state.
        mNetworkRequest = new NetworkRequest.Builder()
                .addTransportType(TRANSPORT_WIFI)
                .build();
        mNetworkCallback = new CallbackUtils.NetworkCallback(CALLBACK_TIMEOUT_MS);
        mConnectivityManager.registerNetworkCallback(mNetworkRequest, mNetworkCallback);

        // Step: Create a suggestion for the chosen open network depending on the type of test.
        WifiNetworkSuggestion networkSuggestion = createNetworkSuggestion(testNetwork);
        mNetworkSuggestions = Arrays.asList(networkSuggestion);

        // Step: Add a network suggestions.
        if (DBG) Log.v(TAG, ""Adding suggestion"");
        mListener.onTestMsgReceived(mContext.getString(R.string.wifi_status_suggestion_add));
        if (mWifiManager.addNetworkSuggestions(mNetworkSuggestions)
                != STATUS_NETWORK_SUGGESTIONS_SUCCESS) {
            setFailureReason(mContext.getString(R.string.wifi_status_suggestion_add_failure));
            return false;
        }
        // Step: Ask user to approval the suggestion.
        if (BuildCompat.isAtLeastS()) {
            if (mUserApprovedStatus != WifiManager.STATUS_SUGGESTION_APPROVAL_APPROVED_BY_USER) {
                mListener.onTestMsgReceived(mContext.getString(
                        R.string.wifi_status_suggestion_wait_for_user_approval));
            }
            if (!userApprovalCountDownLatch.await(CALLBACK_TIMEOUT_MS, TimeUnit.MILLISECONDS)) {
                setFailureReason(mContext.getString(
                        R.string.wifi_status_suggestion_user_approval_status_failure));
                return false;
            }
            if (mUserApprovedStatus != WifiManager.STATUS_SUGGESTION_APPROVAL_APPROVED_BY_USER) {
                setFailureReason(mContext.getString(
                        R.string.wifi_status_suggestion_user_approve_failure));
                return false;
            }
        } else {
            mListener.onTestMsgReceived(mContext.getString(
                    R.string.wifi_status_suggestion_wait_for_user_approval));
        }

        if (DBG) Log.v(TAG, ""Getting suggestion"");
        List<WifiNetworkSuggestion> retrievedSuggestions = mWifiManager.getNetworkSuggestions();
        if (!Objects.equals(mNetworkSuggestions, retrievedSuggestions)) {
            setFailureReason(mContext.getString(R.string.wifi_status_suggestion_get_failure));
            return false;
        }

        // Step: Trigger scans periodically to trigger network selection quicker.
        if (DBG) Log.v(TAG, ""Triggering scan periodically"");
        mExecutorService.scheduleAtFixedRate(() -> {
            if (!mWifiManager.startScan()) {
                Log.w(TAG, ""Failed to trigger scan"");
            }
        }, 0, PERIODIC_SCAN_INTERVAL_MS, TimeUnit.MILLISECONDS);

        // Step: Wait for connection/unavailable.
        if (!mSimulateConnectionFailure) {
            if (DBG) Log.v(TAG, ""Waiting for connection"");
            mListener.onTestMsgReceived(mContext.getString(
                    R.string.wifi_status_suggestion_wait_for_connect));
            Pair<Boolean, Network> cbStatusForAvailable = mNetworkCallback.waitForAvailable();
            if (!cbStatusForAvailable.first) {
                Log.e(TAG, ""Failed to get network available callback"");
                setFailureReason(mContext.getString(R.string.wifi_status_network_cb_timeout));
                return false;
            }
            mListener.onTestMsgReceived(
                    mContext.getString(R.string.wifi_status_suggestion_connect));
        } else {
            if (DBG) Log.v(TAG, ""Ensure no connection"");
            mListener.onTestMsgReceived(mContext.getString(
                    R.string.wifi_status_suggestion_ensure_no_connect));
            Pair<Boolean, Network> cbStatusForAvailable = mNetworkCallback.waitForAvailable();
            if (cbStatusForAvailable.first) {
                Log.e(TAG, ""Unexpectedly got network available callback"");
                setFailureReason(mContext.getString(R.string.wifi_status_network_available_error));
                return false;
            }
            mListener.onTestMsgReceived(
                    mContext.getString(R.string.wifi_status_suggestion_not_connected));
        }

        // Step: Ensure that we connected to the suggested network (optionally, the correct BSSID).
        if (!mSimulateConnectionFailure) {
            if (!mTestUtils.isConnected(""\"""" + testNetwork.SSID + ""\"""",
                    // TODO: This might fail if there are other BSSID's for the same network & the
                    //  device decided to connect/roam to a different BSSID. We don't turn off
                    //  roaming for suggestions.
                    mSetBssid ? testNetwork.BSSID : null)) {
                Log.e(TAG, ""Failed to connected to the network"");
                setFailureReason(
                        mContext.getString(R.string.wifi_status_connected_to_other_network));
                return false;
            }
        }

        // Step (Optional): Ensure we received the post connect broadcast.
        if (mSetRequiresAppInteraction) {
            if (DBG) Log.v(TAG, ""Wait for post connection broadcast"");
            mListener.onTestMsgReceived(
                    mContext.getString(
                            R.string.wifi_status_suggestion_wait_for_post_connect_bcast));
            if (!countDownLatchForPostConnectionBcast.await(
                    CALLBACK_TIMEOUT_MS, TimeUnit.MILLISECONDS)) {
                Log.e(TAG, ""Failed to get post connection broadcast"");
                setFailureReason(mContext.getString(
                        R.string.wifi_status_suggestion_post_connect_bcast_failure));
                return false;
            }
            mListener.onTestMsgReceived(
                    mContext.getString(R.string.wifi_status_suggestion_post_connect_bcast));
        }
        // Step (Optional): Ensure we received the connection status listener.
        if (mSimulateConnectionFailure) {
            if (DBG) Log.v(TAG, ""Wait for connection status listener"");
            mListener.onTestMsgReceived(
                    mContext.getString(
                            R.string.wifi_status_suggestion_wait_for_connection_status));
            if (!countDownLatchForConnectionStatusListener.await(
                    CALLBACK_TIMEOUT_MS, TimeUnit.MILLISECONDS)) {
                Log.e(TAG, ""Failed to receive connection status"");
                setFailureReason(mContext.getString(
                        R.string.wifi_status_suggestion_connection_status_failure));
                return false;
            }
            if (DBG) Log.v(TAG, ""Received connection status"");
            if (!Objects.equals(mConnectionStatusListener.wifiNetworkSuggestion, networkSuggestion)
                    || mConnectionStatusListener.failureReason
                    != WifiManager.STATUS_SUGGESTION_CONNECTION_FAILURE_AUTHENTICATION) {
                Log.e(TAG, ""Received wrong connection status for ""
                        + mConnectionStatusListener.wifiNetworkSuggestion
                        + "" with reason: "" + mConnectionStatusListener.failureReason);
                setFailureReason(mContext.getString(
                        R.string.wifi_status_suggestion_connection_status_failure));
                return false;
            }
            mListener.onTestMsgReceived(
                    mContext.getString(R.string.wifi_status_suggestion_connection_status));
        }

        if (mSetMeteredPostConnection) {
            // ensure that the network is not metered before change.
            if (!mNetworkCallback.getNetworkCapabilities()
                    .hasCapability(NET_CAPABILITY_NOT_METERED)) {
                Log.e(TAG, ""Network meteredness check failed ""
                        + mNetworkCallback.getNetworkCapabilities());
                setFailureReason(mContext.getString(
                        R.string.wifi_status_suggestion_metered_check_failed));
                return false;
            }
            if (DBG) Log.v(TAG, ""Mark suggestion metered after connection"");
            mListener.onTestMsgReceived(
                    mContext.getString(R.string.wifi_status_suggestion_metered_change));
            WifiNetworkSuggestion modifiedSuggestion = mNetworkSuggestionBuilder
                    .setIsMetered(true)
                    .build();
            if (mWifiManager.addNetworkSuggestions(Arrays.asList(modifiedSuggestion))
                    != STATUS_NETWORK_SUGGESTIONS_SUCCESS) {
                setFailureReason(mContext.getString(R.string.wifi_status_suggestion_add_failure));
                return false;
            }
            if (!waitForNetworkToBeMetered()) {
                Log.e(TAG, ""Network was not marked metered"");
                setFailureReason(mContext.getString(
                        R.string.wifi_status_suggestion_metered_check_failed));
                return false;
            }
            mListener.onTestMsgReceived(
                    mContext.getString(R.string.wifi_status_suggestion_metered_changed));
        }

        // Step: Remove the suggestions from the app.
        if (DBG) Log.v(TAG, ""Removing suggestion"");
        mListener.onTestMsgReceived(mContext.getString(R.string.wifi_status_suggestion_remove));
        if (mWifiManager.removeNetworkSuggestions(mNetworkSuggestions)
                != STATUS_NETWORK_SUGGESTIONS_SUCCESS) {
            setFailureReason(mContext.getString(R.string.wifi_status_suggestion_remove_failure));
            return false;
        }

        // Step: Ensure we disconnect immediately on suggestion removal.
        if (!mSimulateConnectionFailure) {
            mListener.onTestMsgReceived(
                    mContext.getString(R.string.wifi_status_suggestion_wait_for_disconnect));
            if (DBG) Log.v(TAG, ""Ensuring we disconnect immediately"");
            boolean cbStatusForLost = mNetworkCallback.waitForLost();
            if (!cbStatusForLost) {
                setFailureReason(
                        mContext.getString(R.string.wifi_status_suggestion_not_disconnected));
                return false;
            }
            mListener.onTestMsgReceived(
                    mContext.getString(R.string.wifi_status_suggestion_disconnected));
        }

        // All done!
        return true;
    }

    @Override
    protected String getFailureReason() {
        synchronized (mLock) {
            return mFailureReason;
        }
    }

    @Override
    protected void setUp() {
        super.setUp();
        mConnectivityManager = mContext.getSystemService(ConnectivityManager.class);
    }

    @Override
    protected void tearDown() {
        mExecutorService.shutdownNow();
        if (mBroadcastReceiver != null) {
            mContext.unregisterReceiver(mBroadcastReceiver);
        }
        if (mConnectionStatusListener != null) {
            mWifiManager.removeSuggestionConnectionStatusListener(mConnectionStatusListener);
        }
        mWifiManager.removeNetworkSuggestions(new ArrayList<>());
        super.tearDown();
    }
}"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.wifibroadcasts.cts.WifiBroadcastsHostJUnit4Test"	"testCleanLogcat"	"CtsWifiBroadcastsHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/wifibroadcasts/src/android/wifibroadcasts/cts/WifiBroadcastsHostJUnit4Test.java"	""	"public void testCleanLogcat() throws Exception {
        ITestDevice device = getDevice();
        assertNotNull(""Device not set"", device);
        if (!device.hasFeature(FEATURE_WIFI)) {
            return;
        }
        // Clear activity
        device.executeShellCommand(CLEAR_COMMAND);
        // No mobile data or wifi to start with
        device.executeShellCommand(""svc data disable; svc wifi disable"");
        // Clear logcat.
        device.executeAdbCommand(""logcat"", ""-c"");
        // Ensure the screen is on, so that rssi polling happens
        device.executeShellCommand(""input keyevent KEYCODE_WAKEUP"");
        // Start the APK
        device.executeShellCommand(START_COMMAND);
        // Bring up wifi
        device.executeShellCommand(""svc wifi enable; sleep 1"");
        // Make sure wifi comes up
        String pingResult = """";
        CommandResult pingCommandResult = null;
        boolean pingSucceeded = false;
        for (int tries = 0; tries < MAXIMUM_PING_TRIES; tries++) {
            if (tries > 0 && tries % MAXIMUM_PING_TRIES_PER_CONNECTION == 0) {
                // if we have been trying for a while, toggle wifi off and then on.
                device.executeShellCommand(""svc wifi disable; sleep 1; svc wifi enable; sleep 3"");
            }
            // We don't require internet connectivity, just a configured address
            pingCommandResult = device.executeShellV2Command(""ping -c 4 -W 2 -t 1 8.8.8.8"");
            pingResult = String.join(""/"", pingCommandResult.getStdout(),
                                          pingCommandResult.getStderr(),
                                          pingCommandResult.getStatus().toString());
            if (pingResult.contains(""4 packets transmitted"")) {
                pingSucceeded = true;
                break;
            }
            Thread.sleep(1000);
        }
        // Stop wifi
        device.executeShellCommand(""svc wifi disable"");

        assertTrue(""Wi-Fi network unavailable - test could not complete "" + pingResult,
                pingSucceeded);

        // Dump logcat.
        String logs = device.executeAdbCommand(""logcat"", ""-v"", ""brief"", ""-d"", CLASS + "":I"", ""*:S"");
        // Search for prohibited string.
        Scanner in = new Scanner(logs);
        try {
            while (in.hasNextLine()) {
                String line = in.nextLine();
                if (line.startsWith(""I/"" + CLASS)) {
                    String payload = line.split("":"")[1].trim();
                    assertFalse(payload, payload.contains(PROHIBITED_STRING));
                }
            }
        } finally {
            in.close();
        }
        //Re-enable Wi-Fi as part of CTS Pre-conditions
        device.executeShellCommand(""svc wifi enable; sleep 1"");
    }
}"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiConfigurationTest"	"testWifiConfiguration"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiConfigurationTest.java"	""	"public void testWifiConfiguration() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        List<WifiConfiguration> wifiConfigurations = mWifiManager.getConfiguredNetworks();
        if (wifiConfigurations != null) {
            for (int i = 0; i < wifiConfigurations.size(); i++) {
                WifiConfiguration wifiConfiguration = wifiConfigurations.get(i);
                assertNotNull(wifiConfiguration);
                assertNotNull(wifiConfiguration.toString());
            }
        }
    }

    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiConfigurationTest"	"testGetAuthType"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiConfigurationTest.java"	""	"public void testGetAuthType() throws Exception {
        WifiConfiguration configuration = new WifiConfiguration();

        configuration.setSecurityParams(SECURITY_TYPE_PSK);
        assertEquals(WifiConfiguration.KeyMgmt.WPA_PSK, configuration.getAuthType());

        configuration.setSecurityParams(SECURITY_TYPE_SAE);
        assertEquals(WifiConfiguration.KeyMgmt.SAE, configuration.getAuthType());

        configuration.setSecurityParams(SECURITY_TYPE_WAPI_PSK);
        assertEquals(WifiConfiguration.KeyMgmt.WAPI_PSK, configuration.getAuthType());

        configuration.setSecurityParams(SECURITY_TYPE_OPEN);
        assertEquals(WifiConfiguration.KeyMgmt.NONE, configuration.getAuthType());

        configuration.setSecurityParams(SECURITY_TYPE_OWE);
        assertEquals(WifiConfiguration.KeyMgmt.OWE, configuration.getAuthType());

        configuration.setSecurityParams(SECURITY_TYPE_EAP);
        assertEquals(WifiConfiguration.KeyMgmt.WPA_EAP, configuration.getAuthType());

        configuration.setSecurityParams(SECURITY_TYPE_EAP_WPA3_ENTERPRISE);
        assertEquals(WifiConfiguration.KeyMgmt.WPA_EAP, configuration.getAuthType());

        configuration.setSecurityParams(SECURITY_TYPE_EAP_SUITE_B);
        assertEquals(WifiConfiguration.KeyMgmt.SUITE_B_192, configuration.getAuthType());

        configuration.setSecurityParams(SECURITY_TYPE_EAP_WPA3_ENTERPRISE_192_BIT);
        assertEquals(WifiConfiguration.KeyMgmt.SUITE_B_192, configuration.getAuthType());

        configuration.setSecurityParams(SECURITY_TYPE_WAPI_CERT);
        assertEquals(WifiConfiguration.KeyMgmt.WAPI_CERT, configuration.getAuthType());
    }

    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiConfigurationTest"	"testGetAuthTypeFailurePsk8021X"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiConfigurationTest.java"	""	"public void testGetAuthTypeFailurePsk8021X() throws Exception {
        WifiConfiguration configuration = new WifiConfiguration();

        configuration.setSecurityParams(SECURITY_TYPE_PSK);
        configuration.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.IEEE8021X);
        try {
            configuration.getAuthType();
            fail(""Expected IllegalStateException exception"");
        } catch(IllegalStateException e) {
            // empty
        }
    }

    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiConfigurationTest"	"testGetAuthTypeFailure8021xEapSae"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiConfigurationTest.java"	""	"public void testGetAuthTypeFailure8021xEapSae() throws Exception {
        WifiConfiguration configuration = new WifiConfiguration();

        configuration.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.IEEE8021X);
        configuration.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.WPA_EAP);
        configuration.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.SAE);
        try {
            configuration.getAuthType();
            fail(""Expected IllegalStateException exception"");
        } catch(IllegalStateException e) {
            // empty
        }
    }

    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiConfigurationTest"	"testSetGetDeletionPriority"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiConfigurationTest.java"	""	"public void testSetGetDeletionPriority() throws Exception {
        WifiConfiguration configuration = new WifiConfiguration();

        assertEquals(0, configuration.getDeletionPriority());
        try {
            configuration.setDeletionPriority(-1);
            fail(""Expected IllegalArgumentException exception"");
        } catch(IllegalArgumentException e) {
            // empty
        }
        configuration.setDeletionPriority(1);
        assertEquals(1, configuration.getDeletionPriority());
    }
}"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiLocationInfoTest"	"isNotNull"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiLocationInfoTest.java"	""	"/*
 *.
 */

package android.net.wifi.cts;

import static android.Manifest.permission.ACCESS_BACKGROUND_LOCATION;
import static android.Manifest.permission.ACCESS_FINE_LOCATION;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import static org.junit.Assume.assumeTrue;

import android.content.ComponentName;
import android.content.Context;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiManager;
import android.os.Build;
import android.platform.test.annotations.AppModeFull;

import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.filters.SdkSuppress;
import androidx.test.filters.SmallTest;
import androidx.test.platform.app.InstrumentationRegistry;
import androidx.test.rule.ActivityTestRule;

import com.android.compatibility.common.util.PollingCheck;
import com.android.compatibility.common.util.ShellIdentityUtils;
import com.android.compatibility.common.util.SystemUtil;

import org.junit.After;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.List;

/**
 * Tests location sensitive APIs exposed by Wi-Fi.
 * Ensures that permissions on these APIs are properly enforced.
 */
@AppModeFull(reason = ""Cannot get WifiManager in instant app mode"")
@SmallTest
@RunWith(AndroidJUnit4.class)
public class WifiLocationInfoTest extends WifiJUnit4TestBase {
    private static final String TAG = ""WifiLocationInfoTest"";

    private static final String WIFI_LOCATION_TEST_APP_APK_PATH =
            ""/data/local/tmp/cts/wifi/CtsWifiLocationTestApp.apk"";
    private static final String WIFI_LOCATION_TEST_APP_PACKAGE_NAME =
            ""android.net.wifi.cts.app"";
    private static final String WIFI_LOCATION_TEST_APP_TRIGGER_SCAN_ACTIVITY =
            WIFI_LOCATION_TEST_APP_PACKAGE_NAME + "".TriggerScanAndReturnStatusActivity"";
    private static final String WIFI_LOCATION_TEST_APP_TRIGGER_SCAN_SERVICE =
            WIFI_LOCATION_TEST_APP_PACKAGE_NAME + "".TriggerScanAndReturnStatusService"";
    private static final String WIFI_LOCATION_TEST_APP_RETRIEVE_SCAN_RESULTS_ACTIVITY =
            WIFI_LOCATION_TEST_APP_PACKAGE_NAME + "".RetrieveScanResultsAndReturnStatusActivity"";
    private static final String WIFI_LOCATION_TEST_APP_RETRIEVE_SCAN_RESULTS_SERVICE =
            WIFI_LOCATION_TEST_APP_PACKAGE_NAME + "".RetrieveScanResultsAndReturnStatusService"";
    private static final String WIFI_LOCATION_TEST_APP_RETRIEVE_CONNECTION_INFO_ACTIVITY =
            WIFI_LOCATION_TEST_APP_PACKAGE_NAME + "".RetrieveConnectionInfoAndReturnStatusActivity"";
    private static final String WIFI_LOCATION_TEST_APP_RETRIEVE_CONNECTION_INFO_SERVICE =
            WIFI_LOCATION_TEST_APP_PACKAGE_NAME + "".RetrieveConnectionInfoAndReturnStatusService"";
    private static final String WIFI_LOCATION_TEST_APP_RETRIEVE_TRANSPORT_INFO_ACTIVITY =
            WIFI_LOCATION_TEST_APP_PACKAGE_NAME + "".RetrieveTransportInfoAndReturnStatusActivity"";
    private static final String WIFI_LOCATION_TEST_APP_RETRIEVE_TRANSPORT_INFO_SERVICE =
            WIFI_LOCATION_TEST_APP_PACKAGE_NAME + "".RetrieveTransportInfoAndReturnStatusService"";

    private static final int DURATION_MS = 10_000;
    private static final int WIFI_CONNECT_TIMEOUT_MILLIS = 30_000;

    @Rule
    public final ActivityTestRule<WaitForResultActivity> mActivityRule =
            new ActivityTestRule<>(WaitForResultActivity.class);

    private Context mContext;
    private WifiManager mWifiManager;
    private boolean mWasVerboseLoggingEnabled;
    private boolean mWasScanThrottleEnabled;

    @Before
    public void setUp() throws Exception {
        mContext = InstrumentationRegistry.getInstrumentation().getContext();
        // skip the test if WiFi is not supported
        assumeTrue(WifiFeature.isWifiSupported(mContext));

        mWifiManager = mContext.getSystemService(WifiManager.class);
        assertThat(mWifiManager).isNotNull();

        installApp(WIFI_LOCATION_TEST_APP_APK_PATH);

        // turn on verbose logging for tests
        mWasVerboseLoggingEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.isVerboseLoggingEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setVerboseLoggingEnabled(true));
        // Disable scan throttling for tests.
        mWasScanThrottleEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.isScanThrottleEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setScanThrottleEnabled(false));

        // enable Wifi
        if (!mWifiManager.isWifiEnabled()) setWifiEnabled(true);
        PollingCheck.check(""Wifi not enabled"", DURATION_MS, () -> mWifiManager.isWifiEnabled());

        // check we have >= 1 saved network
        List<WifiConfiguration> savedNetworks = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.getConfiguredNetworks());
        assertWithMessage(""Need at least one saved network"").that(savedNetworks).isNotEmpty();

        // ensure Wifi is connected
        ShellIdentityUtils.invokeWithShellPermissions(() -> mWifiManager.reconnect());
        PollingCheck.check(
                ""Wifi not connected"",
                WIFI_CONNECT_TIMEOUT_MILLIS,
                () -> mWifiManager.getConnectionInfo().getNetworkId() != -1);
    }

    @After
    public void tearDown() throws Exception {
        if (!WifiFeature.isWifiSupported(mContext)) return;

        uninstallApp(WIFI_LOCATION_TEST_APP_PACKAGE_NAME);

        if (!mWifiManager.isWifiEnabled()) setWifiEnabled(true);
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setScanThrottleEnabled(mWasScanThrottleEnabled));
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setVerboseLoggingEnabled(mWasVerboseLoggingEnabled));
    }

    private void setWifiEnabled(boolean enable) throws Exception {
        // now trigger the change using shell commands.
        SystemUtil.runShellCommand(""svc wifi "" + (enable ? ""enable"" : ""disable""));
    }

    private void turnScreenOn() throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation().executeShellCommand(
                ""input keyevent KEYCODE_WAKEUP"");
        InstrumentationRegistry.getInstrumentation().getUiAutomation().executeShellCommand(""""
                + ""wm dismiss-keyguard"");
        // Since the screen on/off intent is ordered, they will not be sent right now.
        Thread.sleep(2_000);
    }

    private void turnScreenOff() throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation().executeShellCommand(
                ""input keyevent KEYCODE_SLEEP"");
        // Since the screen on/off intent is ordered, they will not be sent right now.
        Thread.sleep(2_000);
    }

    private void installApp(String apk) throws InterruptedException {
        String installResult = SystemUtil.runShellCommand(""pm install -r -d "" + apk);
        Thread.sleep(10_000);
        assertThat(installResult.trim()).isEqualTo(""Success"");
    }

    private void uninstallApp(String pkg) throws InterruptedException {
        String uninstallResult = SystemUtil.runShellCommand(
                ""pm uninstall "" + pkg);
        Thread.sleep(10_000);
        assertThat(uninstallResult.trim()).isEqualTo(""Success"");
    }

    private void startFgActivityAndAssertStatusIs(
            ComponentName componentName, boolean status) throws Exception {
        turnScreenOn();

        WaitForResultActivity activity = mActivityRule.getActivity();
        activity.startActivityToWaitForResult(componentName);
        assertThat(activity.waitForActivityResult(DURATION_MS)).isEqualTo(status);
    }

    private void startBgServiceAndAssertStatusIs(
            ComponentName componentName, boolean status) throws Exception {
        turnScreenOff();

        WaitForResultActivity activity = mActivityRule.getActivity();
        activity.startServiceToWaitForResult(componentName);
        assertThat(activity.waitForServiceResult(DURATION_MS)).isEqualTo(status);
    }

    private void triggerScanFgActivityAndAssertStatusIs(boolean status) throws Exception {
        startFgActivityAndAssertStatusIs(new ComponentName(WIFI_LOCATION_TEST_APP_PACKAGE_NAME,
                WIFI_LOCATION_TEST_APP_TRIGGER_SCAN_ACTIVITY), status);
    }

    private void triggerScanBgServiceAndAssertStatusIs(boolean status) throws Exception {
        startBgServiceAndAssertStatusIs(new ComponentName(WIFI_LOCATION_TEST_APP_PACKAGE_NAME,
                WIFI_LOCATION_TEST_APP_TRIGGER_SCAN_SERVICE), status);
    }

    private void retrieveScanResultsFgActivityAndAssertStatusIs(boolean status) throws Exception {
        startFgActivityAndAssertStatusIs(new ComponentName(WIFI_LOCATION_TEST_APP_PACKAGE_NAME,
                WIFI_LOCATION_TEST_APP_RETRIEVE_SCAN_RESULTS_ACTIVITY), status);
    }

    private void retrieveScanResultsBgServiceAndAssertStatusIs(boolean status) throws Exception {
        startBgServiceAndAssertStatusIs(new ComponentName(WIFI_LOCATION_TEST_APP_PACKAGE_NAME,
                WIFI_LOCATION_TEST_APP_RETRIEVE_SCAN_RESULTS_SERVICE), status);
    }

    private void retrieveConnectionInfoFgActivityAndAssertStatusIs(boolean status)
            throws Exception {
        startFgActivityAndAssertStatusIs(new ComponentName(WIFI_LOCATION_TEST_APP_PACKAGE_NAME,
                WIFI_LOCATION_TEST_APP_RETRIEVE_CONNECTION_INFO_ACTIVITY), status);
    }

    private void retrieveConnectionInfoBgServiceAndAssertStatusIs(boolean status) throws Exception {
        startBgServiceAndAssertStatusIs(new ComponentName(WIFI_LOCATION_TEST_APP_PACKAGE_NAME,
                WIFI_LOCATION_TEST_APP_RETRIEVE_CONNECTION_INFO_SERVICE), status);
    }

    private void retrieveTransportInfoFgActivityAndAssertStatusIs(boolean status)
            throws Exception {
        startFgActivityAndAssertStatusIs(new ComponentName(WIFI_LOCATION_TEST_APP_PACKAGE_NAME,
                WIFI_LOCATION_TEST_APP_RETRIEVE_TRANSPORT_INFO_ACTIVITY), status);
    }

    private void retrieveTransportInfoBgServiceAndAssertStatusIs(boolean status) throws Exception {
        startBgServiceAndAssertStatusIs(new ComponentName(WIFI_LOCATION_TEST_APP_PACKAGE_NAME,
                WIFI_LOCATION_TEST_APP_RETRIEVE_TRANSPORT_INFO_SERVICE), status);
    }"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiLocationInfoTest"	"testScanTriggerAllowedForForegroundActivityWithFineLocationPermission"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiLocationInfoTest.java"	""	"public void testScanTriggerAllowedForForegroundActivityWithFineLocationPermission()
            throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                WIFI_LOCATION_TEST_APP_PACKAGE_NAME, ACCESS_FINE_LOCATION);
        triggerScanFgActivityAndAssertStatusIs(true);
    }"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiLocationInfoTest"	"testScanTriggerAllowedForBackgroundServiceWithBackgroundLocationPermission"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiLocationInfoTest.java"	""	"public void testScanTriggerAllowedForBackgroundServiceWithBackgroundLocationPermission()
            throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                WIFI_LOCATION_TEST_APP_PACKAGE_NAME, ACCESS_FINE_LOCATION);
        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                WIFI_LOCATION_TEST_APP_PACKAGE_NAME, ACCESS_BACKGROUND_LOCATION);
        triggerScanBgServiceAndAssertStatusIs(true);
    }"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiLocationInfoTest"	"testScanTriggerNotAllowedForBackgroundServiceWithFineLocationPermission"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiLocationInfoTest.java"	""	"public void testScanTriggerNotAllowedForBackgroundServiceWithFineLocationPermission()
            throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                WIFI_LOCATION_TEST_APP_PACKAGE_NAME, ACCESS_FINE_LOCATION);
        triggerScanBgServiceAndAssertStatusIs(false);
    }"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiLocationInfoTest"	"testScanResultsRetrievalAllowedForForegroundActivityWithFineLocationPermission"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiLocationInfoTest.java"	""	"public void testScanResultsRetrievalAllowedForForegroundActivityWithFineLocationPermission()
            throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                WIFI_LOCATION_TEST_APP_PACKAGE_NAME, ACCESS_FINE_LOCATION);
        retrieveScanResultsFgActivityAndAssertStatusIs(true);
    }"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiLocationInfoTest"	"testScanResultsRetrievalAllowedForBackgroundServiceWithBackgroundLocationPermission"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiLocationInfoTest.java"	""	"public void testScanResultsRetrievalAllowedForBackgroundServiceWithBackgroundLocationPermission()
            throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                WIFI_LOCATION_TEST_APP_PACKAGE_NAME, ACCESS_FINE_LOCATION);
        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                WIFI_LOCATION_TEST_APP_PACKAGE_NAME, ACCESS_BACKGROUND_LOCATION);
        retrieveScanResultsBgServiceAndAssertStatusIs(true);
    }"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiLocationInfoTest"	"testScanResultsRetrievalNotAllowedForBackgroundServiceWithFineLocationPermission"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiLocationInfoTest.java"	""	"public void testScanResultsRetrievalNotAllowedForBackgroundServiceWithFineLocationPermission()
            throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                WIFI_LOCATION_TEST_APP_PACKAGE_NAME, ACCESS_FINE_LOCATION);
        retrieveScanResultsBgServiceAndAssertStatusIs(false);
    }"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiLocationInfoTest"	"testConnectionInfoRetrievalAllowedForForegroundActivityWithFineLocationPermission"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiLocationInfoTest.java"	""	"public void testConnectionInfoRetrievalAllowedForForegroundActivityWithFineLocationPermission()
            throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                WIFI_LOCATION_TEST_APP_PACKAGE_NAME, ACCESS_FINE_LOCATION);
        retrieveConnectionInfoFgActivityAndAssertStatusIs(true);
    }"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiLocationInfoTest"	"testConnectionInfoRetrievalAllowedForBackgroundServiceWithBackgroundLocationPermission"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiLocationInfoTest.java"	""	"public void
        testConnectionInfoRetrievalAllowedForBackgroundServiceWithBackgroundLocationPermission()
            throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                WIFI_LOCATION_TEST_APP_PACKAGE_NAME, ACCESS_FINE_LOCATION);
        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                WIFI_LOCATION_TEST_APP_PACKAGE_NAME, ACCESS_BACKGROUND_LOCATION);
        retrieveConnectionInfoBgServiceAndAssertStatusIs(true);
    }"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiLocationInfoTest"	"testConnectionInfoRetrievalNotAllowedForBackgroundServiceWithFineLocationPermission"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiLocationInfoTest.java"	""	"public void
        testConnectionInfoRetrievalNotAllowedForBackgroundServiceWithFineLocationPermission()
            throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                WIFI_LOCATION_TEST_APP_PACKAGE_NAME, ACCESS_FINE_LOCATION);
        retrieveConnectionInfoBgServiceAndAssertStatusIs(false);
    }

    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiLocationInfoTest"	"testTransportInfoRetrievalAllowedForForegroundActivityWithFineLocationPermission"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiLocationInfoTest.java"	""	"public void testTransportInfoRetrievalAllowedForForegroundActivityWithFineLocationPermission()
            throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                WIFI_LOCATION_TEST_APP_PACKAGE_NAME, ACCESS_FINE_LOCATION);
        retrieveTransportInfoFgActivityAndAssertStatusIs(true);
    }

    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiLocationInfoTest"	"testTransportInfoRetrievalAllowedForBackgroundServiceWithBackgroundLocationPermission"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiLocationInfoTest.java"	""	"public void
    testTransportInfoRetrievalAllowedForBackgroundServiceWithBackgroundLocationPermission()
            throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                WIFI_LOCATION_TEST_APP_PACKAGE_NAME, ACCESS_FINE_LOCATION);
        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                WIFI_LOCATION_TEST_APP_PACKAGE_NAME, ACCESS_BACKGROUND_LOCATION);
        retrieveTransportInfoBgServiceAndAssertStatusIs(true);
    }

    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiLocationInfoTest"	"testTransportInfoRetrievalNotAllowedForBackgroundServiceWithFineLocationPermission"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiLocationInfoTest.java"	""	"public void
    testTransportInfoRetrievalNotAllowedForBackgroundServiceWithFineLocationPermission()
            throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                WIFI_LOCATION_TEST_APP_PACKAGE_NAME, ACCESS_FINE_LOCATION);
        retrieveTransportInfoBgServiceAndAssertStatusIs(false);
    }
}"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.app.RetrieveTransportInfoAndReturnStatusActivity"	"finish"	""	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/CtsWifiLocationTestApp/src/android/net/wifi/cts/app/RetrieveTransportInfoAndReturnStatusActivity.java"	""	"public void test/*
 *.
 */

package android.net.wifi.cts.app;

import android.app.Activity;
import android.content.Intent;
import android.net.ConnectivityManager;
import android.net.LinkProperties;
import android.net.Network;
import android.net.NetworkCapabilities;
import android.net.NetworkRequest;
import android.net.TransportInfo;
import android.net.wifi.WifiInfo;
import android.net.wifi.WifiManager;
import android.os.Bundle;
import android.util.Log;

import java.util.Objects;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

/**
 * An activity that retrieves Transport info and returns status.
 */
public class RetrieveTransportInfoAndReturnStatusActivity extends Activity {
    private static final String TAG = ""RetrieveTransportInfoAndReturnStatusActivity"";
    private static final String STATUS_EXTRA = ""android.net.wifi.cts.app.extra.STATUS"";
    private static final int DURATION_NETWORK_CONNECTION_MILLIS = 60_000;

    private static class TestNetworkCallback extends ConnectivityManager.NetworkCallback {
        private final CountDownLatch mCountDownLatch;
        public boolean onAvailableCalled = false;
        public NetworkCapabilities networkCapabilities;

        TestNetworkCallback(CountDownLatch countDownLatch) {
            super(ConnectivityManager.NetworkCallback.FLAG_INCLUDE_LOCATION_INFO);
            mCountDownLatch = countDownLatch;
        }

        @Override
        public void onAvailable(Network network) {
            onAvailableCalled = true;
        }

        @Override
        public void onCapabilitiesChanged(Network network,
                NetworkCapabilities networkCapabilities) {
            if (onAvailableCalled) {
                this.networkCapabilities = networkCapabilities;
                mCountDownLatch.countDown();
            }
        }
    }

    public static boolean canRetrieveSsidFromTransportInfo(
            String logTag, ConnectivityManager connectivityManager) {
        CountDownLatch countDownLatch = new CountDownLatch(1);
        TestNetworkCallback testNetworkCallback = new TestNetworkCallback(countDownLatch);
        try {
            // File a callback for wifi network.
            connectivityManager.registerNetworkCallback(
                    new NetworkRequest.Builder()
                            .addTransportType(NetworkCapabilities.TRANSPORT_WIFI)
                            .build(),
                    testNetworkCallback);
            // Wait for callback.
            if (!countDownLatch.await(
                    DURATION_NETWORK_CONNECTION_MILLIS, TimeUnit.MILLISECONDS)) {
                Log.e(logTag, ""Timed out waiting for wifi network"");
                return false;
            }
            if (!testNetworkCallback.onAvailableCalled) {
                Log.e(logTag, ""Failed to get wifi network onAvailable"");
                return false;
            }
            TransportInfo transportInfo =
                    testNetworkCallback.networkCapabilities.getTransportInfo();
            if (!(transportInfo instanceof WifiInfo)) {
                Log.e(logTag, ""Failed to retrieve WifiInfo"");
                return false;
            }
            WifiInfo wifiInfo = (WifiInfo) transportInfo;
            boolean succeeded = !Objects.equals(wifiInfo.getSSID(), WifiManager.UNKNOWN_SSID);
            if (succeeded) {
                Log.v(logTag, ""SSID from transport info retrieval succeeded"");
            } else {
                Log.v(logTag, ""Failed to retrieve SSID from transport info"");
            }
            return succeeded;
        } catch (InterruptedException e) {
            return false;
        } finally {
            connectivityManager.unregisterNetworkCallback(testNetworkCallback);
        }
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        ConnectivityManager connectivityManager  = getSystemService(ConnectivityManager.class);
        setResult(RESULT_OK, new Intent().putExtra(
                STATUS_EXTRA, canRetrieveSsidFromTransportInfo(TAG, connectivityManager)));
        finish();
    }
}"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiJUnit3TestBase"	"isLocationEnabled"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiJUnit3TestBase.java"	""	"public void test/*
 *.
 */

package android.net.wifi.cts;

import android.location.LocationManager;
import android.os.Process;
import android.os.UserHandle;
import android.test.AndroidTestCase;

import com.android.compatibility.common.util.ShellIdentityUtils;

/**
 * Base test for Wifi JUnit3 tests that enables/disables location
 */
public abstract class WifiJUnit3TestBase extends AndroidTestCase {

    private LocationManager mLocationManager;
    private boolean mWasLocationEnabledForTest = false;

    @Override
    protected void setUp() throws Exception {
        super.setUp();

        mLocationManager = mContext.getSystemService(LocationManager.class);
        if (!mLocationManager.isLocationEnabled()) {
            // Turn on location if it isn't on already
            ShellIdentityUtils.invokeWithShellPermissions(() ->
                mLocationManager.setLocationEnabledForUser(
                    true, UserHandle.getUserHandleForUid(Process.myUid())));

            mWasLocationEnabledForTest = true;
        }
    }

    @Override
    protected void tearDown() throws Exception {
        if (mWasLocationEnabledForTest) {
            mLocationManager.setLocationEnabledForUser(
                    false, UserHandle.getUserHandleForUid(Process.myUid()));
        }

        super.tearDown();
    }
}"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.EasyConnectStatusCallbackTest"	"testConfiguratorInitiatorOnFailure"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/EasyConnectStatusCallbackTest.java"	""	"public void testConfiguratorInitiatorOnFailure() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        if (!mWifiManager.isEasyConnectSupported()) {
            // skip the test if Easy Connect is not supported
            return;
        }
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            WifiConfiguration config;
            config = new WifiConfiguration();
            config.SSID = TEST_SSID;
            config.preSharedKey = TEST_PASSPHRASE;
            config.setSecurityParams(SECURITY_TYPE_PSK);
            int networkId = mWifiManager.addNetwork(config);
            assertFalse(networkId == -1);
            synchronized (mLock) {
                mWifiManager.startEasyConnectAsConfiguratorInitiator(TEST_DPP_URI, networkId,
                        EASY_CONNECT_NETWORK_ROLE_STA, mExecutor, mEasyConnectStatusCallback);
                // Note: A long delay is necessary because there is no enrollee, and the system
                // tries to discover it. We will wait for a timeout error to occur.
                mLock.wait(TEST_WAIT_DURATION_MS);
            }
            mWifiManager.removeNetwork(networkId);
            assertTrue(mOnFailureCallback);
            assertEquals(EASY_CONNECT_EVENT_FAILURE_TIMEOUT, mErrorCode);
            mWifiManager.stopEasyConnectSession();
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link android.net.wifi.EasyConnectStatusCallback} class.
     *
     * Since Easy Connect requires 2 devices, start Easy Connect session and expect an error.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.EasyConnectStatusCallbackTest"	"testEnrolleeInitiatorOnFailure"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/EasyConnectStatusCallbackTest.java"	""	"public void testEnrolleeInitiatorOnFailure() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        if (!mWifiManager.isEasyConnectSupported()) {
            // skip the test if Easy Connect is not supported
            return;
        }
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            synchronized (mLock) {
                mWifiManager.startEasyConnectAsEnrolleeInitiator(TEST_DPP_URI, mExecutor,
                        mEasyConnectStatusCallback);
                // Note: A long delay is necessary because there is no configurator, and the system
                // tries to discover it. We will wait for a timeout error to occur.
                mLock.wait(TEST_WAIT_DURATION_MS);
            }
            assertTrue(mOnFailureCallback);
            assertEquals(EASY_CONNECT_EVENT_FAILURE_TIMEOUT, mErrorCode);
            mWifiManager.stopEasyConnectSession();
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link android.net.wifi.EasyConnectStatusCallback#onBootstrapUriGenerated} callback.
     *
     * Since Easy Connect requires 2 devices, start Easy Connect responder session and expect a
     * DPP URI
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.EasyConnectStatusCallbackTest"	"testEnrolleeResponderUriGeneration"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/EasyConnectStatusCallbackTest.java"	""	"public void testEnrolleeResponderUriGeneration() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        if (!mWifiManager.isEasyConnectEnrolleeResponderModeSupported()) {
            // skip the test if Easy Connect Enrollee responder mode is not supported
            return;
        }
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            synchronized (mLock) {
                assertTrue(mWifiManager.getEasyConnectMaxAllowedResponderDeviceInfoLength()
                        > TEST_DEVICE_INFO.length());
                mWifiManager.startEasyConnectAsEnrolleeResponder(TEST_DEVICE_INFO,
                        EASY_CONNECT_CRYPTOGRAPHY_CURVE_PRIME256V1, mExecutor,
                        mEasyConnectStatusCallback);
                // Wait for supplicant to generate DPP URI and trigger the callback function to
                // provide the generated URI.
                mLock.wait(TEST_WAIT_DURATION_MS);
            }
            assertTrue(mOnBootstrapUriGeneratedCallback);
            mWifiManager.stopEasyConnectSession();
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Test that {@link WifiManager#startEasyConnectAsEnrolleeResponder(String, int, Executor,
     * EasyConnectStatusCallback)} throws illegal argument exception on passing a wrong device
     * info.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)
    public void
           testStartEasyConnectAsEnrolleeResponderThrowsIllegalArgumentExceptionOnWrongDeviceInfo()
           throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        if (!mWifiManager.isEasyConnectEnrolleeResponderModeSupported()) {
            // skip the test if Easy Connect Enrollee responder mode is not supported
            return;
        }
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            mWifiManager.startEasyConnectAsEnrolleeResponder(TEST_WRONG_DEVICE_INFO,
                    EASY_CONNECT_CRYPTOGRAPHY_CURVE_PRIME256V1, mExecutor,
                    mEasyConnectStatusCallback);
            fail(""startEasyConnectAsEnrolleeResponder did not throw an IllegalArgumentException""
                    + ""on passing a wrong device info!"");
        } catch (IllegalArgumentException expected) {}
        uiAutomation.dropShellPermissionIdentity();
    }
}"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.p2p.cts.WifiP2pInfoTest"	"testWifiP2pInfoNoGroup"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/p2p/cts/WifiP2pInfoTest.java"	""	"public void testWifiP2pInfoNoGroup() {
        WifiP2pInfo info = new WifiP2pInfo();
        info.groupFormed = false;

        WifiP2pInfo copiedInfo = new WifiP2pInfo(info);
        assertEquals(info.groupFormed, copiedInfo.groupFormed);
        assertEquals(info.isGroupOwner, copiedInfo.isGroupOwner);
        assertEquals(info.groupOwnerAddress, copiedInfo.groupOwnerAddress);
    }"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.p2p.cts.WifiP2pInfoTest"	"testWifiP2pInfoGroupOwner"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/p2p/cts/WifiP2pInfoTest.java"	""	"public void testWifiP2pInfoGroupOwner() {
        WifiP2pInfo info = new WifiP2pInfo();
        info.groupFormed = true;
        info.isGroupOwner = true;
        info.groupOwnerAddress = InetAddresses.parseNumericAddress(TEST_GROUP_OWNER_ADDRESS);

        WifiP2pInfo copiedInfo = new WifiP2pInfo(info);
        assertEquals(info.groupFormed, copiedInfo.groupFormed);
        assertEquals(info.isGroupOwner, copiedInfo.isGroupOwner);
        assertEquals(info.groupOwnerAddress, copiedInfo.groupOwnerAddress);
    }"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.p2p.cts.WifiP2pInfoTest"	"testWifiP2pInfoGroupClient"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/p2p/cts/WifiP2pInfoTest.java"	""	"public void testWifiP2pInfoGroupClient() {
        WifiP2pInfo info = new WifiP2pInfo();
        info.groupFormed = true;
        info.isGroupOwner = false;
        info.groupOwnerAddress = InetAddresses.parseNumericAddress(TEST_GROUP_OWNER_ADDRESS);

        WifiP2pInfo copiedInfo = new WifiP2pInfo(info);
        assertEquals(info.groupFormed, copiedInfo.groupFormed);
        assertEquals(info.isGroupOwner, copiedInfo.isGroupOwner);
        assertEquals(info.groupOwnerAddress, copiedInfo.groupOwnerAddress);
    }
}"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiHotspot2Test"	"testGetMeteredOverride"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiHotspot2Test.java"	""	"public void testGetMeteredOverride() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        PasspointConfiguration passpointConfiguration = new PasspointConfiguration();
        assertEquals(METERED_OVERRIDE_NONE, passpointConfiguration.getMeteredOverride());
    }

    /**
     * Tests {@link PasspointConfiguration#getSubscriptionExpirationTimeMillis()} method.
     * <p>
     * Test default value
     */"	""	""	"passpoint wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiHotspot2Test"	"testGetSubscriptionExpirationTimeMillis"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiHotspot2Test.java"	""	"public void testGetSubscriptionExpirationTimeMillis() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        PasspointConfiguration passpointConfiguration = new PasspointConfiguration();
        assertEquals(Long.MIN_VALUE,
                passpointConfiguration.getSubscriptionExpirationTimeMillis());
    }

    /**
     * Tests {@link PasspointConfiguration#getUniqueId()} method.
     * <p>
     * Test unique identifier is not null
     */"	""	""	"passpoint wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiHotspot2Test"	"testGetUniqueId"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiHotspot2Test.java"	""	"public void testGetUniqueId() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }

        // Create a configuration and make sure the unique ID is not null
        PasspointConfiguration passpointConfiguration1 = createConfig(SIM_CREDENTIAL, ""123456*"",
                18 /* EAP_SIM */);
        String uniqueId1 = passpointConfiguration1.getUniqueId();
        assertNotNull(uniqueId1);

        // Create another configuration and make sure the unique ID is not null
        PasspointConfiguration passpointConfiguration2 = createConfig(SIM_CREDENTIAL, ""567890*"",
                23 /* EAP_AKA */);
        String uniqueId2 = passpointConfiguration2.getUniqueId();
        assertNotNull(uniqueId2);

        // Make sure the IDs are not equal
        assertFalse(uniqueId1.equals(uniqueId2));

        passpointConfiguration2 = createConfig(USER_CREDENTIAL);
        assertFalse(uniqueId1.equals(passpointConfiguration2.getUniqueId()));

        passpointConfiguration2 = createConfig(CERT_CREDENTIAL);
        assertFalse(uniqueId1.equals(passpointConfiguration2.getUniqueId()));
    }

    /**
     * Tests {@link PasspointConfiguration#isAutojoinEnabled()} method.
     * <p>
     * Test default value
     */"	""	""	"passpoint wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiHotspot2Test"	"testIsAutojoinEnabled"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiHotspot2Test.java"	""	"public void testIsAutojoinEnabled() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        PasspointConfiguration passpointConfiguration = new PasspointConfiguration();
        assertTrue(passpointConfiguration.isAutojoinEnabled());
    }

    /**
     * Tests {@link PasspointConfiguration#isMacRandomizationEnabled()} method.
     * <p>
     * Test default value
     */"	""	""	"passpoint wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiHotspot2Test"	"testIsMacRandomizationEnabled"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiHotspot2Test.java"	""	"public void testIsMacRandomizationEnabled() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        PasspointConfiguration passpointConfiguration = new PasspointConfiguration();
        assertTrue(passpointConfiguration.isMacRandomizationEnabled());
    }

    /**
     * Tests {@link PasspointConfiguration#isOsuProvisioned()} method.
     * <p>
     * Test default value
     */"	""	""	"passpoint wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiHotspot2Test"	"testIsOsuProvisioned"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiHotspot2Test.java"	""	"public void testIsOsuProvisioned() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        PasspointConfiguration passpointConfiguration = createConfig(USER_CREDENTIAL);
        assertFalse(passpointConfiguration.isOsuProvisioned());
    }

    /**
     * Tests {@link PasspointConfiguration#PasspointConfiguration(PasspointConfiguration)} method.
     * <p>
     * Test the PasspointConfiguration copy constructor
     */"	""	""	"passpoint wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiHotspot2Test"	"testPasspointConfigurationCopyConstructor"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiHotspot2Test.java"	""	"public void testPasspointConfigurationCopyConstructor() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        PasspointConfiguration passpointConfiguration = createConfig(USER_CREDENTIAL);
        PasspointConfiguration copyOfPasspointConfiguration =
                new PasspointConfiguration(passpointConfiguration);
        assertEquals(passpointConfiguration, copyOfPasspointConfiguration);
    }

    /**
     * Tests {@link HomeSp#HomeSp(HomeSp)} method.
     * <p>
     * Test the HomeSp copy constructor
     */"	""	""	"passpoint wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiHotspot2Test"	"testCredentialGetClientPrivateKey"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiHotspot2Test.java"	""	"public void testCredentialGetClientPrivateKey() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        Credential credential = new Credential();
        credential.setClientPrivateKey(FakeKeys.RSA_KEY1);

        assertEquals(FakeKeys.RSA_KEY1, credential.getClientPrivateKey());
    }

    private static PasspointConfiguration createConfig(int type) throws Exception {
        return createConfig(type, ""123456*"", 18 /* EAP_SIM */);
    }

    private static PasspointConfiguration createConfig(int type, String imsi, int eapType)
            throws Exception {
        PasspointConfiguration config = new PasspointConfiguration();
        config.setHomeSp(createHomeSp());
        switch (type) {
            default:
            case SIM_CREDENTIAL:
                config.setCredential(
                        createCredentialWithSimCredential(imsi, eapType));
                break;
            case USER_CREDENTIAL:
                config.setCredential(createCredentialWithUserCredential());
                break;
            case CERT_CREDENTIAL:
                config.setCredential(createCredentialWithCertificateCredential());
                break;
        }

        return config;
    }

    /**
     * Helper function for generating HomeSp for testing.
     *
     * @return {@link HomeSp}
     */
    private static HomeSp createHomeSp() {
        HomeSp homeSp = new HomeSp();
        homeSp.setFqdn(""test.com"");
        homeSp.setFriendlyName(""friendly name"");
        homeSp.setRoamingConsortiumOis(new long[]{0x55, 0x66});
        return homeSp;
    }

    /**
     * Helper function for generating Credential for testing.
     *
     * @param userCred               Instance of UserCredential
     * @param certCred               Instance of CertificateCredential
     * @param simCred                Instance of SimCredential
     * @param clientCertificateChain Chain of client certificates
     * @param clientPrivateKey       Client private key
     * @param caCerts                CA certificates
     * @return {@link Credential}
     */
    private static Credential createCredential(Credential.UserCredential userCred,
            Credential.CertificateCredential certCred,
            Credential.SimCredential simCred,
            X509Certificate[] clientCertificateChain, PrivateKey clientPrivateKey,
            X509Certificate... caCerts) {
        Credential cred = new Credential();
        cred.setRealm(""realm"");
        cred.setUserCredential(userCred);
        cred.setCertCredential(certCred);
        cred.setSimCredential(simCred);
        return cred;
    }

    /**
     * Helper function for generating certificate credential for testing.
     *
     * @return {@link Credential}
     */
    private static Credential createCredentialWithCertificateCredential()
            throws NoSuchAlgorithmException, CertificateEncodingException {
        Credential.CertificateCredential certCred = new Credential.CertificateCredential();
        certCred.setCertType(""x509v3"");
        certCred.setCertSha256Fingerprint(
                MessageDigest.getInstance(""SHA-256"").digest(
                        FakeKeys.CLIENT_CERT.getEncoded()));
        return createCredential(null, certCred, null, new X509Certificate[]{
                        FakeKeys.CLIENT_CERT},
                FakeKeys.RSA_KEY1, FakeKeys.CA_CERT0,
                FakeKeys.CA_CERT1);
    }

    /**
     * Helper function for generating SIM credential for testing.
     *
     * @return {@link Credential}
     */
    private static Credential createCredentialWithSimCredential(String imsi, int eapType) {
        Credential.SimCredential simCred = new Credential.SimCredential();
        simCred.setImsi(imsi);
        simCred.setEapType(eapType);
        return createCredential(null, null, simCred, null, null, (X509Certificate[]) null);
    }

    /**
     * Helper function for generating user credential for testing.
     *
     * @return {@link Credential}
     */
    private static Credential createCredentialWithUserCredential() {
        Credential.UserCredential userCred = new Credential.UserCredential();
        userCred.setUsername(""username"");
        userCred.setPassword(""password"");
        userCred.setEapType(21 /* EAP_TTLS */);
        userCred.setNonEapInnerMethod(""MS-CHAP"");
        return createCredential(userCred, null, null, null, null,
                FakeKeys.CA_CERT0);
    }

    /**
     * Tests {@link OsuProvider#getFriendlyName()} and {@link OsuProvider#getServerUri()} methods.
     * <p>
     * Test that getting a set friendly name and server URI produces the same value
     */"	""	""	"passpoint wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiHotspot2Test"	"testHomeSpCopyConstructor"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiHotspot2Test.java"	""	"public void testHomeSpCopyConstructor() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        HomeSp homeSp = createHomeSp();
        HomeSp copyOfHomeSp = new HomeSp(homeSp);
        assertEquals(copyOfHomeSp, homeSp);
    }

    /**
     * Tests {@link Credential#Credential(Credential)} method.
     * <p>
     * Test the Credential copy constructor
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiHotspot2Test"	"testCredentialCopyConstructor"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiHotspot2Test.java"	""	"public void testCredentialCopyConstructor() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        Credential credential = createCredentialWithSimCredential(""123456*"", 18 /* EAP_SIM */);
        Credential copyOfCredential = new Credential(credential);
        assertEquals(copyOfCredential, credential);
    }

    /**
     * Tests {@link Credential.UserCredential#UserCredential(Credential.UserCredential)} method.
     * <p>
     * Test the Credential.UserCredential copy constructor
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiHotspot2Test"	"testUserCredentialCopyConstructor"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiHotspot2Test.java"	""	"public void testUserCredentialCopyConstructor() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        Credential.UserCredential userCredential = new Credential.UserCredential();
        userCredential.setUsername(""username"");
        userCredential.setPassword(""password"");
        userCredential.setEapType(21 /* EAP_TTLS */);
        userCredential.setNonEapInnerMethod(""MS-CHAP"");

        Credential.UserCredential copyOfUserCredential =
                new Credential.UserCredential(userCredential);
        assertEquals(copyOfUserCredential, userCredential);
    }

    /**
     * Tests
     * {@link Credential.CertificateCredential#CertificateCredential(Credential.CertificateCredential)}
     * method.
     * <p>
     * Test the Credential.CertificateCredential copy constructor
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiHotspot2Test"	"testCertCredentialCopyConstructor"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiHotspot2Test.java"	""	"public void testCertCredentialCopyConstructor() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        Credential.CertificateCredential certCredential = new Credential.CertificateCredential();
        certCredential.setCertType(""x509v3"");

        Credential.CertificateCredential copyOfCertificateCredential =
                new Credential.CertificateCredential(certCredential);
        assertEquals(copyOfCertificateCredential, certCredential);
    }

    /**
     * Tests {@link Credential.SimCredential#SimCredential(Credential.SimCredential)} method.
     * <p>
     * Test the Credential.SimCredential copy constructor
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiHotspot2Test"	"testSimCredentialCopyConstructor"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiHotspot2Test.java"	""	"public void testSimCredentialCopyConstructor() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        Credential.SimCredential simCredential = new Credential.SimCredential();
        simCredential.setImsi(""1234*"");
        simCredential.setEapType(18/* EAP_SIM */);

        Credential.SimCredential copyOfSimCredential = new Credential.SimCredential(simCredential);
        assertEquals(copyOfSimCredential, simCredential);
    }

    /**
     * Tests {@link Credential#getCaCertificate()}  method.
     * <p>
     * Test that getting a set certificate produces the same value
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiHotspot2Test"	"testCredentialGetCertificate"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiHotspot2Test.java"	""	"public void testCredentialGetCertificate() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        Credential credential = new Credential();
        credential.setCaCertificate(FakeKeys.CA_CERT0);

        assertEquals(FakeKeys.CA_CERT0, credential.getCaCertificate());
    }

    /**
     * Tests {@link Credential#getClientCertificateChain()} and {@link
     * Credential#setCaCertificates(X509Certificate[])} methods.
     * <p>
     * Test that getting a set client certificate chain produces the same value
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiHotspot2Test"	"testCredentialClientCertificateChain"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiHotspot2Test.java"	""	"public void testCredentialClientCertificateChain() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        Credential credential = new Credential();
        X509Certificate[] certificates = new X509Certificate[]{FakeKeys.CLIENT_CERT};
        credential.setClientCertificateChain(certificates);

        assertTrue(Arrays.equals(certificates, credential.getClientCertificateChain()));
    }

    /**
     * Tests {@link Credential#getClientPrivateKey()} and
     * {@link Credential#setClientPrivateKey(PrivateKey)}
     * methods.
     * <p>
     * Test that getting a set client private key produces the same value
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiHotspot2Test"	"testCredentialSetGetClientPrivateKey"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiHotspot2Test.java"	""	"public void testCredentialSetGetClientPrivateKey() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        Credential credential = new Credential();
        credential.setClientPrivateKey(FakeKeys.RSA_KEY1);

        assertEquals(FakeKeys.RSA_KEY1, credential.getClientPrivateKey());
    }

    /**
     * Tests {@link Credential#getClientPrivateKey()} and
     * {@link Credential#setClientPrivateKey(PrivateKey)}
     * methods.
     * <p>
     * Test that getting a set client private key produces the same value
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiHotspot2Test"	"testOsuProviderGetters"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiHotspot2Test.java"	""	"public void testOsuProviderGetters() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }

        // Using Java reflection to construct an OsuProvider instance because its constructor is
        // hidden and not available to apps.
        Class<?> osuProviderClass = Class.forName(""android.net.wifi.hotspot2.OsuProvider"");
        Constructor<?> osuProviderClassConstructor = osuProviderClass.getConstructor(String.class,
                Map.class, String.class, Uri.class, String.class, List.class);

        OsuProvider osuProvider = (OsuProvider) osuProviderClassConstructor.newInstance(TEST_SSID,
                TEST_FRIENDLY_NAMES, TEST_SERVICE_DESCRIPTION, TEST_SERVER_URI, TEST_NAI,
                TEST_METHOD_LIST);
        String lang = Locale.getDefault().getLanguage();
        String friendlyName = TEST_FRIENDLY_NAMES.get(lang);
        if (TextUtils.isEmpty(friendlyName)) {
            friendlyName = TEST_FRIENDLY_NAMES.get(""en"");
        }
        assertEquals(friendlyName, osuProvider.getFriendlyName());
        assertEquals(TEST_SERVER_URI, osuProvider.getServerUri());
    }
}"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.aware.cts.SingleDeviceTest"	"waitForListener"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/aware/cts/SingleDeviceTest.java"	""	"public void test/*
 *.
 */

package android.net.wifi.aware.cts;

import static org.junit.Assert.assertNotEquals;
import static org.mockito.Mockito.mock;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageManager;
import android.location.LocationManager;
import android.net.ConnectivityManager;
import android.net.MacAddress;
import android.net.NetworkCapabilities;
import android.net.NetworkRequest;
import android.net.wifi.WifiManager;
import android.net.wifi.aware.AttachCallback;
import android.net.wifi.aware.AwareResources;
import android.net.wifi.aware.Characteristics;
import android.net.wifi.aware.DiscoverySession;
import android.net.wifi.aware.DiscoverySessionCallback;
import android.net.wifi.aware.IdentityChangedListener;
import android.net.wifi.aware.ParcelablePeerHandle;
import android.net.wifi.aware.PeerHandle;
import android.net.wifi.aware.PublishConfig;
import android.net.wifi.aware.PublishDiscoverySession;
import android.net.wifi.aware.SubscribeConfig;
import android.net.wifi.aware.SubscribeDiscoverySession;
import android.net.wifi.aware.WifiAwareManager;
import android.net.wifi.aware.WifiAwareNetworkSpecifier;
import android.net.wifi.aware.WifiAwareSession;
import android.net.wifi.cts.WifiBuildCompat;
import android.net.wifi.cts.WifiJUnit3TestBase;
import android.os.Build;
import android.os.Handler;
import android.os.HandlerThread;
import android.os.Parcel;
import android.platform.test.annotations.AppModeFull;

import com.android.compatibility.common.util.ApiLevelUtil;
import com.android.compatibility.common.util.ShellIdentityUtils;
import com.android.compatibility.common.util.SystemUtil;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

/**
 * Wi-Fi Aware CTS test suite: single device testing. Performs tests on a single
 * device to validate Wi-Fi Aware.
 */
@AppModeFull(reason = ""Cannot get WifiAwareManager in instant app mode"")
public class SingleDeviceTest extends WifiJUnit3TestBase {
    private static final String TAG = ""WifiAwareCtsTests"";

    // wait for Wi-Fi Aware state changes & network requests callbacks
    private static final int WAIT_FOR_AWARE_CHANGE_SECS = 15; // 15 seconds
    private static final int WAIT_FOR_NETWORK_STATE_CHANGE_SECS = 25; // 25 seconds
    private static final int INTERVAL_BETWEEN_TESTS_SECS = 3; // 3 seconds
    private static final int WAIT_FOR_AWARE_INTERFACE_CREATION_SEC = 3; // 3 seconds
    private static final int MIN_DISTANCE_MM = 1 * 1000;
    private static final int MAX_DISTANCE_MM = 3 * 1000;
    private static final byte[] PMK_VALID = ""01234567890123456789012345678901"".getBytes();
    private static final int AVAILABLE_DATA_PATH_COUNT = 2;
    private static final int AVAILABLE_PUBLISH_SESSION_COUNT = 8;
    private static final int AVAILABLE_SUBSCRIBE_SESSION_COUNT = 8;

    private final Object mLock = new Object();
    private final HandlerThread mHandlerThread = new HandlerThread(""SingleDeviceTest"");
    private final Handler mHandler;
    private Boolean mWasVerboseLoggingEnabled;

    {
        mHandlerThread.start();
        mHandler = new Handler(mHandlerThread.getLooper());
    }

    private WifiAwareManager mWifiAwareManager;
    private WifiManager mWifiManager;
    private WifiManager.WifiLock mWifiLock;
    private ConnectivityManager mConnectivityManager;

    // used to store any WifiAwareSession allocated during tests - will clean-up after tests
    private List<WifiAwareSession> mSessions = new ArrayList<>();

    private class WifiAwareBroadcastReceiver extends BroadcastReceiver {
        private final Object mLock = new Object();
        private CountDownLatch mBlocker = new CountDownLatch(1);
        private int mCountNumber = 0;

        @Override
        public void onReceive(Context context, Intent intent) {
            if (WifiAwareManager.ACTION_WIFI_AWARE_STATE_CHANGED.equals(intent.getAction())) {
                synchronized(mLock) {
                    mCountNumber += 1;
                    mBlocker.countDown();
                    mBlocker = new CountDownLatch(1);
                }
            }
        }

        boolean waitForStateChange() throws InterruptedException {
            CountDownLatch blocker;
            synchronized (mLock) {
                mCountNumber--;
                if (mCountNumber >= 0) {
                    return true;
                }
                blocker = mBlocker;
            }
            return blocker.await(WAIT_FOR_AWARE_CHANGE_SECS, TimeUnit.SECONDS);
        }
    }

    private class AttachCallbackTest extends AttachCallback {
        static final int ATTACHED = 0;
        static final int ATTACH_FAILED = 1;
        static final int ERROR = 2; // no callback: timeout, interruption

        private CountDownLatch mBlocker = new CountDownLatch(1);
        private int mCallbackCalled = ERROR; // garbage init
        private WifiAwareSession mSession = null;

        @Override
        public void onAttached(WifiAwareSession session) {
            mCallbackCalled = ATTACHED;
            mSession = session;
            synchronized (mLock) {
                mSessions.add(session);
            }
            mBlocker.countDown();
        }

        @Override
        public void onAttachFailed() {
            mCallbackCalled = ATTACH_FAILED;
            mBlocker.countDown();
        }

        /**
         * Waits for any of the callbacks to be called - or an error (timeout, interruption).
         * Returns one of the ATTACHED, ATTACH_FAILED, or ERROR values.
         */
        int waitForAnyCallback() {
            try {
                boolean noTimeout = mBlocker.await(WAIT_FOR_AWARE_CHANGE_SECS, TimeUnit.SECONDS);
                if (noTimeout) {
                    return mCallbackCalled;
                } else {
                    return ERROR;
                }
            } catch (InterruptedException e) {
                return ERROR;
            }
        }

        /**
         * Access the session created by a callback. Only useful to be called after calling
         * waitForAnyCallback() and getting the ATTACHED code back.
         */
        WifiAwareSession getSession() {
            return mSession;
        }
    }

    private class IdentityChangedListenerTest extends IdentityChangedListener {
        private CountDownLatch mBlocker = new CountDownLatch(1);
        private byte[] mMac = null;

        @Override
        public void onIdentityChanged(byte[] mac) {
            mMac = mac;
            mBlocker.countDown();
        }

        /**
         * Waits for the listener callback to be called - or an error (timeout, interruption).
         * Returns true on callback called, false on error (timeout, interruption).
         */
        boolean waitForListener() {
            try {
                return mBlocker.await(WAIT_FOR_AWARE_CHANGE_SECS, TimeUnit.SECONDS);
            } catch (InterruptedException e) {
                return false;
            }
        }

        /**
         * Returns the MAC address of the discovery interface supplied to the triggered callback.
         */
        byte[] getMac() {
            return mMac;
        }
    }

    private class DiscoverySessionCallbackTest extends DiscoverySessionCallback {
        static final int ON_PUBLISH_STARTED = 0;
        static final int ON_SUBSCRIBE_STARTED = 1;
        static final int ON_SESSION_CONFIG_UPDATED = 2;
        static final int ON_SESSION_CONFIG_FAILED = 3;
        static final int ON_SESSION_TERMINATED = 4;
        static final int ON_SERVICE_DISCOVERED = 5;
        static final int ON_MESSAGE_SEND_SUCCEEDED = 6;
        static final int ON_MESSAGE_SEND_FAILED = 7;
        static final int ON_MESSAGE_RECEIVED = 8;
        static final int ON_SESSION_DISCOVERED_LOST = 9;

        private final Object mLocalLock = new Object();

        private CountDownLatch mBlocker;
        private int mCurrentWaitForCallback;
        private ArrayDeque<Integer> mCallbackQueue = new ArrayDeque<>();

        private PublishDiscoverySession mPublishDiscoverySession;
        private SubscribeDiscoverySession mSubscribeDiscoverySession;

        private void processCallback(int callback) {
            synchronized (mLocalLock) {
                if (mBlocker != null && mCurrentWaitForCallback == callback) {
                    mBlocker.countDown();
                } else {
                    mCallbackQueue.addLast(callback);
                }
            }
        }

        @Override
        public void onPublishStarted(PublishDiscoverySession session) {
            mPublishDiscoverySession = session;
            processCallback(ON_PUBLISH_STARTED);
        }

        @Override
        public void onSubscribeStarted(SubscribeDiscoverySession session) {
            mSubscribeDiscoverySession = session;
            processCallback(ON_SUBSCRIBE_STARTED);
        }

        @Override
        public void onSessionConfigUpdated() {
            processCallback(ON_SESSION_CONFIG_UPDATED);
        }

        @Override
        public void onSessionConfigFailed() {
            processCallback(ON_SESSION_CONFIG_FAILED);
        }

        @Override
        public void onSessionTerminated() {
            processCallback(ON_SESSION_TERMINATED);
        }

        @Override
        public void onServiceDiscovered(PeerHandle peerHandle, byte[] serviceSpecificInfo,
                List<byte[]> matchFilter) {
            processCallback(ON_SERVICE_DISCOVERED);
        }

        @Override
        public void onMessageSendSucceeded(int messageId) {
            processCallback(ON_MESSAGE_SEND_SUCCEEDED);
        }

        @Override
        public void onMessageSendFailed(int messageId) {
            processCallback(ON_MESSAGE_SEND_FAILED);
        }

        @Override
        public void onMessageReceived(PeerHandle peerHandle, byte[] message) {
            processCallback(ON_MESSAGE_RECEIVED);
        }

        @Override
        public void onServiceLost(PeerHandle peerHandle, int reason) {
            processCallback(ON_SESSION_DISCOVERED_LOST);
        }

        /**
         * Wait for the specified callback - any of the ON_* constants. Returns a true
         * on success (specified callback triggered) or false on failure (timed-out or
         * interrupted while waiting for the requested callback).
         *
         * Note: other callbacks happening while while waiting for the specified callback will
         * be queued.
         */
        boolean waitForCallback(int callback) {
            return waitForCallback(callback, WAIT_FOR_AWARE_CHANGE_SECS);
        }

        /**
         * Wait for the specified callback - any of the ON_* constants. Returns a true
         * on success (specified callback triggered) or false on failure (timed-out or
         * interrupted while waiting for the requested callback).
         *
         * Same as waitForCallback(int callback) execpt that allows specifying a custom timeout.
         * The default timeout is a short value expected to be sufficient for all behaviors which
         * should happen relatively quickly. Specifying a custom timeout should only be done for
         * those cases which are known to take a specific longer period of time.
         *
         * Note: other callbacks happening while while waiting for the specified callback will
         * be queued.
         */
        boolean waitForCallback(int callback, int timeoutSec) {
            synchronized (mLocalLock) {
                boolean found = mCallbackQueue.remove(callback);
                if (found) {
                    return true;
                }

                mCurrentWaitForCallback = callback;
                mBlocker = new CountDownLatch(1);
            }

            try {
                return mBlocker.await(timeoutSec, TimeUnit.SECONDS);
            } catch (InterruptedException e) {
                return false;
            }
        }

        /**
         * Indicates whether the specified callback (any of the ON_* constants) has already
         * happened and in the queue. Useful when the order of events is important.
         */
        boolean hasCallbackAlreadyHappened(int callback) {
            synchronized (mLocalLock) {
                return mCallbackQueue.contains(callback);
            }
        }

        /**
         * Returns the last created publish discovery session.
         */
        PublishDiscoverySession getPublishDiscoverySession() {
            PublishDiscoverySession session = mPublishDiscoverySession;
            mPublishDiscoverySession = null;
            return session;
        }

        /**
         * Returns the last created subscribe discovery session.
         */
        SubscribeDiscoverySession getSubscribeDiscoverySession() {
            SubscribeDiscoverySession session = mSubscribeDiscoverySession;
            mSubscribeDiscoverySession = null;
            return session;
        }
    }

    private class NetworkCallbackTest extends ConnectivityManager.NetworkCallback {
        private CountDownLatch mBlocker = new CountDownLatch(1);

        @Override
        public void onUnavailable() {
            mBlocker.countDown();
        }

        /**
         * Wait for the onUnavailable() callback to be triggered. Returns true if triggered,
         * otherwise (timed-out, interrupted) returns false.
         */
        boolean waitForOnUnavailable() {
            try {
                return mBlocker.await(WAIT_FOR_NETWORK_STATE_CHANGE_SECS, TimeUnit.SECONDS);
            } catch (InterruptedException e) {
                return false;
            }
        }
    }

    @Override
    protected void setUp() throws Exception {
        super.setUp();

        if (!TestUtils.shouldTestWifiAware(getContext())) {
            return;
        }

        assertTrue(""Wi-Fi Aware requires Location to be Enabled"",
                ((LocationManager) getContext().getSystemService(
                        Context.LOCATION_SERVICE)).isLocationEnabled());

        mWifiAwareManager = (WifiAwareManager) getContext().getSystemService(
                Context.WIFI_AWARE_SERVICE);
        assertNotNull(""Wi-Fi Aware Manager"", mWifiAwareManager);

        mWifiManager = (WifiManager) getContext().getSystemService(Context.WIFI_SERVICE);
        assertNotNull(""Wi-Fi Manager"", mWifiManager);

        // turn on verbose logging for tests
        mWasVerboseLoggingEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.isVerboseLoggingEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setVerboseLoggingEnabled(true));

        // Turn on Wi-Fi
        mWifiLock = mWifiManager.createWifiLock(TAG);
        mWifiLock.acquire();
        if (!mWifiManager.isWifiEnabled()) {
            SystemUtil.runShellCommand(""svc wifi enable"");
        }

        mConnectivityManager = (ConnectivityManager) getContext().getSystemService(
                Context.CONNECTIVITY_SERVICE);
        assertNotNull(""Connectivity Manager"", mConnectivityManager);

        IntentFilter intentFilter = new IntentFilter();
        intentFilter.addAction(WifiAwareManager.ACTION_WIFI_AWARE_STATE_CHANGED);
        WifiAwareBroadcastReceiver receiver = new WifiAwareBroadcastReceiver();
        mContext.registerReceiver(receiver, intentFilter);
        if (!mWifiAwareManager.isAvailable()) {
            assertTrue(""Timeout waiting for Wi-Fi Aware to change status"",
                    receiver.waitForStateChange());
            assertTrue(""Wi-Fi Aware is not available (should be)"", mWifiAwareManager.isAvailable());
        }
    }

    @Override
    protected void tearDown() throws Exception {
        if (!TestUtils.shouldTestWifiAware(getContext())) {
            super.tearDown();
            return;
        }

        synchronized (mLock) {
            for (WifiAwareSession session : mSessions) {
                // no damage from destroying twice (i.e. ok if test cleaned up after itself already)
                session.close();
            }
            mSessions.clear();
        }

        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setVerboseLoggingEnabled(mWasVerboseLoggingEnabled));

        super.tearDown();
        Thread.sleep(INTERVAL_BETWEEN_TESTS_SECS * 1000);
    }

    /**
     * Validate:
     * - Characteristics are available
     * - Characteristics values are legitimate. Not in the CDD. However, the tested values are
     *   based on the Wi-Fi Aware protocol.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.aware.cts.SingleDeviceTest"	"testCharacteristics"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/aware/cts/SingleDeviceTest.java"	""	"public void testCharacteristics() {
        if (!TestUtils.shouldTestWifiAware(getContext())) {
            return;
        }

        Characteristics characteristics = mWifiAwareManager.getCharacteristics();
        assertNotNull(""Wi-Fi Aware characteristics are null"", characteristics);
        assertEquals(""Service Name Length"", characteristics.getMaxServiceNameLength(), 255);
        assertEquals(""Service Specific Information Length"",
                characteristics.getMaxServiceSpecificInfoLength(), 255);
        assertEquals(""Match Filter Length"", characteristics.getMaxMatchFilterLength(), 255);
        assertNotEquals(""Cipher suites"", characteristics.getSupportedCipherSuites(), 0);
        if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
            mWifiAwareManager.enableInstantCommunicationMode(true);
            assertEquals(mWifiAwareManager.isInstantCommunicationModeEnabled(),
                    characteristics.isInstantCommunicationModeSupported());
            mWifiAwareManager.enableInstantCommunicationMode(false);
        }
    }

    /**
     * Validate:
     * - AwareResources are available
     * - AwareResources values are legitimate. When no resources are used, the value should equal to
     *   the capability.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.aware.cts.SingleDeviceTest"	"testAvailableAwareResources"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/aware/cts/SingleDeviceTest.java"	""	"public void testAvailableAwareResources() {
        if (!(TestUtils.shouldTestWifiAware(getContext())
                && WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(getContext()))) {
            return;
        }
        AwareResources resources = mWifiAwareManager.getAvailableAwareResources();
        assertNotNull(""Available aware resources are null"", resources);
        assertTrue(resources.getAvailableDataPathsCount() > 0);
        assertTrue(resources.getAvailablePublishSessionsCount() > 0);
        assertTrue(resources.getAvailableSubscribeSessionsCount() > 0);
    }

    /**
     * Validate that on Wi-Fi Aware availability change we get a broadcast + the API returns
     * correct status.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.aware.cts.SingleDeviceTest"	"testAvailabilityStatusChange"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/aware/cts/SingleDeviceTest.java"	""	"public void testAvailabilityStatusChange() throws Exception {
        if (!TestUtils.shouldTestWifiAware(getContext())) {
            return;
        }

        IntentFilter intentFilter = new IntentFilter();
        intentFilter.addAction(WifiAwareManager.ACTION_WIFI_AWARE_STATE_CHANGED);

        // 1. Disable Wi-Fi
        WifiAwareBroadcastReceiver receiver1 = new WifiAwareBroadcastReceiver();
        mContext.registerReceiver(receiver1, intentFilter);
        SystemUtil.runShellCommand(""svc wifi disable"");

        assertTrue(""Timeout waiting for Wi-Fi Aware to change status"",
                receiver1.waitForStateChange());
        // Interface down event may happen before Wifi State change. In that case, Aware available
        // state will keep true for a short time.
        if (mWifiAwareManager.isAvailable()) {
            assertTrue(""Timeout waiting for Wi-Fi Aware to change status"",
                    receiver1.waitForStateChange());
        }
        assertFalse(""Wi-Fi Aware is available (should not be)"", mWifiAwareManager.isAvailable());

        // 2. Enable Wi-Fi
        WifiAwareBroadcastReceiver receiver2 = new WifiAwareBroadcastReceiver();
        mContext.registerReceiver(receiver2, intentFilter);
        SystemUtil.runShellCommand(""svc wifi enable"");

        assertTrue(""Timeout waiting for Wi-Fi Aware to change status"",
                receiver2.waitForStateChange());
        assertTrue(""Wi-Fi Aware is not available (should be)"", mWifiAwareManager.isAvailable());
    }

    /**
     * Validate that can attach to Wi-Fi Aware.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.aware.cts.SingleDeviceTest"	"testAttachNoIdentity"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/aware/cts/SingleDeviceTest.java"	""	"public void testAttachNoIdentity() {
        if (!TestUtils.shouldTestWifiAware(getContext())) {
            return;
        }

        WifiAwareSession session = attachAndGetSession();
        session.close();
        if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(getContext())) {
            assertFalse(mWifiAwareManager.isDeviceAttached());
        }
    }

    /**
     * Validate that can attach to Wi-Fi Aware and get identity information. Use the identity
     * information to validate that MAC address changes on every attach.
     *
     * Note: relies on no other entity using Wi-Fi Aware during the CTS test. Since if it is used
     * then the attach/destroy will not correspond to enable/disable and will not result in a new
     * MAC address being generated.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.aware.cts.SingleDeviceTest"	"testAttachDiscoveryAddressChanges"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/aware/cts/SingleDeviceTest.java"	""	"public void testAttachDiscoveryAddressChanges() {
        if (!TestUtils.shouldTestWifiAware(getContext())) {
            return;
        }

        final int numIterations = 10;
        Set<TestUtils.MacWrapper> macs = new HashSet<>();

        for (int i = 0; i < numIterations; ++i) {
            AttachCallbackTest attachCb = new AttachCallbackTest();
            IdentityChangedListenerTest identityL = new IdentityChangedListenerTest();
            mWifiAwareManager.attach(attachCb, identityL, mHandler);
            assertEquals(""Wi-Fi Aware attach: iteration "" + i, AttachCallbackTest.ATTACHED,
                    attachCb.waitForAnyCallback());
            assertTrue(""Wi-Fi Aware attach: iteration "" + i, identityL.waitForListener());

            WifiAwareSession session = attachCb.getSession();
            assertNotNull(""Wi-Fi Aware session: iteration "" + i, session);

            byte[] mac = identityL.getMac();
            assertNotNull(""Wi-Fi Aware discovery MAC: iteration "" + i, mac);

            session.close();

            macs.add(new TestUtils.MacWrapper(mac));
        }

        assertEquals("""", numIterations, macs.size());
    }

    /**
     * Validate a successful publish discovery session lifetime: publish, update publish, destroy.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.aware.cts.SingleDeviceTest"	"testPublishDiscoverySuccess"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/aware/cts/SingleDeviceTest.java"	""	"public void testPublishDiscoverySuccess() {
        if (!TestUtils.shouldTestWifiAware(getContext())) {
            return;
        }

        final String serviceName = ""ValidName"";

        WifiAwareSession session = attachAndGetSession();

        PublishConfig publishConfig = new PublishConfig.Builder().setServiceName(
                serviceName).build();
        DiscoverySessionCallbackTest discoveryCb = new DiscoverySessionCallbackTest();
        int numOfAllPublishSessions = 0;
        if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(getContext())) {
            numOfAllPublishSessions = mWifiAwareManager
                    .getAvailableAwareResources().getAvailablePublishSessionsCount();
        }

        // 1. publish
        session.publish(publishConfig, discoveryCb, mHandler);
        assertTrue(""Publish started"",
                discoveryCb.waitForCallback(DiscoverySessionCallbackTest.ON_PUBLISH_STARTED));
        PublishDiscoverySession discoverySession = discoveryCb.getPublishDiscoverySession();
        assertNotNull(""Publish session"", discoverySession);
        assertFalse(discoveryCb.waitForCallback(
                DiscoverySessionCallbackTest.ON_SERVICE_DISCOVERED));
        assertFalse(discoveryCb.waitForCallback(
                DiscoverySessionCallbackTest.ON_SESSION_DISCOVERED_LOST));
        if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(getContext())) {
            assertEquals(numOfAllPublishSessions - 1, mWifiAwareManager
                    .getAvailableAwareResources().getAvailablePublishSessionsCount());
        }
        // 2. update-publish
        publishConfig = new PublishConfig.Builder().setServiceName(
                serviceName).setServiceSpecificInfo(""extras"".getBytes()).build();
        discoverySession.updatePublish(publishConfig);
        assertTrue(""Publish update"", discoveryCb.waitForCallback(
                DiscoverySessionCallbackTest.ON_SESSION_CONFIG_UPDATED));

        // 3. destroy
        assertFalse(""Publish not terminated"", discoveryCb.hasCallbackAlreadyHappened(
                DiscoverySessionCallbackTest.ON_SESSION_TERMINATED));
        discoverySession.close();

        // 4. try update post-destroy: should time-out waiting for cb
        discoverySession.updatePublish(publishConfig);
        assertFalse(""Publish update post destroy"", discoveryCb.waitForCallback(
                DiscoverySessionCallbackTest.ON_SESSION_CONFIG_UPDATED));
        if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(getContext())) {
            assertEquals(numOfAllPublishSessions, mWifiAwareManager
                    .getAvailableAwareResources().getAvailablePublishSessionsCount());
        }
        session.close();
    }

    /**
     * Validate that publish with a Time To Live (TTL) setting expires within the specified
     * time (and validates that the terminate callback is triggered).
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.aware.cts.SingleDeviceTest"	"testPublishLimitedTtlSuccess"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/aware/cts/SingleDeviceTest.java"	""	"public void testPublishLimitedTtlSuccess() {
        if (!TestUtils.shouldTestWifiAware(getContext())) {
            return;
        }

        final String serviceName = ""ValidName"";
        final int ttlSec = 5;

        WifiAwareSession session = attachAndGetSession();

        PublishConfig publishConfig = new PublishConfig.Builder().setServiceName(
                serviceName).setTtlSec(ttlSec).setTerminateNotificationEnabled(true).build();
        DiscoverySessionCallbackTest discoveryCb = new DiscoverySessionCallbackTest();

        // 1. publish
        session.publish(publishConfig, discoveryCb, mHandler);
        assertTrue(""Publish started"",
                discoveryCb.waitForCallback(DiscoverySessionCallbackTest.ON_PUBLISH_STARTED));
        PublishDiscoverySession discoverySession = discoveryCb.getPublishDiscoverySession();
        assertNotNull(""Publish session"", discoverySession);

        // 2. wait for terminate within 'ttlSec'.
        assertTrue(""Publish terminated"",
                discoveryCb.waitForCallback(DiscoverySessionCallbackTest.ON_SESSION_TERMINATED,
                        ttlSec + 5));

        // 3. try update post-termination: should time-out waiting for cb
        publishConfig = new PublishConfig.Builder().setServiceName(
                serviceName).setServiceSpecificInfo(""extras"".getBytes()).build();
        discoverySession.updatePublish(publishConfig);
        assertFalse(""Publish update post terminate"", discoveryCb.waitForCallback(
                DiscoverySessionCallbackTest.ON_SESSION_CONFIG_UPDATED));

        session.close();
    }

    /**
     * Validate a successful subscribe discovery session lifetime: subscribe, update subscribe,
     * destroy.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.aware.cts.SingleDeviceTest"	"testSubscribeDiscoverySuccess"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/aware/cts/SingleDeviceTest.java"	""	"public void testSubscribeDiscoverySuccess() {
        if (!TestUtils.shouldTestWifiAware(getContext())) {
            return;
        }

        final String serviceName = ""ValidName"";

        WifiAwareSession session = attachAndGetSession();

        SubscribeConfig subscribeConfig = new SubscribeConfig.Builder().setServiceName(
                serviceName).build();
        DiscoverySessionCallbackTest discoveryCb = new DiscoverySessionCallbackTest();
        int numOfAllSubscribeSessions = 0;
        if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(getContext())) {
            numOfAllSubscribeSessions = mWifiAwareManager
                    .getAvailableAwareResources().getAvailableSubscribeSessionsCount();
        }
        // 1. subscribe
        session.subscribe(subscribeConfig, discoveryCb, mHandler);
        assertTrue(""Subscribe started"",
                discoveryCb.waitForCallback(DiscoverySessionCallbackTest.ON_SUBSCRIBE_STARTED));
        SubscribeDiscoverySession discoverySession = discoveryCb.getSubscribeDiscoverySession();
        assertNotNull(""Subscribe session"", discoverySession);
        assertFalse(discoveryCb.waitForCallback(
                DiscoverySessionCallbackTest.ON_SERVICE_DISCOVERED));
        assertFalse(discoveryCb.waitForCallback(
                DiscoverySessionCallbackTest.ON_SESSION_DISCOVERED_LOST));
        if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(getContext())) {
            assertEquals(numOfAllSubscribeSessions - 1, mWifiAwareManager
                    .getAvailableAwareResources().getAvailableSubscribeSessionsCount());
        }

        // 2. update-subscribe
        boolean rttSupported = getContext().getPackageManager().hasSystemFeature(
                    PackageManager.FEATURE_WIFI_RTT);
        SubscribeConfig.Builder builder = new SubscribeConfig.Builder().setServiceName(
                    serviceName).setServiceSpecificInfo(""extras"".getBytes());

        if (rttSupported) {
            builder.setMinDistanceMm(MIN_DISTANCE_MM);
        }
        subscribeConfig = builder.build();

        discoverySession.updateSubscribe(subscribeConfig);
        assertTrue(""Subscribe update"", discoveryCb.waitForCallback(
                DiscoverySessionCallbackTest.ON_SESSION_CONFIG_UPDATED));

        // 3. destroy
        assertFalse(""Subscribe not terminated"", discoveryCb.hasCallbackAlreadyHappened(
                DiscoverySessionCallbackTest.ON_SESSION_TERMINATED));
        discoverySession.close();

        // 4. try update post-destroy: should time-out waiting for cb
        discoverySession.updateSubscribe(subscribeConfig);
        assertFalse(""Subscribe update post destroy"", discoveryCb.waitForCallback(
                DiscoverySessionCallbackTest.ON_SESSION_CONFIG_UPDATED));
        if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(getContext())) {
            assertEquals(numOfAllSubscribeSessions, mWifiAwareManager
                    .getAvailableAwareResources().getAvailableSubscribeSessionsCount());
        }
        session.close();
    }

    /**
     * Validate that subscribe with a Time To Live (TTL) setting expires within the specified
     * time (and validates that the terminate callback is triggered).
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.aware.cts.SingleDeviceTest"	"testSubscribeLimitedTtlSuccess"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/aware/cts/SingleDeviceTest.java"	""	"public void testSubscribeLimitedTtlSuccess() {
        if (!TestUtils.shouldTestWifiAware(getContext())) {
            return;
        }

        final String serviceName = ""ValidName"";
        final int ttlSec = 5;

        WifiAwareSession session = attachAndGetSession();

        SubscribeConfig subscribeConfig = new SubscribeConfig.Builder().setServiceName(
                serviceName).setTtlSec(ttlSec).setTerminateNotificationEnabled(true).build();
        DiscoverySessionCallbackTest discoveryCb = new DiscoverySessionCallbackTest();

        // 1. subscribe
        session.subscribe(subscribeConfig, discoveryCb, mHandler);
        assertTrue(""Subscribe started"",
                discoveryCb.waitForCallback(DiscoverySessionCallbackTest.ON_SUBSCRIBE_STARTED));
        SubscribeDiscoverySession discoverySession = discoveryCb.getSubscribeDiscoverySession();
        assertNotNull(""Subscribe session"", discoverySession);

        // 2. wait for terminate within 'ttlSec'.
        assertTrue(""Subscribe terminated"",
                discoveryCb.waitForCallback(DiscoverySessionCallbackTest.ON_SESSION_TERMINATED,
                        ttlSec + 5));

        // 3. try update post-termination: should time-out waiting for cb
        subscribeConfig = new SubscribeConfig.Builder().setServiceName(
                serviceName).setServiceSpecificInfo(""extras"".getBytes()).build();
        discoverySession.updateSubscribe(subscribeConfig);
        assertFalse(""Subscribe update post terminate"", discoveryCb.waitForCallback(
                DiscoverySessionCallbackTest.ON_SESSION_CONFIG_UPDATED));

        session.close();
    }

    /**
     * Test the send message flow. Since testing single device cannot send to a real peer -
     * validate that sending to a bogus peer fails.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.aware.cts.SingleDeviceTest"	"testSendMessageFail"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/aware/cts/SingleDeviceTest.java"	""	"public void testSendMessageFail() {
        if (!TestUtils.shouldTestWifiAware(getContext())) {
            return;
        }

        WifiAwareSession session = attachAndGetSession();

        PublishConfig publishConfig = new PublishConfig.Builder().setServiceName(
                ""ValidName"").build();
        DiscoverySessionCallbackTest discoveryCb = new DiscoverySessionCallbackTest();

        // 1. publish
        session.publish(publishConfig, discoveryCb, mHandler);
        assertTrue(""Publish started"",
                discoveryCb.waitForCallback(DiscoverySessionCallbackTest.ON_PUBLISH_STARTED));
        PublishDiscoverySession discoverySession = discoveryCb.getPublishDiscoverySession();
        assertNotNull(""Publish session"", discoverySession);

        // 2. send a message with a null peer-handle - expect exception
        try {
            discoverySession.sendMessage(null, -1290, ""some message"".getBytes());
            fail(""Expected IllegalArgumentException"");
        } catch (IllegalArgumentException e) {
            // empty
        }

        discoverySession.close();
        session.close();
    }

    /**
     * Request an Aware data-path (open) as a Responder with an arbitrary peer MAC address. Validate
     * that receive an onUnavailable() callback.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.aware.cts.SingleDeviceTest"	"testDataPathOpenOutOfBandFail"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/aware/cts/SingleDeviceTest.java"	""	"public void testDataPathOpenOutOfBandFail() throws InterruptedException {
        if (!TestUtils.shouldTestWifiAware(getContext())) {
            return;
        }
        MacAddress mac = MacAddress.fromString(""00:01:02:03:04:05"");

        // 1. initialize Aware: only purpose is to make sure it is available for OOB data-path
        WifiAwareSession session = attachAndGetSession();

        PublishConfig publishConfig = new PublishConfig.Builder().setServiceName(
                ""ValidName"").build();
        DiscoverySessionCallbackTest discoveryCb = new DiscoverySessionCallbackTest();
        session.publish(publishConfig, discoveryCb, mHandler);
        assertTrue(""Publish started"",
                discoveryCb.waitForCallback(DiscoverySessionCallbackTest.ON_PUBLISH_STARTED));
        Thread.sleep(WAIT_FOR_AWARE_INTERFACE_CREATION_SEC * 1000);

        // 2. request an AWARE network
        NetworkCallbackTest networkCb = new NetworkCallbackTest();
        NetworkRequest nr = new NetworkRequest.Builder().addTransportType(
                NetworkCapabilities.TRANSPORT_WIFI_AWARE).setNetworkSpecifier(
                session.createNetworkSpecifierOpen(
                        WifiAwareManager.WIFI_AWARE_DATA_PATH_ROLE_INITIATOR,
                        mac.toByteArray())).build();
        mConnectivityManager.requestNetwork(nr, networkCb);
        assertTrue(""OnUnavailable not received"", networkCb.waitForOnUnavailable());

        session.close();
    }

    /**
     * Request an Aware data-path (encrypted with Passphrase) as a Responder with an arbitrary peer
     * MAC address.
     * Validate that receive an onUnavailable() callback.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.aware.cts.SingleDeviceTest"	"testDataPathPassphraseOutOfBandFail"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/aware/cts/SingleDeviceTest.java"	""	"public void testDataPathPassphraseOutOfBandFail() throws InterruptedException {
        if (!TestUtils.shouldTestWifiAware(getContext())) {
            return;
        }
        MacAddress mac = MacAddress.fromString(""00:01:02:03:04:05"");

        // 1. initialize Aware: only purpose is to make sure it is available for OOB data-path
        WifiAwareSession session = attachAndGetSession();

        PublishConfig publishConfig = new PublishConfig.Builder().setServiceName(
                ""ValidName"").build();
        DiscoverySessionCallbackTest discoveryCb = new DiscoverySessionCallbackTest();
        session.publish(publishConfig, discoveryCb, mHandler);
        assertTrue(""Publish started"",
                discoveryCb.waitForCallback(DiscoverySessionCallbackTest.ON_PUBLISH_STARTED));
        Thread.sleep(WAIT_FOR_AWARE_INTERFACE_CREATION_SEC * 1000);

        // 2. request an AWARE network
        NetworkCallbackTest networkCb = new NetworkCallbackTest();
        NetworkRequest nr = new NetworkRequest.Builder().addTransportType(
                NetworkCapabilities.TRANSPORT_WIFI_AWARE).setNetworkSpecifier(
                session.createNetworkSpecifierPassphrase(
                        WifiAwareManager.WIFI_AWARE_DATA_PATH_ROLE_INITIATOR, mac.toByteArray(),
                        ""abcdefghihk"")).build();
        mConnectivityManager.requestNetwork(nr, networkCb);
        assertTrue(""OnUnavailable not received"", networkCb.waitForOnUnavailable());

        session.close();
    }

    /**
     * Request an Aware data-path (encrypted with PMK) as a Responder with an arbitrary peer MAC
     * address.
     * Validate that receive an onUnavailable() callback.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.aware.cts.SingleDeviceTest"	"testDataPathPmkOutOfBandFail"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/aware/cts/SingleDeviceTest.java"	""	"public void testDataPathPmkOutOfBandFail() throws InterruptedException {
        if (!TestUtils.shouldTestWifiAware(getContext())) {
            return;
        }
        MacAddress mac = MacAddress.fromString(""00:01:02:03:04:05"");

        // 1. initialize Aware: only purpose is to make sure it is available for OOB data-path
        WifiAwareSession session = attachAndGetSession();

        PublishConfig publishConfig = new PublishConfig.Builder().setServiceName(
                ""ValidName"").build();
        DiscoverySessionCallbackTest discoveryCb = new DiscoverySessionCallbackTest();
        session.publish(publishConfig, discoveryCb, mHandler);
        assertTrue(""Publish started"",
                discoveryCb.waitForCallback(DiscoverySessionCallbackTest.ON_PUBLISH_STARTED));
        Thread.sleep(WAIT_FOR_AWARE_INTERFACE_CREATION_SEC * 1000);

        // 2. request an AWARE network
        NetworkCallbackTest networkCb = new NetworkCallbackTest();
        NetworkRequest nr = new NetworkRequest.Builder().addTransportType(
                NetworkCapabilities.TRANSPORT_WIFI_AWARE).setNetworkSpecifier(
                session.createNetworkSpecifierPmk(
                        WifiAwareManager.WIFI_AWARE_DATA_PATH_ROLE_INITIATOR, mac.toByteArray(),
                        PMK_VALID)).build();
        mConnectivityManager.requestNetwork(nr, networkCb);
        assertTrue(""OnUnavailable not received"", networkCb.waitForOnUnavailable());

        session.close();
    }

    /**
     * Test WifiAwareNetworkSpecifier.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.aware.cts.SingleDeviceTest"	"testWifiAwareNetworkSpecifier"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/aware/cts/SingleDeviceTest.java"	""	"public void testWifiAwareNetworkSpecifier() {
        DiscoverySession session = mock(DiscoverySession.class);
        PeerHandle handle = mock(PeerHandle.class);
        WifiAwareNetworkSpecifier networkSpecifier =
                new WifiAwareNetworkSpecifier.Builder(session, handle).build();
        assertFalse(networkSpecifier.canBeSatisfiedBy(null));
        assertTrue(networkSpecifier.canBeSatisfiedBy(networkSpecifier));

        WifiAwareNetworkSpecifier anotherNetworkSpecifier =
                new WifiAwareNetworkSpecifier.Builder(session, handle).setPmk(PMK_VALID).build();
        assertFalse(networkSpecifier.canBeSatisfiedBy(anotherNetworkSpecifier));
    }

    /**
     * Test ParcelablePeerHandle parcel.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.aware.cts.SingleDeviceTest"	"testAwareResourcesConstructor"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/aware/cts/SingleDeviceTest.java"	""	"public void testAwareResourcesConstructor() {
        if (!WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(getContext())) {
            return;
        }
        AwareResources awareResources = new AwareResources(AVAILABLE_DATA_PATH_COUNT,
                AVAILABLE_PUBLISH_SESSION_COUNT, AVAILABLE_SUBSCRIBE_SESSION_COUNT);
        assertEquals(AVAILABLE_DATA_PATH_COUNT, awareResources.getAvailableDataPathsCount());
        assertEquals(AVAILABLE_PUBLISH_SESSION_COUNT, awareResources
                .getAvailablePublishSessionsCount());
        assertEquals(AVAILABLE_SUBSCRIBE_SESSION_COUNT, awareResources
                .getAvailableSubscribeSessionsCount());
    }

    // local utilities

    private WifiAwareSession attachAndGetSession() {
        AttachCallbackTest attachCb = new AttachCallbackTest();
        mWifiAwareManager.attach(attachCb, mHandler);
        int cbCalled = attachCb.waitForAnyCallback();
        assertEquals(""Wi-Fi Aware attach"", AttachCallbackTest.ATTACHED, cbCalled);

        WifiAwareSession session = attachCb.getSession();
        assertNotNull(""Wi-Fi Aware session"", session);
        if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
            assertTrue(mWifiAwareManager.isDeviceAttached());
        }

        return session;
    }
}"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiLockTest"	"testHiPerfWifiLock"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiLockTest.java"	""	"public void testHiPerfWifiLock() {
        testWifiLock(WifiManager.WIFI_MODE_FULL_HIGH_PERF);
    }

    /**
     * Verify acquire and release of Low latency wifi locks
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiLockTest"	"testLowLatencyWifiLock"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiLockTest.java"	""	"public void testLowLatencyWifiLock() {
        testWifiLock(WifiManager.WIFI_MODE_FULL_LOW_LATENCY);
    }

    private void testWifiLock(int lockType) {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        WifiManager wm = (WifiManager) getContext().getSystemService(Context.WIFI_SERVICE);
        WifiLock wl = wm.createWifiLock(lockType, WIFI_TAG);

        wl.setReferenceCounted(true);
        wl.setWorkSource(new WorkSource());
        assertFalse(wl.isHeld());
        wl.acquire();
        assertTrue(wl.isHeld());
        wl.release();
        assertFalse(wl.isHeld());
        wl.acquire();
        wl.acquire();
        assertTrue(wl.isHeld());
        wl.release();
        assertTrue(wl.isHeld());
        wl.release();
        assertFalse(wl.isHeld());
        assertNotNull(wl.toString());
        try {
            wl.release();
            fail(""should throw out exception because release is called""
                    +"" a greater number of times than acquire"");
        } catch (RuntimeException e) {
            // expected
        }

        wl = wm.createWifiLock(lockType, WIFI_TAG);
        wl.setReferenceCounted(false);
        assertFalse(wl.isHeld());
        wl.acquire();
        assertTrue(wl.isHeld());
        wl.release();
        assertFalse(wl.isHeld());
        wl.acquire();
        wl.acquire();
        assertTrue(wl.isHeld());
        wl.release();
        assertFalse(wl.isHeld());
        assertNotNull(wl.toString());
        // releasing again after release: but ignored for non-referenced locks
        wl.release();
    }
}"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.ScanResultTest"	"testScanResultProperties"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ScanResultTest.java"	""	"public void testScanResultProperties() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // this test case should in Wifi environment
        for (ScanResult scanResult : mWifiManager.getScanResults()) {
            assertThat(scanResult.toString()).isNotNull();

            for (InformationElement ie : scanResult.getInformationElements()) {
                testInformationElementCopyConstructor(ie);
                testInformationElementFields(ie);
            }

            assertThat(scanResult.getWifiStandard()).isAnyOf(
                    ScanResult.WIFI_STANDARD_UNKNOWN,
                    ScanResult.WIFI_STANDARD_LEGACY,
                    ScanResult.WIFI_STANDARD_11N,
                    ScanResult.WIFI_STANDARD_11AC,
                    ScanResult.WIFI_STANDARD_11AX
            );

            scanResult.isPasspointNetwork();
        }
    }

    private void testInformationElementCopyConstructor(InformationElement ie) {
        InformationElement copy = new InformationElement(ie);

        assertThat(copy.getId()).isEqualTo(ie.getId());
        assertThat(copy.getIdExt()).isEqualTo(ie.getIdExt());
        assertThat(copy.getBytes()).isEqualTo(ie.getBytes());
    }

    private void testInformationElementFields(InformationElement ie) {
        // id is 1 octet
        int id = ie.getId();
        assertThat(id).isAtLeast(0);
        assertThat(id).isAtMost(255);

        // idExt is 0 or 1 octet
        int idExt = ie.getIdExt();
        assertThat(idExt).isAtLeast(0);
        assertThat(idExt).isAtMost(255);

        ByteBuffer bytes = ie.getBytes();
        assertThat(bytes).isNotNull();
    }

    /* Multiple scans to ensure bssid is updated */
    private void scanAndWait() throws Exception {
        synchronized (mMySync) {
            for (int retry  = 0; retry < SCAN_MAX_RETRY_COUNT; retry++) {
                mMySync.expectedState = STATE_START_SCAN;
                mWifiManager.startScan();
                if (waitForBroadcast(SCAN_WAIT_MSEC, STATE_SCAN_RESULTS_AVAILABLE)) {
                    break;
                }
            }
        }
   }

    @VirtualDeviceNotSupported"	""	""	"passpoint wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.ScanResultTest"	"isNotNull"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ScanResultTest.java"	""	"public void test/*
 *.
 */

package android.net.wifi.cts;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import java.nio.ByteBuffer;
import java.util.List;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.net.wifi.ScanResult;
import android.net.wifi.ScanResult.InformationElement;
import android.net.wifi.WifiInfo;
import android.net.wifi.WifiManager;
import android.net.wifi.WifiManager.WifiLock;
import android.platform.test.annotations.AppModeFull;
import android.test.AndroidTestCase;

import com.android.compatibility.common.util.PollingCheck;
import com.android.compatibility.common.util.ShellIdentityUtils;
import com.android.compatibility.common.util.SystemUtil;

@AppModeFull(reason = ""Cannot get WifiManager in instant app mode"")
public class ScanResultTest extends WifiJUnit3TestBase {
    private static class MySync {
        int expectedState = STATE_NULL;
    }

    private WifiManager mWifiManager;
    private WifiLock mWifiLock;
    private static MySync mMySync;
    private boolean mWasVerboseLoggingEnabled;
    private boolean mWasScanThrottleEnabled;

    private static final int STATE_NULL = 0;
    private static final int STATE_WIFI_CHANGING = 1;
    private static final int STATE_WIFI_CHANGED = 2;
    private static final int STATE_START_SCAN = 3;
    private static final int STATE_SCAN_RESULTS_AVAILABLE = 4;
    private static final int STATE_SCAN_FAILURE = 5;

    private static final String TAG = ""WifiInfoTest"";
    private static final int TIMEOUT_MSEC = 6000;
    private static final int WAIT_MSEC = 60;
    private static final int ENABLE_WAIT_MSEC = 10000;
    private static final int SCAN_WAIT_MSEC = 10000;
    private static final int SCAN_MAX_RETRY_COUNT = 6;
    private static final int SCAN_FIND_BSSID_MAX_RETRY_COUNT = 5;
    private static final long SCAN_FIND_BSSID_WAIT_MSEC = 5_000L;
    private static final int WIFI_CONNECT_TIMEOUT_MILLIS = 30_000;

    private static final String TEST_SSID = ""TEST_SSID"";
    public static final String TEST_BSSID = ""04:ac:fe:45:34:10"";
    public static final String TEST_CAPS = ""CCMP"";
    public static final int TEST_LEVEL = -56;
    public static final int TEST_FREQUENCY = 2412;
    public static final long TEST_TIMESTAMP = 4660L;

    private IntentFilter mIntentFilter;
    private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            final String action = intent.getAction();
            if (action.equals(WifiManager.SUPPLICANT_STATE_CHANGED_ACTION)) {
                synchronized (mMySync) {
                    mMySync.expectedState = STATE_WIFI_CHANGED;
                    mMySync.notify();
                }
            } else if (action.equals(WifiManager.SCAN_RESULTS_AVAILABLE_ACTION)) {
                synchronized (mMySync) {
                    if (intent.getBooleanExtra(WifiManager.EXTRA_RESULTS_UPDATED, false)) {
                        mMySync.expectedState = STATE_SCAN_RESULTS_AVAILABLE;
                    } else {
                        mMySync.expectedState = STATE_SCAN_FAILURE;
                    }
                    mMySync.notify();
                }
            }
        }
    };

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        mMySync = new MySync();
        mIntentFilter = new IntentFilter();
        mIntentFilter.addAction(WifiManager.NETWORK_STATE_CHANGED_ACTION);
        mIntentFilter.addAction(WifiManager.SCAN_RESULTS_AVAILABLE_ACTION);
        mIntentFilter.addAction(WifiManager.SUPPLICANT_CONNECTION_CHANGE_ACTION);
        mIntentFilter.addAction(WifiManager.SUPPLICANT_STATE_CHANGED_ACTION);
        mIntentFilter.addAction(WifiManager.WIFI_STATE_CHANGED_ACTION);
        mIntentFilter.addAction(WifiManager.RSSI_CHANGED_ACTION);
        mIntentFilter.addAction(WifiManager.NETWORK_IDS_CHANGED_ACTION);
        mIntentFilter.addAction(WifiManager.ACTION_PICK_WIFI_NETWORK);

        mContext.registerReceiver(mReceiver, mIntentFilter);
        mWifiManager = (WifiManager) getContext().getSystemService(Context.WIFI_SERVICE);
        assertThat(mWifiManager).isNotNull();

        // turn on verbose logging for tests
        mWasVerboseLoggingEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.isVerboseLoggingEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setVerboseLoggingEnabled(true));
        // Disable scan throttling for tests.
        mWasScanThrottleEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.isScanThrottleEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setScanThrottleEnabled(false));

        mWifiLock = mWifiManager.createWifiLock(TAG);
        mWifiLock.acquire();

        // enable Wifi
        if (!mWifiManager.isWifiEnabled()) setWifiEnabled(true);
        PollingCheck.check(""Wifi not enabled"", ENABLE_WAIT_MSEC,
                () -> mWifiManager.isWifiEnabled());

        mMySync.expectedState = STATE_NULL;
    }

    @Override
    protected void tearDown() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            super.tearDown();
            return;
        }
        mWifiLock.release();
        mContext.unregisterReceiver(mReceiver);
        if (!mWifiManager.isWifiEnabled())
            setWifiEnabled(true);
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setScanThrottleEnabled(mWasScanThrottleEnabled));
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setVerboseLoggingEnabled(mWasVerboseLoggingEnabled));
        Thread.sleep(ENABLE_WAIT_MSEC);
        super.tearDown();
    }

    private void setWifiEnabled(boolean enable) throws Exception {
        synchronized (mMySync) {
            mMySync.expectedState = STATE_WIFI_CHANGING;
            if (enable) {
                SystemUtil.runShellCommand(""svc wifi enable"");
            } else {
                SystemUtil.runShellCommand(""svc wifi disable"");
            }
            waitForBroadcast(TIMEOUT_MSEC, STATE_WIFI_CHANGED);
       }
    }

    private boolean waitForBroadcast(long timeout, int expectedState) throws Exception {
        long waitTime = System.currentTimeMillis() + timeout;
        while (System.currentTimeMillis() < waitTime
                && mMySync.expectedState != expectedState)
            mMySync.wait(WAIT_MSEC);
        return mMySync.expectedState == expectedState;
    }"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.ScanResultTest"	"testScanResultTimeStamp"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ScanResultTest.java"	""	"public void testScanResultTimeStamp() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }

        long timestamp = 0;
        String BSSID = null;

        scanAndWait();

        List<ScanResult> scanResults = mWifiManager.getScanResults();
        for (ScanResult result : scanResults) {
            BSSID = result.BSSID;
            timestamp = result.timestamp;
            assertThat(timestamp).isNotEqualTo(0);
            break;
        }

        scanAndWait();

        scanResults = mWifiManager.getScanResults();
        for (ScanResult result : scanResults) {
            if (result.BSSID.equals(BSSID)) {
                long timeDiff = (result.timestamp - timestamp) / 1000;
                assertThat(timeDiff).isGreaterThan(0L);
                assertThat(timeDiff).isLessThan(6L * SCAN_WAIT_MSEC);
            }
        }
    }

    /** Test that the copy constructor copies fields correctly. */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.ScanResultTest"	"testScanResultConstructors"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ScanResultTest.java"	""	"public void testScanResultConstructors() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }

        ScanResult scanResult = new ScanResult();
        scanResult.SSID = TEST_SSID;
        scanResult.BSSID = TEST_BSSID;
        scanResult.capabilities = TEST_CAPS;
        scanResult.level = TEST_LEVEL;
        scanResult.frequency = TEST_FREQUENCY;
        scanResult.timestamp = TEST_TIMESTAMP;

        ScanResult scanResult2 = new ScanResult(scanResult);
        assertThat(scanResult2.SSID).isEqualTo(TEST_SSID);
        assertThat(scanResult2.BSSID).isEqualTo(TEST_BSSID);
        assertThat(scanResult2.capabilities).isEqualTo(TEST_CAPS);
        assertThat(scanResult2.level).isEqualTo(TEST_LEVEL);
        assertThat(scanResult2.frequency).isEqualTo(TEST_FREQUENCY);
        assertThat(scanResult2.timestamp).isEqualTo(TEST_TIMESTAMP);
    }"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.ScanResultTest"	"testScanResultMatchesWifiInfo"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ScanResultTest.java"	""	"public void testScanResultMatchesWifiInfo() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }

        // ensure Wifi is connected
        ShellIdentityUtils.invokeWithShellPermissions(() -> mWifiManager.reconnect());
        PollingCheck.check(
                ""Wifi not connected"",
                WIFI_CONNECT_TIMEOUT_MILLIS,
                () -> mWifiManager.getConnectionInfo().getNetworkId() != -1);

        final WifiInfo wifiInfo = mWifiManager.getConnectionInfo();
        assertThat(wifiInfo).isNotNull();

        ScanResult currentNetwork = null;
        for (int i = 0; i < SCAN_FIND_BSSID_MAX_RETRY_COUNT; i++) {
            scanAndWait();
            final List<ScanResult> scanResults = mWifiManager.getScanResults();
            currentNetwork = scanResults.stream().filter(r -> r.BSSID.equals(wifiInfo.getBSSID()))
                    .findAny().orElse(null);

            if (currentNetwork != null) {
                break;
            }
            Thread.sleep(SCAN_FIND_BSSID_WAIT_MSEC);
        }
        assertWithMessage(""Current network not found in scan results"")
                .that(currentNetwork).isNotNull();

        String wifiInfoSsidQuoted = wifiInfo.getSSID();
        String scanResultSsidUnquoted = currentNetwork.SSID;

        assertWithMessage(
                ""SSID mismatch: make sure this isn't a hidden network or an SSID containing ""
                        + ""non-UTF-8 characters - neither is supported by this CTS test."")
                .that(""\"""" + scanResultSsidUnquoted + ""\"""")
                .isEqualTo(wifiInfoSsidQuoted);
        assertThat(currentNetwork.frequency).isEqualTo(wifiInfo.getFrequency());
    }
}"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.wifiaware.TestListActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/wifiaware/TestListActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.wifiaware;

import android.app.AlertDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.database.DataSetObserver;
import android.net.wifi.aware.WifiAwareManager;
import android.os.Bundle;
import android.provider.Settings;
import android.util.Log;
import android.view.View;
import android.widget.ListView;

import androidx.core.os.BuildCompat;

import com.android.cts.verifier.ArrayTestListAdapter;
import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;
import com.android.cts.verifier.TestListAdapter;

/**
 * Activity listing all Wi-Fi Aware tests.
 */
public class TestListActivity extends PassFailButtons.TestListActivity {
    private static final String TAG = ""TestListActivity"";

    private WifiAwareManager mWifiAwareManager;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        mWifiAwareManager = (WifiAwareManager) getSystemService(Context.WIFI_AWARE_SERVICE);
        if (mWifiAwareManager == null) {
            Log.wtf(TAG,
                    ""Can't get WIFI_AWARE_SERVICE. Should be gated by 'test_required_features'!?"");
            return;
        }

        boolean isRttSupported = getPackageManager().hasSystemFeature(
                PackageManager.FEATURE_WIFI_RTT);

        setContentView(R.layout.pass_fail_list);
        setInfoResources(R.string.aware_test, R.string.aware_test_info, 0);
        setPassFailButtonClickListeners();
        getPassButton().setEnabled(false);

        // Add the sub-test/categories
        ArrayTestListAdapter adapter = new ArrayTestListAdapter(this);

        adapter.add(TestListAdapter.TestListItem.newCategory(this,
                R.string.aware_dp_ib_open_unsolicited));
        adapter.add(TestListAdapter.TestListItem.newTest(this,
                R.string.aware_publish,
                DataPathOpenUnsolicitedPublishTestActivity.class.getName(),
                new Intent(this, DataPathOpenUnsolicitedPublishTestActivity.class), null));
        adapter.add(TestListAdapter.TestListItem.newTest(this,
                R.string.aware_subscribe,
                DataPathOpenPassiveSubscribeTestActivity.class.getName(),
                new Intent(this, DataPathOpenPassiveSubscribeTestActivity.class), null));
        adapter.add(TestListAdapter.TestListItem.newCategory(this,
                R.string.aware_dp_ib_passphrase_unsolicited));
        adapter.add(TestListAdapter.TestListItem.newTest(this,
                R.string.aware_publish,
                DataPathPassphraseUnsolicitedPublishTestActivity.class.getName(),
                new Intent(this, DataPathPassphraseUnsolicitedPublishTestActivity.class), null));
        adapter.add(TestListAdapter.TestListItem.newTest(this,
                R.string.aware_subscribe,
                DataPathPassphrasePassiveSubscribeTestActivity.class.getName(),
                new Intent(this, DataPathPassphrasePassiveSubscribeTestActivity.class), null));
        adapter.add(TestListAdapter.TestListItem.newCategory(this,
                R.string.aware_dp_ib_pmk_unsolicited));
        adapter.add(TestListAdapter.TestListItem.newTest(this,
                R.string.aware_publish,
                DataPathPmkUnsolicitedPublishTestActivity.class.getName(),
                new Intent(this, DataPathPmkUnsolicitedPublishTestActivity.class), null));
        adapter.add(TestListAdapter.TestListItem.newTest(this,
                R.string.aware_subscribe,
                DataPathPmkPassiveSubscribeTestActivity.class.getName(),
                new Intent(this, DataPathPmkPassiveSubscribeTestActivity.class), null));
        adapter.add(TestListAdapter.TestListItem.newCategory(this,
                R.string.aware_dp_ib_open_solicited));
        adapter.add(TestListAdapter.TestListItem.newTest(this,
                R.string.aware_publish,
                DataPathOpenSolicitedPublishTestActivity.class.getName(),
                new Intent(this, DataPathOpenSolicitedPublishTestActivity.class), null));
        adapter.add(TestListAdapter.TestListItem.newTest(this,
                R.string.aware_subscribe,
                DataPathOpenActiveSubscribeTestActivity.class.getName(),
                new Intent(this, DataPathOpenActiveSubscribeTestActivity.class), null));
        adapter.add(TestListAdapter.TestListItem.newCategory(this,
                R.string.aware_dp_ib_passphrase_solicited));
        adapter.add(TestListAdapter.TestListItem.newTest(this,
                R.string.aware_publish,
                DataPathPassphraseSolicitedPublishTestActivity.class.getName(),
                new Intent(this, DataPathPassphraseSolicitedPublishTestActivity.class), null));
        adapter.add(TestListAdapter.TestListItem.newTest(this,
                R.string.aware_subscribe,
                DataPathPassphraseActiveSubscribeTestActivity.class.getName(),
                new Intent(this, DataPathPassphraseActiveSubscribeTestActivity.class), null));
        adapter.add(TestListAdapter.TestListItem.newCategory(this,
                R.string.aware_dp_ib_pmk_solicited));
        adapter.add(TestListAdapter.TestListItem.newTest(this,
                R.string.aware_publish,
                DataPathPmkSolicitedPublishTestActivity.class.getName(),
                new Intent(this, DataPathPmkSolicitedPublishTestActivity.class), null));
        adapter.add(TestListAdapter.TestListItem.newTest(this,
                R.string.aware_subscribe,
                DataPathPmkActiveSubscribeTestActivity.class.getName(),
                new Intent(this, DataPathPmkActiveSubscribeTestActivity.class), null));
        adapter.add(TestListAdapter.TestListItem.newCategory(this,
                R.string.aware_dp_oob_open));
        adapter.add(TestListAdapter.TestListItem.newTest(this,
                R.string.aware_responder,
                DataPathOobOpenResponderTestActivity.class.getName(),
                new Intent(this, DataPathOobOpenResponderTestActivity.class), null));
        adapter.add(TestListAdapter.TestListItem.newTest(this,
                R.string.aware_initiator,
                DataPathOobOpenInitiatorTestActivity.class.getName(),
                new Intent(this, DataPathOobOpenInitiatorTestActivity.class), null));
        adapter.add(TestListAdapter.TestListItem.newCategory(this,
                R.string.aware_dp_oob_passphrase));
        adapter.add(TestListAdapter.TestListItem.newTest(this,
                R.string.aware_responder,
                DataPathOobPassphraseResponderTestActivity.class.getName(),
                new Intent(this, DataPathOobPassphraseResponderTestActivity.class), null));
        adapter.add(TestListAdapter.TestListItem.newTest(this,
                R.string.aware_initiator,
                DataPathOobPassphraseInitiatorTestActivity.class.getName(),
                new Intent(this, DataPathOobPassphraseInitiatorTestActivity.class), null));
        if (isRttSupported) {
            adapter.add(TestListAdapter.TestListItem.newCategory(this,
                    R.string.aware_discovery_ranging));
            adapter.add(TestListAdapter.TestListItem.newTest(this,
                    R.string.aware_publish,
                    DiscoveryRangingPublishTestActivity.class.getName(),
                    new Intent(this, DiscoveryRangingPublishTestActivity.class), null));
            adapter.add(TestListAdapter.TestListItem.newTest(this,
                    R.string.aware_subscribe,
                    DiscoveryRangingSubscribeTestActivity.class.getName(),
                    new Intent(this, DiscoveryRangingSubscribeTestActivity.class), null));
        }

        if (BuildCompat.isAtLeastS()) {
            adapter.add(TestListAdapter.TestListItem.newCategory(this,
                    R.string.aware_dp_ib_open_unsolicited_accept_any));
            adapter.add(TestListAdapter.TestListItem.newTest(this,
                    R.string.aware_publish,
                    DataPathOpenUnsolicitedPublishAcceptAnyTestActivity.class.getName(),
                    new Intent(this, DataPathOpenUnsolicitedPublishAcceptAnyTestActivity.class),
                    null));
            adapter.add(TestListAdapter.TestListItem.newTest(this,
                    R.string.aware_subscribe,
                    DataPathOpenPassiveSubscribeAcceptAnyTestActivity.class.getName(),
                    new Intent(this, DataPathOpenPassiveSubscribeAcceptAnyTestActivity.class),
                    null));
            adapter.add(TestListAdapter.TestListItem.newCategory(this,
                    R.string.aware_dp_ib_passphrase_unsolicited_accept_any));
            adapter.add(TestListAdapter.TestListItem.newTest(this,
                    R.string.aware_publish,
                    DataPathPassphraseUnsolicitedPublishAcceptAnyTestActivity.class.getName(),
                    new Intent(this,
                            DataPathPassphraseUnsolicitedPublishAcceptAnyTestActivity.class),
                    null));
            adapter.add(TestListAdapter.TestListItem.newTest(this,
                    R.string.aware_subscribe,
                    DataPathPassphrasePassiveSubscribeAcceptAnyTestActivity.class.getName(),
                    new Intent(this, DataPathPassphrasePassiveSubscribeAcceptAnyTestActivity.class),
                    null));
            adapter.add(TestListAdapter.TestListItem.newCategory(this,
                    R.string.aware_dp_ib_pmk_unsolicited_accept_any));
            adapter.add(TestListAdapter.TestListItem.newTest(this,
                    R.string.aware_publish,
                    DataPathPmkUnsolicitedPublishAcceptAnyTestActivity.class.getName(),
                    new Intent(this, DataPathPmkUnsolicitedPublishAcceptAnyTestActivity.class),
                    null));
            adapter.add(TestListAdapter.TestListItem.newTest(this,
                    R.string.aware_subscribe,
                    DataPathPmkPassiveSubscribeAcceptAnyTestActivity.class.getName(),
                    new Intent(this, DataPathPmkPassiveSubscribeAcceptAnyTestActivity.class),
                    null));
            adapter.add(TestListAdapter.TestListItem.newCategory(this,
                    R.string.aware_dp_ib_open_solicited_accept_any));
            adapter.add(TestListAdapter.TestListItem.newTest(this,
                    R.string.aware_publish,
                    DataPathOpenSolicitedPublishAcceptAnyTestActivity.class.getName(),
                    new Intent(this, DataPathOpenSolicitedPublishAcceptAnyTestActivity.class),
                    null));
            adapter.add(TestListAdapter.TestListItem.newTest(this,
                    R.string.aware_subscribe,
                    DataPathOpenActiveSubscribeAcceptAnyTestActivity.class.getName(),
                    new Intent(this, DataPathOpenActiveSubscribeAcceptAnyTestActivity.class),
                    null));
            adapter.add(TestListAdapter.TestListItem.newCategory(this,
                    R.string.aware_dp_ib_passphrase_solicited_accept_any));
            adapter.add(TestListAdapter.TestListItem.newTest(this,
                    R.string.aware_publish,
                    DataPathPassphraseSolicitedPublishAcceptAnyTestActivity.class.getName(),
                    new Intent(this, DataPathPassphraseSolicitedPublishAcceptAnyTestActivity.class),
                    null));
            adapter.add(TestListAdapter.TestListItem.newTest(this,
                    R.string.aware_subscribe,
                    DataPathPassphraseActiveSubscribeAcceptAnyTestActivity.class.getName(),
                    new Intent(this, DataPathPassphraseActiveSubscribeAcceptAnyTestActivity.class),
                    null));
            adapter.add(TestListAdapter.TestListItem.newCategory(this,
                    R.string.aware_dp_ib_pmk_solicited_accept_any));
            adapter.add(TestListAdapter.TestListItem.newTest(this,
                    R.string.aware_publish,
                    DataPathPmkSolicitedPublishAcceptAnyTestActivity.class.getName(),
                    new Intent(this, DataPathPmkSolicitedPublishAcceptAnyTestActivity.class),
                    null));
            adapter.add(TestListAdapter.TestListItem.newTest(this,
                    R.string.aware_subscribe,
                    DataPathPmkActiveSubscribeAcceptAnyTestActivity.class.getName(),
                    new Intent(this, DataPathPmkActiveSubscribeAcceptAnyTestActivity.class), null));
        }

        adapter.registerDataSetObserver(new DataSetObserver() {
            @Override
            public void onChanged() {
                updatePassButton();
            }

            @Override
            public void onInvalidated() {
                updatePassButton();
            }
        });

        setTestListAdapter(adapter);
    }

    @Override
    protected void handleItemClick(ListView listView, View view, int position, long id) {
        if (!mWifiAwareManager.isAvailable()) {
            showAwareEnableDialog();
            return;
        }

        super.handleItemClick(listView, view, position, id);
    }

    /**
     * Show the dialog to jump to system settings in order to enable
     * WiFi (and by extension WiFi Aware).
     */
    private void showAwareEnableDialog() {
        AlertDialog.Builder builder = new AlertDialog.Builder(this);
        builder.setIcon(android.R.drawable.ic_dialog_alert);
        builder.setTitle(R.string.aware_not_enabled);
        builder.setMessage(R.string.aware_not_enabled_message);
        builder.setPositiveButton(R.string.aware_settings,
                new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                        startActivity(new Intent(Settings.ACTION_WIFI_SETTINGS));
                    }
                });
        builder.create().show();
    }
}"	""	""	"view wifi button"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"com.android.cts.deviceowner.wificonfigcreator.WifiConfigCreatorActivity"	"finish"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/WifiConfigCreator/src/com/android/cts/deviceowner/wificonfigcreator/WifiConfigCreatorActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.deviceowner.wificonfigcreator;

import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.util.Log;

import com.android.compatibility.common.util.WifiConfigCreator;
import static com.android.compatibility.common.util.WifiConfigCreator.ACTION_CREATE_WIFI_CONFIG;
import static com.android.compatibility.common.util.WifiConfigCreator.EXTRA_NETID;
import static com.android.compatibility.common.util.WifiConfigCreator.EXTRA_PASSWORD;
import static com.android.compatibility.common.util.WifiConfigCreator.EXTRA_SECURITY_TYPE;
import static com.android.compatibility.common.util.WifiConfigCreator.EXTRA_SSID;
import static com.android.compatibility.common.util.WifiConfigCreator.ACTION_REMOVE_WIFI_CONFIG;
import static com.android.compatibility.common.util.WifiConfigCreator.SECURITY_TYPE_NONE;
import static com.android.compatibility.common.util.WifiConfigCreator.ACTION_UPDATE_WIFI_CONFIG;

/**
 * A simple activity to create and manage wifi configurations.
 */
public class WifiConfigCreatorActivity extends Activity {
    private static final String TAG = ""WifiConfigCreatorActivity"";

    @Override
    public void onCreate(Bundle icicle) {
        super.onCreate(icicle);
        Log.i(TAG, ""Created for user "" + android.os.Process.myUserHandle());
        WifiConfigCreator configCreator = new WifiConfigCreator(this);
        try {
            Intent intent = getIntent();
            String action = intent.getAction();
            if (ACTION_CREATE_WIFI_CONFIG.equals(action)) {
                String ssid = intent.getStringExtra(EXTRA_SSID);
                int securityType = intent.getIntExtra(EXTRA_SECURITY_TYPE, SECURITY_TYPE_NONE);
                String password = intent.getStringExtra(EXTRA_PASSWORD);
                configCreator.addNetwork(ssid, false, securityType, password);
            } else if (ACTION_UPDATE_WIFI_CONFIG.equals(action)) {
                int netId = intent.getIntExtra(EXTRA_NETID, -1);
                String ssid = intent.getStringExtra(EXTRA_SSID);
                int securityType = intent.getIntExtra(EXTRA_SECURITY_TYPE, SECURITY_TYPE_NONE);
                String password = intent.getStringExtra(EXTRA_PASSWORD);
                configCreator.updateNetwork(netId, ssid, false, securityType, password);
            } else if (ACTION_REMOVE_WIFI_CONFIG.equals(action)) {
                int netId = intent.getIntExtra(EXTRA_NETID, -1);
                if (netId != -1) {
                    configCreator.removeNetwork(netId);
                }
            } else {
                Log.i(TAG, ""Unknown command: "" + action);
            }
        } catch (InterruptedException ie) {
            Log.e(TAG, ""Interrupted while changing wifi settings"", ie);
        } finally {
            finish();
        }
    }
}"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.nl80211.cts.PnoSettingsTest"	"createTestNetworks"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/nl80211/cts/PnoSettingsTest.java"	""	"/*
 *.
 */

package android.net.wifi.nl80211.cts;

import static com.google.common.truth.Truth.assertThat;

import static org.junit.Assume.assumeTrue;

import android.content.Context;
import android.net.wifi.cts.WifiFeature;
import android.net.wifi.nl80211.PnoNetwork;
import android.net.wifi.nl80211.PnoSettings;
import android.os.Parcel;

import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.filters.SmallTest;
import androidx.test.platform.app.InstrumentationRegistry;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.Arrays;
import java.util.List;

/** CTS tests for {@link PnoSettings}. */
@SmallTest
@RunWith(AndroidJUnit4.class)
public class PnoSettingsTest {

    private static List<PnoNetwork> createTestNetworks() {
        PnoNetwork network1 = new PnoNetwork();
        network1.setSsid(new byte[] { 's', 's', 'i', 'd' });
        network1.setFrequenciesMhz(new int[] { 2412, 2417, 5035 });
        network1.setHidden(true);

        PnoNetwork network2 = new PnoNetwork();
        network2.setSsid(new byte[] { 'a', 's', 'd', 'f' });
        network2.setFrequenciesMhz(new int[] { 2422, 2427, 5040 });
        network2.setHidden(false);

        return Arrays.asList(network1, network2);
    }

    @Before
    public void setUp() {
        Context context = InstrumentationRegistry.getInstrumentation().getContext();
        // skip tests if Wifi is not supported
        assumeTrue(WifiFeature.isWifiSupported(context));
    }"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.SupplicantStateTest"	"testIsValidState"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/SupplicantStateTest.java"	""	"public void testIsValidState() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        assertTrue(SupplicantState.isValidState(SupplicantState.DISCONNECTED));
        assertTrue(SupplicantState.isValidState(SupplicantState.INACTIVE));
        assertTrue(SupplicantState.isValidState(SupplicantState.SCANNING));
        assertTrue(SupplicantState.isValidState(SupplicantState.ASSOCIATING));
        assertTrue(SupplicantState.isValidState(SupplicantState.ASSOCIATED));
        assertTrue(SupplicantState.isValidState(SupplicantState.FOUR_WAY_HANDSHAKE));
        assertTrue(SupplicantState.isValidState(SupplicantState.GROUP_HANDSHAKE));
        assertTrue(SupplicantState.isValidState(SupplicantState.COMPLETED));
        assertTrue(SupplicantState.isValidState(SupplicantState.DORMANT));
        assertFalse(SupplicantState.isValidState(SupplicantState.UNINITIALIZED));
        assertFalse(SupplicantState.isValidState(SupplicantState.INVALID));
    }

}"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.app.RetrieveConnectionInfoAndReturnStatusActivity"	"finish"	""	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/CtsWifiLocationTestApp/src/android/net/wifi/cts/app/RetrieveConnectionInfoAndReturnStatusActivity.java"	""	"public void test/*
 *.
 */

package android.net.wifi.cts.app;

import android.app.Activity;
import android.content.Intent;
import android.net.wifi.WifiManager;
import android.os.Bundle;
import android.util.Log;

/**
 * An activity that retrieves connection info and returns status.
 */
public class RetrieveConnectionInfoAndReturnStatusActivity extends Activity {
    private static final String TAG = ""RetrieveConnectionInfoAndReturnStatusActivity"";
    private static final String SCAN_STATUS_EXTRA = ""android.net.wifi.cts.app.extra.STATUS"";

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        WifiManager wifiManager = getSystemService(WifiManager.class);
        boolean succeeded;
        try {
            succeeded = !wifiManager.getConnectionInfo().getSSID().equals(WifiManager.UNKNOWN_SSID);
        } catch (SecurityException e) {
            succeeded = false;
        }
        if (succeeded) {
            Log.v(TAG, ""SSID from connection info retrieval succeeded"");
        } else {
            Log.v(TAG, ""Failed to retrieve SSID from connection info"");
        }
        setResult(RESULT_OK, new Intent().putExtra(SCAN_STATUS_EXTRA, succeeded));
        finish();
    }
}"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.TestHelper"	"isEmpty"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/TestHelper.java"	""	"public void test/*
 *.
 */

package android.net.wifi.cts;

import static android.Manifest.permission.CONNECTIVITY_INTERNAL;
import static android.Manifest.permission.NETWORK_SETTINGS;
import static android.net.ConnectivityManager.NetworkCallback.FLAG_INCLUDE_LOCATION_INFO;
import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_OEM_PAID;
import static android.net.NetworkCapabilities.NET_CAPABILITY_OEM_PRIVATE;
import static android.net.NetworkCapabilities.TRANSPORT_WIFI;
import static android.os.Process.myUid;

import static com.google.common.truth.Truth.assertThat;

import static org.junit.Assert.fail;

import android.annotation.NonNull;
import android.app.UiAutomation;
import android.content.Context;
import android.net.ConnectivityManager;
import android.net.MacAddress;
import android.net.Network;
import android.net.NetworkCapabilities;
import android.net.NetworkRequest;
import android.net.wifi.ScanResult;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiInfo;
import android.net.wifi.WifiManager;
import android.net.wifi.WifiNetworkSpecifier;
import android.net.wifi.WifiNetworkSuggestion;
import android.os.Build;
import android.os.WorkSource;
import android.support.test.uiautomator.UiDevice;
import android.text.TextUtils;
import android.util.Log;

import androidx.test.platform.app.InstrumentationRegistry;

import com.android.compatibility.common.util.ApiLevelUtil;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Set;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

/**
 * Class to hold helper methods that are repeated across wifi CTS tests.
 */
public class TestHelper {
    private static final String TAG = ""WifiTestHelper"";

    private final Context mContext;
    private final WifiManager mWifiManager;
    private final ConnectivityManager mConnectivityManager;
    private final UiDevice mUiDevice;

    private static final int DURATION_MILLIS = 10_000;
    private static final int DURATION_NETWORK_CONNECTION_MILLIS = 40_000;
    private static final int DURATION_SCREEN_TOGGLE_MILLIS = 2000;
    private static final int DURATION_UI_INTERACTION_MILLIS = 25_000;
    private static final int SCAN_RETRY_CNT_TO_FIND_MATCHING_BSSID = 3;

    public TestHelper(@NonNull Context context, @NonNull UiDevice uiDevice) {
        mContext = context;
        mWifiManager = context.getSystemService(WifiManager.class);
        mConnectivityManager = context.getSystemService(ConnectivityManager.class);
        mUiDevice = uiDevice;
    }

    public void turnScreenOn() throws Exception {
        mUiDevice.executeShellCommand(""input keyevent KEYCODE_WAKEUP"");
        mUiDevice.executeShellCommand(""wm dismiss-keyguard"");
        // Since the screen on/off intent is ordered, they will not be sent right now.
        Thread.sleep(DURATION_SCREEN_TOGGLE_MILLIS);
    }

    public void turnScreenOff() throws Exception {
        mUiDevice.executeShellCommand(""input keyevent KEYCODE_SLEEP"");
        // Since the screen on/off intent is ordered, they will not be sent right now.
        Thread.sleep(DURATION_SCREEN_TOGGLE_MILLIS);
    }

    private static class TestScanResultsCallback extends WifiManager.ScanResultsCallback {
        private final CountDownLatch mCountDownLatch;
        public boolean onAvailableCalled = false;

        TestScanResultsCallback(CountDownLatch countDownLatch) {
            mCountDownLatch = countDownLatch;
        }

        @Override
        public void onScanResultsAvailable() {
            onAvailableCalled = true;
            mCountDownLatch.countDown();
        }
    }

    /**
     * Loops through all the saved networks available in the scan results. Returns a list of
     * WifiConfiguration with the matching bssid filled in {@link WifiConfiguration#BSSID}.
     *
     * Note:
     * a) If there are more than 2 networks with the same SSID, but different credential type, then
     * this matching may pick the wrong one.
     *
     * @param wifiManager WifiManager service
     * @param savedNetworks List of saved networks on the device.
     */
    public static List<WifiConfiguration> findMatchingSavedNetworksWithBssid(
            @NonNull WifiManager wifiManager, @NonNull List<WifiConfiguration> savedNetworks) {
        if (savedNetworks.isEmpty()) return Collections.emptyList();
        List<WifiConfiguration> matchingNetworksWithBssids = new ArrayList<>();
        CountDownLatch countDownLatch = new CountDownLatch(1);
        for (int i = 0; i < SCAN_RETRY_CNT_TO_FIND_MATCHING_BSSID; i++) {
            // Trigger a scan to get fresh scan results.
            TestScanResultsCallback scanResultsCallback =
                    new TestScanResultsCallback(countDownLatch);
            try {
                wifiManager.registerScanResultsCallback(
                        Executors.newSingleThreadExecutor(), scanResultsCallback);
                wifiManager.startScan(new WorkSource(myUid()));
                // now wait for callback
                countDownLatch.await(DURATION_MILLIS, TimeUnit.MILLISECONDS);
            } catch (InterruptedException e) {
            } finally {
                wifiManager.unregisterScanResultsCallback(scanResultsCallback);
            }
            List<ScanResult> scanResults = wifiManager.getScanResults();
            if (scanResults == null || scanResults.isEmpty()) fail(""No scan results available"");
            for (ScanResult scanResult : scanResults) {
                WifiConfiguration matchingNetwork = savedNetworks.stream()
                        .filter(network -> TextUtils.equals(
                                scanResult.SSID, WifiInfo.sanitizeSsid(network.SSID)))
                        .findAny()
                        .orElse(null);
                if (matchingNetwork != null) {
                    // make a copy in case we have 2 bssid's for the same network.
                    WifiConfiguration matchingNetworkCopy = new WifiConfiguration(matchingNetwork);
                    matchingNetworkCopy.BSSID = scanResult.BSSID;
                    matchingNetworksWithBssids.add(matchingNetworkCopy);
                }
            }
            if (!matchingNetworksWithBssids.isEmpty()) break;
        }
        return matchingNetworksWithBssids;
    }

    /**
     * Convert the provided saved network to a corresponding suggestion builder.
     */
    public static WifiNetworkSuggestion.Builder
            createSuggestionBuilderWithCredentialFromSavedNetworkWithBssid(
            @NonNull WifiConfiguration network) {
        WifiNetworkSuggestion.Builder suggestionBuilder = new WifiNetworkSuggestion.Builder()
                .setSsid(WifiInfo.sanitizeSsid(network.SSID))
                .setBssid(MacAddress.fromString(network.BSSID));
        if (network.preSharedKey != null) {
            if (network.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.WPA_PSK)) {
                suggestionBuilder.setWpa2Passphrase(WifiInfo.sanitizeSsid(network.preSharedKey));
            } else if (network.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.SAE)) {
                suggestionBuilder.setWpa3Passphrase(WifiInfo.sanitizeSsid(network.preSharedKey));
            } else {
                fail(""Unsupported security type found in saved networks"");
            }
        } else if (network.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.OWE)) {
            suggestionBuilder.setIsEnhancedOpen(true);
        } else if (!network.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.NONE)) {
            fail(""Unsupported security type found in saved networks"");
        }
        suggestionBuilder.setIsHiddenSsid(network.hiddenSSID);
        return suggestionBuilder;
    }


    /**
     * Convert the provided saved network to a corresponding specifier builder.
     */
    public static WifiNetworkSpecifier.Builder createSpecifierBuilderWithCredentialFromSavedNetwork(
            @NonNull WifiConfiguration network) {
        WifiNetworkSpecifier.Builder specifierBuilder = new WifiNetworkSpecifier.Builder()
                .setSsid(WifiInfo.sanitizeSsid(network.SSID));
        if (network.preSharedKey != null) {
            if (network.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.WPA_PSK)) {
                specifierBuilder.setWpa2Passphrase(WifiInfo.sanitizeSsid(network.preSharedKey));
            } else if (network.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.SAE)) {
                specifierBuilder.setWpa3Passphrase(WifiInfo.sanitizeSsid(network.preSharedKey));
            } else {
                fail(""Unsupported security type found in saved networks"");
            }
        } else if (network.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.OWE)) {
            specifierBuilder.setIsEnhancedOpen(true);
        } else if (!network.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.NONE)) {
            fail(""Unsupported security type found in saved networks"");
        }
        specifierBuilder.setIsHiddenSsid(network.hiddenSSID);
        return specifierBuilder;
    }

    /**
     * Convert the provided saved network to a corresponding specifier builder.
     */
    public static WifiNetworkSpecifier.Builder
            createSpecifierBuilderWithCredentialFromSavedNetworkWithBssid(
            @NonNull WifiConfiguration network) {
        return createSpecifierBuilderWithCredentialFromSavedNetwork(network)
                .setBssid(MacAddress.fromString(network.BSSID));
    }

    private static class TestNetworkCallback extends ConnectivityManager.NetworkCallback {
        private final CountDownLatch mCountDownLatch;
        public boolean onAvailableCalled = false;
        public boolean onUnavailableCalled = false;
        public NetworkCapabilities networkCapabilities;

        TestNetworkCallback(@NonNull CountDownLatch countDownLatch) {
            mCountDownLatch = countDownLatch;
        }

        TestNetworkCallback(@NonNull CountDownLatch countDownLatch, int flags) {
            super(flags);
            mCountDownLatch = countDownLatch;
        }

        @Override
        public void onAvailable(Network network) {
            onAvailableCalled = true;
        }

        @Override
        public void onCapabilitiesChanged(Network network,
                NetworkCapabilities networkCapabilities) {
            this.networkCapabilities = networkCapabilities;
            mCountDownLatch.countDown();
        }

        @Override
        public void onUnavailable() {
            onUnavailableCalled = true;
            mCountDownLatch.countDown();
        }
    }

    private static TestNetworkCallback createTestNetworkCallback(
            @NonNull CountDownLatch countDownLatch) {
        if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
            // flags for NetworkCallback only introduced in S.
            return new TestNetworkCallback(countDownLatch, FLAG_INCLUDE_LOCATION_INFO);
        } else {
            return new TestNetworkCallback(countDownLatch);
        }
    }

    @NonNull
    private WifiInfo getWifiInfo(@NonNull NetworkCapabilities networkCapabilities) {
        if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
            // WifiInfo in transport info, only available in S.
            return (WifiInfo) networkCapabilities.getTransportInfo();
        } else {
            return mWifiManager.getConnectionInfo();
        }
    }

    private static void assertConnectionEquals(@NonNull WifiConfiguration network,
            @NonNull WifiInfo wifiInfo) {
        assertThat(network.SSID).isEqualTo(wifiInfo.getSSID());
        assertThat(network.BSSID).isEqualTo(wifiInfo.getBSSID());
    }

    private static class TestActionListener implements WifiManager.ActionListener {
        private final CountDownLatch mCountDownLatch;
        public boolean onSuccessCalled = false;
        public boolean onFailedCalled = false;

        TestActionListener(CountDownLatch countDownLatch) {
            mCountDownLatch = countDownLatch;
        }

        @Override
        public void onSuccess() {
            onSuccessCalled = true;
            mCountDownLatch.countDown();
        }

        @Override
        public void onFailure(int reason) {
            onFailedCalled = true;
            mCountDownLatch.countDown();
        }
    }

    /**
     * Triggers connection to one of the saved networks using {@link WifiManager#connect(
     * WifiConfiguration, WifiManager.ActionListener)}
     *
     * @param network saved network from the device to use for the connection.
     *
     * @return NetworkCallback used for the connection (can be used by client to release the
     * connection.
     */
    public ConnectivityManager.NetworkCallback testConnectionFlowWithConnect(
            @NonNull WifiConfiguration network) throws Exception {
        CountDownLatch countDownLatchAl = new CountDownLatch(1);
        CountDownLatch countDownLatchNr = new CountDownLatch(1);
        TestActionListener actionListener = new TestActionListener(countDownLatchAl);
        TestNetworkCallback testNetworkCallback = createTestNetworkCallback(countDownLatchNr);
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            // File a callback for wifi network.
            mConnectivityManager.registerNetworkCallback(
                    new NetworkRequest.Builder()
                            .addTransportType(NetworkCapabilities.TRANSPORT_WIFI)
                            .addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
                            // Needed to ensure that the restricted concurrent connection does not
                            // match this request.
                            .addForbiddenCapability(NET_CAPABILITY_OEM_PAID)
                            .addForbiddenCapability(NET_CAPABILITY_OEM_PRIVATE)
                            .build(),
                    testNetworkCallback);
            // Trigger the connection.
            mWifiManager.connect(network, actionListener);
            // now wait for action listener callback
            assertThat(countDownLatchAl.await(
                    DURATION_NETWORK_CONNECTION_MILLIS, TimeUnit.MILLISECONDS)).isTrue();
            // check if we got the success callback
            assertThat(actionListener.onSuccessCalled).isTrue();

            // Wait for connection to complete & ensure we are connected to the saved network.
            assertThat(countDownLatchNr.await(
                    DURATION_NETWORK_CONNECTION_MILLIS, TimeUnit.MILLISECONDS)).isTrue();
            assertThat(testNetworkCallback.onAvailableCalled).isTrue();
            final WifiInfo wifiInfo = getWifiInfo(testNetworkCallback.networkCapabilities);
            assertConnectionEquals(network, wifiInfo);
            if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
                // User connections should always be primary.
                assertThat(wifiInfo.isPrimary()).isTrue();
            }
        } catch (Throwable e /* catch assertions & exceptions */) {
            // Unregister the network callback in case of any failure (since we don't end up
            // returning the network callback to the caller).
            try {
                mConnectivityManager.unregisterNetworkCallback(testNetworkCallback);
            } catch (IllegalArgumentException ie) { }
            throw e;
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
        return testNetworkCallback;
    }

    /**
     * Tests the entire connection success flow using the provided suggestion.
     *
     * Note: The caller needs to invoke this after acquiring shell identity.
     *
     * @param network saved network from the device to use for the connection.
     * @param suggestion suggestion to use for the connection.
     * @param executorService Excutor service to run scan periodically (to trigger connection).
     * @param restrictedNetworkCapabilities Whether this connection should be restricted with
     *                                    the provided capability.
     *
     * @return NetworkCallback used for the connection (can be used by client to release the
     * connection.
     */
    public ConnectivityManager.NetworkCallback testConnectionFlowWithSuggestionWithShellIdentity(
            WifiConfiguration network, WifiNetworkSuggestion suggestion,
            @NonNull ScheduledExecutorService executorService,
            @NonNull Set<Integer> restrictedNetworkCapabilities) throws Exception {
        return testConnectionFlowWithSuggestionInternal(
                network, suggestion, executorService, restrictedNetworkCapabilities, true);
    }

    /**
     * Tests the entire connection success flow using the provided suggestion.
     *
     * Note: The helper method drops the shell identity, so don't use this if the caller already
     * adopted shell identity.
     *
     * @param network saved network from the device to use for the connection.
     * @param suggestion suggestion to use for the connection.
     * @param executorService Excutor service to run scan periodically (to trigger connection).
     * @param restrictedNetworkCapabilities Whether this connection should be restricted with
     *                                    the provided capability.
     *
     * @return NetworkCallback used for the connection (can be used by client to release the
     * connection.
     */
    public ConnectivityManager.NetworkCallback testConnectionFlowWithSuggestion(
            WifiConfiguration network, WifiNetworkSuggestion suggestion,
            @NonNull ScheduledExecutorService executorService,
            @NonNull Set<Integer> restrictedNetworkCapabilities) throws Exception {
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity(NETWORK_SETTINGS, CONNECTIVITY_INTERNAL);
            return testConnectionFlowWithSuggestionWithShellIdentity(
                    network, suggestion, executorService, restrictedNetworkCapabilities);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests the connection failure flow using the provided suggestion.
     *
     * @param network saved network from the device to use for the connection.
     * @param suggestion suggestion to use for the connection.
     * @param executorService Excutor service to run scan periodically (to trigger connection).
     * @param restrictedNetworkCapabilities Whether this connection should be restricted with
     *                                    the provided capability.
     *
     * @return NetworkCallback used for the connection (can be used by client to release the
     * connection.
     */
    public ConnectivityManager.NetworkCallback testConnectionFailureFlowWithSuggestion(
            WifiConfiguration network, WifiNetworkSuggestion suggestion,
            @NonNull ScheduledExecutorService executorService,
            @NonNull Set<Integer> restrictedNetworkCapabilities) throws Exception {
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity(NETWORK_SETTINGS, CONNECTIVITY_INTERNAL);
            return testConnectionFlowWithSuggestionInternal(
                    network, suggestion, executorService, restrictedNetworkCapabilities, false);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests the entire connection success/failure flow using the provided suggestion.
     *
     * @param network saved network from the device to use for the connection.
     * @param suggestion suggestion to use for the connection.
     * @param executorService Excutor service to run scan periodically (to trigger connection).
     * @param restrictedNetworkCapabilities Whether this connection should be restricted with
     *                                    the provided capability.
     * @param expectConnectionSuccess Whether to expect connection success or not.
     *
     * @return NetworkCallback used for the connection (can be used by client to release the
     * connection.
     */
    private ConnectivityManager.NetworkCallback testConnectionFlowWithSuggestionInternal(
            WifiConfiguration network, WifiNetworkSuggestion suggestion,
            @NonNull ScheduledExecutorService executorService,
            @NonNull Set<Integer> restrictedNetworkCapabilities,
            boolean expectConnectionSuccess) throws Exception {
        CountDownLatch countDownLatch = new CountDownLatch(1);
        // File the network request & wait for the callback.
        TestNetworkCallback testNetworkCallback = createTestNetworkCallback(countDownLatch);
        try {
            // File a request for restricted (oem paid) wifi network.
            NetworkRequest.Builder nrBuilder = new NetworkRequest.Builder()
                    .addTransportType(TRANSPORT_WIFI)
                    .addCapability(NET_CAPABILITY_INTERNET);
            if (restrictedNetworkCapabilities.isEmpty()) {
                // If not a restricted connection, a network callback is sufficient.
                mConnectivityManager.registerNetworkCallback(
                        nrBuilder.build(), testNetworkCallback);
            } else {
                for (Integer restrictedNetworkCapability : restrictedNetworkCapabilities) {
                    nrBuilder.addCapability(restrictedNetworkCapability);
                }
                mConnectivityManager.requestNetwork(nrBuilder.build(), testNetworkCallback);
            }
            // Add wifi network suggestion.
            assertThat(mWifiManager.addNetworkSuggestions(Arrays.asList(suggestion)))
                    .isEqualTo(WifiManager.STATUS_NETWORK_SUGGESTIONS_SUCCESS);
            // Wait for the request to reach the wifi stack before kick-start periodic scans.
            Thread.sleep(100);
            // Step: Trigger scans periodically to trigger network selection quicker.
            executorService.scheduleAtFixedRate(() -> {
                if (!mWifiManager.startScan()) {
                    Log.w(TAG, ""Failed to trigger scan"");
                }
            }, 0, DURATION_MILLIS, TimeUnit.MILLISECONDS);
            if (expectConnectionSuccess) {
                // now wait for connection to complete and wait for callback
                assertThat(countDownLatch.await(
                        DURATION_NETWORK_CONNECTION_MILLIS, TimeUnit.MILLISECONDS)).isTrue();
                assertThat(testNetworkCallback.onAvailableCalled).isTrue();
                final WifiInfo wifiInfo = getWifiInfo(testNetworkCallback.networkCapabilities);
                assertConnectionEquals(network, wifiInfo);
                if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(mContext)) {
                    assertThat(wifiInfo.isTrusted()).isTrue();
                    WifiInfo redact = wifiInfo
                            .makeCopy(NetworkCapabilities.REDACT_FOR_ACCESS_FINE_LOCATION);
                    assertThat(wifiInfo.getInformationElements()).isNotNull();
                    assertThat(redact.getInformationElements()).isNull();
                    assertThat(redact.getApplicableRedactions()).isEqualTo(
                            NetworkCapabilities.REDACT_FOR_ACCESS_FINE_LOCATION
                            | NetworkCapabilities.REDACT_FOR_LOCAL_MAC_ADDRESS
                            | NetworkCapabilities.REDACT_FOR_NETWORK_SETTINGS);
                }
                if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
                    // If STA concurrency for restricted connection is supported, this should not
                    // be the primary connection.
                    if (!restrictedNetworkCapabilities.isEmpty()
                            && mWifiManager.isStaConcurrencyForRestrictedConnectionsSupported()) {
                        assertThat(wifiInfo.isPrimary()).isFalse();
                    } else {
                        assertThat(wifiInfo.isPrimary()).isTrue();
                    }
                }
            } else {
                // now wait for connection to timeout.
                assertThat(countDownLatch.await(
                        DURATION_NETWORK_CONNECTION_MILLIS, TimeUnit.MILLISECONDS)).isFalse();
            }
        } catch (Throwable e /* catch assertions & exceptions */) {
            try {
                mConnectivityManager.unregisterNetworkCallback(testNetworkCallback);
            } catch (IllegalArgumentException ie) { }
            throw e;
        } finally {
            executorService.shutdown();
        }
        return testNetworkCallback;
    }

    private static class TestNetworkRequestMatchCallback implements
            WifiManager.NetworkRequestMatchCallback {
        private final Object mLock;

        public boolean onRegistrationCalled = false;
        public boolean onAbortCalled = false;
        public boolean onMatchCalled = false;
        public boolean onConnectSuccessCalled = false;
        public boolean onConnectFailureCalled = false;
        public WifiManager.NetworkRequestUserSelectionCallback userSelectionCallback = null;
        public List<ScanResult> matchedScanResults = null;

        TestNetworkRequestMatchCallback(Object lock) {
            mLock = lock;
        }

        @Override
        public void onUserSelectionCallbackRegistration(
                WifiManager.NetworkRequestUserSelectionCallback userSelectionCallback) {
            synchronized (mLock) {
                onRegistrationCalled = true;
                this.userSelectionCallback = userSelectionCallback;
                mLock.notify();
            }
        }

        @Override
        public void onAbort() {
            synchronized (mLock) {
                onAbortCalled = true;
                mLock.notify();
            }
        }

        @Override
        public void onMatch(List<ScanResult> scanResults) {
            synchronized (mLock) {
                // This can be invoked multiple times. So, ignore after the first one to avoid
                // disturbing the rest of the test sequence.
                if (onMatchCalled) return;
                onMatchCalled = true;
                matchedScanResults = scanResults;
                mLock.notify();
            }
        }

        @Override
        public void onUserSelectionConnectSuccess(WifiConfiguration config) {
            synchronized (mLock) {
                onConnectSuccessCalled = true;
                mLock.notify();
            }
        }

        @Override
        public void onUserSelectionConnectFailure(WifiConfiguration config) {
            synchronized (mLock) {
                onConnectFailureCalled = true;
                mLock.notify();
            }
        }
    }

    private void handleUiInteractions(WifiConfiguration network, boolean shouldUserReject) {
        // can't use CountDownLatch since there are many callbacks expected and CountDownLatch
        // cannot be reset.
        // TODO(b/177591382): Use ArrayBlockingQueue/LinkedBlockingQueue
        Object uiLock = new Object();
        TestNetworkRequestMatchCallback networkRequestMatchCallback =
                new TestNetworkRequestMatchCallback(uiLock);
        try {
            // 1. Wait for registration callback.
            synchronized (uiLock) {
                try {
                    mWifiManager.registerNetworkRequestMatchCallback(
                            Executors.newSingleThreadExecutor(), networkRequestMatchCallback);
                    uiLock.wait(DURATION_UI_INTERACTION_MILLIS);
                } catch (InterruptedException e) {
                }
            }
            assertThat(networkRequestMatchCallback.onRegistrationCalled).isTrue();
            assertThat(networkRequestMatchCallback.userSelectionCallback).isNotNull();

            // 2. Wait for matching scan results
            synchronized (uiLock) {
                if (!networkRequestMatchCallback.onMatchCalled) {
                    try {
                        uiLock.wait(DURATION_UI_INTERACTION_MILLIS);
                    } catch (InterruptedException e) {
                    }
                }
            }
            assertThat(networkRequestMatchCallback.onMatchCalled).isTrue();
            assertThat(networkRequestMatchCallback.matchedScanResults).isNotNull();
            assertThat(networkRequestMatchCallback.matchedScanResults.size()).isAtLeast(1);

            // 3. Trigger connection to one of the matched networks or reject the request.
            if (shouldUserReject) {
                networkRequestMatchCallback.userSelectionCallback.reject();
            } else {
                networkRequestMatchCallback.userSelectionCallback.select(network);
            }

            // 4. Wait for connection success or abort.
            synchronized (uiLock) {
                try {
                    uiLock.wait(DURATION_UI_INTERACTION_MILLIS);
                } catch (InterruptedException e) {
                }
            }
            if (shouldUserReject) {
                assertThat(networkRequestMatchCallback.onAbortCalled).isTrue();
            } else {
                assertThat(networkRequestMatchCallback.onConnectSuccessCalled).isTrue();
            }
        } finally {
            mWifiManager.unregisterNetworkRequestMatchCallback(networkRequestMatchCallback);
        }
    }

    /**
     * Tests the entire connection flow using the provided specifier,
     *
     * Note: The caller needs to invoke this after acquiring shell identity.
     *
     * @param specifier Specifier to use for network request.
     * @param shouldUserReject Whether to simulate user rejection or not.
     *
     * @return NetworkCallback used for the connection (can be used by client to release the
     * connection.
     */
    public ConnectivityManager.NetworkCallback testConnectionFlowWithSpecifierWithShellIdentity(
            WifiConfiguration network, WifiNetworkSpecifier specifier, boolean shouldUserReject)
            throws Exception {
        CountDownLatch countDownLatch = new CountDownLatch(1);
        // File the network request & wait for the callback.
        TestNetworkCallback testNetworkCallback = createTestNetworkCallback(countDownLatch);

        // Fork a thread to handle the UI interactions.
        Thread uiThread = new Thread(() -> {
            try {
                handleUiInteractions(network, shouldUserReject);
            } catch (Throwable e /* catch assertions & exceptions */) {
                try {
                    mConnectivityManager.unregisterNetworkCallback(testNetworkCallback);
                } catch (IllegalArgumentException ie) { }
                throw e;
            }
        });

        try {
            // File a request for wifi network.
            mConnectivityManager.requestNetwork(
                    new NetworkRequest.Builder()
                            .addTransportType(NetworkCapabilities.TRANSPORT_WIFI)
                            .removeCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
                            .setNetworkSpecifier(specifier)
                            .build(),
                    testNetworkCallback);
            // Wait for the request to reach the wifi stack before kick-starting the UI
            // interactions.
            Thread.sleep(1_000);
            // Start the UI interactions.
            uiThread.run();
            // now wait for callback
            assertThat(countDownLatch.await(
                    DURATION_NETWORK_CONNECTION_MILLIS, TimeUnit.MILLISECONDS)).isTrue();
            if (shouldUserReject) {
                assertThat(testNetworkCallback.onUnavailableCalled).isTrue();
            } else {
                assertThat(testNetworkCallback.onAvailableCalled).isTrue();
                final WifiInfo wifiInfo = getWifiInfo(testNetworkCallback.networkCapabilities);
                assertConnectionEquals(network, wifiInfo);
                if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
                    // If STA concurrency for local only connection is supported, this should not
                    // be the primary connection.
                    if (mWifiManager.isStaConcurrencyForLocalOnlyConnectionsSupported()) {
                        assertThat(wifiInfo.isPrimary()).isFalse();
                    } else {
                        assertThat(wifiInfo.isPrimary()).isTrue();
                    }
                }
            }
        } catch (Throwable e /* catch assertions & exceptions */) {
            try {
                mConnectivityManager.unregisterNetworkCallback(testNetworkCallback);
            } catch (IllegalArgumentException ie) { }
            throw e;
        }
        try {
            // Ensure that the UI interaction thread has completed.
            uiThread.join(DURATION_UI_INTERACTION_MILLIS);
        } catch (InterruptedException e) {
            try {
                mConnectivityManager.unregisterNetworkCallback(testNetworkCallback);
            } catch (IllegalArgumentException ie) { }
            fail(""UI interaction interrupted"");
        }
        return testNetworkCallback;
    }

    /**
     * Tests the entire connection flow using the provided specifier.
     *
     * Note: The helper method drops the shell identity, so don't use this if the caller already
     * adopted shell identity.
     *
     * @param specifier Specifier to use for network request.
     * @param shouldUserReject Whether to simulate user rejection or not.
     *
     * @return NetworkCallback used for the connection (can be used by client to release the
     * connection.
     */
    public ConnectivityManager.NetworkCallback testConnectionFlowWithSpecifier(
            WifiConfiguration network, WifiNetworkSpecifier specifier, boolean shouldUserReject)
            throws Exception {
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity(NETWORK_SETTINGS);
            return testConnectionFlowWithSpecifierWithShellIdentity(
                    network, specifier, shouldUserReject);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Returns the number of wifi connections visible at the networking layer.
     */
    public long getNumWifiConnections() {
        Network[] networks = mConnectivityManager.getAllNetworks();
        return Arrays.stream(networks)
                .filter(n ->
                        mConnectivityManager.getNetworkCapabilities(n).hasTransport(TRANSPORT_WIFI))
                .count();
    }

    /**
     * Registers a network callback for internet connectivity via wifi and asserts that a network
     * is available within {@link #DURATION_NETWORK_CONNECTION_MILLIS}.
     *
     * @throws Exception
     */
    public void assertWifiInternetConnectionAvailable() throws Exception {
        CountDownLatch countDownLatchNr = new CountDownLatch(1);
        TestNetworkCallback testNetworkCallback = createTestNetworkCallback(countDownLatchNr);
        try {
            // File a callback for wifi network.
            NetworkRequest.Builder builder = new NetworkRequest.Builder()
                    .addTransportType(NetworkCapabilities.TRANSPORT_WIFI)
                    .addCapability(NET_CAPABILITY_INTERNET);
            if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
                // Needed to ensure that the restricted concurrent connection does not
                // match this request.
                builder.addForbiddenCapability(NET_CAPABILITY_OEM_PAID)
                        .addForbiddenCapability(NET_CAPABILITY_OEM_PRIVATE);
            }
            mConnectivityManager.registerNetworkCallback(builder.build(), testNetworkCallback);
            // Wait for connection to complete & ensure we are connected to some network capable
            // of providing internet access.
            assertThat(countDownLatchNr.await(
                    DURATION_NETWORK_CONNECTION_MILLIS, TimeUnit.MILLISECONDS)).isTrue();
            assertThat(testNetworkCallback.onAvailableCalled).isTrue();
        } finally {
            mConnectivityManager.unregisterNetworkCallback(testNetworkCallback);
        }
    }

    public static int getBandFromFrequency(final int freqMHz) {
        if (freqMHz < 1000) {
            return ScanResult.UNSPECIFIED;
        } else if (freqMHz < 4000) { // getFrequency is in WifiInfo.FREQUENCY_UNITS = MHz
            return ScanResult.WIFI_BAND_24_GHZ;
        } else if (freqMHz < 5900) {
            // 5GHz band stops at 5885MHz, 6GHz band starts at 5955. See android.net.wifi.ScanResult
            return ScanResult.WIFI_BAND_5_GHZ;
        } else if (freqMHz < 10_000) {
            return ScanResult.WIFI_BAND_6_GHZ;
        } else if (freqMHz < 71_000) {
            // 60 GHz band stops at 70_200
            return ScanResult.WIFI_BAND_60_GHZ;
        } else {
            return ScanResult.UNSPECIFIED;
        }
    }

}"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiInfoTest"	"testWifiInfoProperties"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiInfoTest.java"	""	"public void testWifiInfoProperties() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }

        // ensure Wifi is connected
        ShellIdentityUtils.invokeWithShellPermissions(() -> mWifiManager.reconnect());
        PollingCheck.check(
                ""Wifi not connected - Please ensure there is a saved network in range of this ""
                        + ""device"",
                WIFI_CONNECT_TIMEOUT_MILLIS,
                () -> mWifiManager.getConnectionInfo().getNetworkId() != -1);

        // this test case should in Wifi environment
        WifiInfo wifiInfo = mWifiManager.getConnectionInfo();

        testWifiInfoPropertiesWhileConnected(wifiInfo);

        setWifiEnabled(false);

        PollingCheck.check(""getNetworkId not -1"", 20000,
                () -> mWifiManager.getConnectionInfo().getNetworkId() == -1);

        PollingCheck.check(""getWifiState not disabled"", 20000,
                () -> mWifiManager.getWifiState() == WifiManager.WIFI_STATE_DISABLED);
    }

    private void testWifiInfoPropertiesWhileConnected(WifiInfo wifiInfo) {
        assertThat(wifiInfo).isNotNull();
        assertThat(wifiInfo.toString()).isNotNull();
        SupplicantState.isValidState(wifiInfo.getSupplicantState());
        WifiInfo.getDetailedStateOf(SupplicantState.DISCONNECTED);
        String ssid = wifiInfo.getSSID();
        if (!ssid.startsWith(""0x"") && !ssid.equals(WifiManager.UNKNOWN_SSID)) {
            // Non-hex string should be quoted
            assertThat(ssid).startsWith(""\"""");
            assertThat(ssid).endsWith(""\"""");
        }

        assertThat(wifiInfo.getBSSID()).isNotNull();
        assertThat(wifiInfo.getFrequency()).isGreaterThan(0);
        assertThat(wifiInfo.getMacAddress()).isNotNull();

        wifiInfo.getRssi();
        wifiInfo.getIpAddress();
        wifiInfo.getHiddenSSID();
        wifiInfo.getScore();

        // null for saved networks
        assertThat(wifiInfo.getRequestingPackageName()).isNull();
        assertThat(wifiInfo.getPasspointFqdn()).isNull();
        assertThat(wifiInfo.getPasspointProviderFriendlyName()).isNull();

        // false for saved networks
        assertThat(wifiInfo.isEphemeral()).isFalse();
        assertThat(wifiInfo.isOsuAp()).isFalse();
        assertThat(wifiInfo.isPasspointAp()).isFalse();

        assertThat(wifiInfo.getWifiStandard()).isAnyOf(
                ScanResult.WIFI_STANDARD_UNKNOWN,
                ScanResult.WIFI_STANDARD_LEGACY,
                ScanResult.WIFI_STANDARD_11N,
                ScanResult.WIFI_STANDARD_11AC,
                ScanResult.WIFI_STANDARD_11AX
        );

        assertThat(wifiInfo.getLostTxPacketsPerSecond()).isAtLeast(0.0);
        assertThat(wifiInfo.getRetriedTxPacketsPerSecond()).isAtLeast(0.0);
        assertThat(wifiInfo.getSuccessfulRxPacketsPerSecond()).isAtLeast(0.0);
        assertThat(wifiInfo.getSuccessfulTxPacketsPerSecond()).isAtLeast(0.0);

        // Can be -1 if link speed is unknown
        assertThat(wifiInfo.getLinkSpeed()).isAtLeast(-1);
        assertThat(wifiInfo.getTxLinkSpeedMbps()).isAtLeast(-1);
        assertThat(wifiInfo.getRxLinkSpeedMbps()).isAtLeast(-1);
        assertThat(wifiInfo.getMaxSupportedTxLinkSpeedMbps()).isAtLeast(-1);
        assertThat(wifiInfo.getMaxSupportedRxLinkSpeedMbps()).isAtLeast(-1);
        if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(mContext)) {
            assertThat(wifiInfo.getCurrentSecurityType()).isNotEqualTo(
                    WifiInfo.SECURITY_TYPE_UNKNOWN);
        }
    }

    /**
     * Test that the WifiInfo Builder returns the same values that was set, and that
     * calling build multiple times returns different instances.
     */"	""	""	"passpoint wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiInfoTest"	"isNotNull"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiInfoTest.java"	""	"public void test/*
 *.
 */

package android.net.wifi.cts;

import static com.google.common.truth.Truth.assertThat;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.net.wifi.ScanResult;
import android.net.wifi.SupplicantState;
import android.net.wifi.WifiInfo;
import android.net.wifi.WifiManager;
import android.net.wifi.WifiManager.WifiLock;
import android.os.Build;
import android.platform.test.annotations.AppModeFull;
import android.telephony.SubscriptionManager;

import com.android.compatibility.common.util.ApiLevelUtil;
import com.android.compatibility.common.util.PollingCheck;
import com.android.compatibility.common.util.ShellIdentityUtils;
import com.android.compatibility.common.util.SystemUtil;

import java.nio.charset.StandardCharsets;

@AppModeFull(reason = ""Cannot get WifiManager in instant app mode"")
public class WifiInfoTest extends WifiJUnit3TestBase {
    private static class MySync {
        int expectedState = STATE_NULL;
    }

    private WifiManager mWifiManager;
    private WifiLock mWifiLock;
    private static MySync mMySync;

    private static final int STATE_NULL = 0;
    private static final int STATE_WIFI_CHANGING = 1;
    private static final int STATE_WIFI_CHANGED = 2;

    private static final String TEST_SSID = ""Test123"";
    private static final String TEST_BSSID = ""12:12:12:12:12:12"";
    private static final int TEST_RSSI = -60;
    private static final int TEST_NETWORK_ID = 5;
    private static final int TEST_NETWORK_ID2 = 6;

    private static final String TAG = ""WifiInfoTest"";
    private static final int TIMEOUT_MSEC = 6000;
    private static final int WAIT_MSEC = 60;
    private static final int DURATION = 10000;
    private static final int WIFI_CONNECT_TIMEOUT_MILLIS = 30_000;
    private IntentFilter mIntentFilter;
    private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            final String action = intent.getAction();
            if (action.equals(WifiManager.WIFI_STATE_CHANGED_ACTION)) {
                synchronized (mMySync) {
                    mMySync.expectedState = STATE_WIFI_CHANGED;
                    mMySync.notify();
                }
            }
        }
    };

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        mMySync = new MySync();
        mIntentFilter = new IntentFilter();
        mIntentFilter.addAction(WifiManager.WIFI_STATE_CHANGED_ACTION);

        mContext.registerReceiver(mReceiver, mIntentFilter);
        mWifiManager = (WifiManager) getContext().getSystemService(Context.WIFI_SERVICE);
        assertThat(mWifiManager).isNotNull();
        mWifiLock = mWifiManager.createWifiLock(TAG);
        mWifiLock.acquire();

        // enable Wifi
        if (!mWifiManager.isWifiEnabled()) setWifiEnabled(true);
        PollingCheck.check(""Wifi not enabled"", DURATION, () -> mWifiManager.isWifiEnabled());

        mMySync.expectedState = STATE_NULL;
    }

    @Override
    protected void tearDown() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            super.tearDown();
            return;
        }
        mWifiLock.release();
        mContext.unregisterReceiver(mReceiver);
        if (!mWifiManager.isWifiEnabled())
            setWifiEnabled(true);
        Thread.sleep(DURATION);
        super.tearDown();
    }

    private void setWifiEnabled(boolean enable) throws Exception {
        synchronized (mMySync) {
            mMySync.expectedState = STATE_WIFI_CHANGING;
            if (enable) {
                SystemUtil.runShellCommand(""svc wifi enable"");
            } else {
                SystemUtil.runShellCommand(""svc wifi disable"");
            }
            long timeout = System.currentTimeMillis() + TIMEOUT_MSEC;
            while (System.currentTimeMillis() < timeout
                    && mMySync.expectedState == STATE_WIFI_CHANGING)
                mMySync.wait(WAIT_MSEC);
        }
    }"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiInfoTest"	"testWifiInfoBuilder"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiInfoTest.java"	""	"public void testWifiInfoBuilder() throws Exception {
        WifiInfo.Builder builder = new WifiInfo.Builder()
                .setSsid(TEST_SSID.getBytes(StandardCharsets.UTF_8))
                .setBssid(TEST_BSSID)
                .setRssi(TEST_RSSI)
                .setNetworkId(TEST_NETWORK_ID);

        WifiInfo info1 = builder.build();

        assertThat(info1.getSSID()).isEqualTo(""\"""" + TEST_SSID + ""\"""");
        assertThat(info1.getBSSID()).isEqualTo(TEST_BSSID);
        assertThat(info1.getRssi()).isEqualTo(TEST_RSSI);
        assertThat(info1.getNetworkId()).isEqualTo(TEST_NETWORK_ID);
        if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
            assertThat(info1.getSubscriptionId())
                    .isEqualTo(SubscriptionManager.INVALID_SUBSCRIPTION_ID);
            assertFalse(info1.isOemPaid());
            assertFalse(info1.isOemPrivate());
            assertFalse(info1.isCarrierMerged());
        }

        WifiInfo info2 = builder
                .setNetworkId(TEST_NETWORK_ID2)
                .build();

        // different instances
        assertThat(info1).isNotSameInstanceAs(info2);

        // assert that info1 didn't change
        assertThat(info1.getSSID()).isEqualTo(""\"""" + TEST_SSID + ""\"""");
        assertThat(info1.getBSSID()).isEqualTo(TEST_BSSID);
        assertThat(info1.getRssi()).isEqualTo(TEST_RSSI);
        assertThat(info1.getNetworkId()).isEqualTo(TEST_NETWORK_ID);

        // assert that info2 changed
        assertThat(info2.getSSID()).isEqualTo(""\"""" + TEST_SSID + ""\"""");
        assertThat(info2.getBSSID()).isEqualTo(TEST_BSSID);
        assertThat(info2.getRssi()).isEqualTo(TEST_RSSI);
        assertThat(info2.getNetworkId()).isEqualTo(TEST_NETWORK_ID2);
    }

    /**
     * Test that setCurrentSecurityType and getCurrentSecurityType work as expected
     * @throws Exception
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiInfoTest"	"testWifiInfoCurrentSecurityType"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiInfoTest.java"	""	"public void testWifiInfoCurrentSecurityType() throws Exception {
        if (!WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(mContext)) {
            return;
        }
        WifiInfo.Builder builder = new WifiInfo.Builder()
                .setSsid(TEST_SSID.getBytes(StandardCharsets.UTF_8))
                .setBssid(TEST_BSSID)
                .setRssi(TEST_RSSI)
                .setNetworkId(TEST_NETWORK_ID);

        WifiInfo info = builder.build();
        assertEquals(WifiInfo.SECURITY_TYPE_UNKNOWN, info.getCurrentSecurityType());

        builder.setCurrentSecurityType(WifiInfo.SECURITY_TYPE_SAE);
        info = builder.build();
        assertEquals(WifiInfo.SECURITY_TYPE_SAE, info.getCurrentSecurityType());
    }
}"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiMigrationTest"	"testWifiMigrationSettingsDataBuilder"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiMigrationTest.java"	""	"public void testWifiMigrationSettingsDataBuilder() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        WifiMigration.SettingsMigrationData migrationData =
                new WifiMigration.SettingsMigrationData.Builder()
                        .setScanAlwaysAvailable(true)
                        .setP2pFactoryResetPending(true)
                        .setScanThrottleEnabled(true)
                        .setSoftApTimeoutEnabled(true)
                        .setWakeUpEnabled(true)
                        .setVerboseLoggingEnabled(true)
                        .setP2pDeviceName(TEST_SSID_UNQUOTED)
                        .build();

        assertNotNull(migrationData);
        assertTrue(migrationData.isScanAlwaysAvailable());
        assertTrue(migrationData.isP2pFactoryResetPending());
        assertTrue(migrationData.isScanThrottleEnabled());
        assertTrue(migrationData.isSoftApTimeoutEnabled());
        assertTrue(migrationData.isWakeUpEnabled());
        assertTrue(migrationData.isVerboseLoggingEnabled());
        assertEquals(TEST_SSID_UNQUOTED, migrationData.getP2pDeviceName());
    }

    /**
     * Tests {@link android.net.wifi.WifiMigration.SettingsMigrationData} class.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiMigrationTest"	"testWifiMigrationSettings"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiMigrationTest.java"	""	"public void testWifiMigrationSettings() throws Exception {
        try {
            WifiMigration.loadFromSettings(getContext());
        } catch (Exception ignore) {
        }
    }

    /**
     * Tests {@link WifiMigration#convertAndRetrieveSharedConfigStoreFile(int)},
     * {@link WifiMigration#convertAndRetrieveUserConfigStoreFile(int, UserHandle)},
     * {@link WifiMigration#removeSharedConfigStoreFile(int)} and
     * {@link WifiMigration#removeUserConfigStoreFile(int, UserHandle)}.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiMigrationTest"	"testWifiMigrationConfigStore"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiMigrationTest.java"	""	"public void testWifiMigrationConfigStore() throws Exception {
        try {
            WifiMigration.convertAndRetrieveSharedConfigStoreFile(
                    WifiMigration.STORE_FILE_SHARED_GENERAL);
        } catch (Exception ignore) {
        }
        try {
            WifiMigration.convertAndRetrieveSharedConfigStoreFile(
                    WifiMigration.STORE_FILE_SHARED_SOFTAP);
        } catch (Exception ignore) {
        }
        try {
            WifiMigration.convertAndRetrieveUserConfigStoreFile(
                    WifiMigration.STORE_FILE_USER_GENERAL,
                    UserHandle.of(ActivityManager.getCurrentUser()));
        } catch (Exception ignore) {
        }
        try {
            WifiMigration.convertAndRetrieveUserConfigStoreFile(
                    WifiMigration.STORE_FILE_USER_NETWORK_SUGGESTIONS,
                    UserHandle.of(ActivityManager.getCurrentUser()));
        } catch (Exception ignore) {
        }
        try {
            WifiMigration.removeSharedConfigStoreFile(
                    WifiMigration.STORE_FILE_SHARED_GENERAL);
        } catch (Exception ignore) {
        }
        try {
            WifiMigration.removeSharedConfigStoreFile(
                    WifiMigration.STORE_FILE_SHARED_SOFTAP);
        } catch (Exception ignore) {
        }
        try {
            WifiMigration.removeUserConfigStoreFile(
                    WifiMigration.STORE_FILE_USER_GENERAL,
                    UserHandle.of(ActivityManager.getCurrentUser()));
        } catch (Exception ignore) {
        }
        try {
            WifiMigration.removeUserConfigStoreFile(
                    WifiMigration.STORE_FILE_USER_NETWORK_SUGGESTIONS,
                    UserHandle.of(ActivityManager.getCurrentUser()));
        } catch (Exception ignore) {
        }
    }
}"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.ConcurrencyTest"	"ActionListener"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ConcurrencyTest.java"	""	"public void test/*
 *.
 */

package android.net.wifi.cts;

import static org.junit.Assert.assertNotEquals;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageManager;
import android.net.ConnectivityManager;
import android.net.ConnectivityManager.NetworkCallback;
import android.net.Network;
import android.net.NetworkCapabilities;
import android.net.NetworkInfo;
import android.net.NetworkRequest;
import android.net.wifi.WifiManager;
import android.net.wifi.p2p.WifiP2pDevice;
import android.net.wifi.p2p.WifiP2pGroup;
import android.net.wifi.p2p.WifiP2pGroupList;
import android.net.wifi.p2p.WifiP2pInfo;
import android.net.wifi.p2p.WifiP2pManager;
import android.net.wifi.p2p.nsd.WifiP2pServiceInfo;
import android.net.wifi.p2p.nsd.WifiP2pUpnpServiceInfo;
import android.provider.Settings;
import android.platform.test.annotations.AppModeFull;
import android.test.AndroidTestCase;
import android.util.Log;

import com.android.compatibility.common.util.ShellIdentityUtils;
import com.android.compatibility.common.util.SystemUtil;

import java.util.Arrays;
import java.util.ArrayList;
import java.util.BitSet;
import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

@AppModeFull(reason = ""Cannot get WifiManager in instant app mode"")
public class ConcurrencyTest extends WifiJUnit3TestBase {
    private class MySync {
        static final int WIFI_STATE = 0;
        static final int P2P_STATE = 1;
        static final int DISCOVERY_STATE = 2;
        static final int NETWORK_INFO = 3;

        public BitSet pendingSync = new BitSet();

        public int expectedWifiState;
        public int expectedP2pState;
        public int expectedDiscoveryState;
        public NetworkInfo expectedNetworkInfo;
    }

    private class MyResponse {
        public boolean valid = false;

        public boolean success;
        public int failureReason;
        public int p2pState;
        public int discoveryState;
        public NetworkInfo networkInfo;
        public WifiP2pInfo p2pInfo;
        public String deviceName;
        public WifiP2pGroupList persistentGroups;
        public WifiP2pGroup group = new WifiP2pGroup();
    }

    private WifiManager mWifiManager;
    private WifiP2pManager mWifiP2pManager;
    private WifiP2pManager.Channel mWifiP2pChannel;
    private MySync mMySync = new MySync();
    private MyResponse mMyResponse = new MyResponse();
    private boolean mWasVerboseLoggingEnabled;

    private static final String TAG = ""ConcurrencyTest"";
    private static final int TIMEOUT_MSEC = 6000;
    private static final int WAIT_MSEC = 60;
    private static final int DURATION = 5000;
    private IntentFilter mIntentFilter;
    private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            final String action = intent.getAction();
            if (action.equals(WifiManager.WIFI_STATE_CHANGED_ACTION)) {
                synchronized (mMySync) {
                    mMySync.pendingSync.set(MySync.WIFI_STATE);
                    mMySync.expectedWifiState = intent.getIntExtra(WifiManager.EXTRA_WIFI_STATE,
                            WifiManager.WIFI_STATE_DISABLED);
                    mMySync.notify();
                }
            } else if(action.equals(WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION)) {
                synchronized (mMySync) {
                    mMySync.pendingSync.set(MySync.P2P_STATE);
                    mMySync.expectedP2pState = intent.getIntExtra(WifiP2pManager.EXTRA_WIFI_STATE,
                            WifiP2pManager.WIFI_P2P_STATE_DISABLED);
                    mMySync.notify();
                }
            } else if (action.equals(WifiP2pManager.WIFI_P2P_DISCOVERY_CHANGED_ACTION)) {
                synchronized (mMySync) {
                    mMySync.pendingSync.set(MySync.DISCOVERY_STATE);
                    mMySync.expectedDiscoveryState = intent.getIntExtra(
                            WifiP2pManager.EXTRA_DISCOVERY_STATE,
                            WifiP2pManager.WIFI_P2P_DISCOVERY_STOPPED);
                    mMySync.notify();
                }
            } else if (action.equals(WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION)) {
                synchronized (mMySync) {
                    mMySync.pendingSync.set(MySync.NETWORK_INFO);
                    mMySync.expectedNetworkInfo = (NetworkInfo) intent.getExtra(
                            WifiP2pManager.EXTRA_NETWORK_INFO, null);
                    Log.d(TAG, ""Get WIFI_P2P_CONNECTION_CHANGED_ACTION: ""
                            + mMySync.expectedNetworkInfo);
                    mMySync.notify();
                }
            }
        }
    };

    private WifiP2pManager.ActionListener mActionListener = new WifiP2pManager.ActionListener() {
        @Override
        public void onSuccess() {
            synchronized (mMyResponse) {
                mMyResponse.valid = true;
                mMyResponse.success = true;
                mMyResponse.notify();
            }
        }

        @Override
        public void onFailure(int reason) {
            synchronized (mMyResponse) {
                Log.d(TAG, ""failure reason: "" + reason);
                mMyResponse.valid = true;
                mMyResponse.success = false;
                mMyResponse.failureReason = reason;
                mMyResponse.notify();
            }
        }
    };

    @Override
    protected void setUp() throws Exception {
       super.setUp();
       if (!WifiFeature.isWifiSupported(getContext()) &&
                !WifiFeature.isP2pSupported(getContext())) {
            // skip the test if WiFi && p2p are not supported
            return;
        }

        mIntentFilter = new IntentFilter();
        mIntentFilter.addAction(WifiManager.WIFI_STATE_CHANGED_ACTION);
        mIntentFilter.addAction(WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION);
        mIntentFilter.addAction(WifiP2pManager.WIFI_P2P_DISCOVERY_CHANGED_ACTION);
        mIntentFilter.addAction(WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION);

        mContext.registerReceiver(mReceiver, mIntentFilter);
        mWifiManager = (WifiManager) getContext().getSystemService(Context.WIFI_SERVICE);
        assertNotNull(mWifiManager);
        if (mWifiManager.isWifiEnabled()) {
            SystemUtil.runShellCommand(""svc wifi disable"");
            Thread.sleep(DURATION);
        }

        // turn on verbose logging for tests
        mWasVerboseLoggingEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.isVerboseLoggingEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setVerboseLoggingEnabled(true));

        assertTrue(!mWifiManager.isWifiEnabled());
        mMySync.expectedWifiState = WifiManager.WIFI_STATE_DISABLED;
        mMySync.expectedP2pState = WifiP2pManager.WIFI_P2P_STATE_DISABLED;
        mMySync.expectedDiscoveryState = WifiP2pManager.WIFI_P2P_DISCOVERY_STOPPED;
        mMySync.expectedNetworkInfo = null;
    }

    @Override
    protected void tearDown() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext()) &&
                !WifiFeature.isP2pSupported(getContext())) {
            // skip the test if WiFi and p2p are not supported
            super.tearDown();
            return;
        }
        if (null != mWifiP2pManager) {
            removeAllPersistentGroups();
        }
        mContext.unregisterReceiver(mReceiver);

        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setVerboseLoggingEnabled(mWasVerboseLoggingEnabled));

        enableWifi();
        super.tearDown();
    }

    private boolean waitForBroadcasts(List<Integer> waitSyncList) {
        synchronized (mMySync) {
            long timeout = System.currentTimeMillis() + TIMEOUT_MSEC;
            while (System.currentTimeMillis() < timeout) {
                List<Integer> handledSyncList = waitSyncList.stream()
                        .filter(w -> mMySync.pendingSync.get(w))
                        .collect(Collectors.toList());
                handledSyncList.forEach(w -> mMySync.pendingSync.clear(w));
                waitSyncList.removeAll(handledSyncList);
                if (waitSyncList.isEmpty()) {
                    break;
                }
                try {
                    mMySync.wait(WAIT_MSEC);
                } catch (InterruptedException e) { }
            }
            if (!waitSyncList.isEmpty()) {
                Log.i(TAG, ""Missing broadcast: "" + waitSyncList);
            }
            return waitSyncList.isEmpty();
        }
    }

    private boolean waitForBroadcasts(int waitSingleSync) {
        return waitForBroadcasts(
                new LinkedList<Integer>(Arrays.asList(waitSingleSync)));
    }

    private boolean waitForServiceResponse(MyResponse waitResponse) {
        synchronized (waitResponse) {
            long timeout = System.currentTimeMillis() + TIMEOUT_MSEC;
            while (System.currentTimeMillis() < timeout) {
                try {
                    waitResponse.wait(WAIT_MSEC);
                } catch (InterruptedException e) { }

                if (waitResponse.valid) {
                    return true;
                }
            }
            return false;
        }
    }

    // Return true if location is enabled.
    private boolean isLocationEnabled() {
        return Settings.Secure.getInt(getContext().getContentResolver(),
                Settings.Secure.LOCATION_MODE, Settings.Secure.LOCATION_MODE_OFF)
                != Settings.Secure.LOCATION_MODE_OFF;
    }

    // Returns true if the device has location feature.
    private boolean hasLocationFeature() {
        return getContext().getPackageManager().hasSystemFeature(PackageManager.FEATURE_LOCATION);
    }

    private void resetResponse(MyResponse responseObj) {
        synchronized (responseObj) {
            responseObj.valid = false;
            responseObj.networkInfo = null;
            responseObj.p2pInfo = null;
            responseObj.deviceName = null;
            responseObj.persistentGroups = null;
            responseObj.group = null;
        }
    }

    /*
     * Enables Wifi and block until connection is established.
     */
    private void enableWifi() throws InterruptedException {
        if (!mWifiManager.isWifiEnabled()) {
            SystemUtil.runShellCommand(""svc wifi enable"");
        }

        ConnectivityManager cm =
            (ConnectivityManager) getContext().getSystemService(Context.CONNECTIVITY_SERVICE);
        NetworkRequest request =
            new NetworkRequest.Builder().addTransportType(NetworkCapabilities.TRANSPORT_WIFI)
                                        .addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
                                        .build();
        final CountDownLatch latch = new CountDownLatch(1);
        NetworkCallback networkCallback = new NetworkCallback() {
            @Override
            public void onAvailable(Network network) {
                latch.countDown();
            }
        };
        cm.registerNetworkCallback(request, networkCallback);
        latch.await(DURATION, TimeUnit.MILLISECONDS);

        cm.unregisterNetworkCallback(networkCallback);
    }

    private void removeAllPersistentGroups() {
        WifiP2pGroupList persistentGroups = getPersistentGroups();
        assertNotNull(persistentGroups);
        for (WifiP2pGroup group: persistentGroups.getGroupList()) {
            resetResponse(mMyResponse);
            ShellIdentityUtils.invokeWithShellPermissions(() -> {
                mWifiP2pManager.deletePersistentGroup(mWifiP2pChannel,
                        group.getNetworkId(),
                        mActionListener);
                assertTrue(waitForServiceResponse(mMyResponse));
                assertTrue(mMyResponse.success);
            });
        }
        persistentGroups = getPersistentGroups();
        assertNotNull(persistentGroups);
        assertEquals(0, persistentGroups.getGroupList().size());
    }

    private boolean setupWifiP2p() {
        // Cannot support p2p alone
        if (!WifiFeature.isWifiSupported(getContext())) {
            assertTrue(!WifiFeature.isP2pSupported(getContext()));
            return false;
        }

        if (!WifiFeature.isP2pSupported(getContext())) {
            // skip the test if p2p is not supported
            return false;
        }

        if (!hasLocationFeature()) {
            Log.d(TAG, ""Skipping test as location is not supported"");
            return false;
        }
        if (!isLocationEnabled()) {
            fail(""Please enable location for this test - since P-release WiFi Direct""
                    + "" needs Location enabled."");
        }

        long timeout = System.currentTimeMillis() + TIMEOUT_MSEC;
        while (!mWifiManager.isWifiEnabled() && System.currentTimeMillis() < timeout) {
            try {
                enableWifi();
            } catch (InterruptedException e) { }
        }

        assertTrue(mWifiManager.isWifiEnabled());

        mWifiP2pManager =
                (WifiP2pManager) getContext().getSystemService(Context.WIFI_P2P_SERVICE);
        mWifiP2pChannel = mWifiP2pManager.initialize(
                getContext(), getContext().getMainLooper(), null);

        assertNotNull(mWifiP2pManager);
        assertNotNull(mWifiP2pChannel);

        assertTrue(waitForBroadcasts(
                new LinkedList<Integer>(
                Arrays.asList(MySync.WIFI_STATE, MySync.P2P_STATE))));

        assertEquals(WifiManager.WIFI_STATE_ENABLED, mMySync.expectedWifiState);
        assertEquals(WifiP2pManager.WIFI_P2P_STATE_ENABLED, mMySync.expectedP2pState);
        removeAllPersistentGroups();

        return true;
    }"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.ConcurrencyTest"	"testConcurrency"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ConcurrencyTest.java"	""	"public void testConcurrency() {
        if (!setupWifiP2p()) {
            return;
        }

        resetResponse(mMyResponse);
        mWifiP2pManager.requestP2pState(mWifiP2pChannel, new WifiP2pManager.P2pStateListener() {
            @Override
            public void onP2pStateAvailable(int state) {
                synchronized (mMyResponse) {
                    mMyResponse.valid = true;
                    mMyResponse.p2pState = state;
                    mMyResponse.notify();
                }
            }
        });
        assertTrue(waitForServiceResponse(mMyResponse));
        assertEquals(WifiP2pManager.WIFI_P2P_STATE_ENABLED, mMyResponse.p2pState);
    }"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.ConcurrencyTest"	"testRequestDiscoveryState"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ConcurrencyTest.java"	""	"public void testRequestDiscoveryState() {
        if (!setupWifiP2p()) {
            return;
        }

        resetResponse(mMyResponse);
        mWifiP2pManager.requestDiscoveryState(
                mWifiP2pChannel, new WifiP2pManager.DiscoveryStateListener() {
                    @Override
                    public void onDiscoveryStateAvailable(int state) {
                        synchronized (mMyResponse) {
                            mMyResponse.valid = true;
                            mMyResponse.discoveryState = state;
                            mMyResponse.notify();
                        }
                    }
                });
        assertTrue(waitForServiceResponse(mMyResponse));
        assertEquals(WifiP2pManager.WIFI_P2P_DISCOVERY_STOPPED, mMyResponse.discoveryState);

        // If there is any saved network and this device is connecting to this saved network,
        // p2p discovery might be blocked during DHCP provision.
        int retryCount = 3;
        while (retryCount > 0) {
            resetResponse(mMyResponse);
            mWifiP2pManager.discoverPeers(mWifiP2pChannel, mActionListener);
            assertTrue(waitForServiceResponse(mMyResponse));
            if (mMyResponse.success
                    || mMyResponse.failureReason != WifiP2pManager.BUSY) {
                break;
            }
            Log.w(TAG, ""Discovery is blocked, try again!"");
            try {
                Thread.sleep(500);
            } catch (InterruptedException ex) {}
            retryCount--;
        }
        assertTrue(mMyResponse.success);
        assertTrue(waitForBroadcasts(MySync.DISCOVERY_STATE));

        resetResponse(mMyResponse);
        mWifiP2pManager.requestDiscoveryState(mWifiP2pChannel,
                new WifiP2pManager.DiscoveryStateListener() {
                    @Override
                    public void onDiscoveryStateAvailable(int state) {
                        synchronized (mMyResponse) {
                            mMyResponse.valid = true;
                            mMyResponse.discoveryState = state;
                            mMyResponse.notify();
                        }
                    }
                });
        assertTrue(waitForServiceResponse(mMyResponse));
        assertEquals(WifiP2pManager.WIFI_P2P_DISCOVERY_STARTED, mMyResponse.discoveryState);

        mWifiP2pManager.stopPeerDiscovery(mWifiP2pChannel, null);
    }"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.ConcurrencyTest"	"testRequestNetworkInfo"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ConcurrencyTest.java"	""	"public void testRequestNetworkInfo() {
        if (!setupWifiP2p()) {
            return;
        }

        resetResponse(mMyResponse);
        mWifiP2pManager.requestNetworkInfo(mWifiP2pChannel,
                new WifiP2pManager.NetworkInfoListener() {
                    @Override
                    public void onNetworkInfoAvailable(NetworkInfo info) {
                        synchronized (mMyResponse) {
                            mMyResponse.valid = true;
                            mMyResponse.networkInfo = info;
                            mMyResponse.notify();
                        }
                    }
                });
        assertTrue(waitForServiceResponse(mMyResponse));
        assertNotNull(mMyResponse.networkInfo);
        // The state might be IDLE, DISCONNECTED, FAILED before a connection establishment.
        // Just ensure the state is NOT CONNECTED.
        assertNotEquals(NetworkInfo.DetailedState.CONNECTED,
                mMySync.expectedNetworkInfo.getDetailedState());

        resetResponse(mMyResponse);
        mWifiP2pManager.createGroup(mWifiP2pChannel, mActionListener);
        assertTrue(waitForServiceResponse(mMyResponse));
        assertTrue(mMyResponse.success);

        // The first network state might be IDLE due to
        // lazy initialization, but not CONNECTED.
        for (int i = 0; i < 2; i++) {
            assertTrue(waitForBroadcasts(MySync.NETWORK_INFO));
            assertNotNull(mMySync.expectedNetworkInfo);
            if (NetworkInfo.DetailedState.CONNECTED ==
                    mMySync.expectedNetworkInfo.getDetailedState()) {
                break;
            }
            assertEquals(NetworkInfo.DetailedState.IDLE,
                    mMySync.expectedNetworkInfo.getDetailedState());
        }
        assertEquals(NetworkInfo.DetailedState.CONNECTED,
                mMySync.expectedNetworkInfo.getDetailedState());

        resetResponse(mMyResponse);
        mWifiP2pManager.requestNetworkInfo(mWifiP2pChannel,
                new WifiP2pManager.NetworkInfoListener() {
                    @Override
                    public void onNetworkInfoAvailable(NetworkInfo info) {
                        synchronized (mMyResponse) {
                            mMyResponse.valid = true;
                            mMyResponse.networkInfo = info;
                            mMyResponse.notify();
                        }
                    }
                });
        assertTrue(waitForServiceResponse(mMyResponse));
        assertNotNull(mMyResponse.networkInfo);
        assertEquals(NetworkInfo.DetailedState.CONNECTED,
                mMyResponse.networkInfo.getDetailedState());

        resetResponse(mMyResponse);
        mWifiP2pManager.requestConnectionInfo(mWifiP2pChannel,
                new WifiP2pManager.ConnectionInfoListener() {
                    @Override
                    public void onConnectionInfoAvailable(WifiP2pInfo info) {
                        synchronized (mMyResponse) {
                            mMyResponse.valid = true;
                            mMyResponse.p2pInfo = new WifiP2pInfo(info);
                            mMyResponse.notify();
                        }
                    }
                });
        assertTrue(waitForServiceResponse(mMyResponse));
        assertNotNull(mMyResponse.p2pInfo);
        assertTrue(mMyResponse.p2pInfo.groupFormed);
        assertTrue(mMyResponse.p2pInfo.isGroupOwner);

        resetResponse(mMyResponse);
        mWifiP2pManager.requestGroupInfo(mWifiP2pChannel,
                new WifiP2pManager.GroupInfoListener() {
                    @Override
                    public void onGroupInfoAvailable(WifiP2pGroup group) {
                        synchronized (mMyResponse) {
                            mMyResponse.group = new WifiP2pGroup(group);
                            mMyResponse.valid = true;
                            mMyResponse.notify();
                        }
                    }
                });
        assertTrue(waitForServiceResponse(mMyResponse));
        assertNotNull(mMyResponse.group);
        assertNotEquals(0, mMyResponse.group.getFrequency());
        assertTrue(mMyResponse.group.getNetworkId() >= 0);

        resetResponse(mMyResponse);
        mWifiP2pManager.removeGroup(mWifiP2pChannel, mActionListener);
        assertTrue(waitForServiceResponse(mMyResponse));
        assertTrue(mMyResponse.success);
        assertTrue(waitForBroadcasts(MySync.NETWORK_INFO));
        assertNotNull(mMySync.expectedNetworkInfo);
        assertEquals(NetworkInfo.DetailedState.DISCONNECTED,
                mMySync.expectedNetworkInfo.getDetailedState());
    }

    private String getDeviceName() {
        resetResponse(mMyResponse);
        mWifiP2pManager.requestDeviceInfo(mWifiP2pChannel,
                new WifiP2pManager.DeviceInfoListener() {
                    @Override
                    public void onDeviceInfoAvailable(WifiP2pDevice wifiP2pDevice) {
                        synchronized (mMyResponse) {
                            mMyResponse.deviceName = wifiP2pDevice.deviceName;
                            mMyResponse.valid = true;
                            mMyResponse.notify();
                        }
                    }
                });
        assertTrue(waitForServiceResponse(mMyResponse));
        return mMyResponse.deviceName;
    }"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.ConcurrencyTest"	"testSetDeviceName"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ConcurrencyTest.java"	""	"public void testSetDeviceName() {
        if (!setupWifiP2p()) {
            return;
        }

        String testDeviceName = ""test"";
        String originalDeviceName = getDeviceName();
        assertNotNull(originalDeviceName);

        resetResponse(mMyResponse);
        ShellIdentityUtils.invokeWithShellPermissions(() -> {
            mWifiP2pManager.setDeviceName(
                    mWifiP2pChannel, testDeviceName, mActionListener);
            assertTrue(waitForServiceResponse(mMyResponse));
            assertTrue(mMyResponse.success);
        });

        String currentDeviceName = getDeviceName();
        assertEquals(testDeviceName, currentDeviceName);

        // restore the device name at the end
        resetResponse(mMyResponse);
        ShellIdentityUtils.invokeWithShellPermissions(() -> {
            mWifiP2pManager.setDeviceName(
                    mWifiP2pChannel, originalDeviceName, mActionListener);
            assertTrue(waitForServiceResponse(mMyResponse));
            assertTrue(mMyResponse.success);
        });
    }

    private WifiP2pGroupList getPersistentGroups() {
        resetResponse(mMyResponse);
        ShellIdentityUtils.invokeWithShellPermissions(() -> {
            mWifiP2pManager.requestPersistentGroupInfo(mWifiP2pChannel,
                    new WifiP2pManager.PersistentGroupInfoListener() {
                        @Override
                        public void onPersistentGroupInfoAvailable(WifiP2pGroupList groups) {
                            synchronized (mMyResponse) {
                                mMyResponse.persistentGroups = groups;
                                mMyResponse.valid = true;
                                mMyResponse.notify();
                            }
                        }
                    });
            assertTrue(waitForServiceResponse(mMyResponse));
        });
        return mMyResponse.persistentGroups;
    }"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.ConcurrencyTest"	"testPersistentGroupOperation"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ConcurrencyTest.java"	""	"public void testPersistentGroupOperation() {
        if (!setupWifiP2p()) {
            return;
        }

        resetResponse(mMyResponse);
        mWifiP2pManager.createGroup(mWifiP2pChannel, mActionListener);
        assertTrue(waitForServiceResponse(mMyResponse));
        assertTrue(mMyResponse.success);

        // The first network state might be IDLE due to
        // lazy initialization, but not CONNECTED.
        for (int i = 0; i < 2; i++) {
            assertTrue(waitForBroadcasts(MySync.NETWORK_INFO));
            assertNotNull(mMySync.expectedNetworkInfo);
            if (NetworkInfo.DetailedState.CONNECTED ==
                    mMySync.expectedNetworkInfo.getDetailedState()) {
                break;
            }
            assertEquals(NetworkInfo.DetailedState.IDLE,
                    mMySync.expectedNetworkInfo.getDetailedState());
        }
        assertEquals(NetworkInfo.DetailedState.CONNECTED,
                mMySync.expectedNetworkInfo.getDetailedState());

        resetResponse(mMyResponse);
        mWifiP2pManager.removeGroup(mWifiP2pChannel, mActionListener);
        assertTrue(waitForServiceResponse(mMyResponse));
        assertTrue(mMyResponse.success);
        assertTrue(waitForBroadcasts(MySync.NETWORK_INFO));
        assertNotNull(mMySync.expectedNetworkInfo);
        assertEquals(NetworkInfo.DetailedState.DISCONNECTED,
                mMySync.expectedNetworkInfo.getDetailedState());

        WifiP2pGroupList persistentGroups = getPersistentGroups();
        assertNotNull(persistentGroups);
        assertEquals(1, persistentGroups.getGroupList().size());

        resetResponse(mMyResponse);
        final int firstNetworkId = persistentGroups.getGroupList().get(0).getNetworkId();
        ShellIdentityUtils.invokeWithShellPermissions(() -> {
            mWifiP2pManager.deletePersistentGroup(mWifiP2pChannel,
                    firstNetworkId,
                    mActionListener);
            assertTrue(waitForServiceResponse(mMyResponse));
            assertTrue(mMyResponse.success);
        });

        persistentGroups = getPersistentGroups();
        assertNotNull(persistentGroups);
        assertEquals(0, persistentGroups.getGroupList().size());

        resetResponse(mMyResponse);
        mWifiP2pManager.createGroup(mWifiP2pChannel, mActionListener);
        assertTrue(waitForServiceResponse(mMyResponse));
        assertTrue(mMyResponse.success);
        assertTrue(waitForBroadcasts(MySync.NETWORK_INFO));
        assertNotNull(mMySync.expectedNetworkInfo);
        assertEquals(NetworkInfo.DetailedState.CONNECTED,
                mMySync.expectedNetworkInfo.getDetailedState());

        resetResponse(mMyResponse);
        mWifiP2pManager.removeGroup(mWifiP2pChannel, mActionListener);
        assertTrue(waitForServiceResponse(mMyResponse));
        assertTrue(mMyResponse.success);
        assertTrue(waitForBroadcasts(MySync.NETWORK_INFO));
        assertNotNull(mMySync.expectedNetworkInfo);
        assertEquals(NetworkInfo.DetailedState.DISCONNECTED,
                mMySync.expectedNetworkInfo.getDetailedState());

        resetResponse(mMyResponse);
        ShellIdentityUtils.invokeWithShellPermissions(() -> {
            mWifiP2pManager.factoryReset(mWifiP2pChannel, mActionListener);
            assertTrue(waitForServiceResponse(mMyResponse));
            assertTrue(mMyResponse.success);
        });

        persistentGroups = getPersistentGroups();
        assertNotNull(persistentGroups);
        assertEquals(0, persistentGroups.getGroupList().size());
    }"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.ConcurrencyTest"	"testP2pListening"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ConcurrencyTest.java"	""	"public void testP2pListening() {
        if (!setupWifiP2p()) {
            return;
        }

        resetResponse(mMyResponse);
        ShellIdentityUtils.invokeWithShellPermissions(() -> {
            mWifiP2pManager.setWifiP2pChannels(mWifiP2pChannel, 6, 11, mActionListener);
            assertTrue(waitForServiceResponse(mMyResponse));
            assertTrue(mMyResponse.success);
        });

        resetResponse(mMyResponse);
        ShellIdentityUtils.invokeWithShellPermissions(() -> {
            mWifiP2pManager.startListening(mWifiP2pChannel, mActionListener);
            assertTrue(waitForServiceResponse(mMyResponse));
            assertTrue(mMyResponse.success);
        });

        resetResponse(mMyResponse);
        ShellIdentityUtils.invokeWithShellPermissions(() -> {
            mWifiP2pManager.stopListening(mWifiP2pChannel, mActionListener);
            assertTrue(waitForServiceResponse(mMyResponse));
            assertTrue(mMyResponse.success);
        });
    }"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.ConcurrencyTest"	"testP2pService"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ConcurrencyTest.java"	""	"public void testP2pService() {
        if (!setupWifiP2p()) {
            return;
        }

        // This only store the listener to the WifiP2pManager internal variable, nothing to fail.
        mWifiP2pManager.setServiceResponseListener(mWifiP2pChannel,
                new WifiP2pManager.ServiceResponseListener() {
                    @Override
                    public void onServiceAvailable(
                            int protocolType, byte[] responseData, WifiP2pDevice srcDevice) {
                    }
                });

        resetResponse(mMyResponse);
        List<String> services = new ArrayList<String>();
        services.add(""urn:schemas-upnp-org:service:AVTransport:1"");
        services.add(""urn:schemas-upnp-org:service:ConnectionManager:1"");
        WifiP2pServiceInfo rendererService = WifiP2pUpnpServiceInfo.newInstance(
                ""6859dede-8574-59ab-9332-123456789011"",
                ""urn:schemas-upnp-org:device:MediaRenderer:1"",
                services);
        mWifiP2pManager.addLocalService(mWifiP2pChannel,
                rendererService,
                mActionListener);
        assertTrue(waitForServiceResponse(mMyResponse));
        assertTrue(mMyResponse.success);

        resetResponse(mMyResponse);
        mWifiP2pManager.removeLocalService(mWifiP2pChannel,
                rendererService,
                mActionListener);
        assertTrue(waitForServiceResponse(mMyResponse));
        assertTrue(mMyResponse.success);

        resetResponse(mMyResponse);
        mWifiP2pManager.clearLocalServices(mWifiP2pChannel,
                mActionListener);
        assertTrue(waitForServiceResponse(mMyResponse));
        assertTrue(mMyResponse.success);
    }
}"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.MultiStaConcurrencyWifiNetworkSpecifierTest"	"isStaConcurrencyForLocalOnlyConnectionsSupported"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/MultiStaConcurrencyWifiNetworkSpecifierTest.java"	""	"/*
 *.
 */

package android.net.wifi.cts;

import static android.os.Process.myUid;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import static org.junit.Assume.assumeTrue;

import android.content.Context;
import android.content.pm.PackageManager;
import android.location.LocationManager;
import android.net.ConnectivityManager;
import android.net.NetworkRequest;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiManager;
import android.net.wifi.WifiNetworkSpecifier;
import android.os.Build;
import android.platform.test.annotations.AppModeFull;
import android.support.test.uiautomator.UiDevice;

import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.filters.LargeTest;
import androidx.test.filters.SdkSuppress;
import androidx.test.platform.app.InstrumentationRegistry;

import com.android.compatibility.common.util.PollingCheck;
import com.android.compatibility.common.util.ShellIdentityUtils;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.List;

/**
 * Tests multiple concurrent connection flow on devices that support multi STA concurrency
 * (indicated via {@link WifiManager#isStaConcurrencyForLocalOnlyConnectionsSupported()}.
 *
 * Tests the entire connection flow using {@link WifiNetworkSpecifier} embedded in a
 * {@link NetworkRequest} & passed into {@link ConnectivityManager#requestNetwork(NetworkRequest,
 * ConnectivityManager.NetworkCallback)} along with a concurrent internet connection using
 * {@link WifiManager#connect(int, WifiManager.ActionListener)}.
 *
 * Assumes that all the saved networks is either open/WPA1/WPA2/WPA3 authenticated network.
 *
 * TODO(b/177591382): Refactor some of the utilities to a separate file that are copied over from
 * WifiManagerTest & WifiNetworkSpecifierTest.
 */
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)
@AppModeFull(reason = ""Cannot get WifiManager in instant app mode"")
@LargeTest
@RunWith(AndroidJUnit4.class)
public class MultiStaConcurrencyWifiNetworkSpecifierTest extends WifiJUnit4TestBase {
    private static final String TAG = ""MultiStaConcurrencyWifiNetworkSpecifierTest"";
    private static boolean sWasVerboseLoggingEnabled;
    private static boolean sWasScanThrottleEnabled;
    private static boolean sWasWifiEnabled;

    private Context mContext;
    private WifiManager mWifiManager;
    private ConnectivityManager mConnectivityManager;
    private UiDevice mUiDevice;
    private WifiConfiguration mTestNetworkForPeerToPeer;
    private WifiConfiguration mTestNetworkForInternetConnection;
    private ConnectivityManager.NetworkCallback mNetworkCallback;
    private ConnectivityManager.NetworkCallback mNrNetworkCallback;
    private TestHelper mTestHelper;

    private static final int DURATION = 10_000;
    private static final int DURATION_UI_INTERACTION = 25_000;
    private static final int DURATION_NETWORK_CONNECTION = 60_000;
    private static final int DURATION_SCREEN_TOGGLE = 2000;
    private static final int SCAN_RETRY_CNT_TO_FIND_MATCHING_BSSID = 3;

    @BeforeClass
    public static void setUpClass() throws Exception {
        Context context = InstrumentationRegistry.getInstrumentation().getContext();
        // skip the test if WiFi is not supported. Don't use assumeTrue in @BeforeClass
        if (!WifiFeature.isWifiSupported(context)) return;

        WifiManager wifiManager = context.getSystemService(WifiManager.class);
        assertThat(wifiManager).isNotNull();

        // turn on verbose logging for tests
        sWasVerboseLoggingEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.isVerboseLoggingEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setVerboseLoggingEnabled(true));
        // Disable scan throttling for tests.
        sWasScanThrottleEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.isScanThrottleEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setScanThrottleEnabled(false));

        // enable Wifi
        sWasWifiEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.isWifiEnabled());
        if (!wifiManager.isWifiEnabled()) {
            ShellIdentityUtils.invokeWithShellPermissions(() -> wifiManager.setWifiEnabled(true));
        }
        PollingCheck.check(""Wifi not enabled"", DURATION, () -> wifiManager.isWifiEnabled());
    }

    @AfterClass
    public static void tearDownClass() throws Exception {
        Context context = InstrumentationRegistry.getInstrumentation().getContext();
        if (!WifiFeature.isWifiSupported(context)) return;

        WifiManager wifiManager = context.getSystemService(WifiManager.class);
        assertThat(wifiManager).isNotNull();

        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setScanThrottleEnabled(sWasScanThrottleEnabled));
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setVerboseLoggingEnabled(sWasVerboseLoggingEnabled));
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setWifiEnabled(sWasWifiEnabled));
    }

    @Before
    public void setUp() throws Exception {
        mContext = InstrumentationRegistry.getInstrumentation().getContext();
        mWifiManager = mContext.getSystemService(WifiManager.class);
        mConnectivityManager = mContext.getSystemService(ConnectivityManager.class);
        mUiDevice = UiDevice.getInstance(InstrumentationRegistry.getInstrumentation());
        mTestHelper = new TestHelper(mContext, mUiDevice);

        // skip the test if WiFi is not supported
        assumeTrue(WifiFeature.isWifiSupported(mContext));
        // skip the test if location is not supported
        assumeTrue(mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_LOCATION));
        // skip if multi STA not supported.
        assumeTrue(mWifiManager.isStaConcurrencyForLocalOnlyConnectionsSupported());

        assertWithMessage(""Please enable location for this test!"")
                .that(mContext.getSystemService(LocationManager.class).isLocationEnabled())
                .isTrue();

        // turn screen on
        mTestHelper.turnScreenOn();

        // Clear any existing app state before each test.
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.removeAppState(myUid(), mContext.getPackageName()));

        // We need 2 AP's for the test. If there are 2 networks saved on the device and in range,
        // use those. Otherwise, check if there are 2 BSSID's in range for the only saved network.
        // This assumes a CTS test environment with at least 2 connectable bssid's (Is that ok?).
        List<WifiConfiguration> savedNetworks = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.getPrivilegedConfiguredNetworks());
        List<WifiConfiguration> matchingNetworksWithBssid =
                TestHelper.findMatchingSavedNetworksWithBssid(mWifiManager, savedNetworks);
        assertWithMessage(""Need at least 2 saved network bssids in range"")
                .that(matchingNetworksWithBssid.size()).isAtLeast(2);
        // Pick any 2 bssid for test.
        mTestNetworkForPeerToPeer = matchingNetworksWithBssid.get(0);
        // Try to find a bssid for another saved network in range. If none exists, fallback
        // to using 2 bssid's for the same network.
        mTestNetworkForInternetConnection = matchingNetworksWithBssid.stream()
                .filter(w -> !w.SSID.equals(mTestNetworkForPeerToPeer.SSID))
                .findAny()
                .orElse(matchingNetworksWithBssid.get(1));

        // Disconnect & disable auto-join on the saved network to prevent auto-connect from
        // interfering with the test.
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> {
                    for (WifiConfiguration savedNetwork : savedNetworks) {
                        mWifiManager.disableNetwork(savedNetwork.networkId);
                    }
                    mWifiManager.disconnect();
                });

        // Wait for Wifi to be disconnected.
        PollingCheck.check(
                ""Wifi not disconnected"",
                20_000,
                () -> mWifiManager.getConnectionInfo().getNetworkId() == -1);
    }

    @After
    public void tearDown() throws Exception {
        // Re-enable networks.
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> {
                    for (WifiConfiguration savedNetwork : mWifiManager.getConfiguredNetworks()) {
                        mWifiManager.enableNetwork(savedNetwork.networkId, false);
                    }
                });
        // Release the requests after the test.
        if (mNetworkCallback != null) {
            mConnectivityManager.unregisterNetworkCallback(mNetworkCallback);
        }
        if (mNrNetworkCallback != null) {
            mConnectivityManager.unregisterNetworkCallback(mNrNetworkCallback);
        }
        // Clear any existing app state after each test.
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.removeAppState(myUid(), mContext.getPackageName()));
        mTestHelper.turnScreenOff();
    }

    private void testSuccessfulConnectionWithSpecifier(
            WifiConfiguration network, WifiNetworkSpecifier specifier) throws Exception {
        mNrNetworkCallback = mTestHelper.testConnectionFlowWithSpecifier(
                network, specifier, false);
    }

    private void testUserRejectionWithSpecifier(
            WifiConfiguration network, WifiNetworkSpecifier specifier) throws Exception {
        mNrNetworkCallback = mTestHelper.testConnectionFlowWithSpecifier(
                network, specifier, true);
    }

    /**
     * Tests the concurrent connection flow.
     * 1. Connect to a network using internet connectivity API.
     * 2. Connect to a network using peer to peer API.
     * 3. Verify that both connections are active.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.MultiStaConcurrencyWifiNetworkSpecifierTest"	"testConnectToPeerPeerNetworkWhenConnectedToInternetNetwork"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/MultiStaConcurrencyWifiNetworkSpecifierTest.java"	""	"public void testConnectToPeerPeerNetworkWhenConnectedToInternetNetwork() throws Exception {
        // First trigger internet connectivity.
        mNetworkCallback = mTestHelper.testConnectionFlowWithConnect(
                mTestNetworkForInternetConnection);

        // Now trigger peer to peer connectivity.
        WifiNetworkSpecifier specifier =
                TestHelper.createSpecifierBuilderWithCredentialFromSavedNetworkWithBssid(
                        mTestNetworkForPeerToPeer)
                .build();
        testSuccessfulConnectionWithSpecifier(mTestNetworkForPeerToPeer, specifier);

        // Ensure that there are 2 wifi connections available for apps.
        assertThat(mTestHelper.getNumWifiConnections()).isEqualTo(2);
    }

    /**
     * Tests the concurrent connection flow.
     * 1. Connect to a network using peer to peer API.
     * 2. Connect to a network using internet connectivity API.
     * 3. Verify that both connections are active.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.MultiStaConcurrencyWifiNetworkSpecifierTest"	"testConnectToInternetNetworkWhenConnectedToPeerPeerNetwork"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/MultiStaConcurrencyWifiNetworkSpecifierTest.java"	""	"public void testConnectToInternetNetworkWhenConnectedToPeerPeerNetwork() throws Exception {
        // First trigger peer to peer connectivity.
        WifiNetworkSpecifier specifier =
                TestHelper.createSpecifierBuilderWithCredentialFromSavedNetworkWithBssid(
                        mTestNetworkForPeerToPeer)
                        .build();
        testSuccessfulConnectionWithSpecifier(mTestNetworkForPeerToPeer, specifier);

        // Now trigger internet connectivity.
        mNetworkCallback = mTestHelper.testConnectionFlowWithConnect(
                mTestNetworkForInternetConnection);

        // Ensure that there are 2 wifi connections available for apps.
        assertThat(mTestHelper.getNumWifiConnections()).isEqualTo(2);
    }

    /**
     * Tests the concurrent connection flow.
     * 1. Connect to a network using internet connectivity API.
     * 2. Trigger connect to a network using peer to peer API which is rejected by user.
     * 3. Verify that only one connection is active.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.MultiStaConcurrencyWifiNetworkSpecifierTest"	"testPeerToPeerConnectionRejectWhenConnectedToInternetNetwork"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/MultiStaConcurrencyWifiNetworkSpecifierTest.java"	""	"public void testPeerToPeerConnectionRejectWhenConnectedToInternetNetwork() throws Exception {
        // First trigger internet connectivity.
        mNetworkCallback = mTestHelper.testConnectionFlowWithConnect(
                mTestNetworkForInternetConnection);

        // Now trigger peer to peer connectivity.
        WifiNetworkSpecifier specifier =
                TestHelper.createSpecifierBuilderWithCredentialFromSavedNetworkWithBssid(
                        mTestNetworkForPeerToPeer)
                        .build();
        testUserRejectionWithSpecifier(mTestNetworkForPeerToPeer, specifier);

        // Ensure that there is only 1 wifi connection available for apps.
        assertThat(mTestHelper.getNumWifiConnections()).isEqualTo(1);
    }
}"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WaitForResultActivity"	"isTrue"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WaitForResultActivity.java"	""	"public void test/*
 *.
 */

package android.net.wifi.cts;

import static com.google.common.truth.Truth.assertThat;

import android.app.Activity;
import android.app.job.JobInfo;
import android.app.job.JobScheduler;
import android.content.ComponentName;
import android.content.Intent;
import android.os.Bundle;
import android.os.Parcel;
import android.os.ResultReceiver;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

/**
 * An Activity that can start another Activity and wait for its result.
 */
public class WaitForResultActivity extends Activity {
    private final Object mStatusLock = new Object();
    private CountDownLatch mLatch;
    private boolean mStatus = false;

    private static final int REQUEST_CODE_WAIT_FOR_RESULT = 1;
    private static final String WIFI_LOCATION_TEST_APP_LOCATION_STATUS_EXTRA =
            ""android.net.wifi.cts.app.extra.STATUS"";

    public void startActivityToWaitForResult(@NonNull ComponentName componentName) {
        mLatch = new CountDownLatch(1);
        synchronized (mStatusLock) {
            mStatus = false;
        }
        Intent intent = new Intent()
                .addFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT)
                .setComponent(componentName);
        startActivityForResult(intent, REQUEST_CODE_WAIT_FOR_RESULT);
    }

    @NonNull
    public boolean waitForActivityResult(long timeoutMillis)
            throws InterruptedException {
        assertThat(mLatch.await(timeoutMillis, TimeUnit.MILLISECONDS)).isTrue();
        synchronized (mStatusLock) {
            return mStatus;
        }
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) {
        if (requestCode == REQUEST_CODE_WAIT_FOR_RESULT) {
            assertThat(resultCode).isEqualTo(RESULT_OK);
            assertThat(data.hasExtra(WIFI_LOCATION_TEST_APP_LOCATION_STATUS_EXTRA)).isTrue();
            synchronized (mStatusLock) {
                mStatus = data.getBooleanExtra(
                        WIFI_LOCATION_TEST_APP_LOCATION_STATUS_EXTRA, false);
            }
            mLatch.countDown();
        } else {
            super.onActivityResult(requestCode, resultCode, data);
        }
    }

    private static final String WIFI_LOCATION_TEST_APP_PACKAGE_NAME =
            ""android.net.wifi.cts.app"";
    private static final String WIFI_LOCATION_TEST_APP_SCHEDULE_JOB_ACTIVITY =
            WIFI_LOCATION_TEST_APP_PACKAGE_NAME + "".ScheduleJobActivity"";
    private static final String RESULT_RECEIVER_EXTRA =
            ""android.net.wifi.cts.app.extra.RESULT_RECEIVER"";
    private static final String SERVICE_COMPONENT_EXTRA =
            ""android.net.wifi.cts.app.extra.SERVICE_COMPONENT"";

    private static ResultReceiver convertToGeneric(ResultReceiver receiver) {
        Parcel parcel = Parcel.obtain();
        receiver.writeToParcel(parcel,0);
        parcel.setDataPosition(0);
        ResultReceiver receiverGeneric = ResultReceiver.CREATOR.createFromParcel(parcel);
        parcel.recycle();
        return receiverGeneric;
    }

    public void startServiceToWaitForResult(@NonNull ComponentName serviceComponent) {
        mLatch = new CountDownLatch(1);
        synchronized (mStatusLock) {
            mStatus = false;
        }
        ResultReceiver resultReceiver = new ResultReceiver(null) {
            @Override
            public void onReceiveResult(int resultCode, Bundle data) {
                synchronized (mStatusLock) {
                    mStatus = resultCode == 1;
                }
                mLatch.countDown();
            }
        };
        Intent intent = new Intent()
                .setComponent(new ComponentName(WIFI_LOCATION_TEST_APP_PACKAGE_NAME,
                        WIFI_LOCATION_TEST_APP_SCHEDULE_JOB_ACTIVITY))
                .putExtra(RESULT_RECEIVER_EXTRA, convertToGeneric(resultReceiver))
                .putExtra(SERVICE_COMPONENT_EXTRA, serviceComponent);
        startActivity(intent);
    }

    @NonNull
    public boolean waitForServiceResult(long timeoutMillis)
            throws InterruptedException {
        assertThat(mLatch.await(timeoutMillis, TimeUnit.MILLISECONDS)).isTrue();
        synchronized (mStatusLock) {
            return mStatus;
        }
    }

}"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.nl80211.cts.DeviceWiphyCapabilitiesTest"	"isTrue"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/nl80211/cts/DeviceWiphyCapabilitiesTest.java"	""	"public void canSerializeAndDeserialize() {
        DeviceWiphyCapabilities capa = new DeviceWiphyCapabilities();

        capa.setWifiStandardSupport(ScanResult.WIFI_STANDARD_11N, true);
        capa.setWifiStandardSupport(ScanResult.WIFI_STANDARD_11AC, true);
        capa.setWifiStandardSupport(ScanResult.WIFI_STANDARD_11AX, false);

        Parcel parcel = Parcel.obtain();
        capa.writeToParcel(parcel, 0);
        // Rewind the pointer to the head of the parcel.
        parcel.setDataPosition(0);
        DeviceWiphyCapabilities capaDeserialized =
                DeviceWiphyCapabilities.CREATOR.createFromParcel(parcel);

        assertThat(capaDeserialized.isWifiStandardSupported(ScanResult.WIFI_STANDARD_11N)).isTrue();
        assertThat(capaDeserialized.isWifiStandardSupported(ScanResult.WIFI_STANDARD_11AC))
                .isTrue();
        assertThat(capaDeserialized.isWifiStandardSupported(ScanResult.WIFI_STANDARD_11AX))
                .isFalse();
        assertThat(capaDeserialized).isEqualTo(capa);
        assertThat(capaDeserialized.hashCode()).isEqualTo(capa.hashCode());
    }

    /** Test mapping wifi standard support into channel width support */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.nl80211.cts.DeviceWiphyCapabilitiesTest"	"testMappingWifiStandardIntoChannelWidthSupport"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/nl80211/cts/DeviceWiphyCapabilitiesTest.java"	""	"public void testMappingWifiStandardIntoChannelWidthSupport() {
        DeviceWiphyCapabilities capa = new DeviceWiphyCapabilities();

        capa.setWifiStandardSupport(ScanResult.WIFI_STANDARD_11N, false);
        capa.setWifiStandardSupport(ScanResult.WIFI_STANDARD_11AC, false);
        capa.setWifiStandardSupport(ScanResult.WIFI_STANDARD_11AX, false);
        assertThat(capa.isChannelWidthSupported(ScanResult.CHANNEL_WIDTH_20MHZ)).isTrue();
        assertThat(capa.isChannelWidthSupported(ScanResult.CHANNEL_WIDTH_40MHZ)).isFalse();
        assertThat(capa.isChannelWidthSupported(ScanResult.CHANNEL_WIDTH_80MHZ)).isFalse();

        capa.setWifiStandardSupport(ScanResult.WIFI_STANDARD_11N, true);
        assertThat(capa.isChannelWidthSupported(ScanResult.CHANNEL_WIDTH_20MHZ)).isTrue();
        assertThat(capa.isChannelWidthSupported(ScanResult.CHANNEL_WIDTH_40MHZ)).isTrue();
        assertThat(capa.isChannelWidthSupported(ScanResult.CHANNEL_WIDTH_80MHZ)).isFalse();

        capa.setWifiStandardSupport(ScanResult.WIFI_STANDARD_11AC, true);
        assertThat(capa.isChannelWidthSupported(ScanResult.CHANNEL_WIDTH_20MHZ)).isTrue();
        assertThat(capa.isChannelWidthSupported(ScanResult.CHANNEL_WIDTH_40MHZ)).isTrue();
        assertThat(capa.isChannelWidthSupported(ScanResult.CHANNEL_WIDTH_80MHZ)).isTrue();
    }
}"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.wifiaware.BaseTestActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/wifiaware/BaseTestActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.wifiaware;

import android.content.Context;
import android.os.Bundle;
import android.os.Handler;
import android.view.View;
import android.view.WindowManager;
import android.widget.ProgressBar;
import android.widget.TextView;

import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;

/**
 * Base class for Aware tests.
 */
public abstract class BaseTestActivity extends PassFailButtons.Activity implements
        BaseTestCase.Listener {
    /*
     * Handles to GUI elements.
     */
    private TextView mAwareInfo;
    private ProgressBar mAwareProgress;

    /*
     * Test case to be executed
     */
    private BaseTestCase mTestCase;

    private Handler mHandler = new Handler();

    protected abstract BaseTestCase getTestCase(Context context);

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.aware_main);
        setPassFailButtonClickListeners();
        getPassButton().setEnabled(false);

        // Get UI component.
        mAwareInfo = (TextView) findViewById(R.id.aware_info);
        mAwareProgress = (ProgressBar) findViewById(R.id.aware_progress);

        // Initialize test components.
        mTestCase = getTestCase(this);

        // keep screen on while this activity is front view.
        getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
    }

    @Override
    protected void onResume() {
        super.onResume();
        mTestCase.start(this);
        mAwareProgress.setVisibility(View.VISIBLE);
    }

    @Override
    protected void onPause() {
        super.onPause();
        mTestCase.stop();
        mAwareProgress.setVisibility(View.GONE);
    }


    @Override
    public void onTestStarted() {
        // nop
    }

    @Override
    public void onTestMsgReceived(String msg) {
        if (msg == null) {
            return;
        }
        mHandler.post(new Runnable() {
            @Override
            public void run() {
                mAwareInfo.append(msg);
                mAwareInfo.append(""\n"");
            }
        });
    }

    @Override
    public void onTestSuccess() {
        mHandler.post(new Runnable() {
            @Override
            public void run() {
                getPassButton().setEnabled(true);
                mAwareProgress.setVisibility(View.GONE);
            }
        });
    }

    @Override
    public void onTestFailed(String reason) {
        mHandler.post(new Runnable() {
            @Override
            public void run() {
                if (reason != null) {
                    mAwareInfo.append(reason);
                }
                mAwareProgress.setVisibility(View.GONE);
            }
        });
    }
}"	""	""	"view wifi button"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.ConfigParserTest"	"testParseConfigFile"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ConfigParserTest.java"	""	"public void testParseConfigFile() throws Exception {
        String configStr = loadResourceFile(PASSPOINT_INSTALLATION_FILE_WITH_CA_CERT);
        PasspointConfiguration expectedConfig = generateConfigurationFromProfile();
        PasspointConfiguration actualConfig =
                ConfigParser.parsePasspointConfig(
                        ""application/x-wifi-config"", configStr.getBytes());
        assertTrue(actualConfig.equals(expectedConfig));
    }
}"	""	""	"passpoint wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.wifi.testcase.NetworkRequestTestCase"	"isEmpty"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/wifi/testcase/NetworkRequestTestCase.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.wifi.testcase;

import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.TRANSPORT_WIFI;

import static com.android.cts.verifier.wifi.TestUtils.SCAN_RESULT_TYPE_OPEN;
import static com.android.cts.verifier.wifi.TestUtils.SCAN_RESULT_TYPE_PSK;

import android.annotation.IntDef;
import android.annotation.NonNull;
import android.content.Context;
import android.net.ConnectivityManager;
import android.net.MacAddress;
import android.net.Network;
import android.net.NetworkRequest;
import android.net.NetworkSpecifier;
import android.net.wifi.ScanResult;
import android.net.wifi.WifiNetworkSpecifier;
import android.os.PatternMatcher;
import android.util.Log;
import android.util.Pair;

import com.android.cts.verifier.R;
import com.android.cts.verifier.wifi.BaseTestCase;
import com.android.cts.verifier.wifi.CallbackUtils;
import com.android.cts.verifier.wifi.TestUtils;

import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

/**
 * Test case for all {@link NetworkRequest} requests with specifier built using
 * {@link WifiNetworkSpecifier.Builder#build()}.
 */
public class NetworkRequestTestCase extends BaseTestCase {
    private static final String TAG = ""NetworkRequestTestCase"";
    private static final boolean DBG = true;

    private static final String UNAVAILABLE_SSID = ""blahblahblah"";
    private static final String UNAVAILABLE_BSSID = ""02:00:00:00:00:00"";
    private static final int NETWORK_REQUEST_TIMEOUT_MS = 30_000;
    private static final int CALLBACK_TIMEOUT_MS = 40_000;

    public static final int NETWORK_SPECIFIER_SPECIFIC_SSID_BSSID = 0;
    public static final int NETWORK_SPECIFIER_PATTERN_SSID_BSSID = 1;
    public static final int NETWORK_SPECIFIER_UNAVAILABLE_SSID_BSSID = 2;
    public static final int NETWORK_SPECIFIER_INVALID_CREDENTIAL = 3;

    @IntDef(prefix = { ""NETWORK_SPECIFIER_"" }, value = {
            NETWORK_SPECIFIER_SPECIFIC_SSID_BSSID,
            NETWORK_SPECIFIER_PATTERN_SSID_BSSID,
            NETWORK_SPECIFIER_UNAVAILABLE_SSID_BSSID,
            NETWORK_SPECIFIER_INVALID_CREDENTIAL
    })
    @Retention(RetentionPolicy.SOURCE)
    public @interface NetworkSpecifierType{}

    private final Object mLock = new Object();
    private final @NetworkSpecifierType int mNetworkSpecifierType;

    private ConnectivityManager mConnectivityManager;
    private NetworkRequest mNetworkRequest;
    private CallbackUtils.NetworkCallback mNetworkCallback;
    private String mFailureReason;

    public NetworkRequestTestCase(Context context, @NetworkSpecifierType int networkSpecifierType) {
        super(context);
        mNetworkSpecifierType = networkSpecifierType;
    }

    // Create a network specifier based on the test type.
    private NetworkSpecifier createNetworkSpecifier(@NonNull ScanResult scanResult)
            throws InterruptedException {
        WifiNetworkSpecifier.Builder configBuilder = new WifiNetworkSpecifier.Builder();
        switch (mNetworkSpecifierType) {
            case NETWORK_SPECIFIER_SPECIFIC_SSID_BSSID:
                configBuilder.setSsid(scanResult.SSID);
                configBuilder.setBssid(MacAddress.fromString(scanResult.BSSID));
                if (!mPsk.isEmpty()) {
                    if (TestUtils.isScanResultForWpa2Network(scanResult)) {
                        configBuilder.setWpa2Passphrase(mPsk);
                    } else if (TestUtils.isScanResultForWpa3Network(scanResult)) {
                        configBuilder.setWpa3Passphrase(mPsk);
                    }
                }
                break;
            case NETWORK_SPECIFIER_PATTERN_SSID_BSSID:
                String ssidPrefix = scanResult.SSID.substring(0, scanResult.SSID.length() - 1);
                MacAddress bssidMask = MacAddress.fromString(""ff:ff:ff:ff:ff:00"");
                configBuilder.setSsidPattern(
                        new PatternMatcher(ssidPrefix, PatternMatcher.PATTERN_PREFIX));
                configBuilder.setBssidPattern(MacAddress.fromString(scanResult.BSSID), bssidMask);
                if (!mPsk.isEmpty()) {
                    if (TestUtils.isScanResultForWpa2Network(scanResult)) {
                        configBuilder.setWpa2Passphrase(mPsk);
                    } else if (TestUtils.isScanResultForWpa3Network(scanResult)) {
                        configBuilder.setWpa3Passphrase(mPsk);
                    }
                }
                break;
            case NETWORK_SPECIFIER_UNAVAILABLE_SSID_BSSID:
                String ssid = UNAVAILABLE_SSID;
                MacAddress bssid = MacAddress.fromString(UNAVAILABLE_BSSID);
                if (mTestUtils.findNetworkInScanResultsResults(ssid, bssid.toString())) {
                    Log.e(TAG, ""The specifiers chosen match a network in scan results.""
                            + ""Test will fail"");
                    return null;
                }
                configBuilder.setSsid(UNAVAILABLE_SSID);
                configBuilder.setBssid(bssid);
                if (!mPsk.isEmpty()) {
                    if (TestUtils.isScanResultForWpa2Network(scanResult)) {
                        configBuilder.setWpa2Passphrase(mPsk);
                    } else if (TestUtils.isScanResultForWpa3Network(scanResult)) {
                        configBuilder.setWpa3Passphrase(mPsk);
                    }
                }
                break;
            case NETWORK_SPECIFIER_INVALID_CREDENTIAL:
                configBuilder.setSsid(scanResult.SSID);
                configBuilder.setBssid(MacAddress.fromString(scanResult.BSSID));
                // Use a random password to simulate connection failure.
                if (TestUtils.isScanResultForWpa2Network(scanResult)) {
                    configBuilder.setWpa2Passphrase(mTestUtils.generateRandomPassphrase());
                } else if (TestUtils.isScanResultForWpa3Network(scanResult)) {
                    configBuilder.setWpa3Passphrase(mTestUtils.generateRandomPassphrase());
                }
                break;
            default:
                throw new IllegalStateException(""Unknown specifier type specifier"");
        }
        return configBuilder.build();
    }


    private void setFailureReason(String reason) {
        synchronized (mLock) {
            mFailureReason = reason;
        }
    }

    @Override
    protected boolean executeTest() throws InterruptedException {
        if (mNetworkSpecifierType == NETWORK_SPECIFIER_INVALID_CREDENTIAL && mPsk.isEmpty()) {
            setFailureReason(mContext.getString(R.string.wifi_status_need_psk));
            return false;
        }
        // Step: Scan and find the network around.
        if (DBG) Log.v(TAG, ""Scan and find the network: "" + mSsid);
        ScanResult testNetwork = mTestUtils.startScanAndFindAnyMatchingNetworkInResults(
                mSsid, mPsk.isEmpty() ? SCAN_RESULT_TYPE_OPEN : SCAN_RESULT_TYPE_PSK);
        if (testNetwork == null) {
            setFailureReason(mContext.getString(R.string.wifi_status_scan_failure));
            return false;
        }

        // Step: Create a specifier for the chosen open network depending on the type of test.
        NetworkSpecifier wns = createNetworkSpecifier(testNetwork);
        if (wns == null) return false;

        // Step: Create a network request with specifier.
        mNetworkRequest = new NetworkRequest.Builder()
                .addTransportType(TRANSPORT_WIFI)
                .setNetworkSpecifier(wns)
                .removeCapability(NET_CAPABILITY_INTERNET)
                .build();

        // Step: Send the network request
        if (DBG) Log.v(TAG, ""Request network using "" + mNetworkRequest);
        mNetworkCallback = new CallbackUtils.NetworkCallback(CALLBACK_TIMEOUT_MS);
        mListener.onTestMsgReceived(
                mContext.getString(R.string.wifi_status_initiating_network_request));
        mConnectivityManager.requestNetwork(mNetworkRequest, mNetworkCallback,
                NETWORK_REQUEST_TIMEOUT_MS);

        // Step: Wait for the network available/unavailable callback.
        if (mNetworkSpecifierType == NETWORK_SPECIFIER_UNAVAILABLE_SSID_BSSID
                || mNetworkSpecifierType == NETWORK_SPECIFIER_INVALID_CREDENTIAL) {
            if (mNetworkSpecifierType == NETWORK_SPECIFIER_UNAVAILABLE_SSID_BSSID) {
                mListener.onTestMsgReceived(
                        mContext.getString(R.string.wifi_status_network_wait_for_unavailable));
            } else {
                mListener.onTestMsgReceived(
                        mContext.getString(R.string
                                .wifi_status_network_wait_for_unavailable_invalid_credential));
            }
            if (DBG) Log.v(TAG, ""Waiting for network unavailable callback"");
            boolean cbStatusForUnavailable = mNetworkCallback.waitForUnavailable();
            if (!cbStatusForUnavailable) {
                Log.e(TAG, ""Failed to get network unavailable callback"");
                setFailureReason(mContext.getString(R.string.wifi_status_network_cb_timeout));
                return false;
            }
            mListener.onTestMsgReceived(
                    mContext.getString(R.string.wifi_status_network_unavailable));
            // All done!
            return true;
        }
        mListener.onTestMsgReceived(
                mContext.getString(R.string.wifi_status_network_wait_for_available));
        if (DBG) Log.v(TAG, ""Waiting for network available callback"");
        Pair<Boolean, Network> cbStatusForAvailable = mNetworkCallback.waitForAvailable();
        if (!cbStatusForAvailable.first) {
            Log.e(TAG, ""Failed to get network available callback"");
            setFailureReason(mContext.getString(R.string.wifi_status_network_cb_timeout));
            return false;
        }
        mListener.onTestMsgReceived(
                mContext.getString(R.string.wifi_status_network_available));

        mListener.onTestMsgReceived(
                mContext.getString(R.string.wifi_status_network_wait_for_lost));
        // Step 6: Ensure we don't disconnect from the network as long as the request is alive.
        if (DBG) Log.v(TAG, ""Ensuring network lost callback is not invoked"");
        boolean cbStatusForLost = mNetworkCallback.waitForLost();
        if (cbStatusForLost) {
            Log.e(TAG, ""Disconnected from the network even though the request is active"");
            setFailureReason(mContext.getString(R.string.wifi_status_network_lost));
            return false;
        }
        // All done!
        return true;
    }

    @Override
    protected String getFailureReason() {
        synchronized (mLock) {
            return mFailureReason;
        }
    }

    @Override
    protected void setUp() {
        super.setUp();
        mConnectivityManager = mContext.getSystemService(ConnectivityManager.class);
    }

    @Override
    protected void tearDown() {
        if (mNetworkCallback != null) {
            mConnectivityManager.unregisterNetworkCallback(mNetworkCallback);
        }
        super.tearDown();
    }
}"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.cts.statsdatom.wifi.WifiStatsTests"	"isNotNull"	"CtsStatsdAtomHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/wifi/WifiStatsTests.java"	""	"public void test/*
 *.
 */

package android.cts.statsdatom.wifi;

import static android.cts.statsdatom.statsd.AtomTestCase.FEATURE_PC;
import static android.cts.statsdatom.statsd.AtomTestCase.FEATURE_WIFI;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import android.cts.statsdatom.lib.AtomTestUtils;
import android.cts.statsdatom.lib.ConfigUtils;
import android.cts.statsdatom.lib.DeviceUtils;
import android.cts.statsdatom.lib.ReportUtils;
import android.net.wifi.WifiModeEnum;

import com.android.os.AtomsProto;
import com.android.os.StatsLog;
import com.android.tradefed.build.IBuildInfo;
import com.android.tradefed.testtype.DeviceTestCase;
import com.android.tradefed.testtype.IBuildReceiver;

import com.google.common.collect.Range;
import com.google.protobuf.AbstractMessage;

import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public class WifiStatsTests extends DeviceTestCase implements IBuildReceiver {
    private IBuildInfo mCtsBuild;

    private static final int WIFI_CONNECT_TIMEOUT_MILLIS = 30_000;

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        assertThat(mCtsBuild).isNotNull();
        ConfigUtils.removeConfig(getDevice());
        ReportUtils.clearReports(getDevice());
        DeviceUtils.installStatsdTestApp(getDevice(), mCtsBuild);
        Thread.sleep(AtomTestUtils.WAIT_TIME_LONG);
    }

    @Override
    protected void tearDown() throws Exception {
        ConfigUtils.removeConfig(getDevice());
        ReportUtils.clearReports(getDevice());
        DeviceUtils.uninstallStatsdTestApp(getDevice());
        super.tearDown();
    }

    @Override
    public void setBuild(IBuildInfo buildInfo) {
        mCtsBuild = buildInfo;
    }"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.cts.statsdatom.wifi.WifiStatsTests"	"testWifiLockHighPerf"	"CtsStatsdAtomHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/wifi/WifiStatsTests.java"	""	"public void testWifiLockHighPerf() throws Exception {
        if (!DeviceUtils.hasFeature(getDevice(), FEATURE_WIFI)) return;
        if (DeviceUtils.hasFeature(getDevice(), FEATURE_PC)) return;

        ConfigUtils.uploadConfigForPushedAtomWithUid(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                AtomsProto.Atom.WIFI_LOCK_STATE_CHANGED_FIELD_NUMBER, true);
        DeviceUtils.runDeviceTestsOnStatsdApp(getDevice(), "".AtomTests"", ""testWifiLockHighPerf"");

        // Sorted list of events in order in which they occurred.
        List<StatsLog.EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());

        Set<Integer> lockOn = new HashSet<>(
                Collections.singletonList(AtomsProto.WifiLockStateChanged.State.ON_VALUE));
        Set<Integer> lockOff = new HashSet<>(
                Collections.singletonList(AtomsProto.WifiLockStateChanged.State.OFF_VALUE));

        // Add state sets to the list in order.
        List<Set<Integer>> stateSet = Arrays.asList(lockOn, lockOff);

        // Assert that the events happened in the expected order.
        AtomTestUtils.assertStatesOccurred(stateSet, data, AtomTestUtils.WAIT_TIME_SHORT,
                atom -> atom.getWifiLockStateChanged().getState().getNumber());

        for (StatsLog.EventMetricData event : data) {
            assertThat(event.getAtom().getWifiLockStateChanged().getMode())
                    .isEqualTo(WifiModeEnum.WIFI_MODE_FULL_HIGH_PERF);
        }
    }"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.cts.statsdatom.wifi.WifiStatsTests"	"testWifiLockLowLatency"	"CtsStatsdAtomHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/wifi/WifiStatsTests.java"	""	"public void testWifiLockLowLatency() throws Exception {
        if (!DeviceUtils.hasFeature(getDevice(), FEATURE_WIFI)) return;
        if (DeviceUtils.hasFeature(getDevice(), FEATURE_PC)) return;

        ConfigUtils.uploadConfigForPushedAtomWithUid(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                AtomsProto.Atom.WIFI_LOCK_STATE_CHANGED_FIELD_NUMBER, true);
        DeviceUtils.runDeviceTestsOnStatsdApp(getDevice(), "".AtomTests"", ""testWifiLockLowLatency"");

        // Sorted list of events in order in which they occurred.
        List<StatsLog.EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());

        Set<Integer> lockOn = new HashSet<>(
                Collections.singletonList(AtomsProto.WifiLockStateChanged.State.ON_VALUE));
        Set<Integer> lockOff = new HashSet<>(
                Collections.singletonList(AtomsProto.WifiLockStateChanged.State.OFF_VALUE));

        // Add state sets to the list in order.
        List<Set<Integer>> stateSet = Arrays.asList(lockOn, lockOff);

        // Assert that the events happened in the expected order.
        AtomTestUtils.assertStatesOccurred(stateSet, data, AtomTestUtils.WAIT_TIME_SHORT,
                atom -> atom.getWifiLockStateChanged().getState().getNumber());

        for (StatsLog.EventMetricData event : data) {
            assertThat(event.getAtom().getWifiLockStateChanged().getMode())
                    .isEqualTo(WifiModeEnum.WIFI_MODE_FULL_LOW_LATENCY);
        }
    }"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.cts.statsdatom.wifi.WifiStatsTests"	"testWifiMulticastLock"	"CtsStatsdAtomHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/wifi/WifiStatsTests.java"	""	"public void testWifiMulticastLock() throws Exception {
        if (!DeviceUtils.hasFeature(getDevice(), FEATURE_WIFI)) return;
        if (DeviceUtils.hasFeature(getDevice(), FEATURE_PC)) return;

        ConfigUtils.uploadConfigForPushedAtomWithUid(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                AtomsProto.Atom.WIFI_MULTICAST_LOCK_STATE_CHANGED_FIELD_NUMBER, true);
        DeviceUtils.runDeviceTestsOnStatsdApp(getDevice(), "".AtomTests"", ""testWifiMulticastLock"");

        // Sorted list of events in order in which they occurred.
        List<StatsLog.EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());

        Set<Integer> lockOn = new HashSet<>(
                Collections.singletonList(AtomsProto.WifiMulticastLockStateChanged.State.ON_VALUE));
        Set<Integer> lockOff = new HashSet<>(
                Collections.singletonList(
                        AtomsProto.WifiMulticastLockStateChanged.State.OFF_VALUE));

        final String EXPECTED_TAG = ""StatsdCTSMulticastLock"";

        // Add state sets to the list in order.
        List<Set<Integer>> stateSet = Arrays.asList(lockOn, lockOff);

        // Assert that the events happened in the expected order.
        AtomTestUtils.assertStatesOccurred(stateSet, data, AtomTestUtils.WAIT_TIME_SHORT,
                atom -> atom.getWifiMulticastLockStateChanged().getState().getNumber());

        for (StatsLog.EventMetricData event : data) {
            String tag = event.getAtom().getWifiMulticastLockStateChanged().getTag();
            assertThat(tag).isEqualTo(EXPECTED_TAG);
        }
    }"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.cts.statsdatom.wifi.WifiStatsTests"	"testWifiReconnect"	"CtsStatsdAtomHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/wifi/WifiStatsTests.java"	""	"public void testWifiReconnect() throws Exception {
        if (!DeviceUtils.hasFeature(getDevice(), FEATURE_WIFI)) return;

        ConfigUtils.uploadConfigForPushedAtoms(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                new int[] {
                        AtomsProto.Atom.WIFI_CONNECTION_RESULT_REPORTED_FIELD_NUMBER,
                        AtomsProto.Atom.WIFI_DISCONNECT_REPORTED_FIELD_NUMBER
                });

        // This test on device checks if device is connected, and connects it if it is not;
        // Afterwards, it disconnects from that network and connects back to it.
        DeviceUtils.runDeviceTestsOnStatsdApp(getDevice(), "".AtomTests"", ""testWifiReconnect"");
        Thread.sleep(AtomTestUtils.WAIT_TIME_LONG);

        List<StatsLog.EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());

        // If device had Wifi connected, we'll see two atoms: disconnect, connect.
        // If it was not connected, we'll see three: connect, disconnect, connect.
        // We're only interested in the disconnect-connect pair.
        assertWithMessage(
                ""Expected disconnected and connected atoms, got: \n"" +
                        data.stream().map(AbstractMessage::toString).reduce((acc, i) -> acc + i)
        ).that(data.size()).isIn(Range.closed(2, 3));

        AtomsProto.WifiDisconnectReported a0 =
                data.get(data.size() - 2).getAtom().getWifiDisconnectReported();
        AtomsProto.WifiConnectionResultReported a1 =
                data.get(data.size() - 1).getAtom().getWifiConnectionResultReported();

        assertThat(a0).isNotNull();
        assertThat(a1).isNotNull();

        assertThat(a0.getConnectedDurationSeconds()).isGreaterThan(0);
        int maxLinkSpeedMbps = 1_000_000; /* 640K ought to be enough for anybody. */
        assertThat(a0.getLastLinkSpeed()).isIn(Range.open(0, maxLinkSpeedMbps));
        assertThat(a0.getLastRssi()).isIn(Range.closed(-127, 0));

        assertThat(a1.getConnectionResult()).isTrue();
        assertThat(a1.getRssi()).isIn(Range.closed(-127, 0));
        assertThat(a1.getConnectionAttemptDurationMillis()).isIn(
                Range.open(0, WIFI_CONNECT_TIMEOUT_MILLIS));
        assertThat(a1.getTrigger()).isEqualTo(
                AtomsProto.WifiConnectionResultReported.Trigger.RECONNECT_SAME_NETWORK);
        assertThat(a1.getNetworkUsed()).isTrue();
    }"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.cts.statsdatom.wifi.WifiStatsTests"	"testWifiScanLogsScanAtoms"	"CtsStatsdAtomHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/wifi/WifiStatsTests.java"	""	"public void testWifiScanLogsScanAtoms() throws Exception {
        if (!DeviceUtils.hasFeature(getDevice(), FEATURE_WIFI)) return;

        ConfigUtils.uploadConfigForPushedAtom(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                AtomsProto.Atom.WIFI_SCAN_REPORTED_FIELD_NUMBER);
        DeviceUtils.runDeviceTestsOnStatsdApp(getDevice(), "".AtomTests"", ""testWifiScan"");
        Thread.sleep(AtomTestUtils.WAIT_TIME_SHORT);

        List<StatsLog.EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());
        assertThat(data).hasSize(2);

        AtomsProto.WifiScanReported a0 = data.get(0).getAtom().getWifiScanReported();
        AtomsProto.WifiScanReported a1 = data.get(1).getAtom().getWifiScanReported();

        for (AtomsProto.WifiScanReported a : new AtomsProto.WifiScanReported[]{a0, a1}) {
            assertThat(a.getResult()).isEqualTo(AtomsProto.WifiScanReported.Result.RESULT_SUCCESS);
            assertThat(a.getType()).isEqualTo(AtomsProto.WifiScanReported.Type.TYPE_SINGLE);
            assertThat(a.getSource()).isAnyOf(
                    // If this test is run on a device that has a Settings app open that
                    // continuously performs frequent scans, quite often our scans requests
                    // are bundled together and get attributed to the Settings app.
                    AtomsProto.WifiScanReported.Source.SOURCE_SETTINGS_APP,
                    AtomsProto.WifiScanReported.Source.SOURCE_OTHER_APP);
            assertThat(a.getImportance()).isEqualTo(
                    AtomsProto.WifiScanReported.Importance.IMPORTANCE_FOREGROUND_SERVICE);

            assertThat(a.getScanDurationMillis()).isGreaterThan(0);
        }
    }"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.cts.statsdatom.wifi.WifiStatsTests"	"testWifiScanLogsStateChangedAtoms"	"CtsStatsdAtomHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/wifi/WifiStatsTests.java"	""	"public void testWifiScanLogsStateChangedAtoms() throws Exception {
        if (!DeviceUtils.hasFeature(getDevice(), FEATURE_WIFI)) return;


        ConfigUtils.uploadConfigForPushedAtomWithUid(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                AtomsProto.Atom.WIFI_SCAN_STATE_CHANGED_FIELD_NUMBER,  true);
        DeviceUtils.runDeviceTestsOnStatsdApp(getDevice(), "".AtomTests"", ""testWifiScan"");
        Thread.sleep(AtomTestUtils.WAIT_TIME_SHORT);

        final int stateOn = AtomsProto.WifiScanStateChanged.State.ON_VALUE;
        final int stateOff = AtomsProto.WifiScanStateChanged.State.OFF_VALUE;
        final int minTimeDiffMillis = 250;
        final int maxTimeDiffMillis = 60_000;

        List<StatsLog.EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());
        assertThat(data.size()).isIn(Range.closed(2, 4));
        AtomTestUtils.assertTimeDiffBetween(data.get(0), data.get(1), minTimeDiffMillis,
                maxTimeDiffMillis);
        AtomsProto.WifiScanStateChanged a0 = data.get(0).getAtom().getWifiScanStateChanged();
        AtomsProto.WifiScanStateChanged a1 = data.get(1).getAtom().getWifiScanStateChanged();
        assertThat(a0.getState().getNumber()).isEqualTo(stateOn);
        assertThat(a1.getState().getNumber()).isEqualTo(stateOff);
    }
}"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.nl80211.cts.WifiNl80211ManagerTest"	"testSendMgmtFrame"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/nl80211/cts/WifiNl80211ManagerTest.java"	""	"public void testSendMgmtFrame() {
        try {
            WifiNl80211Manager manager = mContext.getSystemService(WifiNl80211Manager.class);
            manager.sendMgmtFrame(""wlan0"", new byte[]{}, -1, Runnable::run,
                    new WifiNl80211Manager.SendMgmtFrameCallback() {
                        @Override
                        public void onAck(int elapsedTimeMs) {}

                        @Override
                        public void onFailure(int reason) {}
                    });
        } catch (Exception ignore) {}
    }"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.nl80211.cts.WifiNl80211ManagerTest"	"testGetTxPacketCounters"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/nl80211/cts/WifiNl80211ManagerTest.java"	""	"public void testGetTxPacketCounters() {
        try {
            WifiNl80211Manager manager = mContext.getSystemService(WifiNl80211Manager.class);
            manager.getTxPacketCounters(""wlan0"");
        } catch (Exception ignore) {}
    }"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.nl80211.cts.WifiNl80211ManagerTest"	"testSetOnServiceDeadCallback"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/nl80211/cts/WifiNl80211ManagerTest.java"	""	"public void testSetOnServiceDeadCallback() {
        try {
            WifiNl80211Manager manager = mContext.getSystemService(WifiNl80211Manager.class);
            manager.setOnServiceDeadCallback(() -> {});
        } catch (Exception ignore) {}
    }

    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.nl80211.cts.WifiNl80211ManagerTest"	"testCountryCodeChangeListener"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/nl80211/cts/WifiNl80211ManagerTest.java"	""	"public void testCountryCodeChangeListener() {
        TestCountryCodeChangeListener testCountryCodeChangeListener =
                new TestCountryCodeChangeListener();
        TestExecutor executor = new TestExecutor();
        WifiManager wifiManager = mContext.getSystemService(WifiManager.class);
        // Enable wifi to trigger country code change
        wifiManager.setWifiEnabled(true);
        WifiNl80211Manager manager = mContext.getSystemService(WifiNl80211Manager.class);
        // Register listener and unregister listener for API coverage only.
        // Since current cts don't have sufficient permission to call WifiNl80211Manager API.
        // Assert register fail because the CTS don't have sufficient permission to call
        // WifiNl80211Manager API which are guarded by selinux.
        assertFalse(manager.registerCountryCodeChangedListener(executor,
                testCountryCodeChangeListener));
        manager.unregisterCountryCodeChangedListener(testCountryCodeChangeListener);
    }
}"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.wifiaware.testcase.DiscoveryBaseTestCase"	"IdentityListenerSingleShot"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/wifiaware/testcase/DiscoveryBaseTestCase.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.wifiaware.testcase;

import android.content.Context;
import android.net.MacAddress;
import android.net.wifi.aware.DiscoverySession;
import android.net.wifi.aware.PeerHandle;
import android.net.wifi.aware.PublishConfig;
import android.net.wifi.aware.SubscribeConfig;
import android.net.wifi.aware.WifiAwareSession;
import android.util.Log;
import android.util.Pair;

import com.android.cts.verifier.R;
import com.android.cts.verifier.wifiaware.BaseTestCase;
import com.android.cts.verifier.wifiaware.CallbackUtils;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * Base test case providing utilities for Discovery:
 *
 * Subscribe test sequence:
 * 1. Attach
 *    wait for results (session)
 * 2. Subscribe
 *    wait for results (subscribe session)
 * 3. Wait for discovery (possibly with ranging)
 * 4. Send message
 *    Wait for success
 *
 * Publish test sequence:
 * 1. Attach
 *    wait for results (session)
 * 2. Publish
 *    wait for results (publish session)
 * 3. Wait for rx message
 */
public abstract class DiscoveryBaseTestCase extends BaseTestCase {
    private static final String TAG = ""DiscoveryBaseTestCase"";
    private static final boolean DBG = true;

    private static final String SERVICE_NAME = ""CtsVerifierTestService"";
    private static final byte[] MATCH_FILTER_BYTES = ""bytes used for matching"".getBytes();
    private static final byte[] PUB_SSI = ""Extra bytes in the publisher discovery"".getBytes();
    private static final byte[] SUB_SSI = ""Arbitrary bytes for the subscribe discovery"".getBytes();
    private static final byte[] MSG_SUB_TO_PUB = ""Let's talk"".getBytes();
    protected static final int MESSAGE_ID = 1234;
    protected static final int LARGE_ENOUGH_DISTANCE = 100000; // 100 meters

    protected boolean mIsUnsolicited;
    protected boolean mIsRangingRequired;

    protected final Object mLock = new Object();

    private String mFailureReason;
    protected WifiAwareSession mWifiAwareSession;
    protected DiscoverySession mWifiAwareDiscoverySession;
    protected CallbackUtils.DiscoveryCb mDiscoveryCb;
    protected PeerHandle mPeerHandle;
    protected MacAddress mMyMacAddress;
    protected MacAddress mPeerMacAddress;

    public DiscoveryBaseTestCase(Context context, boolean isUnsolicited,
            boolean isRangingRequired) {
        super(context);

        mIsUnsolicited = isUnsolicited;
        mIsRangingRequired = isRangingRequired;
    }

    private boolean executeAttach() throws InterruptedException {
        // attach (optionally with an identity listener)
        CallbackUtils.AttachCb attachCb = new CallbackUtils.AttachCb();
        CallbackUtils.IdentityListenerSingleShot identityL = new CallbackUtils
                .IdentityListenerSingleShot();
        if (mIsRangingRequired) {
            mWifiAwareManager.attach(attachCb, identityL, mHandler);
        } else {
            mWifiAwareManager.attach(attachCb, mHandler);
        }
        Pair<Integer, WifiAwareSession> results = attachCb.waitForAttach();
        switch (results.first) {
            case CallbackUtils.AttachCb.TIMEOUT:
                setFailureReason(mContext.getString(R.string.aware_status_attach_timeout));
                Log.e(TAG, ""executeTest: attach TIMEOUT"");
                return false;
            case CallbackUtils.AttachCb.ON_ATTACH_FAILED:
                setFailureReason(mContext.getString(R.string.aware_status_attach_fail));
                Log.e(TAG, ""executeTest: attach ON_ATTACH_FAILED"");
                return false;
        }
        mWifiAwareSession = results.second;
        if (mWifiAwareSession == null) {
            setFailureReason(mContext.getString(R.string.aware_status_attach_fail));
            Log.e(TAG, ""executeTest: attach callback succeeded but null session returned!?"");
            return false;
        }
        mListener.onTestMsgReceived(mContext.getString(R.string.aware_status_attached));
        if (DBG) {
            Log.d(TAG, ""executeTest: attach succeeded"");
        }

        // 1.5 optionally wait for identity (necessary in ranging cases)
        if (mIsRangingRequired) {
            byte[] mac = identityL.waitForMac();
            if (mac == null) {
                setFailureReason(mContext.getString(R.string.aware_status_identity_fail));
                Log.e(TAG, ""executeAttach: identity callback not triggered"");
                return false;
            }
            mMyMacAddress = MacAddress.fromBytes(mac);
            mListener.onTestMsgReceived(mResources.getString(R.string.aware_status_identity,
                    mMyMacAddress));
            if (DBG) {
                Log.d(TAG, ""executeAttach: identity received: "" + mMyMacAddress.toString());
            }
        }

        return true;
    }

    protected boolean executeSubscribe() throws InterruptedException {
        // 1. attach
        if (!executeAttach()) {
            return false;
        }

        mDiscoveryCb = new CallbackUtils.DiscoveryCb();

        // 2. subscribe
        List<byte[]> matchFilter = new ArrayList<>();
        matchFilter.add(MATCH_FILTER_BYTES);
        SubscribeConfig.Builder builder = new SubscribeConfig.Builder().setServiceName(
                SERVICE_NAME).setServiceSpecificInfo(SUB_SSI).setMatchFilter(
                matchFilter).setSubscribeType(
                mIsUnsolicited ? SubscribeConfig.SUBSCRIBE_TYPE_PASSIVE
                        : SubscribeConfig.SUBSCRIBE_TYPE_ACTIVE).setTerminateNotificationEnabled(
                true);
        if (mIsRangingRequired) {
            // set up a distance that will always trigger - i.e. that we're already in that range
            builder.setMaxDistanceMm(LARGE_ENOUGH_DISTANCE);
        }
        SubscribeConfig subscribeConfig = builder.build();
        if (DBG) Log.d(TAG, ""executeTestSubscriber: subscribeConfig="" + subscribeConfig);
        mWifiAwareSession.subscribe(subscribeConfig, mDiscoveryCb, mHandler);

        //    wait for results - subscribe session
        CallbackUtils.DiscoveryCb.CallbackData callbackData = mDiscoveryCb.waitForCallbacks(
                CallbackUtils.DiscoveryCb.ON_SUBSCRIBE_STARTED
                        | CallbackUtils.DiscoveryCb.ON_SESSION_CONFIG_FAILED);
        switch (callbackData.callback) {
            case CallbackUtils.DiscoveryCb.TIMEOUT:
                setFailureReason(mContext.getString(R.string.aware_status_subscribe_timeout));
                Log.e(TAG, ""executeTestSubscriber: subscribe TIMEOUT"");
                return false;
            case CallbackUtils.DiscoveryCb.ON_SESSION_CONFIG_FAILED:
                setFailureReason(mContext.getString(R.string.aware_status_subscribe_failed));
                Log.e(TAG, ""executeTestSubscriber: subscribe ON_SESSION_CONFIG_FAILED"");
                return false;
        }
        mWifiAwareDiscoverySession = callbackData.subscribeDiscoverySession;
        if (mWifiAwareDiscoverySession == null) {
            setFailureReason(mContext.getString(R.string.aware_status_subscribe_null_session));
            Log.e(TAG, ""executeTestSubscriber: subscribe succeeded but null session returned"");
            return false;
        }
        mListener.onTestMsgReceived(mContext.getString(R.string.aware_status_subscribe_started));
        if (DBG) Log.d(TAG, ""executeTestSubscriber: subscribe succeeded"");

        // 3. wait for discovery
        callbackData = mDiscoveryCb.waitForCallbacks(
                mIsRangingRequired ? CallbackUtils.DiscoveryCb.ON_SERVICE_DISCOVERED_WITH_RANGE
                        : CallbackUtils.DiscoveryCb.ON_SERVICE_DISCOVERED);
        switch (callbackData.callback) {
            case CallbackUtils.DiscoveryCb.TIMEOUT:
                setFailureReason(mContext.getString(R.string.aware_status_discovery_timeout));
                Log.e(TAG, ""executeTestSubscriber: waiting for discovery TIMEOUT"");
                return false;
        }
        mPeerHandle = callbackData.peerHandle;
        if (!mIsRangingRequired) {
            mListener.onTestMsgReceived(mContext.getString(R.string.aware_status_discovery));
            if (DBG) Log.d(TAG, ""executeTestSubscriber: discovery"");
        } else {
            if (DBG) {
                Log.d(TAG, ""executeTestSubscriber: discovery with range=""
                        + callbackData.distanceMm);
            }
        }

        //    validate discovery parameters match
        if (mIsRangingRequired) {
            try {
                mPeerMacAddress = MacAddress.fromBytes(callbackData.serviceSpecificInfo);
            } catch (IllegalArgumentException e) {
                setFailureReason(mContext.getString(R.string.aware_status_discovery_fail));
                Log.e(TAG, ""executeTestSubscriber: invalid MAC received in SSI: rx='"" + new String(
                        callbackData.serviceSpecificInfo) + ""'"");
                return false;
            }
            mListener.onTestMsgReceived(
                    mResources.getString(R.string.aware_status_discovery_with_info,
                            mPeerMacAddress));
        } else {
            if (!Arrays.equals(PUB_SSI, callbackData.serviceSpecificInfo)) {
                setFailureReason(mContext.getString(R.string.aware_status_discovery_fail));
                Log.e(TAG, ""executeTestSubscriber: discovery but SSI mismatch: rx='"" + new String(
                        callbackData.serviceSpecificInfo) + ""'"");
                return false;
            }
        }
        if (callbackData.matchFilter.size() != 1 || !Arrays.equals(MATCH_FILTER_BYTES,
                callbackData.matchFilter.get(0))) {
            setFailureReason(mContext.getString(R.string.aware_status_discovery_fail));
            StringBuffer sb = new StringBuffer();
            sb.append(""size="").append(callbackData.matchFilter.size());
            for (byte[] mf: callbackData.matchFilter) {
                sb.append("", e='"").append(new String(mf)).append(""'"");
            }
            Log.e(TAG, ""executeTestSubscriber: discovery but matchFilter mismatch: ""
                    + sb.toString());
            return false;
        }
        if (mPeerHandle == null) {
            setFailureReason(mContext.getString(R.string.aware_status_discovery_fail));
            Log.e(TAG, ""executeTestSubscriber: discovery but null peerHandle"");
            return false;
        }

        // 4. send message & wait for send status
        mWifiAwareDiscoverySession.sendMessage(mPeerHandle, MESSAGE_ID,
                mIsRangingRequired ? mMyMacAddress.toByteArray() : MSG_SUB_TO_PUB);
        callbackData = mDiscoveryCb.waitForCallbacks(
                CallbackUtils.DiscoveryCb.ON_MESSAGE_SEND_SUCCEEDED
                        | CallbackUtils.DiscoveryCb.ON_MESSAGE_SEND_FAILED);
        switch (callbackData.callback) {
            case CallbackUtils.DiscoveryCb.TIMEOUT:
                setFailureReason(mContext.getString(R.string.aware_status_send_timeout));
                Log.e(TAG, ""executeTestSubscriber: send message TIMEOUT"");
                return false;
            case CallbackUtils.DiscoveryCb.ON_MESSAGE_SEND_FAILED:
                setFailureReason(mContext.getString(R.string.aware_status_send_failed));
                Log.e(TAG, ""executeTestSubscriber: send message ON_MESSAGE_SEND_FAILED"");
                return false;
        }
        mListener.onTestMsgReceived(mContext.getString(R.string.aware_status_send_success));
        if (DBG) Log.d(TAG, ""executeTestSubscriber: send message succeeded"");

        if (callbackData.messageId != MESSAGE_ID) {
            setFailureReason(mContext.getString(R.string.aware_status_send_fail_parameter));
            Log.e(TAG, ""executeTestSubscriber: send message message ID mismatch: ""
                    + callbackData.messageId);
            return false;
        }

        return true;
    }

    protected boolean executePublish() throws InterruptedException {
        // 1. attach
        if (!executeAttach()) {
            return false;
        }

        mDiscoveryCb = new CallbackUtils.DiscoveryCb();

        // 2. publish
        List<byte[]> matchFilter = new ArrayList<>();
        matchFilter.add(MATCH_FILTER_BYTES);
        PublishConfig publishConfig = new PublishConfig.Builder().setServiceName(
                SERVICE_NAME).setServiceSpecificInfo(
                mIsRangingRequired ? mMyMacAddress.toByteArray() : PUB_SSI).setMatchFilter(
                matchFilter).setPublishType(mIsUnsolicited ? PublishConfig.PUBLISH_TYPE_UNSOLICITED
                : PublishConfig.PUBLISH_TYPE_SOLICITED).setTerminateNotificationEnabled(
                true).setRangingEnabled(mIsRangingRequired).build();
        if (DBG) Log.d(TAG, ""executeTestPublisher: publishConfig="" + publishConfig);
        mWifiAwareSession.publish(publishConfig, mDiscoveryCb, mHandler);

        //    wait for results - publish session
        CallbackUtils.DiscoveryCb.CallbackData callbackData = mDiscoveryCb.waitForCallbacks(
                CallbackUtils.DiscoveryCb.ON_PUBLISH_STARTED
                        | CallbackUtils.DiscoveryCb.ON_SESSION_CONFIG_FAILED);
        switch (callbackData.callback) {
            case CallbackUtils.DiscoveryCb.TIMEOUT:
                setFailureReason(mContext.getString(R.string.aware_status_publish_timeout));
                Log.e(TAG, ""executeTestPublisher: publish TIMEOUT"");
                return false;
            case CallbackUtils.DiscoveryCb.ON_SESSION_CONFIG_FAILED:
                setFailureReason(mContext.getString(R.string.aware_status_publish_failed));
                Log.e(TAG, ""executeTestPublisher: publish ON_SESSION_CONFIG_FAILED"");
                return false;
        }
        mWifiAwareDiscoverySession = callbackData.publishDiscoverySession;
        if (mWifiAwareDiscoverySession == null) {
            setFailureReason(mContext.getString(R.string.aware_status_publish_null_session));
            Log.e(TAG, ""executeTestPublisher: publish succeeded but null session returned"");
            return false;
        }
        mListener.onTestMsgReceived(mContext.getString(R.string.aware_status_publish_started));
        if (DBG) Log.d(TAG, ""executeTestPublisher: publish succeeded"");

        // 3. wait to receive message: no timeout since this depends on (human) operator starting
        //    the test on the subscriber device.
        callbackData = mDiscoveryCb.waitForCallbacksNoTimeout(
                CallbackUtils.DiscoveryCb.ON_MESSAGE_RECEIVED);
        mPeerHandle = callbackData.peerHandle;
        mListener.onTestMsgReceived(mContext.getString(R.string.aware_status_received));
        if (DBG) Log.d(TAG, ""executeTestPublisher: received message"");

        //    validate that received the expected message
        if (mIsRangingRequired) {
            try {
                mPeerMacAddress = MacAddress.fromBytes(callbackData.serviceSpecificInfo);
            } catch (IllegalArgumentException e) {
                setFailureReason(mContext.getString(R.string.aware_status_discovery_fail));
                Log.e(TAG, ""executeTestSubscriber: invalid MAC received in SSI: rx='"" + new String(
                        callbackData.serviceSpecificInfo) + ""'"");
                return false;
            }
            mListener.onTestMsgReceived(mResources.getString(R.string.aware_status_received_mac,
                    mPeerMacAddress));
        } else {
            if (!Arrays.equals(MSG_SUB_TO_PUB, callbackData.serviceSpecificInfo)) {
                setFailureReason(mContext.getString(R.string.aware_status_receive_failure));
                Log.e(TAG, ""executeTestPublisher: receive message message content mismatch: rx='""
                        + new String(callbackData.serviceSpecificInfo) + ""'"");
                return false;
            }
        }
        if (mPeerHandle == null) {
            setFailureReason(mContext.getString(R.string.aware_status_receive_failure));
            Log.e(TAG, ""executeTestPublisher: received message but peerHandle is null!?"");
            return false;
        }

        return true;
    }

    protected void setFailureReason(String reason) {
        synchronized (mLock) {
            mFailureReason = reason;
        }
    }

    @Override
    protected String getFailureReason() {
        synchronized (mLock) {
            return mFailureReason;
        }
    }

    @Override
    protected void tearDown() {
        if (mWifiAwareDiscoverySession != null) {
            mWifiAwareDiscoverySession.close();
            mWifiAwareDiscoverySession = null;
        }
        if (mWifiAwareSession != null) {
            mWifiAwareSession.close();
            mWifiAwareSession = null;
        }
        super.tearDown();
    }
}"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.nl80211.cts.NativeWifiClientTest"	"testGetters"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/nl80211/cts/NativeWifiClientTest.java"	""	"public void testGetters() {
        NativeWifiClient client = new NativeWifiClient(MacAddress.fromBytes(TEST_MAC));

        assertThat(client.getMacAddress().toByteArray()).isEqualTo(TEST_MAC);
    }"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.nl80211.cts.NativeWifiClientTest"	"testEquals"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/nl80211/cts/NativeWifiClientTest.java"	""	"public void testEquals() {
        NativeWifiClient client = new NativeWifiClient(MacAddress.fromBytes(TEST_MAC));
        NativeWifiClient client2 =
                new NativeWifiClient(MacAddress.fromBytes(new byte[] { 7, 8, 9, 10, 11, 12 }));

        assertThat(client2).isNotEqualTo(client);
    }
}"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.PpsMoParserTest"	"getRoamingConsortiumOis"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/PpsMoParserTest.java"	""	"public void test/*
 *.
 */

package android.net.wifi.cts;

import android.net.wifi.hotspot2.PasspointConfiguration;
import android.net.wifi.hotspot2.omadm.PpsMoParser;
import android.net.wifi.hotspot2.pps.Credential;
import android.net.wifi.hotspot2.pps.HomeSp;
import android.test.AndroidTestCase;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * CTS tests for PPS MO (PerProviderSubscription Management Object) XML string parsing API.
 */
public class PpsMoParserTest extends WifiJUnit3TestBase {
    private static final String PPS_MO_XML_FILE = ""assets/PerProviderSubscription.xml"";

    /**
     * Read the content of the given resource file into a String.
     *
     * @param filename String name of the file
     * @return String
     * @throws IOException
     */
    private String loadResourceFile(String filename) throws IOException {
        InputStream in = getClass().getClassLoader().getResourceAsStream(filename);
        BufferedReader reader = new BufferedReader(new InputStreamReader(in));
        StringBuilder builder = new StringBuilder();
        String line;
        while ((line = reader.readLine()) != null) {
            builder.append(line).append(""\n"");
        }
        return builder.toString();
    }

    /**
     * Generate a {@link PasspointConfiguration} that matches the configuration specified in the
     * XML file {@link #PPS_MO_XML_FILE}.
     *
     * @return {@link PasspointConfiguration}
     */
    private PasspointConfiguration generateConfigurationFromPPSMOTree() throws Exception {
        DateFormat format = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ss'Z'"");
        byte[] certFingerprint = new byte[32];
        Arrays.fill(certFingerprint, (byte) 0x1f);

        PasspointConfiguration config = new PasspointConfiguration();

        // HomeSP configuration.
        HomeSp homeSp = new HomeSp();
        homeSp.setFriendlyName(""Century House"");
        assertEquals(""Century House"", homeSp.getFriendlyName());
        homeSp.setFqdn(""mi6.co.uk"");
        assertEquals(""mi6.co.uk"", homeSp.getFqdn());
        homeSp.setRoamingConsortiumOis(new long[] {0x112233L, 0x445566L});
        assertTrue(Arrays.equals(new long[] {0x112233L, 0x445566L},
                homeSp.getRoamingConsortiumOis()));
        config.setHomeSp(homeSp);
        assertEquals(homeSp, config.getHomeSp());

        // Credential configuration.
        Credential credential = new Credential();
        credential.setRealm(""shaken.stirred.com"");
        assertEquals(""shaken.stirred.com"", credential.getRealm());
        Credential.UserCredential userCredential = new Credential.UserCredential();
        userCredential.setUsername(""james"");
        assertEquals(""james"", userCredential.getUsername());
        userCredential.setPassword(""Ym9uZDAwNw=="");
        assertEquals(""Ym9uZDAwNw=="", userCredential.getPassword());
        userCredential.setEapType(21);
        assertEquals(21, userCredential.getEapType());
        userCredential.setNonEapInnerMethod(""MS-CHAP-V2"");
        assertEquals(""MS-CHAP-V2"", userCredential.getNonEapInnerMethod());
        credential.setUserCredential(userCredential);
        assertEquals(userCredential, credential.getUserCredential());
        Credential.CertificateCredential certCredential = new Credential.CertificateCredential();
        certCredential.setCertType(""x509v3"");
        assertEquals(""x509v3"", certCredential.getCertType());
        certCredential.setCertSha256Fingerprint(certFingerprint);
        assertTrue(Arrays.equals(certFingerprint, certCredential.getCertSha256Fingerprint()));
        credential.setCertCredential(certCredential);
        assertEquals(certCredential, credential.getCertCredential());
        Credential.SimCredential simCredential = new Credential.SimCredential();
        simCredential.setImsi(""imsi"");
        assertEquals(""imsi"", simCredential.getImsi());
        simCredential.setEapType(24);
        assertEquals(24, simCredential.getEapType());
        credential.setSimCredential(simCredential);
        assertEquals(simCredential, credential.getSimCredential());
        config.setCredential(credential);
        assertEquals(credential, config.getCredential());
        return config;
    }

    /**
     * Parse and verify all supported fields under PPS MO tree.
     *
     * @throws Exception
     */"	""	""	"passpoint wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.PpsMoParserTest"	"testParsePPSMOTree"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/PpsMoParserTest.java"	""	"public void testParsePPSMOTree() throws Exception {
        String ppsMoTree = loadResourceFile(PPS_MO_XML_FILE);
        PasspointConfiguration expectedConfig = generateConfigurationFromPPSMOTree();
        PasspointConfiguration actualConfig = PpsMoParser.parseMoText(ppsMoTree);
        assertTrue(actualConfig.equals(expectedConfig));
    }
}"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.ConnectedNetworkScorerTest"	"isNotNull"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ConnectedNetworkScorerTest.java"	""	"/*
 *.
 */

package android.net.wifi.cts;

import static android.Manifest.permission.CONNECTIVITY_INTERNAL;
import static android.Manifest.permission.NETWORK_SETTINGS;
import static android.Manifest.permission.READ_WIFI_CREDENTIAL;
import static android.Manifest.permission.WIFI_UPDATE_USABILITY_STATS_SCORE;
import static android.net.NetworkCapabilities.NET_CAPABILITY_OEM_PAID;
import static android.net.NetworkCapabilities.NET_CAPABILITY_OEM_PRIVATE;
import static android.net.wifi.WifiUsabilityStatsEntry.ContentionTimeStats;
import static android.net.wifi.WifiUsabilityStatsEntry.RadioStats;
import static android.net.wifi.WifiUsabilityStatsEntry.RateStats;
import static android.net.wifi.WifiUsabilityStatsEntry.PROBE_STATUS_FAILURE;
import static android.net.wifi.WifiUsabilityStatsEntry.PROBE_STATUS_NO_PROBE;
import static android.net.wifi.WifiUsabilityStatsEntry.PROBE_STATUS_SUCCESS;
import static android.net.wifi.WifiUsabilityStatsEntry.PROBE_STATUS_UNKNOWN;
import static android.net.wifi.WifiUsabilityStatsEntry.WME_ACCESS_CATEGORY_BE;
import static android.net.wifi.WifiUsabilityStatsEntry.WME_ACCESS_CATEGORY_BK;
import static android.net.wifi.WifiUsabilityStatsEntry.WME_ACCESS_CATEGORY_VI;
import static android.net.wifi.WifiUsabilityStatsEntry.WME_ACCESS_CATEGORY_VO;
import static android.os.Process.myUid;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.junit.Assume.assumeTrue;

import android.annotation.NonNull;
import android.app.UiAutomation;
import android.content.Context;
import android.net.ConnectivityManager;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiManager;
import android.net.wifi.WifiNetworkSpecifier;
import android.net.wifi.WifiNetworkSuggestion;
import android.net.wifi.WifiUsabilityStatsEntry;
import android.net.wifi.WifiConnectedSessionInfo;
import android.os.Build;
import android.platform.test.annotations.AppModeFull;
import android.support.test.uiautomator.UiDevice;
import android.telephony.TelephonyManager;

import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.filters.LargeTest;
import androidx.test.filters.SdkSuppress;
import androidx.test.platform.app.InstrumentationRegistry;

import com.android.compatibility.common.util.ApiLevelUtil;
import com.android.compatibility.common.util.PollingCheck;
import com.android.compatibility.common.util.PropertyUtil;
import com.android.compatibility.common.util.ShellIdentityUtils;

import com.google.common.collect.Range;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.List;
import java.util.NoSuchElementException;
import java.util.Set;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

/**
 * Tests for wifi connected network scorer interface and usability stats.
 */
@AppModeFull(reason = ""Cannot get WifiManager in instant app mode"")
@LargeTest
@RunWith(AndroidJUnit4.class)
public class ConnectedNetworkScorerTest extends WifiJUnit4TestBase {
    private Context mContext;
    private WifiManager mWifiManager;
    private ConnectivityManager mConnectivityManager;
    private UiDevice mUiDevice;
    private TestHelper mTestHelper;
    private TelephonyManager mTelephonyManager;

    private boolean mWasVerboseLoggingEnabled;

    private static final int WIFI_CONNECT_TIMEOUT_MILLIS = 30_000;
    private static final int TIMEOUT = 12_000;
    private static final int WAIT_DURATION = 5_000;

    @Before
    public void setUp() throws Exception {
        mContext = InstrumentationRegistry.getInstrumentation().getContext();

        // skip the test if WiFi is not supported
        assumeTrue(WifiFeature.isWifiSupported(mContext));

        mWifiManager = mContext.getSystemService(WifiManager.class);
        assertThat(mWifiManager).isNotNull();

        mConnectivityManager = mContext.getSystemService(ConnectivityManager.class);

        // turn on verbose logging for tests
        mWasVerboseLoggingEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.isVerboseLoggingEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setVerboseLoggingEnabled(true));

        // enable Wifi
        if (!mWifiManager.isWifiEnabled()) {
            ShellIdentityUtils.invokeWithShellPermissions(() -> mWifiManager.setWifiEnabled(true));
        }
        PollingCheck.check(""Wifi not enabled"", TIMEOUT, () -> mWifiManager.isWifiEnabled());

        // turn screen on
        mUiDevice = UiDevice.getInstance(InstrumentationRegistry.getInstrumentation());

        mTestHelper = new TestHelper(mContext, mUiDevice);
        mTestHelper.turnScreenOn();

        // Clear any existing app state before each test.
        if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(mContext)) {
            ShellIdentityUtils.invokeWithShellPermissions(
                    () -> mWifiManager.removeAppState(myUid(), mContext.getPackageName()));
        }

        // check we have >= 1 saved network
        List<WifiConfiguration> savedNetworks = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.getConfiguredNetworks());
        assertWithMessage(""Need at least one saved network"").that(savedNetworks).isNotEmpty();

        // ensure Wifi is connected
        ShellIdentityUtils.invokeWithShellPermissions(() -> mWifiManager.reconnect());
        PollingCheck.check(
                ""Wifi not connected"",
                WIFI_CONNECT_TIMEOUT_MILLIS,
                () -> mWifiManager.getConnectionInfo().getNetworkId() != -1);
        mTelephonyManager = mContext.getSystemService(TelephonyManager.class);
    }

    @After
    public void tearDown() throws Exception {
        if (!WifiFeature.isWifiSupported(mContext)) return;
        if (!mWifiManager.isWifiEnabled()) {
            ShellIdentityUtils.invokeWithShellPermissions(() -> mWifiManager.setWifiEnabled(true));
        }
        mTestHelper.turnScreenOff();
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setVerboseLoggingEnabled(mWasVerboseLoggingEnabled));
    }

    private static class TestUsabilityStatsListener implements
            WifiManager.OnWifiUsabilityStatsListener {
        private final CountDownLatch mCountDownLatch;
        public int seqNum;
        public boolean isSameBssidAndFre;
        public WifiUsabilityStatsEntry statsEntry;

        TestUsabilityStatsListener(CountDownLatch countDownLatch) {
            mCountDownLatch = countDownLatch;
        }

        @Override
        public void onWifiUsabilityStats(int seqNum, boolean isSameBssidAndFreq,
                WifiUsabilityStatsEntry statsEntry) {
            this.seqNum = seqNum;
            this.isSameBssidAndFre = isSameBssidAndFreq;
            this.statsEntry = statsEntry;
            mCountDownLatch.countDown();
        }
    }

    /**
     * Tests the {@link android.net.wifi.WifiUsabilityStatsEntry} retrieved from
     * {@link WifiManager.OnWifiUsabilityStatsListener}.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.ConnectedNetworkScorerTest"	"testWifiUsabilityStatsEntry"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ConnectedNetworkScorerTest.java"	""	"public void testWifiUsabilityStatsEntry() throws Exception {
        // Usability stats collection only supported by vendor version Q and above.
        if (!PropertyUtil.isVendorApiLevelAtLeast(Build.VERSION_CODES.Q)) {
            return;
        }
        CountDownLatch countDownLatch = new CountDownLatch(1);
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        TestUsabilityStatsListener usabilityStatsListener =
                new TestUsabilityStatsListener(countDownLatch);
        try {
            uiAutomation.adoptShellPermissionIdentity();
            mWifiManager.addOnWifiUsabilityStatsListener(
                    Executors.newSingleThreadExecutor(), usabilityStatsListener);
            // Wait for new usability stats (while connected & screen on this is triggered
            // by platform periodically).
            assertThat(countDownLatch.await(TIMEOUT, TimeUnit.MILLISECONDS)).isTrue();

            assertThat(usabilityStatsListener.statsEntry).isNotNull();
            WifiUsabilityStatsEntry statsEntry = usabilityStatsListener.statsEntry;

            assertThat(statsEntry.getTimeStampMillis()).isGreaterThan(0L);
            assertThat(statsEntry.getRssi()).isLessThan(0);
            assertThat(statsEntry.getLinkSpeedMbps()).isAtLeast(0);
            assertThat(statsEntry.getTotalTxSuccess()).isAtLeast(0L);
            assertThat(statsEntry.getTotalTxRetries()).isAtLeast(0L);
            assertThat(statsEntry.getTotalTxBad()).isAtLeast(0L);
            assertThat(statsEntry.getTotalRxSuccess()).isAtLeast(0L);
            if (mWifiManager.isEnhancedPowerReportingSupported()) {
                assertThat(statsEntry.getTotalRadioOnTimeMillis()).isAtLeast(0L);
                assertThat(statsEntry.getTotalRadioTxTimeMillis()).isAtLeast(0L);
                assertThat(statsEntry.getTotalRadioRxTimeMillis()).isAtLeast(0L);
                assertThat(statsEntry.getTotalScanTimeMillis()).isAtLeast(0L);
                assertThat(statsEntry.getTotalNanScanTimeMillis()).isAtLeast(0L);
                assertThat(statsEntry.getTotalBackgroundScanTimeMillis()).isAtLeast(0L);
                assertThat(statsEntry.getTotalRoamScanTimeMillis()).isAtLeast(0L);
                assertThat(statsEntry.getTotalPnoScanTimeMillis()).isAtLeast(0L);
                assertThat(statsEntry.getTotalHotspot2ScanTimeMillis()).isAtLeast(0L);
                assertThat(statsEntry.getTotalCcaBusyFreqTimeMillis()).isAtLeast(0L);
                assertThat(statsEntry.getTotalRadioOnTimeMillis()).isAtLeast(0L);
                assertThat(statsEntry.getTotalRadioOnFreqTimeMillis()).isAtLeast(0L);
                assertThat(statsEntry.getTotalBeaconRx()).isAtLeast(0L);
                assertThat(statsEntry.getProbeStatusSinceLastUpdate())
                        .isAnyOf(PROBE_STATUS_SUCCESS,
                                PROBE_STATUS_FAILURE,
                                PROBE_STATUS_NO_PROBE,
                                PROBE_STATUS_UNKNOWN);
                // -1 is default value for some of these fields if they're not available.
                assertThat(statsEntry.getProbeElapsedTimeSinceLastUpdateMillis()).isAtLeast(-1);
                assertThat(statsEntry.getProbeMcsRateSinceLastUpdate()).isAtLeast(-1);
                assertThat(statsEntry.getRxLinkSpeedMbps()).isAtLeast(-1);
                if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
                    try {
                        assertThat(statsEntry.getTimeSliceDutyCycleInPercent())
                                .isIn(Range.closed(0, 100));
                    } catch (NoSuchElementException e) {
                        // pass - Device does not support the field.
                    }
                    assertThat(statsEntry.getContentionTimeStats(
                            WME_ACCESS_CATEGORY_BE).getContentionTimeMinMicros()).isAtLeast(0);
                    assertThat(statsEntry.getContentionTimeStats(
                            WME_ACCESS_CATEGORY_BE).getContentionTimeMaxMicros()).isAtLeast(0);
                    assertThat(statsEntry.getContentionTimeStats(
                            WME_ACCESS_CATEGORY_BE).getContentionTimeAvgMicros()).isAtLeast(0);
                    assertThat(statsEntry.getContentionTimeStats(
                            WME_ACCESS_CATEGORY_BE).getContentionNumSamples()).isAtLeast(0);
                    assertThat(statsEntry.getContentionTimeStats(
                            WME_ACCESS_CATEGORY_BK).getContentionTimeMinMicros()).isAtLeast(0);
                    assertThat(statsEntry.getContentionTimeStats(
                            WME_ACCESS_CATEGORY_BK).getContentionTimeMaxMicros()).isAtLeast(0);
                    assertThat(statsEntry.getContentionTimeStats(
                            WME_ACCESS_CATEGORY_BK).getContentionTimeAvgMicros()).isAtLeast(0);
                    assertThat(statsEntry.getContentionTimeStats(
                            WME_ACCESS_CATEGORY_BK).getContentionNumSamples()).isAtLeast(0);
                    assertThat(statsEntry.getContentionTimeStats(
                            WME_ACCESS_CATEGORY_VI).getContentionTimeMinMicros()).isAtLeast(0);
                    assertThat(statsEntry.getContentionTimeStats(
                            WME_ACCESS_CATEGORY_VI).getContentionTimeMaxMicros()).isAtLeast(0);
                    assertThat(statsEntry.getContentionTimeStats(
                            WME_ACCESS_CATEGORY_VI).getContentionTimeAvgMicros()).isAtLeast(0);
                    assertThat(statsEntry.getContentionTimeStats(
                            WME_ACCESS_CATEGORY_VI).getContentionNumSamples()).isAtLeast(0);
                    assertThat(statsEntry.getContentionTimeStats(
                            WME_ACCESS_CATEGORY_VO).getContentionTimeMinMicros()).isAtLeast(0);
                    assertThat(statsEntry.getContentionTimeStats(
                            WME_ACCESS_CATEGORY_VO).getContentionTimeMaxMicros()).isAtLeast(0);
                    assertThat(statsEntry.getContentionTimeStats(
                            WME_ACCESS_CATEGORY_VO).getContentionTimeAvgMicros()).isAtLeast(0);
                    assertThat(statsEntry.getContentionTimeStats(
                            WME_ACCESS_CATEGORY_VO).getContentionNumSamples()).isAtLeast(0);
                    // This is to add CTS test for the constructor function.
                    ContentionTimeStats contentionStats = new ContentionTimeStats(2, 1, 4, 10);
                    assertEquals(2, contentionStats.getContentionTimeMinMicros());
                    assertEquals(1, contentionStats.getContentionTimeMaxMicros());
                    assertEquals(4, contentionStats.getContentionTimeAvgMicros());
                    assertEquals(10, contentionStats.getContentionNumSamples());
                    assertThat(statsEntry.getChannelUtilizationRatio()).isIn(Range.closed(0, 255));
                    if (mTelephonyManager != null) {
                        boolean isCellularDataAvailable =
                                mTelephonyManager.getDataState() == TelephonyManager.DATA_CONNECTED;
                        assertEquals(isCellularDataAvailable, statsEntry.isCellularDataAvailable());
                    } else {
                        assertFalse(statsEntry.isCellularDataAvailable());
                    }
                    statsEntry.isWifiScoringEnabled();
                    statsEntry.isThroughputSufficient();
                    RateStats rateStats = new RateStats(WifiUsabilityStatsEntry.WIFI_PREAMBLE_VHT,
                            WifiUsabilityStatsEntry.WIFI_SPATIAL_STREAMS_TWO,
                            WifiUsabilityStatsEntry.WIFI_BANDWIDTH_40_MHZ,
                            2, 20, 100, 200, 5, 10);
                    assertThat(statsEntry.getRateStats()).isNotNull();
                    if(statsEntry.getRateStats().size() > 0) {
                        assertThat(statsEntry.getRateStats().get(0).getPreamble()).isAtLeast(0);
                        assertThat(statsEntry.getRateStats().get(0).getNumberOfSpatialStreams())
                                .isAtLeast(1);
                        assertThat(statsEntry.getRateStats().get(0).getBandwidthInMhz())
                                .isAtLeast(0);
                        assertThat(statsEntry.getRateStats().get(0).getRateMcsIdx()).isAtLeast(0);
                        assertThat(statsEntry.getRateStats().get(0).getBitRateInKbps())
                                .isAtLeast(0);
                        assertThat(statsEntry.getRateStats().get(0).getTxMpdu()).isAtLeast(0);
                        assertThat(statsEntry.getRateStats().get(0).getRxMpdu()).isAtLeast(0);
                        assertThat(statsEntry.getRateStats().get(0).getMpduLost()).isAtLeast(0);
                        assertThat(statsEntry.getRateStats().get(0).getRetries()).isAtLeast(0);
                    }
                    RadioStats radioStat = new RadioStats(0, 10, 11, 12, 13, 14, 15, 16, 17, 18);
                    assertThat(statsEntry.getWifiLinkLayerRadioStats()).isNotNull();
                    int numRadios = statsEntry.getWifiLinkLayerRadioStats().size();
                    for (int i = 0; i < numRadios; i++) {
                        RadioStats radioStats = statsEntry.getWifiLinkLayerRadioStats().get(i);
                        assertThat(radioStats.getRadioId()).isAtLeast(0);
                        assertThat(radioStats.getTotalRadioOnTimeMillis()).isAtLeast(0);
                        assertThat(radioStats.getTotalRadioTxTimeMillis()).isAtLeast(0);
                        assertThat(radioStats.getTotalRadioRxTimeMillis()).isAtLeast(0);
                        assertThat(radioStats.getTotalScanTimeMillis()).isAtLeast(0);
                        assertThat(radioStats.getTotalNanScanTimeMillis()).isAtLeast(0);
                        assertThat(radioStats.getTotalBackgroundScanTimeMillis()).isAtLeast(0);
                        assertThat(radioStats.getTotalRoamScanTimeMillis()).isAtLeast(0);
                        assertThat(radioStats.getTotalPnoScanTimeMillis()).isAtLeast(0);
                        assertThat(radioStats.getTotalHotspot2ScanTimeMillis()).isAtLeast(0);
                    }
                }
                // no longer populated, return default value.
                assertThat(statsEntry.getCellularDataNetworkType())
                        .isAnyOf(TelephonyManager.NETWORK_TYPE_UNKNOWN,
                                TelephonyManager.NETWORK_TYPE_GPRS,
                                TelephonyManager.NETWORK_TYPE_EDGE,
                                TelephonyManager.NETWORK_TYPE_UMTS,
                                TelephonyManager.NETWORK_TYPE_CDMA,
                                TelephonyManager.NETWORK_TYPE_EVDO_0,
                                TelephonyManager.NETWORK_TYPE_EVDO_A,
                                TelephonyManager.NETWORK_TYPE_1xRTT,
                                TelephonyManager.NETWORK_TYPE_HSDPA,
                                TelephonyManager.NETWORK_TYPE_HSUPA,
                                TelephonyManager.NETWORK_TYPE_HSPA,
                                TelephonyManager.NETWORK_TYPE_IDEN,
                                TelephonyManager.NETWORK_TYPE_EVDO_B,
                                TelephonyManager.NETWORK_TYPE_LTE,
                                TelephonyManager.NETWORK_TYPE_EHRPD,
                                TelephonyManager.NETWORK_TYPE_HSPAP,
                                TelephonyManager.NETWORK_TYPE_GSM,
                                TelephonyManager.NETWORK_TYPE_TD_SCDMA,
                                TelephonyManager.NETWORK_TYPE_IWLAN,
                                TelephonyManager.NETWORK_TYPE_NR);
                assertThat(statsEntry.getCellularSignalStrengthDbm()).isAtMost(0);
                assertThat(statsEntry.getCellularSignalStrengthDb()).isAtMost(0);
                assertThat(statsEntry.isSameRegisteredCell()).isFalse();
            }
        } finally {
            mWifiManager.removeOnWifiUsabilityStatsListener(usabilityStatsListener);
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests the {@link android.net.wifi.WifiManager#updateWifiUsabilityScore(int, int, int)}
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.ConnectedNetworkScorerTest"	"testUpdateWifiUsabilityScore"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ConnectedNetworkScorerTest.java"	""	"public void testUpdateWifiUsabilityScore() throws Exception {
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            // update scoring with dummy values.
            mWifiManager.updateWifiUsabilityScore(0, 50, 50);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests the {@link android.net.wifi.WifiManager#setWifiScoringEnabled(boolean)}
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.ConnectedNetworkScorerTest"	"testSetWifiScoringEnabled"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ConnectedNetworkScorerTest.java"	""	"public void testSetWifiScoringEnabled() throws Exception {
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            assertTrue(mWifiManager.setWifiScoringEnabled(true));
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    private static abstract class TestConnectedNetworkScorer implements
            WifiManager.WifiConnectedNetworkScorer {
        protected CountDownLatch mCountDownLatch;
        public Integer startSessionId;
        public Integer stopSessionId;
        public WifiManager.ScoreUpdateObserver scoreUpdateObserver;
        public boolean isUserSelected;

        TestConnectedNetworkScorer(CountDownLatch countDownLatch) {
            mCountDownLatch = countDownLatch;
        }

        @Override
        public void onStop(int sessionId) {
            synchronized (mCountDownLatch) {
                this.stopSessionId = sessionId;
                mCountDownLatch.countDown();
            }
        }

        @Override
        public void onSetScoreUpdateObserver(WifiManager.ScoreUpdateObserver observerImpl) {
            synchronized (mCountDownLatch) {
                this.scoreUpdateObserver = observerImpl;
            }
        }

        public void resetCountDownLatch(CountDownLatch countDownLatch) {
            synchronized (mCountDownLatch) {
                mCountDownLatch = countDownLatch;
            }
        }
    }

    private static class TestConnectedNetworkScorerWithSessionId extends
            TestConnectedNetworkScorer {
        TestConnectedNetworkScorerWithSessionId(CountDownLatch countDownLatch) {
            super(countDownLatch);
            isUserSelected = false;
        }

        @Override
        public void onStart(int sessionId) {
            synchronized (mCountDownLatch) {
                this.startSessionId = sessionId;
                mCountDownLatch.countDown();
            }
        }
    }

    private static class TestConnectedNetworkScorerWithSessionInfo extends
            TestConnectedNetworkScorer {
        TestConnectedNetworkScorerWithSessionInfo(CountDownLatch countDownLatch) {
            super(countDownLatch);
        }

        @Override
        public void onStart(WifiConnectedSessionInfo sessionInfo) {
            synchronized (mCountDownLatch) {
                this.startSessionId = sessionInfo.getSessionId();
                this.isUserSelected = sessionInfo.isUserSelected();
                // Build a WifiConnectedSessionInfo object
                WifiConnectedSessionInfo.Builder sessionBuilder =
                        new WifiConnectedSessionInfo.Builder(startSessionId.intValue())
                                .setUserSelected(isUserSelected);
                sessionBuilder.build();
                mCountDownLatch.countDown();
            }
        }
    }

    /**
     * Tests the
     * {@link android.net.wifi.WifiConnectedNetworkScorer#onStart(WifiConnectedSessionInfo)}.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.ConnectedNetworkScorerTest"	"testConnectedNetworkScorerWithSessionInfo"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ConnectedNetworkScorerTest.java"	""	"public void testConnectedNetworkScorerWithSessionInfo() throws Exception {
        CountDownLatch countDownLatchScorer = new CountDownLatch(1);
        TestConnectedNetworkScorerWithSessionInfo connectedNetworkScorer =
                new TestConnectedNetworkScorerWithSessionInfo(countDownLatchScorer);
        testSetWifiConnectedNetworkScorer(connectedNetworkScorer, countDownLatchScorer);
    }

    /**
     * Tests the {@link android.net.wifi.WifiConnectedNetworkScorer#onStart(int)}.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.ConnectedNetworkScorerTest"	"testConnectedNetworkScorerWithSessionId"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ConnectedNetworkScorerTest.java"	""	"public void testConnectedNetworkScorerWithSessionId() throws Exception {
        CountDownLatch countDownLatchScorer = new CountDownLatch(1);
        TestConnectedNetworkScorerWithSessionId connectedNetworkScorer =
                new TestConnectedNetworkScorerWithSessionId(countDownLatchScorer);
        testSetWifiConnectedNetworkScorer(connectedNetworkScorer, countDownLatchScorer);
    }

    /**
     * Note: We could write more interesting test cases (if the device has a mobile connection), but
     * that would make the test flaky. The default network/route selection on the device is not just
     * controlled by the wifi scorer input, but also based on params which are controlled by
     * other parts of the platform (likely in connectivity service) and hence will behave
     * differently on OEM devices.
     */
    private void testSetWifiConnectedNetworkScorer(
            TestConnectedNetworkScorer connectedNetworkScorer,
                    CountDownLatch countDownLatchScorer) throws Exception {
        CountDownLatch countDownLatchUsabilityStats = new CountDownLatch(1);
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        TestUsabilityStatsListener usabilityStatsListener =
                new TestUsabilityStatsListener(countDownLatchUsabilityStats);
        boolean disconnected = false;
        try {
            uiAutomation.adoptShellPermissionIdentity();
            // Clear any external scorer already active on the device.
            mWifiManager.clearWifiConnectedNetworkScorer();
            Thread.sleep(500);

            mWifiManager.setWifiConnectedNetworkScorer(
                    Executors.newSingleThreadExecutor(), connectedNetworkScorer);
            // Since we're already connected, wait for onStart to be invoked.
            assertThat(countDownLatchScorer.await(TIMEOUT, TimeUnit.MILLISECONDS)).isTrue();

            assertThat(connectedNetworkScorer.startSessionId).isAtLeast(0);
            assertThat(connectedNetworkScorer.isUserSelected).isEqualTo(false);
            assertThat(connectedNetworkScorer.scoreUpdateObserver).isNotNull();
            WifiManager.ScoreUpdateObserver scoreUpdateObserver =
                    connectedNetworkScorer.scoreUpdateObserver;

            // Now trigger a dummy score update.
            scoreUpdateObserver.notifyScoreUpdate(connectedNetworkScorer.startSessionId, 50);

            // Register the usability listener
            mWifiManager.addOnWifiUsabilityStatsListener(
                    Executors.newSingleThreadExecutor(), usabilityStatsListener);
            // Trigger a usability stats update.
            scoreUpdateObserver.triggerUpdateOfWifiUsabilityStats(
                    connectedNetworkScorer.startSessionId);
            // Ensure that we got the stats update callback.
            assertThat(countDownLatchUsabilityStats.await(TIMEOUT, TimeUnit.MILLISECONDS))
                    .isTrue();
            assertThat(usabilityStatsListener.seqNum).isAtLeast(0);

            // Reset the scorer countdown latch for onStop
            countDownLatchScorer = new CountDownLatch(1);
            connectedNetworkScorer.resetCountDownLatch(countDownLatchScorer);
            if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
                // Notify status change and request a NUD check
                scoreUpdateObserver.notifyStatusUpdate(
                        connectedNetworkScorer.startSessionId, false);
                scoreUpdateObserver.requestNudOperation(connectedNetworkScorer.startSessionId);
                // Blocklist current AP with invalid session Id
                scoreUpdateObserver.blocklistCurrentBssid(-1);
            }
            // Now disconnect from the network.
            mWifiManager.disconnect();
            // Wait for it to be disconnected.
            PollingCheck.check(
                    ""Wifi not disconnected"",
                    TIMEOUT,
                    () -> mWifiManager.getConnectionInfo().getNetworkId() == -1);
            disconnected = true;

            // Wait for stop to be invoked and ensure that the session id matches.
            assertThat(countDownLatchScorer.await(TIMEOUT, TimeUnit.MILLISECONDS)).isTrue();
            assertThat(connectedNetworkScorer.stopSessionId)
                    .isEqualTo(connectedNetworkScorer.startSessionId);
            // Verify that onStart() and onStop() set internal variables correctly.
            connectedNetworkScorer.onStart(
                    new WifiConnectedSessionInfo.Builder(100)
                            .setUserSelected(false)
                            .build());
            assertEquals(100, connectedNetworkScorer.startSessionId.intValue());
            assertEquals(false, connectedNetworkScorer.isUserSelected);
            connectedNetworkScorer.onStop(200);
            assertEquals(200, connectedNetworkScorer.stopSessionId.intValue());
        } finally {
            mWifiManager.removeOnWifiUsabilityStatsListener(usabilityStatsListener);
            mWifiManager.clearWifiConnectedNetworkScorer();

            if (disconnected) {
                mWifiManager.reconnect();
                // Wait for it to be reconnected.
                PollingCheck.check(
                        ""Wifi not reconnected"",
                        WIFI_CONNECT_TIMEOUT_MILLIS,
                        () -> mWifiManager.getConnectionInfo().getNetworkId() != -1);
            }
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests the {@link android.net.wifi.WifiConnectedNetworkScorer} interface.
     *
     * Verifies that the external scorer works even after wifi restart.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.ConnectedNetworkScorerTest"	"testSetWifiConnectedNetworkScorerOnSubsystemRestart"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ConnectedNetworkScorerTest.java"	""	"public void testSetWifiConnectedNetworkScorerOnSubsystemRestart() throws Exception {
        CountDownLatch countDownLatchScorer = new CountDownLatch(1);
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        TestConnectedNetworkScorerWithSessionInfo connectedNetworkScorer =
                new TestConnectedNetworkScorerWithSessionInfo(countDownLatchScorer);
        try {
            uiAutomation.adoptShellPermissionIdentity();
            // Clear any external scorer already active on the device.
            mWifiManager.clearWifiConnectedNetworkScorer();
            Thread.sleep(500);

            mWifiManager.setWifiConnectedNetworkScorer(
                    Executors.newSingleThreadExecutor(), connectedNetworkScorer);
            // Since we're already connected, wait for onStart to be invoked.
            assertThat(countDownLatchScorer.await(TIMEOUT, TimeUnit.MILLISECONDS)).isTrue();

            int prevSessionId = connectedNetworkScorer.startSessionId;
            WifiManager.ScoreUpdateObserver prevScoreUpdateObserver =
                    connectedNetworkScorer.scoreUpdateObserver;

            // Expect one stop followed by one start after the restart

            // Ensure that we got an onStop() for the previous connection when restart is invoked.
            countDownLatchScorer = new CountDownLatch(1);
            connectedNetworkScorer.resetCountDownLatch(countDownLatchScorer);

            // Restart wifi subsystem.
            mWifiManager.restartWifiSubsystem();
            // Wait for the device to connect back.
            PollingCheck.check(
                    ""Wifi not connected"",
                    WIFI_CONNECT_TIMEOUT_MILLIS * 2,
                    () -> mWifiManager.getConnectionInfo().getNetworkId() != -1);

            assertThat(countDownLatchScorer.await(TIMEOUT, TimeUnit.MILLISECONDS)).isTrue();
            assertThat(connectedNetworkScorer.stopSessionId).isEqualTo(prevSessionId);

            // Followed by a new onStart() after the connection.
            // Note: There is a 5 second delay between stop/start when restartWifiSubsystem() is
            // invoked, so this should not be racy.
            countDownLatchScorer = new CountDownLatch(1);
            connectedNetworkScorer.resetCountDownLatch(countDownLatchScorer);
            assertThat(countDownLatchScorer.await(TIMEOUT, TimeUnit.MILLISECONDS)).isTrue();
            assertThat(connectedNetworkScorer.startSessionId).isNotEqualTo(prevSessionId);

            // Ensure that we did not get a new score update observer.
            assertThat(connectedNetworkScorer.scoreUpdateObserver).isSameInstanceAs(
                    prevScoreUpdateObserver);
        } finally {
            mWifiManager.clearWifiConnectedNetworkScorer();
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    private interface ConnectionInitiator {
        /**
         * Trigger connection (using suggestion or specifier) to the provided network.
         */
        ConnectivityManager.NetworkCallback initiateConnection(
                @NonNull WifiConfiguration testNetwork,
                @NonNull ScheduledExecutorService executorService) throws Exception;
    }

    private void setWifiConnectedNetworkScorerAndInitiateConnectToSpecifierOrRestrictedSuggestion(
            @NonNull ConnectionInitiator connectionInitiator) throws Exception {
        CountDownLatch countDownLatchScorer = new CountDownLatch(1);
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        TestConnectedNetworkScorerWithSessionInfo connectedNetworkScorer =
                new TestConnectedNetworkScorerWithSessionInfo(countDownLatchScorer);
        ConnectivityManager.NetworkCallback networkCallback = null;
        ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor();
        List<WifiConfiguration> savedNetworks = null;
        try {
            uiAutomation.adoptShellPermissionIdentity(
                    NETWORK_SETTINGS, WIFI_UPDATE_USABILITY_STATS_SCORE, CONNECTIVITY_INTERNAL,
                    READ_WIFI_CREDENTIAL);

            // Clear any external scorer already active on the device.
            mWifiManager.clearWifiConnectedNetworkScorer();
            Thread.sleep(500);

            savedNetworks = mWifiManager.getPrivilegedConfiguredNetworks();
            WifiConfiguration testNetwork =
                    TestHelper.findMatchingSavedNetworksWithBssid(mWifiManager, savedNetworks)
                            .get(0);
            // Disconnect & disable auto-join on the saved network to prevent auto-connect from
            // interfering with the test.
            for (WifiConfiguration savedNetwork : savedNetworks) {
                mWifiManager.disableNetwork(savedNetwork.networkId);
            }
            // Wait for Wifi to be disconnected.
            PollingCheck.check(
                    ""Wifi not disconnected"",
                    20000,
                    () -> mWifiManager.getConnectionInfo().getNetworkId() == -1);
            assertThat(testNetwork).isNotNull();

            // Register the external scorer.
            mWifiManager.setWifiConnectedNetworkScorer(
                    Executors.newSingleThreadExecutor(), connectedNetworkScorer);

            // Now connect using the provided connection initiator
            networkCallback = connectionInitiator.initiateConnection(testNetwork, executorService);

            // We should not receive the start
            assertThat(countDownLatchScorer.await(WAIT_DURATION, TimeUnit.MILLISECONDS)).isFalse();
            assertThat(connectedNetworkScorer.startSessionId).isNull();

            // Now disconnect from the network.
            mConnectivityManager.unregisterNetworkCallback(networkCallback);
            networkCallback = null;

            // We should not receive the stop either
            countDownLatchScorer = new CountDownLatch(1);
            connectedNetworkScorer.resetCountDownLatch(countDownLatchScorer);
            assertThat(countDownLatchScorer.await(WAIT_DURATION, TimeUnit.MILLISECONDS)).isFalse();
            assertThat(connectedNetworkScorer.stopSessionId).isNull();
        } finally {
            executorService.shutdownNow();
            mWifiManager.clearWifiConnectedNetworkScorer();
            if (networkCallback != null) {
                mConnectivityManager.unregisterNetworkCallback(networkCallback);
            }
            // Re-enable the networks after the test.
            if (savedNetworks != null) {
                for (WifiConfiguration savedNetwork : savedNetworks) {
                    mWifiManager.enableNetwork(savedNetwork.networkId, false);
                }
            }
            uiAutomation.dropShellPermissionIdentity();
        }
    }
    /**
     * Tests the {@link android.net.wifi.WifiConnectedNetworkScorer} interface.
     *
     * Verifies that the external scorer is not notified for local only connections.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.ConnectedNetworkScorerTest"	"testSetWifiConnectedNetworkScorerForSpecifierConnection"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ConnectedNetworkScorerTest.java"	""	"public void testSetWifiConnectedNetworkScorerForSpecifierConnection() throws Exception {
        setWifiConnectedNetworkScorerAndInitiateConnectToSpecifierOrRestrictedSuggestion(
                (testNetwork, executorService) -> {
                    // Connect using wifi network specifier.
                    WifiNetworkSpecifier specifier =
                            TestHelper.createSpecifierBuilderWithCredentialFromSavedNetwork(
                                    testNetwork)
                                    .build();
                    return mTestHelper.testConnectionFlowWithSpecifierWithShellIdentity(
                            testNetwork, specifier, false);
                }
        );
    }

    private void testSetWifiConnectedNetworkScorerForRestrictedSuggestionConnection(
            Set<Integer> restrictedNetworkCapabilities) throws Exception {
        setWifiConnectedNetworkScorerAndInitiateConnectToSpecifierOrRestrictedSuggestion(
                (testNetwork, executorService) -> {
                    // Connect using wifi network suggestion.
                    WifiNetworkSuggestion.Builder suggestionBuilder =
                            TestHelper
                                    .createSuggestionBuilderWithCredentialFromSavedNetworkWithBssid(
                                    testNetwork);
                    if (restrictedNetworkCapabilities.contains(NET_CAPABILITY_OEM_PAID)) {
                        suggestionBuilder.setOemPaid(true);
                    }
                    if (restrictedNetworkCapabilities.contains(NET_CAPABILITY_OEM_PRIVATE)) {
                        suggestionBuilder.setOemPrivate(true);
                    }
                    return mTestHelper.testConnectionFlowWithSuggestionWithShellIdentity(
                            testNetwork, suggestionBuilder.build(), executorService,
                            restrictedNetworkCapabilities);
                }
        );
    }

    /**
     * Tests the {@link android.net.wifi.WifiConnectedNetworkScorer} interface.
     *
     * Verifies that the external scorer is not notified for oem paid suggestion connections.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.ConnectedNetworkScorerTest"	"testSetWifiConnectedNetworkScorerForOemPaidSuggestionConnection"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ConnectedNetworkScorerTest.java"	""	"public void testSetWifiConnectedNetworkScorerForOemPaidSuggestionConnection() throws Exception {
        testSetWifiConnectedNetworkScorerForRestrictedSuggestionConnection(
                Set.of(NET_CAPABILITY_OEM_PAID));
    }

    /**
     * Tests the {@link android.net.wifi.WifiConnectedNetworkScorer} interface.
     *
     * Verifies that the external scorer is not notified for oem private suggestion connections.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.ConnectedNetworkScorerTest"	"testSetWifiConnectedNetworkScorerForOemPrivateSuggestionConnection"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ConnectedNetworkScorerTest.java"	""	"public void testSetWifiConnectedNetworkScorerForOemPrivateSuggestionConnection()
            throws Exception {
        testSetWifiConnectedNetworkScorerForRestrictedSuggestionConnection(
                Set.of(NET_CAPABILITY_OEM_PRIVATE));
    }
}"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.rtt.cts.TestBase"	"isLocationEnabled"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/rtt/cts/TestBase.java"	""	"public void test/*
 *.
 */

package android.net.wifi.rtt.cts;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageManager;
import android.location.LocationManager;
import android.net.wifi.ScanResult;
import android.net.wifi.WifiManager;
import android.net.wifi.cts.WifiJUnit3TestBase;
import android.net.wifi.rtt.RangingResult;
import android.net.wifi.rtt.RangingResultCallback;
import android.net.wifi.rtt.WifiRttManager;
import android.os.Handler;
import android.os.HandlerExecutor;
import android.os.HandlerThread;

import com.android.compatibility.common.util.ShellIdentityUtils;
import com.android.compatibility.common.util.SystemUtil;

import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executor;
import java.util.concurrent.TimeUnit;

/**
 * Base class for Wi-Fi RTT CTS test cases. Provides a uniform configuration and event management
 * facility.
 */
public class TestBase extends WifiJUnit3TestBase {
    protected static final String TAG = ""WifiRttCtsTests"";

    // wait for Wi-Fi RTT to become available
    private static final int WAIT_FOR_RTT_CHANGE_SECS = 10;

    // wait for Wi-Fi scan results to become available
    private static final int WAIT_FOR_SCAN_RESULTS_SECS = 20;

    // wait for network selection and connection finish
    private static final int WAIT_FOR_CONNECTION_FINISH_MS = 30_000;

    // Interval between failure scans
    private static final int INTERVAL_BETWEEN_FAILURE_SCAN_MILLIS = 5_000;

    // 5GHz Frequency band
    private static final int FREQUENCY_OF_5GHZ_BAND_IN_MHZ = 5_000;

    protected WifiRttManager mWifiRttManager;
    protected WifiManager mWifiManager;
    private LocationManager mLocationManager;
    private WifiManager.WifiLock mWifiLock;

    private final HandlerThread mHandlerThread = new HandlerThread(""SingleDeviceTest"");
    protected final Executor mExecutor;
    private Boolean mWasVerboseLoggingEnabled;

    {
        mHandlerThread.start();
        mExecutor = new HandlerExecutor(new Handler(mHandlerThread.getLooper()));
    }

    /**
     * Returns a flag indicating whether or not Wi-Fi RTT should be tested. Wi-Fi RTT
     * should be tested if the feature is supported on the current device.
     */
    static boolean shouldTestWifiRtt(Context context) {
        final PackageManager pm = context.getPackageManager();
        return pm.hasSystemFeature(PackageManager.FEATURE_WIFI_RTT);
    }

    /**
     * Returns a flag indicating whether or not Wi-Fi Aware should be tested. Wi-Fi Aware
     * should be tested if the feature is supported on the current device.
     */
    static boolean shouldTestWifiAware(Context context) {
        final PackageManager pm = context.getPackageManager();
        return pm.hasSystemFeature(PackageManager.FEATURE_WIFI_AWARE);
    }

    @Override
    protected void setUp() throws Exception {
        super.setUp();

        if (!shouldTestWifiRtt(getContext())) {
            return;
        }

        mLocationManager = (LocationManager) getContext().getSystemService(
                Context.LOCATION_SERVICE);
        assertTrue(""RTT testing requires Location to be enabled"",
                mLocationManager.isLocationEnabled());

        mWifiRttManager = (WifiRttManager) getContext().getSystemService(
                Context.WIFI_RTT_RANGING_SERVICE);
        assertNotNull(""Wi-Fi RTT Manager"", mWifiRttManager);

        mWifiManager = (WifiManager) getContext().getSystemService(Context.WIFI_SERVICE);
        assertNotNull(""Wi-Fi Manager"", mWifiManager);

        // turn on verbose logging for tests
        mWasVerboseLoggingEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.isVerboseLoggingEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setVerboseLoggingEnabled(true));

        mWifiLock = mWifiManager.createWifiLock(TAG);
        mWifiLock.acquire();
        if (!mWifiManager.isWifiEnabled()) {
            SystemUtil.runShellCommand(""svc wifi enable"");
            // Turn on Wi-Fi may trigger connection. Wait connection state stable.
            scanAps();
            Thread.sleep(WAIT_FOR_CONNECTION_FINISH_MS);
        }
        IntentFilter intentFilter = new IntentFilter();
        intentFilter.addAction(WifiRttManager.ACTION_WIFI_RTT_STATE_CHANGED);
        WifiRttBroadcastReceiver receiver = new WifiRttBroadcastReceiver();
        mContext.registerReceiver(receiver, intentFilter);
        if (!mWifiRttManager.isAvailable()) {
            assertTrue(""Timeout waiting for Wi-Fi RTT to change status"",
                    receiver.waitForStateChange());
            assertTrue(""Wi-Fi RTT is not available (should be)"", mWifiRttManager.isAvailable());
        }
    }

    @Override
    protected void tearDown() throws Exception {
        if (!shouldTestWifiRtt(getContext())) {
            super.tearDown();
            return;
        }

        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setVerboseLoggingEnabled(mWasVerboseLoggingEnabled));

        super.tearDown();
    }

    class WifiRttBroadcastReceiver extends BroadcastReceiver {
        private CountDownLatch mBlocker = new CountDownLatch(1);

        @Override
        public void onReceive(Context context, Intent intent) {
            if (WifiRttManager.ACTION_WIFI_RTT_STATE_CHANGED.equals(intent.getAction())) {
                mBlocker.countDown();
            }
        }

        boolean waitForStateChange() throws InterruptedException {
            return mBlocker.await(WAIT_FOR_RTT_CHANGE_SECS, TimeUnit.SECONDS);
        }
    }

    class WifiScansBroadcastReceiver extends BroadcastReceiver {
        private CountDownLatch mBlocker = new CountDownLatch(1);

        @Override
        public void onReceive(Context context, Intent intent) {
            if (WifiManager.SCAN_RESULTS_AVAILABLE_ACTION.equals(intent.getAction())) {
                mBlocker.countDown();
            }
        }

        boolean waitForStateChange() throws InterruptedException {
            return mBlocker.await(WAIT_FOR_SCAN_RESULTS_SECS, TimeUnit.SECONDS);
        }
    }

    class ResultCallback extends RangingResultCallback {
        private CountDownLatch mBlocker = new CountDownLatch(1);
        private int mCode; // 0: success, otherwise RangingResultCallback STATUS_CODE_*.
        private List<RangingResult> mResults;

        @Override
        public void onRangingFailure(int code) {
            mCode = code;
            mResults = null; // not necessary since intialized to null - but for completeness
            mBlocker.countDown();
        }

        @Override
        public void onRangingResults(List<RangingResult> results) {
            mCode = 0; // not necessary since initialized to 0 - but for completeness
            mResults = results;
            mBlocker.countDown();
        }

        /**
         * Waits for the listener callback to be called - or an error (timeout, interruption).
         * Returns true on callback called, false on error (timeout, interruption).
         */
        boolean waitForCallback() throws InterruptedException {
            return mBlocker.await(WAIT_FOR_RTT_CHANGE_SECS, TimeUnit.SECONDS);
        }

        /**
         * Returns the code of the callback operation. Will be 0 for success (onRangingResults
         * called), else (if onRangingFailure called) will be one of the STATUS_CODE_* values.
         */
        int getCode() {
            return mCode;
        }

        /**
         * Returns the list of ranging results. In cases of error (getCode() != 0) will return null.
         */
        List<RangingResult> getResults() {
            return mResults;
        }
    }

    /**
     * Start a scan and return a list of observed ScanResults (APs).
     */
    protected List<ScanResult> scanAps() throws InterruptedException {
        IntentFilter intentFilter = new IntentFilter();
        intentFilter.addAction(WifiManager.SCAN_RESULTS_AVAILABLE_ACTION);
        WifiScansBroadcastReceiver receiver = new WifiScansBroadcastReceiver();
        mContext.registerReceiver(receiver, intentFilter);

        mWifiManager.startScan();
        receiver.waitForStateChange();
        mContext.unregisterReceiver(receiver);
        return mWifiManager.getScanResults();
    }

    /**
     * Start a scan and return a test AP which supports IEEE 802.11mc and which has the highest
     * RSSI. Will perform N (parameterized) scans and get the best AP across both scans.
     *
     * Returns null if test AP is not found in the specified number of scans.
     *
     * @param numScanRetries Maximum number of scans retries (in addition to first scan).
     */
    protected ScanResult scanForTest11mcCapableAp(int numScanRetries)
            throws InterruptedException {
        int scanCount = 0;
        ScanResult bestTestAp = null;
        while (scanCount <= numScanRetries) {
            for (ScanResult scanResult : scanAps()) {
                if (!scanResult.is80211mcResponder()) {
                    continue;
                }
                if (bestTestAp == null || scanResult.level > bestTestAp.level) {
                    bestTestAp = scanResult;
                }
            }
            if (bestTestAp == null) {
                // Ongoing connection may cause scan failure, wait for a while before next scan.
                Thread.sleep(INTERVAL_BETWEEN_FAILURE_SCAN_MILLIS);
            }
            scanCount++;
        }
        return bestTestAp;
    }

    /**
     * Start a scan and return a test AP which does NOT support IEEE 802.11mc, with a BSS in the
     * 5GHz band, and which has the highest RSSI. Will perform N (parameterized) scans and get
     * the best AP across all scan results.
     *
     * Returns null if test AP is not found in the specified number of scans.
     *
     * @param numScanRetries Maximum number of scans retries (in addition to first scan).
     */
    protected ScanResult scanForTestNon11mcCapableAp(int numScanRetries)
            throws InterruptedException {
        int scanCount = 0;
        ScanResult bestTestAp = null;
        while (scanCount <= numScanRetries) {
            for (ScanResult scanResult : scanAps()) {
                // Ensure using a 5GHz or greater channel
                if (scanResult.is80211mcResponder()
                        || scanResult.centerFreq0 < FREQUENCY_OF_5GHZ_BAND_IN_MHZ) {
                    continue;
                }
                if (bestTestAp == null || scanResult.level > bestTestAp.level) {
                    bestTestAp = scanResult;
                }
            }
            if (bestTestAp == null) {
                // Ongoing connection may cause scan failure, wait for a while before next scan.
                Thread.sleep(INTERVAL_BETWEEN_FAILURE_SCAN_MILLIS);
            }
            scanCount++;
        }
        return bestTestAp;
    }
}"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.p2p.cts.WifiP2pDeviceTest"	"testDefaultWpsMethodSupportCheck"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/p2p/cts/WifiP2pDeviceTest.java"	""	"public void testDefaultWpsMethodSupportCheck() {
        WifiP2pDevice dev = new WifiP2pDevice();

        assertFalse(dev.wpsPbcSupported());
        assertFalse(dev.wpsDisplaySupported());
        assertFalse(dev.wpsKeypadSupported());
    }"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.p2p.cts.WifiP2pDeviceTest"	"testDefaultDeviceCapabilityCheck"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/p2p/cts/WifiP2pDeviceTest.java"	""	"public void testDefaultDeviceCapabilityCheck() {
        WifiP2pDevice dev = new WifiP2pDevice();

        assertFalse(dev.isServiceDiscoveryCapable());
    }
}"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.wifi.BaseTestCase"	"executeTest"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/wifi/BaseTestCase.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.wifi;

import android.annotation.NonNull;
import android.content.Context;
import android.content.res.Resources;
import android.net.wifi.WifiManager;
import android.os.Handler;
import android.os.HandlerThread;
import android.util.Log;

import com.android.cts.verifier.R;

/**
 * Base class for all Wifi test cases.
 */
public abstract class BaseTestCase {
    private static final String TAG = ""BaseTestCase"";

    protected Context mContext;
    protected Resources mResources;
    protected Listener mListener;

    private Thread mThread;
    private HandlerThread mHandlerThread;
    protected Handler mHandler;
    protected WifiManager mWifiManager;
    protected TestUtils mTestUtils;

    protected String mSsid;
    protected String mPsk;

    public BaseTestCase(Context context) {
        mContext = context;
        mResources = mContext.getResources();
    }

    /**
     * Set up the test case. Executed once before test starts.
     */
    protected void setUp() {
        mWifiManager = (WifiManager) mContext.getSystemService(Context.WIFI_SERVICE);
        mTestUtils = new TestUtils(mContext, mListener);

        // Ensure we're not connected to any wifi network before we start the tests.
        if (mTestUtils.isConnected(null, null)) {
            mListener.onTestFailed(mContext.getString(
                    R.string.wifi_status_connected_to_other_network));
            throw new IllegalStateException(""Should not be connected to any network"");
        }
        /**
         * TODO: Clear the state before each test. This needs to be an instrumentation to
         * run the below shell commands.
        SystemUtil.runShellCommand(""wifi network-suggestions-set-user-approved ""
                + mContext.getPackageName() + "" no"");
        SystemUtil.runShellCommand(""wifi network-requests-remove-user-approved-access-points ""
                + mContext.getPackageName());
        */
    }

    /**
     * Tear down the test case. Executed after test finishes - whether on success or failure.
     */
    protected void tearDown() {
        mWifiManager = null;
    }

    /**
     * Execute test case.
     *
     * @return true on success, false on failure. In case of failure
     */
    protected abstract boolean executeTest() throws InterruptedException;

    /**
     * Returns a String describing the failure reason of the most recent test failure (not valid
     * in other scenarios). Override to customize the failure string.
     */
    protected String getFailureReason() {
        return mContext.getString(R.string.wifi_unexpected_error);
    }

    /**
     * Start running the test case.
     * <p>
     * Test case is executed in another thread.
     */
    public void start(@NonNull Listener listener, @NonNull String ssid, @NonNull String psk) {
        mListener = listener;
        mSsid = ssid;
        mPsk = psk;

        stop();
        mHandlerThread = new HandlerThread(""CtsVerifier-Wifi"");
        mHandlerThread.start();
        mHandler = new Handler(mHandlerThread.getLooper());
        mThread = new Thread(
                new Runnable() {
                    @Override
                    public void run() {
                        mListener.onTestStarted();
                        try {
                            setUp();
                        } catch (Exception e) {
                            Log.e(TAG, ""Setup failed"", e);
                            mListener.onTestFailed(mContext.getString(R.string.wifi_setup_error));
                            return;
                        }

                        try {
                            if (executeTest()) {
                                mListener.onTestSuccess();
                            } else {
                                mListener.onTestFailed(getFailureReason());
                            }
                        } catch (Exception e) {
                            Log.e(TAG, ""Execute failed"", e);
                            mListener.onTestFailed(
                                    mContext.getString(R.string.wifi_unexpected_error));
                        } finally {
                            tearDown();
                        }
                    }
                });
        mThread.start();
    }

    /**
     * Stop the currently running test case.
     */
    public void stop() {
        if (mThread != null) {
            mThread.interrupt();
            mThread = null;
        }
        if (mHandlerThread != null) {
            mHandlerThread.quitSafely();
            mHandlerThread = null;
            mHandler = null;
        }
    }

    /**
     * Listener interface used to communicate the state and status of the test case. It should
     * be implemented by any activity encompassing a test case.
     */
    public interface Listener {
        /**
         * This function is invoked when the test case starts.
         */
        void onTestStarted();

        /**
         * This function is invoked by the test to send a message to listener.
         */
        void onTestMsgReceived(String msg);

        /**
         * This function is invoked when the test finished successfully.
         */
        void onTestSuccess();

        /**
         * This function is invoked when the test failed (test is done).
         */
        void onTestFailed(String reason);
    }
}"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.wifi.TestListActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/wifi/TestListActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.wifi;

import android.app.AlertDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.database.DataSetObserver;
import android.location.LocationManager;
import android.net.wifi.WifiManager;
import android.os.Bundle;
import android.provider.Settings;
import android.util.Log;
import android.view.View;
import android.widget.ListView;

import com.android.cts.verifier.ArrayTestListAdapter;
import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;
import com.android.cts.verifier.TestListAdapter;

/**
 * Activity listing all Wi-Fi Wifi tests.
 */
public class TestListActivity extends PassFailButtons.TestListActivity {
    private static final String TAG = ""TestListActivity"";

    private WifiManager mWifiManager;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        mWifiManager = (WifiManager) getSystemService(Context.WIFI_SERVICE);
        if (mWifiManager == null) {
            Log.wtf(TAG,
                    ""Can't get WIFI_SERVICE. Should be gated by 'test_required_features'!?"");
            return;
        }
        setContentView(R.layout.pass_fail_list);
        setInfoResources(R.string.wifi_test, R.string.wifi_test_info, 0);
        setPassFailButtonClickListeners();
        getPassButton().setEnabled(false);

        // Add the sub-test/categories
        ArrayTestListAdapter adapter = new ArrayTestListAdapter(this);
        adapter.add(TestListAdapter.TestListItem.newCategory(this,
                R.string.wifi_test_network_request));
        adapter.add(TestListAdapter.TestListItem.newTest(this,
                R.string.wifi_test_network_request_specific,
                NetworkRequestSpecificNetworkSpecifierTestActivity.class.getName(),
                new Intent(this, NetworkRequestSpecificNetworkSpecifierTestActivity.class), null));
        adapter.add(TestListAdapter.TestListItem.newTest(this,
                R.string.wifi_test_network_request_pattern,
                NetworkRequestPatternNetworkSpecifierTestActivity.class.getName(),
                new Intent(this, NetworkRequestPatternNetworkSpecifierTestActivity.class), null));
        adapter.add(TestListAdapter.TestListItem.newTest(this,
                R.string.wifi_test_network_request_unavailable,
                NetworkRequestUnavailableNetworkSpecifierTestActivity.class.getName(),
                new Intent(this, NetworkRequestUnavailableNetworkSpecifierTestActivity.class),
                null));
        adapter.add(TestListAdapter.TestListItem.newTest(this,
                R.string.wifi_test_network_request_invalid_credential,
                NetworkRequestInvalidCredentialNetworkSpecifierTestActivity.class.getName(),
                new Intent(this, NetworkRequestInvalidCredentialNetworkSpecifierTestActivity.class),
                null));
        adapter.add(TestListAdapter.TestListItem.newCategory(this,
                R.string.wifi_test_network_suggestion));
        adapter.add(TestListAdapter.TestListItem.newTest(this,
                R.string.wifi_test_network_suggestion_ssid,
                NetworkSuggestionSsidTestActivity.class.getName(),
                new Intent(this, NetworkSuggestionSsidTestActivity.class), null));
        adapter.add(TestListAdapter.TestListItem.newTest(this,
                R.string.wifi_test_network_suggestion_ssid_bssid,
                NetworkSuggestionSsidBssidTestActivity.class.getName(),
                new Intent(this, NetworkSuggestionSsidBssidTestActivity.class), null));
        adapter.add(TestListAdapter.TestListItem.newTest(this,
                R.string.wifi_test_network_suggestion_ssid_post_connect,
                NetworkSuggestionSsidPostConnectTestActivity.class.getName(),
                new Intent(this, NetworkSuggestionSsidPostConnectTestActivity.class), null));
        adapter.add(TestListAdapter.TestListItem.newTest(this,
                R.string.wifi_test_network_suggestion_connection_failure,
                NetworkSuggestionConnectionFailureTestActivity.class.getName(),
                new Intent(this, NetworkSuggestionConnectionFailureTestActivity.class), null));
        adapter.add(TestListAdapter.TestListItem.newTest(this,
                R.string.wifi_test_network_suggestion_modification_in_place,
                NetworkSuggestionModificationInPlaceTestActivity.class.getName(),
                new Intent(this, NetworkSuggestionModificationInPlaceTestActivity.class), null));

        adapter.registerDataSetObserver(new DataSetObserver() {
            @Override
            public void onChanged() {
                updatePassButton();
            }

            @Override
            public void onInvalidated() {
                updatePassButton();
            }
        });

        setTestListAdapter(adapter);
    }

    @Override
    protected void handleItemClick(ListView listView, View view, int position, long id) {
        LocationManager locationManager =
                (LocationManager) getSystemService(Context.LOCATION_SERVICE);
        if (!mWifiManager.isWifiEnabled() || !locationManager.isLocationEnabled()) {
            showWifiAndLocationEnableDialog();
            return;
        }
        super.handleItemClick(listView, view, position, id);
    }

    /**
     * Show the dialog to jump to system settings in order to enable WiFi & location.
     */
    private void showWifiAndLocationEnableDialog() {
        AlertDialog.Builder builder = new AlertDialog.Builder(this);
        builder.setIcon(android.R.drawable.ic_dialog_alert);
        builder.setTitle(R.string.wifi_location_not_enabled);
        builder.setMessage(R.string.wifi_location_not_enabled_message);
        builder.setPositiveButton(R.string.wifi_settings,
                new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                        startActivity(new Intent(Settings.ACTION_WIFI_SETTINGS));
                    }
                });
        builder.setPositiveButton(R.string.location_settings,
                new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                        startActivity(new Intent(Settings.ACTION_LOCATION_SOURCE_SETTINGS));
                    }
                });
        builder.create().show();
    }
}"	""	""	"view wifi button"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiBackupRestoreTest"	"testCanRestoreBackupData"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiBackupRestoreTest.java"	""	"public void testCanRestoreBackupData() {
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        WifiConfiguration origNetwork = null;
        try {
            uiAutomation.adoptShellPermissionIdentity();

            // Pick a regular saved network to modify (non-enterprise, non-Passpoint)
            origNetwork = mWifiManager.getConfiguredNetworks().stream()
                    .filter(n -> {
                        boolean canOverrideConfig = mContext.checkPermission(
                                android.Manifest.permission.OVERRIDE_WIFI_CONFIG, -1, n.creatorUid)
                                == PERMISSION_GRANTED;
                        return canOverrideConfig && !isEnterprise(n) && !n.isPasspoint();
                    })
                    .findAny()
                    .orElse(null);
            if (origNetwork == null) {
                Log.e(TAG, ""Need a non-enterprise and non-Passpoint network created by an app ""
                        + ""holding OVERRIDE_WIFI_CONFIG permission to fully evaluate the ""
                        + ""functionality"");
            }

            // Retrieve backup data.
            byte[] backupData = mWifiManager.retrieveBackupData();

            if (origNetwork != null) {
                // Modify the metered bit.
                final String origNetworkSsid = origNetwork.SSID;
                WifiConfiguration modNetwork = new WifiConfiguration(origNetwork);
                flipMeteredOverride(modNetwork);
                int networkId = mWifiManager.updateNetwork(modNetwork);
                assertThat(networkId).isEqualTo(origNetwork.networkId);
                assertThat(mWifiManager.getConfiguredNetworks()
                        .stream()
                        .filter(n -> n.SSID.equals(origNetworkSsid))
                        .findAny()
                        .get().meteredOverride)
                        .isNotEqualTo(origNetwork.meteredOverride);
            }

            // Restore the original backup data & ensure that the metered bit is back to orig.
            mWifiManager.restoreBackupData(backupData);

            if (origNetwork != null) {
                final String origNetworkSsid = origNetwork.SSID;
                assertThat(mWifiManager.getConfiguredNetworks()
                        .stream()
                        .filter(n -> n.SSID.equals(origNetworkSsid))
                        .findAny()
                        .get().meteredOverride)
                        .isEqualTo(origNetwork.meteredOverride);
            }
        } finally {
            // Restore the orig network
            if (origNetwork != null) {
                mWifiManager.updateNetwork(origNetwork);
            }
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests for {@link WifiManager#retrieveSoftApBackupData()} &
     * {@link WifiManager#restoreSoftApBackupData(byte[])}
     */"	""	""	"passpoint wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiBackupRestoreTest"	"isNotNull"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiBackupRestoreTest.java"	""	"/*
 *.
 */

package android.net.wifi.cts;

import static android.content.pm.PackageManager.PERMISSION_GRANTED;
import static android.net.wifi.WifiConfiguration.METERED_OVERRIDE_METERED;
import static android.net.wifi.WifiConfiguration.METERED_OVERRIDE_NONE;
import static android.net.wifi.WifiConfiguration.METERED_OVERRIDE_NOT_METERED;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import static org.junit.Assume.assumeTrue;

import android.app.UiAutomation;
import android.content.Context;
import android.net.IpConfiguration;
import android.net.LinkAddress;
import android.net.ProxyInfo;
import android.net.StaticIpConfiguration;
import android.net.Uri;
import android.net.wifi.SoftApConfiguration;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiEnterpriseConfig;
import android.net.wifi.WifiManager;
import android.platform.test.annotations.AppModeFull;
import android.support.test.uiautomator.UiDevice;
import android.util.Log;

import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.filters.SmallTest;
import androidx.test.platform.app.InstrumentationRegistry;

import com.android.compatibility.common.util.PollingCheck;
import com.android.compatibility.common.util.ShellIdentityUtils;
import com.android.compatibility.common.util.SystemUtil;
import com.android.compatibility.common.util.ThrowingRunnable;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.io.DataInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * Tests for wifi backup/restore functionality.
 */
@AppModeFull(reason = ""Cannot get WifiManager in instant app mode"")
@SmallTest
@RunWith(AndroidJUnit4.class)
public class WifiBackupRestoreTest extends WifiJUnit4TestBase {
    private static final String TAG = ""WifiBackupRestoreTest"";
    private static final String LEGACY_SUPP_CONF_FILE =
            ""assets/BackupLegacyFormatSupplicantConf.txt"";
    private static final String LEGACY_IP_CONF_FILE =
            ""assets/BackupLegacyFormatIpConf.txt"";
    private static final String V1_0_FILE = ""assets/BackupV1.0Format.xml"";
    private static final String V1_1_FILE = ""assets/BackupV1.1Format.xml"";
    private static final String V1_2_FILE = ""assets/BackupV1.2Format.xml"";

    public static final String EXPECTED_LEGACY_STATIC_IP_LINK_ADDRESS = ""192.168.48.2"";
    public static final int EXPECTED_LEGACY_STATIC_IP_LINK_PREFIX_LENGTH = 8;
    public static final String EXPECTED_LEGACY_STATIC_IP_GATEWAY_ADDRESS = ""192.168.48.1"";
    public static final String[] EXPECTED_LEGACY_STATIC_IP_DNS_SERVER_ADDRESSES =
            new String[]{""192.168.48.1"", ""192.168.48.10""};
    public static final String EXPECTED_LEGACY_STATIC_PROXY_HOST = ""192.168.48.1"";
    public static final int EXPECTED_LEGACY_STATIC_PROXY_PORT = 8000;
    public static final String EXPECTED_LEGACY_STATIC_PROXY_EXCLUSION_LIST = """";
    public static final String EXPECTED_LEGACY_PAC_PROXY_LOCATION = ""http://"";

    private Context mContext;
    private WifiManager mWifiManager;
    private UiDevice mUiDevice;
    private boolean mWasVerboseLoggingEnabled;

    private static final int DURATION = 10_000;
    private static final int DURATION_SCREEN_TOGGLE = 2000;

    @Before
    public void setUp() throws Exception {
        mContext = InstrumentationRegistry.getInstrumentation().getContext();
        // skip the test if WiFi is not supported
        assumeTrue(WifiFeature.isWifiSupported(mContext));

        mWifiManager = mContext.getSystemService(WifiManager.class);
        assertThat(mWifiManager).isNotNull();

        // turn on verbose logging for tests
        mWasVerboseLoggingEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.isVerboseLoggingEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setVerboseLoggingEnabled(true));
        // Disable scan throttling for tests.
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setScanThrottleEnabled(false));

        if (!mWifiManager.isWifiEnabled()) setWifiEnabled(true);
        mUiDevice = UiDevice.getInstance(InstrumentationRegistry.getInstrumentation());
        turnScreenOn();
        PollingCheck.check(""Wifi not enabled"", DURATION, () -> mWifiManager.isWifiEnabled());

        List<WifiConfiguration> savedNetworks = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.getPrivilegedConfiguredNetworks());
        assertWithMessage(""Need at least one saved network"").that(savedNetworks).isNotEmpty();
    }

    @After
    public void tearDown() throws Exception {
        if (!WifiFeature.isWifiSupported(mContext)) return;
        if (!mWifiManager.isWifiEnabled()) setWifiEnabled(true);
        turnScreenOff();
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setVerboseLoggingEnabled(mWasVerboseLoggingEnabled));
    }

    private void setWifiEnabled(boolean enable) throws Exception {
        // now trigger the change using shell commands.
        SystemUtil.runShellCommand(""svc wifi "" + (enable ? ""enable"" : ""disable""));
    }

    private void turnScreenOn() throws Exception {
        mUiDevice.executeShellCommand(""input keyevent KEYCODE_WAKEUP"");
        mUiDevice.executeShellCommand(""wm dismiss-keyguard"");
        // Since the screen on/off intent is ordered, they will not be sent right now.
        Thread.sleep(DURATION_SCREEN_TOGGLE);
    }

    private void turnScreenOff() throws Exception {
        mUiDevice.executeShellCommand(""input keyevent KEYCODE_SLEEP"");
        // Since the screen on/off intent is ordered, they will not be sent right now.
        Thread.sleep(DURATION_SCREEN_TOGGLE);
    }

    private void flipMeteredOverride(WifiConfiguration network) {
        if (network.meteredOverride == METERED_OVERRIDE_NONE) {
            network.meteredOverride = METERED_OVERRIDE_METERED;
        } else if (network.meteredOverride == METERED_OVERRIDE_METERED) {
            network.meteredOverride = METERED_OVERRIDE_NOT_METERED;
        } else if (network.meteredOverride == METERED_OVERRIDE_NOT_METERED) {
            network.meteredOverride = METERED_OVERRIDE_NONE;
        }
    }

    /** WifiConfiguration#isEnterprise() is @hide, so copy/paste partial implementation here. */
    private static boolean isEnterprise(WifiConfiguration config) {
        WifiEnterpriseConfig enterpriseConfig = config.enterpriseConfig;
        return enterpriseConfig != null
                && enterpriseConfig.getEapMethod() != WifiEnterpriseConfig.Eap.NONE;
    }

    /**
     * Tests for {@link WifiManager#retrieveBackupData()} &
     * {@link WifiManager#restoreBackupData(byte[])}
     * Note: If the network was not created by an app with OVERRIDE_WIFI_CONFIG permission (held
     * by AOSP settings app for example), then the backup data will not contain that network. If
     * the device does not contain any such pre-existing saved network, then this test will be
     * a no-op, will only ensure that the device does not crash when invoking the API's.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiBackupRestoreTest"	"testCanRestoreSoftApBackupData"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiBackupRestoreTest.java"	""	"public void testCanRestoreSoftApBackupData() {
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        SoftApConfiguration origSoftApConfig = null;
        try {
            uiAutomation.adoptShellPermissionIdentity();


            // get soft ap configuration and set it back to update configuration to user
            // configuration.
            mWifiManager.setSoftApConfiguration(mWifiManager.getSoftApConfiguration());

            // Retrieve original soft ap config.
            origSoftApConfig = mWifiManager.getSoftApConfiguration();

            // Retrieve backup data.
            byte[] backupData = mWifiManager.retrieveSoftApBackupData();

            // Modify softap config and set it.
            String origSsid = origSoftApConfig.getSsid();
            char lastOrigSsidChar = origSsid.charAt(origSsid.length() - 1);
            String updatedSsid = new StringBuilder(origSsid.substring(0, origSsid.length() - 1))
                    .append((lastOrigSsidChar == 'a' || lastOrigSsidChar == 'A') ? 'b' : 'a')
                    .toString();
            SoftApConfiguration modSoftApConfig = new SoftApConfiguration.Builder(origSoftApConfig)
                    .setSsid(updatedSsid)
                    .build();
            mWifiManager.setSoftApConfiguration(modSoftApConfig);
            // Ensure that it does not match the orig softap config.
            assertThat(mWifiManager.getSoftApConfiguration()).isNotEqualTo(origSoftApConfig);

            // Restore the original backup data & ensure that the orig softap config is restored.
            mWifiManager.restoreSoftApBackupData(backupData);
            assertThat(mWifiManager.getSoftApConfiguration()).isEqualTo(origSoftApConfig);
        } finally {
            if (origSoftApConfig != null) {
                mWifiManager.setSoftApConfiguration(origSoftApConfig);
            }
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Read the content of the given resource file into a String.
     *
     * @param filename String name of the file
     * @return Byte array of the contents of the file.
     * @throws IOException
     */
    private byte[] loadResourceFile(String filename) throws IOException {
        InputStream in = getClass().getClassLoader().getResourceAsStream(filename);
        DataInputStream dis = new DataInputStream(in);
        byte[] data = new byte[dis.available()];
        dis.readFully(data);
        return data;
    }

    private WifiConfiguration createExpectedLegacyWepWifiConfiguration() {
        WifiConfiguration configuration = new WifiConfiguration();
        configuration.SSID = ""\""TestSsid1\"""";
        configuration.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.NONE);
        configuration.wepKeys = new String[4];
        configuration.wepKeys[0] = ""\""WepAscii12345\"""";
        configuration.wepKeys[1] = ""\""WepAs\"""";
        configuration.wepKeys[2] = ""45342312ab"";
        configuration.wepKeys[3] = ""45342312ab45342312ab34ac12"";
        configuration.wepTxKeyIndex = 1;
        return configuration;
    }

    private WifiConfiguration createExpectedLegacyPskWifiConfiguration() {
        WifiConfiguration configuration = new WifiConfiguration();
        configuration.SSID = ""\""TestSsid2\"""";
        configuration.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.WPA_PSK);
        configuration.preSharedKey = ""\""TestPsk123\"""";
        return configuration;
    }

    private WifiConfiguration createExpectedLegacyOpenWifiConfiguration() {
        WifiConfiguration configuration = new WifiConfiguration();
        configuration.SSID = ""\""TestSsid3\"""";
        configuration.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.NONE);
        return configuration;
    }

    private IpConfiguration createExpectedLegacyDHCPIpConfigurationWithPacProxy() throws Exception {
        IpConfiguration ipConfiguration = new IpConfiguration();
        ipConfiguration.setIpAssignment(IpConfiguration.IpAssignment.DHCP);
        ipConfiguration.setProxySettings(IpConfiguration.ProxySettings.PAC);
        ipConfiguration.setHttpProxy(ProxyInfo.buildPacProxy(
                Uri.parse(EXPECTED_LEGACY_PAC_PROXY_LOCATION)));
        return ipConfiguration;
    }

    private StaticIpConfiguration createExpectedLegacyStaticIpconfiguration() throws Exception {
        return new StaticIpConfiguration.Builder()
                .setIpAddress(
                        new LinkAddress(
                                InetAddress.getByName(EXPECTED_LEGACY_STATIC_IP_LINK_ADDRESS),
                                EXPECTED_LEGACY_STATIC_IP_LINK_PREFIX_LENGTH))
                .setGateway(InetAddress.getByName(EXPECTED_LEGACY_STATIC_IP_GATEWAY_ADDRESS))
                .setDnsServers(Arrays.asList(EXPECTED_LEGACY_STATIC_IP_DNS_SERVER_ADDRESSES)
                        .stream()
                        .map(s -> {
                            try {
                                return InetAddress.getByName(s);
                            } catch (UnknownHostException e) {
                                return null;
                            }
                        })
                        .collect(Collectors.toList()))
                .build();
    }

    private IpConfiguration createExpectedLegacyStaticIpConfigurationWithPacProxy()
            throws Exception {
        IpConfiguration ipConfiguration = new IpConfiguration();
        ipConfiguration.setIpAssignment(IpConfiguration.IpAssignment.STATIC);
        ipConfiguration.setStaticIpConfiguration(createExpectedLegacyStaticIpconfiguration());
        ipConfiguration.setProxySettings(IpConfiguration.ProxySettings.PAC);
        ipConfiguration.setHttpProxy(ProxyInfo.buildPacProxy(
                Uri.parse(EXPECTED_LEGACY_PAC_PROXY_LOCATION)));
        return ipConfiguration;
    }

    private IpConfiguration createExpectedLegacyStaticIpConfigurationWithStaticProxy()
            throws Exception {
        IpConfiguration ipConfiguration = new IpConfiguration();
        ipConfiguration.setIpAssignment(IpConfiguration.IpAssignment.STATIC);
        ipConfiguration.setStaticIpConfiguration(createExpectedLegacyStaticIpconfiguration());
        ipConfiguration.setProxySettings(IpConfiguration.ProxySettings.STATIC);
        ipConfiguration.setHttpProxy(ProxyInfo.buildDirectProxy(
                EXPECTED_LEGACY_STATIC_PROXY_HOST, EXPECTED_LEGACY_STATIC_PROXY_PORT,
                Arrays.asList(EXPECTED_LEGACY_STATIC_PROXY_EXCLUSION_LIST)));
        return ipConfiguration;
    }

    /**
     * Check that expected configrations could be found in restored configurations.
     * As multi-type configurations would be converted to several single-type configurations,
     * two list could not be compared directly.
     */
    private void assertConfigurationsEqual(
            List<WifiConfiguration> expected, List<WifiConfiguration> actual) {
        assertThat(actual.size() >= expected.size()).isTrue();
        for (WifiConfiguration expectedConfiguration : expected) {
            String expectedConfigKey = expectedConfiguration.getKey();
            boolean didCompare = false;
            for (WifiConfiguration actualConfiguration : actual) {
                String actualConfigKey = actualConfiguration.getKey();
                if (actualConfigKey.equals(expectedConfigKey)) {
                    assertConfigurationEqual(
                            expectedConfiguration, actualConfiguration);
                    didCompare = true;
                }
            }
            assertWithMessage(""Didn't find matching config for key = ""
                    + expectedConfigKey).that(didCompare).isTrue();
        }
    }

    /**
     * Asserts that the 2 WifiConfigurations are equal.
     */
    private void assertConfigurationEqual(
            WifiConfiguration expected, WifiConfiguration actual) {
        assertThat(actual).isNotNull();
        assertThat(expected).isNotNull();
        assertWithMessage(""Network: "" + actual.toString())
                .that(actual.SSID).isEqualTo(expected.SSID);
        assertWithMessage(""Network: "" + actual.toString())
                .that(actual.preSharedKey).isEqualTo(expected.preSharedKey);
        assertWithMessage(""Network: "" + actual.toString())
                .that(actual.wepKeys).isEqualTo(expected.wepKeys);
        assertWithMessage(""Network: "" + actual.toString())
                .that(actual.wepTxKeyIndex).isEqualTo(expected.wepTxKeyIndex);
        assertWithMessage(""Network: "" + actual.toString())
                .that(actual.hiddenSSID).isEqualTo(expected.hiddenSSID);
        assertWithMessage(""Network: "" + actual.toString())
                .that(actual.requirePmf).isEqualTo(expected.requirePmf);
        assertWithMessage(""Network: "" + actual.toString())
                .that(actual.allowedKeyManagement).isEqualTo(expected.allowedKeyManagement);
        assertWithMessage(""Network: "" + actual.toString())
                .that(actual.shared).isEqualTo(expected.shared);
        assertWithMessage(""Network: "" + actual.toString())
                .that(actual.allowAutojoin).isEqualTo(expected.allowAutojoin);
        assertWithMessage(""Network: "" + actual.toString())
                .that(actual.getIpConfiguration()).isEqualTo(expected.getIpConfiguration());
        assertWithMessage(""Network: "" + actual.toString())
                .that(actual.meteredOverride).isEqualTo(expected.meteredOverride);
        if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(mContext)) {
            assertWithMessage(""Network: "" + actual.toString())
                    .that(actual.getProfileKey()).isEqualTo(expected.getProfileKey());
        } else {
            assertWithMessage(""Network: "" + actual.toString())
                    .that(actual.getKey()).isEqualTo(expected.getKey());
        }
    }

    private void testRestoreFromBackupData(
            List<WifiConfiguration> expectedConfigurations, ThrowingRunnable restoreMethod)
        throws Exception {
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        List<WifiConfiguration> restoredSavedNetworks = null;
        try {
            uiAutomation.adoptShellPermissionIdentity();
            Set<String> origSavedSsids = mWifiManager.getConfiguredNetworks().stream()
                    .map(n -> n.SSID)
                    .collect(Collectors.toSet());

            restoreMethod.run();

            restoredSavedNetworks = mWifiManager.getPrivilegedConfiguredNetworks().stream()
                    .filter(n -> !origSavedSsids.contains(n.SSID))
                    .collect(Collectors.toList());
            assertConfigurationsEqual(
                    expectedConfigurations, restoredSavedNetworks);
        } finally {
            // clean up all restored networks.
            if (restoredSavedNetworks != null) {
                for (WifiConfiguration network : restoredSavedNetworks) {
                    mWifiManager.removeNetwork(network.networkId);
                }
            }
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    private List<WifiConfiguration> createExpectedLegacyConfigurations() throws Exception {
        List<WifiConfiguration> expectedConfigurations = new ArrayList<>();
        WifiConfiguration wepNetwork = createExpectedLegacyWepWifiConfiguration();
        wepNetwork.setIpConfiguration(createExpectedLegacyDHCPIpConfigurationWithPacProxy());
        expectedConfigurations.add(wepNetwork);

        WifiConfiguration pskNetwork = createExpectedLegacyPskWifiConfiguration();
        pskNetwork.setIpConfiguration(createExpectedLegacyStaticIpConfigurationWithPacProxy());
        expectedConfigurations.add(pskNetwork);

        WifiConfiguration openNetwork = createExpectedLegacyOpenWifiConfiguration();
        openNetwork.setIpConfiguration(
                createExpectedLegacyStaticIpConfigurationWithStaticProxy());
        expectedConfigurations.add(openNetwork);
        return expectedConfigurations;
    }

    /**
     * Verify that 3 network configuration is deserialized correctly from AOSP
     * legacy supplicant/ipconf backup data format.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiBackupRestoreTest"	"testRestoreFromLegacyBackupFormat"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiBackupRestoreTest.java"	""	"public void testRestoreFromLegacyBackupFormat() throws Exception {
        testRestoreFromBackupData(createExpectedLegacyConfigurations(),
                () -> mWifiManager.restoreSupplicantBackupData(
                        loadResourceFile(LEGACY_SUPP_CONF_FILE),
                        loadResourceFile(LEGACY_IP_CONF_FILE)));

    }

    private List<WifiConfiguration> createExpectedV1_0Configurations() throws Exception {
        List<WifiConfiguration> expectedConfigurations = new ArrayList<>();
        WifiConfiguration wepNetwork = createExpectedLegacyWepWifiConfiguration();
        wepNetwork.setIpConfiguration(createExpectedLegacyDHCPIpConfigurationWithPacProxy());
        expectedConfigurations.add(wepNetwork);

        WifiConfiguration pskNetwork = createExpectedLegacyPskWifiConfiguration();
        pskNetwork.setIpConfiguration(createExpectedLegacyStaticIpConfigurationWithPacProxy());
        expectedConfigurations.add(pskNetwork);

        WifiConfiguration openNetwork = createExpectedLegacyOpenWifiConfiguration();
        openNetwork.setIpConfiguration(
                createExpectedLegacyStaticIpConfigurationWithStaticProxy());
        expectedConfigurations.add(openNetwork);
        return expectedConfigurations;
    }

    /**
     * Verify that 3 network configuration is deserialized correctly from AOSP 1.0 format.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiBackupRestoreTest"	"testRestoreFromV1_0BackupFormat"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiBackupRestoreTest.java"	""	"public void testRestoreFromV1_0BackupFormat() throws Exception {
        testRestoreFromBackupData(createExpectedV1_0Configurations(),
                () -> mWifiManager.restoreBackupData(loadResourceFile(V1_0_FILE)));
    }

    private List<WifiConfiguration> createExpectedV1_1Configurations() throws Exception {
        List<WifiConfiguration> expectedConfigurations = new ArrayList<>();
        WifiConfiguration wepNetwork = createExpectedLegacyWepWifiConfiguration();
        wepNetwork.setIpConfiguration(createExpectedLegacyDHCPIpConfigurationWithPacProxy());
        wepNetwork.meteredOverride = METERED_OVERRIDE_METERED;
        expectedConfigurations.add(wepNetwork);

        WifiConfiguration pskNetwork = createExpectedLegacyPskWifiConfiguration();
        pskNetwork.setIpConfiguration(createExpectedLegacyStaticIpConfigurationWithPacProxy());
        pskNetwork.meteredOverride = METERED_OVERRIDE_NONE;
        expectedConfigurations.add(pskNetwork);

        WifiConfiguration openNetwork = createExpectedLegacyOpenWifiConfiguration();
        openNetwork.setIpConfiguration(
                createExpectedLegacyStaticIpConfigurationWithStaticProxy());
        openNetwork.meteredOverride = METERED_OVERRIDE_NOT_METERED;
        expectedConfigurations.add(openNetwork);
        return expectedConfigurations;
    }

    /**
     * Verify that 3 network configuration is deserialized correctly from AOSP 1.1 format.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiBackupRestoreTest"	"testRestoreFromV1_1BackupFormat"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiBackupRestoreTest.java"	""	"public void testRestoreFromV1_1BackupFormat() throws Exception {
        testRestoreFromBackupData(createExpectedV1_1Configurations(),
                () -> mWifiManager.restoreBackupData(loadResourceFile(V1_1_FILE)));
    }

    private List<WifiConfiguration> createExpectedV1_2Configurations() throws Exception {
        List<WifiConfiguration> expectedConfigurations = new ArrayList<>();
        WifiConfiguration wepNetwork = createExpectedLegacyWepWifiConfiguration();
        wepNetwork.setIpConfiguration(createExpectedLegacyDHCPIpConfigurationWithPacProxy());
        wepNetwork.meteredOverride = METERED_OVERRIDE_METERED;
        wepNetwork.allowAutojoin = true;
        expectedConfigurations.add(wepNetwork);

        WifiConfiguration pskNetwork = createExpectedLegacyPskWifiConfiguration();
        pskNetwork.setIpConfiguration(createExpectedLegacyStaticIpConfigurationWithPacProxy());
        pskNetwork.meteredOverride = METERED_OVERRIDE_NONE;
        pskNetwork.allowAutojoin = false;
        expectedConfigurations.add(pskNetwork);

        WifiConfiguration openNetwork = createExpectedLegacyOpenWifiConfiguration();
        openNetwork.setIpConfiguration(
                createExpectedLegacyStaticIpConfigurationWithStaticProxy());
        openNetwork.meteredOverride = METERED_OVERRIDE_NOT_METERED;
        openNetwork.allowAutojoin = false;
        expectedConfigurations.add(openNetwork);
        return expectedConfigurations;
    }

    /**
     * Verify that 3 network configuration is deserialized correctly from AOSP 1.2 format.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiBackupRestoreTest"	"testRestoreFromV1_2BackupFormat"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiBackupRestoreTest.java"	""	"public void testRestoreFromV1_2BackupFormat() throws Exception {
        testRestoreFromBackupData(createExpectedV1_2Configurations(),
                () -> mWifiManager.restoreBackupData(loadResourceFile(V1_2_FILE)));
    }
}"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiJUnit4TestBase"	"isLocationEnabled"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiJUnit4TestBase.java"	""	"public void test/*
 *.
 */

package android.net.wifi.cts;

import android.content.Context;
import android.location.LocationManager;
import android.os.Process;
import android.os.UserHandle;
import android.test.AndroidTestCase;

import androidx.test.platform.app.InstrumentationRegistry;

import com.android.compatibility.common.util.ShellIdentityUtils;

import org.junit.After;
import org.junit.Before;

/**
 * Base test for Wifi JUnit4 tests that enables/disables location
 */
public abstract class WifiJUnit4TestBase {

    private LocationManager mLocationManager;
    private boolean mWasLocationEnabledForTest = false;

    @Before
    public void enableLocationIfNotEnabled() throws Exception {
        Context context = InstrumentationRegistry.getInstrumentation().getContext();

        mLocationManager = context.getSystemService(LocationManager.class);
        if (!mLocationManager.isLocationEnabled()) {
            // Turn on location if it isn't on already
            ShellIdentityUtils.invokeWithShellPermissions(() ->
                mLocationManager.setLocationEnabledForUser(
                    true, UserHandle.getUserHandleForUid(Process.myUid())));

            mWasLocationEnabledForTest = true;
        }
    }

    @After
    public void disableLocationIfOriginallyDisabled() throws Exception {
        if (mWasLocationEnabledForTest) {
            mLocationManager.setLocationEnabledForUser(
                    false, UserHandle.getUserHandleForUid(Process.myUid()));
        }
    }
}"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest"	"isStaConcurrencyForRestrictedConnectionsSupported"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest.java"	""	"/*
 *.
 */

package android.net.wifi.cts;

import static android.net.NetworkCapabilities.NET_CAPABILITY_OEM_PAID;
import static android.net.NetworkCapabilities.NET_CAPABILITY_OEM_PRIVATE;
import static android.os.Process.myUid;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import static org.junit.Assume.assumeTrue;

import android.content.Context;
import android.content.pm.PackageManager;
import android.location.LocationManager;
import android.net.ConnectivityManager;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiManager;
import android.net.wifi.WifiNetworkSuggestion;
import android.os.Build;
import android.platform.test.annotations.AppModeFull;
import android.support.test.uiautomator.UiDevice;

import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.filters.LargeTest;
import androidx.test.filters.SdkSuppress;
import androidx.test.platform.app.InstrumentationRegistry;

import com.android.compatibility.common.util.PollingCheck;
import com.android.compatibility.common.util.ShellIdentityUtils;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.List;
import java.util.Set;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;

/**
 * Tests multiple concurrent connection flow on devices that support multi STA concurrency
 * (indicated via {@link WifiManager#isStaConcurrencyForRestrictedConnectionsSupported()}.
 *
 * Tests the entire connection flow using {@link WifiNetworkSuggestion} which has
 * {@link WifiNetworkSuggestion.Builder#setOemPaid(boolean)} or
 * {@link WifiNetworkSuggestion.Builder#setOemPrivate(boolean)} set along with a concurrent internet
 * connection using {@link WifiManager#connect(int, WifiManager.ActionListener)}.
 *
 * Assumes that all the saved networks is either open/WPA1/WPA2/WPA3 authenticated network.
 */
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)
@AppModeFull(reason = ""Cannot get WifiManager in instant app mode"")
@LargeTest
@RunWith(AndroidJUnit4.class)
public class MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest extends WifiJUnit4TestBase {
    private static final String TAG = ""MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest"";
    private static boolean sWasVerboseLoggingEnabled;
    private static boolean sWasScanThrottleEnabled;
    private static boolean sWasWifiEnabled;

    private Context mContext;
    private WifiManager mWifiManager;
    private ConnectivityManager mConnectivityManager;
    private UiDevice mUiDevice;
    private WifiConfiguration mTestNetworkForRestrictedConnection;
    private WifiConfiguration mTestNetworkForInternetConnection;
    private ConnectivityManager.NetworkCallback mNetworkCallback;
    private ConnectivityManager.NetworkCallback mNsNetworkCallback;
    private ScheduledExecutorService mExecutorService;
    private TestHelper mTestHelper;

    private static final int DURATION_MILLIS = 10_000;

    @BeforeClass
    public static void setUpClass() throws Exception {
        Context context = InstrumentationRegistry.getInstrumentation().getContext();
        // skip the test if WiFi is not supported or not automotive platform.
        // Don't use assumeTrue in @BeforeClass
        if (!WifiFeature.isWifiSupported(context)) return;

        WifiManager wifiManager = context.getSystemService(WifiManager.class);
        assertThat(wifiManager).isNotNull();

        // turn on verbose logging for tests
        sWasVerboseLoggingEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.isVerboseLoggingEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setVerboseLoggingEnabled(true));
        // Disable scan throttling for tests.
        sWasScanThrottleEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.isScanThrottleEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setScanThrottleEnabled(false));

        // enable Wifi
        sWasWifiEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.isWifiEnabled());
        if (!wifiManager.isWifiEnabled()) {
            ShellIdentityUtils.invokeWithShellPermissions(() -> wifiManager.setWifiEnabled(true));
        }
        PollingCheck.check(""Wifi not enabled"", DURATION_MILLIS, () -> wifiManager.isWifiEnabled());
    }

    @AfterClass
    public static void tearDownClass() throws Exception {
        Context context = InstrumentationRegistry.getInstrumentation().getContext();
        if (!WifiFeature.isWifiSupported(context)) return;

        WifiManager wifiManager = context.getSystemService(WifiManager.class);
        assertThat(wifiManager).isNotNull();

        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setScanThrottleEnabled(sWasScanThrottleEnabled));
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setVerboseLoggingEnabled(sWasVerboseLoggingEnabled));
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setWifiEnabled(sWasWifiEnabled));
    }

    @Before
    public void setUp() throws Exception {
        mContext = InstrumentationRegistry.getInstrumentation().getContext();
        mWifiManager = mContext.getSystemService(WifiManager.class);
        mConnectivityManager = mContext.getSystemService(ConnectivityManager.class);
        mUiDevice = UiDevice.getInstance(InstrumentationRegistry.getInstrumentation());
        mExecutorService = Executors.newSingleThreadScheduledExecutor();
        mTestHelper = new TestHelper(mContext, mUiDevice);

        // skip the test if WiFi is not supported or not automitve platform.
        assumeTrue(WifiFeature.isWifiSupported(mContext));
        // skip the test if location is not supported
        assumeTrue(mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_LOCATION));
        // skip if multi STA not supported.
        assumeTrue(mWifiManager.isStaConcurrencyForRestrictedConnectionsSupported());

        assertWithMessage(""Please enable location for this test!"").that(
                mContext.getSystemService(LocationManager.class).isLocationEnabled()).isTrue();

        // turn screen on
        mTestHelper.turnScreenOn();

        // Clear any existing app state before each test.
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.removeAppState(myUid(), mContext.getPackageName()));

        // We need 2 AP's for the test. If there are 2 networks saved on the device and in range,
        // use those. Otherwise, check if there are 2 BSSID's in range for the only saved network.
        // This assumes a CTS test environment with at least 2 connectable bssid's (Is that ok?).
        List<WifiConfiguration> savedNetworks = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.getPrivilegedConfiguredNetworks());
        List<WifiConfiguration> matchingNetworksWithBssid =
                TestHelper.findMatchingSavedNetworksWithBssid(mWifiManager, savedNetworks);
        assertWithMessage(""Need at least 2 saved network bssids in range"").that(
                matchingNetworksWithBssid.size()).isAtLeast(2);
        // Pick any 2 bssid for test.
        mTestNetworkForRestrictedConnection = matchingNetworksWithBssid.get(0);
        // Try to find a bssid for another saved network in range. If none exists, fallback
        // to using 2 bssid's for the same network.
        mTestNetworkForInternetConnection = matchingNetworksWithBssid.stream()
                .filter(w -> !w.SSID.equals(mTestNetworkForRestrictedConnection.SSID))
                .findAny()
                .orElse(matchingNetworksWithBssid.get(1));

        // Disconnect & disable auto-join on the saved network to prevent auto-connect from
        // interfering with the test.
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> {
                    for (WifiConfiguration savedNetwork : savedNetworks) {
                        mWifiManager.disableNetwork(savedNetwork.networkId);
                    }
                    mWifiManager.disconnect();
                });

        // Wait for Wifi to be disconnected.
        PollingCheck.check(
                ""Wifi not disconnected"",
                20_000,
                () -> mWifiManager.getConnectionInfo().getNetworkId() == -1);
    }

    @After
    public void tearDown() throws Exception {
        // Re-enable networks.
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> {
                    for (WifiConfiguration savedNetwork : mWifiManager.getConfiguredNetworks()) {
                        mWifiManager.enableNetwork(savedNetwork.networkId, false);
                    }
                });
        // Release the requests after the test.
        if (mNetworkCallback != null) {
            mConnectivityManager.unregisterNetworkCallback(mNetworkCallback);
        }
        if (mNsNetworkCallback != null) {
            mConnectivityManager.unregisterNetworkCallback(mNsNetworkCallback);
        }
        mExecutorService.shutdownNow();
        // Clear any existing app state after each test.
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.removeAppState(myUid(), mContext.getPackageName()));
        mTestHelper.turnScreenOff();
    }

    /**
     * Tests the concurrent connection flow.
     * 1. Connect to a network using internet connectivity API.
     * 2. Connect to a network using restricted suggestion API.
     * 3. Verify that both connections are active.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest"	"testConnectToOemPaidSuggestionWhenConnectedToInternetNetwork"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest.java"	""	"public void testConnectToOemPaidSuggestionWhenConnectedToInternetNetwork() throws Exception {
        // First trigger internet connectivity.
        mNetworkCallback = mTestHelper.testConnectionFlowWithConnect(
                mTestNetworkForInternetConnection);

        // Now trigger restricted connection.
        WifiNetworkSuggestion suggestion =
                TestHelper.createSuggestionBuilderWithCredentialFromSavedNetworkWithBssid(
                        mTestNetworkForRestrictedConnection)
                        .setOemPaid(true)
                        .build();
        mNsNetworkCallback = mTestHelper.testConnectionFlowWithSuggestion(
                mTestNetworkForRestrictedConnection, suggestion, mExecutorService,
                Set.of(NET_CAPABILITY_OEM_PAID));

        // Ensure that there are 2 wifi connections available for apps.
        assertThat(mTestHelper.getNumWifiConnections()).isEqualTo(2);
    }

    /**
     * Tests the concurrent connection flow.
     * 1. Connect to a network using restricted suggestion API.
     * 2. Connect to a network using internet connectivity API.
     * 3. Verify that both connections are active.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest"	"testConnectToInternetNetworkWhenConnectedToOemPaidSuggestion"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest.java"	""	"public void testConnectToInternetNetworkWhenConnectedToOemPaidSuggestion() throws Exception {
        // First trigger restricted connection.
        WifiNetworkSuggestion suggestion =
                TestHelper.createSuggestionBuilderWithCredentialFromSavedNetworkWithBssid(
                        mTestNetworkForRestrictedConnection)
                        .setOemPaid(true)
                        .build();
        mNsNetworkCallback = mTestHelper.testConnectionFlowWithSuggestion(
                mTestNetworkForRestrictedConnection, suggestion, mExecutorService,
                Set.of(NET_CAPABILITY_OEM_PAID));

        // Now trigger internet connectivity.
        mNetworkCallback = mTestHelper.testConnectionFlowWithConnect(
                mTestNetworkForInternetConnection);

        // Ensure that there are 2 wifi connections available for apps.
        assertThat(mTestHelper.getNumWifiConnections()).isEqualTo(2);
    }

    /**
     * Tests the concurrent connection flow.
     * 1. Connect to a network using internet connectivity API.
     * 2. Connect to a network using restricted suggestion API.
     * 3. Verify that both connections are active.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest"	"testConnectToOemPrivateSuggestionWhenConnectedToInternetNetwork"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest.java"	""	"public void testConnectToOemPrivateSuggestionWhenConnectedToInternetNetwork() throws Exception {
        // First trigger internet connectivity.
        mNetworkCallback = mTestHelper.testConnectionFlowWithConnect(
                mTestNetworkForInternetConnection);

        // Now trigger restricted connection.
        WifiNetworkSuggestion suggestion =
                TestHelper.createSuggestionBuilderWithCredentialFromSavedNetworkWithBssid(
                        mTestNetworkForRestrictedConnection)
                        .setOemPrivate(true)
                        .build();
        mNsNetworkCallback = mTestHelper.testConnectionFlowWithSuggestion(
                mTestNetworkForRestrictedConnection, suggestion, mExecutorService,
                Set.of(NET_CAPABILITY_OEM_PRIVATE));

        // Ensure that there are 2 wifi connections available for apps.
        assertThat(mTestHelper.getNumWifiConnections()).isEqualTo(2);
    }

    /**
     * Tests the concurrent connection flow.
     * 1. Connect to a network using restricted suggestion API.
     * 2. Connect to a network using internet connectivity API.
     * 3. Verify that both connections are active.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest"	"testConnectToInternetNetworkWhenConnectedToOemPrivateSuggestion"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest.java"	""	"public void testConnectToInternetNetworkWhenConnectedToOemPrivateSuggestion() throws Exception {
        // First trigger restricted connection.
        WifiNetworkSuggestion suggestion =
                TestHelper.createSuggestionBuilderWithCredentialFromSavedNetworkWithBssid(
                        mTestNetworkForRestrictedConnection)
                        .setOemPrivate(true)
                        .build();
        mNsNetworkCallback = mTestHelper.testConnectionFlowWithSuggestion(
                mTestNetworkForRestrictedConnection, suggestion, mExecutorService,
                Set.of(NET_CAPABILITY_OEM_PRIVATE));

        // Now trigger internet connectivity.
        mNetworkCallback = mTestHelper.testConnectionFlowWithConnect(
                mTestNetworkForInternetConnection);

        // Ensure that there are 2 wifi connections available for apps.
        assertThat(mTestHelper.getNumWifiConnections()).isEqualTo(2);
    }

    /**
     * Tests the concurrent connection flow.
     * 1. Connect to a network using internet connectivity API.
     * 2. Simulate connection failure to a network using restricted suggestion API & different net
     *    capability (need corresponding net capability requested for platform to connect).
     * 3. Verify that only 1 connection is active.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest"	"testConnectToOemPaidSuggestionFailureWhenConnectedToInternetNetwork"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest.java"	""	"public void testConnectToOemPaidSuggestionFailureWhenConnectedToInternetNetwork()
            throws Exception {
        // First trigger internet connectivity.
        mNetworkCallback = mTestHelper.testConnectionFlowWithConnect(
                mTestNetworkForInternetConnection);

        // Now trigger restricted connection.
        WifiNetworkSuggestion suggestion =
                TestHelper.createSuggestionBuilderWithCredentialFromSavedNetworkWithBssid(
                        mTestNetworkForRestrictedConnection)
                        .setOemPaid(true)
                        .build();
        mNsNetworkCallback = mTestHelper.testConnectionFailureFlowWithSuggestion(
                mTestNetworkForRestrictedConnection, suggestion, mExecutorService,
                Set.of(NET_CAPABILITY_OEM_PRIVATE));

        // Ensure that there is only 1 connection available for apps.
        assertThat(mTestHelper.getNumWifiConnections()).isEqualTo(1);
    }

    /**
     * Tests the concurrent connection flow.
     * 1. Connect to a network using internet connectivity API.
     * 2. Simulate connection failure to a network using restricted suggestion API & different net
     *    capability (need corresponding net capability requested for platform to connect).
     * 3. Verify that only 1 connection is active.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest"	"testConnectToOemPrivateSuggestionFailureWhenConnectedToInternetNetwork"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest.java"	""	"public void testConnectToOemPrivateSuggestionFailureWhenConnectedToInternetNetwork()
            throws Exception {
        // First trigger internet connectivity.
        mNetworkCallback = mTestHelper.testConnectionFlowWithConnect(
                mTestNetworkForInternetConnection);

        // Now trigger restricted connection.
        WifiNetworkSuggestion suggestion =
                TestHelper.createSuggestionBuilderWithCredentialFromSavedNetworkWithBssid(
                        mTestNetworkForRestrictedConnection)
                        .setOemPrivate(true)
                        .build();
        mNsNetworkCallback = mTestHelper.testConnectionFailureFlowWithSuggestion(
                mTestNetworkForRestrictedConnection, suggestion, mExecutorService,
                Set.of(NET_CAPABILITY_OEM_PAID));

        // Ensure that there is only 1 connection available for apps.
        assertThat(mTestHelper.getNumWifiConnections()).isEqualTo(1);
    }

    /**
     * Tests the concurrent connection flow.
     * 1. Connect to a network using internet connectivity API.
     * 2. Simulate connection failure to a restricted network using suggestion API & restricted net
     *    capability (need corresponding restricted bit set in suggestion for platform to connect).
     * 3. Verify that only 1 connection is active.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest"	"testConnectToSuggestionFailureWithOemPaidNetCapabilityWhenConnectedToInternetNetwork"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest.java"	""	"public void
            testConnectToSuggestionFailureWithOemPaidNetCapabilityWhenConnectedToInternetNetwork()
            throws Exception {
        // First trigger internet connectivity.
        mNetworkCallback = mTestHelper.testConnectionFlowWithConnect(
                mTestNetworkForInternetConnection);

        // Now trigger restricted connection.
        WifiNetworkSuggestion suggestion =
                TestHelper.createSuggestionBuilderWithCredentialFromSavedNetworkWithBssid(
                        mTestNetworkForRestrictedConnection)
                        .build();
        mNsNetworkCallback = mTestHelper.testConnectionFailureFlowWithSuggestion(
                mTestNetworkForRestrictedConnection, suggestion, mExecutorService,
                Set.of(NET_CAPABILITY_OEM_PAID));

        // Ensure that there is only 1 connection available for apps.
        assertThat(mTestHelper.getNumWifiConnections()).isEqualTo(1);
    }

    /**
     * Tests the concurrent connection flow.
     * 1. Connect to a network using internet connectivity API.
     * 2. Simulate connection failure to a restricted network using suggestion API & restricted net
     *    capability (need corresponding restricted bit set in suggestion for platform to connect).
     * 3. Verify that only 1 connection is active.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest"	"testConnectToSuggestionFailureWithOemPrivateNetCapabilityWhenConnectedToInternetNetwork"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest.java"	""	"public void
        testConnectToSuggestionFailureWithOemPrivateNetCapabilityWhenConnectedToInternetNetwork()
            throws Exception {
        // First trigger internet connectivity.
        mNetworkCallback = mTestHelper.testConnectionFlowWithConnect(
                mTestNetworkForInternetConnection);

        // Now trigger restricted connection.
        WifiNetworkSuggestion suggestion =
                TestHelper.createSuggestionBuilderWithCredentialFromSavedNetworkWithBssid(
                        mTestNetworkForRestrictedConnection)
                        .build();
        mNsNetworkCallback = mTestHelper.testConnectionFailureFlowWithSuggestion(
                mTestNetworkForRestrictedConnection, suggestion, mExecutorService,
                Set.of(NET_CAPABILITY_OEM_PRIVATE));

        // Ensure that there is only 1 connection available for apps.
        assertThat(mTestHelper.getNumWifiConnections()).isEqualTo(1);
    }
}"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiFrameworkInitializerTest"	"registerServiceWrappers"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiFrameworkInitializerTest.java"	""	"public void test/*
 *.
 */

package android.net.wifi.cts;

import android.net.wifi.WifiFrameworkInitializer;
import android.test.AndroidTestCase;

public class WifiFrameworkInitializerTest extends WifiJUnit3TestBase {
    /**
     * WifiFrameworkInitializer.registerServiceWrappers() should only be called by
     * SystemServiceRegistry during boot up when Wifi is first initialized. Calling this API at
     * any other time should throw an exception.
     */"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiFrameworkInitializerTest"	"testRegisterServiceWrappers_failsWhenCalledOutsideOfSystemServiceRegistry"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiFrameworkInitializerTest.java"	""	"public void testRegisterServiceWrappers_failsWhenCalledOutsideOfSystemServiceRegistry() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        try {
            WifiFrameworkInitializer.registerServiceWrappers();
            fail(""Expected exception when calling ""
                    + ""WifiFrameworkInitializer.registerServiceWrappers() outside of ""
                    + ""SystemServiceRegistry!"");
        } catch (IllegalStateException expected) {}
    }
}"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.p2p.cts.WifiP2pConfigTest"	"testWifiP2pConfigCopyConstructor"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/p2p/cts/WifiP2pConfigTest.java"	""	"public void testWifiP2pConfigCopyConstructor() {
        WifiP2pConfig config = new WifiP2pConfig.Builder()
                .setNetworkName(TEST_NETWORK_NAME)
                .setPassphrase(TEST_PASSPHRASE)
                .setGroupOperatingBand(TEST_OWNER_BAND)
                .setDeviceAddress(MacAddress.fromString(TEST_DEVICE_ADDRESS))
                .enablePersistentMode(true)
                .build();

        WifiP2pConfig copiedConfig = new WifiP2pConfig(config);

        assertEquals(copiedConfig.deviceAddress, TEST_DEVICE_ADDRESS);
        assertEquals(copiedConfig.getNetworkName(), TEST_NETWORK_NAME);
        assertEquals(copiedConfig.getPassphrase(), TEST_PASSPHRASE);
        assertEquals(copiedConfig.getGroupOwnerBand(), TEST_OWNER_BAND);
        assertEquals(copiedConfig.getNetworkId(), WifiP2pGroup.NETWORK_ID_PERSISTENT);
    }"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.p2p.cts.WifiP2pConfigTest"	"testWifiP2pConfigBuilderForPersist"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/p2p/cts/WifiP2pConfigTest.java"	""	"public void testWifiP2pConfigBuilderForPersist() {
        WifiP2pConfig config = new WifiP2pConfig.Builder()
                .setNetworkName(TEST_NETWORK_NAME)
                .setPassphrase(TEST_PASSPHRASE)
                .setGroupOperatingBand(TEST_OWNER_BAND)
                .setDeviceAddress(MacAddress.fromString(TEST_DEVICE_ADDRESS))
                .enablePersistentMode(true)
                .build();

        assertEquals(config.deviceAddress, TEST_DEVICE_ADDRESS);
        assertEquals(config.getNetworkName(), TEST_NETWORK_NAME);
        assertEquals(config.getPassphrase(), TEST_PASSPHRASE);
        assertEquals(config.getGroupOwnerBand(), TEST_OWNER_BAND);
        assertEquals(config.getNetworkId(), WifiP2pGroup.NETWORK_ID_PERSISTENT);
    }"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"android.net.wifi.p2p.cts.WifiP2pConfigTest"	"testWifiP2pConfigBuilderForNonPersist"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/p2p/cts/WifiP2pConfigTest.java"	""	"public void testWifiP2pConfigBuilderForNonPersist() {
        WifiP2pConfig config = new WifiP2pConfig.Builder()
                .setNetworkName(TEST_NETWORK_NAME)
                .setPassphrase(TEST_PASSPHRASE)
                .setGroupOperatingFrequency(TEST_OWNER_FREQ)
                .setDeviceAddress(MacAddress.fromString(TEST_DEVICE_ADDRESS))
                .enablePersistentMode(false)
                .build();

        assertEquals(config.deviceAddress, TEST_DEVICE_ADDRESS);
        assertEquals(config.getNetworkName(), TEST_NETWORK_NAME);
        assertEquals(config.getPassphrase(), TEST_PASSPHRASE);
        assertEquals(config.getGroupOwnerBand(), TEST_OWNER_FREQ);
        assertEquals(config.getNetworkId(), WifiP2pGroup.NETWORK_ID_TEMPORARY);
    }
}"	""	""	"wifi"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-8"	"7.4.2.4/C-1-8"	"07040204.670108"	"""C-1-8] MUST support user control of provisioning through the Wi-Fi picker."""	""	""	"view picker passpoint wifi button"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.wifiaware.testcase.DataPathInBandTestCase"	"executeTest"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/wifiaware/testcase/DataPathInBandTestCase.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.wifiaware.testcase;

import static com.android.cts.verifier.wifiaware.CallbackUtils.CALLBACK_TIMEOUT_SEC;

import android.content.Context;
import android.net.ConnectivityManager;
import android.net.Network;
import android.net.NetworkCapabilities;
import android.net.NetworkRequest;
import android.net.wifi.aware.PublishDiscoverySession;
import android.net.wifi.aware.WifiAwareNetworkInfo;
import android.net.wifi.aware.WifiAwareNetworkSpecifier;
import android.util.Log;
import android.util.Pair;

import com.android.cts.verifier.R;
import com.android.cts.verifier.wifiaware.CallbackUtils;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.Inet6Address;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.Arrays;

/**
 * Test case for data-path, in-band test cases:
 * open/passphrase * solicited/unsolicited * publish/subscribe.
 *
 * Subscribe test sequence:
 * 1. Attach
 *    wait for results (session)
 * 2. Subscribe
 *    wait for results (subscribe session)
 * 3. Wait for discovery (possibly with ranging)
 * 4. Send message
 *    Wait for success
 * 5. Wait for rx message
 * 6. Request network
 *    Wait for network
 * 7. Create socket and bind to server
 * 8. Send/receive data to validate connection
 * 9. Destroy session
 *
 * Publish test sequence:
 * 1. Attach
 *    wait for results (session)
 * 2. Publish
 *    wait for results (publish session)
 * 3. Wait for rx message
 * 4. Start a ServerSocket
 * 5. Request network
 * 6. Send message
 *    Wait for success
 * 7. Wait for network
 * 8. Receive/Send data to validate connection
 * 9. Destroy session
 */
public class DataPathInBandTestCase extends DiscoveryBaseTestCase {
    private static final String TAG = ""DataPathInBandTestCase"";
    private static final boolean DBG = true;

    private static final byte[] MSG_PUB_TO_SUB = ""Ready"".getBytes();
    private static final String PASSPHRASE = ""Some super secret password"";
    private static final byte[] PMK = ""01234567890123456789012345678901"".getBytes();

    private static final byte[] MSG_CLIENT_TO_SERVER = ""GET SOME BYTES"".getBytes();
    private static final byte[] MSG_SERVER_TO_CLIENT = ""PUT SOME OTHER BYTES"".getBytes();

    private boolean mIsSecurityOpen;
    private boolean mUsePmk;
    private boolean mIsPublish;
    private boolean mIsAcceptAny;
    private Thread mClientServerThread;
    private ConnectivityManager mCm;
    private CallbackUtils.NetworkCb mNetworkCb;

    private static int sSDKLevel = android.os.Build.VERSION.SDK_INT;

    public DataPathInBandTestCase(Context context, boolean isSecurityOpen, boolean isPublish,
            boolean isUnsolicited, boolean usePmk, boolean acceptAny) {
        super(context, isUnsolicited, false);

        mIsSecurityOpen = isSecurityOpen;
        mUsePmk = usePmk;
        mIsPublish = isPublish;
        mIsAcceptAny = acceptAny;
    }

    @Override
    protected boolean executeTest() throws InterruptedException {
        if (DBG) {
            Log.d(TAG,
                    ""executeTest: mIsSecurityOpen="" + mIsSecurityOpen + "", mIsPublish="" + mIsPublish
                            + "", mIsUnsolicited="" + mIsUnsolicited);
        }

        mCm = (ConnectivityManager) mContext.getSystemService(Context.CONNECTIVITY_SERVICE);
        mClientServerThread = null;
        mNetworkCb = null;

        boolean success;
        if (mIsPublish) {
            success = executeTestPublisher();
        } else {
            success = executeTestSubscriber();
        }
        if (!success) {
            return false;
        }

        // destroy session
        mWifiAwareDiscoverySession.close();
        mWifiAwareDiscoverySession = null;

        mListener.onTestMsgReceived(mContext.getString(R.string.aware_status_lifecycle_ok));
        return true;
    }

    @Override
    protected void tearDown() {
        if (mClientServerThread != null) {
            mClientServerThread.interrupt();
        }
        if (mNetworkCb != null) {
            mCm.unregisterNetworkCallback(mNetworkCb);
        }
        super.tearDown();
    }


    private boolean executeTestSubscriber() throws InterruptedException {
        if (DBG) Log.d(TAG, ""executeTestSubscriber"");
        if (!executeSubscribe()) {
            return false;
        }

        // 5. wait to receive message
        CallbackUtils.DiscoveryCb.CallbackData callbackData = mDiscoveryCb.waitForCallbacks(
                CallbackUtils.DiscoveryCb.ON_MESSAGE_RECEIVED);
        switch (callbackData.callback) {
            case CallbackUtils.DiscoveryCb.TIMEOUT:
                setFailureReason(mContext.getString(R.string.aware_status_receive_timeout));
                Log.e(TAG, ""executeTestSubscriber: receive message TIMEOUT"");
                return false;
        }
        mListener.onTestMsgReceived(mContext.getString(R.string.aware_status_received));
        if (DBG) Log.d(TAG, ""executeTestSubscriber: received message"");

        //    validate that received the expected message
        if (!Arrays.equals(MSG_PUB_TO_SUB, callbackData.serviceSpecificInfo)) {
            setFailureReason(mContext.getString(R.string.aware_status_receive_failure));
            Log.e(TAG, ""executeTestSubscriber: receive message message content mismatch: rx='""
                    + new String(callbackData.serviceSpecificInfo) + ""'"");
            return false;
        }

        // 6. request network
        WifiAwareNetworkSpecifier.Builder nsBuilder =
                new WifiAwareNetworkSpecifier.Builder(mWifiAwareDiscoverySession, mPeerHandle);
        if (!mIsSecurityOpen) {
            if (mUsePmk) {
                nsBuilder.setPmk(PMK);
            } else {
                nsBuilder.setPskPassphrase(PASSPHRASE);
            }
        }
        NetworkRequest nr = new NetworkRequest.Builder().addTransportType(
                NetworkCapabilities.TRANSPORT_WIFI_AWARE).setNetworkSpecifier(
                nsBuilder.build()).build();
        mNetworkCb = new CallbackUtils.NetworkCb();
        mCm.requestNetwork(nr, mNetworkCb, CALLBACK_TIMEOUT_SEC * 1000);
        mListener.onTestMsgReceived(
                mContext.getString(R.string.aware_status_network_requested));
        if (DBG) Log.d(TAG, ""executeTestSubscriber: requested network"");

        // 7. wait for network
        Pair<Network, NetworkCapabilities> info = mNetworkCb.waitForNetworkCapabilities();
        if (info == null) {
            setFailureReason(mContext.getString(R.string.aware_status_network_failed));
            Log.e(TAG, ""executeTestSubscriber: network request rejected or timed-out"");
            return false;
        }
        if (info.first == null || info.second == null) {
            setFailureReason(mContext.getString(R.string.aware_status_network_failed));
            Log.e(TAG, ""executeTestSubscriber: received a null Network or NetworkCapabilities!?"");
            return false;
        }
        if (sSDKLevel <= android.os.Build.VERSION_CODES.P) {
            if (info.second.getNetworkSpecifier() != null) {
                setFailureReason(mContext.getString(R.string.aware_status_network_failed_leak));
                Log.e(TAG, ""executeTestSubscriber: network request accepted - but leaks NS!"");
                return false;
            }
        }

        mListener.onTestMsgReceived(mContext.getString(R.string.aware_status_network_success));
        if (DBG) Log.d(TAG, ""executeTestSubscriber: network request granted - AVAILABLE"");

        if (!mIsSecurityOpen) {
            if (!(info.second.getTransportInfo() instanceof WifiAwareNetworkInfo)) {
                setFailureReason(mContext.getString(R.string.aware_status_network_failed));
                Log.e(TAG, ""executeTestSubscriber: did not get WifiAwareNetworkInfo from peer!?"");
                return false;
            }
            WifiAwareNetworkInfo peerAwareInfo =
                    (WifiAwareNetworkInfo) info.second.getTransportInfo();
            Inet6Address peerIpv6 = peerAwareInfo.getPeerIpv6Addr();
            int peerPort = peerAwareInfo.getPort();
            int peerTransportProtocol = peerAwareInfo.getTransportProtocol();
            mListener.onTestMsgReceived(
                    mContext.getString(R.string.aware_status_socket_server_info_rx,
                            peerIpv6.toString(),
                            peerPort));
            if (DBG) {
                Log.d(TAG,
                        ""executeTestPublisher: rx peer info IPv6="" + peerIpv6 + "", port="" + peerPort
                                + "", transportProtocol="" + peerTransportProtocol);
            }
            if (peerTransportProtocol != 6) { // 6 == TCP: hard coded at peer
                setFailureReason(mContext.getString(R.string.aware_status_network_failed));
                Log.e(TAG, ""executeTestSubscriber: Got incorrect transport protocol from peer"");
                return false;
            }
            if (peerPort <= 0) {
                setFailureReason(mContext.getString(R.string.aware_status_network_failed));
                Log.e(TAG, ""executeTestSubscriber: Got invalid port from peer (<=0)"");
                return false;
            }

            // 8. send/receive - can happen inline here - no need for another thread
            String currentMethod = """";
            try {
                currentMethod = ""createSocket"";
                Socket socket = info.first.getSocketFactory().createSocket(peerIpv6, peerPort);

                // simple interaction: write X bytes, read Y bytes
                currentMethod = ""getOutputStream()"";
                OutputStream os = socket.getOutputStream();
                currentMethod = ""write()"";
                os.write(MSG_CLIENT_TO_SERVER, 0, MSG_CLIENT_TO_SERVER.length);

                byte[] buffer = new byte[1024];
                currentMethod = ""getInputStream()"";
                InputStream is = socket.getInputStream();
                currentMethod = ""read()"";
                int numBytes = is.read(buffer, 0, MSG_SERVER_TO_CLIENT.length);

                mListener.onTestMsgReceived(
                        mContext.getString(R.string.aware_status_socket_server_message_from_peer,
                                new String(buffer, 0, numBytes)));

                if (numBytes != MSG_SERVER_TO_CLIENT.length) {
                    setFailureReason(mContext.getString(R.string.aware_status_socket_failure));
                    Log.e(TAG,
                            ""executeTestSubscriber: didn't read expected number of bytes - only ""
                                    + ""got -- "" + numBytes);
                    return false;
                }
                if (!Arrays.equals(MSG_SERVER_TO_CLIENT,
                        Arrays.copyOf(buffer, MSG_SERVER_TO_CLIENT.length))) {
                    setFailureReason(mContext.getString(R.string.aware_status_socket_failure));
                    Log.e(TAG, ""executeTestSubscriber: did not get expected message from server."");
                    return false;
                }
                // Sleep 3 second for transmit and receive.
                Thread.sleep(3000);
                currentMethod = ""close()"";
                os.close();
            } catch (IOException e) {
                setFailureReason(mContext.getString(R.string.aware_status_socket_failure));
                Log.e(TAG, ""executeTestSubscriber: failure while executing "" + currentMethod);
                return false;
            }
        }

        return true;
    }

    private boolean executeTestPublisher() throws InterruptedException {
        if (DBG) Log.d(TAG, ""executeTestPublisher"");
        if (!executePublish()) {
            return false;
        }

        // 4. create a ServerSocket
        int port = 0;
        if (!mIsSecurityOpen) {
            ServerSocket server;
            try {
                server = new ServerSocket(0);
            } catch (IOException e) {
                setFailureReason(
                        mContext.getString(R.string.aware_status_socket_failure));
                Log.e(TAG, ""executeTestPublisher: failure creating a ServerSocket -- "" + e);
                return false;
            }
            port = server.getLocalPort();
            mListener.onTestMsgReceived(
                    mContext.getString(R.string.aware_status_socket_server_socket_started, port));
            if (DBG) Log.d(TAG, ""executeTestPublisher: server socket started on port="" + port);

            // accept connections on the server socket - has to be done in a separate thread!
            mClientServerThread = new Thread(() -> {
                String currentMethod = """";

                try {
                    currentMethod = ""accept()"";
                    Socket socket = server.accept();
                    currentMethod = ""getInputStream()"";
                    InputStream is = socket.getInputStream();

                    // simple interaction: read X bytes, write Y bytes
                    byte[] buffer = new byte[1024];
                    currentMethod = ""read()"";
                    int numBytes = is.read(buffer, 0, MSG_CLIENT_TO_SERVER.length);

                    mListener.onTestMsgReceived(mContext.getString(
                            R.string.aware_status_socket_server_message_from_peer,
                            new String(buffer, 0, numBytes)));

                    if (numBytes != MSG_CLIENT_TO_SERVER.length) {
                        setFailureReason(mContext.getString(R.string.aware_status_socket_failure));
                        Log.e(TAG,
                                ""executeTestPublisher: didn't read expected number of bytes - only ""
                                        + ""got -- "" + numBytes);
                        return;
                    }
                    if (!Arrays.equals(MSG_CLIENT_TO_SERVER,
                            Arrays.copyOf(buffer, MSG_CLIENT_TO_SERVER.length))) {
                        setFailureReason(mContext.getString(R.string.aware_status_socket_failure));
                        Log.e(TAG,
                                ""executeTestPublisher: did not get expected message from client."");
                        return;
                    }

                    currentMethod = ""getOutputStream()"";
                    OutputStream os = socket.getOutputStream();
                    currentMethod = ""write()"";
                    os.write(MSG_SERVER_TO_CLIENT, 0, MSG_SERVER_TO_CLIENT.length);
                    // Sleep 3 second for transmit and receive.
                    Thread.sleep(3000);
                    currentMethod = ""close()"";
                    os.close();
                } catch (IOException | InterruptedException e) {
                    setFailureReason(mContext.getString(R.string.aware_status_socket_failure));
                    Log.e(TAG, ""executeTestPublisher: failure while executing "" + currentMethod);
                    return;
                }
            });
            mClientServerThread.start();
        }

        // 5. Request network
        WifiAwareNetworkSpecifier.Builder nsBuilder;
        if (mIsAcceptAny) {
            nsBuilder = new WifiAwareNetworkSpecifier
                    .Builder((PublishDiscoverySession) mWifiAwareDiscoverySession);
        } else {
            nsBuilder = new WifiAwareNetworkSpecifier
                    .Builder(mWifiAwareDiscoverySession, mPeerHandle);
        }
        if (!mIsSecurityOpen) {
            if (mUsePmk) {
                nsBuilder.setPmk(PMK);
            } else {
                nsBuilder.setPskPassphrase(PASSPHRASE);
            }
            nsBuilder.setPort(port).setTransportProtocol(6); // 6 == TCP
        }
        NetworkRequest nr = new NetworkRequest.Builder().addTransportType(
                NetworkCapabilities.TRANSPORT_WIFI_AWARE).setNetworkSpecifier(
                nsBuilder.build()).build();
        mNetworkCb = new CallbackUtils.NetworkCb();
        mCm.requestNetwork(nr, mNetworkCb, CALLBACK_TIMEOUT_SEC * 1000);
        mListener.onTestMsgReceived(
                mContext.getString(R.string.aware_status_network_requested));
        if (DBG) Log.d(TAG, ""executeTestPublisher: requested network"");

        // 6. send message & wait for send status
        mWifiAwareDiscoverySession.sendMessage(mPeerHandle, MESSAGE_ID, MSG_PUB_TO_SUB);
        CallbackUtils.DiscoveryCb.CallbackData callbackData = mDiscoveryCb.waitForCallbacks(
                CallbackUtils.DiscoveryCb.ON_MESSAGE_SEND_SUCCEEDED
                        | CallbackUtils.DiscoveryCb.ON_MESSAGE_SEND_FAILED);
        switch (callbackData.callback) {
            case CallbackUtils.DiscoveryCb.TIMEOUT:
                setFailureReason(mContext.getString(R.string.aware_status_send_timeout));
                Log.e(TAG, ""executeTestPublisher: send message TIMEOUT"");
                return false;
            case CallbackUtils.DiscoveryCb.ON_MESSAGE_SEND_FAILED:
                setFailureReason(mContext.getString(R.string.aware_status_send_failed));
                Log.e(TAG, ""executeTestPublisher: send message ON_MESSAGE_SEND_FAILED"");
                return false;
        }
        mListener.onTestMsgReceived(mContext.getString(R.string.aware_status_send_success));
        if (DBG) Log.d(TAG, ""executeTestPublisher: send message succeeded"");

        if (callbackData.messageId != MESSAGE_ID) {
            setFailureReason(mContext.getString(R.string.aware_status_send_fail_parameter));
            Log.e(TAG, ""executeTestPublisher: send message succeeded but message ID mismatch : ""
                    + callbackData.messageId);
            return false;
        }

        // 7. wait for network
        Pair<Network, NetworkCapabilities> info = mNetworkCb.waitForNetworkCapabilities();
        if (info == null) {
            setFailureReason(mContext.getString(R.string.aware_status_network_failed));
            Log.e(TAG, ""executeTestPublisher: request network rejected - ON_UNAVAILABLE"");
            return false;
        }
        if (info.first == null || info.second == null) {
            setFailureReason(mContext.getString(R.string.aware_status_network_failed));
            Log.e(TAG, ""executeTestPublisher: received a null Network or NetworkCapabilities!?"");
            return false;
        }
        if (sSDKLevel <= android.os.Build.VERSION_CODES.P) {
            if (info.second.getNetworkSpecifier() != null) {
                setFailureReason(mContext.getString(R.string.aware_status_network_failed_leak));
                Log.e(TAG, ""executeTestSubscriber: network request accepted - but leaks NS!"");
                return false;
            }
        }
        mListener.onTestMsgReceived(mContext.getString(R.string.aware_status_network_success));
        if (DBG) Log.d(TAG, ""executeTestPublisher: network request granted - AVAILABLE"");

        // 8. Send/Receive data to validate connection - happens on thread above
        if (!mIsSecurityOpen) {
            mClientServerThread.join(CALLBACK_TIMEOUT_SEC * 1000);
            if (mClientServerThread.isAlive()) {
                setFailureReason(mContext.getString(R.string.aware_status_socket_failure));
                Log.e(TAG,
                        ""executeTestPublisher: failure while waiting for client-server thread to ""
                                + ""finish"");
                return false;
            }
        }

        return true;
    }
}"	""	""	"wifi wifi"	""	""	""	""	""	""	""	""	""	""
