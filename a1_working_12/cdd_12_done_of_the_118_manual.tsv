"Section"	"section_id"	"req_id"	"full_key"	"key_as_number"	"requirement"	"Test Availability"	"search_roots"	"search_terms"	"manual_search_terms"	"not_search_terms"	"not_files"	"max_matches"	"class_defs"	"methods"	"modules"	"protected"	"class_def"	"method"	"module"	"file_name"	"matched_files"	"methods_string"	"urls"	"method_text"	"matched_terms"	"qualified_method"	"Annotation?"	"New Req for S?"	"New CTS for S?"	"Comment(internal) e.g. why a test is not possible"	"CTS Bug Id"	"CDD Bug Id"	"Area"	"Shortened"	"Test Level"
"3.2.3.5  Conditional Application Intents"	"3.2.3.5"	"C-2-6"	"3.2.3.5/C-2-6"	"03020305.670206"	"""C-2-6] MUST honor the [android.intent.action.SENDTO](https://developer.android.com/reference/android/content/Intent#ACTION_SENDTO) and [android.intent.action.VIEW](https://developer.android.com/reference/android/content/Intent#ACTION_VIEW) intents and provide an activity to send/display SMS messages. """	Test Incomplete, Manually testable	""	""	""	""	""	""	""	""	""	""	"android.telephony.cts.CellBroadcastIntentsTest"	"testGetIntentForBackgroundReceivers"	"CtsTelephonyTestCases"	""	""	""	""	""	""	""	""	""	""	Though the intent is tested. The requirement says an activity should be launched so user should see the SMS message and be able to send an SMS this is not tested. This could be manually tested.	"TBD"	""	""	""	""
"3.2.3.5  Conditional Application Intents"	"3.2.3.5"	"C-7-1"	"3.2.3.5/C-7-1"	"03020305.670701"	"""C-7-1] MUST provide a user-accessible mechanism to add and configure third-party input methods in response to the [`android.settings.INPUT_METHOD_SETTINGS`](https://developer.android.com/reference/android/provider/Settings#ACTION_INPUT_METHOD_SETTINGS) intent.  If device implementations support third-party accessibility services, they:  """	Test Incomplete, Manually Testable	""	""	""	""	""	""	""	""	""	""	"android.systemintents.cts.TestSystemIntents"	"getPackageManager"	"CtsSystemIntentTestCases"	""	""	""	""	""	""	""	""	""	""	"Though the intent is tested. The requirement says the user can change to a third party input device. This could be manually tested, but a true end to end test would require a hardware HID."	Maybe saw this test in CTS try again before filing.	""	""	""	""
"3.2.3.5  Conditional Application Intents"	"3.2.3.5"	"C-9-1"	"3.2.3.5/C-9-1"	"03020305.670901"	"""C-9-1] MUST implement the [Settings#ACTION_PROCESS_WIFI_EASY_CONNECT_URI](https://developer.android.com/reference/android/provider/Settings.html#ACTION_PROCESS_WIFI_EASY_CONNECT_URI) Intent APIs as described in the SDK documentation.  If device implementations provide the data saver mode, they: """	Test Available	""	"Settings.html ACTION_PROCESS_WIFI_EASY_CONNECT_URI"	""	""	""	""	""	""	""	""	"android.content.cts.AvailableIntentsTest"	"testEasyConnectIntent"	"CtsContentTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/AvailableIntentsTest.java"	""	"public void testEasyConnectIntent() {
        // Android only supports Initiator-... modes right now, which require the device to
        // have a QR-code capture mechanism. Therefore this feature does not make sense on
        // non-handheld devices.
        if (!isHandheld()) {
            return;
        }
        WifiManager manager = mContext.getSystemService(WifiManager.class);

        if (manager.isEasyConnectSupported()) {
            Intent intent = new Intent(Settings.ACTION_PROCESS_WIFI_EASY_CONNECT_URI);
            intent.setData(Uri.parse(QRCODE));
            assertCanBeHandled(intent);
        }
    }"	""	""	"ACTION_PROCESS_WIFI_EASY_CONNECT_URI"	""	""	""	""	""	""	""	""	""	""
3.2.3.5  Conditional Application Intents	3.2.3.5	C-8-1	3.2.3.5/C-8-1	03020305.670801	"""C-8-1] MUST honor the [`android.settings.ACCESSIBILITY_SETTINGS`](https://developer.android.com/reference/android/provider/Settings#ACTION_ACCESSIBILITY_SETTINGS) intent to provide a user-accessible mechanism to enable and disable the third-party accessibility services alongside the preloaded accessibility services.  If device implementations include support for Wi-Fi Easy Connect and expose the functionality to third-party apps, they:  """	Test Available	""	android.settings.ACCESSIBILITY ACCESSIBILITY_SETTINGS ACTION_ACCESSIBILITY_SETTINGS	""	""	""	""	""	""	""	""	android.accessibilityservice.cts.AccessibilitySettingsTest	testAccessibilitySettingsIntentHandled	CtsAccessibilityServiceTestCases	/home/gpoor/cts-12-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilitySettingsTest.java	""	"public void testAccessibilitySettingsIntentHandled() throws Throwable {
        PackageManager packageManager = getContext().getPackageManager();
        Intent intent = new Intent(Settings.ACTION_ACCESSIBILITY_SETTINGS);
        List<ResolveInfo> resolvedActivities = packageManager.queryIntentActivities(intent,
                PackageManager.MATCH_DEFAULT_ONLY);

        // make sure accessibility settings exist
        String message = ""Accessibility settings activity must be launched via Intent "" +
                ""Settings.ACTION_ACCESSIBILITY_SETTINGS"";
        assertTrue(message, !resolvedActivities.isEmpty());
    }
}"	""	""	ACCESSIBILITY_SETTINGS	""	""	""	""	""	""	""	""	""	""
3.2.3.5  Conditional Application Intents	3.2.3.5	C-6-1	3.2.3.5/C-6-1	03020305.670601	"""C-6-1] MUST implement an activity that would respond to the intent [`ACTION_NOTIFICATION_POLICY_ACCESS_SETTINGS`](https://developer.android.com/reference/android/provider/Settings#ACTION_NOTIFICATION_POLICY_ACCESS_SETTINGS), which for implementations with UI_MODE_TYPE_NORMAL it MUST be an activity where the user can grant or deny the app access to DND policy configurations.  If device implementations allow users to use third-party input methods on the device, they:  """	Test Available, incomplete	""	DND ACTION_NOTIFICATION_POLICY_ACCESS_SETTINGS MODE_TYPE_NORMAL	""	DND MODE_TYPE_NORMAL	""	""	""	""	""	""	android.systemintents.cts.TestSystemIntents	testSystemIntents	CtsSystemIntentTestCases	[('/home/gpoor/cts-12-source/cts/tests/tests/systemintents/src/android/systemintents/cts/TestSystemIntents.java', 1)]	[('(1,ACTION_NOTIFICATION_POLICY_ACCESS_SETTINGS,/android/systemintents/cts/TestSystemIntents.java)', 1)]	[('([1:/android/systemintents/cts/TestSystemIntents.java]:[ACTION_NOTIFICATION_POLICY_ACCESS_SETTINGS]:[1]:method_text:[etInstrumentation().getContext();        mPackageManager = mContext.getPackageManager();    }   ])', 1)]	https://developer.android.com	""	[('ACTION_NOTIFICATION_POLICY_ACCESS_SETTINGS', 1)]	""	""	""	""	Though the intent is tested. The requirement says an activity should be launched so the user can grant or deny the app access to DND policy	""	""	""	""	""
3.2.3.5  Conditional Application Intents	3.2.3.5	C-3-2	3.2.3.5/C-3-2	03020305.670302	"""C-3-2] MUST honor [android.nfc.cardemulation.action.ACTION_CHANGE_DEFAULT](https://developer.android.com/reference/android/nfc/cardemulation/CardEmulation#ACTION_CHANGE_DEFAULT) intent to show an activity which opens a dialog to ask the user to change the default card emulation service for a certain category as described in the SDK.  If device implementations report `android.hardware.nfc`, they:  """	Test Missing	""	ACTION_CHANGE_DEFAULT android.hardware.nfc android.nfc.cardemulation.action.ACTION	""	DND	""	""	[('android.content.cts.AvailableIntentsTest', 2)]	""	[('CtsContentTestCases', 2)]	""	android.content.cts.AvailableIntentsTest	""	CtsContentTestCases	[('/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/AvailableIntentsTest.java', 2)]	[('(2,ACTION_CHANGE_DEFAULT,/android/content/cts/AvailableIntentsTest.java)', 1)]	[('([1:/android/content/cts/AvailableIntentsTest.java]:[ACTION_CHANGE_DEFAULT]:[1]:method_text:[   assertCanBeHandled(new Intent(Telephony.Sms.Intents.ACTION_CHANGE_DEFAULT));        }    }   ])', 1), ('([1:/android/content/cts/AvailableIntentsTest.java]:[ACTION_CHANGE_DEFAULT]:[1]:method_text:[   assertCanBeHandled(new Intent(TelecomManager.ACTION_CHANGE_DEFAULT_DIALER));        }    }   ])', 1)]	https://developer.android.com	""	[('ACTION_CHANGE_DEFAULT', 2)]	[('[android.content.cts.AvailableIntentsTest testChangeDefaultSmsApplication CtsContentTestCases]', 1), ('[android.content.cts.AvailableIntentsTest testChangeDefaultDialer CtsContentTestCases]', 1)]	""	""	""	Test seems to be missing, for NFC handler change, though it is there for SMS and Dialer.	TBD	""	""	""	""
3.2.3.5  Conditional Application Intents	3.2.3.5	C-5-2	3.2.3.5/C-5-2	03020305.670502	"""C-5-2] MUST honor the [‘android.bluetooth.adapter.action.REQUEST_DISCOVERABLE’](https://developer.android.com/reference/android/bluetooth/BluetoothAdapter#ACTION_REQUEST_DISCOVERABLE) intent and show a system activity that requests discoverable mode.  If device implementations support the DND feature, they:  """	Test Available	""	REQUEST_DISCOVERABLE ACTION_REQUEST_DISCOVERABLE android.bluetooth.adapter.action.REQUEST	""	""	""	""	""	""	""	""	com.android.cts.verifier.bluetooth.ConnectionAccessServerActivity	setPassFailButtonClickListeners	""	/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/bluetooth/ConnectionAccessServerActivity.java	""	"public void test/*
 *.
 */

package com.android.cts.verifier.bluetooth;

import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;

import android.app.AlertDialog;
import android.bluetooth.BluetoothAdapter;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.provider.Settings;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.Window;
import android.widget.Button;
import android.widget.TextView;
import android.widget.Toast;

public class ConnectionAccessServerActivity extends PassFailButtons.Activity {

    private static final String ACTION_CONNECTION_ACCESS_REQUEST =
            ""android.bluetooth.device.action.CONNECTION_ACCESS_REQUEST"";

    private static final int ENABLE_BLUETOOTH_REQUEST = 1;

    private BluetoothAdapter mBluetoothAdapter;
    private ConnectionAccessRequestReceiver mConnectionAccessRequestReceiver;
    private BluetoothChatService mChatService;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);
        setContentView(R.layout.bt_connection_access);
        setInfoResources(R.string.bt_connection_access_server,
                R.string.bt_connection_access_server_info, 0);
        setPassFailButtonClickListeners();
        getPassButton().setEnabled(false);

        View settings = findViewById(R.id.bt_settings);
        settings.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View view) {
                startActivity(new Intent(Settings.ACTION_BLUETOOTH_SETTINGS));
            }
        });

        Button makeDiscoverableButton = (Button) findViewById(R.id.bt_make_discoverable_button);
        makeDiscoverableButton.setVisibility(View.VISIBLE);
        makeDiscoverableButton.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                makeDiscoverable();
            }
        });

        mConnectionAccessRequestReceiver = new ConnectionAccessRequestReceiver();
        IntentFilter intentFilter = new IntentFilter(ACTION_CONNECTION_ACCESS_REQUEST);
        registerReceiver(mConnectionAccessRequestReceiver, intentFilter);

        mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
        if (mBluetoothAdapter.isEnabled()) {
            startChatService();
        } else {
            Intent intent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);
            startActivityForResult(intent, ENABLE_BLUETOOTH_REQUEST);
        }
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        switch (requestCode) {
            case ENABLE_BLUETOOTH_REQUEST:
                if (resultCode == RESULT_OK) {
                    startChatService();
                } else {
                    setResult(RESULT_CANCELED);
                    finish();
                }
                break;
        }
    }

    private void startChatService() {
        mChatService = new BluetoothChatService(this, new ChatHandler(),
                BluetoothChatService.HANDSFREE_INSECURE_UUID);
        boolean secure = false;
        mChatService.start(secure);
    }

    private void makeDiscoverable() {
        if (mBluetoothAdapter.getScanMode() !=
                BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE) {
            Intent intent = new Intent(BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE);
            intent.putExtra(BluetoothAdapter.EXTRA_DISCOVERABLE_DURATION, 30);
            startActivity(intent);
        }
    }

    private class ChatHandler extends Handler {
        @Override
        public void handleMessage(Message msg) {
            super.handleMessage(msg);
            switch (msg.what) {
                case BluetoothChatService.MESSAGE_STATE_CHANGE:
                    handleStateChange(msg);
                    break;

                case BluetoothChatService.MESSAGE_TOAST:
                    handleToast(msg);
                    break;
            }
        }
    }

    private void handleStateChange(Message msg) {
        int state = msg.arg1;
        switch (state) {
            case BluetoothChatService.STATE_LISTEN:
                setProgressBarIndeterminateVisibility(true);
                Toast.makeText(this, R.string.bt_listening, Toast.LENGTH_SHORT).show();
                break;
        }
    }

    private void handleToast(Message msg) {
        String toast = msg.getData().getString(BluetoothChatService.TOAST);
        Toast.makeText(this, toast, Toast.LENGTH_LONG).show();
    }

    class ConnectionAccessRequestReceiver extends BroadcastReceiver {
        @Override
        public void onReceive(Context context, Intent intent) {
            new AlertDialog.Builder(ConnectionAccessServerActivity.this)
                    .setMessage(R.string.bt_ca_dialog)
                    .setPositiveButton(android.R.string.ok, new DialogInterface.OnClickListener() {
                        @Override
                        public void onClick(DialogInterface dialog, int which) {
                            getPassButton().setEnabled(true);
                        }
                    })
                    .setNegativeButton(android.R.string.cancel,
                            new DialogInterface.OnClickListener() {
                        @Override
                        public void onClick(DialogInterface dialog, int which) {
                            getPassButton().setEnabled(false);
                        }
                    })
                    .show();
        }
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        if (mChatService != null) {
            mChatService.stop();
        }
        unregisterReceiver(mConnectionAccessRequestReceiver);
    }
}"	""	""	REQUEST_DISCOVERABLE	""	""	""	""	Though maybe not targeted at this requirement it seems to test it fully.	""	""	""	""	""
3.2.3.5  Conditional Application Intents	3.2.3.5	C-5-1	3.2.3.5/C-5-1	03020305.670501	"""C-5-1] MUST honor the [‘android.bluetooth.adapter.action.REQUEST_ENABLE’](https://developer.android.com/reference/kotlin/android/bluetooth/BluetoothAdapter#action_request_enable) intent and show a system activity to allow the user to turn on Bluetooth.  """	Test Available	""	android.bluetooth.adapter.action.REQUEST Adapter.ACTION_REQUEST_ENABLE REQUEST_ENABLE	""	""	""	""	""	""	""	""	com.android.cts.verifier.bluetooth.BluetoothToggleActivity	disable	""	/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/bluetooth/BluetoothToggleActivity.java	""	"public void test/*
 *.
 */

package com.android.cts.verifier.bluetooth;

import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;

import android.app.AlertDialog;
import android.app.ProgressDialog;
import android.bluetooth.BluetoothAdapter;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.ToggleButton;

/**
 * Activity for testing that Bluetooth can be disabled and enabled properly. The activity shows
 * a button that toggles Bluetooth by disabling it via {@link BluetoothAdapter#disable()} and
 * enabling it via the Intent action {@link BluetoothAdapter#ACTION_REQUEST_ENABLE}.
 */
public class BluetoothToggleActivity extends PassFailButtons.Activity {

    private static final String TAG = BluetoothToggleActivity.class.getName();

    private static final int START_ENABLE_BLUETOOTH_REQUEST = 1;

    private BluetoothAdapter mBluetoothAdapter;

    private BluetoothBroadcastReceiver mReceiver;

    private ProgressDialog mDisablingDialog;

    private ToggleButton mToggleButton;

    private int mNumDisabledTimes = 0;

    private int mNumEnabledTimes = 0;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.bt_toggle);
        setPassFailButtonClickListeners();

        mReceiver = new BluetoothBroadcastReceiver();
        IntentFilter filter = new IntentFilter(BluetoothAdapter.ACTION_STATE_CHANGED);
        registerReceiver(mReceiver, filter);

        mDisablingDialog = new ProgressDialog(this);
        mDisablingDialog.setMessage(getString(R.string.bt_disabling));

        mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();

        getPassButton().setEnabled(false);

        mToggleButton = (ToggleButton) findViewById(R.id.bt_toggle_button);
        mToggleButton.setChecked(mBluetoothAdapter.isEnabled());
        mToggleButton.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                if (mToggleButton.isChecked()) {
                    enableBluetooth();
                } else {
                    disableBluetooth();
                }
            }
        });
    }

    private void enableBluetooth() {
        mDisablingDialog.dismiss();
        mToggleButton.setEnabled(false);
        Intent intent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);
        startActivityForResult(intent, START_ENABLE_BLUETOOTH_REQUEST);
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        switch (requestCode) {
            case START_ENABLE_BLUETOOTH_REQUEST:
                boolean enabledBluetooth = RESULT_OK == resultCode;
                mToggleButton.setChecked(enabledBluetooth);
                mToggleButton.setEnabled(true);
                break;
        }
    }

    private void disableBluetooth() {
        mDisablingDialog.show();
        mToggleButton.setEnabled(false);
        if (!mBluetoothAdapter.disable()) {
            mDisablingDialog.dismiss();
            mToggleButton.setEnabled(true);
            new AlertDialog.Builder(this)
                .setIcon(android.R.drawable.ic_dialog_alert)
                .setMessage(R.string.bt_disabling_error)
                .setPositiveButton(android.R.string.ok, null)
                .show();
        }
    }

    class BluetoothBroadcastReceiver extends BroadcastReceiver {
        @Override
        public void onReceive(Context context, Intent intent) {
            int previousState = intent.getIntExtra(BluetoothAdapter.EXTRA_PREVIOUS_STATE, -1);
            int newState = intent.getIntExtra(BluetoothAdapter.EXTRA_STATE, -1);
            Log.i(TAG, ""Previous state: "" + previousState + "" New state: "" + newState);

            if (BluetoothAdapter.STATE_OFF == newState
                    && (BluetoothAdapter.STATE_ON == previousState
                            || BluetoothAdapter.STATE_TURNING_OFF == previousState)) {
                mNumDisabledTimes++;
            }

            if (BluetoothAdapter.STATE_ON == newState
                    && (BluetoothAdapter.STATE_OFF == previousState
                            || BluetoothAdapter.STATE_TURNING_ON == previousState)) {
                mNumEnabledTimes++;
            }

            if (BluetoothAdapter.STATE_OFF == newState) {
                mDisablingDialog.dismiss();
                mToggleButton.setEnabled(true);
            }

            mToggleButton.setChecked(mBluetoothAdapter.isEnabled());
            getPassButton().setEnabled(mNumDisabledTimes > 0 &&  mNumEnabledTimes > 0);
        }
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        unregisterReceiver(mReceiver);
    }
}"	""	""	Adapter.ACTION_REQUEST_ENABLE REQUEST_ENABLE	""	""	""	""	"This is one of the CTS tests, there is a enableBluetooth too, but it is private. For these tests the behavior of the test App must be reverse engineered. There is not a ""testX"" method to find."	""	""	""	""	""