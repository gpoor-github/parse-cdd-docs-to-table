"Section"	"section_id"	"req_id"	"full_key"	"key_as_number"	"requirement"	"Test Availability"	"search_roots"	"search_terms"	"manual_search_terms"	"not_search_terms"	"not_files"	"max_matches"	"class_defs"	"methods"	"modules"	"protected"	"class_def"	"method"	"module"	"file_name"	"matched_files"	"methods_string"	"urls"	"method_text"	"matched_terms"	"qualified_method"	"Annotation?"	"New Req for S?"	"New CTS for S?"	"Comment(internal) e.g. why a test is not possible"	"CTS Bug Id"	"CDD Bug Id"	"Area"	"Shortened"	"Test Level"
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.compatibility.testtype.DalvikTest"	"isFile"	""	"/home/gpoor/cts-12-source/cts/tests/jdwp/runner/host-side/src/com/android/compatibility/testtype/DalvikTest.java"	""	"public void test/*
 *.
 */

package com.android.compatibility.testtype;

import com.android.compatibility.common.tradefed.build.CompatibilityBuildHelper;
import com.android.ddmlib.Log;
import com.android.ddmlib.Log.LogLevel;
import com.android.ddmlib.MultiLineReceiver;
import com.android.tradefed.build.IBuildInfo;
import com.android.tradefed.config.Option;
import com.android.tradefed.config.OptionCopier;
import com.android.tradefed.device.DeviceNotAvailableException;
import com.android.tradefed.device.ITestDevice;
import com.android.tradefed.invoker.TestInformation;
import com.android.tradefed.log.LogUtil.CLog;
import com.android.tradefed.metrics.proto.MetricMeasurement.Metric;
import com.android.tradefed.result.FailureDescription;
import com.android.tradefed.result.ITestInvocationListener;
import com.android.tradefed.result.TestDescription;
import com.android.tradefed.result.proto.TestRecordProto.FailureStatus;
import com.android.tradefed.testtype.IAbi;
import com.android.tradefed.testtype.IAbiReceiver;
import com.android.tradefed.testtype.IBuildReceiver;
import com.android.tradefed.testtype.IDeviceTest;
import com.android.tradefed.testtype.IRemoteTest;
import com.android.tradefed.testtype.IRuntimeHintProvider;
import com.android.tradefed.testtype.IShardableTest;
import com.android.tradefed.testtype.ITestCollector;
import com.android.tradefed.testtype.ITestFileFilterReceiver;
import com.android.tradefed.testtype.ITestFilterReceiver;
import com.android.tradefed.util.AbiUtils;
import com.android.tradefed.util.ArrayUtil;
import com.android.tradefed.util.FileUtil;

import com.google.common.base.Splitter;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.FilenameFilter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import java.util.concurrent.TimeUnit;

import vogar.expect.ExpectationStore;
import vogar.expect.ModeId;

/**
 * A wrapper to run tests against Dalvik.
 */
public class DalvikTest implements IAbiReceiver, IBuildReceiver, IDeviceTest, IRemoteTest,
        IRuntimeHintProvider, IShardableTest, ITestCollector, ITestFileFilterReceiver,
        ITestFilterReceiver {

    private static final String TAG = DalvikTest.class.getSimpleName();

    /**
     * TEST_PACKAGES is a Set containing the names of packages on the classpath known to contain
     * tests to be run under DalvikTest. The TEST_PACKAGES set is used to shard DalvikTest into
     * multiple DalvikTests, each responsible for running one of these packages' tests.
     */
    private static final Set<String> TEST_PACKAGES = new HashSet<>();
    private static final String JDWP_PACKAGE_BASE = ""org.apache.harmony.jpda.tests.jdwp.%s"";
    static {
        // Though uppercase, these are package names, not class names
        TEST_PACKAGES.add(String.format(JDWP_PACKAGE_BASE, ""ArrayReference""));
        TEST_PACKAGES.add(String.format(JDWP_PACKAGE_BASE, ""ArrayType""));
        TEST_PACKAGES.add(String.format(JDWP_PACKAGE_BASE, ""ClassLoaderReference""));
        TEST_PACKAGES.add(String.format(JDWP_PACKAGE_BASE, ""ClassObjectReference""));
        TEST_PACKAGES.add(String.format(JDWP_PACKAGE_BASE, ""ClassType""));
        TEST_PACKAGES.add(String.format(JDWP_PACKAGE_BASE, ""DebuggerOnDemand""));
        TEST_PACKAGES.add(String.format(JDWP_PACKAGE_BASE, ""Deoptimization""));
        TEST_PACKAGES.add(String.format(JDWP_PACKAGE_BASE, ""EventModifiers""));
        TEST_PACKAGES.add(String.format(JDWP_PACKAGE_BASE, ""Events""));
        TEST_PACKAGES.add(String.format(JDWP_PACKAGE_BASE, ""InterfaceType""));
        TEST_PACKAGES.add(String.format(JDWP_PACKAGE_BASE, ""Method""));
        TEST_PACKAGES.add(String.format(JDWP_PACKAGE_BASE, ""MultiSession""));
        TEST_PACKAGES.add(String.format(JDWP_PACKAGE_BASE, ""ObjectReference""));
        TEST_PACKAGES.add(String.format(JDWP_PACKAGE_BASE, ""ReferenceType""));
        TEST_PACKAGES.add(String.format(JDWP_PACKAGE_BASE, ""StackFrame""));
        TEST_PACKAGES.add(String.format(JDWP_PACKAGE_BASE, ""StringReference""));
        TEST_PACKAGES.add(String.format(JDWP_PACKAGE_BASE, ""ThreadGroupReference""));
        TEST_PACKAGES.add(String.format(JDWP_PACKAGE_BASE, ""ThreadReference""));
        TEST_PACKAGES.add(String.format(JDWP_PACKAGE_BASE, ""VirtualMachine""));
    }

    private static final String EXPECTATIONS_EXT = "".expectations"";
    // Command to run the VM, args are bitness, classpath, dalvik-args, abi, runner-args,
    // include and exclude filters, and exclude filters file.
    private static final String COMMAND = ""dalvikvm%s -classpath %s %s ""
            + ""com.android.compatibility.dalvik.DalvikTestRunner --abi=%s %s %s %s %s %s %s"";
    private static final String INCLUDE_FILE = ""/data/local/tmp/dalvik/includes"";
    private static final String EXCLUDE_FILE = ""/data/local/tmp/dalvik/excludes"";
    private static String START_RUN = ""start-run"";
    private static String END_RUN = ""end-run"";
    private static String START_TEST = ""start-test"";
    private static String END_TEST = ""end-test"";
    private static String FAILURE = ""failure"";

    // If we are running with adbconnection jdwp provider (hence a libjdwp agent).
    private boolean mIsAdbConnection = true;

    @Option(name = ""run-name"", description = ""The name to use when reporting results"")
    private String mRunName;

    @Option(name = ""classpath"", description = ""Holds the paths to search when loading tests"")
    private List<String> mClasspath = new ArrayList<>();

    @Option(name = ""dalvik-arg"", description = ""Holds arguments to pass to Dalvik"")
    private List<String> mDalvikArgs = new ArrayList<>();

    @Option(name = ""dalvik-arg-adbconnection"",
            description = ""Holds arguments to pass to Dalvik when "" +
                          ""dalvik.vm.jdwp-provider == adbconnection or default or is empty"")
    private List<String> mDalvikArgsAdbconnection = new ArrayList<>();

    @Option(name = ""dalvik-arg-internal"",
            description = ""Holds arguments to pass to Dalvik only when "" +
                          ""dalvik.vm.jdwp-provider == internal"")
    private List<String> mDalvikArgsInternal = new ArrayList<>();

    @Option(name = ""runner-arg"",
            description = ""Holds arguments to pass to the device-side test runner"")
    private List<String> mRunnerArgs = new ArrayList<>();

    @Option(name = ""include-filter"",
            description = ""The include filters of the test name to run."")
    private Set<String> mIncludeFilters = new LinkedHashSet<>();

    @Option(name = ""exclude-filter"",
            description = ""The exclude filters of the test name to run."")
    private Set<String> mExcludeFilters = new LinkedHashSet<>();

    @Option(name = ""test-file-include-filter"",
            description=""A file containing a list of line separated test classes and optionally""
            + "" methods to include"")
    private File mIncludeTestFile = null;

    @Option(name = ""test-file-exclude-filter"",
            description=""A file containing a list of line separated test classes and optionally""
            + "" methods to exclude"")
    private File mExcludeTestFile = null;

    @Option(name = ""runtime-hint"",
            isTimeVal = true,
            description=""The hint about the test's runtime."")
    private long mRuntimeHint = 60000;// 1 minute

    @Option(name = ""known-failures-adbconnection"",
            description = ""Comma-separated list of files specifying known-failures to be skipped"")
    private String mKnownFailuresAdbconnection;
    @Option(name = ""known-failures-internal"",
            description = ""Comma-separated list of files specifying known-failures to be skipped"")
    private String mKnownFailuresInternal;

    @Option(name = ""known-failures"",
            description = ""Comma-separated list of files specifying known-failures to be skipped"")
    private String mKnownFailures;

    @Option(name = ""collect-tests-only"",
            description = ""Only invoke the instrumentation to collect list of applicable test ""
                    + ""cases. All test run callbacks will be triggered, but test execution will ""
                    + ""not be actually carried out."")
    private boolean mCollectTestsOnly = false;

    @Option(name = ""per-test-timeout"",
            description = ""The maximum amount of time during which the DalvikTestRunner may ""
                    + ""yield no output. Because the runner outputs results for each test, this ""
                    + ""is essentially a per-test timeout"")
    private long mPerTestTimeout = 10; // 10 minutes

    private IAbi mAbi;
    private CompatibilityBuildHelper mBuildHelper;
    private ITestDevice mDevice;

    /**
     * {@inheritDoc}
     */
    @Override
    public void setAbi(IAbi abi) {
        mAbi = abi;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public IAbi getAbi() {
        return mAbi;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void setBuild(IBuildInfo build) {
        mBuildHelper = new CompatibilityBuildHelper(build);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void setDevice(ITestDevice device) {
        mDevice = device;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public ITestDevice getDevice() {
        return mDevice;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void addIncludeFilter(String filter) {
        mIncludeFilters.add(filter);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void addAllIncludeFilters(Set<String> filters) {
        mIncludeFilters.addAll(filters);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void addExcludeFilter(String filter) {
        mExcludeFilters.add(filter);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void addAllExcludeFilters(Set<String> filters) {
        mExcludeFilters.addAll(filters);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Set<String> getIncludeFilters() {
        return mIncludeFilters;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Set<String> getExcludeFilters() {
        return mExcludeFilters;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void clearIncludeFilters() {
        mIncludeFilters.clear();
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void clearExcludeFilters() {
        mExcludeFilters.clear();
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void setIncludeTestFile(File testFile) {
        mIncludeTestFile = testFile;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void setExcludeTestFile(File testFile) {
        mExcludeTestFile = testFile;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public long getRuntimeHint() {
        return mRuntimeHint;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void setCollectTestsOnly(boolean shouldCollectTest) {
        mCollectTestsOnly = shouldCollectTest;
    }

    private static boolean isAdbconnection(ITestDevice device) throws DeviceNotAvailableException {
        String provider = device.getProperty(""dalvik.vm.jdwp-provider"");
        if (provider == null || provider.equals(""default"") || provider.equals(""adbconnection"")) {
            return true;
        } else if (provider.equals(""internal"")) {
            return false;
        } else {
            throw new RuntimeException(""Unknown dalvik.vm.jdwp-provider = "" + provider);
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void run(final TestInformation testInfo, final ITestInvocationListener listener) throws DeviceNotAvailableException {
        String abiName = mAbi.getName();
        String bitness = AbiUtils.getBitness(abiName);
        mIsAdbConnection = isAdbconnection(getDevice());

        File tmpExcludeFile = null;
        String excludeFile = """";
        try {
            // push one file of exclude filters to the device
            tmpExcludeFile = getExcludeFile();
            if (!mDevice.pushFile(tmpExcludeFile, EXCLUDE_FILE)) {
                Log.logAndDisplay(LogLevel.ERROR, TAG, ""Couldn't push file: "" + tmpExcludeFile);
            } else {
                CLog.d(""exclude-filter-file: %s"", safeReadContentFromFile(tmpExcludeFile));
                // If sucessfully pushed then add it as a filter.
                excludeFile = String.format(""--exclude-filter-file=%s"", EXCLUDE_FILE);
            }
        } catch (IOException e) {
            throw new RuntimeException(""Failed to parse expectations"", e);
        } finally {
            FileUtil.deleteFile(tmpExcludeFile);
        }

        // push one file of include filters to the device, if file exists
        String includeFile = """";
        if (mIncludeTestFile != null) {
            String path = mIncludeTestFile.getAbsolutePath();
            if (!mIncludeTestFile.isFile() || !mIncludeTestFile.canRead()) {
                throw new RuntimeException(String.format(""Failed to read include file %s"", path));
            }
            if (!mDevice.pushFile(mIncludeTestFile, INCLUDE_FILE)) {
                Log.logAndDisplay(LogLevel.ERROR, TAG, ""Couldn't push file: "" + path);
            } else {
                CLog.d(""include-filter-file: %s"", safeReadContentFromFile(mIncludeTestFile));
                // If sucessfully pushed then add it as a filter.
                includeFile = String.format(""--include-filter-file=%s"", INCLUDE_FILE);
            }
        }

        if (mIsAdbConnection) {
            Log.logAndDisplay(LogLevel.INFO, TAG, ""Running with ADBConnection/libjdwp agent"");
            mDalvikArgs.addAll(mDalvikArgsAdbconnection);
        } else {
            Log.logAndDisplay(LogLevel.INFO, TAG, ""Running with internal jdwp implementation"");
            mDalvikArgs.addAll(mDalvikArgsInternal);
        }

        // Create command
        mDalvikArgs.add(""-Duser.name=shell"");
        mDalvikArgs.add(""-Duser.language=en"");
        mDalvikArgs.add(""-Duser.region=US"");
        mDalvikArgs.add(""-Xcheck:jni"");
        mDalvikArgs.add(""-Xjnigreflimit:2000"");

        String dalvikArgs = ArrayUtil.join("" "", mDalvikArgs);
        dalvikArgs = dalvikArgs.replace(""|#ABI#|"", bitness);

        String runnerArgs = ArrayUtil.join("" "", mRunnerArgs);
        // Filters
        StringBuilder includeFilters = new StringBuilder();
        if (!mIncludeFilters.isEmpty()) {
            includeFilters.append(""--include-filter="");
            includeFilters.append(ArrayUtil.join("","", mIncludeFilters));
        }
        StringBuilder excludeFilters = new StringBuilder();
        if (!mExcludeFilters.isEmpty()) {
            excludeFilters.append(""--exclude-filter="");
            excludeFilters.append(ArrayUtil.join("","", mExcludeFilters));
        }

        // Communicate with DalvikTestRunner if tests should only be collected
        String collectTestsOnlyString = (mCollectTestsOnly) ? ""--collect-tests-only"" : """";
        final String command = String.format(COMMAND, bitness,
                ArrayUtil.join(File.pathSeparator, mClasspath),
                dalvikArgs, abiName, runnerArgs,
                includeFilters, excludeFilters, includeFile, excludeFile, collectTestsOnlyString);
        Log.logAndDisplay(LogLevel.INFO, TAG, command);
        DalvikOutputParser receiver = new DalvikOutputParser(listener);
        try {
            mDevice.executeShellCommand(command, receiver, mPerTestTimeout, TimeUnit.MINUTES, 1);
        } finally {
            receiver.flush();
            receiver.completeEvents();
        }
    }

    /*
     * Due to known failures, there are typically too many excludes to pass via command line.
     * Collect excludes from .expectation files in the testcases directory, from files in the
     * module's resources directory, and from mExcludeTestFile, if set.
     */
    private File getExcludeFile() throws IOException {
        File excludeFile = null;
        PrintWriter out = null;

        try {
            excludeFile = File.createTempFile(""excludes"", ""txt"");
            out = new PrintWriter(excludeFile);
            // create expectation store from set of expectation files found in testcases dir
            Set<File> expectationFiles = new HashSet<>();
            for (File f : mBuildHelper.getTestsDir().listFiles(
                    new ExpectationFileFilter(mRunName))) {
                expectationFiles.add(f);
            }
            ExpectationStore testsDirStore =
                    ExpectationStore.parse(expectationFiles, ModeId.DEVICE);
            // create expectation store from expectation files found in module resources dir
            ExpectationStore resourceStore = null;
            Set<String> knownFailuresFiles = new HashSet<String>();
            Splitter splitter = Splitter.on(',').trimResults();
            if (mKnownFailures != null) {
                knownFailuresFiles.addAll(splitter.splitToList(mKnownFailures));
            }
            if (mIsAdbConnection && mKnownFailuresAdbconnection != null) {
                knownFailuresFiles.addAll(splitter.splitToList(mKnownFailuresAdbconnection));
            }
            if (!mIsAdbConnection && mKnownFailuresInternal != null) {
                knownFailuresFiles.addAll(splitter.splitToList(mKnownFailuresInternal));
            }
            if (knownFailuresFiles.size() != 0) {
                resourceStore = ExpectationStore.parseResources(
                        getClass(), knownFailuresFiles, ModeId.DEVICE);
            }
            // Add expectations from testcases dir
            for (String exclude : testsDirStore.getAllFailures().keySet()) {
                out.println(exclude);
            }
            for (String exclude : testsDirStore.getAllOutComes().keySet()) {
                out.println(exclude);
            }
            // Add expectations from resources dir
            if (resourceStore != null) {
                for (String exclude : resourceStore.getAllFailures().keySet()) {
                    out.println(exclude);
                }
                for (String exclude : resourceStore.getAllOutComes().keySet()) {
                    out.println(exclude);
                }
            }
            // Add excludes from test-file-exclude-filter option
            for (String exclude : getFiltersFromFile(mExcludeTestFile)) {
                out.println(exclude);
            }
            out.flush();
        } finally {
            if (out != null) {
                out.close();
            }
        }
        return excludeFile;
    }


    /*
     * Helper method that reads filters from a file into a set.
     * Returns an empty set given a null file
     */
    private static Set<String> getFiltersFromFile(File f) throws IOException {
        Set<String> filters = new HashSet<String>();
        if (f != null) {
            BufferedReader reader = new BufferedReader(new FileReader(f));
            String filter = null;
            while ((filter = reader.readLine()) != null) {
                filters.add(filter);
            }
            reader.close();
        }
        return filters;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Collection<IRemoteTest> split() {
        List<IRemoteTest> shards = new ArrayList<>();
        // A DalvikTest to run any tests not contained in packages from TEST_PACKAGES, may be empty
        DalvikTest catchAll = new DalvikTest();
        OptionCopier.copyOptionsNoThrow(this, catchAll);
        catchAll.mAbi = mAbi;
        shards.add(catchAll);
        // estimate catchAll's runtime to be that of a single package in TEST_PACKAGES
        long runtimeHint = mRuntimeHint / TEST_PACKAGES.size();
        catchAll.mRuntimeHint = runtimeHint;
        for (String packageName: TEST_PACKAGES) {
            catchAll.addExcludeFilter(packageName);
            // create one shard for package 'packageName'
            DalvikTest test = new DalvikTest();
            OptionCopier.copyOptionsNoThrow(this, test);
            test.addIncludeFilter(packageName);
            test.mRuntimeHint = runtimeHint / TEST_PACKAGES.size();
            test.mAbi = mAbi;
            shards.add(test);
        }
        // return a shard for each package in TEST_PACKAGE, plus a shard for any other tests
        return shards;
    }

    /**
     * A {@link FilenameFilter} to find all the expectation files in a directory.
     */
    public static class ExpectationFileFilter implements FilenameFilter {

        private String mName;

        public ExpectationFileFilter(String name) {
            mName = name;
        }
        /**
         * {@inheritDoc}
         */
        @Override
        public boolean accept(File dir, String name) {
            return name.startsWith(mName) && name.endsWith(EXPECTATIONS_EXT);
        }
    }

    private String safeReadContentFromFile(File file) {
        try {
            return FileUtil.readStringFromFile(file);
        } catch (IOException e) {
            CLog.e(e);
            return null;
        }
    }

    private class DalvikOutputParser extends MultiLineReceiver {

        private final ITestInvocationListener mListener;
        private TestDescription mTest;
        private Long mStartTime;

        public DalvikOutputParser(ITestInvocationListener listener) {
            this.mListener = listener;
        }

        @Override
        public boolean isCancelled() {
            return false;
        }

        @Override
        public void processNewLines(String[] lines) {
            for (String line : lines) {
                String[] parts = line.split("":"", 2);
                String tag = parts[0];
                if (tag.equals(START_RUN)) {
                    mListener.testRunStarted(mRunName, Integer.parseInt(parts[1]));
                    mStartTime = System.currentTimeMillis();
                } else if (tag.equals(END_RUN)) {
                    mListener.testRunEnded(Integer.parseInt(parts[1]),
                            Collections.<String, String>emptyMap());
                    mStartTime = null;
                } else if (tag.equals(START_TEST)) {
                    mTest = getTestDescription(parts[1]);
                    mListener.testStarted(mTest);
                } else if (tag.equals(FAILURE)) {
                    mListener.testFailed(mTest, processSerializedValue(parts[1]));
                } else if (tag.equals(END_TEST)) {
                    mListener.testEnded(getTestDescription(parts[1]),
                            Collections.<String, String>emptyMap());
                    mTest = null;
                }
                // Always log the output for debugging
                CLog.d(line);
            }
        }

        private String processSerializedValue(String input) {
            // Opposite of stringify.
            return input.replace(""^~^"", ""\n"");
        }

        private TestDescription getTestDescription(String name) {
            String[] parts = name.split(""#"");
            String className = parts[0];
            String testName = """";
            if (parts.length > 1) {
                testName = parts[1];
            }
            return new TestDescription(className, testName);
        }

        /**
         * In case some inconsistent events are left, close them for proper reporting.
         */
        private void completeEvents() {
            if (mTest != null) {
                mListener.testFailed(mTest, ""Test started but no end events received."");
                mListener.testEnded(mTest, new HashMap<String, Metric>());
            }
            if (mStartTime != null) {
                mListener.testRunFailed(
                        FailureDescription.create(""Dalvik test session did not properly terminate."").setFailureStatus(FailureStatus.TEST_FAILURE));
                mListener.testRunEnded(System.currentTimeMillis() - mStartTime, new HashMap<String, Metric>());
            }
        }
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.dumpsys.cts.BatteryStatsDumpsysTest"	"testBatterystatsOutput"	"CtsDumpsysHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/dumpsys/src/android/dumpsys/cts/BatteryStatsDumpsysTest.java"	""	"public void testBatterystatsOutput() throws Exception {
        String batterystats = mDevice.executeShellCommand(""dumpsys batterystats --checkin"");
        assertNotNull(batterystats);
        assertTrue(batterystats.length() > 0);

        Set<String> seenTags = new HashSet<>();

        try (BufferedReader reader = new BufferedReader(
                new StringReader(batterystats))) {

            String line;
            while ((line = reader.readLine()) != null) {
                if (line.isEmpty()) {
                    continue;
                }


                try {
                    // With a default limit of 0, empty strings at the end are discarded.
                    // We still consider the empty string as a valid value in some cases.
                    // Using any negative number for the limit will preserve a trailing empty string.
                    // @see String#split(String, int)
                    String[] parts = line.split("","", -1);
                    assertInteger(parts[0]); // old version
                    assertInteger(parts[1]); // UID
                    switch (parts[2]) { // aggregation type
                        case ""i"":
                        case ""l"":
                        case ""c"":
                        case ""u"":
                            break;
                        default:
                            fail(""malformed stat: "" + parts[2]);
                    }
                    assertNotNull(parts[3]);
                    seenTags.add(parts[3]);

                    // Note the time fields are measured in milliseconds by default.
                    switch (parts[3]) {
                        case ""vers"":
                            checkVersion(parts);
                            break;
                        case ""uid"":
                            checkUid(parts);
                            break;
                        case ""apk"":
                            checkApk(parts);
                            break;
                        case ""pr"":
                            checkProcess(parts);
                            break;
                        case ""sr"":
                            checkSensor(parts);
                            break;
                        case ""vib"":
                            checkVibrator(parts);
                            break;
                        case ""fg"":
                            checkForegroundActivity(parts);
                            break;
                        case ""fgs"":
                            checkForegroundService(parts);
                            break;
                        case ""st"":
                            checkStateTime(parts);
                            break;
                        case ""wl"":
                            checkWakelock(parts);
                            break;
                        case ""awl"":
                            checkAggregatedWakelock(parts);
                            break;
                        case ""sy"":
                            checkSync(parts);
                            break;
                        case ""jb"":
                            checkJob(parts);
                            break;
                        case ""jbc"":
                            checkJobCompletion(parts);
                            break;
                        case ""jbd"":
                            checkJobsDeferred(parts);
                            break;
                        case ""kwl"":
                            checkKernelWakelock(parts);
                            break;
                        case ""wr"":
                            checkWakeupReason(parts);
                            break;
                        case ""nt"":
                            checkNetwork(parts);
                            break;
                        case ""ua"":
                            checkUserActivity(parts);
                            break;
                        case ""bt"":
                            checkBattery(parts);
                            break;
                        case ""dc"":
                            checkBatteryDischarge(parts);
                            break;
                        case ""lv"":
                            checkBatteryLevel(parts);
                            break;
                        case ""wfl"":
                            checkWifi(parts);
                            break;
                        case ""m"":
                            checkMisc(parts);
                            break;
                        case ""gn"":
                            checkGlobalNetwork(parts);
                            break;
                        case ""br"":
                            checkScreenBrightness(parts);
                            break;
                        case ""sgt"":
                        case ""sgc"":
                            checkSignalStrength(parts);
                            break;
                        case ""sst"":
                            checkSignalScanningTime(parts);
                            break;
                        case ""dct"":
                        case ""dcc"":
                            checkDataConnection(parts);
                            break;
                        case ""wst"":
                        case ""wsc"":
                            checkWifiState(parts);
                            break;
                        case ""wsst"":
                        case ""wssc"":
                            checkWifiSupplState(parts);
                            break;
                        case ""wsgt"":
                        case ""wsgc"":
                            checkWifiSignalStrength(parts);
                            break;
                        case ""bst"":
                        case ""bsc"":
                            checkBluetoothState(parts);
                            break;
                        case ""blem"":
                            checkBluetoothMisc(parts);
                            break;
                        case ""pws"":
                            checkPowerUseSummary(parts);
                            break;
                        case ""pwi"":
                            checkPowerUseItem(parts);
                            break;
                        case ""dsd"":
                        case ""csd"":
                            checkChargeDischargeStep(parts);
                            break;
                        case ""dtr"":
                            checkDischargeTimeRemain(parts);
                            break;
                        case ""ctr"":
                            checkChargeTimeRemain(parts);
                            break;
                        case ""cpu"":
                            checkUidCpuUsage(parts);
                            break;
                        default:
                            break;
                    }
                } catch (AssertionError e) {
                    CLog.e(""Assert fail for line <"" + line + "">"");
                    throw e;
                }
            }
        }

        // spot check a few tags
        assertSeenTag(seenTags, ""vers"");
        assertSeenTag(seenTags, ""bt"");
        assertSeenTag(seenTags, ""dc"");
        assertSeenTag(seenTags, ""m"");
    }

    private void checkVersion(String[] parts) {
        assertEquals(8, parts.length);
        assertInteger(parts[4]); // checkinVersion
        assertInteger(parts[5]); // parcelVersion
        assertNotNull(parts[6]); // startPlatformVersion
        assertNotNull(parts[7]); // endPlatformVersion
    }

    private void checkUid(String[] parts) {
        assertEquals(6, parts.length);
        assertInteger(parts[4]); // uid
        assertNotNull(parts[5]); // pkgName
    }

    private void checkApk(String[] parts) {
        assertEquals(10, parts.length);
        long wakeup_count = assertInteger(parts[4]); // wakeups
        assertNotNull(parts[5]); // apk
        assertNotNull(parts[6]); // service
        assertInteger(parts[7]); // startTime
        assertInteger(parts[8]); // starts
        assertInteger(parts[9]); // launches

        // Validation check.
        assertTrue(""wakeup count must be >= 0"", wakeup_count >= 0);
    }

    private void checkProcess(String[] parts) {
        assertTrue(parts.length >= 9);
        assertNotNull(parts[4]); // process
        assertInteger(parts[5]); // userMillis
        assertInteger(parts[6]); // systemMillis
        assertInteger(parts[7]); // foregroundMillis
        assertInteger(parts[8]); // starts
    }

    private void checkSensor(String[] parts) {
        assertEquals(10, parts.length);
        assertInteger(parts[4]); // sensorNumber
        assertInteger(parts[5]); // totalTime
        assertInteger(parts[6]); // count
        assertInteger(parts[7]); // backgroundCount
        assertInteger(parts[8]); // actualTime
        assertInteger(parts[9]); // backgroundActualTime
    }

    private void checkVibrator(String[] parts) {
        assertEquals(6, parts.length);
        assertInteger(parts[4]); // totalTime
        assertInteger(parts[5]); // count
    }

    private void checkForegroundActivity(String[] parts) {
        assertEquals(6, parts.length);
        assertInteger(parts[4]); // totalTime
        assertInteger(parts[5]); // count
    }

    private void checkForegroundService(String[] parts) {
        assertEquals(6, parts.length);
        assertInteger(parts[4]); // totalTime
        assertInteger(parts[5]); // count
    }

    private void checkStateTime(String[] parts) {
        assertEquals(11, parts.length);
        assertInteger(parts[4]);  // top
        assertInteger(parts[5]);  // foreground_service
        assertInteger(parts[6]);  // foreground
        assertInteger(parts[7]);  // background
        assertInteger(parts[8]);  // top_sleeping
        assertInteger(parts[9]);  // heavy_weight
        assertInteger(parts[10]); // cached
    }

    private void checkWakelock(String[] parts) {
        assertEquals(29, parts.length);
        assertNotNull(parts[4]);      // wakelock

        assertInteger(parts[5]);      // full totalTime
        assertEquals(""f"", parts[6]);  // full
        long full_count = assertInteger(parts[7]);      // full count
        assertInteger(parts[8]);      // current duration
        assertInteger(parts[9]);      // max duration
        assertInteger(parts[10]);     // total duration

        assertInteger(parts[11]);      // partial totalTime
        assertEquals(""p"", parts[12]);  // partial
        long partial_count = assertInteger(parts[13]);     // partial count
        assertInteger(parts[14]);      // current duration
        assertInteger(parts[15]);      // max duration
        assertInteger(parts[16]);      // total duration

        assertInteger(parts[17]);      // background partial totalTime
        assertEquals(""bp"", parts[18]); // background partial
        long bg_partial_count = assertInteger(parts[19]);     // background partial count
        assertInteger(parts[20]);      // current duration
        assertInteger(parts[21]);      // max duration
        assertInteger(parts[22]);      // total duration

        assertInteger(parts[23]);      // window totalTime
        assertEquals(""w"", parts[24]);  // window
        long window_count = assertInteger(parts[25]);     // window count
        assertInteger(parts[26]);      // current duration
        assertInteger(parts[27]);      // max duration
        assertInteger(parts[28]);      // total duration

        // Validation checks.
        assertTrue(""full wakelock count must be >= 0"", full_count >= 0);
        assertTrue(""partial wakelock count must be >= 0"", partial_count >= 0);
        assertTrue(""background partial wakelock count must be >= 0"", bg_partial_count >= 0);
        assertTrue(""window wakelock count must be >= 0"", window_count >= 0);
    }

    private void checkAggregatedWakelock(String[] parts) {
        assertEquals(6, parts.length);
        assertInteger(parts[4]); // total time
        assertInteger(parts[5]); // background time
    }

    private void checkSync(String[] parts) {
        assertEquals(9, parts.length);
        assertNotNull(parts[4]); // sync
        assertInteger(parts[5]); // totalTime
        assertInteger(parts[6]); // count
        assertInteger(parts[7]); // bgTime
        assertInteger(parts[8]); // bgCount
    }

    private void checkJob(String[] parts) {
        assertEquals(9, parts.length);
        assertNotNull(parts[4]); // job
        assertInteger(parts[5]); // totalTime
        assertInteger(parts[6]); // count
        assertInteger(parts[7]); // bgTime
        assertInteger(parts[8]); // bgCount
    }

    private void checkJobCompletion(String[] parts) {
        // This line contains a number for each job cancel reason.
        // (See JobParameters.JOB_STOP_REASON_CODES), and future mainline updates may introudce
        // more codes, so we have no upper bound for the number of columns.
        assertThat(parts.length).isAtLeast(11);
        assertNotNull(parts[4]); // job

        // Values for each of JOB_STOP_REASON_CODES.
        for (int i = 5; i < parts.length; i++) {
            assertInteger(parts[i]);
        }
    }

    private void checkJobsDeferred(String[] parts) {
        assertEquals(12, parts.length);
        assertInteger(parts[4]); // jobsDeferredEventCount
        assertInteger(parts[5]); // jobsDeferredCount
        assertInteger(parts[6]); // totalLatencyMillis
        assertInteger(parts[7]); // count at latency < 1 hr
        assertInteger(parts[8]); // count at latency 1-2 hrs
        assertInteger(parts[9]); // count at latency 2-4 hrs
        assertInteger(parts[10]); // count at latency 4-8 hrs
        assertInteger(parts[11]); // count at latency 8+ hrs
    }

    private void checkKernelWakelock(String[] parts) {
        assertTrue(parts.length >= 7);
 assertNotNull(parts[4]); // Kernel wakelock
 assertInteger(parts[parts.length-2]); // totalTime
        assertInteger(parts[parts.length-1]); // count
    }

    private void checkWakeupReason(String[] parts) {
        assertTrue(parts.length >= 7);
        for (int i = 4; i < parts.length-2; i++) {
            assertNotNull(parts[i]); // part of wakeup
        }
        assertInteger(parts[parts.length-2]); // totalTime
        assertInteger(parts[parts.length-1]); // count
    }

    private void checkNetwork(String[] parts) {
        assertEquals(26, parts.length);
        long mbRx = assertInteger(parts[4]);  // mobileBytesRx
        long mbTx = assertInteger(parts[5]);  // mobileBytesTx
        long wbRx = assertInteger(parts[6]);  // wifiBytesRx
        long wbTx = assertInteger(parts[7]);  // wifiBytesTx
        long mpRx = assertInteger(parts[8]);  // mobilePacketsRx
        long mpTx = assertInteger(parts[9]);  // mobilePacketsTx
        long wpRx = assertInteger(parts[10]); // wifiPacketsRx
        long wpTx = assertInteger(parts[11]); // wifiPacketsTx
        assertInteger(parts[12]); // mobileActiveTime (usec)
        assertInteger(parts[13]); // mobileActiveCount
        assertInteger(parts[14]); // btBytesRx
        assertInteger(parts[15]); // btBytesTx
        assertInteger(parts[16]); // mobileWakeup
        assertInteger(parts[17]); // wifiWakeup
        long mbBgRx = assertInteger(parts[18]);  // mobileBytesRx
        long mbBgTx = assertInteger(parts[19]);  // mobileBytesTx
        long wbBgRx = assertInteger(parts[20]);  // wifiBytesRx
        long wbBgTx = assertInteger(parts[21]);  // wifiBytesTx
        long mpBgRx = assertInteger(parts[22]);  // mobilePacketsRx
        long mpBgTx = assertInteger(parts[23]);  // mobilePacketsTx
        long wpBgRx = assertInteger(parts[24]); // wifiPacketsRx
        long wpBgTx = assertInteger(parts[25]); // wifiPacketsTx

        // Assuming each packet contains some bytes, bytes >= packets >= 0.
        assertTrue(""mobileBytesRx must be >= mobilePacketsRx"", mbRx >= mpRx);
        assertTrue(""mobilePacketsRx must be >= 0"", mpRx >= 0);
        assertTrue(""mobileBytesTx must be >= mobilePacketsTx"", mbTx >= mpTx);
        assertTrue(""mobilePacketsTx must be >= 0"", mpTx >= 0);
        assertTrue(""wifiBytesRx must be >= wifiPacketsRx"", wbRx >= wpRx);
        assertTrue(""wifiPacketsRx must be >= 0"", wpRx >= 0);
        assertTrue(""wifiBytesTx must be >= wifiPacketsTx"", wbTx >= wpTx);
        assertTrue(""wifiPacketsTx must be >= 0"", wpTx >= 0);
        // Totals should be greater than or equal to background data numbers
        assertTrue(""mobileBytesRx must be >= mobileBytesBgRx"", mbRx >= mbBgRx);
        assertTrue(""mobilePacketsRx must be >= mobilePacketsBgRx"", mpRx >= mpBgRx);
        assertTrue(""mobileBytesTx must be >= mobileBytesBgTx"", mbTx >= mbBgTx);
        assertTrue(""mobilePacketsTx must be >= mobilePacketsBgTx"", mpTx >= mpBgTx);
        assertTrue(""wifiBytesRx must be >= wifiBytesBgRx"", wbRx >= wbBgRx);
        assertTrue(""wifiPacketsRx must be >= wifiPacketsBgRx"", wpRx >= wpBgRx);
        assertTrue(""wifiBytesTx must be >= wifiBytesBgTx"", wbTx >= wbBgTx);
        assertTrue(""wifiPacketsTx must be >= wifiPacketsBgTx"", wpTx >= wpBgTx);
    }

    private void checkUserActivity(String[] parts) {
        assertEquals(9, parts.length);
        assertInteger(parts[4]); // other
        assertInteger(parts[5]); // button
        assertInteger(parts[6]); // touch
        assertInteger(parts[7]); // accessibility
        assertInteger(parts[8]); // attention
    }

    private void checkBattery(String[] parts) {
        assertEquals(16, parts.length);
        if (!parts[4].equals(""N/A"")) {
            assertInteger(parts[4]);  // startCount
        }
        long bReal = assertInteger(parts[5]);  // batteryRealtime
        long bUp = assertInteger(parts[6]);  // batteryUptime
        long tReal = assertInteger(parts[7]);  // totalRealtime
        long tUp = assertInteger(parts[8]);  // totalUptime
        assertInteger(parts[9]);  // startClockTime
        long bOffReal = assertInteger(parts[10]); // batteryScreenOffRealtime
        long bOffUp = assertInteger(parts[11]); // batteryScreenOffUptime
        long bEstCap = assertInteger(parts[12]); // batteryEstimatedCapacity
        assertInteger(parts[13]); // minLearnedBatteryCapacity
        assertInteger(parts[14]); // maxLearnedBatteryCapacity
        long bDoze = assertInteger(parts[15]); // screenDozeTime

        // The device cannot be up more than there are real-world seconds.
        assertTrue(""batteryRealtime must be >= batteryUptime"", bReal >= bUp);
        assertTrue(""totalRealtime must be >= totalUptime"", tReal >= tUp);
        assertTrue(""batteryScreenOffRealtime must be >= batteryScreenOffUptime"",
                bOffReal >= bOffUp);

        // total >= battery >= battery screen-off >= 0
        assertTrue(""totalRealtime must be >= batteryRealtime"", tReal >= bReal);
        assertTrue(""batteryRealtime must be >= batteryScreenOffRealtime"", bReal >= bOffReal);
        assertTrue(""batteryScreenOffRealtime must be >= 0"", bOffReal >= 0);
        assertTrue(""totalUptime must be >= batteryUptime"", tUp >= bUp);
        assertTrue(""batteryUptime must be >= batteryScreenOffUptime"", bUp >= bOffUp);
        assertTrue(""batteryScreenOffUptime must be >= 0"", bOffUp >= 0);
        assertTrue(""batteryEstimatedCapacity must be >= 0"", bEstCap >= 0);
        assertTrue(""screenDozeTime must be >= 0"", bDoze >= 0);
        assertTrue(""screenDozeTime must be <= batteryScreenOffRealtime"", bDoze <= bOffReal);
    }

    private void checkBatteryDischarge(String[] parts) {
        assertEquals(14, parts.length);
        assertInteger(parts[4]); // low
        assertInteger(parts[5]); // high
        assertInteger(parts[6]); // screenOn
        assertInteger(parts[7]); // screenOff
        assertInteger(parts[8]); // dischargeMah
        assertInteger(parts[9]); // dischargeScreenOffMah
        assertInteger(parts[10]); // dischargeDozeCount
        assertInteger(parts[11]); // dischargeDozeMah
        assertInteger(parts[12]); // dischargeLightDozeMah
        assertInteger(parts[13]); // dischargeDeepDozeMah
    }

    private void checkBatteryLevel(String[] parts) {
        assertEquals(6, parts.length);
        assertInteger(parts[4]); // startLevel
        assertInteger(parts[5]); // currentLevel
    }

    private void checkWifi(String[] parts) {
        assertEquals(14, parts.length);
        assertInteger(parts[4]); // fullWifiLockOnTime (usec)
        assertInteger(parts[5]); // wifiScanTime (usec)
        assertInteger(parts[6]); // uidWifiRunningTime (usec)
        assertInteger(parts[7]); // wifiScanCount
        // Fields for parts[8 and 9 and 10] are deprecated.
        assertInteger(parts[11]); // wifiScanCountBg
        assertInteger(parts[12]); // wifiScanActualTimeMs (msec)
        assertInteger(parts[13]); // wifiScanActualTimeMsBg (msec)
    }

    private void checkMisc(String[] parts) {
        assertTrue(parts.length >= 19);
        assertInteger(parts[4]);      // screenOnTime
        assertInteger(parts[5]);      // phoneOnTime
        assertInteger(parts[6]);      // fullWakeLockTimeTotal
        assertInteger(parts[7]);      // partialWakeLockTimeTotal
        assertInteger(parts[8]);      // mobileRadioActiveTime
        assertInteger(parts[9]);      // mobileRadioActiveAdjustedTime
        assertInteger(parts[10]);     // interactiveTime
        assertInteger(parts[11]);     // lowPowerModeEnabledTime
        assertInteger(parts[12]);     // connChanges
        assertInteger(parts[13]);     // deviceIdleModeEnabledTime
        assertInteger(parts[14]);     // deviceIdleModeEnabledCount
        assertInteger(parts[15]);     // deviceIdlingTime
        assertInteger(parts[16]);     // deviceIdlingCount
        assertInteger(parts[17]);     // mobileRadioActiveCount
        assertInteger(parts[18]);     // mobileRadioActiveUnknownTime
    }

    private void checkGlobalNetwork(String[] parts) {
        assertEquals(14, parts.length);
        assertInteger(parts[4]);  // mobileRxTotalBytes
        assertInteger(parts[5]);  // mobileTxTotalBytes
        assertInteger(parts[6]);  // wifiRxTotalBytes
        assertInteger(parts[7]);  // wifiTxTotalBytes
        assertInteger(parts[8]);  // mobileRxTotalPackets
        assertInteger(parts[9]);  // mobileTxTotalPackets
        assertInteger(parts[10]); // wifiRxTotalPackets
        assertInteger(parts[11]); // wifiTxTotalPackets
        assertInteger(parts[12]); // btRxTotalBytes
        assertInteger(parts[13]); // btTxTotalBytes
    }

    private void checkScreenBrightness(String[] parts) {
        assertEquals(9, parts.length);
        assertInteger(parts[4]); // dark
        assertInteger(parts[5]); // dim
        assertInteger(parts[6]); // medium
        assertInteger(parts[7]); // light
        assertInteger(parts[8]); // bright
    }

    private void checkSignalStrength(String[] parts) {
        assertTrue(parts.length >= 9);
        assertInteger(parts[4]); // none
        assertInteger(parts[5]); // poor
        assertInteger(parts[6]); // moderate
        assertInteger(parts[7]); // good
        assertInteger(parts[8]); // great
    }

    private void checkSignalScanningTime(String[] parts) {
        assertEquals(5, parts.length);
        assertInteger(parts[4]); // signalScanningTime
    }

    private void checkDataConnection(String[] parts) {
        assertEquals(27, parts.length);
        assertInteger(parts[4]);  // none
        assertInteger(parts[5]);  // gprs
        assertInteger(parts[6]);  // edge
        assertInteger(parts[7]);  // umts
        assertInteger(parts[8]);  // cdma
        assertInteger(parts[9]);  // evdo_0
        assertInteger(parts[10]); // evdo_A
        assertInteger(parts[11]); // 1xrtt
        assertInteger(parts[12]); // hsdpa
        assertInteger(parts[13]); // hsupa
        assertInteger(parts[14]); // hspa
        assertInteger(parts[15]); // iden
        assertInteger(parts[16]); // evdo_b
        assertInteger(parts[17]); // lte
        assertInteger(parts[18]); // ehrpd
        assertInteger(parts[19]); // hspap
        assertInteger(parts[20]); // gsm
        assertInteger(parts[21]); // td_scdma
        assertInteger(parts[22]); // iwlan
        assertInteger(parts[23]); // lte_ca
        assertInteger(parts[24]); // nr
        assertInteger(parts[25]); // emngcy
        assertInteger(parts[26]); // other
    }

    private void checkWifiState(String[] parts) {
        assertEquals(12, parts.length);
        assertInteger(parts[4]);  // off
        assertInteger(parts[5]);  // scanning
        assertInteger(parts[6]);  // no_net
        assertInteger(parts[7]);  // disconn
        assertInteger(parts[8]);  // sta
        assertInteger(parts[9]);  // p2p
        assertInteger(parts[10]); // sta_p2p
        assertInteger(parts[11]); // soft_ap
    }

    private void checkWifiSupplState(String[] parts) {
        assertEquals(17, parts.length);
        assertInteger(parts[4]);  // inv
        assertInteger(parts[5]);  // dsc
        assertInteger(parts[6]);  // dis
        assertInteger(parts[7]);  // inact
        assertInteger(parts[8]);  // scan
        assertInteger(parts[9]);  // auth
        assertInteger(parts[10]); // ascing
        assertInteger(parts[11]); // asced
        assertInteger(parts[12]); // 4-way
        assertInteger(parts[13]); // group
        assertInteger(parts[14]); // compl
        assertInteger(parts[15]); // dorm
        assertInteger(parts[16]); // uninit
    }

    private void checkWifiSignalStrength(String[] parts) {
        assertEquals(9, parts.length);
        assertInteger(parts[4]); // none
        assertInteger(parts[5]); // poor
        assertInteger(parts[6]); // moderate
        assertInteger(parts[7]); // good
        assertInteger(parts[8]); // great
    }

    private void checkBluetoothState(String[] parts) {
        assertEquals(8, parts.length);
        assertInteger(parts[4]); // inactive
        assertInteger(parts[5]); // low
        assertInteger(parts[6]); // med
        assertInteger(parts[7]); // high
    }

    private void checkPowerUseSummary(String[] parts) {
        assertEquals(8, parts.length);
        assertDouble(parts[4]); // batteryCapacity
        assertDouble(parts[5]); // computedPower
        assertDouble(parts[6]); // minDrainedPower
        assertDouble(parts[7]); // maxDrainedPower
    }

    private void checkPowerUseItem(String[] parts) {
        assertEquals(9, parts.length);
        assertNotNull(parts[4]); // label
        final double totalPowerMah = assertDouble(parts[5]);  // totalPowerMah
        final long shouldHide = assertInteger(parts[6]);  // shouldHide (0 or 1)
        final double screenPowerMah = assertDouble(parts[7]);  // screenPowerMah
        final double proportionalSmearMah = assertDouble(parts[8]);  // proportionalSmearMah

        assertTrue(""powerUseItem totalPowerMah must be >= 0"", totalPowerMah >= 0);
        assertTrue(""powerUseItem screenPowerMah must be >= 0"", screenPowerMah >= 0);
        assertTrue(""powerUseItem proportionalSmearMah must be >= 0"", proportionalSmearMah >= 0);
        assertTrue(""powerUseItem shouldHide must be 0 or 1"", shouldHide == 0 || shouldHide == 1);

        // Largest current Android battery is ~5K. 100K shouldn't get made for a while.
        assertTrue(""powerUseItem totalPowerMah is expected to be <= 100000"", totalPowerMah <= 100000);
    }

    private void checkChargeDischargeStep(String[] parts) {
        assertEquals(9, parts.length);
        assertInteger(parts[4]); // duration
        if (!parts[5].equals(""?"")) {
            assertInteger(parts[5]); // level
        }
        assertNotNull(parts[6]); // screen
        assertNotNull(parts[7]); // power-save
        assertNotNull(parts[8]); // device-idle
    }

    private void checkDischargeTimeRemain(String[] parts) {
        assertEquals(5, parts.length);
        assertInteger(parts[4]); // batteryTimeRemaining
    }

    private void checkChargeTimeRemain(String[] parts) {
        assertEquals(5, parts.length);
        assertInteger(parts[4]); // chargeTimeRemaining
    }

    private void checkUidCpuUsage(String[] parts) {
        assertTrue(parts.length >= 6);
        assertInteger(parts[4]); // user time
        assertInteger(parts[5]); // system time
    }

    private void checkBluetoothMisc(String[] parts) {
        assertEquals(15, parts.length);
        assertInteger(parts[4]); // totalTime
        assertInteger(parts[5]); // count
        assertInteger(parts[6]); // countBg
        assertInteger(parts[7]); // actualTime
        assertInteger(parts[8]); // actualTimeBg
        assertInteger(parts[9]); // resultsCount
        assertInteger(parts[10]); // resultsCountBg
        assertInteger(parts[11]); // unoptimizedScanTotalTime
        assertInteger(parts[12]); // unoptimizedScanTotalTimeBg
        assertInteger(parts[13]); // unoptimizedScanMaxTime
        assertInteger(parts[14]); // unoptimizedScanMaxTimeBg
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.os.cts.AsyncTaskTest"	"testCancelWithInterrupt"	""	"/home/gpoor/cts-12-source/cts/tests/tests/os/src/android/os/cts/AsyncTaskTest.java"	""	"public void testCancelWithInterrupt() throws Throwable {
        startAsyncTask();
        Thread.sleep(COMPUTE_TIME / 2);
        assertTrue(mMyAsyncTask.cancel(true));
        // already cancelled
        assertFalse(mMyAsyncTask.cancel(true));
        Thread.sleep(DURATION);
        assertTrue(mMyAsyncTask.isCancelled());
        assertTrue(mMyAsyncTask.isOnCancelledCalled);
        assertNotNull(mMyAsyncTask.exception);
        assertTrue(mMyAsyncTask.exception instanceof InterruptedException);
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.os.cts.AsyncTaskTest"	"testCancel"	""	"/home/gpoor/cts-12-source/cts/tests/tests/os/src/android/os/cts/AsyncTaskTest.java"	""	"public void testCancel() throws Throwable {
        startAsyncTask();
        Thread.sleep(COMPUTE_TIME / 2);
        assertTrue(mMyAsyncTask.cancel(false));
        // already cancelled
        assertFalse(mMyAsyncTask.cancel(false));
        Thread.sleep(DURATION);
        assertTrue(mMyAsyncTask.isCancelled());
        assertTrue(mMyAsyncTask.isOnCancelledCalled);
        assertNull(mMyAsyncTask.exception);
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.os.cts.AsyncTaskTest"	"testCancelTooLate"	""	"/home/gpoor/cts-12-source/cts/tests/tests/os/src/android/os/cts/AsyncTaskTest.java"	""	"public void testCancelTooLate() throws Throwable {
        startAsyncTask();
        Thread.sleep(DURATION);
        assertFalse(mMyAsyncTask.cancel(false));
        assertTrue(mMyAsyncTask.isCancelled());
        assertFalse(mMyAsyncTask.isOnCancelledCalled);
        assertNull(mMyAsyncTask.exception);
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.readexternalstorageapp.ReadMultiViewTest"	"testFolderSetup"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/ReadExternalStorageApp/src/com/android/cts/readexternalstorageapp/ReadMultiViewTest.java"	""	"public void testFolderSetup() throws Exception {
        final File ourCache = getContext().getExternalCacheDir();
        final File ourTestDir = new File(ourCache, ""testDir"");
        final File ourFile = new File(ourTestDir, ""test.probe"");

        ourFile.getParentFile().mkdirs();
        assertTrue(ourFile.createNewFile());
    }

    /**
     * Verify that we have R/W access to test.probe in our cache.
     */"	""	""	"probe"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.readexternalstorageapp.ReadMultiViewTest"	"testRWAccess"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/ReadExternalStorageApp/src/com/android/cts/readexternalstorageapp/ReadMultiViewTest.java"	""	"public void testRWAccess() throws Exception {
        final File ourCache = getContext().getExternalCacheDir();
        final File ourTestDir = new File(ourCache, ""testDir"");
        final File testFile = new File(ourTestDir, ""test.probe"");

        assertFileReadWriteAccess(testFile);
        assertEquals(Os.getuid(), Os.stat(ourCache.getAbsolutePath()).st_uid);
        assertEquals(Os.getuid(), Os.stat(ourTestDir.getAbsolutePath()).st_uid);
        assertEquals(Os.getuid(), Os.stat(testFile.getAbsolutePath()).st_uid);
    }
}"	""	""	"probe"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.audio.MidiNativeTestActivity"	"MidiNativeTestActivity"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/audio/MidiNativeTestActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.audio;

import java.io.IOException;

import android.media.midi.MidiDevice;
import android.media.midi.MidiDeviceInfo;
import android.media.midi.MidiManager;
import android.media.midi.MidiReceiver;
import android.os.Bundle;
import android.util.Log;

import com.android.cts.verifier.audio.midilib.MidiIODevice;
import com.android.cts.verifier.audio.midilib.NativeMidiManager;
import com.android.cts.verifier.R;

/*
 * A note about the USB MIDI device.
 * Any USB MIDI peripheral with standard female DIN jacks can be used. A standard MIDI cable
 * plugged into both input and output is required for the USB Loopback Test. A Bluetooth MIDI
 * device like the Yamaha MD-BT01 plugged into both input and output is required for the
 * Bluetooth Loopback test.
 */

/*
 * A note about the ""virtual MIDI"" device...
 * See file MidiEchoService for implementation of the echo server itself.
 * This service is started by the main manifest file (AndroidManifest.xml).
 */

/*
 * A note about Bluetooth MIDI devices...
 * Any Bluetooth MIDI device needs to be paired with the DUT with the ""MIDI+BTLE"" application
 * available in the Play Store:
 * (https://play.google.com/store/apps/details?id=com.mobileer.example.midibtlepairing).
 */

/**
 * CTS Verifier Activity for MIDI test
 */
public class MidiNativeTestActivity extends MidiTestActivityBase {
    private static final String TAG = ""MidiNativeTestActivity"";
    private static final boolean DEBUG = false;

    public MidiNativeTestActivity() {
        super();
        initTestModules(new NativeMidiTestModule(MidiDeviceInfo.TYPE_USB),
                new NativeMidiTestModule(MidiDeviceInfo.TYPE_VIRTUAL),
                new BTMidiTestModule());

        NativeMidiManager.loadNativeAPI();
        NativeMidiManager.initN();
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        if (DEBUG) {
            Log.i(TAG, ""---- onCreate()"");
        }

        setContentView(R.layout.ndk_midi_activity);

        super.onCreate(savedInstanceState);

        startMidiEchoServer();
        scanMidiDevices();

        connectDeviceListener();
    }

    @Override
    protected void onPause () {
        super.onPause();
        if (DEBUG) {
            Log.i(TAG, ""---- onPause()"");
        }

        boolean isFound = stopService(mMidiServiceIntent);
        if (DEBUG) {
            Log.i(TAG, ""---- Stop Service: "" + isFound);
        }
    }

    /**
     * A class to control and represent the state of a given test.
     * It hold the data needed for IO, and the logic for sending, receiving and matching
     * the MIDI data stream.
     */
    public class NativeMidiTestModule extends MidiTestModule {
        private static final String TAG = ""NativeMidiTestModule"";
        private static final boolean DEBUG = true;

        private NativeMidiManager   mNativeMidiManager;

        public NativeMidiTestModule(int deviceType) {
            super(deviceType);
            mNativeMidiManager = new NativeMidiManager();

            // this call is just to keep the build from stripping out ""endTest"", because
            // it is only called from JNI.
            endTest(TESTSTATUS_NOTRUN);
        }

        protected void closePorts() {
            // NOP
        }

        @Override
        void startLoopbackTest(int testID) {
            synchronized (mTestLock) {
                mTestRunning = true;
                enableTestButtons(false);
            }

            if (DEBUG) {
                Log.i(TAG, ""---- startLoopbackTest()"");
            }

            mRunningTestID = testID;

            synchronized (mTestLock) {
                mTestStatus = TESTSTATUS_NOTRUN;
            }

            if (mIODevice.mSendDevInfo != null) {
                mMidiManager.openDevice(mIODevice.mSendDevInfo, new TestModuleOpenListener(), null);
            }

            startTimeoutHandler();
        }

        @Override
        boolean hasTestPassed() {
            int status;
            synchronized (mTestLock) {
                status = mTestStatus;
            }
            return status == TESTSTATUS_PASSED;
        }

        public void endTest(int endCode) {
            synchronized (mTestLock) {
                mTestRunning = false;
                mTestStatus = endCode;
            }
            if (endCode != TESTSTATUS_NOTRUN) {
                updateTestStateUI();
                enableTestButtons(true);
            }

            closePorts();
        }

        /**
         * Listens for MIDI device opens. Opens I/O ports and sends out the apriori
         * setup messages.
         */
        class TestModuleOpenListener implements MidiManager.OnDeviceOpenedListener {
            //
            // This is where the logical part of the test starts
            //
            @Override
            public void onDeviceOpened(MidiDevice device) {
                if (DEBUG) {
                    Log.i(TAG, ""---- onDeviceOpened()"");
                }
                mNativeMidiManager.startTest(NativeMidiTestModule.this, device,
                        mRunningTestID == TESTID_BTLOOPBACK);
            }
        }
    } /* class NativeMidiTestModule */

    /**
     * Test Module for Bluetooth Loopback.
     * This is a specialization of NativeMidiTestModule (which has the connections for the BL device
     * itself) with and added MidiIODevice object for the USB audio device which does the
     * ""looping back"".
     */
    private class BTMidiTestModule extends NativeMidiTestModule {
        private static final String TAG = ""BTMidiTestModule"";
        private MidiIODevice mUSBLoopbackDevice = new MidiIODevice(MidiDeviceInfo.TYPE_USB);

        public BTMidiTestModule() {
            super(MidiDeviceInfo.TYPE_BLUETOOTH);
        }

        @Override
        public void scanDevices(MidiDeviceInfo[] devInfos) {
            // (normal) Scan for BT MIDI device
            super.scanDevices(devInfos);
            // Find a USB Loopback Device
            mUSBLoopbackDevice.scanDevices(devInfos);
        }

        protected void closePorts() {
            super.closePorts();
            if (mUSBLoopbackDevice != null) {
                mUSBLoopbackDevice.closePorts();
            }
        }

        @Override
        void startLoopbackTest(int testID) {
            if (DEBUG) {
                Log.i(TAG, ""---- startLoopbackTest()"");
            }
            // Setup the USB Loopback Device
            mUSBLoopbackDevice.closePorts();

            if (mIODevice.mSendDevInfo != null) {
                mMidiManager.openDevice(
                        mUSBLoopbackDevice.mSendDevInfo, new USBLoopbackOpenListener(), null);
            }

            // Now start the test as usual
            super.startLoopbackTest(testID);
        }

        /**
         * We need this OnDeviceOpenedListener to open the USB-Loopback device
         */
        private class USBLoopbackOpenListener implements MidiManager.OnDeviceOpenedListener {
            @Override
            public void onDeviceOpened(MidiDevice device) {
                if (DEBUG) {
                    Log.i(""USBLoopbackOpenListener"", ""---- onDeviceOpened()"");
                }
                mUSBLoopbackDevice.openPorts(device, new USBMidiEchoReceiver());
            }
        } /* class USBLoopbackOpenListener */

        /**
         * MidiReceiver subclass for BlueTooth Loopback Test
         *
         * This class receives bytes from the USB Interface (presumably coming from the
         * Bluetooth MIDI peripheral) and echoes them back out (presumably to the Bluetooth
         * MIDI peripheral).
         */
        //TODO - This could be pulled out into a separate class and shared with the identical
        // code in MidiJavaTestActivity is we pass in the send port
        private class USBMidiEchoReceiver extends MidiReceiver {
            private int mTotalBytesEchoed;

            @Override
            public void onSend(byte[] msg, int offset, int count, long timestamp) throws IOException {
                mTotalBytesEchoed += count;
                if (DEBUG) {
                    Log.i(TAG, ""---- USBMidiEchoReceiver.onSend() count:"" + count +
                            "" total:"" + mTotalBytesEchoed);
                }
                if (mUSBLoopbackDevice.mSendPort == null) {
                    Log.e(TAG, ""(native) mUSBLoopbackDevice.mSendPort is null"");
                } else {
                    mUSBLoopbackDevice.mSendPort.onSend(msg, offset, count, timestamp);
                }
            }
        } /* class USBMidiEchoReceiver */
    } /* class BTMidiTestModule */
} /* class MidiNativeTestActivity */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.view.cts.LongPressBackActivity"	"isCanceled"	"CtsViewTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/view/src/android/view/cts/LongPressBackActivity.java"	""	"public void test/*
 *.
 */

package android.view.cts;

import android.app.Activity;
import android.os.Bundle;
import android.view.KeyEvent;

public class LongPressBackActivity extends Activity {

    private boolean mWasPaused;
    private boolean mWasStopped;
    private boolean mSawBackDown;
    private boolean mSawBackUp;
    private boolean mSawOnBackPressed;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
    }

    @Override
    protected void onPause() {
        mWasPaused = true;
        super.onPause();
    }

    @Override
    protected void onStop() {
        mWasStopped = true;
        super.onStop();
    }

    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event) {
        if (keyCode == KeyEvent.KEYCODE_BACK && !event.isCanceled()) {
            mSawBackDown = true;
        }
        return super.onKeyDown(keyCode, event);
    }

    @Override
    public boolean onKeyUp(int keyCode, KeyEvent event) {
        if (keyCode == KeyEvent.KEYCODE_BACK) {
            mSawBackUp = true;
        }
        return super.onKeyUp(keyCode, event);
    }

    @Override
    public void onBackPressed() {
        mSawOnBackPressed = true;
        super.onBackPressed();
    }

    public boolean wasPaused() {
        return mWasPaused;
    }

    public boolean wasStopped() {
        return mWasStopped;
    }

    public boolean sawBackDown() {
        return mSawBackDown;
    }

    public boolean sawBackUp() {
        return mSawBackUp;
    }

    public boolean sawOnBackPressed() {
        return mSawOnBackPressed;
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.app.cts.NotificationManagerTest"	"testAutogrouping_autogroupStaysUntilAllNotificationsCanceled"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/NotificationManagerTest.java"	""	"public void testAutogrouping_autogroupStaysUntilAllNotificationsCanceled() throws Exception {
        sendNotification(701, R.drawable.black);
        sendNotification(702, R.drawable.blue);
        sendNotification(703, R.drawable.yellow);
        sendNotification(704, R.drawable.yellow);

        assertNotificationCount(5);
        assertAllPostedNotificationsAutogrouped();

        // Assert all notis stay in the same autogroup until all children are canceled
        for (int i = 704; i > 701; i--) {
            cancelAndPoll(i);
            assertNotificationCount(i - 700);
            assertAllPostedNotificationsAutogrouped();
        }
        cancelAndPoll(701);
        assertNotificationCount(0);
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.app.cts.NotificationManagerTest"	"testNewNotificationsAddedToAutogroup_ifOriginalNotificationsCanceled"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/NotificationManagerTest.java"	""	"public void testNewNotificationsAddedToAutogroup_ifOriginalNotificationsCanceled()
            throws Exception {
        String newGroup = ""new!"";
        sendNotification(910, R.drawable.black);
        sendNotification(920, R.drawable.blue);
        sendNotification(930, R.drawable.yellow);
        sendNotification(940, R.drawable.yellow);

        List<Integer> postedIds = new ArrayList<>();
        postedIds.add(910);
        postedIds.add(920);
        postedIds.add(930);
        postedIds.add(940);

        assertNotificationCount(5);
        assertAllPostedNotificationsAutogrouped();

        // regroup all but one of the children
        for (int i = postedIds.size() - 1; i > 0; i--) {
            try {
                Thread.sleep(200);
            } catch (InterruptedException ex) {
                // pass
            }
            int id = postedIds.remove(i);
            sendNotification(id, newGroup, R.drawable.blue);
            assertNotificationCount(5);
            assertOnlySomeNotificationsAutogrouped(postedIds);
        }

        // send a new non-grouped notification. since the autogroup summary still exists,
        // the notification should be added to it
        sendNotification(950, R.drawable.blue);
        postedIds.add(950);
        try {
            Thread.sleep(200);
        } catch (InterruptedException ex) {
            // pass
        }
        assertOnlySomeNotificationsAutogrouped(postedIds);
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.bluetooth.cts.ScanRecordTest"	"testParser"	"CtsBluetoothTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/bluetooth/src/android/bluetooth/cts/ScanRecordTest.java"	""	"public void testParser() {
        byte[] scanRecord = new byte[] {
                0x02, 0x01, 0x1a, // advertising flags
                0x05, 0x02, 0x0b, 0x11, 0x0a, 0x11, // 16 bit service uuids
                0x04, 0x09, 0x50, 0x65, 0x64, // name
                0x02, 0x0A, (byte) 0xec, // tx power level
                0x05, 0x16, 0x0b, 0x11, 0x50, 0x64, // service data
                0x05, (byte) 0xff, (byte) 0xe0, 0x00, 0x02, 0x15, // manufacturer specific data
                0x05, 0x14, 0x0c, 0x11, 0x0d, 0x11, // 16 bit service solicitation uuids
                0x03, 0x50, 0x01, 0x02, // an unknown data type won't cause trouble
        };
        ScanRecord data = TestUtils.parseScanRecord(scanRecord);
        assertEquals(0x1a, data.getAdvertiseFlags());
        ParcelUuid uuid1 = ParcelUuid.fromString(""0000110A-0000-1000-8000-00805F9B34FB"");
        ParcelUuid uuid2 = ParcelUuid.fromString(""0000110B-0000-1000-8000-00805F9B34FB"");
        ParcelUuid uuid3 = ParcelUuid.fromString(""0000110C-0000-1000-8000-00805F9B34FB"");
        ParcelUuid uuid4 = ParcelUuid.fromString(""0000110D-0000-1000-8000-00805F9B34FB"");
        assertTrue(data.getServiceUuids().contains(uuid1));
        assertTrue(data.getServiceUuids().contains(uuid2));
        assertFalse(data.getServiceUuids().contains(uuid3));
        assertFalse(data.getServiceUuids().contains(uuid4));
        assertFalse(data.getServiceSolicitationUuids().contains(uuid1));
        assertFalse(data.getServiceSolicitationUuids().contains(uuid2));
        assertTrue(data.getServiceSolicitationUuids().contains(uuid3));
        assertTrue(data.getServiceSolicitationUuids().contains(uuid4));

        assertEquals(""Ped"", data.getDeviceName());
        assertEquals(-20, data.getTxPowerLevel());

        assertTrue(data.getManufacturerSpecificData().get(0x00E0) != null);

        final byte[] manufacturerData = new byte[] {
                0x02, 0x15 };
        TestUtils.assertArrayEquals(manufacturerData,
                data.getManufacturerSpecificData().get(0x00E0));
        TestUtils.assertArrayEquals(manufacturerData, data.getManufacturerSpecificData(0x00E0));

        assertTrue(data.getServiceData().containsKey(uuid2));
        final byte[] serviceData = new byte[] {
                0x50, 0x64 };
        TestUtils.assertArrayEquals(serviceData, data.getServiceData().get(uuid2));
        TestUtils.assertArrayEquals(serviceData, data.getServiceData(uuid2));
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.scopedstorage.cts.device.BypassDatabaseOperationsTest"	"testSystemGallery_targets30_WithBypassFlag_BypassesDatabase"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/device/src/android/scopedstorage/cts/device/BypassDatabaseOperationsTest.java"	""	"@SdkSuppress(minSdkVersion = 31, codeName = ""S"")
    public void testSystemGallery_targets30_WithBypassFlag_BypassesDatabase() throws Exception {
        installAppWithStoragePermissions(APP_SYSTEM_GALLERY_30_BYPASS_DB);
        try {
            final int sgUid =
                    getContext().getPackageManager().getPackageUid(
                            APP_SYSTEM_GALLERY_30_BYPASS_DB.getPackageName(), 0);
            allowAppOpsToUid(sgUid, SYSTEM_GALLERY_APPOPS);
            testAppBypassesDatabaseOps(APP_SYSTEM_GALLERY_30_BYPASS_DB);
        } finally {
            uninstallAppNoThrow(APP_SYSTEM_GALLERY_30_BYPASS_DB);
        }
    }

    private void testAppDoesntBypassDatabaseOps(TestApp app) throws Exception {
        final File file = new File(getDcimDir(), IMAGE_FILE_NAME);
        final File renamedFile = new File(getPicturesDir(), IMAGE_FILE_NAME);
        try {
            assertThat(createFileAs(app, file.getAbsolutePath())).isTrue();
            // File path create() added file to database.
            assertThat(TestUtils.checkDatabaseRowExistsAs(app, file)).isTrue();

            assertThat(renameFileAs(app, file, renamedFile)).isTrue();
            // File path rename() also updates the database row
            assertThat(TestUtils.checkDatabaseRowExistsAs(app, file)).isFalse();
            assertThat(TestUtils.checkDatabaseRowExistsAs(app, renamedFile)).isTrue();

            assertThat(deleteFileAs(app, renamedFile.getAbsolutePath())).isTrue();
            // File path delete() removes database row.
            assertThat(TestUtils.checkDatabaseRowExistsAs(app, renamedFile)).isFalse();
        } finally {
            if (file.exists()) {
                deleteFileAsNoThrow(app, file.getAbsolutePath());
            }
            if (renamedFile.exists()) {
                deleteFileAsNoThrow(app, renamedFile.getAbsolutePath());
            }
        }
    }

    private void testAppBypassesDatabaseOps(TestApp app) throws Exception {
        final File file = new File(getDcimDir(), IMAGE_FILE_NAME);
        final File renamedFile = new File(getPicturesDir(), IMAGE_FILE_NAME);
        try {
            assertThat(createFileAs(app, file.getAbsolutePath())).isTrue();
            // File path create() didn't add the file to database.
            assertThat(TestUtils.checkDatabaseRowExistsAs(app, file)).isFalse();

            // Ensure file is added to database.
            assertNotNull(MediaStore.scanFile(getContentResolver(), file));

            assertThat(renameFileAs(app, file, renamedFile)).isTrue();
            // Rename() didn't update the database row.
            assertThat(TestUtils.checkDatabaseRowExistsAs(app, file)).isTrue();
            assertThat(TestUtils.checkDatabaseRowExistsAs(app, renamedFile)).isFalse();

            // Ensure database is updated with renamed path
            assertNull(MediaStore.scanFile(getContentResolver(), file));
            assertNotNull(MediaStore.scanFile(getContentResolver(), renamedFile));
            assertThat(TestUtils.checkDatabaseRowExistsAs(app, renamedFile)).isTrue();

            assertThat(deleteFileAs(app, renamedFile.getAbsolutePath())).isTrue();
            // Unlink() didn't remove the database row.
            assertThat(TestUtils.checkDatabaseRowExistsAs(app, renamedFile)).isTrue();
        } finally {
            if (file.exists()) {
                deleteFileAsNoThrow(app, file.getAbsolutePath());
            }
            if (renamedFile.exists()) {
                deleteFileAsNoThrow(app, renamedFile.getAbsolutePath());
            }
            MediaStore.scanFile(getContentResolver(), file);
            MediaStore.scanFile(getContentResolver(), renamedFile);
        }
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.hardware.input.cts.tests.NintendoSwitchProTest"	"NintendoSwitchProTest"	"CtsHardwareTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/hardware/src/android/hardware/input/cts/tests/NintendoSwitchProTest.java"	""	"/*
 *.
 */

package android.hardware.input.cts.tests;

import static androidx.test.platform.app.InstrumentationRegistry.getInstrumentation;
import static org.junit.Assume.assumeFalse;

import android.content.pm.PackageManager;
import android.hardware.cts.R;
import android.os.SystemClock;

import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.filters.MediumTest;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

@MediumTest
@RunWith(AndroidJUnit4.class)
public class NintendoSwitchProTest extends InputHidTestCase {
    public NintendoSwitchProTest() {
        super(R.raw.nintendo_switchpro_register);
    }

    @Before
    public void setUp() throws Exception {
        super.setUp();
        /**
         * During probe, hid-nintendo sends commands to the joystick and waits for some of those
         * commands to execute. Somewhere in the middle of the commands, the driver will register
         * an input device, which is the notification received by InputHidTestCase.
         * If a command is still being waited on while we start writing
         * events to uhid, all incoming events are dropped, because probe() still hasn't finished.
         * To ensure that hid-nintendo probe is done, add a delay here.
         */
        SystemClock.sleep(1000);
    }"	""	""	"probe"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.net.wifi.rtt.cts.TestBase"	"isLocationEnabled"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/rtt/cts/TestBase.java"	""	"public void test/*
 *.
 */

package android.net.wifi.rtt.cts;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageManager;
import android.location.LocationManager;
import android.net.wifi.ScanResult;
import android.net.wifi.WifiManager;
import android.net.wifi.cts.WifiJUnit3TestBase;
import android.net.wifi.rtt.RangingResult;
import android.net.wifi.rtt.RangingResultCallback;
import android.net.wifi.rtt.WifiRttManager;
import android.os.Handler;
import android.os.HandlerExecutor;
import android.os.HandlerThread;

import com.android.compatibility.common.util.ShellIdentityUtils;
import com.android.compatibility.common.util.SystemUtil;

import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executor;
import java.util.concurrent.TimeUnit;

/**
 * Base class for Wi-Fi RTT CTS test cases. Provides a uniform configuration and event management
 * facility.
 */
public class TestBase extends WifiJUnit3TestBase {
    protected static final String TAG = ""WifiRttCtsTests"";

    // wait for Wi-Fi RTT to become available
    private static final int WAIT_FOR_RTT_CHANGE_SECS = 10;

    // wait for Wi-Fi scan results to become available
    private static final int WAIT_FOR_SCAN_RESULTS_SECS = 20;

    // wait for network selection and connection finish
    private static final int WAIT_FOR_CONNECTION_FINISH_MS = 30_000;

    // Interval between failure scans
    private static final int INTERVAL_BETWEEN_FAILURE_SCAN_MILLIS = 5_000;

    // 5GHz Frequency band
    private static final int FREQUENCY_OF_5GHZ_BAND_IN_MHZ = 5_000;

    protected WifiRttManager mWifiRttManager;
    protected WifiManager mWifiManager;
    private LocationManager mLocationManager;
    private WifiManager.WifiLock mWifiLock;

    private final HandlerThread mHandlerThread = new HandlerThread(""SingleDeviceTest"");
    protected final Executor mExecutor;
    private Boolean mWasVerboseLoggingEnabled;

    {
        mHandlerThread.start();
        mExecutor = new HandlerExecutor(new Handler(mHandlerThread.getLooper()));
    }

    /**
     * Returns a flag indicating whether or not Wi-Fi RTT should be tested. Wi-Fi RTT
     * should be tested if the feature is supported on the current device.
     */
    static boolean shouldTestWifiRtt(Context context) {
        final PackageManager pm = context.getPackageManager();
        return pm.hasSystemFeature(PackageManager.FEATURE_WIFI_RTT);
    }

    /**
     * Returns a flag indicating whether or not Wi-Fi Aware should be tested. Wi-Fi Aware
     * should be tested if the feature is supported on the current device.
     */
    static boolean shouldTestWifiAware(Context context) {
        final PackageManager pm = context.getPackageManager();
        return pm.hasSystemFeature(PackageManager.FEATURE_WIFI_AWARE);
    }

    @Override
    protected void setUp() throws Exception {
        super.setUp();

        if (!shouldTestWifiRtt(getContext())) {
            return;
        }

        mLocationManager = (LocationManager) getContext().getSystemService(
                Context.LOCATION_SERVICE);
        assertTrue(""RTT testing requires Location to be enabled"",
                mLocationManager.isLocationEnabled());

        mWifiRttManager = (WifiRttManager) getContext().getSystemService(
                Context.WIFI_RTT_RANGING_SERVICE);
        assertNotNull(""Wi-Fi RTT Manager"", mWifiRttManager);

        mWifiManager = (WifiManager) getContext().getSystemService(Context.WIFI_SERVICE);
        assertNotNull(""Wi-Fi Manager"", mWifiManager);

        // turn on verbose logging for tests
        mWasVerboseLoggingEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.isVerboseLoggingEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setVerboseLoggingEnabled(true));

        mWifiLock = mWifiManager.createWifiLock(TAG);
        mWifiLock.acquire();
        if (!mWifiManager.isWifiEnabled()) {
            SystemUtil.runShellCommand(""svc wifi enable"");
            // Turn on Wi-Fi may trigger connection. Wait connection state stable.
            scanAps();
            Thread.sleep(WAIT_FOR_CONNECTION_FINISH_MS);
        }
        IntentFilter intentFilter = new IntentFilter();
        intentFilter.addAction(WifiRttManager.ACTION_WIFI_RTT_STATE_CHANGED);
        WifiRttBroadcastReceiver receiver = new WifiRttBroadcastReceiver();
        mContext.registerReceiver(receiver, intentFilter);
        if (!mWifiRttManager.isAvailable()) {
            assertTrue(""Timeout waiting for Wi-Fi RTT to change status"",
                    receiver.waitForStateChange());
            assertTrue(""Wi-Fi RTT is not available (should be)"", mWifiRttManager.isAvailable());
        }
    }

    @Override
    protected void tearDown() throws Exception {
        if (!shouldTestWifiRtt(getContext())) {
            super.tearDown();
            return;
        }

        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setVerboseLoggingEnabled(mWasVerboseLoggingEnabled));

        super.tearDown();
    }

    class WifiRttBroadcastReceiver extends BroadcastReceiver {
        private CountDownLatch mBlocker = new CountDownLatch(1);

        @Override
        public void onReceive(Context context, Intent intent) {
            if (WifiRttManager.ACTION_WIFI_RTT_STATE_CHANGED.equals(intent.getAction())) {
                mBlocker.countDown();
            }
        }

        boolean waitForStateChange() throws InterruptedException {
            return mBlocker.await(WAIT_FOR_RTT_CHANGE_SECS, TimeUnit.SECONDS);
        }
    }

    class WifiScansBroadcastReceiver extends BroadcastReceiver {
        private CountDownLatch mBlocker = new CountDownLatch(1);

        @Override
        public void onReceive(Context context, Intent intent) {
            if (WifiManager.SCAN_RESULTS_AVAILABLE_ACTION.equals(intent.getAction())) {
                mBlocker.countDown();
            }
        }

        boolean waitForStateChange() throws InterruptedException {
            return mBlocker.await(WAIT_FOR_SCAN_RESULTS_SECS, TimeUnit.SECONDS);
        }
    }

    class ResultCallback extends RangingResultCallback {
        private CountDownLatch mBlocker = new CountDownLatch(1);
        private int mCode; // 0: success, otherwise RangingResultCallback STATUS_CODE_*.
        private List<RangingResult> mResults;

        @Override
        public void onRangingFailure(int code) {
            mCode = code;
            mResults = null; // not necessary since intialized to null - but for completeness
            mBlocker.countDown();
        }

        @Override
        public void onRangingResults(List<RangingResult> results) {
            mCode = 0; // not necessary since initialized to 0 - but for completeness
            mResults = results;
            mBlocker.countDown();
        }

        /**
         * Waits for the listener callback to be called - or an error (timeout, interruption).
         * Returns true on callback called, false on error (timeout, interruption).
         */
        boolean waitForCallback() throws InterruptedException {
            return mBlocker.await(WAIT_FOR_RTT_CHANGE_SECS, TimeUnit.SECONDS);
        }

        /**
         * Returns the code of the callback operation. Will be 0 for success (onRangingResults
         * called), else (if onRangingFailure called) will be one of the STATUS_CODE_* values.
         */
        int getCode() {
            return mCode;
        }

        /**
         * Returns the list of ranging results. In cases of error (getCode() != 0) will return null.
         */
        List<RangingResult> getResults() {
            return mResults;
        }
    }

    /**
     * Start a scan and return a list of observed ScanResults (APs).
     */
    protected List<ScanResult> scanAps() throws InterruptedException {
        IntentFilter intentFilter = new IntentFilter();
        intentFilter.addAction(WifiManager.SCAN_RESULTS_AVAILABLE_ACTION);
        WifiScansBroadcastReceiver receiver = new WifiScansBroadcastReceiver();
        mContext.registerReceiver(receiver, intentFilter);

        mWifiManager.startScan();
        receiver.waitForStateChange();
        mContext.unregisterReceiver(receiver);
        return mWifiManager.getScanResults();
    }

    /**
     * Start a scan and return a test AP which supports IEEE 802.11mc and which has the highest
     * RSSI. Will perform N (parameterized) scans and get the best AP across both scans.
     *
     * Returns null if test AP is not found in the specified number of scans.
     *
     * @param numScanRetries Maximum number of scans retries (in addition to first scan).
     */
    protected ScanResult scanForTest11mcCapableAp(int numScanRetries)
            throws InterruptedException {
        int scanCount = 0;
        ScanResult bestTestAp = null;
        while (scanCount <= numScanRetries) {
            for (ScanResult scanResult : scanAps()) {
                if (!scanResult.is80211mcResponder()) {
                    continue;
                }
                if (bestTestAp == null || scanResult.level > bestTestAp.level) {
                    bestTestAp = scanResult;
                }
            }
            if (bestTestAp == null) {
                // Ongoing connection may cause scan failure, wait for a while before next scan.
                Thread.sleep(INTERVAL_BETWEEN_FAILURE_SCAN_MILLIS);
            }
            scanCount++;
        }
        return bestTestAp;
    }

    /**
     * Start a scan and return a test AP which does NOT support IEEE 802.11mc, with a BSS in the
     * 5GHz band, and which has the highest RSSI. Will perform N (parameterized) scans and get
     * the best AP across all scan results.
     *
     * Returns null if test AP is not found in the specified number of scans.
     *
     * @param numScanRetries Maximum number of scans retries (in addition to first scan).
     */
    protected ScanResult scanForTestNon11mcCapableAp(int numScanRetries)
            throws InterruptedException {
        int scanCount = 0;
        ScanResult bestTestAp = null;
        while (scanCount <= numScanRetries) {
            for (ScanResult scanResult : scanAps()) {
                // Ensure using a 5GHz or greater channel
                if (scanResult.is80211mcResponder()
                        || scanResult.centerFreq0 < FREQUENCY_OF_5GHZ_BAND_IN_MHZ) {
                    continue;
                }
                if (bestTestAp == null || scanResult.level > bestTestAp.level) {
                    bestTestAp = scanResult;
                }
            }
            if (bestTestAp == null) {
                // Ongoing connection may cause scan failure, wait for a while before next scan.
                Thread.sleep(INTERVAL_BETWEEN_FAILURE_SCAN_MILLIS);
            }
            scanCount++;
        }
        return bestTestAp;
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.provider.cts.media.MediaStorePendingTest"	"testMutableColumns"	"CtsProviderTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/provider/src/android/provider/cts/media/MediaStorePendingTest.java"	""	"public void testMutableColumns() throws Exception {
        // Stage pending content
        final ContentValues values = new ContentValues();
        values.put(MediaColumns.MIME_TYPE, ""image/png"");
        values.put(MediaColumns.IS_PENDING, 1);
        values.put(MediaColumns.HEIGHT, 32);
        final Uri uri = mResolver.insert(mExternalImages, values);
        try (InputStream in = mContext.getResources().openRawResource(R.raw.scenery);
                OutputStream out = mResolver.openOutputStream(uri)) {
            FileUtils.copy(in, out);
        }

        // Verify that initial values are present
        try (Cursor c = mResolver.query(uri, null, null, null)) {
            c.moveToFirst();
            assertEquals(32, c.getLong(c.getColumnIndexOrThrow(MediaColumns.HEIGHT)));
        }

        // Verify that we can update values while pending
        values.clear();
        values.put(MediaColumns.HEIGHT, 64);
        mResolver.update(uri, values, null, null);
        try (Cursor c = mResolver.query(uri, null, null, null)) {
            c.moveToFirst();
            assertEquals(64, c.getLong(c.getColumnIndexOrThrow(MediaColumns.HEIGHT)));
        }

        // Publishing triggers scan of underlying file
        values.clear();
        values.put(MediaColumns.IS_PENDING, 0);
        mResolver.update(uri, values, null, null);
        try (Cursor c = mResolver.query(uri, null, null, null)) {
            c.moveToFirst();
            assertEquals(107, c.getLong(c.getColumnIndexOrThrow(MediaColumns.HEIGHT)));
        }

        // Ignored now that we're published
        values.clear();
        values.put(MediaColumns.HEIGHT, 48);
        mResolver.update(uri, values, null, null);
        try (Cursor c = mResolver.query(uri, null, null, null)) {
            c.moveToFirst();
            assertEquals(107, c.getLong(c.getColumnIndexOrThrow(MediaColumns.HEIGHT)));
        }
    }

    /**
     * Verify that if clever apps try writing the exact modified time and size
     * as part of publishing that we still perform a full scan.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.PermissionsTest"	"testSensorsRelatedPermissionsCannotBeGranted"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/PermissionsTest.java"	""	"public void testSensorsRelatedPermissionsCannotBeGranted() throws Exception {
        for (String sensorPermission : SENSORS_PERMISSIONS) {
            try {
                // The permission cannot be granted.
                assertFailedToSetPermissionGrantState(
                        sensorPermission, DevicePolicyManager.PERMISSION_GRANT_STATE_GRANTED);

                // But the user can grant it.
                PermissionUtils.launchActivityAndRequestPermission(mReceiver, mDevice,
                        sensorPermission, PERMISSION_GRANTED, PERMISSION_APP_PACKAGE_NAME,
                        PERMISSIONS_ACTIVITY_NAME);

                // And the package manager should show it as granted.
                PermissionUtils.checkPermission(sensorPermission, PERMISSION_GRANTED,
                        PERMISSION_APP_PACKAGE_NAME);
            } finally {
                revokePermission(sensorPermission);
            }
        }
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.PermissionsTest"	"testSensorsRelatedPermissionsCanBeDenied"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/PermissionsTest.java"	""	"public void testSensorsRelatedPermissionsCanBeDenied() throws Exception {
        for (String sensorPermission : SENSORS_PERMISSIONS) {
            // The permission can be denied
            setPermissionGrantState(sensorPermission, PERMISSION_GRANT_STATE_DENIED);

            assertPermissionGrantState(sensorPermission, PERMISSION_GRANT_STATE_DENIED);
            assertCannotRequestPermissionFromActivity(sensorPermission);
        }
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.PermissionsTest"	"testStateOfSensorsRelatedPermissionsCannotBeRead"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/PermissionsTest.java"	""	"public void testStateOfSensorsRelatedPermissionsCannotBeRead() throws Exception {
        for (String sensorPermission : SENSORS_PERMISSIONS) {
            try {
                // The admin tries to grant the permission.
                setPermissionGrantState(sensorPermission, PERMISSION_GRANT_STATE_GRANTED);

                // But the user denies it.
                PermissionUtils.launchActivityAndRequestPermission(mReceiver, mDevice,
                        sensorPermission, PERMISSION_DENIED, PERMISSION_APP_PACKAGE_NAME,
                        PERMISSIONS_ACTIVITY_NAME);

                // And the admin cannot learn of it.
                assertPermissionGrantState(sensorPermission, PERMISSION_GRANT_STATE_DEFAULT);
            } finally {
                revokePermission(sensorPermission);
            }
        }
    }

    private void revokePermission(String sensorPermission) {
        if (LOCATION_PERMISSIONS.contains(sensorPermission)) {
            mUiAutomation.revokeRuntimePermission(PERMISSION_APP_PACKAGE_NAME,
                    permission.ACCESS_FINE_LOCATION);
            mUiAutomation.revokeRuntimePermission(PERMISSION_APP_PACKAGE_NAME,
                    permission.ACCESS_COARSE_LOCATION);
        } else {
            mUiAutomation.revokeRuntimePermission(PERMISSION_APP_PACKAGE_NAME, sensorPermission);
        }
    }

    private void assertFailedToSetPermissionGrantState(String permission, int value) {
        assertTrue(mDevicePolicyManager.setPermissionGrantState(ADMIN_RECEIVER_COMPONENT,
                PERMISSION_APP_PACKAGE_NAME, permission, value));
        assertEquals(mDevicePolicyManager.getPermissionGrantState(ADMIN_RECEIVER_COMPONENT,
                PERMISSION_APP_PACKAGE_NAME, permission),
                DevicePolicyManager.PERMISSION_GRANT_STATE_DEFAULT);
        assertEquals(mContext.getPackageManager().checkPermission(permission,
                PERMISSION_APP_PACKAGE_NAME),
                PackageManager.PERMISSION_DENIED);
    }

    private CountDownLatch initPermissionNotificationLatch() {
        CountDownLatch notificationCounterLatch = new CountDownLatch(1);
        NotificationListener.getInstance().addListener((notification) -> {
            if (notification.getPackageName().equals(
                    mContext.getPackageManager().getPermissionControllerPackageName()) &&
                    notification.getNotification().getChannelId().equals(
                            AUTO_GRANTED_PERMISSIONS_CHANNEL_ID)) {
                notificationCounterLatch.countDown();
            }
        });
        return notificationCounterLatch;
    }

    private void setPermissionPolicy(int permissionPolicy) {
        mDevicePolicyManager.setPermissionPolicy(ADMIN_RECEIVER_COMPONENT, permissionPolicy);
    }

    private boolean setPermissionGrantState(String permission, int grantState) {
        return mDevicePolicyManager.setPermissionGrantState(ADMIN_RECEIVER_COMPONENT,
                PERMISSION_APP_PACKAGE_NAME, permission, grantState);
    }

    private void unableToSetPermissionGrantState(String permission, int grantState) {
        assertFalse(setPermissionGrantState(permission, grantState));
    }

    private void assertPermissionGrantState(String permission, int grantState) {
        assertEquals(mDevicePolicyManager.getPermissionGrantState(ADMIN_RECEIVER_COMPONENT,
                PERMISSION_APP_PACKAGE_NAME, permission), grantState);
    }

    private void assertPermissionPolicy(int permissionPolicy) {
        assertEquals(mDevicePolicyManager.getPermissionPolicy(ADMIN_RECEIVER_COMPONENT),
                permissionPolicy);
    }

    private void assertCanRequestPermissionFromActivity(String permission) throws Exception {
        PermissionUtils.launchActivityAndRequestPermission(
                mReceiver, permission, PERMISSION_GRANTED,
                PERMISSION_APP_PACKAGE_NAME, PERMISSIONS_ACTIVITY_NAME);
    }

    private void assertCannotRequestPermissionFromActivity(String permission) throws Exception {
        PermissionUtils.launchActivityAndRequestPermission(
                mReceiver, permission, PERMISSION_DENIED,
                PERMISSION_APP_PACKAGE_NAME, PERMISSIONS_ACTIVITY_NAME);
    }

    private void assertHasPermissionFromActivity(String permission) throws Exception {
        PermissionUtils.launchActivityAndCheckPermission(
                mReceiver, permission, PERMISSION_GRANTED,
                PERMISSION_APP_PACKAGE_NAME, PERMISSIONS_ACTIVITY_NAME);
    }

    private void assertNoPermissionFromActivity(String permission) throws Exception {
        PermissionUtils.launchActivityAndCheckPermission(
                mReceiver, permission, PERMISSION_DENIED,
                PERMISSION_APP_PACKAGE_NAME, PERMISSIONS_ACTIVITY_NAME);
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.monkey.SeedTest"	"testSeed2"	"CtsMonkeyTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/monkey/src/com/android/cts/monkey/SeedTest.java"	""	"public void testSeed2() throws Exception {
        String cmd2 = MONKEY_CMD + "" -s 3007 -v -p "" + PKGS[0] + "" 125"";
        String out3 = mDevice.executeShellCommand(cmd2);
        String out4 = mDevice.executeShellCommand(cmd2);
        assertOutputs(out3, out4);
    }

    private void assertOutputs(String out1, String out2) {
        Scanner s1 = new Scanner(out1);
        Scanner s2 = new Scanner(out2);
        int numEvents = 0;
        while (true) {
            String line1 = getNextLine(s1);
            String line2 = getNextLine(s2);
            if (line1 != null || line2 != null) {
                assertEquals(line1, line2);
                numEvents++;
            } else {
                break;
            }
        }
        assertTrue(numEvents > 0);
    }

    private String getNextLine(Scanner sc) {
        while (sc.hasNextLine()) {
            String line = sc.nextLine().trim();
            if (line.startsWith("":Sending"")) {
                return line;
            }
        }
        return null;
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.media.cts.ScannerNotificationReceiver"	"listFiles"	"CtsMediaTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/ScannerNotificationReceiver.java"	""	"public void test/*
 *.
 */

package android.media.cts;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.os.Environment;

import java.io.File;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

class ScannerNotificationReceiver extends BroadcastReceiver {

    private static final int TIMEOUT_MS = 4 * 60 * 1000;

    private final String mAction;
    private CountDownLatch mLatch = new CountDownLatch(1);

    ScannerNotificationReceiver(String action) {
        mAction = action;
    }

    @Override
    public void onReceive(Context context, Intent intent) {
        if (intent.getAction().equals(mAction)) {
            mLatch.countDown();
        }
    }

    public void waitForBroadcast() throws InterruptedException {
        if (!mLatch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS)) {
            int numFiles = countFiles(Environment.getExternalStorageDirectory());
            MediaScannerTest.fail(""Failed to receive broadcast in "" + TIMEOUT_MS + ""ms for ""
                    + mAction + "" while trying to scan "" + numFiles + "" files!"");
        }
    }

    void reset() {
        mLatch = new CountDownLatch(1);
    }

    private int countFiles(File dir) {
        int count = 0;
        File[] files = dir.listFiles();
        if (files != null) {
            for (File file : files) {
                if (file.isDirectory()) {
                    count += countFiles(file);
                } else {
                    count++;
                }
            }
        }
        return count;
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.storagestatsapp.StorageStatsTest"	"testVerifyStatsExternal"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/StorageStatsApp/src/com/android/cts/storagestatsapp/StorageStatsTest.java"	""	"public void testVerifyStatsExternal() throws Exception {
        final StorageStatsManager stats = getContext().getSystemService(StorageStatsManager.class);
        final int uid = android.os.Process.myUid();
        final UserHandle user = UserHandle.getUserHandleForUid(uid);

        final ExternalStorageStats before = stats.queryExternalStatsForUser(UUID_DEFAULT, user);

        final File dir = Environment.getExternalStorageDirectory();
        final File downloadsDir = Environment.getExternalStoragePublicDirectory(
                Environment.DIRECTORY_DOWNLOADS);
        downloadsDir.mkdirs();

        final File image = new File(dir, System.nanoTime() + "".jpg"");
        final File video = new File(downloadsDir, System.nanoTime() + "".MP4"");
        final File audio = new File(dir, System.nanoTime() + "".png.WaV"");
        final File internal = new File(
                getContext().getExternalFilesDir(Environment.DIRECTORY_PICTURES), ""test.jpg"");

        useWrite(image, 2 * MB_IN_BYTES);
        useWrite(video, 3 * MB_IN_BYTES);
        useWrite(audio, 5 * MB_IN_BYTES);
        useWrite(internal, 7 * MB_IN_BYTES);

        final ExternalStorageStats afterInit = stats.queryExternalStatsForUser(UUID_DEFAULT, user);

        assertMostlyEquals(17 * MB_IN_BYTES, afterInit.getTotalBytes() - before.getTotalBytes());
        assertMostlyEquals(5 * MB_IN_BYTES, afterInit.getAudioBytes() - before.getAudioBytes());
        assertMostlyEquals(3 * MB_IN_BYTES, afterInit.getVideoBytes() - before.getVideoBytes());
        assertMostlyEquals(2 * MB_IN_BYTES, afterInit.getImageBytes() - before.getImageBytes());
        assertMostlyEquals(7 * MB_IN_BYTES, afterInit.getAppBytes() - before.getAppBytes());

        // Rename to ensure that stats are updated
        video.renameTo(new File(dir, System.nanoTime() + "".PnG""));

        // Since we have MANAGE_EXTERNAL_STORAGE, need to ask for a re-scan
        MediaStore.scanFile(getContext().getContentResolver(), dir);
        MediaStore.scanFile(getContext().getContentResolver(), downloadsDir);
        MediaStore.waitForIdle(getContext().getContentResolver());

        final ExternalStorageStats afterRename = stats.queryExternalStatsForUser(UUID_DEFAULT, user);

        assertMostlyEquals(17 * MB_IN_BYTES, afterRename.getTotalBytes() - before.getTotalBytes());
        assertMostlyEquals(5 * MB_IN_BYTES, afterRename.getAudioBytes() - before.getAudioBytes());
        assertMostlyEquals(0 * MB_IN_BYTES, afterRename.getVideoBytes() - before.getVideoBytes());
        assertMostlyEquals(5 * MB_IN_BYTES, afterRename.getImageBytes() - before.getImageBytes());
        assertMostlyEquals(7 * MB_IN_BYTES, afterRename.getAppBytes() - before.getAppBytes());
    }

    /**
     * Measuring external storage manually should always be consistent with
     * whatever the stats APIs are returning.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.cts.backup.keyvaluerestoreapp.KeyValueBackupRestoreTest"	"testSharedPreferencesRestore"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/backup/KeyValueApp/src/android/cts/backup/keyvaluerestoreapp/KeyValueBackupRestoreTest.java"	""	"/*
 *
 */

package android.cts.backup.keyvaluerestoreapp;

import static android.content.Context.MODE_PRIVATE;

import static androidx.test.InstrumentationRegistry.getTargetContext;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

import android.app.backup.BackupManager;
import android.app.backup.BackupObserver;
import android.app.backup.FileBackupHelper;
import android.app.backup.SharedPreferencesBackupHelper;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.SharedPreferences;
import android.platform.test.annotations.AppModeFull;
import android.util.Log;

import androidx.test.runner.AndroidJUnit4;

import com.android.compatibility.common.util.SystemUtil;
import com.android.compatibility.common.util.TestUtils;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.PrintWriter;
import java.util.Scanner;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

/**
 * Device side routines to be invoked by the host side KeyValueBackupRestoreHostSideTest. These
 * are not designed to be called in any other way, as they rely on state set up by the host side
 * test.
 *
 * Some tests invoked by KeyValueBackupRestoreHostSideTest#testSharedPreferencesRestore() are
 * interacting with SharedPrefsRestoreTestActivity from another package.
 *
 */
@RunWith(AndroidJUnit4.class)
@AppModeFull
public class KeyValueBackupRestoreTest {
    private static final String KEY_VALUE_RESTORE_APP_PACKAGE =
            ""android.cts.backup.keyvaluerestoreapp"";
    private static final String TAG = ""KeyValueBackupRestore"";

    // Names and values of the test files for
    // KeyValueBackupRestoreHostSideTest#testKeyValueBackupAndRestore()
    private static final String TEST_FILE_1 = ""test-file-1"";
    private static final String TEST_FILE_1_DATA = ""test-file-1-data"";

    private static final String TEST_FILE_2 = ""test-file-2"";
    private static final String TEST_FILE_2_DATA = ""test-file-2-data"";

    private static final String TEST_PREFS_1 = ""test-prefs-1"";
    private static final String INT_PREF = ""int-pref"";
    private static final int INT_PREF_VALUE = 111;
    private static final String BOOL_PREF = ""bool-pref"";
    private static final boolean BOOL_PREF_VALUE = true;

    private static final String TEST_PREFS_2 = ""test-prefs-2"";
    private static final String FLOAT_PREF = ""float-pref"";
    private static final float FLOAT_PREF_VALUE = 0.12345f;
    private static final String LONG_PREF = ""long-pref"";
    private static final long LONG_PREF_VALUE = 12345L;
    private static final String STRING_PREF = ""string-pref"";
    private static final String STRING_PREF_VALUE = ""string-pref-value"";

    private static final int DEFAULT_INT_VALUE = 0;
    private static final boolean DEFAULT_BOOL_VALUE = false;
    private static final float DEFAULT_FLOAT_VALUE = 0.0f;
    private static final long DEFAULT_LONG_VALUE = 0L;
    private static final String DEFAULT_STRING_VALUE = null;
    private static final String DEFAULT_FILE_CONTENT = """";


    /** Package name of the test app for
     * KeyValueBackupRestoreHostSideTest#testSharedPreferencesRestore() */
    private static final String SHARED_PREFERENCES_RESTORE_PACKAGE_NAME =
            ""android.cts.backup.sharedprefrestoreapp"";

    /** Test activity for KeyValueBackupRestoreHostSideTest#testSharedPreferencesRestore() */
    private static final String SHARED_PREFERENCES_RESTORE_ACTIVITY_NAME =
            SHARED_PREFERENCES_RESTORE_PACKAGE_NAME + "".SharedPrefsRestoreTestActivity"";

    // Shared prefs test activity actions
    private static final String INIT_ACTION = ""android.backup.cts.backuprestore.INIT"";
    private static final String UPDATE_ACTION = ""android.backup.cts.backuprestore.UPDATE"";
    private static final String TEST_ACTION = ""android.backup.cts.backuprestore.TEST"";

    // Action for returning the result of shared preference activity's operations
    private static final String RESULT_ACTION = ""android.backup.cts.backuprestore.RESULT"";
    private static final String EXTRA_SUCCESS = ""EXTRA_SUCCESS"";

    private static final int ACTIVITY_TEST_TIMEOUT_MS = 5000;
    private static final int REQUEST_BACKUP_TIMEOUT_SECS = 60;

    private Context mContext;

    private int mIntValue;
    private boolean mBoolValue;
    private float mFloatValue;
    private long mLongValue;
    private String mStringValue;
    private String mFileContent1;
    private String mFileContent2;

    private boolean mSharedPrefTestSuccess;
    private CountDownLatch mLatch;
    private Intent mSharedPrefActivityIntent;
    private BackupManager mBackupManager;

    private final BroadcastReceiver mSharedPrefencesReceiver = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            Log.i(TAG, ""Received shared preference activity result broadcast"");
            mSharedPrefTestSuccess = intent.getBooleanExtra(EXTRA_SUCCESS, false);
            mLatch.countDown();
        }
    };

    @Before
    public void setUp() {
        Log.i(TAG, ""set up"");

        mContext = getTargetContext();
        mLatch = new CountDownLatch(1);
        mSharedPrefTestSuccess = false;
        mSharedPrefActivityIntent = new Intent()
                .setClassName(SHARED_PREFERENCES_RESTORE_PACKAGE_NAME,
                        SHARED_PREFERENCES_RESTORE_ACTIVITY_NAME)
                .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        mContext.registerReceiver(mSharedPrefencesReceiver, new IntentFilter(RESULT_ACTION));
        mBackupManager = new BackupManager(mContext);
    }

    @After
    public void tearDown() {
        mContext.unregisterReceiver(mSharedPrefencesReceiver);
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.cts.backup.keyvaluerestoreapp.KeyValueBackupRestoreTest"	"exists"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/backup/KeyValueApp/src/android/cts/backup/keyvaluerestoreapp/KeyValueBackupRestoreTest.java"	""	"public void checkSharedPrefActivity() throws Exception {
        mContext.startActivity(mSharedPrefActivityIntent.setAction(TEST_ACTION));

        assertTrue(""Activity test timed out"",
                mLatch.await(ACTIVITY_TEST_TIMEOUT_MS, TimeUnit.MILLISECONDS));
        assertTrue(""Shared preference value wasn't updated from the restore set"",
                mSharedPrefTestSuccess);
    }

    /** Saves predefined constant values to shared preferences and files. */
    private void saveSharedPreferencesValues() throws FileNotFoundException {
        SharedPreferences prefs = mContext.getSharedPreferences(TEST_PREFS_1, MODE_PRIVATE);
        SharedPreferences.Editor editor = prefs.edit();
        editor.putInt(INT_PREF, INT_PREF_VALUE);
        editor.putBoolean(BOOL_PREF, BOOL_PREF_VALUE);
        assertTrue(""Error committing shared preference 1 value"", editor.commit());

        prefs = mContext.getSharedPreferences(TEST_PREFS_2, MODE_PRIVATE);
        editor = prefs.edit();
        editor.putFloat(FLOAT_PREF, FLOAT_PREF_VALUE);
        editor.putLong(LONG_PREF, LONG_PREF_VALUE);
        editor.putString(STRING_PREF, STRING_PREF_VALUE);
        assertTrue(""Error committing shared preference 2 value"", editor.commit());

        File file = new File(mContext.getFilesDir(), TEST_FILE_1);
        PrintWriter writer = new PrintWriter(file);
        writer.write(TEST_FILE_1_DATA);
        writer.close();
        assertTrue(""Error writing file 1 data"", file.exists());

        file = new File(mContext.getFilesDir(), TEST_FILE_2);
        writer = new PrintWriter(file);
        writer.write(TEST_FILE_2_DATA);
        writer.close();
        assertTrue(""Error writing file 2 data"", file.exists());
    }

    private void readSharedPrefValues() throws InterruptedException {
        SharedPreferences prefs = mContext.getSharedPreferences(TEST_PREFS_1, MODE_PRIVATE);
        mIntValue = prefs.getInt(INT_PREF, DEFAULT_INT_VALUE);
        mBoolValue = prefs.getBoolean(BOOL_PREF, DEFAULT_BOOL_VALUE);

        prefs = mContext.getSharedPreferences(TEST_PREFS_2, MODE_PRIVATE);
        mFloatValue = prefs.getFloat(FLOAT_PREF, DEFAULT_FLOAT_VALUE);
        mLongValue = prefs.getLong(LONG_PREF, DEFAULT_LONG_VALUE);
        mStringValue = prefs.getString(STRING_PREF, DEFAULT_STRING_VALUE);

        mFileContent1 = readFileContent(TEST_FILE_1);
        mFileContent2 = readFileContent(TEST_FILE_2);

        Log.i(TAG, INT_PREF + "":"" + mIntValue + ""\n""
                + BOOL_PREF + "":"" + mBoolValue + ""\n""
                + FLOAT_PREF + "":"" + mFloatValue + ""\n""
                + LONG_PREF + "":"" + mLongValue + ""\n""
                + STRING_PREF + "":"" + mStringValue + ""\n""
                + TEST_FILE_1 + "":"" + mFileContent1 + ""\n""
                + TEST_FILE_2 + "":"" + mFileContent2 + ""\n"");
    }

    private String readFileContent(String fileName) {
        StringBuilder contents = new StringBuilder();
        Scanner scanner = null;
        try {
            scanner = new Scanner(new File(mContext.getFilesDir(), fileName));
            while (scanner.hasNext()) {
                contents.append(scanner.nextLine());
            }
            scanner.close();
        } catch (FileNotFoundException e) {
            Log.i(TAG, ""Couldn't find test file but this may be fine..."");
        } finally {
            if (scanner != null) {
                scanner.close();
            }
        }
        return contents.toString();
    }

    public static SharedPreferencesBackupHelper getSharedPreferencesBackupHelper(Context context) {
        return new SharedPreferencesBackupHelper(context, TEST_PREFS_1, TEST_PREFS_2);
    }

    public static FileBackupHelper getFileBackupHelper(Context context) {
        return new FileBackupHelper(context, TEST_FILE_1, TEST_FILE_2);
    }

    /**
     * This is not an actual test, but a device-side routine that's called from the host-side to
     * requestBackup.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.managedprofile.WifiTest"	"testCannotGetWifiMacAddress"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/ManagedProfile/src/com/android/cts/managedprofile/WifiTest.java"	""	"public void testCannotGetWifiMacAddress() {
        DevicePolicyManager dpm = getContext().getSystemService(DevicePolicyManager.class);
        try {
            dpm.getWifiMacAddress(BaseManagedProfileTest.ADMIN_RECEIVER_COMPONENT);
            fail(""Managed Profile owner shouldn't be able to get the MAC address"");
        } catch (SecurityException expected) {

        }
    }

    /**
     * Block until a network configuration with a certain SSID either exists or ceases to.
     * Wait for up to {@link WifiTest#UPDATE_TIMEOUT_MS} milliseconds, in increments of
     * {@link WifiTest#UPDATE_INTERVAL_MS}.
     */
    private boolean awaitNetworkState(String ssid, boolean exists) {
        for (int probes = 0; probes * UPDATE_INTERVAL_MS <= UPDATE_TIMEOUT_MS; probes++) {
            if (probes != 0) {
                SystemClock.sleep(UPDATE_INTERVAL_MS);
            }
            if ((getNetworkForSsid(ssid) != null) == exists) {
                return true;
            }
        }
        return false;
    }

    /**
     * Block until {@link WifiManager#isWifiEnabled()} returns {@param enabled}. Wait for up to
     * {@link WifiTest#UPDATE_TIMEOUT_MS} milliseconds, in increments of
     * {@link WifiTest#UPDATE_INTERVAL_MS}.
     */
    private void awaitWifiEnabledState(boolean enabled) throws RuntimeException {
        for (int probes = 0; probes * UPDATE_INTERVAL_MS <= UPDATE_TIMEOUT_MS; probes++) {
            if (probes != 0) {
                SystemClock.sleep(UPDATE_INTERVAL_MS);
            }
            if (mWifiManager.isWifiEnabled() == enabled) {
                return;
            }
        }
        throw new RuntimeException(""Waited too long for wifi enabled state = "" + enabled);
    }

    /**
     * Internal method to find an existing {@link WifiConfiguration} with the given SSID.
     *
     * @return A {@link WifiConfiguration} matching the specification, or {@code null} if no such
     *         configuration exists.
     */
    private WifiConfiguration getNetworkForSsid(String ssid) {
        if (!ssid.startsWith(""\"""")) {
            ssid = '""' + ssid + '""';
        }
        final List<WifiConfiguration> configs = mWifiManager.getConfiguredNetworks();
        if (configs != null) {
            for (WifiConfiguration config : configs) {
                if (ssid.equals(config.SSID)) {
                    return config;
                }
            }
        }
        return null;
    }
}"	""	""	"probe"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.media.cts.MediaRoute2ProviderServiceTest"	"testOnDiscoveryPreferenceChanged"	"CtsMediaTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/MediaRoute2ProviderServiceTest.java"	""	"public void testOnDiscoveryPreferenceChanged() throws Exception {
        CountDownLatch latch = new CountDownLatch(1);
        CountDownLatch latch2 = new CountDownLatch(1);

        RouteCallback routeCallback = new RouteCallback() {};
        RouteCallback routeCallback2 = new RouteCallback() {};

        List<String> featuresSample = Collections.singletonList(FEATURE_SAMPLE);
        List<String> featuresSpecial = Collections.singletonList(FEATURE_SPECIAL);

        setProxy(new Proxy() {
            @Override
            public void onDiscoveryPreferenceChanged(RouteDiscoveryPreference preference) {
                List<String> features = preference.getPreferredFeatures();
                if (features.contains(FEATURE_SAMPLE) && features.contains(FEATURE_SPECIAL)
                        && preference.shouldPerformActiveScan()) {
                    latch.countDown();
                }
                if (latch.getCount() == 0 && !features.contains(FEATURE_SAMPLE)
                    && features.contains(FEATURE_SPECIAL)) {
                    latch2.countDown();
                }
            }
        });

        mRouter2.registerRouteCallback(mExecutor, routeCallback,
                new RouteDiscoveryPreference.Builder(featuresSample, true).build());
        mRouter2.registerRouteCallback(mExecutor, routeCallback2,
                new RouteDiscoveryPreference.Builder(featuresSpecial, true).build());
        try {
            assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
            mRouter2.unregisterRouteCallback(routeCallback);
            assertTrue(latch2.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
        } finally {
            mRouter2.unregisterRouteCallback(routeCallback2);
        }
    }

    void setProxy(StubMediaRoute2ProviderService.Proxy proxy) {
        StubMediaRoute2ProviderService service = mService;
        if (service != null) {
            service.setProxy(proxy);
        }
    }

    Map<String, MediaRoute2Info> waitAndGetRoutes(List<String> features)
            throws Exception {
        CountDownLatch latch = new CountDownLatch(1);

        RouteCallback routeCallback = new RouteCallback() {
            @Override
            public void onRoutesAdded(List<MediaRoute2Info> routes) {
                for (MediaRoute2Info route : routes) {
                    if (!route.isSystemRoute()) {
                        latch.countDown();
                    }
                }
            }
        };

        mRouter2.registerRouteCallback(mExecutor, routeCallback,
                new RouteDiscoveryPreference.Builder(features, true).build());
        try {
            latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS);
            return createRouteMap(mRouter2.getRoutes());
        } finally {
            mRouter2.unregisterRouteCallback(routeCallback);
        }
    }

    // Helper for getting routes easily. Uses original ID as a key
    static Map<String, MediaRoute2Info> createRouteMap(List<MediaRoute2Info> routes) {
        Map<String, MediaRoute2Info> routeMap = new HashMap<>();
        for (MediaRoute2Info route : routes) {
            routeMap.put(route.getOriginalId(), route);
        }
        return routeMap;
    }

}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.bluetooth.ConnectionAccessServerActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/bluetooth/ConnectionAccessServerActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.bluetooth;

import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;

import android.app.AlertDialog;
import android.bluetooth.BluetoothAdapter;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.provider.Settings;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.Window;
import android.widget.Button;
import android.widget.TextView;
import android.widget.Toast;

public class ConnectionAccessServerActivity extends PassFailButtons.Activity {

    private static final String ACTION_CONNECTION_ACCESS_REQUEST =
            ""android.bluetooth.device.action.CONNECTION_ACCESS_REQUEST"";

    private static final int ENABLE_BLUETOOTH_REQUEST = 1;

    private BluetoothAdapter mBluetoothAdapter;
    private ConnectionAccessRequestReceiver mConnectionAccessRequestReceiver;
    private BluetoothChatService mChatService;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);
        setContentView(R.layout.bt_connection_access);
        setInfoResources(R.string.bt_connection_access_server,
                R.string.bt_connection_access_server_info, 0);
        setPassFailButtonClickListeners();
        getPassButton().setEnabled(false);

        View settings = findViewById(R.id.bt_settings);
        settings.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View view) {
                startActivity(new Intent(Settings.ACTION_BLUETOOTH_SETTINGS));
            }
        });

        Button makeDiscoverableButton = (Button) findViewById(R.id.bt_make_discoverable_button);
        makeDiscoverableButton.setVisibility(View.VISIBLE);
        makeDiscoverableButton.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                makeDiscoverable();
            }
        });

        mConnectionAccessRequestReceiver = new ConnectionAccessRequestReceiver();
        IntentFilter intentFilter = new IntentFilter(ACTION_CONNECTION_ACCESS_REQUEST);
        registerReceiver(mConnectionAccessRequestReceiver, intentFilter);

        mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
        if (mBluetoothAdapter.isEnabled()) {
            startChatService();
        } else {
            Intent intent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);
            startActivityForResult(intent, ENABLE_BLUETOOTH_REQUEST);
        }
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        switch (requestCode) {
            case ENABLE_BLUETOOTH_REQUEST:
                if (resultCode == RESULT_OK) {
                    startChatService();
                } else {
                    setResult(RESULT_CANCELED);
                    finish();
                }
                break;
        }
    }

    private void startChatService() {
        mChatService = new BluetoothChatService(this, new ChatHandler(),
                BluetoothChatService.HANDSFREE_INSECURE_UUID);
        boolean secure = false;
        mChatService.start(secure);
    }

    private void makeDiscoverable() {
        if (mBluetoothAdapter.getScanMode() !=
                BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE) {
            Intent intent = new Intent(BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE);
            intent.putExtra(BluetoothAdapter.EXTRA_DISCOVERABLE_DURATION, 30);
            startActivity(intent);
        }
    }

    private class ChatHandler extends Handler {
        @Override
        public void handleMessage(Message msg) {
            super.handleMessage(msg);
            switch (msg.what) {
                case BluetoothChatService.MESSAGE_STATE_CHANGE:
                    handleStateChange(msg);
                    break;

                case BluetoothChatService.MESSAGE_TOAST:
                    handleToast(msg);
                    break;
            }
        }
    }

    private void handleStateChange(Message msg) {
        int state = msg.arg1;
        switch (state) {
            case BluetoothChatService.STATE_LISTEN:
                setProgressBarIndeterminateVisibility(true);
                Toast.makeText(this, R.string.bt_listening, Toast.LENGTH_SHORT).show();
                break;
        }
    }

    private void handleToast(Message msg) {
        String toast = msg.getData().getString(BluetoothChatService.TOAST);
        Toast.makeText(this, toast, Toast.LENGTH_LONG).show();
    }

    class ConnectionAccessRequestReceiver extends BroadcastReceiver {
        @Override
        public void onReceive(Context context, Intent intent) {
            new AlertDialog.Builder(ConnectionAccessServerActivity.this)
                    .setMessage(R.string.bt_ca_dialog)
                    .setPositiveButton(android.R.string.ok, new DialogInterface.OnClickListener() {
                        @Override
                        public void onClick(DialogInterface dialog, int which) {
                            getPassButton().setEnabled(true);
                        }
                    })
                    .setNegativeButton(android.R.string.cancel,
                            new DialogInterface.OnClickListener() {
                        @Override
                        public void onClick(DialogInterface dialog, int which) {
                            getPassButton().setEnabled(false);
                        }
                    })
                    .show();
        }
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        if (mChatService != null) {
            mChatService.stop();
        }
        unregisterReceiver(mConnectionAccessRequestReceiver);
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.media.cts.MediaScannerConnectionTest"	"currentTimeMillis"	"CtsMediaTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/MediaScannerConnectionTest.java"	""	"public void test/*
 *.
 */

package android.media.cts;

import android.content.ComponentName;
import android.content.Context;
import android.media.MediaScannerConnection;
import android.media.MediaScannerConnection.MediaScannerConnectionClient;
import android.net.Uri;
import android.os.IBinder;
import android.platform.test.annotations.AppModeFull;
import android.test.AndroidTestCase;

import com.android.compatibility.common.util.FileCopyHelper;
import com.android.compatibility.common.util.PollingCheck;

import java.io.File;

@NonMediaMainlineTest
@AppModeFull(reason = ""TODO: evaluate and port to instant"")
public class MediaScannerConnectionTest extends AndroidTestCase {

    private static final String MEDIA_TYPE = ""audio/mpeg"";
    private File mMediaFile;
    private static final int TIME_OUT = 10000;
    private MockMediaScannerConnection mMediaScannerConnection;
    private MockMediaScannerConnectionClient mMediaScannerConnectionClient;

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        // prepare the media file.

        FileCopyHelper copier = new FileCopyHelper(mContext);
        String fileName = ""test"" + System.currentTimeMillis() + "".mp3"";
        File dir = getContext().getExternalMediaDirs()[0];
        mMediaFile = new File(dir, fileName);
        copier.copyToExternalStorage(R.raw.testmp3, mMediaFile);

        assertTrue(mMediaFile.exists());
    }

    @Override
    protected void tearDown() throws Exception {
        super.tearDown();
        if (mMediaFile != null) {
            mMediaFile.delete();
        }
        if (mMediaScannerConnection != null) {
            mMediaScannerConnection.disconnect();
            mMediaScannerConnection = null;
        }
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.media.cts.MediaScannerConnectionTest"	"testMediaScannerConnection"	"CtsMediaTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/MediaScannerConnectionTest.java"	""	"public void testMediaScannerConnection() throws InterruptedException {
        mMediaScannerConnectionClient = new MockMediaScannerConnectionClient();
        mMediaScannerConnection = new MockMediaScannerConnection(getContext(),
                                    mMediaScannerConnectionClient);

        assertFalse(mMediaScannerConnection.isConnected());

        // test connect and disconnect.
        mMediaScannerConnection.connect();
        checkConnectionState(true);

        mMediaScannerConnection.disconnect();

        checkConnectionState(false);

        mMediaScannerConnection.connect();

        checkConnectionState(true);

        mMediaScannerConnection.scanFile(mMediaFile.getAbsolutePath(), MEDIA_TYPE);

        checkMediaScannerConnection();

        assertEquals(mMediaFile.getAbsolutePath(), mMediaScannerConnectionClient.mediaPath);
        assertNotNull(mMediaScannerConnectionClient.mediaUri);
    }

    private void checkMediaScannerConnection() {
        new PollingCheck(TIME_OUT) {
            protected boolean check() {
                return mMediaScannerConnectionClient.isOnMediaScannerConnectedCalled;
            }
        }.run();
        new PollingCheck(TIME_OUT) {
            protected boolean check() {
                return mMediaScannerConnectionClient.mediaPath != null;
            }
        }.run();
    }

    private void checkConnectionState(final boolean expected) {
        new PollingCheck(TIME_OUT) {
            protected boolean check() {
                return mMediaScannerConnection.isConnected() == expected;
            }
        }.run();
    }

    class MockMediaScannerConnection extends MediaScannerConnection {
        public MockMediaScannerConnection(Context context, MediaScannerConnectionClient client) {
            super(context, client);
        }
    }

    class MockMediaScannerConnectionClient implements MediaScannerConnectionClient {

        public boolean isOnMediaScannerConnectedCalled;
        public String mediaPath;
        public Uri mediaUri;
        public void onMediaScannerConnected() {
            isOnMediaScannerConnectedCalled = true;
        }

        public void onScanCompleted(String path, Uri uri) {
            mediaPath = path;
            if (uri != null) {
                mediaUri = uri;
            }
        }

    }

}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.permission.cts.LocationAccessCheckTest"	"getPermissionControllerPackageName"	"CtsPermissionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/LocationAccessCheckTest.java"	""	"/*
 *.
 */

package android.permission.cts;

import static android.Manifest.permission.ACCESS_BACKGROUND_LOCATION;
import static android.Manifest.permission.ACCESS_FINE_LOCATION;
import static android.app.AppOpsManager.OPSTR_FINE_LOCATION;
import static android.app.AppOpsManager.OP_FLAGS_ALL_TRUSTED;
import static android.app.Notification.EXTRA_TITLE;
import static android.content.Context.BIND_AUTO_CREATE;
import static android.content.Context.BIND_NOT_FOREGROUND;
import static android.content.Intent.ACTION_BOOT_COMPLETED;
import static android.content.Intent.FLAG_RECEIVER_FOREGROUND;
import static android.location.Criteria.ACCURACY_FINE;
import static android.os.Process.myUserHandle;
import static android.provider.Settings.Secure.LOCATION_ACCESS_CHECK_DELAY_MILLIS;
import static android.provider.Settings.Secure.LOCATION_ACCESS_CHECK_INTERVAL_MILLIS;

import static com.android.compatibility.common.util.SystemUtil.runShellCommand;
import static com.android.compatibility.common.util.SystemUtil.runWithShellPermissionIdentity;
import static com.android.server.job.nano.JobPackageHistoryProto.START_PERIODIC_JOB;
import static com.android.server.job.nano.JobPackageHistoryProto.STOP_JOB;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.junit.Assume.assumeFalse;
import static org.junit.Assume.assumeTrue;

import static java.lang.Math.max;
import static java.util.concurrent.TimeUnit.MILLISECONDS;

import android.app.ActivityManager;
import android.app.AppOpsManager;
import android.app.UiAutomation;
import android.content.ComponentName;
import android.content.ContentResolver;
import android.content.Context;
import android.content.Intent;
import android.content.ServiceConnection;
import android.content.pm.PackageManager;
import android.content.pm.ResolveInfo;
import android.location.Criteria;
import android.location.Location;
import android.location.LocationListener;
import android.location.LocationManager;
import android.os.Bundle;
import android.os.IBinder;
import android.os.Looper;
import android.permission.cts.appthataccesseslocation.IAccessLocationOnCommand;
import android.platform.test.annotations.AppModeFull;
import android.platform.test.annotations.AsbSecurityTest;
import android.platform.test.annotations.SystemUserOnly;
import android.provider.DeviceConfig;
import android.provider.Settings;
import android.service.notification.NotificationListenerService;
import android.service.notification.StatusBarNotification;
import android.util.Log;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.test.InstrumentationRegistry;
import androidx.test.runner.AndroidJUnit4;

import com.android.compatibility.common.util.DeviceConfigStateHelper;
import com.android.compatibility.common.util.ProtoUtils;
import com.android.compatibility.common.util.mainline.MainlineModule;
import com.android.compatibility.common.util.mainline.ModuleDetector;
import com.android.server.job.nano.JobPackageHistoryProto;
import com.android.server.job.nano.JobSchedulerServiceDumpProto;
import com.android.server.job.nano.JobSchedulerServiceDumpProto.RegisteredJob;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.Arrays;
import java.util.List;
import java.util.concurrent.CountDownLatch;

/**
 * Tests the {@code LocationAccessCheck} in permission controller.
 */
@RunWith(AndroidJUnit4.class)
@AppModeFull(reason = ""Cannot set system settings as instant app. Also we never show a location ""
        + ""access check notification for instant apps."")
public class LocationAccessCheckTest {
    private static final String LOG_TAG = LocationAccessCheckTest.class.getSimpleName();

    private static final String TEST_APP_PKG = ""android.permission.cts.appthataccesseslocation"";
    private static final String TEST_APP_LABEL = ""CtsLocationAccess"";
    private static final String TEST_APP_SERVICE = TEST_APP_PKG + "".AccessLocationOnCommand"";
    private static final String TEST_APP_LOCATION_BG_ACCESS_APK =
            ""/data/local/tmp/cts/permissions/CtsAppThatAccessesLocationOnCommand.apk"";
    private static final String TEST_APP_LOCATION_FG_ACCESS_APK =
            ""/data/local/tmp/cts/permissions/AppThatDoesNotHaveBgLocationAccess.apk"";
    private static final int LOCATION_ACCESS_CHECK_JOB_ID = 0;

    /** Whether to show location access check notifications. */
    private static final String PROPERTY_LOCATION_ACCESS_CHECK_ENABLED =
            ""location_access_check_enabled"";

    private static final long UNEXPECTED_TIMEOUT_MILLIS = 10000;
    private static final long EXPECTED_TIMEOUT_MILLIS = 15000;
    private static final long LOCATION_ACCESS_TIMEOUT_MILLIS = 15000;

    private static final Context sContext = InstrumentationRegistry.getTargetContext();
    private static final ActivityManager sActivityManager =
            sContext.getSystemService(ActivityManager.class);
    private static final PackageManager sPackageManager = sContext.getPackageManager();
    private static final AppOpsManager sAppOpsManager =
            sContext.getSystemService(AppOpsManager.class);
    private static final UiAutomation sUiAutomation = InstrumentationRegistry.getInstrumentation()
            .getUiAutomation();

    private static final String PERMISSION_CONTROLLER_PKG = sContext.getPackageManager()
            .getPermissionControllerPackageName();

    /**
     * The result of {@link #assumeCanGetFineLocation()}, so we don't have to run it over and over
     * again.
     */
    private static Boolean sCanAccessFineLocation = null;

    private static ServiceConnection sConnection;
    private static IAccessLocationOnCommand sLocationAccessor;

    private DeviceConfigStateHelper mPrivacyDeviceConfig =
            new DeviceConfigStateHelper(DeviceConfig.NAMESPACE_PRIVACY);
    private static DeviceConfigStateHelper sJobSchedulerDeviceConfig =
            new DeviceConfigStateHelper(DeviceConfig.NAMESPACE_JOB_SCHEDULER);

    private static void assumeNotPlayManaged() throws Exception {
        assumeFalse(ModuleDetector.moduleIsPlayManaged(
                sContext.getPackageManager(), MainlineModule.PERMISSION_CONTROLLER));
    }

    /**
     * Connected to {@value #TEST_APP_PKG} and make it access the location in the background
     */
    private void accessLocation() throws Throwable {
        if (sConnection == null || sLocationAccessor == null) {
            bindService();
        }

        long beforeAccess = System.currentTimeMillis();
        // Wait a little to avoid raciness in timing between threads
        Thread.sleep(1000);

        // Try again until binder call goes though. It might not go through if the sLocationAccessor
        // is not bound yet
        eventually(() -> {
            assertNotNull(sLocationAccessor);
            sLocationAccessor.accessLocation();
        }, EXPECTED_TIMEOUT_MILLIS);

        // Wait until the access is recorded
        eventually(() -> {
            List<AppOpsManager.PackageOps> ops = runWithShellPermissionIdentity(
                    () -> sAppOpsManager.getOpsForPackage(
                            sPackageManager.getPackageUid(TEST_APP_PKG, 0), TEST_APP_PKG,
                            OPSTR_FINE_LOCATION));

            // Background access must have happened after ""beforeAccess""
            assertTrue(ops.get(0).getOps().get(0).getLastAccessBackgroundTime(OP_FLAGS_ALL_TRUSTED)
                    >= beforeAccess);
        }, EXPECTED_TIMEOUT_MILLIS);
    }

    /**
     * A {@link java.util.concurrent.Callable} that can throw a {@link Throwable}
     */
    private interface ThrowingCallable<T> {
        T call() throws Throwable;
    }

    /**
     * A {@link Runnable} that can throw a {@link Throwable}
     */
    private interface ThrowingRunnable {
        void run() throws Throwable;
    }

    /**
     * Make sure that a {@link ThrowingRunnable} eventually finishes without throwing a {@link
     * Exception}.
     *
     * @param r       The {@link ThrowingRunnable} to run.
     * @param timeout the maximum time to wait
     */
    public static void eventually(@NonNull ThrowingRunnable r, long timeout) throws Throwable {
        eventually(() -> {
            r.run();
            return 0;
        }, timeout);
    }

    /**
     * Make sure that a {@link ThrowingCallable} eventually finishes without throwing a {@link
     * Exception}.
     *
     * @param r       The {@link ThrowingCallable} to run.
     * @param timeout the maximum time to wait
     * @return the return value from the callable
     * @throws NullPointerException If the return value never becomes non-null
     */
    public static <T> T eventually(@NonNull ThrowingCallable<T> r, long timeout) throws Throwable {
        long start = System.currentTimeMillis();

        while (true) {
            try {
                T res = r.call();
                if (res == null) {
                    throw new NullPointerException(""No result"");
                }

                return res;
            } catch (Throwable e) {
                if (System.currentTimeMillis() - start < timeout) {
                    Log.d(LOG_TAG, ""Ignoring exception"", e);

                    Thread.sleep(500);
                } else {
                    throw e;
                }
            }
        }
    }

    /**
     * Get the state of the job scheduler
     */
    public static JobSchedulerServiceDumpProto getJobSchedulerDump() throws Exception {
        return ProtoUtils.getProto(sUiAutomation, JobSchedulerServiceDumpProto.class,
                ProtoUtils.DUMPSYS_JOB_SCHEDULER);
    }

    /**
     * Clear all data of a package including permissions and files.
     *
     * @param pkg The name of the package to be cleared
     */
    private static void clearPackageData(@NonNull String pkg) {
        unbindService();
        runShellCommand(""pm clear --user -2 "" + pkg);
    }

    /**
     * Get the last time the LOCATION_ACCESS_CHECK_JOB_ID job was started/stopped for permission
     * controller.
     *
     * @param event the job event (start/stop)
     *
     * @return the last time the event happened.
     */
    private static long getLastJobTime(int event) throws Exception {
        int permControllerUid = sPackageManager.getPackageUid(PERMISSION_CONTROLLER_PKG, 0);

        long lastTime = -1;

        for (JobPackageHistoryProto.HistoryEvent historyEvent :
                getJobSchedulerDump().history.historyEvent) {
            if (historyEvent.uid == permControllerUid
                    && historyEvent.jobId == LOCATION_ACCESS_CHECK_JOB_ID
                    && historyEvent.event == event) {
                lastTime = max(lastTime,
                        System.currentTimeMillis() - historyEvent.timeSinceEventMs);
            }
        }

        return lastTime;
    }

    /**
     * Force a run of the location check.
     */
    private static void runLocationCheck() throws Throwable {
        // Sleep a little bit to make sure we don't have overlap in timing
        Thread.sleep(1000);

        long beforeJob = System.currentTimeMillis();

        // Sleep a little bit to avoid raciness in time keeping
        Thread.sleep(1000);

        runShellCommand(
                ""cmd jobscheduler run -u "" + android.os.Process.myUserHandle().getIdentifier()
                        + "" -f "" + PERMISSION_CONTROLLER_PKG + "" 0"");

        eventually(() -> {
            long startTime = getLastJobTime(START_PERIODIC_JOB);
            assertTrue(startTime + "" !> "" + beforeJob, startTime > beforeJob);
        }, EXPECTED_TIMEOUT_MILLIS);

        // We can't simply require startTime <= endTime because the time being reported isn't
        // accurate, and sometimes the end time may come before the start time by around 100 ms.
        eventually(() -> {
            long stopTime = getLastJobTime(STOP_JOB);
            assertTrue(stopTime + "" !> "" + beforeJob, stopTime > beforeJob);
        }, EXPECTED_TIMEOUT_MILLIS);
    }

    /**
     * Get a notification thrown by the permission controller that is currently visible.
     *
     * @return The notification or {@code null} if there is none
     */
    private @Nullable StatusBarNotification getPermissionControllerNotification() throws Exception {
        NotificationListenerService notificationService = NotificationListener.getInstance();

        for (StatusBarNotification notification : notificationService.getActiveNotifications()) {
            if (notification.getPackageName().equals(PERMISSION_CONTROLLER_PKG)) {
                return notification;
            }
        }

        return null;
    }

    /**
     * Get a location access notification that is currently visible.
     *
     * @param cancelNotification if {@code true} the notification is canceled inside this method
     * @return The notification or {@code null} if there is none
     */
    private StatusBarNotification getNotification(boolean cancelNotification) throws Throwable {
        NotificationListenerService notificationService = NotificationListener.getInstance();

        StatusBarNotification notification = getPermissionControllerNotification();
        if (notification == null) {
            return null;
        }

        if (notification.getNotification().extras.getString(EXTRA_TITLE, """")
                .contains(TEST_APP_LABEL)) {
            if (cancelNotification) {
                notificationService.cancelNotification(notification.getKey());

                // Wait for notification to get canceled
                eventually(() -> assertFalse(
                        Arrays.asList(notificationService.getActiveNotifications()).contains(
                                notification)), UNEXPECTED_TIMEOUT_MILLIS);
            }

            return notification;
        }

        Log.d(LOG_TAG, ""Bad notification "" + notification);

        return null;
    }

    /**
     * Grant a permission to the {@value #TEST_APP_PKG}.
     *
     * @param permission The permission to grant
     */
    private void grantPermissionToTestApp(@NonNull String permission) {
        sUiAutomation.grantRuntimePermission(TEST_APP_PKG, permission);
    }

    /**
     * Register {@link NotificationListener}.
     */
    @BeforeClass
    public static void allowNotificationAccess() {
        runShellCommand(""cmd notification allow_listener "" + (new ComponentName(sContext,
                NotificationListener.class).flattenToString()));
    }

    /**
     * Change settings so that permission controller can show location access notifications more
     * often.
     */
    @BeforeClass
    public static void reduceDelays() {
        runWithShellPermissionIdentity(() -> {
            ContentResolver cr = sContext.getContentResolver();

            // New settings will be applied in when permission controller is reset
            Settings.Secure.putLong(cr, LOCATION_ACCESS_CHECK_INTERVAL_MILLIS, 100);
            Settings.Secure.putLong(cr, LOCATION_ACCESS_CHECK_DELAY_MILLIS, 50);

            // Disable job scheduler throttling by allowing 300000 jobs per 30 sec
            sJobSchedulerDeviceConfig.set(""qc_max_job_count_per_rate_limiting_window"", ""3000000"");
            sJobSchedulerDeviceConfig.set(""qc_rate_limiting_window_ms"", ""30000"");
        });
    }

    @BeforeClass
    public static void installBackgroundAccessApp() throws Exception {
        installBackgroundAccessApp(false);
    }

    private static void installBackgroundAccessApp(boolean isDowngrade) throws Exception {
        String command = ""pm install -r -g "";
        if (isDowngrade) {
            command = command + ""-d "";
        }
        String output = runShellCommand(command + TEST_APP_LOCATION_BG_ACCESS_APK);
        assertTrue(output.contains(""Success""));
        // Wait for user sensitive to be updated, which is checked by LocationAccessCheck.
        Thread.sleep(5000);
    }

    @AfterClass
    public static void uninstallBackgroundAccessApp() {
        unbindService();
        runShellCommand(""pm uninstall "" + TEST_APP_PKG);
    }

    private static void unbindService() {
        if (sConnection != null) {
            sContext.unbindService(sConnection);
        }
        sConnection = null;
        sLocationAccessor = null;
    }


    private static void installForegroundAccessApp() throws Exception {
        unbindService();
        runShellCommand(""pm install -r -g "" + TEST_APP_LOCATION_FG_ACCESS_APK);
        // Wait for user sensitive to be updated, which is checked by LocationAccessCheck.
        Thread.sleep(5000);
    }

    private static void uninstallForegroundAccessApp() {
        runShellCommand(""pm uninstall "" + TEST_APP_LOCATION_FG_ACCESS_APK);
    }

    /**
     * Skip each test for low ram device
     */
    @Before
    public void assumeIsNotLowRamDevice() {
        assumeFalse(sActivityManager.isLowRamDevice());
    }

    @Before
    public void wakeUpAndDismissKeyguard() {
        runShellCommand(""input keyevent KEYCODE_WAKEUP"");
        runShellCommand(""wm dismiss-keyguard"");
    }

    @Before
    public void bindService() {
        sConnection = new ServiceConnection() {
            @Override
            public void onServiceConnected(ComponentName name, IBinder service) {
                sLocationAccessor = IAccessLocationOnCommand.Stub.asInterface(service);
            }

            @Override
            public void onServiceDisconnected(ComponentName name) {
                sConnection = null;
                sLocationAccessor = null;
            }
        };

        Intent testAppService = new Intent();
        testAppService.setComponent(new ComponentName(TEST_APP_PKG, TEST_APP_SERVICE));

        sContext.bindService(testAppService, sConnection, BIND_AUTO_CREATE | BIND_NOT_FOREGROUND);
    }

    /**
     * Reset the permission controllers state before each test
     */
    @Before
    public void resetPermissionControllerBeforeEachTest() throws Throwable {
        // Has to be before resetPermissionController to make sure enablement time is the reset time
        // of permission controller
        enableLocationAccessCheck();

        resetPermissionController();

        eventually(() -> assertNull(getNotification(false)), UNEXPECTED_TIMEOUT_MILLIS);

        // Reset job scheduler stats (to allow more jobs to be run)
        runShellCommand(
                ""cmd jobscheduler reset-execution-quota -u "" + myUserHandle().getIdentifier() + "" ""
                        + PERMISSION_CONTROLLER_PKG);
    }

    /**
     * Enable location access check
     */
    public void enableLocationAccessCheck() throws Throwable {
        mPrivacyDeviceConfig.set(PROPERTY_LOCATION_ACCESS_CHECK_ENABLED, ""true"");

        // Run a location access check to update enabled state inside permission controller
        runLocationCheck();
    }

    /**
     * Disable location access check
     */
    private void disableLocationAccessCheck() throws Throwable {
        mPrivacyDeviceConfig.set(PROPERTY_LOCATION_ACCESS_CHECK_ENABLED, ""false"");

        // Run a location access check to update enabled state inside permission controller
        runLocationCheck();
    }

    /**
     * Make sure fine location can be accessed at all.
     */
    @Before
    public void assumeCanGetFineLocation() {
        if (sCanAccessFineLocation == null) {
            Criteria crit = new Criteria();
            crit.setAccuracy(ACCURACY_FINE);

            CountDownLatch locationCounter = new CountDownLatch(1);
            sContext.getSystemService(LocationManager.class).requestSingleUpdate(crit,
                    new LocationListener() {
                        @Override
                        public void onLocationChanged(Location location) {
                            locationCounter.countDown();
                        }

                        @Override
                        public void onStatusChanged(String provider, int status, Bundle extras) {
                        }

                        @Override
                        public void onProviderEnabled(String provider) {
                        }

                        @Override
                        public void onProviderDisabled(String provider) {
                        }
                    }, Looper.getMainLooper());


            try {
                sCanAccessFineLocation = locationCounter.await(LOCATION_ACCESS_TIMEOUT_MILLIS,
                        MILLISECONDS);
            } catch (InterruptedException ignored) {
            }
        }

        assumeTrue(sCanAccessFineLocation);
    }

    /**
     * Reset the permission controllers state.
     */
    private static void resetPermissionController() throws Throwable {
        clearPackageData(PERMISSION_CONTROLLER_PKG);
        int currentUserId = myUserHandle().getIdentifier();

        // Wait until jobs are cleared
        eventually(() -> {
            JobSchedulerServiceDumpProto dump = getJobSchedulerDump();

            for (RegisteredJob job : dump.registeredJobs) {
                if (job.dump.sourceUserId == currentUserId) {
                    assertNotEquals(job.dump.sourcePackageName, PERMISSION_CONTROLLER_PKG);
                }
            }
        }, UNEXPECTED_TIMEOUT_MILLIS);

        // Setup up permission controller again (simulate a reboot)
        Intent permissionControllerSetupIntent = null;
        for (ResolveInfo ri : sContext.getPackageManager().queryBroadcastReceivers(
                new Intent(ACTION_BOOT_COMPLETED), 0)) {
            String pkg = ri.activityInfo.packageName;

            if (pkg.equals(PERMISSION_CONTROLLER_PKG)) {
                permissionControllerSetupIntent = new Intent()
                        .setClassName(pkg, ri.activityInfo.name)
                        .setFlags(FLAG_RECEIVER_FOREGROUND)
                        .setPackage(PERMISSION_CONTROLLER_PKG);

                sContext.sendBroadcast(permissionControllerSetupIntent);
            }
        }

        // Wait until jobs are set up
        eventually(() -> {
            JobSchedulerServiceDumpProto dump = getJobSchedulerDump();

            for (RegisteredJob job : dump.registeredJobs) {
                if (job.dump.sourceUserId == currentUserId
                        && job.dump.sourcePackageName.equals(PERMISSION_CONTROLLER_PKG)
                        && job.dump.jobInfo.service.className.contains(""LocationAccessCheck"")) {
                    return;
                }
            }

            fail(""Permission controller jobs not found"");
        }, UNEXPECTED_TIMEOUT_MILLIS);
    }

    /**
     * Unregister {@link NotificationListener}.
     */
    @AfterClass
    public static void disallowNotificationAccess() {
        runShellCommand(""cmd notification disallow_listener "" + (new ComponentName(sContext,
                NotificationListener.class)).flattenToString());
    }

    /**
     * Reset settings so that permission controller runs normally.
     */
    @AfterClass
    public static void resetDelays() throws Throwable {
        runWithShellPermissionIdentity(() -> {
            ContentResolver cr = sContext.getContentResolver();

            Settings.Secure.resetToDefaults(cr, LOCATION_ACCESS_CHECK_INTERVAL_MILLIS);
            Settings.Secure.resetToDefaults(cr, LOCATION_ACCESS_CHECK_DELAY_MILLIS);

            sJobSchedulerDeviceConfig.restoreOriginalValues();
        });
    }

    /**
     * Reset location access check
     */
    @After
    public void resetPrivacyConfig() throws Throwable {
        mPrivacyDeviceConfig.restoreOriginalValues();

        // Run a location access check to update enabled state inside permission controller
        runLocationCheck();
    }

    @After
    public void locationUnbind() throws Throwable {
        unbindService();
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.display.cts.DisplayTest"	"finish"	"CtsDisplayTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/display/src/android/display/cts/DisplayTest.java"	""	"/*
 *.
 */

package android.display.cts;

import static android.content.pm.PackageManager.FEATURE_LEANBACK;
import static android.view.Display.DEFAULT_DISPLAY;

import static androidx.test.platform.app.InstrumentationRegistry.getInstrumentation;

import static org.junit.Assert.*;
import static org.junit.Assume.*;

import android.Manifest;
import android.app.Activity;
import android.app.Instrumentation;
import android.app.Presentation;
import android.app.UiModeManager;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.content.res.Configuration;
import android.graphics.Color;
import android.graphics.ColorSpace;
import android.graphics.PixelFormat;
import android.graphics.Point;
import android.hardware.display.DeviceProductInfo;
import android.hardware.display.DisplayManager;
import android.hardware.display.DisplayManager.DisplayListener;
import android.os.Build;
import android.os.Bundle;
import android.os.Handler;
import android.os.IBinder;
import android.os.Looper;
import android.os.ParcelFileDescriptor;
import android.os.SystemProperties;
import android.platform.test.annotations.Presubmit;
import android.provider.Settings;
import android.text.TextUtils;
import android.util.DisplayMetrics;
import android.util.Log;
import android.view.Display;
import android.view.Display.HdrCapabilities;
import android.view.SurfaceControl;
import android.view.View;
import android.view.ViewGroup;
import android.view.WindowManager;

import androidx.test.InstrumentationRegistry;
import androidx.test.rule.ActivityTestRule;
import androidx.test.runner.AndroidJUnit4;

import com.android.compatibility.common.util.AdoptShellPermissionsRule;
import com.android.compatibility.common.util.DisplayUtil;
import com.android.compatibility.common.util.PropertyUtil;

import org.junit.After;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.io.FileInputStream;
import java.io.InputStream;
import java.time.Duration;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
import java.util.Random;
import java.util.Scanner;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.function.Predicate;

@RunWith(AndroidJUnit4.class)
public class DisplayTest {
    private static final String TAG = ""DisplayTest"";

    // The CTS package brings up an overlay display on the target device (see AndroidTest.xml).
    // The overlay display parameters must match the ones defined there which are
    // 181x161/214 (wxh/dpi).  It only matters that these values are different from any real
    // display.

    private static final int SECONDARY_DISPLAY_WIDTH = 181;
    private static final int SECONDARY_DISPLAY_HEIGHT = 161;
    private static final int SECONDARY_DISPLAY_DPI = 214;
    private static final float SCALE_DENSITY_LOWER_BOUND =
            (float)(SECONDARY_DISPLAY_DPI - 1) / DisplayMetrics.DENSITY_DEFAULT;
    private static final float SCALE_DENSITY_UPPER_BOUND =
            (float)(SECONDARY_DISPLAY_DPI + 1) / DisplayMetrics.DENSITY_DEFAULT;
    // Matches com.android.internal.R.string.display_manager_overlay_display_name.
    private static final String OVERLAY_DISPLAY_NAME_PREFIX = ""Overlay #"";

    private static final int BRIGHTNESS_MAX = 255;

    private DisplayManager mDisplayManager;
    private WindowManager mWindowManager;
    private UiModeManager mUiModeManager;
    private Context mContext;
    private ColorSpace[] mSupportedWideGamuts;
    private Display mDefaultDisplay;
    private HdrSettings mOriginalHdrSettings;

    // To test display mode switches.
    private TestPresentation mPresentation;

    private Activity mScreenOnActivity;

    private static class DisplayModeState {
        public final int mHeight;
        public final int mWidth;
        public final float mRefreshRate;

        DisplayModeState(Display display) {
            mHeight = display.getMode().getPhysicalHeight();
            mWidth = display.getMode().getPhysicalWidth();

            // Starting Android S the, the platform might throttle down
            // applications frame rate to a divisor of the refresh rate instead if changing the
            // physical display refresh rate. Applications should use
            // {@link android.view.Display#getRefreshRate} to know their frame rate as opposed to
            // {@link android.view.Display.Mode#getRefreshRate} that returns the physical display
            // refresh rate. See
            // {@link com.android.server.display.DisplayManagerService.DISPLAY_MODE_RETURNS_PHYSICAL_REFRESH_RATE}
            // for more details.
            mRefreshRate = display.getRefreshRate();
        }

        @Override
        public boolean equals(Object obj) {
            if (!(obj instanceof DisplayModeState)) {
                return false;
            }

            DisplayModeState other = (DisplayModeState) obj;
            return mHeight == other.mHeight
                && mWidth == other.mWidth
                && mRefreshRate == other.mRefreshRate;
        }

        @Override
        public String toString() {
            return new StringBuilder(""{"")
                    .append(""width="").append(mWidth)
                    .append("", height="").append(mHeight)
                    .append("", fps="").append(mRefreshRate)
                    .append(""}"")
                    .toString();
        }
    }

    @Rule
    public ActivityTestRule<DisplayTestActivity> mDisplayTestActivity =
            new ActivityTestRule<>(
                    DisplayTestActivity.class,
                    false /* initialTouchMode */,
                    false /* launchActivity */);

    @Rule
    public ActivityTestRule<RetainedDisplayTestActivity> mRetainedDisplayTestActivity =
            new ActivityTestRule<>(
                    RetainedDisplayTestActivity.class,
                    false /* initialTouchMode */,
                    false /* launchActivity */);

    /**
     * This rule adopts the Shell process permissions, needed because OVERRIDE_DISPLAY_MODE_REQUESTS
     * and ACCESS_SURFACE_FLINGER are privileged permission.
     */
    @Rule
    public AdoptShellPermissionsRule mAdoptShellPermissionsRule = new AdoptShellPermissionsRule(
            InstrumentationRegistry.getInstrumentation().getUiAutomation(),
            Manifest.permission.OVERRIDE_DISPLAY_MODE_REQUESTS,
            Manifest.permission.ACCESS_SURFACE_FLINGER,
            Manifest.permission.WRITE_SECURE_SETTINGS,
            Manifest.permission.HDMI_CEC);

    @Before
    public void setUp() throws Exception {
        mScreenOnActivity = launchScreenOnActivity();
        mContext = getInstrumentation().getTargetContext();
        assertTrue(""Physical display is expected."", DisplayUtil.isDisplayConnected(mContext));

        mDisplayManager = mContext.getSystemService(DisplayManager.class);
        mWindowManager = mContext.getSystemService(WindowManager.class);
        mUiModeManager = mContext.getSystemService(UiModeManager.class);
        mDefaultDisplay = mDisplayManager.getDisplay(DEFAULT_DISPLAY);
        mSupportedWideGamuts = mDefaultDisplay.getSupportedWideColorGamut();
        mOriginalHdrSettings = new HdrSettings();
        cacheAndClearOriginalHdrSettings();
    }

    @After
    public void tearDown() throws Exception {
        restoreOriginalHdrSettings();
        if (mScreenOnActivity != null) {
            mScreenOnActivity.finish();
        }
    }

    private void enableAppOps() {
        StringBuilder cmd = new StringBuilder();
        cmd.append(""appops set "");
        cmd.append(InstrumentationRegistry.getInstrumentation().getContext().getPackageName());
        cmd.append("" android:system_alert_window allow"");
        InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .executeShellCommand(cmd.toString());

        StringBuilder query = new StringBuilder();
        query.append(""appops get "");
        query.append(InstrumentationRegistry.getInstrumentation().getContext().getPackageName());
        query.append("" android:system_alert_window"");
        String queryStr = query.toString();

        String result = ""No operations."";
        while (result.contains(""No operations"")) {
            ParcelFileDescriptor pfd = InstrumentationRegistry.getInstrumentation()
                    .getUiAutomation().executeShellCommand(queryStr);
            InputStream inputStream = new FileInputStream(pfd.getFileDescriptor());
            result = convertStreamToString(inputStream);
        }
    }

    private String convertStreamToString(InputStream is) {
        try (java.util.Scanner s = new Scanner(is).useDelimiter(""\\A"")) {
            return s.hasNext() ? s.next() : """";
        }
    }

    /** Check if the display is an overlay display, created by this test. */
    private boolean isSecondaryDisplay(Display display) {
        return display.getType() == Display.TYPE_OVERLAY;
    }

    /** Get the overlay display, created by this test. */
    private Display getSecondaryDisplay(Display[] displays) {
        for (Display display : displays) {
            if (isSecondaryDisplay(display)) {
                return display;
            }
        }
        return null;
    }

    /**
     * Verify that the getDisplays method returns both a default and an overlay display.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.appsecurity.cts.UseProcessTest"	"testInstallUsePackageFailApplication_instant"	"CtsAppSecurityHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/UseProcessTest.java"	""	"@AppModeInstant(reason = ""'instant' portion of the hostside test"")
    public void testInstallUsePackageFailApplication_instant() throws Exception {
        testInstallUsePackageFailApplication(true);
    }
    private void testInstallUsePackageFailApplication(boolean instant) throws Exception {
        new InstallMultiple(instant).addFile(APK_FAIL_APPLICATION).runExpectingFailure(
                ""Failure [INSTALL_FAILED_PROCESS_NOT_DEFINED: Scanning Failed.: "" +
                        ""Can't install because application"");
        assertTrue(!getDevice().getInstalledPackageNames().contains(PKG));
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.appsecurity.cts.UseProcessTest"	"testInstallUsePackageFailActivity_instant"	"CtsAppSecurityHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/UseProcessTest.java"	""	"@AppModeInstant(reason = ""'instant' portion of the hostside test"")
    public void testInstallUsePackageFailActivity_instant() throws Exception {
        testInstallUsePackageFailActivity(true);
    }
    private void testInstallUsePackageFailActivity(boolean instant) throws Exception {
        new InstallMultiple(instant).addFile(APK_FAIL_ACTIVITY).runExpectingFailure(
                ""Failure [INSTALL_FAILED_PROCESS_NOT_DEFINED: Scanning Failed.: "" +
                        ""Can't install because activity com.android.cts.useprocess.DummyActivity"");
        assertTrue(!getDevice().getInstalledPackageNames().contains(PKG));
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.appsecurity.cts.UseProcessTest"	"testInstallUsePackageFailService_instant"	"CtsAppSecurityHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/UseProcessTest.java"	""	"@AppModeInstant(reason = ""'instant' portion of the hostside test"")
    public void testInstallUsePackageFailService_instant() throws Exception {
        testInstallUsePackageFailService(true);
    }
    private void testInstallUsePackageFailService(boolean instant) throws Exception {
        new InstallMultiple(instant).addFile(APK_FAIL_SERVICE).runExpectingFailure(
                ""Failure [INSTALL_FAILED_PROCESS_NOT_DEFINED: Scanning Failed.: "" +
                        ""Can't install because service com.android.cts.useprocess.DummyService"");
        assertTrue(!getDevice().getInstalledPackageNames().contains(PKG));
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.appsecurity.cts.UseProcessTest"	"testInstallUsePackageFailReceiver_instant"	"CtsAppSecurityHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/UseProcessTest.java"	""	"@AppModeInstant(reason = ""'instant' portion of the hostside test"")
    public void testInstallUsePackageFailReceiver_instant() throws Exception {
        testInstallUsePackageFailReceiver(true);
    }
    private void testInstallUsePackageFailReceiver(boolean instant) throws Exception {
        new InstallMultiple(instant).addFile(APK_FAIL_RECEIVER).runExpectingFailure(
                ""Failure [INSTALL_FAILED_PROCESS_NOT_DEFINED: Scanning Failed.: "" +
                        ""Can't install because receiver com.android.cts.useprocess.DummyReceiver"");
        assertTrue(!getDevice().getInstalledPackageNames().contains(PKG));
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.appsecurity.cts.UseProcessTest"	"testInstallUsePackageFailProvider_instant"	"CtsAppSecurityHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/UseProcessTest.java"	""	"@AppModeInstant(reason = ""'instant' portion of the hostside test"")
    public void testInstallUsePackageFailProvider_instant() throws Exception {
        testInstallUsePackageFailProvider(true);
    }
    private void testInstallUsePackageFailProvider(boolean instant) throws Exception {
        new InstallMultiple(instant).addFile(APK_FAIL_PROVIDER).runExpectingFailure(
                ""Failure [INSTALL_FAILED_PROCESS_NOT_DEFINED: Scanning Failed.: "" +
                        ""Can't install because provider com.android.cts.useprocess.DummyProvider"");
        assertTrue(!getDevice().getInstalledPackageNames().contains(PKG));
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.cts.statsdatom.wifi.WifiStatsTests"	"testWifiScanLogsScanAtoms"	"CtsStatsdAtomHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/wifi/WifiStatsTests.java"	""	"public void testWifiScanLogsScanAtoms() throws Exception {
        if (!DeviceUtils.hasFeature(getDevice(), FEATURE_WIFI)) return;

        ConfigUtils.uploadConfigForPushedAtom(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                AtomsProto.Atom.WIFI_SCAN_REPORTED_FIELD_NUMBER);
        DeviceUtils.runDeviceTestsOnStatsdApp(getDevice(), "".AtomTests"", ""testWifiScan"");
        Thread.sleep(AtomTestUtils.WAIT_TIME_SHORT);

        List<StatsLog.EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());
        assertThat(data).hasSize(2);

        AtomsProto.WifiScanReported a0 = data.get(0).getAtom().getWifiScanReported();
        AtomsProto.WifiScanReported a1 = data.get(1).getAtom().getWifiScanReported();

        for (AtomsProto.WifiScanReported a : new AtomsProto.WifiScanReported[]{a0, a1}) {
            assertThat(a.getResult()).isEqualTo(AtomsProto.WifiScanReported.Result.RESULT_SUCCESS);
            assertThat(a.getType()).isEqualTo(AtomsProto.WifiScanReported.Type.TYPE_SINGLE);
            assertThat(a.getSource()).isAnyOf(
                    // If this test is run on a device that has a Settings app open that
                    // continuously performs frequent scans, quite often our scans requests
                    // are bundled together and get attributed to the Settings app.
                    AtomsProto.WifiScanReported.Source.SOURCE_SETTINGS_APP,
                    AtomsProto.WifiScanReported.Source.SOURCE_OTHER_APP);
            assertThat(a.getImportance()).isEqualTo(
                    AtomsProto.WifiScanReported.Importance.IMPORTANCE_FOREGROUND_SERVICE);

            assertThat(a.getScanDurationMillis()).isGreaterThan(0);
        }
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.cts.statsdatom.wifi.WifiStatsTests"	"testWifiScanLogsStateChangedAtoms"	"CtsStatsdAtomHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/wifi/WifiStatsTests.java"	""	"public void testWifiScanLogsStateChangedAtoms() throws Exception {
        if (!DeviceUtils.hasFeature(getDevice(), FEATURE_WIFI)) return;


        ConfigUtils.uploadConfigForPushedAtomWithUid(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                AtomsProto.Atom.WIFI_SCAN_STATE_CHANGED_FIELD_NUMBER,  true);
        DeviceUtils.runDeviceTestsOnStatsdApp(getDevice(), "".AtomTests"", ""testWifiScan"");
        Thread.sleep(AtomTestUtils.WAIT_TIME_SHORT);

        final int stateOn = AtomsProto.WifiScanStateChanged.State.ON_VALUE;
        final int stateOff = AtomsProto.WifiScanStateChanged.State.OFF_VALUE;
        final int minTimeDiffMillis = 250;
        final int maxTimeDiffMillis = 60_000;

        List<StatsLog.EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());
        assertThat(data.size()).isIn(Range.closed(2, 4));
        AtomTestUtils.assertTimeDiffBetween(data.get(0), data.get(1), minTimeDiffMillis,
                maxTimeDiffMillis);
        AtomsProto.WifiScanStateChanged a0 = data.get(0).getAtom().getWifiScanStateChanged();
        AtomsProto.WifiScanStateChanged a1 = data.get(1).getAtom().getWifiScanStateChanged();
        assertThat(a0.getState().getNumber()).isEqualTo(stateOn);
        assertThat(a1.getState().getNumber()).isEqualTo(stateOff);
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.provider.cts.media.MediaStoreTrashedTest"	"testOwned"	"CtsProviderTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/provider/src/android/provider/cts/media/MediaStoreTrashedTest.java"	""	"public void testOwned() throws Exception {
        Assume.assumeFalse(MediaStore.VOLUME_EXTERNAL.equals(mVolumeName));

        final File dir = ProviderTestUtils.getVolumePath(mVolumeName);
        final File file = ProviderTestUtils.stageFile(R.drawable.scenery,
                Environment.buildPath(dir, ""DCIM"", System.nanoTime() + "".jpg""));
        final Uri uri = ProviderTestUtils.scanFile(file);
        ProviderTestUtils.setOwner(uri, InstrumentationRegistry.getContext().getPackageName());

        doTrashed(file, uri);
    }

    /**
     * Verify that we can trash and untrash items we don't own.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.provider.cts.media.MediaStoreTrashedTest"	"testUnowned"	"CtsProviderTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/provider/src/android/provider/cts/media/MediaStoreTrashedTest.java"	""	"public void testUnowned() throws Exception {
        Assume.assumeFalse(MediaStore.VOLUME_EXTERNAL.equals(mVolumeName));

        final File dir = ProviderTestUtils.getVolumePath(mVolumeName);
        final File file = ProviderTestUtils.stageFile(R.drawable.scenery,
                Environment.buildPath(dir, ""DCIM"", System.nanoTime() + "".jpg""));
        final Uri uri = ProviderTestUtils.scanFile(file);
        ProviderTestUtils.clearOwner(uri);

        doTrashed(file, uri);
    }

    /**
     * Verify that we can trash and untrash items in odd locations.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.provider.cts.media.MediaStoreTrashedTest"	"testAtypical"	"CtsProviderTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/provider/src/android/provider/cts/media/MediaStoreTrashedTest.java"	""	"public void testAtypical() throws Exception {
        Assume.assumeFalse(MediaStore.VOLUME_EXTERNAL.equals(mVolumeName));

        final File dir = ProviderTestUtils.getVolumePath(mVolumeName);
        final File file = ProviderTestUtils.stageFile(R.drawable.scenery,
                Environment.buildPath(dir, ""NOT_DCIM"", System.nanoTime() + "".jpg""));
        final Uri uri = ProviderTestUtils.scanFile(file);
        ProviderTestUtils.clearOwner(uri);

        doTrashed(file, uri);
    }

    private void doTrashed(File file, Uri uri) {
        final ContentValues values = new ContentValues();

        // When trashed, display name needs to remain intact
        values.clear();
        values.put(MediaColumns.IS_TRASHED, 1);
        mResolver.update(uri, values, null);
        try (Cursor c = mResolver.query(uri, null, null, null)) {
            assertTrue(c.moveToFirst());
            assertEquals(1,
                    c.getInt(c.getColumnIndexOrThrow(MediaColumns.IS_TRASHED)));
            assertEquals(file.getName(),
                    c.getString(c.getColumnIndexOrThrow(MediaColumns.DISPLAY_NAME)));
        }

        // When untrashed, we returned back to original file
        values.clear();
        values.put(MediaColumns.IS_TRASHED, 0);
        mResolver.update(uri, values, null);
        try (Cursor c = mResolver.query(uri, null, null, null)) {
            assertTrue(c.moveToFirst());
            assertEquals(0,
                    c.getInt(c.getColumnIndexOrThrow(MediaColumns.IS_TRASHED)));
            assertEquals(file.getName(),
                    c.getString(c.getColumnIndexOrThrow(MediaColumns.DISPLAY_NAME)));
            assertEquals(file.getAbsolutePath(),
                    c.getString(c.getColumnIndexOrThrow(MediaColumns.DATA)));
        }
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.print.cts.InterfaceForAppsTest"	"createFirstMockPrinterDiscoverySessionCallbacks"	"CtsPrintTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/print/src/android/print/cts/InterfaceForAppsTest.java"	""	"/*
 *.
 */

package android.print.cts;

import static android.print.test.Utils.eventually;
import static android.print.test.Utils.getPrintJob;
import static android.print.test.Utils.getPrintManager;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import android.print.PrintAttributes;
import android.print.PrintDocumentAdapter;
import android.print.PrintJob;
import android.print.PrintJobInfo;
import android.print.PrinterCapabilitiesInfo;
import android.print.PrinterId;
import android.print.PrinterInfo;
import android.print.test.BasePrintTest;
import android.print.test.services.FirstPrintService;
import android.print.test.services.PrintServiceCallbacks;
import android.print.test.services.PrinterDiscoverySessionCallbacks;
import android.print.test.services.SecondPrintService;
import android.print.test.services.StubbablePrinterDiscoverySession;
import android.util.Log;

import androidx.annotation.NonNull;
import androidx.test.runner.AndroidJUnit4;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.ArrayList;

/**
 * Test interface from the application to the print service.
 */
@RunWith(AndroidJUnit4.class)
public class InterfaceForAppsTest extends BasePrintTest {
    private static final String TEST_PRINTER = ""Test printer"";
    private static final String LOG_TAG = ""InterfaceForAppsTest"";

    private static final PrintAttributes.Resolution TWO_HUNDRED_DPI =
            new PrintAttributes.Resolution(""200x200"", ""200dpi"", 200, 200);
    private static boolean sHasBeenSetUp;

    /**
     * Create a mock {@link PrinterDiscoverySessionCallbacks} that discovers a simple test printer.
     *
     * @return The mock session callbacks
     */
    private @NonNull PrinterDiscoverySessionCallbacks createFirstMockPrinterDiscoverySessionCallbacks() {
        return createMockPrinterDiscoverySessionCallbacks(invocation -> {
            StubbablePrinterDiscoverySession session = ((PrinterDiscoverySessionCallbacks) invocation
                    .getMock()).getSession();

            if (session.getPrinters().isEmpty()) {
                PrinterId printerId = session.getService().generatePrinterId(TEST_PRINTER);
                PrinterInfo.Builder printer = new PrinterInfo.Builder(
                        session.getService().generatePrinterId(TEST_PRINTER), TEST_PRINTER,
                        PrinterInfo.STATUS_IDLE);

                printer.setCapabilities(new PrinterCapabilitiesInfo.Builder(printerId)
                        .addMediaSize(PrintAttributes.MediaSize.ISO_A5, true)
                        .addMediaSize(PrintAttributes.MediaSize.ISO_A3, false)
                        .addResolution(TWO_HUNDRED_DPI, true)
                        .setColorModes(PrintAttributes.COLOR_MODE_MONOCHROME
                                        | PrintAttributes.COLOR_MODE_COLOR,
                                PrintAttributes.COLOR_MODE_MONOCHROME)
                        .setDuplexModes(PrintAttributes.DUPLEX_MODE_NONE
                                        | PrintAttributes.DUPLEX_MODE_LONG_EDGE,
                                PrintAttributes.DUPLEX_MODE_NONE)
                        .setMinMargins(new PrintAttributes.Margins(0, 0, 0, 0)).build());

                ArrayList<PrinterInfo> printers = new ArrayList<>(1);
                printers.add(printer.build());

                session.addPrinters(printers);
            }
            return null;
        }, null, null, invocation -> null, null, null, invocation -> {
            // Take a note onDestroy was called.
            onPrinterDiscoverySessionDestroyCalled();
            return null;
        });
    }

    /**
     * Create mock service callback for a session. Once the job is queued the test function is
     * called.
     *
     * @param sessionCallbacks The callbacks of the session
     * @param blockAfterState  The state the print services should progress to
     */
    private @NonNull PrintServiceCallbacks createFirstMockPrinterServiceCallbacks(
            final @NonNull PrinterDiscoverySessionCallbacks sessionCallbacks, int blockAfterState) {
        return createMockPrintServiceCallbacks(
                invocation -> sessionCallbacks, invocation -> {
                    android.printservice.PrintJob job = (android.printservice.PrintJob) invocation
                            .getArguments()[0];

                    switch (blockAfterState) {
                        case PrintJobInfo.STATE_CREATED:
                            eventually(() -> assertEquals(PrintJobInfo.STATE_CREATED,
                                    job.getInfo().getState()));
                            break;
                        case PrintJobInfo.STATE_STARTED:
                            eventually(() -> assertTrue(job.isQueued()));
                            job.start();
                            break;
                        case PrintJobInfo.STATE_QUEUED:
                            eventually(() -> assertTrue(job.isQueued()));
                            break;
                        case PrintJobInfo.STATE_BLOCKED:
                            eventually(() -> assertTrue(job.isQueued()));
                            job.start();
                            job.block(""test block"");
                            break;
                        case PrintJobInfo.STATE_FAILED:
                            eventually(() -> assertTrue(job.isQueued()));
                            job.start();
                            job.fail(""test fail"");
                            break;
                        case PrintJobInfo.STATE_COMPLETED:
                            eventually(() -> assertTrue(job.isQueued()));
                            job.start();
                            job.complete();
                            break;
                        default:
                            throw new Exception(""Should not be reached"");
                    }

                    return null;
                }, invocation -> {
                    android.printservice.PrintJob job = (android.printservice.PrintJob) invocation
                            .getArguments()[0];

                    job.cancel();
                    Log.d(LOG_TAG, ""job.cancel()"");

                    return null;
                });
    }

    /**
     * Setup mock print subsystem
     *
     * @param blockAfterState Tell the print service to block all print jobs at this state
     *
     * @return The print document adapter to be used for printing
     */
    private @NonNull PrintDocumentAdapter setupPrint(int blockAfterState) {
        // Create the session of the printers that we will be checking.
        PrinterDiscoverySessionCallbacks sessionCallbacks = createFirstMockPrinterDiscoverySessionCallbacks();

        // Create the service callbacks for the first print service.
        PrintServiceCallbacks serviceCallbacks = createFirstMockPrinterServiceCallbacks(
                sessionCallbacks, blockAfterState);

        // Configure the print services.
        FirstPrintService.setCallbacks(serviceCallbacks);

        // We don't use the second service, but we have to still configure it
        SecondPrintService.setCallbacks(createMockPrintServiceCallbacks(null, null, null));

        return createDefaultPrintDocumentAdapter(1);
    }

    @Before
    public void setPrinter() throws Throwable {
        if (!sHasBeenSetUp) {
            resetCounters();
            PrintDocumentAdapter adapter = setupPrint(PrintJobInfo.STATE_COMPLETED);
            makeDefaultPrinter(adapter, TEST_PRINTER);

            sHasBeenSetUp = true;
        }

        resetCounters();
    }

    /**
     * Base test for all cancel print job tests
     *
     * @param cancelAfterState The print job state state to progress to canceling
     * @param printJobName     The print job name to use
     *
     * @throws Exception If anything is unexpected
     */
    private void cancelPrintJobBaseTest(int cancelAfterState, @NonNull String printJobName)
            throws Throwable {
        PrintDocumentAdapter adapter = setupPrint(cancelAfterState);

        print(adapter, printJobName);
        waitForWriteAdapterCallback(1);
        mPrintHelper.submitPrintJob();

        PrintJob job = getPrintJob(getPrintManager(getActivity()), printJobName);

        // Check getState
        eventually(() -> assertEquals(cancelAfterState, job.getInfo().getState()));

        // Check
        switch (cancelAfterState) {
            case PrintJobInfo.STATE_QUEUED:
                assertTrue(job.isQueued());
                break;
            case PrintJobInfo.STATE_STARTED:
                assertTrue(job.isStarted());
                break;
            case PrintJobInfo.STATE_BLOCKED:
                assertTrue(job.isBlocked());
                break;
            case PrintJobInfo.STATE_COMPLETED:
                assertTrue(job.isCompleted());
                break;
            case PrintJobInfo.STATE_FAILED:
                assertTrue(job.isFailed());
                break;
            case PrintJobInfo.STATE_CANCELED:
                assertTrue(job.isCancelled());
                break;
        }

        job.cancel();
        eventually(() -> assertTrue(job.isCancelled()));

        waitForPrinterDiscoverySessionDestroyCallbackCalled(1);
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.print.cts.InterfaceForAppsTest"	"isCancelled"	"CtsPrintTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/print/src/android/print/cts/InterfaceForAppsTest.java"	""	"public void attemptCancelCreatedPrintJob() throws Throwable {
        PrintDocumentAdapter adapter = setupPrint(PrintJobInfo.STATE_STARTED);

        print(adapter, ""testAttemptCancelCreatedPrintJob"");
        waitForWriteAdapterCallback(1);

        PrintJob job = getPrintJob(getPrintManager(getActivity()),
                ""testAttemptCancelCreatedPrintJob"");

        // Cancel does not have an effect on created jobs
        job.cancel();
        eventually(() -> assertEquals(PrintJobInfo.STATE_CREATED, job.getInfo().getState()));

        // Cancel printing by exiting print activity
        mPrintHelper.cancelPrinting();
        eventually(() -> assertTrue(job.isCancelled()));

        waitForPrinterDiscoverySessionDestroyCallbackCalled(1);
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.print.cts.InterfaceForAppsTest"	"isFailed"	"CtsPrintTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/print/src/android/print/cts/InterfaceForAppsTest.java"	""	"public void restartFailedPrintJob() throws Throwable {
        PrintDocumentAdapter adapter = setupPrint(PrintJobInfo.STATE_FAILED);

        print(adapter, ""testRestartFailedPrintJob"");
        waitForWriteAdapterCallback(1);
        mPrintHelper.submitPrintJob();

        PrintJob job = getPrintJob(getPrintManager(getActivity()), ""testRestartFailedPrintJob"");

        eventually(() -> assertTrue(job.isFailed()));

        // Restart goes from failed right to queued, so stop the print job at ""queued"" now
        setupPrint(PrintJobInfo.STATE_QUEUED);

        job.restart();
        eventually(() -> assertTrue(job.isQueued()));

        job.cancel();
        eventually(() -> assertTrue(job.isCancelled()));

        waitForPrinterDiscoverySessionDestroyCallbackCalled(1);
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.app.RetrieveScanResultsAndReturnStatusActivity"	"isEmpty"	""	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/CtsWifiLocationTestApp/src/android/net/wifi/cts/app/RetrieveScanResultsAndReturnStatusActivity.java"	""	"public void test/*
 *.
 */

package android.net.wifi.cts.app;

import android.app.Activity;
import android.content.Intent;
import android.net.wifi.WifiManager;
import android.os.Bundle;
import android.util.Log;

/**
 * An activity that retrieves scan results and returns status.
 */
public class RetrieveScanResultsAndReturnStatusActivity extends Activity {
    private static final String TAG = ""RetrieveScanResultsAndReturnStatusActivity"";
    private static final String SCAN_STATUS_EXTRA = ""android.net.wifi.cts.app.extra.STATUS"";

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        WifiManager wifiManager = getSystemService(WifiManager.class);
        boolean succeeded;
        try {
            succeeded = !wifiManager.getScanResults().isEmpty();
        } catch (SecurityException e) {
            succeeded = false;
        }
        if (succeeded) {
            Log.v(TAG, ""Scan results retrieval succeeded"");
        } else {
            Log.v(TAG, ""Failed to retrieve scan results"");
        }
        setResult(RESULT_OK, new Intent().putExtra(SCAN_STATUS_EXTRA, succeeded));
        finish();
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.gputools.cts.CtsRootlessGpuDebugHostTest"	"currentTimeMillis"	"CtsGpuToolsHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/gputools/src/android/gputools/cts/CtsRootlessGpuDebugHostTest.java"	""	"/*
 *.
 */
package android.gputools.cts;

import com.android.tradefed.device.ITestDevice;
import com.android.tradefed.testtype.DeviceJUnit4ClassRunner;
import com.android.tradefed.testtype.junit4.BaseHostJUnit4Test;

import java.util.Scanner;

import org.junit.After;
import org.junit.Before;
import org.junit.Assert;
import org.junit.Test;
import org.junit.runner.RunWith;

/**
 * Tests that exercise Rootless GPU Debug functionality supported by the loader.
 */
@RunWith(DeviceJUnit4ClassRunner.class)
public class CtsRootlessGpuDebugHostTest extends BaseHostJUnit4Test {

    public static final String TAG = ""RootlessGpuDebugService"";

    // This test ensures that the Vulkan and GLES loaders can use Settings to load layers
    // from the base directory of debuggable applications.  Is also tests several
    // positive and negative scenarios we want to cover (listed below).
    //
    // There are three APKs; DEBUG and RELEASE are practically identical with one
    // being flagged as debuggable.  The LAYERS APK is mainly a conduit for getting
    // layers onto the device without affecting the other APKs.
    //
    // The RELEASE APK does contain one layer to ensure using Settings to enable
    // layers does not interfere with legacy methods using system properties.
    //
    // The layers themselves are practically null, only enough functionality to
    // satisfy loader enumerating and loading.  They don't actually chain together.
    //
    // Positive Vulkan tests
    // - Ensure we can toggle the Enable Setting on and off (testDebugLayerLoadVulkan)
    // - Ensure we can set the debuggable app (testDebugLayerLoadVulkan)
    // - Ensure we can set the layer list (testDebugLayerLoadVulkan)
    // - Ensure we can push a layer to debuggable app (testDebugLayerLoadVulkan)
    // - Ensure we can specify the app to load layers (testDebugLayerLoadVulkan)
    // - Ensure we can load a layer from app's data directory (testDebugLayerLoadVulkan)
    // - Ensure we can load multiple layers, in order, from app's data directory (testDebugLayerLoadVulkan)
    // - Ensure we can still use system properties if no layers loaded via Settings (testSystemPropertyEnableVulkan)
    // - Ensure we can find layers in separate specified app and load them in a debuggable app (testDebugLayerLoadExternalVulkan)
    // - Ensure we can find layers in separate specified app and load them in an injectLayers app (testInjectLayerLoadExternalVulkan)
    // - Ensure we can enumerate the instance extension advertised by implicitly enabled layer (testInstanceExtensionPropertiesFromImplicitLayerVulkanBasic)
    // - Ensure we can only enumerate first instance extension closest to application
    //   when multiple implicitly enabled layers advertise the same extension (testInstanceExtensionPropertiesFromImplicitLayerVulkanMultipleLayers)
    // Negative Vulkan tests
    // - Ensure we cannot push a layer to non-debuggable app (testReleaseLayerLoadVulkan)
    // - Ensure non-debuggable app ignores the new Settings (testReleaseLayerLoadVulkan)
    // - Ensure we cannot push a layer to an injectLayers app (testInjectLayerLoadVulkan)
    // - Ensure we cannot enumerate layers from debuggable app's data directory if Setting not specified (testDebugNoEnumerateVulkan)
    // - Ensure we cannot enumerate layers without specifying the debuggable app (testDebugNoEnumerateVulkan)
    // - Ensure we cannot use system properties when layer is found via Settings with debuggable app (testSystemPropertyIgnoreVulkan)
    //
    // Positive GLES tests
    // - Ensure we can toggle the Enable Setting on and off (testDebugLayerLoadGLES)
    // - Ensure we can set the debuggable app (testDebugLayerLoadGLES)
    // - Ensure we can set the layer list (testDebugLayerLoadGLES)
    // - Ensure we can push a layer to debuggable app (testDebugLayerLoadGLES)
    // - Ensure we can specify the app to load layers (testDebugLayerLoadGLES)
    // - Ensure we can load a layer from app's data directory (testDebugLayerLoadGLES)
    // - Ensure we can load multiple layers, in order, from app's data directory (testDebugLayerLoadGLES)
    // - Ensure we can find layers in separate specified app and load them in a debuggable app (testDebugLayerLoadExternalGLES)
    // - Ensure we can find layers in separate specified app and load them in an injectLayers app (testInjectLayerLoadExternalGLES)
    // Negative GLES tests
    // - Ensure we cannot push a layer to non-debuggable app (testReleaseLayerLoadGLES)
    // - Ensure non-debuggable app ignores the new Settings (testReleaseLayerLoadGLES)
    // - Ensure we cannot enumerate layers from debuggable app's data directory if Setting not specified (testDebugNoEnumerateGLES)
    // - Ensure we cannot enumerate layers without specifying the debuggable app (testDebugNoEnumerateGLES)
    //
    // Positive combined tests
    // - Ensure we can load Vulkan and GLES layers at the same time, from multiple external apps (testMultipleExternalApps)

    private static final String API_VULKAN = ""Vulkan"";
    private static final String API_GLES = ""GLES"";
    private static final String API_BOTH = ""Both"";
    private static final String VK_LAYER_LIB_PREFIX = ""libVkLayer_nullLayer"";
    private static final String VK_LAYER_A_LIB = VK_LAYER_LIB_PREFIX + ""A.so"";
    private static final String VK_LAYER_B_LIB = VK_LAYER_LIB_PREFIX + ""B.so"";
    private static final String VK_LAYER_C_LIB = VK_LAYER_LIB_PREFIX + ""C.so"";
    private static final String VK_LAYER_D_LIB = VK_LAYER_LIB_PREFIX + ""D.so"";
    private static final String VK_LAYER_E_LIB = VK_LAYER_LIB_PREFIX + ""E.so"";
    private static final String VK_LAYER_NAME_PREFIX = ""VK_LAYER_ANDROID_nullLayer"";
    private static final String VK_LAYER_A = VK_LAYER_NAME_PREFIX + ""A"";
    private static final String VK_LAYER_B = VK_LAYER_NAME_PREFIX + ""B"";
    private static final String VK_LAYER_C = VK_LAYER_NAME_PREFIX + ""C"";
    private static final String VK_LAYER_D = VK_LAYER_NAME_PREFIX + ""D"";
    private static final String VK_LAYER_E = VK_LAYER_NAME_PREFIX + ""E"";
    private static final String DEBUG_APP = ""android.rootlessgpudebug.DEBUG.app"";
    private static final String RELEASE_APP = ""android.rootlessgpudebug.RELEASE.app"";
    private static final String INJECT_APP = ""android.rootlessgpudebug.INJECT.app"";
    private static final String LAYERS_APP = ""android.rootlessgpudebug.LAYERS.app"";
    private static final String GLES_LAYERS_APP = ""android.rootlessgpudebug.GLES_LAYERS.app"";
    private static final String DEBUG_APK = ""CtsGpuToolsRootlessGpuDebugApp-DEBUG.apk"";
    private static final String RELEASE_APK = ""CtsGpuToolsRootlessGpuDebugApp-RELEASE.apk"";
    private static final String INJECT_APK = ""CtsGpuToolsRootlessGpuDebugApp-INJECT.apk"";
    private static final String LAYERS_APK = ""CtsGpuToolsRootlessGpuDebugApp-LAYERS.apk"";
    private static final String GLES_LAYERS_APK = ""CtsGpuToolsRootlessGpuDebugApp-GLES_LAYERS.apk"";
    private static final String GLES_LAYER_A = ""glesLayerA"";
    private static final String GLES_LAYER_B = ""glesLayerB"";
    private static final String GLES_LAYER_C = ""glesLayerC"";
    private static final String GLES_LAYER_A_LIB = ""libGLES_"" + GLES_LAYER_A + "".so"";
    private static final String GLES_LAYER_B_LIB = ""libGLES_"" + GLES_LAYER_B + "".so"";
    private static final String GLES_LAYER_C_LIB = ""libGLES_"" + GLES_LAYER_C + "".so"";

    // This is how long we'll scan the log for a result before giving up. This limit will only
    // be reached if something has gone wrong
    private static final long LOG_SEARCH_TIMEOUT_MS = 5000;
    private static final long SETTING_APPLY_TIMEOUT_MS = 5000;

    private static boolean initialized = false;

    private String removeWhitespace(String input) {
        return input.replaceAll(System.getProperty(""line.separator""), """").trim();
    }

    /**
     * Return current timestamp in format accepted by logcat
     */
    private String getTime() throws Exception {
        // logcat will accept ""MM-DD hh:mm:ss.mmm""
        return getDevice().executeShellCommand(""date +\""%m-%d %H:%M:%S.%3N\"""");
    }

    /**
     * Apply a setting and refresh the platform's cache
     */
    private void applySetting(String setting, String value) throws Exception {
        getDevice().executeShellCommand(""settings put global "" + setting + "" "" + value);
        getDevice().executeShellCommand(""am refresh-settings-cache"");
    }

    /**
     * Delete a setting and refresh the platform's cache
     */
    private void deleteSetting(String setting) throws Exception {
        getDevice().executeShellCommand(""settings delete global "" + setting);
        getDevice().executeShellCommand(""am refresh-settings-cache"");
    }

    /**
     * Extract the requested layer from APK and copy to tmp
     */
    private void setupLayer(String layer, String layerApp) throws Exception {

        // We use the LAYERS apk to facilitate getting layers onto the device for mixing and matching
        String libPath = getDevice().executeAdbCommand(""shell"", ""pm"", ""path"", layerApp);
        libPath = libPath.replaceAll(""package:"", """");
        libPath = libPath.replaceAll(""base.apk"", """");
        libPath = removeWhitespace(libPath);
        libPath += ""lib/"";

        // Use find to get the .so so we can ignore ABI
        String layerPath = getDevice().executeAdbCommand(""shell"", ""find"", libPath + "" -name "" + layer);
        layerPath = removeWhitespace(layerPath);
        getDevice().executeAdbCommand(""shell"", ""cp"", layerPath + "" /data/local/tmp"");
    }

    /**
     * Check that the layer is loaded by only checking the log after startTime.
     */
    private void assertVkLayerLoading(String startTime, String layerName, boolean loaded) throws Exception {
        String searchString = ""nullCreateInstance called in "" + layerName;
        LogScanResult result = scanLog(TAG + "","" + layerName, searchString, startTime);
        if (loaded) {
            Assert.assertTrue(layerName + "" was not loaded"", result.found);
        } else {
            Assert.assertFalse(layerName + "" was loaded"", result.found);
        }
    }

    /**
     * Check that the layer is enumerated by only checking the log after startTime.
     */
    private void assertVkLayerEnumeration(String startTime, String layerName, boolean enumerated) throws Exception {
        String searchString = layerName + "" loaded"";
        LogScanResult result = scanLog(TAG + "","" + layerName, searchString, startTime);
        if (enumerated) {
            Assert.assertTrue(layerName + "" was not enumerated"", result.found);
        } else {
            Assert.assertFalse(layerName + "" was enumerated"", result.found);
        }
    }

    /**
     * Check whether an extension is properly advertised by only checking the log after startTime.
     */
    private void assertVkExtension(String startTime, String extensionName, int specVersion) throws Exception {
        String searchString = extensionName + "": "" + specVersion;
        LogScanResult result = scanLog(TAG + "",RootlessGpuDebug"", searchString, startTime);
        Assert.assertTrue(extensionName + ""with spec version: "" + specVersion + "" was not advertised"", result.found);
    }

    /**
     * Simple helper class for returning multiple results
     */
    public class LogScanResult {
        public boolean found;
        public int lineNumber;
    }

    private LogScanResult scanLog(String tag, String searchString, String appStartTime) throws Exception {
        return scanLog(tag, searchString, """", appStartTime);
    }

    /**
     * Scan the logcat for requested layer tag, returning if found and which line
     */
    private LogScanResult scanLog(String tag, String searchString, String endString, String appStartTime) throws Exception {

        LogScanResult result = new LogScanResult();
        result.found = false;
        result.lineNumber = -1;

        // Scan until output from app is found
        boolean scanComplete= false;

        // Let the test run a reasonable amount of time before moving on
        long hostStartTime = System.currentTimeMillis();

        while (!scanComplete && ((System.currentTimeMillis() - hostStartTime) < LOG_SEARCH_TIMEOUT_MS)) {

            // Give our activity a chance to run and fill the log
            Thread.sleep(1000);

            // Pull the logcat since the app started, filter for tags
            // This command should look something like this:
            // adb logcat -d -t '03-27 21:35:05.392' -s ""RootlessGpuDebugDeviceActivity,nullLayerC""
            String logcat = getDevice().executeShellCommand(
                    ""logcat -d "" +
                    ""-t '"" + removeWhitespace(appStartTime) + ""' "" +
                    ""-s \"""" + tag + ""\"""");
            int lineNumber = 0;
            Scanner apkIn = new Scanner(logcat);
            while (apkIn.hasNextLine()) {
                lineNumber++;
                String line = apkIn.nextLine();
                if (line.contains(searchString) && line.endsWith(endString)) {
                    result.found = true;
                    result.lineNumber = lineNumber;
                }
                if (line.contains(""RootlessGpuDebugService complete"")) {
                    // Once we've got output from the app, we've collected what we need
                    scanComplete= true;
                }
            }
            apkIn.close();
        }

        // If this assert fires , try increasing the timeout
        Assert.assertTrue(""Log scanning did not complete before timout ("" +
                LOG_SEARCH_TIMEOUT_MS + ""ms)"", scanComplete);

        return result;
    }

    /**
     * Remove any temporary files on the device, clear any settings, kill the apps after each test
     */
    @After
    public void cleanup() throws Exception {
        getDevice().executeAdbCommand(""shell"", ""am"", ""force-stop"", DEBUG_APP);
        getDevice().executeAdbCommand(""shell"", ""am"", ""force-stop"", RELEASE_APP);
        getDevice().executeAdbCommand(""shell"", ""am"", ""force-stop"", INJECT_APP);
        getDevice().executeAdbCommand(""shell"", ""rm"", ""-f"", ""/data/local/tmp/"" + VK_LAYER_A_LIB);
        getDevice().executeAdbCommand(""shell"", ""rm"", ""-f"", ""/data/local/tmp/"" + VK_LAYER_B_LIB);
        getDevice().executeAdbCommand(""shell"", ""rm"", ""-f"", ""/data/local/tmp/"" + VK_LAYER_C_LIB);
        getDevice().executeAdbCommand(""shell"", ""rm"", ""-f"", ""/data/local/tmp/"" + GLES_LAYER_A_LIB);
        getDevice().executeAdbCommand(""shell"", ""rm"", ""-f"", ""/data/local/tmp/"" + GLES_LAYER_B_LIB);
        getDevice().executeAdbCommand(""shell"", ""rm"", ""-f"", ""/data/local/tmp/"" + GLES_LAYER_C_LIB);
        getDevice().executeAdbCommand(""shell"", ""settings"", ""delete"", ""global"", ""enable_gpu_debug_layers"");
        getDevice().executeAdbCommand(""shell"", ""settings"", ""delete"", ""global"", ""gpu_debug_app"");
        getDevice().executeAdbCommand(""shell"", ""settings"", ""delete"", ""global"", ""gpu_debug_layers"");
        getDevice().executeAdbCommand(""shell"", ""settings"", ""delete"", ""global"", ""gpu_debug_layers_gles"");
        getDevice().executeAdbCommand(""shell"", ""settings"", ""delete"", ""global"", ""gpu_debug_layer_app"");
        getDevice().executeAdbCommand(""shell"", ""setprop"", ""debug.vulkan.layers"", ""\'\'"");
        getDevice().executeAdbCommand(""shell"", ""setprop"", ""debug.gles.layers"", ""\'\'"");
    }

    /**
     * Clean up before starting any tests, and ensure supporting packages are installed
     */
    @Before
    public void init() throws Exception {
        installPackage(DEBUG_APK);
        installPackage(RELEASE_APK);
        installPackage(LAYERS_APK);
        installPackage(GLES_LAYERS_APK);
        if (!initialized) {
            cleanup();
            initialized = true;
        }
    }

    /**
     * Launch our test as a background service, avoiding any platform rendering code
     */
    private void launchBackgroundService(String appName, String Api) throws Exception {

        // Allow the app to be launched as a background service
        getDevice().executeAdbCommand(""shell"", ""cmd"", ""deviceidle"", ""tempwhitelist"", appName);

        // Start the service and tell it to init Vulkan/GLES/Both
        getDevice().executeAdbCommand(""shell"", ""am"", ""startservice"", ""-a"", ""android.service.action.TARGET_API_SERVICE"",
                                      ""--es"", ""API"", Api, appName);
    }


    /**
     * This is the primary test of the feature. It pushes layers to our debuggable app and ensures they are
     * loaded in the correct order.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.gputools.cts.CtsRootlessGpuDebugHostTest"	"testDebugLayerLoadVulkan"	"CtsGpuToolsHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/gputools/src/android/gputools/cts/CtsRootlessGpuDebugHostTest.java"	""	"public void testDebugLayerLoadVulkan() throws Exception {

        // Set up layers to be loaded
        applySetting(""enable_gpu_debug_layers"", ""1"");
        applySetting(""gpu_debug_app"", DEBUG_APP);
        applySetting(""gpu_debug_layers"", VK_LAYER_A + "":"" + VK_LAYER_B);

        // Copy the layers from our LAYERS APK to tmp
        setupLayer(VK_LAYER_A_LIB, LAYERS_APP);
        setupLayer(VK_LAYER_B_LIB, LAYERS_APP);

        // Copy them over to our DEBUG app
        getDevice().executeAdbCommand(""shell"", ""cat"", ""/data/local/tmp/"" + VK_LAYER_A_LIB, ""|"",
                ""run-as"", DEBUG_APP, ""--user"", Integer.toString(getDevice().getCurrentUser()),
                ""sh"", ""-c"", ""\'cat"", "">"", VK_LAYER_A_LIB, "";"", ""chmod"", ""700"", VK_LAYER_A_LIB + ""\'"");
        getDevice().executeAdbCommand(""shell"", ""cat"", ""/data/local/tmp/"" + VK_LAYER_B_LIB, ""|"",
                ""run-as"", DEBUG_APP, ""--user"", Integer.toString(getDevice().getCurrentUser()),
                ""sh"", ""-c"", ""\'cat"", "">"", VK_LAYER_B_LIB, "";"", ""chmod"", ""700"", VK_LAYER_B_LIB + ""\'"");

        // Kick off our DEBUG app
        String appStartTime = getTime();
        launchBackgroundService(DEBUG_APP, API_VULKAN);

        // Check that both layers were loaded, in the correct order
        String searchStringA = ""nullCreateInstance called in "" + VK_LAYER_A;
        LogScanResult resultA = scanLog(TAG + "","" + VK_LAYER_A + "","" + VK_LAYER_B, searchStringA, appStartTime);
        Assert.assertTrue(""LayerA was not loaded"", resultA.found);

        String searchStringB = ""nullCreateInstance called in "" + VK_LAYER_B;
        LogScanResult resultB = scanLog(TAG + "","" + VK_LAYER_A + "","" + VK_LAYER_B, searchStringB, appStartTime);
        Assert.assertTrue(""LayerB was not loaded"", resultB.found);

        Assert.assertTrue(""LayerA should be loaded before LayerB"", resultA.lineNumber < resultB.lineNumber);
    }

    public void testLayerNotLoadedVulkan(final String APP_NAME) throws Exception {

        // Set up a layers to be loaded for RELEASE or INJECT app
        applySetting(""enable_gpu_debug_layers"", ""1"");
        applySetting(""gpu_debug_app"", APP_NAME);
        applySetting(""gpu_debug_layers"", VK_LAYER_A + "":"" + VK_LAYER_B);

        // Copy a layer from our LAYERS APK to tmp
        setupLayer(VK_LAYER_A_LIB, LAYERS_APP);

        // Attempt to copy them over to our RELEASE or INJECT app (this should fail)
        getDevice().executeAdbCommand(""shell"", ""cat"", ""/data/local/tmp/"" + VK_LAYER_A_LIB, ""|"",
            ""run-as"", APP_NAME, ""--user"", Integer.toString(getDevice().getCurrentUser()),
            ""sh"", ""-c"", ""\'cat"", "">"", VK_LAYER_A_LIB, "";"", ""chmod"", ""700"", VK_LAYER_A_LIB + ""\'"", ""||"", ""echo"", ""run-as"", ""failed"");

        // Kick off our app
        String appStartTime = getTime();
        launchBackgroundService(APP_NAME, API_VULKAN);

        // Ensure we don't load the layer in base dir
        assertVkLayerEnumeration(appStartTime, VK_LAYER_A, false);
    }

    /**
     * This test ensures that we cannot push a layer to a release app
     * It also ensures non-debuggable apps ignore Settings and don't enumerate layers in the base directory.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.gputools.cts.CtsRootlessGpuDebugHostTest"	"testDebugLayerLoadGLES"	"CtsGpuToolsHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/gputools/src/android/gputools/cts/CtsRootlessGpuDebugHostTest.java"	""	"public void testDebugLayerLoadGLES() throws Exception {

        // Set up layers to be loaded
        applySetting(""enable_gpu_debug_layers"", ""1"");
        applySetting(""gpu_debug_app"", DEBUG_APP);
        applySetting(""gpu_debug_layers_gles"", GLES_LAYER_A_LIB + "":"" + GLES_LAYER_B_LIB);

        // Copy the layers from our LAYERS APK to tmp
        setupLayer(GLES_LAYER_A_LIB, GLES_LAYERS_APP);
        setupLayer(GLES_LAYER_B_LIB, GLES_LAYERS_APP);

        // Copy them over to our DEBUG app
        getDevice().executeAdbCommand(""shell"", ""cat"", ""/data/local/tmp/"" + GLES_LAYER_A_LIB, ""|"",
            ""run-as"", DEBUG_APP, ""--user"", Integer.toString(getDevice().getCurrentUser()),
            ""sh"", ""-c"", ""\'cat"", "">"", GLES_LAYER_A_LIB, "";"", ""chmod"", ""700"", GLES_LAYER_A_LIB + ""\'"");
        getDevice().executeAdbCommand(""shell"", ""cat"", ""/data/local/tmp/"" + GLES_LAYER_B_LIB, ""|"",
            ""run-as"", DEBUG_APP, ""--user"", Integer.toString(getDevice().getCurrentUser()),
            ""sh"", ""-c"", ""\'cat"", "">"", GLES_LAYER_B_LIB, "";"", ""chmod"", ""700"", GLES_LAYER_B_LIB + ""\'"");

        // Kick off our DEBUG app
        String appStartTime = getTime();
        launchBackgroundService(DEBUG_APP, API_GLES);

        // Check that both layers were loaded, in the correct order
        String searchStringA = ""glesLayer_eglChooseConfig called in "" + GLES_LAYER_A;
        LogScanResult resultA = scanLog(TAG + "","" + GLES_LAYER_A + "","" + GLES_LAYER_B, searchStringA, appStartTime);
        Assert.assertTrue(GLES_LAYER_A + "" was not loaded"", resultA.found);

        String searchStringB = ""glesLayer_eglChooseConfig called in "" + GLES_LAYER_B;
        LogScanResult resultB = scanLog(TAG + "","" + GLES_LAYER_A + "","" + GLES_LAYER_B, searchStringB, appStartTime);
        Assert.assertTrue(GLES_LAYER_B + "" was not loaded"", resultB.found);

        Assert.assertTrue(GLES_LAYER_A + "" should be loaded before "" + GLES_LAYER_B, resultA.lineNumber < resultB.lineNumber);
    }

    /**
     * This test ensures that we cannot push a layer to a non-debuggable GLES app
     * It also ensures non-debuggable apps ignore Settings and don't enumerate layers in the base directory.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.gputools.cts.CtsRootlessGpuDebugHostTest"	"testReleaseLayerLoadGLES"	"CtsGpuToolsHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/gputools/src/android/gputools/cts/CtsRootlessGpuDebugHostTest.java"	""	"public void testReleaseLayerLoadGLES() throws Exception {

        // Set up a layers to be loaded for RELEASE app
        applySetting(""enable_gpu_debug_layers"", ""1"");
        applySetting(""gpu_debug_app"", RELEASE_APP);
        applySetting(""gpu_debug_layers_gles"", GLES_LAYER_A_LIB + "":"" + GLES_LAYER_B_LIB);
        deleteSetting(""gpu_debug_layer_app"");

        // Copy a layer from our LAYERS APK to tmp
        setupLayer(GLES_LAYER_A_LIB, GLES_LAYERS_APP);

        // Attempt to copy them over to our RELEASE app (this should fail)
        getDevice().executeAdbCommand(""shell"", ""cat"", ""/data/local/tmp/"" + GLES_LAYER_A_LIB, ""|"", ""run-as"", RELEASE_APP,
                                   ""sh"", ""-c"", ""\'cat"", "">"", GLES_LAYER_A_LIB, "";"", ""chmod"", ""700"", GLES_LAYER_A_LIB + ""\'"", ""||"", ""echo"", ""run-as"", ""failed"");

        // Kick off our RELEASE app
        String appStartTime = getTime();
        launchBackgroundService(RELEASE_APP, API_GLES);

        // Ensure we don't load the layer in base dir
        String searchStringA = GLES_LAYER_A + "" loaded"";
        LogScanResult resultA = scanLog(TAG + "","" + GLES_LAYER_A, searchStringA, appStartTime);
        Assert.assertFalse(GLES_LAYER_A + "" was enumerated"", resultA.found);
    }

    /**
     * This test ensures debuggable GLES apps do not enumerate layers in base
     * directory if enable_gpu_debug_layers is not enabled.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.gputools.cts.CtsRootlessGpuDebugHostTest"	"testDebugNotEnabledGLES"	"CtsGpuToolsHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/gputools/src/android/gputools/cts/CtsRootlessGpuDebugHostTest.java"	""	"public void testDebugNotEnabledGLES() throws Exception {

        // Ensure the global layer enable settings is NOT enabled
        applySetting(""enable_gpu_debug_layers"", ""0"");
        applySetting(""gpu_debug_app"", DEBUG_APP);
        applySetting(""gpu_debug_layers_gles"", GLES_LAYER_A_LIB);

        // Copy a layer from our LAYERS APK to tmp
        setupLayer(GLES_LAYER_A_LIB, GLES_LAYERS_APP);

        // Copy it over to our DEBUG app
        getDevice().executeAdbCommand(""shell"", ""cat"", ""/data/local/tmp/"" + GLES_LAYER_A_LIB, ""|"", ""run-as"", DEBUG_APP,
                                  ""sh"", ""-c"", ""\'cat"", "">"", GLES_LAYER_A_LIB, "";"", ""chmod"", ""700"", GLES_LAYER_A_LIB + ""\'"");

        // Kick off our DEBUG app
        String appStartTime = getTime();
        launchBackgroundService(DEBUG_APP, API_GLES);

        // Ensure we don't load the layer in base dir
        String searchStringA = GLES_LAYER_A + "" loaded"";
        LogScanResult resultA = scanLog(TAG + "","" + GLES_LAYER_A, searchStringA, appStartTime);
        Assert.assertFalse(GLES_LAYER_A + "" was enumerated"", resultA.found);
    }

    /**
     * This test ensures debuggable GLES apps do not enumerate layers in base
     * directory if gpu_debug_app does not match.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.gputools.cts.CtsRootlessGpuDebugHostTest"	"testDebugWrongAppGLES"	"CtsGpuToolsHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/gputools/src/android/gputools/cts/CtsRootlessGpuDebugHostTest.java"	""	"public void testDebugWrongAppGLES() throws Exception {

        // Ensure the gpu_debug_app does not match what we launch
        applySetting(""enable_gpu_debug_layers"", ""1"");
        applySetting(""gpu_debug_app"", RELEASE_APP);
        applySetting(""gpu_debug_layers_gles"", GLES_LAYER_A_LIB);

        // Copy a layer from our LAYERS APK to tmp
        setupLayer(GLES_LAYER_A_LIB, GLES_LAYERS_APP);

        // Copy it over to our DEBUG app
        getDevice().executeAdbCommand(""shell"", ""cat"", ""/data/local/tmp/"" + GLES_LAYER_A_LIB, ""|"", ""run-as"", DEBUG_APP,
                                  ""sh"", ""-c"", ""\'cat"", "">"", GLES_LAYER_A_LIB, "";"", ""chmod"", ""700"", GLES_LAYER_A_LIB + ""\'"");

        // Kick off our DEBUG app
        String appStartTime = getTime();
        launchBackgroundService(DEBUG_APP, API_GLES);

        // Ensure we don't load the layer in base dir
        String searchStringA = GLES_LAYER_A + "" loaded"";
        LogScanResult resultA = scanLog(TAG + "","" + GLES_LAYER_A, searchStringA, appStartTime);
        Assert.assertFalse(GLES_LAYER_A + "" was enumerated"", resultA.found);
    }

    /**
     * This test ensures debuggable GLES apps do not enumerate layers in base
     * directory if gpu_debug_layers are not set.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.gputools.cts.CtsRootlessGpuDebugHostTest"	"testDebugNoLayersEnabledGLES"	"CtsGpuToolsHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/gputools/src/android/gputools/cts/CtsRootlessGpuDebugHostTest.java"	""	"public void testDebugNoLayersEnabledGLES() throws Exception {

        // Ensure the global layer enable settings is NOT enabled
        applySetting(""enable_gpu_debug_layers"", ""1"");
        applySetting(""gpu_debug_app"", DEBUG_APP);
        applySetting(""gpu_debug_layers_gles"", ""foo"");

        // Copy a layer from our LAYERS APK to tmp
        setupLayer(GLES_LAYER_A_LIB, GLES_LAYERS_APP);

        // Copy it over to our DEBUG app
        getDevice().executeAdbCommand(""shell"", ""cat"", ""/data/local/tmp/"" + GLES_LAYER_A_LIB, ""|"", ""run-as"", DEBUG_APP,
                                  ""sh"", ""-c"", ""\'cat"", "">"", GLES_LAYER_A_LIB, "";"", ""chmod"", ""700"", GLES_LAYER_A_LIB + ""\'"");

        // Kick off our DEBUG app
        String appStartTime = getTime();
        launchBackgroundService(DEBUG_APP, API_GLES);

        // Ensure layerA is not loaded
        String searchStringA = ""glesLayer_eglChooseConfig called in "" + GLES_LAYER_A;
        LogScanResult resultA = scanLog(TAG + "","" + GLES_LAYER_A, searchStringA, appStartTime);
        Assert.assertFalse(GLES_LAYER_A + "" was loaded"", resultA.found);
    }

    /**
     * This test ensures we can still use properties if no GLES layers are specified
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.gputools.cts.CtsRootlessGpuDebugHostTest"	"testSystemPropertyEnableGLES"	"CtsGpuToolsHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/gputools/src/android/gputools/cts/CtsRootlessGpuDebugHostTest.java"	""	"public void testSystemPropertyEnableGLES() throws Exception {

        // Set up layerA to be loaded, but not layerB or layerC
        applySetting(""enable_gpu_debug_layers"", ""1"");
        applySetting(""gpu_debug_app"", RELEASE_APP);
        deleteSetting(""gpu_debug_layers_gles"");

        // Enable layerC (which is packaged with the RELEASE app) with system properties
        getDevice().executeAdbCommand(""shell"", ""setprop"", ""debug.gles.layers "" + GLES_LAYER_C_LIB);

        // Kick off our RELEASE app
        String appStartTime = getTime();
        launchBackgroundService(RELEASE_APP, API_GLES);

        // Check that both layers were loaded, in the correct order
        String searchStringA = GLES_LAYER_A + ""loaded"";
        LogScanResult resultA = scanLog(TAG + "","" + GLES_LAYER_A, searchStringA, appStartTime);
        Assert.assertFalse(GLES_LAYER_A + "" was enumerated"", resultA.found);

        String searchStringC = ""glesLayer_eglChooseConfig called in "" + GLES_LAYER_C;
        LogScanResult resultC = scanLog(TAG + "","" + GLES_LAYER_C, searchStringC, appStartTime);
        Assert.assertTrue(GLES_LAYER_C + "" was not loaded"", resultC.found);
    }

    /**
     * This test ensures system properties are ignored if Settings load a GLES layer
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.gputools.cts.CtsRootlessGpuDebugHostTest"	"testSystemPropertyIgnoreGLES"	"CtsGpuToolsHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/gputools/src/android/gputools/cts/CtsRootlessGpuDebugHostTest.java"	""	"public void testSystemPropertyIgnoreGLES() throws Exception {

        // Set up layerA to be loaded, but not layerB
        applySetting(""enable_gpu_debug_layers"", ""1"");
        applySetting(""gpu_debug_app"", DEBUG_APP);
        applySetting(""gpu_debug_layers_gles"", GLES_LAYER_A_LIB);

        // Copy the layers from our LAYERS APK
        setupLayer(GLES_LAYER_A_LIB, GLES_LAYERS_APP);
        setupLayer(GLES_LAYER_B_LIB, GLES_LAYERS_APP);

        // Copy them over to our DEBUG app
        getDevice().executeAdbCommand(""shell"", ""cat"", ""/data/local/tmp/"" + GLES_LAYER_A_LIB, ""|"",
            ""run-as"", DEBUG_APP, ""--user"", Integer.toString(getDevice().getCurrentUser()),
            ""sh"", ""-c"", ""\'cat"", "">"", GLES_LAYER_A_LIB, "";"", ""chmod"", ""700"", GLES_LAYER_A_LIB + ""\'"");
        getDevice().executeAdbCommand(""shell"", ""cat"", ""/data/local/tmp/"" + GLES_LAYER_B_LIB, ""|"",
            ""run-as"", DEBUG_APP, ""--user"", Integer.toString(getDevice().getCurrentUser()),
            ""sh"", ""-c"", ""\'cat"", "">"", GLES_LAYER_B_LIB, "";"", ""chmod"", ""700"", GLES_LAYER_B_LIB + ""\'"");

        // Enable layerB with system properties
        getDevice().executeAdbCommand(""shell"", ""setprop"", ""debug.gles.layers "" + GLES_LAYER_B_LIB);

        // Kick off our DEBUG app
        String appStartTime = getTime();
        launchBackgroundService(DEBUG_APP, API_GLES);

        // Ensure only layerA is loaded
        String searchStringA = ""glesLayer_eglChooseConfig called in "" + GLES_LAYER_A;
        LogScanResult resultA = scanLog(TAG + "","" + GLES_LAYER_A, searchStringA, appStartTime);
        Assert.assertTrue(GLES_LAYER_A + "" was not loaded"", resultA.found);

        String searchStringB = ""glesLayer_eglChooseConfig called in "" + GLES_LAYER_B;
        LogScanResult resultB = scanLog(TAG + "","" + GLES_LAYER_B, searchStringB, appStartTime);
        Assert.assertFalse(GLES_LAYER_B + "" was loaded"", resultB.found);
    }

    public void testLayerLoadExternalGLES(final String APP_NAME) throws Exception {
        // Set up layers to be loaded
        applySetting(""enable_gpu_debug_layers"", ""1"");
        applySetting(""gpu_debug_app"", APP_NAME);
        applySetting(""gpu_debug_layers_gles"", GLES_LAYER_C_LIB);

        // Specify the external app that hosts layers
        applySetting(""gpu_debug_layer_app"", GLES_LAYERS_APP);

        // Kick off our app
        String appStartTime = getTime();
        launchBackgroundService(APP_NAME, API_GLES);

        // Check that our external layer was loaded
        String searchStringC = ""glesLayer_eglChooseConfig called in "" + GLES_LAYER_C;
        LogScanResult resultC = scanLog(TAG + "","" + GLES_LAYER_C, searchStringC, appStartTime);
        Assert.assertTrue(GLES_LAYER_C + "" was not loaded"", resultC.found);
    }

    /**
     * This test ensures that external GLES layers can be loaded by a debuggable app
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.gputools.cts.CtsRootlessGpuDebugHostTest"	"testMultipleExternalApps"	"CtsGpuToolsHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/gputools/src/android/gputools/cts/CtsRootlessGpuDebugHostTest.java"	""	"public void testMultipleExternalApps() throws Exception {

        // Set up layers to be loaded
        applySetting(""enable_gpu_debug_layers"", ""1"");
        applySetting(""gpu_debug_app"", DEBUG_APP);
        applySetting(""gpu_debug_layers"", VK_LAYER_C);
        applySetting(""gpu_debug_layers_gles"", GLES_LAYER_C_LIB);

        // Specify multple external apps that host layers
        applySetting(""gpu_debug_layer_app"", LAYERS_APP + "":"" + GLES_LAYERS_APP);

        // Kick off our DEBUG app
        String appStartTime = getTime();
        launchBackgroundService(DEBUG_APP, API_BOTH);

        // Check that external layers were loaded from both apps
        assertVkLayerLoading(appStartTime, VK_LAYER_C, true);

        String glesString = ""glesLayer_eglChooseConfig called in "" + GLES_LAYER_C;
        LogScanResult glesResult = scanLog(TAG + "","" + GLES_LAYER_C, glesString, appStartTime);
        Assert.assertTrue(GLES_LAYER_C + "" was not loaded"", glesResult.found);
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.bluetooth.DevicePickerActivity"	"PairedDeviceClickListener"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/bluetooth/DevicePickerActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.bluetooth;

import com.android.cts.verifier.R;

import android.app.Activity;
import android.app.AlertDialog;
import android.bluetooth.BluetoothAdapter;
import android.bluetooth.BluetoothDevice;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.Bundle;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.AdapterView;
import android.widget.ArrayAdapter;
import android.widget.Button;
import android.widget.ListView;
import android.widget.ProgressBar;
import android.widget.TextView;
import android.widget.AdapterView.OnItemClickListener;

import java.util.Set;

/**
 * {@link Activity} that shows a list of paired and new devices and returns the device selected
 * by the user. When the user selects a paired device, it forwards them to the Bluetooth settings
 * page, so that they can unpair it for the test.
 */
public class DevicePickerActivity extends Activity {

    public static final String EXTRA_DEVICE_ADDRESS = ""deviceAddress"";

    private static final int ENABLE_BLUETOOTH_REQUEST = 1;

    private BluetoothAdapter mBluetoothAdapter;

    private DiscoveryReceiver mReceiver;

    private ArrayAdapter<Device> mNewDevicesAdapter;

    private ArrayAdapter<Device> mPairedDevicesAdapter;

    private TextView mEmptyNewView;

    private ProgressBar mProgressBar;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.bt_device_picker);

        mProgressBar = (ProgressBar) findViewById(R.id.bt_progress_bar);

        mPairedDevicesAdapter = new ArrayAdapter<Device>(this, R.layout.bt_device_name);
        ListView pairedDevicesListView = (ListView) findViewById(R.id.bt_paired_devices);
        pairedDevicesListView.setAdapter(mPairedDevicesAdapter);
        pairedDevicesListView.setOnItemClickListener(new PairedDeviceClickListener());

        View emptyPairedView = findViewById(R.id.bt_empty_paired_devices);
        pairedDevicesListView.setEmptyView(emptyPairedView);

        mNewDevicesAdapter = new ArrayAdapter<Device>(this, R.layout.bt_device_name);
        ListView newDevicesListView = (ListView) findViewById(R.id.bt_new_devices);
        newDevicesListView.setAdapter(mNewDevicesAdapter);
        newDevicesListView.setOnItemClickListener(new NewDeviceClickListener());

        mEmptyNewView = (TextView) findViewById(R.id.bt_empty_new_devices);
        newDevicesListView.setEmptyView(mEmptyNewView);

        mReceiver = new DiscoveryReceiver();
        IntentFilter filter = new IntentFilter(BluetoothAdapter.ACTION_DISCOVERY_STARTED);
        filter.addAction(BluetoothAdapter.ACTION_DISCOVERY_FINISHED);
        filter.addAction(BluetoothDevice.ACTION_FOUND);
        registerReceiver(mReceiver, filter);

        Button scanButton = (Button) findViewById(R.id.bt_scan_button);
        scanButton.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                scan();
            }
        });

        mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
        if (mBluetoothAdapter.isEnabled()) {
            scan();
        } else {
            Intent intent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);
            startActivityForResult(intent, ENABLE_BLUETOOTH_REQUEST);
        }
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        if (requestCode == ENABLE_BLUETOOTH_REQUEST) {
            if (resultCode == RESULT_OK) {
                scan();
            } else {
                setResult(RESULT_CANCELED);
                finish();
            }
        }
    }

    private void scan() {
        populatePairedDevices();
        mNewDevicesAdapter.clear();
        if (mBluetoothAdapter.isDiscovering()) {
            mBluetoothAdapter.cancelDiscovery();
        }
        mBluetoothAdapter.startDiscovery();
    }

    private void populatePairedDevices() {
        mPairedDevicesAdapter.clear();
        Set<BluetoothDevice> pairedDevices = mBluetoothAdapter.getBondedDevices();
        for (BluetoothDevice device : pairedDevices) {
            mPairedDevicesAdapter.add(Device.fromBluetoothDevice(device));
        }
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        if (mBluetoothAdapter != null) {
            mBluetoothAdapter.cancelDiscovery();
        }
        unregisterReceiver(mReceiver);
    }

    class NewDeviceClickListener implements OnItemClickListener {
        @Override
        public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
            Intent data = new Intent();
            Device device = (Device) parent.getItemAtPosition(position);
            data.putExtra(EXTRA_DEVICE_ADDRESS, device.mAddress);
            setResult(RESULT_OK, data);
            finish();
        }
    }

    class PairedDeviceClickListener implements OnItemClickListener {
        @Override
        public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
            new AlertDialog.Builder(DevicePickerActivity.this)
                .setIcon(android.R.drawable.ic_dialog_alert)
                .setMessage(R.string.bt_unpair)
                .setPositiveButton(R.string.bt_settings, new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                        if (mBluetoothAdapter != null) {
                            mBluetoothAdapter.cancelDiscovery();
                        }
                        Intent intent = new Intent();
                        intent.setAction(android.provider.Settings.ACTION_BLUETOOTH_SETTINGS);
                        startActivity(intent);
                    }
                })
                .show();
        }
    }

    class DiscoveryReceiver extends BroadcastReceiver {
        @Override
        public void onReceive(Context context, Intent intent) {
            if (BluetoothAdapter.ACTION_DISCOVERY_STARTED.equals(intent.getAction())) {
                mEmptyNewView.setText(R.string.bt_scanning);
                mProgressBar.setVisibility(View.VISIBLE);
            } else if (BluetoothAdapter.ACTION_DISCOVERY_FINISHED.equals(intent.getAction())) {
                mEmptyNewView.setText(R.string.bt_no_devices);
                mProgressBar.setVisibility(View.INVISIBLE);
            } else if (BluetoothDevice.ACTION_FOUND.equals(intent.getAction())) {
                BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
                if (device.getBondState() != BluetoothDevice.BOND_BONDED) {
                    mNewDevicesAdapter.add(Device.fromBluetoothDevice(device));
                }
            }
        }
    }

    static class Device {

        String mName;

        String mAddress;

        Device(String name, String address) {
            mName = name;
            mAddress = address;
        }

        @Override
        public String toString() {
            return mName + ""\n"" + mAddress;
        }

        static Device fromBluetoothDevice(BluetoothDevice device) {
            return new Device(device.getName() != null ? device.getName() : """",
                    device.getAddress());
        }
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.media.cts.MediaScannerNotificationTest"	"testMediaScannerNotification"	"CtsMediaTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/MediaScannerNotificationTest.java"	""	"public void testMediaScannerNotification() throws Exception {
        ScannerNotificationReceiver startedReceiver = new ScannerNotificationReceiver(
                Intent.ACTION_MEDIA_SCANNER_STARTED);
        ScannerNotificationReceiver finishedReceiver = new ScannerNotificationReceiver(
                Intent.ACTION_MEDIA_SCANNER_FINISHED);

        IntentFilter startedIntentFilter = new IntentFilter(Intent.ACTION_MEDIA_SCANNER_STARTED);
        startedIntentFilter.addDataScheme(""file"");
        IntentFilter finshedIntentFilter = new IntentFilter(Intent.ACTION_MEDIA_SCANNER_FINISHED);
        finshedIntentFilter.addDataScheme(""file"");

        mContext.registerReceiver(startedReceiver, startedIntentFilter);
        mContext.registerReceiver(finishedReceiver, finshedIntentFilter);

        String [] temps = new String[] { ""avi"", ""gif"", ""jpg"", ""dat"", ""mp3"", ""mp4"", ""txt"" };
        String tmpPath = createTempFiles(temps);

        MediaScannerTest.startMediaScan();
        startedReceiver.waitForBroadcast();
        finishedReceiver.waitForBroadcast();

        checkTempFiles(tmpPath, temps);

        // add .nomedia file and scan again
        File noMedia = new File(tmpPath, "".nomedia"");
        try {
            noMedia.createNewFile();
        } catch (IOException e) {
            fail(""couldn't create .nomedia file"");
        }
        startedReceiver.reset();
        finishedReceiver.reset();
        MediaScannerTest.startMediaScan();
        startedReceiver.waitForBroadcast();
        finishedReceiver.waitForBroadcast();

        checkTempFiles(tmpPath, temps);
        assertTrue(noMedia.delete());
        deleteTempFiles(tmpPath, temps);

        // scan one more time just to clean everything up nicely
        startedReceiver.reset();
        finishedReceiver.reset();
        MediaScannerTest.startMediaScan();
        startedReceiver.waitForBroadcast();
        finishedReceiver.waitForBroadcast();

    }

    String createTempFiles(String [] extensions) {
        String externalPath = Environment.getExternalStorageDirectory().getAbsolutePath();
        File tmpDir = new File(externalPath, """" + System.nanoTime());
        String tmpPath = tmpDir.getAbsolutePath();
        assertFalse(tmpPath + "" already exists"", tmpDir.exists());
        assertTrue(""failed to create "" + tmpDir, tmpDir.mkdirs());

        for (int i = 0; i < extensions.length; i++) {
            File foo = new File(tmpPath, ""foobar."" + extensions[i]);
            try {
                // create a non-empty file
                foo.createNewFile();
                FileOutputStream out = new FileOutputStream(foo);
                out.write(0x12);
                out.flush();
                out.close();
                assertTrue(foo.length() != 0);
            } catch (IOException e) {
                fail(""Error creating "" + foo.getAbsolutePath() + "": "" + e);
            }
        }
        return tmpPath;
    }

    void checkTempFiles(String tmpPath, String [] extensions) {
        for (int i = 0; i < extensions.length; i++) {
            File foo = new File(tmpPath, ""foobar."" + extensions[i]);
            assertTrue(foo.getAbsolutePath() + "" no longer exists or was truncated"",
                    foo.length() != 0);
        }
    }

    void deleteTempFiles(String tmpPath, String [] extensions) {
        for (int i = 0; i < extensions.length; i++) {
            assertTrue(new File(tmpPath, ""foobar."" + extensions[i]).delete());
        }
        assertTrue(new File(tmpPath).delete());
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.media.tv.tuner.cts.TunerFrontendTest"	"testDvbsFrontendSettings"	"CtsTvTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/tv/src/android/media/tv/tuner/cts/TunerFrontendTest.java"	""	"public void testDvbsFrontendSettings() throws Exception {
        DvbsCodeRate codeRate =
                DvbsCodeRate
                        .builder()
                        .setInnerFec(FrontendSettings.FEC_9_10)
                        .setLinear(true)
                        .setShortFrameEnabled(false)
                        .setBitsPer1000Symbol(55)
                        .build();

        DvbsFrontendSettings settings =
                DvbsFrontendSettings
                        .builder()
                        .setFrequency(5)
                        .setModulation(DvbsFrontendSettings.MODULATION_MOD_ACM)
                        .setCodeRate(codeRate)
                        .setSymbolRate(3)
                        .setRolloff(DvbsFrontendSettings.ROLLOFF_0_15)
                        .setPilot(DvbsFrontendSettings.PILOT_OFF)
                        .setInputStreamId(1)
                        .setStandard(DvbsFrontendSettings.STANDARD_S2)
                        .setVcmMode(DvbsFrontendSettings.VCM_MODE_MANUAL)
                        .setScanType(DvbsFrontendSettings.SCAN_TYPE_DIRECT)
                        .setCanHandleDiseqcRxMessage(true)
                        .build();

        settings.setSpectralInversion(FrontendSettings.FRONTEND_SPECTRAL_INVERSION_NORMAL);
        settings.setEndFrequency(100);

        assertEquals(FrontendSettings.TYPE_DVBS, settings.getType());
        assertEquals(5, settings.getFrequency());
        assertEquals(DvbsFrontendSettings.MODULATION_MOD_ACM, settings.getModulation());
        assertEquals(3, settings.getSymbolRate());
        assertEquals(DvbsFrontendSettings.ROLLOFF_0_15, settings.getRolloff());
        assertEquals(DvbsFrontendSettings.PILOT_OFF, settings.getPilot());
        assertEquals(1, settings.getInputStreamId());
        assertEquals(DvbsFrontendSettings.STANDARD_S2, settings.getStandard());
        assertEquals(DvbsFrontendSettings.VCM_MODE_MANUAL, settings.getVcmMode());
        if (TunerVersionChecker.isHigherOrEqualVersionTo(TunerVersionChecker.TUNER_VERSION_1_1)) {
            assertEquals(DvbsFrontendSettings.SCAN_TYPE_DIRECT, settings.getScanType());
            assertTrue(settings.canHandleDiseqcRxMessage());
            assertEquals(FrontendSettings.FRONTEND_SPECTRAL_INVERSION_NORMAL,
                    settings.getFrontendSpectralInversion());
            assertEquals(100, settings.getEndFrequency());
        } else {
            assertEquals(DvbsFrontendSettings.SCAN_TYPE_UNDEFINED, settings.getScanType());
            assertFalse(settings.canHandleDiseqcRxMessage());
            assertEquals(FrontendSettings.FRONTEND_SPECTRAL_INVERSION_UNDEFINED,
                    settings.getFrontendSpectralInversion());
            assertEquals(Tuner.INVALID_FRONTEND_SETTING_FREQUENCY, settings.getEndFrequency());
        }

        DvbsCodeRate cr = settings.getCodeRate();
        assertNotNull(cr);
        assertEquals(FrontendSettings.FEC_9_10, cr.getInnerFec());
        assertEquals(true, cr.isLinear());
        assertEquals(false, cr.isShortFrameEnabled());
        assertEquals(55, cr.getBitsPer1000Symbol());
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.media.cts.RouteDiscoveryPreferenceTest"	"testGetters"	"CtsMediaTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/RouteDiscoveryPreferenceTest.java"	""	"public void testGetters() {
        final List<String> features = new ArrayList<>();
        features.add(TEST_FEATURE_1);
        features.add(TEST_FEATURE_2);

        RouteDiscoveryPreference preference =
                new RouteDiscoveryPreference.Builder(features, true /* isActiveScan */).build();
        assertEquals(features, preference.getPreferredFeatures());
        assertTrue(preference.shouldPerformActiveScan());
        assertEquals(0, preference.describeContents());
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.media.cts.RouteDiscoveryPreferenceTest"	"testBuilderSetPreferredFeatures"	"CtsMediaTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/RouteDiscoveryPreferenceTest.java"	""	"public void testBuilderSetPreferredFeatures() {
        final List<String> features = new ArrayList<>();
        features.add(TEST_FEATURE_1);
        features.add(TEST_FEATURE_2);

        RouteDiscoveryPreference preference =
                new RouteDiscoveryPreference.Builder(features, true /* isActiveScan */).build();

        final List<String> newFeatures = new ArrayList<>();
        newFeatures.add(TEST_FEATURE_1);

        // Using copy constructor, we only change the setPreferredFeatures.
        RouteDiscoveryPreference newPreference = new RouteDiscoveryPreference.Builder(preference)
                .setPreferredFeatures(newFeatures)
                .build();

        assertEquals(newFeatures, newPreference.getPreferredFeatures());
        assertTrue(newPreference.shouldPerformActiveScan());
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.media.cts.RouteDiscoveryPreferenceTest"	"testBuilderSetActiveScan"	"CtsMediaTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/RouteDiscoveryPreferenceTest.java"	""	"public void testBuilderSetActiveScan() {
        final List<String> features = new ArrayList<>();
        features.add(TEST_FEATURE_1);
        features.add(TEST_FEATURE_2);

        RouteDiscoveryPreference preference =
                new RouteDiscoveryPreference.Builder(features, true /* isActiveScan */).build();

        // Using copy constructor, we only change the activeScan to 'false'.
        RouteDiscoveryPreference newPreference = new RouteDiscoveryPreference.Builder(preference)
                .setShouldPerformActiveScan(false)
                .build();

        assertEquals(features, newPreference.getPreferredFeatures());
        assertFalse(newPreference.shouldPerformActiveScan());
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.media.cts.RouteDiscoveryPreferenceTest"	"testEqualsCreatedWithSameArguments"	"CtsMediaTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/RouteDiscoveryPreferenceTest.java"	""	"public void testEqualsCreatedWithSameArguments() {
        final List<String> features = new ArrayList<>();
        features.add(TEST_FEATURE_1);
        features.add(TEST_FEATURE_2);

        RouteDiscoveryPreference preference1 =
                new RouteDiscoveryPreference.Builder(features, true /* isActiveScan */).build();

        RouteDiscoveryPreference preference2 =
                new RouteDiscoveryPreference.Builder(features, true /* isActiveScan */).build();

        assertEquals(preference1, preference2);
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.media.cts.RouteDiscoveryPreferenceTest"	"testEqualsCreatedWithBuilderCopyConstructor"	"CtsMediaTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/RouteDiscoveryPreferenceTest.java"	""	"public void testEqualsCreatedWithBuilderCopyConstructor() {
        final List<String> features = new ArrayList<>();
        features.add(TEST_FEATURE_1);
        features.add(TEST_FEATURE_2);

        RouteDiscoveryPreference preference1 =
                new RouteDiscoveryPreference.Builder(features, true /* isActiveScan */).build();

        RouteDiscoveryPreference preference2 =
                new RouteDiscoveryPreference.Builder(preference1).build();

        assertEquals(preference1, preference2);
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.media.cts.RouteDiscoveryPreferenceTest"	"testEqualsReturnFalse"	"CtsMediaTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/RouteDiscoveryPreferenceTest.java"	""	"public void testEqualsReturnFalse() {
        final List<String> features = new ArrayList<>();
        features.add(TEST_FEATURE_1);
        features.add(TEST_FEATURE_2);

        RouteDiscoveryPreference preference =
                new RouteDiscoveryPreference.Builder(features, true /* isActiveScan */).build();

        RouteDiscoveryPreference preferenceWithDifferentFeatures =
                new RouteDiscoveryPreference.Builder(new ArrayList<>(), true /* isActiveScan */)
                        .build();
        assertNotEquals(preference, preferenceWithDifferentFeatures);

        RouteDiscoveryPreference preferenceWithDifferentActiveScan =
                new RouteDiscoveryPreference.Builder(features, false /* isActiveScan */)
                        .build();
        assertNotEquals(preference, preferenceWithDifferentActiveScan);
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.media.cts.RouteDiscoveryPreferenceTest"	"testEqualsReturnFalseWithCopyConstructor"	"CtsMediaTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/RouteDiscoveryPreferenceTest.java"	""	"public void testEqualsReturnFalseWithCopyConstructor() {
        final List<String> features = new ArrayList<>();
        features.add(TEST_FEATURE_1);
        features.add(TEST_FEATURE_2);

        RouteDiscoveryPreference preference =
                new RouteDiscoveryPreference.Builder(features, true /* isActiveScan */).build();

        final List<String> newFeatures = new ArrayList<>();
        newFeatures.add(TEST_FEATURE_1);
        RouteDiscoveryPreference preferenceWithDifferentFeatures =
                new RouteDiscoveryPreference.Builder(preference)
                        .setPreferredFeatures(newFeatures)
                        .build();
        assertNotEquals(preference, preferenceWithDifferentFeatures);

        RouteDiscoveryPreference preferenceWithDifferentActiveScan =
                new RouteDiscoveryPreference.Builder(preference)
                        .setShouldPerformActiveScan(false)
                        .build();
        assertNotEquals(preference, preferenceWithDifferentActiveScan);
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.media.cts.RouteDiscoveryPreferenceTest"	"testParcelingAndUnParceling"	"CtsMediaTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/RouteDiscoveryPreferenceTest.java"	""	"public void testParcelingAndUnParceling() {
        final List<String> features = new ArrayList<>();
        features.add(TEST_FEATURE_1);
        features.add(TEST_FEATURE_2);

        RouteDiscoveryPreference preference =
                new RouteDiscoveryPreference.Builder(features, true /* isActiveScan */).build();

        Parcel parcel = Parcel.obtain();
        parcel.writeParcelable(preference, 0);
        parcel.setDataPosition(0);

        RouteDiscoveryPreference preferenceFromParcel = parcel.readParcelable(null);
        assertEquals(preference, preferenceFromParcel);
        parcel.recycle();

        // In order to mark writeToParcel as tested, we let's just call it directly.
        Parcel dummyParcel = Parcel.obtain();
        preference.writeToParcel(dummyParcel, 0);
        dummyParcel.recycle();
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.app.RetrieveConnectionInfoAndReturnStatusActivity"	"finish"	""	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/CtsWifiLocationTestApp/src/android/net/wifi/cts/app/RetrieveConnectionInfoAndReturnStatusActivity.java"	""	"public void test/*
 *.
 */

package android.net.wifi.cts.app;

import android.app.Activity;
import android.content.Intent;
import android.net.wifi.WifiManager;
import android.os.Bundle;
import android.util.Log;

/**
 * An activity that retrieves connection info and returns status.
 */
public class RetrieveConnectionInfoAndReturnStatusActivity extends Activity {
    private static final String TAG = ""RetrieveConnectionInfoAndReturnStatusActivity"";
    private static final String SCAN_STATUS_EXTRA = ""android.net.wifi.cts.app.extra.STATUS"";

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        WifiManager wifiManager = getSystemService(WifiManager.class);
        boolean succeeded;
        try {
            succeeded = !wifiManager.getConnectionInfo().getSSID().equals(WifiManager.UNKNOWN_SSID);
        } catch (SecurityException e) {
            succeeded = false;
        }
        if (succeeded) {
            Log.v(TAG, ""SSID from connection info retrieval succeeded"");
        } else {
            Log.v(TAG, ""Failed to retrieve SSID from connection info"");
        }
        setResult(RESULT_OK, new Intent().putExtra(SCAN_STATUS_EXTRA, succeeded));
        finish();
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.bluetooth.BleAdvertiserHardwareScanFilterActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/bluetooth/BleAdvertiserHardwareScanFilterActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.bluetooth;

import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;

import android.bluetooth.BluetoothAdapter;
import android.bluetooth.BluetoothDevice;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.Bundle;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.Toast;

public class BleAdvertiserHardwareScanFilterActivity extends PassFailButtons.Activity {

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.ble_advertiser_hardware_scan_filter);
        setPassFailButtonClickListeners();
        setInfoResources(R.string.ble_advertiser_scan_filter_name,
                         R.string.ble_advertiser_scan_filter_info, -1);

        ((Button) findViewById(R.id.ble_advertiser_scannable_start))
            .setOnClickListener(new OnClickListener() {
                @Override
                public void onClick(View v) {
                    Intent intent = new Intent(BleAdvertiserHardwareScanFilterActivity.this,
                                               BleAdvertiserService.class);
                    intent.putExtra(BleAdvertiserService.EXTRA_COMMAND,
                                    BleAdvertiserService.COMMAND_START_SCANNABLE);
                    startService(intent);
                }
            });
        ((Button)findViewById(R.id.ble_advertiser_scannable_stop))
            .setOnClickListener(new OnClickListener() {
                @Override
                public void onClick(View v) {
                    stopAdvertising();
                }
            });
        ((Button)findViewById(R.id.ble_advertiser_unscannable_start))
            .setOnClickListener(new OnClickListener() {
                @Override
                public void onClick(View v) {
                    Intent intent = new Intent(BleAdvertiserHardwareScanFilterActivity.this,
                                               BleAdvertiserService.class);
                    intent.putExtra(BleAdvertiserService.EXTRA_COMMAND,
                                    BleAdvertiserService.COMMAND_START_UNSCANNABLE);
                    startService(intent);
                }
        });
        ((Button)findViewById(R.id.ble_advertiser_unscannable_stop))
            .setOnClickListener(new OnClickListener() {
                @Override
                public void onClick(View v) {
                    stopAdvertising();
                }
        });
    }

    @Override
    public void onResume() {
        super.onResume();
        IntentFilter filter = new IntentFilter();
        filter.addAction(BleAdvertiserService.BLE_ADV_NOT_SUPPORT);
        filter.addAction(BleAdvertiserService.BLE_START_SCANNABLE);
        filter.addAction(BleAdvertiserService.BLE_START_UNSCANNABLE);
        filter.addAction(BleAdvertiserService.BLE_STOP_SCANNABLE);
        filter.addAction(BleAdvertiserService.BLE_STOP_UNSCANNABLE);
        registerReceiver(onBroadcast, filter);
    }

    @Override
    public void onPause() {
        super.onPause();
        unregisterReceiver(onBroadcast);
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        stopAdvertising();
    }

    private void showMessage(String msg) {
        Toast.makeText(this, msg, Toast.LENGTH_SHORT).show();
    }

    private void pass() {
        this.setTestResultAndFinish(true);
    }

    private void stopAdvertising() {
        Intent intent = new Intent(BleAdvertiserHardwareScanFilterActivity.this,
                                   BleAdvertiserService.class);
        intent.putExtra(BleAdvertiserService.EXTRA_COMMAND,
                        BleAdvertiserService.COMMAND_STOP_SCANNABLE);
        intent.putExtra(BleAdvertiserService.EXTRA_COMMAND,
                        BleAdvertiserService.COMMAND_STOP_UNSCANNABLE);
        startService(intent);
    }

    private BroadcastReceiver onBroadcast = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            switch (intent.getAction()) {
                case BleAdvertiserService.BLE_START_SCANNABLE:
                    showMessage(""Start advertising, this should be scanned"");
                    break;
                case BleAdvertiserService.BLE_START_UNSCANNABLE:
                    showMessage(""Start advertising, this should not be scanned"");
                    break;
                case BleAdvertiserService.BLE_STOP_SCANNABLE:
                case BleAdvertiserService.BLE_STOP_UNSCANNABLE:
                    showMessage(""Stop advertising"");
                    break;
                case BleAdvertiserService.BLE_ADV_NOT_SUPPORT:
                    pass();
                    break;
            }
        }
    };
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.bluetooth.BleScannerPowerLevelActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/bluetooth/BleScannerPowerLevelActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.bluetooth;

import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;

import java.lang.Math;
import java.util.Set;
import java.util.Map;
import java.util.HashMap;

import android.bluetooth.le.AdvertiseSettings;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.graphics.Color;
import android.os.Bundle;
import android.util.Log;
import android.widget.TextView;
import android.widget.Toast;

public class BleScannerPowerLevelActivity extends PassFailButtons.Activity {

    private static final String TAG = ""BleScannerPowerLevel"";

    private Map<Integer, TextView> mMacText;
    private Map<Integer, TextView> mCountText;
    private Map<Integer, TextView> mRssiText;
    private Map<Integer, TextView> mSetPowerText;
    private Map<Integer, Integer> mCount;
    private int[] mPowerLevel;

    private static final int[] POWER_DBM = {-21, -15, -7, 1, 9};
    private static final int ADV_TX_POWER_LEVEL_ALLOWANCE = 5;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.ble_scanner_power_level);
        setPassFailButtonClickListeners();
        setInfoResources(R.string.ble_power_level_name,
                         R.string.ble_power_level_info, -1);

        mRssiText = new HashMap<Integer, TextView>();
        mCountText = new HashMap<Integer, TextView>();
        mCount = null;
        mMacText = new HashMap<Integer, TextView>();
        mSetPowerText = new HashMap<Integer, TextView>();
        mPowerLevel = new int[]{AdvertiseSettings.ADVERTISE_TX_POWER_ULTRA_LOW,
            AdvertiseSettings.ADVERTISE_TX_POWER_LOW,
            AdvertiseSettings.ADVERTISE_TX_POWER_MEDIUM,
            AdvertiseSettings.ADVERTISE_TX_POWER_HIGH};

        mMacText.put(AdvertiseSettings.ADVERTISE_TX_POWER_ULTRA_LOW,
            (TextView)findViewById(R.id.ble_ultra_low_mac));
        mMacText.put(AdvertiseSettings.ADVERTISE_TX_POWER_LOW,
            (TextView)findViewById(R.id.ble_low_mac));
        mMacText.put(AdvertiseSettings.ADVERTISE_TX_POWER_MEDIUM,
            (TextView)findViewById(R.id.ble_medium_mac));
        mMacText.put(AdvertiseSettings.ADVERTISE_TX_POWER_HIGH,
            (TextView)findViewById(R.id.ble_high_mac));

        mCountText.put(AdvertiseSettings.ADVERTISE_TX_POWER_ULTRA_LOW,
            (TextView)findViewById(R.id.ble_ultra_low_count));
        mCountText.put(AdvertiseSettings.ADVERTISE_TX_POWER_LOW,
            (TextView)findViewById(R.id.ble_low_count));
        mCountText.put(AdvertiseSettings.ADVERTISE_TX_POWER_MEDIUM,
            (TextView)findViewById(R.id.ble_medium_count));
        mCountText.put(AdvertiseSettings.ADVERTISE_TX_POWER_HIGH,
            (TextView)findViewById(R.id.ble_high_count));

        mRssiText.put(AdvertiseSettings.ADVERTISE_TX_POWER_ULTRA_LOW,
            (TextView)findViewById(R.id.ble_ultra_low_rssi));
        mRssiText.put(AdvertiseSettings.ADVERTISE_TX_POWER_LOW,
            (TextView)findViewById(R.id.ble_low_rssi));
        mRssiText.put(AdvertiseSettings.ADVERTISE_TX_POWER_MEDIUM,
            (TextView)findViewById(R.id.ble_medium_rssi));
        mRssiText.put(AdvertiseSettings.ADVERTISE_TX_POWER_HIGH,
            (TextView)findViewById(R.id.ble_high_rssi));

        mSetPowerText.put(AdvertiseSettings.ADVERTISE_TX_POWER_ULTRA_LOW,
            (TextView)findViewById(R.id.ble_ultra_low_set_power));
        mSetPowerText.put(AdvertiseSettings.ADVERTISE_TX_POWER_LOW,
            (TextView)findViewById(R.id.ble_low_set_power));
        mSetPowerText.put(AdvertiseSettings.ADVERTISE_TX_POWER_MEDIUM,
            (TextView)findViewById(R.id.ble_medium_set_power));
        mSetPowerText.put(AdvertiseSettings.ADVERTISE_TX_POWER_HIGH,
            (TextView)findViewById(R.id.ble_high_set_power));

        Intent intent = new Intent(this, BleScannerService.class);
        intent.putExtra(BleScannerService.EXTRA_COMMAND, BleScannerService.COMMAND_POWER_LEVEL);
        startService(intent);
    }

    @Override
    public void onResume() {
        super.onResume();

        IntentFilter filter = new IntentFilter();
        filter.addAction(BleScannerService.BLE_POWER_LEVEL);
        filter.addAction(BleScannerService.BLE_PRIVACY_NEW_MAC_RECEIVE);
        registerReceiver(onBroadcast, filter);
    }

    @Override
    public void onPause() {
        super.onPause();
        unregisterReceiver(onBroadcast);
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        stopService(new Intent(this, BleScannerService.class));
    }

    private BroadcastReceiver onBroadcast = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            switch (intent.getAction()) {
                case BleScannerService.BLE_POWER_LEVEL:
                    int powerLevelBit = intent.getIntExtra(
                            BleScannerService.EXTRA_POWER_LEVEL_BIT, -1);
                    int powerLevel = intent.getIntExtra(BleScannerService.EXTRA_POWER_LEVEL, -2);
                    if (powerLevelBit < 0 || powerLevelBit > 3) {
                        Toast.makeText(context, ""Invalid power level"", Toast.LENGTH_SHORT).show();
                        break;
                    }

                    if (mCount == null) {
                        mCount = new HashMap<Integer, Integer>();
                        for (int i : mPowerLevel) {
                            mCount.put(i, 0);
                        }
                    }
                    Integer t = mCount.get(powerLevelBit) + 1;
                    mCount.put(powerLevelBit, t);
                    mCountText.get(powerLevelBit).setText(t.toString());

                    mMacText.get(powerLevelBit)
                        .setText(intent.getStringExtra(BleScannerService.EXTRA_MAC_ADDRESS));
                    mRssiText.get(powerLevelBit)
                        .setText(intent.getStringExtra(BleScannerService.EXTRA_RSSI));

                    if ((POWER_DBM[powerLevelBit] >= powerLevel) &&
                        ((POWER_DBM[powerLevelBit] - ADV_TX_POWER_LEVEL_ALLOWANCE) <= powerLevel)) {
                        mSetPowerText.get(powerLevelBit).setText(""Valid power level"");
                    } else {
                        mSetPowerText.get(powerLevelBit)
                            .setText(""Unknown BLe advertise tx power: "" + powerLevel);
                    }
                    break;
                case BleScannerService.BLE_PRIVACY_NEW_MAC_RECEIVE:
                     Toast.makeText(context, ""New MAC address detected"", Toast.LENGTH_SHORT)
                            .show();
                     break;
            }
        }
    };
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.media.cts.DecoderTest"	"testMPEG2ColorAspectsTV"	"CtsMediaTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/DecoderTest.java"	""	"public void testMPEG2ColorAspectsTV() throws Exception {
        testColorAspects(
                ""color_176x144_bt709_lr_sdr_mpeg2.mp4"", 1 /* testId */,
                MediaFormat.COLOR_RANGE_LIMITED, MediaFormat.COLOR_STANDARD_BT709,
                MediaFormat.COLOR_TRANSFER_SDR_VIDEO);
        testColorAspects(
                ""color_176x144_bt601_625_lr_sdr_mpeg2.mp4"", 2 /* testId */,
                MediaFormat.COLOR_RANGE_LIMITED, MediaFormat.COLOR_STANDARD_BT601_PAL,
                MediaFormat.COLOR_TRANSFER_SDR_VIDEO);
        testColorAspects(
                ""color_176x144_bt601_525_lr_sdr_mpeg2.mp4"", 3 /* testId */,
                MediaFormat.COLOR_RANGE_LIMITED, MediaFormat.COLOR_STANDARD_BT601_NTSC,
                MediaFormat.COLOR_TRANSFER_SDR_VIDEO);
        testColorAspects(
                ""color_176x144_srgb_lr_sdr_mpeg2.mp4"", 4 /* testId */,
                MediaFormat.COLOR_RANGE_LIMITED, MediaFormat.COLOR_STANDARD_BT709,
                2 /* MediaFormat.COLOR_TRANSFER_SRGB */);
    }

    private void testColorAspects(
            final String res, int testId, int expectRange, int expectStandard, int expectTransfer)
            throws Exception {
        testColorAspects(
                res, testId, expectRange, expectStandard, expectTransfer, null /*surface*/);
    }

    private void testColorAspects(
            final String res, int testId, int expectRange, int expectStandard, int expectTransfer,
            Surface surface) throws Exception {
        Preconditions.assertTestFileExists(mInpPrefix + res);
        MediaFormat format = MediaUtils.getTrackFormatForResource(mInpPrefix + res, ""video"");
        MediaFormat mimeFormat = new MediaFormat();
        mimeFormat.setString(MediaFormat.KEY_MIME, format.getString(MediaFormat.KEY_MIME));

        for (String decoderName: MediaUtils.getDecoderNames(mimeFormat)) {
            if (!MediaUtils.supports(decoderName, format)) {
                MediaUtils.skipTest(decoderName + "" cannot play resource "" + mInpPrefix + res);
            } else {
                testColorAspects(decoderName, res, testId,
                        expectRange, expectStandard, expectTransfer, surface);
            }
        }
    }

    private void testColorAspects(
            String decoderName, final String res, int testId, int expectRange,
            int expectStandard, int expectTransfer, Surface surface) throws Exception {
        Preconditions.assertTestFileExists(mInpPrefix + res);
        MediaExtractor ex = new MediaExtractor();
        ex.setDataSource(mInpPrefix + res);
        MediaFormat format = ex.getTrackFormat(0);
        MediaCodec dec = MediaCodec.createByCodecName(decoderName);
        dec.configure(format, surface, null, 0);
        dec.start();
        ByteBuffer[] buf = dec.getInputBuffers();
        ex.selectTrack(0);
        MediaCodec.BufferInfo info = new MediaCodec.BufferInfo();
        boolean sawInputEOS = false;
        boolean getOutputFormat = false;
        boolean rangeMatch = false;
        boolean colorMatch = false;
        boolean transferMatch = false;
        int colorRange = 0;
        int colorStandard = 0;
        int colorTransfer = 0;

        while (true) {
            if (!sawInputEOS) {
                int flags = ex.getSampleFlags();
                long time = ex.getSampleTime();
                int bufidx = dec.dequeueInputBuffer(200 * 1000);
                if (bufidx >= 0) {
                    int n = ex.readSampleData(buf[bufidx], 0);
                    if (n < 0) {
                        flags = MediaCodec.BUFFER_FLAG_END_OF_STREAM;
                        sawInputEOS = true;
                        n = 0;
                    }
                    dec.queueInputBuffer(bufidx, 0, n, time, flags);
                    ex.advance();
                } else {
                    assertEquals(
                            ""codec.dequeueInputBuffer() unrecognized return value: "" + bufidx,
                            MediaCodec.INFO_TRY_AGAIN_LATER, bufidx);
                }
            }

            int status = dec.dequeueOutputBuffer(info, sawInputEOS ? 3000 * 1000 : 100 * 1000);
            if (status == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {
                MediaFormat fmt = dec.getOutputFormat();
                colorRange = fmt.containsKey(""color-range"") ? fmt.getInteger(""color-range"") : 0;
                colorStandard = fmt.containsKey(""color-standard"") ? fmt.getInteger(""color-standard"") : 0;
                colorTransfer = fmt.containsKey(""color-transfer"") ? fmt.getInteger(""color-transfer"") : 0;
                rangeMatch = colorRange == expectRange;
                colorMatch = colorStandard == expectStandard;
                transferMatch = colorTransfer == expectTransfer;
                getOutputFormat = true;
                // Test only needs to check the color format in the first format changed event.
                break;
            } else if (status >= 0) {
                // Test should get at least one format changed event before getting first frame.
                assertTrue(getOutputFormat == true);
                break;
            } else {
                assertFalse(
                        ""codec.dequeueOutputBuffer() timeout after seeing input EOS"",
                        status == MediaCodec.INFO_TRY_AGAIN_LATER && sawInputEOS);
            }
        }

        String reportName = decoderName + ""_colorAspectsTest Test "" + testId +
                "" (Get R: "" + colorRange + "" S: "" + colorStandard + "" T: "" + colorTransfer + "")"" +
                "" (Expect R: "" + expectRange + "" S: "" + expectStandard + "" T: "" + expectTransfer + "")"";
        Log.d(TAG, reportName);

        DeviceReportLog log = new DeviceReportLog(""CtsMediaTestCases"", ""color_aspects_test"");
        log.addValue(""decoder_name"", decoderName, ResultType.NEUTRAL, ResultUnit.NONE);
        log.addValue(""test_id"", testId, ResultType.NEUTRAL, ResultUnit.NONE);
        log.addValues(
                ""rst_actual"", new int[] { colorRange, colorStandard, colorTransfer },
                ResultType.NEUTRAL, ResultUnit.NONE);
        log.addValues(
                ""rst_expected"", new int[] { expectRange, expectStandard, expectTransfer },
                ResultType.NEUTRAL, ResultUnit.NONE);

        if (rangeMatch && colorMatch && transferMatch) {
            log.setSummary(""result"", 1, ResultType.HIGHER_BETTER, ResultUnit.COUNT);
        } else {
            log.setSummary(""result"", 0, ResultType.HIGHER_BETTER, ResultUnit.COUNT);
        }
        log.submit(getInstrumentation());

        assertTrue(rangeMatch && colorMatch && transferMatch);

        dec.release();
        ex.release();
    }

    private void testTrackSelection(final String res) throws Exception {
        MediaExtractor ex1 = new MediaExtractor();
        Preconditions.assertTestFileExists(mInpPrefix + res);
        try {
            ex1.setDataSource(mInpPrefix + res);

            ByteBuffer buf1 = ByteBuffer.allocate(1024*1024);
            ArrayList<Integer> vid = new ArrayList<Integer>();
            ArrayList<Integer> aud = new ArrayList<Integer>();

            // scan the file once and build lists of audio and video samples
            ex1.selectTrack(0);
            ex1.selectTrack(1);
            while(true) {
                int n1 = ex1.readSampleData(buf1, 0);
                if (n1 < 0) {
                    break;
                }
                int idx = ex1.getSampleTrackIndex();
                if (idx == 0) {
                    vid.add(n1);
                } else if (idx == 1) {
                    aud.add(n1);
                } else {
                    fail(""unexpected track index: "" + idx);
                }
                ex1.advance();
            }

            // read the video track once, then rewind and do it again, and
            // verify we get the right samples
            ex1.release();
            ex1 = new MediaExtractor();
            ex1.setDataSource(mInpPrefix + res);
            ex1.selectTrack(0);
            for (int i = 0; i < 2; i++) {
                ex1.seekTo(0, MediaExtractor.SEEK_TO_NEXT_SYNC);
                int idx = 0;
                while(true) {
                    int n1 = ex1.readSampleData(buf1, 0);
                    if (n1 < 0) {
                        assertEquals(vid.size(), idx);
                        break;
                    }
                    assertEquals(vid.get(idx++).intValue(), n1);
                    ex1.advance();
                }
            }

            // read the audio track once, then rewind and do it again, and
            // verify we get the right samples
            ex1.release();
            ex1 = new MediaExtractor();
            ex1.setDataSource(mInpPrefix + res);
            ex1.selectTrack(1);
            for (int i = 0; i < 2; i++) {
                ex1.seekTo(0, MediaExtractor.SEEK_TO_NEXT_SYNC);
                int idx = 0;
                while(true) {
                    int n1 = ex1.readSampleData(buf1, 0);
                    if (n1 < 0) {
                        assertEquals(aud.size(), idx);
                        break;
                    }
                    assertEquals(aud.get(idx++).intValue(), n1);
                    ex1.advance();
                }
            }

            // read the video track first, then rewind and get the audio track instead, and
            // verify we get the right samples
            ex1.release();
            ex1 = new MediaExtractor();
            ex1.setDataSource(mInpPrefix + res);
            for (int i = 0; i < 2; i++) {
                ex1.selectTrack(i);
                ex1.seekTo(0, MediaExtractor.SEEK_TO_NEXT_SYNC);
                int idx = 0;
                while(true) {
                    int n1 = ex1.readSampleData(buf1, 0);
                    if (i == 0) {
                        if (n1 < 0) {
                            assertEquals(vid.size(), idx);
                            break;
                        }
                        assertEquals(vid.get(idx++).intValue(), n1);
                    } else if (i == 1) {
                        if (n1 < 0) {
                            assertEquals(aud.size(), idx);
                            break;
                        }
                        assertEquals(aud.get(idx++).intValue(), n1);
                    } else {
                        fail(""unexpected track index: "" + idx);
                    }
                    ex1.advance();
                }
                ex1.unselectTrack(i);
            }

            // read the video track first, then rewind, enable the audio track in addition
            // to the video track, and verify we get the right samples
            ex1.release();
            ex1 = new MediaExtractor();
            ex1.setDataSource(mInpPrefix + res);
            for (int i = 0; i < 2; i++) {
                ex1.selectTrack(i);
                ex1.seekTo(0, MediaExtractor.SEEK_TO_NEXT_SYNC);
                int vididx = 0;
                int audidx = 0;
                while(true) {
                    int n1 = ex1.readSampleData(buf1, 0);
                    if (n1 < 0) {
                        // we should have read all audio and all video samples at this point
                        assertEquals(vid.size(), vididx);
                        if (i == 1) {
                            assertEquals(aud.size(), audidx);
                        }
                        break;
                    }
                    int trackidx = ex1.getSampleTrackIndex();
                    if (trackidx == 0) {
                        assertEquals(vid.get(vididx++).intValue(), n1);
                    } else if (trackidx == 1) {
                        assertEquals(aud.get(audidx++).intValue(), n1);
                    } else {
                        fail(""unexpected track index: "" + trackidx);
                    }
                    ex1.advance();
                }
            }

            // read both tracks from the start, then rewind and verify we get the right
            // samples both times
            ex1.release();
            ex1 = new MediaExtractor();
            ex1.setDataSource(mInpPrefix + res);
            for (int i = 0; i < 2; i++) {
                ex1.selectTrack(0);
                ex1.selectTrack(1);
                ex1.seekTo(0, MediaExtractor.SEEK_TO_NEXT_SYNC);
                int vididx = 0;
                int audidx = 0;
                while(true) {
                    int n1 = ex1.readSampleData(buf1, 0);
                    if (n1 < 0) {
                        // we should have read all audio and all video samples at this point
                        assertEquals(vid.size(), vididx);
                        assertEquals(aud.size(), audidx);
                        break;
                    }
                    int trackidx = ex1.getSampleTrackIndex();
                    if (trackidx == 0) {
                        assertEquals(vid.get(vididx++).intValue(), n1);
                    } else if (trackidx == 1) {
                        assertEquals(aud.get(audidx++).intValue(), n1);
                    } else {
                        fail(""unexpected track index: "" + trackidx);
                    }
                    ex1.advance();
                }
            }

        } finally {
            if (ex1 != null) {
                ex1.release();
            }
        }
    }

    private static final String VP9_HDR_RES = ""video_1280x720_vp9_hdr_static_3mbps.mkv"";
    private static final String VP9_HDR_STATIC_INFO =
            ""00 d0 84 80 3e c2 33 c4  86 4c 1d b8 0b 13 3d 42"" +
            ""40 e8 03 64 00 e8 03 2c  01                     "" ;

    private static final String AV1_HDR_RES = ""video_1280x720_av1_hdr_static_3mbps.webm"";
    private static final String AV1_HDR_STATIC_INFO =
            ""00 d0 84 80 3e c2 33 c4  86 4c 1d b8 0b 13 3d 42"" +
            ""40 e8 03 64 00 e8 03 2c  01                     "" ;

    // Expected value of MediaFormat.KEY_HDR_STATIC_INFO key.
    // The associated value is a ByteBuffer. This buffer contains the raw contents of the
    // Static Metadata Descriptor (including the descriptor ID) of an HDMI Dynamic Range and
    // Mastering InfoFrame as defined by CTA-861.3.
    // Media frameworks puts the display primaries in RGB order, here we verify the three
    // primaries are indeed in this order and fail otherwise.
    private static final String H265_HDR10_RES = ""video_1280x720_hevc_hdr10_static_3mbps.mp4"";
    private static final String H265_HDR10_STATIC_INFO =
            ""00 d0 84 80 3e c2 33 c4  86 4c 1d b8 0b 13 3d 42"" +
            ""40 e8 03 00 00 e8 03 90  01                     "" ;

    private static final String VP9_HDR10PLUS_RES = ""video_bikes_hdr10plus.webm"";
    private static final String VP9_HDR10PLUS_STATIC_INFO =
            ""00 4c 1d b8 0b d0 84 80  3e c0 33 c4 86 12 3d 42"" +
            ""40 e8 03 32 00 e8 03 c8  00                     "" ;
    // TODO: Use some manually extracted metadata for now.
    // MediaExtractor currently doesn't have an API for extracting
    // the dynamic metadata. Get the metadata from extractor when
    // it's supported.
    private static final String[] VP9_HDR10PLUS_DYNAMIC_INFO = new String[] {
            ""b5 00 3c 00 01 04 00 40  00 0c 80 4e 20 27 10 00"" +
            ""0a 00 00 24 08 00 00 28  00 00 50 00 28 c8 00 c9"" +
            ""90 02 aa 58 05 ca d0 0c  0a f8 16 83 18 9c 18 00"" +
            ""40 78 13 64 d5 7c 2e 2c  c3 59 de 79 6e c3 c2 00"" ,

            ""b5 00 3c 00 01 04 00 40  00 0c 80 4e 20 27 10 00"" +
            ""0a 00 00 24 08 00 00 28  00 00 50 00 28 c8 00 c9"" +
            ""90 02 aa 58 05 ca d0 0c  0a f8 16 83 18 9c 18 00"" +
            ""40 78 13 64 d5 7c 2e 2c  c3 59 de 79 6e c3 c2 00"" ,

            ""b5 00 3c 00 01 04 00 40  00 0c 80 4e 20 27 10 00"" +
            ""0e 80 00 24 08 00 00 28  00 00 50 00 28 c8 00 c9"" +
            ""90 02 aa 58 05 ca d0 0c  0a f8 16 83 18 9c 18 00"" +
            ""40 78 13 64 d5 7c 2e 2c  c3 59 de 79 6e c3 c2 00"" ,

            ""b5 00 3c 00 01 04 00 40  00 0c 80 4e 20 27 10 00"" +
            ""0e 80 00 24 08 00 00 28  00 00 50 00 28 c8 00 c9"" +
            ""90 02 aa 58 05 ca d0 0c  0a f8 16 83 18 9c 18 00"" +
            ""40 78 13 64 d5 7c 2e 2c  c3 59 de 79 6e c3 c2 00"" ,
    };

    private static final String H265_HDR10PLUS_RES = ""video_h265_hdr10plus.mp4"";
    private static final String H265_HDR10PLUS_STATIC_INFO =
            ""00 4c 1d b8 0b d0 84 80  3e c2 33 c4 86 13 3d 42"" +
            ""40 e8 03 32 00 e8 03 c8  00                     "" ;
    private static final String[] H265_HDR10PLUS_DYNAMIC_INFO = new String[] {
            ""b5 00 3c 00 01 04 00 40  00 0c 80 4e 20 27 10 00"" +
            ""0f 00 00 24 08 00 00 28  00 00 50 00 28 c8 00 a1"" +
            ""90 03 9a 58 0b 6a d0 23  2a f8 40 8b 18 9c 18 00"" +
            ""40 78 13 64 cf 78 ed cc  bf 5a de f9 8e c7 c3 00"" ,

            ""b5 00 3c 00 01 04 00 40  00 0c 80 4e 20 27 10 00"" +
            ""0a 00 00 24 08 00 00 28  00 00 50 00 28 c8 00 a1"" +
            ""90 03 9a 58 0b 6a d0 23  2a f8 40 8b 18 9c 18 00"" +
            ""40 78 13 64 cf 78 ed cc  bf 5a de f9 8e c7 c3 00"" ,

            ""b5 00 3c 00 01 04 00 40  00 0c 80 4e 20 27 10 00"" +
            ""0f 00 00 24 08 00 00 28  00 00 50 00 28 c8 00 a1"" +
            ""90 03 9a 58 0b 6a d0 23  2a f8 40 8b 18 9c 18 00"" +
            ""40 78 13 64 cf 78 ed cc  bf 5a de f9 8e c7 c3 00"" ,

            ""b5 00 3c 00 01 04 00 40  00 0c 80 4e 20 27 10 00"" +
            ""0a 00 00 24 08 00 00 28  00 00 50 00 28 c8 00 a1"" +
            ""90 03 9a 58 0b 6a d0 23  2a f8 40 8b 18 9c 18 00"" +
            ""40 78 13 64 cf 78 ed cc  bf 5a de f9 8e c7 c3 00""
    };

    @CddTest(requirement=""5.3.7"")"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.permission.cts.NearbyDevicesRenouncePermissionTest"	"isEnabled"	"CtsPermissionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NearbyDevicesRenouncePermissionTest.java"	""	"/*
 *.
 */

package android.permission.cts;

import static android.Manifest.permission.ACCESS_FINE_LOCATION;
import static android.app.AppOpsManager.OPSTR_FINE_LOCATION;

import static androidx.test.core.app.ApplicationProvider.getApplicationContext;

import static com.android.compatibility.common.util.SystemUtil.runShellCommandOrThrow;

import static com.google.common.truth.Truth.assertThat;

import static org.junit.Assert.assertTrue;
import static org.junit.Assume.assumeTrue;

import android.app.AppOpsManager;
import android.app.AsyncNotedAppOp;
import android.app.SyncNotedAppOp;
import android.bluetooth.BluetoothAdapter;
import android.bluetooth.BluetoothManager;
import android.bluetooth.cts.BTAdapterUtils;
import android.bluetooth.le.BluetoothLeScanner;
import android.bluetooth.le.ScanCallback;
import android.bluetooth.le.ScanResult;
import android.content.AttributionSource;
import android.content.Context;
import android.content.ContextParams;
import android.content.pm.PackageManager;
import android.os.Process;
import android.os.SystemClock;
import android.platform.test.annotations.AppModeFull;
import android.util.ArraySet;
import android.util.Base64;
import android.util.Log;

import androidx.test.InstrumentationRegistry;

import com.android.compatibility.common.util.SystemUtil;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import java.util.HashSet;
import java.util.List;
import java.util.Set;

/**
 * Tests behaviour when performing bluetooth scans with renounced location permission.
 */
public class NearbyDevicesRenouncePermissionTest {

    private static final String TAG = ""NearbyDevicesRenouncePermissionTest"";
    private static final String OPSTR_BLUETOOTH_SCAN = ""android:bluetooth_scan"";

    private AppOpsManager mAppOpsManager;
    private int mLocationNoteCount;
    private int mScanNoteCount;
    private Context mContext = InstrumentationRegistry.getInstrumentation().getContext();
    private BluetoothAdapter mBluetoothAdapter;
    private boolean mBluetoothAdapterWasEnabled;

    private enum Result {
        UNKNOWN, EXCEPTION, EMPTY, FILTERED, FULL
    }

    private enum Scenario {
        DEFAULT, RENOUNCE, RENOUNCE_MIDDLE, RENOUNCE_END
    }

    @Before
    public void enableBluetooth() {
        assumeTrue(supportsBluetooth());
        mBluetoothAdapter = mContext.getSystemService(BluetoothManager.class).getAdapter();
        mBluetoothAdapterWasEnabled = mBluetoothAdapter.isEnabled();
        assertTrue(BTAdapterUtils.enableAdapter(mBluetoothAdapter, mContext));
        enableTestMode();
    }

    @After
    public void disableBluetooth() {
        assumeTrue(supportsBluetooth());
        disableTestMode();
        if (!mBluetoothAdapterWasEnabled) {
            assertTrue(BTAdapterUtils.disableAdapter(mBluetoothAdapter, mContext));
        }
    }

    @Before
    public void setUp() {
        mAppOpsManager = getApplicationContext().getSystemService(AppOpsManager.class);
        mAppOpsManager.setOnOpNotedCallback(getApplicationContext().getMainExecutor(),
                new AppOpsManager.OnOpNotedCallback() {
                    @Override
                    public void onNoted(SyncNotedAppOp op) {
                        switch (op.getOp()) {
                            case OPSTR_FINE_LOCATION:
                                mLocationNoteCount++;
                                break;
                            case OPSTR_BLUETOOTH_SCAN:
                                mScanNoteCount++;
                                break;
                            default:
                        }
                    }

                    @Override
                    public void onSelfNoted(SyncNotedAppOp op) {
                    }

                    @Override
                    public void onAsyncNoted(AsyncNotedAppOp asyncOp) {
                        switch (asyncOp.getOp()) {
                            case OPSTR_FINE_LOCATION:
                                mLocationNoteCount++;
                                break;
                            case OPSTR_BLUETOOTH_SCAN:
                                mScanNoteCount++;
                                break;
                            default:
                        }
                    }
                });
    }

    @After
    public void tearDown() {
        mAppOpsManager.setOnOpNotedCallback(null, null);
    }

    private void clearNoteCounts() {
        mLocationNoteCount = 0;
        mScanNoteCount = 0;
    }

    @AppModeFull"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.permission.cts.NearbyDevicesRenouncePermissionTest"	"enableTestMode"	"CtsPermissionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NearbyDevicesRenouncePermissionTest.java"	""	"public void scanRenouncingAtEndOfChainNotesBluetoothButNotLocation() throws Exception {
        clearNoteCounts();
        assertThat(performScan(Scenario.RENOUNCE_END)).isEqualTo(Result.FILTERED);
        SystemUtil.eventually(() -> {
            assertThat(mLocationNoteCount).isEqualTo(0);
            assertThat(mScanNoteCount).isGreaterThan(0);
        });
    }

    private Result performScan(Scenario scenario) {
        try {
            Context context = createContext(scenario, getApplicationContext());

            final BluetoothManager bm = context.getSystemService(BluetoothManager.class);
            final BluetoothLeScanner scanner = bm.getAdapter().getBluetoothLeScanner();

            final HashSet<String> observed = new HashSet<>();

            ScanCallback callback = new ScanCallback() {
                public void onScanResult(int callbackType, ScanResult result) {
                    Log.v(TAG, String.valueOf(result));
                    observed.add(Base64.encodeToString(result.getScanRecord().getBytes(), 0));
                }

                public void onBatchScanResults(List<ScanResult> results) {
                    for (ScanResult result : results) {
                        onScanResult(0, result);
                    }
                }
            };
            scanner.startScan(callback);

            // Wait a few seconds to figure out what we actually observed
            SystemClock.sleep(3000);
            scanner.stopScan(callback);
            switch (observed.size()) {
                case 0: return Result.EMPTY;
                case 1: return Result.FILTERED;
                case 5: return Result.FULL;
                default: return Result.UNKNOWN;
            }
        } catch (Throwable t) {
            Log.v(TAG, ""Failed to scan"", t);
            return Result.EXCEPTION;
        }
    }

    private Context createContext(Scenario scenario, Context context) throws Exception {
        if (scenario == Scenario.DEFAULT) {
            return context;
        }

        Set<String> renouncedPermissions = new ArraySet<>();
        renouncedPermissions.add(ACCESS_FINE_LOCATION);

        switch (scenario) {
            case RENOUNCE:
                return SystemUtil.callWithShellPermissionIdentity(() ->
                        context.createContext(
                                new ContextParams.Builder()
                                        .setRenouncedPermissions(renouncedPermissions)
                                        .setAttributionTag(context.getAttributionTag())
                                        .build())
                );
            case RENOUNCE_MIDDLE:
                AttributionSource nextAttrib = new AttributionSource(
                        Process.SHELL_UID, ""com.android.shell"", null, (Set<String>) null, null);
                return SystemUtil.callWithShellPermissionIdentity(() ->
                        context.createContext(
                                new ContextParams.Builder()
                                        .setRenouncedPermissions(renouncedPermissions)
                                        .setAttributionTag(context.getAttributionTag())
                                        .setNextAttributionSource(nextAttrib)
                                        .build())
                );
            case RENOUNCE_END:
                nextAttrib = new AttributionSource(
                        Process.SHELL_UID, ""com.android.shell"", null, renouncedPermissions, null);
                return SystemUtil.callWithShellPermissionIdentity(() ->
                        context.createContext(
                                new ContextParams.Builder()
                                        .setAttributionTag(context.getAttributionTag())
                                        .setNextAttributionSource(nextAttrib)
                                        .build())
                );
            default:
                throw new IllegalStateException();
        }
    }


    private boolean supportsBluetooth() {
        return mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH);
    }

    private void enableTestMode() {
        runShellCommandOrThrow(""dumpsys activity service""
                + "" com.android.bluetooth/.btservice.AdapterService set-test-mode enabled"");
    }

    private void disableTestMode() {
        runShellCommandOrThrow(""dumpsys activity service""
                + "" com.android.bluetooth/.btservice.AdapterService set-test-mode disabled"");
    }

}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.app.cts.DownloadManagerTest"	"testDownload_mediaScanned"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/DownloadManagerTest.java"	""	"public void testDownload_mediaScanned() throws Exception {
        final String[] destinations = {
                Environment.DIRECTORY_MUSIC,
                Environment.DIRECTORY_DOWNLOADS,
        };
        final String[] subPaths = {
                ""testmp3.mp3"",
                ""testvideo.3gp"",
        };
        final Pair<String, String>[] expectedMediaAttributes = new Pair[] {
                Pair.create(MediaStore.Audio.AudioColumns.IS_MUSIC, ""1""),
                Pair.create(MediaStore.Video.VideoColumns.DURATION, ""11047""),
        };

        for (int i = 0; i < destinations.length; ++i) {
            final String destination = destinations[i];
            final String subPath = subPaths[i];

            final DownloadCompleteReceiver receiver = new DownloadCompleteReceiver();
            try {
                IntentFilter intentFilter = new IntentFilter(
                        DownloadManager.ACTION_DOWNLOAD_COMPLETE);
                mContext.registerReceiver(receiver, intentFilter);

                DownloadManager.Request requestPublic = new DownloadManager.Request(
                        getAssetUrl(subPath));
                requestPublic.setDestinationInExternalPublicDir(destination, subPath);
                long id = mDownloadManager.enqueue(requestPublic);

                int allDownloads = getTotalNumberDownloads();
                assertEquals(1, allDownloads);

                int countBeforeDownload = getExternalVolumeMediaStoreFilesCount();
                receiver.waitForDownloadComplete(SHORT_TIMEOUT, id);
                assertSuccessfulDownload(id, new File(
                        Environment.getExternalStoragePublicDirectory(destination), subPath));

                int countAfterDownload = getExternalVolumeMediaStoreFilesCount();
                // Asserts that only one row entry is added for 1 download
                assertEquals((countBeforeDownload + 1), countAfterDownload);
                final Uri downloadUri = mDownloadManager.getUriForDownloadedFile(id);
                mContext.grantUriPermission(""com.android.shell"", downloadUri,
                        Intent.FLAG_GRANT_READ_URI_PERMISSION);
                final Uri mediaStoreUri = getMediaStoreUri(downloadUri);
                assertEquals(expectedMediaAttributes[i].second,
                        getMediaStoreColumnValue(mediaStoreUri, expectedMediaAttributes[i].first));
                final int expectedSize = getTotalBytes(
                        mContext.getContentResolver().openInputStream(downloadUri));
                assertEquals(expectedSize, Integer.parseInt(getMediaStoreColumnValue(
                        mediaStoreUri, MediaStore.MediaColumns.SIZE)));

                assertRemoveDownload(id, 0);
            } finally {
                mContext.unregisterReceiver(receiver);
            }
        }
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.app.cts.DownloadManagerTest"	"testDownload_onMediaStoreDownloadsDeleted"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/DownloadManagerTest.java"	""	"public void testDownload_onMediaStoreDownloadsDeleted() throws Exception {
        // prepare file
        File file = new File(Environment.getExternalStoragePublicDirectory(
                Environment.DIRECTORY_DOWNLOADS), ""cts"" + System.nanoTime() + "".mp3"");
        try {
            stageFile(""testmp3.mp3"", file);
            Uri mediaStoreUri = MediaStore.scanFile(mContext.getContentResolver(), file);

            // setup for activity
            GetResultActivity activity = setUpForActivity();

            // call activity as we want uri permission grant on DownloadStorageProvider Uri
            final Intent intent = new Intent();
            intent.setAction(Intent.ACTION_OPEN_DOCUMENT);
            intent.addCategory(Intent.CATEGORY_OPENABLE);
            intent.setType(""*/*"");
            Uri rootUri = DocumentsContract.buildRootUri(DOWNLOAD_STORAGE_PROVIDER_AUTHORITY,
                    ""downloads"");
            intent.putExtra(DocumentsContract.EXTRA_INITIAL_URI, rootUri);
            activity.startActivityForResult(intent, REQUEST_CODE);
            mDevice.waitForIdle();

            findDocument(file.getName()).click();
            final GetResultActivity.Result result = activity.getResult();
            final Uri uri = result.data.getData();

            assertTrue(PERMISSION_GRANTED == checkUriPermission(uri));

            // onMediaStoreDownloadsDeleted API is called on MediaProvider#delete()
            // for download files. This API revokes grants on DownloadStorageProvider granted Uris
            LongSparseArray<String> lpa = new LongSparseArray<String>();
            final long mediaStoreId = Long.parseLong(getMediaStoreColumnValue(mediaStoreUri,
                    MediaStore.Files.FileColumns._ID));
            final String mimeType = getMediaStoreColumnValue(mediaStoreUri,
                    MediaStore.Files.FileColumns.MIME_TYPE);
            lpa.put(mediaStoreId, mimeType);
            // This API is permission protected
            mInstrumentation.getUiAutomation().adoptShellPermissionIdentity(WRITE_MEDIA_STORAGE);
            try {
                mDownloadManager.onMediaStoreDownloadsDeleted(lpa);
            } finally {
                mInstrumentation.getUiAutomation().dropShellPermissionIdentity();
            }

            assertTrue(PERMISSION_DENIED == checkUriPermission(uri));
        } finally {
            file.delete();
        }
    }

    private GetResultActivity setUpForActivity() {
        final PackageManager pm = mContext.getPackageManager();
        final Intent intent = new Intent(Intent.ACTION_OPEN_DOCUMENT);
        intent.addCategory(Intent.CATEGORY_OPENABLE);
        intent.setType(""*/*"");
        final ResolveInfo ri = pm.resolveActivity(intent, 0);
        mDocumentsUiPackageId = ri.activityInfo.packageName;

        final Intent intent2 = new Intent(mContext, GetResultActivity.class);
        intent2.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        GetResultActivity activity = (GetResultActivity) mInstrumentation.startActivitySync(
                intent2);
        mInstrumentation.waitForIdleSync();
        activity.clearResult();
        return activity;
    }

    private int checkUriPermission(Uri uri) {
        return mContext.checkUriPermission(uri, android.os.Process.myPid(),
                android.os.Process.myUid(), Intent.FLAG_GRANT_READ_URI_PERMISSION);
    }

    private UiObject findDocument(String label) throws UiObjectNotFoundException {
        final UiSelector docList = new UiSelector().resourceId(getDocumentsUiPackageId()
                + "":id/dir_list"");

        // Wait for the first list item to appear
        assertTrue(""First list item"",
                new UiObject(docList.childSelector(new UiSelector()))
                        .waitForExists(LONG_TIMEOUT));

        try {
            //Enforce to set the list mode
            //Because UiScrollable can't reach the real bottom (when WEB_LINKABLE_FILE item)
            // in grid mode when screen landscape mode
            new UiObject(new UiSelector().resourceId(getDocumentsUiPackageId()
                    + "":id/sub_menu_list"")).click();
            mDevice.waitForIdle();
        } catch (UiObjectNotFoundException e) {
            //do nothing, already be in list mode.
        }

        // Repeat swipe gesture to find our item
        // (UiScrollable#scrollIntoView does not seem to work well with SwipeRefreshLayout)
        UiObject targetObject = new UiObject(docList.childSelector(new UiSelector().text(label)));
        UiObject saveButton = findSaveButton();
        int stepLimit = 10;
        while (stepLimit-- > 0) {
            if (targetObject.exists()) {
                boolean targetObjectFullyVisible = !saveButton.exists()
                        || targetObject.getVisibleBounds().bottom
                        <= saveButton.getVisibleBounds().top;
                if (targetObjectFullyVisible) {
                    break;
                }
            }

            mDevice.swipe(/* startX= */ mDevice.getDisplayWidth() / 2,
                    /* startY= */ mDevice.getDisplayHeight() / 2,
                    /* endX= */ mDevice.getDisplayWidth() / 2,
                    /* endY= */ 0,
                    /* steps= */ 40);
        }
        return targetObject;
    }

    private UiObject findSaveButton() throws UiObjectNotFoundException {
        return new UiObject(new UiSelector().resourceId(
                getDocumentsUiPackageId() + "":id/container_save"")
                .childSelector(new UiSelector().resourceId(""android:id/button1"")));
    }

    private String getDocumentsUiPackageId() {
        return mDocumentsUiPackageId;
    }

    private File stageFile(String resId, File file) throws IOException {
        // The caller may be trying to stage into a location only available to
        // the shell user, so we need to perform the entire copy as the shell
        final File dir = file.getParentFile();
        dir.mkdirs();
        if (!dir.exists()) {
            throw new FileNotFoundException(""Failed to create parent for "" + file);
        }
        try (InputStream source = mContext.getAssets().open(resId);
             OutputStream target = new FileOutputStream(file)) {
            FileUtils.copy(source, target);
        }
        return file;
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.mediadrm.cts.Utils"	"isEmpty"	"CtsMediaDrmTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/mediadrm/src/android/mediadrm/cts/Utils.java"	""	"public void test/*
 *.
 */

package android.mediadrm.cts;

import android.app.Instrumentation;
import android.app.NotificationManager;
import android.app.UiAutomation;
import android.content.Context;
import android.media.AudioManager;
import android.media.AudioPlaybackConfiguration;
import android.media.MediaPlayer;
import android.media.session.MediaSessionManager.RemoteUserInfo;
import android.net.Uri;
import android.os.Bundle;
import android.os.Handler;
import android.os.HandlerThread;
import android.os.ParcelFileDescriptor;
import android.platform.test.annotations.AppModeFull;
import android.util.Log;
import androidx.test.platform.app.InstrumentationRegistry;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.List;
import java.util.Scanner;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

import junit.framework.Assert;

public class Utils {
    private static final String TAG = ""CtsMediaTestUtil"";
    private static final int TEST_TIMING_TOLERANCE_MS = 500;
    private static final String MEDIA_PATH_INSTR_ARG_KEY = ""media-path"";

    public static void enableAppOps(String packageName, String operation,
            Instrumentation instrumentation) {
        setAppOps(packageName, operation, instrumentation, true);
    }

    public static void disableAppOps(String packageName, String operation,
            Instrumentation instrumentation) {
        setAppOps(packageName, operation, instrumentation, false);
    }

    public static String convertStreamToString(InputStream is) {
        try (Scanner scanner = new Scanner(is).useDelimiter(""\\A"")) {
            return scanner.hasNext() ? scanner.next() : """";
        }
    }

    public static String getMediaPath() {
        Bundle bundle = InstrumentationRegistry.getArguments();
        String mediaPath = bundle.getString(MEDIA_PATH_INSTR_ARG_KEY);
        Log.i(TAG, ""Media Path value is: "" + mediaPath);

        if (mediaPath != null && !mediaPath.isEmpty()) {
            if (mediaPath.startsWith(""http"") || mediaPath.startsWith(""file"")) {
                return mediaPath;
            }
            // Otherwise, assume a file path that is not already Uri formatted
            return Uri.fromFile(new File(mediaPath)).toString();
        }
        return ""https://storage.googleapis.com/wvmedia"";
    }

    private static void setAppOps(String packageName, String operation,
            Instrumentation instrumentation, boolean enable) {
        StringBuilder cmd = new StringBuilder();
        cmd.append(""appops set "");
        cmd.append(packageName);
        cmd.append("" "");
        cmd.append(operation);
        cmd.append(enable ? "" allow"" : "" deny"");
        instrumentation.getUiAutomation().executeShellCommand(cmd.toString());

        StringBuilder query = new StringBuilder();
        query.append(""appops get "");
        query.append(packageName);
        query.append("" "");
        query.append(operation);
        String queryStr = query.toString();

        String expectedResult = enable ? ""allow"" : ""deny"";
        String result = """";
        while(!result.contains(expectedResult)) {
            ParcelFileDescriptor pfd = instrumentation.getUiAutomation().executeShellCommand(
                                                            queryStr);
            InputStream inputStream = new FileInputStream(pfd.getFileDescriptor());
            result = convertStreamToString(inputStream);
        }
    }

    protected static void toggleNotificationPolicyAccess(String packageName,
            Instrumentation instrumentation, boolean on) throws IOException {

        String command = "" cmd notification "" + (on ? ""allow_dnd "" : ""disallow_dnd "") + packageName;

        // Get permission to enable accessibility
        UiAutomation uiAutomation = instrumentation.getUiAutomation();
        // Execute command
        try (ParcelFileDescriptor fd = uiAutomation.executeShellCommand(command)) {
            Assert.assertNotNull(""Failed to execute shell command: "" + command, fd);
            // Wait for the command to finish by reading until EOF
            try (InputStream in = new FileInputStream(fd.getFileDescriptor())) {
                byte[] buffer = new byte[4096];
                while (in.read(buffer) > 0) {}
            } catch (IOException e) {
                throw new IOException(""Could not read stdout of command: "" + command, e);
            }
        } finally {
            uiAutomation.destroy();
        }

        NotificationManager nm = (NotificationManager) instrumentation.getContext()
                .getSystemService(Context.NOTIFICATION_SERVICE);
        Assert.assertEquals(""Wrote setting should be the same as the read one"", on,
                nm.isNotificationPolicyAccessGranted());
    }

    static boolean compareRemoteUserInfo(RemoteUserInfo a, RemoteUserInfo b) {
        if (a == null && b == null) {
            return true;
        } else if (a == null || b == null) {
            return false;
        }
        return a.getPackageName().equals(b.getPackageName())
                && a.getPid() == b.getPid()
                && a.getUid() == b.getUid();
    }

    /**
     * Assert that a media playback is started and an active {@link AudioPlaybackConfiguration}
     * is created once. The playback will be stopped immediately after that.
     * <p>For a media session to receive media button events, an actual playback is needed.
     */
    @AppModeFull(reason = ""Instant apps cannot access the SD card"")
    static void assertMediaPlaybackStarted(Context context) {
        final AudioManager am = new AudioManager(context);
        final HandlerThread handlerThread = new HandlerThread(TAG);
        handlerThread.start();
        final TestAudioPlaybackCallback callback = new TestAudioPlaybackCallback();
        MediaPlayer mediaPlayer = null;
        final String mInpPrefix = WorkDir.getMediaDirString();

        try {
            final int activeConfigSizeBeforeStart = am.getActivePlaybackConfigurations().size();
            final Handler handler = new Handler(handlerThread.getLooper());

            am.registerAudioPlaybackCallback(callback, handler);
            File testAudioFile = new File(mInpPrefix + ""sine1khzm40db.wav"");
            Assert.assertTrue(""Test audio file does not exist! path=""
                            + testAudioFile.getAbsolutePath(), testAudioFile.exists());
            mediaPlayer = MediaPlayer.create(context, Uri.fromFile(testAudioFile));
            mediaPlayer.start();
            if (!callback.mCountDownLatch.await(TEST_TIMING_TOLERANCE_MS, TimeUnit.MILLISECONDS)
                    || callback.mActiveConfigSize != activeConfigSizeBeforeStart + 1) {
                Assert.fail(""Failed to create an active AudioPlaybackConfiguration"");
            }
        } catch (InterruptedException e) {
            Assert.fail(""Failed to create an active AudioPlaybackConfiguration"");
        } finally {
            am.unregisterAudioPlaybackCallback(callback);
            if (mediaPlayer != null) {
                mediaPlayer.stop();
                mediaPlayer.release();
                mediaPlayer = null;
            }
            handlerThread.quitSafely();
        }
    }

    private static class TestAudioPlaybackCallback extends AudioManager.AudioPlaybackCallback {
        private final CountDownLatch mCountDownLatch = new CountDownLatch(1);
        private int mActiveConfigSize;

        @Override
        public void onPlaybackConfigChanged(List<AudioPlaybackConfiguration> configs) {
            // For non-framework apps, only anonymized active AudioPlaybackCallbacks will be
            // notified.
            mActiveConfigSize = configs.size();
            mCountDownLatch.countDown();
        }
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.abioverride.cts.AbiOverrideTest"	"testAbiIs32bit"	"CtsAbiOverrideHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/abioverride/src/android/abioverride/cts/AbiOverrideTest.java"	""	"public void testAbiIs32bit() throws Exception {
        ITestDevice device = getDevice();
        //skip this test for 64bit only system
        String prop32bit = device.getProperty(""ro.product.cpu.abilist32"");
        if (prop32bit == null || prop32bit.trim().isEmpty()){
            return;
        }
        // Clear logcat.
        device.executeAdbCommand(""logcat"", ""-c"");
        // Start the APK and wait for it to complete.
        device.executeShellCommand(START_COMMAND);
        // Dump logcat
        String logs = device.executeAdbCommand(""logcat"", ""-v"", ""brief"", ""-d"", CLASS + "":I"", ""*:S"");
        // Search for string.
        String testString = """";
        Scanner in = new Scanner(logs);
        while (in.hasNextLine()) {
            String line = in.nextLine();
            if(line.startsWith(""I/""+CLASS)) {
                testString = line.split("":"")[1].trim();
            }
        }
        in.close();
        // Verify that TEST_STRING is actually found in logs.
        assertTrue(""No result found in logs"", testString.startsWith(TEST_STRING));
        // Assert that the result is false
        assertEquals(""Incorrect abi"", TEST_STRING + ""false"", testString);
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.appsecurity.cts.listeningports.ListeningPortsTest"	"testNoAccessibleListeningPorts"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/ListeningPortsApp/src/android/appsecurity/cts/listeningports/ListeningPortsTest.java"	""	"public void testNoAccessibleListeningPorts() throws Exception {
        final Bundle testArgs = InstrumentationRegistry.getArguments();
        final String procFileContents = testArgs.getString(PROC_FILE_CONTENTS_PARAM);
        final boolean isTcp = Boolean.valueOf(testArgs.getString(IS_TCP_PARAM));
        final boolean loopback = Boolean.valueOf(testArgs.getString(LOOPBACK_PARAM));

        String errors = """";
        List<ParsedProcEntry> entries = ParsedProcEntry.parse(procFileContents);
        for (ParsedProcEntry entry : entries) {
            String addrPort = entry.localAddress.getHostAddress() + ':' + entry.port;
            String addrUid = entry.localAddress.getHostAddress() + ' ' + entry.uid;
            String addrPortUid = addrPort + ' ' + entry.uid;

            if (isPortListening(entry.state, isTcp)
                    && !(isException(addrPort) || isException(addrUid) || isException(addrPortUid))
                    && (!entry.localAddress.isLoopbackAddress() ^ loopback)) {
                if (isTcp && !isTcpConnectable(entry.localAddress, entry.port)) {
                    continue;
                }
                // allow non-system processes to listen
                int appId = UserHandle.getAppId(entry.uid);
                if (appId >= Process.FIRST_APPLICATION_UID
                        && appId <= Process.LAST_APPLICATION_UID) {
                    continue;
                }
                errors += ""\nFound port listening on addr=""
                        + entry.localAddress.getHostAddress() + "", port=""
                        + entry.port + "", UID="" + entry.uid
                        + "" "" + uidToPackage(entry.uid);
            }
        }
        if (!errors.equals("""")) {
            throw new ListeningPortsAssertionError(errors);
        }
    }

    private String uidToPackage(int uid) {
        PackageManager pm = this.getContext().getPackageManager();
        String[] packages = pm.getPackagesForUid(uid);
        if (packages == null) {
            return ""[unknown]"";
        }
        return Arrays.asList(packages).toString();
    }

    private boolean isTcpConnectable(InetAddress address, int port) {
        Socket socket = new Socket();

        try {
            if (Log.isLoggable(TAG, Log.DEBUG)) {
                Log.d(TAG, ""Trying to connect "" + address + "":"" + port);
            }
            socket.connect(new InetSocketAddress(address, port), CONN_TIMEOUT_IN_MS);
        } catch (IOException ioe) {
            if (Log.isLoggable(TAG, Log.DEBUG)) {
                Log.d(TAG, ""Unable to connect:"" + ioe);
            }
            return false;
        } finally {
            try {
                socket.close();
            } catch (IOException closeError) {
                Log.e(TAG, ""Unable to close socket: "" + closeError);
            }
        }

        if (Log.isLoggable(TAG, Log.DEBUG)) {
            Log.d(TAG, address + "":"" + port + "" is connectable."");
        }
        return true;
    }

    private static boolean isException(String localAddress) {
        return isPatternMatch(EXCEPTION_PATTERNS, localAddress);
    }

    private static boolean isPatternMatch(List<String> patterns, String input) {
        for (String pattern : patterns) {
            pattern = Pattern.quote(pattern);
            if (Pattern.matches(pattern, input)) {
                return true;
            }
        }
        return false;
    }

    private static boolean isPortListening(String state, boolean isTcp) {
        // 0A = TCP_LISTEN from include/net/tcp_states.h
        String listeningState = isTcp ? ""0A"" : ""07"";
        return listeningState.equals(state);
    }

    private static class ListeningPortsAssertionError extends AssertionFailedError {
        private ListeningPortsAssertionError(String msg) {
            super(msg);
        }
    }

    private static class ParsedProcEntry {
        private final InetAddress localAddress;
        private final int port;
        private final String state;
        private final int uid;

        private ParsedProcEntry(InetAddress addr, int port, String state, int uid) {
            this.localAddress = addr;
            this.port = port;
            this.state = state;
            this.uid = uid;
        }


        private static List<ParsedProcEntry> parse(String procFileContents) throws IOException {

            List<ParsedProcEntry> retval = new ArrayList<ParsedProcEntry>();
            /*
            * Sample output of ""cat /proc/net/tcp"" on emulator:
            *
            * sl  local_address rem_address   st tx_queue rx_queue tr tm->when retrnsmt   uid  ...
            * 0: 0100007F:13AD 00000000:0000 0A 00000000:00000000 00:00000000 00000000     0   ...
            * 1: 00000000:15B3 00000000:0000 0A 00000000:00000000 00:00000000 00000000     0   ...
            * 2: 0F02000A:15B3 0202000A:CE8A 01 00000000:00000000 00:00000000 00000000     0   ...
            *
            */

            Scanner scanner = null;
            try {
                scanner = new Scanner(procFileContents);
                while (scanner.hasNextLine()) {
                    String line = scanner.nextLine().trim();

                    // Skip column headers
                    if (line.startsWith(""sl"")) {
                        continue;
                    }

                    String[] fields = line.split(""\\s+"");
                    final int expectedNumColumns = 12;
                    assertTrue(line + "" should have at least "" + expectedNumColumns
                            + "" columns of output "" + Arrays.toString(fields),
                            fields.length >= expectedNumColumns);

                    String state = fields[3];
                    int uid = Integer.parseInt(fields[7]);
                    InetAddress localIp = addrToInet(fields[1].split("":"")[0]);
                    int localPort = Integer.parseInt(fields[1].split("":"")[1], 16);

                    retval.add(new ParsedProcEntry(localIp, localPort, state, uid));
                }
            } finally {
                if (scanner != null) {
                    scanner.close();
                }
            }
            return retval;
        }

        /**
         * Convert a string stored in little endian format to an IP address.
         */
        private static InetAddress addrToInet(String s) throws UnknownHostException {
            int len = s.length();
            if (len != 8 && len != 32) {
                throw new IllegalArgumentException(len + """");
            }
            byte[] retval = new byte[len / 2];

            for (int i = 0; i < len / 2; i += 4) {
                retval[i] = (byte) ((Character.digit(s.charAt(2*i + 6), 16) << 4)
                        + Character.digit(s.charAt(2*i + 7), 16));
                retval[i + 1] = (byte) ((Character.digit(s.charAt(2*i + 4), 16) << 4)
                        + Character.digit(s.charAt(2*i + 5), 16));
                retval[i + 2] = (byte) ((Character.digit(s.charAt(2*i + 2), 16) << 4)
                        + Character.digit(s.charAt(2*i + 3), 16));
                retval[i + 3] = (byte) ((Character.digit(s.charAt(2*i), 16) << 4)
                        + Character.digit(s.charAt(2*i + 1), 16));
            }
            return InetAddress.getByAddress(retval);
        }
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiBackupRestoreTest"	"isNotNull"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiBackupRestoreTest.java"	""	"/*
 *.
 */

package android.net.wifi.cts;

import static android.content.pm.PackageManager.PERMISSION_GRANTED;
import static android.net.wifi.WifiConfiguration.METERED_OVERRIDE_METERED;
import static android.net.wifi.WifiConfiguration.METERED_OVERRIDE_NONE;
import static android.net.wifi.WifiConfiguration.METERED_OVERRIDE_NOT_METERED;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import static org.junit.Assume.assumeTrue;

import android.app.UiAutomation;
import android.content.Context;
import android.net.IpConfiguration;
import android.net.LinkAddress;
import android.net.ProxyInfo;
import android.net.StaticIpConfiguration;
import android.net.Uri;
import android.net.wifi.SoftApConfiguration;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiEnterpriseConfig;
import android.net.wifi.WifiManager;
import android.platform.test.annotations.AppModeFull;
import android.support.test.uiautomator.UiDevice;
import android.util.Log;

import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.filters.SmallTest;
import androidx.test.platform.app.InstrumentationRegistry;

import com.android.compatibility.common.util.PollingCheck;
import com.android.compatibility.common.util.ShellIdentityUtils;
import com.android.compatibility.common.util.SystemUtil;
import com.android.compatibility.common.util.ThrowingRunnable;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.io.DataInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * Tests for wifi backup/restore functionality.
 */
@AppModeFull(reason = ""Cannot get WifiManager in instant app mode"")
@SmallTest
@RunWith(AndroidJUnit4.class)
public class WifiBackupRestoreTest extends WifiJUnit4TestBase {
    private static final String TAG = ""WifiBackupRestoreTest"";
    private static final String LEGACY_SUPP_CONF_FILE =
            ""assets/BackupLegacyFormatSupplicantConf.txt"";
    private static final String LEGACY_IP_CONF_FILE =
            ""assets/BackupLegacyFormatIpConf.txt"";
    private static final String V1_0_FILE = ""assets/BackupV1.0Format.xml"";
    private static final String V1_1_FILE = ""assets/BackupV1.1Format.xml"";
    private static final String V1_2_FILE = ""assets/BackupV1.2Format.xml"";

    public static final String EXPECTED_LEGACY_STATIC_IP_LINK_ADDRESS = ""192.168.48.2"";
    public static final int EXPECTED_LEGACY_STATIC_IP_LINK_PREFIX_LENGTH = 8;
    public static final String EXPECTED_LEGACY_STATIC_IP_GATEWAY_ADDRESS = ""192.168.48.1"";
    public static final String[] EXPECTED_LEGACY_STATIC_IP_DNS_SERVER_ADDRESSES =
            new String[]{""192.168.48.1"", ""192.168.48.10""};
    public static final String EXPECTED_LEGACY_STATIC_PROXY_HOST = ""192.168.48.1"";
    public static final int EXPECTED_LEGACY_STATIC_PROXY_PORT = 8000;
    public static final String EXPECTED_LEGACY_STATIC_PROXY_EXCLUSION_LIST = """";
    public static final String EXPECTED_LEGACY_PAC_PROXY_LOCATION = ""http://"";

    private Context mContext;
    private WifiManager mWifiManager;
    private UiDevice mUiDevice;
    private boolean mWasVerboseLoggingEnabled;

    private static final int DURATION = 10_000;
    private static final int DURATION_SCREEN_TOGGLE = 2000;

    @Before
    public void setUp() throws Exception {
        mContext = InstrumentationRegistry.getInstrumentation().getContext();
        // skip the test if WiFi is not supported
        assumeTrue(WifiFeature.isWifiSupported(mContext));

        mWifiManager = mContext.getSystemService(WifiManager.class);
        assertThat(mWifiManager).isNotNull();

        // turn on verbose logging for tests
        mWasVerboseLoggingEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.isVerboseLoggingEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setVerboseLoggingEnabled(true));
        // Disable scan throttling for tests.
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setScanThrottleEnabled(false));

        if (!mWifiManager.isWifiEnabled()) setWifiEnabled(true);
        mUiDevice = UiDevice.getInstance(InstrumentationRegistry.getInstrumentation());
        turnScreenOn();
        PollingCheck.check(""Wifi not enabled"", DURATION, () -> mWifiManager.isWifiEnabled());

        List<WifiConfiguration> savedNetworks = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.getPrivilegedConfiguredNetworks());
        assertWithMessage(""Need at least one saved network"").that(savedNetworks).isNotEmpty();
    }

    @After
    public void tearDown() throws Exception {
        if (!WifiFeature.isWifiSupported(mContext)) return;
        if (!mWifiManager.isWifiEnabled()) setWifiEnabled(true);
        turnScreenOff();
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setVerboseLoggingEnabled(mWasVerboseLoggingEnabled));
    }

    private void setWifiEnabled(boolean enable) throws Exception {
        // now trigger the change using shell commands.
        SystemUtil.runShellCommand(""svc wifi "" + (enable ? ""enable"" : ""disable""));
    }

    private void turnScreenOn() throws Exception {
        mUiDevice.executeShellCommand(""input keyevent KEYCODE_WAKEUP"");
        mUiDevice.executeShellCommand(""wm dismiss-keyguard"");
        // Since the screen on/off intent is ordered, they will not be sent right now.
        Thread.sleep(DURATION_SCREEN_TOGGLE);
    }

    private void turnScreenOff() throws Exception {
        mUiDevice.executeShellCommand(""input keyevent KEYCODE_SLEEP"");
        // Since the screen on/off intent is ordered, they will not be sent right now.
        Thread.sleep(DURATION_SCREEN_TOGGLE);
    }

    private void flipMeteredOverride(WifiConfiguration network) {
        if (network.meteredOverride == METERED_OVERRIDE_NONE) {
            network.meteredOverride = METERED_OVERRIDE_METERED;
        } else if (network.meteredOverride == METERED_OVERRIDE_METERED) {
            network.meteredOverride = METERED_OVERRIDE_NOT_METERED;
        } else if (network.meteredOverride == METERED_OVERRIDE_NOT_METERED) {
            network.meteredOverride = METERED_OVERRIDE_NONE;
        }
    }

    /** WifiConfiguration#isEnterprise() is @hide, so copy/paste partial implementation here. */
    private static boolean isEnterprise(WifiConfiguration config) {
        WifiEnterpriseConfig enterpriseConfig = config.enterpriseConfig;
        return enterpriseConfig != null
                && enterpriseConfig.getEapMethod() != WifiEnterpriseConfig.Eap.NONE;
    }

    /**
     * Tests for {@link WifiManager#retrieveBackupData()} &
     * {@link WifiManager#restoreBackupData(byte[])}
     * Note: If the network was not created by an app with OVERRIDE_WIFI_CONFIG permission (held
     * by AOSP settings app for example), then the backup data will not contain that network. If
     * the device does not contain any such pre-existing saved network, then this test will be
     * a no-op, will only ensure that the device does not crash when invoking the API's.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.provider.cts.media.MediaStore_Images_MediaTest"	"testUpdateAndReplace"	"CtsProviderTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/provider/src/android/provider/cts/media/MediaStore_Images_MediaTest.java"	""	"public void testUpdateAndReplace() throws Exception {
        File dir = mContext.getSystemService(StorageManager.class)
                .getStorageVolume(mExternalFiles).getDirectory();
        File dcimDir = new File(dir, Environment.DIRECTORY_DCIM);
        File file = null;
        try {
            // Create file
            file = copyResourceToFile(R.raw.scenery, dcimDir, ""cts"" + System.nanoTime() + "".jpg"");
            final String externalPath = file.getAbsolutePath();
            assertNotNull(MediaStore.scanFile(mContentResolver, file));

            // Insert another file, insertedFile doesn't exist in lower file system.
            ContentValues values = new ContentValues();
            final File insertedFile = new File(dcimDir, ""cts"" + System.nanoTime() + "".jpg"");
            values.put(Media.DATA, insertedFile.getAbsolutePath());

            final Uri uri = mContentResolver.insert(mExternalImages, values);
            assertNotNull(uri);

            // Now update the second file to the same file path as the first file.
            values.put(Media.DATA, externalPath);
            // This update is implemented as update and replace on conflict and shouldn't throw
            // UNIQUE constraint error.
            assertEquals(1, mContentResolver.update(uri, values, Bundle.EMPTY));
            Uri scannedUri = MediaStore.scanFile(mContentResolver, file);
            assertNotNull(scannedUri);

            // _id in inserted uri and scannedUri should be same.
            assertEquals(uri.getLastPathSegment(), scannedUri.getLastPathSegment());
        } finally {
            if (file != null) {
                file.delete();
            }
        }
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.provider.cts.media.MediaStore_Images_MediaTest"	"testUpsert"	"CtsProviderTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/provider/src/android/provider/cts/media/MediaStore_Images_MediaTest.java"	""	"public void testUpsert() throws Exception {
        File dir = mContext.getSystemService(StorageManager.class)
                .getStorageVolume(mExternalFiles).getDirectory();
        File dcimDir = new File(dir, Environment.DIRECTORY_DCIM);
        File file = null;
        try {
            // Create file
            file = copyResourceToFile(R.raw.scenery, dcimDir, ""cts"" + System.nanoTime() + "".jpg"");
            final String externalPath = file.getAbsolutePath();

            // Verify a record exists in MediaProvider.
            final Uri scannedUri = MediaStore.scanFile(mContentResolver, file);
            assertNotNull(scannedUri);

            // Now insert via ContentResolver and verify it works.
            ContentValues values = new ContentValues();
            values.put(Media.DATA, externalPath);

            // This insert is really an upsert. It should work.
            final Uri uri = mContentResolver.insert(mExternalImages, values);
            assertNotNull(uri);
            // insert was an upsert, _id in uri and scannedUri should be same.
            assertEquals(uri.getLastPathSegment(), scannedUri.getLastPathSegment());
        } finally {
            if (file != null) {
                file.delete();
            }
        }
    }

    private File copyResourceToFile(int sourceResId, File destinationDir,
            String destinationFileName) throws Exception {
        final File file = new File(destinationDir, destinationFileName);
        file.createNewFile();

        try (InputStream source = InstrumentationRegistry.getTargetContext().getResources()
                .openRawResource(sourceResId);
             OutputStream target = new FileOutputStream(file)) {
            FileUtils.copy(source, target);
        }
        return file;
    }

    private void assertInsertionSuccess(String stringUrl) throws IOException {
        final Uri uri = Uri.parse(stringUrl);

        // check whether the thumbnails are generated
        try (Cursor c = mContentResolver.query(uri, null, null, null)) {
            assertEquals(1, c.getCount());
        }

        assertNotNull(mContentResolver.loadThumbnail(uri, new Size(512, 384), null));
        assertNotNull(mContentResolver.loadThumbnail(uri, new Size(96, 96), null));
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.provider.cts.media.MediaStore_Images_MediaTest"	"testCanonicalize"	"CtsProviderTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/provider/src/android/provider/cts/media/MediaStore_Images_MediaTest.java"	""	"public void testCanonicalize() throws Exception {
        // Remove all audio left over from other tests
        ProviderTestUtils.executeShellCommand(""content delete""
                + "" --user "" + InstrumentationRegistry.getTargetContext().getUserId()
                + "" --uri "" + mExternalImages,
                InstrumentationRegistry.getInstrumentation().getUiAutomation());

        // Publish some content
        final File dir = ProviderTestUtils.stageDir(mVolumeName);
        final Uri a = ProviderTestUtils.scanFileFromShell(
                ProviderTestUtils.stageFile(R.raw.scenery, new File(dir, ""a.jpg"")));
        final Uri b = ProviderTestUtils.scanFileFromShell(
                ProviderTestUtils.stageFile(R.raw.lg_g4_iso_800_jpg, new File(dir, ""b.jpg"")));
        final Uri c = ProviderTestUtils.scanFileFromShell(
                ProviderTestUtils.stageFile(R.raw.scenery, new File(dir, ""c.jpg"")));

        // Confirm we can canonicalize and recover it
        final Uri canonicalized = mContentResolver.canonicalize(b);
        assertNotNull(canonicalized);
        assertEquals(b, mContentResolver.uncanonicalize(canonicalized));

        // Delete all items above
        mContentResolver.delete(a, null, null);
        mContentResolver.delete(b, null, null);
        mContentResolver.delete(c, null, null);

        // Confirm canonical item isn't found
        assertNull(mContentResolver.uncanonicalize(canonicalized));

        // Publish data again and confirm we can recover it
        final Uri d = ProviderTestUtils.scanFileFromShell(
                ProviderTestUtils.stageFile(R.raw.lg_g4_iso_800_jpg, new File(dir, ""d.jpg"")));
        assertEquals(d, mContentResolver.uncanonicalize(canonicalized));
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.app.usage.cts.NetworkUsageStatsTest"	"getIsDefault"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/NetworkUsageStatsTest.java"	""	"public void test/**
 * Copyright (C) 2015 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License""); you may not
 * use this file except in compliance with the License. You may obtain a copy
 * of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */

package android.app.usage.cts;

import android.app.AppOpsManager;
import android.app.usage.NetworkStatsManager;
import android.app.usage.NetworkStats;
import android.content.Context;
import android.content.pm.PackageManager;
import android.net.ConnectivityManager;
import android.net.Network;
import android.net.NetworkCapabilities;
import android.net.NetworkInfo;
import android.net.NetworkRequest;
import android.net.TrafficStats;
import android.os.Handler;
import android.os.HandlerThread;
import android.os.ParcelFileDescriptor;
import android.os.Process;
import android.os.RemoteException;
import android.os.SystemClock;
import android.platform.test.annotations.AppModeFull;
import android.telephony.TelephonyManager;
import android.test.InstrumentationTestCase;
import android.util.Log;

import com.android.compatibility.common.util.ShellIdentityUtils;
import com.android.compatibility.common.util.SystemUtil;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.URL;
import java.net.UnknownHostException;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.Scanner;
import java.net.HttpURLConnection;

import libcore.io.IoUtils;
import libcore.io.Streams;

import static android.app.usage.NetworkStats.Bucket.DEFAULT_NETWORK_ALL;
import static android.app.usage.NetworkStats.Bucket.DEFAULT_NETWORK_NO;
import static android.app.usage.NetworkStats.Bucket.DEFAULT_NETWORK_YES;
import static android.app.usage.NetworkStats.Bucket.METERED_ALL;
import static android.app.usage.NetworkStats.Bucket.METERED_YES;
import static android.app.usage.NetworkStats.Bucket.METERED_NO;
import static android.app.usage.NetworkStats.Bucket.STATE_ALL;
import static android.app.usage.NetworkStats.Bucket.STATE_DEFAULT;
import static android.app.usage.NetworkStats.Bucket.STATE_FOREGROUND;
import static android.app.usage.NetworkStats.Bucket.TAG_NONE;
import static android.app.usage.NetworkStats.Bucket.UID_ALL;

public class NetworkUsageStatsTest extends InstrumentationTestCase {
    private static final String LOG_TAG = ""NetworkUsageStatsTest"";
    private static final String APPOPS_SET_SHELL_COMMAND = ""appops set {0} {1} {2}"";
    private static final String APPOPS_GET_SHELL_COMMAND = ""appops get {0} {1}"";

    private static final long MINUTE = 1000 * 60;
    private static final int TIMEOUT_MILLIS = 15000;

    private static final String CHECK_CONNECTIVITY_URL = ""http://www.265.com/"";
    private static final int HOST_RESOLUTION_RETRIES = 4;
    private static final int HOST_RESOLUTION_INTERVAL_MS = 500;

    private static final int NETWORK_TAG = 0xf00d;
    private static final long THRESHOLD_BYTES = 2 * 1024 * 1024;  // 2 MB

    private abstract class NetworkInterfaceToTest {
        private boolean mMetered;
        private boolean mIsDefault;

        abstract int getNetworkType();
        abstract int getTransportType();

        public boolean getMetered() {
            return mMetered;
        }

        public void setMetered(boolean metered) {
            this.mMetered = metered;
        }

        public boolean getIsDefault() {
            return mIsDefault;
        }

        public void setIsDefault(boolean isDefault) {
            mIsDefault = isDefault;
        }

        abstract String getSystemFeature();
        abstract String getErrorMessage();
    }

    private final NetworkInterfaceToTest[] mNetworkInterfacesToTest =
            new NetworkInterfaceToTest[] {
                    new NetworkInterfaceToTest() {
                        @Override
                        public int getNetworkType() {
                            return ConnectivityManager.TYPE_WIFI;
                        }

                        @Override
                        public int getTransportType() {
                            return NetworkCapabilities.TRANSPORT_WIFI;
                        }

                        @Override
                        public String getSystemFeature() {
                            return PackageManager.FEATURE_WIFI;
                        }

                        @Override
                        public String getErrorMessage() {
                            return "" Please make sure you are connected to a WiFi access point."";
                        }
                    },
                    new NetworkInterfaceToTest() {
                        @Override
                        public int getNetworkType() {
                            return ConnectivityManager.TYPE_MOBILE;
                        }

                        @Override
                        public int getTransportType() {
                            return NetworkCapabilities.TRANSPORT_CELLULAR;
                        }

                        @Override
                        public String getSystemFeature() {
                            return PackageManager.FEATURE_TELEPHONY;
                        }

                        @Override
                        public String getErrorMessage() {
                            return "" Please make sure you have added a SIM card with data plan to"" +
                                    "" your phone, have enabled data over cellular and in case of"" +
                                    "" dual SIM devices, have selected the right SIM "" +
                                    ""for data connection."";
                        }
                    }
    };

    private String mPkg;
    private NetworkStatsManager mNsm;
    private ConnectivityManager mCm;
    private PackageManager mPm;
    private long mStartTime;
    private long mEndTime;

    private long mBytesRead;
    private String mWriteSettingsMode;
    private String mUsageStatsMode;

    private void exerciseRemoteHost(Network network, URL url) throws Exception {
        NetworkInfo networkInfo = mCm.getNetworkInfo(network);
        if (networkInfo == null) {
            Log.w(LOG_TAG, ""Network info is null"");
        } else {
            Log.w(LOG_TAG, ""Network: "" + networkInfo.toString());
        }
        InputStreamReader in = null;
        HttpURLConnection urlc = null;
        String originalKeepAlive = System.getProperty(""http.keepAlive"");
        System.setProperty(""http.keepAlive"", ""false"");
        try {
            TrafficStats.setThreadStatsTag(NETWORK_TAG);
            urlc = (HttpURLConnection) network.openConnection(url);
            urlc.setConnectTimeout(TIMEOUT_MILLIS);
            urlc.setUseCaches(false);
            // Disable compression so we generate enough traffic that assertWithinPercentage will
            // not be affected by the small amount of traffic (5-10kB) sent by the test harness.
            urlc.setRequestProperty(""Accept-Encoding"", ""identity"");
            urlc.connect();
            boolean ping = urlc.getResponseCode() == 200;
            if (ping) {
                in = new InputStreamReader(
                        (InputStream) urlc.getContent());

                mBytesRead = 0;
                while (in.read() != -1) ++mBytesRead;
            }
        } catch (Exception e) {
            Log.i(LOG_TAG, ""Badness during exercising remote server: "" + e);
        } finally {
            TrafficStats.clearThreadStatsTag();
            if (in != null) {
                try {
                    in.close();
                } catch (IOException e) {
                    // don't care
                }
            }
            if (urlc != null) {
                urlc.disconnect();
            }
            if (originalKeepAlive == null) {
                System.clearProperty(""http.keepAlive"");
            } else {
                System.setProperty(""http.keepAlive"", originalKeepAlive);
            }
        }
    }

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        mNsm = (NetworkStatsManager) getInstrumentation().getContext()
                .getSystemService(Context.NETWORK_STATS_SERVICE);
        mNsm.setPollForce(true);

        mCm = (ConnectivityManager) getInstrumentation().getContext()
                .getSystemService(Context.CONNECTIVITY_SERVICE);

        mPm = getInstrumentation().getContext().getPackageManager();

        mPkg = getInstrumentation().getContext().getPackageName();

        mWriteSettingsMode = getAppOpsMode(AppOpsManager.OPSTR_WRITE_SETTINGS);
        setAppOpsMode(AppOpsManager.OPSTR_WRITE_SETTINGS, ""allow"");
        mUsageStatsMode = getAppOpsMode(AppOpsManager.OPSTR_GET_USAGE_STATS);
    }

    @Override
    protected void tearDown() throws Exception {
        if (mWriteSettingsMode != null) {
            setAppOpsMode(AppOpsManager.OPSTR_WRITE_SETTINGS, mWriteSettingsMode);
        }
        if (mUsageStatsMode != null) {
            setAppOpsMode(AppOpsManager.OPSTR_GET_USAGE_STATS, mUsageStatsMode);
        }
        super.tearDown();
    }

    private void setAppOpsMode(String appop, String mode) throws Exception {
        final String command = MessageFormat.format(APPOPS_SET_SHELL_COMMAND, mPkg, appop, mode);
        SystemUtil.runShellCommand(command);
    }

    private String getAppOpsMode(String appop) throws Exception {
        final String command = MessageFormat.format(APPOPS_GET_SHELL_COMMAND, mPkg, appop);
        String result = SystemUtil.runShellCommand(command);
        if (result == null) {
            Log.w(LOG_TAG, ""App op "" + appop + "" could not be read."");
        }
        return result;
    }

    private boolean isInForeground() throws IOException {
        String result = SystemUtil.runShellCommand(getInstrumentation(),
                ""cmd activity get-uid-state "" + Process.myUid());
        return result.contains(""FOREGROUND"");
    }

    private class NetworkCallback extends ConnectivityManager.NetworkCallback {
        private long mTolerance;
        private URL mUrl;
        public boolean success;
        public boolean metered;
        public boolean isDefault;

        NetworkCallback(long tolerance, URL url) {
            mTolerance = tolerance;
            mUrl = url;
            success = false;
            metered = false;
            isDefault = false;
        }

        // The test host only has IPv4. So on a dual-stack network where IPv6 connects before IPv4,
        // we need to wait until IPv4 is available or the test will spuriously fail.
        private void waitForHostResolution(Network network) {
            for (int i = 0; i < HOST_RESOLUTION_RETRIES; i++) {
                try {
                    network.getAllByName(mUrl.getHost());
                    return;
                } catch (UnknownHostException e) {
                    SystemClock.sleep(HOST_RESOLUTION_INTERVAL_MS);
                }
            }
            fail(String.format(""%s could not be resolved on network %s (%d attempts %dms apart)"",
                  mUrl.getHost(), network, HOST_RESOLUTION_RETRIES, HOST_RESOLUTION_INTERVAL_MS));
        }

        @Override
        public void onAvailable(Network network) {
            try {
                mStartTime = System.currentTimeMillis() - mTolerance;
                isDefault = network.equals(mCm.getActiveNetwork());
                waitForHostResolution(network);
                exerciseRemoteHost(network, mUrl);
                mEndTime = System.currentTimeMillis() + mTolerance;
                success = true;
                metered = !mCm.getNetworkCapabilities(network)
                        .hasCapability(NetworkCapabilities.NET_CAPABILITY_NOT_METERED);
                synchronized(NetworkUsageStatsTest.this) {
                    NetworkUsageStatsTest.this.notify();
                }
            } catch (Exception e) {
                Log.w(LOG_TAG, ""exercising remote host failed."", e);
                success = false;
            }
        }
    }

    private boolean shouldTestThisNetworkType(int networkTypeIndex, final long tolerance)
            throws Exception {
        boolean hasFeature = mPm.hasSystemFeature(
                mNetworkInterfacesToTest[networkTypeIndex].getSystemFeature());
        if (!hasFeature) {
            return false;
        }
        NetworkCallback callback = new NetworkCallback(tolerance, new URL(CHECK_CONNECTIVITY_URL));
        mCm.requestNetwork(new NetworkRequest.Builder()
                .addTransportType(mNetworkInterfacesToTest[networkTypeIndex].getTransportType())
                .addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
                .build(), callback);
        synchronized(this) {
            try {
                wait((int)(TIMEOUT_MILLIS * 1.2));
            } catch (InterruptedException e) {
            }
        }
        if (callback.success) {
            mNetworkInterfacesToTest[networkTypeIndex].setMetered(callback.metered);
            mNetworkInterfacesToTest[networkTypeIndex].setIsDefault(callback.isDefault);
            return true;
        }

        // This will always fail at this point as we know 'hasFeature' is true.
        assertFalse (mNetworkInterfacesToTest[networkTypeIndex].getSystemFeature() +
                "" is a reported system feature, "" +
                ""however no corresponding connected network interface was found or the attempt "" +
                ""to connect has timed out (timeout = "" + TIMEOUT_MILLIS + ""ms)."" +
                mNetworkInterfacesToTest[networkTypeIndex].getErrorMessage(), hasFeature);
        return false;
    }

    private String getSubscriberId(int networkIndex) {
        int networkType = mNetworkInterfacesToTest[networkIndex].getNetworkType();
        if (ConnectivityManager.TYPE_MOBILE == networkType) {
            TelephonyManager tm = (TelephonyManager) getInstrumentation().getContext()
                    .getSystemService(Context.TELEPHONY_SERVICE);
            return ShellIdentityUtils.invokeMethodWithShellPermissions(tm,
                    (telephonyManager) -> telephonyManager.getSubscriberId());
        }
        return """";
    }

    @AppModeFull"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.webkit.cts.TestWebServer"	"TestHostnameVerifier"	""	"/home/gpoor/cts-12-source/cts/libs/testserver/src/android/webkit/cts/TestWebServer.java"	""	"public void test// Copyright 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Any changes to this file should be done in upstream chromium.org:
// net/test/android/javatests/src/org/chromium/net/test/util/TestWebServer.java

package android.webkit.cts;

import android.util.Base64;
import android.util.Log;
import android.util.Pair;

import org.apache.http.HttpException;
import org.apache.http.HttpRequest;
import org.apache.http.HttpResponse;
import org.apache.http.HttpStatus;
import org.apache.http.HttpVersion;
import org.apache.http.RequestLine;
import org.apache.http.StatusLine;
import org.apache.http.entity.ByteArrayEntity;
import org.apache.http.impl.DefaultHttpServerConnection;
import org.apache.http.impl.cookie.DateUtils;
import org.apache.http.message.BasicHttpResponse;
import org.apache.http.params.BasicHttpParams;
import org.apache.http.params.CoreProtocolPNames;
import org.apache.http.params.HttpParams;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.MalformedURLException;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.URI;
import java.net.URL;
import java.net.URLConnection;
import java.security.KeyManagementException;
import java.security.KeyStore;
import java.security.NoSuchAlgorithmException;
import java.security.cert.X509Certificate;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.List;
import java.util.Map;

import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.KeyManager;
import javax.net.ssl.KeyManagerFactory;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSession;
import javax.net.ssl.X509TrustManager;

/**
 * Simple http test server for testing.
 *
 * This server runs in a thread in the current process, so it is convenient
 * for loopback testing without the need to setup tcp forwarding to the
 * host computer.
 *
 * Based heavily on the CTSWebServer in Android.
 */
public class TestWebServer {
    private static final String TAG = ""TestWebServer"";

    public static final String SHUTDOWN_PREFIX = ""/shutdown"";

    private static TestWebServer sInstance;
    private static TestWebServer sSecureInstance;
    private static Hashtable<Integer, String> sReasons;

    private final ServerThread mServerThread;
    private String mServerUri;
    private final boolean mSsl;

    private static class Response {
        final byte[] mResponseData;
        final List<Pair<String, String>> mResponseHeaders;
        final boolean mIsRedirect;
        final Runnable mResponseAction;
        final boolean mIsNotFound;

        Response(byte[] responseData, List<Pair<String, String>> responseHeaders,
                boolean isRedirect, boolean isNotFound, Runnable responseAction) {
            mIsRedirect = isRedirect;
            mIsNotFound = isNotFound;
            mResponseData = responseData;
            mResponseHeaders = responseHeaders == null ?
                    new ArrayList<Pair<String, String>>() : responseHeaders;
            mResponseAction = responseAction;
        }
    }

    // The Maps below are modified on both the client thread and the internal server thread, so
    // need to use a lock when accessing them.
    private final Object mLock = new Object();
    private final Map<String, Response> mResponseMap = new HashMap<String, Response>();
    private final Map<String, Integer> mResponseCountMap = new HashMap<String, Integer>();
    private final Map<String, HttpRequest> mLastRequestMap = new HashMap<String, HttpRequest>();

    /**
     * Create and start a local HTTP server instance.
     * @param ssl True if the server should be using secure sockets.
     * @throws Exception
     */
    public TestWebServer(boolean ssl) throws Exception {
        mSsl = ssl;
        if (mSsl) {
            mServerUri = ""https:"";
            if (sSecureInstance != null) {
                sSecureInstance.shutdown();
            }
        } else {
            mServerUri = ""http:"";
            if (sInstance != null) {
                sInstance.shutdown();
            }
        }

        setInstance(this, mSsl);
        mServerThread = new ServerThread(this, mSsl);
        mServerThread.start();
        mServerUri += ""//localhost:"" + mServerThread.mSocket.getLocalPort();
    }

    /**
     * Terminate the http server.
     */
    public void shutdown() {
        try {
            // Avoid a deadlock between two threads where one is trying to call
            // close() and the other one is calling accept() by sending a GET
            // request for shutdown and having the server's one thread
            // sequentially call accept() and close().
            URL url = new URL(mServerUri + SHUTDOWN_PREFIX);
            URLConnection connection = openConnection(url);
            connection.connect();

            // Read the input from the stream to send the request.
            InputStream is = connection.getInputStream();
            is.close();

            // Block until the server thread is done shutting down.
            mServerThread.join();

        } catch (MalformedURLException e) {
            throw new IllegalStateException(e);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        } catch (IOException e) {
            throw new RuntimeException(e);
        } catch (NoSuchAlgorithmException e) {
            throw new IllegalStateException(e);
        } catch (KeyManagementException e) {
            throw new IllegalStateException(e);
        }

        setInstance(null, mSsl);
    }

    private static void setInstance(TestWebServer instance, boolean isSsl) {
        if (isSsl) {
            sSecureInstance = instance;
        } else {
            sInstance = instance;
        }
    }

    private static final int RESPONSE_STATUS_NORMAL = 0;
    private static final int RESPONSE_STATUS_MOVED_TEMPORARILY = 1;
    private static final int RESPONSE_STATUS_NOT_FOUND = 2;

    private String setResponseInternal(
            String requestPath, byte[] responseData,
            List<Pair<String, String>> responseHeaders, Runnable responseAction,
            int status) {
        final boolean isRedirect = (status == RESPONSE_STATUS_MOVED_TEMPORARILY);
        final boolean isNotFound = (status == RESPONSE_STATUS_NOT_FOUND);

        synchronized (mLock) {
            mResponseMap.put(requestPath, new Response(
                    responseData, responseHeaders, isRedirect, isNotFound, responseAction));
            mResponseCountMap.put(requestPath, Integer.valueOf(0));
            mLastRequestMap.put(requestPath, null);
        }
        return getResponseUrl(requestPath);
    }

    /**
     * Gets the URL on the server under which a particular request path will be accessible.
     *
     * This only gets the URL, you still need to set the response if you intend to access it.
     *
     * @param requestPath The path to respond to.
     * @return The full URL including the requestPath.
     */
    public String getResponseUrl(String requestPath) {
        return mServerUri + requestPath;
    }

    /**
     * Sets a 404 (not found) response to be returned when a particular request path is passed in.
     *
     * @param requestPath The path to respond to.
     * @return The full URL including the path that should be requested to get the expected
     *         response.
     */
    public String setResponseWithNotFoundStatus(
            String requestPath) {
        return setResponseInternal(requestPath, """".getBytes(), null, null,
                RESPONSE_STATUS_NOT_FOUND);
    }

    /**
     * Sets a response to be returned when a particular request path is passed
     * in (with the option to specify additional headers).
     *
     * @param requestPath The path to respond to.
     * @param responseString The response body that will be returned.
     * @param responseHeaders Any additional headers that should be returned along with the
     *                        response (null is acceptable).
     * @return The full URL including the path that should be requested to get the expected
     *         response.
     */
    public String setResponse(
            String requestPath, String responseString,
            List<Pair<String, String>> responseHeaders) {
        return setResponseInternal(requestPath, responseString.getBytes(), responseHeaders, null,
                RESPONSE_STATUS_NORMAL);
    }

    /**
     * Sets a response to be returned when a particular request path is passed
     * in with the option to specify additional headers as well as an arbitrary action to be
     * executed on each request.
     *
     * @param requestPath The path to respond to.
     * @param responseString The response body that will be returned.
     * @param responseHeaders Any additional headers that should be returned along with the
     *                        response (null is acceptable).
     * @param responseAction The action to be performed when fetching the response.  This action
     *                       will be executed for each request and will be handled on a background
     *                       thread.
     * @return The full URL including the path that should be requested to get the expected
     *         response.
     */
    public String setResponseWithRunnableAction(
            String requestPath, String responseString, List<Pair<String, String>> responseHeaders,
            Runnable responseAction) {
        return setResponseInternal(
                requestPath, responseString.getBytes(), responseHeaders, responseAction,
                RESPONSE_STATUS_NORMAL);
    }

    /**
     * Sets a redirect.
     *
     * @param requestPath The path to respond to.
     * @param targetPath The path to redirect to.
     * @return The full URL including the path that should be requested to get the expected
     *         response.
     */
    public String setRedirect(
            String requestPath, String targetPath) {
        List<Pair<String, String>> responseHeaders = new ArrayList<Pair<String, String>>();
        responseHeaders.add(Pair.create(""Location"", targetPath));

        return setResponseInternal(requestPath, targetPath.getBytes(), responseHeaders, null,
                RESPONSE_STATUS_MOVED_TEMPORARILY);
    }

    /**
     * Sets a base64 encoded response to be returned when a particular request path is passed
     * in (with the option to specify additional headers).
     *
     * @param requestPath The path to respond to.
     * @param base64EncodedResponse The response body that is base64 encoded. The actual server
     *                              response will the decoded binary form.
     * @param responseHeaders Any additional headers that should be returned along with the
     *                        response (null is acceptable).
     * @return The full URL including the path that should be requested to get the expected
     *         response.
     */
    public String setResponseBase64(
            String requestPath, String base64EncodedResponse,
            List<Pair<String, String>> responseHeaders) {
        return setResponseInternal(
                requestPath, Base64.decode(base64EncodedResponse, Base64.DEFAULT),
                responseHeaders, null, RESPONSE_STATUS_NORMAL);
    }

    /**
     * Get the number of requests was made at this path since it was last set.
     */
    public int getRequestCount(String requestPath) {
        Integer count = null;
        synchronized (mLock) {
            count = mResponseCountMap.get(requestPath);
        }
        if (count == null) throw new IllegalArgumentException(""Path not set: "" + requestPath);
        return count.intValue();
    }

    /**
     * Returns the last HttpRequest at this path. Can return null if it is never requested.
     */
    public HttpRequest getLastRequest(String requestPath) {
        synchronized (mLock) {
            if (!mLastRequestMap.containsKey(requestPath))
                throw new IllegalArgumentException(""Path not set: "" + requestPath);
            return mLastRequestMap.get(requestPath);
        }
    }

    public String getBaseUrl() {
        return mServerUri + ""/"";
    }

    private URLConnection openConnection(URL url)
            throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (mSsl) {
            // Install hostname verifiers and trust managers that don't do
            // anything in order to get around the client not trusting
            // the test server due to a lack of certificates.

            HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
            connection.setHostnameVerifier(new TestHostnameVerifier());

            SSLContext context = SSLContext.getInstance(""TLS"");
            TestTrustManager trustManager = new TestTrustManager();
            context.init(null, new TestTrustManager[] {trustManager}, null);
            connection.setSSLSocketFactory(context.getSocketFactory());

            return connection;
        } else {
            return url.openConnection();
        }
    }

    /**
     * {@link X509TrustManager} that trusts everybody. This is used so that
     * the client calling {@link TestWebServer#shutdown()} can issue a request
     * for shutdown by blindly trusting the {@link TestWebServer}'s
     * credentials.
     */
    private static class TestTrustManager implements X509TrustManager {
        @Override
        public void checkClientTrusted(X509Certificate[] chain, String authType) {
            // Trust the TestWebServer...
        }

        @Override
        public void checkServerTrusted(X509Certificate[] chain, String authType) {
            // Trust the TestWebServer...
        }

        @Override
        public X509Certificate[] getAcceptedIssuers() {
            return null;
        }
    }

    /**
     * {@link HostnameVerifier} that verifies everybody. This permits
     * the client to trust the web server and call
     * {@link TestWebServer#shutdown()}.
     */
    private static class TestHostnameVerifier implements HostnameVerifier {
        @Override
        public boolean verify(String hostname, SSLSession session) {
            return true;
        }
    }

    private void servedResponseFor(String path, HttpRequest request) {
        synchronized (mLock) {
            mResponseCountMap.put(path, Integer.valueOf(
                    mResponseCountMap.get(path).intValue() + 1));
            mLastRequestMap.put(path, request);
        }
    }

    /**
     * Generate a response to the given request.
     *
     * <p>Always executed on the background server thread.
     *
     * <p>If there is an action associated with the response, it will be executed inside of
     * this function.
     *
     * @throws InterruptedException
     */
    private HttpResponse getResponse(HttpRequest request) throws InterruptedException {
        assert Thread.currentThread() == mServerThread
                : ""getResponse called from non-server thread"";

        RequestLine requestLine = request.getRequestLine();
        HttpResponse httpResponse = null;
        Log.i(TAG, requestLine.getMethod() + "": "" + requestLine.getUri());
        String uriString = requestLine.getUri();
        URI uri = URI.create(uriString);
        String path = uri.getPath();

        Response response = null;
        synchronized (mLock) {
            response = mResponseMap.get(path);
        }
        if (path.equals(SHUTDOWN_PREFIX)) {
            httpResponse = createResponse(HttpStatus.SC_OK);
        } else if (response == null) {
            httpResponse = createResponse(HttpStatus.SC_NOT_FOUND);
        } else if (response.mIsNotFound) {
            httpResponse = createResponse(HttpStatus.SC_NOT_FOUND);
            servedResponseFor(path, request);
        } else if (response.mIsRedirect) {
            httpResponse = createResponse(HttpStatus.SC_MOVED_TEMPORARILY);
            for (Pair<String, String> header : response.mResponseHeaders) {
                httpResponse.addHeader(header.first, header.second);
            }
            servedResponseFor(path, request);
        } else {
            if (response.mResponseAction != null) response.mResponseAction.run();

            httpResponse = createResponse(HttpStatus.SC_OK);
            ByteArrayEntity entity = createEntity(response.mResponseData);
            httpResponse.setEntity(entity);
            httpResponse.setHeader(""Content-Length"", """" + entity.getContentLength());
            for (Pair<String, String> header : response.mResponseHeaders) {
                httpResponse.addHeader(header.first, header.second);
            }
            servedResponseFor(path, request);
        }
        StatusLine sl = httpResponse.getStatusLine();
        Log.i(TAG, sl.getStatusCode() + ""("" + sl.getReasonPhrase() + "")"");
        setDateHeaders(httpResponse);
        return httpResponse;
    }

    private void setDateHeaders(HttpResponse response) {
        response.addHeader(""Date"", DateUtils.formatDate(new Date(), DateUtils.PATTERN_RFC1123));
    }

    /**
     * Create an empty response with the given status.
     */
    private HttpResponse createResponse(int status) {
        HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_0, status, null);
        String reason = null;

        // This synchronized silences findbugs.
        synchronized (TestWebServer.class) {
            if (sReasons == null) {
                sReasons = new Hashtable<Integer, String>();
                sReasons.put(HttpStatus.SC_UNAUTHORIZED, ""Unauthorized"");
                sReasons.put(HttpStatus.SC_NOT_FOUND, ""Not Found"");
                sReasons.put(HttpStatus.SC_FORBIDDEN, ""Forbidden"");
                sReasons.put(HttpStatus.SC_MOVED_TEMPORARILY, ""Moved Temporarily"");
            }
            // Fill in error reason. Avoid use of the ReasonPhraseCatalog, which is
            // Locale-dependent.
            reason = sReasons.get(status);
        }

        if (reason != null) {
            StringBuffer buf = new StringBuffer(""<html><head><title>"");
            buf.append(reason);
            buf.append(""</title></head><body>"");
            buf.append(reason);
            buf.append(""</body></html>"");
            ByteArrayEntity entity = createEntity(buf.toString().getBytes());
            response.setEntity(entity);
            response.setHeader(""Content-Length"", """" + entity.getContentLength());
        }
        return response;
    }

    /**
     * Create a string entity for the given content.
     */
    private ByteArrayEntity createEntity(byte[] data) {
        ByteArrayEntity entity = new ByteArrayEntity(data);
        entity.setContentType(""text/html"");
        return entity;
    }

    private static class ServerThread extends Thread {
        private TestWebServer mServer;
        private ServerSocket mSocket;
        private boolean mIsSsl;
        private boolean mIsCancelled;
        private SSLContext mSslContext;

        /**
         * Defines the keystore contents for the server, BKS version. Holds just a
         * single self-generated key. The subject name is ""Test Server"".
         */
        private static final String SERVER_KEYS_BKS =
            ""AAAAAQAAABQDkebzoP1XwqyWKRCJEpn/t8dqIQAABDkEAAVteWtleQAAARpYl20nAAAAAQAFWC41"" +
            ""MDkAAAJNMIICSTCCAbKgAwIBAgIESEfU1jANBgkqhkiG9w0BAQUFADBpMQswCQYDVQQGEwJVUzET"" +
            ""MBEGA1UECBMKQ2FsaWZvcm5pYTEMMAoGA1UEBxMDTVRWMQ8wDQYDVQQKEwZHb29nbGUxEDAOBgNV"" +
            ""BAsTB0FuZHJvaWQxFDASBgNVBAMTC1Rlc3QgU2VydmVyMB4XDTA4MDYwNTExNTgxNFoXDTA4MDkw"" +
            ""MzExNTgxNFowaTELMAkGA1UEBhMCVVMxEzARBgNVBAgTCkNhbGlmb3JuaWExDDAKBgNVBAcTA01U"" +
            ""VjEPMA0GA1UEChMGR29vZ2xlMRAwDgYDVQQLEwdBbmRyb2lkMRQwEgYDVQQDEwtUZXN0IFNlcnZl"" +
            ""cjCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA0LIdKaIr9/vsTq8BZlA3R+NFWRaH4lGsTAQy"" +
            ""DPMF9ZqEDOaL6DJuu0colSBBBQ85hQTPa9m9nyJoN3pEi1hgamqOvQIWcXBk+SOpUGRZZFXwniJV"" +
            ""zDKU5nE9MYgn2B9AoiH3CSuMz6HRqgVaqtppIe1jhukMc/kHVJvlKRNy9XMCAwEAATANBgkqhkiG"" +
            ""9w0BAQUFAAOBgQC7yBmJ9O/eWDGtSH9BH0R3dh2NdST3W9hNZ8hIa8U8klhNHbUCSSktZmZkvbPU"" +
            ""hse5LI3dh6RyNDuqDrbYwcqzKbFJaq/jX9kCoeb3vgbQElMRX8D2ID1vRjxwlALFISrtaN4VpWzV"" +
            ""yeoHPW4xldeZmoVtjn8zXNzQhLuBqX2MmAAAAqwAAAAUvkUScfw9yCSmALruURNmtBai7kQAAAZx"" +
            ""4Jmijxs/l8EBaleaUru6EOPioWkUAEVWCxjM/TxbGHOi2VMsQWqRr/DZ3wsDmtQgw3QTrUK666sR"" +
            ""MBnbqdnyCyvM1J2V1xxLXPUeRBmR2CXorYGF9Dye7NkgVdfA+9g9L/0Au6Ugn+2Cj5leoIgkgApN"" +
            ""vuEcZegFlNOUPVEs3SlBgUF1BY6OBM0UBHTPwGGxFBBcetcuMRbUnu65vyDG0pslT59qpaR0TMVs"" +
            ""P+tcheEzhyjbfM32/vwhnL9dBEgM8qMt0sqF6itNOQU/F4WGkK2Cm2v4CYEyKYw325fEhzTXosck"" +
            ""MhbqmcyLab8EPceWF3dweoUT76+jEZx8lV2dapR+CmczQI43tV9btsd1xiBbBHAKvymm9Ep9bPzM"" +
            ""J0MQi+OtURL9Lxke/70/MRueqbPeUlOaGvANTmXQD2OnW7PISwJ9lpeLfTG0LcqkoqkbtLKQLYHI"" +
            ""rQfV5j0j+wmvmpMxzjN3uvNajLa4zQ8l0Eok9SFaRr2RL0gN8Q2JegfOL4pUiHPsh64WWya2NB7f"" +
            ""V+1s65eA5ospXYsShRjo046QhGTmymwXXzdzuxu8IlnTEont6P4+J+GsWk6cldGbl20hctuUKzyx"" +
            ""OptjEPOKejV60iDCYGmHbCWAzQ8h5MILV82IclzNViZmzAapeeCnexhpXhWTs+xDEYSKEiG/camt"" +
            ""bhmZc3BcyVJrW23PktSfpBQ6D8ZxoMfF0L7V2GQMaUg+3r7ucrx82kpqotjv0xHghNIm95aBr1Qw"" +
            ""1gaEjsC/0wGmmBDg1dTDH+F1p9TInzr3EFuYD0YiQ7YlAHq3cPuyGoLXJ5dXYuSBfhDXJSeddUkl"" +
            ""k1ufZyOOcskeInQge7jzaRfmKg3U94r+spMEvb0AzDQVOKvjjo1ivxMSgFRZaDb/4qw="";

        private static final String PASSWORD = ""android"";

        /**
         * Loads a keystore from a base64-encoded String. Returns the KeyManager[]
         * for the result.
         */
        private KeyManager[] getKeyManagers() throws Exception {
            byte[] bytes = Base64.decode(SERVER_KEYS_BKS, Base64.DEFAULT);
            InputStream inputStream = new ByteArrayInputStream(bytes);

            KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
            keyStore.load(inputStream, PASSWORD.toCharArray());
            inputStream.close();

            String algorithm = KeyManagerFactory.getDefaultAlgorithm();
            KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(algorithm);
            keyManagerFactory.init(keyStore, PASSWORD.toCharArray());

            return keyManagerFactory.getKeyManagers();
        }


        public ServerThread(TestWebServer server, boolean ssl) throws Exception {
            super(""ServerThread"");
            mServer = server;
            mIsSsl = ssl;
            int retry = 3;
            while (true) {
                try {
                    if (mIsSsl) {
                        mSslContext = SSLContext.getInstance(""TLS"");
                        mSslContext.init(getKeyManagers(), null, null);
                        mSocket = mSslContext.getServerSocketFactory().createServerSocket(0);
                    } else {
                        mSocket = new ServerSocket(0);
                    }
                    return;
                } catch (IOException e) {
                    Log.w(TAG, e);
                    if (--retry == 0) {
                        throw e;
                    }
                    // sleep in case server socket is still being closed
                    Thread.sleep(1000);
                }
            }
        }

        @Override
        public void run() {
            HttpParams params = new BasicHttpParams();
            params.setParameter(CoreProtocolPNames.PROTOCOL_VERSION, HttpVersion.HTTP_1_0);
            while (!mIsCancelled) {
                try {
                    Socket socket = mSocket.accept();
                    DefaultHttpServerConnection conn = new DefaultHttpServerConnection();
                    conn.bind(socket, params);

                    // Determine whether we need to shutdown early before
                    // parsing the response since conn.close() will crash
                    // for SSL requests due to UnsupportedOperationException.
                    HttpRequest request = conn.receiveRequestHeader();
                    if (isShutdownRequest(request)) {
                        mIsCancelled = true;
                    }

                    HttpResponse response = mServer.getResponse(request);
                    conn.sendResponseHeader(response);
                    conn.sendResponseEntity(response);
                    conn.close();

                } catch (IOException e) {
                    // normal during shutdown, ignore
                    Log.w(TAG, e);
                } catch (HttpException e) {
                    Log.w(TAG, e);
                } catch (InterruptedException e) {
                    Log.w(TAG, e);
                } catch (UnsupportedOperationException e) {
                    // DefaultHttpServerConnection's close() throws an
                    // UnsupportedOperationException.
                    Log.w(TAG, e);
                }
            }
            try {
                mSocket.close();
            } catch (IOException ignored) {
                // safe to ignore
            }
        }

        private boolean isShutdownRequest(HttpRequest request) {
            RequestLine requestLine = request.getRequestLine();
            String uriString = requestLine.getUri();
            URI uri = URI.create(uriString);
            String path = uri.getPath();
            return path.equals(SHUTDOWN_PREFIX);
        }
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.compatibility.common.deviceinfo.GlesStubActivity"	"waitForActivityToFinish"	""	"/home/gpoor/cts-12-source/cts/common/device-side/device-info/src/com/android/compatibility/common/deviceinfo/GlesStubActivity.java"	""	"public void test/*
 *.
 */
package com.android.compatibility.common.deviceinfo;

import android.app.Activity;
import android.app.ActivityManager;
import android.app.Instrumentation;
import android.content.Context;
import android.content.pm.ConfigurationInfo;
import android.content.res.Configuration;
import android.os.Bundle;
import android.view.Window;
import android.view.WindowManager;
import android.opengl.EGL14;
import android.opengl.EGLDisplay;
import android.opengl.GLES20;
import android.opengl.GLES30;
import android.opengl.GLSurfaceView;
import android.util.Log;

import java.lang.reflect.Field;
import java.nio.FloatBuffer;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Locale;
import java.util.HashSet;
import java.util.HashMap;
import java.util.Scanner;
import java.util.Set;
import java.util.concurrent.CountDownLatch;

import javax.microedition.khronos.egl.EGLConfig;
import javax.microedition.khronos.opengles.GL10;

/** Stub activity to collect data from the GlesView */
public final class GlesStubActivity extends Activity {

    private static final String LOG_TAG = ""GlesStubActivity"";
    private int mVersion = -1;
    private GraphicsDeviceInfo mGraphicsDeviceInfo;
    private CountDownLatch mDone = new CountDownLatch(1);
    private HashSet<String> mOpenGlExtensions = new HashSet<>();
    private HashSet<String> mEglExtensions = new HashSet<>();
    private HashSet<String> mFormats = new HashSet<>();
    private HashMap<String, Object> mImplVariables = new HashMap<>();
    private HashSet<String> mDynamicArrayVariables = new HashSet<>();
    private String mGraphicsVendor;
    private String mGraphicsRenderer;

    @Override
    public void onCreate(Bundle bundle) {
        // Dismiss keyguard and keep screen on while this test is on.
        Window window = getWindow();
        window.addFlags(WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD |
                WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON |
                WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);

        super.onCreate(bundle);

        window.setFlags(WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED,
                WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED);

        ActivityManager activityManager =
                (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE);
        ConfigurationInfo info = activityManager.getDeviceConfigurationInfo();

        mVersion = (info.reqGlEsVersion & 0xffff0000) >> 16;

        new Thread() {
            @Override
            public void run() {
                runIterations(mVersion);
            }
        }.start();
    }

     /**
     * Wait for this activity to finish gathering information
     */
    public void waitForActivityToFinish() {
        try {
            mDone.await();
        } catch (InterruptedException e) {
            // just move on
        }
    }

    private void runIterations(int glVersion) {
        for (int i = 1; i <= glVersion; i++) {
            final CountDownLatch done = new CountDownLatch(1);
            final int version = i;
            GlesStubActivity.this.runOnUiThread(new Runnable() {
                @Override
                public void run() {
                    setContentView(new GlesSurfaceView(GlesStubActivity.this, version, done));
                }
            });
            try {
                done.await();
            } catch (InterruptedException e) {
                // just move on
            }
        }
        mDone.countDown();
    }

    int getGlVersion() {
        return mVersion;
    }

    List<String> getOpenGlExtensions() {
        return new ArrayList<>(mOpenGlExtensions);
    }

    void addOpenGlExtension(String openGlExtension) {
        mOpenGlExtensions.add(openGlExtension);
    }

    List<String> getEglExtensions() {
        return new ArrayList<>(mEglExtensions);
    }

    void addEglExtensions(String[] eglExtensions) {
        // NOTE: We may end up here multiple times, using set to avoid dupes.
        mEglExtensions.addAll(Arrays.asList(eglExtensions));
    }

    List<String> getCompressedTextureFormats() {
        return new ArrayList<>(mFormats);
    }

    void addCompressedTextureFormat(String format) {
        mFormats.add(format);
    }

    String getVendor() {
        return mGraphicsVendor;
    }

    void setVendor(String vendor) {
        mGraphicsVendor = vendor;
    }

    String getRenderer() {
        return mGraphicsRenderer;
    }

    void setRenderer(String renderer) {
        mGraphicsRenderer = renderer;
    }

    public Set<String> getImplementationVariableNames() {
        return mImplVariables.keySet();
    }

    public Object getImplementationVariable(String name) {
        return mImplVariables.get(name);
    }

    public boolean isDynamicArrayVariable(String name) {
        return mDynamicArrayVariables.contains(name);
    }

    void addImplementationVariable(String name, Object value, boolean isDynamicArray) {
        mImplVariables.put(name, value);
        if (isDynamicArray) {
            mDynamicArrayVariables.add(name);
        }
    }

    static class GlesSurfaceView extends GLSurfaceView {

        public GlesSurfaceView(GlesStubActivity parent, int glVersion, CountDownLatch done) {
            super(parent);

            if (glVersion > 1) {
                // Default is 1 so only set if bigger than 1
                setEGLContextClientVersion(glVersion);
            }
            setRenderer(new OpenGlesRenderer(parent, glVersion, done));
        }
    }

    static abstract class ImplementationVariable {
        private Field mField;
        public ImplementationVariable(String fieldName) {
            try {
                mField = GLES30.class.getField(fieldName);
            } catch (NoSuchFieldException e) {
                Log.e(LOG_TAG, ""Failed to get field reflection"", e);
            }
        }

        public String getName() {
            return mField.getName();
        }

        public int getFieldIdValue() throws IllegalAccessException {
            return mField.getInt(null);
        }

        abstract public Object getValue();

        static protected int[] getIntValues(int fieldId, int count) throws IllegalAccessException{
            int[] resultInts = new int[count];
            // The JNI wrapper layer has a piece of code that defines
            // the expected array length. It defaults to 1 and looks
            // like it's missing GLES3 variables. So, we won't be
            // querying if the array has zero lenght.
            if (count > 0) {
                GLES20.glGetIntegerv(fieldId, resultInts, 0);
            }
            return resultInts;
        }
    }

    static class IntVectorValue extends ImplementationVariable {
        private int mCount;

        public IntVectorValue(String fieldName, int count) {
            super(fieldName);
            mCount = count;
        }

        @Override
        public Object getValue() {
            Log.i(LOG_TAG, ""Getting : "" + this.getName() + "" "" + mCount);
            try {
                return getIntValues(this.getFieldIdValue(), mCount);
            } catch (IllegalAccessException e) {
                Log.e(LOG_TAG, ""Failed to read the GL field"", e);
            }
            return null;
        }
    }

    static class DynamicIntVectorValue extends ImplementationVariable {
        private Field mCountField;

        public DynamicIntVectorValue(String fieldName, String countFieldName) {
            super(fieldName);
            try {
                mCountField = GLES30.class.getField(countFieldName);
            } catch (NoSuchFieldException e) {
                Log.e(LOG_TAG, ""Failed to get field reflection"", e);
            }
        }

        @Override
        public Object getValue() {
            Log.i(LOG_TAG, ""Getting : "" + this.getName() + "" "" + mCountField.getName());
            try {
                int[] count = new int[] {0};
                GLES20.glGetIntegerv(mCountField.getInt(null), count, 0);
                Log.i(LOG_TAG, ""Getting : "" + mCountField.getName() + "" "" + count[0]);
                return getIntValues(this.getFieldIdValue(), count[0]);
            } catch (IllegalAccessException e) {
                Log.e(LOG_TAG, ""Failed to read the GL field"", e);
            }
            return null;
        }
    }

    static class FloatVectorValue extends ImplementationVariable {
        private int mCount;

        public FloatVectorValue(String fieldName, int count) {
            super(fieldName);
            mCount = count;
        }

        @Override
        public Object getValue() {
            Log.i(LOG_TAG, ""Getting : "" + this.getName() + "" "" + mCount);
            try {
                float[] result = new float[mCount];
                GLES20.glGetFloatv(getFieldIdValue(), result, 0);
                return result;
            } catch (IllegalAccessException e) {
                Log.e(LOG_TAG, ""Failed to read the GL field"", e);
            }
            return null;
        }
    }

    static class LongVectorValue extends ImplementationVariable {
        private int mCount;

        public LongVectorValue(String fieldName, int count) {
            super(fieldName);
            mCount = count;
        }

        @Override
        public Object getValue() {
            Log.i(LOG_TAG, ""Getting : "" + this.getName() + "" "" + mCount);
            try {
                long result[] = new long[mCount];
                GLES30.glGetInteger64v(getFieldIdValue(), result, 0);
                return result;
            } catch (IllegalAccessException e) {
                Log.e(LOG_TAG, ""Failed to read the GL field"", e);
            }
            return null;
        }
    }

    static class StringValue extends ImplementationVariable {
        public StringValue(String fieldName) {
            super(fieldName);
        }

        @Override
        public Object getValue() {
            Log.i(LOG_TAG, ""Getting : "" + this.getName());
            String result = null;
            try {
                result = GLES20.glGetString(this.getFieldIdValue());
            } catch (IllegalAccessException e) {
                Log.e(LOG_TAG, ""Failed to read the GL field"", e);
            }
            return result;
        }
    }

    // NOTE: Changes to the types of the variables will carry over to
    // GraphicsDeviceInfo proto via GraphicsDeviceInfo. See
    // go/edi-userguide for details.
    static ImplementationVariable[] GLES2_IMPLEMENTATION_VARIABLES = {
        new IntVectorValue(""GL_SUBPIXEL_BITS"", 1),
        new IntVectorValue(""GL_MAX_TEXTURE_SIZE"", 1),
        new IntVectorValue(""GL_MAX_CUBE_MAP_TEXTURE_SIZE"", 1),
        new IntVectorValue(""GL_MAX_VIEWPORT_DIMS"", 2),
        new FloatVectorValue(""GL_ALIASED_POINT_SIZE_RANGE"", 2),
        new FloatVectorValue(""GL_ALIASED_LINE_WIDTH_RANGE"", 2),
        new DynamicIntVectorValue(""GL_COMPRESSED_TEXTURE_FORMATS"", ""GL_NUM_COMPRESSED_TEXTURE_FORMATS""),
        new DynamicIntVectorValue(""GL_SHADER_BINARY_FORMATS"", ""GL_NUM_SHADER_BINARY_FORMATS""),
        new IntVectorValue(""GL_SHADER_COMPILER"", 1),
        new StringValue(""GL_SHADING_LANGUAGE_VERSION""),
        new StringValue(""GL_VERSION""),
        new IntVectorValue(""GL_MAX_VERTEX_ATTRIBS"", 1),
        new IntVectorValue(""GL_MAX_VERTEX_UNIFORM_VECTORS"", 1),
        new IntVectorValue(""GL_MAX_VARYING_VECTORS"", 1),
        new IntVectorValue(""GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS"", 1),
        new IntVectorValue(""GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS"", 1),
        new IntVectorValue(""GL_MAX_TEXTURE_IMAGE_UNITS"", 1),
        new IntVectorValue(""GL_MAX_FRAGMENT_UNIFORM_VECTORS"", 1),
        new IntVectorValue(""GL_MAX_RENDERBUFFER_SIZE"", 1)
    };

    static ImplementationVariable[] GLES3_IMPLEMENTATION_VARIABLES = {
        new LongVectorValue(""GL_MAX_ELEMENT_INDEX"", 1),
        new IntVectorValue(""GL_MAX_3D_TEXTURE_SIZE"", 1),
        new IntVectorValue(""GL_MAX_ARRAY_TEXTURE_LAYERS"", 1),
        new FloatVectorValue(""GL_MAX_TEXTURE_LOD_BIAS"", 1),
        new IntVectorValue(""GL_MAX_DRAW_BUFFERS"", 1),
        new IntVectorValue(""GL_MAX_COLOR_ATTACHMENTS"", 1),
        new IntVectorValue(""GL_MAX_ELEMENTS_INDICES"", 1),
        new IntVectorValue(""GL_MAX_ELEMENTS_VERTICES"", 1),
        new DynamicIntVectorValue(""GL_PROGRAM_BINARY_FORMATS"", ""GL_NUM_PROGRAM_BINARY_FORMATS""),
        new LongVectorValue(""GL_MAX_SERVER_WAIT_TIMEOUT"", 1),
        new IntVectorValue(""GL_MAJOR_VERSION"", 1),
        new IntVectorValue(""GL_MINOR_VERSION"", 1),
        new IntVectorValue(""GL_MAX_VERTEX_UNIFORM_COMPONENTS"", 1),
        new IntVectorValue(""GL_MAX_VERTEX_UNIFORM_BLOCKS"", 1),
        new IntVectorValue(""GL_MAX_VERTEX_OUTPUT_COMPONENTS"", 1),
        new IntVectorValue(""GL_MAX_FRAGMENT_UNIFORM_COMPONENTS"", 1),
        new IntVectorValue(""GL_MAX_FRAGMENT_UNIFORM_BLOCKS"", 1),
        new IntVectorValue(""GL_MAX_FRAGMENT_INPUT_COMPONENTS"", 1),
        new IntVectorValue(""GL_MIN_PROGRAM_TEXEL_OFFSET"", 1),
        new IntVectorValue(""GL_MAX_PROGRAM_TEXEL_OFFSET"", 1),
        new IntVectorValue(""GL_MAX_UNIFORM_BUFFER_BINDINGS"", 1),
        new LongVectorValue(""GL_MAX_UNIFORM_BLOCK_SIZE"", 1),
        new IntVectorValue(""GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT"", 1),
        new IntVectorValue(""GL_MAX_COMBINED_UNIFORM_BLOCKS"", 1),
        new LongVectorValue(""GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS"", 1),
        new LongVectorValue(""GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS"", 1),
        new IntVectorValue(""GL_MAX_VARYING_COMPONENTS"", 1),
        new IntVectorValue(""GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS"", 1),
        new IntVectorValue(""GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS"", 1),
        new IntVectorValue(""GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS"", 1)
    };

    static class OpenGlesRenderer implements GLSurfaceView.Renderer {

        private final GlesStubActivity mParent;
        private final int mGlVersion;
        private final CountDownLatch mDone;

        OpenGlesRenderer(GlesStubActivity parent, int glVersion, CountDownLatch done) {
            mParent = parent;
            mGlVersion = glVersion;
            mDone = done;
        }

        @Override
        public void onSurfaceCreated(GL10 gl, EGLConfig config) {
            String extensions;
            String vendor;
            String renderer;
            if (mGlVersion == 2) {
                extensions = GLES20.glGetString(GLES20.GL_EXTENSIONS);
                vendor = GLES20.glGetString(GLES20.GL_VENDOR);
                renderer = GLES20.glGetString(GLES20.GL_RENDERER);
                collectImplementationVariables(GLES2_IMPLEMENTATION_VARIABLES);
            } else if (mGlVersion == 3) {
                extensions = GLES30.glGetString(GLES30.GL_EXTENSIONS);
                vendor = GLES30.glGetString(GLES30.GL_VENDOR);
                renderer = GLES30.glGetString(GLES30.GL_RENDERER);
                collectImplementationVariables(GLES3_IMPLEMENTATION_VARIABLES);
            } else {
                extensions = gl.glGetString(GL10.GL_EXTENSIONS);
                vendor = gl.glGetString(GL10.GL_VENDOR);
                renderer = gl.glGetString(GL10.GL_RENDERER);
            }
            mParent.setVendor(vendor);
            mParent.setRenderer(renderer);
            Scanner scanner = new Scanner(extensions);
            scanner.useDelimiter("" "");
            while (scanner.hasNext()) {
                String ext = scanner.next();
                mParent.addOpenGlExtension(ext);
                if (ext.contains(""texture"")) {
                    if (ext.contains(""compression"") || ext.contains(""compressed"")) {
                        mParent.addCompressedTextureFormat(ext);
                    }
                }
            }
            scanner.close();

            collectEglExtensions(mParent);

            mDone.countDown();
        }

        @Override
        public void onSurfaceChanged(GL10 gl, int width, int height) {}

        @Override
        public void onDrawFrame(GL10 gl) {}

        private void collectImplementationVariables(ImplementationVariable[] variables) {
            for (int i = 0; i < variables.length; i++) {
                String name = variables[i].getName();
                Object value = variables[i].getValue();
                boolean dynamicArray = variables[i] instanceof DynamicIntVectorValue;
                mParent.addImplementationVariable(name, value, dynamicArray);
            }
        }

        private static void collectEglExtensions(GlesStubActivity collector) {
            EGLDisplay display = EGL14.eglGetDisplay(EGL14.EGL_DEFAULT_DISPLAY);
            if (display == EGL14.EGL_NO_DISPLAY) {
                Log.e(LOG_TAG, ""Failed to init EGL default display: 0x"" +
                        Integer.toHexString(EGL14.eglGetError()));
                return;
            }
            String extensions = EGL14.eglQueryString(display, EGL14.EGL_EXTENSIONS);
            int error = EGL14.eglGetError();
            if (error != EGL14.EGL_SUCCESS) {
                Log.e(LOG_TAG, ""Failed to query extension string: 0x"" + Integer.toHexString(error));
                return;
            }
            // Fingers crossed for no extra white space in the extension string.
            collector.addEglExtensions(extensions.split("" ""));
        }
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.server.cts.device.statsdatom.AtomTests"	"testBleScanOpportunistic"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/apps/statsdapp/src/com/android/server/cts/device/statsdatom/AtomTests.java"	""	"public void testBleScanOpportunistic() {
        ScanSettings scanSettings = new ScanSettings.Builder()
                .setScanMode(ScanSettings.SCAN_MODE_OPPORTUNISTIC).build();
        performBleScan(scanSettings, null,false);
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.server.cts.device.statsdatom.AtomTests"	"testBleScanUnoptimized"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/apps/statsdapp/src/com/android/server/cts/device/statsdatom/AtomTests.java"	""	"public void testBleScanUnoptimized() {
        ScanSettings scanSettings = new ScanSettings.Builder()
                .setScanMode(ScanSettings.SCAN_MODE_LOW_LATENCY).build();
        performBleScan(scanSettings, null, false);
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.server.cts.device.statsdatom.AtomTests"	"testBleScanResult"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/apps/statsdapp/src/com/android/server/cts/device/statsdatom/AtomTests.java"	""	"public void testBleScanResult() {
        ScanSettings scanSettings = new ScanSettings.Builder()
                .setScanMode(ScanSettings.SCAN_MODE_LOW_LATENCY).build();
        ScanFilter.Builder scanFilter = new ScanFilter.Builder();
        performBleScan(scanSettings, Arrays.asList(scanFilter.build()), true);
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.server.cts.device.statsdatom.AtomTests"	"testBleScanInterrupted"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/apps/statsdapp/src/com/android/server/cts/device/statsdatom/AtomTests.java"	""	"public void testBleScanInterrupted() throws Exception {
        performBleAction((bluetoothAdapter, bleScanner) -> {
            ScanSettings scanSettings = new ScanSettings.Builder()
                    .setScanMode(ScanSettings.SCAN_MODE_LOW_LATENCY).build();
            ScanCallback scanCallback = new ScanCallback() {
                @Override
                public void onScanResult(int callbackType, ScanResult result) {
                    Log.v(TAG, ""called onScanResult"");
                }
                @Override
                public void onScanFailed(int errorCode) {
                    Log.v(TAG, ""called onScanFailed"");
                }
                @Override
                public void onBatchScanResults(List<ScanResult> results) {
                    Log.v(TAG, ""called onBatchScanResults"");
                }
            };

            int uid = Process.myUid();
            int whatAtomId = 9_999;

            // Get the current setting for bluetooth background scanning.
            // Set to 0 if the setting is not found or an error occurs.
            int initialBleScanGlobalSetting = Settings.Global.getInt(
                    InstrumentationRegistry.getTargetContext().getContentResolver(),
                    Settings.Global.BLE_SCAN_ALWAYS_AVAILABLE, 0);

            // Turn off bluetooth background scanning.
            Settings.Global.putInt(InstrumentationRegistry.getTargetContext().getContentResolver(),
                    Settings.Global.BLE_SCAN_ALWAYS_AVAILABLE, 0);

            // Change state to State.ON.
            bleScanner.startScan(null, scanSettings, scanCallback);
            sleep(6_000);
            writeSliceByBleScanStateChangedAtom(whatAtomId, uid, false, false, false);
            writeSliceByBleScanStateChangedAtom(whatAtomId, uid, false, false, false);

            bluetoothAdapter.disable();
            sleep(6_000);

            // Trigger State.RESET so that new state is State.OFF.
            if (!bluetoothAdapter.enable()) {
                Log.e(TAG, ""Could not enable bluetooth to trigger state reset"");
                return;
            }
            sleep(6_000); // Wait for Bluetooth to fully turn on.
            writeSliceByBleScanStateChangedAtom(whatAtomId, uid, false, false, false);
            writeSliceByBleScanStateChangedAtom(whatAtomId, uid, false, false, false);
            writeSliceByBleScanStateChangedAtom(whatAtomId, uid, false, false, false);

            // Set bluetooth background scanning to original setting.
            Settings.Global.putInt(InstrumentationRegistry.getTargetContext().getContentResolver(),
                    Settings.Global.BLE_SCAN_ALWAYS_AVAILABLE, initialBleScanGlobalSetting);
        });
    }

    private static void writeSliceByBleScanStateChangedAtom(int atomId, int firstUid,
                                                            boolean field2, boolean field3,
                                                            boolean field4) {
        final StatsEvent.Builder builder = StatsEvent.newBuilder()
                .setAtomId(atomId)
                .writeAttributionChain(new int[] {firstUid}, new String[] {""tag1""})
                .writeBoolean(field2)
                .writeBoolean(field3)
                .writeBoolean(field4)
                .usePooledBuffer();

        StatsLog.write(builder.build());
    }

    /**
     * Set up BluetoothLeScanner and perform the action in the callback.
     * Restore Bluetooth to original state afterwards.
     **/
    private static void performBleAction(BiConsumer<BluetoothAdapter, BluetoothLeScanner> actions) {
        BluetoothAdapter bluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
        if (bluetoothAdapter == null) {
            Log.e(TAG, ""Device does not support Bluetooth"");
            return;
        }
        boolean bluetoothEnabledByTest = false;
        if (!bluetoothAdapter.isEnabled()) {
            if (!bluetoothAdapter.enable()) {
                Log.e(TAG, ""Bluetooth is not enabled"");
                return;
            }
            sleep(2_000); // Wait for Bluetooth to fully turn on.
            bluetoothEnabledByTest = true;
        }
        BluetoothLeScanner bleScanner = bluetoothAdapter.getBluetoothLeScanner();
        if (bleScanner == null) {
            Log.e(TAG, ""Cannot access BLE scanner"");
            return;
        }

        actions.accept(bluetoothAdapter, bleScanner);

        // Restore adapter state
        if (bluetoothEnabledByTest) {
            bluetoothAdapter.disable();
        }
    }


    private static void performBleScan(ScanSettings scanSettings, List<ScanFilter> scanFilters, boolean waitForResult) {
        performBleAction((bluetoothAdapter, bleScanner) -> {
            CountDownLatch resultsLatch = new CountDownLatch(1);
            ScanCallback scanCallback = new ScanCallback() {
                @Override
                public void onScanResult(int callbackType, ScanResult result) {
                    Log.v(TAG, ""called onScanResult"");
                    resultsLatch.countDown();
                }
                @Override
                public void onScanFailed(int errorCode) {
                    Log.v(TAG, ""called onScanFailed"");
                }
                @Override
                public void onBatchScanResults(List<ScanResult> results) {
                    Log.v(TAG, ""called onBatchScanResults"");
                    resultsLatch.countDown();
                }
            };

            bleScanner.startScan(scanFilters, scanSettings, scanCallback);
            if (waitForResult) {
                waitForReceiver(InstrumentationRegistry.getContext(), 59_000, resultsLatch, null);
            } else {
                sleep(2_000);
            }
            bleScanner.stopScan(scanCallback);
        });
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.server.cts.device.statsdatom.AtomTests"	"testGpsScan"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/apps/statsdapp/src/com/android/server/cts/device/statsdatom/AtomTests.java"	""	"public void testGpsScan() {
        Context context = InstrumentationRegistry.getContext();
        final LocationManager locManager = context.getSystemService(LocationManager.class);
        if (!locManager.isProviderEnabled(LocationManager.GPS_PROVIDER)) {
            Log.e(TAG, ""GPS provider is not enabled"");
            return;
        }
        CountDownLatch latch = new CountDownLatch(1);

        final LocationListener locListener = new LocationListener() {
            public void onLocationChanged(Location location) {
                Log.v(TAG, ""onLocationChanged: location has been obtained"");
            }
            public void onProviderDisabled(String provider) {
                Log.w(TAG, ""onProviderDisabled "" + provider);
            }
            public void onProviderEnabled(String provider) {
                Log.w(TAG, ""onProviderEnabled "" + provider);
            }
            public void onStatusChanged(String provider, int status, Bundle extras) {
                Log.w(TAG, ""onStatusChanged "" + provider + "" "" + status);
            }
        };

        new AsyncTask<Void, Void, Void>() {
            @Override
            protected Void doInBackground(Void... params) {
                Looper.prepare();
                locManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 990, 0,
                        locListener);
                sleep(1_000);
                locManager.removeUpdates(locListener);
                latch.countDown();
                return null;
            }
        }.execute();

        waitForReceiver(context, 59_000, latch, null);
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.server.cts.device.statsdatom.AtomTests"	"testWifiScan"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/apps/statsdapp/src/com/android/server/cts/device/statsdatom/AtomTests.java"	""	"/** Does two wifi scans. */
    // TODO: Copied this from BatterystatsValidation but we probably don't need to wait for results.
    public void testWifiScan() {
        Context context = InstrumentationRegistry.getContext();
        IntentFilter intentFilter = new IntentFilter(WifiManager.SCAN_RESULTS_AVAILABLE_ACTION);
        // Sometimes a scan was already running (from a different uid), so the first scan doesn't
        // start when requested. Therefore, additionally wait for whatever scan is currently running
        // to finish, then request a scan again - at least one of these two scans should be
        // attributed to this app.
        for (int i = 0; i < 2; i++) {
            CountDownLatch onReceiveLatch = new CountDownLatch(1);
            BroadcastReceiver receiver = registerReceiver(context, onReceiveLatch, intentFilter);
            context.getSystemService(WifiManager.class).startScan();
            waitForReceiver(context, 60_000, onReceiveLatch, receiver);
        }
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.scopedstorage.cts.legacy.LegacyStorageTest"	"isTrue"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/legacy/src/android/scopedstorage/cts/legacy/LegacyStorageTest.java"	""	"public void setupExternalStorage() {
        setupDefaultDirectories();
    }

    @Before
    public void setup() throws Exception {
        pollForExternalStorageState();

        assertThat(checkPermission(APP_A_HAS_RES,
                Manifest.permission.READ_EXTERNAL_STORAGE)).isTrue();
        assertThat(checkPermission(APP_B_NO_PERMS,
                Manifest.permission.READ_EXTERNAL_STORAGE)).isFalse();
    }

    @After
    public void teardown() throws Exception {
        deleteFileInExternalDir(getShellFile());
        try {
            MediaStore.scanFile(getContentResolver(), getShellFile());
        } catch (Exception ignored) {
            //ignore MediaScanner exceptions
        }
    }

    /**
     * Tests that legacy apps bypass the type-path conformity restrictions imposed by
     * MediaProvider. <p> Assumes we have WRITE_EXTERNAL_STORAGE.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.scopedstorage.cts.legacy.LegacyStorageTest"	"testCantAccessExternalStorage"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/legacy/src/android/scopedstorage/cts/legacy/LegacyStorageTest.java"	""	"public void testCantAccessExternalStorage() throws Exception {
        pollForPermission(Manifest.permission.READ_EXTERNAL_STORAGE, /*granted*/ false);
        pollForPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE, /*granted*/ false);
        // Can't create file under root dir
        final File newTxtFile = new File(TestUtils.getExternalStorageDir(),
                ""LegacyFileAccessTest.txt"");
        try {
            newTxtFile.createNewFile();
            fail(""File creation expected to fail: "" + newTxtFile);
        } catch (IOException expected) {
        }

        // Can't create music file under /MUSIC
        final File newMusicFile = new File(TestUtils.getMusicDir(), ""LegacyFileAccessTest.mp3"");
        try {
            newMusicFile.createNewFile();
            fail(""File creation expected to fail: "" + newMusicFile);
        } catch (IOException expected) {
        }

        // Can't create a top-level direcotry
        final File topLevelDir = new File(TestUtils.getExternalStorageDir(), ""LegacyFileAccessTest"");
        assertThat(topLevelDir.mkdir()).isFalse();

        // Can't read existing file
        final File existingFile = getShellFile();

        try {
            createFileInExternalDir(existingFile);
            MediaStore.scanFile(getContentResolver(), existingFile);
            Os.open(existingFile.getPath(), OsConstants.O_RDONLY, /*mode*/ 0);
            fail(""Opening file for read expected to fail: "" + existingFile);
        } catch (ErrnoException expected) {
        }

        // Can't delete file
        assertThat(existingFile.delete()).isFalse();

        // try to list a directory and fail
        assertThat(TestUtils.getMusicDir().list()).isNull();
        assertThat(TestUtils.getExternalStorageDir().list()).isNull();

        // However, even without permissions, we can access our own external dir
        final File fileInDataDir =
                new File(TestUtils.getExternalFilesDir(),
                        ""LegacyFileAccessTest"");
        try {
            assertThat(fileInDataDir.createNewFile()).isTrue();
            assertThat(Arrays.asList(fileInDataDir.getParentFile().list()))
                    .contains(""LegacyFileAccessTest"");
        } finally {
            fileInDataDir.delete();
        }

        // we can access our own external media directory without permissions.
        final File fileInMediaDir =
                new File(TestUtils.getExternalMediaDir(),
                        ""LegacyFileAccessTest"");
        try {
            assertThat(fileInMediaDir.createNewFile()).isTrue();
            assertThat(Arrays.asList(fileInMediaDir.getParentFile().list()))
                    .contains(""LegacyFileAccessTest"");
        } finally {
            fileInMediaDir.delete();
        }
    }

    // test read storage permission"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.scopedstorage.cts.legacy.LegacyStorageTest"	"testReadOnlyExternalStorage_hasR"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/legacy/src/android/scopedstorage/cts/legacy/LegacyStorageTest.java"	""	"public void testReadOnlyExternalStorage_hasR() throws Exception {
        pollForPermission(Manifest.permission.READ_EXTERNAL_STORAGE, /*granted*/ true);
        pollForPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE, /*granted*/ false);
        // can list directory content
        assertThat(TestUtils.getMusicDir().list()).isNotNull();

        // try to write a file and fail
        final File existingFile = getShellFile();

        // can open file for read
        FileDescriptor fd = null;
        try {
            createFileInExternalDir(existingFile);
            MediaStore.scanFile(getContentResolver(), existingFile);
            fd = Os.open(existingFile.getPath(), OsConstants.O_RDONLY, /*mode*/ 0);
        } finally {
            if (fd != null) {
                Os.close(fd);
            }
        }

        try {
            fd = Os.open(existingFile.getPath(), OsConstants.O_WRONLY, /*mode*/ 0);
            Os.close(fd);
            fail(""Opening file for write expected to fail: "" + existingFile);
        } catch (ErrnoException expected) {
        }

        // try to create file and fail, because it requires WRITE
        final File newFile = new File(TestUtils.getMusicDir(), ""LegacyFileAccessTest.mp3"");
        try {
            newFile.createNewFile();
            fail(""Creating file expected to fail: "" + newFile);
        } catch (IOException expected) {
        }

        // try to mkdir and fail, because it requires WRITE
        final File newDir = new File(TestUtils.getExternalStorageDir(), ""LegacyFileAccessTest"");
        try {
            assertThat(newDir.mkdir()).isFalse();
        } finally {
            newDir.delete();
        }
    }

    /**
     * Test that legacy app with storage permission can list all files
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.scopedstorage.cts.legacy.LegacyStorageTest"	"testListFiles_hasR"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/legacy/src/android/scopedstorage/cts/legacy/LegacyStorageTest.java"	""	"public void testListFiles_hasR() throws Exception {
        pollForPermission(Manifest.permission.READ_EXTERNAL_STORAGE, /*granted*/ true);
        pollForPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE, /*granted*/ false);
        final File shellFile = getShellFile();

        createFileInExternalDir(shellFile);
        MediaStore.scanFile(getContentResolver(), getShellFile());
        // can list a non-media file created by other package.
        assertThat(Arrays.asList(shellFile.getParentFile().list()))
                .contains(shellFile.getName());
    }

    /**
     * Test that URI returned on inserting hidden file is valid after scan.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.scopedstorage.cts.legacy.LegacyStorageTest"	"testInsertHiddenFile"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/legacy/src/android/scopedstorage/cts/legacy/LegacyStorageTest.java"	""	"public void testInsertHiddenFile() throws Exception {
        pollForPermission(Manifest.permission.READ_EXTERNAL_STORAGE, /*granted*/ true);
        final File dcimDir = getDcimDir();
        final String hiddenImageFileName = "".hidden"" + IMAGE_FILE_NAME;
        final File hiddenImageFile = new File(dcimDir, hiddenImageFileName);
        try {
            ContentValues values = new ContentValues();
            values.put(MediaStore.MediaColumns.DATA, hiddenImageFile.getAbsolutePath());
            Uri uri = getContentResolver().insert(getImageContentUri(), values);
            try (OutputStream fos = getContentResolver().openOutputStream(uri, ""rw"")) {
                fos.write(BYTES_DATA1);
            }
            MediaStore.scanFile(getContentResolver(), hiddenImageFile);
            final String[] projection = {MediaStore.MediaColumns.DISPLAY_NAME};
            try (Cursor c = getContentResolver().query(uri, projection, null, null, null)) {
                assertThat(c.moveToFirst()).isTrue();
                assertThat(c.getString(0)).isEqualTo(hiddenImageFileName);
            }
        } finally {
            hiddenImageFile.delete();
        }
    }

    /**
     * Test that rename for legacy app with WRITE_EXTERNAL_STORAGE permission bypasses rename
     * restrictions imposed by MediaProvider
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.scopedstorage.cts.legacy.LegacyStorageTest"	"testCantRename_hasR"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/legacy/src/android/scopedstorage/cts/legacy/LegacyStorageTest.java"	""	"public void testCantRename_hasR() throws Exception {
        pollForPermission(Manifest.permission.READ_EXTERNAL_STORAGE, /*granted*/ true);
        pollForPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE, /*granted*/ false);

        final File shellFile1 = getShellFile();
        final File shellFile2 = new File(TestUtils.getDownloadDir(), ""LegacyFileAccessTest_shell"");
        final File mediaFile1 =
                new File(TestUtils.getExternalMediaDir(),
                        ""LegacyFileAccessTest1"");
        final File mediaFile2 =
                new File(TestUtils.getExternalMediaDir(),
                        ""LegacyFileAccessTest2"");
        try {
            createFileInExternalDir(shellFile1);
            MediaStore.scanFile(getContentResolver(), shellFile1);
            // app can't rename shell file.
            assertCantRenameFile(shellFile1, shellFile2);
            // app can't move shell file to its media directory.
            assertCantRenameFile(shellFile1, mediaFile1);
            // However, even without permissions, app can rename files in its own external media
            // directory.
            assertThat(mediaFile1.createNewFile()).isTrue();
            assertThat(mediaFile1.renameTo(mediaFile2)).isTrue();
            assertThat(mediaFile2.exists()).isTrue();
        } finally {
            mediaFile1.delete();
            mediaFile2.delete();
        }
    }

    /**
     * Test that legacy app with no storage permission can only rename files in app external
     * directories.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.scopedstorage.cts.legacy.LegacyStorageTest"	"testCantRename_noStoragePermission"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/legacy/src/android/scopedstorage/cts/legacy/LegacyStorageTest.java"	""	"public void testCantRename_noStoragePermission() throws Exception {
        pollForPermission(Manifest.permission.READ_EXTERNAL_STORAGE, /*granted*/ false);
        pollForPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE, /*granted*/ false);

        final File shellFile1 = getShellFile();
        final File shellFile2 = new File(TestUtils.getDownloadDir(), ""LegacyFileAccessTest_shell"");
        final File mediaFile1 =
                new File(TestUtils.getExternalMediaDir(),
                        ""LegacyFileAccessTest1"");
        final File mediaFile2 =
                new File(TestUtils.getExternalMediaDir(),
                        ""LegacyFileAccessTest2"");
        try {
            createFileInExternalDir(shellFile1);
            MediaStore.scanFile(getContentResolver(), shellFile1);
            // app can't rename shell file.
            assertCantRenameFile(shellFile1, shellFile2);
            // app can't move shell file to its media directory.
            assertCantRenameFile(shellFile1, mediaFile1);
            // However, even without permissions, app can rename files in its own external media
            // directory.
            assertThat(mediaFile1.createNewFile()).isTrue();
            assertThat(mediaFile1.renameTo(mediaFile2)).isTrue();
            assertThat(mediaFile2.exists()).isTrue();
        } finally {
            mediaFile1.delete();
            mediaFile2.delete();
        }
    }

    /**
     * b/156046098, Test that MediaProvider doesn't throw UNIQUE constraint error while updating db
     * rows corresponding to renamed directory.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.scopedstorage.cts.legacy.LegacyStorageTest"	"testRenameDoesntInvalidateUri_hasRW"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/legacy/src/android/scopedstorage/cts/legacy/LegacyStorageTest.java"	""	"public void testRenameDoesntInvalidateUri_hasRW() throws Exception {
        pollForPermission(Manifest.permission.READ_EXTERNAL_STORAGE, /*granted*/ true);
        pollForPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE, /*granted*/ true);

        final File imageFile = new File(TestUtils.getDcimDir(), IMAGE_FILE_NAME);
        final File temporaryImageFile = new File(TestUtils.getDcimDir(), IMAGE_FILE_NAME + ""_.tmp"");
        final ContentResolver cr = getContentResolver();

        try {
            assertThat(imageFile.createNewFile()).isTrue();
            try (final FileOutputStream fos = new FileOutputStream(imageFile)) {
                fos.write(BYTES_DATA1);
            }
            // Insert this file to database.
            final Uri uri = TestUtils.insertFileUsingDataColumn(imageFile);
            assertNotNull(uri);

            Files.copy(imageFile, temporaryImageFile);
            // Write more bytes to temporaryImageFile
            try (final FileOutputStream fos = new FileOutputStream(temporaryImageFile, true)) {
                fos.write(BYTES_DATA2);
            }
            assertThat(imageFile.delete()).isTrue();
            temporaryImageFile.renameTo(imageFile);

            // Previous uri of imageFile is unaltered after delete & rename.
            final Uri scannedUri = MediaStore.scanFile(cr, imageFile);
            assertThat(scannedUri.getLastPathSegment()).isEqualTo(uri.getLastPathSegment());

            final byte[] expected = (STR_DATA1 + STR_DATA2).getBytes();
            assertFileContent(imageFile, expected);
        } finally {
            imageFile.delete();
            temporaryImageFile.delete();
        }
    }

    /**
     * b/150498564,b/150274099: Test that apps can rename files that are not in database.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.scopedstorage.cts.legacy.LegacyStorageTest"	"testCanRenameAFileWithNoDBRow_hasRW"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/legacy/src/android/scopedstorage/cts/legacy/LegacyStorageTest.java"	""	"public void testCanRenameAFileWithNoDBRow_hasRW() throws Exception {
        pollForPermission(Manifest.permission.READ_EXTERNAL_STORAGE, /*granted*/ true);
        pollForPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE, /*granted*/ true);

        final File directoryNoMedia = new File(TestUtils.getDcimDir(), "".directoryNoMedia"");
        final File imageInNoMediaDir = new File(directoryNoMedia, IMAGE_FILE_NAME);
        final File renamedImageInDCIM = new File(TestUtils.getDcimDir(), IMAGE_FILE_NAME);
        final File noMediaFile = new File(directoryNoMedia, "".nomedia"");
        final ContentResolver cr = getContentResolver();

        try {
            if (!directoryNoMedia.exists()) {
                assertThat(directoryNoMedia.mkdirs()).isTrue();
            }
            assertThat(noMediaFile.createNewFile()).isTrue();
            assertThat(imageInNoMediaDir.createNewFile()).isTrue();
            // Remove imageInNoMediaDir from database.
            MediaStore.scanFile(cr, directoryNoMedia);

            // Query for all images/videos in the device. This shouldn't list imageInNoMediaDir
            assertThat(getImageAndVideoFilesFromDatabase())
                    .doesNotContain(imageInNoMediaDir.getName());

            // Rename shouldn't throw error even if imageInNoMediaDir is not in database.
            assertThat(imageInNoMediaDir.renameTo(renamedImageInDCIM)).isTrue();
            // We can insert renamedImageInDCIM to database
            ContentValues values = new ContentValues();
            values.put(MediaStore.MediaColumns.DATA, renamedImageInDCIM.getAbsolutePath());
            final Uri uri = TestUtils.insertFileUsingDataColumn(renamedImageInDCIM);
            assertNotNull(uri);
        } finally {
            imageInNoMediaDir.delete();
            renamedImageInDCIM.delete();
            noMediaFile.delete();
            directoryNoMedia.delete();
        }
    }

    /**
     * Test that legacy apps creating files for existing db row doesn't upsert and set IS_PENDING
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.scopedstorage.cts.legacy.LegacyStorageTest"	"testInsertWithUnsupportedMimeType"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/legacy/src/android/scopedstorage/cts/legacy/LegacyStorageTest.java"	""	"public void testInsertWithUnsupportedMimeType() throws Exception {
        pollForPermission(Manifest.permission.READ_EXTERNAL_STORAGE, /*granted*/ true);
        pollForPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE, /*granted*/ true);

        final String IMAGE_FILE_DISPLAY_NAME = ""LegacyStorageTest_file_"" + NONCE;
        final File imageFile = new File(TestUtils.getDcimDir(), IMAGE_FILE_DISPLAY_NAME + "".jpg"");

        for (String mimeType : new String[] {
            ""image/*"", """", null, ""foo/bar""
        }) {
            Uri uri = null;
            try {
                ContentValues values = new ContentValues();
                values.put(MediaStore.MediaColumns.RELATIVE_PATH, Environment.DIRECTORY_DCIM);
                if (TextUtils.isEmpty(mimeType)) {
                    values.put(MediaStore.MediaColumns.DISPLAY_NAME, imageFile.getName());
                } else {
                    values.put(MediaStore.MediaColumns.DISPLAY_NAME, IMAGE_FILE_DISPLAY_NAME);
                }
                values.put(MediaStore.MediaColumns.MIME_TYPE, mimeType);

                uri = getContentResolver().insert(getImageContentUri(), values, Bundle.EMPTY);
                assertNotNull(uri);

                try (final OutputStream fos = getContentResolver().openOutputStream(uri, ""rw"")) {
                    fos.write(BYTES_DATA1);
                }

                // Closing the file should trigger a scan, we still scan again to ensure MIME type
                // is extracted from file extension
                assertNotNull(MediaStore.scanFile(getContentResolver(), imageFile));

                final String[] projection = {MediaStore.MediaColumns.DISPLAY_NAME,
                        MediaStore.MediaColumns.MIME_TYPE};
                try (Cursor c = getContentResolver().query(uri, projection, null, null, null)) {
                    assertTrue(c.moveToFirst());
                    assertEquals(c.getCount(), 1);
                    assertEquals(c.getString(0), imageFile.getName());
                    assertTrue(""image/jpeg"".equalsIgnoreCase(c.getString(1)));
                }
            } finally {
                deleteWithMediaProviderNoThrow(uri);
            }
        }
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.scopedstorage.cts.legacy.LegacyStorageTest"	"testLegacySystemGalleryWithoutWESCannotRename"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/legacy/src/android/scopedstorage/cts/legacy/LegacyStorageTest.java"	""	"public void testLegacySystemGalleryWithoutWESCannotRename() throws Exception {
        pollForPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE, /*granted*/ false);

        final File otherAppVideoFile = new File(getDcimDir(), ""other_"" + VIDEO_FILE_NAME);
        final File videoFile = new File(getPicturesDir(), VIDEO_FILE_NAME);

        try {
            allowAppOpsToUid(Process.myUid(), SYSTEM_GALERY_APPOPS);

            // Create file of other app.
            assertThat(createFileAs(APP_B_NO_PERMS, otherAppVideoFile.getPath())).isTrue();

            // Check we cannot rename it.
            assertThat(otherAppVideoFile.renameTo(videoFile)).isFalse();
        } finally {
            otherAppVideoFile.delete();
            videoFile.delete();
            denyAppOpsToUid(Process.myUid(), SYSTEM_GALERY_APPOPS);
        }
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.scopedstorage.cts.legacy.LegacyStorageTest"	"testLegacyWESCanRenameImagesAndVideosWithDbUpdates_hasW"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/legacy/src/android/scopedstorage/cts/legacy/LegacyStorageTest.java"	""	"public void testLegacyWESCanRenameImagesAndVideosWithDbUpdates_hasW() throws Exception {
        pollForPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE, /*granted*/ true);

        final File otherAppVideoFile = new File(getDcimDir(), ""other_"" + VIDEO_FILE_NAME);
        final File videoFile = new File(getPicturesDir(), VIDEO_FILE_NAME);

        try {
            // Create and write some data to the file
            assertThat(createFileAs(APP_B_NO_PERMS, otherAppVideoFile.getPath())).isTrue();
            try (FileOutputStream fos = new FileOutputStream(otherAppVideoFile)) {
                fos.write(BYTES_DATA1);
            }

            // Assert legacy WES can rename the file (including database updated).
            assertCanRenameFile(otherAppVideoFile, videoFile);
            assertFileContent(videoFile, BYTES_DATA1);
        } finally {
            otherAppVideoFile.delete();
            videoFile.delete();
        }
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.scopedstorage.cts.legacy.LegacyStorageTest"	"testScanUpdatesMetadataForNewlyAddedFile_hasRW"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/legacy/src/android/scopedstorage/cts/legacy/LegacyStorageTest.java"	""	"public void testScanUpdatesMetadataForNewlyAddedFile_hasRW() throws Exception {
        pollForPermission(Manifest.permission.READ_EXTERNAL_STORAGE, /*granted*/ true);
        pollForPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE, /*granted*/ true);

        final File jpgFile = new File(getPicturesDir(), IMAGE_FILE_NAME);
        try {
            // Copy the image content to jpgFile
            try (InputStream in =
                         getContext().getResources().openRawResource(R.raw.img_with_metadata);
                 FileOutputStream out = new FileOutputStream(jpgFile)) {
                FileUtils.copy(in, out);
                out.getFD().sync();
            }
            // Insert a new row for jpgFile.
            ContentValues values = new ContentValues();
            values.put(MediaStore.MediaColumns.DATA, jpgFile.getAbsolutePath());
            final Uri targetUri =
                    getContentResolver().insert(getImageContentUri(), values, Bundle.EMPTY);
            assertNotNull(targetUri);

            try (Cursor c = TestUtils.queryFile(jpgFile, MediaStore.MediaColumns.DATE_TAKEN)) {
                // Since the file is not yet scanned, no metadata is available
                assertThat(c.moveToFirst()).isTrue();
                assertThat(c.getString(0)).isNull();
            }

            // Scan the file to update the metadata. This scan shouldn't no-op
            final Uri scanUri = MediaStore.scanFile(getContentResolver(), jpgFile);
            assertNotNull(scanUri);

            // ScanFile was able to update the metadata hence we should see DATE_TAKEN value.
            try (Cursor c = TestUtils.queryFile(jpgFile, MediaStore.MediaColumns.DATE_TAKEN)) {
                assertThat(c.moveToFirst()).isTrue();
                assertThat(c.getString(0)).isNotNull();
            }
        } finally {
            jpgFile.delete();
        }
    }

    /**
     * Make sure inserting files from app private directories in legacy apps is allowed via DATA.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.hardware.camera2.cts.RobustnessTest"	"testOisDataMode"	"CtsCameraTestCases"	"/home/gpoor/cts-12-source/cts/tests/camera/src/android/hardware/camera2/cts/RobustnessTest.java"	""	"public void testOisDataMode() throws Exception {
        final int NUM_FRAMES_VERIFIED = 3;

        for (String id : mCameraIdsUnderTest) {
            Log.i(TAG, String.format(""Testing Camera %s for OIS mode"", id));

            StaticMetadata staticInfo =
                    new StaticMetadata(mCameraManager.getCameraCharacteristics(id));
            if (!staticInfo.isOisDataModeSupported()) {
                continue;
            }

            openDevice(id);

            try {
                SurfaceTexture preview = new SurfaceTexture(/*random int*/ 1);
                Surface previewSurface = new Surface(preview);

                CaptureRequest.Builder previewRequest = preparePreviewTestSession(preview);
                SimpleCaptureCallback previewListener = new CameraTestUtils.SimpleCaptureCallback();

                int[] availableOisDataModes = staticInfo.getCharacteristics().get(
                        CameraCharacteristics.STATISTICS_INFO_AVAILABLE_OIS_DATA_MODES);

                // Test each OIS data mode
                for (int oisMode : availableOisDataModes) {
                    previewRequest.set(CaptureRequest.STATISTICS_OIS_DATA_MODE, oisMode);

                    int sequenceId = mCameraSession.setRepeatingRequest(previewRequest.build(),
                            previewListener, mHandler);

                    // Check OIS data in each mode.
                    for (int i = 0; i < NUM_FRAMES_VERIFIED; i++) {
                        TotalCaptureResult result =
                            previewListener.getTotalCaptureResult(CAPTURE_TIMEOUT);

                        OisSample[] oisSamples = result.get(CaptureResult.STATISTICS_OIS_SAMPLES);

                        if (oisMode == CameraCharacteristics.STATISTICS_OIS_DATA_MODE_OFF) {
                            mCollector.expectKeyValueEquals(result,
                                    CaptureResult.STATISTICS_OIS_DATA_MODE,
                                    CaptureResult.STATISTICS_OIS_DATA_MODE_OFF);
                            mCollector.expectTrue(""OIS samples reported in OIS_DATA_MODE_OFF"",
                                    oisSamples == null || oisSamples.length == 0);

                        } else if (oisMode == CameraCharacteristics.STATISTICS_OIS_DATA_MODE_ON) {
                            mCollector.expectKeyValueEquals(result,
                                    CaptureResult.STATISTICS_OIS_DATA_MODE,
                                    CaptureResult.STATISTICS_OIS_DATA_MODE_ON);
                            mCollector.expectTrue(""OIS samples not reported in OIS_DATA_MODE_ON"",
                                    oisSamples != null && oisSamples.length != 0);
                        } else {
                            mCollector.addMessage(String.format(""Invalid OIS mode: %d"", oisMode));
                        }
                    }

                    mCameraSession.stopRepeating();
                    previewListener.getCaptureSequenceLastFrameNumber(sequenceId, CAPTURE_TIMEOUT);
                    previewListener.drain();
                }
            } finally {
                closeDevice(id);
            }
        }
    }

    private CaptureRequest.Builder preparePreviewTestSession(SurfaceTexture preview)
            throws Exception {
        Surface previewSurface = new Surface(preview);

        preview.setDefaultBufferSize(640, 480);

        ArrayList<Surface> sessionOutputs = new ArrayList<>();
        sessionOutputs.add(previewSurface);

        createSession(sessionOutputs);

        CaptureRequest.Builder previewRequest =
                mCamera.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);

        previewRequest.addTarget(previewSurface);

        return previewRequest;
    }

    private CaptureRequest.Builder prepareTriggerTestSession(
            SurfaceTexture preview, int aeMode, int afMode) throws Exception {
        Log.i(TAG, String.format(""Testing AE mode %s, AF mode %s"",
                        StaticMetadata.getAeModeName(aeMode),
                        StaticMetadata.getAfModeName(afMode)));

        CaptureRequest.Builder previewRequest = preparePreviewTestSession(preview);
        previewRequest.set(CaptureRequest.CONTROL_AE_MODE, aeMode);
        previewRequest.set(CaptureRequest.CONTROL_AF_MODE, afMode);

        return previewRequest;
    }

    private void cancelTriggersAndWait(CaptureRequest.Builder previewRequest,
            SimpleCaptureCallback captureListener, int afMode) throws Exception {
        previewRequest.set(CaptureRequest.CONTROL_AF_TRIGGER,
                CaptureRequest.CONTROL_AF_TRIGGER_CANCEL);
        previewRequest.set(CaptureRequest.CONTROL_AE_PRECAPTURE_TRIGGER,
                CaptureRequest.CONTROL_AE_PRECAPTURE_TRIGGER_CANCEL);

        CaptureRequest triggerRequest = previewRequest.build();
        mCameraSession.capture(triggerRequest, captureListener, mHandler);

        // Wait for a few frames to initialize 3A

        CaptureResult previewResult = null;
        int afState;
        int aeState;

        for (int i = 0; i < PREVIEW_WARMUP_FRAMES; i++) {
            previewResult = captureListener.getCaptureResult(
                    CameraTestUtils.CAPTURE_RESULT_TIMEOUT_MS);
            if (VERBOSE) {
                afState = previewResult.get(CaptureResult.CONTROL_AF_STATE);
                aeState = previewResult.get(CaptureResult.CONTROL_AE_STATE);
                Log.v(TAG, String.format(""AF state: %s, AE state: %s"",
                                StaticMetadata.AF_STATE_NAMES[afState],
                                StaticMetadata.AE_STATE_NAMES[aeState]));
            }
        }

        // Verify starting states

        afState = previewResult.get(CaptureResult.CONTROL_AF_STATE);
        aeState = previewResult.get(CaptureResult.CONTROL_AE_STATE);

        verifyStartingAfState(afMode, afState);

        // After several frames, AE must no longer be in INACTIVE state
        assertTrue(String.format(""AE state must be SEARCHING, CONVERGED, "" +
                        ""or FLASH_REQUIRED, is %s"", StaticMetadata.AE_STATE_NAMES[aeState]),
                aeState == CaptureResult.CONTROL_AE_STATE_SEARCHING ||
                aeState == CaptureResult.CONTROL_AE_STATE_CONVERGED ||
                aeState == CaptureResult.CONTROL_AE_STATE_FLASH_REQUIRED);
    }

    private void verifyBasicSensorPixelModes(String id, StreamConfigurationMap configs,
            boolean maxResolution) throws Exception {
        // Go through StreamConfiguration map, set up OutputConfiguration and add the opposite
        // sensorPixelMode.
        final int MIN_RESULT_COUNT = 3;
        if (!maxResolution) {
            assertTrue(""Default stream config map must be present for id: "" + id, configs != null);
        }
        if (configs == null) {
            Log.i(TAG, ""camera id "" + id + "" has no StreamConfigurationMap for max resolution "" +
                "", skipping verifyBasicSensorPixelModes"");
            return;
        }
        OutputConfiguration outputConfig = null;
        for (int format : configs.getOutputFormats()) {
            Size targetSize = CameraTestUtils.getMaxSize(configs.getOutputSizes(format));
            // Create outputConfiguration with this size and format
            SimpleImageReaderListener imageListener = new SimpleImageReaderListener();
            SurfaceTexture textureTarget = null;
            ImageReader readerTarget = null;
            if (format == ImageFormat.PRIVATE) {
                textureTarget = new SurfaceTexture(1);
                textureTarget.setDefaultBufferSize(targetSize.getWidth(), targetSize.getHeight());
                outputConfig = new OutputConfiguration(new Surface(textureTarget));
            } else {
                readerTarget = ImageReader.newInstance(targetSize.getWidth(),
                        targetSize.getHeight(), format, MIN_RESULT_COUNT);
                readerTarget.setOnImageAvailableListener(imageListener, mHandler);
                outputConfig = new OutputConfiguration(readerTarget.getSurface());
            }
            try {
                int invalidSensorPixelMode =
                        maxResolution ? CameraMetadata.SENSOR_PIXEL_MODE_DEFAULT :
                                CameraMetadata.SENSOR_PIXEL_MODE_MAXIMUM_RESOLUTION;

                outputConfig.addSensorPixelModeUsed(invalidSensorPixelMode);
                CameraCaptureSession.StateCallback sessionListener =
                        mock(CameraCaptureSession.StateCallback.class);
                List<OutputConfiguration> outputs = new ArrayList<>();
                outputs.add(outputConfig);
                CameraCaptureSession session =
                        CameraTestUtils.configureCameraSessionWithConfig(mCamera, outputs,
                                sessionListener, mHandler);

                verify(sessionListener, timeout(CONFIGURE_TIMEOUT).atLeastOnce()).
                        onConfigureFailed(any(CameraCaptureSession.class));
                verify(sessionListener, never()).onConfigured(any(CameraCaptureSession.class));

                // Remove the invalid sensor pixel mode, session configuration should succeed
                sessionListener = mock(CameraCaptureSession.StateCallback.class);
                outputConfig.removeSensorPixelModeUsed(invalidSensorPixelMode);
                CameraTestUtils.configureCameraSessionWithConfig(mCamera, outputs,
                        sessionListener, mHandler);
                verify(sessionListener, timeout(CONFIGURE_TIMEOUT).atLeastOnce()).
                        onConfigured(any(CameraCaptureSession.class));
                verify(sessionListener, never()).onConfigureFailed(any(CameraCaptureSession.class));
            } finally {
                if (textureTarget != null) {
                    textureTarget.release();
                }

                if (readerTarget != null) {
                    readerTarget.close();
                }
            }
        }
    }

    private void verifyStartingAfState(int afMode, int afState) {
        switch (afMode) {
            case CaptureResult.CONTROL_AF_MODE_AUTO:
            case CaptureResult.CONTROL_AF_MODE_MACRO:
                assertTrue(String.format(""AF state not INACTIVE, is %s"",
                                StaticMetadata.AF_STATE_NAMES[afState]),
                        afState == CaptureResult.CONTROL_AF_STATE_INACTIVE);
                break;
            case CaptureResult.CONTROL_AF_MODE_CONTINUOUS_PICTURE:
            case CaptureResult.CONTROL_AF_MODE_CONTINUOUS_VIDEO:
                // After several frames, AF must no longer be in INACTIVE state
                assertTrue(String.format(""In AF mode %s, AF state not PASSIVE_SCAN"" +
                                "", PASSIVE_FOCUSED, or PASSIVE_UNFOCUSED, is %s"",
                                StaticMetadata.getAfModeName(afMode),
                                StaticMetadata.AF_STATE_NAMES[afState]),
                        afState == CaptureResult.CONTROL_AF_STATE_PASSIVE_SCAN ||
                        afState == CaptureResult.CONTROL_AF_STATE_PASSIVE_FOCUSED ||
                        afState == CaptureResult.CONTROL_AF_STATE_PASSIVE_UNFOCUSED);
                break;
            default:
                fail(""unexpected af mode"");
        }
    }

    private boolean verifyAfSequence(int afMode, int afState, boolean focusComplete) {
        if (focusComplete) {
            assertTrue(String.format(""AF Mode %s: Focus lock lost after convergence: AF state: %s"",
                            StaticMetadata.getAfModeName(afMode),
                            StaticMetadata.AF_STATE_NAMES[afState]),
                    afState == CaptureResult.CONTROL_AF_STATE_FOCUSED_LOCKED ||
                    afState ==CaptureResult.CONTROL_AF_STATE_NOT_FOCUSED_LOCKED);
            return focusComplete;
        }
        if (VERBOSE) {
            Log.v(TAG, String.format(""AF mode: %s, AF state: %s"",
                            StaticMetadata.getAfModeName(afMode),
                            StaticMetadata.AF_STATE_NAMES[afState]));
        }
        switch (afMode) {
            case CaptureResult.CONTROL_AF_MODE_AUTO:
            case CaptureResult.CONTROL_AF_MODE_MACRO:
                assertTrue(String.format(""AF mode %s: Unexpected AF state %s"",
                                StaticMetadata.getAfModeName(afMode),
                                StaticMetadata.AF_STATE_NAMES[afState]),
                        afState == CaptureResult.CONTROL_AF_STATE_ACTIVE_SCAN ||
                        afState == CaptureResult.CONTROL_AF_STATE_FOCUSED_LOCKED ||
                        afState == CaptureResult.CONTROL_AF_STATE_NOT_FOCUSED_LOCKED);
                focusComplete =
                        (afState != CaptureResult.CONTROL_AF_STATE_ACTIVE_SCAN);
                break;
            case CaptureResult.CONTROL_AF_MODE_CONTINUOUS_PICTURE:
                assertTrue(String.format(""AF mode %s: Unexpected AF state %s"",
                                StaticMetadata.getAfModeName(afMode),
                                StaticMetadata.AF_STATE_NAMES[afState]),
                        afState == CaptureResult.CONTROL_AF_STATE_PASSIVE_SCAN ||
                        afState == CaptureResult.CONTROL_AF_STATE_FOCUSED_LOCKED ||
                        afState == CaptureResult.CONTROL_AF_STATE_NOT_FOCUSED_LOCKED);
                focusComplete =
                        (afState != CaptureResult.CONTROL_AF_STATE_PASSIVE_SCAN);
                break;
            case CaptureResult.CONTROL_AF_MODE_CONTINUOUS_VIDEO:
                assertTrue(String.format(""AF mode %s: Unexpected AF state %s"",
                                StaticMetadata.getAfModeName(afMode),
                                StaticMetadata.AF_STATE_NAMES[afState]),
                        afState == CaptureResult.CONTROL_AF_STATE_FOCUSED_LOCKED ||
                        afState == CaptureResult.CONTROL_AF_STATE_NOT_FOCUSED_LOCKED);
                focusComplete = true;
                break;
            default:
                fail(""Unexpected AF mode: "" + StaticMetadata.getAfModeName(afMode));
        }
        return focusComplete;
    }

    private boolean verifyAeSequence(int aeState, boolean precaptureComplete) {
        if (precaptureComplete) {
            assertTrue(""Precapture state seen after convergence"",
                    aeState != CaptureResult.CONTROL_AE_STATE_PRECAPTURE);
            return precaptureComplete;
        }
        if (VERBOSE) {
            Log.v(TAG, String.format(""AE state: %s"", StaticMetadata.AE_STATE_NAMES[aeState]));
        }
        switch (aeState) {
            case CaptureResult.CONTROL_AE_STATE_PRECAPTURE:
                // scan still continuing
                break;
            case CaptureResult.CONTROL_AE_STATE_CONVERGED:
            case CaptureResult.CONTROL_AE_STATE_FLASH_REQUIRED:
                // completed
                precaptureComplete = true;
                break;
            default:
                fail(String.format(""Precapture sequence transitioned to ""
                                + ""state %s incorrectly!"", StaticMetadata.AE_STATE_NAMES[aeState]));
                break;
        }
        return precaptureComplete;
    }

    /**
     * Test for making sure that all expected mandatory stream combinations are present and
     * advertised accordingly.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.writeexternalstorageapp.WriteExternalStorageTest"	"assertExternalStorageMounted"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/WriteExternalStorageApp/src/com/android/cts/writeexternalstorageapp/WriteExternalStorageTest.java"	""	"public void test/*
 *.
 */

package com.android.cts.writeexternalstorageapp;

import static androidx.test.platform.app.InstrumentationRegistry.getInstrumentation;

import static com.android.cts.externalstorageapp.CommonExternalStorageTest.TAG;
import static com.android.cts.externalstorageapp.CommonExternalStorageTest.assertDirNoWriteAccess;
import static com.android.cts.externalstorageapp.CommonExternalStorageTest.assertDirReadWriteAccess;
import static com.android.cts.externalstorageapp.CommonExternalStorageTest.buildCommonChildDirs;
import static com.android.cts.externalstorageapp.CommonExternalStorageTest.buildProbeFile;
import static com.android.cts.externalstorageapp.CommonExternalStorageTest.deleteContents;
import static com.android.cts.externalstorageapp.CommonExternalStorageTest.getAllPackageSpecificPathsExceptMedia;
import static com.android.cts.externalstorageapp.CommonExternalStorageTest.getMountPaths;
import static com.android.cts.externalstorageapp.CommonExternalStorageTest.getPrimaryPackageSpecificPaths;
import static com.android.cts.externalstorageapp.CommonExternalStorageTest.getSecondaryPackageSpecificPaths;
import static com.android.cts.externalstorageapp.CommonExternalStorageTest.readInt;
import static com.android.cts.externalstorageapp.CommonExternalStorageTest.writeInt;

import android.os.Environment;
import android.os.ParcelFileDescriptor;
import android.provider.MediaStore;
import android.support.test.uiautomator.UiDevice;
import android.system.Os;
import android.test.AndroidTestCase;
import android.util.Log;

import androidx.core.os.BuildCompat;
import com.android.cts.externalstorageapp.CommonExternalStorageTest;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.List;
import java.util.Random;

/**
 * Test external storage from an application that has
 * {@link android.Manifest.permission#WRITE_EXTERNAL_STORAGE}.
 */
public class WriteExternalStorageTest extends AndroidTestCase {

    private static final File TEST_FILE = new File(
            Environment.getExternalStorageDirectory(), ""meow"");

    /**
     * Set of file paths that should all refer to the same location to verify
     * support for legacy paths.
     */
    private static final File[] IDENTICAL_FILES = {
            new File(""/sdcard/caek""),
            new File(System.getenv(""EXTERNAL_STORAGE""), ""caek""),
            new File(Environment.getExternalStorageDirectory(), ""caek""),
    };

    @Override
    protected void tearDown() throws Exception {
        try {
            TEST_FILE.delete();
            for (File file : IDENTICAL_FILES) {
                file.delete();
            }
        } finally {
            super.tearDown();
        }
    }

    private void assertExternalStorageMounted() {
        assertEquals(Environment.MEDIA_MOUNTED, Environment.getExternalStorageState());
    }"	""	""	"probe"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.writeexternalstorageapp.WriteExternalStorageTest"	"testWriteExternalStorageDirs"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/WriteExternalStorageApp/src/com/android/cts/writeexternalstorageapp/WriteExternalStorageTest.java"	""	"public void testWriteExternalStorageDirs() throws Exception {
        final File probe = new File(
                Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DCIM),
                ""100CTS"");

        assertFalse(probe.exists());
        assertTrue(probe.mkdirs());

        try {
            assertDirReadWriteAccess(probe);
        }
        finally {
            probe.delete();
            assertFalse(probe.exists());
        }
    }

    /**
     * Verify that legacy filesystem paths continue working, and that they all
     * point to same location.
     */"	""	""	"probe"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.writeexternalstorageapp.WriteExternalStorageTest"	"testSecondaryMountPoints"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/WriteExternalStorageApp/src/com/android/cts/writeexternalstorageapp/WriteExternalStorageTest.java"	""	"public void testSecondaryMountPoints() throws Exception {
        // Probe path could be /storage/emulated/0 or /storage/1234-5678
        final File probe = buildProbeFile(Environment.getExternalStorageDirectory());
        assertTrue(probe.createNewFile());

        final String userId = Integer.toString(android.os.Process.myUid() / 100000);
        final List<File> mountPaths = getMountPaths();
        final String packageName = getContext().getPackageName();
        for (File path : mountPaths) {
            // Mount points could be multi-user aware, so try probing both top
            // level and user-specific directory.
            final File userPath = new File(path, userId);

            final File testProbe = new File(path, probe.getName());
            final File testUserProbe = new File(userPath, probe.getName());

            if (testProbe.exists() || testUserProbe.exists()) {
                Log.d(TAG, ""Primary external mountpoint "" + path);
            } else {
                Log.d(TAG, ""Other mountpoint "" + path);
                if (Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState(path))) {
                    if (path.getAbsolutePath().endsWith(""/Android/data"")
                            || path.getAbsolutePath().endsWith(""/Android/obb"")) {
                        assertDirNoWriteAccess(path);
                    } else {
                        if (path.getAbsolutePath().endsWith(packageName)) {
                            // It's package's own obb / data dir, it's not a normal mount point
                            // and we don't need to check the access.
                            continue;
                        }
                        assertDirReadWriteAccess(path);
                        assertDirReadWriteAccess(buildCommonChildDirs(path));
                    }
                }
                else {
                    assertDirNoWriteAccess(path);
                    assertDirNoWriteAccess(userPath);
                }
            }
        }
    }"	""	""	"probe"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.writeexternalstorageapp.WriteExternalStorageTest"	"testWriteExternalStorage"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/WriteExternalStorageApp/src/com/android/cts/writeexternalstorageapp/WriteExternalStorageTest.java"	""	"public void testWriteExternalStorage() throws Exception {
        final long newTimeMillis = 12345000;
        assertExternalStorageMounted();

        // Write a value and make sure we can read it back
        writeInt(TEST_FILE, 32);
        assertEquals(readInt(TEST_FILE), 32);

        assertTrue(""Must be able to set last modified"", TEST_FILE.setLastModified(newTimeMillis));

        // This uses the same fd, so info is cached by VFS.
        assertEquals(newTimeMillis, TEST_FILE.lastModified());

        // Obtain a new fd, using the low FS and check timestamp on it.
        ParcelFileDescriptor fd =
                getContext().getContentResolver().openFileDescriptor(
                        MediaStore.scanFile(getContext().getContentResolver(), TEST_FILE), ""rw"");

        long newTimeSeconds = newTimeMillis / 1000;
        assertEquals(newTimeSeconds, Os.fstat(fd.getFileDescriptor()).st_mtime);
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.writeexternalstorageapp.WriteExternalStorageTest"	"testVerifyNoMediaCreated"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/WriteExternalStorageApp/src/com/android/cts/writeexternalstorageapp/WriteExternalStorageTest.java"	""	"public void testVerifyNoMediaCreated() throws Exception {
        boolean expectNoMediaFileExists = true;
        if (BuildCompat.isAtLeastS() && isFuseDataIsolationIsEnabled()) {
            // All package specific paths will be in app's mount namespace, and it cannot
            // access its parent to check .nomedia file.
            expectNoMediaFileExists = false;
        }
        for (File file : getAllPackageSpecificPathsExceptMedia(getContext())) {
            deleteContents(file);
        }
        final List<File> paths = getAllPackageSpecificPathsExceptMedia(getContext());

        for (File path : paths) {
            MediaStore.scanFile(getContext().getContentResolver(), path);
        }

        // Require that .nomedia was created somewhere above each dir
        for (File path : paths) {
            assertNotNull(""Valid media must be inserted during CTS"", path);
            assertEquals(""Valid media must be inserted during CTS"", Environment.MEDIA_MOUNTED,
                    Environment.getExternalStorageState(path));

            final File start = path;

            boolean found = false;
            while (Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState(path))) {
                final File test = new File(path, "".nomedia"");
                if (test.exists()) {
                    found = true;
                    break;
                }
                path = path.getParentFile();
            }

            if (expectNoMediaFileExists && !found) {
                fail(""Missing .nomedia file above package-specific directory "" + start
                        + ""; gave up at "" + path);
            } else if (!expectNoMediaFileExists && found) {
                fail("".nomedia file should not be exists due to app data isolation, but found "" +
                    "" in package-specific directory "" + start + ""; gave up at "" + path);
            }
        }
    }

    /**
     * Secondary external storage mount points must always be read-only (unless mounted), per
     * CDD, <em>except</em> for the package specific directories tested by
     * {@link CommonExternalStorageTest#testAllPackageDirsWritable()}.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.security.cts.CVE_2020_0018"	"testPocCVE_2020_0018"	"CtsSecurityBulletinHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/securitybulletin/src/android/security/cts/CVE_2020_0018.java"	""	"@AsbSecurityTest(cveBugId = 139945049)
    public void testPocCVE_2020_0018() throws Exception {
        ITestDevice device = getDevice();
        String debuggable = device.getProperty(""ro.debuggable"").trim();

        /* If ro.debuggable is 1, KeyEvent info can be disclosed, and no need to check  */
        /* If ro.debuggable is 0, KeyEvent info should not be disclosed                 */
        /* The vulnerability is KeyEvent info is disclosed even if ro.debuggable is 0   */
        assumeThat(""The debugger needs to be disabled for this vulnerability.""+
                    ""Skipping the test since ro.debuggable is enabled"", debuggable, is(""0""));

        /* Simulate MotionEvent */
        device.executeShellCommand(""input tap 0 0"");

        /* Simulate KeyEvent */
        device.executeShellCommand(""input keyboard text \""f\"""");

        String cmdOut = device.executeShellCommand(""dumpsys input | grep -A 10 RecentQueue "");
        Scanner scanResult = new Scanner(cmdOut).useDelimiter(""\\n+"");
        while (scanResult.hasNext()) {
            String eventEntry = scanResult.nextLine();
            if (eventEntry.contains(""MotionEvent"") || eventEntry.contains(""KeyEvent"")) {
                assertThat(""MotionEvent/ KeyEvent info leaked in dumpsys!"", eventEntry,
                           not(containsString(""deviceId"")));
            }
        }
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.appwidget.cts.AppWidgetTest"	"testInstantAppsCannotProvideAppWidgets"	"CtsAppWidgetTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/appwidget/src/android/appwidget/cts/AppWidgetTest.java"	""	"public void testInstantAppsCannotProvideAppWidgets() {
        Assume.assumeTrue(getInstrumentation().getTargetContext()
                .getPackageManager().isInstantApp());
        assertNull(getFirstAppWidgetProviderInfo());
    }

    @AppModeInstant(reason = ""Instant apps cannot provide or host app widgets"")"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.appwidget.cts.AppWidgetTest"	"testInstantAppsCannotHostAppWidgets"	"CtsAppWidgetTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/appwidget/src/android/appwidget/cts/AppWidgetTest.java"	""	"public void testInstantAppsCannotHostAppWidgets() {
        Assume.assumeTrue(getInstrumentation().getTargetContext()
                .getPackageManager().isInstantApp());
        // Create a host and start listening.
        AppWidgetHost host = new AppWidgetHost(getInstrumentation().getTargetContext(), 0);
        // Allocate an app widget id to bind.
        assertSame(AppWidgetManager.INVALID_APPWIDGET_ID, host.allocateAppWidgetId());
    }

    @AppModeFull(reason = ""Instant apps cannot provide or host app widgets"")"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.carrierapi.cts.NetworkScanApiTest"	"werePreconditionsSatisfied"	"CtsCarrierApiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/carrierapi/src/android/carrierapi/cts/NetworkScanApiTest.java"	""	"/*
 *.
 */
package android.carrierapi.cts;

import static android.Manifest.permission.ACCESS_BACKGROUND_LOCATION;
import static android.Manifest.permission.ACCESS_FINE_LOCATION;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import static org.junit.Assert.fail;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.location.LocationManager;
import android.os.AsyncTask;
import android.os.Handler;
import android.os.HandlerThread;
import android.os.Message;
import android.os.Parcel;
import android.os.Process;
import android.os.UserHandle;
import android.telephony.AccessNetworkConstants;
import android.telephony.CellInfo;
import android.telephony.CellInfoGsm;
import android.telephony.CellInfoLte;
import android.telephony.CellInfoWcdma;
import android.telephony.NetworkScan;
import android.telephony.NetworkScanRequest;
import android.telephony.RadioAccessSpecifier;
import android.telephony.TelephonyManager;
import android.telephony.TelephonyScanManager;
import android.util.Log;

import androidx.test.InstrumentationRegistry;
import androidx.test.runner.AndroidJUnit4;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

/**
 * Unit tests for {@link TelephonyManager}'s network scan APIs.
 *
 * <p>Test using `atest CtsCarrierApiTestCases:NetworkScanApiTest` or `make cts -j64 && cts-tradefed
 * run cts -m CtsCarrierApiTestCases --test android.carrierapi.cts.NetworkScanApiTest`
 */
@RunWith(AndroidJUnit4.class)
public class NetworkScanApiTest extends BaseCarrierApiTest {
    private static final String TAG = ""NetworkScanApiTest"";

    private TelephonyManager mTelephonyManager;
    private int mNetworkScanStatus;
    private static final int EVENT_NETWORK_SCAN_START = 100;
    private static final int EVENT_NETWORK_SCAN_RESULTS = 200;
    private static final int EVENT_NETWORK_SCAN_RESTRICTED_RESULTS = 201;
    private static final int EVENT_NETWORK_SCAN_ERROR = 300;
    private static final int EVENT_NETWORK_SCAN_COMPLETED = 400;
    private static final int EVENT_SCAN_DENIED = 500;
    private List<CellInfo> mScanResults = null;
    private NetworkScanHandlerThread mTestHandlerThread;
    private Handler mHandler;
    private NetworkScan mNetworkScan;
    private NetworkScanRequest mNetworkScanRequest;
    private NetworkScanCallbackImpl mNetworkScanCallback;
    private static final int LOCATION_SETTING_CHANGE_WAIT_MS = 1000;
    private static final int MAX_CELLINFO_WAIT_MILLIS = 5000; // 5 seconds
    private static final int SCAN_SEARCH_TIME_SECONDS = 60;
    // Wait one second longer than the max scan search time to give the test time to receive the
    // results.
    private static final int MAX_INIT_WAIT_MS = (SCAN_SEARCH_TIME_SECONDS + 1) * 1000;
    private Object mLock = new Object();
    private boolean mReady;
    private int mErrorCode;
    /* All the following constants are used to construct NetworkScanRequest*/
    private static final int SCAN_TYPE = NetworkScanRequest.SCAN_TYPE_ONE_SHOT;
    private static final boolean INCREMENTAL_RESULTS = true;
    private static final int SEARCH_PERIODICITY_SEC = 5;
    private static final int MAX_SEARCH_TIME_SEC = 300;
    private static final int INCREMENTAL_RESULTS_PERIODICITY_SEC = 3;
    private static final ArrayList<String> MCC_MNC = new ArrayList<>();
    private static final RadioAccessSpecifier[] RADIO_ACCESS_SPECIFIERS = {
        new RadioAccessSpecifier(
                AccessNetworkConstants.AccessNetworkType.GERAN,
                null /* bands */,
                null /* channels */),
        new RadioAccessSpecifier(
                AccessNetworkConstants.AccessNetworkType.EUTRAN,
                null /* bands */,
                null /* channels */),
        new RadioAccessSpecifier(
                AccessNetworkConstants.AccessNetworkType.UTRAN,
                null /* bands */,
                null /* channels */)
    };

    // Needed because NETWORK_SCAN_PERMISSION is a systemapi
    public static final String NETWORK_SCAN_PERMISSION = ""android.permission.NETWORK_SCAN"";

    @Before
    public void setUp() throws Exception {
        mTelephonyManager = getContext().getSystemService(TelephonyManager.class);
        String selfPackageName = getContext().getPackageName();
        InstrumentationRegistry.getInstrumentation()
                .getUiAutomation()
                .grantRuntimePermission(selfPackageName, ACCESS_FINE_LOCATION);
        InstrumentationRegistry.getInstrumentation()
                .getUiAutomation()
                .grantRuntimePermission(selfPackageName, ACCESS_BACKGROUND_LOCATION);
        mTestHandlerThread = new NetworkScanHandlerThread(TAG);
        mTestHandlerThread.start();
    }

    @After
    public void tearDown() throws Exception {
        if (!werePreconditionsSatisfied()) return;

        // Revoking runtime permissions makes ActivityManager kill our process, so we don't do it,
        // as the test harness will eventually uninstall this APK after testing completes anyway, so
        // we aren't really leaking anything long-term.
        mTestHandlerThread.quit();
    }

    private void waitUntilReady() {
        synchronized (mLock) {
            try {
                mLock.wait(MAX_INIT_WAIT_MS);
            } catch (InterruptedException ie) {
            }

            assertWithMessage(""NetworkScanApiTest failed to initialize"").that(mReady).isTrue();
        }
    }

    private void setReady(boolean ready) {
        synchronized (mLock) {
            mReady = ready;
            mLock.notifyAll();
        }
    }

    private class NetworkScanHandlerThread extends HandlerThread {

        public NetworkScanHandlerThread(String name) {
            super(name);
        }

        @Override
        public void onLooperPrepared() {
            /* create a custom handler for the Handler Thread */
            mHandler =
                    new Handler(mTestHandlerThread.getLooper()) {
                        @Override
                        public void handleMessage(Message msg) {
                            switch (msg.what) {
                                case EVENT_NETWORK_SCAN_START:
                                    Log.d(TAG, ""request network scan"");
                                    boolean useShellIdentity = (Boolean) msg.obj;
                                    if (useShellIdentity) {
                                        InstrumentationRegistry.getInstrumentation()
                                                .getUiAutomation()
                                                .adoptShellPermissionIdentity();
                                    }
                                    try {
                                        mNetworkScan =
                                                mTelephonyManager.requestNetworkScan(
                                                        mNetworkScanRequest,
                                                        AsyncTask.SERIAL_EXECUTOR,
                                                        mNetworkScanCallback);
                                        if (mNetworkScan == null) {
                                            mNetworkScanStatus = EVENT_SCAN_DENIED;
                                            setReady(true);
                                        }
                                    } catch (SecurityException e) {
                                        mNetworkScanStatus = EVENT_SCAN_DENIED;
                                        setReady(true);
                                    } finally {
                                        if (useShellIdentity) {
                                            InstrumentationRegistry.getInstrumentation()
                                                    .getUiAutomation()
                                                    .dropShellPermissionIdentity();
                                        }
                                    }
                                    break;
                                default:
                                    Log.d(TAG, ""Unknown Event "" + msg.what);
                            }
                        }
                    };
        }
    }

    private class NetworkScanCallbackImpl extends TelephonyScanManager.NetworkScanCallback {
        @Override
        public void onResults(List<CellInfo> results) {
            Log.d(TAG, ""onResults: "" + results.toString());
            mNetworkScanStatus = EVENT_NETWORK_SCAN_RESULTS;
            mScanResults = results;
        }

        @Override
        public void onComplete() {
            Log.d(TAG, ""onComplete"");
            mNetworkScanStatus = EVENT_NETWORK_SCAN_COMPLETED;
            setReady(true);
        }

        @Override
        public void onError(int error) {
            Log.d(TAG, ""onError: "" + String.valueOf(error));
            mNetworkScanStatus = EVENT_NETWORK_SCAN_ERROR;
            mErrorCode = error;
            setReady(true);
        }
    }

    private class CellInfoResultsCallback extends TelephonyManager.CellInfoCallback {
        public List<CellInfo> cellInfo;

        @Override
        public synchronized void onCellInfo(List<CellInfo> cellInfo) {
            this.cellInfo = cellInfo;
            notifyAll();
        }

        public synchronized void wait(int millis) throws InterruptedException {
            if (cellInfo == null) {
                super.wait(millis);
            }
        }
    }

    private List<RadioAccessSpecifier> getRadioAccessSpecifier(List<CellInfo> allCellInfo) {
        List<RadioAccessSpecifier> radioAccessSpecifier = new ArrayList<>();
        List<Integer> lteChannels = new ArrayList<>();
        List<Integer> wcdmaChannels = new ArrayList<>();
        List<Integer> gsmChannels = new ArrayList<>();
        for (int i = 0; i < allCellInfo.size(); i++) {
            CellInfo cellInfo = allCellInfo.get(i);
            if (cellInfo instanceof CellInfoLte) {
                lteChannels.add(((CellInfoLte) cellInfo).getCellIdentity().getEarfcn());
            } else if (cellInfo instanceof CellInfoWcdma) {
                wcdmaChannels.add(((CellInfoWcdma) cellInfo).getCellIdentity().getUarfcn());
            } else if (cellInfo instanceof CellInfoGsm) {
                gsmChannels.add(((CellInfoGsm) cellInfo).getCellIdentity().getArfcn());
            }
        }
        if (!lteChannels.isEmpty()) {
            Log.d(TAG, ""lte channels"" + lteChannels.toString());
            int ranLte = AccessNetworkConstants.AccessNetworkType.EUTRAN;
            radioAccessSpecifier.add(
                    new RadioAccessSpecifier(
                            ranLte,
                            null /* bands */,
                            lteChannels.stream().mapToInt(i -> i).toArray()));
        }
        if (!wcdmaChannels.isEmpty()) {
            Log.d(TAG, ""wcdma channels"" + wcdmaChannels.toString());
            int ranWcdma = AccessNetworkConstants.AccessNetworkType.UTRAN;
            radioAccessSpecifier.add(
                    new RadioAccessSpecifier(
                            ranWcdma,
                            null /* bands */,
                            wcdmaChannels.stream().mapToInt(i -> i).toArray()));
        }
        if (!gsmChannels.isEmpty()) {
            Log.d(TAG, ""gsm channels"" + gsmChannels.toString());
            int ranGsm = AccessNetworkConstants.AccessNetworkType.GERAN;
            radioAccessSpecifier.add(
                    new RadioAccessSpecifier(
                            ranGsm,
                            null /* bands */,
                            gsmChannels.stream().mapToInt(i -> i).toArray()));
        }
        return radioAccessSpecifier;
    }

    /** Tests that the device properly requests a network scan. */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.carrierapi.cts.NetworkScanApiTest"	"testRequestNetworkScan"	"CtsCarrierApiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/carrierapi/src/android/carrierapi/cts/NetworkScanApiTest.java"	""	"public void testRequestNetworkScan() {
        boolean isLocationSwitchOn = getAndSetLocationSwitch(true);
        try {
            mNetworkScanRequest = buildNetworkScanRequest(true);
            mNetworkScanCallback = new NetworkScanCallbackImpl();
            Message startNetworkScan = mHandler.obtainMessage(EVENT_NETWORK_SCAN_START, false);
            setReady(false);
            startNetworkScan.sendToTarget();
            waitUntilReady();

            Log.d(TAG, ""mNetworkScanStatus: "" + mNetworkScanStatus);
            assertWithMessage(
                            ""The final scan status is ""
                                    + mNetworkScanStatus
                                    + "" with error code ""
                                    + mErrorCode
                                    + "", not ScanCompleted""
                                    + "" or ScanError with an error code ERROR_MODEM_UNAVAILABLE or""
                                    + "" ERROR_UNSUPPORTED"")
                    .that(isScanStatusValid())
                    .isTrue();
        } finally {
            getAndSetLocationSwitch(isLocationSwitchOn);
        }
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.carrierapi.cts.NetworkScanApiTest"	"testRequestNetworkScanLocationOffPass"	"CtsCarrierApiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/carrierapi/src/android/carrierapi/cts/NetworkScanApiTest.java"	""	"public void testRequestNetworkScanLocationOffPass() {
        requestNetworkScanLocationOffHelper(false, true);
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.carrierapi.cts.NetworkScanApiTest"	"testRequestNetworkScanLocationOffFail"	"CtsCarrierApiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/carrierapi/src/android/carrierapi/cts/NetworkScanApiTest.java"	""	"public void testRequestNetworkScanLocationOffFail() {
        requestNetworkScanLocationOffHelper(true, true);
    }

    public void requestNetworkScanLocationOffHelper(
            boolean includeBandsAndChannels, boolean useSpecialScanPermission) {
        mNetworkScanRequest = buildNetworkScanRequest(includeBandsAndChannels);

        boolean isLocationSwitchOn = getAndSetLocationSwitch(false);
        try {
            mNetworkScanCallback = new NetworkScanCallbackImpl();
            Message startNetworkScan =
                    mHandler.obtainMessage(EVENT_NETWORK_SCAN_START, useSpecialScanPermission);
            setReady(false);
            startNetworkScan.sendToTarget();
            waitUntilReady();
            if (includeBandsAndChannels) {
                // If we included the bands when location is off, expect a security error and
                // nothing else.
                assertThat(mNetworkScanStatus).isEqualTo(EVENT_SCAN_DENIED);
                return;
            }

            Log.d(TAG, ""mNetworkScanStatus: "" + mNetworkScanStatus);
            assertWithMessage(
                            ""The final scan status is ""
                                    + mNetworkScanStatus
                                    + "" with error code ""
                                    + mErrorCode
                                    + "", not ScanCompleted""
                                    + "" or ScanError with an error code ERROR_MODEM_UNAVAILABLE or""
                                    + "" ERROR_UNSUPPORTED"")
                    .that(isScanStatusValid())
                    .isTrue();
        } finally {
            getAndSetLocationSwitch(isLocationSwitchOn);
        }
    }

    private NetworkScanRequest buildNetworkScanRequest(boolean includeBandsAndChannels) {
        // Make sure that there should be at least one entry.
        List<CellInfo> allCellInfo = getCellInfo();
        List<RadioAccessSpecifier> radioAccessSpecifier = new ArrayList<>();

        if (allCellInfo != null && allCellInfo.size() != 0) {
            // Construct a NetworkScanRequest
            radioAccessSpecifier = getRadioAccessSpecifier(allCellInfo);
            if (!includeBandsAndChannels) {
                radioAccessSpecifier =
                        radioAccessSpecifier.stream()
                                .map(
                                        spec ->
                                                new RadioAccessSpecifier(
                                                        spec.getRadioAccessNetwork(), null, null))
                                .collect(Collectors.toList());
            }
        }

        Log.d(TAG, ""number of radioAccessSpecifier: "" + radioAccessSpecifier.size());
        if (radioAccessSpecifier.isEmpty()) {
            // Put in some arbitrary bands and channels so that we trip the location check if needed
            int[] fakeBands =
                    includeBandsAndChannels
                            ? new int[] {AccessNetworkConstants.EutranBand.BAND_5}
                            : null;
            int[] fakeChannels = includeBandsAndChannels ? new int[] {2400} : null;

            RadioAccessSpecifier gsm =
                    new RadioAccessSpecifier(
                            AccessNetworkConstants.AccessNetworkType.GERAN,
                            null /* bands */,
                            null /* channels */);
            RadioAccessSpecifier lte =
                    new RadioAccessSpecifier(
                            AccessNetworkConstants.AccessNetworkType.EUTRAN,
                            fakeBands /* bands */,
                            fakeChannels /* channels */);
            RadioAccessSpecifier wcdma =
                    new RadioAccessSpecifier(
                            AccessNetworkConstants.AccessNetworkType.UTRAN,
                            null /* bands */,
                            null /* channels */);
            radioAccessSpecifier.add(gsm);
            radioAccessSpecifier.add(lte);
            radioAccessSpecifier.add(wcdma);
        }
        RadioAccessSpecifier[] radioAccessSpecifierArray =
                new RadioAccessSpecifier[radioAccessSpecifier.size()];
        return new NetworkScanRequest(
                NetworkScanRequest.SCAN_TYPE_ONE_SHOT /* scan type */,
                radioAccessSpecifier.toArray(radioAccessSpecifierArray),
                5 /* search periodicity */,
                SCAN_SEARCH_TIME_SECONDS /* max search time */,
                true /*enable incremental results*/,
                5 /* incremental results periodicity */,
                null /* List of PLMN ids (MCC-MNC) */);
    }

    private List<CellInfo> getCellInfo() {
        CellInfoResultsCallback resultsCallback = new CellInfoResultsCallback();
        mTelephonyManager.requestCellInfoUpdate(r -> r.run(), resultsCallback);
        try {
            resultsCallback.wait(MAX_CELLINFO_WAIT_MILLIS);
        } catch (InterruptedException ex) {
            fail(""CellInfoCallback was interrupted: "" + ex);
        }
        return resultsCallback.cellInfo;
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.carrierapi.cts.NetworkScanApiTest"	"testNetworkScanPermission"	"CtsCarrierApiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/carrierapi/src/android/carrierapi/cts/NetworkScanApiTest.java"	""	"public void testNetworkScanPermission() {
        PackageManager pm = getContext().getPackageManager();

        List<Integer> specialUids =
                Arrays.asList(Process.SYSTEM_UID, Process.PHONE_UID, Process.SHELL_UID);

        List<PackageInfo> holding =
                pm.getPackagesHoldingPermissions(
                        new String[] {NETWORK_SCAN_PERMISSION},
                        PackageManager.MATCH_DISABLED_COMPONENTS);

        List<Integer> nonSpecialPackages =
                holding.stream()
                        .map(
                                pi -> {
                                    try {
                                        return pm.getPackageUid(pi.packageName, 0);
                                    } catch (PackageManager.NameNotFoundException e) {
                                        return Process.INVALID_UID;
                                    }
                                })
                        .filter(uid -> !specialUids.contains(UserHandle.getAppId(uid)))
                        .collect(Collectors.toList());

        assertWithMessage(
                        ""Only one app on the device is allowed to hold the NETWORK_SCAN""
                                + "" permission."")
                .that(nonSpecialPackages.size())
                .isAtMost(1);
    }

    private boolean getAndSetLocationSwitch(boolean enabled) {
        CountDownLatch locationChangeLatch = new CountDownLatch(1);
        BroadcastReceiver locationModeChangeReceiver = new BroadcastReceiver() {
            @Override
            public void onReceive(Context context, Intent intent) {
                if (LocationManager.MODE_CHANGED_ACTION.equals(intent.getAction())
                        && intent.getBooleanExtra(LocationManager.EXTRA_LOCATION_ENABLED, !enabled)
                        == enabled) {
                    locationChangeLatch.countDown();
                }
            }
        };

        InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .adoptShellPermissionIdentity();
        try {
            Context context = InstrumentationRegistry.getContext();
            LocationManager lm = context.getSystemService(
                    LocationManager.class);
            boolean oldLocationOn = lm.isLocationEnabledForUser(
                    UserHandle.of(UserHandle.myUserId()));

            if (enabled != oldLocationOn) {
                context.registerReceiver(locationModeChangeReceiver,
                        new IntentFilter(LocationManager.MODE_CHANGED_ACTION));
                lm.setLocationEnabledForUser(enabled, UserHandle.of(UserHandle.myUserId()));
                try {
                    assertThat(locationChangeLatch.await(LOCATION_SETTING_CHANGE_WAIT_MS,
                            TimeUnit.MILLISECONDS)).isTrue();
                } catch (InterruptedException e) {
                    Log.w(NetworkScanApiTest.class.getSimpleName(),
                            ""Interrupted while waiting for location settings change. Test results""
                                    + "" may not be accurate."");
                } finally {
                    context.unregisterReceiver(locationModeChangeReceiver);
                }
            }
            return oldLocationOn;
        } finally {
            InstrumentationRegistry.getInstrumentation().getUiAutomation()
                    .dropShellPermissionIdentity();
        }
    }

    private boolean isScanStatusValid() {
        // TODO(b/72162885): test the size of ScanResults is not zero after the blocking bug fixed.
        if ((mNetworkScanStatus == EVENT_NETWORK_SCAN_COMPLETED) && (mScanResults != null)) {
            // Scan complete.
            return true;
        }
        if ((mNetworkScanStatus == EVENT_NETWORK_SCAN_ERROR)
                && ((mErrorCode == NetworkScan.ERROR_MODEM_UNAVAILABLE)
                        || (mErrorCode == NetworkScan.ERROR_UNSUPPORTED))) {
            // Scan error but the error type is allowed.
            return true;
        }
        return false;
    }

    private ArrayList<String> getPlmns() {
        ArrayList<String> mccMncs = new ArrayList<>();
        mccMncs.add(""310260"");
        mccMncs.add(""310120"");
        return mccMncs;
    }

    /** To test its constructor and getters. */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.carrierapi.cts.NetworkScanApiTest"	"testNetworkScanRequest_constructorAndGetters"	"CtsCarrierApiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/carrierapi/src/android/carrierapi/cts/NetworkScanApiTest.java"	""	"public void testNetworkScanRequest_constructorAndGetters() {
        NetworkScanRequest networkScanRequest =
                new NetworkScanRequest(
                        SCAN_TYPE,
                        RADIO_ACCESS_SPECIFIERS,
                        SEARCH_PERIODICITY_SEC,
                        MAX_SEARCH_TIME_SEC,
                        INCREMENTAL_RESULTS,
                        INCREMENTAL_RESULTS_PERIODICITY_SEC,
                        getPlmns());

        assertWithMessage(""getScanType() returns wrong value"")
                .that(networkScanRequest.getScanType())
                .isEqualTo(SCAN_TYPE);
        assertWithMessage(""getSpecifiers() returns wrong value"")
                .that(networkScanRequest.getSpecifiers())
                .isEqualTo(RADIO_ACCESS_SPECIFIERS);
        assertWithMessage(""getSearchPeriodicity() returns wrong value"")
                .that(networkScanRequest.getSearchPeriodicity())
                .isEqualTo(SEARCH_PERIODICITY_SEC);
        assertWithMessage(""getMaxSearchTime() returns wrong value"")
                .that(networkScanRequest.getMaxSearchTime())
                .isEqualTo(MAX_SEARCH_TIME_SEC);
        assertWithMessage(""getIncrementalResults() returns wrong value"")
                .that(networkScanRequest.getIncrementalResults())
                .isEqualTo(INCREMENTAL_RESULTS);
        assertWithMessage(""getIncrementalResultsPeriodicity() returns wrong value"")
                .that(networkScanRequest.getIncrementalResultsPeriodicity())
                .isEqualTo(INCREMENTAL_RESULTS_PERIODICITY_SEC);
        assertWithMessage(""getPlmns() returns wrong value"")
                .that(networkScanRequest.getPlmns())
                .isEqualTo(getPlmns());
        assertWithMessage(""describeContents() returns wrong value"")
                .that(networkScanRequest.describeContents())
                .isEqualTo(0);
    }

    /** To test its hashCode method. */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.carrierapi.cts.NetworkScanApiTest"	"testNetworkScanRequestParcel_hashCode"	"CtsCarrierApiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/carrierapi/src/android/carrierapi/cts/NetworkScanApiTest.java"	""	"public void testNetworkScanRequestParcel_hashCode() {
        NetworkScanRequest networkScanRequest1 =
                new NetworkScanRequest(
                        SCAN_TYPE,
                        RADIO_ACCESS_SPECIFIERS,
                        SEARCH_PERIODICITY_SEC,
                        MAX_SEARCH_TIME_SEC,
                        INCREMENTAL_RESULTS,
                        INCREMENTAL_RESULTS_PERIODICITY_SEC,
                        getPlmns());

        NetworkScanRequest networkScanRequest2 =
                new NetworkScanRequest(
                        SCAN_TYPE,
                        RADIO_ACCESS_SPECIFIERS,
                        SEARCH_PERIODICITY_SEC,
                        MAX_SEARCH_TIME_SEC,
                        INCREMENTAL_RESULTS,
                        INCREMENTAL_RESULTS_PERIODICITY_SEC,
                        getPlmns());

        NetworkScanRequest networkScanRequest3 =
                new NetworkScanRequest(
                        SCAN_TYPE,
                        null,
                        SEARCH_PERIODICITY_SEC,
                        MAX_SEARCH_TIME_SEC,
                        false,
                        0,
                        getPlmns());

        assertWithMessage(""hashCode() returns different hash code for same objects"")
                .that(networkScanRequest1.hashCode())
                .isEqualTo(networkScanRequest2.hashCode());
        assertWithMessage(""hashCode() returns same hash code for different objects"")
                .that(networkScanRequest1.hashCode())
                .isNotEqualTo(networkScanRequest3.hashCode());
    }

    /** To test its comparison method. */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.carrierapi.cts.NetworkScanApiTest"	"testNetworkScanRequestParcel_equals"	"CtsCarrierApiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/carrierapi/src/android/carrierapi/cts/NetworkScanApiTest.java"	""	"public void testNetworkScanRequestParcel_equals() {
        NetworkScanRequest networkScanRequest1 =
                new NetworkScanRequest(
                        SCAN_TYPE,
                        RADIO_ACCESS_SPECIFIERS,
                        SEARCH_PERIODICITY_SEC,
                        MAX_SEARCH_TIME_SEC,
                        INCREMENTAL_RESULTS,
                        INCREMENTAL_RESULTS_PERIODICITY_SEC,
                        getPlmns());

        NetworkScanRequest networkScanRequest2 =
                new NetworkScanRequest(
                        SCAN_TYPE,
                        RADIO_ACCESS_SPECIFIERS,
                        SEARCH_PERIODICITY_SEC,
                        MAX_SEARCH_TIME_SEC,
                        INCREMENTAL_RESULTS,
                        INCREMENTAL_RESULTS_PERIODICITY_SEC,
                        getPlmns());

        assertThat(networkScanRequest1).isEqualTo(networkScanRequest2);

        networkScanRequest2 =
                new NetworkScanRequest(
                        SCAN_TYPE,
                        RADIO_ACCESS_SPECIFIERS,
                        SEARCH_PERIODICITY_SEC,
                        MAX_SEARCH_TIME_SEC,
                        INCREMENTAL_RESULTS,
                        INCREMENTAL_RESULTS_PERIODICITY_SEC,
                        null /* List of PLMN ids (MCC-MNC) */);
        assertThat(networkScanRequest1).isNotEqualTo(networkScanRequest2);
    }

    /** To test its writeToParcel and createFromParcel methods. */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.carrierapi.cts.NetworkScanApiTest"	"testNetworkScanRequestParcel_parcel"	"CtsCarrierApiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/carrierapi/src/android/carrierapi/cts/NetworkScanApiTest.java"	""	"public void testNetworkScanRequestParcel_parcel() {
        NetworkScanRequest networkScanRequest =
                new NetworkScanRequest(
                        SCAN_TYPE,
                        null /* Radio Access Specifier */,
                        SEARCH_PERIODICITY_SEC,
                        MAX_SEARCH_TIME_SEC,
                        INCREMENTAL_RESULTS,
                        INCREMENTAL_RESULTS_PERIODICITY_SEC,
                        getPlmns());

        Parcel p = Parcel.obtain();
        networkScanRequest.writeToParcel(p, 0);
        p.setDataPosition(0);
        NetworkScanRequest newnsr = NetworkScanRequest.CREATOR.createFromParcel(p);
        assertThat(networkScanRequest).isEqualTo(newnsr);
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.content.cts.ContentProviderClientTest"	"isCanceled"	"CtsContentTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContentProviderClientTest.java"	""	"public void test/*
 *.
 */

package android.content.cts;

import static org.mockito.Mockito.doAnswer;
import static org.mockito.Mockito.doReturn;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.spy;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.RETURNS_DEFAULTS;

import android.content.AttributionSource;
import android.content.ContentProvider;
import android.content.ContentProviderClient;
import android.content.ContentProviderOperation;
import android.content.ContentResolver;
import android.content.ContentValues;
import android.content.Context;
import android.content.ContextParams;
import android.content.IContentProvider;
import android.content.OperationApplicationException;
import android.net.Uri;
import android.os.Bundle;
import android.os.CancellationSignal;
import android.os.ICancellationSignal;
import android.os.OperationCanceledException;
import android.os.Process;
import android.os.RemoteException;
import android.test.AndroidTestCase;
import android.test.mock.MockContentResolver;

import org.mockito.stubbing.Answer;

import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

/**
 * Simple delegation test for {@link ContentProviderClient}, checking the right methods are called.
 * Actual {@link ContentProvider} functionality is tested in {@link ContentProviderTest}.
 */
public class ContentProviderClientTest extends AndroidTestCase {

    private static final Answer ANSWER_SLEEP = invocation -> {
        // Sleep long enough to trigger ANR
        Thread.sleep(100);
        return null;
    };

    private static final String PACKAGE_NAME = ""android.content.cts"";
    private static final String FEATURE_ID = ""testFeature"";
    private static final String MODE = ""mode"";
    private static final String AUTHORITY = ""authority"";
    private static final String METHOD = ""method"";
    private static final String ARG = ""arg"";
    private static final Uri URI = Uri.parse(""com.example.app://path"");
    private static final Bundle ARGS = new Bundle();
    private static final Bundle EXTRAS = new Bundle();
    private static final ContentValues VALUES = new ContentValues();
    private static final ContentValues[] VALUES_ARRAY = {VALUES};
    private static final ArrayList<ContentProviderOperation> OPS = new ArrayList<>();

    private ContentResolver mContentResolver;
    private IContentProvider mIContentProvider;
    private ContentProviderClient mContentProviderClient;
    private AttributionSource mAttributionSource;

    private CancellationSignal mCancellationSignal = new CancellationSignal();
    private ICancellationSignal mICancellationSignal;
    private boolean mCalledCancel = false;

    @Override
    public void setUp() throws Exception {
        super.setUp();

        mIContentProvider = mock(IContentProvider.class, RETURNS_DEFAULTS);
        mICancellationSignal = mock(ICancellationSignal.class);

        doReturn(mICancellationSignal).when(mIContentProvider).createCancellationSignal();

        final Context attributionContext = getContext().createContext(
                new ContextParams.Builder()
                        .setAttributionTag(FEATURE_ID)
                        .build());

        mAttributionSource = attributionContext.getAttributionSource();
        mContentResolver = spy(new MockContentResolver(attributionContext));
        mContentProviderClient = spy(new ContentProviderClient(mContentResolver, mIContentProvider,
                false));

        mCalledCancel = false;
    }

    @Override
    protected void tearDown() throws Exception {
        super.tearDown();
        if (!mCalledCancel) {
            // Client should never cancel unless the test called cancel
            assertFalse(mCancellationSignal.isCanceled());
            verify(mICancellationSignal, never()).cancel();
        }
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.net.wifi.nl80211.cts.WifiNl80211ManagerTest"	"testOemSecurityTypeConstructor"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/nl80211/cts/WifiNl80211ManagerTest.java"	""	"public void testOemSecurityTypeConstructor() {
        OemSecurityType securityType = new OemSecurityType(
                ScanResult.PROTOCOL_WPA,
                Arrays.asList(ScanResult.KEY_MGMT_PSK, ScanResult.KEY_MGMT_SAE),
                Arrays.asList(ScanResult.CIPHER_NONE, ScanResult.CIPHER_TKIP),
                ScanResult.CIPHER_CCMP);

        assertThat(securityType.protocol).isEqualTo(ScanResult.PROTOCOL_WPA);
        assertThat(securityType.keyManagement)
                .isEqualTo(Arrays.asList(ScanResult.KEY_MGMT_PSK, ScanResult.KEY_MGMT_SAE));
        assertThat(securityType.pairwiseCipher)
                .isEqualTo(Arrays.asList(ScanResult.CIPHER_NONE, ScanResult.CIPHER_TKIP));
        assertThat(securityType.groupCipher).isEqualTo(ScanResult.CIPHER_CCMP);
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.tagging.TaggingSdk30Test"	"testMemoryTagChecksCompatFeatureDisabled"	"CtsTaggingHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/tagging/src/com/android/cts/tagging/TaggingSdk30Test.java"	""	"public void testMemoryTagChecksCompatFeatureDisabled() throws Exception {
        if (!deviceSupportsMemoryTagging) {
            return;
        }
        runDeviceCompatTest(TEST_PKG, "".TaggingTest"", ""testMemoryTagChecksDisabled"",
                /*enabledChanges*/ ImmutableSet.of(),
                /*disabledChanges*/
                ImmutableSet.of(NATIVE_MEMTAG_SYNC_CHANGE_ID, NATIVE_MEMTAG_ASYNC_CHANGE_ID));
    }

    // Ensure that enabling MTE on non-MTE hardware is a no-op. Note - No statsd report for
    // NATIVE_HEAP_POINTER_TAGGING_CHANGE_ID. The fallback for an app that requests MTE on non-MTE
    // hardware is an implicit TBI. Compat is never probed for the status of the heap pointer
    // tagging feature in this instance."	""	""	"probe"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.tagging.TaggingSdk30Test"	"testMemoryTagChecksCompatFeatureEnabledNonMTE"	"CtsTaggingHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/tagging/src/com/android/cts/tagging/TaggingSdk30Test.java"	""	"public void testMemoryTagChecksCompatFeatureEnabledNonMTE() throws Exception {
        if (deviceSupportsMemoryTagging) {
            return;
        }
        // Tagged Pointers should still be used if the kernel/HW supports it.
        runDeviceCompatTestReported(TEST_PKG, "".TaggingTest"", testForWhenSoftwareWantsTagging,
                /*enabledChanges*/ ImmutableSet.of(NATIVE_MEMTAG_ASYNC_CHANGE_ID),
                /*disabledChanges*/ ImmutableSet.of(),
                // Don't check statsd report for NATIVE_MEMTAG_ASYNC_CHANGE_ID, as on non-aarch64
                // we never probed compat for this feature.
                /*reportedEnabledChanges*/ ImmutableSet.of(),
                /*reportedDisabledChanges*/ ImmutableSet.of());
    }

    // Ensure that disabling MTE on non-MTE hardware is a no-op."	""	""	"probe"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.hardware.camera2.cts.CameraDeviceTest"	"testSessionParametersStateLeak"	"CtsCameraTestCases"	"/home/gpoor/cts-12-source/cts/tests/camera/src/android/hardware/camera2/cts/CameraDeviceTest.java"	""	"public void testSessionParametersStateLeak() throws Exception {
        for (int i = 0; i < mCameraIdsUnderTest.length; i++) {
            try {
                if (!mAllStaticInfo.get(mCameraIdsUnderTest[i]).isColorOutputSupported()) {
                    Log.i(TAG, ""Camera "" + mCameraIdsUnderTest[i] +
                            "" does not support color outputs, skipping"");
                    continue;
                }
                openDevice(mCameraIdsUnderTest[i], mCameraMockListener);
                waitForDeviceState(STATE_OPENED, CAMERA_OPEN_TIMEOUT_MS);

                testSessionParametersStateLeakByCamera(mCameraIdsUnderTest[i]);
            }
            finally {
                closeDevice(mCameraIdsUnderTest[i], mCameraMockListener);
            }
        }
    }

    /**
     * Check for any state leakage in case of internal re-configure
     */
    private void testSessionParametersStateLeakByCamera(String cameraId)
            throws Exception {
        int outputFormat = ImageFormat.YUV_420_888;
        Size outputSize = mOrderedPreviewSizes.get(0);

        CameraCharacteristics characteristics = mCameraManager.getCameraCharacteristics(cameraId);
        StreamConfigurationMap config = characteristics.get(
                CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);
        List <CaptureRequest.Key<?>> sessionKeys = characteristics.getAvailableSessionKeys();
        if (sessionKeys == null) {
            return;
        }

        if (config.isOutputSupportedFor(outputFormat)) {
            outputSize = config.getOutputSizes(outputFormat)[0];
        } else {
            return;
        }

        ImageReader imageReader = ImageReader.newInstance(outputSize.getWidth(),
                outputSize.getHeight(), outputFormat, /*maxImages*/3);

        class OnReadyCaptureStateCallback extends CameraCaptureSession.StateCallback {
            private ConditionVariable onReadyTriggeredCond = new ConditionVariable();
            private boolean onReadyTriggered = false;

            @Override
            public void onConfigured(CameraCaptureSession session) {
            }

            @Override
            public void onConfigureFailed(CameraCaptureSession session) {
            }

            @Override
            public synchronized void onReady(CameraCaptureSession session) {
                onReadyTriggered = true;
                onReadyTriggeredCond.open();
            }

            public void waitForOnReady(long timeout) {
                synchronized (this) {
                    if (onReadyTriggered) {
                        onReadyTriggered = false;
                        onReadyTriggeredCond.close();
                        return;
                    }
                }

                if (onReadyTriggeredCond.block(timeout)) {
                    synchronized (this) {
                        onReadyTriggered = false;
                        onReadyTriggeredCond.close();
                    }
                } else {
                    throw new TimeoutRuntimeException(""Unable to receive onReady after ""
                        + timeout + ""ms"");
                }
            }
        }

        OnReadyCaptureStateCallback sessionListener = new OnReadyCaptureStateCallback();

        try {
            mSessionMockListener = spy(new BlockingSessionCallback(sessionListener));
            mSessionWaiter = mSessionMockListener.getStateWaiter();
            List<OutputConfiguration> outputs = new ArrayList<>();
            outputs.add(new OutputConfiguration(imageReader.getSurface()));
            SessionConfiguration sessionConfig = new SessionConfiguration(
                    SessionConfiguration.SESSION_REGULAR, outputs,
                    new HandlerExecutor(mHandler), mSessionMockListener);

            CaptureRequest.Builder builder =
                    mCamera.createCaptureRequest(CameraDevice.TEMPLATE_STILL_CAPTURE);
            builder.addTarget(imageReader.getSurface());
            CaptureRequest request = builder.build();

            sessionConfig.setSessionParameters(request);
            mCamera.createCaptureSession(sessionConfig);

            mSession = mSessionMockListener.waitAndGetSession(SESSION_CONFIGURE_TIMEOUT_MS);
            sessionListener.waitForOnReady(SESSION_CONFIGURE_TIMEOUT_MS);

            SimpleCaptureCallback captureListener = new SimpleCaptureCallback();
            ImageDropperListener imageListener = new ImageDropperListener();
            imageReader.setOnImageAvailableListener(imageListener, mHandler);

            // To check the state leak condition, we need a capture request that has
            // at least one session pararameter value difference from the initial session
            // parameters configured above. Scan all available template types for the
            // required delta.
            CaptureRequest.Builder requestBuilder = null;
            ArrayList<CaptureRequest.Builder> builders = new ArrayList<CaptureRequest.Builder> ();
            if (mStaticInfo.isCapabilitySupported(
                        CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_MANUAL_SENSOR)) {
                builders.add(mCamera.createCaptureRequest(CameraDevice.TEMPLATE_MANUAL));
            }
            if (mStaticInfo.isCapabilitySupported(
                        CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_PRIVATE_REPROCESSING)
                    || mStaticInfo.isCapabilitySupported(
                        CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_YUV_REPROCESSING)) {
                builders.add(mCamera.createCaptureRequest(CameraDevice.TEMPLATE_ZERO_SHUTTER_LAG));
            }
            builders.add(mCamera.createCaptureRequest(CameraDevice.TEMPLATE_VIDEO_SNAPSHOT));
            builders.add(mCamera.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW));
            builders.add(mCamera.createCaptureRequest(CameraDevice.TEMPLATE_RECORD));
            for (CaptureRequest.Key<?> key : sessionKeys) {
                Object sessionValue = builder.get(key);
                for (CaptureRequest.Builder newBuilder : builders) {
                    Object currentValue = newBuilder.get(key);
                    if ((sessionValue == null) && (currentValue == null)) {
                        continue;
                    }

                    if (((sessionValue == null) && (currentValue != null)) ||
                            ((sessionValue != null) && (currentValue == null)) ||
                            (!sessionValue.equals(currentValue))) {
                        requestBuilder = newBuilder;
                        break;
                    }
                }

                if (requestBuilder != null) {
                    break;
                }
            }

            if (requestBuilder != null) {
                requestBuilder.addTarget(imageReader.getSurface());
                request = requestBuilder.build();
                mSession.setRepeatingRequest(request, captureListener, mHandler);
                try {
                    sessionListener.waitForOnReady(SESSION_CONFIGURE_TIMEOUT_MS);
                    fail(""Camera shouldn't switch to ready state when session parameters are "" +
                            ""modified"");
                } catch (TimeoutRuntimeException e) {
                    //expected
                }
            }
        } finally {
            imageReader.close();
            mSession.close();
        }
    }

    /**
     * Verify creating a session with additional parameters.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.view.cts.VerifyInputEventTest"	"testDeviceIdBecomesVirtualForInjectedKeys"	"CtsViewTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/view/src/android/view/cts/VerifyInputEventTest.java"	""	"public void testDeviceIdBecomesVirtualForInjectedKeys() {
        final long downTime = SystemClock.uptimeMillis();
        KeyEvent downEvent = new KeyEvent(downTime, downTime, KeyEvent.ACTION_DOWN,
                KeyEvent.KEYCODE_A, 0 /*repeat*/, 0 /*metaState*/,
                1/*deviceId*/, 0 /*scanCode*/);
        mAutomation.injectInputEvent(downEvent, true);
        KeyEvent received = waitForKey();
        assertEquals(INJECTED_EVENT_DEVICE_ID, received.getDeviceId());

        // This event can still be verified, however.
        VerifiedInputEvent verified = mInputManager.verifyInputEvent(received);
        assertEquals(INJECTED_EVENT_DEVICE_ID, verified.getDeviceId());

        // Send UP event for consistency
        KeyEvent upEvent = new KeyEvent(downTime, SystemClock.uptimeMillis(), KeyEvent.ACTION_UP,
                KeyEvent.KEYCODE_A, 0 /*repeat*/, 0 /*metaState*/,
                1/*deviceId*/, 0 /*scanCode*/);
        mAutomation.injectInputEvent(upEvent, true);
        waitForKey();
    }

    /**
     * Ensure that injected motion events that contain a real device id get injected as virtual
     * device events, to prevent misrepresentation of actual hardware.
     * The verified events should contain the virtual device id, which is consistent with what the
     * app receives.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.view.cts.VerifyInputEventTest"	"testDeviceIdBecomesVirtualForInjectedMotions"	"CtsViewTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/view/src/android/view/cts/VerifyInputEventTest.java"	""	"public void testDeviceIdBecomesVirtualForInjectedMotions() {
        final View view = mActivity.getWindow().getDecorView();
        final Point point = getViewCenterOnScreen(view);
        final long downTime = SystemClock.uptimeMillis();
        MotionEvent downEvent = MotionEvent.obtain(downTime, downTime, MotionEvent.ACTION_DOWN,
                point.x, point.y, 1 /*pressure*/, 1 /*size*/, 0 /*metaState*/,
                0 /*xPrecision*/, 0 /*yPrecision*/, 1 /*deviceId*/, 0 /*edgeFlags*/);
        mAutomation.injectInputEvent(downEvent, true);
        MotionEvent received = waitForMotion();
        assertEquals(INJECTED_EVENT_DEVICE_ID, received.getDeviceId());

        // This event can still be verified, however.
        VerifiedInputEvent verified = mInputManager.verifyInputEvent(received);
        assertEquals(INJECTED_EVENT_DEVICE_ID, verified.getDeviceId());

        // Send UP event for consistency
        MotionEvent upEvent = MotionEvent.obtain(downTime, SystemClock.uptimeMillis(),
                MotionEvent.ACTION_UP, point.x, point.y, 0 /*pressure*/, 1 /*size*/,
                0 /*metaState*/, 0 /*xPrecision*/, 0 /*yPrecision*/,
                1 /*deviceId*/, 0 /*edgeFlags*/);
        mAutomation.injectInputEvent(upEvent, true);
        waitForMotion();
    }

    private static Point getViewCenterOnScreen(View view) {
        final int[] location = new int[2];
        view.getLocationOnScreen(location);
        final int width = view.getWidth();
        final int height = view.getHeight();

        return new Point(location[0] + width / 2, location[1] + height / 2);
    }

    private KeyEvent waitForKey() {
        return mActivity.mKeyEvents.poll();
    }

    private MotionEvent waitForMotion() {
        return mActivity.mMotionEvents.poll();
    }

    private static void compareKeys(KeyEvent keyEvent, VerifiedInputEvent verified) {
        assertEquals(INJECTED_EVENT_DEVICE_ID, verified.getDeviceId());
        assertEquals(keyEvent.getEventTime() * NANOS_PER_MILLISECOND,
                verified.getEventTimeNanos());
        assertEquals(keyEvent.getSource(), verified.getSource());
        assertEquals(DEFAULT_DISPLAY, verified.getDisplayId());

        assertTrue(verified instanceof VerifiedKeyEvent);
        VerifiedKeyEvent verifiedKey = (VerifiedKeyEvent) verified;

        assertEquals(keyEvent.getAction(), verifiedKey.getAction());
        assertEquals(keyEvent.getDownTime() * NANOS_PER_MILLISECOND,
                verifiedKey.getDownTimeNanos());
        compareKeyFlags(keyEvent.getFlags(), verifiedKey);
        assertEquals(keyEvent.getKeyCode(), verifiedKey.getKeyCode());
        assertEquals(keyEvent.getScanCode(), verifiedKey.getScanCode());
        assertEquals(keyEvent.getMetaState(), verifiedKey.getMetaState());
        assertEquals(keyEvent.getRepeatCount(), verifiedKey.getRepeatCount());
    }

    private static void compareMotions(MotionEvent motionEvent, VerifiedInputEvent verified) {
        assertEquals(INJECTED_EVENT_DEVICE_ID, verified.getDeviceId());
        assertEquals(motionEvent.getEventTime() * NANOS_PER_MILLISECOND,
                verified.getEventTimeNanos());
        assertEquals(motionEvent.getSource(), verified.getSource());
        assertEquals(DEFAULT_DISPLAY, verified.getDisplayId());

        assertTrue(verified instanceof VerifiedMotionEvent);
        VerifiedMotionEvent verifiedMotion = (VerifiedMotionEvent) verified;

        assertEquals(motionEvent.getRawX(), verifiedMotion.getRawX(), STRICT_TOLERANCE);
        assertEquals(motionEvent.getRawY(), verifiedMotion.getRawY(), STRICT_TOLERANCE);
        assertEquals(motionEvent.getActionMasked(), verifiedMotion.getActionMasked());
        assertEquals(motionEvent.getDownTime() * NANOS_PER_MILLISECOND,
                verifiedMotion.getDownTimeNanos());
        compareMotionFlags(motionEvent.getFlags(), verifiedMotion);
        assertEquals(motionEvent.getMetaState(), verifiedMotion.getMetaState());
        assertEquals(motionEvent.getButtonState(), verifiedMotion.getButtonState());
    }

    private static void compareKeyFlags(int expectedFlags, VerifiedKeyEvent verified) {
        final List<Integer> verifiedKeyFlags = Arrays.asList(
                FLAG_CANCELED,
                KeyEvent.FLAG_IS_ACCESSIBILITY_EVENT);
        // Separately check the value of verifiable flags
        for (int flag : verifiedKeyFlags) {
            assertFlag(expectedFlags, flag, verified);
        }
        // All other flags should be null, because they are not verifiable
        for (int i = 0; i < Integer.SIZE; i++) {
            int flag = 1 << i;
            if (verifiedKeyFlags.contains(flag)) {
                continue;
            }
            assertNull(verified.getFlag(flag));
        }
    }

    private static void compareMotionFlags(int expectedFlags, VerifiedMotionEvent verified) {
        final List<Integer> verifiedMotionFlags = Arrays.asList(
                FLAG_WINDOW_IS_OBSCURED,
                FLAG_WINDOW_IS_PARTIALLY_OBSCURED,
                MotionEvent.FLAG_IS_ACCESSIBILITY_EVENT);
        // Separately check the value of verifiable flags
        for (int flag : verifiedMotionFlags) {
            assertFlag(expectedFlags, flag, verified);
        }
        // All other flags should be null, because they are not verifiable
        for (int i = 0; i < Integer.SIZE; i++) {
            int flag = 1 << i;
            if (verifiedMotionFlags.contains(flag)) {
                continue;
            }
            assertNull(verified.getFlag(flag));
        }
    }

    private static void assertFlag(int expectedFlags, int flag, VerifiedInputEvent verified) {
        final Boolean actual;
        if (verified instanceof VerifiedKeyEvent) {
            actual = ((VerifiedKeyEvent) verified).getFlag(flag);
        } else if (verified instanceof VerifiedMotionEvent) {
            actual = ((VerifiedMotionEvent) verified).getFlag(flag);
        } else {
            fail(""Unknown type of VerifiedInputEvent"");
            actual = null;
        }
        assertNotNull(actual);
        boolean flagValue = (expectedFlags & flag) != 0;
        assertEquals(flagValue, actual);
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.SustainedPerformance.cts.SustainedPerformanceHostTest"	"currentTimeMillis"	"CtsSustainedPerformanceHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/sustainedperf/src/android/SustainedPerformance/cts/SustainedPerformanceHostTest.java"	""	"public void test/*
 *.
 */

package android.sustainedPerformance.cts;

import com.android.compatibility.common.util.CddTest;
import com.android.ddmlib.IShellOutputReceiver;
import com.android.ddmlib.Log;
import com.android.ddmlib.MultiLineReceiver;
import com.android.tradefed.device.ITestDevice;
import com.android.tradefed.testtype.DeviceTestCase;
import java.util.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Scanner;
import java.util.concurrent.TimeUnit;
/**
 * Test to check if device implements Sustained Performance Mode
 */
@CddTest(requirement=""8.5/C-0-1,C-1-1,C-1-2"")
public class SustainedPerformanceHostTest extends DeviceTestCase {

    ITestDevice device;
    private static final String PACKAGE = ""com.android.gputest"";
    private static final String CLASS = ""GPUStressTestActivity"";
    private static final String START_COMMAND = String.format(
            ""am start -W -a android.intent.action.MAIN -n %s/%s.%s"",
            PACKAGE, PACKAGE, CLASS);
    private static final String START_COMMAND_MODE = String.format(
            ""am start -W -a android.intent.action.MAIN -n %s/%s.%s --ez SustainedPerformanceMode true"",
            PACKAGE, PACKAGE, CLASS);
    private static final String STOP_COMMAND = String.format(
            ""am force-stop %s"", PACKAGE);
    private static final String TEST_PACKAGE = ""android.test.app"";
    private static final String TEST_CLASS = ""DeviceTestActivity"";
    private static final String START_TEST_COMMAND = String.format(
            ""am start -W -a android.intent.action.MAIN -n %s/%s.%s"",
            TEST_PACKAGE, TEST_PACKAGE, TEST_CLASS);
    private static final String DHRYSTONE = ""/data/local/tmp/"";
    private static final String LOG_TAG = ""sustainedPerfTest"";

    private static ArrayList<Double> appResultsWithMode = new ArrayList<Double>();
    private static ArrayList<Double> appResultsWithoutMode = new ArrayList<Double>();
    private static ArrayList<Double> dhrystoneResultsWithMode = new ArrayList<Double>();
    private static ArrayList<Double> dhrystoneResultsWithoutMode = new ArrayList<Double>();
    private double dhryMin = Double.MAX_VALUE, dhryMax = Double.MIN_VALUE;
    private static long testDuration = 1800000; //30 minutes

    public class Dhrystone implements Runnable {
        private boolean modeEnabled;
        private long startTime;
        private long loopCount = 300000000;
        private long cpumask = 1;

        public Dhrystone(boolean enabled, long cm) {
            cpumask = cm;
            modeEnabled = enabled;
            startTime = System.currentTimeMillis();
        }

        public void run() {
            double[] testSet = new double[3];
            int index = 0;
            try {
                device.executeShellCommand(""cd "" + DHRYSTONE + "" ; chmod 777 dhry"");
                while (true) {
                    String result = device.executeShellCommand(""echo "" + loopCount
                          + "" | taskset -a "" + cpumask + "" "" + DHRYSTONE + ""dhry"");
                    if (Math.abs(System.currentTimeMillis() - startTime) >= testDuration) {
                        break;
                    } else if (result.contains(""Measured time too small"")) {
                         loopCount = loopCount*10;
                    } else if (!result.isEmpty()){
                         double dmips = Double.parseDouble(result);
                         testSet[index++] = dmips;
                         if (index == 3) {
                             synchronized(this) {
                                 if (modeEnabled) {
                                     dhrystoneResultsWithMode.add(testSet[1]);
                                 } else {
                                     dhrystoneResultsWithoutMode.add(testSet[1]);
                                 }
                                 if (testSet[1] > dhryMax) {
                                     dhryMax = testSet[1];
                                 }
                                 if (testSet[1] < dhryMin) {
                                     dhryMin = testSet[1];
                                 }
                                 index = 0;
                             }
                        }
                    }
               }
           } catch (Exception e) {
               Log.e(LOG_TAG, e.toString());

           }
        }
    }

    public void analyzeResults(String logs, boolean mode) {
        Double[] testSet = new Double[10];
        int index = 0;
        double min = Double.MAX_VALUE, max = Double.MIN_VALUE;
        boolean first = true;

        Scanner in = new Scanner(logs);
        while (in.hasNextLine()) {
            String line = in.nextLine();
            if(line.startsWith(""I/""+CLASS)) {
                Double time = Double.parseDouble(line.split("":"")[1]);
                testSet[index++] = time;
                if (index == 10) {
                    if (first) {
                        first = false;
                        index = 0;
                        continue;
                    }
                    Arrays.sort(testSet);
                    if (mode) {
                        appResultsWithMode.add(testSet[5]);
                    } else {
                        appResultsWithoutMode.add(testSet[5]);
                    }
                    if (testSet[5] > max) {
                        max = testSet[5];
                    }
                    if (testSet[5] < min) {
                        min = testSet[5];
                    }
                    index = 0;
                }
            }
        }
        in.close();
        double diff = (max - min)*100/max;
        if (mode) {
            appResultsWithMode.add(0, min);
            appResultsWithMode.add(1, max);
            appResultsWithMode.add(2, diff);
        } else {
            appResultsWithoutMode.add(0, min);
            appResultsWithoutMode.add(1, max);
            appResultsWithoutMode.add(2, diff);
        }
    }

    private void setUpEnvironment() throws Exception {
        dhryMin = Double.MAX_VALUE;
        dhryMax = Double.MIN_VALUE;
        Thread.sleep(600000);
        device.executeAdbCommand(""logcat"", ""-c"");
        device.executeShellCommand(""settings put global airplane_mode_on 1"");
        device.executeShellCommand(""am broadcast -a android.intent.action.AIRPLANE_MODE --ez state true"");
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.SustainedPerformance.cts.SustainedPerformanceHostTest"	"testShader"	"CtsSustainedPerformanceHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/sustainedperf/src/android/SustainedPerformance/cts/SustainedPerformanceHostTest.java"	""	"public void testShader() throws Exception {
        device = getDevice();

        /**
         * Check if the device supports Sustained Performance Mode.
         * If not then assert true and return.
         **/
        device.executeAdbCommand(""logcat"", ""-c"");
        device.executeShellCommand(START_TEST_COMMAND);
        String logs = device.executeAdbCommand(""logcat"", ""-v"", ""brief"", ""-d"", TEST_CLASS + "":I"", ""*:S"");
        String testString = """";
        Scanner in = new Scanner(logs);
        while (in.hasNextLine()) {
            String line = in.nextLine();
            if(line.startsWith(""I/""+TEST_CLASS)) {
                testString = line.split("":"")[1].trim();
            }
        }
        in.close();
        if (testString.isEmpty()) {
            assertTrue(true);
            return;
        }

        appResultsWithoutMode.clear();
        appResultsWithMode.clear();
        dhrystoneResultsWithoutMode.clear();
        dhrystoneResultsWithMode.clear();

        /*
         * Run the test with the mode.
         * Start the application and collect stats.
         * Run two threads of dhrystone and collect stats.
         */
        setUpEnvironment();
        device.executeShellCommand(START_COMMAND_MODE);
        Thread dhrystone = new Thread(new Dhrystone(true, 1));
        Thread dhrystone1 = new Thread(new Dhrystone(true, 2));
        dhrystone.start();
        dhrystone1.start();
        Thread.sleep(testDuration);
        device.executeShellCommand(STOP_COMMAND);
        dhrystone.join();
        dhrystone1.join();
        logs = device.executeAdbCommand(""logcat"", ""-v"", ""brief"", ""-d"", CLASS + "":I"", ""*:S"");
        analyzeResults(logs, true);
        double diff = (dhryMax - dhryMin)*100/dhryMax;
        dhrystoneResultsWithMode.add(0, dhryMin);
        dhrystoneResultsWithMode.add(1, dhryMax);
        dhrystoneResultsWithMode.add(2, diff);

        device.executeShellCommand(""settings put global airplane_mode_on 0"");
        device.executeShellCommand(""am broadcast -a android.intent.action.AIRPLANE_MODE --ez state false"");

        double resDhry = dhrystoneResultsWithMode.get(2);
        double resApp = appResultsWithMode.get(2);

        /* Report if performance is below 5% margin for both dhrystone and shader */
        if ((resDhry > 5) || (resApp > 5)) {
            Log.w(""SustainedPerformanceHostTests"",
                  ""Sustainable mode results, Dhrystone: "" + resDhry + "" App: "" + resApp);
        }

        /*
         * Error if the performance in the mode is not consistent with
         * 5% error margin for shader and 10% error margin for dhrystone.
         */
        assertFalse(""Results in the mode are not sustainable"",
                    (resDhry > 15) ||
                    (resApp > 5));
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.scopedstorage.cts.host.ScopedStorageInstantAppHostTest"	"testInstantAppsCantAccessExternalStorage"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/host/src/android/scopedstorage/cts/host/ScopedStorageInstantAppHostTest.java"	""	"@AppModeInstant
    public void testInstantAppsCantAccessExternalStorage() throws Exception {
        runDeviceTest(""testInstantAppsCantAccessExternalStorage"");
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.sensors.helpers.OpenCVLibrary"	"isLoaded"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/sensors/helpers/OpenCVLibrary.java"	""	"public void test/*
 *.
 */
package com.android.cts.verifier.sensors.helpers;

import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.ServiceConnection;
import android.os.IBinder;
import android.util.Log;

import org.opencv.android.BaseLoaderCallback;
import org.opencv.android.LoaderCallbackInterface;
import org.opencv.android.OpenCVLoader;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

/**
 * OpenCV library loader class
 */
public class OpenCVLibrary {

    private final static String TAG = ""OpenCVLibraryProbe"";
    private final static int ASYNC_LOAD_TIMEOUT_SEC = 30;
    private static boolean sLoaded = false;

    /**
     * Load OpenCV Library in async mode
     *
     * @param context Activity context.
     * @param allowStatic Allow trying load from local package.
     * @param allowInstall Allow installing package from play store.
     *
     * @return if load succeed return true. Return false otherwise.
     */
    public static boolean load(Context context,
            boolean allowLocal, boolean allowPackage, boolean allowInstall) {
        // only need to load once
        if (!sLoaded) {
            // Try static load first
            if (allowLocal && OpenCVLoader.initDebug()) {
                sLoaded = true;
            } else if (allowPackage) {
                if (allowInstall || probePackage(context)) {
                    final CountDownLatch done = new CountDownLatch(1);
                    // Load the library through async loader
                    OpenCVLoader.initAsync(OpenCVLoader.OPENCV_VERSION_3_0_0, context,
                            new BaseLoaderCallback(context) {
                                @Override
                                public void onManagerConnected(int status) {
                                    Log.v(TAG, ""New Loading status: "" + status);
                                    switch (status) {
                                        case LoaderCallbackInterface.SUCCESS: {
                                            sLoaded = true;
                                        }
                                        break;
                                        default: {
                                            Log.e(TAG, ""Connecting OpenCV Manager failed"");
                                        }
                                        break;
                                    }
                                    done.countDown();
                                }
                            });
                    try {
                        if (!done.await(ASYNC_LOAD_TIMEOUT_SEC, TimeUnit.SECONDS)) {
                            Log.e(TAG, ""Time out when attempt async load"");
                        }
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                    }
                }
            }
        }
        return sLoaded;
    }

    /**
     * Test if the library is loaded
     * @return a boolean indicates whether the OpenCV library is loaded.
     */
    public static boolean isLoaded() {
        return sLoaded;
    }

    /**
     * Probe if the OpenCV Manager package is installed
     *
     * @return a boolean indicate wheather OpenCV Manager is installed
     */
    private static boolean probePackage(Context context) {
        Intent intent = new Intent(""org.opencv.engine.BIND"");
        intent.setPackage(""org.opencv.engine"");

        ServiceConnection conn = new ServiceConnection() {
            @Override
            public void onServiceConnected(ComponentName className, IBinder service) {
                // Do nothing
            }
            @Override
            public void onServiceDisconnected(ComponentName className) {
                // Do nothing
            }
        };

        boolean ret = false;
        try {
            if (context.bindService(intent, conn, Context.BIND_AUTO_CREATE)) {
                ret = true;
            }
        } finally {
            context.unbindService(conn);
        }

        return ret;
    }
}"	""	""	"probe"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSpecifierTest"	"isNotNull"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSpecifierTest.java"	""	"/*
 *.
 */

package android.net.wifi.cts;

import static android.os.Process.myUid;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import static org.junit.Assume.assumeTrue;

import android.annotation.NonNull;
import android.content.Context;
import android.net.ConnectivityManager;
import android.net.ConnectivityManager.NetworkCallback;
import android.net.MacAddress;
import android.net.Network;
import android.net.NetworkCapabilities;
import android.net.NetworkRequest;
import android.net.NetworkSpecifier;
import android.net.wifi.ScanResult;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiEnterpriseConfig;
import android.net.wifi.WifiInfo;
import android.net.wifi.WifiManager;
import android.net.wifi.WifiNetworkSpecifier;
import android.os.Build;
import android.os.PatternMatcher;
import android.platform.test.annotations.AppModeFull;
import android.support.test.uiautomator.UiDevice;
import android.util.Pair;

import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.filters.LargeTest;
import androidx.test.filters.SdkSuppress;
import androidx.test.platform.app.InstrumentationRegistry;

import com.android.compatibility.common.util.ApiLevelUtil;
import com.android.compatibility.common.util.PollingCheck;
import com.android.compatibility.common.util.ShellIdentityUtils;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.security.KeyFactory;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.PKCS8EncodedKeySpec;
import java.util.List;
import java.util.ArrayList;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;

/**
 * Tests the entire connection flow using {@link WifiNetworkSpecifier} embedded in a
 * {@link NetworkRequest} & passed into {@link ConnectivityManager#requestNetwork(NetworkRequest,
 * ConnectivityManager.NetworkCallback)}.
 *
 * Assumes that all the saved networks is either open/WPA1/WPA2/WPA3 authenticated network.
 */
@AppModeFull(reason = ""Cannot get WifiManager in instant app mode"")
@LargeTest
@RunWith(AndroidJUnit4.class)
public class WifiNetworkSpecifierTest extends WifiJUnit4TestBase {
    private static final String TAG = ""WifiNetworkSpecifierTest"";

    private static final String CA_SUITE_B_ECDSA_CERT_STRING =
            ""-----BEGIN CERTIFICATE-----\n""
                    + ""MIICTzCCAdSgAwIBAgIUdnLttwNPnQzFufplGOr9bTrGCqMwCgYIKoZIzj0EAwMw\n""
                    + ""XjELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAkNBMQwwCgYDVQQHDANNVFYxEDAOBgNV\n""
                    + ""BAoMB0FuZHJvaWQxDjAMBgNVBAsMBVdpLUZpMRIwEAYDVQQDDAl1bml0ZXN0Q0Ew\n""
                    + ""HhcNMjAwNzIxMDIyNDA1WhcNMzAwNTMwMDIyNDA1WjBeMQswCQYDVQQGEwJVUzEL\n""
                    + ""MAkGA1UECAwCQ0ExDDAKBgNVBAcMA01UVjEQMA4GA1UECgwHQW5kcm9pZDEOMAwG\n""
                    + ""A1UECwwFV2ktRmkxEjAQBgNVBAMMCXVuaXRlc3RDQTB2MBAGByqGSM49AgEGBSuB\n""
                    + ""BAAiA2IABFmntXwk9icqhDQFUP1xy04WyEpaGW4q6Q+8pujlSl/X3iotPZ++GZfp\n""
                    + ""Mfv3YDHDBl6sELPQ2BEjyPXmpsKjOUdiUe69e88oGEdeqT2xXiQ6uzpTfJD4170i\n""
                    + ""O/TwLrQGKKNTMFEwHQYDVR0OBBYEFCjptsX3g4g5W0L4oEP6N3gfyiZXMB8GA1Ud\n""
                    + ""IwQYMBaAFCjptsX3g4g5W0L4oEP6N3gfyiZXMA8GA1UdEwEB/wQFMAMBAf8wCgYI\n""
                    + ""KoZIzj0EAwMDaQAwZgIxAK61brUYRbLmQKiaEboZgrHtnPAcGo7Yzx3MwHecx3Dm\n""
                    + ""5soIeLVYc8bPYN1pbhXW1gIxALdEe2sh03nBHyQH4adYoZungoCwt8mp/7sJFxou\n""
                    + ""9UnRegyBgGzf74ROWdpZHzh+Pg==\n""
                    + ""-----END CERTIFICATE-----\n"";
    public static final X509Certificate CA_SUITE_B_ECDSA_CERT =
            loadCertificate(CA_SUITE_B_ECDSA_CERT_STRING);

    private static final String CLIENT_SUITE_B_ECDSA_CERT_STRING =
            ""-----BEGIN CERTIFICATE-----\n""
                    + ""MIIB9zCCAX4CFDpfSZh3AH07BEfGWuMDa7Ynz6y+MAoGCCqGSM49BAMDMF4xCzAJ\n""
                    + ""BgNVBAYTAlVTMQswCQYDVQQIDAJDQTEMMAoGA1UEBwwDTVRWMRAwDgYDVQQKDAdB\n""
                    + ""bmRyb2lkMQ4wDAYDVQQLDAVXaS1GaTESMBAGA1UEAwwJdW5pdGVzdENBMB4XDTIw\n""
                    + ""MDcyMTAyMjk1MFoXDTMwMDUzMDAyMjk1MFowYjELMAkGA1UEBhMCVVMxCzAJBgNV\n""
                    + ""BAgMAkNBMQwwCgYDVQQHDANNVFYxEDAOBgNVBAoMB0FuZHJvaWQxDjAMBgNVBAsM\n""
                    + ""BVdpLUZpMRYwFAYDVQQDDA11bml0ZXN0Q2xpZW50MHYwEAYHKoZIzj0CAQYFK4EE\n""
                    + ""ACIDYgAEhxhVJ7dcSqrto0X+dgRxtd8BWG8cWmPjBji3MIxDLfpcMDoIB84ae1Ew\n""
                    + ""gJn4YUYHrWsUDiVNihv8j7a/Ol1qcIY2ybH7tbezefLmagqA4vXEUXZXoUyL4ZNC\n""
                    + ""DWcdw6LrMAoGCCqGSM49BAMDA2cAMGQCMH4aP73HrriRUJRguiuRic+X4Cqj/7YQ\n""
                    + ""ueJmP87KF92/thhoQ9OrRo8uJITPmNDswwIwP2Q1AZCSL4BI9dYrqu07Ar+pSkXE\n""
                    + ""R7oOqGdZR+d/MvXcFSrbIaLKEoHXmQamIHLe\n""
                    + ""-----END CERTIFICATE-----\n"";
    public static final X509Certificate CLIENT_SUITE_B_ECDSA_CERT =
            loadCertificate(CLIENT_SUITE_B_ECDSA_CERT_STRING);

    private static final byte[] CLIENT_SUITE_B_ECC_KEY_DATA = new byte[]{
            (byte) 0x30, (byte) 0x81, (byte) 0xb6, (byte) 0x02, (byte) 0x01, (byte) 0x00,
            (byte) 0x30, (byte) 0x10, (byte) 0x06, (byte) 0x07, (byte) 0x2a, (byte) 0x86,
            (byte) 0x48, (byte) 0xce, (byte) 0x3d, (byte) 0x02, (byte) 0x01, (byte) 0x06,
            (byte) 0x05, (byte) 0x2b, (byte) 0x81, (byte) 0x04, (byte) 0x00, (byte) 0x22,
            (byte) 0x04, (byte) 0x81, (byte) 0x9e, (byte) 0x30, (byte) 0x81, (byte) 0x9b,
            (byte) 0x02, (byte) 0x01, (byte) 0x01, (byte) 0x04, (byte) 0x30, (byte) 0xea,
            (byte) 0x6c, (byte) 0x4b, (byte) 0x6d, (byte) 0x43, (byte) 0xf9, (byte) 0x6c,
            (byte) 0x91, (byte) 0xdc, (byte) 0x2d, (byte) 0x6e, (byte) 0x87, (byte) 0x4f,
            (byte) 0x0a, (byte) 0x0b, (byte) 0x97, (byte) 0x25, (byte) 0x1c, (byte) 0x79,
            (byte) 0xa2, (byte) 0x07, (byte) 0xdc, (byte) 0x94, (byte) 0xc2, (byte) 0xee,
            (byte) 0x64, (byte) 0x51, (byte) 0x6d, (byte) 0x4e, (byte) 0x35, (byte) 0x1c,
            (byte) 0x22, (byte) 0x2f, (byte) 0xc0, (byte) 0xea, (byte) 0x09, (byte) 0x47,
            (byte) 0x3e, (byte) 0xb9, (byte) 0xb6, (byte) 0xb8, (byte) 0x83, (byte) 0x9e,
            (byte) 0xed, (byte) 0x59, (byte) 0xe5, (byte) 0xe7, (byte) 0x0f, (byte) 0xa1,
            (byte) 0x64, (byte) 0x03, (byte) 0x62, (byte) 0x00, (byte) 0x04, (byte) 0x87,
            (byte) 0x18, (byte) 0x55, (byte) 0x27, (byte) 0xb7, (byte) 0x5c, (byte) 0x4a,
            (byte) 0xaa, (byte) 0xed, (byte) 0xa3, (byte) 0x45, (byte) 0xfe, (byte) 0x76,
            (byte) 0x04, (byte) 0x71, (byte) 0xb5, (byte) 0xdf, (byte) 0x01, (byte) 0x58,
            (byte) 0x6f, (byte) 0x1c, (byte) 0x5a, (byte) 0x63, (byte) 0xe3, (byte) 0x06,
            (byte) 0x38, (byte) 0xb7, (byte) 0x30, (byte) 0x8c, (byte) 0x43, (byte) 0x2d,
            (byte) 0xfa, (byte) 0x5c, (byte) 0x30, (byte) 0x3a, (byte) 0x08, (byte) 0x07,
            (byte) 0xce, (byte) 0x1a, (byte) 0x7b, (byte) 0x51, (byte) 0x30, (byte) 0x80,
            (byte) 0x99, (byte) 0xf8, (byte) 0x61, (byte) 0x46, (byte) 0x07, (byte) 0xad,
            (byte) 0x6b, (byte) 0x14, (byte) 0x0e, (byte) 0x25, (byte) 0x4d, (byte) 0x8a,
            (byte) 0x1b, (byte) 0xfc, (byte) 0x8f, (byte) 0xb6, (byte) 0xbf, (byte) 0x3a,
            (byte) 0x5d, (byte) 0x6a, (byte) 0x70, (byte) 0x86, (byte) 0x36, (byte) 0xc9,
            (byte) 0xb1, (byte) 0xfb, (byte) 0xb5, (byte) 0xb7, (byte) 0xb3, (byte) 0x79,
            (byte) 0xf2, (byte) 0xe6, (byte) 0x6a, (byte) 0x0a, (byte) 0x80, (byte) 0xe2,
            (byte) 0xf5, (byte) 0xc4, (byte) 0x51, (byte) 0x76, (byte) 0x57, (byte) 0xa1,
            (byte) 0x4c, (byte) 0x8b, (byte) 0xe1, (byte) 0x93, (byte) 0x42, (byte) 0x0d,
            (byte) 0x67, (byte) 0x1d, (byte) 0xc3, (byte) 0xa2, (byte) 0xeb
    };
    public static final PrivateKey CLIENT_SUITE_B_ECC_KEY =
            loadPrivateKey(""EC"", CLIENT_SUITE_B_ECC_KEY_DATA);

    private static X509Certificate loadCertificate(String blob) {
        try {
            final CertificateFactory certFactory = CertificateFactory.getInstance(""X.509"");
            InputStream stream = new ByteArrayInputStream(blob.getBytes(StandardCharsets.UTF_8));

            return (X509Certificate) certFactory.generateCertificate(stream);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    private static PrivateKey loadPrivateKey(String algorithm, byte[] fakeKey) {
        try {
            KeyFactory kf = KeyFactory.getInstance(algorithm);
            return kf.generatePrivate(new PKCS8EncodedKeySpec(fakeKey));
        } catch (InvalidKeySpecException | NoSuchAlgorithmException e) {
            return null;
        }
    }

    private static boolean sWasVerboseLoggingEnabled;
    private static boolean sWasScanThrottleEnabled;
    private static WifiConfiguration sTestNetwork;

    private Context mContext;
    private WifiManager mWifiManager;
    private ConnectivityManager mConnectivityManager;
    private UiDevice mUiDevice;
    private ConnectivityManager.NetworkCallback mNrNetworkCallback;
    private TestHelper mTestHelper;

    private static final int DURATION = 10_000;

    @BeforeClass
    public static void setUpClass() throws Exception {
        Context context = InstrumentationRegistry.getInstrumentation().getContext();
        // skip the test if WiFi is not supported
        if (!WifiFeature.isWifiSupported(context)) return;

        WifiManager wifiManager = context.getSystemService(WifiManager.class);
        assertThat(wifiManager).isNotNull();

        // turn on verbose logging for tests
        sWasVerboseLoggingEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.isVerboseLoggingEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setVerboseLoggingEnabled(true));
        // Disable scan throttling for tests.
        sWasScanThrottleEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.isScanThrottleEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setScanThrottleEnabled(false));

        // enable Wifi
        if (!wifiManager.isWifiEnabled()) {
            ShellIdentityUtils.invokeWithShellPermissions(() -> wifiManager.setWifiEnabled(true));
        }
        PollingCheck.check(""Wifi not enabled"", DURATION, () -> wifiManager.isWifiEnabled());

        // check we have >= 1 saved network
        List<WifiConfiguration> savedNetworks = ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.getPrivilegedConfiguredNetworks());
        assertWithMessage(""Need at least one saved network"")
                .that(savedNetworks.isEmpty()).isFalse();

        // Pick any network in range.
        sTestNetwork = TestHelper.findMatchingSavedNetworksWithBssid(wifiManager, savedNetworks)
                .get(0);
    }

    private static void enableAllSavedNetworks(@NonNull WifiManager wifiManager) {
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> {
                    for (WifiConfiguration savedNetwork : wifiManager.getConfiguredNetworks()) {
                        wifiManager.enableNetwork(savedNetwork.networkId, false);
                    }
                });
    }

    private static void disableAllSavedNetworks(@NonNull WifiManager wifiManager) {
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> {
                    for (WifiConfiguration savedNetwork : wifiManager.getConfiguredNetworks()) {
                        wifiManager.disableNetwork(savedNetwork.networkId);
                    }
                });
    }

    @AfterClass
    public static void tearDownClass() throws Exception {
        Context context = InstrumentationRegistry.getInstrumentation().getContext();
        if (!WifiFeature.isWifiSupported(context)) return;

        WifiManager wifiManager = context.getSystemService(WifiManager.class);
        assertThat(wifiManager).isNotNull();

        if (!wifiManager.isWifiEnabled()) {
            ShellIdentityUtils.invokeWithShellPermissions(() -> wifiManager.setWifiEnabled(true));
        }

        // Re-enable networks.
        enableAllSavedNetworks(wifiManager);

        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setScanThrottleEnabled(sWasScanThrottleEnabled));
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setVerboseLoggingEnabled(sWasVerboseLoggingEnabled));
    }

    @Before
    public void setUp() throws Exception {
        mContext = InstrumentationRegistry.getInstrumentation().getContext();
        mWifiManager = (WifiManager) mContext.getSystemService(Context.WIFI_SERVICE);
        mConnectivityManager = mContext.getSystemService(ConnectivityManager.class);
        mUiDevice = UiDevice.getInstance(InstrumentationRegistry.getInstrumentation());
        mTestHelper = new TestHelper(mContext, mUiDevice);

        assumeTrue(WifiFeature.isWifiSupported(mContext));

        // turn screen on
        mTestHelper.turnScreenOn();

        // Clear any existing app state before each test.
        if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(mContext)) {
            ShellIdentityUtils.invokeWithShellPermissions(
                    () -> mWifiManager.removeAppState(myUid(), mContext.getPackageName()));
        }

        // Disconnect & disable auto-join on the saved network to prevent auto-connect from
        // interfering with the test.
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.allowAutojoinGlobal(false));
        disableAllSavedNetworks(mWifiManager);
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.allowAutojoinGlobal(true));

        // Wait for Wifi to be disconnected.
        PollingCheck.check(
                ""Wifi not disconnected"",
                20000,
                () -> mWifiManager.getConnectionInfo().getNetworkId() == -1);
    }

    @After
    public void tearDown() throws Exception {
        // If there is failure, ensure we unregister the previous request.
        if (mNrNetworkCallback != null) {
            mConnectivityManager.unregisterNetworkCallback(mNrNetworkCallback);
        }
        // Clear any existing app state after each test.
        if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(mContext)) {
            ShellIdentityUtils.invokeWithShellPermissions(
                    () -> mWifiManager.removeAppState(myUid(), mContext.getPackageName()));
        }
        mTestHelper.turnScreenOff();
    }

    private void testSuccessfulConnectionWithSpecifier(WifiNetworkSpecifier specifier)
            throws Exception {
        mNrNetworkCallback = mTestHelper.testConnectionFlowWithSpecifier(
                sTestNetwork, specifier, false);
    }

    private void testUserRejectionWithSpecifier(WifiNetworkSpecifier specifier)
            throws Exception {
        mNrNetworkCallback = mTestHelper.testConnectionFlowWithSpecifier(
                sTestNetwork, specifier, true);
    }

    /**
     * Tests the entire connection flow using a specific SSID in the specifier.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSpecifierTest"	"testWifiBandInNetworkCallback"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSpecifierTest.java"	""	"public void testWifiBandInNetworkCallback() throws Exception {
        // Enable all networks and wait for Internet connectivity to be restored.
        // The callbacks in this test will match the existing network as soon as they are filed.
        enableAllSavedNetworks(mWifiManager);
        mTestHelper.assertWifiInternetConnectionAvailable();

        final LinkedBlockingQueue<Pair<Integer, Integer>> results = new LinkedBlockingQueue<>();
        final int[] bands = { ScanResult.WIFI_BAND_24_GHZ, ScanResult.WIFI_BAND_5_GHZ,
                ScanResult.WIFI_BAND_6_GHZ, ScanResult.WIFI_BAND_60_GHZ };
        final ArrayList<NetworkCallback> registeredCallbacks = new ArrayList<>();
        for (final int band : bands) {
            final NetworkCallback callback = new NetworkCallback() {
                @Override public void onCapabilitiesChanged(final Network net,
                        final NetworkCapabilities caps) {
                    results.offer(new Pair(band, TestHelper.getBandFromFrequency(
                            ((WifiInfo) caps.getTransportInfo()).getFrequency())));
                }
            };

            final WifiNetworkSpecifier specifier =
                    new WifiNetworkSpecifier.Builder().setBand(band).build();
            assertThat(specifier.getBand()).isEqualTo(band);

            final NetworkRequest request = new NetworkRequest.Builder()
                .addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
                .addTransportType(NetworkCapabilities.TRANSPORT_WIFI)
                .setNetworkSpecifier(specifier)
                .build();
            mConnectivityManager.registerNetworkCallback(request, callback);
            registeredCallbacks.add(callback);
        }

        try {
            // There should be at least one network callback about availability of the wifi network
            // on the right band. If the device is currently connected to multiple WiFi networks,
            // there will be several. Wait for a relatively long time for any callback, but only
            // a short time for subsequent ones (as the last timeout will be incurred always).
            Pair<Integer, Integer> result = results.poll(10, TimeUnit.SECONDS);
            assertThat(result).isNotNull();
            while (null != result) {
                assertThat(result.first).isEqualTo(result.second);
                result = results.poll(200, TimeUnit.MILLISECONDS);
            }
        } finally {
            for (final NetworkCallback cb : registeredCallbacks) {
                mConnectivityManager.unregisterNetworkCallback(cb);
            }
        }
    }

    /**
     * Tests the entire connection flow using a specific SSID in the specifier and ensure that the
     * device auto connects back to some saved network or suggestions in range of the device (that
     * can provide internet connectivity) when the request is released.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSpecifierTest"	"testRedact"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSpecifierTest.java"	""	"public void testRedact() {
        if (!WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(mContext)) {
            // Skip the test if wifi module version is older than S.
            return;
        }
        WifiNetworkSpecifier specifier = TestHelper
                .createSpecifierBuilderWithCredentialFromSavedNetworkWithBssid(sTestNetwork)
                .setBssidPattern(MacAddress.fromString(sTestNetwork.BSSID),
                        MacAddress.fromString(""ff:ff:ff:00:00:00""))
                .setBand(ScanResult.WIFI_BAND_5_GHZ)
                .build();

        final NetworkSpecifier redacted = specifier.redact();
        if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
            assertThat(new WifiNetworkSpecifier.Builder().setBand(ScanResult.WIFI_BAND_5_GHZ)
                    .build().equals(redacted)).isTrue();
        } else {
            assertThat(redacted.equals(specifier)).isTrue();
        }
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.bluetooth.cts.ScanSettingsTest"	"testDefaultSettings"	"CtsBluetoothTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/bluetooth/src/android/bluetooth/cts/ScanSettingsTest.java"	""	"public void testDefaultSettings() {
        ScanSettings settings = new ScanSettings.Builder().build();
        assertEquals(ScanSettings.CALLBACK_TYPE_ALL_MATCHES, settings.getCallbackType());
        assertEquals(ScanSettings.SCAN_MODE_LOW_POWER, settings.getScanMode());
        assertEquals(0, settings.getScanResultType());
        assertEquals(0, settings.getReportDelayMillis());
    }

    @SmallTest"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.bluetooth.cts.ScanSettingsTest"	"testDescribeContents"	"CtsBluetoothTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/bluetooth/src/android/bluetooth/cts/ScanSettingsTest.java"	""	"public void testDescribeContents() {
        ScanSettings settings = new ScanSettings.Builder().build();
        assertEquals(0, settings.describeContents());
    }

    @SmallTest"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.bluetooth.cts.ScanSettingsTest"	"testReadWriteParcel"	"CtsBluetoothTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/bluetooth/src/android/bluetooth/cts/ScanSettingsTest.java"	""	"public void testReadWriteParcel() {
        final long reportDelayMillis = 60 * 1000;
        Parcel parcel = Parcel.obtain();
        ScanSettings settings = new ScanSettings.Builder()
                .setReportDelay(reportDelayMillis)
                .setScanMode(ScanSettings.SCAN_MODE_LOW_LATENCY)
                .setMatchMode(ScanSettings.MATCH_MODE_AGGRESSIVE)
                .setNumOfMatches(ScanSettings.MATCH_NUM_MAX_ADVERTISEMENT)
                .build();
        settings.writeToParcel(parcel, 0);
        parcel.setDataPosition(0);
        ScanSettings settingsFromParcel = ScanSettings.CREATOR.createFromParcel(parcel);
        assertEquals(reportDelayMillis, settingsFromParcel.getReportDelayMillis());
        assertEquals(ScanSettings.SCAN_MODE_LOW_LATENCY, settings.getScanMode());
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.provider.cts.media.MediaStore_FilesTest"	"testInPlaceUpdate_mediaFileWithInvalidRelativePath"	"CtsProviderTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/provider/src/android/provider/cts/media/MediaStore_FilesTest.java"	""	"public void testInPlaceUpdate_mediaFileWithInvalidRelativePath() throws Exception {
        final File file = new File(ProviderTestUtils.stageDownloadDir(mVolumeName),
                ""test"" + System.nanoTime() + "".mp3"");
        ProviderTestUtils.stageFile(R.raw.testmp3, file);
        Log.d(TAG, ""Staged audio file at "" + file.getAbsolutePath());

        // Since file is created by shell, package name in MediaStore database row for this file
        // will not be test app's package name. To treat the insert as upsert, package name in
        // database must be test app's package name. Force test app to be the owner of database row.
        final Uri scannedUri = ProviderTestUtils.scanFile(file);
        ProviderTestUtils.setOwner(scannedUri,
                InstrumentationRegistry.getContext().getPackageName());

        final ContentValues insertValues = new ContentValues();
        insertValues.put(MediaColumns.DATA, file.getAbsolutePath());
        insertValues.put(MediaStore.Audio.AudioColumns.BOOKMARK, 42L);
        final Uri uri = mResolver.insert(mExternalAudio, insertValues);
        assertEquals(42L, queryLong(uri, MediaStore.Audio.AudioColumns.BOOKMARK));

        final ContentValues updateValues = new ContentValues();
        updateValues.put(MediaStore.Audio.AudioColumns.BOOKMARK, 43L);
        assertEquals(1, mResolver.update(uri, updateValues, null, null));
        assertEquals(43L, queryLong(uri, MediaStore.Audio.AudioColumns.BOOKMARK));
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.wifi.testcase.NetworkRequestTestCase"	"isEmpty"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/wifi/testcase/NetworkRequestTestCase.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.wifi.testcase;

import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.TRANSPORT_WIFI;

import static com.android.cts.verifier.wifi.TestUtils.SCAN_RESULT_TYPE_OPEN;
import static com.android.cts.verifier.wifi.TestUtils.SCAN_RESULT_TYPE_PSK;

import android.annotation.IntDef;
import android.annotation.NonNull;
import android.content.Context;
import android.net.ConnectivityManager;
import android.net.MacAddress;
import android.net.Network;
import android.net.NetworkRequest;
import android.net.NetworkSpecifier;
import android.net.wifi.ScanResult;
import android.net.wifi.WifiNetworkSpecifier;
import android.os.PatternMatcher;
import android.util.Log;
import android.util.Pair;

import com.android.cts.verifier.R;
import com.android.cts.verifier.wifi.BaseTestCase;
import com.android.cts.verifier.wifi.CallbackUtils;
import com.android.cts.verifier.wifi.TestUtils;

import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

/**
 * Test case for all {@link NetworkRequest} requests with specifier built using
 * {@link WifiNetworkSpecifier.Builder#build()}.
 */
public class NetworkRequestTestCase extends BaseTestCase {
    private static final String TAG = ""NetworkRequestTestCase"";
    private static final boolean DBG = true;

    private static final String UNAVAILABLE_SSID = ""blahblahblah"";
    private static final String UNAVAILABLE_BSSID = ""02:00:00:00:00:00"";
    private static final int NETWORK_REQUEST_TIMEOUT_MS = 30_000;
    private static final int CALLBACK_TIMEOUT_MS = 40_000;

    public static final int NETWORK_SPECIFIER_SPECIFIC_SSID_BSSID = 0;
    public static final int NETWORK_SPECIFIER_PATTERN_SSID_BSSID = 1;
    public static final int NETWORK_SPECIFIER_UNAVAILABLE_SSID_BSSID = 2;
    public static final int NETWORK_SPECIFIER_INVALID_CREDENTIAL = 3;

    @IntDef(prefix = { ""NETWORK_SPECIFIER_"" }, value = {
            NETWORK_SPECIFIER_SPECIFIC_SSID_BSSID,
            NETWORK_SPECIFIER_PATTERN_SSID_BSSID,
            NETWORK_SPECIFIER_UNAVAILABLE_SSID_BSSID,
            NETWORK_SPECIFIER_INVALID_CREDENTIAL
    })
    @Retention(RetentionPolicy.SOURCE)
    public @interface NetworkSpecifierType{}

    private final Object mLock = new Object();
    private final @NetworkSpecifierType int mNetworkSpecifierType;

    private ConnectivityManager mConnectivityManager;
    private NetworkRequest mNetworkRequest;
    private CallbackUtils.NetworkCallback mNetworkCallback;
    private String mFailureReason;

    public NetworkRequestTestCase(Context context, @NetworkSpecifierType int networkSpecifierType) {
        super(context);
        mNetworkSpecifierType = networkSpecifierType;
    }

    // Create a network specifier based on the test type.
    private NetworkSpecifier createNetworkSpecifier(@NonNull ScanResult scanResult)
            throws InterruptedException {
        WifiNetworkSpecifier.Builder configBuilder = new WifiNetworkSpecifier.Builder();
        switch (mNetworkSpecifierType) {
            case NETWORK_SPECIFIER_SPECIFIC_SSID_BSSID:
                configBuilder.setSsid(scanResult.SSID);
                configBuilder.setBssid(MacAddress.fromString(scanResult.BSSID));
                if (!mPsk.isEmpty()) {
                    if (TestUtils.isScanResultForWpa2Network(scanResult)) {
                        configBuilder.setWpa2Passphrase(mPsk);
                    } else if (TestUtils.isScanResultForWpa3Network(scanResult)) {
                        configBuilder.setWpa3Passphrase(mPsk);
                    }
                }
                break;
            case NETWORK_SPECIFIER_PATTERN_SSID_BSSID:
                String ssidPrefix = scanResult.SSID.substring(0, scanResult.SSID.length() - 1);
                MacAddress bssidMask = MacAddress.fromString(""ff:ff:ff:ff:ff:00"");
                configBuilder.setSsidPattern(
                        new PatternMatcher(ssidPrefix, PatternMatcher.PATTERN_PREFIX));
                configBuilder.setBssidPattern(MacAddress.fromString(scanResult.BSSID), bssidMask);
                if (!mPsk.isEmpty()) {
                    if (TestUtils.isScanResultForWpa2Network(scanResult)) {
                        configBuilder.setWpa2Passphrase(mPsk);
                    } else if (TestUtils.isScanResultForWpa3Network(scanResult)) {
                        configBuilder.setWpa3Passphrase(mPsk);
                    }
                }
                break;
            case NETWORK_SPECIFIER_UNAVAILABLE_SSID_BSSID:
                String ssid = UNAVAILABLE_SSID;
                MacAddress bssid = MacAddress.fromString(UNAVAILABLE_BSSID);
                if (mTestUtils.findNetworkInScanResultsResults(ssid, bssid.toString())) {
                    Log.e(TAG, ""The specifiers chosen match a network in scan results.""
                            + ""Test will fail"");
                    return null;
                }
                configBuilder.setSsid(UNAVAILABLE_SSID);
                configBuilder.setBssid(bssid);
                if (!mPsk.isEmpty()) {
                    if (TestUtils.isScanResultForWpa2Network(scanResult)) {
                        configBuilder.setWpa2Passphrase(mPsk);
                    } else if (TestUtils.isScanResultForWpa3Network(scanResult)) {
                        configBuilder.setWpa3Passphrase(mPsk);
                    }
                }
                break;
            case NETWORK_SPECIFIER_INVALID_CREDENTIAL:
                configBuilder.setSsid(scanResult.SSID);
                configBuilder.setBssid(MacAddress.fromString(scanResult.BSSID));
                // Use a random password to simulate connection failure.
                if (TestUtils.isScanResultForWpa2Network(scanResult)) {
                    configBuilder.setWpa2Passphrase(mTestUtils.generateRandomPassphrase());
                } else if (TestUtils.isScanResultForWpa3Network(scanResult)) {
                    configBuilder.setWpa3Passphrase(mTestUtils.generateRandomPassphrase());
                }
                break;
            default:
                throw new IllegalStateException(""Unknown specifier type specifier"");
        }
        return configBuilder.build();
    }


    private void setFailureReason(String reason) {
        synchronized (mLock) {
            mFailureReason = reason;
        }
    }

    @Override
    protected boolean executeTest() throws InterruptedException {
        if (mNetworkSpecifierType == NETWORK_SPECIFIER_INVALID_CREDENTIAL && mPsk.isEmpty()) {
            setFailureReason(mContext.getString(R.string.wifi_status_need_psk));
            return false;
        }
        // Step: Scan and find the network around.
        if (DBG) Log.v(TAG, ""Scan and find the network: "" + mSsid);
        ScanResult testNetwork = mTestUtils.startScanAndFindAnyMatchingNetworkInResults(
                mSsid, mPsk.isEmpty() ? SCAN_RESULT_TYPE_OPEN : SCAN_RESULT_TYPE_PSK);
        if (testNetwork == null) {
            setFailureReason(mContext.getString(R.string.wifi_status_scan_failure));
            return false;
        }

        // Step: Create a specifier for the chosen open network depending on the type of test.
        NetworkSpecifier wns = createNetworkSpecifier(testNetwork);
        if (wns == null) return false;

        // Step: Create a network request with specifier.
        mNetworkRequest = new NetworkRequest.Builder()
                .addTransportType(TRANSPORT_WIFI)
                .setNetworkSpecifier(wns)
                .removeCapability(NET_CAPABILITY_INTERNET)
                .build();

        // Step: Send the network request
        if (DBG) Log.v(TAG, ""Request network using "" + mNetworkRequest);
        mNetworkCallback = new CallbackUtils.NetworkCallback(CALLBACK_TIMEOUT_MS);
        mListener.onTestMsgReceived(
                mContext.getString(R.string.wifi_status_initiating_network_request));
        mConnectivityManager.requestNetwork(mNetworkRequest, mNetworkCallback,
                NETWORK_REQUEST_TIMEOUT_MS);

        // Step: Wait for the network available/unavailable callback.
        if (mNetworkSpecifierType == NETWORK_SPECIFIER_UNAVAILABLE_SSID_BSSID
                || mNetworkSpecifierType == NETWORK_SPECIFIER_INVALID_CREDENTIAL) {
            if (mNetworkSpecifierType == NETWORK_SPECIFIER_UNAVAILABLE_SSID_BSSID) {
                mListener.onTestMsgReceived(
                        mContext.getString(R.string.wifi_status_network_wait_for_unavailable));
            } else {
                mListener.onTestMsgReceived(
                        mContext.getString(R.string
                                .wifi_status_network_wait_for_unavailable_invalid_credential));
            }
            if (DBG) Log.v(TAG, ""Waiting for network unavailable callback"");
            boolean cbStatusForUnavailable = mNetworkCallback.waitForUnavailable();
            if (!cbStatusForUnavailable) {
                Log.e(TAG, ""Failed to get network unavailable callback"");
                setFailureReason(mContext.getString(R.string.wifi_status_network_cb_timeout));
                return false;
            }
            mListener.onTestMsgReceived(
                    mContext.getString(R.string.wifi_status_network_unavailable));
            // All done!
            return true;
        }
        mListener.onTestMsgReceived(
                mContext.getString(R.string.wifi_status_network_wait_for_available));
        if (DBG) Log.v(TAG, ""Waiting for network available callback"");
        Pair<Boolean, Network> cbStatusForAvailable = mNetworkCallback.waitForAvailable();
        if (!cbStatusForAvailable.first) {
            Log.e(TAG, ""Failed to get network available callback"");
            setFailureReason(mContext.getString(R.string.wifi_status_network_cb_timeout));
            return false;
        }
        mListener.onTestMsgReceived(
                mContext.getString(R.string.wifi_status_network_available));

        mListener.onTestMsgReceived(
                mContext.getString(R.string.wifi_status_network_wait_for_lost));
        // Step 6: Ensure we don't disconnect from the network as long as the request is alive.
        if (DBG) Log.v(TAG, ""Ensuring network lost callback is not invoked"");
        boolean cbStatusForLost = mNetworkCallback.waitForLost();
        if (cbStatusForLost) {
            Log.e(TAG, ""Disconnected from the network even though the request is active"");
            setFailureReason(mContext.getString(R.string.wifi_status_network_lost));
            return false;
        }
        // All done!
        return true;
    }

    @Override
    protected String getFailureReason() {
        synchronized (mLock) {
            return mFailureReason;
        }
    }

    @Override
    protected void setUp() {
        super.setUp();
        mConnectivityManager = mContext.getSystemService(ConnectivityManager.class);
    }

    @Override
    protected void tearDown() {
        if (mNetworkCallback != null) {
            mConnectivityManager.unregisterNetworkCallback(mNetworkCallback);
        }
        super.tearDown();
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.externalstorageapp.CommonExternalStorageTest"	"testAllPackageDirsWritable"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/ExternalStorageApp/src/com/android/cts/externalstorageapp/CommonExternalStorageTest.java"	""	"public void testAllPackageDirsWritable() throws Exception {
        final long testValue = 1234500000000L;
        final List<File> paths = getAllPackageSpecificPaths(getContext());
        for (File path : paths) {
            assertNotNull(""Valid media must be inserted during CTS"", path);
            assertEquals(""Valid media must be inserted during CTS"", Environment.MEDIA_MOUNTED,
                    Environment.getExternalStorageState(path));

            assertDirReadWriteAccess(path);

            final File directChild = new File(path, ""directChild"");
            final File subdir = new File(path, ""subdir"");
            final File subdirChild = new File(path, ""subdirChild"");

            writeInt(directChild, 32);
            subdir.mkdirs();
            assertDirReadWriteAccess(subdir);
            writeInt(subdirChild, 64);

            assertEquals(32, readInt(directChild));
            assertEquals(64, readInt(subdirChild));

            assertTrue(""Must be able to set last modified"", directChild.setLastModified(testValue));
            assertTrue(""Must be able to set last modified"", subdirChild.setLastModified(testValue));

            assertEquals(testValue, directChild.lastModified());
            assertEquals(testValue, subdirChild.lastModified());
        }

        for (File path : paths) {
            deleteContents(path);
        }
    }

    /**
     * Return a set of several package-specific external storage paths.
     */
    public static List<File> getAllPackageSpecificPaths(Context context) {
        final List<File> paths = new ArrayList<File>();
        Collections.addAll(paths, context.getExternalCacheDirs());
        Collections.addAll(paths, context.getExternalFilesDirs(null));
        Collections.addAll(paths, context.getExternalFilesDirs(Environment.DIRECTORY_PICTURES));
        Collections.addAll(paths, context.getExternalMediaDirs());
        Collections.addAll(paths, context.getObbDirs());
        return paths;
    }

    public static List<File> getAllPackageSpecificPathsExceptMedia(Context context) {
        final List<File> paths = new ArrayList<File>();
        Collections.addAll(paths, context.getExternalCacheDirs());
        Collections.addAll(paths, context.getExternalFilesDirs(null));
        Collections.addAll(paths, context.getExternalFilesDirs(Environment.DIRECTORY_PICTURES));
        Collections.addAll(paths, context.getObbDirs());
        return paths;
    }

    public static List<File> getAllPackageSpecificPathsExceptObb(Context context) {
        final List<File> paths = new ArrayList<File>();
        Collections.addAll(paths, context.getExternalCacheDirs());
        Collections.addAll(paths, context.getExternalFilesDirs(null));
        Collections.addAll(paths, context.getExternalFilesDirs(Environment.DIRECTORY_PICTURES));
        Collections.addAll(paths, context.getExternalMediaDirs());
        return paths;
    }

    public static List<File> getAllPackageSpecificObbGiftPaths(Context context,
            String targetPackageName) {
        final List<File> targetFiles = new ArrayList<>();
        final File obbDir = context.getObbDir();
        final File targetObbDir = new File(
                obbDir.getAbsolutePath().replace(context.getPackageName(), targetPackageName));
        targetFiles.add(new File(targetObbDir, targetPackageName + "".gift""));
        return targetFiles;
    }

    /**
     * Return a set of several package-specific external storage paths pointing
     * at ""gift"" files designed to be exchanged with the target package in Q.
     * These directories can't be used to exchange ""gift"" files in R.
     */
    public static List<File> getAllPackageSpecificNoGiftPaths(Context context,
            String targetPackageName) {
        final List<File> files = getPrimaryPackageSpecificPathsExceptMedia(context);
        final List<File> targetFiles = new ArrayList<>();
        for (File file : files) {
            final File targetFile = new File(
                    file.getAbsolutePath().replace(context.getPackageName(), targetPackageName));
            targetFiles.add(new File(targetFile, targetPackageName + "".gift""));
        }
        return targetFiles;
    }

    public static List<File> getPrimaryPackageSpecificPathsExceptMedia(Context context) {
        final List<File> paths = new ArrayList<File>();
        Collections.addAll(paths, context.getExternalCacheDir());
        Collections.addAll(paths, context.getExternalFilesDir(null));
        Collections.addAll(paths, context.getObbDir());
        return paths;
    }

    public static List<File> getPrimaryPackageSpecificPaths(Context context) {
        final List<File> paths = new ArrayList<File>();
        Collections.addAll(paths, context.getExternalCacheDir());
        Collections.addAll(paths, context.getExternalFilesDir(null));
        Collections.addAll(paths, context.getExternalFilesDir(Environment.DIRECTORY_PICTURES));
        Collections.addAll(paths, context.getObbDir());
        return paths;
    }

    public static List<File> getSecondaryPackageSpecificPaths(Context context) {
        final List<File> paths = new ArrayList<File>();
        Collections.addAll(paths, dropFirst(context.getExternalCacheDirs()));
        Collections.addAll(paths, dropFirst(context.getExternalFilesDirs(null)));
        Collections.addAll(
                paths, dropFirst(context.getExternalFilesDirs(Environment.DIRECTORY_PICTURES)));
        Collections.addAll(paths, dropFirst(context.getObbDirs()));
        return paths;
    }

    public static List<File> getMountPaths() throws IOException {
        final List<File> paths = new ArrayList<>();
        final BufferedReader br = new BufferedReader(new FileReader(""/proc/self/mounts""));
        try {
            String line;
            while ((line = br.readLine()) != null) {
                final String[] fields = line.split("" "");
                paths.add(new File(fields[1]));
            }
        } finally {
            br.close();
        }
        return paths;
    }

    private static File[] dropFirst(File[] before) {
        final File[] after = new File[before.length - 1];
        System.arraycopy(before, 1, after, 0, after.length);
        return after;
    }

    public static File buildProbeFile(File dir) {
        return new File(dir, "".probe_"" + System.nanoTime());
    }

    public static File[] buildCommonChildDirs(File dir) {
        return new File[] {
                new File(dir, Environment.DIRECTORY_MUSIC),
                new File(dir, Environment.DIRECTORY_PODCASTS),
                new File(dir, Environment.DIRECTORY_ALARMS),
                new File(dir, Environment.DIRECTORY_RINGTONES),
                new File(dir, Environment.DIRECTORY_NOTIFICATIONS),
                new File(dir, Environment.DIRECTORY_PICTURES),
                new File(dir, Environment.DIRECTORY_MOVIES),
                new File(dir, Environment.DIRECTORY_DOWNLOADS),
                new File(dir, Environment.DIRECTORY_DCIM),
                new File(dir, Environment.DIRECTORY_DOCUMENTS),
        };
    }

    public static void assertDirReadOnlyAccess(File path) {
        Log.d(TAG, ""Asserting read-only access to "" + path);

        assertTrue(""exists"", path.exists());
        assertTrue(""execute"", path.canExecute());

        try {
            final File probe = buildProbeFile(path);
            assertFalse(probe.createNewFile());
            assertFalse(probe.exists());
            assertFalse(probe.delete());
            fail(""able to create probe!"");
        } catch (IOException e) {
            // expected
        }
    }

    public static void assertDirReadWriteAccess(File[] paths) {
        for (File path : paths) {
            assertDirReadWriteAccess(path);
        }
    }

    public static void assertDirReadWriteAccess(File path) {
        Log.d(TAG, ""Asserting read/write access to "" + path);

        assertTrue(""exists"", path.exists());
        assertTrue(""read"", path.canRead());
        assertTrue(""execute"", path.canExecute());
        assertNotNull(""list"", path.list());

        try {
            final File probe = buildProbeFile(path);
            assertTrue(probe.createNewFile());
            assertTrue(probe.exists());
            assertTrue(probe.delete());
            assertFalse(probe.exists());
        } catch (IOException e) {
            fail(""failed to create probe!"");
        }
    }

    public static void assertDirNoAccess(File path) {
        Log.d(TAG, ""Asserting no access to "" + path);

        try {
            final File probe = buildProbeFile(path);
            assertFalse(probe.createNewFile());
            assertFalse(probe.exists());
            assertFalse(probe.delete());
            fail(""able to create probe!"");
        } catch (IOException e) {
            // expected
        }
    }

    public static void assertDirNoWriteAccess(File[] paths) {
        for (File path : paths) {
            assertDirNoWriteAccess(path);
        }
    }

    public static void assertDirNoWriteAccess(File path) {
        Log.d(TAG, ""Asserting no write access to "" + path);

        try {
            final File probe = buildProbeFile(path);
            assertFalse(probe.createNewFile());
            assertFalse(probe.exists());
            assertFalse(probe.delete());
            fail(""able to create probe!"");
        } catch (IOException e) {
            // expected
        }
    }

    public static void assertFileReadWriteAccess(File path) {
        try {
            new FileInputStream(path).close();
        } catch (IOException e) {
            fail(""failed to read!"");
        }

        try {
            new FileOutputStream(path, true).close();
        } catch (IOException e) {
            fail(""failed to write!"");
        }
    }

    public static void assertFileNoAccess(File path) {
        try {
            new FileInputStream(path).close();
            fail(""able to read!"");
        } catch (IOException e) {
            // expected
        }

        try {
            new FileOutputStream(path, true).close();
            fail(""able to write!"");
        } catch (IOException e) {
            // expected
        }
    }

    public static void assertFileNotPresent(File path) {
        assertFalse(path + "" exists!"", path.exists());
    }

    public static void assertMediaNoAccess(ContentResolver resolver, boolean legacyApp)
            throws Exception {
        final ContentValues values = new ContentValues();
        values.put(Images.Media.MIME_TYPE, ""image/jpeg"");
        values.put(Images.Media.DATA,
                buildProbeFile(Environment.getExternalStorageDirectory()).getAbsolutePath());

        try {
            Uri uri = resolver.insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, values);
            if (legacyApp) {
                // For legacy apps we do not crash - just make the operation do nothing
                assertEquals(MediaStore.Images.Media.EXTERNAL_CONTENT_URI
                        .buildUpon().appendPath(""0"").build().toString(), uri.toString());
            } else {
                fail(""Expected access to be blocked"");
            }
        } catch (Exception expected) {
        }
    }

    public static void assertMediaReadWriteAccess(ContentResolver resolver) throws Exception {
        final ContentValues values = new ContentValues();
        values.put(Images.Media.MIME_TYPE, ""image/jpeg"");
        values.put(Images.Media.DATA,
                buildProbeFile(Environment.getExternalStorageDirectory()).getAbsolutePath());

        final Uri uri = resolver.insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, values);
        try {
            resolver.openFileDescriptor(uri, ""rw"").close();
            resolver.openFileDescriptor(uri, ""w"").close();
            resolver.openFileDescriptor(uri, ""r"").close();
        } finally {
            resolver.delete(uri, null, null);
        }
    }

    private static boolean isAllowList(File file) {
        final String[] allowLists = {
                ""autorun.inf"", "".android_secure"", ""android_secure""
        };
        if (file.getParentFile().getAbsolutePath().equals(
                Environment.getExternalStorageDirectory().getAbsolutePath())) {
            for (String allowList : allowLists) {
                if (file.getName().equalsIgnoreCase(allowList)) {
                    return true;
                }
            }
        }
        return false;
    }

    private static File[] removeAllowList(File[] files) {
        List<File> fileList = new ArrayList<File>();
        if (files == null) {
            return null;
        }

        for (File file : files) {
            if (!isAllowList(file)) {
                fileList.add(file);
            }
        }
        return fileList.toArray(new File[fileList.size()]);
    }

    public static void deleteContents(File dir) throws IOException {
        File[] files = dir.listFiles();
        files = removeAllowList(files);
        if (files != null) {
            for (File file : files) {
                if (file.isDirectory()) {
                    deleteContents(file);
                }
                assertTrue(file.delete());
            }

            File[] dirs = removeAllowList(dir.listFiles());
            if (dirs.length != 0) {
                fail(""Expected wiped storage but found: "" + Arrays.toString(dirs));
            }
        }
    }

    public static void writeInt(File file, int value) throws IOException {
        final DataOutputStream os = new DataOutputStream(new FileOutputStream(file));
        try {
            os.writeInt(value);
        } finally {
            os.close();
        }
    }

    public static int readInt(File file) throws IOException {
        final DataInputStream is = new DataInputStream(new FileInputStream(file));
        try {
            return is.readInt();
        } finally {
            is.close();
        }
    }

    public static void logCommand(String... cmd) throws Exception {
        final Process proc = new ProcessBuilder(cmd).redirectErrorStream(true).start();

        final ByteArrayOutputStream buf = new ByteArrayOutputStream();
        copy(proc.getInputStream(), buf);
        final int res = proc.waitFor();

        Log.d(TAG, Arrays.toString(cmd) + "" result "" + res + "":"");
        Log.d(TAG, buf.toString());
    }

    /** Shamelessly lifted from libcore.io.Streams */
    public static int copy(InputStream in, OutputStream out) throws IOException {
        int total = 0;
        byte[] buffer = new byte[8192];
        int c;
        while ((c = in.read(buffer)) != -1) {
            total += c;
            out.write(buffer, 0, c);
        }
        return total;
    }
}"	""	""	"probe"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.tv.TvInputManagerHostTest"	"testInputUpdated"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/tv/src/com/android/cts/tv/TvInputManagerHostTest.java"	""	"public void testInputUpdated() throws Exception {
        if (!mHasFeatureLiveTv) {
            return;
        }
        ITestDevice device = getDevice();
        device.executeAdbCommand(""logcat"", ""-c"");
        device.executeShellCommand(START_COMMAND);
        // Re-install the input app so the monitoring app can get the onInputUpdated callback.
        installPackage(TEST_APK);
        String testString = """";
        for (int i = 0; i < 5; ++i) {
            // Try 5 times as this sometimes fails.
            String logs = device.executeAdbCommand(
                    ""logcat"", ""-v"", ""brief"", ""-d"", CLASS + "":I"", ""*:S"");
            Scanner in = new Scanner(logs);
            while (in.hasNextLine()) {
                String line = in.nextLine();
                if (line.contains(INPUT_UPDATED_STRING)) {
                    testString = line.split("":"")[1].trim();
                }
            }
            in.close();
            if (!testString.isEmpty()) {
                break;
            }
            // Wait for the system service to handle the installation.
            Thread.currentThread().sleep(100);
        }
        assertEquals(""Incorrect test string"", INPUT_UPDATED_STRING, testString);
    }

    private boolean hasDeviceFeature(String requiredFeature) throws DeviceNotAvailableException {
        if (mAvailableFeatures == null) {
            // TODO: Move this logic to ITestDevice.
            String command = ""pm list features"";
            String commandOutput = getDevice().executeShellCommand(command);
            CLog.i(""Output for command "" + command + "": "" + commandOutput);

            // Extract the id of the new user.
            mAvailableFeatures = new HashSet<>();
            for (String feature: commandOutput.split(""\\s+"")) {
                // Each line in the output of the command has the format ""feature:{FEATURE_VALUE}"".
                String[] tokens = feature.split("":"");
                assertTrue(""\"""" + feature + ""\"" expected to have format feature:{FEATURE_VALUE}"",
                        tokens.length > 1);
                assertEquals(feature, ""feature"", tokens[0]);
                mAvailableFeatures.add(tokens[1]);
            }
        }
        boolean result = mAvailableFeatures.contains(requiredFeature);
        if (!result) {
            CLog.logAndDisplay(LogLevel.INFO, ""Device doesn't have required feature ""
            + requiredFeature + "". Test won't run."");
        }
        return result;
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.tagging.TaggingManifestDisabledTest"	"testHeapTaggingCompatFeatureDefault"	"CtsTaggingHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/tagging/src/com/android/cts/tagging/TaggingManifestDisabledTest.java"	""	"public void testHeapTaggingCompatFeatureDefault() throws Exception {
        runDeviceCompatTestReported(TEST_PKG, DEVICE_TEST_CLASS_NAME,
                DEVICE_TAGGING_DISABLED_TEST_NAME,
                /*enabledChanges*/ ImmutableSet.of(),
                /*disabledChanges*/ ImmutableSet.of(),
                /*reportedEnabledChanges*/ ImmutableSet.of(),
                // No statsd report for manifest-disabled apps because the platform compat is never
                // probed - see `reportedChangeSet` in TaggingBaseTest for more info.
                /*reportedDisabledChanges*/ ImmutableSet.of());
    }"	""	""	"probe"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.tagging.TaggingManifestDisabledTest"	"testHeapTaggingCompatFeatureEnabled"	"CtsTaggingHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/tagging/src/com/android/cts/tagging/TaggingManifestDisabledTest.java"	""	"public void testHeapTaggingCompatFeatureEnabled() throws Exception {
        // Trying to force the compat feature on should fail if the manifest specifically turns the
        // feature off.
        runDeviceCompatTestReported(TEST_PKG, DEVICE_TEST_CLASS_NAME,
                DEVICE_TAGGING_DISABLED_TEST_NAME,
                /*enabledChanges*/ ImmutableSet.of(NATIVE_HEAP_POINTER_TAGGING_CHANGE_ID),
                /*disabledChanges*/ ImmutableSet.of(),
                /*reportedEnabledChanges*/ ImmutableSet.of(),
                // No statsd report for manifest-disabled apps because the platform compat is never
                // probed - see `reportedChangeSet` in TaggingBaseTest for more info.
                /*reportedDisabledChanges*/ ImmutableSet.of());
    }
}"	""	""	"probe"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.appsecurity.cts.ExternalStorageHostTest"	"testSecondaryUsersInaccessible"	"CtsAppSecurityHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/ExternalStorageHostTest.java"	""	"public void testSecondaryUsersInaccessible() throws Exception {
        List<String> mounts = new ArrayList<>();
        for (String line : getDevice().executeShellCommand(""cat /proc/mounts"").split(""\n"")) {
            String[] split = line.split("" "");
            if (split[1].startsWith(""/storage/"") || split[1].startsWith(""/mnt/"")) {
                mounts.add(split[1]);
            }
        }

        for (int user : mUsers) {
            String probe = ""/sdcard/../"" + user;
            if (user == Utils.USER_SYSTEM) {
                // Primary user should always be visible. Skip checking raw
                // mount points, since we'd get false-positives for physical
                // devices that aren't multi-user aware.
                assertTrue(probe, access(probe));
            } else {
                // Secondary user should never be visible.
                assertFalse(probe, access(probe));
                for (String mount : mounts) {
                    probe = mount + ""/"" + user;
                    assertFalse(probe, access(probe));
                }
            }
        }
    }"	""	""	"probe"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.harmfulappwarning.cts.HarmfulAppWarningTest"	"isEmpty"	"CtsHarmfulAppWarningHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/harmfulappwarning/src/android/harmfulappwarning/cts/HarmfulAppWarningTest.java"	""	"/*
 *.
 */

package android.harmfulappwarning.cts;

import com.android.tradefed.device.DeviceNotAvailableException;
import com.android.tradefed.device.ITestDevice;
import com.android.tradefed.device.PackageInfo;
import com.android.tradefed.result.InputStreamSource;
import com.android.tradefed.testtype.DeviceJUnit4ClassRunner;
import com.android.tradefed.testtype.junit4.BaseHostJUnit4Test;

import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.Scanner;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assume.assumeFalse;

/**
 * Host-side tests for the harmful app launch warning
 *
 * <p>These tests have a few different components. This is the host-side part of the test, which is
 * responsible for setting up the environment and passing off execution to the device-side part
 * of the test.
 *
 * <p>The {@link HarmfulAppWarningDeviceTest} class is the device side of these tests. It attempts to launch
 * the sample warned application, and verifies the correct behavior of the harmful app warning that
 * is shown by the platform.
 *
 * <p>The third component is the sample app, which is just a placeholder app with a basic activity
 * that only serves as a target for the harmful app warning.
 *
 * <p>Run with: atest CtsHarmfulAppWarningHostTestCases
 */
@RunWith(DeviceJUnit4ClassRunner.class)
public class HarmfulAppWarningTest extends BaseHostJUnit4Test {

    private static final String FEATURE_WEARABLE = ""android.hardware.type.watch"";

    private static final String TEST_APP_PACKAGE_NAME = ""android.harmfulappwarning.sampleapp"";
    private static final String TEST_APP_ACTIVITY_CLASS_NAME = ""SampleDeviceActivity"";
    private static final String TEST_APP_LAUNCHED_STRING = ""Sample activity started."";

    private static final String WARNING_MESSAGE = ""This is a warning message."";
    private static final String SET_HARMFUL_APP_WARNING_COMMAND = String.format(
            ""cmd package set-harmful-app-warning %s \"""" + WARNING_MESSAGE + ""\"""",
            TEST_APP_PACKAGE_NAME);

    private static final String CLEAR_HARMFUL_APP_WARNING_COMMAND = String.format(
            ""cmd package set-harmful-app-warning %s"", TEST_APP_PACKAGE_NAME);

    private static final String GET_HARMFUL_APP_WARNING_COMMAND = String.format(
            ""cmd package get-harmful-app-warning %s"", TEST_APP_PACKAGE_NAME);

    private static final String LIST_PACKAGES_COMMAND =
            ""cmd package list packages --user %d "" + TEST_APP_PACKAGE_NAME;

    private ITestDevice mDevice;

    @Before
    public void setUp() throws Exception {
        installPackage(""CtsHarmfulAppWarningSampleApp.apk"");
        mDevice = getDevice();
        mDevice.clearLogcat();

        // Skip the tests for wearable devices. This feature is not used on wearable
        // devices, for now (no wearable UI, etc.)
        assumeFalse(hasFeature(FEATURE_WEARABLE));
    }

    private void runDeviceTest(String testName) throws DeviceNotAvailableException {
        runDeviceTests(""android.harmfulappwarning.testapp"",
                ""android.harmfulappwarning.testapp.HarmfulAppWarningDeviceTest"",
                testName);
    }

    private void verifyHarmfulAppWarningSet() throws DeviceNotAvailableException {
        String warning = getDevice().executeShellCommand(GET_HARMFUL_APP_WARNING_COMMAND);
        assertEquals(WARNING_MESSAGE, warning.trim());
    }

    private void verifyHarmfulAppWarningUnset() throws DeviceNotAvailableException {
        String warning = getDevice().executeShellCommand(GET_HARMFUL_APP_WARNING_COMMAND);
        if (warning != null) {
            warning = warning.trim();
        }
        assertTrue(warning == null || warning.length() == 0);
    }

    private void verifySampleAppUninstalled() throws DeviceNotAvailableException {
        String installedPackage = getDevice().executeShellCommand(
                String.format(LIST_PACKAGES_COMMAND, getDevice().getCurrentUser()));
        Assert.assertTrue(""Harmful application was not uninstalled"", installedPackage.isEmpty());
    }

    private void verifySampleAppInstalled() throws DeviceNotAvailableException {
        String installedPackage = getDevice().executeShellCommand(
                String.format(LIST_PACKAGES_COMMAND, getDevice().getCurrentUser()));
        Assert.assertFalse(""Harmful application was uninstalled"", installedPackage.isEmpty());
    }

    /**
     * A basic smoke test to ensure that we're able to detect the launch of the activity when there
     * is no warning.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.mediapc.cts.MultiCodecPerfTestBase"	"isSPerfClass"	"CtsMediaPerformanceClassTestCases"	"/home/gpoor/cts-12-source/cts/tests/mediapc/src/android/mediapc/cts/MultiCodecPerfTestBase.java"	""	"public void test/*
 *.
 */

package android.mediapc.cts;

import android.media.MediaCodec;
import android.media.MediaCodecInfo;
import android.media.MediaCodecInfo.VideoCapabilities.PerformancePoint;
import android.media.MediaFormat;
import android.util.Pair;
import android.util.Log;
import org.junit.Before;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static android.mediapc.cts.CodecTestBase.selectHardwareCodecs;
import static org.junit.Assert.assertTrue;
import static org.junit.Assume.assumeTrue;

public class MultiCodecPerfTestBase {
    private static final String LOG_TAG = MultiCodecPerfTestBase.class.getSimpleName();
    static final boolean[] boolStates = {true, false};
    static final int REQUIRED_MIN_CONCURRENT_INSTANCES = 6;
    static final int REQUIRED_MIN_CONCURRENT_INSTANCES_FOR_VP9 = 2;
    // allowed tolerance in measured fps vs expected fps in percentage, i.e. codecs achieving fps
    // that is greater than (FPS_TOLERANCE_FACTOR * expectedFps) will be considered as
    // passing the test
    static final double FPS_TOLERANCE_FACTOR = 0.95;
    static ArrayList<String> mMimeList = new ArrayList<String>();
    static Map<String, String> mTestFiles = new HashMap<>();
    static {
        mMimeList.add(MediaFormat.MIMETYPE_VIDEO_AVC);
        mMimeList.add(MediaFormat.MIMETYPE_VIDEO_HEVC);

        mTestFiles.put(MediaFormat.MIMETYPE_VIDEO_AVC, ""bbb_1280x720_3mbps_30fps_avc.mp4"");
        mTestFiles.put(MediaFormat.MIMETYPE_VIDEO_HEVC, ""bbb_1280x720_3mbps_30fps_hevc.mp4"");

        // Test VP9 and AV1 as well for Build.VERSION_CODES.S
        if (Utils.isSPerfClass()) {
            mMimeList.add(MediaFormat.MIMETYPE_VIDEO_VP9);
            mMimeList.add(MediaFormat.MIMETYPE_VIDEO_AV1);

            mTestFiles.put(MediaFormat.MIMETYPE_VIDEO_VP9, ""bbb_1280x720_3mbps_30fps_vp9.webm"");
            mTestFiles.put(MediaFormat.MIMETYPE_VIDEO_AV1, ""bbb_1280x720_3mbps_30fps_av1.mp4"");
        }
    }

    String mMime;
    String mTestFile;
    final boolean mIsAsync;

    double mMaxFrameRate;

    @Before
    public void isPerformanceClassCandidate() {
        Utils.assumeDeviceMeetsPerformanceClassPreconditions();
    }

    public MultiCodecPerfTestBase(String mime, String testFile, boolean isAsync) {
        mMime = mime;
        mTestFile = testFile;
        mIsAsync = isAsync;
    }

    // Returns the list of hardware codecs supporting the 720p 30fps format.
    public static ArrayList<String> getHardwareCodecsFor720p(String mime, boolean isEncoder) {
        MediaFormat fmt = MediaFormat.createVideoFormat(mime, 1280, 720);
        fmt.setInteger(MediaFormat.KEY_FRAME_RATE, 30);
        ArrayList<MediaFormat> formatsList = new ArrayList<>();
        formatsList.add(fmt);
        return selectHardwareCodecs(mime, formatsList, null, isEncoder);
    }

    // Returns the max number of 720p 30 fps instances that the given list of mimeCodecPairs
    // supports. It also checks that the each codec supports 720p 180 fps PerformancePoint.
    public int checkAndGetMaxSupportedInstancesFor720p(
            ArrayList<Pair<String, String>> mimeCodecPairs) throws IOException {
        int[] maxInstances = new int[mimeCodecPairs.size()];
        int[] maxFrameRates = new int[mimeCodecPairs.size()];
        int[] maxMacroBlockRates = new int[mimeCodecPairs.size()];
        int loopCount = 0;
        for (Pair<String, String> mimeCodecPair : mimeCodecPairs) {
            MediaCodec codec = MediaCodec.createByCodecName(mimeCodecPair.second);
            MediaCodecInfo.CodecCapabilities cap = codec.getCodecInfo()
                    .getCapabilitiesForType(mimeCodecPair.first);
            List<PerformancePoint> pps = cap.getVideoCapabilities().getSupportedPerformancePoints();
            assertTrue(pps.size() > 0);

            int requiredFrameRate = 180;
            // VP9 requires 60 fps at 720p and minimum of 2 instances
            if (mimeCodecPair.first.equals(MediaFormat.MIMETYPE_VIDEO_VP9)) {
                requiredFrameRate = 60;
            }

            maxInstances[loopCount] = cap.getMaxSupportedInstances();
            PerformancePoint PP720p = new PerformancePoint(1280, 720, requiredFrameRate);

            maxMacroBlockRates[loopCount] = 0;
            boolean supports720pPerformance = false;
            for (PerformancePoint pp : pps) {
                if (pp.covers(PP720p)) {
                    supports720pPerformance = true;
                    if (pp.getMaxMacroBlockRate() > maxMacroBlockRates[loopCount]) {
                        maxMacroBlockRates[loopCount] = (int) pp.getMaxMacroBlockRate();
                        maxFrameRates[loopCount] = pp.getMaxFrameRate();
                    }
                }
            }
            codec.release();
            if (!supports720pPerformance) {
                Log.e(LOG_TAG, ""Codec "" + mimeCodecPair.second + "" doesn't support 720p "" +
                        requiredFrameRate + "" performance point"");
                return 0;
            }
            loopCount++;
        }
        Arrays.sort(maxInstances);
        Arrays.sort(maxFrameRates);
        Arrays.sort(maxMacroBlockRates);
        int minOfMaxInstances = maxInstances[0];
        int minOfMaxFrameRates = maxFrameRates[0];
        int minOfMaxMacroBlockRates = maxMacroBlockRates[0];

        // Allow a tolerance in expected frame rate
        mMaxFrameRate = minOfMaxFrameRates * FPS_TOLERANCE_FACTOR;

        // Calculate how many 720p 30fps max instances it can support from it's mMaxFrameRate
        // amd maxMacroBlockRate. (720p is 3,600 macro blocks assuming 16x16 macroblocks)
        return Math.min(minOfMaxInstances, Math.min((int) (minOfMaxFrameRates / 30.0),
                (int) (minOfMaxMacroBlockRates / 3600.0 / 30)));
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.projection.offscreen.ProjectionOffscreenActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/projection/offscreen/ProjectionOffscreenActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.projection.offscreen;

import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.ServiceConnection;
import android.graphics.Color;
import android.graphics.PixelFormat;
import android.media.Image;
import android.media.ImageReader;
import android.media.Ringtone;
import android.media.RingtoneManager;
import android.net.Uri;
import android.os.Bundle;
import android.os.Handler;
import android.os.IBinder;
import android.os.Looper;
import android.os.RemoteException;
import android.os.SystemClock;
import android.os.Vibrator;
import android.util.DisplayMetrics;
import android.util.Log;
import android.view.KeyEvent;
import android.view.View;
import android.widget.TextView;

import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;
import com.android.cts.verifier.projection.IProjectionService;
import com.android.cts.verifier.projection.ProjectionPresentationType;
import com.android.cts.verifier.projection.ProjectionService;

import java.nio.ByteBuffer;

public class ProjectionOffscreenActivity extends PassFailButtons.Activity
        implements ImageReader.OnImageAvailableListener {
    private static String TAG = ProjectionOffscreenActivity.class.getSimpleName();
    private static final int WIDTH = 800;
    private static final int HEIGHT = 480;
    private static final int DENSITY = DisplayMetrics.DENSITY_MEDIUM;
    private static final int TIME_SCREEN_OFF = 5000; // Time screen must remain off for test to run
    private static final int DELAYED_RUNNABLE_TIME = 1000; // Time after screen turned off
                                                           // keyevent is sent
    private static final int RENDERER_DELAY_THRESHOLD = 2000; // Time after keyevent sent that
                                                              // rendering must happen by

    protected ImageReader mReader;
    protected IProjectionService mService;
    protected TextView mStatusView;
    protected int mPreviousColor = Color.BLACK;
    private long mTimeScreenTurnedOff = 0;
    private long mTimeKeyEventSent = 0;
    private enum TestStatus { CREATED, PASSED, FAILED, RUNNING };
    protected TestStatus mTestStatus = TestStatus.CREATED;

    private final Runnable sendKeyEventRunnable = new Runnable() {
        @Override
        public void run() {
            try {
                mService.onKeyEvent(new KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_DPAD_DOWN));
                mTimeKeyEventSent = SystemClock.elapsedRealtime();
            } catch (RemoteException e) {
                Log.e(TAG, ""Error running onKeyEvent"", e);
            }
        }
    };

    private final Runnable playNotificationRunnable = new Runnable() {

        @Override
        public void run() {
            Uri notification = RingtoneManager.getDefaultUri(RingtoneManager.TYPE_NOTIFICATION);
            Ringtone r = RingtoneManager.getRingtone(getApplicationContext(), notification);
            r.play();
            ((Vibrator) getSystemService(VIBRATOR_SERVICE)).vibrate(1000);
        }
    };

    private final BroadcastReceiver mReceiver = new BroadcastReceiver() {

    @Override
    public void onReceive(Context context, Intent intent) {
        if (intent.getAction().equals(Intent.ACTION_SCREEN_OFF)) {
            mTestStatus = TestStatus.RUNNING;
            Handler handler = new Handler(Looper.getMainLooper());
            handler.postDelayed(
                    sendKeyEventRunnable, DELAYED_RUNNABLE_TIME);
            mStatusView.setText(""Running test..."");
            mTimeScreenTurnedOff = SystemClock.elapsedRealtime();
            // Notify user its safe to turn screen back on after 5s + fudge factor
            handler.postDelayed(playNotificationRunnable, TIME_SCREEN_OFF + 500);
        } else if (intent.getAction().equals(Intent.ACTION_SCREEN_ON)) {
            if (SystemClock.elapsedRealtime() - mTimeScreenTurnedOff < TIME_SCREEN_OFF) {
                mStatusView.setText(""ERROR: Turned on screen too early"");
                getPassButton().setEnabled(false);
                mTestStatus = TestStatus.FAILED;
            } else if (mTestStatus == TestStatus.RUNNING) {
                mStatusView.setText(""Failed: Image not rendered"");
                mTestStatus = TestStatus.FAILED;
            }
        }
    }

};

    protected final ServiceConnection mConnection = new ServiceConnection() {

            @Override
        public void onServiceConnected(ComponentName name, IBinder binder) {
            mService = IProjectionService.Stub.asInterface(binder);
            new Handler().post(new Runnable() {

                    @Override
                public void run() {
                    Log.i(TAG, ""onServiceConnected thread "" + Thread.currentThread());
                    try {
                        mService.startRendering(mReader.getSurface(), WIDTH, HEIGHT, DENSITY,
                                ProjectionPresentationType.OFFSCREEN.ordinal());
                    } catch (RemoteException e) {
                        Log.e(TAG, ""Failed to execute startRendering"", e);
                    }

                    IntentFilter filter = new IntentFilter();
                    filter.addAction(Intent.ACTION_SCREEN_OFF);
                    filter.addAction(Intent.ACTION_SCREEN_ON);

                    registerReceiver(mReceiver, filter);
                    mStatusView.setText(""Please turn off your screen and turn it back on after "" +
                            ""5 seconds. A sound will be played when it is safe to turn the "" +
                            ""screen back on"");
                }

            });

        }

            @Override
        public void onServiceDisconnected(ComponentName name) {
            mService = null;
        }

    };



    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        View view = getLayoutInflater().inflate(R.layout.poa_main, null);
        mStatusView = (TextView) view.findViewById(R.id.poa_status_text);
        mStatusView.setText(""Waiting for service to bind..."");

        setContentView(view);

        setInfoResources(R.string.poa_test, R.string.poa_info, -1);
        setPassFailButtonClickListeners();
        mReader = ImageReader.newInstance(WIDTH, HEIGHT, PixelFormat.RGBA_8888, 2);

        mReader.setOnImageAvailableListener(this, null);
        bindService(new Intent(this, ProjectionService.class), mConnection,
                Context.BIND_AUTO_CREATE);

        getPassButton().setEnabled(false);
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        unregisterReceiver(mReceiver);
        try {
            mService.stopRendering();
        } catch (RemoteException e) {
            Log.e(TAG, ""Failed to execute stopRendering"", e);
        }
        if (mConnection != null) {
            unbindService(mConnection);
        }
        mReader.close();
    }

    @Override
    protected void onPause() {
        super.onPause();
        if (mTestStatus == TestStatus.FAILED) {
            setTestResultAndFinish(false);
        }
    }

    @Override
    public void onImageAvailable(ImageReader reader) {
        Log.i(TAG, ""onImageAvailable: "" + reader);
        if (mTestStatus == TestStatus.CREATED) {
            Log.i(TAG, ""onImageAvailable called before test started"");
            // Drop latest image to keep buffer clear.
            dropLatestImage(reader);
            return;
        }

        if (mTimeKeyEventSent != 0
                && mTestStatus == TestStatus.RUNNING
                && mTimeKeyEventSent + RENDERER_DELAY_THRESHOLD < SystemClock.elapsedRealtime()) {
            mTestStatus = TestStatus.FAILED;
            mStatusView.setText(""Failed: took too long to render"");
        }

        Image image = reader.acquireLatestImage();

        // No new images available
        if (image == null) {
            Log.w(TAG, ""onImageAvailable called but no image!"");
            return;
        }

        if (mTestStatus == TestStatus.RUNNING) {
            int ret = scanImage(image);
            if (ret == -1) {
                mStatusView.setText(""Failed: saw unexpected color"");
                getPassButton().setEnabled(false);
                mTestStatus = TestStatus.FAILED;
            } else if (ret != mPreviousColor && ret == Color.BLUE) {
                mStatusView.setText(""Success: virtual display rendered expected color"");
                getPassButton().setEnabled(true);
                mTestStatus = TestStatus.PASSED;
            }
        }
        image.close();
    }

    // modified from the VirtualDisplay Cts test
    /**
     * Gets the color of the image and ensures all the pixels are the same color
     * @param image input image
     * @return The color of the image, or -1 for failure
     */
    private int scanImage(Image image) {
        final Image.Plane plane = image.getPlanes()[0];
        final ByteBuffer buffer = plane.getBuffer();
        final int width = image.getWidth();
        final int height = image.getHeight();
        final int pixelStride = plane.getPixelStride();
        final int rowStride = plane.getRowStride();
        final int rowPadding = rowStride - pixelStride * width;

        Log.d(TAG, ""- Scanning image: width="" + width + "", height="" + height
                + "", pixelStride="" + pixelStride + "", rowStride="" + rowStride);

        int offset = 0;
        int blackPixels = 0;
        int bluePixels = 0;
        int otherPixels = 0;
        for (int y = 0; y < height; y++) {
            for (int x = 0; x < width; x++) {
                int pixel = 0;
                pixel |= (buffer.get(offset) & 0xff) << 16;     // R
                pixel |= (buffer.get(offset + 1) & 0xff) << 8;  // G
                pixel |= (buffer.get(offset + 2) & 0xff);       // B
                pixel |= (buffer.get(offset + 3) & 0xff) << 24; // A
                if (pixel == Color.BLACK || pixel == 0) {
                    blackPixels += 1;
                } else if (pixel == Color.BLUE) {
                    bluePixels += 1;
                } else {
                    otherPixels += 1;
                    if (otherPixels < 10) {
                        Log.d(TAG, ""- Found unexpected color: "" + Integer.toHexString(pixel));
                    }
                }
                offset += pixelStride;
            }
            offset += rowPadding;
        }

        // Return a color if it represents all of the pixels.
        Log.d(TAG, ""- Pixels: "" + blackPixels + "" black, ""
                + bluePixels + "" blue, ""
                + otherPixels + "" other"");
        if (blackPixels == width * height) {
            return Color.BLACK;
        } else if (bluePixels == width * height) {
            return Color.BLUE;
        } else {
            return -1;
        }
    }

    private void dropLatestImage(ImageReader reader) {
        Image image = reader.acquireLatestImage();
        if (image != null) {
            image.close();
        }
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.bluetooth.cts.BluetoothLeScanTest"	"isEnabled"	"CtsBluetoothTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/bluetooth/src/android/bluetooth/cts/BluetoothLeScanTest.java"	""	"public void test/*
 *.
 */

package android.bluetooth.cts;

import android.app.PendingIntent;
import android.bluetooth.BluetoothAdapter;
import android.bluetooth.BluetoothManager;
import android.bluetooth.le.BluetoothLeScanner;
import android.bluetooth.le.ScanCallback;
import android.bluetooth.le.ScanFilter;
import android.bluetooth.le.ScanRecord;
import android.bluetooth.le.ScanResult;
import android.bluetooth.le.ScanSettings;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.os.ParcelUuid;
import android.os.SystemClock;
import android.test.AndroidTestCase;
import android.test.suitebuilder.annotation.MediumTest;
import android.util.Log;
import android.util.SparseArray;

import androidx.test.InstrumentationRegistry;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

/**
 * Test cases for Bluetooth LE scans.
 * <p>
 * To run the test, the device must be placed in an environment that has at least 3 beacons, all
 * placed less than 5 meters away from the DUT.
 * <p>
 * Run 'run cts --class android.bluetooth.cts.BluetoothLeScanTest' in cts-tradefed to run the test
 * cases.
 */
public class BluetoothLeScanTest extends AndroidTestCase {

    private static final String TAG = ""BluetoothLeScanTest"";

    private static final int SCAN_DURATION_MILLIS = 10000;
    private static final int BATCH_SCAN_REPORT_DELAY_MILLIS = 20000;
    private static final int SCAN_STOP_TIMEOUT = 2000;
    private CountDownLatch mFlushBatchScanLatch;

    private BluetoothAdapter mBluetoothAdapter;
    private BluetoothLeScanner mScanner;
    // Whether location is on before running the tests.
    private boolean mLocationOn;

    @Override
    public void setUp() {
        if (!TestUtils.isBleSupported(getContext())) {
            return;
        }
        BluetoothManager manager = (BluetoothManager) mContext.getSystemService(
                Context.BLUETOOTH_SERVICE);
        mBluetoothAdapter = manager.getAdapter();
        if (!mBluetoothAdapter.isEnabled()) {
            assertTrue(BTAdapterUtils.enableAdapter(mBluetoothAdapter, mContext));
        }
        mScanner = mBluetoothAdapter.getBluetoothLeScanner();
        mLocationOn = TestUtils.isLocationOn(getContext());
        if (!mLocationOn) {
            TestUtils.enableLocation(getContext());
        }
        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                ""android.bluetooth.cts"", android.Manifest.permission.ACCESS_FINE_LOCATION);
    }

    @Override
    public void tearDown() {
        if (!TestUtils.isBleSupported(getContext())) {
          // mBluetoothAdapter == null.
          return;
        }

        if (!mLocationOn) {
            TestUtils.disableLocation(getContext());
        }
        assertTrue(BTAdapterUtils.disableAdapter(mBluetoothAdapter, mContext));
    }

    /**
     * Basic test case for BLE scans. Checks BLE scan timestamp is within correct range.
     */
    @MediumTest"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.bluetooth.cts.BluetoothLeScanTest"	"testBasicBleScan"	"CtsBluetoothTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/bluetooth/src/android/bluetooth/cts/BluetoothLeScanTest.java"	""	"public void testBasicBleScan() {
        if (!TestUtils.isBleSupported(getContext())) {
            return;
        }
        long scanStartMillis = SystemClock.elapsedRealtime();
        Collection<ScanResult> scanResults = scan();
        long scanEndMillis = SystemClock.elapsedRealtime();
        Log.d(TAG, ""scan result size:"" + scanResults.size());
        assertTrue(""Scan results shouldn't be empty"", !scanResults.isEmpty());
        verifyTimestamp(scanResults, scanStartMillis, scanEndMillis);
    }

    /**
     * Test of scan filters. Ensures only beacons matching certain type of scan filters were
     * reported.
     */
    @MediumTest"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.bluetooth.cts.BluetoothLeScanTest"	"testScanFilter"	"CtsBluetoothTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/bluetooth/src/android/bluetooth/cts/BluetoothLeScanTest.java"	""	"public void testScanFilter() {
        if (!TestUtils.isBleSupported(getContext())) {
            return;
        }

        List<ScanFilter> filters = new ArrayList<ScanFilter>();
        ScanFilter filter = createScanFilter();
        if (filter == null) {
            Log.d(TAG, ""no appropriate filter can be set"");
            return;
        }
        filters.add(filter);

        BleScanCallback filterLeScanCallback = new BleScanCallback();
        ScanSettings settings = new ScanSettings.Builder().setScanMode(
                ScanSettings.SCAN_MODE_LOW_LATENCY).build();
        mScanner.startScan(filters, settings, filterLeScanCallback);
        TestUtils.sleep(SCAN_DURATION_MILLIS);
        mScanner.stopScan(filterLeScanCallback);
        TestUtils.sleep(SCAN_STOP_TIMEOUT);
        Collection<ScanResult> scanResults = filterLeScanCallback.getScanResults();
        for (ScanResult result : scanResults) {
            assertTrue(filter.matches(result));
        }
    }

    // Create a scan filter based on the nearby beacon with highest signal strength.
    private ScanFilter createScanFilter() {
        // Get a list of nearby beacons.
        List<ScanResult> scanResults = new ArrayList<ScanResult>(scan());
        assertTrue(""Scan results shouldn't be empty"", !scanResults.isEmpty());
        // Find the beacon with strongest signal strength, which is the target device for filter
        // scan.
        Collections.sort(scanResults, new RssiComparator());
        ScanResult result = scanResults.get(0);
        ScanRecord record = result.getScanRecord();
        if (record == null) {
            return null;
        }
        Map<ParcelUuid, byte[]> serviceData = record.getServiceData();
        if (serviceData != null && !serviceData.isEmpty()) {
            ParcelUuid uuid = serviceData.keySet().iterator().next();
            return new ScanFilter.Builder().setServiceData(uuid, new byte[]{0},
                    new byte[]{0}).build();
        }
        SparseArray<byte[]> manufacturerSpecificData = record.getManufacturerSpecificData();
        if (manufacturerSpecificData != null && manufacturerSpecificData.size() > 0) {
            return new ScanFilter.Builder().setManufacturerData(manufacturerSpecificData.keyAt(0),
                    new byte[]{0}, new byte[]{0}).build();
        }
        List<ParcelUuid> serviceUuids = record.getServiceUuids();
        if (serviceUuids != null && !serviceUuids.isEmpty()) {
            return new ScanFilter.Builder().setServiceUuid(serviceUuids.get(0)).build();
        }
        return null;
    }

//    /**
//     * Test of opportunistic BLE scans.
//     * Temporarily disable this test because it is interfered by the GmsCore;
//     * it fails when it obtains results from GmsCore explicit scan.
//     * TODO(b/70865144): re-enable this test.
//     */
//    @MediumTest
//"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.bluetooth.cts.BluetoothLeScanTest"	"testOpportunisticScan"	"CtsBluetoothTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/bluetooth/src/android/bluetooth/cts/BluetoothLeScanTest.java"	""	"public void testOpportunisticScan() {
//        if (!TestUtils.isBleSupported(getContext())) {
//            return;
//        }
//        ScanSettings opportunisticScanSettings = new ScanSettings.Builder()
//                .setScanMode(ScanSettings.SCAN_MODE_OPPORTUNISTIC)
//                .build();
//        BleScanCallback emptyScanCallback = new BleScanCallback();
//        assertTrue(""opportunistic scan shouldn't have scan results"",
//                emptyScanCallback.getScanResults().isEmpty());
//
//        // No scans are really started with opportunistic scans only.
//        mScanner.startScan(Collections.<ScanFilter>emptyList(), opportunisticScanSettings,
//                emptyScanCallback);
//        sleep(SCAN_DURATION_MILLIS);
//        Log.d(TAG, ""result: "" + emptyScanCallback.getScanResults());
//        assertTrue(""opportunistic scan shouldn't have scan results"",
//                emptyScanCallback.getScanResults().isEmpty());
//
//        BleScanCallback regularScanCallback = new BleScanCallback();
//        ScanSettings regularScanSettings = new ScanSettings.Builder()
//                .setScanMode(ScanSettings.SCAN_MODE_LOW_LATENCY).build();
//        List<ScanFilter> filters = new ArrayList<>();
//        ScanFilter filter = createScanFilter();
//        if (filter != null) {
//            filters.add(filter);
//        } else {
//            Log.d(TAG, ""no appropriate filter can be set"");
//        }
//        mScanner.startScan(filters, regularScanSettings, regularScanCallback);
//        sleep(SCAN_DURATION_MILLIS);
//        // With normal BLE scan client, opportunistic scan client will get scan results.
//        assertTrue(""opportunistic scan results shouldn't be empty"",
//                !emptyScanCallback.getScanResults().isEmpty());
//
//        // No more scan results for opportunistic scan clients once the normal BLE scan clients
//        // stops.
//        mScanner.stopScan(regularScanCallback);
//        // In case we got scan results before scan was completely stopped.
//        sleep(SCAN_STOP_TIMEOUT);
//        emptyScanCallback.clear();
//        sleep(SCAN_DURATION_MILLIS);
//        assertTrue(""opportunistic scan shouldn't have scan results"",
//                emptyScanCallback.getScanResults().isEmpty());
//    }

    /**
     * Test case for BLE Batch scan.
     */
    @MediumTest"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.bluetooth.cts.BluetoothLeScanTest"	"testBatchScan"	"CtsBluetoothTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/bluetooth/src/android/bluetooth/cts/BluetoothLeScanTest.java"	""	"public void testBatchScan() {
        if (!TestUtils.isBleSupported(getContext()) || !isBleBatchScanSupported()) {
            Log.d(TAG, ""BLE or BLE batching not suppported"");
            return;
        }
        ScanSettings batchScanSettings = new ScanSettings.Builder()
                .setScanMode(ScanSettings.SCAN_MODE_LOW_LATENCY)
                .setReportDelay(BATCH_SCAN_REPORT_DELAY_MILLIS).build();
        BleScanCallback batchScanCallback = new BleScanCallback();
        mScanner.startScan(Collections.<ScanFilter>emptyList(), batchScanSettings,
                batchScanCallback);
        TestUtils.sleep(SCAN_DURATION_MILLIS);
        mScanner.flushPendingScanResults(batchScanCallback);
        mFlushBatchScanLatch = new CountDownLatch(1);
        List<ScanResult> results = batchScanCallback.getBatchScanResults();
        try {
            mFlushBatchScanLatch.await(5, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
            // Nothing to do.
            Log.e(TAG, ""interrupted!"");
        }
        assertTrue(!results.isEmpty());
        long scanEndMillis = SystemClock.elapsedRealtime();
        mScanner.stopScan(batchScanCallback);
        verifyTimestamp(results, 0, scanEndMillis);
    }

    /**
     * Test case for starting a scan with a PendingIntent.
     */
    @MediumTest"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.bluetooth.cts.BluetoothLeScanTest"	"testStartScanPendingIntent_nullnull"	"CtsBluetoothTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/bluetooth/src/android/bluetooth/cts/BluetoothLeScanTest.java"	""	"public void testStartScanPendingIntent_nullnull() throws Exception {
        if (!TestUtils.isBleSupported(getContext()) || !isBleBatchScanSupported()) {
            Log.d(TAG, ""BLE or BLE batching not suppported"");
            return;
        }
        Intent broadcastIntent = new Intent();
        broadcastIntent.setClass(mContext, BluetoothScanReceiver.class);
        PendingIntent pi = PendingIntent.getBroadcast(mContext, 1, broadcastIntent,
            PendingIntent.FLAG_IMMUTABLE);
        CountDownLatch latch = BluetoothScanReceiver.createCountDownLatch();
        mScanner.startScan(null, null, pi);
        boolean gotResults = latch.await(20, TimeUnit.SECONDS);
        mScanner.stopScan(pi);
        assertTrue(""Scan results not received"", gotResults);
    }

    /**
     * Test case for starting a scan with a PendingIntent.
     */
    @MediumTest"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.bluetooth.cts.BluetoothLeScanTest"	"testStartScanPendingIntent"	"CtsBluetoothTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/bluetooth/src/android/bluetooth/cts/BluetoothLeScanTest.java"	""	"public void testStartScanPendingIntent() throws Exception {
        if (!TestUtils.isBleSupported(getContext()) || !isBleBatchScanSupported()) {
            Log.d(TAG, ""BLE or BLE batching not suppported"");
            return;
        }
        ScanSettings batchScanSettings = new ScanSettings.Builder()
                .setScanMode(ScanSettings.SCAN_MODE_LOW_LATENCY)
                .setReportDelay(0).build();
        ScanFilter filter = createScanFilter();
        ArrayList<ScanFilter> filters = null;
        if (filter != null) {
            filters = new ArrayList<>();
            filters.add(filter);
        } else {
            Log.d(TAG, ""Could not add a filter"");
        }
        Intent broadcastIntent = new Intent();
        broadcastIntent.setClass(mContext, BluetoothScanReceiver.class);
        PendingIntent pi = PendingIntent.getBroadcast(mContext, 1, broadcastIntent,
            PendingIntent.FLAG_IMMUTABLE);
        CountDownLatch latch = BluetoothScanReceiver.createCountDownLatch();
        mScanner.startScan(filters, batchScanSettings, pi);
        boolean gotResults = latch.await(20, TimeUnit.SECONDS);
        mScanner.stopScan(pi);
        assertTrue(""Scan results not received"", gotResults);
    }

    // Verify timestamp of all scan results are within [scanStartMillis, scanEndMillis].
    private void verifyTimestamp(Collection<ScanResult> results, long scanStartMillis,
            long scanEndMillis) {
        for (ScanResult result : results) {
            long timestampMillis = TimeUnit.NANOSECONDS.toMillis(result.getTimestampNanos());
            assertTrue(""Invalid timestamp: "" + timestampMillis + "" should be >= "" + scanStartMillis,
                    timestampMillis >= scanStartMillis);
            assertTrue(""Invalid timestamp: "" + timestampMillis + "" should be <= "" + scanEndMillis,
                    timestampMillis <= scanEndMillis);
        }
    }

    // Helper class for BLE scan callback.
    private class BleScanCallback extends ScanCallback {
        private Set<ScanResult> mResults = new HashSet<ScanResult>();
        private List<ScanResult> mBatchScanResults = new ArrayList<ScanResult>();

        @Override
        public void onScanResult(int callbackType, ScanResult result) {
            if (callbackType == ScanSettings.CALLBACK_TYPE_ALL_MATCHES) {
                mResults.add(result);
            }
        }

        @Override
        public void onBatchScanResults(List<ScanResult> results) {
            // In case onBatchScanResults are called due to buffer full, we want to collect all
            // scan results.
            mBatchScanResults.addAll(results);
            if (mFlushBatchScanLatch != null) {
                mFlushBatchScanLatch.countDown();
            }
        }

        // Clear regular and batch scan results.
        synchronized public void clear() {
            mResults.clear();
            mBatchScanResults.clear();
        }

        // Return regular BLE scan results accumulated so far.
        synchronized Set<ScanResult> getScanResults() {
            return Collections.unmodifiableSet(mResults);
        }

        // Return batch scan results.
        synchronized List<ScanResult> getBatchScanResults() {
            return Collections.unmodifiableList(mBatchScanResults);
        }
    }

    private class RssiComparator implements Comparator<ScanResult> {

        @Override
        public int compare(ScanResult lhs, ScanResult rhs) {
            return rhs.getRssi() - lhs.getRssi();
        }

    }

    // Perform a BLE scan to get results of nearby BLE devices.
    private Set<ScanResult> scan() {
        BleScanCallback regularLeScanCallback = new BleScanCallback();
        mScanner.startScan(regularLeScanCallback);
        TestUtils.sleep(SCAN_DURATION_MILLIS);
        mScanner.stopScan(regularLeScanCallback);
        TestUtils.sleep(SCAN_STOP_TIMEOUT);
        return regularLeScanCallback.getScanResults();
    }

    // Returns whether offloaded scan batching is supported.
    private boolean isBleBatchScanSupported() {
        return mBluetoothAdapter.isOffloadedScanBatchingSupported();
    }

}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.storageapp.StorageTest"	"testBehaviorTombstone"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/StorageApp/src/com/android/cts/storageapp/StorageTest.java"	""	"public void testBehaviorTombstone() throws Exception {
        final StorageManager sm = getContext().getSystemService(StorageManager.class);

        final File dir = makeUniqueFile(getContext().getCacheDir());
        dir.mkdir();
        sm.setCacheBehaviorTombstone(dir, true);
        assertTrue(sm.isCacheBehaviorTombstone(dir));

        final File ext = makeUniqueFile(getContext().getExternalCacheDir());
        ext.mkdir();
        try { sm.setCacheBehaviorTombstone(ext, true); fail(); } catch (IOException expected) { }
        try { sm.setCacheBehaviorTombstone(ext, false); fail(); } catch (IOException expected) { }
    }

    /**
     * Create ""cts"" probe files in every possible common storage location that
     * we can think of.
     */"	""	""	"probe"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.storageapp.StorageTest"	"testExternalStorageIsolatedWrite"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/StorageApp/src/com/android/cts/storageapp/StorageTest.java"	""	"public void testExternalStorageIsolatedWrite() throws Exception {
        final Context context = getContext();
        final List<File> paths = new ArrayList<File>();
        Collections.addAll(paths, Environment.getExternalStorageDirectory());
        Collections.addAll(paths,
                Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES));
        Collections.addAll(paths, context.getExternalCacheDirs());
        Collections.addAll(paths, context.getExternalFilesDirs(null));
        Collections.addAll(paths, context.getExternalFilesDirs(Environment.DIRECTORY_PICTURES));
        Collections.addAll(paths, context.getExternalMediaDirs());
        Collections.addAll(paths, context.getObbDirs());

        final String name = ""cts_"" + System.nanoTime();
        for (File path : paths) {
            final File otherPath = new File(path.getAbsolutePath()
                    .replace(""com.android.cts.storageapp_a"", ""com.android.cts.storageapp_b""));

            path.mkdirs();
            otherPath.mkdirs();

            final File file = new File(path, name);
            final File otherFile = new File(otherPath, name);

            file.createNewFile();
            otherFile.createNewFile();

            assertTrue(file.exists());
            assertTrue(otherFile.exists());
        }
    }

    /**
     * Verify that we can't see any of the ""cts"" probe files created above,
     * since our storage should be fully isolated.
     */"	""	""	"probe"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.audio.MidiJavaTestActivity"	"MidiJavaTestActivity"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/audio/MidiJavaTestActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.audio;

import java.io.IOException;
import java.util.ArrayList;

import android.media.midi.MidiDevice;
import android.media.midi.MidiDeviceInfo;
import android.media.midi.MidiInputPort;
import android.media.midi.MidiManager;
import android.media.midi.MidiReceiver;
import android.os.Bundle;
import android.util.Log;

import com.android.cts.verifier.R;

import com.android.cts.verifier.audio.midilib.MidiIODevice;

/*
 * A note about the USB MIDI device.
 * Any USB MIDI peripheral with standard female DIN jacks can be used. A standard MIDI cable
 * plugged into both input and output is required for the USB Loopback Test. A Bluetooth MIDI
 * device like the Yamaha MD-BT01 plugged into both input and output is required for the
 * Bluetooth Loopback test.
 */

/*
 *  A note about the ""virtual MIDI"" device...
 * See file MidiEchoService for implementation of the echo server itself.
 * This service is started by the main manifest file (AndroidManifest.xml).
 */

/*
 * A note about Bluetooth MIDI devices...
 * Any Bluetooth MIDI device needs to be paired with the DUT with the ""MIDI+BTLE"" application
 * available in the Play Store:
 * (https://play.google.com/store/apps/details?id=com.mobileer.example.midibtlepairing).
 */

/**
 * CTS Verifier Activity for MIDI test
 */
public class MidiJavaTestActivity extends MidiTestActivityBase {
    private static final String TAG = ""MidiJavaTestActivity"";
    private static final boolean DEBUG = false;

    public MidiJavaTestActivity() {
        super();
        initTestModules(new JavaMidiTestModule(MidiDeviceInfo.TYPE_USB),
                new JavaMidiTestModule(MidiDeviceInfo.TYPE_VIRTUAL),
                new BTMidiTestModule());
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        if (DEBUG) {
            Log.i(TAG, ""---- onCreate()"");
        }

        setContentView(R.layout.midi_activity);

        super.onCreate(savedInstanceState);

        startMidiEchoServer();
        scanMidiDevices();

        connectDeviceListener();
    }

    //
    // MIDI Messages
    //
    // channel-oriented message (Commands)
    public static final byte MIDICMD_NOTEON = 9;
    public static final byte MIDICMD_NOTEOFF = 8;
    public static final byte MIDICMD_POLYPRESS = 10;
    public static final byte MIDICMD_CONTROL = 11;
    public static final byte MIDICMD_PROGRAMCHANGE = 12;
    public static final byte MIDICMD_CHANNELPRESS = 13;
    public static final byte MIDICMD_PITCHWHEEL = 14;
    public static final byte MIDICMD_SYSEX = (byte)0xF0;
    public static final byte MIDICMD_EOSYSEX = (byte)0xF7; // (byte)0b11110111;    // 0xF7

    private class TestMessage {
        public byte[]   mMsgBytes;

        public boolean matches(byte[] msg, int offset, int count) {
            // Length
            if (DEBUG) {
                Log.i(TAG, ""  count ["" + count + "" : "" + mMsgBytes.length + ""]"");
            }
            if (count != mMsgBytes.length) {
                return false;
            }

            // Data
            for(int index = 0; index < count; index++) {
                if (DEBUG) {
                    Log.i(TAG, ""  ["" + msg[offset + index] + "" : "" + mMsgBytes[index] + ""]"");
                }
                if (msg[offset + index] != mMsgBytes[index]) {
                    return false;
                }
            }
            return true;
        }
    } /* class TestMessage */

    private static byte makeMIDICmd(int cmd, int channel) {
        return (byte)((cmd << 4) | (channel & 0x0F));
    }

    //
    // Logging Utility
    //
    static void logByteArray(String prefix, byte[] value, int offset, int count) {
        StringBuilder builder = new StringBuilder(prefix);
        for (int i = 0; i < count; i++) {
            builder.append(String.format(""0x%02X"", value[offset + i]));
            if (i != value.length - 1) {
                builder.append("", "");
            }
        }
        Log.d(TAG, builder.toString());
    }

    static void logByteArray(String prefix, ArrayList<Byte> value, int offset) {
        StringBuilder builder = new StringBuilder(prefix);
        for (int i = 0; i < value.size(); i++) {
            builder.append(String.format(""0x%02X"", value.get(offset + i)));
            if (i != value.size() - 1) {
                builder.append("", "");
            }
        }
        Log.d(TAG, builder.toString());
    }

    /**
     * A class to control and represent the state of a given test.
     * It hold the data needed for IO, and the logic for sending, receiving and matching
     * the MIDI data stream.
     */
    private class JavaMidiTestModule extends MidiTestModule {
        private static final String TAG = ""JavaMidiTestModule"";

        protected boolean mTestMismatched;

        // Test Data
        // - The set of messages to send
        private TestMessage[] mTestMessages;

        // - The stream of message data to walk through when MIDI data is received.
        // NOTE: To work on USB Audio Peripherals that drop the first message
        // (AudioBoxUSB), have 2 streams to match against, one with the ""warm-up""
        // message in tact (""Nominal"") and one where it is absent.
        private ArrayList<Byte> mMatchStream = new ArrayList<Byte>();

        private int mReceiveStreamPos;
        private static final int MESSAGE_MAX_BYTES = 1024;

        // Some MIDI interfaces have been know to consistently drop the first message
        // Send one to throw away. If it shows up, ignore it. If it doesn't then
        // there is nothing there to ignore and the remainder should be legitimate.
        // Use the MIDI CONTROL command to identify this ""warm-up"" message
        private byte[] mWarmUpMsg = {makeMIDICmd(MIDICMD_CONTROL, 0), 0, 0};

        public JavaMidiTestModule(int deviceType) {
            super(deviceType);
            setupTestMessages();
        }

        @Override
        void startLoopbackTest(int testId) {
            synchronized (mTestLock) {
                mTestRunning = true;
                enableTestButtons(false);
            }

            if (DEBUG) {
                Log.i(TAG, ""---- startLoopbackTest()"");
            }

            mTestStatus = TESTSTATUS_NOTRUN;
            mTestMismatched = false;
            mReceiveStreamPos = 0;

            mRunningTestID = testId;

            // These might be left open due to a failing, previous test
            // so just to be sure...
            closePorts();

            if (mIODevice.mSendDevInfo != null) {
                mMidiManager.openDevice(mIODevice.mSendDevInfo, new TestModuleOpenListener(), null);
            }

            startTimeoutHandler();
        }

        protected void openPorts(MidiDevice device) {
            mIODevice.openPorts(device, new MidiMatchingReceiver());
        }

        protected void closePorts() {
            mIODevice.closePorts();
        }

        @Override
        boolean hasTestPassed() {
            return mTestStatus == TESTSTATUS_PASSED;
        }

        // A little explanation here... It seems reasonable to send complete MIDI messages, i.e.
        // as a set of discrete pakages.
        // However the looped-back data may not be delivered in message-size packets, so it makes more
        // sense to look at that as a stream of bytes.
        // So we build a set of messages to send, and then create the equivalent stream of bytes
        // from that to match against when received back in from the looped-back device.
        private void setupTestMessages() {
            if (DEBUG) {
                Log.i(TAG, ""setupTestMessages()"");
            }
            int NUM_TEST_MESSAGES = 3;
            mTestMessages = new TestMessage[NUM_TEST_MESSAGES];

            //TODO - Investgate using ByteArrayOutputStream for these data streams.

            //
            // Set up any set of messages you want
            // Except for the command IDs, the data values are purely arbitrary and meaningless
            // outside of being matched.
            // KeyDown
            mTestMessages[0] = new TestMessage();
            mTestMessages[0].mMsgBytes = new byte[]{makeMIDICmd(MIDICMD_NOTEON, 0), 64, 12};

            // KeyUp
            mTestMessages[1] = new TestMessage();
            mTestMessages[1].mMsgBytes = new byte[]{makeMIDICmd(MIDICMD_NOTEOFF, 0), 73, 65};

            // SysEx
            // NOTE: A sysex on the MT-BT01 seems to top out at sometimes as low as 40 bytes.
            // It is not clear, but needs more research. For now choose a conservative size.
            int sysExSize = 32;
            byte[] sysExMsg = new byte[sysExSize];
            sysExMsg[0] = MIDICMD_SYSEX;
            for(int index = 1; index < sysExSize-1; index++) {
                sysExMsg[index] = (byte)index;
            }
            sysExMsg[sysExSize-1] = (byte) MIDICMD_EOSYSEX;
            mTestMessages[2] = new TestMessage();
            mTestMessages[2].mMsgBytes = sysExMsg;

            //
            // Now build the stream to match against
            //
            mMatchStream.clear();
            for(int byteIndex = 0; byteIndex < mWarmUpMsg.length; byteIndex++) {
                mMatchStream.add(mWarmUpMsg[byteIndex]);
            }
            for (int msgIndex = 0; msgIndex < mTestMessages.length; msgIndex++) {
                for(int byteIndex = 0; byteIndex < mTestMessages[msgIndex].mMsgBytes.length; byteIndex++) {
                    mMatchStream.add(mTestMessages[msgIndex].mMsgBytes[byteIndex]);
                }
            }

            mReceiveStreamPos = 0;

            if (DEBUG) {
                logByteArray(""mMatchStream: "", mMatchStream, 0);
            }
        }

        /**
         * Compares the supplied bytes against the sent message stream at the current position
         * and advances the stream position.
         */
        private boolean matchStream(byte[] bytes, int offset, int count) {
            if (DEBUG) {
                Log.i(TAG, ""---- matchStream() offset:"" + offset + "" count:"" + count);
            }
            // a little bit of checking here...
            if (count < 0) {
                Log.e(TAG, ""Negative Byte Count in MidiActivity::matchStream()"");
                return false;
            }

            if (count > MESSAGE_MAX_BYTES) {
                Log.e(TAG, ""Too Large Byte Count ("" + count + "") in MidiActivity::matchStream()"");
                return false;
            }

            boolean matches = true;

            for (int index = 0; index < count; index++) {
                // Avoid a buffer overrun. Still don't understand why it happens
                if (mReceiveStreamPos >= mMatchStream.size()) {
                    // report an error here
                    Log.d(TAG, ""matchStream buffer overrun @"" + index +
                            "" of "" + mMatchStream.size());
                    // Dump the bufer here
                    logByteArray(""Expected: "", mMatchStream, 0);
                    matches = false;
                    break;  // bail
                }

                if (bytes[offset + index] != mMatchStream.get(mReceiveStreamPos)) {
                    matches = false;
                    if (DEBUG) {
                        int gotValue = bytes[offset + index] & 0x000000FF;
                        int expectedValue = mMatchStream.get(mReceiveStreamPos) & 0x000000FF;
                        Log.i(TAG, ""---- mismatch @""
                                + index
                                + "" [0x"" + Integer.toHexString(gotValue)
                                + "" : 0x"" + Integer.toHexString(expectedValue)
                                + ""]"");
                    }
                    break;
                }
                mReceiveStreamPos++;
            }

            if (DEBUG) {
                Log.i(TAG, ""  returns:"" + matches);
            }

            return matches;
        }

        // In some instances, BlueTooth MIDI in particular, it is possible to overrun
        // the bandwidth, resulting in lost data. In this case, slow the data stream
        // down.
        private static final int THROTTLE_PERIOD_MS = 10;
        private void portSend(MidiInputPort inputPort, byte[] bytes, int offset, int length,
                              boolean throttle) {
            if (DEBUG) {
                Log.i(TAG, ""portSend() throttle:"" + throttle);
            }
            try {
                if (throttle) {
                    try {
                        for (int index = 0; index < length; index++) {
                            inputPort.send(bytes, offset + index, 1);
                            Thread.sleep(THROTTLE_PERIOD_MS);
                        }
                    } catch (InterruptedException ex) {
                        Log.i(TAG, ""---- InterruptedException "" + ex);
                    }
                } else {
                    inputPort.send(bytes, offset, length);
                }
            } catch (IOException ex) {
                Log.i(TAG, ""---- IOException "" + ex);
            }
        }

        /**
         * Writes out the list of MIDI messages to the output port.
         */
        private void sendMessages() {
            if (DEBUG) {
                Log.i(TAG, ""---- sendMessages()..."");
            }

            synchronized (mTestLock) {
                int totalSent = 0;
                if (mIODevice.mSendPort != null) {
                    // Send a warm-up message...
                    logByteArray(""warm-up: "", mWarmUpMsg, 0, mWarmUpMsg.length);
                    portSend(mIODevice.mSendPort, mWarmUpMsg, 0, mWarmUpMsg.length,
                            mRunningTestID == TESTID_BTLOOPBACK);

                    for (TestMessage msg : mTestMessages) {
                        if (DEBUG) {
                            logByteArray(""send: "", msg.mMsgBytes, 0, msg.mMsgBytes.length);
                        }
                        portSend(mIODevice.mSendPort, msg.mMsgBytes, 0, msg.mMsgBytes.length,
                                mRunningTestID == TESTID_BTLOOPBACK);
                        totalSent += msg.mMsgBytes.length;
                    }
                }
                if (DEBUG) {
                    Log.i(TAG, ""---- totalSent:"" + totalSent);
                }
            }
        }

        /**
         * Listens for MIDI device opens. Opens I/O ports and sends out the apriori
         * setup messages.
         */
        class TestModuleOpenListener implements MidiManager.OnDeviceOpenedListener {
            @Override
            public void onDeviceOpened(MidiDevice device) {
                if (DEBUG) {
                    Log.i(TAG, ""---- onDeviceOpened()"");
                }
                openPorts(device);
                sendMessages();
            }
        }

        /**
         * A MidiReceiver subclass whose job it is to monitor incomming messages
         * and match them against the stream sent by the test.
         */
        private class MidiMatchingReceiver extends MidiReceiver {
            private static final String TAG = ""MidiMatchingReceiver"";

            @Override
            public void onSend(byte[] msg, int offset, int count, long timestamp) throws IOException {
                if (DEBUG) {
                    Log.i(TAG, ""---- onSend(offset:"" + offset + "" count:"" + count);
                    logByteArray(""bytes-received: "", msg, offset, count);
                }
                synchronized (mTestLock) {
                    if (!mTestRunning) {
                        return;
                    }

                    // Check for ""Warm Up"" message
                    if (mReceiveStreamPos == 0 && msg[offset] != makeMIDICmd(MIDICMD_CONTROL, 0)) {
                        // advance the match stream past the ""warm-up"" message
                        mReceiveStreamPos += mWarmUpMsg.length;
                        if (DEBUG) {
                            Log.i(TAG, ""---- No Warm Up Message Detected."");
                        }
                    }

                    mTestMismatched = !matchStream(msg, offset, count);

                    if (mTestMismatched || mReceiveStreamPos == mMatchStream.size()) {
                        mTestRunning = false;
                        mRunningTestID = TESTID_NONE;

                        if (DEBUG) {
                            Log.i(TAG, ""---- Test Complete"");
                        }
                        // defer closing the ports to outside of this callback.
                        new Thread(new Runnable() {
                            public void run() {
                                mTestStatus = mTestMismatched
                                        ? TESTSTATUS_FAILED_MISMATCH : TESTSTATUS_PASSED;
                                closePorts();
                            }
                        }).start();

                        enableTestButtons(true);
                        updateTestStateUI();
                    }
                }
            }
        } /* class MidiMatchingReceiver */
    } /* class JavaMidiTestModule */

    /**
     * Test Module for Bluetooth Loopback.
     * This is a specialization of JavaMidiTestModule (which has the connections for the BL device
     * itself) with and added MidiIODevice object for the USB audio device which does the
     * ""looping back"".
     */
    private class BTMidiTestModule extends JavaMidiTestModule {
        private static final String TAG = ""BTMidiTestModule"";
        private MidiIODevice mUSBLoopbackDevice = new MidiIODevice(MidiDeviceInfo.TYPE_USB);

        public BTMidiTestModule() {
            super(MidiDeviceInfo.TYPE_BLUETOOTH );
        }

        @Override
        public void scanDevices(MidiDeviceInfo[] devInfos) {
            // (normal) Scan for BT MIDI device
            super.scanDevices(devInfos);
            // Find a USB Loopback Device
            mUSBLoopbackDevice.scanDevices(devInfos);
        }

        private void openUSBEchoDevice(MidiDevice device) {
            MidiDeviceInfo deviceInfo = device.getInfo();
            int numOutputs = deviceInfo.getOutputPortCount();
            if (numOutputs > 0) {
                mUSBLoopbackDevice.mReceivePort = device.openOutputPort(0);
                mUSBLoopbackDevice.mReceivePort.connect(new USBMidiEchoReceiver());
            }

            int numInputs = deviceInfo.getInputPortCount();
            if (numInputs != 0) {
                mUSBLoopbackDevice.mSendPort = device.openInputPort(0);
            }
        }

        protected void closePorts() {
            super.closePorts();
            mUSBLoopbackDevice.closePorts();
        }

        @Override
        void startLoopbackTest(int testID) {
            if (DEBUG) {
                Log.i(TAG, ""---- startLoopbackTest()"");
            }

            // Setup the USB Loopback Device
            mUSBLoopbackDevice.closePorts();

            if (mIODevice.mSendDevInfo != null) {
                mMidiManager.openDevice(
                        mUSBLoopbackDevice.mSendDevInfo, new USBLoopbackOpenListener(), null);
            }

            // Now start the test as usual
            super.startLoopbackTest(testID);
        }

        /**
         * We need this OnDeviceOpenedListener to open the USB-Loopback device
         */
        private class USBLoopbackOpenListener implements MidiManager.OnDeviceOpenedListener {
            @Override
            public void onDeviceOpened(MidiDevice device) {
                if (DEBUG) {
                    Log.i(""USBLoopbackOpenListener"", ""---- onDeviceOpened()"");
                }
                mUSBLoopbackDevice.openPorts(device, new USBMidiEchoReceiver());
            }
        } /* class USBLoopbackOpenListener */

        /**
         * MidiReceiver subclass for BlueTooth Loopback Test
         *
         * This class receives bytes from the USB Interface (presumably coming from the
         * Bluetooth MIDI peripheral) and echoes them back out (presumably to the Bluetooth
         * MIDI peripheral).
         */
        //TODO - This could be pulled out into a separate class and shared with the identical
        // code in MidiNativeTestActivity if we pass in the USB Loopback Device object rather
        // than accessing it from the enclosing BTMidiTestModule class.
        private class USBMidiEchoReceiver extends MidiReceiver {
            private int mTotalBytesEchoed;

            @Override
            public void onSend(byte[] msg, int offset, int count, long timestamp) throws IOException {
                mTotalBytesEchoed += count;
                if (DEBUG) {
                    logByteArray(""echo: "", msg, offset, count);
                }
                if (mUSBLoopbackDevice.mSendPort == null) {
                    Log.e(TAG, ""(java) mUSBLoopbackDevice.mSendPort is null"");
                } else {
                    mUSBLoopbackDevice.mSendPort.onSend(msg, offset, count, timestamp);
                }
            }
        } /* class USBMidiEchoReceiver */
    } /* class BTMidiTestModule */
} /* class MidiActivity */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.media.cts.MediaSessionTestActivity"	"isKeyguardLocked"	"CtsMediaTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/MediaSessionTestActivity.java"	""	"public void test/*
 *
 */

package android.media.cts;

import static org.junit.Assert.fail;

import android.app.Activity;
import android.app.KeyguardManager;
import android.content.Context;
import android.media.session.MediaController;
import android.media.session.MediaSession;
import android.os.Bundle;
import android.util.Log;
import android.view.WindowManager;

/**
 * Activity for testing foreground activity behavior with the
 * {@link android.media.session.MediaSession}.
 */
public class MediaSessionTestActivity extends Activity {
    public static final String KEY_SESSION_TOKEN = ""KEY_SESSION_TOKEN"";
    private static final String TAG = ""MediaSessionTestActivity"";

    private boolean mDeviceLocked;
    private boolean mResumed;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        // Wake up device.
        getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
        setTurnScreenOn(true);

        // Unlock device which is previously locked by power button press.
        // This is required even when the screen lock is set to 'None'.
        setShowWhenLocked(true);

        KeyguardManager keyguardManager =
                (KeyguardManager) getSystemService(Context.KEYGUARD_SERVICE);
        // KeyguardManager can be null for the instant mode.
        if (keyguardManager == null) {
            Log.i(TAG, ""Unable to get KeyguardManager. Probably in the instant mode."");
        } else if (keyguardManager.isKeyguardLocked()) {
            Log.i(TAG, ""Device is locked. Try unlocking and bring activity foreground."");
            mDeviceLocked = true;
            // Note: CTS requires 'no lock pattern or password is set on the device'.
            // However, try to dismiss keyguard for convenience.
            keyguardManager.requestDismissKeyguard(this,
                    new KeyguardManager.KeyguardDismissCallback() {
                        @Override
                        public void onDismissError() {
                            finish();
                        }

                        @Override
                        public void onDismissCancelled() {
                            finish();
                        }

                        @Override
                        public void onDismissSucceeded() {
                            mDeviceLocked = false;
                            setMediaControllerIfInForeground();
                        }
                    });
        }
    }

    @Override
    protected void onResume() {
        super.onResume();
        mResumed = true;
        setMediaControllerIfInForeground();
    }

    @Override
    protected void onPause() {
        super.onPause();
        mResumed = false;
        setMediaController(null);
    }

    private void setMediaControllerIfInForeground() {
        if (mDeviceLocked || !mResumed) {
            return;
        }
        MediaSession.Token token = getIntent().getParcelableExtra(KEY_SESSION_TOKEN);
        if (token != null) {
            MediaController controller = new MediaController(this, token);
            setMediaController(controller);
        }
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.graphics.text.cts.TextRunShaperTest"	"resultTest_IllegalArgument_Y"	"CtsGraphicsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/graphics/src/android/graphics/text/cts/TextRunShaperTest.java"	""	"(expected = IllegalArgumentException.class)
    public void resultTest_IllegalArgument_Y() {
        // Setup
        Paint paint = new Paint();
        String text = ""Hello, World."";
        paint.setTextSize(100f);  // Shape text with 100px
        PositionedGlyphs res = TextRunShaper.shapeTextRun(
                text, 0, text.length(), 0, text.length(), 0f, 0f, false, paint);

        // Act
        res.getGlyphY(res.glyphCount());  // throws IllegalArgumentException
    }

    public void assertSameDrawResult(CharSequence text, TextPaint paint,
            TextDirectionHeuristic textDir) {
        int width = (int) Math.ceil(Layout.getDesiredWidth(text, paint));
        Paint.FontMetricsInt fmi = paint.getFontMetricsInt();
        int height = fmi.descent - fmi.ascent;
        boolean isRtl = textDir.isRtl(text, 0, text.length());

        // Expected bitmap output
        Bitmap layoutResult = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
        Canvas layoutCanvas = new Canvas(layoutResult);
        layoutCanvas.translate(0f, -fmi.ascent);
        layoutCanvas.drawTextRun(
                text,
                0, text.length(),  // range
                0, text.length(),  // context range
                0f, 0f,  // position
                isRtl, paint);

        // Actual bitmap output
        Bitmap glyphsResult = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
        Canvas glyphsCanvas = new Canvas(glyphsResult);
        glyphsCanvas.translate(0f, -fmi.ascent);
        PositionedGlyphs glyphs = TextRunShaper.shapeTextRun(
                text,
                0, text.length(),  // range
                0, text.length(),  // context range
                0f, 0f,  // position
                isRtl, paint);
        for (int i = 0; i < glyphs.glyphCount(); ++i) {
            glyphsCanvas.drawGlyphs(
                    new int[] { glyphs.getGlyphId(i) },
                    0,
                    new float[] { glyphs.getGlyphX(i), glyphs.getGlyphY(i) },
                    0,
                    1,
                    glyphs.getFont(i),
                    paint
            );
        }

        assertThat(glyphsResult.sameAs(layoutResult)).isTrue();
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.content.cts.ContentResolverSyncTestCase"	"isDone"	"CtsContentTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContentResolverSyncTestCase.java"	""	"public void test/*
 *.
 */

package android.content.cts;

import android.accounts.Account;
import android.accounts.AccountManager;
import android.accounts.AccountManagerCallback;
import android.accounts.AccountManagerFuture;
import android.accounts.AuthenticatorException;
import android.accounts.OperationCanceledException;
import android.content.ContentResolver;
import android.content.Context;
import android.content.SyncAdapterType;
import android.os.Bundle;
import android.os.SystemClock;
import android.platform.test.annotations.AppModeFull;
import android.test.AndroidTestCase;
import android.util.Log;

import java.io.IOException;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

@AppModeFull(reason = ""Sync manager not supported"")
public class ContentResolverSyncTestCase extends AndroidTestCase {
    private static final String TAG = ""SyncTest"";

    private static final String AUTHORITY = ""android.content.cts.authority"";

    private static final Account ACCOUNT = new Account(MockAccountAuthenticator.ACCOUNT_NAME,
            MockAccountAuthenticator.ACCOUNT_TYPE);

    private static final int INITIAL_SYNC_TIMEOUT_MS = 60 * 1000;
    private static final int CANCEL_TIMEOUT_MS = 60 * 1000;
    private static final int LATCH_TIMEOUT_MS = 5000;

    private static AccountManager sAccountManager;

    @Override
    public void setUp() throws Exception {
        super.setUp();
        getMockSyncAdapter();
        sAccountManager = AccountManager.get(getContext());
    }

    @Override
    public void tearDown() throws Exception {
        getMockSyncAdapter().clearData();

        // Need to clean up created account
        removeAccount(sAccountManager, ACCOUNT, null /* callback */);

        // Need to cancel any sync that was started.
        cancelSync(null, AUTHORITY, LATCH_TIMEOUT_MS);

        super.tearDown();
    }

    public static synchronized MockSyncAdapter getMockSyncAdapter() {
        return MockSyncAdapter.getMockSyncAdapter();

    }

    public static synchronized MockAccountAuthenticator getMockAuthenticator(Context context) {
        return MockAccountAuthenticator.getMockAuthenticator(context);
    }

    private void addAccountExplicitly(Account account, String password, Bundle userdata) {
        assertTrue(sAccountManager.addAccountExplicitly(account, password, userdata));
    }

    private boolean removeAccount(AccountManager am, Account account,
            AccountManagerCallback<Boolean> callback) throws IOException, AuthenticatorException,
                OperationCanceledException {

        AccountManagerFuture<Boolean> futureBoolean = am.removeAccount(account,
                callback,
                null /* handler */);
        Boolean resultBoolean = futureBoolean.getResult();
        assertTrue(futureBoolean.isDone());

        return resultBoolean;
    }

    private CountDownLatch setNewLatch(CountDownLatch latch) {
        getMockSyncAdapter().clearData();
        getMockSyncAdapter().setLatch(latch);
        return latch;
    }

    private void addAccountAndVerifyInitSync(Account account, String password,
            String authority, int accountIndex) {

        CountDownLatch latch = setNewLatch(new CountDownLatch(1));

        addAccountExplicitly(account, password, null /* userData */);

        // Wait with timeout for the callback to do its work
        try {
            if (!latch.await(INITIAL_SYNC_TIMEOUT_MS, TimeUnit.MILLISECONDS)) {
                fail(""should not time out waiting on latch"");
            }
        } catch (InterruptedException e) {
            fail(""should not throw an InterruptedException"");
        }

        assertFalse(getMockSyncAdapter().isStartSync());
        assertFalse(getMockSyncAdapter().isCancelSync());
        assertTrue(getMockSyncAdapter().isInitialized());
        assertEquals(account, getMockSyncAdapter().getAccounts().get(accountIndex));
        assertEquals(authority, getMockSyncAdapter().getAuthority());
    }

    private void cancelSync(Account account, String authority, int latchTimeoutMillis) {
        CountDownLatch latch = setNewLatch(new CountDownLatch(1));

        Bundle extras = new Bundle();
        extras.putBoolean(ContentResolver.SYNC_EXTRAS_MANUAL, true);

        ContentResolver.cancelSync(account, authority);

        // Wait with timeout for the callback to do its work
        try {
            latch.await(latchTimeoutMillis, TimeUnit.MILLISECONDS);
        } catch (InterruptedException e) {
            fail(""should not throw an InterruptedException"");
        }
        // Make sure the sync manager thinks the sync finished.

        final long timeout = SystemClock.uptimeMillis() + CANCEL_TIMEOUT_MS;
        while (SystemClock.uptimeMillis() < timeout) {
            if (!ContentResolver.isSyncActive(ACCOUNT, AUTHORITY)
                && !ContentResolver.isSyncPending(ACCOUNT, AUTHORITY)) {
                break;
            }
            Log.i(TAG, ""Waiting for sync to finish..."");
            try {
                Thread.sleep(500);
            } catch (InterruptedException e) {
            }
        }
    }

    private void requestSync(Account account, String authority, int latchTimeoutMillis) {
        CountDownLatch latch = setNewLatch(new CountDownLatch(1));

        Bundle extras = new Bundle();
        extras.putBoolean(ContentResolver.SYNC_EXTRAS_MANUAL, true);

        ContentResolver.requestSync(account, authority, extras);

        // Wait with timeout for the callback to do its work
        try {
            latch.await(latchTimeoutMillis, TimeUnit.MILLISECONDS);
        } catch (InterruptedException e) {
            fail(""should not throw an InterruptedException"");
        }
    }

    private void setIsSyncable(Account account, String authority, boolean b) {
        ContentResolver.setIsSyncable(account, authority, (b) ? 1 : 0);
    }

    /**
     * Test a sync request
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.content.cts.ContentResolverSyncTestCase"	"testRequestSync"	"CtsContentTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContentResolverSyncTestCase.java"	""	"public void testRequestSync() throws IOException, AuthenticatorException,
            OperationCanceledException {

        // Prevent auto sync
        ContentResolver.setMasterSyncAutomatically(false);
        assertEquals(false, ContentResolver.getMasterSyncAutomatically());

        addAccountAndVerifyInitSync(ACCOUNT,
                MockAccountAuthenticator.ACCOUNT_PASSWORD,
                AUTHORITY,
                0);

        getMockSyncAdapter().clearData();

        setIsSyncable(ACCOUNT, AUTHORITY, true);
        cancelSync(ACCOUNT, AUTHORITY, LATCH_TIMEOUT_MS);

        getMockSyncAdapter().clearData();

        requestSync(ACCOUNT, AUTHORITY, LATCH_TIMEOUT_MS);

        assertTrue(getMockSyncAdapter().isStartSync());
        assertFalse(getMockSyncAdapter().isCancelSync());
        assertFalse(getMockSyncAdapter().isInitialized());
        assertEquals(ACCOUNT, getMockSyncAdapter().getAccounts().get(0));
        assertEquals(AUTHORITY, getMockSyncAdapter().getAuthority());
    }

    /**
     * Test a sync cancel
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.content.cts.ContentResolverSyncTestCase"	"testCancelSync"	"CtsContentTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContentResolverSyncTestCase.java"	""	"public void testCancelSync() throws IOException, AuthenticatorException,
            OperationCanceledException {

        // Prevent auto sync
        ContentResolver.setMasterSyncAutomatically(false);
        assertEquals(false, ContentResolver.getMasterSyncAutomatically());

        addAccountAndVerifyInitSync(ACCOUNT,
                MockAccountAuthenticator.ACCOUNT_PASSWORD,
                AUTHORITY,
                0);

        getMockSyncAdapter().clearData();

        setIsSyncable(ACCOUNT, AUTHORITY, true);
        requestSync(ACCOUNT, AUTHORITY, LATCH_TIMEOUT_MS);

        getMockSyncAdapter().clearData();

        cancelSync(ACCOUNT, AUTHORITY, LATCH_TIMEOUT_MS);

        assertFalse(getMockSyncAdapter().isStartSync());
        assertTrue(getMockSyncAdapter().isCancelSync());
        assertFalse(getMockSyncAdapter().isInitialized());

        assertFalse(ContentResolver.isSyncActive(ACCOUNT, AUTHORITY));
        assertFalse(ContentResolver.isSyncPending(ACCOUNT, AUTHORITY));
    }

    /**
     * Test if we can set and get the MasterSyncAutomatically switch
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.content.cts.ContentResolverSyncTestCase"	"testCallMultipleAccounts"	"CtsContentTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContentResolverSyncTestCase.java"	""	"public void testCallMultipleAccounts() {
        // Prevent auto sync
        ContentResolver.setMasterSyncAutomatically(false);
        assertEquals(false, ContentResolver.getMasterSyncAutomatically());

        addAccountAndVerifyInitSync(ACCOUNT,
                MockAccountAuthenticator.ACCOUNT_PASSWORD,
                AUTHORITY,
                0);

        getMockSyncAdapter().clearData();

        setIsSyncable(ACCOUNT, AUTHORITY, true);
        cancelSync(ACCOUNT, AUTHORITY, LATCH_TIMEOUT_MS);

        getMockSyncAdapter().clearData();

        requestSync(null /* all accounts */, AUTHORITY, LATCH_TIMEOUT_MS);

        assertTrue(getMockSyncAdapter().isStartSync());
        assertFalse(getMockSyncAdapter().isCancelSync());
        assertFalse(getMockSyncAdapter().isInitialized());
        assertEquals(ACCOUNT, getMockSyncAdapter().getAccounts().get(0));
        assertEquals(AUTHORITY, getMockSyncAdapter().getAuthority());

    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.print.cts.PrintJobStateTransitionsTest"	"createFirstMockPrinterDiscoverySessionCallbacks"	"CtsPrintTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/print/src/android/print/cts/PrintJobStateTransitionsTest.java"	""	"/*
 *.
 */

package android.print.cts;

import static android.print.test.Utils.eventually;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

import android.print.PrintAttributes;
import android.print.PrintAttributes.Margins;
import android.print.PrintAttributes.MediaSize;
import android.print.PrintAttributes.Resolution;
import android.print.PrintDocumentAdapter;
import android.print.PrintJobInfo;
import android.print.PrinterCapabilitiesInfo;
import android.print.PrinterId;
import android.print.PrinterInfo;
import android.print.test.BasePrintTest;
import android.print.test.services.FirstPrintService;
import android.print.test.services.PrintServiceCallbacks;
import android.print.test.services.PrinterDiscoverySessionCallbacks;
import android.print.test.services.SecondPrintService;
import android.print.test.services.StubbablePrinterDiscoverySession;
import android.printservice.PrintJob;
import android.util.Log;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;

import java.util.ArrayList;
import java.util.Collection;

/**
 * Tests all possible states of print jobs.
 */
@RunWith(Parameterized.class)
public class PrintJobStateTransitionsTest extends BasePrintTest {
    private static final String PRINTER_NAME = ""TestPrinter"";
    private static final String LOG_TAG = ""PrintJobStateTransTest"";

    /** The printer discovery session used in this test */
    private static StubbablePrinterDiscoverySession sDiscoverySession;
    private static boolean sHasBeenSetUp;

    private final static int STATES[] = new int[] { PrintJobInfo.STATE_QUEUED,
            PrintJobInfo.STATE_STARTED,
            PrintJobInfo.STATE_BLOCKED,
            PrintJobInfo.STATE_COMPLETED,
            PrintJobInfo.STATE_FAILED,
            PrintJobInfo.STATE_CANCELED
    };

    private final static boolean sKnownFailures[][] = new boolean[8][8];

    private final int mState1;
    private final int mState2;
    private final int mState3;
    private final boolean[] mTestSuccess = new boolean[1];

    /**
     * Create a mock {@link PrinterDiscoverySessionCallbacks} that discovers a simple test printer.
     *
     * @return The mock session callbacks
     */
    private PrinterDiscoverySessionCallbacks createFirstMockPrinterDiscoverySessionCallbacks() {
        return createMockPrinterDiscoverySessionCallbacks(invocation -> {
            // Get the session.
            sDiscoverySession = ((PrinterDiscoverySessionCallbacks) invocation.getMock())
                    .getSession();

            if (sDiscoverySession.getPrinters().isEmpty()) {
                PrinterId printerId =
                        sDiscoverySession.getService().generatePrinterId(PRINTER_NAME);
                PrinterInfo.Builder printer = new PrinterInfo.Builder(
                        sDiscoverySession.getService().generatePrinterId(PRINTER_NAME),
                        PRINTER_NAME, PrinterInfo.STATUS_IDLE);

                printer.setCapabilities(new PrinterCapabilitiesInfo.Builder(printerId)
                        .addMediaSize(MediaSize.ISO_A4, true)
                        .addResolution(new Resolution(""300x300"", ""300dpi"", 300, 300), true)
                        .setColorModes(PrintAttributes.COLOR_MODE_COLOR,
                                PrintAttributes.COLOR_MODE_COLOR)
                        .setMinMargins(new Margins(0, 0, 0, 0)).build());

                ArrayList<PrinterInfo> printers = new ArrayList<>(1);
                printers.add(printer.build());

                sDiscoverySession.addPrinters(printers);
            }
            return null;
        }, null, null, invocation -> null, null, null, invocation -> {
            // Take a note onDestroy was called.
            onPrinterDiscoverySessionDestroyCalled();
            return null;
        });
    }

    private interface PrintJobTestFn {
        void onPrintJobQueued(PrintJob printJob) throws Throwable;
    }

    /**
     * Create mock service callback for a session. Once the job is queued the test function is
     * called.
     *
     * @param sessionCallbacks The callbacks of the session
     * @param printJobTest test function to call
     */
    private PrintServiceCallbacks createFirstMockPrinterServiceCallbacks(
            final PrinterDiscoverySessionCallbacks sessionCallbacks,
            final PrintJobTestFn printJobTest) {
        return createMockPrintServiceCallbacks(
                invocation -> sessionCallbacks, invocation -> {
                    PrintJob printJob = (PrintJob) invocation.getArguments()[0];

                    try {
                        printJobTest.onPrintJobQueued(printJob);
                        mTestSuccess[0] = true;
                    } catch (Throwable t) {
                        throw new RuntimeException(t);
                    }

                    onPrintJobQueuedCalled();

                    return null;
                }, null);
    }

    public PrintJobStateTransitionsTest(int state1, int state2, int state3) {
        mState1 = state1;
        mState2 = state2;
        mState3 = state3;
    }

    private static boolean setState(PrintJob job, int state) {
        switch (state) {
            case PrintJobInfo.STATE_QUEUED:
                // queue cannot be set, but is set at the beginning
                return job.isQueued();
            case PrintJobInfo.STATE_STARTED:
                return job.start();
            case PrintJobInfo.STATE_BLOCKED:
                return job.block(null);
            case PrintJobInfo.STATE_COMPLETED:
                return job.complete();
            case PrintJobInfo.STATE_FAILED:
                return job.fail(null);
            case PrintJobInfo.STATE_CANCELED:
                return job.cancel();
            default:
                // not reached
                throw new IllegalArgumentException(""Cannot switch to "" + state);
        }
    }

    private static boolean isStateTransitionAllowed(int before, int after) {
        switch (before) {
            case PrintJobInfo.STATE_QUEUED:
                switch (after) {
                    case PrintJobInfo.STATE_QUEUED:
                        // queued is not actually set, see setState
                    case PrintJobInfo.STATE_STARTED:
                    case PrintJobInfo.STATE_FAILED:
                    case PrintJobInfo.STATE_CANCELED:
                        return true;
                    default:
                        return false;
                }
            case PrintJobInfo.STATE_STARTED:
                switch (after) {
                    case PrintJobInfo.STATE_QUEUED:
                    case PrintJobInfo.STATE_STARTED:
                        return false;
                    default:
                        return true;
                }
            case PrintJobInfo.STATE_BLOCKED:
                switch (after) {
                    case PrintJobInfo.STATE_STARTED:
                        // blocked -> started == restart
                    case PrintJobInfo.STATE_FAILED:
                    case PrintJobInfo.STATE_CANCELED:
                        return true;
                    default:
                        return false;
                }
            case PrintJobInfo.STATE_COMPLETED:
                return false;
            case PrintJobInfo.STATE_FAILED:
                return false;
            case PrintJobInfo.STATE_CANCELED:
                return false;
            default:
                // not reached
                throw new IllegalArgumentException(""Cannot switch from "" + before);
        }
    }

    private static void checkState(PrintJob job, int state) throws Throwable {
        eventually(() -> assertEquals(state, job.getInfo().getState()));
        switch (state) {
            case PrintJobInfo.STATE_QUEUED:
                eventually(() -> assertTrue(job.isQueued()));
                break;
            case PrintJobInfo.STATE_STARTED:
                eventually(() -> assertTrue(job.isStarted()));
                break;
            case PrintJobInfo.STATE_BLOCKED:
                eventually(() -> assertTrue(job.isBlocked()));
                break;
            case PrintJobInfo.STATE_COMPLETED:
                eventually(() -> assertTrue(job.isCompleted()));
                break;
            case PrintJobInfo.STATE_FAILED:
                eventually(() -> assertTrue(job.isFailed()));
                break;
            case PrintJobInfo.STATE_CANCELED:
                eventually(() -> assertTrue(job.isCancelled()));
                break;
            default:
                // not reached
                throw new IllegalArgumentException(""Cannot check "" + state);
        }
    }

    @Parameterized.Parameters
    public static Collection<Object[]> getParameters() {
        ArrayList<Object[]> parameters = new ArrayList<>((int)Math.pow(STATES.length, 3));
        for (final int state1 : STATES) {
            for (final int state2 : STATES) {
                for (final int state3 : STATES) {
                    // No need to test the same non-transitions twice
                    if (state1 == state2 && state2 == state3) {
                        continue;
                    }

                    // QUEUED does not actually set a state, see setState
                    if (state1 == PrintJobInfo.STATE_QUEUED) {
                        continue;
                    }

                    parameters.add(new Object[]{state1, state2, state3});
                }
            }
        }

        return parameters;
    }

    @Before
    public void setPrinter() throws Throwable {
        if (!sHasBeenSetUp) {
            createActivity();

            resetCounters();
            PrinterDiscoverySessionCallbacks sessionCallbacks
                    = createFirstMockPrinterDiscoverySessionCallbacks();

            // Create the service callbacks for the first print service.
            PrintServiceCallbacks serviceCallbacks = createFirstMockPrinterServiceCallbacks(
                    sessionCallbacks, printJob -> { });

            // Configure the print services.
            FirstPrintService.setCallbacks(serviceCallbacks);

            // We don't use the second service, but we have to still configure it
            SecondPrintService.setCallbacks(createMockPrintServiceCallbacks(null, null, null));

            // Create a print adapter that respects the print contract.
            PrintDocumentAdapter adapter = createDefaultPrintDocumentAdapter(1);

            makeDefaultPrinter(adapter, PRINTER_NAME);

            sHasBeenSetUp = true;
        }

        resetCounters();
    }

    /**
     * Base test for the print job tests. Starts a print job and executes a testFn once the job is
     * queued.
     *
     * @throws Exception If anything is unexpected.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.trustedvoice.cts.TrustedVoiceHostTest"	"testUnlock"	"CtsTrustedVoiceHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/trustedvoice/src/android/trustedvoice/cts/TrustedVoiceHostTest.java"	""	"public void testUnlock() throws Exception {
        Scanner in = null;
        try {
            // Clear logcat.
            getDevice().executeAdbCommand(""logcat"", ""-c"");
            // Lock the device
            getDevice().executeShellCommand(SLEEP_COMMAND);
            // Add a delay to allow the device to go to sleep.
            Thread.sleep(1000);
            // Start the APK and wait for it to complete.
            getDevice().executeShellCommand(START_COMMAND);
            // Adding delay for OEM specific features which could delay the time of printing the
            // test log. Please refer to b/62075150 for additional details.
            Thread.sleep(1000);
            // Dump logcat.
            String logs = getDevice().executeAdbCommand(
                    ""logcat"", ""-v"", ""brief"", ""-d"", CLASS + "":I"", ""*:S"");
            // Search for string.
            in = new Scanner(logs);
            String testString = """";

            while (in.hasNextLine()) {
                String line = in.nextLine();
                if(line.contains(TEST_STRING)) {
                    // Retrieve the test string.
                    testString = line.split("":"")[1].trim();
                    break;
                }
            }
            // Assert the logged string matches the test string.
            assertNotNull(""Test string must not be null"", testString);
            assertEquals(""Test string does not match"", TEST_STRING, testString);
        } finally {
            if (in != null) {
                in.close();
            }
            // Unlock the device
            getDevice().executeShellCommand(AWAKE_COMMAND);
            getDevice().executeShellCommand(DISMISS_KEYGUARD_COMMAND);
        }
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"isLocationEnabled"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	"/*
 *.
 */

package android.net.wifi.cts;

import static android.net.NetworkCapabilities.NET_CAPABILITY_OEM_PAID;
import static android.net.NetworkCapabilities.NET_CAPABILITY_OEM_PRIVATE;
import static android.net.wifi.WifiEnterpriseConfig.Eap.AKA;
import static android.net.wifi.WifiEnterpriseConfig.Eap.WAPI_CERT;
import static android.os.Process.myUid;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.junit.Assume.assumeTrue;

import android.content.Context;
import android.content.pm.PackageManager;
import android.location.LocationManager;
import android.net.ConnectivityManager;
import android.net.MacAddress;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiEnterpriseConfig;
import android.net.wifi.WifiManager;
import android.net.wifi.WifiNetworkSuggestion;
import android.net.wifi.hotspot2.PasspointConfiguration;
import android.net.wifi.hotspot2.pps.Credential;
import android.net.wifi.hotspot2.pps.HomeSp;
import android.os.Build;
import android.platform.test.annotations.AppModeFull;
import android.support.test.uiautomator.UiDevice;
import android.telephony.TelephonyManager;

import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.filters.LargeTest;
import androidx.test.filters.SdkSuppress;
import androidx.test.platform.app.InstrumentationRegistry;

import com.android.compatibility.common.util.ApiLevelUtil;
import com.android.compatibility.common.util.PollingCheck;
import com.android.compatibility.common.util.ShellIdentityUtils;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.security.KeyFactory;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.PKCS8EncodedKeySpec;
import java.util.List;
import java.util.Set;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;

@AppModeFull(reason = ""Cannot get WifiManager in instant app mode"")
@LargeTest
@RunWith(AndroidJUnit4.class)
public class WifiNetworkSuggestionTest extends WifiJUnit4TestBase {
    private static final String TAG = ""WifiNetworkSuggestionTest"";

    private static final String TEST_SSID = ""testSsid"";
    private static final String TEST_BSSID = ""00:df:aa:bc:12:23"";
    private static final String TEST_PASSPHRASE = ""testPassword"";
    private static final int TEST_PRIORITY = 5;
    private static final int TEST_PRIORITY_GROUP = 1;
    private static final int TEST_SUB_ID = 1;

    private static boolean sWasVerboseLoggingEnabled;
    private static boolean sWasScanThrottleEnabled;
    private static boolean sWasWifiEnabled;

    private static Context sContext;
    private static WifiManager sWifiManager;
    private static ConnectivityManager sConnectivityManager;
    private static UiDevice sUiDevice;
    private static WifiConfiguration sTestNetwork;
    private static ConnectivityManager.NetworkCallback sNsNetworkCallback;
    private static TestHelper sTestHelper;

    private ScheduledExecutorService mExecutorService;

    private static final int DURATION_MILLIS = 10_000;

    @BeforeClass
    public static void setUpClass() throws Exception {
        sContext = InstrumentationRegistry.getInstrumentation().getContext();
        // skip the test if WiFi is not supported
        // Don't use assumeTrue in @BeforeClass
        if (!WifiFeature.isWifiSupported(sContext)) return;
        // skip the test if location is not supported
        if (!sContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_LOCATION)) return;
        // skip if the location is disabled
        if (!sContext.getSystemService(LocationManager.class).isLocationEnabled()) return;

        sWifiManager = sContext.getSystemService(WifiManager.class);
        assertThat(sWifiManager).isNotNull();
        sConnectivityManager = sContext.getSystemService(ConnectivityManager.class);
        sUiDevice = UiDevice.getInstance(InstrumentationRegistry.getInstrumentation());
        sTestHelper = new TestHelper(sContext, sUiDevice);

        // turn on verbose logging for tests
        sWasVerboseLoggingEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> sWifiManager.isVerboseLoggingEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> sWifiManager.setVerboseLoggingEnabled(true));
        // Disable scan throttling for tests.
        sWasScanThrottleEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> sWifiManager.isScanThrottleEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> sWifiManager.setScanThrottleEnabled(false));

        // enable Wifi
        sWasWifiEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> sWifiManager.isWifiEnabled());
        if (!sWifiManager.isWifiEnabled()) {
            ShellIdentityUtils.invokeWithShellPermissions(() -> sWifiManager.setWifiEnabled(true));
        }
        PollingCheck.check(""Wifi not enabled"", DURATION_MILLIS, () -> sWifiManager.isWifiEnabled());

        // check we have >= 1 saved network
        List<WifiConfiguration> savedNetworks = ShellIdentityUtils.invokeWithShellPermissions(
                () -> sWifiManager.getPrivilegedConfiguredNetworks());
        if (savedNetworks.isEmpty()) {
            return;
        }
        // Pick any network in range.

        List<WifiConfiguration> networks = TestHelper.findMatchingSavedNetworksWithBssid(
                sWifiManager, savedNetworks);
        if (!networks.isEmpty()) {
            sTestNetwork = networks.get(0);
        }

        // Disable auto-join on the saved network to prevent auto-connect from
        // interfering with the test.
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> {
                    for (WifiConfiguration savedNetwork : savedNetworks) {
                        sWifiManager.disableNetwork(savedNetwork.networkId);
                    }
                });
    }

    @AfterClass
    public static void tearDownClass() throws Exception {
        if (!WifiFeature.isWifiSupported(sContext)) return;

        ShellIdentityUtils.invokeWithShellPermissions(
                () -> sWifiManager.setScanThrottleEnabled(sWasScanThrottleEnabled));
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> sWifiManager.setVerboseLoggingEnabled(sWasVerboseLoggingEnabled));
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> sWifiManager.setWifiEnabled(sWasWifiEnabled));

        // Re-enable networks.
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> {
                    for (WifiConfiguration savedNetwork : sWifiManager.getConfiguredNetworks()) {
                        sWifiManager.enableNetwork(savedNetwork.networkId, false);
                    }
                });
    }

    @Before
    public void setUp() throws Exception {
        mExecutorService = Executors.newSingleThreadScheduledExecutor();
        // turn screen on
        sTestHelper.turnScreenOn();

        // Disconnect current network if any.
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> sWifiManager.disconnect());

        // Wait for Wifi to be disconnected.
        PollingCheck.check(
                ""Wifi not disconnected"",
                20_000,
                () -> sWifiManager.getConnectionInfo().getNetworkId() == -1);

        // Clear any existing app state before each test.
        if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(sContext)) {
            ShellIdentityUtils.invokeWithShellPermissions(
                    () -> sWifiManager.removeAppState(myUid(), sContext.getPackageName()));
        }
    }

    @After
    public void tearDown() throws Exception {
        // Release the requests after the test.
        if (sNsNetworkCallback != null) {
            sConnectivityManager.unregisterNetworkCallback(sNsNetworkCallback);
        }
        mExecutorService.shutdownNow();
        // Clear any existing app state after each test.
        if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(sContext)) {
            ShellIdentityUtils.invokeWithShellPermissions(
                    () -> sWifiManager.removeAppState(myUid(), sContext.getPackageName()));
        }
        sTestHelper.turnScreenOff();
    }

    private static final String CA_SUITE_B_RSA3072_CERT_STRING =
            ""-----BEGIN CERTIFICATE-----\n""
                    + ""MIIEnTCCAwWgAwIBAgIUD87Y8fFLzLr1HQ/64aEnjNq2R/4wDQYJKoZIhvcNAQEM\n""
                    + ""BQAwXjELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAkNBMQwwCgYDVQQHDANNVFYxEDAO\n""
                    + ""BgNVBAoMB0FuZHJvaWQxDjAMBgNVBAsMBVdpLUZpMRIwEAYDVQQDDAl1bml0ZXN0\n""
                    + ""Q0EwHhcNMjAwNzIxMDIxNzU0WhcNMzAwNTMwMDIxNzU0WjBeMQswCQYDVQQGEwJV\n""
                    + ""UzELMAkGA1UECAwCQ0ExDDAKBgNVBAcMA01UVjEQMA4GA1UECgwHQW5kcm9pZDEO\n""
                    + ""MAwGA1UECwwFV2ktRmkxEjAQBgNVBAMMCXVuaXRlc3RDQTCCAaIwDQYJKoZIhvcN\n""
                    + ""AQEBBQADggGPADCCAYoCggGBAMtrsT0otlxh0QS079KpRRbU1PQjCihSoltXnrxF\n""
                    + ""sTWZs2weVEeYVyYU5LaauCDDgISCMtjtfbfylMBeYjpWB5hYzYQOiTzo0anWhMyb\n""
                    + ""Ngb7gpMVZuIl6lwMYRyVRKwHWnTo2EUg1ZzW5rGe5fs/KHj6//hoNFm+3Oju0TQd\n""
                    + ""nraQULpoERPF5B7p85Cssk8uNbviBfZXvtCuJ4N6w7PNceOY/9bbwc1mC+pPZmzV\n""
                    + ""SOAg0vvbIQRzChm63C3jBC3xmxSOOZVrKN4zKDG2s8P0oCNGt0NlgRMrgbPRekzg\n""
                    + ""4avkbA0vTuc2AyriTEYkdea/Mt4EpRg9XuOb43U/GJ/d/vQv2/9fsxhXmsZrn8kr\n""
                    + ""Qo5MMHJFUd96GgHmvYSU3Mf/5r8gF626lvqHioGuTAuHUSnr02ri1WUxZ15LDRgY\n""
                    + ""quMjDCFZfucjJPDAdtiHcFSej/4SLJlN39z8oKKNPn3aL9Gv49oAKs9S8tfDVzMk\n""
                    + ""fDLROQFHFuW715GnnMgEAoOpRwIDAQABo1MwUTAdBgNVHQ4EFgQUeVuGmSVN4ARs\n""
                    + ""mesUMWSJ2qWLbxUwHwYDVR0jBBgwFoAUeVuGmSVN4ARsmesUMWSJ2qWLbxUwDwYD\n""
                    + ""VR0TAQH/BAUwAwEB/zANBgkqhkiG9w0BAQwFAAOCAYEAit1Lo/hegZpPuT9dlWZJ\n""
                    + ""bC8JvAf95O8lnn6LFb69pgYOHCLgCIlvYXu9rdBUJgZo+V1MzJJljiO6RxWRfKbQ\n""
                    + ""8WBYkoqR1EqriR3Kn8q/SjIZCdFSaznTyU1wQMveBQ6RJWXSUhYVfE9RjyFTp7B4\n""
                    + ""UyH2uCluR/0T06HQNGfH5XpIYQqCk1Zgng5lmEmheLDPoJpa92lKeQFJMC6eYz9g\n""
                    + ""lF1GHxPxkPfbMJ6ZDp5X6Yopu6Q6uEXhVKM/iQVcgzRkx9rid+xTYl+nOKyK/XfC\n""
                    + ""z8P0/TFIoPTW02DLge5wKagdoCpy1B7HdrAXyUjoH4B8MsUkq3kYPFSjPzScuTtV\n""
                    + ""kUuDw5ipCNeXCRnhbYqRDk6PX5GUu2cmN9jtaH3tbgm3fKNOsd/BO1fLIl7qjXlR\n""
                    + ""27HHbC0JXjNvlm2DLp23v4NTxS7WZGYsxyUj5DZrxBxqCsTXu/01w1BrQKWKh9FM\n""
                    + ""aVrlA8omfVODK2CSuw+KhEMHepRv/AUgsLl4L4+RMoa+\n""
                    + ""-----END CERTIFICATE-----\n"";
    private static final X509Certificate CA_SUITE_B_RSA3072_CERT =
            loadCertificate(CA_SUITE_B_RSA3072_CERT_STRING);

    private static final String CA_SUITE_B_ECDSA_CERT_STRING =
            ""-----BEGIN CERTIFICATE-----\n""
                    + ""MIICTzCCAdSgAwIBAgIUdnLttwNPnQzFufplGOr9bTrGCqMwCgYIKoZIzj0EAwMw\n""
                    + ""XjELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAkNBMQwwCgYDVQQHDANNVFYxEDAOBgNV\n""
                    + ""BAoMB0FuZHJvaWQxDjAMBgNVBAsMBVdpLUZpMRIwEAYDVQQDDAl1bml0ZXN0Q0Ew\n""
                    + ""HhcNMjAwNzIxMDIyNDA1WhcNMzAwNTMwMDIyNDA1WjBeMQswCQYDVQQGEwJVUzEL\n""
                    + ""MAkGA1UECAwCQ0ExDDAKBgNVBAcMA01UVjEQMA4GA1UECgwHQW5kcm9pZDEOMAwG\n""
                    + ""A1UECwwFV2ktRmkxEjAQBgNVBAMMCXVuaXRlc3RDQTB2MBAGByqGSM49AgEGBSuB\n""
                    + ""BAAiA2IABFmntXwk9icqhDQFUP1xy04WyEpaGW4q6Q+8pujlSl/X3iotPZ++GZfp\n""
                    + ""Mfv3YDHDBl6sELPQ2BEjyPXmpsKjOUdiUe69e88oGEdeqT2xXiQ6uzpTfJD4170i\n""
                    + ""O/TwLrQGKKNTMFEwHQYDVR0OBBYEFCjptsX3g4g5W0L4oEP6N3gfyiZXMB8GA1Ud\n""
                    + ""IwQYMBaAFCjptsX3g4g5W0L4oEP6N3gfyiZXMA8GA1UdEwEB/wQFMAMBAf8wCgYI\n""
                    + ""KoZIzj0EAwMDaQAwZgIxAK61brUYRbLmQKiaEboZgrHtnPAcGo7Yzx3MwHecx3Dm\n""
                    + ""5soIeLVYc8bPYN1pbhXW1gIxALdEe2sh03nBHyQH4adYoZungoCwt8mp/7sJFxou\n""
                    + ""9UnRegyBgGzf74ROWdpZHzh+Pg==\n""
                    + ""-----END CERTIFICATE-----\n"";
    private static final X509Certificate CA_SUITE_B_ECDSA_CERT =
            loadCertificate(CA_SUITE_B_ECDSA_CERT_STRING);

    private static final String CLIENT_SUITE_B_RSA3072_CERT_STRING =
            ""-----BEGIN CERTIFICATE-----\n""
                    + ""MIIERzCCAq8CFDopjyNgaj+c2TN2k06h7okEWpHJMA0GCSqGSIb3DQEBDAUAMF4x\n""
                    + ""CzAJBgNVBAYTAlVTMQswCQYDVQQIDAJDQTEMMAoGA1UEBwwDTVRWMRAwDgYDVQQK\n""
                    + ""DAdBbmRyb2lkMQ4wDAYDVQQLDAVXaS1GaTESMBAGA1UEAwwJdW5pdGVzdENBMB4X\n""
                    + ""DTIwMDcyMTAyMjkxMVoXDTMwMDUzMDAyMjkxMVowYjELMAkGA1UEBhMCVVMxCzAJ\n""
                    + ""BgNVBAgMAkNBMQwwCgYDVQQHDANNVFYxEDAOBgNVBAoMB0FuZHJvaWQxDjAMBgNV\n""
                    + ""BAsMBVdpLUZpMRYwFAYDVQQDDA11bml0ZXN0Q2xpZW50MIIBojANBgkqhkiG9w0B\n""
                    + ""AQEFAAOCAY8AMIIBigKCAYEAwSK3C5K5udtCKTnE14e8z2cZvwmB4Xe+a8+7QLud\n""
                    + ""Hooc/lQzClgK4MbVUC0D3FE+U32C78SxKoTaRWtvPmNm+UaFT8KkwyUno/dv+2XD\n""
                    + ""pd/zARQ+3FwAfWopAhEyCVSxwsCa+slQ4juRIMIuUC1Mm0NaptZyM3Tj/ICQEfpk\n""
                    + ""o9qVIbiK6eoJMTkY8EWfAn7RTFdfR1OLuO0mVOjgLW9/+upYv6hZ19nAMAxw4QTJ\n""
                    + ""x7lLwALX7B+tDYNEZHDqYL2zyvQWAj2HClere8QYILxkvktgBg2crEJJe4XbDH7L\n""
                    + ""A3rrXmsiqf1ZbfFFEzK9NFqovL+qGh+zIP+588ShJFO9H/RDnDpiTnAFTWXQdTwg\n""
                    + ""szSS0Vw2PB+JqEABAa9DeMvXT1Oy+NY3ItPHyy63nQZVI2rXANw4NhwS0Z6DF+Qs\n""
                    + ""TNrj+GU7e4SG/EGR8SvldjYfQTWFLg1l/UT1hOOkQZwdsaW1zgKyeuiFB2KdMmbA\n""
                    + ""Sq+Ux1L1KICo0IglwWcB/8nnAgMBAAEwDQYJKoZIhvcNAQEMBQADggGBAMYwJkNw\n""
                    + ""BaCviKFmReDTMwWPRy4AMNViEeqAXgERwDEKwM7efjsaj5gctWfKsxX6UdLzkhgg\n""
                    + ""6S/T6PxVWKzJ6l7SoOuTa6tMQOZp+h3R1mdfEQbw8B5cXBxZ+batzAai6Fiy1FKS\n""
                    + ""/ka3INbcGfYuIYghfTrb4/NJKN06ZaQ1bpPwq0e4gN7800T2nbawvSf7r+8ZLcG3\n""
                    + ""6bGCjRMwDSIipNvOwoj3TG315XC7TccX5difQ4sKOY+d2MkVJ3RiO0Ciw2ZbEW8d\n""
                    + ""1FH5vUQJWnBUfSFznosGzLwH3iWfqlP+27jNE+qB2igEwCRFgVAouURx5ou43xuX\n""
                    + ""qf6JkdI3HTJGLIWxkp7gOeln4dEaYzKjYw+P0VqJvKVqQ0IXiLjHgE0J9p0vgyD6\n""
                    + ""HVVcP7U8RgqrbIjL1QgHU4KBhGi+WSUh/mRplUCNvHgcYdcHi/gHpj/j6ubwqIGV\n""
                    + ""z4iSolAHYTmBWcLyE0NgpzE6ntp+53r2KaUJA99l2iGVzbWTwqPSm0XAVw==\n""
                    + ""-----END CERTIFICATE-----\n"";
    private static final X509Certificate CLIENT_SUITE_B_RSA3072_CERT =
            loadCertificate(CLIENT_SUITE_B_RSA3072_CERT_STRING);

    private static final byte[] CLIENT_SUITE_B_RSA3072_KEY_DATA = new byte[]{
            (byte) 0x30, (byte) 0x82, (byte) 0x06, (byte) 0xfe, (byte) 0x02, (byte) 0x01,
            (byte) 0x00, (byte) 0x30, (byte) 0x0d, (byte) 0x06, (byte) 0x09, (byte) 0x2a,
            (byte) 0x86, (byte) 0x48, (byte) 0x86, (byte) 0xf7, (byte) 0x0d, (byte) 0x01,
            (byte) 0x01, (byte) 0x01, (byte) 0x05, (byte) 0x00, (byte) 0x04, (byte) 0x82,
            (byte) 0x06, (byte) 0xe8, (byte) 0x30, (byte) 0x82, (byte) 0x06, (byte) 0xe4,
            (byte) 0x02, (byte) 0x01, (byte) 0x00, (byte) 0x02, (byte) 0x82, (byte) 0x01,
            (byte) 0x81, (byte) 0x00, (byte) 0xc1, (byte) 0x22, (byte) 0xb7, (byte) 0x0b,
            (byte) 0x92, (byte) 0xb9, (byte) 0xb9, (byte) 0xdb, (byte) 0x42, (byte) 0x29,
            (byte) 0x39, (byte) 0xc4, (byte) 0xd7, (byte) 0x87, (byte) 0xbc, (byte) 0xcf,
            (byte) 0x67, (byte) 0x19, (byte) 0xbf, (byte) 0x09, (byte) 0x81, (byte) 0xe1,
            (byte) 0x77, (byte) 0xbe, (byte) 0x6b, (byte) 0xcf, (byte) 0xbb, (byte) 0x40,
            (byte) 0xbb, (byte) 0x9d, (byte) 0x1e, (byte) 0x8a, (byte) 0x1c, (byte) 0xfe,
            (byte) 0x54, (byte) 0x33, (byte) 0x0a, (byte) 0x58, (byte) 0x0a, (byte) 0xe0,
            (byte) 0xc6, (byte) 0xd5, (byte) 0x50, (byte) 0x2d, (byte) 0x03, (byte) 0xdc,
            (byte) 0x51, (byte) 0x3e, (byte) 0x53, (byte) 0x7d, (byte) 0x82, (byte) 0xef,
            (byte) 0xc4, (byte) 0xb1, (byte) 0x2a, (byte) 0x84, (byte) 0xda, (byte) 0x45,
            (byte) 0x6b, (byte) 0x6f, (byte) 0x3e, (byte) 0x63, (byte) 0x66, (byte) 0xf9,
            (byte) 0x46, (byte) 0x85, (byte) 0x4f, (byte) 0xc2, (byte) 0xa4, (byte) 0xc3,
            (byte) 0x25, (byte) 0x27, (byte) 0xa3, (byte) 0xf7, (byte) 0x6f, (byte) 0xfb,
            (byte) 0x65, (byte) 0xc3, (byte) 0xa5, (byte) 0xdf, (byte) 0xf3, (byte) 0x01,
            (byte) 0x14, (byte) 0x3e, (byte) 0xdc, (byte) 0x5c, (byte) 0x00, (byte) 0x7d,
            (byte) 0x6a, (byte) 0x29, (byte) 0x02, (byte) 0x11, (byte) 0x32, (byte) 0x09,
            (byte) 0x54, (byte) 0xb1, (byte) 0xc2, (byte) 0xc0, (byte) 0x9a, (byte) 0xfa,
            (byte) 0xc9, (byte) 0x50, (byte) 0xe2, (byte) 0x3b, (byte) 0x91, (byte) 0x20,
            (byte) 0xc2, (byte) 0x2e, (byte) 0x50, (byte) 0x2d, (byte) 0x4c, (byte) 0x9b,
            (byte) 0x43, (byte) 0x5a, (byte) 0xa6, (byte) 0xd6, (byte) 0x72, (byte) 0x33,
            (byte) 0x74, (byte) 0xe3, (byte) 0xfc, (byte) 0x80, (byte) 0x90, (byte) 0x11,
            (byte) 0xfa, (byte) 0x64, (byte) 0xa3, (byte) 0xda, (byte) 0x95, (byte) 0x21,
            (byte) 0xb8, (byte) 0x8a, (byte) 0xe9, (byte) 0xea, (byte) 0x09, (byte) 0x31,
            (byte) 0x39, (byte) 0x18, (byte) 0xf0, (byte) 0x45, (byte) 0x9f, (byte) 0x02,
            (byte) 0x7e, (byte) 0xd1, (byte) 0x4c, (byte) 0x57, (byte) 0x5f, (byte) 0x47,
            (byte) 0x53, (byte) 0x8b, (byte) 0xb8, (byte) 0xed, (byte) 0x26, (byte) 0x54,
            (byte) 0xe8, (byte) 0xe0, (byte) 0x2d, (byte) 0x6f, (byte) 0x7f, (byte) 0xfa,
            (byte) 0xea, (byte) 0x58, (byte) 0xbf, (byte) 0xa8, (byte) 0x59, (byte) 0xd7,
            (byte) 0xd9, (byte) 0xc0, (byte) 0x30, (byte) 0x0c, (byte) 0x70, (byte) 0xe1,
            (byte) 0x04, (byte) 0xc9, (byte) 0xc7, (byte) 0xb9, (byte) 0x4b, (byte) 0xc0,
            (byte) 0x02, (byte) 0xd7, (byte) 0xec, (byte) 0x1f, (byte) 0xad, (byte) 0x0d,
            (byte) 0x83, (byte) 0x44, (byte) 0x64, (byte) 0x70, (byte) 0xea, (byte) 0x60,
            (byte) 0xbd, (byte) 0xb3, (byte) 0xca, (byte) 0xf4, (byte) 0x16, (byte) 0x02,
            (byte) 0x3d, (byte) 0x87, (byte) 0x0a, (byte) 0x57, (byte) 0xab, (byte) 0x7b,
            (byte) 0xc4, (byte) 0x18, (byte) 0x20, (byte) 0xbc, (byte) 0x64, (byte) 0xbe,
            (byte) 0x4b, (byte) 0x60, (byte) 0x06, (byte) 0x0d, (byte) 0x9c, (byte) 0xac,
            (byte) 0x42, (byte) 0x49, (byte) 0x7b, (byte) 0x85, (byte) 0xdb, (byte) 0x0c,
            (byte) 0x7e, (byte) 0xcb, (byte) 0x03, (byte) 0x7a, (byte) 0xeb, (byte) 0x5e,
            (byte) 0x6b, (byte) 0x22, (byte) 0xa9, (byte) 0xfd, (byte) 0x59, (byte) 0x6d,
            (byte) 0xf1, (byte) 0x45, (byte) 0x13, (byte) 0x32, (byte) 0xbd, (byte) 0x34,
            (byte) 0x5a, (byte) 0xa8, (byte) 0xbc, (byte) 0xbf, (byte) 0xaa, (byte) 0x1a,
            (byte) 0x1f, (byte) 0xb3, (byte) 0x20, (byte) 0xff, (byte) 0xb9, (byte) 0xf3,
            (byte) 0xc4, (byte) 0xa1, (byte) 0x24, (byte) 0x53, (byte) 0xbd, (byte) 0x1f,
            (byte) 0xf4, (byte) 0x43, (byte) 0x9c, (byte) 0x3a, (byte) 0x62, (byte) 0x4e,
            (byte) 0x70, (byte) 0x05, (byte) 0x4d, (byte) 0x65, (byte) 0xd0, (byte) 0x75,
            (byte) 0x3c, (byte) 0x20, (byte) 0xb3, (byte) 0x34, (byte) 0x92, (byte) 0xd1,
            (byte) 0x5c, (byte) 0x36, (byte) 0x3c, (byte) 0x1f, (byte) 0x89, (byte) 0xa8,
            (byte) 0x40, (byte) 0x01, (byte) 0x01, (byte) 0xaf, (byte) 0x43, (byte) 0x78,
            (byte) 0xcb, (byte) 0xd7, (byte) 0x4f, (byte) 0x53, (byte) 0xb2, (byte) 0xf8,
            (byte) 0xd6, (byte) 0x37, (byte) 0x22, (byte) 0xd3, (byte) 0xc7, (byte) 0xcb,
            (byte) 0x2e, (byte) 0xb7, (byte) 0x9d, (byte) 0x06, (byte) 0x55, (byte) 0x23,
            (byte) 0x6a, (byte) 0xd7, (byte) 0x00, (byte) 0xdc, (byte) 0x38, (byte) 0x36,
            (byte) 0x1c, (byte) 0x12, (byte) 0xd1, (byte) 0x9e, (byte) 0x83, (byte) 0x17,
            (byte) 0xe4, (byte) 0x2c, (byte) 0x4c, (byte) 0xda, (byte) 0xe3, (byte) 0xf8,
            (byte) 0x65, (byte) 0x3b, (byte) 0x7b, (byte) 0x84, (byte) 0x86, (byte) 0xfc,
            (byte) 0x41, (byte) 0x91, (byte) 0xf1, (byte) 0x2b, (byte) 0xe5, (byte) 0x76,
            (byte) 0x36, (byte) 0x1f, (byte) 0x41, (byte) 0x35, (byte) 0x85, (byte) 0x2e,
            (byte) 0x0d, (byte) 0x65, (byte) 0xfd, (byte) 0x44, (byte) 0xf5, (byte) 0x84,
            (byte) 0xe3, (byte) 0xa4, (byte) 0x41, (byte) 0x9c, (byte) 0x1d, (byte) 0xb1,
            (byte) 0xa5, (byte) 0xb5, (byte) 0xce, (byte) 0x02, (byte) 0xb2, (byte) 0x7a,
            (byte) 0xe8, (byte) 0x85, (byte) 0x07, (byte) 0x62, (byte) 0x9d, (byte) 0x32,
            (byte) 0x66, (byte) 0xc0, (byte) 0x4a, (byte) 0xaf, (byte) 0x94, (byte) 0xc7,
            (byte) 0x52, (byte) 0xf5, (byte) 0x28, (byte) 0x80, (byte) 0xa8, (byte) 0xd0,
            (byte) 0x88, (byte) 0x25, (byte) 0xc1, (byte) 0x67, (byte) 0x01, (byte) 0xff,
            (byte) 0xc9, (byte) 0xe7, (byte) 0x02, (byte) 0x03, (byte) 0x01, (byte) 0x00,
            (byte) 0x01, (byte) 0x02, (byte) 0x82, (byte) 0x01, (byte) 0x80, (byte) 0x04,
            (byte) 0xb1, (byte) 0xcc, (byte) 0x53, (byte) 0x3a, (byte) 0xb0, (byte) 0xcb,
            (byte) 0x04, (byte) 0xba, (byte) 0x59, (byte) 0xf8, (byte) 0x2e, (byte) 0x81,
            (byte) 0xb2, (byte) 0xa9, (byte) 0xf3, (byte) 0x3c, (byte) 0xa5, (byte) 0x52,
            (byte) 0x90, (byte) 0x6f, (byte) 0x98, (byte) 0xc4, (byte) 0x69, (byte) 0x5b,
            (byte) 0x83, (byte) 0x84, (byte) 0x20, (byte) 0xb1, (byte) 0xae, (byte) 0xc3,
            (byte) 0x04, (byte) 0x46, (byte) 0x6a, (byte) 0x24, (byte) 0x2f, (byte) 0xcd,
            (byte) 0x6b, (byte) 0x90, (byte) 0x70, (byte) 0x20, (byte) 0x45, (byte) 0x25,
            (byte) 0x1a, (byte) 0xc3, (byte) 0x02, (byte) 0x42, (byte) 0xf3, (byte) 0x49,
            (byte) 0xe2, (byte) 0x3e, (byte) 0x21, (byte) 0x87, (byte) 0xdd, (byte) 0x6a,
            (byte) 0x94, (byte) 0x2a, (byte) 0x1e, (byte) 0x0f, (byte) 0xdb, (byte) 0x77,
            (byte) 0x5f, (byte) 0xc1, (byte) 0x2c, (byte) 0x03, (byte) 0xfb, (byte) 0xcf,
            (byte) 0x91, (byte) 0x82, (byte) 0xa1, (byte) 0xbf, (byte) 0xb0, (byte) 0x73,
            (byte) 0xfa, (byte) 0xda, (byte) 0xbc, (byte) 0xf8, (byte) 0x9f, (byte) 0x45,
            (byte) 0xd3, (byte) 0xe8, (byte) 0xbb, (byte) 0x38, (byte) 0xfb, (byte) 0xc2,
            (byte) 0x2d, (byte) 0x76, (byte) 0x51, (byte) 0x96, (byte) 0x18, (byte) 0x03,
            (byte) 0x15, (byte) 0xd9, (byte) 0xea, (byte) 0x82, (byte) 0x25, (byte) 0x83,
            (byte) 0xff, (byte) 0x5c, (byte) 0x85, (byte) 0x06, (byte) 0x09, (byte) 0xb2,
            (byte) 0x46, (byte) 0x12, (byte) 0x64, (byte) 0x02, (byte) 0x74, (byte) 0x4f,
            (byte) 0xbc, (byte) 0x9a, (byte) 0x25, (byte) 0x18, (byte) 0x01, (byte) 0x07,
            (byte) 0x17, (byte) 0x25, (byte) 0x55, (byte) 0x7c, (byte) 0xdc, (byte) 0xe1,
            (byte) 0xd1, (byte) 0x5a, (byte) 0x2f, (byte) 0x25, (byte) 0xaf, (byte) 0xf6,
            (byte) 0x8f, (byte) 0xa4, (byte) 0x9a, (byte) 0x5a, (byte) 0x3a, (byte) 0xfe,
            (byte) 0x2e, (byte) 0x93, (byte) 0x24, (byte) 0xa0, (byte) 0x27, (byte) 0xac,
            (byte) 0x07, (byte) 0x75, (byte) 0x33, (byte) 0x01, (byte) 0x54, (byte) 0x23,
            (byte) 0x0f, (byte) 0xe8, (byte) 0x9f, (byte) 0xfa, (byte) 0x36, (byte) 0xe6,
            (byte) 0x3a, (byte) 0xd5, (byte) 0x78, (byte) 0xb0, (byte) 0xe4, (byte) 0x6a,
            (byte) 0x16, (byte) 0x50, (byte) 0xbd, (byte) 0x0f, (byte) 0x9f, (byte) 0x32,
            (byte) 0xa1, (byte) 0x6b, (byte) 0xf5, (byte) 0xa4, (byte) 0x34, (byte) 0x58,
            (byte) 0xb6, (byte) 0xa4, (byte) 0xb3, (byte) 0xc3, (byte) 0x83, (byte) 0x08,
            (byte) 0x18, (byte) 0xc7, (byte) 0xef, (byte) 0x95, (byte) 0xe2, (byte) 0x1b,
            (byte) 0xba, (byte) 0x35, (byte) 0x61, (byte) 0xa3, (byte) 0xb4, (byte) 0x30,
            (byte) 0xe0, (byte) 0xd1, (byte) 0xc1, (byte) 0xa2, (byte) 0x3a, (byte) 0xc6,
            (byte) 0xb4, (byte) 0xd2, (byte) 0x80, (byte) 0x5a, (byte) 0xaf, (byte) 0xa4,
            (byte) 0x54, (byte) 0x3c, (byte) 0x66, (byte) 0x5a, (byte) 0x1c, (byte) 0x4d,
            (byte) 0xe1, (byte) 0xd9, (byte) 0x98, (byte) 0x44, (byte) 0x01, (byte) 0x1b,
            (byte) 0x8c, (byte) 0xe9, (byte) 0x80, (byte) 0x54, (byte) 0x83, (byte) 0x3d,
            (byte) 0x96, (byte) 0x25, (byte) 0x41, (byte) 0x1c, (byte) 0xad, (byte) 0xae,
            (byte) 0x3b, (byte) 0x7a, (byte) 0xd7, (byte) 0x9d, (byte) 0x10, (byte) 0x7c,
            (byte) 0xd1, (byte) 0xa7, (byte) 0x96, (byte) 0x39, (byte) 0xa5, (byte) 0x2f,
            (byte) 0xbe, (byte) 0xc3, (byte) 0x2c, (byte) 0x64, (byte) 0x01, (byte) 0xfe,
            (byte) 0xa2, (byte) 0xd1, (byte) 0x6a, (byte) 0xcf, (byte) 0x4c, (byte) 0x76,
            (byte) 0x3b, (byte) 0xc8, (byte) 0x35, (byte) 0x21, (byte) 0xda, (byte) 0x98,
            (byte) 0xcf, (byte) 0xf9, (byte) 0x29, (byte) 0xff, (byte) 0x30, (byte) 0x59,
            (byte) 0x36, (byte) 0x53, (byte) 0x0b, (byte) 0xbb, (byte) 0xfa, (byte) 0xba,
            (byte) 0xc4, (byte) 0x03, (byte) 0x23, (byte) 0xe0, (byte) 0xd3, (byte) 0x33,
            (byte) 0xff, (byte) 0x32, (byte) 0xdb, (byte) 0x30, (byte) 0x64, (byte) 0xc7,
            (byte) 0x56, (byte) 0xca, (byte) 0x55, (byte) 0x14, (byte) 0xee, (byte) 0x58,
            (byte) 0xfe, (byte) 0x96, (byte) 0x7e, (byte) 0x1c, (byte) 0x34, (byte) 0x16,
            (byte) 0xeb, (byte) 0x76, (byte) 0x26, (byte) 0x48, (byte) 0xe2, (byte) 0xe5,
            (byte) 0x5c, (byte) 0xd5, (byte) 0x83, (byte) 0x37, (byte) 0xd9, (byte) 0x09,
            (byte) 0x71, (byte) 0xbc, (byte) 0x54, (byte) 0x25, (byte) 0xca, (byte) 0x2e,
            (byte) 0xdb, (byte) 0x36, (byte) 0x39, (byte) 0xcc, (byte) 0x3a, (byte) 0x81,
            (byte) 0x95, (byte) 0x9e, (byte) 0xf4, (byte) 0x01, (byte) 0xa7, (byte) 0xc0,
            (byte) 0x20, (byte) 0xce, (byte) 0x70, (byte) 0x55, (byte) 0x2c, (byte) 0xe0,
            (byte) 0x93, (byte) 0x72, (byte) 0xa6, (byte) 0x25, (byte) 0xda, (byte) 0x64,
            (byte) 0x19, (byte) 0x18, (byte) 0xd2, (byte) 0x31, (byte) 0xe2, (byte) 0x7c,
            (byte) 0xf2, (byte) 0x30, (byte) 0x9e, (byte) 0x8d, (byte) 0xc6, (byte) 0x14,
            (byte) 0x8a, (byte) 0x38, (byte) 0xf0, (byte) 0x94, (byte) 0xeb, (byte) 0xf4,
            (byte) 0x64, (byte) 0x92, (byte) 0x3d, (byte) 0x67, (byte) 0xa6, (byte) 0x2c,
            (byte) 0x52, (byte) 0xfc, (byte) 0x60, (byte) 0xca, (byte) 0x2a, (byte) 0xcf,
            (byte) 0x24, (byte) 0xd5, (byte) 0x42, (byte) 0x5f, (byte) 0xc7, (byte) 0x9f,
            (byte) 0xf3, (byte) 0xb4, (byte) 0xdf, (byte) 0x76, (byte) 0x6e, (byte) 0x53,
            (byte) 0xa1, (byte) 0x7b, (byte) 0xae, (byte) 0xa5, (byte) 0x84, (byte) 0x1f,
            (byte) 0xfa, (byte) 0xc0, (byte) 0xb4, (byte) 0x6c, (byte) 0xc9, (byte) 0x02,
            (byte) 0x81, (byte) 0xc1, (byte) 0x00, (byte) 0xf3, (byte) 0x17, (byte) 0xd9,
            (byte) 0x48, (byte) 0x17, (byte) 0x87, (byte) 0x84, (byte) 0x16, (byte) 0xea,
            (byte) 0x2d, (byte) 0x31, (byte) 0x1b, (byte) 0xce, (byte) 0xec, (byte) 0xaf,
            (byte) 0xdc, (byte) 0x6b, (byte) 0xaf, (byte) 0xc8, (byte) 0xf1, (byte) 0x40,
            (byte) 0xa7, (byte) 0x4f, (byte) 0xef, (byte) 0x48, (byte) 0x08, (byte) 0x5e,
            (byte) 0x9a, (byte) 0xd1, (byte) 0xc0, (byte) 0xb1, (byte) 0xfe, (byte) 0xe7,
            (byte) 0x03, (byte) 0xd5, (byte) 0x96, (byte) 0x01, (byte) 0xe8, (byte) 0x40,
            (byte) 0xca, (byte) 0x78, (byte) 0xcb, (byte) 0xb3, (byte) 0x28, (byte) 0x1a,
            (byte) 0xf0, (byte) 0xe5, (byte) 0xf6, (byte) 0x46, (byte) 0xef, (byte) 0xcd,
            (byte) 0x1a, (byte) 0x0f, (byte) 0x13, (byte) 0x2d, (byte) 0x38, (byte) 0xf8,
            (byte) 0xf7, (byte) 0x88, (byte) 0x21, (byte) 0x15, (byte) 0xce, (byte) 0x48,
            (byte) 0xf4, (byte) 0x92, (byte) 0x7e, (byte) 0x9b, (byte) 0x2e, (byte) 0x2f,
            (byte) 0x22, (byte) 0x3e, (byte) 0x5c, (byte) 0x67, (byte) 0xd7, (byte) 0x58,
            (byte) 0xf6, (byte) 0xef, (byte) 0x1f, (byte) 0xb4, (byte) 0x04, (byte) 0xc7,
            (byte) 0xfd, (byte) 0x8c, (byte) 0x4e, (byte) 0x27, (byte) 0x9e, (byte) 0xb9,
            (byte) 0xef, (byte) 0x0f, (byte) 0xf7, (byte) 0x4a, (byte) 0xc2, (byte) 0xf4,
            (byte) 0x64, (byte) 0x6b, (byte) 0xe0, (byte) 0xfb, (byte) 0xe3, (byte) 0x45,
            (byte) 0xd5, (byte) 0x37, (byte) 0xa0, (byte) 0x2a, (byte) 0xc6, (byte) 0xf3,
            (byte) 0xf6, (byte) 0xcc, (byte) 0xb5, (byte) 0x94, (byte) 0xbf, (byte) 0x56,
            (byte) 0xa0, (byte) 0x61, (byte) 0x36, (byte) 0x88, (byte) 0x35, (byte) 0xd5,
            (byte) 0xa5, (byte) 0xad, (byte) 0x20, (byte) 0x48, (byte) 0xda, (byte) 0x70,
            (byte) 0x35, (byte) 0xd9, (byte) 0x75, (byte) 0x66, (byte) 0xa5, (byte) 0xac,
            (byte) 0x86, (byte) 0x7a, (byte) 0x75, (byte) 0x49, (byte) 0x88, (byte) 0x40,
            (byte) 0xce, (byte) 0xb0, (byte) 0x6f, (byte) 0x57, (byte) 0x15, (byte) 0x54,
            (byte) 0xd3, (byte) 0x2f, (byte) 0x11, (byte) 0x9b, (byte) 0xe3, (byte) 0x87,
            (byte) 0xc8, (byte) 0x8d, (byte) 0x98, (byte) 0xc6, (byte) 0xe0, (byte) 0xbc,
            (byte) 0x85, (byte) 0xb9, (byte) 0x04, (byte) 0x43, (byte) 0xa9, (byte) 0x41,
            (byte) 0xce, (byte) 0x42, (byte) 0x1a, (byte) 0x57, (byte) 0x10, (byte) 0xd8,
            (byte) 0xe4, (byte) 0x6a, (byte) 0x51, (byte) 0x10, (byte) 0x0a, (byte) 0xec,
            (byte) 0xe4, (byte) 0x57, (byte) 0xc7, (byte) 0xee, (byte) 0xe9, (byte) 0xd6,
            (byte) 0xcb, (byte) 0x3e, (byte) 0xba, (byte) 0xfa, (byte) 0xe9, (byte) 0x0e,
            (byte) 0xed, (byte) 0x87, (byte) 0x04, (byte) 0x9a, (byte) 0x48, (byte) 0xba,
            (byte) 0xaf, (byte) 0x08, (byte) 0xf5, (byte) 0x02, (byte) 0x81, (byte) 0xc1,
            (byte) 0x00, (byte) 0xcb, (byte) 0x63, (byte) 0xd6, (byte) 0x54, (byte) 0xb6,
            (byte) 0xf3, (byte) 0xf3, (byte) 0x8c, (byte) 0xf8, (byte) 0xd0, (byte) 0xd2,
            (byte) 0x84, (byte) 0xc1, (byte) 0xf5, (byte) 0x12, (byte) 0xe0, (byte) 0x02,
            (byte) 0x80, (byte) 0x42, (byte) 0x92, (byte) 0x4e, (byte) 0xa4, (byte) 0x5c,
            (byte) 0xa5, (byte) 0x64, (byte) 0xec, (byte) 0xb7, (byte) 0xdc, (byte) 0xe0,
            (byte) 0x2d, (byte) 0x5d, (byte) 0xac, (byte) 0x0e, (byte) 0x24, (byte) 0x48,
            (byte) 0x13, (byte) 0x05, (byte) 0xe8, (byte) 0xff, (byte) 0x96, (byte) 0x93,
            (byte) 0xba, (byte) 0x3c, (byte) 0x88, (byte) 0xcc, (byte) 0x80, (byte) 0xf9,
            (byte) 0xdb, (byte) 0xa8, (byte) 0x4d, (byte) 0x86, (byte) 0x47, (byte) 0xc8,
            (byte) 0xbf, (byte) 0x34, (byte) 0x2d, (byte) 0xda, (byte) 0xb6, (byte) 0x28,
            (byte) 0xf0, (byte) 0x1e, (byte) 0xd2, (byte) 0x46, (byte) 0x0d, (byte) 0x6f,
            (byte) 0x36, (byte) 0x8e, (byte) 0x84, (byte) 0xd8, (byte) 0xaf, (byte) 0xf7,
            (byte) 0x69, (byte) 0x23, (byte) 0x77, (byte) 0xfb, (byte) 0xc5, (byte) 0x04,
            (byte) 0x08, (byte) 0x18, (byte) 0xac, (byte) 0x85, (byte) 0x80, (byte) 0x87,
            (byte) 0x1c, (byte) 0xfe, (byte) 0x8e, (byte) 0x5d, (byte) 0x00, (byte) 0x7f,
            (byte) 0x5b, (byte) 0x33, (byte) 0xf5, (byte) 0xdf, (byte) 0x70, (byte) 0x81,
            (byte) 0xad, (byte) 0x81, (byte) 0xf4, (byte) 0x5a, (byte) 0x37, (byte) 0x8a,
            (byte) 0x79, (byte) 0x09, (byte) 0xc5, (byte) 0x55, (byte) 0xab, (byte) 0x58,
            (byte) 0x7c, (byte) 0x47, (byte) 0xca, (byte) 0xa5, (byte) 0x80, (byte) 0x49,
            (byte) 0x5f, (byte) 0x71, (byte) 0x83, (byte) 0xfb, (byte) 0x3b, (byte) 0x06,
            (byte) 0xec, (byte) 0x75, (byte) 0x23, (byte) 0xc4, (byte) 0x32, (byte) 0xc7,
            (byte) 0x18, (byte) 0xf6, (byte) 0x82, (byte) 0x95, (byte) 0x98, (byte) 0x39,
            (byte) 0xf7, (byte) 0x92, (byte) 0x31, (byte) 0xc0, (byte) 0x89, (byte) 0xba,
            (byte) 0xd4, (byte) 0xd4, (byte) 0x58, (byte) 0x4e, (byte) 0x38, (byte) 0x35,
            (byte) 0x10, (byte) 0xb9, (byte) 0xf1, (byte) 0x27, (byte) 0xdc, (byte) 0xff,
            (byte) 0xc7, (byte) 0xb2, (byte) 0xba, (byte) 0x1f, (byte) 0x27, (byte) 0xaf,
            (byte) 0x99, (byte) 0xd5, (byte) 0xb0, (byte) 0x39, (byte) 0xe7, (byte) 0x43,
            (byte) 0x88, (byte) 0xd3, (byte) 0xce, (byte) 0x38, (byte) 0xc2, (byte) 0x99,
            (byte) 0x43, (byte) 0xfc, (byte) 0x8a, (byte) 0xe3, (byte) 0x60, (byte) 0x0d,
            (byte) 0x0a, (byte) 0xb8, (byte) 0xc4, (byte) 0x29, (byte) 0xca, (byte) 0x0d,
            (byte) 0x30, (byte) 0xaf, (byte) 0xca, (byte) 0xd0, (byte) 0xaa, (byte) 0x67,
            (byte) 0xb1, (byte) 0xdd, (byte) 0xdb, (byte) 0x7a, (byte) 0x11, (byte) 0xad,
            (byte) 0xeb, (byte) 0x02, (byte) 0x81, (byte) 0xc0, (byte) 0x71, (byte) 0xb8,
            (byte) 0xcf, (byte) 0x72, (byte) 0x35, (byte) 0x67, (byte) 0xb5, (byte) 0x38,
            (byte) 0x8f, (byte) 0x16, (byte) 0xd3, (byte) 0x29, (byte) 0x82, (byte) 0x35,
            (byte) 0x21, (byte) 0xd4, (byte) 0x49, (byte) 0x20, (byte) 0x74, (byte) 0x2d,
            (byte) 0xc0, (byte) 0xa4, (byte) 0x44, (byte) 0xf5, (byte) 0xd8, (byte) 0xc9,
            (byte) 0xe9, (byte) 0x90, (byte) 0x1d, (byte) 0xde, (byte) 0x3a, (byte) 0xa6,
            (byte) 0xd7, (byte) 0xe5, (byte) 0xe8, (byte) 0x4e, (byte) 0x83, (byte) 0xd7,
            (byte) 0xe6, (byte) 0x2f, (byte) 0x92, (byte) 0x31, (byte) 0x21, (byte) 0x3f,
            (byte) 0xfa, (byte) 0xd2, (byte) 0x85, (byte) 0x92, (byte) 0x1f, (byte) 0xff,
            (byte) 0x61, (byte) 0x00, (byte) 0xf6, (byte) 0xda, (byte) 0x6e, (byte) 0xc6,
            (byte) 0x7f, (byte) 0x5a, (byte) 0x35, (byte) 0x79, (byte) 0xdc, (byte) 0xdc,
            (byte) 0xa3, (byte) 0x2e, (byte) 0x9f, (byte) 0x35, (byte) 0xd1, (byte) 0x5c,
            (byte) 0xda, (byte) 0xb9, (byte) 0xf7, (byte) 0x58, (byte) 0x7d, (byte) 0x4f,
            (byte) 0xb6, (byte) 0x13, (byte) 0xd7, (byte) 0x2c, (byte) 0x0a, (byte) 0xa8,
            (byte) 0x4d, (byte) 0xf2, (byte) 0xe4, (byte) 0x67, (byte) 0x4f, (byte) 0x8b,
            (byte) 0xa6, (byte) 0xca, (byte) 0x1a, (byte) 0xbb, (byte) 0x02, (byte) 0x63,
            (byte) 0x8f, (byte) 0xb7, (byte) 0x46, (byte) 0xec, (byte) 0x7a, (byte) 0x8a,
            (byte) 0x09, (byte) 0x0a, (byte) 0x45, (byte) 0x3a, (byte) 0x8d, (byte) 0xa8,
            (byte) 0x83, (byte) 0x4b, (byte) 0x0a, (byte) 0xdb, (byte) 0x4b, (byte) 0x99,
            (byte) 0xf3, (byte) 0x69, (byte) 0x95, (byte) 0xf0, (byte) 0xcf, (byte) 0xe9,
            (byte) 0xf7, (byte) 0x67, (byte) 0xc9, (byte) 0x45, (byte) 0x18, (byte) 0x2f,
            (byte) 0xf0, (byte) 0x5c, (byte) 0x90, (byte) 0xbd, (byte) 0xa6, (byte) 0x66,
            (byte) 0x8c, (byte) 0xfe, (byte) 0x60, (byte) 0x5d, (byte) 0x6c, (byte) 0x27,
            (byte) 0xec, (byte) 0xc1, (byte) 0x84, (byte) 0xb2, (byte) 0xa1, (byte) 0x97,
            (byte) 0x9e, (byte) 0x16, (byte) 0x29, (byte) 0xa7, (byte) 0xe0, (byte) 0x38,
            (byte) 0xa2, (byte) 0x36, (byte) 0x05, (byte) 0x5f, (byte) 0xda, (byte) 0x72,
            (byte) 0x1a, (byte) 0x5f, (byte) 0xa8, (byte) 0x7d, (byte) 0x41, (byte) 0x35,
            (byte) 0xf6, (byte) 0x4e, (byte) 0x0a, (byte) 0x88, (byte) 0x8e, (byte) 0x00,
            (byte) 0x98, (byte) 0xa6, (byte) 0xca, (byte) 0xc1, (byte) 0xdf, (byte) 0x72,
            (byte) 0x6c, (byte) 0xfe, (byte) 0x29, (byte) 0xbe, (byte) 0xa3, (byte) 0x9b,
            (byte) 0x0b, (byte) 0x5c, (byte) 0x0b, (byte) 0x9d, (byte) 0xa7, (byte) 0x71,
            (byte) 0xce, (byte) 0x04, (byte) 0xfa, (byte) 0xac, (byte) 0x01, (byte) 0x8d,
            (byte) 0x52, (byte) 0xa0, (byte) 0x3d, (byte) 0xdd, (byte) 0x02, (byte) 0x81,
            (byte) 0xc1, (byte) 0x00, (byte) 0xc1, (byte) 0xc0, (byte) 0x2e, (byte) 0xa9,
            (byte) 0xee, (byte) 0xca, (byte) 0xff, (byte) 0xe4, (byte) 0xf8, (byte) 0x15,
            (byte) 0xfd, (byte) 0xa5, (byte) 0x68, (byte) 0x1b, (byte) 0x2d, (byte) 0x4a,
            (byte) 0xe6, (byte) 0x37, (byte) 0x06, (byte) 0xb3, (byte) 0xd7, (byte) 0x64,
            (byte) 0xad, (byte) 0xb9, (byte) 0x05, (byte) 0x26, (byte) 0x97, (byte) 0x94,
            (byte) 0x3a, (byte) 0x9e, (byte) 0x1c, (byte) 0xd0, (byte) 0xcd, (byte) 0x7b,
            (byte) 0xf4, (byte) 0x88, (byte) 0xe2, (byte) 0xa5, (byte) 0x6d, (byte) 0xed,
            (byte) 0x24, (byte) 0x77, (byte) 0x52, (byte) 0x39, (byte) 0x43, (byte) 0x0f,
            (byte) 0x4e, (byte) 0x75, (byte) 0xd8, (byte) 0xa3, (byte) 0x59, (byte) 0x5a,
            (byte) 0xc2, (byte) 0xba, (byte) 0x9a, (byte) 0x5b, (byte) 0x60, (byte) 0x31,
            (byte) 0x0d, (byte) 0x58, (byte) 0x89, (byte) 0x13, (byte) 0xe8, (byte) 0x95,
            (byte) 0xdd, (byte) 0xae, (byte) 0xcc, (byte) 0x1f, (byte) 0x73, (byte) 0x48,
            (byte) 0x55, (byte) 0xd8, (byte) 0xfb, (byte) 0x67, (byte) 0xce, (byte) 0x18,
            (byte) 0x85, (byte) 0x59, (byte) 0xad, (byte) 0x1f, (byte) 0x93, (byte) 0xe1,
            (byte) 0xb7, (byte) 0x54, (byte) 0x80, (byte) 0x8e, (byte) 0x5f, (byte) 0xbc,
            (byte) 0x1c, (byte) 0x96, (byte) 0x66, (byte) 0x2e, (byte) 0x40, (byte) 0x17,
            (byte) 0x2e, (byte) 0x01, (byte) 0x7a, (byte) 0x7d, (byte) 0xaa, (byte) 0xff,
            (byte) 0xa3, (byte) 0xd2, (byte) 0xdf, (byte) 0xe2, (byte) 0xf3, (byte) 0x54,
            (byte) 0x51, (byte) 0xeb, (byte) 0xba, (byte) 0x7c, (byte) 0x2a, (byte) 0x22,
            (byte) 0xc6, (byte) 0x42, (byte) 0xbc, (byte) 0xa1, (byte) 0x6c, (byte) 0xcf,
            (byte) 0x73, (byte) 0x2e, (byte) 0x07, (byte) 0xfc, (byte) 0xf5, (byte) 0x67,
            (byte) 0x25, (byte) 0xd0, (byte) 0xfa, (byte) 0xeb, (byte) 0xb4, (byte) 0xd4,
            (byte) 0x19, (byte) 0xcc, (byte) 0x64, (byte) 0xa1, (byte) 0x2e, (byte) 0x78,
            (byte) 0x45, (byte) 0xd9, (byte) 0x7f, (byte) 0x1b, (byte) 0x4c, (byte) 0x10,
            (byte) 0x31, (byte) 0x44, (byte) 0xe8, (byte) 0xcc, (byte) 0xf9, (byte) 0x1b,
            (byte) 0x87, (byte) 0x31, (byte) 0xd6, (byte) 0x69, (byte) 0x85, (byte) 0x4a,
            (byte) 0x49, (byte) 0xf6, (byte) 0xb2, (byte) 0xe0, (byte) 0xb8, (byte) 0x98,
            (byte) 0x3c, (byte) 0xf6, (byte) 0x78, (byte) 0x46, (byte) 0xc8, (byte) 0x3d,
            (byte) 0x60, (byte) 0xc1, (byte) 0xaa, (byte) 0x2f, (byte) 0x28, (byte) 0xa1,
            (byte) 0x14, (byte) 0x6b, (byte) 0x75, (byte) 0x4d, (byte) 0xb1, (byte) 0x3d,
            (byte) 0x80, (byte) 0x49, (byte) 0x33, (byte) 0xfd, (byte) 0x71, (byte) 0xc0,
            (byte) 0x13, (byte) 0x1e, (byte) 0x16, (byte) 0x69, (byte) 0x80, (byte) 0xa4,
            (byte) 0x9c, (byte) 0xd7, (byte) 0x02, (byte) 0x81, (byte) 0xc1, (byte) 0x00,
            (byte) 0x8c, (byte) 0x33, (byte) 0x2d, (byte) 0xd9, (byte) 0xf3, (byte) 0x42,
            (byte) 0x4d, (byte) 0xca, (byte) 0x5e, (byte) 0x60, (byte) 0x14, (byte) 0x10,
            (byte) 0xf6, (byte) 0xf3, (byte) 0x71, (byte) 0x15, (byte) 0x88, (byte) 0x54,
            (byte) 0x84, (byte) 0x21, (byte) 0x04, (byte) 0xb1, (byte) 0xaf, (byte) 0x02,
            (byte) 0x11, (byte) 0x7f, (byte) 0x42, (byte) 0x3e, (byte) 0x86, (byte) 0xcb,
            (byte) 0x6c, (byte) 0xf5, (byte) 0x57, (byte) 0x78, (byte) 0x4a, (byte) 0x03,
            (byte) 0x9b, (byte) 0x80, (byte) 0xc2, (byte) 0x04, (byte) 0x3a, (byte) 0x6b,
            (byte) 0xb3, (byte) 0x30, (byte) 0x31, (byte) 0x7e, (byte) 0xc3, (byte) 0x89,
            (byte) 0x09, (byte) 0x4e, (byte) 0x86, (byte) 0x59, (byte) 0x41, (byte) 0xb5,
            (byte) 0xae, (byte) 0xd5, (byte) 0xc6, (byte) 0x38, (byte) 0xbc, (byte) 0xd7,
            (byte) 0xd7, (byte) 0x8e, (byte) 0xa3, (byte) 0x1a, (byte) 0xde, (byte) 0x32,
            (byte) 0xad, (byte) 0x8d, (byte) 0x15, (byte) 0x81, (byte) 0xfe, (byte) 0xac,
            (byte) 0xbd, (byte) 0xd0, (byte) 0xca, (byte) 0xbc, (byte) 0xd8, (byte) 0x6a,
            (byte) 0xe1, (byte) 0xfe, (byte) 0xda, (byte) 0xc4, (byte) 0xd8, (byte) 0x62,
            (byte) 0x71, (byte) 0x20, (byte) 0xa3, (byte) 0xd3, (byte) 0x06, (byte) 0x11,
            (byte) 0xa9, (byte) 0x53, (byte) 0x7a, (byte) 0x44, (byte) 0x89, (byte) 0x3d,
            (byte) 0x28, (byte) 0x5e, (byte) 0x7d, (byte) 0xf0, (byte) 0x60, (byte) 0xeb,
            (byte) 0xb5, (byte) 0xdf, (byte) 0xed, (byte) 0x4f, (byte) 0x6d, (byte) 0x05,
            (byte) 0x59, (byte) 0x06, (byte) 0xb0, (byte) 0x62, (byte) 0x50, (byte) 0x1c,
            (byte) 0xb7, (byte) 0x2c, (byte) 0x44, (byte) 0xa4, (byte) 0x49, (byte) 0xf8,
            (byte) 0x4f, (byte) 0x4b, (byte) 0xab, (byte) 0x71, (byte) 0x5b, (byte) 0xcb,
            (byte) 0x31, (byte) 0x10, (byte) 0x41, (byte) 0xe0, (byte) 0x1a, (byte) 0x15,
            (byte) 0xdc, (byte) 0x4c, (byte) 0x5d, (byte) 0x4f, (byte) 0x62, (byte) 0x83,
            (byte) 0xa4, (byte) 0x80, (byte) 0x06, (byte) 0x36, (byte) 0xba, (byte) 0xc9,
            (byte) 0xe2, (byte) 0xa4, (byte) 0x11, (byte) 0x98, (byte) 0x6b, (byte) 0x4c,
            (byte) 0xe9, (byte) 0x90, (byte) 0x55, (byte) 0x18, (byte) 0xde, (byte) 0xe1,
            (byte) 0x42, (byte) 0x38, (byte) 0x28, (byte) 0xa3, (byte) 0x54, (byte) 0x56,
            (byte) 0x31, (byte) 0xaf, (byte) 0x5a, (byte) 0xd6, (byte) 0xf0, (byte) 0x26,
            (byte) 0xe0, (byte) 0x7a, (byte) 0xd9, (byte) 0x6c, (byte) 0x64, (byte) 0xca,
            (byte) 0x5d, (byte) 0x6d, (byte) 0x3d, (byte) 0x9a, (byte) 0xfe, (byte) 0x36,
            (byte) 0x93, (byte) 0x9e, (byte) 0x62, (byte) 0x94, (byte) 0xc6, (byte) 0x07,
            (byte) 0x83, (byte) 0x96, (byte) 0xd6, (byte) 0x27, (byte) 0xa6, (byte) 0xd8
    };
    private static final PrivateKey CLIENT_SUITE_B_RSA3072_KEY =
            loadPrivateKey(""RSA"", CLIENT_SUITE_B_RSA3072_KEY_DATA);

    private static final String CLIENT_SUITE_B_ECDSA_CERT_STRING =
            ""-----BEGIN CERTIFICATE-----\n""
                    + ""MIIB9zCCAX4CFDpfSZh3AH07BEfGWuMDa7Ynz6y+MAoGCCqGSM49BAMDMF4xCzAJ\n""
                    + ""BgNVBAYTAlVTMQswCQYDVQQIDAJDQTEMMAoGA1UEBwwDTVRWMRAwDgYDVQQKDAdB\n""
                    + ""bmRyb2lkMQ4wDAYDVQQLDAVXaS1GaTESMBAGA1UEAwwJdW5pdGVzdENBMB4XDTIw\n""
                    + ""MDcyMTAyMjk1MFoXDTMwMDUzMDAyMjk1MFowYjELMAkGA1UEBhMCVVMxCzAJBgNV\n""
                    + ""BAgMAkNBMQwwCgYDVQQHDANNVFYxEDAOBgNVBAoMB0FuZHJvaWQxDjAMBgNVBAsM\n""
                    + ""BVdpLUZpMRYwFAYDVQQDDA11bml0ZXN0Q2xpZW50MHYwEAYHKoZIzj0CAQYFK4EE\n""
                    + ""ACIDYgAEhxhVJ7dcSqrto0X+dgRxtd8BWG8cWmPjBji3MIxDLfpcMDoIB84ae1Ew\n""
                    + ""gJn4YUYHrWsUDiVNihv8j7a/Ol1qcIY2ybH7tbezefLmagqA4vXEUXZXoUyL4ZNC\n""
                    + ""DWcdw6LrMAoGCCqGSM49BAMDA2cAMGQCMH4aP73HrriRUJRguiuRic+X4Cqj/7YQ\n""
                    + ""ueJmP87KF92/thhoQ9OrRo8uJITPmNDswwIwP2Q1AZCSL4BI9dYrqu07Ar+pSkXE\n""
                    + ""R7oOqGdZR+d/MvXcFSrbIaLKEoHXmQamIHLe\n""
                    + ""-----END CERTIFICATE-----\n"";
    private static final X509Certificate CLIENT_SUITE_B_ECDSA_CERT =
            loadCertificate(CLIENT_SUITE_B_ECDSA_CERT_STRING);

    private static final byte[] CLIENT_SUITE_B_ECC_KEY_DATA = new byte[]{
            (byte) 0x30, (byte) 0x81, (byte) 0xb6, (byte) 0x02, (byte) 0x01, (byte) 0x00,
            (byte) 0x30, (byte) 0x10, (byte) 0x06, (byte) 0x07, (byte) 0x2a, (byte) 0x86,
            (byte) 0x48, (byte) 0xce, (byte) 0x3d, (byte) 0x02, (byte) 0x01, (byte) 0x06,
            (byte) 0x05, (byte) 0x2b, (byte) 0x81, (byte) 0x04, (byte) 0x00, (byte) 0x22,
            (byte) 0x04, (byte) 0x81, (byte) 0x9e, (byte) 0x30, (byte) 0x81, (byte) 0x9b,
            (byte) 0x02, (byte) 0x01, (byte) 0x01, (byte) 0x04, (byte) 0x30, (byte) 0xea,
            (byte) 0x6c, (byte) 0x4b, (byte) 0x6d, (byte) 0x43, (byte) 0xf9, (byte) 0x6c,
            (byte) 0x91, (byte) 0xdc, (byte) 0x2d, (byte) 0x6e, (byte) 0x87, (byte) 0x4f,
            (byte) 0x0a, (byte) 0x0b, (byte) 0x97, (byte) 0x25, (byte) 0x1c, (byte) 0x79,
            (byte) 0xa2, (byte) 0x07, (byte) 0xdc, (byte) 0x94, (byte) 0xc2, (byte) 0xee,
            (byte) 0x64, (byte) 0x51, (byte) 0x6d, (byte) 0x4e, (byte) 0x35, (byte) 0x1c,
            (byte) 0x22, (byte) 0x2f, (byte) 0xc0, (byte) 0xea, (byte) 0x09, (byte) 0x47,
            (byte) 0x3e, (byte) 0xb9, (byte) 0xb6, (byte) 0xb8, (byte) 0x83, (byte) 0x9e,
            (byte) 0xed, (byte) 0x59, (byte) 0xe5, (byte) 0xe7, (byte) 0x0f, (byte) 0xa1,
            (byte) 0x64, (byte) 0x03, (byte) 0x62, (byte) 0x00, (byte) 0x04, (byte) 0x87,
            (byte) 0x18, (byte) 0x55, (byte) 0x27, (byte) 0xb7, (byte) 0x5c, (byte) 0x4a,
            (byte) 0xaa, (byte) 0xed, (byte) 0xa3, (byte) 0x45, (byte) 0xfe, (byte) 0x76,
            (byte) 0x04, (byte) 0x71, (byte) 0xb5, (byte) 0xdf, (byte) 0x01, (byte) 0x58,
            (byte) 0x6f, (byte) 0x1c, (byte) 0x5a, (byte) 0x63, (byte) 0xe3, (byte) 0x06,
            (byte) 0x38, (byte) 0xb7, (byte) 0x30, (byte) 0x8c, (byte) 0x43, (byte) 0x2d,
            (byte) 0xfa, (byte) 0x5c, (byte) 0x30, (byte) 0x3a, (byte) 0x08, (byte) 0x07,
            (byte) 0xce, (byte) 0x1a, (byte) 0x7b, (byte) 0x51, (byte) 0x30, (byte) 0x80,
            (byte) 0x99, (byte) 0xf8, (byte) 0x61, (byte) 0x46, (byte) 0x07, (byte) 0xad,
            (byte) 0x6b, (byte) 0x14, (byte) 0x0e, (byte) 0x25, (byte) 0x4d, (byte) 0x8a,
            (byte) 0x1b, (byte) 0xfc, (byte) 0x8f, (byte) 0xb6, (byte) 0xbf, (byte) 0x3a,
            (byte) 0x5d, (byte) 0x6a, (byte) 0x70, (byte) 0x86, (byte) 0x36, (byte) 0xc9,
            (byte) 0xb1, (byte) 0xfb, (byte) 0xb5, (byte) 0xb7, (byte) 0xb3, (byte) 0x79,
            (byte) 0xf2, (byte) 0xe6, (byte) 0x6a, (byte) 0x0a, (byte) 0x80, (byte) 0xe2,
            (byte) 0xf5, (byte) 0xc4, (byte) 0x51, (byte) 0x76, (byte) 0x57, (byte) 0xa1,
            (byte) 0x4c, (byte) 0x8b, (byte) 0xe1, (byte) 0x93, (byte) 0x42, (byte) 0x0d,
            (byte) 0x67, (byte) 0x1d, (byte) 0xc3, (byte) 0xa2, (byte) 0xeb
    };
    private static final PrivateKey CLIENT_SUITE_B_ECC_KEY =
            loadPrivateKey(""EC"", CLIENT_SUITE_B_ECC_KEY_DATA);

    private static X509Certificate loadCertificate(String blob) {
        try {
            final CertificateFactory certFactory = CertificateFactory.getInstance(""X.509"");
            InputStream stream = new ByteArrayInputStream(blob.getBytes(StandardCharsets.UTF_8));

            return (X509Certificate) certFactory.generateCertificate(stream);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    private static PrivateKey loadPrivateKey(String algorithm, byte[] fakeKey) {
        try {
            KeyFactory kf = KeyFactory.getInstance(algorithm);
            return kf.generatePrivate(new PKCS8EncodedKeySpec(fakeKey));
        } catch (InvalidKeySpecException | NoSuchAlgorithmException e) {
            return null;
        }
    }

    private WifiNetworkSuggestion.Builder createBuilderWithCommonParams() {
        return createBuilderWithCommonParams(false);
    }

    private WifiNetworkSuggestion.Builder createBuilderWithCommonParams(boolean isPasspoint) {
        WifiNetworkSuggestion.Builder builder = new WifiNetworkSuggestion.Builder();
        if (!isPasspoint) {
            builder.setSsid(TEST_SSID);
            builder.setBssid(MacAddress.fromString(TEST_BSSID));
            builder.setIsEnhancedOpen(false);
            builder.setIsHiddenSsid(true);
        }
        builder.setPriority(TEST_PRIORITY);
        builder.setIsAppInteractionRequired(true);
        builder.setIsUserInteractionRequired(true);
        builder.setIsMetered(true);
        builder.setCarrierId(TelephonyManager.UNKNOWN_CARRIER_ID);
        builder.setCredentialSharedWithUser(true);
        builder.setIsInitialAutojoinEnabled(true);
        builder.setUntrusted(false);
        if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
            builder.setOemPaid(false);
            builder.setOemPrivate(false);
            builder.setSubscriptionId(TEST_SUB_ID);
        }
        if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(sContext)) {
            builder.setPriorityGroup(TEST_PRIORITY_GROUP);
        }
        return builder;
    }

    private void validateCommonParams(WifiNetworkSuggestion suggestion) {
        validateCommonParams(suggestion, false);
    }

    private void validateCommonParams(WifiNetworkSuggestion suggestion, boolean isPasspoint) {
        assertNotNull(suggestion);
        assertNotNull(suggestion.getWifiConfiguration());
        if (!isPasspoint) {
            assertEquals(TEST_SSID, suggestion.getSsid());
            assertEquals(TEST_BSSID, suggestion.getBssid().toString());
            assertFalse(suggestion.isEnhancedOpen());
            assertTrue(suggestion.isHiddenSsid());
        }
        assertEquals(TEST_PRIORITY, suggestion.getPriority());
        assertTrue(suggestion.isAppInteractionRequired());
        assertTrue(suggestion.isUserInteractionRequired());
        assertTrue(suggestion.isMetered());
        assertTrue(suggestion.isCredentialSharedWithUser());
        assertTrue(suggestion.isInitialAutojoinEnabled());
        assertFalse(suggestion.isUntrusted());
        if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
            assertFalse(suggestion.isOemPaid());
            assertFalse(suggestion.isOemPrivate());
            assertEquals(TEST_SUB_ID, suggestion.getSubscriptionId());
        }
        if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(sContext)) {
            assertEquals(TEST_PRIORITY_GROUP, suggestion.getPriorityGroup());
            assertEquals(TelephonyManager.UNKNOWN_CARRIER_ID, suggestion.getCarrierId());
        }
    }

    /**
     * Tests {@link android.net.wifi.WifiNetworkSuggestion.Builder} class.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.permission.cts.SharedUidPermissionsTest"	"runtimePermissionsCanBeRevokedOnPackageThatDoesNotDeclarePermission"	"CtsPermissionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/SharedUidPermissionsTest.java"	""	"public void runtimePermissionsCanBeRevokedOnPackageThatDoesNotDeclarePermission()
            throws Exception {
        install(APK_THAT_REQUESTS_PERMISSIONS);
        install(APK_THAT_REQUESTS_NO_PERMISSIONS);
        grantPermission(PKG_THAT_REQUESTS_PERMISSIONS, READ_CONTACTS);
        revokePermission(PKG_THAT_REQUESTS_NO_PERMISSIONS, READ_CONTACTS);

        assertThat(isPermissionGranted(PKG_THAT_REQUESTS_PERMISSIONS, READ_CONTACTS)).isFalse();
        assertThat(isPermissionGranted(PKG_THAT_REQUESTS_NO_PERMISSIONS, READ_CONTACTS)).isFalse();
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.permission.cts.SharedUidPermissionsTest"	"runtimePermissionsCanBeGrantedOnPackageThatDoesNotDeclarePermission"	"CtsPermissionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/SharedUidPermissionsTest.java"	""	"public void runtimePermissionsCanBeGrantedOnPackageThatDoesNotDeclarePermission()
            throws Exception {
        install(APK_THAT_REQUESTS_PERMISSIONS);
        install(APK_THAT_REQUESTS_NO_PERMISSIONS);
        grantPermission(PKG_THAT_REQUESTS_NO_PERMISSIONS, READ_CONTACTS);

        assertThat(isPermissionGranted(PKG_THAT_REQUESTS_PERMISSIONS, READ_CONTACTS)).isTrue();
        assertThat(isPermissionGranted(PKG_THAT_REQUESTS_NO_PERMISSIONS, READ_CONTACTS)).isTrue();
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.tests.stagedinstall.StagedInstallTest"	"testApexTargetingOldDevSdkFailsVerification"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/stagedinstall/app/src/com/android/tests/stagedinstall/StagedInstallTest.java"	""	"public void testApexTargetingOldDevSdkFailsVerification() throws Exception {
        stageSingleApk(Apex2SdkTargetP).assertFailure();
    }

    /**
     * Apex should fail to install if apk-in-apex fails to get scanned
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.tests.stagedinstall.StagedInstallTest"	"testApexFailsToInstallIfApkInApexFailsToScan_Commit"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/stagedinstall/app/src/com/android/tests/stagedinstall/StagedInstallTest.java"	""	"public void testApexFailsToInstallIfApkInApexFailsToScan_Commit() throws Exception {
        int sessionId = stageSingleApk(Apex2ApkInApexSdkTargetP).assertSuccessful().getSessionId();
        waitForIsReadyBroadcast(sessionId);
        storeSessionId(sessionId);
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.tests.stagedinstall.StagedInstallTest"	"testApexFailsToInstallIfApkInApexFailsToScan_VerifyPostReboot"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/stagedinstall/app/src/com/android/tests/stagedinstall/StagedInstallTest.java"	""	"public void testApexFailsToInstallIfApkInApexFailsToScan_VerifyPostReboot() throws Exception {
        int sessionId = retrieveLastSessionId();
        assertSessionFailed(sessionId);
        assertSessionFailedWithMessage(sessionId, ""Failed to parse ""
                + ""/apex/com.android.apex.cts.shim/app/CtsShimTargetPSdk"");
        assertThat(getInstalledVersion(SHIM_APEX_PACKAGE_NAME)).isEqualTo(1);
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.compatibility.common.util.CtsKeyEventUtil"	"uptimeMillis"	""	"/home/gpoor/cts-12-source/cts/common/device-side/util-axt/src/com/android/compatibility/common/util/CtsKeyEventUtil.java"	""	"public void test/*
 *.
 */

package com.android.compatibility.common.util;

import android.app.Instrumentation;
import android.os.Looper;
import android.os.SystemClock;
import android.util.Log;
import android.view.InputDevice;
import android.view.KeyCharacterMap;
import android.view.KeyEvent;
import android.view.View;
import android.view.inputmethod.InputMethodManager;

import java.lang.reflect.Field;

/**
 * Utility class to send KeyEvents bypassing the IME. The code is similar to functions in
 * {@link Instrumentation} and {@link android.test.InstrumentationTestCase} classes. It uses
 * {@link InputMethodManager#dispatchKeyEventFromInputMethod(View, KeyEvent)} to send the events.
 * After sending the events waits for idle.
 */
public final class CtsKeyEventUtil {

    private CtsKeyEventUtil() {}

    /**
     * Sends the key events corresponding to the text to the app being instrumented.
     *
     * @param instrumentation the instrumentation used to run the test.
     * @param targetView View to find the ViewRootImpl and dispatch.
     * @param text The text to be sent. Null value returns immediately.
     */
    public static void sendString(final Instrumentation instrumentation, final View targetView,
            final String text) {
        if (text == null) {
            return;
        }

        KeyEvent[] events = getKeyEvents(text);

        if (events != null) {
            for (int i = 0; i < events.length; i++) {
                // We have to change the time of an event before injecting it because
                // all KeyEvents returned by KeyCharacterMap.getEvents() have the same
                // time stamp and the system rejects too old events. Hence, it is
                // possible for an event to become stale before it is injected if it
                // takes too long to inject the preceding ones.
                sendKey(instrumentation, targetView, KeyEvent.changeTimeRepeat(
                        events[i], SystemClock.uptimeMillis(), 0 /* newRepeat */));
            }
        }
    }

    /**
     * Sends a series of key events through instrumentation. For instance:
     * sendKeys(view, KEYCODE_DPAD_LEFT, KEYCODE_DPAD_CENTER).
     *
     * @param instrumentation the instrumentation used to run the test.
     * @param targetView View to find the ViewRootImpl and dispatch.
     * @param keys The series of key codes.
     */
    public static void sendKeys(final Instrumentation instrumentation, final View targetView,
            final int...keys) {
        final int count = keys.length;

        for (int i = 0; i < count; i++) {
            try {
                sendKeyDownUp(instrumentation, targetView, keys[i]);
            } catch (SecurityException e) {
                // Ignore security exceptions that are now thrown
                // when trying to send to another app, to retain
                // compatibility with existing tests.
            }
        }
    }

    /**
     * Sends a series of key events through instrumentation. The sequence of keys is a string
     * containing the key names as specified in KeyEvent, without the KEYCODE_ prefix. For
     * instance: sendKeys(view, ""DPAD_LEFT A B C DPAD_CENTER""). Each key can be repeated by using
     * the N* prefix. For instance, to send two KEYCODE_DPAD_LEFT, use the following:
     * sendKeys(view, ""2*DPAD_LEFT"").
     *
     * @param instrumentation the instrumentation used to run the test.
     * @param targetView View to find the ViewRootImpl and dispatch.
     * @param keysSequence The sequence of keys.
     */
    public static void sendKeys(final Instrumentation instrumentation, final View targetView,
            final String keysSequence) {
        final String[] keys = keysSequence.split("" "");
        final int count = keys.length;

        for (int i = 0; i < count; i++) {
            String key = keys[i];
            int repeater = key.indexOf('*');

            int keyCount;
            try {
                keyCount = repeater == -1 ? 1 : Integer.parseInt(key.substring(0, repeater));
            } catch (NumberFormatException e) {
                Log.w(""ActivityTestCase"", ""Invalid repeat count: "" + key);
                continue;
            }

            if (repeater != -1) {
                key = key.substring(repeater + 1);
            }

            for (int j = 0; j < keyCount; j++) {
                try {
                    final Field keyCodeField = KeyEvent.class.getField(""KEYCODE_"" + key);
                    final int keyCode = keyCodeField.getInt(null);
                    try {
                        sendKeyDownUp(instrumentation, targetView, keyCode);
                    } catch (SecurityException e) {
                        // Ignore security exceptions that are now thrown
                        // when trying to send to another app, to retain
                        // compatibility with existing tests.
                    }
                } catch (NoSuchFieldException e) {
                    Log.w(""ActivityTestCase"", ""Unknown keycode: KEYCODE_"" + key);
                    break;
                } catch (IllegalAccessException e) {
                    Log.w(""ActivityTestCase"", ""Unknown keycode: KEYCODE_"" + key);
                    break;
                }
            }
        }
    }

    /**
     * Sends an up and down key events.
     *
     * @param instrumentation the instrumentation used to run the test.
     * @param targetView View to find the ViewRootImpl and dispatch.
     * @param key The integer keycode for the event to be sent.
     */
    public static void sendKeyDownUp(final Instrumentation instrumentation, final View targetView,
            final int key) {
        sendKey(instrumentation, targetView, new KeyEvent(KeyEvent.ACTION_DOWN, key),
                false /* waitForIdle */);
        sendKey(instrumentation, targetView, new KeyEvent(KeyEvent.ACTION_UP, key));
    }

    /**
     * Sends a key event.
     *
     * @param instrumentation the instrumentation used to run the test.
     * @param targetView View to find the ViewRootImpl and dispatch.
     * @param event KeyEvent to be send.
     */
    public static void sendKey(final Instrumentation instrumentation, final View targetView,
            final KeyEvent event) {
        sendKey(instrumentation, targetView, event, true /* waitForIdle */);
    }

    private static void sendKey(final Instrumentation instrumentation, final View targetView,
            final KeyEvent event, boolean waitForIdle) {
        validateNotAppThread();

        long downTime = event.getDownTime();
        long eventTime = event.getEventTime();
        int action = event.getAction();
        int code = event.getKeyCode();
        int repeatCount = event.getRepeatCount();
        int metaState = event.getMetaState();
        int deviceId = event.getDeviceId();
        int scanCode = event.getScanCode();
        int source = event.getSource();
        int flags = event.getFlags();
        if (source == InputDevice.SOURCE_UNKNOWN) {
            source = InputDevice.SOURCE_KEYBOARD;
        }
        if (eventTime == 0) {
            eventTime = SystemClock.uptimeMillis();
        }
        if (downTime == 0) {
            downTime = eventTime;
        }

        final KeyEvent newEvent = new KeyEvent(downTime, eventTime, action, code, repeatCount,
                metaState, deviceId, scanCode, flags, source);

        InputMethodManager imm = targetView.getContext().getSystemService(InputMethodManager.class);
        imm.dispatchKeyEventFromInputMethod(imm.isActive() ? null : targetView, newEvent);
        if (waitForIdle) {
            instrumentation.waitForIdleSync();
        }
    }

    /**
     * Sends a key event while holding another modifier key down, then releases both keys and
     * waits for idle sync. Useful for sending combinations like shift + tab.
     *
     * @param instrumentation the instrumentation used to run the test.
     * @param targetView View to find the ViewRootImpl and dispatch.
     * @param keyCodeToSend The integer keycode for the event to be sent.
     * @param modifierKeyCodeToHold The integer keycode of the modifier to be held.
     */
    public static void sendKeyWhileHoldingModifier(final Instrumentation instrumentation,
            final View targetView, final int keyCodeToSend,
            final int modifierKeyCodeToHold) {
        final int metaState = getMetaStateForModifierKeyCode(modifierKeyCodeToHold);
        final long downTime = SystemClock.uptimeMillis();

        final KeyEvent holdKeyDown = new KeyEvent(downTime, downTime, KeyEvent.ACTION_DOWN,
                modifierKeyCodeToHold, 0 /* repeat */);
        sendKey(instrumentation ,targetView, holdKeyDown);

        final KeyEvent keyDown = new KeyEvent(downTime, downTime, KeyEvent.ACTION_DOWN,
                keyCodeToSend, 0 /* repeat */, metaState);
        sendKey(instrumentation, targetView, keyDown);

        final KeyEvent keyUp = new KeyEvent(downTime, downTime, KeyEvent.ACTION_UP,
                keyCodeToSend, 0 /* repeat */, metaState);
        sendKey(instrumentation, targetView, keyUp);

        final KeyEvent holdKeyUp = new KeyEvent(downTime, downTime, KeyEvent.ACTION_UP,
                modifierKeyCodeToHold, 0 /* repeat */);
        sendKey(instrumentation, targetView, holdKeyUp);

        instrumentation.waitForIdleSync();
    }

    private static int getMetaStateForModifierKeyCode(int modifierKeyCode) {
        if (!KeyEvent.isModifierKey(modifierKeyCode)) {
            throw new IllegalArgumentException(""Modifier key expected, but got: ""
                    + KeyEvent.keyCodeToString(modifierKeyCode));
        }

        int metaState;
        switch (modifierKeyCode) {
            case KeyEvent.KEYCODE_SHIFT_LEFT:
                metaState = KeyEvent.META_SHIFT_LEFT_ON;
                break;
            case KeyEvent.KEYCODE_SHIFT_RIGHT:
                metaState = KeyEvent.META_SHIFT_RIGHT_ON;
                break;
            case KeyEvent.KEYCODE_ALT_LEFT:
                metaState = KeyEvent.META_ALT_LEFT_ON;
                break;
            case KeyEvent.KEYCODE_ALT_RIGHT:
                metaState = KeyEvent.META_ALT_RIGHT_ON;
                break;
            case KeyEvent.KEYCODE_CTRL_LEFT:
                metaState = KeyEvent.META_CTRL_LEFT_ON;
                break;
            case KeyEvent.KEYCODE_CTRL_RIGHT:
                metaState = KeyEvent.META_CTRL_RIGHT_ON;
                break;
            case KeyEvent.KEYCODE_META_LEFT:
                metaState = KeyEvent.META_META_LEFT_ON;
                break;
            case KeyEvent.KEYCODE_META_RIGHT:
                metaState = KeyEvent.META_META_RIGHT_ON;
                break;
            case KeyEvent.KEYCODE_SYM:
                metaState = KeyEvent.META_SYM_ON;
                break;
            case KeyEvent.KEYCODE_NUM:
                metaState = KeyEvent.META_NUM_LOCK_ON;
                break;
            case KeyEvent.KEYCODE_FUNCTION:
                metaState = KeyEvent.META_FUNCTION_ON;
                break;
            default:
                // Safety net: all modifier keys need to have at least one meta state associated.
                throw new UnsupportedOperationException(""No meta state associated with ""
                        + ""modifier key: "" + KeyEvent.keyCodeToString(modifierKeyCode));
        }

        return KeyEvent.normalizeMetaState(metaState);
    }

    private static KeyEvent[] getKeyEvents(final String text) {
        KeyCharacterMap keyCharacterMap = KeyCharacterMap.load(KeyCharacterMap.VIRTUAL_KEYBOARD);
        return keyCharacterMap.getEvents(text.toCharArray());
    }

    private static void validateNotAppThread() {
        if (Looper.myLooper() == Looper.getMainLooper()) {
            throw new RuntimeException(
                    ""This method can not be called from the main application thread"");
        }
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.server.cts.device.batterystats.BatteryStatsBgVsFgActions"	"getDefaultDisplay"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/incident/apps/batterystatsapp/src/com/android/server/cts/device/batterystats/BatteryStatsBgVsFgActions.java"	""	"public void test/*
 *.
 */

package com.android.server.cts.device.batterystats;

import android.accounts.Account;
import android.app.Activity;
import android.app.ActivityManager;
import android.bluetooth.BluetoothAdapter;
import android.bluetooth.le.BluetoothLeScanner;
import android.bluetooth.le.ScanCallback;
import android.bluetooth.le.ScanResult;
import android.bluetooth.le.ScanSettings;
import android.content.BroadcastReceiver;
import android.app.job.JobInfo;
import android.app.job.JobScheduler;
import android.content.ComponentName;
import android.content.ContentResolver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.graphics.Color;
import android.graphics.Point;
import android.location.Location;
import android.location.LocationListener;
import android.location.LocationManager;
import android.os.AsyncTask;
import android.os.Bundle;
import android.os.Handler;
import android.os.HandlerThread;
import android.os.Looper;
import android.util.Log;
import android.view.Gravity;
import android.view.View;
import android.view.ViewGroup;
import android.view.WindowManager;


import org.junit.Assert;

import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

public class BatteryStatsBgVsFgActions {
    private static final String TAG = BatteryStatsBgVsFgActions.class.getSimpleName();

    private static final int DO_NOTHING_TIMEOUT = 2000;

    public static final String KEY_ACTION = ""action"";
    public static final String ACTION_BLE_SCAN_OPTIMIZED = ""action.ble_scan_optimized"";
    public static final String ACTION_BLE_SCAN_UNOPTIMIZED = ""action.ble_scan_unoptimized"";
    public static final String ACTION_JOB_SCHEDULE = ""action.jobs"";
    public static final String ACTION_SYNC = ""action.sync"";
    public static final String ACTION_SLEEP_WHILE_BACKGROUND = ""action.sleep_background"";
    public static final String ACTION_SLEEP_WHILE_TOP = ""action.sleep_top"";
    public static final String ACTION_SHOW_APPLICATION_OVERLAY = ""action.show_application_overlay"";

    public static final String KEY_REQUEST_CODE = ""request_code"";

    /** Number of times to check that app is in correct state before giving up. */
    public static final int PROC_STATE_CHECK_ATTEMPTS = 10;

    /** Number of times to check that Bluetooth is enabled before giving up. */
    public static final int BT_ENABLE_ATTEMPTS = 8;

    /** Perform the action specified by the given action code (see constants above). */
    public static void doAction(Context ctx, String actionCode, String requestCode) {
        if (actionCode == null) {
            Log.e(TAG, ""Intent was missing action."");
            return;
        }
        sleep(100);
        switch (actionCode) {
            case ACTION_BLE_SCAN_OPTIMIZED:
                doOptimizedBleScan(ctx, requestCode);
                break;
            case ACTION_BLE_SCAN_UNOPTIMIZED:
                doUnoptimizedBleScan(ctx, requestCode);
                break;
            case ACTION_JOB_SCHEDULE:
                doScheduleJob(ctx, requestCode);
                break;
            case ACTION_SYNC:
                doSync(ctx, requestCode);
                break;
            case ACTION_SLEEP_WHILE_BACKGROUND:
                sleep(DO_NOTHING_TIMEOUT);
                tellHostActionFinished(ACTION_SLEEP_WHILE_BACKGROUND, requestCode);
                break;
            case ACTION_SLEEP_WHILE_TOP:
                doNothingAsync(ctx, ACTION_SLEEP_WHILE_TOP, requestCode);
                break;
            case ACTION_SHOW_APPLICATION_OVERLAY:
                showApplicationOverlay(ctx, requestCode);
                break;
            default:
                Log.e(TAG, ""Intent had invalid action"");
        }
        sleep(100);
    }

    private static void showApplicationOverlay(Context ctx, String requestCode) {
        final WindowManager wm = ctx.getSystemService(WindowManager.class);
        Point size = new Point();
        wm.getDefaultDisplay().getSize(size);

        WindowManager.LayoutParams wmlp = new WindowManager.LayoutParams(
                WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY,
                WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE
                        | WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON
                        | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE);
        wmlp.width = size.x / 4;
        wmlp.height = size.y / 4;
        wmlp.gravity = Gravity.CENTER | Gravity.LEFT;
        wmlp.setTitle(ctx.getPackageName());

        ViewGroup.LayoutParams vglp = new ViewGroup.LayoutParams(
                ViewGroup.LayoutParams.MATCH_PARENT,
                ViewGroup.LayoutParams.MATCH_PARENT);

        View v = new View(ctx);
        v.setBackgroundColor(Color.GREEN);
        v.setLayoutParams(vglp);
        wm.addView(v, wmlp);

        tellHostActionFinished(ACTION_SHOW_APPLICATION_OVERLAY, requestCode);
    }

    private static void doOptimizedBleScan(Context ctx, String requestCode) {
        ScanSettings scanSettings = new ScanSettings.Builder()
                .setScanMode(ScanSettings.SCAN_MODE_OPPORTUNISTIC).build();
        performBleScan(scanSettings);
        tellHostActionFinished(ACTION_BLE_SCAN_OPTIMIZED, requestCode);
    }

    private static void doUnoptimizedBleScan(Context ctx, String requestCode) {
        ScanSettings scanSettings = new ScanSettings.Builder()
                .setScanMode(ScanSettings.SCAN_MODE_LOW_LATENCY).build();
        performBleScan(scanSettings);
        tellHostActionFinished(ACTION_BLE_SCAN_UNOPTIMIZED, requestCode);
    }

    private static void performBleScan(ScanSettings scanSettings) {
        BluetoothAdapter bluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
        if (bluetoothAdapter == null) {
            Log.e(TAG, ""Device does not support Bluetooth"");
            return;
        }
        boolean bluetoothEnabledByTest = false;
        if (!bluetoothAdapter.isEnabled()) {
            if (!bluetoothAdapter.enable()) {
                Log.e(TAG, ""Bluetooth is not enabled"");
                return;
            }
            for (int attempt = 0; attempt < BT_ENABLE_ATTEMPTS; attempt++) {
                if (bluetoothAdapter.isEnabled()) {
                    break;
                } else {
                    if (attempt < BT_ENABLE_ATTEMPTS - 1) {
                        sleep(1_000);
                    } else {
                        throw new RuntimeException(""Bluetooth enable failed."");
                    }
                }
            }
            bluetoothEnabledByTest = true;
        }

        BluetoothLeScanner bleScanner = bluetoothAdapter.getBluetoothLeScanner();
        if (bleScanner == null) {
            Log.e(TAG, ""Cannot access BLE scanner"");
            return;
        }

        ScanCallback scanCallback = new ScanCallback() {
            @Override
            public void onScanResult(int callbackType, ScanResult result) {
                Log.v(TAG, ""called onScanResult"");
            }

            @Override
            public void onScanFailed(int errorCode) {
                Log.v(TAG, ""called onScanFailed"");
            }

            @Override
            public void onBatchScanResults(List<ScanResult> results) {
                Log.v(TAG, ""called onBatchScanResults"");
            }
        };

        bleScanner.startScan(null, scanSettings, scanCallback);
        sleep(2_000);
        bleScanner.stopScan(scanCallback);

        // Restore adapter state at end of test
        if (bluetoothEnabledByTest) {
            bluetoothAdapter.disable();
        }
    }

    private static void doScheduleJob(Context ctx, String requestCode) {
        final ComponentName JOB_COMPONENT_NAME =
                new ComponentName(""com.android.server.cts.device.batterystats"",
                        SimpleJobService.class.getName());
        JobScheduler js = ctx.getSystemService(JobScheduler.class);
        if (js == null) {
            Log.e(TAG, ""JobScheduler service not available"");
            tellHostActionFinished(ACTION_JOB_SCHEDULE, requestCode);
            return;
        }
        final JobInfo job = (new JobInfo.Builder(1, JOB_COMPONENT_NAME))
                .setOverrideDeadline(0)
                .build();
        CountDownLatch latch = SimpleJobService.resetCountDownLatch();
        js.schedule(job);
        // Job starts in main thread so wait in another thread to see if job finishes.
        new AsyncTask<Void, Void, Void>() {
            @Override
            protected Void doInBackground(Void... params) {
                waitForReceiver(null, 60_000, latch, null);
                tellHostActionFinished(ACTION_JOB_SCHEDULE, requestCode);
                return null;
            }
        }.execute();
    }

    private static void doNothingAsync(Context ctx, String requestCode, String actionCode) {
        new AsyncTask<Void, Void, Void>() {
            @Override
            protected Void doInBackground(Void... params) {
                sleep(DO_NOTHING_TIMEOUT);
                return null;
            }

            @Override
            protected void onPostExecute(Void nothing) {
                if (ctx instanceof Activity) {
                    ((Activity) ctx).finish();
                    tellHostActionFinished(actionCode, requestCode);
                }
            }
        }.execute();
    }

    private static void doSync(Context ctx, String requestCode) {
        BatteryStatsAuthenticator.removeAllAccounts(ctx);
        final Account account = BatteryStatsAuthenticator.getTestAccount();
        // Create the test account.
        BatteryStatsAuthenticator.ensureTestAccount(ctx);
        // Force set is syncable.
        ContentResolver.setMasterSyncAutomatically(true);
        ContentResolver.setIsSyncable(account, BatteryStatsProvider.AUTHORITY, 1);

        new AsyncTask<Void, Void, Void>() {
            @Override
            protected Void doInBackground(Void... params) {
                try {
                    Log.v(TAG, ""Starting sync"");
                    BatteryStatsSyncAdapter.requestSync(account);
                    sleep(500);
                } catch (Exception e) {
                    Log.e(TAG, ""Exception trying to sync"", e);
                }
                BatteryStatsAuthenticator.removeAllAccounts(ctx);
                return null;
            }

            @Override
            protected void onPostExecute(Void aVoid) {
                super.onPostExecute(aVoid);
                Log.v(TAG, ""Finished sync method"");
                // If ctx is an Activity, finish it when sync is done. If it's a service, don't.
                if (ctx instanceof Activity) {
                    ((Activity) ctx).finish();
                }
                tellHostActionFinished(ACTION_SYNC, requestCode);
            }
        }.execute();
    }

    /** Register receiver to determine when given action is complete. */
    private static BroadcastReceiver registerReceiver(
            Context ctx, CountDownLatch onReceiveLatch, IntentFilter intentFilter) {
        BroadcastReceiver receiver = new BroadcastReceiver() {
            @Override
            public void onReceive(Context context, Intent intent) {
                onReceiveLatch.countDown();
            }
        };
        // run Broadcast receiver in a different thread since the foreground activity will wait.
        HandlerThread handlerThread = new HandlerThread(""br_handler_thread"");
        handlerThread.start();
        Looper looper = handlerThread.getLooper();
        Handler handler = new Handler(looper);
        ctx.registerReceiver(receiver, intentFilter, null, handler);
        return receiver;
    }

    /**
     * Uses the receiver to wait until the action is complete. ctx and receiver may be null if no
     * receiver is needed to be unregistered.
     */
    private static void waitForReceiver(Context ctx,
            int maxWaitTimeMs, CountDownLatch latch, BroadcastReceiver receiver) {
        try {
            boolean didFinish = latch.await(maxWaitTimeMs, TimeUnit.MILLISECONDS);
            if (didFinish) {
                Log.v(TAG, ""Finished performing action"");
            } else {
                // This is not necessarily a problem. If we just want to make sure a count was
                // recorded for the request, it doesn't matter if the action actually finished.
                Log.w(TAG, ""Did not finish in specified time."");
            }
        } catch (InterruptedException e) {
            Log.e(TAG, ""Interrupted exception while awaiting action to finish"", e);
        }
        if (ctx != null && receiver != null) {
            ctx.unregisterReceiver(receiver);
        }
    }

    /** Communicates to hostside (via logcat) that action has completed (regardless of success). */
    private static void tellHostActionFinished(String actionCode, String requestCode) {
        String s = String.format(""Completed performing %s for request %s"", actionCode, requestCode);
        Log.i(TAG, s);
    }

    /** Determines whether the package is running as a background process. */
    private static boolean isAppInBackground(Context context) throws ReflectiveOperationException {
        String pkgName = context.getPackageName();
        ActivityManager am = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
        List<ActivityManager.RunningAppProcessInfo> processes = am.getRunningAppProcesses();
        if (processes == null) {
            return false;
        }
        for (ActivityManager.RunningAppProcessInfo r : processes) {
            // BatteryStatsImpl treats as background if procState is >=
            // Activitymanager.PROCESS_STATE_IMPORTANT_BACKGROUND (corresponding
            // to BatteryStats.PROCESS_STATE_BACKGROUND).
            // Due to lack of permissions, only the current app should show up in the list of
            // processes, which is desired in this case; but in case this changes later, we check
            // that the package name matches anyway.
            int processState = -1;
            int backgroundCode = -1;
            try {
                processState = ActivityManager.RunningAppProcessInfo.class
                        .getField(""processState"").getInt(r);
                backgroundCode = (Integer) ActivityManager.class
                        .getDeclaredField(""PROCESS_STATE_IMPORTANT_BACKGROUND"").get(null);
            } catch (ReflectiveOperationException ex) {
                Log.e(TAG, ""Failed to get proc state info via reflection"", ex);
                throw ex;
            }
            if (processState < backgroundCode) { // if foreground process
                for (String rpkg : r.pkgList) {
                    if (pkgName.equals(rpkg)) {
                        return false;
                    }
                }
            }
        }
        return true;
    }

    /**
     * Makes sure app is in desired state, either background (if shouldBeBg = true) or foreground
     * (if shouldBeBg = false).
     * Tries for up to PROC_STATE_CHECK_ATTEMPTS seconds. If app is still not in the correct state,
     * throws an AssertionError failure to crash the app.
     */
    public static void checkAppState(
            Context context, boolean shouldBeBg, String actionCode, String requestCode) {
        final String errMsg = ""App is "" + (shouldBeBg ? ""not "" : """") + ""a background process!"";
        try {
            for (int attempt = 0; attempt < PROC_STATE_CHECK_ATTEMPTS; attempt++) {
                if (shouldBeBg == isAppInBackground(context)) {
                    return; // No problems.
                } else {
                    if (attempt < PROC_STATE_CHECK_ATTEMPTS - 1) {
                        Log.w(TAG, errMsg + "" Trying again in 1s."");
                        sleep(1_000);
                    } else {
                        Log.e(TAG, errMsg + "" Quiting app."");
                        BatteryStatsBgVsFgActions.tellHostActionFinished(actionCode, requestCode);
                        Assert.fail(errMsg + "" Test requires app to be in the correct state."");
                    }
                }
            }
        } catch(ReflectiveOperationException ex) {
            Log.w(TAG, ""Couldn't determine if app is in background. Proceeding with test anyway."");
        }
    }

    /** Puts the current thread to sleep. */
    private static void sleep(int millis) {
        try {
            Thread.sleep(millis);
        } catch (InterruptedException e) {
            Log.e(TAG, ""Interrupted exception while sleeping"", e);
        }
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.os.cts.ProcfsHostTests"	"startTestApp"	"CtsOsHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/os/src/android/os/cts/ProcfsHostTests.java"	""	"public void test/*
 *.
 */

package android.os.cts;

import com.android.compatibility.common.tradefed.build.CompatibilityBuildHelper;
import com.android.tradefed.build.IBuildInfo;
import com.android.tradefed.device.ITestDevice;
import com.android.tradefed.testtype.DeviceTestCase;
import com.android.tradefed.testtype.IBuildReceiver;

import java.io.File;
import java.util.Scanner;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import junit.framework.AssertionFailedError;

public class ProcfsHostTests extends DeviceTestCase implements IBuildReceiver {
  // We need a running test app to test /proc/[PID]/* files.
  private static final String TEST_APP_PACKAGE = ""android.os.procfs"";
  private static final String TEST_APP_CLASS = ""ProcfsTest"";
  private static final String APK_NAME = ""CtsHostProcfsTestApp.apk"";
  private static final String START_TEST_APP_COMMAND =
      String.format(
          ""am start -W -a android.intent.action.MAIN -n %s/%s.%s"",
          TEST_APP_PACKAGE, TEST_APP_PACKAGE, TEST_APP_CLASS);
  private static final String TEST_APP_LOG_REGEXP = ""PID is (\\d+)"";
  private static final Pattern TEST_APP_LOG_PATTERN = Pattern.compile(TEST_APP_LOG_REGEXP);

  private static final String PROC_STAT_PATH = ""/proc/stat"";
  private static final String PROC_STAT_READ_COMMAND = ""head -1 "";
  // Verfies the first line of /proc/stat includes 'cpu' followed by 10 numbers.
  // The 10th column was introduced in kernel version 2.6.33.
  private static final String PROC_STAT_REGEXP = ""cpu ( \\d+){10,10}"";
  private static final Pattern PROC_STAT_PATTERN = Pattern.compile(PROC_STAT_REGEXP);

  // In Linux, a process's stat file (/proc/[PID]/stat) and a thread's (/proc/[PID]/task/[TID]/stat)
  // share the same format. We want to verify these stat files include pid (a number), file name
  // (a string in parentheses), and state (a character), followed by 41 or more numbers.
  // The 44th column was introduced in kernel version 2.6.24.
  private static final String PID_TID_STAT_REGEXP = ""\\d+ \\(.*\\) [A-Za-z]( [\\d-]+){41,}"";
  private static final Pattern PID_TID_STAT_PATTERN = Pattern.compile(PID_TID_STAT_REGEXP);

  // Interval in milliseconds between two sequential reads when checking whether a file is being
  // updated.
  private static final long UPDATE_READ_INTERVAL_MS = 100;
  // Max time in milliseconds waiting for a file being update. If a file's content does not change
  // during the period, it is not considered being actively updated.
  private static final long UPDATE_MAX_WAIT_TIME_MS = 5000;

  // A reference to the device under test, which gives us a handle to run commands.
  private ITestDevice mDevice;

  private int mTestAppPid = -1;

  private IBuildInfo mBuild;

  @Override
  public void setBuild(IBuildInfo buildInfo) {
      mBuild = buildInfo;
  }

  @Override
  protected synchronized void setUp() throws Exception {
    super.setUp();
    mDevice = getDevice();
    mTestAppPid = startTestApp();
  }

  /**
   * Tests that host, as the shell user, can read /proc/stat file, the file is in a reasonable
   * shape, and the file is being updated.
   *
   * @throws Exception
   */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.os.cts.ProcfsHostTests"	"testProcTidStat"	"CtsOsHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/os/src/android/os/cts/ProcfsHostTests.java"	""	"public void testProcTidStat() throws Exception {
    int[] tids = lookForTidsInProcess(mTestAppPid);
    assertTrue(""/proc/"" + mTestAppPid + ""/task/ includes < 2 threads"", tids.length >= 2);
    int successCount = 0;
    for (int tid : tids) {
      String filePath = ""/proc/"" + mTestAppPid + ""/task/"" + tid + ""/stat"";
      try {
        readAndCheckFile(filePath, ""cat "", PID_TID_STAT_PATTERN);
        successCount++;
      } catch (AssertionFailedError e) {
        // Threads may be short-lived. Make sure they're still there before throwing assertion error
        if (mDevice.doesFileExist(filePath)) {
          throw e;
        }
      }
    }
    assertTrue(""/proc/"" + mTestAppPid + ""/task/ includes < 2 threads"", successCount >= 2);
  }

  /**
   * Tests that host, as the shell user, can read the file at the given absolute path by using the
   * given read command, the file is in the expected format pattern, and the file is being updated.
   *
   * @throws Exception
   */
  private void testFile(String absolutePath, String readCommand, Pattern pattern) throws Exception {
    String content = readAndCheckFile(absolutePath, readCommand, pattern);

    // Check the file is being updated.
    long waitTime = 0;
    while (waitTime < UPDATE_MAX_WAIT_TIME_MS) {
      java.lang.Thread.sleep(UPDATE_READ_INTERVAL_MS);
      waitTime += UPDATE_READ_INTERVAL_MS;
      String newContent = readAndCheckFile(absolutePath, readCommand, pattern);
      if (!newContent.equals(content)) {
        return;
      }
    }
    assertTrue(absolutePath + "" not actively updated. Content: \"""" + content + ""\"""", false);
  }

  /**
   * Starts the test app and returns its process ID.
   *
   * @throws Exception
   */
  private int startTestApp() throws Exception {

    // Uninstall+install the app
    mDevice.uninstallPackage(TEST_APP_PACKAGE);
    CompatibilityBuildHelper buildHelper = new CompatibilityBuildHelper(mBuild);
    File app = buildHelper.getTestFile(APK_NAME);
    String[] options = {};
    mDevice.installPackage(app, false, options);

    // Clear logcat.
    mDevice.executeAdbCommand(""logcat"", ""-c"");
    // Start the app activity and wait for it to complete.
    String results = mDevice.executeShellCommand(START_TEST_APP_COMMAND);
    // Dump logcat.
    String logs =
        mDevice.executeAdbCommand(""logcat"", ""-v"", ""brief"", ""-d"", TEST_APP_CLASS + "":I"", ""*:S"");
    // Search for string contianing the process ID.
    int pid = -1;
    Scanner in = new Scanner(logs);
    while (in.hasNextLine()) {
      String line = in.nextLine();
      if (line.startsWith(""I/"" + TEST_APP_CLASS)) {
        Matcher m = TEST_APP_LOG_PATTERN.matcher(line.split("":"")[1].trim());
        if (m.matches()) {
          pid = Integer.parseInt(m.group(1));
        }
      }
    }
    in.close();
    // Assert test app's pid is captured from log.
    assertTrue(
        ""Test app PID not captured. results = \"""" + results + ""\""; logs = \"""" + logs + ""\"""",
        pid > 0);
    return pid;
  }

  /**
   * Reads and returns the file content at the given absolute path by using the given read command,
   * after ensuring it is in the expected pattern.
   *
   * @throws Exception
   */
  private String readAndCheckFile(String absolutePath, String readCommand, Pattern pattern)
      throws Exception {
    String readResult = getDevice().executeShellCommand(readCommand + absolutePath);
    assertNotNull(""Unexpected empty file "" + absolutePath, readResult);
    readResult = readResult.trim();
    assertTrue(
        ""Unexpected format of "" + absolutePath + "": \"""" + readResult + ""\"""",
        pattern.matcher(readResult).matches());
    return readResult;
  }

  /**
   * Returns the thread IDs in a given process.
   *
   * @throws Exception
   */
  private int[] lookForTidsInProcess(int pid) throws Exception {
    String taskPath = ""/proc/"" + pid + ""/task"";
    // Explicitly pass -1 to 'ls' to get one per line rather than relying on adb not allocating a
    // tty.
    String lsOutput = getDevice().executeShellCommand(""ls -1 "" + taskPath);
    assertNotNull(""Unexpected empty directory "" + taskPath, lsOutput);

    String[] threads = lsOutput.split(""\\s+"");
    int[] tids = new int[threads.length];
    for (int i = 0; i < threads.length; i++) {
      tids[i] = Integer.parseInt(threads[i]);
    }
    return tids;
  }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.tagging.TaggingBaseTest"	"isChangeEnabled"	"CtsTaggingHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/tagging/src/com/android/cts/tagging/TaggingBaseTest.java"	""	"public void test/*
 *.
 */

package com.android.cts.tagging;

import android.compat.cts.CompatChangeGatingTestCase;
import com.android.tradefed.device.ITestDevice;
import com.google.common.collect.ImmutableSet;
import java.util.Scanner;

public class TaggingBaseTest extends CompatChangeGatingTestCase {
    private static final String DEVICE_KERNEL_HELPER_CLASS_NAME = ""DeviceKernelHelpers"";
    private static final String DEVICE_KERNEL_HELPER_APK_NAME = ""DeviceKernelHelpers.apk"";
    private static final String DEVICE_KERNEL_HELPER_PKG_NAME = ""android.cts.tagging.support"";
    private static final String KERNEL_HELPER_START_COMMAND = String.format(
        ""am instrument -w -e package %1$s %1$s/androidx.test.runner.AndroidJUnitRunner"",
        DEVICE_KERNEL_HELPER_PKG_NAME);

    protected static final long NATIVE_HEAP_POINTER_TAGGING_CHANGE_ID = 135754954;
    protected static final String DEVICE_TEST_CLASS_NAME = "".TaggingTest"";
    protected static final String DEVICE_TAGGING_DISABLED_TEST_NAME = ""testHeapTaggingDisabled"";
    protected static final String DEVICE_TAGGING_ENABLED_TEST_NAME = ""testHeapTaggingEnabled"";

    // True if test device supports ARM MTE extension.
    protected boolean deviceSupportsMemoryTagging = false;
    // Initialized in setUp(), contains a set of pointer tagging changes that should be reported by
    // statsd. This set contains the compat change ID for heap tagging iff we can guarantee a statsd
    // report containing the compat change, and is empty otherwise. If the platform doesn't call
    // mPlatformCompat.isChangeEnabled(), the statsd report doesn't contain an entry to the status
    // of the corresponding compat feature. Compat isn't probed in a few scenarios: non-aarch64
    // builds, if the kernel doesn't have support for tagged pointers, if the device supports MTE,
    // or if the app has opted-out of the tagged pointers feature via. the manifest flag.
    protected ImmutableSet reportedChangeSet = ImmutableSet.of();
    // Initialized in setUp(), contains DEVICE_TAGGING_ENABLED_TEST_NAME iff the device supports
    // tagged pointers, and DEVICE_TAGGING_DISABLED_TEST_NAME otherwise. Note - if MTE hardware
    // is present, the device does not support the tagged pointers feature.
    protected String testForWhenSoftwareWantsTagging = DEVICE_TAGGING_DISABLED_TEST_NAME;

    @Override
    protected void setUp() throws Exception {
        installPackage(DEVICE_KERNEL_HELPER_APK_NAME, true);
        ITestDevice device = getDevice();

        // Compat features have a very complicated truth table as to whether they can be
        // enabled/disabled, including variants for:
        //   - Enabling vs. disabling.
        //   - `-userdebug` vs. ""pre-release"" `-user` vs. ""release"" `-user` builds.
        //   - `targetSdkLevel`-gated changes vs. default-enabled vs. default-disabled.
        //   - Debuggable vs. non-debuggable apps.
        // We care most about compat features working correctly in the context of released `-user`
        // builds, as these are what the customers of the compat features are most likely using. In
        // order to ensure consistency here, we basically remove all these variables by reducing our
        // device config permutations to a single set. All our apps are debuggable, and the
        // following code forces the device to treat this test as a ""released"" `-user` build, which
        // is the most restrictive and the most realistic w.r.t. what our users will use.
        device.executeShellCommand(
                ""settings put global force_non_debuggable_final_build_for_compat 1"");

        // Kernel support for tagged pointers can only be determined on device.
        // Deploy a helper package and observe what the kernel tells us about
        // tagged pointers support.
        device.executeAdbCommand(""logcat"", ""-c"");
        device.executeShellCommand(KERNEL_HELPER_START_COMMAND);
        String logs = device.executeAdbCommand(
                ""logcat"", ""-v"", ""brief"", ""-d"", DEVICE_KERNEL_HELPER_CLASS_NAME + "":I"", ""*:S"");

        // Holds whether the device that this test is running on was determined to have both
        // requirements for ARM TBI: the correct architecture (aarch64) and the full set of kernel
        // patches (as indicated by a successful prctl(PR_GET_TAGGED_ADDR_CTRL)).
        boolean deviceHasTBI = false;
        boolean foundKernelHelperResult = false;
        Scanner in = new Scanner(logs);
        while (in.hasNextLine()) {
            String line = in.nextLine();
            if (line.contains(""Kernel supports tagged pointers"")) {
                foundKernelHelperResult = true;
                deviceHasTBI = line.contains(""true"");
                break;
            }
        }
        in.close();
        if (!foundKernelHelperResult) {
            throw new Exception(""Failed to get a result from the kernel helper."");
        }

        deviceSupportsMemoryTagging = !runCommand(""grep 'Features.* mte' /proc/cpuinfo"").isEmpty();

        if (deviceHasTBI && !deviceSupportsMemoryTagging) {
            reportedChangeSet = ImmutableSet.of(NATIVE_HEAP_POINTER_TAGGING_CHANGE_ID);
            testForWhenSoftwareWantsTagging = DEVICE_TAGGING_ENABLED_TEST_NAME;
        }
    }

    @Override
    protected void tearDown() throws Exception {
        uninstallPackage(DEVICE_KERNEL_HELPER_PKG_NAME, true);
        ITestDevice device = getDevice();
        device.executeShellCommand(
                ""settings put global force_non_debuggable_final_build_for_compat 0"");
    }
}"	""	""	"probe scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.scopedstorage.cts.ScopedStorageTest"	"testAccess_file"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/src/android/scopedstorage/cts/ScopedStorageTest.java"	""	"public void testAccess_file() throws Exception {
        pollForPermission(Manifest.permission.READ_EXTERNAL_STORAGE, /*granted*/ true);

        final File downloadDir = getDownloadDir();
        final File otherAppPdf = new File(downloadDir, ""other-"" + NONMEDIA_FILE_NAME);
        final File shellPdfAtRoot = new File(getExternalStorageDir(),
                ""shell-"" + NONMEDIA_FILE_NAME);
        final File otherAppImage = new File(getDcimDir(), ""other-"" + IMAGE_FILE_NAME);
        final File myAppPdf = new File(downloadDir, ""my-"" + NONMEDIA_FILE_NAME);
        final File doesntExistPdf = new File(downloadDir, ""nada-"" + NONMEDIA_FILE_NAME);

        try {
            assertThat(createFileAs(APP_B_NO_PERMS, otherAppPdf.getPath())).isTrue();
            assertThat(createFileAs(APP_B_NO_PERMS, otherAppImage.getPath())).isTrue();

            // We can read our image and pdf files.
            assertThat(myAppPdf.createNewFile()).isTrue();
            assertFileAccess_readWrite(myAppPdf);

            // We can read the other app's image file because we hold R_E_S, but we can
            // check only exists for the pdf files.
            assertFileAccess_readOnly(otherAppImage);
            assertFileAccess_existsOnly(otherAppPdf);
            assertAccess(doesntExistPdf, false, false, false);

            // We can check only exists for another app's files on root.
            createFileAsLegacyApp(shellPdfAtRoot);
            MediaStore.scanFile(getContentResolver(), shellPdfAtRoot);
            assertFileAccess_existsOnly(shellPdfAtRoot);
        } finally {
            deleteFileAsNoThrow(APP_B_NO_PERMS, otherAppPdf.getAbsolutePath());
            deleteFileAsNoThrow(APP_B_NO_PERMS, otherAppImage.getAbsolutePath());
            deleteAsLegacyApp(shellPdfAtRoot);
            MediaStore.scanFile(getContentResolver(), shellPdfAtRoot);
            myAppPdf.delete();
        }
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.scopedstorage.cts.ScopedStorageTest"	"testManageExternalStorageReaddir"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/src/android/scopedstorage/cts/ScopedStorageTest.java"	""	"public void testManageExternalStorageReaddir() throws Exception {
        pollForManageExternalStorageAllowed();

        final File otherAppPdf = new File(getDownloadDir(), ""other"" + NONMEDIA_FILE_NAME);
        final File otherAppImg = new File(getDcimDir(), ""other"" + IMAGE_FILE_NAME);
        final File otherAppMusic = new File(getMusicDir(), ""other"" + AUDIO_FILE_NAME);
        final File otherTopLevelFile = new File(getExternalStorageDir(),
                ""other"" + NONMEDIA_FILE_NAME);
        try {
            assertCreateFilesAs(APP_B_NO_PERMS, otherAppImg, otherAppMusic, otherAppPdf);
            createFileAsLegacyApp(otherTopLevelFile);
            MediaStore.scanFile(getContentResolver(), otherTopLevelFile);

            // We can list other apps' files
            assertDirectoryContains(otherAppPdf.getParentFile(), otherAppPdf);
            assertDirectoryContains(otherAppImg.getParentFile(), otherAppImg);
            assertDirectoryContains(otherAppMusic.getParentFile(), otherAppMusic);
            // We can list top level files
            assertDirectoryContains(getExternalStorageDir(), otherTopLevelFile);

            // We can also list all top level directories
            assertDirectoryContains(getExternalStorageDir(), getDefaultTopLevelDirs());
        } finally {
            deleteAsLegacyApp(otherTopLevelFile);
            MediaStore.scanFile(getContentResolver(), otherTopLevelFile);
            deleteFilesAs(APP_B_NO_PERMS, otherAppImg, otherAppMusic, otherAppPdf);
        }
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.scopedstorage.cts.ScopedStorageTest"	"testManageExternalStorageDoesntSkipScanningDirtyNomediaDir"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/src/android/scopedstorage/cts/ScopedStorageTest.java"	""	"public void testManageExternalStorageDoesntSkipScanningDirtyNomediaDir() throws Exception {
        pollForManageExternalStorageAllowed();

        final File nomediaDir = new File(getDownloadDir(), TEST_DIRECTORY_NAME);
        final File nomediaFile = new File(nomediaDir, "".nomedia"");
        final File mediaFile = new File(nomediaDir, IMAGE_FILE_NAME);
        final File renamedMediaFile = new File(nomediaDir, ""Renamed_"" + IMAGE_FILE_NAME);
        try {
            if (!nomediaDir.exists()) {
                assertTrue(nomediaDir.mkdirs());
            }
            assertThat(nomediaFile.createNewFile()).isTrue();
            MediaStore.scanFile(getContentResolver(), nomediaDir);

            assertThat(mediaFile.createNewFile()).isTrue();
            MediaStore.scanFile(getContentResolver(), nomediaDir);
            assertThat(getFileRowIdFromDatabase(mediaFile)).isNotEqualTo(-1);

            assertThat(mediaFile.renameTo(renamedMediaFile)).isTrue();
            MediaStore.scanFile(getContentResolver(), nomediaDir);
            assertThat(getFileRowIdFromDatabase(renamedMediaFile)).isNotEqualTo(-1);

            assertThat(renamedMediaFile.delete()).isTrue();
            MediaStore.scanFile(getContentResolver(), nomediaDir);
            assertThat(getFileRowIdFromDatabase(renamedMediaFile)).isEqualTo(-1);
        } finally {
            nomediaFile.delete();
            mediaFile.delete();
            renamedMediaFile.delete();
            nomediaDir.delete();
        }
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.scopedstorage.cts.ScopedStorageTest"	"testScanDoesntSkipDirtySubtree"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/src/android/scopedstorage/cts/ScopedStorageTest.java"	""	"public void testScanDoesntSkipDirtySubtree() throws Exception {
        pollForManageExternalStorageAllowed();

        final File nomediaDir = new File(getDownloadDir(), TEST_DIRECTORY_NAME);
        final File topLevelNomediaFile = new File(nomediaDir, "".nomedia"");
        final File nomediaSubDir = new File(nomediaDir, ""child_"" + TEST_DIRECTORY_NAME);
        final File nomediaFileInSubDir = new File(nomediaSubDir, "".nomedia"");
        final File mediaFile1InSubDir = new File(nomediaSubDir, ""1_"" + IMAGE_FILE_NAME);
        final File mediaFile2InSubDir = new File(nomediaSubDir, ""2_"" + IMAGE_FILE_NAME);
        try {
            if (!nomediaDir.exists()) {
                assertTrue(nomediaDir.mkdirs());
            }
            if (!nomediaSubDir.exists()) {
                assertTrue(nomediaSubDir.mkdirs());
            }
            assertThat(topLevelNomediaFile.createNewFile()).isTrue();
            assertThat(nomediaFileInSubDir.createNewFile()).isTrue();
            MediaStore.scanFile(getContentResolver(), nomediaDir);

            // Verify creating a new file in subdirectory sets dirty state, and scanning the top
            // level nomedia directory will not skip scanning the subdirectory.
            assertCreateFileAndScanNomediaDirDoesntNoOp(mediaFile1InSubDir, nomediaDir);

            // Verify creating a new file in subdirectory sets dirty state, and scanning the
            // subdirectory will not no-op.
            assertCreateFileAndScanNomediaDirDoesntNoOp(mediaFile2InSubDir, nomediaSubDir);
        } finally {
            nomediaFileInSubDir.delete();
            mediaFile1InSubDir.delete();
            mediaFile2InSubDir.delete();
            topLevelNomediaFile.delete();
            nomediaSubDir.delete();
            nomediaDir.delete();
            // Scan the directory to remove stale db rows.
            MediaStore.scanFile(getContentResolver(), nomediaDir);
        }
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.scopedstorage.cts.ScopedStorageTest"	"testUpdateExternalFilesViaRelativePath"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/src/android/scopedstorage/cts/ScopedStorageTest.java"	""	"public void testUpdateExternalFilesViaRelativePath() throws Exception {
        verifyUpdateToExternalMediaDirViaRelativePath_allowed();
        verifyUpdateToExternalPrivateDirsViaRelativePath_denied();
    }

    private void assertCreateFileAndScanNomediaDirDoesntNoOp(File newFile, File scanDir)
            throws Exception {
        assertThat(newFile.createNewFile()).isTrue();
        // File is not added to database yet, but the directory is marked as dirty so that next
        // scan doesn't no-op.
        assertThat(getFileRowIdFromDatabase(newFile)).isEqualTo(-1);

        MediaStore.scanFile(getContentResolver(), scanDir);
        assertThat(getFileRowIdFromDatabase(newFile)).isNotEqualTo(-1);
    }

    /**
     * Verifies that files created by {@code otherApp} in shared locations {@code imageDir}
     * and {@code documentDir} follow the scoped storage rules. Requires the running app to hold
     * {@code READ_EXTERNAL_STORAGE}.
     */
    private void assertSharedStorageAccess(File imageDir, File documentDir, TestApp otherApp)
            throws Exception {
        final File otherAppImage = new File(imageDir, ""abc.jpg"");
        final File otherAppBinary = new File(documentDir, ""abc.bin"");
        try {
            assertCreateFilesAs(otherApp, otherAppImage, otherAppBinary);

            // We can read the other app's image
            assertFileAccess_readOnly(otherAppImage);
            assertFileContent(otherAppImage, new String().getBytes());

            // .. but not the binary file
            assertFileAccess_existsOnly(otherAppBinary);
            assertThrows(FileNotFoundException.class, () -> {
                assertFileContent(otherAppBinary, new String().getBytes());
            });
        } finally {
            deleteFileAsNoThrow(otherApp, otherAppImage.getAbsolutePath());
            deleteFileAsNoThrow(otherApp, otherAppBinary.getAbsolutePath());
        }
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.scopedstorage.cts.ScopedStorageTest"	"testInstantAppsCantAccessExternalStorage"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/src/android/scopedstorage/cts/ScopedStorageTest.java"	""	"@AppModeInstant
    public void testInstantAppsCantAccessExternalStorage() throws Exception {
        assumeTrue(""This test requires that the test runs as an Instant app"",
                getContext().getPackageManager().isInstantApp());
        assertThat(getContext().getPackageManager().isInstantApp()).isTrue();

        // Check that the app does not have legacy external storage access
        assertThat(Environment.isExternalStorageLegacy()).isFalse();

        // Can't read ExternalStorageDir
        assertThat(getExternalStorageDir().list()).isNull();

        // Can't create a top-level direcotry
        final File topLevelDir = new File(getExternalStorageDir(), TEST_DIRECTORY_NAME);
        assertThat(topLevelDir.mkdir()).isFalse();

        // Can't create file under root dir
        final File newTxtFile = new File(getExternalStorageDir(), NONMEDIA_FILE_NAME);
        assertThrows(IOException.class,
                () -> {
                    newTxtFile.createNewFile();
                });

        // Can't create music file under /MUSIC
        final File newMusicFile = new File(getMusicDir(), AUDIO_FILE_NAME);
        assertThrows(IOException.class,
                () -> {
                    newMusicFile.createNewFile();
                });

        // getExternalFilesDir() is not null
        assertThat(getExternalFilesDir()).isNotNull();

        // Can't read/write app specific dir
        assertThat(getExternalFilesDir().list()).isNull();
        assertThat(getExternalFilesDir().exists()).isFalse();
    }

    private static boolean isAtLeastS() {
        return Build.VERSION.SDK_INT >= Build.VERSION_CODES.S;
    }

    private void createAndCheckFileAsApp(TestApp testApp, File newFile) throws Exception {
        assertThat(createFileAs(testApp, newFile.getPath())).isTrue();
        assertThat(getFileOwnerPackageFromDatabase(newFile))
            .isEqualTo(testApp.getPackageName());
        assertThat(getFileRowIdFromDatabase(newFile)).isNotEqualTo(-1);
    }

    private static void assertCreateFilesAs(TestApp testApp, File... files) throws Exception {
        for (File file : files) {
            assertFalse(""File already exists: "" + file, file.exists());
            assertTrue(""Failed to create file "" + file + "" on behalf of ""
                            + testApp.getPackageName(), createFileAs(testApp, file.getPath()));
        }
    }

    /**
     * Makes {@code testApp} create {@code files}. Publishes {@code files} by scanning the file.
     * Pending files from FUSE are not visible to other apps via MediaStore APIs. We have to publish
     * the file or make the file non-pending to make the file visible to other apps.
     * <p>
     * Note that this method can only be used for scannable files.
     */
    private static void assertCreatePublishedFilesAs(TestApp testApp, File... files)
            throws Exception {
        for (File file : files) {
            assertTrue(""Failed to create published file "" + file + "" on behalf of ""
                    + testApp.getPackageName(), createFileAs(testApp, file.getPath()));
            assertNotNull(""Failed to scan "" + file,
                    MediaStore.scanFile(getContentResolver(), file));
        }
    }

    private static void deleteFilesAs(TestApp testApp, File... files) throws Exception {
        for (File file : files) {
            deleteFileAs(testApp, file.getPath());
        }
    }

    /**
     * For possible values of {@code mode}, look at {@link android.content.ContentProvider#openFile}
     */
    private static void assertCanQueryAndOpenFile(File file, String mode) throws IOException {
        // This call performs the query
        final Uri fileUri = getFileUri(file);
        // The query succeeds iff it didn't return null
        assertThat(fileUri).isNotNull();
        // Now we assert that we can open the file through ContentResolver
        try (final ParcelFileDescriptor pfd =
                        getContentResolver().openFileDescriptor(fileUri, mode)) {
            assertThat(pfd).isNotNull();
        }
    }

    private static void assertCanCreateFile(File file) throws IOException {
        // If the file somehow managed to survive a previous run, then the test app was uninstalled
        // and MediaProvider will remove our its ownership of the file, so it's not guaranteed that
        // we can create nor delete it.
        if (!file.exists()) {
            assertThat(file.createNewFile()).isTrue();
            assertThat(file.delete()).isTrue();
        } else {
            Log.w(TAG,
                    ""Couldn't assertCanCreateFile("" + file + "") because file existed prior to ""
                            + ""running the test!"");
        }
    }

    private static void assertFileAccess_existsOnly(File file) throws Exception {
        assertThat(file.isFile()).isTrue();
        assertAccess(file, true, false, false);
    }

    private static void assertFileAccess_readOnly(File file) throws Exception {
        assertThat(file.isFile()).isTrue();
        assertAccess(file, true, true, false);
    }

    private static void assertFileAccess_readWrite(File file) throws Exception {
        assertThat(file.isFile()).isTrue();
        assertAccess(file, true, true, true);
    }

    private static void assertDirectoryAccess(File dir, boolean exists, boolean canWrite)
            throws Exception {
        // This util does not handle app data directories.
        assumeFalse(dir.getAbsolutePath().startsWith(getAndroidDir().getAbsolutePath())
                && !dir.equals(getAndroidDir()));
        assertThat(dir.isDirectory()).isEqualTo(exists);
        // For non-app data directories, exists => canRead().
        assertAccess(dir, exists, exists, exists && canWrite);
    }

    private static void assertAccess(File file, boolean exists, boolean canRead, boolean canWrite)
            throws Exception {
        assertAccess(file, exists, canRead, canWrite, true /* checkExists */);
    }

    private static void assertCannotReadOrWrite(File file)
            throws Exception {
        // App data directories have different 'x' bits on upgrading vs new devices. Let's not
        // check 'exists', by passing checkExists=false. But assert this app cannot read or write
        // the other app's file.
        assertAccess(file, false /* value is moot */, false /* canRead */,
                false /* canWrite */, false /* checkExists */);
    }

    private static void assertCanAccessMyAppFile(File file)
            throws Exception {
        assertAccess(file, true, true /* canRead */,
                true /*canWrite */, true /* checkExists */);
    }

    private static void assertAccess(File file, boolean exists, boolean canRead, boolean canWrite,
            boolean checkExists) throws Exception {
        if (checkExists) {
            assertThat(file.exists()).isEqualTo(exists);
        }
        assertThat(file.canRead()).isEqualTo(canRead);
        assertThat(file.canWrite()).isEqualTo(canWrite);
        if (file.isDirectory()) {
            if (checkExists) {
                assertThat(file.canExecute()).isEqualTo(exists);
            }
        } else {
            assertThat(file.canExecute()).isFalse(); // Filesytem is mounted with MS_NOEXEC
        }

        // Test some combinations of mask.
        assertAccess(file, R_OK, canRead);
        assertAccess(file, W_OK, canWrite);
        assertAccess(file, R_OK | W_OK, canRead && canWrite);
        assertAccess(file, W_OK | F_OK, canWrite);

        if (checkExists) {
            assertAccess(file, F_OK, exists);
        }
    }

    private static void assertAccess(File file, int mask, boolean expected) throws Exception {
        if (expected) {
            assertThat(Os.access(file.getAbsolutePath(), mask)).isTrue();
        } else {
            assertThrows(ErrnoException.class, () -> { Os.access(file.getAbsolutePath(), mask); });
        }
    }

    /**
     * Creates a file at any location on storage (except external app data directory).
     * The owner of the file is not the caller app.
     */
    private void createFileAsLegacyApp(File file) throws Exception {
        // Use a legacy app to create this file, since it could be outside shared storage.
        Log.d(TAG, ""Creating file "" + file);
        assertThat(createFileAs(APP_D_LEGACY_HAS_RW, file.getAbsolutePath())).isTrue();
    }

    /**
     * Creates a file at any location on storage (except external app data directory).
     * The owner of the file is not the caller app.
     */
    private void createDirectoryAsLegacyApp(File file) throws Exception {
        // Use a legacy app to create this file, since it could be outside shared storage.
        Log.d(TAG, ""Creating directory "" + file);
        // Create a tmp file in the target directory, this would also create the required
        // directory, then delete the tmp file. It would leave only new directory.
        assertThat(createFileAs(APP_D_LEGACY_HAS_RW, file.getAbsolutePath() + ""/tmp.txt"")).isTrue();
        assertThat(deleteFileAs(APP_D_LEGACY_HAS_RW, file.getAbsolutePath() + ""/tmp.txt"")).isTrue();
    }

    /**
     * Deletes a file at any location on storage (except external app data directory).
     */
    private void deleteAsLegacyApp(File file) throws Exception {
        // Use a legacy app to delete this file, since it could be outside shared storage.
        Log.d(TAG, ""Deleting file "" + file);
        deleteFileAs(APP_D_LEGACY_HAS_RW, file.getAbsolutePath());
    }

    private int getCurrentUser() throws Exception {
        String userId = executeShellCommand(""am get-current-user"");
        return Integer.parseInt(userId.trim());
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.scopedstorage.cts.device.RedactUriDeviceTest"	"testRedactedUri_single"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/device/src/android/scopedstorage/cts/device/RedactUriDeviceTest.java"	""	"public void testRedactedUri_single() throws Exception {
        final File img = stageImageFileWithMetadata(IMAGE_FILE_NAME);

        try {
            final Uri uri = MediaStore.scanFile(getContentResolver(), img);
            final Uri redactedUri = MediaStore.getRedactedUri(getContentResolver(), uri);
            testRedactedUriCommon(uri, redactedUri);
        } finally {
            img.delete();
        }
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.scopedstorage.cts.device.RedactUriDeviceTest"	"testRedactedUri_list"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/device/src/android/scopedstorage/cts/device/RedactUriDeviceTest.java"	""	"public void testRedactedUri_list() throws Exception {
        List<Uri> uris = new ArrayList<>();
        List<File> files = new ArrayList<>();

        try {
            for (int i = 0; i < 10; i++) {
                File file = stageImageFileWithMetadata(""img_metadata"" + String.valueOf(
                        System.nanoTime()) + i + "".jpg"");
                files.add(file);
                uris.add(MediaStore.scanFile(getContentResolver(), file));
            }

            final Collection<Uri> redactedUris = MediaStore.getRedactedUri(getContentResolver(),
                    uris);
            int i = 0;
            for (Uri redactedUri : redactedUris) {
                Uri uri = uris.get(i++);
                testRedactedUriCommon(uri, redactedUri);
            }
        } finally {
            files.forEach(file -> file.delete());
        }
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.scopedstorage.cts.device.RedactUriDeviceTest"	"testQueryOnRedactionUri"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/device/src/android/scopedstorage/cts/device/RedactUriDeviceTest.java"	""	"public void testQueryOnRedactionUri() throws Exception {
        final File img = stageImageFileWithMetadata(IMAGE_FILE_NAME);
        final Uri uri = MediaStore.scanFile(getContentResolver(), img);
        final Uri redactedUri = MediaStore.getRedactedUri(getContentResolver(), uri);
        final Cursor uriCursor = getContentResolver().query(uri, null, null, null);
        final String redactedUriDir = "".transforms/synthetic/redacted"";
        final String redactedUriDirAbsolutePath =
                Environment.getExternalStorageDirectory() + ""/"" + redactedUriDir;
        try {
            assertNotNull(uriCursor);
            assertThat(uriCursor.moveToFirst()).isTrue();

            final Cursor redactedUriCursor = getContentResolver().query(redactedUri, null, null,
                    null);
            assertNotNull(redactedUriCursor);
            assertThat(redactedUriCursor.moveToFirst()).isTrue();

            assertEquals(redactedUriCursor.getColumnCount(), uriCursor.getColumnCount());

            final String data = getStringFromCursor(redactedUriCursor,
                    MediaStore.MediaColumns.DATA);
            final String redactedUriDisplayName = redactedUri.getLastPathSegment() + "".jpg"";
            assertEquals(redactedUriDirAbsolutePath + ""/"" + redactedUriDisplayName, data);

            final String name = getStringFromCursor(redactedUriCursor,
                    MediaStore.MediaColumns.DISPLAY_NAME);
            assertEquals(redactedUriDisplayName, name);

            final String relativePath = getStringFromCursor(redactedUriCursor,
                    MediaStore.MediaColumns.RELATIVE_PATH);
            assertEquals(redactedUriDir, relativePath);

            final String bucketDisplayName = getStringFromCursor(redactedUriCursor,
                    MediaStore.MediaColumns.BUCKET_DISPLAY_NAME);
            assertEquals(redactedUriDir, bucketDisplayName);

            final String docId = getStringFromCursor(redactedUriCursor,
                    MediaStore.MediaColumns.DOCUMENT_ID);
            assertNull(docId);

            final String insId = getStringFromCursor(redactedUriCursor,
                    MediaStore.MediaColumns.INSTANCE_ID);
            assertNull(insId);

            final String bucId = getStringFromCursor(redactedUriCursor,
                    MediaStore.MediaColumns.BUCKET_ID);
            assertNull(bucId);

            final Collection<String> updatedCols = Arrays.asList(MediaStore.MediaColumns._ID,
                    MediaStore.MediaColumns.DISPLAY_NAME,
                    MediaStore.MediaColumns.RELATIVE_PATH,
                    MediaStore.MediaColumns.BUCKET_DISPLAY_NAME,
                    MediaStore.MediaColumns.DATA,
                    MediaStore.MediaColumns.DOCUMENT_ID,
                    MediaStore.MediaColumns.INSTANCE_ID,
                    MediaStore.MediaColumns.BUCKET_ID);
            for (String colName : uriCursor.getColumnNames()) {
                if (!updatedCols.contains(colName)) {
                    if (uriCursor.getType(uriCursor.getColumnIndex(colName)) == FIELD_TYPE_BLOB) {
                        assertThat(
                                Arrays.equals(uriCursor.getBlob(uriCursor.getColumnIndex(colName)),
                                        redactedUriCursor.getBlob(redactedUriCursor.getColumnIndex(
                                                colName)))).isTrue();
                    } else {
                        assertEquals(getStringFromCursor(uriCursor, colName),
                                getStringFromCursor(redactedUriCursor, colName));
                    }
                }
            }
        } finally {
            img.delete();
        }
    }

    /*
     * Verify that app can't open the shared redacted URI for write.
     **/"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.scopedstorage.cts.device.RedactUriDeviceTest"	"testOpenOnRedactedUri_read"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/device/src/android/scopedstorage/cts/device/RedactUriDeviceTest.java"	""	"public void testOpenOnRedactedUri_read() throws Exception {
        final File img = stageImageFileWithMetadata(IMAGE_FILE_NAME);
        final Uri redactedUri = getRedactedUri(img);
        try {
            assertUriIsUnredacted(img);

            FileDescriptor fd = getContentResolver().openFileDescriptor(redactedUri,
                    ""r"").getFileDescriptor();
            ExifInterface redactedExifInf = new ExifInterface(fd);
            assertUriIsRedacted(redactedExifInf);
        } finally {
            img.delete();
        }
    }

    private void testRedactedUriCommon(Uri uri, Uri redactedUri) {
        assertEquals(redactedUri.getAuthority(), uri.getAuthority());
        assertEquals(redactedUri.getScheme(), uri.getScheme());
        assertNotEquals(redactedUri.getPath(), uri.getPath());
        assertNotEquals(redactedUri.getPathSegments(), uri.getPathSegments());

        final String uriId = redactedUri.getLastPathSegment();
        assertThat(uriId.startsWith(""RUID"")).isTrue();
        assertEquals(uriId.length(), 36);
    }

    private Uri shareAndGetRedactedUri(File file, TestApp testApp) {
        final Uri redactedUri = getRedactedUri(file);
        getContext().grantUriPermission(testApp.getPackageName(), redactedUri,
                FLAG_GRANT_READ_URI_PERMISSION);

        return redactedUri;
    }

    private Uri getRedactedUri(File file) {
        final Uri uri = MediaStore.scanFile(getContentResolver(), file);
        return MediaStore.getRedactedUri(getContentResolver(), uri);
    }

    private void assertUriIsUnredacted(File img) throws Exception {
        final ExifInterface exifInterface = new ExifInterface(img);
        assertNotEquals(exifInterface.getGpsDateTime(), -1);

        float[] latLong = new float[]{0, 0};
        exifInterface.getLatLong(latLong);
        assertNotEquals(latLong[0], 0);
        assertNotEquals(latLong[1], 0);
    }

    private void assertUriIsRedacted(ExifInterface redactedExifInf) {
        assertEquals(redactedExifInf.getGpsDateTime(), -1);
        float[] latLong = new float[]{0, 0};
        redactedExifInf.getLatLong(latLong);
        assertEquals(latLong[0], 0.0, 0.0);
        assertEquals(latLong[1], 0.0, 0.0);
    }

    private Cursor getRedactedCursor(Uri redactedUri) {
        Cursor redactedUriCursor = getContentResolver().query(redactedUri, null, null, null);
        assertNotNull(redactedUriCursor);
        assertThat(redactedUriCursor.moveToFirst()).isTrue();

        return redactedUriCursor;
    }

    private String getStringFromCursor(Cursor c, String colName) {
        return c.getString(c.getColumnIndex(colName));
    }

    private File stageImageFileWithMetadata(String name) throws Exception {
        final File img = new File(
                Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DCIM), name);

        try (InputStream in =
                     getContext().getResources().openRawResource(R.raw.img_with_metadata);
             OutputStream out = new FileOutputStream(img)) {
            // Dump the image we have to external storage
            FileUtils.copy(in, out);
        }

        return img;
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.tests.stagedinstall.host.StagedInstallTest"	"testApexTargetingOldDevSdkFailsVerification"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/stagedinstall/src/com/android/tests/stagedinstall/host/StagedInstallTest.java"	""	"public void testApexTargetingOldDevSdkFailsVerification() throws Exception {
        assumeTrue(""Device does not support updating APEX"", mHostUtils.isApexUpdateSupported());

        runPhase(""testApexTargetingOldDevSdkFailsVerification"");
    }

    /**
     * Apex should fail to install if apk-in-apex fails to get scanned
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.tests.stagedinstall.host.StagedInstallTest"	"testApexFailsToInstallIfApkInApexFailsToScan"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/stagedinstall/src/com/android/tests/stagedinstall/host/StagedInstallTest.java"	""	"@LargeTest
    public void testApexFailsToInstallIfApkInApexFailsToScan() throws Exception {
        assumeTrue(""Device does not support updating APEX"", mHostUtils.isApexUpdateSupported());

        runPhase(""testApexFailsToInstallIfApkInApexFailsToScan_Commit"");
        getDevice().reboot();
        runPhase(""testApexFailsToInstallIfApkInApexFailsToScan_VerifyPostReboot"");
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.net.wifi.nl80211.cts.DeviceWiphyCapabilitiesTest"	"isTrue"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/nl80211/cts/DeviceWiphyCapabilitiesTest.java"	""	"public void canSerializeAndDeserialize() {
        DeviceWiphyCapabilities capa = new DeviceWiphyCapabilities();

        capa.setWifiStandardSupport(ScanResult.WIFI_STANDARD_11N, true);
        capa.setWifiStandardSupport(ScanResult.WIFI_STANDARD_11AC, true);
        capa.setWifiStandardSupport(ScanResult.WIFI_STANDARD_11AX, false);

        Parcel parcel = Parcel.obtain();
        capa.writeToParcel(parcel, 0);
        // Rewind the pointer to the head of the parcel.
        parcel.setDataPosition(0);
        DeviceWiphyCapabilities capaDeserialized =
                DeviceWiphyCapabilities.CREATOR.createFromParcel(parcel);

        assertThat(capaDeserialized.isWifiStandardSupported(ScanResult.WIFI_STANDARD_11N)).isTrue();
        assertThat(capaDeserialized.isWifiStandardSupported(ScanResult.WIFI_STANDARD_11AC))
                .isTrue();
        assertThat(capaDeserialized.isWifiStandardSupported(ScanResult.WIFI_STANDARD_11AX))
                .isFalse();
        assertThat(capaDeserialized).isEqualTo(capa);
        assertThat(capaDeserialized.hashCode()).isEqualTo(capa.hashCode());
    }

    /** Test mapping wifi standard support into channel width support */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.net.wifi.nl80211.cts.DeviceWiphyCapabilitiesTest"	"testMappingWifiStandardIntoChannelWidthSupport"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/nl80211/cts/DeviceWiphyCapabilitiesTest.java"	""	"public void testMappingWifiStandardIntoChannelWidthSupport() {
        DeviceWiphyCapabilities capa = new DeviceWiphyCapabilities();

        capa.setWifiStandardSupport(ScanResult.WIFI_STANDARD_11N, false);
        capa.setWifiStandardSupport(ScanResult.WIFI_STANDARD_11AC, false);
        capa.setWifiStandardSupport(ScanResult.WIFI_STANDARD_11AX, false);
        assertThat(capa.isChannelWidthSupported(ScanResult.CHANNEL_WIDTH_20MHZ)).isTrue();
        assertThat(capa.isChannelWidthSupported(ScanResult.CHANNEL_WIDTH_40MHZ)).isFalse();
        assertThat(capa.isChannelWidthSupported(ScanResult.CHANNEL_WIDTH_80MHZ)).isFalse();

        capa.setWifiStandardSupport(ScanResult.WIFI_STANDARD_11N, true);
        assertThat(capa.isChannelWidthSupported(ScanResult.CHANNEL_WIDTH_20MHZ)).isTrue();
        assertThat(capa.isChannelWidthSupported(ScanResult.CHANNEL_WIDTH_40MHZ)).isTrue();
        assertThat(capa.isChannelWidthSupported(ScanResult.CHANNEL_WIDTH_80MHZ)).isFalse();

        capa.setWifiStandardSupport(ScanResult.WIFI_STANDARD_11AC, true);
        assertThat(capa.isChannelWidthSupported(ScanResult.CHANNEL_WIDTH_20MHZ)).isTrue();
        assertThat(capa.isChannelWidthSupported(ScanResult.CHANNEL_WIDTH_40MHZ)).isTrue();
        assertThat(capa.isChannelWidthSupported(ScanResult.CHANNEL_WIDTH_80MHZ)).isTrue();
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.cpptools.RunasPermissionsTest"	"testRunasCanConnectToAppsSocket"	"CtsCppToolsTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/cpptools/src/com/android/cts/cpptools/RunasPermissionsTest.java"	""	"public void testRunasCanConnectToAppsSocket() throws Exception {
        // Start the app activity and wait for it to complete.
        // The app will open a domain socket.
        getDevice().executeShellCommand(START_TEST_APP_COMMAND);

        // Sleep for 0.3 second (300 milliseconds) so the test app has sufficient time
        // to open the socket.
        try {
            Thread.sleep(300);
        } catch (InterruptedException e) {
            // ignored
        }

        // Start a run-as process that attempts to connect to the socket opened by the
        // app.
        int currentUser = getDevice().getCurrentUser();
        getDevice().executeShellCommand(String.format(
                ""run-as %s --user %d sh -c 'cp -f /data/local/tmp/%s ./code_cache/'"",
                        TEST_APP_PACKAGE, currentUser, CONNECTOR_EXE_NAME));
        String results = getDevice().executeShellCommand(String.format(
                ""run-as %s --user %d sh -c './code_cache/%s'"",
                        TEST_APP_PACKAGE, currentUser, CONNECTOR_EXE_NAME));
        assertEquals(EXPECTED_CONNECTOR_OUTPUT, results);
    }

}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.bluetooth.cts.ScanResultTest"	"testScanResultParceling"	"CtsBluetoothTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/bluetooth/src/android/bluetooth/cts/ScanResultTest.java"	""	"public void testScanResultParceling() {
        if (! mContext.getPackageManager().
                  hasSystemFeature(PackageManager.FEATURE_BLUETOOTH)) return;

        BluetoothDevice device =
                BluetoothAdapter.getDefaultAdapter().getRemoteDevice(DEVICE_ADDRESS);
        ScanResult result = new ScanResult(device, TestUtils.parseScanRecord(SCAN_RECORD), RSSI,
                TIMESTAMP_NANOS);
        Parcel parcel = Parcel.obtain();
        result.writeToParcel(parcel, 0);
        // Need to reset parcel data position to the beginning.
        parcel.setDataPosition(0);
        ScanResult resultFromParcel = ScanResult.CREATOR.createFromParcel(parcel);

        assertEquals(RSSI, resultFromParcel.getRssi());
        assertEquals(TIMESTAMP_NANOS, resultFromParcel.getTimestampNanos());
        assertEquals(device, resultFromParcel.getDevice());
        TestUtils.assertArrayEquals(SCAN_RECORD, resultFromParcel.getScanRecord().getBytes());
    }

    @SmallTest"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.bluetooth.cts.ScanResultTest"	"testDescribeContents"	"CtsBluetoothTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/bluetooth/src/android/bluetooth/cts/ScanResultTest.java"	""	"public void testDescribeContents() {
        if (! mContext.getPackageManager().
                  hasSystemFeature(PackageManager.FEATURE_BLUETOOTH)) return;

        BluetoothDevice device =
                BluetoothAdapter.getDefaultAdapter().getRemoteDevice(DEVICE_ADDRESS);
        ScanResult result = new ScanResult(device, TestUtils.parseScanRecord(SCAN_RECORD), RSSI,
                TIMESTAMP_NANOS);
        assertEquals(0, result.describeContents());
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.provider.cts.media.MediaStore_Video_MediaTest"	"testCanonicalize"	"CtsProviderTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/provider/src/android/provider/cts/media/MediaStore_Video_MediaTest.java"	""	"public void testCanonicalize() throws Exception {
        // Remove all audio left over from other tests
        ProviderTestUtils.executeShellCommand(""content delete""
                + "" --user "" + InstrumentationRegistry.getTargetContext().getUserId()
                + "" --uri "" + mExternalVideo,
                InstrumentationRegistry.getInstrumentation().getUiAutomation());

        // Publish some content
        final File dir = ProviderTestUtils.stageDir(mVolumeName);
        final Uri a = ProviderTestUtils.scanFileFromShell(
                ProviderTestUtils.stageFile(R.raw.testvideo, new File(dir, ""a.mp4"")));
        final Uri b = ProviderTestUtils.scanFileFromShell(
                ProviderTestUtils.stageFile(R.raw.testvideo_meta, new File(dir, ""b.mp4"")));
        final Uri c = ProviderTestUtils.scanFileFromShell(
                ProviderTestUtils.stageFile(R.raw.testvideo, new File(dir, ""c.mp4"")));

        // Confirm we can canonicalize and recover it
        final Uri canonicalized = mContentResolver.canonicalize(b);
        assertNotNull(canonicalized);
        assertEquals(b, mContentResolver.uncanonicalize(canonicalized));

        // Delete all items above
        mContentResolver.delete(a, null, null);
        mContentResolver.delete(b, null, null);
        mContentResolver.delete(c, null, null);

        // Confirm canonical item isn't found
        assertNull(mContentResolver.uncanonicalize(canonicalized));

        // Publish data again and confirm we can recover it
        final Uri d = ProviderTestUtils.scanFileFromShell(
                ProviderTestUtils.stageFile(R.raw.testvideo_meta, new File(dir, ""d.mp4"")));
        assertEquals(d, mContentResolver.uncanonicalize(canonicalized));
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.content.pm.cts.PackageManagerShellCommandIncrementalTest"	"testInstallWithIdSigNoMissingPages"	"CtsContentTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/PackageManagerShellCommandIncrementalTest.java"	""	"public void testInstallWithIdSigNoMissingPages() throws Exception {
        final int installIterations = 1;
        final int atraceDumpIterations = 3;
        final int atraceDumpDelayMs = 1000;
        final String missingPageReads = ""|missing_page_reads: count="";

        final ArrayList<String> missingPages = new ArrayList<>();

        checkSysTrace(
                installIterations,
                atraceDumpIterations,
                atraceDumpDelayMs,
                () -> {
                    // Install multiple splits so that digesters won't kick in.
                    installPackage(TEST_APK);
                    installSplit(TEST_APK_SPLIT0);
                    installSplit(TEST_APK_SPLIT1);
                    installSplit(TEST_APK_SPLIT2);
                    // Now read it as fast as we can.
                    readSplitInChunks(""base.apk"");
                    readSplitInChunks(""split_config.mdpi.apk"");
                    readSplitInChunks(""split_config.hdpi.apk"");
                    readSplitInChunks(""split_config.xhdpi.apk"");
                    return null;
                },
                (stdout) -> {
                    try (Scanner scanner = new Scanner(stdout)) {
                        ReadLogEntry prevLogEntry = null;
                        while (scanner.hasNextLine()) {
                            final String line = scanner.nextLine();

                            final ReadLogEntry readLogEntry = ReadLogEntry.parse(line);
                            if (readLogEntry != null) {
                                prevLogEntry = readLogEntry;
                                continue;
                            }

                            int missingPageIdx = line.indexOf(missingPageReads);
                            if (missingPageIdx == -1) {
                                continue;
                            }
                            String missingBlocks = line.substring(
                                    missingPageIdx + missingPageReads.length());

                            int prvTimestamp = prevLogEntry != null ? extractTimestamp(
                                    prevLogEntry.line) : -1;
                            int curTimestamp = extractTimestamp(line);
                            if (prvTimestamp == -1 || curTimestamp == -1) {
                                missingPages.add(""count="" + missingBlocks);
                                continue;
                            }

                            int delta = curTimestamp - prvTimestamp;
                            missingPages.add(
                                    ""count="" + missingBlocks + "", timestamp delta="" + delta + ""ms"");
                        }
                        return false;
                    }
                });

        assertTrue(""Missing page reads found in atrace dump: "" + String.join(""\n"", missingPages),
                missingPages.isEmpty());
    }

    static class ReadLogEntry {
        public final String line;
        public final int blockIdx;
        public final int count;
        public final int fileIdx;
        public final int appId;
        public final int userId;

        private ReadLogEntry(String line, int blockIdx, int count, int fileIdx, int appId,
                int userId) {
            this.line = line;
            this.blockIdx = blockIdx;
            this.count = count;
            this.fileIdx = fileIdx;
            this.appId = appId;
            this.userId = userId;
        }

        public String toString() {
            return blockIdx + ""/"" + count + ""/"" + fileIdx + ""/"" + appId + ""/"" + userId;
        }

        static final String BLOCK_PREFIX = ""|page_read: index="";
        static final String COUNT_PREFIX = "" count="";
        static final String FILE_PREFIX = "" file="";
        static final String APP_ID_PREFIX = "" appid="";
        static final String USER_ID_PREFIX = "" userid="";

        private static int parseInt(String line, int prefixIdx, int prefixLen, int endIdx) {
            if (prefixIdx == -1) {
                return -1;
            }
            final String intStr;
            if (endIdx != -1) {
                intStr = line.substring(prefixIdx + prefixLen, endIdx);
            } else {
                intStr = line.substring(prefixIdx + prefixLen);
            }

            return Integer.parseInt(intStr);
        }

        static ReadLogEntry parse(String line) {
            int blockIdx = line.indexOf(BLOCK_PREFIX);
            if (blockIdx == -1) {
                return null;
            }
            int countIdx = line.indexOf(COUNT_PREFIX, blockIdx + BLOCK_PREFIX.length());
            if (countIdx == -1) {
                return null;
            }
            int fileIdx = line.indexOf(FILE_PREFIX, countIdx + COUNT_PREFIX.length());
            if (fileIdx == -1) {
                return null;
            }
            int appIdIdx = line.indexOf(APP_ID_PREFIX, fileIdx + FILE_PREFIX.length());
            final int userIdIdx;
            if (appIdIdx != -1) {
                userIdIdx = line.indexOf(USER_ID_PREFIX, appIdIdx + APP_ID_PREFIX.length());
            } else {
                userIdIdx = -1;
            }

            return new ReadLogEntry(
                    line,
                    parseInt(line, blockIdx, BLOCK_PREFIX.length(), countIdx),
                    parseInt(line, countIdx, COUNT_PREFIX.length(), fileIdx),
                    parseInt(line, fileIdx, FILE_PREFIX.length(), appIdIdx),
                    parseInt(line, appIdIdx, APP_ID_PREFIX.length(), userIdIdx),
                    parseInt(line, userIdIdx, USER_ID_PREFIX.length(), -1));
        }
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.ConnectedNetworkScorerTest"	"isNotNull"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ConnectedNetworkScorerTest.java"	""	"/*
 *.
 */

package android.net.wifi.cts;

import static android.Manifest.permission.CONNECTIVITY_INTERNAL;
import static android.Manifest.permission.NETWORK_SETTINGS;
import static android.Manifest.permission.READ_WIFI_CREDENTIAL;
import static android.Manifest.permission.WIFI_UPDATE_USABILITY_STATS_SCORE;
import static android.net.NetworkCapabilities.NET_CAPABILITY_OEM_PAID;
import static android.net.NetworkCapabilities.NET_CAPABILITY_OEM_PRIVATE;
import static android.net.wifi.WifiUsabilityStatsEntry.ContentionTimeStats;
import static android.net.wifi.WifiUsabilityStatsEntry.RadioStats;
import static android.net.wifi.WifiUsabilityStatsEntry.RateStats;
import static android.net.wifi.WifiUsabilityStatsEntry.PROBE_STATUS_FAILURE;
import static android.net.wifi.WifiUsabilityStatsEntry.PROBE_STATUS_NO_PROBE;
import static android.net.wifi.WifiUsabilityStatsEntry.PROBE_STATUS_SUCCESS;
import static android.net.wifi.WifiUsabilityStatsEntry.PROBE_STATUS_UNKNOWN;
import static android.net.wifi.WifiUsabilityStatsEntry.WME_ACCESS_CATEGORY_BE;
import static android.net.wifi.WifiUsabilityStatsEntry.WME_ACCESS_CATEGORY_BK;
import static android.net.wifi.WifiUsabilityStatsEntry.WME_ACCESS_CATEGORY_VI;
import static android.net.wifi.WifiUsabilityStatsEntry.WME_ACCESS_CATEGORY_VO;
import static android.os.Process.myUid;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.junit.Assume.assumeTrue;

import android.annotation.NonNull;
import android.app.UiAutomation;
import android.content.Context;
import android.net.ConnectivityManager;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiManager;
import android.net.wifi.WifiNetworkSpecifier;
import android.net.wifi.WifiNetworkSuggestion;
import android.net.wifi.WifiUsabilityStatsEntry;
import android.net.wifi.WifiConnectedSessionInfo;
import android.os.Build;
import android.platform.test.annotations.AppModeFull;
import android.support.test.uiautomator.UiDevice;
import android.telephony.TelephonyManager;

import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.filters.LargeTest;
import androidx.test.filters.SdkSuppress;
import androidx.test.platform.app.InstrumentationRegistry;

import com.android.compatibility.common.util.ApiLevelUtil;
import com.android.compatibility.common.util.PollingCheck;
import com.android.compatibility.common.util.PropertyUtil;
import com.android.compatibility.common.util.ShellIdentityUtils;

import com.google.common.collect.Range;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.List;
import java.util.NoSuchElementException;
import java.util.Set;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

/**
 * Tests for wifi connected network scorer interface and usability stats.
 */
@AppModeFull(reason = ""Cannot get WifiManager in instant app mode"")
@LargeTest
@RunWith(AndroidJUnit4.class)
public class ConnectedNetworkScorerTest extends WifiJUnit4TestBase {
    private Context mContext;
    private WifiManager mWifiManager;
    private ConnectivityManager mConnectivityManager;
    private UiDevice mUiDevice;
    private TestHelper mTestHelper;
    private TelephonyManager mTelephonyManager;

    private boolean mWasVerboseLoggingEnabled;

    private static final int WIFI_CONNECT_TIMEOUT_MILLIS = 30_000;
    private static final int TIMEOUT = 12_000;
    private static final int WAIT_DURATION = 5_000;

    @Before
    public void setUp() throws Exception {
        mContext = InstrumentationRegistry.getInstrumentation().getContext();

        // skip the test if WiFi is not supported
        assumeTrue(WifiFeature.isWifiSupported(mContext));

        mWifiManager = mContext.getSystemService(WifiManager.class);
        assertThat(mWifiManager).isNotNull();

        mConnectivityManager = mContext.getSystemService(ConnectivityManager.class);

        // turn on verbose logging for tests
        mWasVerboseLoggingEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.isVerboseLoggingEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setVerboseLoggingEnabled(true));

        // enable Wifi
        if (!mWifiManager.isWifiEnabled()) {
            ShellIdentityUtils.invokeWithShellPermissions(() -> mWifiManager.setWifiEnabled(true));
        }
        PollingCheck.check(""Wifi not enabled"", TIMEOUT, () -> mWifiManager.isWifiEnabled());

        // turn screen on
        mUiDevice = UiDevice.getInstance(InstrumentationRegistry.getInstrumentation());

        mTestHelper = new TestHelper(mContext, mUiDevice);
        mTestHelper.turnScreenOn();

        // Clear any existing app state before each test.
        if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(mContext)) {
            ShellIdentityUtils.invokeWithShellPermissions(
                    () -> mWifiManager.removeAppState(myUid(), mContext.getPackageName()));
        }

        // check we have >= 1 saved network
        List<WifiConfiguration> savedNetworks = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.getConfiguredNetworks());
        assertWithMessage(""Need at least one saved network"").that(savedNetworks).isNotEmpty();

        // ensure Wifi is connected
        ShellIdentityUtils.invokeWithShellPermissions(() -> mWifiManager.reconnect());
        PollingCheck.check(
                ""Wifi not connected"",
                WIFI_CONNECT_TIMEOUT_MILLIS,
                () -> mWifiManager.getConnectionInfo().getNetworkId() != -1);
        mTelephonyManager = mContext.getSystemService(TelephonyManager.class);
    }

    @After
    public void tearDown() throws Exception {
        if (!WifiFeature.isWifiSupported(mContext)) return;
        if (!mWifiManager.isWifiEnabled()) {
            ShellIdentityUtils.invokeWithShellPermissions(() -> mWifiManager.setWifiEnabled(true));
        }
        mTestHelper.turnScreenOff();
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setVerboseLoggingEnabled(mWasVerboseLoggingEnabled));
    }

    private static class TestUsabilityStatsListener implements
            WifiManager.OnWifiUsabilityStatsListener {
        private final CountDownLatch mCountDownLatch;
        public int seqNum;
        public boolean isSameBssidAndFre;
        public WifiUsabilityStatsEntry statsEntry;

        TestUsabilityStatsListener(CountDownLatch countDownLatch) {
            mCountDownLatch = countDownLatch;
        }

        @Override
        public void onWifiUsabilityStats(int seqNum, boolean isSameBssidAndFreq,
                WifiUsabilityStatsEntry statsEntry) {
            this.seqNum = seqNum;
            this.isSameBssidAndFre = isSameBssidAndFreq;
            this.statsEntry = statsEntry;
            mCountDownLatch.countDown();
        }
    }

    /**
     * Tests the {@link android.net.wifi.WifiUsabilityStatsEntry} retrieved from
     * {@link WifiManager.OnWifiUsabilityStatsListener}.
     */"	""	""	"probe"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	Test Available	""	"probe scan"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.ConnectedNetworkScorerTest"	"testWifiUsabilityStatsEntry"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ConnectedNetworkScorerTest.java"	""	"public void testWifiUsabilityStatsEntry() throws Exception {
        // Usability stats collection only supported by vendor version Q and above.
        if (!PropertyUtil.isVendorApiLevelAtLeast(Build.VERSION_CODES.Q)) {
            return;
        }
        CountDownLatch countDownLatch = new CountDownLatch(1);
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        TestUsabilityStatsListener usabilityStatsListener =
                new TestUsabilityStatsListener(countDownLatch);
        try {
            uiAutomation.adoptShellPermissionIdentity();
            mWifiManager.addOnWifiUsabilityStatsListener(
                    Executors.newSingleThreadExecutor(), usabilityStatsListener);
            // Wait for new usability stats (while connected & screen on this is triggered
            // by platform periodically).
            assertThat(countDownLatch.await(TIMEOUT, TimeUnit.MILLISECONDS)).isTrue();

            assertThat(usabilityStatsListener.statsEntry).isNotNull();
            WifiUsabilityStatsEntry statsEntry = usabilityStatsListener.statsEntry;

            assertThat(statsEntry.getTimeStampMillis()).isGreaterThan(0L);
            assertThat(statsEntry.getRssi()).isLessThan(0);
            assertThat(statsEntry.getLinkSpeedMbps()).isAtLeast(0);
            assertThat(statsEntry.getTotalTxSuccess()).isAtLeast(0L);
            assertThat(statsEntry.getTotalTxRetries()).isAtLeast(0L);
            assertThat(statsEntry.getTotalTxBad()).isAtLeast(0L);
            assertThat(statsEntry.getTotalRxSuccess()).isAtLeast(0L);
            if (mWifiManager.isEnhancedPowerReportingSupported()) {
                assertThat(statsEntry.getTotalRadioOnTimeMillis()).isAtLeast(0L);
                assertThat(statsEntry.getTotalRadioTxTimeMillis()).isAtLeast(0L);
                assertThat(statsEntry.getTotalRadioRxTimeMillis()).isAtLeast(0L);
                assertThat(statsEntry.getTotalScanTimeMillis()).isAtLeast(0L);
                assertThat(statsEntry.getTotalNanScanTimeMillis()).isAtLeast(0L);
                assertThat(statsEntry.getTotalBackgroundScanTimeMillis()).isAtLeast(0L);
                assertThat(statsEntry.getTotalRoamScanTimeMillis()).isAtLeast(0L);
                assertThat(statsEntry.getTotalPnoScanTimeMillis()).isAtLeast(0L);
                assertThat(statsEntry.getTotalHotspot2ScanTimeMillis()).isAtLeast(0L);
                assertThat(statsEntry.getTotalCcaBusyFreqTimeMillis()).isAtLeast(0L);
                assertThat(statsEntry.getTotalRadioOnTimeMillis()).isAtLeast(0L);
                assertThat(statsEntry.getTotalRadioOnFreqTimeMillis()).isAtLeast(0L);
                assertThat(statsEntry.getTotalBeaconRx()).isAtLeast(0L);
                assertThat(statsEntry.getProbeStatusSinceLastUpdate())
                        .isAnyOf(PROBE_STATUS_SUCCESS,
                                PROBE_STATUS_FAILURE,
                                PROBE_STATUS_NO_PROBE,
                                PROBE_STATUS_UNKNOWN);
                // -1 is default value for some of these fields if they're not available.
                assertThat(statsEntry.getProbeElapsedTimeSinceLastUpdateMillis()).isAtLeast(-1);
                assertThat(statsEntry.getProbeMcsRateSinceLastUpdate()).isAtLeast(-1);
                assertThat(statsEntry.getRxLinkSpeedMbps()).isAtLeast(-1);
                if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
                    try {
                        assertThat(statsEntry.getTimeSliceDutyCycleInPercent())
                                .isIn(Range.closed(0, 100));
                    } catch (NoSuchElementException e) {
                        // pass - Device does not support the field.
                    }
                    assertThat(statsEntry.getContentionTimeStats(
                            WME_ACCESS_CATEGORY_BE).getContentionTimeMinMicros()).isAtLeast(0);
                    assertThat(statsEntry.getContentionTimeStats(
                            WME_ACCESS_CATEGORY_BE).getContentionTimeMaxMicros()).isAtLeast(0);
                    assertThat(statsEntry.getContentionTimeStats(
                            WME_ACCESS_CATEGORY_BE).getContentionTimeAvgMicros()).isAtLeast(0);
                    assertThat(statsEntry.getContentionTimeStats(
                            WME_ACCESS_CATEGORY_BE).getContentionNumSamples()).isAtLeast(0);
                    assertThat(statsEntry.getContentionTimeStats(
                            WME_ACCESS_CATEGORY_BK).getContentionTimeMinMicros()).isAtLeast(0);
                    assertThat(statsEntry.getContentionTimeStats(
                            WME_ACCESS_CATEGORY_BK).getContentionTimeMaxMicros()).isAtLeast(0);
                    assertThat(statsEntry.getContentionTimeStats(
                            WME_ACCESS_CATEGORY_BK).getContentionTimeAvgMicros()).isAtLeast(0);
                    assertThat(statsEntry.getContentionTimeStats(
                            WME_ACCESS_CATEGORY_BK).getContentionNumSamples()).isAtLeast(0);
                    assertThat(statsEntry.getContentionTimeStats(
                            WME_ACCESS_CATEGORY_VI).getContentionTimeMinMicros()).isAtLeast(0);
                    assertThat(statsEntry.getContentionTimeStats(
                            WME_ACCESS_CATEGORY_VI).getContentionTimeMaxMicros()).isAtLeast(0);
                    assertThat(statsEntry.getContentionTimeStats(
                            WME_ACCESS_CATEGORY_VI).getContentionTimeAvgMicros()).isAtLeast(0);
                    assertThat(statsEntry.getContentionTimeStats(
                            WME_ACCESS_CATEGORY_VI).getContentionNumSamples()).isAtLeast(0);
                    assertThat(statsEntry.getContentionTimeStats(
                            WME_ACCESS_CATEGORY_VO).getContentionTimeMinMicros()).isAtLeast(0);
                    assertThat(statsEntry.getContentionTimeStats(
                            WME_ACCESS_CATEGORY_VO).getContentionTimeMaxMicros()).isAtLeast(0);
                    assertThat(statsEntry.getContentionTimeStats(
                            WME_ACCESS_CATEGORY_VO).getContentionTimeAvgMicros()).isAtLeast(0);
                    assertThat(statsEntry.getContentionTimeStats(
                            WME_ACCESS_CATEGORY_VO).getContentionNumSamples()).isAtLeast(0);
                    // This is to add CTS test for the constructor function.
                    ContentionTimeStats contentionStats = new ContentionTimeStats(2, 1, 4, 10);
                    assertEquals(2, contentionStats.getContentionTimeMinMicros());
                    assertEquals(1, contentionStats.getContentionTimeMaxMicros());
                    assertEquals(4, contentionStats.getContentionTimeAvgMicros());
                    assertEquals(10, contentionStats.getContentionNumSamples());
                    assertThat(statsEntry.getChannelUtilizationRatio()).isIn(Range.closed(0, 255));
                    if (mTelephonyManager != null) {
                        boolean isCellularDataAvailable =
                                mTelephonyManager.getDataState() == TelephonyManager.DATA_CONNECTED;
                        assertEquals(isCellularDataAvailable, statsEntry.isCellularDataAvailable());
                    } else {
                        assertFalse(statsEntry.isCellularDataAvailable());
                    }
                    statsEntry.isWifiScoringEnabled();
                    statsEntry.isThroughputSufficient();
                    RateStats rateStats = new RateStats(WifiUsabilityStatsEntry.WIFI_PREAMBLE_VHT,
                            WifiUsabilityStatsEntry.WIFI_SPATIAL_STREAMS_TWO,
                            WifiUsabilityStatsEntry.WIFI_BANDWIDTH_40_MHZ,
                            2, 20, 100, 200, 5, 10);
                    assertThat(statsEntry.getRateStats()).isNotNull();
                    if(statsEntry.getRateStats().size() > 0) {
                        assertThat(statsEntry.getRateStats().get(0).getPreamble()).isAtLeast(0);
                        assertThat(statsEntry.getRateStats().get(0).getNumberOfSpatialStreams())
                                .isAtLeast(1);
                        assertThat(statsEntry.getRateStats().get(0).getBandwidthInMhz())
                                .isAtLeast(0);
                        assertThat(statsEntry.getRateStats().get(0).getRateMcsIdx()).isAtLeast(0);
                        assertThat(statsEntry.getRateStats().get(0).getBitRateInKbps())
                                .isAtLeast(0);
                        assertThat(statsEntry.getRateStats().get(0).getTxMpdu()).isAtLeast(0);
                        assertThat(statsEntry.getRateStats().get(0).getRxMpdu()).isAtLeast(0);
                        assertThat(statsEntry.getRateStats().get(0).getMpduLost()).isAtLeast(0);
                        assertThat(statsEntry.getRateStats().get(0).getRetries()).isAtLeast(0);
                    }
                    RadioStats radioStat = new RadioStats(0, 10, 11, 12, 13, 14, 15, 16, 17, 18);
                    assertThat(statsEntry.getWifiLinkLayerRadioStats()).isNotNull();
                    int numRadios = statsEntry.getWifiLinkLayerRadioStats().size();
                    for (int i = 0; i < numRadios; i++) {
                        RadioStats radioStats = statsEntry.getWifiLinkLayerRadioStats().get(i);
                        assertThat(radioStats.getRadioId()).isAtLeast(0);
                        assertThat(radioStats.getTotalRadioOnTimeMillis()).isAtLeast(0);
                        assertThat(radioStats.getTotalRadioTxTimeMillis()).isAtLeast(0);
                        assertThat(radioStats.getTotalRadioRxTimeMillis()).isAtLeast(0);
                        assertThat(radioStats.getTotalScanTimeMillis()).isAtLeast(0);
                        assertThat(radioStats.getTotalNanScanTimeMillis()).isAtLeast(0);
                        assertThat(radioStats.getTotalBackgroundScanTimeMillis()).isAtLeast(0);
                        assertThat(radioStats.getTotalRoamScanTimeMillis()).isAtLeast(0);
                        assertThat(radioStats.getTotalPnoScanTimeMillis()).isAtLeast(0);
                        assertThat(radioStats.getTotalHotspot2ScanTimeMillis()).isAtLeast(0);
                    }
                }
                // no longer populated, return default value.
                assertThat(statsEntry.getCellularDataNetworkType())
                        .isAnyOf(TelephonyManager.NETWORK_TYPE_UNKNOWN,
                                TelephonyManager.NETWORK_TYPE_GPRS,
                                TelephonyManager.NETWORK_TYPE_EDGE,
                                TelephonyManager.NETWORK_TYPE_UMTS,
                                TelephonyManager.NETWORK_TYPE_CDMA,
                                TelephonyManager.NETWORK_TYPE_EVDO_0,
                                TelephonyManager.NETWORK_TYPE_EVDO_A,
                                TelephonyManager.NETWORK_TYPE_1xRTT,
                                TelephonyManager.NETWORK_TYPE_HSDPA,
                                TelephonyManager.NETWORK_TYPE_HSUPA,
                                TelephonyManager.NETWORK_TYPE_HSPA,
                                TelephonyManager.NETWORK_TYPE_IDEN,
                                TelephonyManager.NETWORK_TYPE_EVDO_B,
                                TelephonyManager.NETWORK_TYPE_LTE,
                                TelephonyManager.NETWORK_TYPE_EHRPD,
                                TelephonyManager.NETWORK_TYPE_HSPAP,
                                TelephonyManager.NETWORK_TYPE_GSM,
                                TelephonyManager.NETWORK_TYPE_TD_SCDMA,
                                TelephonyManager.NETWORK_TYPE_IWLAN,
                                TelephonyManager.NETWORK_TYPE_NR);
                assertThat(statsEntry.getCellularSignalStrengthDbm()).isAtMost(0);
                assertThat(statsEntry.getCellularSignalStrengthDb()).isAtMost(0);
                assertThat(statsEntry.isSameRegisteredCell()).isFalse();
            }
        } finally {
            mWifiManager.removeOnWifiUsabilityStatsListener(usabilityStatsListener);
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests the {@link android.net.wifi.WifiManager#updateWifiUsabilityScore(int, int, int)}
     */"	""	""	"probe scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.widget.cts.ListViewTest"	"testAccessItemsCanFocus"	"CtsWidgetTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/ListViewTest.java"	""	"public void testAccessItemsCanFocus() {
        mListView.setItemsCanFocus(true);
        assertTrue(mListView.getItemsCanFocus());

        mListView.setItemsCanFocus(false);
        assertFalse(mListView.getItemsCanFocus());

        // TODO: how to check?
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiMigrationTest"	"testWifiMigrationSettingsDataBuilder"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiMigrationTest.java"	""	"public void testWifiMigrationSettingsDataBuilder() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        WifiMigration.SettingsMigrationData migrationData =
                new WifiMigration.SettingsMigrationData.Builder()
                        .setScanAlwaysAvailable(true)
                        .setP2pFactoryResetPending(true)
                        .setScanThrottleEnabled(true)
                        .setSoftApTimeoutEnabled(true)
                        .setWakeUpEnabled(true)
                        .setVerboseLoggingEnabled(true)
                        .setP2pDeviceName(TEST_SSID_UNQUOTED)
                        .build();

        assertNotNull(migrationData);
        assertTrue(migrationData.isScanAlwaysAvailable());
        assertTrue(migrationData.isP2pFactoryResetPending());
        assertTrue(migrationData.isScanThrottleEnabled());
        assertTrue(migrationData.isSoftApTimeoutEnabled());
        assertTrue(migrationData.isWakeUpEnabled());
        assertTrue(migrationData.isVerboseLoggingEnabled());
        assertEquals(TEST_SSID_UNQUOTED, migrationData.getP2pDeviceName());
    }

    /**
     * Tests {@link android.net.wifi.WifiMigration.SettingsMigrationData} class.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.releaseparser.TestModuleConfigHandler"	"getTestClassName"	""	"/home/gpoor/cts-12-source/cts/tools/release-parser/src/com/android/cts/releaseparser/TestModuleConfigHandler.java"	""	"public void test/*
 *.
 */

package com.android.cts.releaseparser;

import com.android.cts.releaseparser.ReleaseProto.*;

import org.xml.sax.Attributes;
import org.xml.sax.SAXException;
import org.xml.sax.helpers.DefaultHandler;

/**
 * {@link DefaultHandler} that builds an empty {@link ApiCoverage} object from scanning
 * TestModule.xml.
 */
class TestModuleConfigHandler extends DefaultHandler {
    private static final String CONFIGURATION_TAG = ""configuration"";
    private static final String DESCRIPTION_TAG = ""description"";
    private static final String OPTION_TAG = ""option"";
    private static final String TARGET_PREPARER_TAG = ""target_preparer"";
    private static final String TEST_TAG = ""test"";
    private static final String CLASS_TAG = ""class"";
    private static final String NAME_TAG = ""name"";
    private static final String KEY_TAG = ""key"";
    private static final String VALUE_TAG = ""value"";
    private static final String MODULE_NAME_TAG = ""module-name"";
    private static final String GTEST_CLASS_TAG = ""com.android.tradefed.testtype.GTest"";
    // com.android.compatibility.common.tradefed.testtype.JarHostTest option
    private static final String JAR_TAG = ""jar"";
    // com.android.tradefed.targetprep.suite.SuiteApkInstaller option
    private static final String TEST_FILE_NAME_TAG = ""test-file-name"";

    private TestModuleConfig.Builder mTestModuleConfig;
    private TestModuleConfig.TargetPreparer.Builder mTargetPreparer;
    private TestModuleConfig.TestClass.Builder mTestCase;
    private String mModuleName = null;

    TestModuleConfigHandler(String configFileName) {
        mTestModuleConfig = TestModuleConfig.newBuilder();
        mTestCase = null;
        mTargetPreparer = null;
        // Default Module Name is the Config File Name
        mModuleName = configFileName.replaceAll("".config$"", """");
    }

    @Override
    public void startElement(String uri, String localName, String name, Attributes attributes)
            throws SAXException {
        super.startElement(uri, localName, name, attributes);

        switch (localName) {
            case CONFIGURATION_TAG:
                if (null != attributes.getValue(DESCRIPTION_TAG)) {
                    mTestModuleConfig.setDescription(attributes.getValue(DESCRIPTION_TAG));
                } else {
                    mTestModuleConfig.setDescription(""WARNING: no description."");
                }
                break;
            case TEST_TAG:
                mTestCase = TestModuleConfig.TestClass.newBuilder();
                mTestCase.setTestClass(attributes.getValue(CLASS_TAG));
                break;
            case TARGET_PREPARER_TAG:
                mTargetPreparer = TestModuleConfig.TargetPreparer.newBuilder();
                mTargetPreparer.setTestClass(attributes.getValue(CLASS_TAG));
                break;
            case OPTION_TAG:
                Option.Builder option = Option.newBuilder();
                option.setName(attributes.getValue(NAME_TAG));
                option.setValue(attributes.getValue(VALUE_TAG));
                String keyStr = attributes.getValue(KEY_TAG);
                if (null != keyStr) {
                    option.setKey(keyStr);
                }
                if (null != mTestCase) {
                    mTestCase.addOptions(option);
                    switch (option.getName()) {
                        case JAR_TAG:
                            mTestModuleConfig.addTestJars(option.getValue());
                            break;
                        case GTEST_CLASS_TAG:
                            mModuleName = option.getValue();
                            break;
                    }
                } else if (null != mTargetPreparer) {
                    mTargetPreparer.addOptions(option);
                    if (TEST_FILE_NAME_TAG.equalsIgnoreCase(option.getName())) {
                        mTestModuleConfig.addTestFileNames(option.getValue());
                    }
                }
                break;
        }
    }

    @Override
    public void endElement(String uri, String localName, String name) throws SAXException {
        super.endElement(uri, localName, name);
        switch (localName) {
            case CONFIGURATION_TAG:
                mTestModuleConfig.setModuleName(mModuleName);
                break;
            case TARGET_PREPARER_TAG:
                mTestModuleConfig.addTargetPreparers(mTargetPreparer);
                mTargetPreparer = null;
                break;
            case TEST_TAG:
                mTestModuleConfig.addTestClasses(mTestCase);
                mTestCase = null;
                break;
        }
    }

    public String getModuleName() {
        return mModuleName;
    }

    public String getTestClassName() {
        //return the 1st Test Class
        return mTestModuleConfig.getTestClassesList().get(0).getTestClass();
    }

    public TestModuleConfig getTestModuleConfig() {
        return mTestModuleConfig.build();
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.security.NetworkSecurityPolicyTestBase"	"testDownloadManager"	""	"/home/gpoor/cts-12-source/cts/tests/tests/netsecpolicy/src/android/security/NetworkSecurityPolicyTestBase.java"	""	"public void testDownloadManager() throws Exception {
        Uri uri = Uri.parse(mHttpOnlyWebServer.getTestDownloadUrl(""netsecpolicy"", 0));
        int[] result = downloadUsingDownloadManager(uri);
        int status = result[0];
        int reason = result[1];
        uri = uri.buildUpon().scheme(null).authority(null).build();
        if (mCleartextTrafficExpectedToBePermitted) {
            assertEquals(DownloadManager.STATUS_SUCCESSFUL, status);
            assertTrue(mHttpOnlyWebServer.wasResourceRequested(uri.toString()));
        } else {
            assertEquals(DownloadManager.STATUS_FAILED, status);
            assertEquals(400, reason);
            assertFalse(mHttpOnlyWebServer.wasResourceRequested(uri.toString()));
        }
    }


    private int[] downloadUsingDownloadManager(Uri uri) throws Exception {
        DownloadManager downloadManager =
                (DownloadManager) getContext().getSystemService(Context.DOWNLOAD_SERVICE);
        removeAllDownloads(downloadManager);
        BroadcastReceiver downloadCompleteReceiver = null;
        try {
            final SettableFuture<Intent> downloadCompleteIntentFuture = new SettableFuture<Intent>();
            downloadCompleteReceiver = new BroadcastReceiver() {
                @Override
                public void onReceive(Context context, Intent intent) {
                    downloadCompleteIntentFuture.set(intent);
                }
            };
            getContext().registerReceiver(
                    downloadCompleteReceiver,
                    new IntentFilter(DownloadManager.ACTION_DOWNLOAD_COMPLETE));

            Intent downloadCompleteIntent;

            long downloadId = downloadManager.enqueue(new DownloadManager.Request(uri));
            downloadCompleteIntent = downloadCompleteIntentFuture.get(5, TimeUnit.SECONDS);

            assertEquals(downloadId,
                    downloadCompleteIntent.getLongExtra(DownloadManager.EXTRA_DOWNLOAD_ID, -1));
            Cursor c = downloadManager.query(
                    new DownloadManager.Query().setFilterById(downloadId));
            try {
                if (!c.moveToNext()) {
                    fail(""Download not found"");
                    return null;
                }
                int status = c.getInt(c.getColumnIndexOrThrow(DownloadManager.COLUMN_STATUS));
                int reason = c.getInt(c.getColumnIndexOrThrow(DownloadManager.COLUMN_REASON));
                return new int[] {status, reason};
            } finally {
                c.close();
            }
        } finally {
            if (downloadCompleteReceiver != null) {
                getContext().unregisterReceiver(downloadCompleteReceiver);
            }
            removeAllDownloads(downloadManager);
        }
    }

    private static void removeAllDownloads(DownloadManager downloadManager) {
        Cursor cursor = null;
        try {
            DownloadManager.Query query = new DownloadManager.Query();
            cursor = downloadManager.query(query);
            if (cursor.getCount() == 0) {
                return;
            }
            long[] removeIds = new long[cursor.getCount()];
            int columnIndex = cursor.getColumnIndex(DownloadManager.COLUMN_ID);
            for (int i = 0; cursor.moveToNext(); i++) {
                removeIds[i] = cursor.getLong(columnIndex);
            }
            assertEquals(removeIds.length, downloadManager.remove(removeIds));
        } finally {
            if (cursor != null) {
                cursor.close();
            }
        }
    }

    private static class SettableFuture<T> implements Future<T> {

        private final Object mLock = new Object();
        private boolean mDone;
        private boolean mCancelled;
        private T mValue;
        private Throwable mException;

        public void set(T value) {
            synchronized (mLock) {
                if (!mDone) {
                    mValue = value;
                    mDone = true;
                    mLock.notifyAll();
                }
            }
        }

        public void setException(Throwable exception) {
            synchronized (mLock) {
                if (!mDone) {
                    mException = exception;
                    mDone = true;
                    mLock.notifyAll();
                }
            }
        }

        @Override
        public boolean cancel(boolean mayInterruptIfRunning) {
            synchronized (mLock) {
                if (mDone) {
                    return false;
                }
                mCancelled = true;
                mDone = true;
                mLock.notifyAll();
                return true;
            }
        }

        @Override
        public T get() throws InterruptedException, ExecutionException {
            synchronized (mLock) {
                while (!mDone) {
                    mLock.wait();
                }
                return getValue();
            }
        }

        @Override
        public T get(long timeout, TimeUnit timeUnit)
                throws InterruptedException, ExecutionException, TimeoutException {
            synchronized (mLock) {
                if (mDone) {
                    return getValue();
                }
                long timeoutMillis = timeUnit.toMillis(timeout);
                long deadlineTimeMillis = System.currentTimeMillis() + timeoutMillis;

                while (!mDone) {
                    long millisTillDeadline = deadlineTimeMillis - System.currentTimeMillis();
                    if ((millisTillDeadline <= 0) || (millisTillDeadline > timeoutMillis)) {
                        throw new TimeoutException();
                    }
                    mLock.wait(millisTillDeadline);
                }
                return getValue();
            }
        }

        private T getValue() throws ExecutionException {
            synchronized (mLock) {
                if (!mDone) {
                    throw new IllegalStateException(""Not yet done"");
                }
                if (mCancelled) {
                    throw new CancellationException();
                }
                if (mException != null) {
                    throw new ExecutionException(mException);
                }
                return mValue;
            }
        }

        @Override
        public boolean isCancelled() {
            synchronized (mLock) {
                return mCancelled;
            }
        }

        @Override
        public boolean isDone() {
            synchronized (mLock) {
                return mDone;
            }
        }
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.view.cts.input.InputDeviceKeyLayoutMapTest"	"createDeviceRegisterCommand"	"CtsViewTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/view/src/android/view/cts/input/InputDeviceKeyLayoutMapTest.java"	""	"/*
 *.
 */

package android.view.cts;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotEquals;
import static org.junit.Assert.assertNotNull;

import android.app.Instrumentation;
import android.view.InputDevice;
import android.view.KeyEvent;

import androidx.annotation.NonNull;
import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.filters.MediumTest;
import androidx.test.platform.app.InstrumentationRegistry;
import androidx.test.rule.ActivityTestRule;

import com.android.compatibility.common.util.PollingCheck;
import com.android.cts.input.InputJsonParser;
import com.android.cts.input.UinputDevice;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;
import org.junit.After;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.Arrays;
import java.util.List;
import java.util.Map;

/**
 * CTS test case for generic.kl key layout mapping.
 * This test utilize uinput command line tool to create a test device, and configure the virtual
 * device to have all keys need to be tested. The JSON format input for device configuration
 * and EV_KEY injection will be created directly from this test for uinput command.
 * Keep res/raw/Generic.kl in sync with framework/base/data/keyboards/Generic.kl, this file
 * will be loaded and parsed in this test, looping through all key labels and the corresponding
 * EV_KEY code, injecting the KEY_UP and KEY_DOWN event to uinput, then verify the KeyEvent
 * delivered to test application view. Except meta control keys and special keys not delivered
 * to apps, all key codes in generic.kl will be verified.
 *
 */
@MediumTest
@RunWith(AndroidJUnit4.class)
public class InputDeviceKeyLayoutMapTest {
    private static final String TAG = ""InputDeviceKeyLayoutMapTest"";
    private static final String LABEL_PREFIX = ""KEYCODE_"";
    private static final int DEVICE_ID = 1;
    private static final int EV_SYN = 0;
    private static final int EV_KEY = 1;
    private static final int EV_KEY_DOWN = 1;
    private static final int EV_KEY_UP = 0;
    private static final int UI_SET_EVBIT = 100;
    private static final int UI_SET_KEYBIT = 101;
    private static final int GOOGLE_VENDOR_ID = 0x18d1;
    private static final int GOOGLE_VIRTUAL_KEYBOARD_ID = 0x001f;
    private static final int POLL_EVENT_TIMEOUT_SECONDS = 1;
    private static final int RETRY_COUNT = 10;

    private Map<String, Integer> mKeyLayout;
    private Instrumentation mInstrumentation;
    private UinputDevice mUinputDevice;
    private int mMetaState;
    private InputJsonParser mParser;

    private static native Map<String, Integer> nativeLoadKeyLayout(String genericKeyLayout);

    static {
        System.loadLibrary(""ctsview_jni"");
    }

    @Rule
    public ActivityTestRule<InputDeviceKeyLayoutMapTestActivity> mActivityRule =
            new ActivityTestRule<>(InputDeviceKeyLayoutMapTestActivity.class);

    @Before
    public void setup() {
        mInstrumentation = InstrumentationRegistry.getInstrumentation();
        PollingCheck.waitFor(mActivityRule.getActivity()::hasWindowFocus);
        mParser = new InputJsonParser(mInstrumentation.getTargetContext());
        mKeyLayout = nativeLoadKeyLayout(mParser.readRegisterCommand(R.raw.Generic));
        mUinputDevice = new UinputDevice(mInstrumentation, DEVICE_ID, GOOGLE_VENDOR_ID,
                GOOGLE_VIRTUAL_KEYBOARD_ID, InputDevice.SOURCE_KEYBOARD,
                createDeviceRegisterCommand());

        mMetaState = KeyEvent.META_NUM_LOCK_ON;
    }

    @After
    public void tearDown() {
        if (mUinputDevice != null) {
            mUinputDevice.close();
        }
    }

    /**
     * Get a KeyEvent from event queue or timeout.
     * The test activity instance may change in the middle, calling getKeyEvent with the old
     * activity instance will get timed out when test activity instance changed. Rather than
     * doing a long wait for timeout with same activity instance, break the polling into a number
     * of retries and each time of retry call the ActivityTestRule.getActivity for current activity
     * instance to avoid the test failure because of polling the old activity instance get timed
     * out consequently failed the test.
     *
     * @param retryCount The times to retry get KeyEvent from test activity.
     *
     * @return KeyEvent delivered to test activity, null if timeout.
     */
    private KeyEvent getKeyEvent(int retryCount) {
        for (int i = 0; i < retryCount; i++) {
            KeyEvent event = mActivityRule.getActivity().getKeyEvent(POLL_EVENT_TIMEOUT_SECONDS);
            if (event != null) {
                return event;
            }
        }
        return null;
    }

    /**
     * Asserts that the application received a {@link android.view.KeyEvent} with the given
     * metadata.
     *
     * If other KeyEvents are received by the application prior to the expected KeyEvent, or no
     * KeyEvents are received within a reasonable amount of time, then this will throw an
     * {@link AssertionError}.
     *
     * Only action, source, keyCode and metaState are being compared.
     */
    private void assertReceivedKeyEvent(@NonNull KeyEvent expectedKeyEvent) {
        if (expectedKeyEvent.getKeyCode() == KeyEvent.KEYCODE_UNKNOWN) {
            return;
        }

        KeyEvent receivedKeyEvent = getKeyEvent(RETRY_COUNT);
        String log = ""Expected "" + expectedKeyEvent + "" Received "" + receivedKeyEvent;
        assertNotNull(log, receivedKeyEvent);
        assertEquals(log, expectedKeyEvent.getAction(), receivedKeyEvent.getAction());
        assertEquals(log, expectedKeyEvent.getSource(), receivedKeyEvent.getSource());
        assertEquals(log, expectedKeyEvent.getKeyCode(), receivedKeyEvent.getKeyCode());
        assertEquals(log, expectedKeyEvent.getMetaState(), receivedKeyEvent.getMetaState());
    }

    /**
     * Create the uinput device registration command, in JSON format of uinput commandline tool.
     * Refer to {@link framework/base/cmds/uinput/README.md}
     */
    private String createDeviceRegisterCommand() {
        JSONObject json = new JSONObject();
        JSONArray arrayConfigs =  new JSONArray();
        try {
            json.put(""id"", DEVICE_ID);
            json.put(""type"", ""uinput"");
            json.put(""command"", ""register"");
            json.put(""name"", ""Virtual All Buttons Device (Test)"");
            json.put(""vid"", GOOGLE_VENDOR_ID);
            json.put(""pid"", GOOGLE_VIRTUAL_KEYBOARD_ID);
            json.put(""bus"", ""bluetooth"");

            JSONObject jsonSetEvBit = new JSONObject();
            JSONArray arraySetEvBit =  new JSONArray();
            arraySetEvBit.put(EV_KEY);
            jsonSetEvBit.put(""type"", UI_SET_EVBIT);
            jsonSetEvBit.put(""data"", arraySetEvBit);
            arrayConfigs.put(jsonSetEvBit);

            // Configure device have all keys from key layout map.
            JSONArray arraySetKeyBit = new JSONArray();
            for (Map.Entry<String, Integer> entry : mKeyLayout.entrySet()) {
                arraySetKeyBit.put(entry.getValue());
            }
            JSONObject jsonSetKeyBit = new JSONObject();
            jsonSetKeyBit.put(""type"", UI_SET_KEYBIT);
            jsonSetKeyBit.put(""data"", arraySetKeyBit);
            arrayConfigs.put(jsonSetKeyBit);
            json.put(""configuration"", arrayConfigs);
        } catch (JSONException e) {
            throw new RuntimeException(
                    ""Could not create JSON object"");
        }

        return json.toString();
    }

    /**
     * Update expected meta state for incoming key event.
     * @param action KeyEvent.ACTION_DOWN or KeyEvent.ACTION_UP
     * @param label Key label from key layout mapping definition
     * @return updated meta state
     */

    private int updateMetaState(int action, String label) {

        int metaState = 0;
        int metaStateToggle = 0;
        if (label.equals(""CTRL_LEFT"")) {
            metaState = KeyEvent.META_CTRL_ON | KeyEvent.META_CTRL_LEFT_ON;
        }
        if (label.equals(""CTRL_RIGHT"")) {
            metaState = KeyEvent.META_CTRL_ON | KeyEvent.META_CTRL_RIGHT_ON;
        }
        if (label.equals(""SHIFT_LEFT"")) {
            metaState = KeyEvent.META_SHIFT_ON | KeyEvent.META_SHIFT_LEFT_ON;
        }
        if (label.equals(""SHIFT_RIGHT"")) {
            metaState = KeyEvent.META_SHIFT_ON | KeyEvent.META_SHIFT_RIGHT_ON;
        }
        if (label.equals(""ALT_LEFT"")) {
            metaState = KeyEvent.META_ALT_ON | KeyEvent.META_ALT_LEFT_ON;
        }
        if (label.equals(""ALT_RIGHT"")) {
            metaState = KeyEvent.META_ALT_ON | KeyEvent.META_ALT_RIGHT_ON;
        }
        if (label.equals(""CAPS_LOCK"")) {
            metaStateToggle =  KeyEvent.META_CAPS_LOCK_ON;
        }
        if (label.equals(""NUM_LOCK"")) {
            metaStateToggle =  KeyEvent.META_NUM_LOCK_ON;
        }
        if (label.equals(""SCROLL_LOCK"")) {
            metaStateToggle =  KeyEvent.META_SCROLL_LOCK_ON;
        }

        if (action == KeyEvent.ACTION_DOWN) {
            mMetaState |= metaState;
        } else if (action == KeyEvent.ACTION_UP) {
            mMetaState &= ~metaState;
        }

        if (action == KeyEvent.ACTION_UP) {
            if ((mMetaState & metaStateToggle) == 0) {
                mMetaState |= metaStateToggle;
            } else {
                mMetaState &= ~metaStateToggle;
            }
        }
        return mMetaState;
    }

    /**
     * Generate a key event from the key label and action.
     * @param action KeyEvent.ACTION_DOWN or KeyEvent.ACTION_UP
     * @param label Key label from key layout mapping definition
     * @return KeyEvent expected to receive
     */
    private KeyEvent generateKeyEvent(int action, String label) {
        int source = InputDevice.SOURCE_KEYBOARD | InputDevice.SOURCE_GAMEPAD
                | InputDevice.SOURCE_DPAD;
        int keyCode = KeyEvent.keyCodeFromString(LABEL_PREFIX + label);
        int metaState = updateMetaState(action, label);
        // We will only check select fields of the KeyEvent. Times are not checked.
        KeyEvent event = new KeyEvent(/* downTime */ 0, /* eventTime */ 0, action, keyCode,
                /* repeat */ 0, metaState, /* deviceId */ 0, /* scanCode */ 0,
                /* flags */ 0, source);

        return event;
    }

    /**
     * Simulate pressing a key.
     * @param evKeyCode The key scan code
     */
    private void pressKey(int evKeyCode) {
        int[] evCodesDown = new int[] {
                EV_KEY, evKeyCode, EV_KEY_DOWN,
                EV_SYN, 0, 0};
        mUinputDevice.injectEvents(Arrays.toString(evCodesDown));

        int[] evCodesUp = new int[] {
                EV_KEY, evKeyCode, EV_KEY_UP,
                EV_SYN, 0, 0 };
        mUinputDevice.injectEvents(Arrays.toString(evCodesUp));
    }

    /**
     * Check the initial global meta key state.
     * @param label Key label from key layout mapping definition
     * @param metaState The meta state that the meta key changes
     */
    private void checkMetaKeyState(String label, int metaState) {
        int eveKeyCode = mKeyLayout.get(label);
        pressKey(eveKeyCode);
        // Get 2 key events for up and down.
        KeyEvent keyDownEvent = getKeyEvent(RETRY_COUNT);
        assertNotNull(""Didn't get KeyDown event "" + label, keyDownEvent);
        KeyEvent keyUpEvent = getKeyEvent(RETRY_COUNT);
        assertNotNull(""Didn't get KeyUp event "" + label, keyUpEvent);

        if (keyUpEvent.getKeyCode() == KeyEvent.keyCodeFromString(label)
                && keyUpEvent.getAction() == KeyEvent.ACTION_UP) {
            mMetaState &= ~metaState;
            mMetaState |= (keyUpEvent.getMetaState() & metaState);
        }
    }

    /**
     * Initialize NUM_LOCK, CAPS_LOCK, SCROLL_LOCK state as they are global meta state
     */
    private void initializeMetaKeysState() {
        // Detect NUM_LOCK key state before test.
        checkMetaKeyState(""NUM_LOCK"", KeyEvent.META_NUM_LOCK_ON);
        // Detect CAPS_LOCK key state before test.
        checkMetaKeyState(""CAPS_LOCK"", KeyEvent.META_CAPS_LOCK_ON);
        // Detect CAPS_LOCK key state before test.
        checkMetaKeyState(""SCROLL_LOCK"", KeyEvent.META_SCROLL_LOCK_ON);
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.location.cts.fine.ScanningSettingsTest"	"isTV"	"CtsLocationFineTestCases"	"/home/gpoor/cts-12-source/cts/tests/location/location_fine/src/android/location/cts/fine/ScanningSettingsTest.java"	""	"public void test/*
 *.
 */

package android.location.cts.fine;

import android.content.ContentResolver;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.content.res.Resources;
import android.database.ContentObserver;
import android.net.wifi.WifiManager;
import android.os.Handler;
import android.os.HandlerThread;
import android.platform.test.annotations.AppModeFull;
import android.provider.Settings;
import android.support.test.uiautomator.By;
import android.support.test.uiautomator.UiDevice;
import android.support.test.uiautomator.UiObject2;
import android.support.test.uiautomator.UiObjectNotFoundException;
import android.support.test.uiautomator.UiScrollable;
import android.support.test.uiautomator.UiSelector;
import android.support.test.uiautomator.Until;
import android.test.AndroidTestCase;

import com.android.compatibility.common.util.CddTest;
import com.android.compatibility.common.util.FeatureUtil;
import com.android.compatibility.common.util.PollingCheck;

import androidx.test.platform.app.InstrumentationRegistry;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

/**
 * Tests if system settings app provides scanning settings.
 */
@AppModeFull(reason = ""Test cases don't apply for Instant apps"")
public class ScanningSettingsTest extends AndroidTestCase {
    private static final String TAG = ""ScanningSettingsTest"";

    private static final int TIMEOUT = 8_000;  // 8 seconds
    private static final String SETTINGS_PACKAGE = ""com.android.settings"";

    private static final String WIFI_SCANNING_TITLE_RES =
            ""location_scanning_wifi_always_scanning_title"";
    private static final String BLUETOOTH_SCANNING_TITLE_RES =
            ""location_scanning_bluetooth_always_scanning_title"";

    private UiDevice mDevice;
    private Context mContext;
    private String mLauncherPackage;
    private PackageManager mPackageManager;

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        // Can't use assumeTrue / assumeFalse because this is not a junit test, and so doesn't
        // support using these keywords to trigger assumption failure and skip test.
        if (FeatureUtil.isTV() || FeatureUtil.isAutomotive() || FeatureUtil.isWatch()) {
            // TV, auto, and watch do not support the setting options of WIFI scanning and Bluetooth
            // scanning
            return;
        }
        mContext = InstrumentationRegistry.getInstrumentation().getContext();
        mDevice = UiDevice.getInstance(InstrumentationRegistry.getInstrumentation());

        mPackageManager = mContext.getPackageManager();
        final Intent launcherIntent = new Intent(Intent.ACTION_MAIN);
        launcherIntent.addCategory(Intent.CATEGORY_HOME);
        mLauncherPackage = mPackageManager.resolveActivity(launcherIntent,
                PackageManager.MATCH_DEFAULT_ONLY).activityInfo.packageName;
    }

    @CddTest(requirement = ""7.4.2/C-2-1"")"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.location.cts.fine.ScanningSettingsTest"	"testWifiScanningSettings"	"CtsLocationFineTestCases"	"/home/gpoor/cts-12-source/cts/tests/location/location_fine/src/android/location/cts/fine/ScanningSettingsTest.java"	""	"public void testWifiScanningSettings() throws Exception {
        if (FeatureUtil.isTV() || FeatureUtil.isAutomotive() || FeatureUtil.isWatch()) {
            return;
        }
        launchLocationServicesSettings();
        launchScanningSettingsFragment(WIFI_SCANNING_TITLE_RES);

        final Resources res = mPackageManager.getResourcesForApplication(SETTINGS_PACKAGE);
        final int resId = res.getIdentifier(WIFI_SCANNING_TITLE_RES, ""string"", SETTINGS_PACKAGE);
        final UiObject2 pref = mDevice.findObject(By.text(res.getString(resId)));

        final WifiManager wifiManager = mContext.getSystemService(WifiManager.class);

        final boolean checked = wifiManager.isScanAlwaysAvailable();

        // Click the preference to toggle the setting.
        pref.click();
        PollingCheck.check(
                ""Scan Always Available wasn't toggled from "" + checked + "" to "" + !checked,
                TIMEOUT,
                () -> !checked == wifiManager.isScanAlwaysAvailable()
        );

        // Click the preference again to toggle the setting back.
        pref.click();
        PollingCheck.check(
                ""Scan Always Available wasn't toggled from "" + !checked + "" to "" + checked,
                TIMEOUT,
                () -> checked == wifiManager.isScanAlwaysAvailable()
        );
    }

    @CddTest(requirement = ""7.4.3/C-4-1"")"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.location.cts.fine.ScanningSettingsTest"	"testBleScanningSettings"	"CtsLocationFineTestCases"	"/home/gpoor/cts-12-source/cts/tests/location/location_fine/src/android/location/cts/fine/ScanningSettingsTest.java"	""	"public void testBleScanningSettings() throws PackageManager.NameNotFoundException {
        if (FeatureUtil.isTV() || FeatureUtil.isAutomotive() || FeatureUtil.isWatch()) {
            return;
        }
        launchLocationServicesSettings();
        launchScanningSettingsFragment(BLUETOOTH_SCANNING_TITLE_RES);

        toggleSettingAndVerify(BLUETOOTH_SCANNING_TITLE_RES,
                Settings.Global.BLE_SCAN_ALWAYS_AVAILABLE);
    }

    private void launchLocationServicesSettings() {
        // Start from the home screen
        mDevice.pressHome();
        mDevice.wait(Until.hasObject(By.pkg(mLauncherPackage).depth(0)), TIMEOUT);

        final Intent intent = new Intent(Settings.ACTION_LOCATION_SCANNING_SETTINGS);
        // Clear out any previous instances
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);
        mContext.startActivity(intent);

        // Wait for the app to appear
        mDevice.wait(Until.hasObject(By.pkg(SETTINGS_PACKAGE).depth(0)), TIMEOUT);
    }

    private void launchScanningSettingsFragment(String name)
            throws PackageManager.NameNotFoundException {
        final Resources res = mPackageManager.getResourcesForApplication(SETTINGS_PACKAGE);
        int resId = res.getIdentifier(name, ""string"", SETTINGS_PACKAGE);
        UiScrollable uiScrollable = new UiScrollable(new UiSelector().scrollable(true));
        try {
            uiScrollable.scrollTextIntoView(res.getString(resId));
        } catch (UiObjectNotFoundException e) {
            // Scrolling can fail if the UI is not scrollable
        }

        UiObject2 pref = mDevice.findObject(By.text(res.getString(resId)));
        // Click the preference to show the Scanning fragment
        pref.click();

        // Wait for the Scanning fragment to appear
        mDevice.wait(Until.hasObject(By.pkg(SETTINGS_PACKAGE).depth(1)), TIMEOUT);
    }

    private void clickAndWaitForSettingChange(UiObject2 pref, ContentResolver resolver,
            String settingKey) {
        final CountDownLatch latch = new CountDownLatch(1);
        final HandlerThread handlerThread = new HandlerThread(TAG);
        handlerThread.start();
        final ContentObserver observer = new ContentObserver(
                new Handler(handlerThread.getLooper())) {
            @Override
            public void onChange(boolean selfChange) {
                super.onChange(selfChange);
                latch.countDown();
            }
        };
        resolver.registerContentObserver(Settings.Global.getUriFor(settingKey), false, observer);
        pref.click();
        try {
            latch.await(TIMEOUT, TimeUnit.MILLISECONDS);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        handlerThread.quit();
        resolver.unregisterContentObserver(observer);
        assertEquals(0, latch.getCount());
    }

    private void toggleSettingAndVerify(String prefTitleRes, String settingKey)
            throws PackageManager.NameNotFoundException {
        final Resources res = mPackageManager.getResourcesForApplication(SETTINGS_PACKAGE);
        final int resId = res.getIdentifier(prefTitleRes, ""string"", SETTINGS_PACKAGE);
        final UiObject2 pref = mDevice.findObject(By.text(res.getString(resId)));
        final ContentResolver resolver = mContext.getContentResolver();
        final boolean checked = Settings.Global.getInt(resolver, settingKey, 0) == 1;

        // Click the preference to toggle the setting.
        clickAndWaitForSettingChange(pref, resolver, settingKey);
        assertEquals(!checked, Settings.Global.getInt(resolver, settingKey, 0) == 1);

        // Click the preference again to toggle the setting back.
        clickAndWaitForSettingChange(pref, resolver, settingKey);
        assertEquals(checked, Settings.Global.getInt(resolver, settingKey, 0) == 1);
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest"	"isStaConcurrencyForRestrictedConnectionsSupported"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest.java"	""	"/*
 *.
 */

package android.net.wifi.cts;

import static android.net.NetworkCapabilities.NET_CAPABILITY_OEM_PAID;
import static android.net.NetworkCapabilities.NET_CAPABILITY_OEM_PRIVATE;
import static android.os.Process.myUid;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import static org.junit.Assume.assumeTrue;

import android.content.Context;
import android.content.pm.PackageManager;
import android.location.LocationManager;
import android.net.ConnectivityManager;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiManager;
import android.net.wifi.WifiNetworkSuggestion;
import android.os.Build;
import android.platform.test.annotations.AppModeFull;
import android.support.test.uiautomator.UiDevice;

import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.filters.LargeTest;
import androidx.test.filters.SdkSuppress;
import androidx.test.platform.app.InstrumentationRegistry;

import com.android.compatibility.common.util.PollingCheck;
import com.android.compatibility.common.util.ShellIdentityUtils;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.List;
import java.util.Set;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;

/**
 * Tests multiple concurrent connection flow on devices that support multi STA concurrency
 * (indicated via {@link WifiManager#isStaConcurrencyForRestrictedConnectionsSupported()}.
 *
 * Tests the entire connection flow using {@link WifiNetworkSuggestion} which has
 * {@link WifiNetworkSuggestion.Builder#setOemPaid(boolean)} or
 * {@link WifiNetworkSuggestion.Builder#setOemPrivate(boolean)} set along with a concurrent internet
 * connection using {@link WifiManager#connect(int, WifiManager.ActionListener)}.
 *
 * Assumes that all the saved networks is either open/WPA1/WPA2/WPA3 authenticated network.
 */
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)
@AppModeFull(reason = ""Cannot get WifiManager in instant app mode"")
@LargeTest
@RunWith(AndroidJUnit4.class)
public class MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest extends WifiJUnit4TestBase {
    private static final String TAG = ""MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest"";
    private static boolean sWasVerboseLoggingEnabled;
    private static boolean sWasScanThrottleEnabled;
    private static boolean sWasWifiEnabled;

    private Context mContext;
    private WifiManager mWifiManager;
    private ConnectivityManager mConnectivityManager;
    private UiDevice mUiDevice;
    private WifiConfiguration mTestNetworkForRestrictedConnection;
    private WifiConfiguration mTestNetworkForInternetConnection;
    private ConnectivityManager.NetworkCallback mNetworkCallback;
    private ConnectivityManager.NetworkCallback mNsNetworkCallback;
    private ScheduledExecutorService mExecutorService;
    private TestHelper mTestHelper;

    private static final int DURATION_MILLIS = 10_000;

    @BeforeClass
    public static void setUpClass() throws Exception {
        Context context = InstrumentationRegistry.getInstrumentation().getContext();
        // skip the test if WiFi is not supported or not automotive platform.
        // Don't use assumeTrue in @BeforeClass
        if (!WifiFeature.isWifiSupported(context)) return;

        WifiManager wifiManager = context.getSystemService(WifiManager.class);
        assertThat(wifiManager).isNotNull();

        // turn on verbose logging for tests
        sWasVerboseLoggingEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.isVerboseLoggingEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setVerboseLoggingEnabled(true));
        // Disable scan throttling for tests.
        sWasScanThrottleEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.isScanThrottleEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setScanThrottleEnabled(false));

        // enable Wifi
        sWasWifiEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.isWifiEnabled());
        if (!wifiManager.isWifiEnabled()) {
            ShellIdentityUtils.invokeWithShellPermissions(() -> wifiManager.setWifiEnabled(true));
        }
        PollingCheck.check(""Wifi not enabled"", DURATION_MILLIS, () -> wifiManager.isWifiEnabled());
    }

    @AfterClass
    public static void tearDownClass() throws Exception {
        Context context = InstrumentationRegistry.getInstrumentation().getContext();
        if (!WifiFeature.isWifiSupported(context)) return;

        WifiManager wifiManager = context.getSystemService(WifiManager.class);
        assertThat(wifiManager).isNotNull();

        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setScanThrottleEnabled(sWasScanThrottleEnabled));
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setVerboseLoggingEnabled(sWasVerboseLoggingEnabled));
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setWifiEnabled(sWasWifiEnabled));
    }

    @Before
    public void setUp() throws Exception {
        mContext = InstrumentationRegistry.getInstrumentation().getContext();
        mWifiManager = mContext.getSystemService(WifiManager.class);
        mConnectivityManager = mContext.getSystemService(ConnectivityManager.class);
        mUiDevice = UiDevice.getInstance(InstrumentationRegistry.getInstrumentation());
        mExecutorService = Executors.newSingleThreadScheduledExecutor();
        mTestHelper = new TestHelper(mContext, mUiDevice);

        // skip the test if WiFi is not supported or not automitve platform.
        assumeTrue(WifiFeature.isWifiSupported(mContext));
        // skip the test if location is not supported
        assumeTrue(mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_LOCATION));
        // skip if multi STA not supported.
        assumeTrue(mWifiManager.isStaConcurrencyForRestrictedConnectionsSupported());

        assertWithMessage(""Please enable location for this test!"").that(
                mContext.getSystemService(LocationManager.class).isLocationEnabled()).isTrue();

        // turn screen on
        mTestHelper.turnScreenOn();

        // Clear any existing app state before each test.
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.removeAppState(myUid(), mContext.getPackageName()));

        // We need 2 AP's for the test. If there are 2 networks saved on the device and in range,
        // use those. Otherwise, check if there are 2 BSSID's in range for the only saved network.
        // This assumes a CTS test environment with at least 2 connectable bssid's (Is that ok?).
        List<WifiConfiguration> savedNetworks = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.getPrivilegedConfiguredNetworks());
        List<WifiConfiguration> matchingNetworksWithBssid =
                TestHelper.findMatchingSavedNetworksWithBssid(mWifiManager, savedNetworks);
        assertWithMessage(""Need at least 2 saved network bssids in range"").that(
                matchingNetworksWithBssid.size()).isAtLeast(2);
        // Pick any 2 bssid for test.
        mTestNetworkForRestrictedConnection = matchingNetworksWithBssid.get(0);
        // Try to find a bssid for another saved network in range. If none exists, fallback
        // to using 2 bssid's for the same network.
        mTestNetworkForInternetConnection = matchingNetworksWithBssid.stream()
                .filter(w -> !w.SSID.equals(mTestNetworkForRestrictedConnection.SSID))
                .findAny()
                .orElse(matchingNetworksWithBssid.get(1));

        // Disconnect & disable auto-join on the saved network to prevent auto-connect from
        // interfering with the test.
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> {
                    for (WifiConfiguration savedNetwork : savedNetworks) {
                        mWifiManager.disableNetwork(savedNetwork.networkId);
                    }
                    mWifiManager.disconnect();
                });

        // Wait for Wifi to be disconnected.
        PollingCheck.check(
                ""Wifi not disconnected"",
                20_000,
                () -> mWifiManager.getConnectionInfo().getNetworkId() == -1);
    }

    @After
    public void tearDown() throws Exception {
        // Re-enable networks.
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> {
                    for (WifiConfiguration savedNetwork : mWifiManager.getConfiguredNetworks()) {
                        mWifiManager.enableNetwork(savedNetwork.networkId, false);
                    }
                });
        // Release the requests after the test.
        if (mNetworkCallback != null) {
            mConnectivityManager.unregisterNetworkCallback(mNetworkCallback);
        }
        if (mNsNetworkCallback != null) {
            mConnectivityManager.unregisterNetworkCallback(mNsNetworkCallback);
        }
        mExecutorService.shutdownNow();
        // Clear any existing app state after each test.
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.removeAppState(myUid(), mContext.getPackageName()));
        mTestHelper.turnScreenOff();
    }

    /**
     * Tests the concurrent connection flow.
     * 1. Connect to a network using internet connectivity API.
     * 2. Connect to a network using restricted suggestion API.
     * 3. Verify that both connections are active.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.KeyManagementTest"	"testNotUserSelectableAliasCanBeChosenViaPolicy"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/KeyManagementTest.java"	""	"public void testNotUserSelectableAliasCanBeChosenViaPolicy() throws Exception {
        final String alias = ""com.android.test.not-selectable-key-1"";

        // Install keypair.
        assertThat(
                mDevicePolicyManager.installKeyPair(
                        getWho(), mFakePrivKey, new Certificate[] {mFakeCert}, alias, 0))
                .isTrue();
        try {
            // Request and retrieve using the alias.
            assertGranted(alias, false);
            assertThat(new KeyChainAliasFuture(alias).get()).isEqualTo(alias);
            assertGranted(alias, true);
        } finally {
            // Delete regardless of whether the test succeeded.
            assertThat(mDevicePolicyManager.removeKeyPair(getWho(), alias)).isTrue();
        }
    }

    byte[] signDataWithKey(String algoIdentifier, PrivateKey privateKey) throws Exception {
        byte[] data = new String(""hello"").getBytes();
        Signature sign = Signature.getInstance(algoIdentifier);
        sign.initSign(privateKey);
        sign.update(data);
        return sign.sign();
    }

    void verifySignature(String algoIdentifier, PublicKey publicKey, byte[] signature)
            throws Exception {
        byte[] data = new String(""hello"").getBytes();
        Signature verify = Signature.getInstance(algoIdentifier);
        verify.initVerify(publicKey);
        verify.update(data);
        assertThat(verify.verify(signature)).isTrue();
    }

    void verifySignatureOverData(String algoIdentifier, KeyPair keyPair) throws Exception {
        verifySignature(algoIdentifier, keyPair.getPublic(),
                signDataWithKey(algoIdentifier, keyPair.getPrivate()));
    }

    private KeyGenParameterSpec buildRsaKeySpec(String alias, boolean useStrongBox) {
        return new KeyGenParameterSpec.Builder(
                alias,
                KeyProperties.PURPOSE_SIGN | KeyProperties.PURPOSE_VERIFY)
            .setKeySize(2048)
            .setDigests(KeyProperties.DIGEST_SHA256)
            .setSignaturePaddings(KeyProperties.SIGNATURE_PADDING_RSA_PSS,
                    KeyProperties.SIGNATURE_PADDING_RSA_PKCS1)
            .setIsStrongBoxBacked(useStrongBox)
            .build();
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.media.tv.tuner.cts.TunerTest"	"adoptShellPermissionIdentity"	"CtsTvTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/tv/src/android/media/tv/tuner/cts/TunerTest.java"	""	"/*
 *.
 */

package android.media.tv.tuner.cts;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

import android.content.Context;
import android.content.pm.PackageManager;
import android.media.tv.tuner.DemuxCapabilities;
import android.media.tv.tuner.Descrambler;
import android.media.tv.tuner.Lnb;
import android.media.tv.tuner.LnbCallback;
import android.media.tv.tuner.Tuner;
import android.media.tv.tuner.TunerVersionChecker;
import android.media.tv.tuner.dvr.DvrPlayback;
import android.media.tv.tuner.dvr.DvrRecorder;
import android.media.tv.tuner.dvr.OnPlaybackStatusChangedListener;
import android.media.tv.tuner.dvr.OnRecordStatusChangedListener;
import android.media.tv.tuner.filter.AlpFilterConfiguration;
import android.media.tv.tuner.filter.AudioDescriptor;
import android.media.tv.tuner.filter.AvSettings;
import android.media.tv.tuner.filter.DownloadEvent;
import android.media.tv.tuner.filter.DownloadSettings;
import android.media.tv.tuner.filter.Filter;
import android.media.tv.tuner.filter.FilterCallback;
import android.media.tv.tuner.filter.FilterConfiguration;
import android.media.tv.tuner.filter.FilterEvent;
import android.media.tv.tuner.filter.IpCidChangeEvent;
import android.media.tv.tuner.filter.IpFilterConfiguration;
import android.media.tv.tuner.filter.IpPayloadEvent;
import android.media.tv.tuner.filter.MediaEvent;
import android.media.tv.tuner.filter.MmtpFilterConfiguration;
import android.media.tv.tuner.filter.MmtpRecordEvent;
import android.media.tv.tuner.filter.PesEvent;
import android.media.tv.tuner.filter.PesSettings;
import android.media.tv.tuner.filter.RecordSettings;
import android.media.tv.tuner.filter.RestartEvent;
import android.media.tv.tuner.filter.ScramblingStatusEvent;
import android.media.tv.tuner.filter.SectionEvent;
import android.media.tv.tuner.filter.SectionSettingsWithSectionBits;
import android.media.tv.tuner.filter.SectionSettingsWithTableInfo;
import android.media.tv.tuner.filter.Settings;
import android.media.tv.tuner.filter.TemiEvent;
import android.media.tv.tuner.filter.TimeFilter;
import android.media.tv.tuner.filter.TlvFilterConfiguration;
import android.media.tv.tuner.filter.TsFilterConfiguration;
import android.media.tv.tuner.filter.TsRecordEvent;
import android.media.tv.tuner.frontend.AnalogFrontendCapabilities;
import android.media.tv.tuner.frontend.AnalogFrontendSettings;
import android.media.tv.tuner.frontend.Atsc3FrontendCapabilities;
import android.media.tv.tuner.frontend.Atsc3FrontendSettings;
import android.media.tv.tuner.frontend.Atsc3PlpInfo;
import android.media.tv.tuner.frontend.AtscFrontendCapabilities;
import android.media.tv.tuner.frontend.AtscFrontendSettings;
import android.media.tv.tuner.frontend.DtmbFrontendCapabilities;
import android.media.tv.tuner.frontend.DtmbFrontendSettings;
import android.media.tv.tuner.frontend.DvbcFrontendCapabilities;
import android.media.tv.tuner.frontend.DvbcFrontendSettings;
import android.media.tv.tuner.frontend.DvbsFrontendCapabilities;
import android.media.tv.tuner.frontend.DvbsFrontendSettings;
import android.media.tv.tuner.frontend.DvbtFrontendCapabilities;
import android.media.tv.tuner.frontend.DvbtFrontendSettings;
import android.media.tv.tuner.frontend.FrontendCapabilities;
import android.media.tv.tuner.frontend.FrontendInfo;
import android.media.tv.tuner.frontend.FrontendSettings;
import android.media.tv.tuner.frontend.FrontendStatus;
import android.media.tv.tuner.frontend.FrontendStatus.Atsc3PlpTuningInfo;
import android.media.tv.tuner.frontend.Isdbs3FrontendCapabilities;
import android.media.tv.tuner.frontend.Isdbs3FrontendSettings;
import android.media.tv.tuner.frontend.IsdbsFrontendCapabilities;
import android.media.tv.tuner.frontend.IsdbsFrontendSettings;
import android.media.tv.tuner.frontend.IsdbtFrontendCapabilities;
import android.media.tv.tuner.frontend.IsdbtFrontendSettings;
import android.media.tv.tuner.frontend.OnTuneEventListener;
import android.media.tv.tuner.frontend.ScanCallback;

import androidx.test.InstrumentationRegistry;
import androidx.test.filters.SmallTest;
import androidx.test.runner.AndroidJUnit4;

import com.android.compatibility.common.util.RequiredFeatureRule;

import org.junit.After;
import org.junit.Before;
import org.junit.Ignore;
import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executor;
import java.util.concurrent.TimeUnit;

@RunWith(AndroidJUnit4.class)
@SmallTest
public class TunerTest {
    private static final String TAG = ""MediaTunerTest"";

    @Rule
    public RequiredFeatureRule featureRule = new RequiredFeatureRule(
            PackageManager.FEATURE_TUNER);

    private static final int TIMEOUT_MS = 10000;

    private Context mContext;
    private Tuner mTuner;
    private CountDownLatch mLockLatch = new CountDownLatch(1);

    @Before
    public void setUp() throws Exception {
        mContext = InstrumentationRegistry.getTargetContext();
        InstrumentationRegistry
                .getInstrumentation().getUiAutomation().adoptShellPermissionIdentity();
        mTuner = new Tuner(mContext, null, 100);
    }

    @After
    public void tearDown() {
        if (mTuner != null) {
          mTuner.close();
          mTuner = null;
        }
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.media.tv.tuner.cts.TunerTest"	"testScanning"	"CtsTvTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/tv/src/android/media/tv/tuner/cts/TunerTest.java"	""	"public void testScanning() throws Exception {
        List<Integer> ids = mTuner.getFrontendIds();
        assertFalse(ids.isEmpty());
        for (int id : ids) {
            FrontendInfo info = mTuner.getFrontendInfoById(id);
            if (info != null) {
                mLockLatch = new CountDownLatch(1);
                int res = mTuner.scan(
                        createFrontendSettings(info),
                        Tuner.SCAN_TYPE_AUTO,
                        getExecutor(),
                        getScanCallback());
               assertEquals(Tuner.RESULT_SUCCESS, res);
               assertTrue(mLockLatch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
               res = mTuner.cancelScanning();
               assertEquals(Tuner.RESULT_SUCCESS, res);
            }
        }
        mLockLatch = null;
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.media.tv.tuner.cts.TunerTest"	"testShareFrontendFromTuner"	"CtsTvTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/tv/src/android/media/tv/tuner/cts/TunerTest.java"	""	"public void testShareFrontendFromTuner() throws Exception {
        Tuner other = new Tuner(mContext, null, 100);
        List<Integer> ids = other.getFrontendIds();
        assertFalse(ids.isEmpty());
        FrontendInfo info = other.getFrontendInfoById(ids.get(0));

        // call tune() to open frontend resource
        int res = other.tune(createFrontendSettings(info));
        assertEquals(Tuner.RESULT_SUCCESS, res);
        assertNotNull(other.getFrontendInfo());
        mTuner.shareFrontendFromTuner(other);
        other.close();
    }

    private boolean hasTuner() {
        return mContext.getPackageManager().hasSystemFeature(""android.hardware.tv.tuner"");
    }

    private Executor getExecutor() {
        return Runnable::run;
    }

    private LnbCallback getLnbCallback() {
        return new LnbCallback() {
            @Override
            public void onEvent(int lnbEventType) {}
            @Override
            public void onDiseqcMessage(byte[] diseqcMessage) {}
        };
    }

    private FilterCallback getFilterCallback() {
        return new FilterCallback() {
            @Override
            public void onFilterEvent(Filter filter, FilterEvent[] events) {
                for (FilterEvent e : events) {
                    if (e instanceof DownloadEvent) {
                        testDownloadEvent(filter, (DownloadEvent) e);
                    } else if (e instanceof IpPayloadEvent) {
                        testIpPayloadEvent(filter, (IpPayloadEvent) e);
                    } else if (e instanceof MediaEvent) {
                        testMediaEvent(filter, (MediaEvent) e);
                    } else if (e instanceof MmtpRecordEvent) {
                        testMmtpRecordEvent(filter, (MmtpRecordEvent) e);
                    } else if (e instanceof PesEvent) {
                        testPesEvent(filter, (PesEvent) e);
                    } else if (e instanceof SectionEvent) {
                        testSectionEvent(filter, (SectionEvent) e);
                    } else if (e instanceof TemiEvent) {
                        testTemiEvent(filter, (TemiEvent) e);
                    } else if (e instanceof TsRecordEvent) {
                        testTsRecordEvent(filter, (TsRecordEvent) e);
                    } else if (e instanceof ScramblingStatusEvent) {
                        testScramblingStatusEvent(filter, (ScramblingStatusEvent) e);
                    } else if (e instanceof IpCidChangeEvent) {
                        testIpCidChangeEvent(filter, (IpCidChangeEvent) e);
                    } else if (e instanceof RestartEvent) {
                        testRestartEvent(filter, (RestartEvent) e);
                    }
                }
            }
            @Override
            public void onFilterStatusChanged(Filter filter, int status) {}
        };
    }

    private void testDownloadEvent(Filter filter, DownloadEvent e) {
        e.getItemId();
        e.getMpuSequenceNumber();
        e.getItemFragmentIndex();
        e.getLastItemFragmentIndex();
        long length = e.getDataLength();
        if (length > 0) {
            byte[] buffer = new byte[(int) length];
            assertNotEquals(0, filter.read(buffer, 0, length));
        }
    }

    private void testIpPayloadEvent(Filter filter, IpPayloadEvent e) {
        long length = e.getDataLength();
        if (length > 0) {
            byte[] buffer = new byte[(int) length];
            assertNotEquals(0, filter.read(buffer, 0, length));
        }
    }

    private void testMediaEvent(Filter filter, MediaEvent e) {
        e.getStreamId();
        e.isPtsPresent();
        e.getPts();
        e.getDataLength();
        e.getOffset();
        e.getLinearBlock();
        e.isSecureMemory();
        e.getAvDataId();
        e.getAudioHandle();
        e.getMpuSequenceNumber();
        e.isPrivateData();
        AudioDescriptor ad = e.getExtraMetaData();
        if (ad != null) {
            ad.getAdFade();
            ad.getAdPan();
            ad.getAdVersionTextTag();
            ad.getAdGainCenter();
            ad.getAdGainFront();
            ad.getAdGainSurround();
        }
        e.release();
    }

    private void testMmtpRecordEvent(Filter filter, MmtpRecordEvent e) {
        e.getScHevcIndexMask();
        e.getDataLength();
        int mpuSequenceNumber = e.getMpuSequenceNumber();
        long pts = e.getPts();
        int firstMbInSlice = e.getFirstMacroblockInSlice();
        int tsIndexMask = e.getTsIndexMask();
        if (!TunerVersionChecker.isHigherOrEqualVersionTo(TunerVersionChecker.TUNER_VERSION_1_1)) {
            assertEquals(mpuSequenceNumber, Tuner.INVALID_MMTP_RECORD_EVENT_MPT_SEQUENCE_NUM);
            assertEquals(pts, Tuner.INVALID_TIMESTAMP);
            assertEquals(firstMbInSlice, Tuner.INVALID_FIRST_MACROBLOCK_IN_SLICE);
            assertEquals(tsIndexMask, 0);
        }
    }

    private void testPesEvent(Filter filter, PesEvent e) {
        e.getStreamId();
        e.getMpuSequenceNumber();
        long length = e.getDataLength();
        if (length > 0) {
            byte[] buffer = new byte[(int) length];
            assertNotEquals(0, filter.read(buffer, 0, length));
        }
    }

    private void testSectionEvent(Filter filter, SectionEvent e) {
        e.getTableId();
        e.getVersion();
        e.getSectionNumber();
        long length = e.getDataLength();
        if (length > 0) {
            byte[] buffer = new byte[(int) length];
            assertNotEquals(0, filter.read(buffer, 0, length));
        }
    }

    private void testTemiEvent(Filter filter, TemiEvent e) {
        e.getPts();
        e.getDescriptorTag();
        e.getDescriptorData();
    }

    private void testTsRecordEvent(Filter filter, TsRecordEvent e) {
        e.getPacketId();
        e.getTsIndexMask();
        e.getScIndexMask();
        e.getDataLength();
        long pts = e.getPts();
        int firstMbInSlice = e.getFirstMacroblockInSlice();
        if (!TunerVersionChecker.isHigherOrEqualVersionTo(TunerVersionChecker.TUNER_VERSION_1_1)) {
            assertEquals(pts, Tuner.INVALID_TIMESTAMP);
            assertEquals(firstMbInSlice, Tuner.INVALID_FIRST_MACROBLOCK_IN_SLICE);
        }
    }

    private void testScramblingStatusEvent(Filter filter, ScramblingStatusEvent e) {
        e.getScramblingStatus();
    }

    private void testIpCidChangeEvent(Filter filter, IpCidChangeEvent e) {
        e.getIpCid();
    }

    private void testRestartEvent(Filter filter, RestartEvent e) {
        e.getStartId();
    }

    private OnRecordStatusChangedListener getRecordListener() {
        return new OnRecordStatusChangedListener() {
            @Override
            public void onRecordStatusChanged(int status) {}
        };
    }

    private OnPlaybackStatusChangedListener getPlaybackListener() {
        return new OnPlaybackStatusChangedListener() {
            @Override
            public void onPlaybackStatusChanged(int status) {}
        };
    }

    private FrontendSettings createFrontendSettings(FrontendInfo info) {
            FrontendCapabilities caps = info.getFrontendCapabilities();
            int minFreq = info.getFrequencyRange().getLower();
            int maxFreq = info.getFrequencyRange().getUpper();
            FrontendCapabilities feCaps = info.getFrontendCapabilities();
            switch(info.getType()) {
                case FrontendSettings.TYPE_ANALOG: {
                    AnalogFrontendCapabilities analogCaps = (AnalogFrontendCapabilities) caps;
                    int signalType = getFirstCapable(analogCaps.getSignalTypeCapability());
                    int sif = getFirstCapable(analogCaps.getSifStandardCapability());
                    return AnalogFrontendSettings
                            .builder()
                            .setFrequency(minFreq)
                            .setSignalType(signalType)
                            .setSifStandard(sif)
                            .build();
                }
                case FrontendSettings.TYPE_ATSC3: {
                    Atsc3FrontendCapabilities atsc3Caps = (Atsc3FrontendCapabilities) caps;
                    int bandwidth = getFirstCapable(atsc3Caps.getBandwidthCapability());
                    int demod = getFirstCapable(atsc3Caps.getDemodOutputFormatCapability());
                    Atsc3FrontendSettings settings =
                            Atsc3FrontendSettings
                                    .builder()
                                    .setFrequency(minFreq)
                                    .setBandwidth(bandwidth)
                                    .setDemodOutputFormat(demod)
                                    .build();
                    settings.setEndFrequency(maxFreq);
                    return settings;
                }
                case FrontendSettings.TYPE_ATSC: {
                    AtscFrontendCapabilities atscCaps = (AtscFrontendCapabilities) caps;
                    int modulation = getFirstCapable(atscCaps.getModulationCapability());
                    return AtscFrontendSettings
                            .builder()
                            .setFrequency(minFreq)
                            .setModulation(modulation)
                            .build();
                }
                case FrontendSettings.TYPE_DVBC: {
                    DvbcFrontendCapabilities dvbcCaps = (DvbcFrontendCapabilities) caps;
                    int modulation = getFirstCapable(dvbcCaps.getModulationCapability());
                    int fec = getFirstCapable(dvbcCaps.getFecCapability());
                    int annex = getFirstCapable(dvbcCaps.getAnnexCapability());
                    DvbcFrontendSettings settings =
                            DvbcFrontendSettings
                                    .builder()
                                    .setFrequency(minFreq)
                                    .setModulation(modulation)
                                    .setInnerFec(fec)
                                    .setAnnex(annex)
                                    .build();
                    settings.setEndFrequency(maxFreq);
                    return settings;
                }
                case FrontendSettings.TYPE_DVBS: {
                    DvbsFrontendCapabilities dvbsCaps = (DvbsFrontendCapabilities) caps;
                    int modulation = getFirstCapable(dvbsCaps.getModulationCapability());
                    int standard = getFirstCapable(dvbsCaps.getStandardCapability());
                    DvbsFrontendSettings settings =
                            DvbsFrontendSettings
                                    .builder()
                                    .setFrequency(minFreq)
                                    .setModulation(modulation)
                                    .setStandard(standard)
                                    .build();
                    settings.setEndFrequency(maxFreq);
                    return settings;
                }
                case FrontendSettings.TYPE_DVBT: {
                    DvbtFrontendCapabilities dvbtCaps = (DvbtFrontendCapabilities) caps;
                    int transmission = getFirstCapable(dvbtCaps.getTransmissionModeCapability());
                    int bandwidth = getFirstCapable(dvbtCaps.getBandwidthCapability());
                    int constellation = getFirstCapable(dvbtCaps.getConstellationCapability());
                    int codeRate = getFirstCapable(dvbtCaps.getCodeRateCapability());
                    int hierarchy = getFirstCapable(dvbtCaps.getHierarchyCapability());
                    int guardInterval = getFirstCapable(dvbtCaps.getGuardIntervalCapability());
                    return DvbtFrontendSettings
                            .builder()
                            .setFrequency(minFreq)
                            .setTransmissionMode(transmission)
                            .setBandwidth(bandwidth)
                            .setConstellation(constellation)
                            .setHierarchy(hierarchy)
                            .setHighPriorityCodeRate(codeRate)
                            .setLowPriorityCodeRate(codeRate)
                            .setGuardInterval(guardInterval)
                            .setStandard(DvbtFrontendSettings.STANDARD_T)
                            .setMiso(false)
                            .build();
                }
                case FrontendSettings.TYPE_ISDBS3: {
                    Isdbs3FrontendCapabilities isdbs3Caps = (Isdbs3FrontendCapabilities) caps;
                    int modulation = getFirstCapable(isdbs3Caps.getModulationCapability());
                    int codeRate = getFirstCapable(isdbs3Caps.getCodeRateCapability());
                    return Isdbs3FrontendSettings
                            .builder()
                            .setFrequency(minFreq)
                            .setModulation(modulation)
                            .setCodeRate(codeRate)
                            .build();
                }
                case FrontendSettings.TYPE_ISDBS: {
                    IsdbsFrontendCapabilities isdbsCaps = (IsdbsFrontendCapabilities) caps;
                    int modulation = getFirstCapable(isdbsCaps.getModulationCapability());
                    int codeRate = getFirstCapable(isdbsCaps.getCodeRateCapability());
                    return IsdbsFrontendSettings
                            .builder()
                            .setFrequency(minFreq)
                            .setModulation(modulation)
                            .setCodeRate(codeRate)
                            .build();
                }
                case FrontendSettings.TYPE_ISDBT: {
                    IsdbtFrontendCapabilities isdbtCaps = (IsdbtFrontendCapabilities) caps;
                    int mode = getFirstCapable(isdbtCaps.getModeCapability());
                    int bandwidth = getFirstCapable(isdbtCaps.getBandwidthCapability());
                    int modulation = getFirstCapable(isdbtCaps.getModulationCapability());
                    int codeRate = getFirstCapable(isdbtCaps.getCodeRateCapability());
                    int guardInterval = getFirstCapable(isdbtCaps.getGuardIntervalCapability());
                    return IsdbtFrontendSettings
                            .builder()
                            .setFrequency(minFreq)
                            .setModulation(modulation)
                            .setBandwidth(bandwidth)
                            .setMode(mode)
                            .setCodeRate(codeRate)
                            .setGuardInterval(guardInterval)
                            .build();
                }
                case FrontendSettings.TYPE_DTMB: {
                    DtmbFrontendCapabilities dtmbCaps = (DtmbFrontendCapabilities) caps;
                    int modulation = getFirstCapable(dtmbCaps.getModulationCapability());
                    int transmissionMode = getFirstCapable(
                            dtmbCaps.getTransmissionModeCapability());
                    int guardInterval = getFirstCapable(dtmbCaps.getGuardIntervalCapability());
                    int timeInterleaveMode = getFirstCapable(
                            dtmbCaps.getTimeInterleaveModeCapability());
                    int codeRate = getFirstCapable(dtmbCaps.getCodeRateCapability());
                    int bandwidth = getFirstCapable(dtmbCaps.getBandwidthCapability());
                    DtmbFrontendSettings settings =
                            DtmbFrontendSettings
                                    .builder()
                                    .setFrequency(minFreq)
                                    .setModulation(modulation)
                                    .setTransmissionMode(transmissionMode)
                                    .setBandwidth(bandwidth)
                                    .setCodeRate(codeRate)
                                    .setGuardInterval(guardInterval)
                                    .setTimeInterleaveMode(timeInterleaveMode)
                                    .build();
                    settings.setEndFrequency(maxFreq);
                    return settings;
                }
                default:
                    break;
            }
        return null;
    }

    private int getFirstCapable(int caps) {
        if (caps == 0) return 0;
        int mask = 1;
        while ((mask & caps) == 0) {
            mask = mask << 1;
        }
        return (mask & caps);
    }

    private long getFirstCapable(long caps) {
        if (caps == 0) return 0;
        long mask = 1;
        while ((mask & caps) == 0) {
            mask = mask << 1;
        }
        return (mask & caps);
    }

    private ScanCallback getScanCallback() {
        return new ScanCallback() {
            @Override
            public void onLocked() {
                if (mLockLatch != null) {
                    mLockLatch.countDown();
                }
            }

            @Override
            public void onScanStopped() {}

            @Override
            public void onProgress(int percent) {}

            @Override
            public void onFrequenciesReported(int[] frequency) {}

            @Override
            public void onSymbolRatesReported(int[] rate) {}

            @Override
            public void onPlpIdsReported(int[] plpIds) {}

            @Override
            public void onGroupIdsReported(int[] groupIds) {}

            @Override
            public void onInputStreamIdsReported(int[] inputStreamIds) {}

            @Override
            public void onDvbsStandardReported(int dvbsStandard) {}

            @Override
            public void onDvbtStandardReported(int dvbtStandard) {}

            @Override
            public void onAnalogSifStandardReported(int sif) {}

            @Override
            public void onAtsc3PlpInfosReported(Atsc3PlpInfo[] atsc3PlpInfos) {
                for (Atsc3PlpInfo info : atsc3PlpInfos) {
                    if (info != null) {
                        info.getPlpId();
                        info.getLlsFlag();
                    }
                }
            }

            @Override
            public void onHierarchyReported(int hierarchy) {}

            @Override
            public void onSignalTypeReported(int signalType) {}

            @Override
            public void onModulationReported(int modulation) {
                ScanCallback.super.onModulationReported(modulation);
            }

            @Override
            public void onPriorityReported(boolean isHighPriority) {
                ScanCallback.super.onPriorityReported(isHighPriority);
            }

            @Override
            public void onDvbcAnnexReported(int dvbcAnnext) {
                ScanCallback.super.onDvbcAnnexReported(dvbcAnnext);
            }
        };
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.compatibility.common.util.ShellIdentityUtils"	"adoptShellPermissionIdentity"	""	"/home/gpoor/cts-12-source/cts/common/device-side/util-axt/src/com/android/compatibility/common/util/ShellIdentityUtils.java"	""	"public void test/*
 *.
 */

package com.android.compatibility.common.util;

import android.app.UiAutomation;

import androidx.test.InstrumentationRegistry;

import java.util.function.BiFunction;
import java.util.function.Supplier;

/**
 * Provides utility methods to invoke system and privileged APIs as the shell user.
 */
public class ShellIdentityUtils {

    /**
     * Utility interface to invoke a method against the target object.
     *
     * @param <T> the type returned by the invoked method.
     * @param <U> the type of the object against which the method is invoked.
     */
    public interface ShellPermissionMethodHelper<T, U> {
        /**
         * Invokes the method against the target object.
         *
         * @param targetObject the object against which the method should be invoked.
         * @return the result of the invoked method.
         */
        T callMethod(U targetObject);
    }

    /**
     * Utility interface to invoke a method against the target object.
     *
     * @param <U> the type of the object against which the method is invoked.
     */
    public interface ShellPermissionMethodHelperNoReturn<U> {
        /**
         * Invokes the method against the target object.
         *
         * @param targetObject the object against which the method should be invoked.
         */
        void callMethod(U targetObject);
    }

    /**
     * Utility interface to invoke a method against the target object that may throw an Exception.
     *
     * @param <U> the type of the object against which the method is invoked.
     */
    public interface ShellPermissionThrowableMethodHelper<T, U, E extends Throwable> {
        /**
         * Invokes the method against the target object.
         *
         * @param targetObject the object against which the method should be invoked.
         * @return the result of the target method.
         */
        T callMethod(U targetObject) throws E;
    }

    /**
     * Utility interface to invoke a method against the target object that may throw an Exception.
     *
     * @param <U> the type of the object against which the method is invoked.
     */
    public interface ShellPermissionThrowableMethodHelperNoReturn<U, E extends Throwable> {
        /**
         * Invokes the method against the target object.
         *
         * @param targetObject the object against which the method should be invoked.
         */
        void callMethod(U targetObject) throws E;
    }

    /**
     * Invokes the specified method on the targetObject as the shell user. The method can be invoked
     * as follows:
     *
     * {@code ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,
     *        (tm) -> tm.getDeviceId());}
     */
    public static <T, U> T invokeMethodWithShellPermissions(U targetObject,
            ShellPermissionMethodHelper<T, U> methodHelper) {
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            return methodHelper.callMethod(targetObject);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Invokes the specified method on the targetObject as the shell user with only the subset of
     * permissions specified. The method can be invoked as follows:
     *
     * {@code ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,
     *        (tm) -> tm.getDeviceId(), ""android.permission.READ_PHONE_STATE"");}
     */
    public static <T, U> T invokeMethodWithShellPermissions(U targetObject,
            ShellPermissionMethodHelper<T, U> methodHelper, String... permissions) {
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity(permissions);
            return methodHelper.callMethod(targetObject);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /** A three argument {@link java.util.function.Function}. */
    public interface TriFunction<T, U, V, R> {
        R apply(T t, U u, V v);
    }

    /** A four argument {@link java.util.function.Function}. */
    public interface QuadFunction<T, U, V, W, R> {
        R apply(T t, U u, V v, W w);
    }

    /**
     * Invokes the specified method wht arg1 and arg2, as the shell user
     * with only the subset of permissions specified. The method can be invoked as follows:
     *
     * {@code ShellIdentityUtils.invokeMethodWithShellPermissions(op, pers,
     *        mTelephonyManager::setNetworkSelectionModeManual(on, p),
     *        ""android.permission.MODIFY_PHONE_STATE"");}
     */
    public static <T, U, R> R invokeMethodWithShellPermissions(T arg1, U arg2,
            BiFunction<? super T, ? super U, ? extends R>  methodHelper, String... permissions) {
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity(permissions);
            return methodHelper.apply(arg1, arg2);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Invokes the specified method with arg1, arg2 and arg3, as the shell user
     * with only the subset of permissions specified. The method can be invoked as follows:
     *
     * {@code ShellIdentityUtils.invokeMethodWithShellPermissions(req, cb, exe,
     *        mTelephonyManager::requestNetworkScan,
     *        ""android.permission.MODIFY_PHONE_STATE"",
     *        ""android.permission.ACCESS_FINE_LOCATION"");}
     */
    public static <T, U, V, R> R invokeMethodWithShellPermissions(T arg1, U arg2, V arg3,
            TriFunction<? super T, ? super U, ? super V, ? extends R>  methodHelper,
            String... permissions) {
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity(permissions);
            return methodHelper.apply(arg1, arg2, arg3);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Invokes the specified method with arg1, arg2, arg3 and arg4, as the shell
     * user with only the subset of permissions specified. The method can be invoked as follows:
     *
     * {@code ShellIdentityUtils.invokeMethodWithShellPermissions(a, b, c, d,
     *        mTelephonyManager::requestSomething,
     *        ""android.permission.MODIFY_PHONE_STATE"",
     *        ""android.permission.ACCESS_FINE_LOCATION"");}
     */
    public static <T, U, V, W, R> R invokeMethodWithShellPermissions(T arg1, U arg2, V arg3, W arg4,
            QuadFunction<? super T, ? super U, ? super V, ? super W, ? extends R>  methodHelper,
            String... permissions) {
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity(permissions);
            return methodHelper.apply(arg1, arg2, arg3, arg4);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Invokes the specified method on the targetObject as the shell user with only the subset of
     * permissions specified. The method can be invoked as follows:
     *
     * {@code ShellIdentityUtils.invokeMethodWithShellPermissions(mRcsUceAdapter,
     *        (m) -> RcsUceAdapter::getUcePublishState, ImsException.class,
     *                     ""android.permission.READ_PRIVILEGED_PHONE_STATE"")}
     */
    public static <T, U, E extends Throwable> T invokeThrowableMethodWithShellPermissions(
            U targetObject, ShellPermissionThrowableMethodHelper<T, U, E> methodHelper,
            Class<E> clazz, String... permissions) throws E {
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity(permissions);
            return methodHelper.callMethod(targetObject);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Invokes the specified method on the targetObject as the shell user for only the permissions
     * specified. The method can be invoked as follows:
     *
     * {@code ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,
     *        (tm) -> tm.getDeviceId(), ""android.permission.READ_PHONE_STATE"");}
     */
    public static <U> void invokeMethodWithShellPermissionsNoReturn(
            U targetObject, ShellPermissionMethodHelperNoReturn<U> methodHelper,
            String... permissions) {
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity(permissions);
            methodHelper.callMethod(targetObject);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Invokes the specified throwable method on the targetObject as the shell user with only the
     * subset of permissions specified specified. The method can be invoked as follows:
     *
     * {@code ShellIdentityUtils.invokeMethodWithShellPermissions(mImsMmtelManager,
     *        (m) -> m.isSupported(...), ImsException.class);}
     */
    public static <U, E extends Throwable> void invokeThrowableMethodWithShellPermissionsNoReturn(
            U targetObject, ShellPermissionThrowableMethodHelperNoReturn<U, E> methodHelper,
            Class<E> clazz) throws E {
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            methodHelper.callMethod(targetObject);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Invokes the specified throwable method on the targetObject as the shell user with only the
     * subset of permissions specified specified. The method can be invoked as follows:
     *
     * {@code ShellIdentityUtils.invokeMethodWithShellPermissions(mImsMmtelManager,
     *        (m) -> m.isSupported(...), ImsException.class,
     *        ""android.permission.READ_PRIVILEGED_PHONE_STATE"");}
     */
    public static <U, E extends Throwable> void invokeThrowableMethodWithShellPermissionsNoReturn(
            U targetObject, ShellPermissionThrowableMethodHelperNoReturn<U, E> methodHelper,
            Class<E> clazz, String... permissions) throws E {
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity(permissions);
            methodHelper.callMethod(targetObject);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }


    /**
     * Invokes the specified method on the targetObject as the shell user. The method can be invoked
     * as follows:
     *
     * {@code ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,
     *        (tm) -> tm.getDeviceId());}
     */
    public static <U> void invokeMethodWithShellPermissionsNoReturn(
            U targetObject, ShellPermissionMethodHelperNoReturn<U> methodHelper) {
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            methodHelper.callMethod(targetObject);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Utility interface to invoke a static method.
     *
     * @param <T> the type returned by the invoked method.
     */
    public interface StaticShellPermissionMethodHelper<T> {
        /**
         * Invokes the static method.
         *
         * @return the result of the invoked method.
         */
        T callMethod();
    }

    /**
     * Invokes the specified static method as the shell user. This method can be invoked as follows:
     *
     * {@code ShellIdentityUtils.invokeStaticMethodWithShellPermissions(Build::getSerial));}
     */
    public static <T> T invokeStaticMethodWithShellPermissions(
            StaticShellPermissionMethodHelper<T> methodHelper) {
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            return methodHelper.callMethod();
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Drop the shell permission identity adopted by a previous call to
     * {@link UiAutomation#adoptShellPermissionIdentity()}.
     */
    public static void dropShellPermissionIdentity() {
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();

        uiAutomation.dropShellPermissionIdentity();
    }

    /**
     * Run an arbitrary piece of code while holding shell permissions.
     *
     * @param supplier an expression that performs the desired operation with shell permissions
     * @param <T> the return type of the expression
     * @return the return value of the expression
     */
    public static <T> T invokeWithShellPermissions(Supplier<T> supplier) {
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            return supplier.get();
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Run an arbitrary piece of code while holding shell permissions.
     *
     * @param runnable an expression that performs the desired operation with shell permissions
     * @return the return value of the expression
     */
    public static void invokeWithShellPermissions(Runnable runnable) {
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            runnable.run();
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.alarmmanager.cts.ExactAlarmsTest"	"denyListedChangesCanScheduleExactAlarms"	"CtsAlarmManagerTestCases"	"/home/gpoor/cts-12-source/cts/tests/AlarmManager/src/android/alarmmanager/cts/ExactAlarmsTest.java"	""	"public void denyListedChangesCanScheduleExactAlarms() throws Exception {
        mDeviceConfigHelper.with(""exact_alarm_deny_list"", sContext.getOpPackageName())
                .commitAndAwaitPropagation();
        assertFalse(mAlarmManager.canScheduleExactAlarms());

        mDeviceConfigHelper.without(""exact_alarm_deny_list"").commitAndAwaitPropagation();
        assertTrue(mAlarmManager.canScheduleExactAlarms());

    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.provider.cts.media.MediaStorePlacementTest"	"testIgnored"	"CtsProviderTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/provider/src/android/provider/cts/media/MediaStorePlacementTest.java"	""	"public void testIgnored() throws Exception {
        final Uri uri = ProviderTestUtils.stageMedia(R.drawable.scenery,
                mExternalImages, ""image/jpeg"");

        {
            final ContentValues values = new ContentValues();
            values.put(MediaColumns.SIZE, 0);
            assertEquals(0, mContentResolver.update(uri, values, null, null));
        }

        // Make sure shady paths can't be passed in
        for (String probe : new String[] {
                ""path/.to/dir"",
                "".dir"",
                ""path/../dir"",
        }) {
            final ContentValues values = new ContentValues();
            values.put(MediaColumns.RELATIVE_PATH, probe);
            try {
                mContentResolver.update(uri, values, null, null);
                fail();
            } catch (IllegalArgumentException expected) {
            }
        }
    }"	""	""	"probe"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.provider.cts.media.MediaStorePlacementTest"	"testRelated"	"CtsProviderTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/provider/src/android/provider/cts/media/MediaStorePlacementTest.java"	""	"public void testRelated() throws Exception {
        final Uri unusualUri = stageImageInAudio();

        // Normal file creation should fail (image in audio)
        mValues.put(MediaColumns.DISPLAY_NAME, ""edited"" + System.nanoTime());
        mValues.put(MediaColumns.MIME_TYPE, ""image/png"");
        mValues.put(MediaColumns.RELATIVE_PATH, Environment.DIRECTORY_ALARMS + ""/"");
        mValues.put(MediaColumns.IS_PENDING, 1);
        try {
            mContentResolver.insert(mExternalImages, mValues, mExtras);
            fail();
        } catch (Exception expected) {
        }

        // But if we leverage item already there, we can succeed
        mExtras.putParcelable(MediaStore.QUERY_ARG_RELATED_URI, unusualUri);
        final Uri probeUri = mContentResolver.insert(mExternalImages, mValues, mExtras);
        assertNotNull(probeUri);
        assertEquals(ProviderTestUtils.getRelativeFile(unusualUri).getParent(),
                ProviderTestUtils.getRelativeFile(probeUri).getParent());

        // And we should have edit and delete access, since we created it
        try (OutputStream out = mContentResolver.openOutputStream(probeUri)) {
            out.write(42);
        }

        // And we should be able to publish it
        mValues.clear();
        mValues.put(MediaColumns.IS_PENDING, 0);
        assertEquals(1, mContentResolver.update(probeUri, mValues, null));

        // And finally able to delete it
        assertEquals(1, mContentResolver.delete(probeUri, null));
    }"	""	""	"probe"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.provider.cts.media.MediaStorePlacementTest"	"testDirectory_InsideSandbox"	"CtsProviderTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/provider/src/android/provider/cts/media/MediaStorePlacementTest.java"	""	"public void testDirectory_InsideSandbox() throws Exception {
        Assume.assumeFalse(MediaStore.VOLUME_EXTERNAL.equals(mVolumeName));

        final File dir = ProviderTestUtils.getVolumePath(mVolumeName);
        final File file = ProviderTestUtils.stageFile(R.drawable.scenery, Environment.buildPath(dir,
                ""Android"", ""media"", ""android.provider.cts"", System.nanoTime() + "".jpg""));
        final Uri uri = ProviderTestUtils.scanFile(file);

        assertTrue(updatePlacement(uri,
                Optional.of(""Android/media/android.provider.cts/foo""), null));
        assertFalse(updatePlacement(uri,
                Optional.of(""Android/media/com.example/foo""), null));
        assertFalse(updatePlacement(uri,
                Optional.of(""DCIM""), null));
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.provider.cts.media.MediaStorePlacementTest"	"testRelated_InvalidPath"	"CtsProviderTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/provider/src/android/provider/cts/media/MediaStorePlacementTest.java"	""	"public void testRelated_InvalidPath() throws Exception {
        final Uri unusualUri = stageImageInAudio();

        // Normal file creation should fail (path not exact match)
        mValues.put(MediaColumns.DISPLAY_NAME, ""edited"" + System.nanoTime());
        mValues.put(MediaColumns.MIME_TYPE, ""image/jpeg"");
        mValues.put(MediaColumns.RELATIVE_PATH, Environment.DIRECTORY_ALARMS + ""/cts/"");
        mExtras.putParcelable(MediaStore.QUERY_ARG_RELATED_URI, unusualUri);
        try {
            mContentResolver.insert(mExternalImages, mValues, mExtras);
            fail();
        } catch (Exception expected) {
        }
    }

    private Uri stageImageInAudio() throws Exception {
        Assume.assumeFalse(MediaStore.VOLUME_EXTERNAL.equals(mVolumeName));

        final String displayName = ""cts"" + System.nanoTime() + "".jpg"";
        final File file = Environment.buildPath(ProviderTestUtils.getVolumePath(mVolumeName),
                Environment.DIRECTORY_ALARMS, displayName);
        return ProviderTestUtils.scanFileFromShell(
                ProviderTestUtils.stageFile(R.raw.scenery, file));
    }

    private boolean updatePlacement(Uri uri, Optional<String> path, Optional<String> displayName)
            throws Exception {
        final ContentValues values = new ContentValues();
        if (path != null) {
            values.put(MediaColumns.RELATIVE_PATH, path.orElse(null));
        }
        if (displayName != null) {
            values.put(MediaColumns.DISPLAY_NAME, displayName.orElse(null));
        }
        try {
            return (mContentResolver.update(uri, values, null, null) == 1);
        } catch (Exception tolerated) {
            return false;
        }
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.permission.cts.NoWifiStatePermissionTest"	"testGetConnectionInfo"	"CtsPermissionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NoWifiStatePermissionTest.java"	""	"public void testGetConnectionInfo() {
        try {
            mWifiManager.getConnectionInfo();
            fail(""WifiManager.getConnectionInfo didn't throw SecurityException as expected"");
        } catch (SecurityException e) {
            // expected
        }
    }

    /**
     * Verify that WifiManager#getScanResults() requires permissions.
     * <p>Requires Permission:
     *   {@link android.Manifest.permission#ACCESS_WIFI_STATE}.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.permission.cts.NoWifiStatePermissionTest"	"testGetScanResults"	"CtsPermissionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NoWifiStatePermissionTest.java"	""	"public void testGetScanResults() {
        try {
            mWifiManager.getScanResults();
            fail(""WifiManager.getScanResults didn't throw SecurityException as expected"");
        } catch (SecurityException e) {
            // expected
        }
    }

    /**
     * Verify that WifiManager#getDhcpInfo() requires permissions.
     * <p>Requires Permission:
     *   {@link android.Manifest.permission#ACCESS_WIFI_STATE}.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.permission.cts.NoWifiStatePermissionTest"	"testPingSupplicant"	"CtsPermissionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NoWifiStatePermissionTest.java"	""	"public void testPingSupplicant() {
        try {
            mWifiManager.pingSupplicant();
            fail(""WifiManager.pingSupplicant didn't throw SecurityException as expected"");
        } catch (SecurityException e) {
            // expected
        }
    }

    /**
     * Verify that WifiManager#startScan() requires permissions.
     * <p>Requires Permission:
     *   {@link android.Manifest.permission#CHANGE_WIFI_STATE}.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.permission.cts.NoWifiStatePermissionTest"	"testStartScan"	"CtsPermissionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NoWifiStatePermissionTest.java"	""	"public void testStartScan() {
        try {
            mWifiManager.startScan();
            fail(""WifiManager.startScan didn't throw SecurityException as expected"");
        } catch (SecurityException e) {
            // expected
        }
    }

    /**
     * Verify that WifiManager#setWifiEnabled() requires permissions.
     * <p>Requires Permission:
     *   {@link android.Manifest.permission#CHANGE_WIFI_STATE}.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.media.cts.SystemMediaRouter2Test"	"ArrayList"	"CtsMediaTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/SystemMediaRouter2Test.java"	""	"/*
 *.
 */

package android.media.cts;

import static android.content.Context.AUDIO_SERVICE;
import static android.media.MediaRoute2Info.FEATURE_LIVE_AUDIO;
import static android.media.MediaRoute2Info.PLAYBACK_VOLUME_VARIABLE;
import static android.media.cts.StubMediaRoute2ProviderService.FEATURE_SAMPLE;
import static android.media.cts.StubMediaRoute2ProviderService.FEATURE_SPECIAL;
import static android.media.cts.StubMediaRoute2ProviderService.ROUTE_ID1;
import static android.media.cts.StubMediaRoute2ProviderService.ROUTE_ID2;
import static android.media.cts.StubMediaRoute2ProviderService.ROUTE_ID3_SESSION_CREATION_FAILED;
import static android.media.cts.StubMediaRoute2ProviderService.ROUTE_ID4_TO_SELECT_AND_DESELECT;
import static android.media.cts.StubMediaRoute2ProviderService.ROUTE_ID5_TO_TRANSFER_TO;
import static android.media.cts.StubMediaRoute2ProviderService.ROUTE_ID_VARIABLE_VOLUME;
import static android.media.cts.StubMediaRoute2ProviderService.ROUTE_NAME2;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertSame;
import static org.junit.Assert.assertTrue;

import android.Manifest;
import android.app.UiAutomation;
import android.content.Context;
import android.media.AudioManager;
import android.media.MediaRoute2Info;
import android.media.MediaRouter2;
import android.media.MediaRouter2.ControllerCallback;
import android.media.MediaRouter2.RouteCallback;
import android.media.MediaRouter2.RoutingController;
import android.media.MediaRouter2.TransferCallback;
import android.media.MediaRouter2Manager;
import android.media.RouteDiscoveryPreference;
import android.media.RoutingSessionInfo;
import android.platform.test.annotations.AppModeFull;
import android.platform.test.annotations.LargeTest;
import android.text.TextUtils;

import androidx.test.InstrumentationRegistry;
import androidx.test.runner.AndroidJUnit4;

import com.android.compatibility.common.util.PollingCheck;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

@RunWith(AndroidJUnit4.class)
@AppModeFull(reason = ""The system should be able to bind to StubMediaRoute2ProviderService"")
@LargeTest
@NonMediaMainlineTest
public class SystemMediaRouter2Test {
    private static final String TAG = ""SystemMR2Test"";

    UiAutomation mUiAutomation;
    Context mContext;
    private MediaRouter2 mSystemRouter2ForCts;
    private MediaRouter2 mAppRouter2;

    private Executor mExecutor;
    private AudioManager mAudioManager;
    private StubMediaRoute2ProviderService mService;

    private static final int TIMEOUT_MS = 5000;
    private static final int WAIT_MS = 2000;

    private RouteCallback mAppRouterPlaceHolderCallback = new RouteCallback() {};

    private final List<RouteCallback> mRouteCallbacks = new ArrayList<>();
    private final List<TransferCallback> mTransferCallbacks = new ArrayList<>();

    public static final List<String> FEATURES_ALL = new ArrayList();
    public static final List<String> FEATURES_SPECIAL = new ArrayList();

    static {
        FEATURES_ALL.add(FEATURE_SAMPLE);
        FEATURES_ALL.add(FEATURE_SPECIAL);
        FEATURES_ALL.add(FEATURE_LIVE_AUDIO);

        FEATURES_SPECIAL.add(FEATURE_SPECIAL);
    }

    @Before
    public void setUp() throws Exception {
        mContext = InstrumentationRegistry.getTargetContext();
        mUiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        mUiAutomation.adoptShellPermissionIdentity(Manifest.permission.MEDIA_CONTENT_CONTROL);

        mExecutor = Executors.newSingleThreadExecutor();
        mAudioManager = (AudioManager) mContext.getSystemService(AUDIO_SERVICE);
        MediaRouter2TestActivity.startActivity(mContext);

        mSystemRouter2ForCts = MediaRouter2.getInstance(mContext, mContext.getPackageName());
        mSystemRouter2ForCts.startScan();

        mAppRouter2 = MediaRouter2.getInstance(mContext);
        // In order to make the system bind to the test service,
        // set a non-empty discovery preference.
        List<String> features = new ArrayList<>();
        features.add(""A test feature"");
        RouteDiscoveryPreference preference =
                new RouteDiscoveryPreference.Builder(features, false).build();
        mRouteCallbacks.add(mAppRouterPlaceHolderCallback);
        mAppRouter2.registerRouteCallback(mExecutor, mAppRouterPlaceHolderCallback, preference);

        new PollingCheck(TIMEOUT_MS) {
            @Override
            protected boolean check() {
                StubMediaRoute2ProviderService service =
                        StubMediaRoute2ProviderService.getInstance();
                if (service != null) {
                    mService = service;
                    return true;
                }
                return false;
            }
        }.run();
        mService.initializeRoutes();
        mService.publishRoutes();
    }

    @After
    public void tearDown() throws Exception {
        mSystemRouter2ForCts.stopScan();

        MediaRouter2TestActivity.finishActivity();
        if (mService != null) {
            mService.clear();
            mService = null;
        }

        // order matters (callbacks should be cleared at the last)
        releaseAllSessions();
        // unregister callbacks
        clearCallbacks();

        mUiAutomation.dropShellPermissionIdentity();
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.launcherapps.simpleapp.SimpleActivityStartService"	"KeyguardDismissCallback"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/SimpleApp/src/com/android/cts/launcherapps/simpleapp/SimpleActivityStartService.java"	""	"public void test/*
 *.
 */

package com.android.cts.launcherapps.simpleapp;

import android.app.Activity;
import android.app.KeyguardManager;
import android.app.KeyguardManager.KeyguardDismissCallback;
import android.content.Intent;
import android.os.Bundle;
import android.os.Handler;
import android.util.Log;

/**
 * Test being able to start a service (with no background check restrictions) as soon as
 * an activity is created.
 */
public class SimpleActivityStartService extends Activity {
    private static final String TAG = ""SimpleActivityStartService"";

    public static String ACTION_SIMPLE_ACTIVITY_START_SERVICE_RESULT =
            ""com.android.cts.launcherapps.simpleapp.SimpleActivityStartService.RESULT"";

    @Override
    protected void onCreate(Bundle icicle) {
        super.onCreate(icicle);
        getSystemService(KeyguardManager.class).requestDismissKeyguard(this,
                new KeyguardDismissCallback() {
            @Override
            public void onDismissCancelled() {
                Log.i(TAG, ""onDismissCancelled"");
            }

            @Override
            public void onDismissError() {
                Log.i(TAG, ""onDismissError"");
            }

            @Override
            public void onDismissSucceeded() {
                Log.i(TAG, ""onDismissSucceeded"");
            }
        });
        // No matter if the dismiss was successful or not, continue the test after 2000ms
        (new Handler()).postDelayed(()-> {
            attemptStartService();
            finish();
        }, 2000);
    }

    void attemptStartService() {
        Log.i(TAG, ""attemptStartService"");
        Intent reply = new Intent(ACTION_SIMPLE_ACTIVITY_START_SERVICE_RESULT);
        reply.setFlags(Intent.FLAG_RECEIVER_FOREGROUND);
        Intent serviceIntent = getIntent().getParcelableExtra(""service"");
        try {
            startService(serviceIntent);
        } catch (IllegalStateException e) {
            reply.putExtra(""result"", Activity.RESULT_CANCELED);
            sendBroadcast(reply);
            return;
        }
        reply.putExtra(""result"", Activity.RESULT_FIRST_USER);
        sendBroadcast(reply);
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.bluetooth.BleCocClientService"	"isEnabled"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/bluetooth/BleCocClientService.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.bluetooth;

import java.util.Arrays;
import java.util.List;
import java.util.Set;
import java.util.UUID;

import java.io.ByteArrayOutputStream;

import com.android.cts.verifier.R;

import android.app.Service;
import android.bluetooth.BluetoothAdapter;
import android.bluetooth.BluetoothDevice;
import android.bluetooth.BluetoothGatt;
import android.bluetooth.BluetoothGattCallback;
import android.bluetooth.BluetoothGattCharacteristic;
import android.bluetooth.BluetoothGattDescriptor;
import android.bluetooth.BluetoothGattService;
import android.bluetooth.BluetoothManager;
import android.bluetooth.BluetoothProfile;
import android.bluetooth.BluetoothSocket;
import android.bluetooth.le.BluetoothLeScanner;
import android.bluetooth.le.ScanCallback;
import android.bluetooth.le.ScanFilter;
import android.bluetooth.le.ScanResult;
import android.bluetooth.le.ScanSettings;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.Build;
import android.os.Handler;
import android.os.IBinder;
import android.os.Message;
import android.os.ParcelUuid;
import android.text.TextUtils;
import android.util.Log;
import android.widget.Toast;

public class BleCocClientService extends Service {

    public static final boolean DEBUG = true;
    public static final String TAG = ""BleCocClientService"";

    private static final int TRANSPORT_MODE_FOR_SECURE_CONNECTION = BluetoothDevice.TRANSPORT_LE;

    public static final String BLE_LE_CONNECTED =
            ""com.android.cts.verifier.bluetooth.BLE_LE_CONNECTED"";
    public static final String BLE_GOT_PSM =
            ""com.android.cts.verifier.bluetooth.BLE_GOT_PSM"";
    public static final String BLE_COC_CONNECTED =
            ""com.android.cts.verifier.bluetooth.BLE_COC_CONNECTED"";
    public static final String BLE_CONNECTION_TYPE_CHECKED =
            ""com.android.cts.verifier.bluetooth.BLE_CONNECTION_TYPE_CHECKED"";
    public static final String BLE_DATA_8BYTES_SENT =
            ""com.android.cts.verifier.bluetooth.BLE_DATA_8BYTES_SENT"";
    public static final String BLE_DATA_8BYTES_READ =
            ""com.android.cts.verifier.bluetooth.BLE_DATA_8BYTES_READ"";
    public static final String BLE_DATA_LARGEBUF_READ =
            ""com.android.cts.verifier.bluetooth.BLE_DATA_LARGEBUF_READ"";
    public static final String BLE_LE_DISCONNECTED =
            ""com.android.cts.verifier.bluetooth.BLE_LE_DISCONNECTED"";

    public static final String BLE_BLUETOOTH_MISMATCH_SECURE =
            ""com.android.cts.verifier.bluetooth.BLE_BLUETOOTH_MISMATCH_SECURE"";
    public static final String BLE_BLUETOOTH_MISMATCH_INSECURE =
            ""com.android.cts.verifier.bluetooth.BLE_BLUETOOTH_MISMATCH_INSECURE"";
    public static final String BLE_BLUETOOTH_DISABLED =
            ""com.android.cts.verifier.bluetooth.BLE_BLUETOOTH_DISABLED"";
    public static final String BLE_GATT_CONNECTED =
            ""com.android.cts.verifier.bluetooth.BLE_GATT_CONNECTED"";
    public static final String BLE_BLUETOOTH_DISCONNECTED =
            ""com.android.cts.verifier.bluetooth.BLE_BLUETOOTH_DISCONNECTED"";
    public static final String BLE_CLIENT_ERROR =
            ""com.android.cts.verifier.bluetooth.BLE_CLIENT_ERROR"";
    public static final String EXTRA_COMMAND =
            ""com.android.cts.verifier.bluetooth.EXTRA_COMMAND"";
    public static final String EXTRA_WRITE_VALUE =
            ""com.android.cts.verifier.bluetooth.EXTRA_WRITE_VALUE"";
    public static final String EXTRA_BOOL =
            ""com.android.cts.verifier.bluetooth.EXTRA_BOOL"";

    // Literal for Client Action
    public static final String BLE_COC_CLIENT_ACTION_LE_INSECURE_CONNECT =
            ""com.android.cts.verifier.bluetooth.BLE_COC_CLIENT_ACTION_LE_INSECURE_CONNECT"";
    public static final String BLE_COC_CLIENT_ACTION_LE_SECURE_CONNECT =
            ""com.android.cts.verifier.bluetooth.BLE_COC_CLIENT_ACTION_LE_SECURE_CONNECT"";
    public static final String BLE_COC_CLIENT_ACTION_GET_PSM =
            ""com.android.cts.verifier.bluetooth.BLE_COC_CLIENT_ACTION_GET_PSM"";
    public static final String BLE_COC_CLIENT_ACTION_COC_CLIENT_CONNECT =
            ""com.android.cts.verifier.bluetooth.BLE_COC_CLIENT_ACTION_COC_CLIENT_CONNECT"";
    public static final String BLE_COC_CLIENT_ACTION_CHECK_CONNECTION_TYPE =
            ""com.android.cts.verifier.bluetooth.BLE_COC_CLIENT_ACTION_CHECK_CONNECTION_TYPE"";
    public static final String BLE_COC_CLIENT_ACTION_SEND_DATA_8BYTES =
            ""com.android.cts.verifier.bluetooth.BLE_COC_CLIENT_ACTION_SEND_DATA_8BYTES"";
    public static final String BLE_COC_CLIENT_ACTION_READ_DATA_8BYTES =
            ""com.android.cts.verifier.bluetooth.BLE_COC_CLIENT_ACTION_READ_DATA_8BYTES"";
    public static final String BLE_COC_CLIENT_ACTION_EXCHANGE_DATA =
            ""com.android.cts.verifier.bluetooth.BLE_COC_CLIENT_ACTION_EXCHANGE_DATA"";
    public static final String BLE_COC_CLIENT_ACTION_CLIENT_CONNECT =
            ""com.android.cts.verifier.bluetooth.BLE_COC_CLIENT_ACTION_CLIENT_CONNECT"";
    public static final String BLE_COC_CLIENT_ACTION_CLIENT_CONNECT_SECURE =
            ""com.android.cts.verifier.bluetooth.BLE_COC_CLIENT_ACTION_CLIENT_CONNECT_SECURE"";
    public static final String BLE_CLIENT_ACTION_CLIENT_DISCONNECT =
            ""com.android.cts.verifier.bluetooth.BLE_CLIENT_ACTION_CLIENT_DISCONNECT"";

    private static final UUID SERVICE_UUID =
            UUID.fromString(""00009999-0000-1000-8000-00805f9b34fb"");

    /**
     * UUID of the GATT Read Characteristics for LE_PSM value.
     */
    public static final UUID LE_PSM_CHARACTERISTIC_UUID =
            UUID.fromString(""2d410339-82b6-42aa-b34e-e2e01df8cc1a"");

    public static final String WRITE_VALUE = ""CLIENT_TEST"";
    private static final String NOTIFY_VALUE = ""NOTIFY_TEST"";
    private int mBleState = BluetoothProfile.STATE_DISCONNECTED;
    private static final int EXECUTION_DELAY = 1500;

    // current test category
    private String mCurrentAction;

    private BluetoothManager mBluetoothManager;
    private BluetoothAdapter mBluetoothAdapter;
    private BluetoothDevice mDevice;
    private BluetoothGatt mBluetoothGatt;
    private BluetoothLeScanner mScanner;
    private Handler mHandler;
    private boolean mSecure;
    private boolean mValidityService;
    private int mPsm;
    private BluetoothChatService mChatService;
    private int mNextReadExpectedLen = -1;
    private String mNextReadCompletionIntent;
    private int mTotalReadLen = 0;
    private byte mNextReadByte;
    private int mNextWriteExpectedLen = -1;
    private String mNextWriteCompletionIntent = null;

    // Handler for communicating task with peer.
    private TestTaskQueue mTaskQueue;

    @Override
    public void onCreate() {
        super.onCreate();

        registerReceiver(mBondStatusReceiver,
                         new IntentFilter(BluetoothDevice.ACTION_BOND_STATE_CHANGED));

        mBluetoothManager = (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE);
        mBluetoothAdapter = mBluetoothManager.getAdapter();
        mScanner = mBluetoothAdapter.getBluetoothLeScanner();
        mHandler = new Handler();

        mTaskQueue = new TestTaskQueue(getClass().getName() + ""_taskHandlerThread"");
    }

    @Override
    public int onStartCommand(final Intent intent, int flags, int startId) {
        if (!mBluetoothAdapter.isEnabled()) {
            notifyBluetoothDisabled();
        } else {
            mTaskQueue.addTask(new Runnable() {
                @Override
                public void run() {
                    onTestFinish(intent.getAction());
                }
            }, EXECUTION_DELAY);
        }
        return START_NOT_STICKY;
    }

    private void onTestFinish(String action) {
        mCurrentAction = action;
        if (mCurrentAction != null) {
            switch (mCurrentAction) {
                case BLE_COC_CLIENT_ACTION_LE_INSECURE_CONNECT:
                    mSecure = false;
                    startScan();
                    break;
                case BLE_COC_CLIENT_ACTION_LE_SECURE_CONNECT:
                    mSecure = true;
                    startScan();
                    break;
                case BLE_COC_CLIENT_ACTION_GET_PSM:
                    startLeDiscovery();
                    break;
                case BLE_COC_CLIENT_ACTION_COC_CLIENT_CONNECT:
                    leCocClientConnect();
                    break;
                case BLE_COC_CLIENT_ACTION_CHECK_CONNECTION_TYPE:
                    leCheckConnectionType();
                    break;
                case BLE_COC_CLIENT_ACTION_SEND_DATA_8BYTES:
                    sendData8bytes();
                    break;
                case BLE_COC_CLIENT_ACTION_READ_DATA_8BYTES:
                    readData8bytes();
                    break;
                case BLE_COC_CLIENT_ACTION_EXCHANGE_DATA:
                    sendDataLargeBuf();
                    break;
                case BLE_CLIENT_ACTION_CLIENT_DISCONNECT:
                    if (mBluetoothGatt != null) {
                        mBluetoothGatt.disconnect();
                    }
                    if (mChatService != null) {
                        mChatService.stop();
                    }
                    break;
                default:
                    Log.e(TAG, ""Error: Unhandled or invalid action="" + mCurrentAction);
            }
        }
    }

    @Override
    public IBinder onBind(Intent intent) {
        return null;
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        if (mBluetoothGatt != null) {
            mBluetoothGatt.disconnect();
            mBluetoothGatt.close();
            mBluetoothGatt = null;
        }
        stopScan();
        unregisterReceiver(mBondStatusReceiver);

        if (mChatService != null) {
            mChatService.stop();
        }

        mTaskQueue.quit();
    }

    public static BluetoothGatt connectGatt(BluetoothDevice device, Context context,
                                            boolean autoConnect, boolean isSecure,
                                            BluetoothGattCallback callback) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
            if (isSecure) {
                if (TRANSPORT_MODE_FOR_SECURE_CONNECTION == BluetoothDevice.TRANSPORT_AUTO) {
                    Toast.makeText(context, ""connectGatt(transport=AUTO)"", Toast.LENGTH_SHORT)
                    .show();
                } else {
                    Toast.makeText(context, ""connectGatt(transport=LE)"", Toast.LENGTH_SHORT).show();
                }
                return device.connectGatt(context, autoConnect, callback,
                                          TRANSPORT_MODE_FOR_SECURE_CONNECTION);
            } else {
                Toast.makeText(context, ""connectGatt(transport=LE)"", Toast.LENGTH_SHORT).show();
                return device.connectGatt(context, autoConnect, callback,
                                          BluetoothDevice.TRANSPORT_LE);
            }
        } else {
            Toast.makeText(context, ""connectGatt"", Toast.LENGTH_SHORT).show();
            return device.connectGatt(context, autoConnect, callback);
        }
    }

    private void readCharacteristic(UUID uuid) {
        BluetoothGattCharacteristic characteristic = getCharacteristic(uuid);
        if (characteristic != null) {
            mBluetoothGatt.readCharacteristic(characteristic);
        }
    }

    private void notifyError(String message) {
        showMessage(message);
        Log.e(TAG, message);

        Intent intent = new Intent(BLE_CLIENT_ERROR);
        sendBroadcast(intent);
    }

    private void notifyMismatchSecure() {
        Intent intent = new Intent(BLE_BLUETOOTH_MISMATCH_SECURE);
        sendBroadcast(intent);
    }

    private void notifyMismatchInsecure() {
        Intent intent = new Intent(BLE_BLUETOOTH_MISMATCH_INSECURE);
        sendBroadcast(intent);
    }

    private void notifyBluetoothDisabled() {
        Intent intent = new Intent(BLE_BLUETOOTH_DISABLED);
        sendBroadcast(intent);
    }

    private void notifyConnected() {
        showMessage(""Bluetooth LE GATT connected"");
        Intent intent = new Intent(BLE_LE_CONNECTED);
        sendBroadcast(intent);
    }

    private void startLeDiscovery() {
        // Start Service Discovery
        if (mBluetoothGatt != null && mBleState == BluetoothProfile.STATE_CONNECTED) {
            mBluetoothGatt.discoverServices();
        } else {
            showMessage(""Bluetooth LE GATT not connected."");
        }
    }

    private void notifyDisconnected() {
        showMessage(""Bluetooth LE disconnected"");
        Intent intent = new Intent(BLE_BLUETOOTH_DISCONNECTED);
        sendBroadcast(intent);
    }

    private void notifyServicesDiscovered() {
        showMessage(""Service discovered"");
        // Find the LE_COC_PSM characteristics
        if (DEBUG) {
            Log.d(TAG, ""notifyServicesDiscovered: Next step is to read the PSM char."");
        }
        readCharacteristic(LE_PSM_CHARACTERISTIC_UUID);
    }

    private BluetoothGattService getService() {
        BluetoothGattService service = null;

        if (mBluetoothGatt != null) {
            service = mBluetoothGatt.getService(SERVICE_UUID);
            if (service == null) {
                showMessage(""GATT Service not found"");
            }
        }
        return service;
    }

    private BluetoothGattCharacteristic getCharacteristic(UUID uuid) {
        BluetoothGattCharacteristic characteristic = null;

        BluetoothGattService service = getService();
        if (service != null) {
            characteristic = service.getCharacteristic(uuid);
            if (characteristic == null) {
                showMessage(""Characteristic not found"");
            }
        }
        return characteristic;
    }

    private void showMessage(final String msg) {
        mHandler.post(new Runnable() {
            public void run() {
                Toast.makeText(BleCocClientService.this, msg, Toast.LENGTH_SHORT).show();
            }
        });
    }

    private final BluetoothGattCallback mGattCallbacks = new BluetoothGattCallback() {
        @Override
        public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) {
            if (DEBUG) {
                Log.d(TAG, ""onConnectionStateChange: status="" + status + "", newState="" + newState);
            }
            if (status == BluetoothGatt.GATT_SUCCESS) {
                if (newState == BluetoothProfile.STATE_CONNECTED) {
                    mBleState = newState;
                    int bondState = gatt.getDevice().getBondState();
                    boolean bonded = false;
                    BluetoothDevice target = gatt.getDevice();
                    Set<BluetoothDevice> pairedDevices = mBluetoothAdapter.getBondedDevices();
                    if (!pairedDevices.isEmpty()) {
                        for (BluetoothDevice device : pairedDevices) {
                            if (device.getAddress().equals(target.getAddress())) {
                                bonded = true;
                                break;
                            }
                        }
                    }
                    if (mSecure && ((bondState == BluetoothDevice.BOND_NONE) || !bonded)) {
                        // not pairing and execute Secure Test
                        Log.e(TAG, ""BluetoothGattCallback.onConnectionStateChange: ""
                              + ""Not paired but execute secure test"");
                        mBluetoothGatt.disconnect();
                        notifyMismatchSecure();
                    } else if (!mSecure && ((bondState != BluetoothDevice.BOND_NONE) || bonded)) {
                        // already pairing and execute Insecure Test
                        Log.e(TAG, ""BluetoothGattCallback.onConnectionStateChange: ""
                              + ""Paired but execute insecure test"");
                        mBluetoothGatt.disconnect();
                        notifyMismatchInsecure();
                    } else {
                        notifyConnected();
                    }
                } else if (status == BluetoothProfile.STATE_DISCONNECTED) {
                    mBleState = newState;
                    mSecure = false;
                    mBluetoothGatt.close();
                    notifyDisconnected();
                }
            } else {
                showMessage(""Failed to connect: "" + status + "" , newState = "" + newState);
                mBluetoothGatt.close();
                mBluetoothGatt = null;
            }
        }

        @Override
        public void onServicesDiscovered(BluetoothGatt gatt, int status) {
            if (DEBUG) {
                Log.d(TAG, ""onServicesDiscovered: status="" + status);
            }
            if ((status == BluetoothGatt.GATT_SUCCESS) &&
                (mBluetoothGatt.getService(SERVICE_UUID) != null)) {
                notifyServicesDiscovered();
            }
        }

        @Override
        public void onCharacteristicRead(BluetoothGatt gatt,
                BluetoothGattCharacteristic characteristic, int status) {
            UUID uid = characteristic.getUuid();
            if (DEBUG) {
                Log.d(TAG, ""onCharacteristicRead: status="" + status + "", uuid="" + uid);
            }
            if (status == BluetoothGatt.GATT_SUCCESS) {
                String value = characteristic.getStringValue(0);
                if (characteristic.getUuid().equals(LE_PSM_CHARACTERISTIC_UUID)) {
                    mPsm = characteristic.getIntValue(BluetoothGattCharacteristic.FORMAT_UINT8, 0);
                    if (DEBUG) {
                        Log.d(TAG, ""onCharacteristicRead: reading PSM="" + mPsm);
                    }
                    Intent intent = new Intent(BLE_GOT_PSM);
                    sendBroadcast(intent);
                } else {
                    if (DEBUG) {
                        Log.d(TAG, ""onCharacteristicRead: Note: unknown uuid="" + uid);
                    }
                }
            } else if (status == BluetoothGatt.GATT_READ_NOT_PERMITTED) {
                notifyError(""Not Permission Read: "" + status + "" : "" + uid);
            } else if (status == BluetoothGatt.GATT_INSUFFICIENT_AUTHENTICATION) {
                notifyError(""Not Authentication Read: "" + status + "" : "" + uid);
            } else {
                notifyError(""Failed to read characteristic: "" + status + "" : "" + uid);
            }
        }
    };

    private final ScanCallback mScanCallback = new ScanCallback() {
        @Override
        public void onScanResult(int callbackType, ScanResult result) {
            if (mBluetoothGatt == null) {
                // verify the validity of the advertisement packet.
                mValidityService = false;
                List<ParcelUuid> uuids = result.getScanRecord().getServiceUuids();
                for (ParcelUuid uuid : uuids) {
                    if (uuid.getUuid().equals(BleCocServerService.ADV_COC_SERVICE_UUID)) {
                        if (DEBUG) {
                            Log.d(TAG, ""onScanResult: Found ADV with LE CoC Service UUID."");
                        }
                        mValidityService = true;
                        break;
                    }
                }
                if (mValidityService) {
                    stopScan();

                    BluetoothDevice device = result.getDevice();
                    if (DEBUG) {
                        Log.d(TAG, ""onScanResult: Found ADV with CoC UUID on device=""
                              + device);
                    }
                    if (mSecure) {
                        if (device.getBondState() != BluetoothDevice.BOND_BONDED) {
                            if (!device.createBond()) {
                                notifyError(""Failed to call create bond"");
                            }
                        } else {
                            mDevice = device;
                            mBluetoothGatt = connectGatt(result.getDevice(), BleCocClientService.this, false,
                                                         mSecure, mGattCallbacks);
                        }
                    } else {
                        mDevice = device;
                        mBluetoothGatt = connectGatt(result.getDevice(), BleCocClientService.this, false, mSecure,
                                                     mGattCallbacks);
                    }
                } else {
                    notifyError(""No valid service in Advertisement"");
                }
            }
        }
    };

    private boolean checkReadBufContent(byte[] buf, int len) {
        // Check that the content is correct
        for (int i = 0; i < len; i++) {
            if (buf[i] != mNextReadByte) {
                Log.e(TAG, ""handleMessageRead: Error: wrong byte content. buf[""
                      + i + ""]="" + buf[i] + "" not equal to "" + mNextReadByte);
                return false;
            }
            mNextReadByte++;
        }
        return true;
    }

    private void handleMessageRead(Message msg) {
        byte[] buf = (byte[])msg.obj;
        int len = msg.arg1;
        if (len <= 0) {
            return;
        }
        mTotalReadLen += len;
        if (DEBUG) {
            Log.d(TAG, ""handleMessageRead: receive buffer of length="" + len + "", mTotalReadLen=""
                  + mTotalReadLen + "", mNextReadExpectedLen="" + mNextReadExpectedLen);
        }

        if (mNextReadExpectedLen == mTotalReadLen) {
            if (!checkReadBufContent(buf, len)) {
                mNextReadExpectedLen = -1;
                return;
            }
            showMessage(""Read "" + len + "" bytes"");
            if (DEBUG) {
                Log.d(TAG, ""handleMessageRead: broadcast intent "" + mNextReadCompletionIntent);
            }
            Intent intent = new Intent(mNextReadCompletionIntent);
            sendBroadcast(intent);
            mTotalReadLen = 0;
            if (mNextReadCompletionIntent.equals(BLE_DATA_8BYTES_READ)) {
                // The server will not wait for any signal to send out the next bunch of data, after
                // it finishes sending the first 8 bytes. That means if we set the expectation
                // asynchronously, the data could come before that, so we have to do that here.
                readDataLargeBuf();
            } else {
                mNextReadExpectedLen = -1;
                mNextReadCompletionIntent = null;
            }
        } else if (mNextReadExpectedLen > mTotalReadLen) {
            if (!checkReadBufContent(buf, len)) {
                mNextReadExpectedLen = -1;
                return;
            }
        } else if (mNextReadExpectedLen < mTotalReadLen) {
            Log.e(TAG, ""handleMessageRead: Unexpected receive buffer of length="" + len
                  + "", expected len="" + mNextReadExpectedLen);
        }
    }

    private void sendMessage(byte[] buf) {
        mChatService.write(buf);
    }

    private void handleMessageWrite(Message msg) {
        byte[] buffer = (byte[]) msg.obj;
        int len = buffer.length;

        showMessage(""LE Coc Client wrote "" + len + "" bytes"");
        if (len == mNextWriteExpectedLen) {
            if (mNextWriteCompletionIntent != null) {
                Intent intent = new Intent(mNextWriteCompletionIntent);
                sendBroadcast(intent);
            }
        } else {
            Log.d(TAG, ""handleMessageWrite: unrecognized length="" + len);
        }
    }

    private class ChatHandler extends Handler {
        @Override
        public void handleMessage(Message msg) {
            super.handleMessage(msg);
            if (DEBUG) {
                Log.d(TAG, ""ChatHandler.handleMessage: msg="" + msg);
            }
            int state = msg.arg1;
            switch (msg.what) {
            case BluetoothChatService.MESSAGE_STATE_CHANGE:
                if (state == BluetoothChatService.STATE_CONNECTED) {
                    // LE CoC is established
                    notifyLeCocClientConnected();
                }
                break;
            case BluetoothChatService.MESSAGE_READ:
                handleMessageRead(msg);
                break;
            case BluetoothChatService.MESSAGE_WRITE:
                handleMessageWrite(msg);
                break;
            }
        }
    }

    private void notifyLeCocClientConnected() {
        if (DEBUG) {
            Log.d(TAG, ""notifyLeCocClientConnected: device="" + mDevice + "", mSecure="" + mSecure);
        }
        showMessage(""Bluetooth LE Coc connected"");
        Intent intent = new Intent(BLE_COC_CONNECTED);
        sendBroadcast(intent);
    }

    private void leCocClientConnect() {
        if (DEBUG) {
            Log.d(TAG, ""leCocClientConnect: device="" + mDevice + "", mSecure="" + mSecure);
        }
        if (mDevice == null) {
            Log.e(TAG, ""leCocClientConnect: mDevice is null"");
            return;
        }
        // Construct BluetoothChatService with useBle=true parameter
        mChatService = new BluetoothChatService(this, new ChatHandler(), true);
        mChatService.connect(mDevice, mSecure, mPsm);
    }

    private void leCheckConnectionType() {
        if (mChatService == null) {
            Log.e(TAG, ""leCheckConnectionType: no LE Coc connection"");
            return;
        }
        int type = mChatService.getSocketConnectionType();
        if (type != BluetoothSocket.TYPE_L2CAP) {
            Log.e(TAG, ""leCheckConnectionType: invalid connection type="" + type);
            return;
        }
        showMessage(""LE Coc Connection Type Checked"");
        Intent intent = new Intent(BLE_CONNECTION_TYPE_CHECKED);
        sendBroadcast(intent);
    }

    private void sendData8bytes() {
        if (DEBUG) Log.d(TAG, ""sendData8bytes"");

        final byte[] buf = new byte[]{1, 2, 3, 4, 5, 6, 7, 8};
        mNextWriteExpectedLen = 8;
        mNextWriteCompletionIntent = BLE_DATA_8BYTES_SENT;
        sendMessage(buf);
    }

    private void sendDataLargeBuf() {
        final int len = BleCocServerService.TEST_DATA_EXCHANGE_BUFSIZE;
        if (DEBUG) Log.d(TAG, ""sendDataLargeBuf of size="" + len);

        byte[] buf = new byte[len];
        for (int i = 0; i < len; i++) {
            buf[i] = (byte)(i + 1);
        }
        mNextWriteExpectedLen = len;
        mNextWriteCompletionIntent = null;
        sendMessage(buf);
    }

    private void readData8bytes() {
        mNextReadExpectedLen = 8;
        mNextReadCompletionIntent = BLE_DATA_8BYTES_READ;
        mNextReadByte = 1;
    }

    private void readDataLargeBuf() {
        mNextReadExpectedLen = BleCocServerService.TEST_DATA_EXCHANGE_BUFSIZE;
        mNextReadCompletionIntent = BLE_DATA_LARGEBUF_READ;
        mNextReadByte = 1;
    }

    private void startScan() {
        if (DEBUG) Log.d(TAG, ""startScan"");
        List<ScanFilter> filter = Arrays.asList(new ScanFilter.Builder().setServiceUuid(
                new ParcelUuid(BleCocServerService.ADV_COC_SERVICE_UUID)).build());
        ScanSettings setting = new ScanSettings.Builder()
                .setScanMode(ScanSettings.SCAN_MODE_LOW_LATENCY).build();
        mScanner.startScan(filter, setting, mScanCallback);
    }

    private void stopScan() {
        if (DEBUG) Log.d(TAG, ""stopScan"");
        if (mScanner != null) {
            mScanner.stopScan(mScanCallback);
        }
    }

    private final BroadcastReceiver mBondStatusReceiver = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            if (intent.getAction().equals(BluetoothDevice.ACTION_BOND_STATE_CHANGED)) {
                BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
                int state = intent.getIntExtra(BluetoothDevice.EXTRA_BOND_STATE,
                                               BluetoothDevice.BOND_NONE);
                switch (state) {
                    case BluetoothDevice.BOND_BONDED:
                        if (mBluetoothGatt == null) {
                            if (DEBUG) {
                                Log.d(TAG, ""onReceive:BOND_BONDED: calling connectGatt. device=""
                                             + device + "", mSecure="" + mSecure
                                             + "", mDevice="" + mDevice);
                            }
                            if (mDevice == null) {
                                mDevice = device;
                            }

                            mBluetoothGatt = connectGatt(mDevice, BleCocClientService.this, false,
                                                         mSecure, mGattCallbacks);
                        }
                        break;
                    case BluetoothDevice.BOND_NONE:
                        notifyError(""Failed to create bond"");
                        break;
                    case BluetoothDevice.BOND_BONDING:
                        // fall through
                    default:
                        // wait for next state
                        break;
                }
            }
        }
    };
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.bluetooth.BleAdvertiserTestActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/bluetooth/BleAdvertiserTestActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.bluetooth;

import android.app.AlertDialog;
import android.app.Dialog;
import android.bluetooth.BluetoothAdapter;
import android.content.DialogInterface;
import android.os.Bundle;

import com.android.cts.verifier.ManifestTestListAdapter;
import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;

import java.util.ArrayList;
import java.util.List;

public class BleAdvertiserTestActivity extends PassFailButtons.TestListActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.pass_fail_list);
        setPassFailButtonClickListeners();
        setInfoResources(R.string.ble_advertiser_test_name, R.string.ble_advertiser_test_info, -1);

        BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
        List<String> disabledTest = new ArrayList<String>();
        if (adapter == null || !adapter.isOffloadedFilteringSupported()) {
            disabledTest.add(
                    ""com.android.cts.verifier.bluetooth.BleAdvertiserHardwareScanFilterActivity."");
        }

        setTestListAdapter(new ManifestTestListAdapter(this, getClass().getName(),
                disabledTest.toArray(new String[disabledTest.size()])));
        if (!adapter.isEnabled()) {
            new AlertDialog.Builder(this)
                    .setTitle(R.string.ble_bluetooth_disable_title)
                    .setMessage(R.string.ble_bluetooth_disable_message)
                    .setOnCancelListener(new Dialog.OnCancelListener() {
                        @Override
                        public void onCancel(DialogInterface dialog) {
                            finish();
                        }
                    })
                    .create().show();
        }
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.compatibility.common.deviceinfo.StorageDeviceInfo"	"isExternalStorageEmulated"	""	"/home/gpoor/cts-12-source/cts/common/device-side/device-info/src/com/android/compatibility/common/deviceinfo/StorageDeviceInfo.java"	""	"public void test/*
 *.
 */
package com.android.compatibility.common.deviceinfo;

import android.os.Environment;
import android.util.Log;

import com.android.compatibility.common.util.DeviceInfoStore;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

/**
 * Storage device info collector.
 */
public class StorageDeviceInfo extends DeviceInfo {
    private static final String TAG = ""StorageDeviceInfo"";

    @Override
    protected void collectDeviceInfo(DeviceInfoStore store) throws Exception {
        int total = 0;
        total = Math.max(total, getContext().getExternalCacheDirs().length);
        total = Math.max(total, getContext().getExternalFilesDirs(null).length);
        total = Math.max(
                total, getContext().getExternalFilesDirs(Environment.DIRECTORY_PICTURES).length);
        total = Math.max(total, getContext().getObbDirs().length);

        int emulated = 0;
        int physical = 0;
        if (Environment.isExternalStorageEmulated()) {
            if (total == 1) {
                emulated = 1;
            } else {
                emulated = 1;
                physical = total - 1;
            }
        } else {
            physical = total;
        }

        store.addResult(""num_physical"", physical);
        store.addResult(""num_emulated"", emulated);

        store.addListResult(""raw_partition"", scanPartitions());
    }

    private List<String> scanPartitions() {
        List<String> partitionList = new ArrayList<>();
        try {
            Process df = new ProcessBuilder(""df -k"").start();
            Scanner scanner = new Scanner(df.getInputStream());
            try {
                while (scanner.hasNextLine()) {
                    partitionList.add(scanner.nextLine());
                }
            } finally {
                scanner.close();
            }
        } catch (Exception e) {
            Log.w(TAG, Log.getStackTraceString(e));
        }
        return partitionList;
    }

}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.text.method.cts.PasswordTransformationMethodTest"	"isFocused"	"CtsTextTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/text/src/android/text/method/cts/PasswordTransformationMethodTest.java"	""	"/*
 *.
 */

package android.text.method.cts;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertSame;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.mockito.Mockito.any;
import static org.mockito.Mockito.anyInt;
import static org.mockito.Mockito.atLeastOnce;
import static org.mockito.Mockito.reset;
import static org.mockito.Mockito.spy;
import static org.mockito.Mockito.verify;

import android.app.Instrumentation;
import android.app.UiAutomation;
import android.os.ParcelFileDescriptor;
import android.provider.Settings.SettingNotFoundException;
import android.provider.Settings.System;
import android.text.method.PasswordTransformationMethod;
import android.util.TypedValue;
import android.view.KeyCharacterMap;
import android.widget.Button;
import android.widget.EditText;
import android.widget.LinearLayout;
import android.widget.LinearLayout.LayoutParams;

import androidx.test.InstrumentationRegistry;
import androidx.test.filters.MediumTest;
import androidx.test.rule.ActivityTestRule;
import androidx.test.runner.AndroidJUnit4;

import com.android.compatibility.common.util.CtsKeyEventUtil;
import com.android.compatibility.common.util.PollingCheck;

import org.junit.After;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.io.FileInputStream;
import java.io.InputStream;
import java.util.Scanner;

/**
 * Test {@link PasswordTransformationMethod}.
 */
@MediumTest
@RunWith(AndroidJUnit4.class)
public class PasswordTransformationMethodTest {
    private static final int EDIT_TXT_ID = 1;

    /** original text */
    private static final String TEST_CONTENT = ""test content"";

    /** text after transformation: ************(12 dots) */
    private static final String TEST_CONTENT_TRANSFORMED =
        ""\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022"";

    private Instrumentation mInstrumentation;
    private CtsActivity mActivity;
    private int mPasswordPrefBackUp;
    private boolean isPasswordPrefSaved;
    private PasswordTransformationMethod mMethod;
    private EditText mEditText;
    private CharSequence mTransformedText;

    @Rule
    public ActivityTestRule<CtsActivity> mActivityRule = new ActivityTestRule<>(CtsActivity.class);

    @Before
    public void setup() throws Throwable {
        mActivity = mActivityRule.getActivity();
        PollingCheck.waitFor(1000, mActivity::hasWindowFocus);
        mInstrumentation = InstrumentationRegistry.getInstrumentation();
        mMethod = spy(new PasswordTransformationMethod());

        mActivityRule.runOnUiThread(() -> {
            EditText editText = new EditTextNoIme(mActivity);
            editText.setTextSize(TypedValue.COMPLEX_UNIT_SP, 10);
            editText.setId(EDIT_TXT_ID);
            editText.setTransformationMethod(mMethod);
            Button button = new Button(mActivity);
            LinearLayout layout = new LinearLayout(mActivity);
            layout.setOrientation(LinearLayout.VERTICAL);
            layout.addView(editText, new LayoutParams(LayoutParams.MATCH_PARENT,
                    LayoutParams.WRAP_CONTENT));
            layout.addView(button, new LayoutParams(LayoutParams.MATCH_PARENT,
                    LayoutParams.WRAP_CONTENT));
            mActivity.setContentView(layout);
            editText.requestFocus();
        });
        mInstrumentation.waitForIdleSync();

        mEditText = (EditText) mActivity.findViewById(EDIT_TXT_ID);
        assertTrue(mEditText.isFocused());

        enableAppOps();
        savePasswordPref();
        switchShowPassword(true);
    }

    @After
    public void teardown() {
        resumePasswordPref();
    }

    private void enableAppOps() {
        UiAutomation uiAutomation = mInstrumentation.getUiAutomation();

        StringBuilder cmd = new StringBuilder();
        cmd.append(""appops set "");
        cmd.append(mActivity.getPackageName());
        cmd.append("" android:write_settings allow"");
        uiAutomation.executeShellCommand(cmd.toString());

        StringBuilder query = new StringBuilder();
        query.append(""appops get "");
        query.append(mActivity.getPackageName());
        query.append("" android:write_settings"");
        String queryStr = query.toString();

        String result = ""No operations."";
        while (result.contains(""No operations"")) {
            ParcelFileDescriptor pfd = uiAutomation.executeShellCommand(queryStr);
            InputStream inputStream = new FileInputStream(pfd.getFileDescriptor());
            result = convertStreamToString(inputStream);
        }
    }

    private String convertStreamToString(InputStream is) {
        try (Scanner scanner = new Scanner(is).useDelimiter(""\\A"")) {
            return scanner.hasNext() ? scanner.next() : """";
        }
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.nfc.TagVerifierActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/nfc/TagVerifierActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.nfc;

import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;
import com.android.cts.verifier.nfc.tech.MifareUltralightTagTester;
import com.android.cts.verifier.nfc.tech.NdefTagTester;
import com.android.cts.verifier.nfc.tech.TagTester;
import com.android.cts.verifier.nfc.tech.TagVerifier;
import com.android.cts.verifier.nfc.tech.TagVerifier.Result;

import android.app.AlertDialog;
import android.app.Dialog;
import android.app.PendingIntent;
import android.app.ProgressDialog;
import android.content.DialogInterface;
import android.content.Intent;
import android.nfc.NfcAdapter;
import android.nfc.NfcManager;
import android.nfc.Tag;
import android.nfc.tech.MifareUltralight;
import android.nfc.tech.Ndef;
import android.os.AsyncTask;
import android.os.Bundle;
import android.util.Log;
import android.widget.ArrayAdapter;
import android.widget.TextView;
import android.widget.Toast;

/**
 * Test activity for reading and writing NFC tags using different technologies.
 * First, it asks the user to write some random data to the tag. Then it asks
 * the user to scan that tag again to verify that the data was properly written
 * and read back.
 */
public class TagVerifierActivity<T> extends PassFailButtons.ListActivity {

    static final String TAG = TagVerifierActivity.class.getSimpleName();

    /** Non-optional argument specifying the tag technology to be used to read and write tags. */
    static final String EXTRA_TECH = ""tech"";

    private static final int NFC_NOT_ENABLED_DIALOG_ID = 1;
    private static final int TESTABLE_TAG_DISCOVERED_DIALOG_ID = 2;
    private static final int TESTABLE_TAG_REMINDER_DIALOG_ID = 3;
    private static final int WRITE_PROGRESS_DIALOG_ID = 4;
    private static final int READ_PROGRESS_DIALOG_ID = 5;
    private static final int VERIFY_RESULT_DIALOG_ID = 6;

    // Arguments used for the dialog showing what was written to the tag and read from the tag.
    private static final String EXPECTED_CONTENT_ID = ""expectedContent"";
    private static final String ACTUAL_CONTENT_ID = ""actualContent"";
    private static final String IS_MATCH_ID = ""isMatch"";

    // The test activity has two states - writing data to a tag and then verifying it.
    private static final int WRITE_STEP = 0;
    private static final int VERIFY_STEP = 1;

    private NfcAdapter mNfcAdapter;
    private PendingIntent mPendingIntent;
    private Class<?> mTechClass;

    private int mStep;
    private TagTester mTagTester;
    private TagVerifier mTagVerifier;
    private Tag mTag;
    private ArrayAdapter<String> mTechListAdapter;
    private TextView mEmptyText;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.nfc_tag);
        setInfoResources(R.string.nfc_tag_verifier, R.string.nfc_tag_verifier_info, 0);
        setPassFailButtonClickListeners();
        getPassButton().setEnabled(false);

        parseIntentExtras();
        if (mTechClass != null) {
            mTagTester = getTagTester(mTechClass);

            mEmptyText = (TextView) findViewById(android.R.id.empty);

            mTechListAdapter = new ArrayAdapter<String>(this, android.R.layout.simple_list_item_1);
            setListAdapter(mTechListAdapter);

            NfcManager nfcManager = (NfcManager) getSystemService(NFC_SERVICE);
            mNfcAdapter = nfcManager.getDefaultAdapter();
            mPendingIntent = PendingIntent.getActivity(this, 0, new Intent(this, getClass())
                    .addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP), PendingIntent.FLAG_MUTABLE_UNAUDITED);

            goToWriteStep();
        } else {
            finish();
        }
    }

    private void parseIntentExtras() {
        try {
            String tech = getIntent().getStringExtra(EXTRA_TECH);
            if (tech != null) {
                mTechClass = Class.forName(tech);
            }
        } catch (ClassNotFoundException e) {
            Log.e(TAG, ""Couldn't find tech for class"", e);
        }
    }

    @Override
    protected void onResume() {
        super.onResume();
        if (!mNfcAdapter.isEnabled()) {
            showDialog(NFC_NOT_ENABLED_DIALOG_ID);
        }

        mNfcAdapter.enableForegroundDispatch(this, mPendingIntent, null, null);
    }

    @Override
    protected void onPause() {
        super.onPause();
        mNfcAdapter.disableForegroundDispatch(this);
    }

    private TagTester getTagTester(Class<?> techClass) {
        if (Ndef.class.equals(techClass)) {
            return new NdefTagTester(this);
        } else if (MifareUltralight.class.equals(techClass)) {
            return new MifareUltralightTagTester();
        } else {
            throw new IllegalArgumentException(""Unsupported technology: "" + techClass);
        }
    }

    @Override
    protected void onNewIntent(Intent intent) {
        Tag tag = intent.getParcelableExtra(NfcAdapter.EXTRA_TAG);
        if (tag != null) {
            mTag = tag;
            updateTechListAdapter(tag);
            switch (mStep) {
                case WRITE_STEP:
                    handleWriteStep(tag);
                    break;

                case VERIFY_STEP:
                    handleVerifyStep();
                    break;
            }
        }
    }

    private void handleWriteStep(Tag tag) {
        if (mTagTester.isTestableTag(tag)) {
            brutallyDismissDialog(TESTABLE_TAG_REMINDER_DIALOG_ID);
            showDialog(TESTABLE_TAG_DISCOVERED_DIALOG_ID);
        } else {
            brutallyDismissDialog(TESTABLE_TAG_DISCOVERED_DIALOG_ID);
            showDialog(TESTABLE_TAG_REMINDER_DIALOG_ID);
        }
    }

    private void brutallyDismissDialog(int id) {
        try {
            dismissDialog(id);
        } catch (IllegalArgumentException e) {
            // Don't care if it hasn't been shown before...
        }
    }

    private void handleVerifyStep() {
        new VerifyTagTask().execute(mTag);
    }

    private void updateTechListAdapter(Tag tag) {
        mEmptyText.setText(R.string.nfc_no_tech);
        String[] techList = tag.getTechList();
        mTechListAdapter.clear();
        for (String tech : techList) {
            mTechListAdapter.add(tech);
        }
    }

    class WriteTagTask extends AsyncTask<Tag, Void, TagVerifier> {

        @Override
        protected void onPreExecute() {
            super.onPreExecute();
            showDialog(WRITE_PROGRESS_DIALOG_ID);
        }

        @Override
        protected TagVerifier doInBackground(Tag... tags) {
            try {
                return mTagTester.writeTag(tags[0]);
            } catch (Exception e) {
                Log.e(TAG, ""Error writing NFC tag..."", e);
                return null;
            }
        }

        @Override
        protected void onPostExecute(TagVerifier tagVerifier) {
            dismissDialog(WRITE_PROGRESS_DIALOG_ID);
            mTagVerifier = tagVerifier;
            if (tagVerifier != null) {
                goToVerifyStep();
            } else {
                Toast.makeText(TagVerifierActivity.this, R.string.nfc_writing_tag_error,
                        Toast.LENGTH_SHORT).show();
                goToWriteStep();
            }
        }
    }

    private void goToWriteStep() {
        mStep = WRITE_STEP;
        mEmptyText.setText(getString(R.string.nfc_scan_tag, mTechClass.getSimpleName()));
        mTechListAdapter.clear();
    }

    private void goToVerifyStep() {
        mStep = VERIFY_STEP;
        mEmptyText.setText(getString(R.string.nfc_scan_tag_again, mTechClass.getSimpleName()));
        mTechListAdapter.clear();
    }

    class VerifyTagTask extends AsyncTask<Tag, Void, Result> {

        @Override
        protected void onPreExecute() {
            super.onPreExecute();
            showDialog(READ_PROGRESS_DIALOG_ID);
        }

        @Override
        protected Result doInBackground(Tag... tags) {
            try {
                return mTagVerifier.verifyTag(tags[0]);
            } catch (Exception e) {
                Log.e(TAG, ""Error verifying NFC tag..."", e);
                return null;
            }
        }

        @Override
        protected void onPostExecute(Result result) {
            super.onPostExecute(result);
            dismissDialog(READ_PROGRESS_DIALOG_ID);
            mTagVerifier = null;
            if (result != null) {
                getPassButton().setEnabled(result.isMatch());

                Bundle args = new Bundle();
                args.putCharSequence(EXPECTED_CONTENT_ID, result.getExpectedContent());
                args.putCharSequence(ACTUAL_CONTENT_ID, result.getActualContent());
                args.putBoolean(IS_MATCH_ID, result.isMatch());
                showDialog(VERIFY_RESULT_DIALOG_ID, args);

                goToWriteStep();
            } else {
                Toast.makeText(TagVerifierActivity.this, R.string.nfc_reading_tag_error,
                        Toast.LENGTH_SHORT).show();
                goToWriteStep();
            }
        }
    }

    @Override
    public Dialog onCreateDialog(int id, Bundle args) {
        switch (id) {
            case NFC_NOT_ENABLED_DIALOG_ID:
                return NfcDialogs.createNotEnabledDialog(this);

            case TESTABLE_TAG_DISCOVERED_DIALOG_ID:
                return createTestableTagDiscoveredDialog();

            case TESTABLE_TAG_REMINDER_DIALOG_ID:
                return createTestableTagReminderDialog();

            case WRITE_PROGRESS_DIALOG_ID:
                return createWriteProgressDialog();

            case READ_PROGRESS_DIALOG_ID:
                return createReadProgressDialog();

            case VERIFY_RESULT_DIALOG_ID:
                return createVerifyResultDialog();

            default:
                return super.onCreateDialog(id, args);
        }
    }

    private AlertDialog createTestableTagDiscoveredDialog() {
        return new AlertDialog.Builder(this)
                .setIcon(android.R.drawable.ic_dialog_info)
                .setTitle(R.string.nfc_write_tag_title)
                .setMessage(R.string.nfc_write_tag_message)
                .setPositiveButton(android.R.string.ok, new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                        new WriteTagTask().execute(mTag);
                    }
                })
                .setOnCancelListener(new DialogInterface.OnCancelListener() {
                    @Override
                    public void onCancel(DialogInterface dialog) {
                        goToWriteStep();
                    }
                })
                .show();
    }

    private AlertDialog createTestableTagReminderDialog() {
        return new AlertDialog.Builder(this)
                .setIcon(android.R.drawable.ic_dialog_alert)
                .setTitle(R.string.nfc_wrong_tag_title)
                .setMessage(getString(R.string.nfc_scan_tag, mTechClass.getSimpleName()))
                .setPositiveButton(android.R.string.ok, null)
                .show();
    }

    private ProgressDialog createWriteProgressDialog() {
        ProgressDialog dialog = new ProgressDialog(this);
        dialog.setMessage(getString(R.string.nfc_writing_tag));
        return dialog;
    }

    private ProgressDialog createReadProgressDialog() {
        ProgressDialog dialog = new ProgressDialog(this);
        dialog.setMessage(getString(R.string.nfc_reading_tag));
        return dialog;
    }

    private AlertDialog createVerifyResultDialog() {
        // Placeholder title and message that will be set properly in onPrepareDialog
        return new AlertDialog.Builder(this)
                .setIcon(android.R.drawable.ic_dialog_alert)
                .setTitle(R.string.result_failure)
                .setMessage("""")
                .setPositiveButton(android.R.string.ok, null)
                .create();
    }

    @Override
    protected void onPrepareDialog(int id, Dialog dialog, Bundle args) {
        switch (id) {
            case VERIFY_RESULT_DIALOG_ID:
                prepareVerifyResultDialog(dialog, args);
                break;

            default:
                super.onPrepareDialog(id, dialog, args);
                break;
        }
    }

    private void prepareVerifyResultDialog(Dialog dialog, Bundle args) {
        CharSequence expectedContent = args.getCharSequence(EXPECTED_CONTENT_ID);
        CharSequence actualContent = args.getCharSequence(ACTUAL_CONTENT_ID);
        boolean isMatch = args.getBoolean(IS_MATCH_ID);

        AlertDialog alert = (AlertDialog) dialog;
        alert.setTitle(isMatch
                ? R.string.result_success
                : R.string.result_failure);
        alert.setMessage(getString(R.string.nfc_result_message, expectedContent, actualContent));
    }

    @Override
    public String getTestId() {
        return getTagTestId(mTechClass);
    }

    static String getTagTestId(Class<?> primaryTech) {
        return NfcTestActivity.class.getName() + ""_"" + primaryTech.getSimpleName();
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.security.cts.MotionEventTest"	"testActionOutsideDoesNotContainedObscuredInformation"	"CtsSecurityTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/security/src/android/security/cts/MotionEventTest.java"	""	"public void testActionOutsideDoesNotContainedObscuredInformation() throws Throwable {
        enableAppOps();
        final OnTouchListener listener = new OnTouchListener();
        final WindowManager wm = mActivity.getSystemService(WindowManager.class);
        WindowManager.LayoutParams wmlp = new WindowManager.LayoutParams(
                WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY,
                WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE |
                        WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH |
                        WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE);

        FutureTask<View> addViewTask = new FutureTask<>(() -> {
            final Point size = new Point();
            wm.getDefaultDisplay().getSize(size);

            wmlp.width = size.x / 4;
            wmlp.height = size.y / 4;
            wmlp.gravity = Gravity.TOP | Gravity.LEFT;
            wmlp.setTitle(mActivity.getPackageName());

            ViewGroup.LayoutParams vglp = new ViewGroup.LayoutParams(
                    ViewGroup.LayoutParams.MATCH_PARENT,
                    ViewGroup.LayoutParams.MATCH_PARENT);

            View v = new View(mActivity);
            v.setOnTouchListener(listener);
            v.setBackgroundColor(Color.GREEN);
            v.setLayoutParams(vglp);
            wm.addView(v, wmlp);

            wmlp.gravity = Gravity.TOP | Gravity.RIGHT;

            v = new View(mActivity);
            v.setBackgroundColor(Color.BLUE);
            v.setOnTouchListener(listener);
            v.setLayoutParams(vglp);

            wm.addView(v, wmlp);
            return v;
        });
        mActivity.runOnUiThread(addViewTask);
        View view = addViewTask.get(5, TimeUnit.SECONDS);

        // Wait for a layout pass to be certain the view is on the screen
        // before getting the location and injecting touches.
        WidgetTestUtils.runOnMainAndLayoutSync(mActivityRule, view, null /*runnable*/,
                true /*forceLayout*/);

        // This ensures the window is visible, where the code above ensures
        // the view is on screen.
        mActivityRule.runOnUiThread(() -> {
            // This will force WindowManager to relayout, ensuring the
            // transaction to show the window are sent to the graphics code.
            wm.updateViewLayout(view, wmlp);
        });

        // Find the position inside the main activity and outside of the overlays.
        FutureTask<Point> clickLocationTask = new FutureTask<>(() -> {
            final int[] viewLocation = new int[2];
            final View decorView = mActivity.getWindow().getDecorView();
            decorView.getLocationOnScreen(viewLocation);
            // Set y position to the center of the view, to make sure it is away from the status bar
            return new Point(viewLocation[0], viewLocation[1] + decorView.getHeight() / 2);
        });
        mActivity.runOnUiThread(clickLocationTask);
        Point viewLocation = clickLocationTask.get(5, TimeUnit.SECONDS);
        injectTap(viewLocation.x, viewLocation.y);

        List<MotionEvent> outsideEvents = listener.getOutsideEvents();

        if (isRunningInVR()) {
            // In VR mode we should be prevented from seeing any events.
            assertEquals(0, outsideEvents.size());
        } else {
            assertEquals(2, outsideEvents.size());
            for (MotionEvent e : outsideEvents) {
                assertEquals(0, e.getFlags() & MotionEvent.FLAG_WINDOW_IS_OBSCURED);
            }
        }
    }


    private void enableAppOps() {
        StringBuilder cmd = new StringBuilder();
        cmd.append(""appops set "");
        cmd.append(mInstrumentation.getContext().getPackageName());
        cmd.append("" android:system_alert_window allow"");
        mInstrumentation.getUiAutomation().executeShellCommand(cmd.toString());

        StringBuilder query = new StringBuilder();
        query.append(""appops get "");
        query.append(mInstrumentation.getContext().getPackageName());
        query.append("" android:system_alert_window"");
        String queryStr = query.toString();

        String result;
        do {
            ParcelFileDescriptor pfd =
                    mInstrumentation.getUiAutomation().executeShellCommand(queryStr);
            InputStream inputStream = new FileInputStream(pfd.getFileDescriptor());
            result = convertStreamToString(inputStream);
        } while (result.contains(""No operations""));
    }

    private String convertStreamToString(InputStream is) {
        try (Scanner s = new Scanner(is).useDelimiter(""\\A"")) {
            return s.hasNext() ? s.next() : """";
        }
    }

    private void injectTap(int x, int y) {
        long downTime = SystemClock.uptimeMillis();
        injectEvent(MotionEvent.ACTION_DOWN, x, y, downTime);
        injectEvent(MotionEvent.ACTION_UP, x, y, downTime);
    }

    private void injectEvent(int action, int x, int y, long downTime) {
        final UiAutomation automation = mInstrumentation.getUiAutomation();
        final long eventTime = SystemClock.uptimeMillis();
        MotionEvent event = MotionEvent.obtain(downTime, eventTime, action, x, y, 0);
        event.setSource(InputDevice.SOURCE_TOUCHSCREEN);
        automation.injectInputEvent(event, true);
        event.recycle();
    }

    private static class OnTouchListener implements View.OnTouchListener {
        private List<MotionEvent> mOutsideEvents;

        public OnTouchListener() {
            mOutsideEvents = new ArrayList<>();
        }

        public boolean onTouch(View v, MotionEvent e) {
            if (e.getAction() == MotionEvent.ACTION_OUTSIDE) {
                mOutsideEvents.add(MotionEvent.obtain(e));
            }
            return true;
        }

        public List<MotionEvent> getOutsideEvents() {
            return mOutsideEvents;
        }
    }

    private boolean isRunningInVR() {
        final Context context = InstrumentationRegistry.getTargetContext();
        return (context.getResources().getConfiguration().uiMode &
                Configuration.UI_MODE_TYPE_MASK) == Configuration.UI_MODE_TYPE_VR_HEADSET;
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.acceleration.cts.HardwareAccelerationTest"	"testIsHardwareAccelerated"	"CtsAccelerationTestCases"	"/home/gpoor/cts-12-source/cts/tests/acceleration/src/android/acceleration/cts/HardwareAccelerationTest.java"	""	"public void testIsHardwareAccelerated() {
        // Hardware acceleration should be available on devices with GL ES 2 or higher...
        if (getGlEsVersion(mActivity) >= 2) {
            // Both of the views are attached to a hardware accelerated window
            assertTrue(mHardwareView.isHardwareAccelerated());
            assertTrue(mSoftwareView.isHardwareAccelerated());
            assertTrue(mManualHardwareView.isHardwareAccelerated());
            assertTrue(mManualSoftwareView.isHardwareAccelerated());

            assertTrue(mHardwareView.isCanvasHardwareAccelerated());
            assertFalse(mSoftwareView.isCanvasHardwareAccelerated());
            assertTrue(mManualHardwareView.isCanvasHardwareAccelerated());
            assertFalse(mManualSoftwareView.isCanvasHardwareAccelerated());
        } else {
            assertFalse(mHardwareView.isHardwareAccelerated());
            assertFalse(mSoftwareView.isHardwareAccelerated());
            assertFalse(mManualHardwareView.isHardwareAccelerated());
            assertFalse(mManualSoftwareView.isHardwareAccelerated());

            assertFalse(mHardwareView.isCanvasHardwareAccelerated());
            assertFalse(mSoftwareView.isCanvasHardwareAccelerated());
            assertFalse(mManualHardwareView.isCanvasHardwareAccelerated());
            assertFalse(mManualSoftwareView.isCanvasHardwareAccelerated());
        }
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.acceleration.cts.WindowFlagHardwareAccelerationTest"	"testIsHardwareAccelerated"	"CtsAccelerationTestCases"	"/home/gpoor/cts-12-source/cts/tests/acceleration/src/android/acceleration/cts/WindowFlagHardwareAccelerationTest.java"	""	"public void testIsHardwareAccelerated() {
        // Hardware acceleration should be available on devices with GL ES 2 or higher...
        if (getGlEsVersion(mActivity) >= 2) {
            // Both of the views are attached to a hardware accelerated window
            assertTrue(mHardwareView.isHardwareAccelerated());
            assertTrue(mSoftwareView.isHardwareAccelerated());
            assertTrue(mManualHardwareView.isHardwareAccelerated());
            assertTrue(mManualSoftwareView.isHardwareAccelerated());

            assertTrue(mHardwareView.isCanvasHardwareAccelerated());
            assertFalse(mSoftwareView.isCanvasHardwareAccelerated());
            assertTrue(mManualHardwareView.isCanvasHardwareAccelerated());
            assertFalse(mManualSoftwareView.isCanvasHardwareAccelerated());
        } else {
            assertFalse(mHardwareView.isHardwareAccelerated());
            assertFalse(mSoftwareView.isHardwareAccelerated());
            assertFalse(mManualHardwareView.isHardwareAccelerated());
            assertFalse(mManualSoftwareView.isHardwareAccelerated());

            assertFalse(mHardwareView.isCanvasHardwareAccelerated());
            assertFalse(mSoftwareView.isCanvasHardwareAccelerated());
            assertFalse(mManualHardwareView.isCanvasHardwareAccelerated());
            assertFalse(mManualSoftwareView.isCanvasHardwareAccelerated());
        }
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.bluetooth.MessageTestActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/bluetooth/MessageTestActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.bluetooth;

import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;
import com.android.cts.verifier.TestResult;

import android.app.AlertDialog;
import android.bluetooth.BluetoothAdapter;
import android.bluetooth.BluetoothDevice;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.ArrayAdapter;
import android.widget.Button;
import android.widget.ListView;
import android.widget.ProgressBar;
import android.widget.TextView;
import android.widget.Toast;

import java.util.UUID;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

class MessageTestActivity extends PassFailButtons.Activity {

    /** Broadcast action that should only be fired when pairing for a secure connection. */
    private static final String ACTION_PAIRING_REQUEST =
            ""android.bluetooth.device.action.PAIRING_REQUEST"";

    private static final int ENABLE_BLUETOOTH_REQUEST = 1;
    private static final int PICK_SERVER_DEVICE_REQUEST = 2;

    private static final String MESSAGE_DELIMITER = ""\n"";
    private static final Pattern MESSAGE_PATTERN = Pattern.compile(""Message (\\d+) to .*"");

    private BluetoothAdapter mBluetoothAdapter;
    private PairingActionReceiver mPairingActionReceiver;
    private BluetoothChatService mChatService;

    private ArrayAdapter<String> mReceivedMessagesAdapter;
    private ArrayAdapter<String> mSentMessagesAdapter;

    private ListView mReceivedMessages;
    private ListView mSentMessages;

    private TextView mEmptyReceivedView;
    private TextView mEmptySentView;

    private AlertDialog mInstructionsDialog;

    private ProgressBar mProgressBar;

    private String mDeviceAddress;

    private final boolean mSecure;
    private final boolean mServer;
    private final UUID mUuid;

    private String mRemoteDeviceName = """";
    private StringBuilder mMessageBuffer = new StringBuilder();

    MessageTestActivity(boolean secure, boolean server, UUID uuid) {
        mSecure = secure;
        mServer = server;
        mUuid = uuid;
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.bt_messages);
        setPassFailButtonClickListeners();

        mProgressBar = (ProgressBar) findViewById(R.id.bt_progress_bar);

        if (mServer) {
            setTitle(mSecure ? R.string.bt_secure_server : R.string.bt_insecure_server);
        } else {
            setTitle(mSecure ? R.string.bt_secure_client : R.string.bt_insecure_client);
        }

        mReceivedMessages = (ListView) findViewById(R.id.bt_received_messages);
        mReceivedMessagesAdapter = new ArrayAdapter<String>(this, R.layout.bt_message_row);
        mReceivedMessages.setAdapter(mReceivedMessagesAdapter);

        mSentMessages = (ListView) findViewById(R.id.bt_sent_messages);
        mSentMessagesAdapter = new ArrayAdapter<String>(this, R.layout.bt_message_row);
        mSentMessages.setAdapter(mSentMessagesAdapter);

        mEmptyReceivedView = (TextView) findViewById(R.id.bt_empty_received_messages);
        mReceivedMessages.setEmptyView(mEmptyReceivedView);

        mEmptySentView = (TextView) findViewById(R.id.bt_empty_sent_messages);
        mSentMessages.setEmptyView(mEmptySentView);

        setEmptyViewText(R.string.bt_no_messages);

        Button makeDiscoverableButton = (Button) findViewById(R.id.bt_make_discoverable_button);
        makeDiscoverableButton.setVisibility(mServer ? View.VISIBLE : View.GONE);
        makeDiscoverableButton.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                makeDiscoverable();
            }
        });

        getPassButton().setEnabled(false);

        mPairingActionReceiver = new PairingActionReceiver();
        IntentFilter intentFilter = new IntentFilter(ACTION_PAIRING_REQUEST);
        registerReceiver(mPairingActionReceiver, intentFilter);

        mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
        if (!mServer) {
            Intent intent = new Intent(this, DevicePickerActivity.class);
            startActivityForResult(intent, PICK_SERVER_DEVICE_REQUEST);
        } else {
            if (mBluetoothAdapter.isEnabled()) {
                startChatService();
            } else {
                Intent intent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);
                startActivityForResult(intent, ENABLE_BLUETOOTH_REQUEST);
            }
        }
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        switch (requestCode) {
            case ENABLE_BLUETOOTH_REQUEST:
                if (resultCode == RESULT_OK) {
                    startChatService();
                } else {
                    setResult(RESULT_CANCELED);
                    finish();
                }
                break;

            case PICK_SERVER_DEVICE_REQUEST:
                if (resultCode == RESULT_OK) {
                    mDeviceAddress = data.getStringExtra(DevicePickerActivity.EXTRA_DEVICE_ADDRESS);
                    startChatService();
                } else {
                    setResult(RESULT_CANCELED);
                    finish();
                }
                break;
        }
    }

    private void startChatService() {
        mChatService = new BluetoothChatService(this, new ChatHandler(), mUuid);
        if (mServer) {
            mChatService.start(mSecure);
        } else {
            BluetoothDevice device = mBluetoothAdapter.getRemoteDevice(mDeviceAddress);
            mChatService.connect(device, mSecure);
        }
    }

    private void makeDiscoverable() {
        if (mBluetoothAdapter.getScanMode() !=
                BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE) {
            Intent intent = new Intent(BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE);
            intent.putExtra(BluetoothAdapter.EXTRA_DISCOVERABLE_DURATION, 30);
            startActivity(intent);
        }
    }

    private class ChatHandler extends Handler {
        @Override
        public void handleMessage(Message msg) {
            super.handleMessage(msg);
            switch (msg.what) {
                case BluetoothChatService.MESSAGE_STATE_CHANGE:
                    handleStateChange(msg);
                    break;
                case BluetoothChatService.MESSAGE_READ:
                    handleMessageRead(msg);
                    break;
                case BluetoothChatService.MESSAGE_WRITE:
                    handleMessageWrite(msg);
                    break;
                case BluetoothChatService.MESSAGE_DEVICE_NAME:
                    handleDeviceName(msg);
                    break;
                case BluetoothChatService.MESSAGE_TOAST:
                    handleToast(msg);
                    break;
            }
        }
    }

    private void handleStateChange(Message msg) {
        int state = msg.arg1;
        switch (state) {
            case BluetoothChatService.STATE_LISTEN:
                setEmptyViewText(R.string.bt_waiting);
                mProgressBar.setVisibility(View.VISIBLE);
                showInstructionsDialog();
                break;

            case BluetoothChatService.STATE_CONNECTING:
                setEmptyViewText(R.string.bt_connecting);
                mProgressBar.setVisibility(View.VISIBLE);
                break;

            case BluetoothChatService.STATE_CONNECTED:
                setEmptyViewText(R.string.bt_no_messages);
                mProgressBar.setVisibility(View.INVISIBLE);

                hideInstructionsDialog();
                sendInitialMessageFromClient();
                break;

            case BluetoothChatService.STATE_NONE:
                setEmptyViewText(R.string.bt_no_messages);
                mProgressBar.setVisibility(View.INVISIBLE);
                break;
        }
    }

    private void setEmptyViewText(int textId) {
        mEmptyReceivedView.setText(textId);
        mEmptySentView.setText(textId);
    }

    private void showInstructionsDialog() {
        if (mInstructionsDialog == null) {
            mInstructionsDialog = new AlertDialog.Builder(this)
                    .setIcon(android.R.drawable.ic_dialog_info)
                    .setTitle(getString(R.string.bt_waiting))
                    .setMessage(getString(mSecure
                            ? R.string.bt_secure_server_instructions
                            : R.string.bt_insecure_server_instructions))
                    .setPositiveButton(android.R.string.ok, null)
                    .create();
        }
        mInstructionsDialog.show();
    }

    private void hideInstructionsDialog() {
        if (mInstructionsDialog != null) {
            mInstructionsDialog.hide();
        }
    }

    private void sendInitialMessageFromClient() {
        if (!mServer) {
            sendMessage(0);
        }
    }

    private void sendMessage(int number) {
        String message = ""Message "" + number + "" to ""
                + (mRemoteDeviceName != null ? mRemoteDeviceName : """")
                + MESSAGE_DELIMITER;
        mChatService.write(message.getBytes());
    }

    private void handleMessageRead(Message msg) {
        String chunk = new String((byte[]) msg.obj, 0, msg.arg1);
        mMessageBuffer.append(chunk);

        int delimiterIndex = mMessageBuffer.indexOf(MESSAGE_DELIMITER);
        if (delimiterIndex != -1) {
            String message = mMessageBuffer.substring(0, delimiterIndex); // Chop off delimiter
            mMessageBuffer.delete(0, delimiterIndex + 1);
            addNewMessage(message);
        }
    }

    private void addNewMessage(String msg) {
        mReceivedMessagesAdapter.add(msg);
        Matcher matcher = MESSAGE_PATTERN.matcher(msg);
        if (matcher.matches()) {
            int number = Integer.valueOf(matcher.group(1));
            if (mServer && number == 10 || !mServer && number == 11) {
                getPassButton().setEnabled(true);
            }
            if (number <= 10) {
                sendMessage(number + 1);
            }
        }
    }

    private void handleMessageWrite(Message msg) {
        String sentMessage = new String((byte[]) msg.obj).trim(); // Chop off delimiter
        mSentMessagesAdapter.add(sentMessage);
    }

    private void handleDeviceName(Message msg) {
        mRemoteDeviceName = msg.getData().getString(BluetoothChatService.DEVICE_NAME);
    }

    private void handleToast(Message msg) {
        String toast = msg.getData().getString(BluetoothChatService.TOAST);
        Toast.makeText(this, toast, Toast.LENGTH_LONG).show();
    }

    class PairingActionReceiver extends BroadcastReceiver {
        @Override
        public void onReceive(Context context, Intent intent) {
            if (!mSecure && ACTION_PAIRING_REQUEST.equals(intent.getAction())) {
                runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        showPairingErrorDialog();
                    }
                });
            }
        }
    }

    private void showPairingErrorDialog() {
        new AlertDialog.Builder(MessageTestActivity.this)
            .setIcon(android.R.drawable.ic_dialog_alert)
            .setTitle(R.string.bt_insecure_pairing_error_title)
            .setMessage(R.string.bt_insecure_pairing_error_message)
            .setPositiveButton(android.R.string.ok,
                    new DialogInterface.OnClickListener() {
                @Override
                public void onClick(DialogInterface dialog, int which) {
                    TestResult.setFailedResult(MessageTestActivity.this, getTestId(), null);
                    finish();
                }
            })
            .setCancelable(false)
            .show();
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        if (mChatService != null) {
            mChatService.stop();
        }
        unregisterReceiver(mPairingActionReceiver);
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.SupplicantStateTest"	"testIsValidState"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/SupplicantStateTest.java"	""	"public void testIsValidState() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        assertTrue(SupplicantState.isValidState(SupplicantState.DISCONNECTED));
        assertTrue(SupplicantState.isValidState(SupplicantState.INACTIVE));
        assertTrue(SupplicantState.isValidState(SupplicantState.SCANNING));
        assertTrue(SupplicantState.isValidState(SupplicantState.ASSOCIATING));
        assertTrue(SupplicantState.isValidState(SupplicantState.ASSOCIATED));
        assertTrue(SupplicantState.isValidState(SupplicantState.FOUR_WAY_HANDSHAKE));
        assertTrue(SupplicantState.isValidState(SupplicantState.GROUP_HANDSHAKE));
        assertTrue(SupplicantState.isValidState(SupplicantState.COMPLETED));
        assertTrue(SupplicantState.isValidState(SupplicantState.DORMANT));
        assertFalse(SupplicantState.isValidState(SupplicantState.UNINITIALIZED));
        assertFalse(SupplicantState.isValidState(SupplicantState.INVALID));
    }

}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.audio.MidiTestActivityBase"	"MidiTestActivityBase"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/audio/MidiTestActivityBase.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.audio;

import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.content.res.Resources;
import android.content.ServiceConnection;
import android.media.midi.MidiDeviceInfo;
import android.media.midi.MidiManager;
import android.os.Bundle;
import android.os.Handler;
import android.os.IBinder;
import android.util.Log;
import android.view.View;
import android.widget.Button;
import android.widget.TextView;

import com.android.cts.verifier.audio.midilib.MidiIODevice;
import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;  // needed to access resource in CTSVerifier project namespace.

import com.android.midi.VerifierMidiEchoService;

import java.util.Timer;
import java.util.TimerTask;

/**
 * Common information and behaviors for the MidiJavaTestActivity and MidiNativeTestActivity
 */
public abstract class MidiTestActivityBase
        extends PassFailButtons.Activity
        implements View.OnClickListener {

    private static final String TAG = ""MidiTestActivityBase"";
    private static final boolean DEBUG = false;

    protected MidiManager mMidiManager;

    protected Intent mMidiServiceIntent;
    private MidiServiceConnection mMidiServiceConnection;

    // Flags
    protected boolean mHasMIDI;

    // Test Status
    protected static final int TESTSTATUS_NOTRUN = 0;
    protected static final int TESTSTATUS_PASSED = 1;
    protected static final int TESTSTATUS_FAILED_MISMATCH = 2;
    protected static final int TESTSTATUS_FAILED_TIMEOUT = 3;
    protected static final int TESTSTATUS_FAILED_OVERRUN = 4;
    protected static final int TESTSTATUS_FAILED_DEVICE = 5;
    protected static final int TESTSTATUS_FAILED_JNI = 6;

    private MidiTestModule mUSBTestModule;
    private MidiTestModule mVirtualTestModule;
    private MidiTestModule mBTTestModule;

    // Widgets
    protected Button mUSBTestBtn;
    protected Button mVirtTestBtn;
    protected Button mBTTestBtn;

    protected TextView    mUSBIInputDeviceLbl;
    protected TextView    mUSBOutputDeviceLbl;
    protected TextView    mUSBTestStatusTxt;

    protected TextView    mVirtInputDeviceLbl;
    protected TextView    mVirtOutputDeviceLbl;
    protected TextView    mVirtTestStatusTxt;

    protected TextView    mBTInputDeviceLbl;
    protected TextView    mBTOutputDeviceLbl;
    protected TextView    mBTTestStatusTxt;

    protected static final int TESTID_NONE = 0;
    protected static final int TESTID_USBLOOPBACK = 1;
    protected static final int TESTID_VIRTUALLOOPBACK = 2;
    protected static final int TESTID_BTLOOPBACK = 3;
    protected int mRunningTestID = TESTID_NONE;

    public MidiTestActivityBase() {
    }

    protected void initTestModules(MidiTestModule USBTestModule,
                                    MidiTestModule virtualTestModule,
                                    MidiTestModule BTTestModule) {
        mUSBTestModule = USBTestModule;
        mVirtualTestModule = virtualTestModule;
        mBTTestModule = BTTestModule;
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        mMidiManager = getSystemService(MidiManager.class);

        // Standard PassFailButtons.Activity initialization
        setPassFailButtonClickListeners();
        setInfoResources(R.string.midi_test, R.string.midi_info, -1);

        // May as well calculate this right off the bat.
        mHasMIDI = hasMIDI();
        ((TextView)findViewById(R.id.midiHasMIDILbl)).setText("""" + mHasMIDI);

        mUSBTestBtn = (Button)findViewById(R.id.midiTestUSBInterfaceBtn);
        mUSBTestBtn.setOnClickListener(this);
        mUSBIInputDeviceLbl = (TextView)findViewById(R.id.midiUSBInputLbl);
        mUSBOutputDeviceLbl = (TextView)findViewById(R.id.midiUSBOutputLbl);
        mUSBTestStatusTxt = (TextView)findViewById(R.id.midiUSBTestStatusLbl);

        mVirtTestBtn = (Button)findViewById(R.id.midiTestVirtInterfaceBtn);
        mVirtTestBtn.setOnClickListener(this);
        mVirtInputDeviceLbl = (TextView)findViewById(R.id.midiVirtInputLbl);
        mVirtOutputDeviceLbl = (TextView)findViewById(R.id.midiVirtOutputLbl);
        mVirtTestStatusTxt = (TextView)findViewById(R.id.midiVirtTestStatusLbl);

        mBTTestBtn = (Button)findViewById(R.id.midiTestBTInterfaceBtn);
        mBTTestBtn.setOnClickListener(this);
        mBTInputDeviceLbl = (TextView)findViewById(R.id.midiBTInputLbl);
        mBTOutputDeviceLbl = (TextView)findViewById(R.id.midiBTOutputLbl);
        mBTTestStatusTxt = (TextView)findViewById(R.id.midiBTTestStatusLbl);

        calcTestPassed();
    }

    @Override
    protected void onResume() {
        super.onResume();
        if (DEBUG) {
            Log.i(TAG, ""---- Loading Virtual MIDI Service ..."");
        }
        mMidiServiceConnection = new MidiServiceConnection();
        boolean isBound =
                bindService(mMidiServiceIntent,  mMidiServiceConnection,  Context.BIND_AUTO_CREATE);
        if (DEBUG) {
            Log.i(TAG, ""---- Virtual MIDI Service loaded: "" + isBound);
        }
    }

    @Override
    protected void onPause() {
        super.onPause();
        if (DEBUG) {
            Log.i(TAG, ""---- onPause()"");
        }

        unbindService(mMidiServiceConnection);
        mMidiServiceConnection = null;
    }

    private boolean hasMIDI() {
        // CDD Section C-1-4: android.software.midi
        return getPackageManager().hasSystemFeature(PackageManager.FEATURE_MIDI);
    }

    void startMidiEchoServer() {
        // Init MIDI Stuff
        mMidiServiceIntent = new Intent(this, VerifierMidiEchoService.class);
    }

    void connectDeviceListener() {
        // Plug in device connect/disconnect callback
        mMidiManager.registerDeviceCallback(new MidiDeviceCallback(), new Handler(getMainLooper()));
    }

    void startWiredLoopbackTest() {
        mUSBTestModule.startLoopbackTest(TESTID_USBLOOPBACK);
    }

    void startVirtualLoopbackTest() {
        mVirtualTestModule.startLoopbackTest(TESTID_VIRTUALLOOPBACK);
    }

    void startBTLoopbackTest() {
        mBTTestModule.startLoopbackTest(TESTID_BTLOOPBACK);
    }

    boolean calcTestPassed() {
        boolean hasPassed = false;
        if (!mHasMIDI) {
            // if it doesn't report MIDI support, then it doesn't have to pass the other tests.
            hasPassed = true;
        } else {
            hasPassed = mUSBTestModule.hasTestPassed() &&
                    mVirtualTestModule.hasTestPassed() &&
                    mBTTestModule.hasTestPassed();
        }

        getPassButton().setEnabled(hasPassed);
        return hasPassed;
    }

    void scanMidiDevices() {
        if (DEBUG) {
            Log.i(TAG, ""scanMidiDevices()...."");
        }

        MidiDeviceInfo[] devInfos = mMidiManager.getDevices();
        mUSBTestModule.scanDevices(devInfos);
        mVirtualTestModule.scanDevices(devInfos);
        mBTTestModule.scanDevices(devInfos);

        showConnectedMIDIPeripheral();
    }

    //
    // UI Updaters
    //
    void showConnectedMIDIPeripheral() {
        // USB
        mUSBIInputDeviceLbl.setText(mUSBTestModule.getInputName());
        mUSBOutputDeviceLbl.setText(mUSBTestModule.getOutputName());
        mUSBTestBtn.setEnabled(mUSBTestModule.isTestReady());

        // Virtual MIDI
        mVirtInputDeviceLbl.setText(mVirtualTestModule.getInputName());
        mVirtOutputDeviceLbl.setText(mVirtualTestModule.getOutputName());
        mVirtTestBtn.setEnabled(mVirtualTestModule.isTestReady());

        // Bluetooth
        mBTInputDeviceLbl.setText(mBTTestModule.getInputName());
        mBTOutputDeviceLbl.setText(mBTTestModule.getOutputName());
        // use mUSBTestModule.isTestReady() as a proxy for knowing the interface loopback
        // is connected
        mBTTestBtn.setEnabled(mBTTestModule.isTestReady() && mUSBTestModule.isTestReady());
    }

    //
    // UI Updaters
    //
    void showUSBTestStatus() {
        mUSBTestStatusTxt.setText(getTestStatusString(mUSBTestModule.getTestStatus()));
    }

    void showVirtTestStatus() {
        mVirtTestStatusTxt.setText(getTestStatusString(mVirtualTestModule.getTestStatus()));
    }

    void showBTTestStatus() {
        mBTTestStatusTxt.setText(getTestStatusString(mBTTestModule.getTestStatus()));
    }

    void enableTestButtons(boolean enable) {
        runOnUiThread(new Runnable() {
            public void run() {
                if (enable) {
                    // remember, a given test might not be enabled, so we can't just enable
                    // all of the buttons
                    showConnectedMIDIPeripheral();
                } else {
                    mUSBTestBtn.setEnabled(enable);
                    mVirtTestBtn.setEnabled(enable);
                    mBTTestBtn.setEnabled(enable);
                }
            }
        });
    }

    // Need this to update UI from MIDI read thread
    public void updateTestStateUI() {
        runOnUiThread(new Runnable() {
            public void run() {
                calcTestPassed();
                showUSBTestStatus();
                showVirtTestStatus();
                showBTTestStatus();
            }
        });
    }

    // UI Helper
    public String getTestStatusString(int status) {
        Resources appResources = getApplicationContext().getResources();
        switch (status) {
            case TESTSTATUS_NOTRUN:
                return appResources.getString(R.string.midiNotRunLbl);

            case TESTSTATUS_PASSED:
                return appResources.getString(R.string.midiPassedLbl);

            case TESTSTATUS_FAILED_MISMATCH:
                return appResources.getString(R.string.midiFailedMismatchLbl);

            case TESTSTATUS_FAILED_TIMEOUT:
                return appResources.getString(R.string.midiFailedTimeoutLbl);

            case TESTSTATUS_FAILED_OVERRUN:
                return appResources.getString(R.string.midiFailedOverrunLbl);

            case TESTSTATUS_FAILED_DEVICE:
                return appResources.getString(R.string.midiFailedDeviceLbl);

            case TESTSTATUS_FAILED_JNI:
                return appResources.getString(R.string.midiFailedJNILbl);

            default:
                return ""Unknown Test Status."";
        }
    }

    //
    // View.OnClickListener Override - Handles button clicks
    //
    @Override
    public void onClick(View view) {
        switch (view.getId()) {
        case R.id.midiTestUSBInterfaceBtn:
            startWiredLoopbackTest();
            break;

        case R.id.midiTestVirtInterfaceBtn:
            startVirtualLoopbackTest();
            break;

        case R.id.midiTestBTInterfaceBtn:
            startBTLoopbackTest();
            break;

        default:
            assert false : ""Unhandled button click"";
        }
    }

    class MidiServiceConnection implements ServiceConnection {
        private static final String TAG = ""MidiServiceConnection"";
        @Override
        public void  onServiceConnected(ComponentName name, IBinder service) {
            if (DEBUG) {
                Log.i(TAG, ""MidiServiceConnection.onServiceConnected()"");
            }
            scanMidiDevices();
        }

        @Override
        public void onServiceDisconnected(ComponentName name) {
            if (DEBUG) {
                Log.i(TAG, ""MidiServiceConnection.onServiceDisconnected()"");
            }
        }
    }

    /**
     * Callback class for MIDI device connect/disconnect.
     */
    class MidiDeviceCallback extends MidiManager.DeviceCallback {
        private static final String TAG = ""MidiDeviceCallback"";

        @Override
        public void onDeviceAdded(MidiDeviceInfo device) {
            scanMidiDevices();
        }

        @Override
        public void onDeviceRemoved(MidiDeviceInfo device) {
            scanMidiDevices();
        }
    } /* class MidiDeviceCallback */

    abstract class MidiTestModule {
        protected int mTestStatus = TESTSTATUS_NOTRUN;

        // The Test Peripheral
        MidiIODevice                mIODevice;

        // Test State
        protected final Object        mTestLock = new Object();
        protected boolean             mTestRunning;

        // Timeout handling
        protected static final int    TEST_TIMEOUT_MS = 1000;
        protected final Timer         mTimeoutTimer = new Timer();

        public MidiTestModule(int deviceType) {
            mIODevice = new MidiIODevice(deviceType);
        }

        abstract void startLoopbackTest(int testID);
        abstract boolean hasTestPassed();

        public int getTestStatus() { return mTestStatus; }

        public boolean isTestReady() {
            return mIODevice.mReceiveDevInfo != null && mIODevice.mSendDevInfo != null;
        }

        public String getInputName() {
            return mIODevice.getInputName();
        }

        public String getOutputName() {
            return mIODevice.getOutputName();
        }

        public void scanDevices(MidiDeviceInfo[] devInfos) {
            mIODevice.scanDevices(devInfos);
        }

        void showTimeoutMessage() {
            runOnUiThread(new Runnable() {
                public void run() {
                    synchronized (mTestLock) {
                        if (mTestRunning) {
                            if (DEBUG) {
                                Log.i(TAG, ""---- Test Failed - TIMEOUT"");
                            }
                            mTestStatus = TESTSTATUS_FAILED_TIMEOUT;
                            updateTestStateUI();
                        }
                    }
                }
            });
        }

        void startTimeoutHandler() {
            // Start the timeout timer
            TimerTask task = new TimerTask() {
                @Override
                public void run() {
                    synchronized (mTestLock) {
                        if (mTestRunning) {
                            // Timeout
                            showTimeoutMessage();
                            enableTestButtons(true);
                        }
                    }
                }
            };
            mTimeoutTimer.schedule(task, TEST_TIMEOUT_MS);
        }
    }

}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.managedprovisioning.LocationCheckerActivity"	"hasLocationPermission"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/managedprovisioning/LocationCheckerActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.managedprovisioning;

import android.Manifest;
import android.app.Activity;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.location.Location;
import android.location.LocationManager;
import android.location.LocationRequest;
import android.os.Bundle;
import android.os.CancellationSignal;
import android.util.Log;
import android.widget.TextView;

import androidx.annotation.NonNull;
import androidx.core.app.ActivityCompat;
import androidx.core.content.ContextCompat;

import com.android.cts.verifier.R;

import java.util.List;
import java.util.stream.Collectors;

/**
 * Activity that checks whether it can obtain location. Asks for permission in case it is missing.
 * Result is reported to whoever invoked it with startActivityForResult.
 */
public class LocationCheckerActivity extends Activity {
    private static final String TAG = LocationCheckerActivity.class.getSimpleName();

    public static final String ACTION_CHECK_LOCATION_PRIMARY =
            ""com.android.cts.verifier.managedprovisioning.CHECK_LOCATION_ACCESS_PRIMARY"";
    public static final String ACTION_CHECK_LOCATION_WORK =
            ""com.android.cts.verifier.managedprovisioning.CHECK_LOCATION_ACCESS_WORK"";
    public static final String WORK_ACTIVITY_ALIAS =
            ""com.android.cts.verifier.managedprovisioning.WorkLocationCheckerActivityAlias"";

    public static final String EXTRA_ERROR_ID = ""extra-error-id"";
    public static final int LOCATION_PERMISSION_REQUEST = 125;
    private static final int REQUEST_MAX_DURATION_MILLIS = 15000;

    private List<String> mProviders;
    private LocationManager mLocationManager;
    private TextView mStatusText;
    private final CancellationSignal mCancellationSignal = new CancellationSignal();

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.location_checker);

        mLocationManager = getSystemService(LocationManager.class);
        mStatusText = findViewById(R.id.status_text);

        if (hasLocationPermission()) {
            requestCurrentLocation();
        } else {
            requestLocationPermission();
        }
    }

    private void requestCurrentLocation() {
        synchronized (this) {
            mProviders = mLocationManager.getAllProviders().stream()
                    .filter(mLocationManager::isProviderEnabled)
                    .collect(Collectors.toList());
            if (mProviders.isEmpty()) {
                finish(R.string.provisioning_byod_location_no_provider);
                return;
            }
            // Callback will be invoked with null if duration exceeded.
            LocationRequest request = new LocationRequest.Builder(0)
                    .setDurationMillis(REQUEST_MAX_DURATION_MILLIS).build();
            // Request location from all available providers.
            for (String provider: mProviders) {
                mLocationManager.getCurrentLocation(provider, request, mCancellationSignal,
                        getMainExecutor(), l -> onLocation(provider, l));
            }
            updateStatusLocked();
        }
    }

    private void updateStatusLocked() {
        String providers = String.join("", "", mProviders);
        mStatusText.setText(getString(R.string.provisioning_byod_location_trying, providers));
    }

    private boolean hasLocationPermission() {
        return ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION)
                == PackageManager.PERMISSION_GRANTED;
    }

    private void requestLocationPermission() {
        ActivityCompat.requestPermissions(this,
                new String[]{Manifest.permission.ACCESS_FINE_LOCATION},
                LOCATION_PERMISSION_REQUEST);
    }

    @Override
    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions,
            @NonNull int[] grants) {
        // Test that the right permission was granted.
        if (requestCode == LOCATION_PERMISSION_REQUEST) {
            if (!permissions[0].equals(Manifest.permission.ACCESS_FINE_LOCATION)
                    || grants[0] != PackageManager.PERMISSION_GRANTED
                    || !hasLocationPermission()) {
                Log.e(TAG, ""The test needs location permission."");
                finish(R.string.provisioning_byod_location_mode_enable_missing_permission);
                return;
            }
            requestCurrentLocation();
        }
    }

    private void onLocation(String provider, Location location) {
        if (mCancellationSignal.isCanceled()) {
            return;
        } else if (location != null) {
            mCancellationSignal.cancel();
            finish(-1 /* no error */);
        }

        // location == null, provider wasn't able to get location, see if there are more providers
        synchronized (this) {
            mProviders.remove(provider);
            if (mProviders.isEmpty()) {
                finish(R.string.provisioning_byod_location_failed);
            } else {
                updateStatusLocked();
            }
        }
    }

    void finish(int messageId) {
        Intent result = new Intent();
        result.putExtra(EXTRA_ERROR_ID, messageId);
        setResult(Activity.RESULT_OK, result);
        finish();
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.os.cts.BuildTest"	"testCpuAbi_valuesMatchPermitted"	""	"/home/gpoor/cts-12-source/cts/tests/tests/os/src/android/os/cts/BuildTest.java"	""	"public void testCpuAbi_valuesMatchPermitted() throws Exception {
        // The permitted ABIs are listed in https://developer.android.com/ndk/guides/abis.
        Set<String> just32 = new HashSet<>(Arrays.asList(""armeabi"", ""armeabi-v7a"", ""x86""));
        Set<String> just64 = new HashSet<>(Arrays.asList(""x86_64"", ""arm64-v8a""));
        Set<String> all = new HashSet<>();
        all.addAll(just32);
        all.addAll(just64);
        Set<String> allAndEmpty = new HashSet<>(all);
        allAndEmpty.add("""");

        // The cpu abi fields on the device must match the permitted values.
        assertValueIsAllowed(all, Build.CPU_ABI);
        // CPU_ABI2 will be empty when the device does not support a secondary CPU architecture.
        assertValueIsAllowed(allAndEmpty, Build.CPU_ABI2);

        // The supported abi fields on the device must match the permitted values.
        assertValuesAreAllowed(all, Build.SUPPORTED_ABIS);
        assertValuesAreAllowed(just32, Build.SUPPORTED_32_BIT_ABIS);
        assertValuesAreAllowed(just64, Build.SUPPORTED_64_BIT_ABIS);
    }

    private void runTestCpuAbiCommon() throws Exception {
        // The build property must match Build.SUPPORTED_ABIS exactly.
        final String[] abiListProperty = getStringList(RO_PRODUCT_CPU_ABILIST);
        assertEquals(Arrays.toString(abiListProperty), Arrays.toString(Build.SUPPORTED_ABIS));

        List<String> abiList = Arrays.asList(abiListProperty);

        // Every supported 32 bit ABI must be present in Build.SUPPORTED_ABIS.
        for (String abi : Build.SUPPORTED_32_BIT_ABIS) {
            assertTrue(abiList.contains(abi));
            assertFalse(Build.is64BitAbi(abi));
        }

        // Every supported 64 bit ABI must be present in Build.SUPPORTED_ABIS.
        for (String abi : Build.SUPPORTED_64_BIT_ABIS) {
            assertTrue(abiList.contains(abi));
            assertTrue(Build.is64BitAbi(abi));
        }

        // Build.CPU_ABI and Build.CPU_ABI2 must be present in Build.SUPPORTED_ABIS.
        assertTrue(abiList.contains(Build.CPU_ABI));
        if (!Build.CPU_ABI2.isEmpty()) {
            assertTrue(abiList.contains(Build.CPU_ABI2));
        }
    }

    private void runTestCpuAbi32() throws Exception {
        List<String> abi32 = Arrays.asList(Build.SUPPORTED_32_BIT_ABIS);
        assertTrue(abi32.contains(Build.CPU_ABI));

        if (!Build.CPU_ABI2.isEmpty()) {
            assertTrue(abi32.contains(Build.CPU_ABI2));
        }
    }

    private void runTestCpuAbi64() {
        List<String> abi64 = Arrays.asList(Build.SUPPORTED_64_BIT_ABIS);
        assertTrue(abi64.contains(Build.CPU_ABI));

        if (!Build.CPU_ABI2.isEmpty()) {
            assertTrue(abi64.contains(Build.CPU_ABI2));
        }
    }

    private String[] getStringList(String property) throws IOException {
        String value = getProperty(property);
        if (value.isEmpty()) {
            return new String[0];
        } else {
            return value.split("","");
        }
    }

    /**
     * @param property name passed to getprop
     */
    static String getProperty(String property)
            throws IOException {
        Process process = new ProcessBuilder(""getprop"", property).start();
        Scanner scanner = null;
        String line = """";
        try {
            scanner = new Scanner(process.getInputStream());
            line = scanner.nextLine();
        } finally {
            if (scanner != null) {
                scanner.close();
            }
        }
        return line;
    }
    /**
     * @param message shown when the test fails
     * @param property name passed to getprop
     * @param expected value of the property
     */
    private void assertProperty(String message, String property, String expected)
            throws IOException {
        Process process = new ProcessBuilder(""getprop"", property).start();
        Scanner scanner = null;
        try {
            scanner = new Scanner(process.getInputStream());
            String line = scanner.nextLine();
            assertEquals(message + "" Value found: "" + line , expected, line);
            assertFalse(scanner.hasNext());
        } finally {
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Check that a property is not set by scanning through the list of properties returned by
     * getprop, since calling getprop on an property set to """" and on a non-existent property
     * yields the same output.
     *
     * @param message shown when the test fails
     * @param property name passed to getprop
     */
    private void assertNoPropertySet(String message, String property) throws IOException {
        Process process = new ProcessBuilder(""getprop"").start();
        Scanner scanner = null;
        try {
            scanner = new Scanner(process.getInputStream());
            while (scanner.hasNextLine()) {
                String line = scanner.nextLine();
                assertFalse(message + ""Property found: "" + line,
                        line.startsWith(""["" + property + ""]""));
            }
        } finally {
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    private static void assertValueIsAllowed(Set<String> allowedValues, String actualValue) {
        assertTrue(""Expected one of "" + allowedValues + "", but was: '"" + actualValue + ""'"",
                allowedValues.contains(actualValue));
    }

    private static void assertValuesAreAllowed(Set<String> allowedValues, String[] actualValues) {
        for (String actualValue : actualValues) {
            assertValueIsAllowed(allowedValues, actualValue);
        }
    }

    private static final Pattern BOARD_PATTERN =
        Pattern.compile(""^([0-9A-Za-z._-]+)$"");
    private static final Pattern BRAND_PATTERN =
        Pattern.compile(""^([0-9A-Za-z._-]+)$"");
    private static final Pattern DEVICE_PATTERN =
        Pattern.compile(""^([0-9A-Za-z._-]+)$"");
    private static final Pattern ID_PATTERN =
        Pattern.compile(""^([0-9A-Za-z._-]+)$"");
    private static final Pattern HARDWARE_PATTERN =
        Pattern.compile(""^([0-9A-Za-z.,_-]+)$"");
    private static final Pattern PRODUCT_PATTERN =
        Pattern.compile(""^([0-9A-Za-z._-]+)$"");
    private static final Pattern SOC_MANUFACTURER_PATTERN =
        Pattern.compile(""^([0-9A-Za-z ]+)$"");
    private static final Pattern SOC_MODEL_PATTERN =
        Pattern.compile(""^([0-9A-Za-z ._/+-]+)$"");
    private static final Pattern SERIAL_NUMBER_PATTERN =
        Pattern.compile(""^([0-9A-Za-z]{6,20})$"");
    private static final Pattern SKU_PATTERN =
        Pattern.compile(""^([0-9A-Za-z.,_-]+)$"");
    private static final Pattern TAGS_PATTERN =
        Pattern.compile(""^([0-9A-Za-z.,_-]+)$"");
    private static final Pattern TYPE_PATTERN =
        Pattern.compile(""^([0-9A-Za-z._-]+)$"");

    /** Tests that check for valid values of constants in Build. */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.edi.cts.PropertyDeviceInfo"	"isEmpty"	"CtsEdiHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/edi/src/android/edi/cts/PropertyDeviceInfo.java"	""	"public void test/*
 *.
 */
package android.edi.cts;

import com.android.compatibility.common.util.DeviceInfo;
import com.android.compatibility.common.util.HostInfoStore;
import com.android.tradefed.device.ITestDevice;
import com.android.tradefed.log.LogUtil.CLog;
import com.android.tradefed.util.CommandResult;

import java.util.Scanner;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * System property info collector.
 */
public class PropertyDeviceInfo extends DeviceInfo {

    @Override
    protected void collectDeviceInfo(HostInfoStore store) throws Exception {
        store.startArray(""ro_property"");
        try {
            ITestDevice device = getDevice();
            CommandResult commandResult = device.executeShellV2Command(""getprop"");
            if (commandResult.getExitCode() == null) {
                throw new NullPointerException(""getprop exit code is null"");
            }
            if (commandResult.getExitCode() != 0) {
                throw new IllegalStateException(
                        String.format(""getprop returns %d: %s"", commandResult.getExitCode(),
                                commandResult.getStderr()));
            }
            if (commandResult.getExitCode() == 0 && !commandResult.getStderr().isEmpty()) {
                CLog.w(""Warnings occur when running getprop:\n%s"",
                        commandResult.getStderr());
            }

            parseProps(commandResult.getStdout(), store);
        } finally {
            store.endArray();
        }
    }

    private void parseProps(String stdout, HostInfoStore store) throws Exception {
        Pattern pattern = Pattern.compile(""\\[(ro.+)\\]: \\[(.+)\\]"");
        if (stdout == null) stdout = """";
        boolean hasMatched = false;
        try (Scanner scanner = new Scanner(stdout)) {
            while (scanner.hasNextLine()) {
                String line = scanner.nextLine();
                Matcher matcher = pattern.matcher(line);
                if (matcher.matches()) {
                    String name = matcher.group(1);
                    String value = matcher.group(2);

                    store.startGroup();
                    store.addResult(""name"", name);
                    store.addResult(""value"", value);
                    store.endGroup();
                    hasMatched = true;
                }
            }
        }
        if (!hasMatched) {
            throw new IllegalStateException(
                    ""Unable to find any read-only properties. Output is "" + stdout);
        }
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.telecom.cts.CallTest"	"testCapabilitiesCan"	"CtsTelecomTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/CallTest.java"	""	"public void testCapabilitiesCan() {
        assertTrue(Call.Details.can(CAPABILITY_HOLD, CAPABILITY_HOLD));
        assertTrue(Call.Details.can(CAPABILITY_MUTE, CAPABILITY_MUTE));
        assertTrue(Call.Details.can(CAPABILITY_HOLD | CAPABILITY_DISCONNECT_FROM_CONFERENCE,
                CAPABILITY_HOLD));
        assertTrue(Call.Details.can(CAPABILITY_MERGE_CONFERENCE
                | CAPABILITY_DISCONNECT_FROM_CONFERENCE | CAPABILITY_MUTE,
                CAPABILITY_MUTE));
        assertTrue(Call.Details.can(CAPABILITY_CAN_PAUSE_VIDEO, CAPABILITY_CAN_PAUSE_VIDEO));
        assertTrue(Call.Details.can(CAPABILITY_CAN_PULL_CALL, CAPABILITY_CAN_PULL_CALL));

        assertFalse(Call.Details.can(CAPABILITY_MUTE, CAPABILITY_HOLD));
        assertFalse(Call.Details.can(CAPABILITY_MERGE_CONFERENCE
                | CAPABILITY_DISCONNECT_FROM_CONFERENCE | CAPABILITY_MUTE,
                CAPABILITY_HOLD));
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.server.wm.DragDropTest"	"testSoftwareCanvas"	"CtsWindowManagerDeviceTestCases"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DragDropTest.java"	""	"public void testSoftwareCanvas() throws InterruptedException {
        SoftwareCanvasDragDropActivity activity =
                startActivity(SoftwareCanvasDragDropActivity.class);
        assertDragCanvasHwAcceleratedState(activity, false);
    }

    private void assertDragCanvasHwAcceleratedState(DragDropActivity activity,
            boolean expectedHwAccelerated) {
        CountDownLatch latch = new CountDownLatch(1);
        AtomicBoolean isCanvasHwAccelerated = new AtomicBoolean();
        runOnMain(() -> {
            View v = activity.findViewById(R.id.draggable);
            v.startDragAndDrop(sClipData, new View.DragShadowBuilder(v) {
                @Override
                public void onDrawShadow(Canvas canvas) {
                    isCanvasHwAccelerated.set(canvas.isHardwareAccelerated());
                    latch.countDown();
                }
            }, null, 0);
        });

        try {
            assertTrue(""Timeout while waiting for canvas"", latch.await(5, TimeUnit.SECONDS));
            assertTrue(""Expected canvas hardware acceleration to be: "" + expectedHwAccelerated,
                    expectedHwAccelerated == isCanvasHwAccelerated.get());
        } catch (InterruptedException e) {
            fail(""Got InterruptedException while waiting for canvas"");
        }
    }

    public static class DragDropActivity extends FocusableActivity {
        @Override
        protected void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            setContentView(R.layout.drag_drop_layout);
        }
    }

    public static class SoftwareCanvasDragDropActivity extends DragDropActivity {
        @Override
        protected void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            setContentView(R.layout.drag_drop_layout);
        }
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.security.cts.CVE_2021_0523.PocService"	"getDisplayMetrics"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/securitybulletin/test-apps/CVE-2021-0523/src/android/security/cts/CVE_2021_0523/PocService.java"	""	"public void test/*
 *.
 */

package android.security.cts.cve_2021_0523;

import android.app.Service;
import android.content.Intent;
import android.content.res.Resources;
import android.graphics.Bitmap;
import android.graphics.Color;
import android.graphics.PixelFormat;
import android.os.Build;
import android.os.Handler;
import android.os.IBinder;
import android.provider.Settings;
import android.view.Gravity;
import android.view.MotionEvent;
import android.view.View;
import android.view.WindowManager;
import android.view.WindowManager.LayoutParams;
import android.widget.Button;

public class PocService extends Service {
    public static Button mButton;
    private WindowManager mWindowManager;
    private WindowManager.LayoutParams mLayoutParams;

    private static int getScreenWidth() {
        return Resources.getSystem().getDisplayMetrics().widthPixels;
    }

    private static int getScreenHeight() {
        return Resources.getSystem().getDisplayMetrics().heightPixels;
    }

    @Override
    public void onCreate() {
        super.onCreate();
        mWindowManager = getSystemService(WindowManager.class);
        mLayoutParams = new WindowManager.LayoutParams();
        mLayoutParams.type = WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY;
        mLayoutParams.flags = WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL
                | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
        mLayoutParams.format = PixelFormat.OPAQUE;
        mLayoutParams.gravity = Gravity.LEFT | Gravity.TOP;
        mLayoutParams.width = getScreenWidth();
        mLayoutParams.height = getScreenHeight();
        mLayoutParams.x = getScreenWidth() / 2;
        mLayoutParams.y = getScreenHeight() / 2;
    }

    @Override
    public IBinder onBind(Intent intent) {
        return null;
    }

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        showFloatingWindow();
        return super.onStartCommand(intent, flags, startId);
    }

    @Override
    public void onDestroy() {
        if (mWindowManager != null && mButton != null) {
            mWindowManager.removeView(mButton);
        }
        super.onDestroy();
    }

    private void showFloatingWindow() {
        if (Settings.canDrawOverlays(this)) {
            mButton = new Button(getApplicationContext());
            mButton.setBackgroundColor(Color.parseColor(""#BEBEBE"")); // R-BE G-BE B-BE
            mWindowManager.addView(mButton, mLayoutParams);
            mButton.setOnTouchListener(new FloatingOnTouchListener());
            new Handler().postDelayed(new Runnable() {
                @Override
                public void run() {
                    onDestroy();
                }
            }, 60000); // one minute
            mButton.setTag(mButton.getVisibility());
        }
    }

    private static class FloatingOnTouchListener implements View.OnTouchListener {

        @Override
        public boolean onTouch(View view, MotionEvent event) {
            view.setDrawingCacheEnabled(true);
            view.buildDrawingCache();
            Bitmap bitmap = view.getDrawingCache();
            int pixel = bitmap.getPixel(getScreenWidth() / 2, getScreenHeight() / 2);
            int red = Color.red(pixel);
            int green = Color.green(pixel);
            int blue = Color.blue(pixel);
            view.setDrawingCacheEnabled(false);
            if ((red == 0xBE) && (green == 0xBE) && (blue == 0xBE)) {
                throw new RuntimeException(
                    ""Device is vulnerable to b/174047492 hence any app with "" +
                    ""SYSTEM_ALERT_WINDOW can overlay the WifiScanModeActivity screen"");
            }
            return false;
        }
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiLocationInfoTest"	"isNotNull"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiLocationInfoTest.java"	""	"/*
 *.
 */

package android.net.wifi.cts;

import static android.Manifest.permission.ACCESS_BACKGROUND_LOCATION;
import static android.Manifest.permission.ACCESS_FINE_LOCATION;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import static org.junit.Assume.assumeTrue;

import android.content.ComponentName;
import android.content.Context;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiManager;
import android.os.Build;
import android.platform.test.annotations.AppModeFull;

import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.filters.SdkSuppress;
import androidx.test.filters.SmallTest;
import androidx.test.platform.app.InstrumentationRegistry;
import androidx.test.rule.ActivityTestRule;

import com.android.compatibility.common.util.PollingCheck;
import com.android.compatibility.common.util.ShellIdentityUtils;
import com.android.compatibility.common.util.SystemUtil;

import org.junit.After;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.List;

/**
 * Tests location sensitive APIs exposed by Wi-Fi.
 * Ensures that permissions on these APIs are properly enforced.
 */
@AppModeFull(reason = ""Cannot get WifiManager in instant app mode"")
@SmallTest
@RunWith(AndroidJUnit4.class)
public class WifiLocationInfoTest extends WifiJUnit4TestBase {
    private static final String TAG = ""WifiLocationInfoTest"";

    private static final String WIFI_LOCATION_TEST_APP_APK_PATH =
            ""/data/local/tmp/cts/wifi/CtsWifiLocationTestApp.apk"";
    private static final String WIFI_LOCATION_TEST_APP_PACKAGE_NAME =
            ""android.net.wifi.cts.app"";
    private static final String WIFI_LOCATION_TEST_APP_TRIGGER_SCAN_ACTIVITY =
            WIFI_LOCATION_TEST_APP_PACKAGE_NAME + "".TriggerScanAndReturnStatusActivity"";
    private static final String WIFI_LOCATION_TEST_APP_TRIGGER_SCAN_SERVICE =
            WIFI_LOCATION_TEST_APP_PACKAGE_NAME + "".TriggerScanAndReturnStatusService"";
    private static final String WIFI_LOCATION_TEST_APP_RETRIEVE_SCAN_RESULTS_ACTIVITY =
            WIFI_LOCATION_TEST_APP_PACKAGE_NAME + "".RetrieveScanResultsAndReturnStatusActivity"";
    private static final String WIFI_LOCATION_TEST_APP_RETRIEVE_SCAN_RESULTS_SERVICE =
            WIFI_LOCATION_TEST_APP_PACKAGE_NAME + "".RetrieveScanResultsAndReturnStatusService"";
    private static final String WIFI_LOCATION_TEST_APP_RETRIEVE_CONNECTION_INFO_ACTIVITY =
            WIFI_LOCATION_TEST_APP_PACKAGE_NAME + "".RetrieveConnectionInfoAndReturnStatusActivity"";
    private static final String WIFI_LOCATION_TEST_APP_RETRIEVE_CONNECTION_INFO_SERVICE =
            WIFI_LOCATION_TEST_APP_PACKAGE_NAME + "".RetrieveConnectionInfoAndReturnStatusService"";
    private static final String WIFI_LOCATION_TEST_APP_RETRIEVE_TRANSPORT_INFO_ACTIVITY =
            WIFI_LOCATION_TEST_APP_PACKAGE_NAME + "".RetrieveTransportInfoAndReturnStatusActivity"";
    private static final String WIFI_LOCATION_TEST_APP_RETRIEVE_TRANSPORT_INFO_SERVICE =
            WIFI_LOCATION_TEST_APP_PACKAGE_NAME + "".RetrieveTransportInfoAndReturnStatusService"";

    private static final int DURATION_MS = 10_000;
    private static final int WIFI_CONNECT_TIMEOUT_MILLIS = 30_000;

    @Rule
    public final ActivityTestRule<WaitForResultActivity> mActivityRule =
            new ActivityTestRule<>(WaitForResultActivity.class);

    private Context mContext;
    private WifiManager mWifiManager;
    private boolean mWasVerboseLoggingEnabled;
    private boolean mWasScanThrottleEnabled;

    @Before
    public void setUp() throws Exception {
        mContext = InstrumentationRegistry.getInstrumentation().getContext();
        // skip the test if WiFi is not supported
        assumeTrue(WifiFeature.isWifiSupported(mContext));

        mWifiManager = mContext.getSystemService(WifiManager.class);
        assertThat(mWifiManager).isNotNull();

        installApp(WIFI_LOCATION_TEST_APP_APK_PATH);

        // turn on verbose logging for tests
        mWasVerboseLoggingEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.isVerboseLoggingEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setVerboseLoggingEnabled(true));
        // Disable scan throttling for tests.
        mWasScanThrottleEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.isScanThrottleEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setScanThrottleEnabled(false));

        // enable Wifi
        if (!mWifiManager.isWifiEnabled()) setWifiEnabled(true);
        PollingCheck.check(""Wifi not enabled"", DURATION_MS, () -> mWifiManager.isWifiEnabled());

        // check we have >= 1 saved network
        List<WifiConfiguration> savedNetworks = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.getConfiguredNetworks());
        assertWithMessage(""Need at least one saved network"").that(savedNetworks).isNotEmpty();

        // ensure Wifi is connected
        ShellIdentityUtils.invokeWithShellPermissions(() -> mWifiManager.reconnect());
        PollingCheck.check(
                ""Wifi not connected"",
                WIFI_CONNECT_TIMEOUT_MILLIS,
                () -> mWifiManager.getConnectionInfo().getNetworkId() != -1);
    }

    @After
    public void tearDown() throws Exception {
        if (!WifiFeature.isWifiSupported(mContext)) return;

        uninstallApp(WIFI_LOCATION_TEST_APP_PACKAGE_NAME);

        if (!mWifiManager.isWifiEnabled()) setWifiEnabled(true);
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setScanThrottleEnabled(mWasScanThrottleEnabled));
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setVerboseLoggingEnabled(mWasVerboseLoggingEnabled));
    }

    private void setWifiEnabled(boolean enable) throws Exception {
        // now trigger the change using shell commands.
        SystemUtil.runShellCommand(""svc wifi "" + (enable ? ""enable"" : ""disable""));
    }

    private void turnScreenOn() throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation().executeShellCommand(
                ""input keyevent KEYCODE_WAKEUP"");
        InstrumentationRegistry.getInstrumentation().getUiAutomation().executeShellCommand(""""
                + ""wm dismiss-keyguard"");
        // Since the screen on/off intent is ordered, they will not be sent right now.
        Thread.sleep(2_000);
    }

    private void turnScreenOff() throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation().executeShellCommand(
                ""input keyevent KEYCODE_SLEEP"");
        // Since the screen on/off intent is ordered, they will not be sent right now.
        Thread.sleep(2_000);
    }

    private void installApp(String apk) throws InterruptedException {
        String installResult = SystemUtil.runShellCommand(""pm install -r -d "" + apk);
        Thread.sleep(10_000);
        assertThat(installResult.trim()).isEqualTo(""Success"");
    }

    private void uninstallApp(String pkg) throws InterruptedException {
        String uninstallResult = SystemUtil.runShellCommand(
                ""pm uninstall "" + pkg);
        Thread.sleep(10_000);
        assertThat(uninstallResult.trim()).isEqualTo(""Success"");
    }

    private void startFgActivityAndAssertStatusIs(
            ComponentName componentName, boolean status) throws Exception {
        turnScreenOn();

        WaitForResultActivity activity = mActivityRule.getActivity();
        activity.startActivityToWaitForResult(componentName);
        assertThat(activity.waitForActivityResult(DURATION_MS)).isEqualTo(status);
    }

    private void startBgServiceAndAssertStatusIs(
            ComponentName componentName, boolean status) throws Exception {
        turnScreenOff();

        WaitForResultActivity activity = mActivityRule.getActivity();
        activity.startServiceToWaitForResult(componentName);
        assertThat(activity.waitForServiceResult(DURATION_MS)).isEqualTo(status);
    }

    private void triggerScanFgActivityAndAssertStatusIs(boolean status) throws Exception {
        startFgActivityAndAssertStatusIs(new ComponentName(WIFI_LOCATION_TEST_APP_PACKAGE_NAME,
                WIFI_LOCATION_TEST_APP_TRIGGER_SCAN_ACTIVITY), status);
    }

    private void triggerScanBgServiceAndAssertStatusIs(boolean status) throws Exception {
        startBgServiceAndAssertStatusIs(new ComponentName(WIFI_LOCATION_TEST_APP_PACKAGE_NAME,
                WIFI_LOCATION_TEST_APP_TRIGGER_SCAN_SERVICE), status);
    }

    private void retrieveScanResultsFgActivityAndAssertStatusIs(boolean status) throws Exception {
        startFgActivityAndAssertStatusIs(new ComponentName(WIFI_LOCATION_TEST_APP_PACKAGE_NAME,
                WIFI_LOCATION_TEST_APP_RETRIEVE_SCAN_RESULTS_ACTIVITY), status);
    }

    private void retrieveScanResultsBgServiceAndAssertStatusIs(boolean status) throws Exception {
        startBgServiceAndAssertStatusIs(new ComponentName(WIFI_LOCATION_TEST_APP_PACKAGE_NAME,
                WIFI_LOCATION_TEST_APP_RETRIEVE_SCAN_RESULTS_SERVICE), status);
    }

    private void retrieveConnectionInfoFgActivityAndAssertStatusIs(boolean status)
            throws Exception {
        startFgActivityAndAssertStatusIs(new ComponentName(WIFI_LOCATION_TEST_APP_PACKAGE_NAME,
                WIFI_LOCATION_TEST_APP_RETRIEVE_CONNECTION_INFO_ACTIVITY), status);
    }

    private void retrieveConnectionInfoBgServiceAndAssertStatusIs(boolean status) throws Exception {
        startBgServiceAndAssertStatusIs(new ComponentName(WIFI_LOCATION_TEST_APP_PACKAGE_NAME,
                WIFI_LOCATION_TEST_APP_RETRIEVE_CONNECTION_INFO_SERVICE), status);
    }

    private void retrieveTransportInfoFgActivityAndAssertStatusIs(boolean status)
            throws Exception {
        startFgActivityAndAssertStatusIs(new ComponentName(WIFI_LOCATION_TEST_APP_PACKAGE_NAME,
                WIFI_LOCATION_TEST_APP_RETRIEVE_TRANSPORT_INFO_ACTIVITY), status);
    }

    private void retrieveTransportInfoBgServiceAndAssertStatusIs(boolean status) throws Exception {
        startBgServiceAndAssertStatusIs(new ComponentName(WIFI_LOCATION_TEST_APP_PACKAGE_NAME,
                WIFI_LOCATION_TEST_APP_RETRIEVE_TRANSPORT_INFO_SERVICE), status);
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiLocationInfoTest"	"testScanTriggerNotAllowedForForegroundActivityWithNoLocationPermission"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiLocationInfoTest.java"	""	"public void testScanTriggerNotAllowedForForegroundActivityWithNoLocationPermission()
            throws Exception {
        triggerScanFgActivityAndAssertStatusIs(false);
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiLocationInfoTest"	"testScanTriggerAllowedForForegroundActivityWithFineLocationPermission"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiLocationInfoTest.java"	""	"public void testScanTriggerAllowedForForegroundActivityWithFineLocationPermission()
            throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                WIFI_LOCATION_TEST_APP_PACKAGE_NAME, ACCESS_FINE_LOCATION);
        triggerScanFgActivityAndAssertStatusIs(true);
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiLocationInfoTest"	"testScanTriggerAllowedForBackgroundServiceWithBackgroundLocationPermission"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiLocationInfoTest.java"	""	"public void testScanTriggerAllowedForBackgroundServiceWithBackgroundLocationPermission()
            throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                WIFI_LOCATION_TEST_APP_PACKAGE_NAME, ACCESS_FINE_LOCATION);
        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                WIFI_LOCATION_TEST_APP_PACKAGE_NAME, ACCESS_BACKGROUND_LOCATION);
        triggerScanBgServiceAndAssertStatusIs(true);
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiLocationInfoTest"	"testScanTriggerNotAllowedForBackgroundServiceWithFineLocationPermission"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiLocationInfoTest.java"	""	"public void testScanTriggerNotAllowedForBackgroundServiceWithFineLocationPermission()
            throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                WIFI_LOCATION_TEST_APP_PACKAGE_NAME, ACCESS_FINE_LOCATION);
        triggerScanBgServiceAndAssertStatusIs(false);
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiLocationInfoTest"	"testScanResultsRetrievalNotAllowedForForegroundActivityWithNoLocationPermission"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiLocationInfoTest.java"	""	"public void testScanResultsRetrievalNotAllowedForForegroundActivityWithNoLocationPermission()
            throws Exception {
        retrieveScanResultsFgActivityAndAssertStatusIs(false);
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiLocationInfoTest"	"testScanResultsRetrievalAllowedForForegroundActivityWithFineLocationPermission"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiLocationInfoTest.java"	""	"public void testScanResultsRetrievalAllowedForForegroundActivityWithFineLocationPermission()
            throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                WIFI_LOCATION_TEST_APP_PACKAGE_NAME, ACCESS_FINE_LOCATION);
        retrieveScanResultsFgActivityAndAssertStatusIs(true);
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiLocationInfoTest"	"testScanResultsRetrievalAllowedForBackgroundServiceWithBackgroundLocationPermission"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiLocationInfoTest.java"	""	"public void testScanResultsRetrievalAllowedForBackgroundServiceWithBackgroundLocationPermission()
            throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                WIFI_LOCATION_TEST_APP_PACKAGE_NAME, ACCESS_FINE_LOCATION);
        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                WIFI_LOCATION_TEST_APP_PACKAGE_NAME, ACCESS_BACKGROUND_LOCATION);
        retrieveScanResultsBgServiceAndAssertStatusIs(true);
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiLocationInfoTest"	"testScanResultsRetrievalNotAllowedForBackgroundServiceWithFineLocationPermission"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiLocationInfoTest.java"	""	"public void testScanResultsRetrievalNotAllowedForBackgroundServiceWithFineLocationPermission()
            throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                WIFI_LOCATION_TEST_APP_PACKAGE_NAME, ACCESS_FINE_LOCATION);
        retrieveScanResultsBgServiceAndAssertStatusIs(false);
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.wifibroadcasts.cts.WifiBroadcastsHostJUnit4Test"	"testCleanLogcat"	"CtsWifiBroadcastsHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/wifibroadcasts/src/android/wifibroadcasts/cts/WifiBroadcastsHostJUnit4Test.java"	""	"public void testCleanLogcat() throws Exception {
        ITestDevice device = getDevice();
        assertNotNull(""Device not set"", device);
        if (!device.hasFeature(FEATURE_WIFI)) {
            return;
        }
        // Clear activity
        device.executeShellCommand(CLEAR_COMMAND);
        // No mobile data or wifi to start with
        device.executeShellCommand(""svc data disable; svc wifi disable"");
        // Clear logcat.
        device.executeAdbCommand(""logcat"", ""-c"");
        // Ensure the screen is on, so that rssi polling happens
        device.executeShellCommand(""input keyevent KEYCODE_WAKEUP"");
        // Start the APK
        device.executeShellCommand(START_COMMAND);
        // Bring up wifi
        device.executeShellCommand(""svc wifi enable; sleep 1"");
        // Make sure wifi comes up
        String pingResult = """";
        CommandResult pingCommandResult = null;
        boolean pingSucceeded = false;
        for (int tries = 0; tries < MAXIMUM_PING_TRIES; tries++) {
            if (tries > 0 && tries % MAXIMUM_PING_TRIES_PER_CONNECTION == 0) {
                // if we have been trying for a while, toggle wifi off and then on.
                device.executeShellCommand(""svc wifi disable; sleep 1; svc wifi enable; sleep 3"");
            }
            // We don't require internet connectivity, just a configured address
            pingCommandResult = device.executeShellV2Command(""ping -c 4 -W 2 -t 1 8.8.8.8"");
            pingResult = String.join(""/"", pingCommandResult.getStdout(),
                                          pingCommandResult.getStderr(),
                                          pingCommandResult.getStatus().toString());
            if (pingResult.contains(""4 packets transmitted"")) {
                pingSucceeded = true;
                break;
            }
            Thread.sleep(1000);
        }
        // Stop wifi
        device.executeShellCommand(""svc wifi disable"");

        assertTrue(""Wi-Fi network unavailable - test could not complete "" + pingResult,
                pingSucceeded);

        // Dump logcat.
        String logs = device.executeAdbCommand(""logcat"", ""-v"", ""brief"", ""-d"", CLASS + "":I"", ""*:S"");
        // Search for prohibited string.
        Scanner in = new Scanner(logs);
        try {
            while (in.hasNextLine()) {
                String line = in.nextLine();
                if (line.startsWith(""I/"" + CLASS)) {
                    String payload = line.split("":"")[1].trim();
                    assertFalse(payload, payload.contains(PROHIBITED_STRING));
                }
            }
        } finally {
            in.close();
        }
        //Re-enable Wi-Fi as part of CTS Pre-conditions
        device.executeShellCommand(""svc wifi enable; sleep 1"");
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.provider.cts.media.MediaStore_Audio_MediaTest"	"testCanonicalize"	"CtsProviderTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/provider/src/android/provider/cts/media/MediaStore_Audio_MediaTest.java"	""	"(timeout = 60000)
    public void testCanonicalize() throws Exception {
        // Remove all audio left over from other tests
        ProviderTestUtils.executeShellCommand(""content delete""
                + "" --user "" + InstrumentationRegistry.getTargetContext().getUserId()
                + "" --uri "" + mExternalAudio,
                InstrumentationRegistry.getInstrumentation().getUiAutomation());

        // Publish some content
        final File dir = ProviderTestUtils.stageDir(mVolumeName);
        final Uri a = ProviderTestUtils.scanFileFromShell(
                ProviderTestUtils.stageFile(R.raw.testmp3_2, new File(dir, ""a.mp3"")));
        final Uri b = ProviderTestUtils.scanFileFromShell(
                ProviderTestUtils.stageFile(R.raw.testmp3, new File(dir, ""b.mp3"")));
        final Uri c = ProviderTestUtils.scanFileFromShell(
                ProviderTestUtils.stageFile(R.raw.testmp3_2, new File(dir, ""c.mp3"")));

        // Confirm we can canonicalize and recover it
        final Uri canonicalized = mContentResolver.canonicalize(b);
        assertNotNull(canonicalized);
        assertEquals(b, mContentResolver.uncanonicalize(canonicalized));

        // Delete all items above
        mContentResolver.delete(a, null, null);
        mContentResolver.delete(b, null, null);
        mContentResolver.delete(c, null, null);

        // Confirm canonical item isn't found
        assertNull(mContentResolver.uncanonicalize(canonicalized));

        // Publish data again and confirm we can recover it
        final Uri d = ProviderTestUtils.scanFileFromShell(
                ProviderTestUtils.stageFile(R.raw.testmp3, new File(dir, ""d.mp3"")));
        assertEquals(d, mContentResolver.uncanonicalize(canonicalized));
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.video.cts.VideoEncoderDecoderTest"	"initPerfTest"	"CtsVideoTestCases"	"/home/gpoor/cts-12-source/cts/tests/video/src/android/video/cts/VideoEncoderDecoderTest.java"	""	"public void test/*
 *.
 */

package android.video.cts;

import android.graphics.ImageFormat;
import android.graphics.Point;
import android.media.Image;
import android.media.Image.Plane;
import android.media.MediaCodec;
import android.media.MediaCodec.BufferInfo;
import android.media.MediaCodecInfo;
import android.media.MediaCodecInfo.CodecCapabilities;
import android.media.MediaFormat;
import android.media.cts.CodecImage;
import android.media.cts.CodecUtils;
import android.media.cts.YUVImage;
import android.os.Build;
import android.util.Log;
import android.util.Pair;
import android.util.Range;

import com.android.compatibility.common.util.CtsAndroidTestCase;
import com.android.compatibility.common.util.DeviceReportLog;
import com.android.compatibility.common.util.MediaPerfUtils;
import com.android.compatibility.common.util.MediaUtils;
import com.android.compatibility.common.util.ResultType;
import com.android.compatibility.common.util.ResultUnit;
import com.android.compatibility.common.util.Stat;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.Random;
import java.util.Scanner;

/**
 * This tries to test video encoder / decoder performance by running encoding / decoding
 * without displaying the raw data. To make things simpler, encoder is used to encode synthetic
 * data and decoder is used to decode the encoded video. This approach does not work where
 * there is only decoder. Performance index is total time taken for encoding and decoding
 * the whole frames.
 * To prevent sacrificing quality for faster encoding / decoding, randomly selected pixels are
 * compared with the original image. As the pixel comparison can slow down the decoding process,
 * only some randomly selected pixels are compared. As there can be only one performance index,
 * error above certain threshold in pixel value will be treated as an error.
 */
public class VideoEncoderDecoderTest extends CtsAndroidTestCase {
    private static final String TAG = ""VideoEncoderDecoderTest"";
    private static final String REPORT_LOG_NAME = ""CtsVideoTestCases"";
    // this wait time affects fps as too big value will work as a blocker if device fps
    // is not very high.
    private static final long VIDEO_CODEC_WAIT_TIME_US = 1000;
    private static final boolean VERBOSE = false;
    private static final int MAX_FPS = 30; // measure performance at 30fps, this is relevant for
                                           // the meaning of bitrate

    private static final String AVC = MediaFormat.MIMETYPE_VIDEO_AVC;
    private static final String H263 = MediaFormat.MIMETYPE_VIDEO_H263;
    private static final String HEVC = MediaFormat.MIMETYPE_VIDEO_HEVC;
    private static final String MPEG2 = MediaFormat.MIMETYPE_VIDEO_MPEG2;
    private static final String MPEG4 = MediaFormat.MIMETYPE_VIDEO_MPEG4;
    private static final String VP8 = MediaFormat.MIMETYPE_VIDEO_VP8;
    private static final String VP9 = MediaFormat.MIMETYPE_VIDEO_VP9;

    private static final boolean GOOG = true;
    private static final boolean OTHER = false;

    // test results:

    private int mCurrentTestRound = 0;
    private double[][] mEncoderFrameTimeUsDiff;
    private double[] mEncoderFpsResults;

    private double[][] mDecoderFrameTimeUsDiff;
    private double[] mDecoderFpsResults;
    private double[] mTotalFpsResults;
    private double[] mDecoderRmsErrorResults;

    // i frame interval for encoder
    private static final int KEY_I_FRAME_INTERVAL = 5;
    private static final int MAX_TEST_TIMEOUT_MS = 300000;   // 5 minutes

    private static final int Y_CLAMP_MIN = 16;
    private static final int Y_CLAMP_MAX = 235;
    private static final int YUV_PLANE_ADDITIONAL_LENGTH = 200;
    private ByteBuffer mYBuffer, mYDirectBuffer;
    private ByteBuffer mUVBuffer, mUVDirectBuffer;
    private int mSrcColorFormat;
    private int mDstColorFormat;
    private int mBufferWidth;
    private int mBufferHeight;
    private int mVideoWidth;
    private int mVideoHeight;
    private int mVideoStride;
    private int mVideoVStride;
    private int mFrameRate;

    private MediaFormat mEncConfigFormat;
    private MediaFormat mEncInputFormat;
    private MediaFormat mEncOutputFormat;
    private MediaFormat mDecOutputFormat;

    private LinkedList<Pair<ByteBuffer, BufferInfo>> mEncodedOutputBuffer;
    // check this many pixels per each decoded frame
    // checking too many points decreases decoder frame rates a lot.
    private static final int PIXEL_CHECK_PER_FRAME = 1000;
    // RMS error in pixel values above this will be treated as error.
    private static final double PIXEL_RMS_ERROR_MARGIN = 20.0;
    private double mRmsErrorMargin;
    private Random mRandom;

    private class TestConfig {
        public boolean mTestPixels = true;
        public boolean mReportFrameTime = false;
        public int mTotalFrames = 300;
        public int mMinNumFrames = 300;
        public int mMaxTimeMs = 120000;  // 2 minutes
        public int mMinTimeMs = 10000;   // 10 seconds
        public int mNumberOfRepeat = 10;

        public void initPerfTest() {
            mTestPixels = false;
            mTotalFrames = 30000;
            mMinNumFrames = 3000;
            mNumberOfRepeat = 2;
        }
    }

    private TestConfig mTestConfig;

    private static boolean isPreferredAbi() {
        boolean prefers64Bit = false;
        if (Build.SUPPORTED_64_BIT_ABIS.length > 0 &&
                Build.SUPPORTED_ABIS.length > 0 &&
                Build.SUPPORTED_ABIS[0].equals(Build.SUPPORTED_64_BIT_ABIS[0])) {
            prefers64Bit = true;
        }
        return android.os.Process.is64Bit() ? prefers64Bit : !prefers64Bit;
    }

    @Override
    protected void setUp() throws Exception {
        mEncodedOutputBuffer = new LinkedList<Pair<ByteBuffer, BufferInfo>>();
        mRmsErrorMargin = PIXEL_RMS_ERROR_MARGIN;
        // Use time as a seed, hoping to prevent checking pixels in the same pattern
        long now = System.currentTimeMillis();
        mRandom = new Random(now);
        mTestConfig = new TestConfig();
        super.setUp();
    }

    @Override
    protected void tearDown() throws Exception {
        mEncodedOutputBuffer.clear();
        mEncodedOutputBuffer = null;
        mYBuffer = null;
        mUVBuffer = null;
        mYDirectBuffer = null;
        mUVDirectBuffer = null;
        mRandom = null;
        mTestConfig = null;
        super.tearDown();
    }

    private void count(String mime, int width, int height, int numGoog, int numOther)
            throws Exception {
        MediaFormat format = MediaFormat.createVideoFormat(mime, width, height);
        MediaUtils.verifyNumCodecs(numGoog,  true /* isEncoder */, true /* isGoog */,  format);
        MediaUtils.verifyNumCodecs(numOther, true /* isEncoder */, false /* isGoog */, format);
    }

    /** run performance test. */
    private void perf(String mimeType, int w, int h, boolean isGoog, int ix) throws Exception {
        doTest(mimeType, w, h, true /* isPerf */, isGoog, ix);
    }

    /** run quality test. */
    private void qual(String mimeType, int w, int h, boolean isGoog, int ix) throws Exception {
        doTest(mimeType, w, h, false /* isPerf */, isGoog, ix);
    }

    /** run quality test but do not report error. */
    private void qual(String mimeType, int w, int h, boolean isGoog, int ix, double margin)
            throws Exception {
        mRmsErrorMargin = margin;
        doTest(mimeType, w, h, false /* isPerf */, isGoog, ix);
    }

    // Poor man's Parametrized test as this test must still run on CTSv1 runner.

    // The count tests are to ensure this Cts test covers all encoders. Add further
    // tests and change the count if there can be more encoders.

    // AVC tests"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.server.wm.KeyguardLockedTests"	"testDismissKeyguardActivity_method_cancelled"	"CtsWindowManagerDeviceTestCases"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/KeyguardLockedTests.java"	""	"public void testDismissKeyguardActivity_method_cancelled() {
        // Pressing the back button does not cancel Keyguard in AAOS.
        assumeFalse(isCar());

        final LockScreenSession lockScreenSession = createManagedLockScreenSession();
        lockScreenSession.setLockCredential();
        separateTestJournal();

        lockScreenSession.gotoKeyguard();
        mWmState.computeState();
        assertTrue(mWmState.getKeyguardControllerState().keyguardShowing);

        launchActivity(DISMISS_KEYGUARD_METHOD_ACTIVITY);
        pressBackButton();
        assertOnDismissCancelled(DISMISS_KEYGUARD_METHOD_ACTIVITY);
        mWmState.computeState();
        mWmState.assertVisibility(DISMISS_KEYGUARD_METHOD_ACTIVITY, false);
        assertTrue(mWmState.getKeyguardControllerState().keyguardShowing);
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.media.tv.cts.TvInputServiceTest"	"xPrecision"	"CtsTvTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/tv/src/android/media/tv/cts/TvInputServiceTest.java"	""	"public void verifyCallbackLayoutSurface() {
        final CountingSession session = tune(CHANNEL_0);
        final int left = 10;
        final int top = 20;
        final int right = 30;
        final int bottom = 40;

        session.layoutSurface(left, top, right, bottom);
        PollingCheck.waitFor(TIME_OUT, () -> {
            final AtomicBoolean retValue = new AtomicBoolean();
            onTvView(tvView -> {
                int childCount = tvView.getChildCount();
                for (int i = 0; i < childCount; ++i) {
                    View v = tvView.getChildAt(i);
                    if (v instanceof SurfaceView) {
                        retValue.set(v.getLeft() == left && v.getTop() == top
                                && v.getRight() == right
                                && v.getBottom() == bottom
                        );
                        break;
                    }
                }
            });
            mInstrumentation.waitForIdleSync();
            return retValue.get();
        });
    }

    public static void assertKeyEventEquals(KeyEvent actual, KeyEvent expected) {
        if ((expected == null) != (actual == null)) {
            // Fail miss matched nulls early using the StandardSubject
            Truth.assertThat(actual).isEqualTo(expected);
        } else if (expected != null && actual != null) {
            assertThat(actual.getDownTime()).isEqualTo(expected.getDownTime());
            assertThat(actual.getEventTime()).isEqualTo(expected.getEventTime());
            assertThat(actual.getAction()).isEqualTo(expected.getAction());
            assertThat(actual.getKeyCode()).isEqualTo(expected.getKeyCode());
            assertThat(actual.getRepeatCount()).isEqualTo(expected.getRepeatCount());
            assertThat(actual.getMetaState()).isEqualTo(expected.getMetaState());
            assertThat(actual.getDeviceId()).isEqualTo(expected.getDeviceId());
            assertThat(actual.getScanCode()).isEqualTo(expected.getScanCode());
            assertThat(actual.getFlags()).isEqualTo(expected.getFlags());
            assertThat(actual.getSource()).isEqualTo(expected.getSource());
            assertThat(actual.getCharacters()).isEqualTo(expected.getCharacters());
        }// else both null so do nothing
    }

    public static void assertMotionEventEquals(MotionEvent actual, MotionEvent expected) {
        if ((expected == null) != (actual == null)) {
            // Fail miss matched nulls early using the StandardSubject
            Truth.assertThat(actual).isEqualTo(expected);
        } else if (expected != null && actual != null) {
            assertThat(actual).hasDownTime(expected.getDownTime());
            assertThat(actual).hasEventTime(expected.getEventTime());
            assertThat(actual).hasAction(expected.getAction());
            assertThat(actual).x().isEqualTo(expected.getX());
            assertThat(actual).y().isEqualTo(expected.getY());
            assertThat(actual).pressure().isEqualTo(expected.getPressure());
            assertThat(actual).size().isEqualTo(expected.getSize());
            assertThat(actual).hasMetaState(expected.getMetaState());
            assertThat(actual).xPrecision().isEqualTo(expected.getXPrecision());
            assertThat(actual).yPrecision().isEqualTo(expected.getYPrecision());
            assertThat(actual).hasDeviceId(expected.getDeviceId());
            assertThat(actual).hasEdgeFlags(expected.getEdgeFlags());
            assertThat(actual.getSource()).isEqualTo(expected.getSource());

        } // else both null so do nothing
    }

    public static void assertPlaybackParamsEquals(PlaybackParams actual, PlaybackParams expected) {
        if ((expected == null) != (actual == null)) {
            // Fail miss matched nulls early using the StandardSubject
            Truth.assertThat(actual).isEqualTo(expected);
        } else if (expected != null && actual != null) {
            assertThat(actual.getAudioFallbackMode()).isEqualTo(expected.getAudioFallbackMode());
            assertThat(actual.getSpeed()).isEqualTo(expected.getSpeed());
        } // else both null so do nothing
    }

    private static void assertBundlesAreEqual(Bundle actual, Bundle expected) {
        if ((expected == null) != (actual == null)) {
            // Fail miss matched nulls early using the StandardSubject
            Truth.assertThat(actual).isEqualTo(expected);
        } else if (expected != null && actual != null) {
            assertThat(actual.keySet()).isEqualTo(expected.keySet());
            for (String key : expected.keySet()) {
                assertThat(actual.get(key)).isEqualTo(expected.get(key));
            }
        }
    }

    private void notifyTuned(Uri uri) {
        final CountingRecordingSession session = CountingTvInputService.sRecordingSession;
        session.notifyTuned(uri);
        PollingCheck.waitFor(TIME_OUT, () -> mRecordingCallback.mTunedCount > 0);
    }

    private void onTvView(Consumer<TvView> tvViewConsumer) {
        activityRule.getScenario().onActivity(viewAction(tvViewConsumer));

    }

    private void resetCounts() {
        if (CountingTvInputService.sSession != null) {
            CountingTvInputService.sSession.resetCounts();
        }
        if (CountingTvInputService.sRecordingSession != null) {
            CountingTvInputService.sRecordingSession.resetCounts();
        }
        mCallback.resetCounts();
        mTimeShiftPositionCallback.resetCounts();
        mRecordingCallback.resetCounts();
    }

    private void resetPassedValues() {
        if (CountingTvInputService.sSession != null) {
            CountingTvInputService.sSession.resetPassedValues();
        }
        if (CountingTvInputService.sRecordingSession != null) {
            CountingTvInputService.sRecordingSession.resetPassedValues();
        }
        mCallback.resetPassedValues();
        mRecordingCallback.resetPassedValues();
    }

    @NonNull
    private static PollingCheck.PollingCheckCondition recordingSessionCheck(
            ToBooleanFunction<CountingRecordingSession> toBooleanFunction) {
        return () -> {
            final CountingRecordingSession session = CountingTvInputService.sRecordingSession;
            return session != null && toBooleanFunction.apply(session);
        };
    }

    @NonNull
    private static PollingCheck.PollingCheckCondition sessionCheck(
            ToBooleanFunction<CountingSession> toBooleanFunction) {
        return () -> {
            final CountingSession session = CountingTvInputService.sSession;
            return session != null && toBooleanFunction.apply(session);
        };
    }

    @NonNull
    private CountingSession tune(Uri uri) {
        onTvView(tvView -> {
            tvView.setCallback(mCallback);
            tvView.tune(mStubInfo.getId(), CHANNEL_0);
        });
        return waitForSessionCheck(session -> session.mTuneCount > 0);
    }

    @NonNull
    private CountingRecordingSession tuneForRecording(Uri uri) {
        mTvRecordingClient.tune(mStubInfo.getId(), uri);
        return waitForRecordingSessionCheck(s -> s.mTuneCount > 0);
    }

    @NonNull
    private CountingRecordingSession tuneForRecording(Uri uri, Bundle bundle) {
        mTvRecordingClient.tune(mStubInfo.getId(), uri, bundle);
        return waitForRecordingSessionCheck(s -> s.mTuneCount > 0 && s.mTuneWithBundleCount > 0);
    }

    @NonNull
    private static ActivityScenario.ActivityAction<TvViewStubActivity> viewAction(
            Consumer<TvView> consumer) {
        return activity -> consumer.accept(activity.getTvView());
    }

    @NonNull
    private static CountingSession waitForSessionCheck(
            ToBooleanFunction<CountingSession> countingSessionToBooleanFunction) {
        PollingCheck.waitFor(TIME_OUT, sessionCheck(countingSessionToBooleanFunction));
        return CountingTvInputService.sSession;
    }

    @NonNull
    private static CountingRecordingSession waitForRecordingSessionCheck(
            ToBooleanFunction<CountingRecordingSession> toBool) {
        PollingCheck.waitFor(TIME_OUT, recordingSessionCheck(toBool));
        return CountingTvInputService.sRecordingSession;
    }

    public static class CountingTvInputService extends StubTvInputService {

        static CountingSession sSession;
        static CountingRecordingSession sRecordingSession;

        @Override
        public Session onCreateSession(String inputId) {
            return onCreateSession(inputId, null);
        }

        @Override
        public Session onCreateSession(String inputId, String tvInputSessionId) {
            if(sSession != null){
                Log.w(TAG,""onCreateSession called with sSession set to ""+ sSession);
            }
            sSession = new CountingSession(this, tvInputSessionId);
            sSession.setOverlayViewEnabled(true);
            return sSession;
        }

        @Override
        public RecordingSession onCreateRecordingSession(String inputId) {
            return onCreateRecordingSession(inputId, null);
        }

        @Override
        public RecordingSession onCreateRecordingSession(String inputId, String tvInputSessionId) {
            if (sRecordingSession != null) {
                Log.w(TAG, ""onCreateRecordingSession called with sRecordingSession set to ""
                        + sRecordingSession);
            }
            sRecordingSession = new CountingRecordingSession(this, tvInputSessionId);
            return sRecordingSession;
        }

        @Override
        public IBinder createExtension() {
            super.createExtension();
            return null;
        }

        public static class CountingSession extends Session {
            public final String mSessionId;

            public volatile int mTuneCount;
            public volatile int mTuneWithBundleCount;
            public volatile int mSetStreamVolumeCount;
            public volatile int mSetCaptionEnabledCount;
            public volatile int mSelectTrackCount;
            public volatile int mCreateOverlayView;
            public volatile int mKeyDownCount;
            public volatile int mKeyLongPressCount;
            public volatile int mKeyMultipleCount;
            public volatile int mKeyUpCount;
            public volatile int mTouchEventCount;
            public volatile int mTrackballEventCount;
            public volatile int mGenricMotionEventCount;
            public volatile int mOverlayViewSizeChangedCount;
            public volatile int mTimeShiftPauseCount;
            public volatile int mTimeShiftResumeCount;
            public volatile int mTimeShiftSeekToCount;
            public volatile int mTimeShiftSetPlaybackParamsCount;
            public volatile int mTimeShiftPlayCount;
            public volatile long mTimeShiftGetCurrentPositionCount;
            public volatile long mTimeShiftGetStartPositionCount;
            public volatile int mAppPrivateCommandCount;

            public volatile String mAppPrivateCommandAction;
            public volatile Bundle mAppPrivateCommandData;
            public volatile Uri mTunedChannelUri;
            public volatile Bundle mTuneWithBundleData;
            public volatile Float mStreamVolume;
            public volatile Boolean mCaptionEnabled;
            public volatile Integer mSelectTrackType;
            public volatile String mSelectTrackId;
            public volatile Integer mKeyDownCode;
            public volatile KeyEvent mKeyDownEvent;
            public volatile Integer mKeyLongPressCode;
            public volatile KeyEvent mKeyLongPressEvent;
            public volatile Integer mKeyMultipleCode;
            public volatile Integer mKeyMultipleNumber;
            public volatile KeyEvent mKeyMultipleEvent;
            public volatile Integer mKeyUpCode;
            public volatile KeyEvent mKeyUpEvent;
            public volatile MotionEvent mTouchEvent;
            public volatile MotionEvent mTrackballEvent;
            public volatile MotionEvent mGenricMotionEvent;
            public volatile Long mTimeShiftSeekTo;
            public volatile PlaybackParams mTimeShiftSetPlaybackParams;
            public volatile Uri mRecordedProgramUri;
            public volatile Integer mOverlayViewSizeChangedWidth;
            public volatile Integer mOverlayViewSizeChangedHeight;


            CountingSession(Context context, @Nullable String sessionId) {

                super(context);
                mSessionId = sessionId;

            }

            public void resetCounts() {
                mTuneCount = 0;
                mTuneWithBundleCount = 0;
                mSetStreamVolumeCount = 0;
                mSetCaptionEnabledCount = 0;
                mSelectTrackCount = 0;
                mCreateOverlayView = 0;
                mKeyDownCount = 0;
                mKeyLongPressCount = 0;
                mKeyMultipleCount = 0;
                mKeyUpCount = 0;
                mTouchEventCount = 0;
                mTrackballEventCount = 0;
                mGenricMotionEventCount = 0;
                mOverlayViewSizeChangedCount = 0;
                mTimeShiftPauseCount = 0;
                mTimeShiftResumeCount = 0;
                mTimeShiftSeekToCount = 0;
                mTimeShiftSetPlaybackParamsCount = 0;
                mTimeShiftPlayCount = 0;
                mTimeShiftGetCurrentPositionCount = 0;
                mTimeShiftGetStartPositionCount = 0;
                mAppPrivateCommandCount = 0;
            }

            public void resetPassedValues() {
                mAppPrivateCommandAction = null;
                mAppPrivateCommandData = null;
                mTunedChannelUri = null;
                mTuneWithBundleData = null;
                mStreamVolume = null;
                mCaptionEnabled = null;
                mSelectTrackType = null;
                mSelectTrackId = null;
                mKeyDownCode = null;
                mKeyDownEvent = null;
                mKeyLongPressCode = null;
                mKeyLongPressEvent = null;
                mKeyMultipleCode = null;
                mKeyMultipleNumber = null;
                mKeyMultipleEvent = null;
                mKeyUpCode = null;
                mKeyUpEvent = null;
                mTouchEvent = null;
                mTrackballEvent = null;
                mGenricMotionEvent = null;
                mTimeShiftSeekTo = null;
                mTimeShiftSetPlaybackParams = null;
                mRecordedProgramUri = null;
                mOverlayViewSizeChangedWidth = null;
                mOverlayViewSizeChangedHeight = null;
            }

            @Override
            public void onAppPrivateCommand(String action, Bundle data) {
                mAppPrivateCommandCount++;
                mAppPrivateCommandAction = action;
                mAppPrivateCommandData = data;
            }

            @Override
            public void onRelease() {
            }

            @Override
            public boolean onSetSurface(Surface surface) {
                return false;
            }

            @Override
            public boolean onTune(Uri channelUri) {
                mTuneCount++;
                mTunedChannelUri = channelUri;
                return false;
            }

            @Override
            public boolean onTune(Uri channelUri, Bundle data) {
                mTuneWithBundleCount++;
                mTuneWithBundleData = data;
                // Also calls {@link #onTune(Uri)} since it will never be called if the
                // implementation overrides {@link #onTune(Uri, Bundle)}.
                onTune(channelUri);
                return false;
            }

            @Override
            public void onSetStreamVolume(float volume) {
                mSetStreamVolumeCount++;
                mStreamVolume = volume;
            }

            @Override
            public void onSetCaptionEnabled(boolean enabled) {
                mSetCaptionEnabledCount++;
                mCaptionEnabled = enabled;
            }

            @Override
            public boolean onSelectTrack(int type, String id) {
                mSelectTrackCount++;
                mSelectTrackType = type;
                mSelectTrackId = id;
                return false;
            }

            @Override
            public View onCreateOverlayView() {
                mCreateOverlayView++;
                return null;
            }

            @Override
            public boolean onKeyDown(int keyCode, KeyEvent event) {
                mKeyDownCount++;
                mKeyDownCode = keyCode;
                mKeyDownEvent = event;
                return false;
            }

            @Override
            public boolean onKeyLongPress(int keyCode, KeyEvent event) {
                mKeyLongPressCount++;
                mKeyLongPressCode = keyCode;
                mKeyLongPressEvent = event;
                return false;
            }

            @Override
            public boolean onKeyMultiple(int keyCode, int count, KeyEvent event) {
                mKeyMultipleCount++;
                mKeyMultipleCode = keyCode;
                mKeyMultipleNumber = count;
                mKeyMultipleEvent = event;
                return false;
            }

            @Override
            public boolean onKeyUp(int keyCode, KeyEvent event) {
                mKeyUpCount++;
                mKeyUpCode = keyCode;
                mKeyUpEvent = event;
                return false;
            }

            @Override
            public boolean onTouchEvent(MotionEvent event) {
                mTouchEventCount++;
                mTouchEvent = event;
                return false;
            }

            @Override
            public boolean onTrackballEvent(MotionEvent event) {
                mTrackballEventCount++;
                mTrackballEvent = event;
                return false;
            }

            @Override
            public boolean onGenericMotionEvent(MotionEvent event) {
                mGenricMotionEventCount++;
                mGenricMotionEvent = event;
                return false;
            }

            @Override
            public void onTimeShiftPause() {
                mTimeShiftPauseCount++;
            }

            @Override
            public void onTimeShiftResume() {
                mTimeShiftResumeCount++;
            }

            @Override
            public void onTimeShiftSeekTo(long timeMs) {
                mTimeShiftSeekToCount++;
                mTimeShiftSeekTo = timeMs;
            }

            @Override
            public void onTimeShiftSetPlaybackParams(PlaybackParams param) {
                mTimeShiftSetPlaybackParamsCount++;
                mTimeShiftSetPlaybackParams = param;
            }

            @Override
            public void onTimeShiftPlay(Uri recordedProgramUri) {
                mTimeShiftPlayCount++;
                mRecordedProgramUri = recordedProgramUri;
            }

            @Override
            public long onTimeShiftGetCurrentPosition() {
                return ++mTimeShiftGetCurrentPositionCount;
            }

            @Override
            public long onTimeShiftGetStartPosition() {
                return ++mTimeShiftGetStartPositionCount;
            }

            @Override
            public void onOverlayViewSizeChanged(int width, int height) {
                mOverlayViewSizeChangedCount++;
                mOverlayViewSizeChangedWidth = width;
                mOverlayViewSizeChangedHeight = height;
            }
        }

        public static class CountingRecordingSession extends RecordingSession {
            public final String mSessionId;

            public volatile int mTuneCount;
            public volatile int mTuneWithBundleCount;
            public volatile int mReleaseCount;
            public volatile int mStartRecordingCount;
            public volatile int mStartRecordingWithBundleCount;
            public volatile int mPauseRecordingWithBundleCount;
            public volatile int mResumeRecordingWithBundleCount;
            public volatile int mStopRecordingCount;
            public volatile int mAppPrivateCommandCount;

            public volatile Uri mTunedChannelUri;
            public volatile Bundle mTuneWithBundleData;
            public volatile Uri mProgramHint;
            public volatile Bundle mStartRecordingWithBundleData;
            public volatile Bundle mPauseRecordingWithBundleData;
            public volatile Bundle mResumeRecordingWithBundleData;
            public volatile String mAppPrivateCommandAction;
            public volatile Bundle mAppPrivateCommandData;

            CountingRecordingSession(Context context, @Nullable String sessionId) {
                super(context);
                mSessionId = sessionId;
            }

            public void resetCounts() {
                mTuneCount = 0;
                mTuneWithBundleCount = 0;
                mReleaseCount = 0;
                mStartRecordingCount = 0;
                mStartRecordingWithBundleCount = 0;
                mPauseRecordingWithBundleCount = 0;
                mResumeRecordingWithBundleCount = 0;
                mStopRecordingCount = 0;
                mAppPrivateCommandCount = 0;
            }

            public void resetPassedValues() {
                mTunedChannelUri = null;
                mTuneWithBundleData = null;
                mProgramHint = null;
                mStartRecordingWithBundleData = null;
                mPauseRecordingWithBundleData = null;
                mResumeRecordingWithBundleData = null;
                mAppPrivateCommandAction = null;
                mAppPrivateCommandData = null;
            }

            @Override
            public void onTune(Uri channelUri) {
                mTuneCount++;
                mTunedChannelUri = channelUri;
            }

            @Override
            public void onTune(Uri channelUri, Bundle data) {
                mTuneWithBundleCount++;
                mTuneWithBundleData = data;
                // Also calls {@link #onTune(Uri)} since it will never be called if the
                // implementation overrides {@link #onTune(Uri, Bundle)}.
                onTune(channelUri);
            }

            @Override
            public void onRelease() {
                mReleaseCount++;
            }

            @Override
            public void onStartRecording(Uri programHint) {
                mStartRecordingCount++;
                mProgramHint = programHint;
            }

            @Override
            public void onStartRecording(Uri programHint, Bundle data) {
                mStartRecordingWithBundleCount++;
                mProgramHint = programHint;
                mStartRecordingWithBundleData = data;
                // Also calls {@link #onStartRecording(Uri)} since it will never be called if the
                // implementation overrides {@link #onStartRecording(Uri, Bundle)}.
                onStartRecording(programHint);
            }

            @Override
            public void onPauseRecording(Bundle data) {
                mPauseRecordingWithBundleCount++;
                mPauseRecordingWithBundleData = data;
            }

            @Override
            public void onResumeRecording(Bundle data) {
                mResumeRecordingWithBundleCount++;
                mResumeRecordingWithBundleData = data;

            }

            @Override
            public void onStopRecording() {
                mStopRecordingCount++;
            }

            @Override
            public void onAppPrivateCommand(String action, Bundle data) {
                mAppPrivateCommandCount++;
                mAppPrivateCommandAction = action;
                mAppPrivateCommandData = data;
            }
        }
    }

    private static class StubRecordingCallback extends TvRecordingClient.RecordingCallback {
        private int mTunedCount;
        private int mRecordingStoppedCount;
        private int mErrorCount;
        private int mConnectionFailedCount;
        private int mDisconnectedCount;

        private Uri mTunedChannelUri;
        private Uri mRecordedProgramUri;
        private Integer mError;

        @Override
        public void onTuned(Uri channelUri) {
            mTunedCount++;
            mTunedChannelUri = channelUri;
        }

        @Override
        public void onRecordingStopped(Uri recordedProgramUri) {
            mRecordingStoppedCount++;
            mRecordedProgramUri = recordedProgramUri;
        }

        @Override
        public void onError(int error) {
            mErrorCount++;
            mError = error;
        }

        @Override
        public void onConnectionFailed(String inputId) {
            mConnectionFailedCount++;
        }

        @Override
        public void onDisconnected(String inputId) {
            mDisconnectedCount++;
        }

        public void resetCounts() {
            mTunedCount = 0;
            mRecordingStoppedCount = 0;
            mErrorCount = 0;
            mConnectionFailedCount = 0;
            mDisconnectedCount = 0;
        }

        public void resetPassedValues() {
            mTunedChannelUri = null;
            mRecordedProgramUri = null;
            mError = null;
        }
    }


    // Copied from {@link com.android.internal.util.ToBooleanFunction}
    /**
     * Represents a function that produces an boolean-valued result.  This is the
     * {@code boolean}-producing primitive specialization for {@link Function}.
     *
     * <p>This is a <a href=""package-summary.html"">functional interface</a>
     * whose functional method is {@link #apply(Object)}.
     *
     * @param <T> the type of the input to the function
     *
     * @see Function
     */
    @FunctionalInterface
    private  interface ToBooleanFunction<T> {

        /**
         * Applies this function to the given argument.
         *
         * @param value the function argument
         * @return the function result
         */
        boolean apply(T value);
    }

}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.audio.AudioFrequencyActivity"	"testMaxLevel"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/audio/AudioFrequencyActivity.java"	""	"public void testMaxLevel() {
        int currentLevel = mAudioManager.getStreamVolume(AudioManager.STREAM_MUSIC);
        Log.i(TAG, String.format(""Max level: %d curLevel: %d"", mMaxLevel, currentLevel));
        if (currentLevel != mMaxLevel) {
            new AlertDialog.Builder(this)
                .setTitle(R.string.audio_general_warning)
                .setMessage(R.string.audio_general_level_not_max)
                .setPositiveButton(R.string.audio_general_ok, null)
                .show();
        }
    }

    public int getMaxLevelForStream(int streamType) {
        return mAudioManager.getStreamMaxVolume(streamType);
    }

    public void setLevelForStream(int streamType, int level) {
        try {
            mAudioManager.setStreamVolume(streamType, level, 0);
        } catch (Exception e) {
            Log.e(TAG, ""Error setting stream volume: "", e);
        }
    }

    public int getLevelForStream(int streamType) {
        return mAudioManager.getStreamVolume(streamType);
    }

    public void enableUILayout(LinearLayout layout, boolean enable) {
        for (int i = 0; i < layout.getChildCount(); i++) {
            View view = layout.getChildAt(i);
            view.setEnabled(enable);
        }
    }

    private void scanPeripheralList(AudioDeviceInfo[] devices) {
        // Can't just use the first record because then we will only get
        // Source OR sink, not both even on devices that are both.
        mOutputDevInfo = null;
        mInputDevInfo = null;

        // Any valid peripherals
        for(AudioDeviceInfo devInfo : devices) {
            if (devInfo.getType() == AudioDeviceInfo.TYPE_USB_DEVICE ||
                    devInfo.getType() == AudioDeviceInfo.TYPE_USB_HEADSET) {
                if (devInfo.isSink()) {
                    mOutputDevInfo = devInfo;
                }
                if (devInfo.isSource()) {
                    mInputDevInfo = devInfo;
                }
            }
        }

    }

    private class ConnectListener extends AudioDeviceCallback {
        /*package*/ ConnectListener() {}

        //
        // AudioDevicesManager.OnDeviceConnectionListener
        //
        @Override
        public void onAudioDevicesAdded(AudioDeviceInfo[] addedDevices) {
            // Log.i(TAG, ""onAudioDevicesAdded() num:"" + addedDevices.length);

            scanPeripheralList(mAudioManager.getDevices(AudioManager.GET_DEVICES_ALL));
        }

        @Override
        public void onAudioDevicesRemoved(AudioDeviceInfo[] removedDevices) {
            // Log.i(TAG, ""onAudioDevicesRemoved() num:"" + removedDevices.length);

            scanPeripheralList(mAudioManager.getDevices(AudioManager.GET_DEVICES_ALL));
        }
    }

//    abstract public void updateConnectStatus();
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.autofillservice.cts.dropdown.AuthenticationTest"	"testFillResponseAuthBothFields"	"CtsAutoFillServiceTestCases"	"/home/gpoor/cts-12-source/cts/tests/autofillservice/src/android/autofillservice/cts/dropdown/AuthenticationTest.java"	""	"@AppModeFull(reason = ""testFillResponseAuthBothFields() is enough"")
    public void testFillResponseAuthWhenAppCallsCancel() throws Exception {
        // Set service.
        enableService();
        final MyAutofillCallback callback = mActivity.registerCallback();

        // Prepare the authenticated response
        final IntentSender authentication = AuthenticationActivity.createSender(mContext, 1,
                new CannedFillResponse.Builder().addDataset(
                        new CannedDataset.Builder()
                                .setField(ID_USERNAME, ""dude"")
                                .setField(ID_PASSWORD, ""sweet"")
                                .setId(""name"")
                                .setPresentation(createPresentation(""Dataset""))
                                .build())
                        .build());

        // Configure the service behavior
        sReplier.addResponse(new CannedFillResponse.Builder()
                .setAuthentication(authentication, ID_USERNAME, ID_PASSWORD)
                .setPresentation(createPresentation(""Tap to auth response""))
                .build());

        // Trigger autofill.
        requestFocusOnUsername();

        // Wait for onFill() before proceeding.
        sReplier.getNextFillRequest();
        final View username = mActivity.getUsername();
        callback.assertUiShownEvent(username);
        mUiBot.assertDatasets(""Tap to auth response"");

        // Disables autofill so it's not triggered again after the auth activity is finished
        // (and current session is canceled) and the login activity is resumed.
        username.setImportantForAutofill(IMPORTANT_FOR_AUTOFILL_NO);

        // Autofill it.
        final CountDownLatch latch = new CountDownLatch(1);
        AuthenticationActivity.setResultCode(latch, RESULT_OK);

        mUiBot.selectDataset(""Tap to auth response"");
        callback.assertUiHiddenEvent(username);

        // Cancel session...
        mActivity.getAutofillManager().cancel();

        // ...before finishing the Auth UI.
        latch.countDown();

        mUiBot.assertNoDatasets();
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.tests.getinfo.RootProcessScanner"	"exists"	""	"/home/gpoor/cts-12-source/cts/tools/device-setup/TestDeviceSetup/src/android/tests/getinfo/RootProcessScanner.java"	""	"public void test/*
 *.
 */

package android.tests.getinfo;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.regex.Pattern;

/** Crawls /proc to find processes that are running as root. */
class RootProcessScanner {

    /** Processes that are allowed to run as root. */
    private static final Pattern ROOT_PROCESS_WHITELIST_PATTERN = getRootProcessWhitelistPattern(
            ""debuggerd"",
            ""debuggerd64"",
            ""healthd"",
            ""init"",
            ""installd"",
            ""lmkd"",
            ""netd"",
            ""servicemanager"",
            ""ueventd"",
            ""vold"",
            ""watchdogd"",
            ""zygote""
    );

    /** Combine the individual patterns into one super pattern. */
    private static Pattern getRootProcessWhitelistPattern(String... patterns) {
        StringBuilder rootProcessPattern = new StringBuilder();
        for (int i = 0; i < patterns.length; i++) {
            rootProcessPattern.append(patterns[i]);
            if (i + 1 < patterns.length) {
                rootProcessPattern.append('|');
            }
        }
        return Pattern.compile(rootProcessPattern.toString());
    }

    /** Test that there are no unapproved root processes running on the system. */
    public static String[] getRootProcesses()
            throws FileNotFoundException, MalformedStatMException {
        List<File> rootProcessDirs = getRootProcessDirs();
        String[] rootProcessNames = new String[rootProcessDirs.size()];
        for (int i = 0; i < rootProcessNames.length; i++) {
            rootProcessNames[i] = getProcessName(rootProcessDirs.get(i));
        }
        return rootProcessNames;
    }

    private static List<File> getRootProcessDirs()
            throws FileNotFoundException, MalformedStatMException {
        File proc = new File(""/proc"");
        if (!proc.exists()) {
            throw new FileNotFoundException(proc + "" is missing (man 5 proc)"");
        }

        List<File> rootProcesses = new ArrayList<File>();
        File[] processDirs = proc.listFiles();
        if (processDirs != null && processDirs.length > 0) {
            for (File processDir : processDirs) {
                if (isUnapprovedRootProcess(processDir)) {
                    rootProcesses.add(processDir);
                }
            }
        }
        return rootProcesses;
    }

    /**
     * Filters out processes in /proc that are not approved.
     * @throws FileNotFoundException
     * @throws MalformedStatMException
     */
    private static boolean isUnapprovedRootProcess(File pathname)
            throws FileNotFoundException, MalformedStatMException {
        return isPidDirectory(pathname)
                && !isKernelProcess(pathname)
                && isRootProcess(pathname);
    }

    private static boolean isPidDirectory(File pathname) {
        return pathname.isDirectory() && Pattern.matches(""\\d+"", pathname.getName());
    }

    private static boolean isKernelProcess(File processDir)
            throws FileNotFoundException, MalformedStatMException {
        File statm = getProcessStatM(processDir);
        Scanner scanner = null;
        try {
            scanner = new Scanner(statm);

            boolean allZero = true;
            for (int i = 0; i < 7; i++) {
                if (scanner.nextInt() != 0) {
                    allZero = false;
                }
            }

            if (scanner.hasNext()) {
                throw new MalformedStatMException(processDir
                        + "" statm expected to have 7 integers (man 5 proc)"");
            }

            return allZero;
        } finally {
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    private static File getProcessStatM(File processDir) {
        return new File(processDir, ""statm"");
    }

    public static class MalformedStatMException extends Exception {
        MalformedStatMException(String detailMessage) {
            super(detailMessage);
        }
    }

    /**
     * Return whether or not this process is running as root without being approved.
     *
     * @param processDir with the status file
     * @return whether or not it is a unwhitelisted root process
     * @throws FileNotFoundException
     */
    private static boolean isRootProcess(File processDir) throws FileNotFoundException {
        File status = getProcessStatus(processDir);
        Scanner scanner = null;
        try {
            scanner = new Scanner(status);

            findToken(scanner, ""Name:"");
            String name = scanner.next();

            findToken(scanner, ""Uid:"");
            boolean rootUid = hasRootId(scanner);

            findToken(scanner, ""Gid:"");
            boolean rootGid = hasRootId(scanner);

            return !ROOT_PROCESS_WHITELIST_PATTERN.matcher(name).matches()
                    && (rootUid || rootGid);
        } finally {
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Get the status {@link File} that has name:value pairs.
     * <pre>
     * Name:   init
     * ...
     * Uid:    0       0       0       0
     * Gid:    0       0       0       0
     * </pre>
     */
    private static File getProcessStatus(File processDir) {
        return new File(processDir, ""status"");
    }

    /**
     * Convenience method to move the scanner's position to the point after the given token.
     *
     * @param scanner to call next() until the token is found
     * @param token to find like ""Name:""
     */
    private static void findToken(Scanner scanner, String token) {
        while (true) {
            String next = scanner.next();
            if (next.equals(token)) {
                return;
            }
        }

        // Scanner will exhaust input and throw an exception before getting here.
    }

    /**
     * Uid and Gid lines have four values: ""Uid:    0       0       0       0""
     *
     * @param scanner that has just processed the ""Uid:"" or ""Gid:"" token
     * @return whether or not any of the ids are root
     */
    private static boolean hasRootId(Scanner scanner) {
        int realUid = scanner.nextInt();
        int effectiveUid = scanner.nextInt();
        int savedSetUid = scanner.nextInt();
        int fileSystemUid = scanner.nextInt();
        return realUid == 0 || effectiveUid == 0 || savedSetUid == 0 || fileSystemUid == 0;
    }

    /** Returns the name of the process corresponding to its process directory in /proc. */
    private static String getProcessName(File processDir) throws FileNotFoundException {
        File status = getProcessStatus(processDir);
        Scanner scanner = new Scanner(status);
        try {
            findToken(scanner, ""Name:"");
            return scanner.next();
        } finally {
            scanner.close();
        }
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.sample.cts.SampleHostJUnit4Test"	"TestMetrics"	"CtsSampleHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/sample/src/android/sample/cts/SampleHostJUnit4Test.java"	""	"/*
 *.
 */

package android.sample.cts;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;

import com.android.tradefed.device.ITestDevice;
import com.android.tradefed.testtype.DeviceJUnit4ClassRunner;
import com.android.tradefed.testtype.DeviceJUnit4ClassRunner.TestMetrics;
import com.android.tradefed.testtype.IDeviceTest;

import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.Scanner;

/**
 * Test to check the APK logs to Logcat.
 *
 * When this test builds, it also builds {@link android.sample.app.SampleDeviceActivity} into an
 * APK which it then installed at runtime and started. The activity simply prints a message to
 * Logcat and then gets uninstalled.
 *
 * Instead of extending DeviceTestCase, this JUnit4 test extends IDeviceTest and is run with
 * tradefed's DeviceJUnit4ClassRunner
 */
@RunWith(DeviceJUnit4ClassRunner.class)
public class SampleHostJUnit4Test implements IDeviceTest {

    /**
     * The package name of the APK.
     */
    private static final String PACKAGE = ""android.sample.app"";

    /**
     * The class name of the main activity in the APK.
     */
    private static final String CLASS = ""SampleDeviceActivity"";

    /**
     * The command to launch the main activity.
     */
    private static final String START_COMMAND = String.format(
            ""am start -W -a android.intent.action.MAIN -n %s/%s.%s"", PACKAGE, PACKAGE, CLASS);

    /**
     * The command to clear the main activity.
     */
    private static final String CLEAR_COMMAND = String.format(""pm clear %s"", PACKAGE);

    /**
     * The test string to look for.
     */
    private static final String TEST_STRING = ""SampleTestString"";

    /**
     * A rule annotation that allows to log metrics in test cases.
     */
    @Rule public TestMetrics mMetrics = new TestMetrics();

    private ITestDevice mDevice;

    @Override
    public void setDevice(ITestDevice device) {
        mDevice = device;
    }

    @Override
    public ITestDevice getDevice() {
        return mDevice;
    }

    /**
     * Tests the string was successfully logged to Logcat from the activity.
     *
     * @throws Exception
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.sample.cts.SampleHostJUnit4Test"	"testLogcat"	"CtsSampleHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/sample/src/android/sample/cts/SampleHostJUnit4Test.java"	""	"public void testLogcat() throws Exception {
        ITestDevice device = getDevice();
        assertNotNull(""Device not set"", device);
        // Clear activity
        device.executeShellCommand(CLEAR_COMMAND);
        // Clear logcat.
        device.executeAdbCommand(""logcat"", ""-c"");
        // Start the APK and wait for it to complete.
        device.executeShellCommand(START_COMMAND);
        // Dump logcat.
        String logs = device.executeAdbCommand(""logcat"", ""-v"", ""brief"", ""-d"", CLASS + "":I"", ""*:S"");
        // Search for string.
        String testString = """";
        Scanner in = new Scanner(logs);
        while (in.hasNextLine()) {
            String line = in.nextLine();
            if(line.startsWith(""I/""+CLASS)) {
                testString = line.split("":"")[1].trim();
            }
        }
        in.close();
        // Assert the logged string matches the test string.
        assertEquals(""Incorrect test string"", TEST_STRING, testString);
    }

    /**
     * Documentation: https://source.android.com/devices/tech/test_infra/tradefed/testing/through-tf/report-metrics
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.bluetooth.BleScannerTestActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/bluetooth/BleScannerTestActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.bluetooth;

import android.app.AlertDialog;
import android.app.Dialog;
import android.bluetooth.BluetoothAdapter;
import android.content.DialogInterface;
import android.os.Bundle;

import com.android.cts.verifier.ManifestTestListAdapter;
import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;

import java.util.ArrayList;
import java.util.List;

public class BleScannerTestActivity extends PassFailButtons.TestListActivity {

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.pass_fail_list);
        setPassFailButtonClickListeners();
        setInfoResources(R.string.ble_scanner_test_name,
                         R.string.ble_scanner_test_info, -1);
        BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
        List<String> disabledTest = new ArrayList<String>();
        if (adapter == null || !adapter.isOffloadedFilteringSupported()) {
            disabledTest.add(
                    ""com.android.cts.verifier.bluetooth.BleScannerHardwareScanFilterActivity"");
        }

        setTestListAdapter(new ManifestTestListAdapter(this, getClass().getName(),
                disabledTest.toArray(new String[disabledTest.size()])));

        if (!adapter.isEnabled()) {
            new AlertDialog.Builder(this)
                    .setTitle(R.string.ble_bluetooth_disable_title)
                    .setMessage(R.string.ble_bluetooth_disable_message)
                    .setOnCancelListener(new Dialog.OnCancelListener() {
                        @Override
                        public void onCancel(DialogInterface dialog) {
                            finish();
                        }
                    })
                    .create().show();
        }
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.TestHelper"	"isEmpty"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/TestHelper.java"	""	"public void test/*
 *.
 */

package android.net.wifi.cts;

import static android.Manifest.permission.CONNECTIVITY_INTERNAL;
import static android.Manifest.permission.NETWORK_SETTINGS;
import static android.net.ConnectivityManager.NetworkCallback.FLAG_INCLUDE_LOCATION_INFO;
import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_OEM_PAID;
import static android.net.NetworkCapabilities.NET_CAPABILITY_OEM_PRIVATE;
import static android.net.NetworkCapabilities.TRANSPORT_WIFI;
import static android.os.Process.myUid;

import static com.google.common.truth.Truth.assertThat;

import static org.junit.Assert.fail;

import android.annotation.NonNull;
import android.app.UiAutomation;
import android.content.Context;
import android.net.ConnectivityManager;
import android.net.MacAddress;
import android.net.Network;
import android.net.NetworkCapabilities;
import android.net.NetworkRequest;
import android.net.wifi.ScanResult;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiInfo;
import android.net.wifi.WifiManager;
import android.net.wifi.WifiNetworkSpecifier;
import android.net.wifi.WifiNetworkSuggestion;
import android.os.Build;
import android.os.WorkSource;
import android.support.test.uiautomator.UiDevice;
import android.text.TextUtils;
import android.util.Log;

import androidx.test.platform.app.InstrumentationRegistry;

import com.android.compatibility.common.util.ApiLevelUtil;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Set;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

/**
 * Class to hold helper methods that are repeated across wifi CTS tests.
 */
public class TestHelper {
    private static final String TAG = ""WifiTestHelper"";

    private final Context mContext;
    private final WifiManager mWifiManager;
    private final ConnectivityManager mConnectivityManager;
    private final UiDevice mUiDevice;

    private static final int DURATION_MILLIS = 10_000;
    private static final int DURATION_NETWORK_CONNECTION_MILLIS = 40_000;
    private static final int DURATION_SCREEN_TOGGLE_MILLIS = 2000;
    private static final int DURATION_UI_INTERACTION_MILLIS = 25_000;
    private static final int SCAN_RETRY_CNT_TO_FIND_MATCHING_BSSID = 3;

    public TestHelper(@NonNull Context context, @NonNull UiDevice uiDevice) {
        mContext = context;
        mWifiManager = context.getSystemService(WifiManager.class);
        mConnectivityManager = context.getSystemService(ConnectivityManager.class);
        mUiDevice = uiDevice;
    }

    public void turnScreenOn() throws Exception {
        mUiDevice.executeShellCommand(""input keyevent KEYCODE_WAKEUP"");
        mUiDevice.executeShellCommand(""wm dismiss-keyguard"");
        // Since the screen on/off intent is ordered, they will not be sent right now.
        Thread.sleep(DURATION_SCREEN_TOGGLE_MILLIS);
    }

    public void turnScreenOff() throws Exception {
        mUiDevice.executeShellCommand(""input keyevent KEYCODE_SLEEP"");
        // Since the screen on/off intent is ordered, they will not be sent right now.
        Thread.sleep(DURATION_SCREEN_TOGGLE_MILLIS);
    }

    private static class TestScanResultsCallback extends WifiManager.ScanResultsCallback {
        private final CountDownLatch mCountDownLatch;
        public boolean onAvailableCalled = false;

        TestScanResultsCallback(CountDownLatch countDownLatch) {
            mCountDownLatch = countDownLatch;
        }

        @Override
        public void onScanResultsAvailable() {
            onAvailableCalled = true;
            mCountDownLatch.countDown();
        }
    }

    /**
     * Loops through all the saved networks available in the scan results. Returns a list of
     * WifiConfiguration with the matching bssid filled in {@link WifiConfiguration#BSSID}.
     *
     * Note:
     * a) If there are more than 2 networks with the same SSID, but different credential type, then
     * this matching may pick the wrong one.
     *
     * @param wifiManager WifiManager service
     * @param savedNetworks List of saved networks on the device.
     */
    public static List<WifiConfiguration> findMatchingSavedNetworksWithBssid(
            @NonNull WifiManager wifiManager, @NonNull List<WifiConfiguration> savedNetworks) {
        if (savedNetworks.isEmpty()) return Collections.emptyList();
        List<WifiConfiguration> matchingNetworksWithBssids = new ArrayList<>();
        CountDownLatch countDownLatch = new CountDownLatch(1);
        for (int i = 0; i < SCAN_RETRY_CNT_TO_FIND_MATCHING_BSSID; i++) {
            // Trigger a scan to get fresh scan results.
            TestScanResultsCallback scanResultsCallback =
                    new TestScanResultsCallback(countDownLatch);
            try {
                wifiManager.registerScanResultsCallback(
                        Executors.newSingleThreadExecutor(), scanResultsCallback);
                wifiManager.startScan(new WorkSource(myUid()));
                // now wait for callback
                countDownLatch.await(DURATION_MILLIS, TimeUnit.MILLISECONDS);
            } catch (InterruptedException e) {
            } finally {
                wifiManager.unregisterScanResultsCallback(scanResultsCallback);
            }
            List<ScanResult> scanResults = wifiManager.getScanResults();
            if (scanResults == null || scanResults.isEmpty()) fail(""No scan results available"");
            for (ScanResult scanResult : scanResults) {
                WifiConfiguration matchingNetwork = savedNetworks.stream()
                        .filter(network -> TextUtils.equals(
                                scanResult.SSID, WifiInfo.sanitizeSsid(network.SSID)))
                        .findAny()
                        .orElse(null);
                if (matchingNetwork != null) {
                    // make a copy in case we have 2 bssid's for the same network.
                    WifiConfiguration matchingNetworkCopy = new WifiConfiguration(matchingNetwork);
                    matchingNetworkCopy.BSSID = scanResult.BSSID;
                    matchingNetworksWithBssids.add(matchingNetworkCopy);
                }
            }
            if (!matchingNetworksWithBssids.isEmpty()) break;
        }
        return matchingNetworksWithBssids;
    }

    /**
     * Convert the provided saved network to a corresponding suggestion builder.
     */
    public static WifiNetworkSuggestion.Builder
            createSuggestionBuilderWithCredentialFromSavedNetworkWithBssid(
            @NonNull WifiConfiguration network) {
        WifiNetworkSuggestion.Builder suggestionBuilder = new WifiNetworkSuggestion.Builder()
                .setSsid(WifiInfo.sanitizeSsid(network.SSID))
                .setBssid(MacAddress.fromString(network.BSSID));
        if (network.preSharedKey != null) {
            if (network.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.WPA_PSK)) {
                suggestionBuilder.setWpa2Passphrase(WifiInfo.sanitizeSsid(network.preSharedKey));
            } else if (network.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.SAE)) {
                suggestionBuilder.setWpa3Passphrase(WifiInfo.sanitizeSsid(network.preSharedKey));
            } else {
                fail(""Unsupported security type found in saved networks"");
            }
        } else if (network.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.OWE)) {
            suggestionBuilder.setIsEnhancedOpen(true);
        } else if (!network.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.NONE)) {
            fail(""Unsupported security type found in saved networks"");
        }
        suggestionBuilder.setIsHiddenSsid(network.hiddenSSID);
        return suggestionBuilder;
    }


    /**
     * Convert the provided saved network to a corresponding specifier builder.
     */
    public static WifiNetworkSpecifier.Builder createSpecifierBuilderWithCredentialFromSavedNetwork(
            @NonNull WifiConfiguration network) {
        WifiNetworkSpecifier.Builder specifierBuilder = new WifiNetworkSpecifier.Builder()
                .setSsid(WifiInfo.sanitizeSsid(network.SSID));
        if (network.preSharedKey != null) {
            if (network.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.WPA_PSK)) {
                specifierBuilder.setWpa2Passphrase(WifiInfo.sanitizeSsid(network.preSharedKey));
            } else if (network.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.SAE)) {
                specifierBuilder.setWpa3Passphrase(WifiInfo.sanitizeSsid(network.preSharedKey));
            } else {
                fail(""Unsupported security type found in saved networks"");
            }
        } else if (network.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.OWE)) {
            specifierBuilder.setIsEnhancedOpen(true);
        } else if (!network.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.NONE)) {
            fail(""Unsupported security type found in saved networks"");
        }
        specifierBuilder.setIsHiddenSsid(network.hiddenSSID);
        return specifierBuilder;
    }

    /**
     * Convert the provided saved network to a corresponding specifier builder.
     */
    public static WifiNetworkSpecifier.Builder
            createSpecifierBuilderWithCredentialFromSavedNetworkWithBssid(
            @NonNull WifiConfiguration network) {
        return createSpecifierBuilderWithCredentialFromSavedNetwork(network)
                .setBssid(MacAddress.fromString(network.BSSID));
    }

    private static class TestNetworkCallback extends ConnectivityManager.NetworkCallback {
        private final CountDownLatch mCountDownLatch;
        public boolean onAvailableCalled = false;
        public boolean onUnavailableCalled = false;
        public NetworkCapabilities networkCapabilities;

        TestNetworkCallback(@NonNull CountDownLatch countDownLatch) {
            mCountDownLatch = countDownLatch;
        }

        TestNetworkCallback(@NonNull CountDownLatch countDownLatch, int flags) {
            super(flags);
            mCountDownLatch = countDownLatch;
        }

        @Override
        public void onAvailable(Network network) {
            onAvailableCalled = true;
        }

        @Override
        public void onCapabilitiesChanged(Network network,
                NetworkCapabilities networkCapabilities) {
            this.networkCapabilities = networkCapabilities;
            mCountDownLatch.countDown();
        }

        @Override
        public void onUnavailable() {
            onUnavailableCalled = true;
            mCountDownLatch.countDown();
        }
    }

    private static TestNetworkCallback createTestNetworkCallback(
            @NonNull CountDownLatch countDownLatch) {
        if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
            // flags for NetworkCallback only introduced in S.
            return new TestNetworkCallback(countDownLatch, FLAG_INCLUDE_LOCATION_INFO);
        } else {
            return new TestNetworkCallback(countDownLatch);
        }
    }

    @NonNull
    private WifiInfo getWifiInfo(@NonNull NetworkCapabilities networkCapabilities) {
        if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
            // WifiInfo in transport info, only available in S.
            return (WifiInfo) networkCapabilities.getTransportInfo();
        } else {
            return mWifiManager.getConnectionInfo();
        }
    }

    private static void assertConnectionEquals(@NonNull WifiConfiguration network,
            @NonNull WifiInfo wifiInfo) {
        assertThat(network.SSID).isEqualTo(wifiInfo.getSSID());
        assertThat(network.BSSID).isEqualTo(wifiInfo.getBSSID());
    }

    private static class TestActionListener implements WifiManager.ActionListener {
        private final CountDownLatch mCountDownLatch;
        public boolean onSuccessCalled = false;
        public boolean onFailedCalled = false;

        TestActionListener(CountDownLatch countDownLatch) {
            mCountDownLatch = countDownLatch;
        }

        @Override
        public void onSuccess() {
            onSuccessCalled = true;
            mCountDownLatch.countDown();
        }

        @Override
        public void onFailure(int reason) {
            onFailedCalled = true;
            mCountDownLatch.countDown();
        }
    }

    /**
     * Triggers connection to one of the saved networks using {@link WifiManager#connect(
     * WifiConfiguration, WifiManager.ActionListener)}
     *
     * @param network saved network from the device to use for the connection.
     *
     * @return NetworkCallback used for the connection (can be used by client to release the
     * connection.
     */
    public ConnectivityManager.NetworkCallback testConnectionFlowWithConnect(
            @NonNull WifiConfiguration network) throws Exception {
        CountDownLatch countDownLatchAl = new CountDownLatch(1);
        CountDownLatch countDownLatchNr = new CountDownLatch(1);
        TestActionListener actionListener = new TestActionListener(countDownLatchAl);
        TestNetworkCallback testNetworkCallback = createTestNetworkCallback(countDownLatchNr);
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            // File a callback for wifi network.
            mConnectivityManager.registerNetworkCallback(
                    new NetworkRequest.Builder()
                            .addTransportType(NetworkCapabilities.TRANSPORT_WIFI)
                            .addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
                            // Needed to ensure that the restricted concurrent connection does not
                            // match this request.
                            .addForbiddenCapability(NET_CAPABILITY_OEM_PAID)
                            .addForbiddenCapability(NET_CAPABILITY_OEM_PRIVATE)
                            .build(),
                    testNetworkCallback);
            // Trigger the connection.
            mWifiManager.connect(network, actionListener);
            // now wait for action listener callback
            assertThat(countDownLatchAl.await(
                    DURATION_NETWORK_CONNECTION_MILLIS, TimeUnit.MILLISECONDS)).isTrue();
            // check if we got the success callback
            assertThat(actionListener.onSuccessCalled).isTrue();

            // Wait for connection to complete & ensure we are connected to the saved network.
            assertThat(countDownLatchNr.await(
                    DURATION_NETWORK_CONNECTION_MILLIS, TimeUnit.MILLISECONDS)).isTrue();
            assertThat(testNetworkCallback.onAvailableCalled).isTrue();
            final WifiInfo wifiInfo = getWifiInfo(testNetworkCallback.networkCapabilities);
            assertConnectionEquals(network, wifiInfo);
            if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
                // User connections should always be primary.
                assertThat(wifiInfo.isPrimary()).isTrue();
            }
        } catch (Throwable e /* catch assertions & exceptions */) {
            // Unregister the network callback in case of any failure (since we don't end up
            // returning the network callback to the caller).
            try {
                mConnectivityManager.unregisterNetworkCallback(testNetworkCallback);
            } catch (IllegalArgumentException ie) { }
            throw e;
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
        return testNetworkCallback;
    }

    /**
     * Tests the entire connection success flow using the provided suggestion.
     *
     * Note: The caller needs to invoke this after acquiring shell identity.
     *
     * @param network saved network from the device to use for the connection.
     * @param suggestion suggestion to use for the connection.
     * @param executorService Excutor service to run scan periodically (to trigger connection).
     * @param restrictedNetworkCapabilities Whether this connection should be restricted with
     *                                    the provided capability.
     *
     * @return NetworkCallback used for the connection (can be used by client to release the
     * connection.
     */
    public ConnectivityManager.NetworkCallback testConnectionFlowWithSuggestionWithShellIdentity(
            WifiConfiguration network, WifiNetworkSuggestion suggestion,
            @NonNull ScheduledExecutorService executorService,
            @NonNull Set<Integer> restrictedNetworkCapabilities) throws Exception {
        return testConnectionFlowWithSuggestionInternal(
                network, suggestion, executorService, restrictedNetworkCapabilities, true);
    }

    /**
     * Tests the entire connection success flow using the provided suggestion.
     *
     * Note: The helper method drops the shell identity, so don't use this if the caller already
     * adopted shell identity.
     *
     * @param network saved network from the device to use for the connection.
     * @param suggestion suggestion to use for the connection.
     * @param executorService Excutor service to run scan periodically (to trigger connection).
     * @param restrictedNetworkCapabilities Whether this connection should be restricted with
     *                                    the provided capability.
     *
     * @return NetworkCallback used for the connection (can be used by client to release the
     * connection.
     */
    public ConnectivityManager.NetworkCallback testConnectionFlowWithSuggestion(
            WifiConfiguration network, WifiNetworkSuggestion suggestion,
            @NonNull ScheduledExecutorService executorService,
            @NonNull Set<Integer> restrictedNetworkCapabilities) throws Exception {
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity(NETWORK_SETTINGS, CONNECTIVITY_INTERNAL);
            return testConnectionFlowWithSuggestionWithShellIdentity(
                    network, suggestion, executorService, restrictedNetworkCapabilities);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests the connection failure flow using the provided suggestion.
     *
     * @param network saved network from the device to use for the connection.
     * @param suggestion suggestion to use for the connection.
     * @param executorService Excutor service to run scan periodically (to trigger connection).
     * @param restrictedNetworkCapabilities Whether this connection should be restricted with
     *                                    the provided capability.
     *
     * @return NetworkCallback used for the connection (can be used by client to release the
     * connection.
     */
    public ConnectivityManager.NetworkCallback testConnectionFailureFlowWithSuggestion(
            WifiConfiguration network, WifiNetworkSuggestion suggestion,
            @NonNull ScheduledExecutorService executorService,
            @NonNull Set<Integer> restrictedNetworkCapabilities) throws Exception {
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity(NETWORK_SETTINGS, CONNECTIVITY_INTERNAL);
            return testConnectionFlowWithSuggestionInternal(
                    network, suggestion, executorService, restrictedNetworkCapabilities, false);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests the entire connection success/failure flow using the provided suggestion.
     *
     * @param network saved network from the device to use for the connection.
     * @param suggestion suggestion to use for the connection.
     * @param executorService Excutor service to run scan periodically (to trigger connection).
     * @param restrictedNetworkCapabilities Whether this connection should be restricted with
     *                                    the provided capability.
     * @param expectConnectionSuccess Whether to expect connection success or not.
     *
     * @return NetworkCallback used for the connection (can be used by client to release the
     * connection.
     */
    private ConnectivityManager.NetworkCallback testConnectionFlowWithSuggestionInternal(
            WifiConfiguration network, WifiNetworkSuggestion suggestion,
            @NonNull ScheduledExecutorService executorService,
            @NonNull Set<Integer> restrictedNetworkCapabilities,
            boolean expectConnectionSuccess) throws Exception {
        CountDownLatch countDownLatch = new CountDownLatch(1);
        // File the network request & wait for the callback.
        TestNetworkCallback testNetworkCallback = createTestNetworkCallback(countDownLatch);
        try {
            // File a request for restricted (oem paid) wifi network.
            NetworkRequest.Builder nrBuilder = new NetworkRequest.Builder()
                    .addTransportType(TRANSPORT_WIFI)
                    .addCapability(NET_CAPABILITY_INTERNET);
            if (restrictedNetworkCapabilities.isEmpty()) {
                // If not a restricted connection, a network callback is sufficient.
                mConnectivityManager.registerNetworkCallback(
                        nrBuilder.build(), testNetworkCallback);
            } else {
                for (Integer restrictedNetworkCapability : restrictedNetworkCapabilities) {
                    nrBuilder.addCapability(restrictedNetworkCapability);
                }
                mConnectivityManager.requestNetwork(nrBuilder.build(), testNetworkCallback);
            }
            // Add wifi network suggestion.
            assertThat(mWifiManager.addNetworkSuggestions(Arrays.asList(suggestion)))
                    .isEqualTo(WifiManager.STATUS_NETWORK_SUGGESTIONS_SUCCESS);
            // Wait for the request to reach the wifi stack before kick-start periodic scans.
            Thread.sleep(100);
            // Step: Trigger scans periodically to trigger network selection quicker.
            executorService.scheduleAtFixedRate(() -> {
                if (!mWifiManager.startScan()) {
                    Log.w(TAG, ""Failed to trigger scan"");
                }
            }, 0, DURATION_MILLIS, TimeUnit.MILLISECONDS);
            if (expectConnectionSuccess) {
                // now wait for connection to complete and wait for callback
                assertThat(countDownLatch.await(
                        DURATION_NETWORK_CONNECTION_MILLIS, TimeUnit.MILLISECONDS)).isTrue();
                assertThat(testNetworkCallback.onAvailableCalled).isTrue();
                final WifiInfo wifiInfo = getWifiInfo(testNetworkCallback.networkCapabilities);
                assertConnectionEquals(network, wifiInfo);
                if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(mContext)) {
                    assertThat(wifiInfo.isTrusted()).isTrue();
                    WifiInfo redact = wifiInfo
                            .makeCopy(NetworkCapabilities.REDACT_FOR_ACCESS_FINE_LOCATION);
                    assertThat(wifiInfo.getInformationElements()).isNotNull();
                    assertThat(redact.getInformationElements()).isNull();
                    assertThat(redact.getApplicableRedactions()).isEqualTo(
                            NetworkCapabilities.REDACT_FOR_ACCESS_FINE_LOCATION
                            | NetworkCapabilities.REDACT_FOR_LOCAL_MAC_ADDRESS
                            | NetworkCapabilities.REDACT_FOR_NETWORK_SETTINGS);
                }
                if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
                    // If STA concurrency for restricted connection is supported, this should not
                    // be the primary connection.
                    if (!restrictedNetworkCapabilities.isEmpty()
                            && mWifiManager.isStaConcurrencyForRestrictedConnectionsSupported()) {
                        assertThat(wifiInfo.isPrimary()).isFalse();
                    } else {
                        assertThat(wifiInfo.isPrimary()).isTrue();
                    }
                }
            } else {
                // now wait for connection to timeout.
                assertThat(countDownLatch.await(
                        DURATION_NETWORK_CONNECTION_MILLIS, TimeUnit.MILLISECONDS)).isFalse();
            }
        } catch (Throwable e /* catch assertions & exceptions */) {
            try {
                mConnectivityManager.unregisterNetworkCallback(testNetworkCallback);
            } catch (IllegalArgumentException ie) { }
            throw e;
        } finally {
            executorService.shutdown();
        }
        return testNetworkCallback;
    }

    private static class TestNetworkRequestMatchCallback implements
            WifiManager.NetworkRequestMatchCallback {
        private final Object mLock;

        public boolean onRegistrationCalled = false;
        public boolean onAbortCalled = false;
        public boolean onMatchCalled = false;
        public boolean onConnectSuccessCalled = false;
        public boolean onConnectFailureCalled = false;
        public WifiManager.NetworkRequestUserSelectionCallback userSelectionCallback = null;
        public List<ScanResult> matchedScanResults = null;

        TestNetworkRequestMatchCallback(Object lock) {
            mLock = lock;
        }

        @Override
        public void onUserSelectionCallbackRegistration(
                WifiManager.NetworkRequestUserSelectionCallback userSelectionCallback) {
            synchronized (mLock) {
                onRegistrationCalled = true;
                this.userSelectionCallback = userSelectionCallback;
                mLock.notify();
            }
        }

        @Override
        public void onAbort() {
            synchronized (mLock) {
                onAbortCalled = true;
                mLock.notify();
            }
        }

        @Override
        public void onMatch(List<ScanResult> scanResults) {
            synchronized (mLock) {
                // This can be invoked multiple times. So, ignore after the first one to avoid
                // disturbing the rest of the test sequence.
                if (onMatchCalled) return;
                onMatchCalled = true;
                matchedScanResults = scanResults;
                mLock.notify();
            }
        }

        @Override
        public void onUserSelectionConnectSuccess(WifiConfiguration config) {
            synchronized (mLock) {
                onConnectSuccessCalled = true;
                mLock.notify();
            }
        }

        @Override
        public void onUserSelectionConnectFailure(WifiConfiguration config) {
            synchronized (mLock) {
                onConnectFailureCalled = true;
                mLock.notify();
            }
        }
    }

    private void handleUiInteractions(WifiConfiguration network, boolean shouldUserReject) {
        // can't use CountDownLatch since there are many callbacks expected and CountDownLatch
        // cannot be reset.
        // TODO(b/177591382): Use ArrayBlockingQueue/LinkedBlockingQueue
        Object uiLock = new Object();
        TestNetworkRequestMatchCallback networkRequestMatchCallback =
                new TestNetworkRequestMatchCallback(uiLock);
        try {
            // 1. Wait for registration callback.
            synchronized (uiLock) {
                try {
                    mWifiManager.registerNetworkRequestMatchCallback(
                            Executors.newSingleThreadExecutor(), networkRequestMatchCallback);
                    uiLock.wait(DURATION_UI_INTERACTION_MILLIS);
                } catch (InterruptedException e) {
                }
            }
            assertThat(networkRequestMatchCallback.onRegistrationCalled).isTrue();
            assertThat(networkRequestMatchCallback.userSelectionCallback).isNotNull();

            // 2. Wait for matching scan results
            synchronized (uiLock) {
                if (!networkRequestMatchCallback.onMatchCalled) {
                    try {
                        uiLock.wait(DURATION_UI_INTERACTION_MILLIS);
                    } catch (InterruptedException e) {
                    }
                }
            }
            assertThat(networkRequestMatchCallback.onMatchCalled).isTrue();
            assertThat(networkRequestMatchCallback.matchedScanResults).isNotNull();
            assertThat(networkRequestMatchCallback.matchedScanResults.size()).isAtLeast(1);

            // 3. Trigger connection to one of the matched networks or reject the request.
            if (shouldUserReject) {
                networkRequestMatchCallback.userSelectionCallback.reject();
            } else {
                networkRequestMatchCallback.userSelectionCallback.select(network);
            }

            // 4. Wait for connection success or abort.
            synchronized (uiLock) {
                try {
                    uiLock.wait(DURATION_UI_INTERACTION_MILLIS);
                } catch (InterruptedException e) {
                }
            }
            if (shouldUserReject) {
                assertThat(networkRequestMatchCallback.onAbortCalled).isTrue();
            } else {
                assertThat(networkRequestMatchCallback.onConnectSuccessCalled).isTrue();
            }
        } finally {
            mWifiManager.unregisterNetworkRequestMatchCallback(networkRequestMatchCallback);
        }
    }

    /**
     * Tests the entire connection flow using the provided specifier,
     *
     * Note: The caller needs to invoke this after acquiring shell identity.
     *
     * @param specifier Specifier to use for network request.
     * @param shouldUserReject Whether to simulate user rejection or not.
     *
     * @return NetworkCallback used for the connection (can be used by client to release the
     * connection.
     */
    public ConnectivityManager.NetworkCallback testConnectionFlowWithSpecifierWithShellIdentity(
            WifiConfiguration network, WifiNetworkSpecifier specifier, boolean shouldUserReject)
            throws Exception {
        CountDownLatch countDownLatch = new CountDownLatch(1);
        // File the network request & wait for the callback.
        TestNetworkCallback testNetworkCallback = createTestNetworkCallback(countDownLatch);

        // Fork a thread to handle the UI interactions.
        Thread uiThread = new Thread(() -> {
            try {
                handleUiInteractions(network, shouldUserReject);
            } catch (Throwable e /* catch assertions & exceptions */) {
                try {
                    mConnectivityManager.unregisterNetworkCallback(testNetworkCallback);
                } catch (IllegalArgumentException ie) { }
                throw e;
            }
        });

        try {
            // File a request for wifi network.
            mConnectivityManager.requestNetwork(
                    new NetworkRequest.Builder()
                            .addTransportType(NetworkCapabilities.TRANSPORT_WIFI)
                            .removeCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
                            .setNetworkSpecifier(specifier)
                            .build(),
                    testNetworkCallback);
            // Wait for the request to reach the wifi stack before kick-starting the UI
            // interactions.
            Thread.sleep(1_000);
            // Start the UI interactions.
            uiThread.run();
            // now wait for callback
            assertThat(countDownLatch.await(
                    DURATION_NETWORK_CONNECTION_MILLIS, TimeUnit.MILLISECONDS)).isTrue();
            if (shouldUserReject) {
                assertThat(testNetworkCallback.onUnavailableCalled).isTrue();
            } else {
                assertThat(testNetworkCallback.onAvailableCalled).isTrue();
                final WifiInfo wifiInfo = getWifiInfo(testNetworkCallback.networkCapabilities);
                assertConnectionEquals(network, wifiInfo);
                if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
                    // If STA concurrency for local only connection is supported, this should not
                    // be the primary connection.
                    if (mWifiManager.isStaConcurrencyForLocalOnlyConnectionsSupported()) {
                        assertThat(wifiInfo.isPrimary()).isFalse();
                    } else {
                        assertThat(wifiInfo.isPrimary()).isTrue();
                    }
                }
            }
        } catch (Throwable e /* catch assertions & exceptions */) {
            try {
                mConnectivityManager.unregisterNetworkCallback(testNetworkCallback);
            } catch (IllegalArgumentException ie) { }
            throw e;
        }
        try {
            // Ensure that the UI interaction thread has completed.
            uiThread.join(DURATION_UI_INTERACTION_MILLIS);
        } catch (InterruptedException e) {
            try {
                mConnectivityManager.unregisterNetworkCallback(testNetworkCallback);
            } catch (IllegalArgumentException ie) { }
            fail(""UI interaction interrupted"");
        }
        return testNetworkCallback;
    }

    /**
     * Tests the entire connection flow using the provided specifier.
     *
     * Note: The helper method drops the shell identity, so don't use this if the caller already
     * adopted shell identity.
     *
     * @param specifier Specifier to use for network request.
     * @param shouldUserReject Whether to simulate user rejection or not.
     *
     * @return NetworkCallback used for the connection (can be used by client to release the
     * connection.
     */
    public ConnectivityManager.NetworkCallback testConnectionFlowWithSpecifier(
            WifiConfiguration network, WifiNetworkSpecifier specifier, boolean shouldUserReject)
            throws Exception {
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity(NETWORK_SETTINGS);
            return testConnectionFlowWithSpecifierWithShellIdentity(
                    network, specifier, shouldUserReject);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Returns the number of wifi connections visible at the networking layer.
     */
    public long getNumWifiConnections() {
        Network[] networks = mConnectivityManager.getAllNetworks();
        return Arrays.stream(networks)
                .filter(n ->
                        mConnectivityManager.getNetworkCapabilities(n).hasTransport(TRANSPORT_WIFI))
                .count();
    }

    /**
     * Registers a network callback for internet connectivity via wifi and asserts that a network
     * is available within {@link #DURATION_NETWORK_CONNECTION_MILLIS}.
     *
     * @throws Exception
     */
    public void assertWifiInternetConnectionAvailable() throws Exception {
        CountDownLatch countDownLatchNr = new CountDownLatch(1);
        TestNetworkCallback testNetworkCallback = createTestNetworkCallback(countDownLatchNr);
        try {
            // File a callback for wifi network.
            NetworkRequest.Builder builder = new NetworkRequest.Builder()
                    .addTransportType(NetworkCapabilities.TRANSPORT_WIFI)
                    .addCapability(NET_CAPABILITY_INTERNET);
            if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
                // Needed to ensure that the restricted concurrent connection does not
                // match this request.
                builder.addForbiddenCapability(NET_CAPABILITY_OEM_PAID)
                        .addForbiddenCapability(NET_CAPABILITY_OEM_PRIVATE);
            }
            mConnectivityManager.registerNetworkCallback(builder.build(), testNetworkCallback);
            // Wait for connection to complete & ensure we are connected to some network capable
            // of providing internet access.
            assertThat(countDownLatchNr.await(
                    DURATION_NETWORK_CONNECTION_MILLIS, TimeUnit.MILLISECONDS)).isTrue();
            assertThat(testNetworkCallback.onAvailableCalled).isTrue();
        } finally {
            mConnectivityManager.unregisterNetworkCallback(testNetworkCallback);
        }
    }

    public static int getBandFromFrequency(final int freqMHz) {
        if (freqMHz < 1000) {
            return ScanResult.UNSPECIFIED;
        } else if (freqMHz < 4000) { // getFrequency is in WifiInfo.FREQUENCY_UNITS = MHz
            return ScanResult.WIFI_BAND_24_GHZ;
        } else if (freqMHz < 5900) {
            // 5GHz band stops at 5885MHz, 6GHz band starts at 5955. See android.net.wifi.ScanResult
            return ScanResult.WIFI_BAND_5_GHZ;
        } else if (freqMHz < 10_000) {
            return ScanResult.WIFI_BAND_6_GHZ;
        } else if (freqMHz < 71_000) {
            // 60 GHz band stops at 70_200
            return ScanResult.WIFI_BAND_60_GHZ;
        } else {
            return ScanResult.UNSPECIFIED;
        }
    }

}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.security.cts.PackageSignatureTest"	"testPackageSignatures"	"CtsSecurityTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/security/src/android/security/cts/PackageSignatureTest.java"	""	"public void testPackageSignatures() throws Exception {
        Set<String> badPackages = new HashSet<String>();
        Set<Signature> wellKnownSignatures = getWellKnownSignatures();

        PackageManager packageManager = mContext.getPackageManager();
        List<PackageInfo> allPackageInfos = packageManager.getInstalledPackages(
                PackageManager.GET_UNINSTALLED_PACKAGES |
                PackageManager.GET_SIGNATURES |
                PackageManager.MATCH_APEX);
        for (PackageInfo packageInfo : allPackageInfos) {
            String packageName = packageInfo.packageName;
            Log.v(TAG, ""Scanning "" + packageName);
            if (packageName != null && !isWhitelistedPackage(packageName)) {
                for (Signature signature : packageInfo.signatures) {
                    if (wellKnownSignatures.contains(signature)) {
                        badPackages.add(packageInfo.packageName);
                    }
                }
            }
        }

        assertTrue(""These packages should not be signed with a well known key: "" + badPackages,
                badPackages.isEmpty());
    }

    /**
     * Returns the well-known dev-key signatures, e.g. to detect cases where devices under test are
     * using modules that have been signed using dev keys; Google will supply modules that have been
     * signed with production keys in all cases.
     *
     * <p>See {@link #writeSignature(String, String)} for instructions for how to create the raw
     * .bin files when adding entries to this list.
     */
    private Set<Signature> getWellKnownSignatures() throws NotFoundException, IOException {
        Set<Signature> wellKnownSignatures = new HashSet<Signature>();
        wellKnownSignatures.add(getSignature(R.raw.sig_media));
        wellKnownSignatures.add(getSignature(R.raw.sig_platform));
        wellKnownSignatures.add(getSignature(R.raw.sig_shared));
        wellKnownSignatures.add(getSignature(R.raw.sig_testkey));
        wellKnownSignatures.add(getSignature(R.raw.sig_devkeys));
        wellKnownSignatures.add(getSignature(R.raw.sig_networkstack));
        wellKnownSignatures.add(getSignature(R.raw.sig_devkeys_media));
        wellKnownSignatures.add(getSignature(R.raw.sig_devkeys_platform));
        wellKnownSignatures.add(getSignature(R.raw.sig_devkeys_shared));
        wellKnownSignatures.add(getSignature(R.raw.sig_devkeys_networkstack));
        wellKnownSignatures.add(getSignature(R.raw.sig_com_android_conscrypt));
        wellKnownSignatures.add(getSignature(R.raw.sig_com_android_media));
        wellKnownSignatures.add(getSignature(R.raw.sig_com_android_media_swcodec));
        wellKnownSignatures.add(getSignature(R.raw.sig_com_android_resolv));
        wellKnownSignatures.add(getSignature(R.raw.sig_com_android_runtime_debug));
        wellKnownSignatures.add(getSignature(R.raw.sig_com_android_runtime_release));
        wellKnownSignatures.add(getSignature(R.raw.sig_com_android_tzdata));
        wellKnownSignatures.add(getSignature(R.raw.sig_com_google_android_conscrypt));
        wellKnownSignatures.add(getSignature(R.raw.sig_com_google_android_media));
        wellKnownSignatures.add(getSignature(R.raw.sig_com_google_android_media_swcodec));
        wellKnownSignatures.add(getSignature(R.raw.sig_com_google_android_resolv));
        wellKnownSignatures.add(getSignature(R.raw.sig_com_google_android_runtime_debug));
        wellKnownSignatures.add(getSignature(R.raw.sig_com_google_android_runtime_release));
        wellKnownSignatures.add(getSignature(R.raw.sig_com_google_android_tzdata3));
        // The following keys are not not used by modules on the latest Android release, but it
        // won't negatively affect tests to include their signatures here too.
        wellKnownSignatures.add(getSignature(R.raw.sig_com_google_android_tzdata));
        wellKnownSignatures.add(getSignature(R.raw.sig_com_google_android_tzdata2));
        return wellKnownSignatures;
    }

    private static final Set<String> WHITELISTED_PACKAGES = new HashSet<String>(Arrays.asList(
            // APKS are installed before beigning test
            ""android.netsecpolicy.usescleartext_false.cts"",
            ""android.netsecpolicy.usescleartext_unspecified.cts"",
            ""android.netsecpolicy.usescleartext_true.cts"",

            // The accessibility APK required to be installed while running CTS
            ""android.accessibilityservice.delegate"",

            // The device management APK required to be installed while running CTS
            ""android.deviceadmin.cts"",

            // APK for an activity that collects information printed in the CTS report header
            ""android.tests.devicesetup"",

            // Test utilities used by Tradefed harness
            ""com.android.tradefed.utils.wifi"",
            ""android.tradefed.contentprovider"",

            // Game used for CTS testing...
            ""com.replica.replicaisland"",

            // CTS test
            ""android.core.tests.libcore.package.com"",
            ""android.core.tests.libcore.package.conscrypt"",
            ""android.core.tests.libcore.package.dalvik"",
            ""android.core.tests.libcore.package.libcore"",
            ""android.core.tests.libcore.package.org"",
            ""android.core.tests.libcore.package.sun"",
            ""android.core.tests.libcore.package.tests"",

            // Test package to verify upgrades to privileged applications
            ""com.android.cts.priv.ctsshim"",
            ""com.android.cts.ctsshim"",
            // Test APEX used in CTS tests.
            ""com.android.apex.cts.shim"",

            // Oom Catcher package to prevent tests from ooming device.
            ""com.android.cts.oomcatcher"",

            // Collects device info at the start of the test
            ""com.android.compatibility.common.deviceinfo""

            ));

    private boolean isWhitelistedPackage(String packageName) {
        // Don't check the signatures of CTS test packages on the device.
        // devicesetup is the APK CTS loads to collect information needed in the final report
        final Matcher matcher = TEST_PACKAGE_PATTERN.matcher(packageName);
        return matcher.matches() || WHITELISTED_PACKAGES.contains(packageName);
    }

    private static final int DEFAULT_BUFFER_BYTES = 1024 * 4;

    private Signature getSignature(int resId) throws NotFoundException, IOException {
        InputStream input = mContext.getResources().openRawResource(resId);
        ByteArrayOutputStream output = new ByteArrayOutputStream();

        try {
            byte[] buffer = new byte[DEFAULT_BUFFER_BYTES];
            int numBytes = 0;
            while ((numBytes = input.read(buffer)) != -1) {
                output.write(buffer, 0, numBytes);
            }
            return new Signature(output.toByteArray());
        } finally {
            input.close();
            output.close();
        }
    }

    /**
     * Writes a package's signature to a file on the device's external storage.
     * This method was used to generate the well known signatures used by
     * this test.
     *
     * As an alternative, you can use openssl to create the
     * DER encoded certificate file.
     *
     * openssl x509 -in $ANDROID_HOME/build/target/product/security/media.x509.pem \
     *     -out sig_media.bin -outform DER
     */
    @SuppressWarnings(""unused"")
    private void writeSignature(String packageName, String fileName)
            throws NameNotFoundException, IOException {
        PackageManager packageManager = mContext.getPackageManager();
        PackageInfo packageInfo = packageManager.getPackageInfo(packageName,
                PackageManager.GET_SIGNATURES);
        File directory = mContext.getExternalFilesDir(null);
        int numSignatures = packageInfo.signatures.length;
        Log.i(TAG, ""Will dump "" + numSignatures + "" signatures to "" + directory);
        for (int i = 0; i < numSignatures; i++) {
            Signature signature = packageInfo.signatures[i];
            byte[] signatureBytes = signature.toByteArray();
            File signatureFile = new File(directory, fileName + ""."" + i);
            FileOutputStream output = null;
            try {
                output = new FileOutputStream(signatureFile);
                output.write(signatureBytes);
            } finally {
                if (output != null) {
                    output.close();
                }
            }
        }
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.accessibilityservice.cts.utils.ActivityLaunchUtils"	"adoptShellPermissionIdentity"	"CtsAccessibilityServiceTestCases"	"/home/gpoor/cts-12-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/utils/ActivityLaunchUtils.java"	""	"public void test/**
 *.
 */

package android.accessibilityservice.cts.utils;

import static android.accessibility.cts.common.ShellCommandBuilder.execShellCommand;
import static android.accessibilityservice.cts.utils.AsyncUtils.DEFAULT_TIMEOUT_MS;
import static android.content.pm.PackageManager.FEATURE_ACTIVITIES_ON_SECONDARY_DISPLAYS;

import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.fail;

import android.accessibilityservice.AccessibilityServiceInfo;
import android.app.Activity;
import android.app.ActivityOptions;
import android.app.Instrumentation;
import android.app.UiAutomation;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.content.pm.ResolveInfo;
import android.graphics.Rect;
import android.os.PowerManager;
import android.os.SystemClock;
import android.text.TextUtils;
import android.util.Log;
import android.util.SparseArray;
import android.view.Display;
import android.view.InputDevice;
import android.view.KeyCharacterMap;
import android.view.KeyEvent;
import android.view.accessibility.AccessibilityEvent;
import android.view.accessibility.AccessibilityNodeInfo;
import android.view.accessibility.AccessibilityWindowInfo;

import androidx.test.rule.ActivityTestRule;

import com.android.compatibility.common.util.TestUtils;

import java.util.Arrays;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.TimeoutException;
import java.util.function.BooleanSupplier;
import java.util.stream.Collectors;

/**
 * Utilities useful when launching an activity to make sure it's all the way on the screen
 * before we start testing it.
 */
public class ActivityLaunchUtils {
    private static final String LOG_TAG = ""ActivityLaunchUtils"";
    private static final String AM_START_HOME_ACTIVITY_COMMAND =
            ""am start -a android.intent.action.MAIN -c android.intent.category.HOME"";
    public static final String AM_BROADCAST_CLOSE_SYSTEM_DIALOG_COMMAND =
            ""am broadcast -a android.intent.action.CLOSE_SYSTEM_DIALOGS"";

    // Using a static variable so it can be used in lambdas. Not preserving state in it.
    private static Activity mTempActivity;

    public static <T extends Activity> T launchActivityAndWaitForItToBeOnscreen(
            Instrumentation instrumentation, UiAutomation uiAutomation,
            ActivityTestRule<T> rule) throws Exception {
        ActivityLauncher activityLauncher = new ActivityLauncher() {
            @Override
            Activity launchActivity() {
                return rule.launchActivity(null);
            }
        };
        return launchActivityOnSpecifiedDisplayAndWaitForItToBeOnscreen(instrumentation,
                uiAutomation, activityLauncher, Display.DEFAULT_DISPLAY);
    }

    /**
     * If this activity would be launched at virtual display, please finishes this activity before
     * this test ended. Otherwise it will be displayed on default display and impacts the next test.
     */
    public static <T extends Activity> T launchActivityOnSpecifiedDisplayAndWaitForItToBeOnscreen(
            Instrumentation instrumentation, UiAutomation uiAutomation, Class<T> clazz,
            int displayId) throws Exception {
        final ActivityOptions options = ActivityOptions.makeBasic();
        options.setLaunchDisplayId(displayId);
        final Intent intent = new Intent(instrumentation.getTargetContext(), clazz);
        // Add clear task because this activity may on other display.
        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK|Intent.FLAG_ACTIVITY_NEW_TASK);

        ActivityLauncher activityLauncher = new ActivityLauncher() {
            @Override
            Activity launchActivity() {
                uiAutomation.adoptShellPermissionIdentity();
                try {
                    return instrumentation.startActivitySync(intent, options.toBundle());
                } finally {
                    uiAutomation.dropShellPermissionIdentity();
                }
            }
        };
        return launchActivityOnSpecifiedDisplayAndWaitForItToBeOnscreen(instrumentation,
                uiAutomation, activityLauncher, displayId);
    }

    public static CharSequence getActivityTitle(
            Instrumentation instrumentation, Activity activity) {
        final StringBuilder titleBuilder = new StringBuilder();
        instrumentation.runOnMainSync(() -> titleBuilder.append(activity.getTitle()));
        return titleBuilder;
    }

    public static AccessibilityWindowInfo findWindowByTitle(
            UiAutomation uiAutomation, CharSequence title) {
        final List<AccessibilityWindowInfo> windows = uiAutomation.getWindows();
        return findWindowByTitleWithList(title, windows);
    }

    public static AccessibilityWindowInfo findWindowByTitleAndDisplay(
            UiAutomation uiAutomation, CharSequence title, int displayId) {
        final SparseArray<List<AccessibilityWindowInfo>> allWindows =
                uiAutomation.getWindowsOnAllDisplays();
        final List<AccessibilityWindowInfo> windowsOfDisplay = allWindows.get(displayId);
        return findWindowByTitleWithList(title, windowsOfDisplay);
    }

    public static void homeScreenOrBust(Context context, UiAutomation uiAutomation) {
        wakeUpOrBust(context, uiAutomation);
        if (context.getPackageManager().isInstantApp()) return;
        if (isHomeScreenShowing(context, uiAutomation)) return;
        try {
            executeAndWaitOn(
                    uiAutomation,
                    () -> {
                        execShellCommand(uiAutomation, AM_START_HOME_ACTIVITY_COMMAND);
                        execShellCommand(uiAutomation, AM_BROADCAST_CLOSE_SYSTEM_DIALOG_COMMAND);
                    },
                    () -> isHomeScreenShowing(context, uiAutomation),
                    DEFAULT_TIMEOUT_MS,
                    ""home screen"");
        } catch (AssertionError error) {
            Log.e(LOG_TAG, ""Timed out looking for home screen. Dumping window list"");
            final List<AccessibilityWindowInfo> windows = uiAutomation.getWindows();
            if (windows == null) {
                Log.e(LOG_TAG, ""Window list is null"");
            } else if (windows.isEmpty()) {
                Log.e(LOG_TAG, ""Window list is empty"");
            } else {
                for (AccessibilityWindowInfo window : windows) {
                    Log.e(LOG_TAG, window.toString());
                }
            }

            fail(""Unable to reach home screen"");
        }
    }

    public static boolean supportsMultiDisplay(Context context) {
        return context.getPackageManager().hasSystemFeature(
                FEATURE_ACTIVITIES_ON_SECONDARY_DISPLAYS);
    }

    private static boolean isHomeScreenShowing(Context context, UiAutomation uiAutomation) {
        final List<AccessibilityWindowInfo> windows = uiAutomation.getWindows();
        final PackageManager packageManager = context.getPackageManager();
        final List<ResolveInfo> resolveInfos = packageManager.queryIntentActivities(
                new Intent(Intent.ACTION_MAIN).addCategory(Intent.CATEGORY_HOME),
                PackageManager.MATCH_DEFAULT_ONLY);

        // Look for a window with a package name that matches the default home screen
        for (AccessibilityWindowInfo window : windows) {
            final AccessibilityNodeInfo root = window.getRoot();
            if (root != null) {
                final CharSequence packageName = root.getPackageName();
                if (packageName != null) {
                    for (ResolveInfo resolveInfo : resolveInfos) {
                        if ((resolveInfo.activityInfo != null)
                                && packageName.equals(resolveInfo.activityInfo.packageName)) {
                            return true;
                        }
                    }
                }
            }
        }
        // List unexpected package names of default home screen that invoking ResolverActivity
        final CharSequence homePackageNames = resolveInfos.stream()
                .map(r -> r.activityInfo).filter(Objects::nonNull)
                .map(a -> a.packageName).collect(Collectors.joining("", ""));
        Log.v(LOG_TAG, ""No window matched with package names of home screen: "" + homePackageNames);
        return false;
    }

    private static void wakeUpOrBust(Context context, UiAutomation uiAutomation) {
        final long deadlineUptimeMillis = SystemClock.uptimeMillis() + DEFAULT_TIMEOUT_MS;
        final PowerManager powerManager = context.getSystemService(PowerManager.class);
        do {
            if (powerManager.isInteractive()) {
                Log.d(LOG_TAG, ""Device is interactive"");
                return;
            }

            Log.d(LOG_TAG, ""Sending wakeup keycode"");
            final long eventTime = SystemClock.uptimeMillis();
            uiAutomation.injectInputEvent(
                    new KeyEvent(eventTime, eventTime, KeyEvent.ACTION_DOWN,
                            KeyEvent.KEYCODE_WAKEUP, 0 /* repeat */, 0 /* metastate */,
                            KeyCharacterMap.VIRTUAL_KEYBOARD, 0 /* scancode */, 0 /* flags */,
                            InputDevice.SOURCE_KEYBOARD), true /* sync */);
            uiAutomation.injectInputEvent(
                    new KeyEvent(eventTime, eventTime, KeyEvent.ACTION_UP,
                            KeyEvent.KEYCODE_WAKEUP, 0 /* repeat */, 0 /* metastate */,
                            KeyCharacterMap.VIRTUAL_KEYBOARD, 0 /* scancode */, 0 /* flags */,
                            InputDevice.SOURCE_KEYBOARD), true /* sync */);
            try {
                Thread.sleep(50);
            } catch (InterruptedException e) {}
        } while (SystemClock.uptimeMillis() < deadlineUptimeMillis);
        fail(""Unable to wake up screen"");
    }

    /**
     * Executes a command and waits for a specified condition up to a given wait timeout. It checks
     * condition result each time when events delivered, and throws exception if the condition
     * result is not {@code true} within the given timeout.
     */
    private static void executeAndWaitOn(UiAutomation uiAutomation, Runnable command,
            BooleanSupplier condition, long timeoutMillis, String conditionName) {
        final Object waitObject = new Object();
        final long executionStartTimeMillis = SystemClock.uptimeMillis();
        try {
            uiAutomation.setOnAccessibilityEventListener((event) -> {
                if (event.getEventTime() < executionStartTimeMillis) {
                    return;
                }
                synchronized (waitObject) {
                    waitObject.notifyAll();
                }
            });
            command.run();
            TestUtils.waitOn(waitObject, condition, timeoutMillis, conditionName);
        } finally {
            uiAutomation.setOnAccessibilityEventListener(null);
        }
    }

    private static <T extends Activity> T launchActivityOnSpecifiedDisplayAndWaitForItToBeOnscreen(
            Instrumentation instrumentation, UiAutomation uiAutomation,
            ActivityLauncher activityLauncher, int displayId) throws Exception {
        final int[] location = new int[2];
        final StringBuilder activityPackage = new StringBuilder();
        final Rect bounds = new Rect();
        final StringBuilder activityTitle = new StringBuilder();
        final StringBuilder timeoutExceptionRecords = new StringBuilder();
        // Make sure we get window events, so we'll know when the window appears
        AccessibilityServiceInfo info = uiAutomation.getServiceInfo();
        info.flags |= AccessibilityServiceInfo.FLAG_RETRIEVE_INTERACTIVE_WINDOWS;
        uiAutomation.setServiceInfo(info);
        // There is no any window on virtual display even doing GLOBAL_ACTION_HOME, so only
        // checking the home screen for default display.
        if (displayId == Display.DEFAULT_DISPLAY) {
            homeScreenOrBust(instrumentation.getContext(), uiAutomation);
        }

        try {
            final AccessibilityEvent awaitedEvent = uiAutomation.executeAndWaitForEvent(
                    () -> {
                        mTempActivity = activityLauncher.launchActivity();
                        instrumentation.runOnMainSync(() -> {
                            mTempActivity.getWindow().getDecorView().getLocationOnScreen(location);
                            activityPackage.append(mTempActivity.getPackageName());
                        });
                        instrumentation.waitForIdleSync();
                        activityTitle.append(getActivityTitle(instrumentation, mTempActivity));
                    },
                    (event) -> {
                        final AccessibilityWindowInfo window =
                                findWindowByTitleAndDisplay(uiAutomation, activityTitle, displayId);
                        if (window == null) return false;
                        if (window.getRoot() == null) return false;

                        window.getBoundsInScreen(bounds);
                        mTempActivity.getWindow().getDecorView().getLocationOnScreen(location);

                        // Stores the related information including event, location and window
                        // as a timeout exception record.
                        timeoutExceptionRecords.append(String.format(""{Received event: %s \n""
                                + ""Window location: %s \nA11y window: %s}\n"",
                                event, Arrays.toString(location), window));

                        return (!bounds.isEmpty())
                                && (bounds.left == location[0]) && (bounds.top == location[1]);
                    }, DEFAULT_TIMEOUT_MS);
            assertNotNull(awaitedEvent);
        } catch (TimeoutException timeout) {
            throw new TimeoutException(timeout.getMessage() + ""\n\nTimeout exception records : \n""
                    + timeoutExceptionRecords);
        }
        return (T) mTempActivity;
    }

    private static AccessibilityWindowInfo findWindowByTitleWithList(CharSequence title,
            List<AccessibilityWindowInfo> windows) {
        AccessibilityWindowInfo returnValue = null;
        if (windows != null && windows.size() > 0) {
            for (int i = 0; i < windows.size(); i++) {
                final AccessibilityWindowInfo window = windows.get(i);
                if (TextUtils.equals(title, window.getTitle())) {
                    returnValue = window;
                } else {
                    window.recycle();
                }
            }
        }
        return returnValue;
    }

    private static abstract class ActivityLauncher {
        abstract Activity launchActivity();
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.mockime.MockIme"	"shouldDispatchToMainThread"	""	"/home/gpoor/cts-12-source/cts/tests/inputmethod/mockime/src/com/android/cts/mockime/MockIme.java"	""	"public void test/*
 *.
 */

package com.android.cts.mockime;

import static android.view.ViewGroup.LayoutParams.MATCH_PARENT;
import static android.view.ViewGroup.LayoutParams.WRAP_CONTENT;
import static android.view.WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS;

import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageManager;
import android.content.res.Configuration;
import android.graphics.Bitmap;
import android.inputmethodservice.InputMethodService;
import android.os.Build;
import android.os.Bundle;
import android.os.Handler;
import android.os.HandlerThread;
import android.os.IBinder;
import android.os.Looper;
import android.os.Process;
import android.os.ResultReceiver;
import android.os.StrictMode;
import android.os.SystemClock;
import android.text.TextUtils;
import android.util.Log;
import android.util.Size;
import android.util.TypedValue;
import android.view.Display;
import android.view.GestureDetector;
import android.view.Gravity;
import android.view.KeyEvent;
import android.view.View;
import android.view.ViewConfiguration;
import android.view.Window;
import android.view.WindowInsets;
import android.view.WindowManager;
import android.view.inputmethod.CompletionInfo;
import android.view.inputmethod.CorrectionInfo;
import android.view.inputmethod.CursorAnchorInfo;
import android.view.inputmethod.EditorInfo;
import android.view.inputmethod.ExtractedTextRequest;
import android.view.inputmethod.InlineSuggestion;
import android.view.inputmethod.InlineSuggestionsRequest;
import android.view.inputmethod.InlineSuggestionsResponse;
import android.view.inputmethod.InputBinding;
import android.view.inputmethod.InputConnection;
import android.view.inputmethod.InputContentInfo;
import android.view.inputmethod.InputMethod;
import android.widget.FrameLayout;
import android.widget.HorizontalScrollView;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.TextView;
import android.widget.inline.InlinePresentationSpec;

import androidx.annotation.AnyThread;
import androidx.annotation.CallSuper;
import androidx.annotation.MainThread;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.annotation.WorkerThread;
import androidx.autofill.inline.UiVersions;
import androidx.autofill.inline.UiVersions.StylesBuilder;
import androidx.autofill.inline.v1.InlineSuggestionUi;

import java.util.ArrayList;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.BooleanSupplier;
import java.util.function.Consumer;
import java.util.function.Supplier;

/**
 * Mock IME for end-to-end tests.
 */
public final class MockIme extends InputMethodService {

    private static final String TAG = ""MockIme"";

    private static final String PACKAGE_NAME = ""com.android.cts.mockime"";

    static ComponentName getComponentName() {
        return new ComponentName(PACKAGE_NAME, MockIme.class.getName());
    }

    static String getImeId() {
        return getComponentName().flattenToShortString();
    }

    static String getCommandActionName(@NonNull String eventActionName) {
        return eventActionName + "".command"";
    }

    private final HandlerThread mHandlerThread = new HandlerThread(""CommandReceiver"");

    private final Handler mMainHandler = new Handler();

    private static final class CommandReceiver extends BroadcastReceiver {
        @NonNull
        private final String mActionName;
        @NonNull
        private final Consumer<ImeCommand> mOnReceiveCommand;

        CommandReceiver(@NonNull String actionName,
                @NonNull Consumer<ImeCommand> onReceiveCommand) {
            mActionName = actionName;
            mOnReceiveCommand = onReceiveCommand;
        }

        @Override
        public void onReceive(Context context, Intent intent) {
            if (TextUtils.equals(mActionName, intent.getAction())) {
                mOnReceiveCommand.accept(ImeCommand.fromBundle(intent.getExtras()));
            }
        }
    }

    @Nullable
    private InputConnection mMemorizedInputConnection = null;

    @Nullable
    @MainThread
    private InputConnection getMemorizedOrCurrentInputConnection() {
        return mMemorizedInputConnection != null
                ? mMemorizedInputConnection : getCurrentInputConnection();
    }

    @WorkerThread
    private void onReceiveCommand(@NonNull ImeCommand command) {
        getTracer().onReceiveCommand(command, () -> {
            if (command.shouldDispatchToMainThread()) {
                mMainHandler.post(() -> onHandleCommand(command));
            } else {
                onHandleCommand(command);
            }
        });
    }

    @AnyThread
    private void onHandleCommand(@NonNull ImeCommand command) {
        getTracer().onHandleCommand(command, () -> {
            if (command.shouldDispatchToMainThread()) {
                if (Looper.myLooper() != Looper.getMainLooper()) {
                    throw new IllegalStateException(""command "" + command
                            + "" should be handled on the main thread"");
                }
                // The context which created from InputMethodService#createXXXContext must behave
                // like an UI context, which can obtain a display, a window manager,
                // a view configuration and a gesture detector instance without strict mode
                // violation.
                final Configuration testConfig = new Configuration();
                testConfig.setToDefaults();
                final Context configContext = createConfigurationContext(testConfig);
                final Context attrContext = createAttributionContext(null /* attributionTag */);
                // UI component accesses on a display context must throw strict mode violations.
                final Context displayContext = createDisplayContext(getDisplay());
                switch (command.getName()) {
                    case ""memorizeCurrentInputConnection"": {
                        if (!Looper.getMainLooper().isCurrentThread()) {
                            return new UnsupportedOperationException(
                                    ""memorizeCurrentInputConnection can be requested only for the""
                                            + "" main thread."");
                        }
                        mMemorizedInputConnection = getCurrentInputConnection();
                        return ImeEvent.RETURN_VALUE_UNAVAILABLE;
                    }
                    case ""unmemorizeCurrentInputConnection"": {
                        if (!Looper.getMainLooper().isCurrentThread()) {
                            return new UnsupportedOperationException(
                                    ""unmemorizeCurrentInputConnection can be requested only for the""
                                            + "" main thread."");
                        }
                        mMemorizedInputConnection = null;
                        return ImeEvent.RETURN_VALUE_UNAVAILABLE;
                    }
                    case ""getTextBeforeCursor"": {
                        final int n = command.getExtras().getInt(""n"");
                        final int flag = command.getExtras().getInt(""flag"");
                        return getMemorizedOrCurrentInputConnection().getTextBeforeCursor(n, flag);
                    }
                    case ""getTextAfterCursor"": {
                        final int n = command.getExtras().getInt(""n"");
                        final int flag = command.getExtras().getInt(""flag"");
                        return getMemorizedOrCurrentInputConnection().getTextAfterCursor(n, flag);
                    }
                    case ""getSelectedText"": {
                        final int flag = command.getExtras().getInt(""flag"");
                        return getMemorizedOrCurrentInputConnection().getSelectedText(flag);
                    }
                    case ""getCursorCapsMode"": {
                        final int reqModes = command.getExtras().getInt(""reqModes"");
                        return getMemorizedOrCurrentInputConnection().getCursorCapsMode(reqModes);
                    }
                    case ""getExtractedText"": {
                        final ExtractedTextRequest request =
                                command.getExtras().getParcelable(""request"");
                        final int flags = command.getExtras().getInt(""flags"");
                        return getMemorizedOrCurrentInputConnection().getExtractedText(request,
                                flags);
                    }
                    case ""deleteSurroundingText"": {
                        final int beforeLength = command.getExtras().getInt(""beforeLength"");
                        final int afterLength = command.getExtras().getInt(""afterLength"");
                        return getMemorizedOrCurrentInputConnection().deleteSurroundingText(
                                beforeLength, afterLength);
                    }
                    case ""deleteSurroundingTextInCodePoints"": {
                        final int beforeLength = command.getExtras().getInt(""beforeLength"");
                        final int afterLength = command.getExtras().getInt(""afterLength"");
                        return getMemorizedOrCurrentInputConnection()
                                .deleteSurroundingTextInCodePoints(beforeLength, afterLength);
                    }
                    case ""setComposingText"": {
                        final CharSequence text = command.getExtras().getCharSequence(""text"");
                        final int newCursorPosition =
                                command.getExtras().getInt(""newCursorPosition"");
                        return getMemorizedOrCurrentInputConnection().setComposingText(
                                text, newCursorPosition);
                    }
                    case ""setComposingRegion"": {
                        final int start = command.getExtras().getInt(""start"");
                        final int end = command.getExtras().getInt(""end"");
                        return getMemorizedOrCurrentInputConnection().setComposingRegion(start,
                                end);
                    }
                    case ""finishComposingText"":
                        return getMemorizedOrCurrentInputConnection().finishComposingText();
                    case ""commitText"": {
                        final CharSequence text = command.getExtras().getCharSequence(""text"");
                        final int newCursorPosition =
                                command.getExtras().getInt(""newCursorPosition"");
                        return getMemorizedOrCurrentInputConnection().commitText(text,
                                newCursorPosition);
                    }
                    case ""commitCompletion"": {
                        final CompletionInfo text = command.getExtras().getParcelable(""text"");
                        return getMemorizedOrCurrentInputConnection().commitCompletion(text);
                    }
                    case ""commitCorrection"": {
                        final CorrectionInfo correctionInfo =
                                command.getExtras().getParcelable(""correctionInfo"");
                        return getMemorizedOrCurrentInputConnection().commitCorrection(
                                correctionInfo);
                    }
                    case ""setSelection"": {
                        final int start = command.getExtras().getInt(""start"");
                        final int end = command.getExtras().getInt(""end"");
                        return getMemorizedOrCurrentInputConnection().setSelection(start, end);
                    }
                    case ""performEditorAction"": {
                        final int editorAction = command.getExtras().getInt(""editorAction"");
                        return getMemorizedOrCurrentInputConnection().performEditorAction(
                                editorAction);
                    }
                    case ""performContextMenuAction"": {
                        final int id = command.getExtras().getInt(""id"");
                        return getMemorizedOrCurrentInputConnection().performContextMenuAction(id);
                    }
                    case ""beginBatchEdit"":
                        return getMemorizedOrCurrentInputConnection().beginBatchEdit();
                    case ""endBatchEdit"":
                        return getMemorizedOrCurrentInputConnection().endBatchEdit();
                    case ""sendKeyEvent"": {
                        final KeyEvent event = command.getExtras().getParcelable(""event"");
                        return getMemorizedOrCurrentInputConnection().sendKeyEvent(event);
                    }
                    case ""clearMetaKeyStates"": {
                        final int states = command.getExtras().getInt(""states"");
                        return getMemorizedOrCurrentInputConnection().clearMetaKeyStates(states);
                    }
                    case ""reportFullscreenMode"": {
                        final boolean enabled = command.getExtras().getBoolean(""enabled"");
                        return getMemorizedOrCurrentInputConnection().reportFullscreenMode(enabled);
                    }
                    case ""performSpellCheck"": {
                        return getMemorizedOrCurrentInputConnection().performSpellCheck();
                    }
                    case ""performPrivateCommand"": {
                        final String action = command.getExtras().getString(""action"");
                        final Bundle data = command.getExtras().getBundle(""data"");
                        return getMemorizedOrCurrentInputConnection().performPrivateCommand(action,
                                data);
                    }
                    case ""requestCursorUpdates"": {
                        final int cursorUpdateMode = command.getExtras().getInt(""cursorUpdateMode"");
                        return getMemorizedOrCurrentInputConnection().requestCursorUpdates(
                                cursorUpdateMode);
                    }
                    case ""getHandler"":
                        return getMemorizedOrCurrentInputConnection().getHandler();
                    case ""closeConnection"":
                        getMemorizedOrCurrentInputConnection().closeConnection();
                        return ImeEvent.RETURN_VALUE_UNAVAILABLE;
                    case ""commitContent"": {
                        final InputContentInfo inputContentInfo =
                                command.getExtras().getParcelable(""inputContentInfo"");
                        final int flags = command.getExtras().getInt(""flags"");
                        final Bundle opts = command.getExtras().getBundle(""opts"");
                        return getMemorizedOrCurrentInputConnection().commitContent(
                                inputContentInfo, flags, opts);
                    }
                    case ""setBackDisposition"": {
                        final int backDisposition =
                                command.getExtras().getInt(""backDisposition"");
                        setBackDisposition(backDisposition);
                        return ImeEvent.RETURN_VALUE_UNAVAILABLE;
                    }
                    case ""requestHideSelf"": {
                        final int flags = command.getExtras().getInt(""flags"");
                        requestHideSelf(flags);
                        return ImeEvent.RETURN_VALUE_UNAVAILABLE;
                    }
                    case ""requestShowSelf"": {
                        final int flags = command.getExtras().getInt(""flags"");
                        requestShowSelf(flags);
                        return ImeEvent.RETURN_VALUE_UNAVAILABLE;
                    }
                    case ""sendDownUpKeyEvents"": {
                        final int keyEventCode = command.getExtras().getInt(""keyEventCode"");
                        sendDownUpKeyEvents(keyEventCode);
                        return ImeEvent.RETURN_VALUE_UNAVAILABLE;
                    }
                    case ""getApplicationInfo"": {
                        final String packageName = command.getExtras().getString(""packageName"");
                        final int flags = command.getExtras().getInt(""flags"");
                        try {
                            return getPackageManager().getApplicationInfo(packageName, flags);
                        } catch (PackageManager.NameNotFoundException e) {
                            return e;
                        }
                    }
                    case ""getDisplayId"":
                        return getDisplay().getDisplayId();
                    case ""verifyLayoutInflaterContext"":
                        return getLayoutInflater().getContext() == this;
                    case ""setHeight"":
                        final int height = command.getExtras().getInt(""height"");
                        mView.setHeight(height);
                        return ImeEvent.RETURN_VALUE_UNAVAILABLE;
                    case ""setInlineSuggestionsExtras"":
                        mInlineSuggestionsExtras = command.getExtras();
                        return ImeEvent.RETURN_VALUE_UNAVAILABLE;
                    case ""verifyGetDisplay"":
                        try {
                            return verifyGetDisplay();
                        } catch (UnsupportedOperationException e) {
                            return e;
                        }
                    case ""verifyGetWindowManager"": {
                        final WindowManager imsWm = getSystemService(WindowManager.class);
                        final WindowManager configContextWm =
                                configContext.getSystemService(WindowManager.class);
                        final WindowManager attrContextWm =
                                attrContext.getSystemService(WindowManager.class);
                        return ImeEvent.RETURN_VALUE_UNAVAILABLE;
                    }
                    case ""verifyGetViewConfiguration"": {
                        final ViewConfiguration imsViewConfig = ViewConfiguration.get(this);
                        final ViewConfiguration configContextViewConfig =
                                ViewConfiguration.get(configContext);
                        final ViewConfiguration attrContextViewConfig =
                                ViewConfiguration.get(attrContext);
                        return ImeEvent.RETURN_VALUE_UNAVAILABLE;
                    }
                    case ""verifyGetGestureDetector"": {
                        GestureDetector.SimpleOnGestureListener listener =
                                new GestureDetector.SimpleOnGestureListener();
                        final GestureDetector imsGestureDetector =
                                new GestureDetector(this, listener);
                        final GestureDetector configContextGestureDetector =
                                new GestureDetector(configContext, listener);
                        final GestureDetector attrGestureDetector =
                                new GestureDetector(attrContext, listener);
                        return ImeEvent.RETURN_VALUE_UNAVAILABLE;
                    }
                    case ""verifyGetWindowManagerOnDisplayContext"": {
                        // Obtaining a WindowManager on a display context must throw a strict mode
                        // violation.
                        final WindowManager wm = displayContext
                                .getSystemService(WindowManager.class);

                        return ImeEvent.RETURN_VALUE_UNAVAILABLE;
                    }
                    case ""verifyGetViewConfigurationOnDisplayContext"": {
                        // Obtaining a ViewConfiguration on a display context must throw a strict
                        // mode violation.
                        final ViewConfiguration viewConfiguration =
                                ViewConfiguration.get(displayContext);

                        return ImeEvent.RETURN_VALUE_UNAVAILABLE;
                    }
                    case ""verifyGetGestureDetectorOnDisplayContext"": {
                        // Obtaining a GestureDetector on a display context must throw a strict mode
                        // violation.
                        GestureDetector.SimpleOnGestureListener listener =
                                new GestureDetector.SimpleOnGestureListener();
                        final GestureDetector gestureDetector =
                                new GestureDetector(displayContext, listener);

                        return ImeEvent.RETURN_VALUE_UNAVAILABLE;
                    }
                }
            }
            return ImeEvent.RETURN_VALUE_UNAVAILABLE;
        });
    }

    private boolean verifyGetDisplay() throws UnsupportedOperationException {
        final Display display;
        final Display configContextDisplay;
        final Configuration config = new Configuration();
        config.setToDefaults();
        final Context configContext = createConfigurationContext(config);
        display = getDisplay();
        configContextDisplay = configContext.getDisplay();
        return display != null && configContextDisplay != null;
    }

    @Nullable
    private Bundle mInlineSuggestionsExtras;

    @Nullable
    private CommandReceiver mCommandReceiver;

    @Nullable
    private ImeSettings mSettings;

    private final AtomicReference<String> mImeEventActionName = new AtomicReference<>();

    @Nullable
    String getImeEventActionName() {
        return mImeEventActionName.get();
    }

    private final AtomicReference<String> mClientPackageName = new AtomicReference<>();

    @Nullable
    String getClientPackageName() {
        return mClientPackageName.get();
    }

    private class MockInputMethodImpl extends InputMethodImpl {
        @Override
        public void showSoftInput(int flags, ResultReceiver resultReceiver) {
            getTracer().showSoftInput(flags, resultReceiver,
                    () -> super.showSoftInput(flags, resultReceiver));
        }

        @Override
        public void hideSoftInput(int flags, ResultReceiver resultReceiver) {
            getTracer().hideSoftInput(flags, resultReceiver,
                    () -> super.hideSoftInput(flags, resultReceiver));
        }

        @Override
        public void attachToken(IBinder token) {
            getTracer().attachToken(token, () -> super.attachToken(token));
        }

        @Override
        public void bindInput(InputBinding binding) {
            getTracer().bindInput(binding, () -> super.bindInput(binding));
        }

        @Override
        public void unbindInput() {
            getTracer().unbindInput(() -> super.unbindInput());
        }
    }

    @Override
    public void onCreate() {
        // Initialize minimum settings to send events in Tracer#onCreate().
        mSettings = SettingsProvider.getSettings();
        if (mSettings == null) {
            throw new IllegalStateException(""Settings file is not found. ""
                    + ""Make sure MockImeSession.create() is used to launch Mock IME."");
        }
        mClientPackageName.set(mSettings.getClientPackageName());
        mImeEventActionName.set(mSettings.getEventCallbackActionName());

        // TODO(b/159593676): consider to detect more violations
        if (mSettings.isStrictModeEnabled()) {
            StrictMode.setVmPolicy(
                    new StrictMode.VmPolicy.Builder()
                            .detectIncorrectContextUse()
                            .penaltyLog()
                            .penaltyListener(Runnable::run,
                                    v -> getTracer().onStrictModeViolated(() -> { }))
                            .build());
        }

        getTracer().onCreate(() -> {
            super.onCreate();
            mHandlerThread.start();
            final String actionName = getCommandActionName(mSettings.getEventCallbackActionName());
            mCommandReceiver = new CommandReceiver(actionName, this::onReceiveCommand);
            final IntentFilter filter = new IntentFilter(actionName);
            final Handler handler = new Handler(mHandlerThread.getLooper());
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                registerReceiver(mCommandReceiver, filter, null /* broadcastPermission */, handler,
                        Context.RECEIVER_VISIBLE_TO_INSTANT_APPS);
            } else {
                registerReceiver(mCommandReceiver, filter, null /* broadcastPermission */, handler);
            }
            if (mSettings.isVerifyGetDisplayOnCreate()) {
                getTracer().onVerify(""getDisplay"", this::verifyGetDisplay);
            }
            final int windowFlags = mSettings.getWindowFlags(0);
            final int windowFlagsMask = mSettings.getWindowFlagsMask(0);
            if (windowFlags != 0 || windowFlagsMask != 0) {
                final int prevFlags = getWindow().getWindow().getAttributes().flags;
                getWindow().getWindow().setFlags(windowFlags, windowFlagsMask);
                // For some reasons, seems that we need to post another requestLayout() when
                // FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS bit is changed.
                // TODO: Investigate the reason.
                if ((windowFlagsMask & FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) != 0) {
                    final boolean hadFlag = (prevFlags & FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) != 0;
                    final boolean hasFlag = (windowFlags & FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) != 0;
                    if (hadFlag != hasFlag) {
                        final View decorView = getWindow().getWindow().getDecorView();
                        decorView.post(() -> decorView.requestLayout());
                    }
                }
            }

            // Ensuring bar contrast interferes with the tests.
            getWindow().getWindow().setStatusBarContrastEnforced(false);
            getWindow().getWindow().setNavigationBarContrastEnforced(false);

            if (mSettings.hasNavigationBarColor()) {
                getWindow().getWindow().setNavigationBarColor(mSettings.getNavigationBarColor());
            }
        });
    }

    @Override
    public void onConfigureWindow(Window win, boolean isFullscreen, boolean isCandidatesOnly) {
        getTracer().onConfigureWindow(win, isFullscreen, isCandidatesOnly,
                () -> super.onConfigureWindow(win, isFullscreen, isCandidatesOnly));
    }

    @Override
    public boolean onEvaluateFullscreenMode() {
        return getTracer().onEvaluateFullscreenMode(() ->
                mSettings.fullscreenModeAllowed(false) && super.onEvaluateFullscreenMode());
    }

    private static final class KeyboardLayoutView extends LinearLayout {
        @NonNull
        private final MockIme mMockIme;
        @NonNull
        private final ImeSettings mSettings;
        @NonNull
        private final View.OnLayoutChangeListener mLayoutListener;

        private final LinearLayout mLayout;

        @Nullable
        private final LinearLayout mSuggestionView;

        private boolean mDrawsBehindNavBar = false;

        KeyboardLayoutView(MockIme mockIme, @NonNull ImeSettings imeSettings,
                @Nullable Consumer<ImeLayoutInfo> onInputViewLayoutChangedCallback) {
            super(mockIme);

            mMockIme = mockIme;
            mSettings = imeSettings;

            setOrientation(VERTICAL);

            final int defaultBackgroundColor =
                    getResources().getColor(android.R.color.holo_orange_dark, null);

            final int mainSpacerHeight = mSettings.getInputViewHeight(LayoutParams.WRAP_CONTENT);
            mLayout = new LinearLayout(getContext());
            mLayout.setOrientation(LinearLayout.VERTICAL);

            if (mSettings.getInlineSuggestionsEnabled()) {
                final HorizontalScrollView scrollView = new HorizontalScrollView(getContext());
                final LayoutParams scrollViewParams = new LayoutParams(MATCH_PARENT, 100);
                scrollView.setLayoutParams(scrollViewParams);

                final LinearLayout suggestionView = new LinearLayout(getContext());
                suggestionView.setBackgroundColor(0xFFEEEEEE);
                final String suggestionViewContentDesc =
                        mSettings.getInlineSuggestionViewContentDesc(null /* default */);
                if (suggestionViewContentDesc != null) {
                    suggestionView.setContentDescription(suggestionViewContentDesc);
                }
                scrollView.addView(suggestionView, new LayoutParams(MATCH_PARENT, MATCH_PARENT));
                mSuggestionView = suggestionView;

                mLayout.addView(scrollView);
            } else {
                mSuggestionView = null;
            }

            {
                final FrameLayout secondaryLayout = new FrameLayout(getContext());
                secondaryLayout.setForegroundGravity(Gravity.CENTER);

                final TextView textView = new TextView(getContext());
                textView.setLayoutParams(new LayoutParams(MATCH_PARENT, WRAP_CONTENT));
                textView.setTextSize(TypedValue.COMPLEX_UNIT_SP, 20);
                textView.setGravity(Gravity.CENTER);
                textView.setText(getImeId());
                textView.setBackgroundColor(
                        mSettings.getBackgroundColor(defaultBackgroundColor));
                secondaryLayout.addView(textView);

                if (mSettings.isWatermarkEnabled(true /* defaultValue */)) {
                    final ImageView imageView = new ImageView(getContext());
                    final Bitmap bitmap = Watermark.create();
                    imageView.setImageBitmap(bitmap);
                    secondaryLayout.addView(imageView,
                            new FrameLayout.LayoutParams(bitmap.getWidth(), bitmap.getHeight(),
                                    Gravity.CENTER));
                }

                mLayout.addView(secondaryLayout);
            }

            addView(mLayout, MATCH_PARENT, mainSpacerHeight);

            final int systemUiVisibility = mSettings.getInputViewSystemUiVisibility(0);
            if (systemUiVisibility != 0) {
                setSystemUiVisibility(systemUiVisibility);
            }

            if (mSettings.getDrawsBehindNavBar()) {
                mDrawsBehindNavBar = true;
                mMockIme.getWindow().getWindow().setDecorFitsSystemWindows(false);
                setSystemUiVisibility(getSystemUiVisibility()
                        | SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION);
            }

            mLayoutListener = (View v, int left, int top, int right, int bottom, int oldLeft,
                    int oldTop, int oldRight, int oldBottom) ->
                    onInputViewLayoutChangedCallback.accept(
                            ImeLayoutInfo.fromLayoutListenerCallback(
                                    v, left, top, right, bottom, oldLeft, oldTop, oldRight,
                                    oldBottom));
            this.addOnLayoutChangeListener(mLayoutListener);
        }

        private void setHeight(int height) {
            mLayout.getLayoutParams().height = height;
            mLayout.requestLayout();
        }

        private void updateBottomPaddingIfNecessary(int newPaddingBottom) {
            if (getPaddingBottom() != newPaddingBottom) {
                setPadding(getPaddingLeft(), getPaddingTop(), getPaddingRight(), newPaddingBottom);
            }
        }

        @Override
        public WindowInsets onApplyWindowInsets(WindowInsets insets) {
            if (insets.isConsumed()
                    || mDrawsBehindNavBar
                    || (getSystemUiVisibility() & SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION) == 0) {
                // In this case we are not interested in consuming NavBar region.
                // Make sure that the bottom padding is empty.
                updateBottomPaddingIfNecessary(0);
                return insets;
            }

            // In some cases the bottom system window inset is not a navigation bar. Wear devices
            // that have bottom chin are examples.  For now, assume that it's a navigation bar if it
            // has the same height as the root window's stable bottom inset.
            final WindowInsets rootWindowInsets = getRootWindowInsets();
            if (rootWindowInsets != null && (rootWindowInsets.getStableInsetBottom()
                    != insets.getSystemWindowInsetBottom())) {
                // This is probably not a NavBar.
                updateBottomPaddingIfNecessary(0);
                return insets;
            }

            final int possibleNavBarHeight = insets.getSystemWindowInsetBottom();
            updateBottomPaddingIfNecessary(possibleNavBarHeight);
            return possibleNavBarHeight <= 0
                    ? insets
                    : insets.replaceSystemWindowInsets(
                            insets.getSystemWindowInsetLeft(),
                            insets.getSystemWindowInsetTop(),
                            insets.getSystemWindowInsetRight(),
                            0 /* bottom */);
        }

        @Override
        protected void onWindowVisibilityChanged(int visibility) {
            mMockIme.getTracer().onWindowVisibilityChanged(() -> {
                super.onWindowVisibilityChanged(visibility);
            }, visibility);
        }

        @Override
        protected void onDetachedFromWindow() {
            super.onDetachedFromWindow();
            removeOnLayoutChangeListener(mLayoutListener);
        }

        @MainThread
        private void updateInlineSuggestions(
                @NonNull PendingInlineSuggestions pendingInlineSuggestions) {
            Log.d(TAG, ""updateInlineSuggestions() called: "" + pendingInlineSuggestions.mTotalCount);
            if (mSuggestionView == null || !pendingInlineSuggestions.mValid.get()) {
                return;
            }
            mSuggestionView.removeAllViews();
            for (int i = 0; i < pendingInlineSuggestions.mTotalCount; i++) {
                View view = pendingInlineSuggestions.mViews[i];
                if (view == null) {
                    continue;
                }
                mSuggestionView.addView(view);
            }
        }
    }

    KeyboardLayoutView mView;

    private void onInputViewLayoutChanged(@NonNull ImeLayoutInfo layoutInfo) {
        getTracer().onInputViewLayoutChanged(layoutInfo, () -> { });
    }

    @Override
    public View onCreateInputView() {
        return getTracer().onCreateInputView(() -> {
            mView = new KeyboardLayoutView(this, mSettings, this::onInputViewLayoutChanged);
            return mView;
        });
    }

    @Override
    public void onStartInput(EditorInfo editorInfo, boolean restarting) {
        getTracer().onStartInput(editorInfo, restarting,
                () -> super.onStartInput(editorInfo, restarting));
    }

    @Override
    public void onStartInputView(EditorInfo editorInfo, boolean restarting) {
        getTracer().onStartInputView(editorInfo, restarting,
                () -> super.onStartInputView(editorInfo, restarting));
    }

    @Override
    public void onFinishInputView(boolean finishingInput) {
        getTracer().onFinishInputView(finishingInput,
                () -> super.onFinishInputView(finishingInput));
    }

    @Override
    public void onFinishInput() {
        getTracer().onFinishInput(() -> super.onFinishInput());
    }

    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event) {
        return getTracer().onKeyDown(keyCode, event, () -> super.onKeyDown(keyCode, event));
    }

    @Override
    public void onUpdateCursorAnchorInfo(CursorAnchorInfo cursorAnchorInfo) {
        getTracer().onUpdateCursorAnchorInfo(cursorAnchorInfo,
                () -> super.onUpdateCursorAnchorInfo(cursorAnchorInfo));
    }

    @Override
    public void onUpdateSelection(int oldSelStart, int oldSelEnd, int newSelStart, int newSelEnd,
            int candidatesStart, int candidatesEnd) {
        getTracer().onUpdateSelection(oldSelStart, oldSelEnd, newSelStart, newSelEnd,
                candidatesStart, candidatesEnd,
                () -> super.onUpdateSelection(oldSelStart, oldSelEnd, newSelStart, newSelEnd,
                        candidatesStart, candidatesEnd));
    }

    @CallSuper
    public boolean onEvaluateInputViewShown() {
        return getTracer().onEvaluateInputViewShown(() -> {
            // onShowInputRequested() is indeed @CallSuper so we always call this, even when the
            // result is ignored.
            final boolean originalResult = super.onEvaluateInputViewShown();
            if (!mSettings.getHardKeyboardConfigurationBehaviorAllowed(false)) {
                final Configuration config = getResources().getConfiguration();
                if (config.keyboard != Configuration.KEYBOARD_NOKEYS
                        && config.hardKeyboardHidden != Configuration.HARDKEYBOARDHIDDEN_YES) {
                    // Override the behavior of InputMethodService#onEvaluateInputViewShown()
                    return true;
                }
            }
            return originalResult;
        });
    }

    @Override
    public boolean onShowInputRequested(int flags, boolean configChange) {
        return getTracer().onShowInputRequested(flags, configChange, () -> {
            // onShowInputRequested() is not marked with @CallSuper, but just in case.
            final boolean originalResult = super.onShowInputRequested(flags, configChange);
            if (!mSettings.getHardKeyboardConfigurationBehaviorAllowed(false)) {
                if ((flags & InputMethod.SHOW_EXPLICIT) == 0
                        && getResources().getConfiguration().keyboard
                        != Configuration.KEYBOARD_NOKEYS) {
                    // Override the behavior of InputMethodService#onShowInputRequested()
                    return true;
                }
            }
            return originalResult;
        });
    }

    @Override
    public void onDestroy() {
        getTracer().onDestroy(() -> {
            super.onDestroy();
            unregisterReceiver(mCommandReceiver);
            mHandlerThread.quitSafely();
        });
    }

    @Override
    public AbstractInputMethodImpl onCreateInputMethodInterface() {
        return getTracer().onCreateInputMethodInterface(() -> new MockInputMethodImpl());
    }

    private final ThreadLocal<Tracer> mThreadLocalTracer = new ThreadLocal<>();

    private Tracer getTracer() {
        Tracer tracer = mThreadLocalTracer.get();
        if (tracer == null) {
            tracer = new Tracer(this);
            mThreadLocalTracer.set(tracer);
        }
        return tracer;
    }

    @NonNull
    private ImeState getState() {
        final boolean hasInputBinding = getCurrentInputBinding() != null;
        final boolean hasFallbackInputConnection =
                !hasInputBinding
                        || getCurrentInputConnection() == getCurrentInputBinding().getConnection();
        return new ImeState(hasInputBinding, hasFallbackInputConnection);
    }

    private PendingInlineSuggestions mPendingInlineSuggestions;

    private static final class PendingInlineSuggestions {
        final InlineSuggestionsResponse mResponse;
        final int mTotalCount;
        final View[] mViews;
        final AtomicInteger mInflatedViewCount;
        final AtomicBoolean mValid = new AtomicBoolean(true);

        PendingInlineSuggestions(InlineSuggestionsResponse response) {
            mResponse = response;
            mTotalCount = response.getInlineSuggestions().size();
            mViews = new View[mTotalCount];
            mInflatedViewCount = new AtomicInteger(0);
        }
    }

    @MainThread
    @Override
    public InlineSuggestionsRequest onCreateInlineSuggestionsRequest(Bundle uiExtras) {
        StylesBuilder stylesBuilder = UiVersions.newStylesBuilder();
        stylesBuilder.addStyle(InlineSuggestionUi.newStyleBuilder().build());
        Bundle styles = stylesBuilder.build();

        if (mInlineSuggestionsExtras != null) {
            styles.putAll(mInlineSuggestionsExtras);
        }

        return getTracer().onCreateInlineSuggestionsRequest(() -> {
            final ArrayList<InlinePresentationSpec> presentationSpecs = new ArrayList<>();
            presentationSpecs.add(new InlinePresentationSpec.Builder(new Size(100, 100),
                    new Size(400, 100)).setStyle(styles).build());
            presentationSpecs.add(new InlinePresentationSpec.Builder(new Size(100, 100),
                    new Size(400, 100)).setStyle(styles).build());

            final InlinePresentationSpec tooltipSpec =
                    new InlinePresentationSpec.Builder(new Size(100, 100),
                            new Size(400, 100)).setStyle(styles).build();
            final InlineSuggestionsRequest.Builder builder =
                    new InlineSuggestionsRequest.Builder(presentationSpecs)
                            .setInlineTooltipPresentationSpec(tooltipSpec)
                            .setMaxSuggestionCount(6);
            if (mInlineSuggestionsExtras != null) {
                builder.setExtras(mInlineSuggestionsExtras.deepCopy());
            }
            return builder.build();
        });
    }

    @MainThread
    @Override
    public boolean onInlineSuggestionsResponse(@NonNull InlineSuggestionsResponse response) {
        return getTracer().onInlineSuggestionsResponse(response, () -> {
            final PendingInlineSuggestions pendingInlineSuggestions =
                    new PendingInlineSuggestions(response);
            if (mPendingInlineSuggestions != null) {
                mPendingInlineSuggestions.mValid.set(false);
            }
            mPendingInlineSuggestions = pendingInlineSuggestions;
            if (pendingInlineSuggestions.mTotalCount == 0) {
                if (mView != null) {
                    mView.updateInlineSuggestions(pendingInlineSuggestions);
                }
                return true;
            }

            final ExecutorService executorService = Executors.newCachedThreadPool();
            for (int i = 0; i < pendingInlineSuggestions.mTotalCount; i++) {
                final int index = i;
                InlineSuggestion inlineSuggestion =
                        pendingInlineSuggestions.mResponse.getInlineSuggestions().get(index);
                inlineSuggestion.inflate(
                        this,
                        new Size(WRAP_CONTENT, WRAP_CONTENT),
                        executorService,
                        suggestionView -> {
                            Log.d(TAG, ""new inline suggestion view ready"");
                            if (suggestionView != null) {
                                suggestionView.setOnClickListener((v) -> {
                                    getTracer().onInlineSuggestionClickedEvent(() -> { });
                                });
                                suggestionView.setOnLongClickListener((v) -> {
                                    getTracer().onInlineSuggestionLongClickedEvent(() -> { });
                                    return true;
                                });
                                pendingInlineSuggestions.mViews[index] = suggestionView;
                            }
                            if (pendingInlineSuggestions.mInflatedViewCount.incrementAndGet()
                                    == pendingInlineSuggestions.mTotalCount
                                    && pendingInlineSuggestions.mValid.get()) {
                                Log.d(TAG, ""ready to display all suggestions"");
                                mMainHandler.post(() ->
                                        mView.updateInlineSuggestions(pendingInlineSuggestions));
                            }
                        });
            }
            return true;
        });
    }

    /**
     * Event tracing helper class for {@link MockIme}.
     */
    private static final class Tracer {

        @NonNull
        private final MockIme mIme;

        private final int mThreadId = Process.myTid();

        @NonNull
        private final String mThreadName =
                Thread.currentThread().getName() != null ? Thread.currentThread().getName() : """";

        private final boolean mIsMainThread =
                Looper.getMainLooper().getThread() == Thread.currentThread();

        private int mNestLevel = 0;

        private String mImeEventActionName;

        private String mClientPackageName;

        Tracer(@NonNull MockIme mockIme) {
            mIme = mockIme;
        }

        private void sendEventInternal(@NonNull ImeEvent event) {
            if (mImeEventActionName == null) {
                mImeEventActionName = mIme.getImeEventActionName();
            }
            if (mClientPackageName == null) {
                mClientPackageName = mIme.getClientPackageName();
            }
            if (mImeEventActionName == null || mClientPackageName == null) {
                Log.e(TAG, ""Tracer cannot be used before onCreate()"");
                return;
            }
            final Intent intent = new Intent()
                    .setAction(mImeEventActionName)
                    .setPackage(mClientPackageName)
                    .putExtras(event.toBundle())
                    .addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY
                            | Intent.FLAG_RECEIVER_VISIBLE_TO_INSTANT_APPS);
            mIme.sendBroadcast(intent);
        }

        private void recordEventInternal(@NonNull String eventName, @NonNull Runnable runnable) {
            recordEventInternal(eventName, runnable, new Bundle());
        }

        private void recordEventInternal(@NonNull String eventName, @NonNull Runnable runnable,
                @NonNull Bundle arguments) {
            recordEventInternal(eventName, () -> {
                runnable.run(); return ImeEvent.RETURN_VALUE_UNAVAILABLE;
            }, arguments);
        }

        private <T> T recordEventInternal(@NonNull String eventName,
                @NonNull Supplier<T> supplier) {
            return recordEventInternal(eventName, supplier, new Bundle());
        }

        private <T> T recordEventInternal(@NonNull String eventName,
                @NonNull Supplier<T> supplier, @NonNull Bundle arguments) {
            final ImeState enterState = mIme.getState();
            final long enterTimestamp = SystemClock.elapsedRealtimeNanos();
            final long enterWallTime = System.currentTimeMillis();
            final int nestLevel = mNestLevel;
            // Send enter event
            sendEventInternal(new ImeEvent(eventName, nestLevel, mThreadName,
                    mThreadId, mIsMainThread, enterTimestamp, 0, enterWallTime,
                    0, enterState, null, arguments,
                    ImeEvent.RETURN_VALUE_UNAVAILABLE));
            ++mNestLevel;
            T result;
            try {
                result = supplier.get();
            } finally {
                --mNestLevel;
            }
            final long exitTimestamp = SystemClock.elapsedRealtimeNanos();
            final long exitWallTime = System.currentTimeMillis();
            final ImeState exitState = mIme.getState();
            // Send exit event
            sendEventInternal(new ImeEvent(eventName, nestLevel, mThreadName,
                    mThreadId, mIsMainThread, enterTimestamp, exitTimestamp, enterWallTime,
                    exitWallTime, enterState, exitState, arguments, result));
            return result;
        }

        void onCreate(@NonNull Runnable runnable) {
            recordEventInternal(""onCreate"", runnable);
        }

        void onVerify(String name, @NonNull BooleanSupplier supplier) {
            final Bundle arguments = new Bundle();
            arguments.putString(""name"", name);
            recordEventInternal(""onVerify"", supplier::getAsBoolean, arguments);
        }

        void onConfigureWindow(Window win, boolean isFullscreen, boolean isCandidatesOnly,
                @NonNull Runnable runnable) {
            final Bundle arguments = new Bundle();
            arguments.putBoolean(""isFullscreen"", isFullscreen);
            arguments.putBoolean(""isCandidatesOnly"", isCandidatesOnly);
            recordEventInternal(""onConfigureWindow"", runnable, arguments);
        }

        boolean onEvaluateFullscreenMode(@NonNull BooleanSupplier supplier) {
            return recordEventInternal(""onEvaluateFullscreenMode"", supplier::getAsBoolean);
        }

        boolean onEvaluateInputViewShown(@NonNull BooleanSupplier supplier) {
            return recordEventInternal(""onEvaluateInputViewShown"", supplier::getAsBoolean);
        }

        View onCreateInputView(@NonNull Supplier<View> supplier) {
            return recordEventInternal(""onCreateInputView"", supplier);
        }

        void onStartInput(EditorInfo editorInfo, boolean restarting, @NonNull Runnable runnable) {
            final Bundle arguments = new Bundle();
            arguments.putParcelable(""editorInfo"", editorInfo);
            arguments.putBoolean(""restarting"", restarting);
            recordEventInternal(""onStartInput"", runnable, arguments);
        }

        void onWindowVisibilityChanged(@NonNull Runnable runnable, int visibility) {
            final Bundle arguments = new Bundle();
            arguments.putInt(""visible"", visibility);
            recordEventInternal(""onWindowVisibilityChanged"", runnable, arguments);
        }

        void onStartInputView(EditorInfo editorInfo, boolean restarting,
                @NonNull Runnable runnable) {
            final Bundle arguments = new Bundle();
            arguments.putParcelable(""editorInfo"", editorInfo);
            arguments.putBoolean(""restarting"", restarting);
            recordEventInternal(""onStartInputView"", runnable, arguments);
        }

        void onFinishInputView(boolean finishingInput, @NonNull Runnable runnable) {
            final Bundle arguments = new Bundle();
            arguments.putBoolean(""finishingInput"", finishingInput);
            recordEventInternal(""onFinishInputView"", runnable, arguments);
        }

        void onFinishInput(@NonNull Runnable runnable) {
            recordEventInternal(""onFinishInput"", runnable);
        }

        boolean onKeyDown(int keyCode, KeyEvent event, @NonNull BooleanSupplier supplier) {
            final Bundle arguments = new Bundle();
            arguments.putInt(""keyCode"", keyCode);
            arguments.putParcelable(""event"", event);
            return recordEventInternal(""onKeyDown"", supplier::getAsBoolean, arguments);
        }

        void onUpdateCursorAnchorInfo(CursorAnchorInfo cursorAnchorInfo,
                @NonNull Runnable runnable) {
            final Bundle arguments = new Bundle();
            arguments.putParcelable(""cursorAnchorInfo"", cursorAnchorInfo);
            recordEventInternal(""onUpdateCursorAnchorInfo"", runnable, arguments);
        }

        void onUpdateSelection(int oldSelStart,
                int oldSelEnd,
                int newSelStart,
                int newSelEnd,
                int candidatesStart,
                int candidatesEnd,
                @NonNull Runnable runnable) {
            final Bundle arguments = new Bundle();
            arguments.putInt(""oldSelStart"", oldSelStart);
            arguments.putInt(""oldSelEnd"", oldSelEnd);
            arguments.putInt(""newSelStart"", newSelStart);
            arguments.putInt(""newSelEnd"", newSelEnd);
            arguments.putInt(""candidatesStart"", candidatesStart);
            arguments.putInt(""candidatesEnd"", candidatesEnd);
            recordEventInternal(""onUpdateSelection"", runnable, arguments);
        }

        boolean onShowInputRequested(int flags, boolean configChange,
                @NonNull BooleanSupplier supplier) {
            final Bundle arguments = new Bundle();
            arguments.putInt(""flags"", flags);
            arguments.putBoolean(""configChange"", configChange);
            return recordEventInternal(""onShowInputRequested"", supplier::getAsBoolean, arguments);
        }

        void onDestroy(@NonNull Runnable runnable) {
            recordEventInternal(""onDestroy"", runnable);
        }

        void attachToken(IBinder token, @NonNull Runnable runnable) {
            final Bundle arguments = new Bundle();
            arguments.putBinder(""token"", token);
            recordEventInternal(""attachToken"", runnable, arguments);
        }

        void bindInput(InputBinding binding, @NonNull Runnable runnable) {
            final Bundle arguments = new Bundle();
            arguments.putParcelable(""binding"", binding);
            recordEventInternal(""bindInput"", runnable, arguments);
        }

        void unbindInput(@NonNull Runnable runnable) {
            recordEventInternal(""unbindInput"", runnable);
        }

        void showSoftInput(int flags, ResultReceiver resultReceiver, @NonNull Runnable runnable) {
            final Bundle arguments = new Bundle();
            arguments.putInt(""flags"", flags);
            arguments.putParcelable(""resultReceiver"", resultReceiver);
            recordEventInternal(""showSoftInput"", runnable, arguments);
        }

        void hideSoftInput(int flags, ResultReceiver resultReceiver, @NonNull Runnable runnable) {
            final Bundle arguments = new Bundle();
            arguments.putInt(""flags"", flags);
            arguments.putParcelable(""resultReceiver"", resultReceiver);
            recordEventInternal(""hideSoftInput"", runnable, arguments);
        }

        AbstractInputMethodImpl onCreateInputMethodInterface(
                @NonNull Supplier<AbstractInputMethodImpl> supplier) {
            return recordEventInternal(""onCreateInputMethodInterface"", supplier);
        }

        void onReceiveCommand(@NonNull ImeCommand command, @NonNull Runnable runnable) {
            final Bundle arguments = new Bundle();
            arguments.putBundle(""command"", command.toBundle());
            recordEventInternal(""onReceiveCommand"", runnable, arguments);
        }

        void onHandleCommand(
                @NonNull ImeCommand command, @NonNull Supplier<Object> resultSupplier) {
            final Bundle arguments = new Bundle();
            arguments.putBundle(""command"", command.toBundle());
            recordEventInternal(""onHandleCommand"", resultSupplier, arguments);
        }

        void onInputViewLayoutChanged(@NonNull ImeLayoutInfo imeLayoutInfo,
                @NonNull Runnable runnable) {
            final Bundle arguments = new Bundle();
            imeLayoutInfo.writeToBundle(arguments);
            recordEventInternal(""onInputViewLayoutChanged"", runnable, arguments);
        }

        void onStrictModeViolated(@NonNull Runnable runnable) {
            final Bundle arguments = new Bundle();
            recordEventInternal(""onStrictModeViolated"", runnable, arguments);
        }

        InlineSuggestionsRequest onCreateInlineSuggestionsRequest(
                @NonNull Supplier<InlineSuggestionsRequest> supplier) {
            return recordEventInternal(""onCreateInlineSuggestionsRequest"", supplier);
        }

        boolean onInlineSuggestionsResponse(@NonNull InlineSuggestionsResponse response,
                @NonNull BooleanSupplier supplier) {
            final Bundle arguments = new Bundle();
            arguments.putParcelable(""response"", response);
            return recordEventInternal(""onInlineSuggestionsResponse"", supplier::getAsBoolean,
                    arguments);
        }

        void onInlineSuggestionClickedEvent(@NonNull Runnable runnable) {
            final Bundle arguments = new Bundle();
            recordEventInternal(""onInlineSuggestionClickedEvent"", runnable, arguments);
        }

        void onInlineSuggestionLongClickedEvent(@NonNull Runnable runnable) {
            final Bundle arguments = new Bundle();
            recordEventInternal(""onInlineSuggestionLongClickedEvent"", runnable, arguments);
        }
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.acceleration.cts.SoftwareAccelerationTest"	"testIsHardwareAccelerated"	"CtsAccelerationTestCases"	"/home/gpoor/cts-12-source/cts/tests/acceleration/src/android/acceleration/cts/SoftwareAccelerationTest.java"	""	"public void testIsHardwareAccelerated() {
        // Both of the views are not attached to a hardware accelerated window
        assertFalse(mHardwareView.isHardwareAccelerated());
        assertFalse(mSoftwareView.isHardwareAccelerated());
        assertFalse(mManualHardwareView.isHardwareAccelerated());
        assertFalse(mManualSoftwareView.isHardwareAccelerated());

        assertFalse(mHardwareView.isCanvasHardwareAccelerated());
        assertFalse(mSoftwareView.isCanvasHardwareAccelerated());
        assertFalse(mManualHardwareView.isCanvasHardwareAccelerated());
        assertFalse(mManualSoftwareView.isCanvasHardwareAccelerated());
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.packageaccessapp.PackageAccessTest"	"testPackageAccess_getPackagesCantSeeTiny"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/PackageAccessApp/src/com/android/cts/packageaccessapp/PackageAccessTest.java"	""	"public void testPackageAccess_getPackagesCantSeeTiny() throws Exception {
        PackageManager pm = InstrumentationRegistry.getContext().getPackageManager();
        List<PackageInfo> packages = pm.getInstalledPackages(
                PackageManager.MATCH_UNINSTALLED_PACKAGES);
        for (PackageInfo pi : packages) {
            if (TINY_PKG.equals(pi.packageName)) {
                fail(TINY_PKG + "" visible in user"");
            }
        }
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.packageaccessapp.PackageAccessTest"	"testPackageAccess_getPackagesCanSeeTiny"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/PackageAccessApp/src/com/android/cts/packageaccessapp/PackageAccessTest.java"	""	"public void testPackageAccess_getPackagesCanSeeTiny() throws Exception {
        PackageManager pm = InstrumentationRegistry.getContext().getPackageManager();
        List<PackageInfo> packages = pm.getInstalledPackages(
                PackageManager.MATCH_UNINSTALLED_PACKAGES);
        for (PackageInfo pi : packages) {
            if (TINY_PKG.equals(pi.packageName)) {
                return;
            }
        }
        fail(TINY_PKG + "" not found in getInstalledPackages()"");
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.hardware.camera2.cts.StillCaptureTest"	"testFullRawZSLCapture"	"CtsCameraTestCases"	"/home/gpoor/cts-12-source/cts/tests/camera/src/android/hardware/camera2/cts/StillCaptureTest.java"	""	"public void testFullRawZSLCapture() throws Exception {
        for (int i = 0; i < mCameraIdsUnderTest.length; i++) {
            try {
                Log.i(TAG, ""Testing raw+JPEG ZSL capture for Camera "" + mCameraIdsUnderTest[i]);
                if (!mAllStaticInfo.get(mCameraIdsUnderTest[i]).isCapabilitySupported(
                        CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_RAW)) {
                    Log.i(TAG, ""RAW capability is not supported in camera "" + mCameraIdsUnderTest[i] +
                            "". Skip the test."");
                    continue;
                }
                openDevice(mCameraIdsUnderTest[i]);
                CaptureRequest.Builder stillRequest =
                        mCamera.createCaptureRequest(CameraDevice.TEMPLATE_STILL_CAPTURE);
                stillRequest.set(CaptureRequest.CONTROL_ENABLE_ZSL, true);
                fullRawCaptureTestByCamera(stillRequest);
            } finally {
                closeDevice();
                closeImageReader();
            }
        }
    }

    /**
     * Test touch for focus.
     * <p>
     * AF is in CAF mode when preview is started, test uses several pre-selected
     * regions to simulate touches. Active scan is triggered to make sure the AF
     * converges in reasonable time.
     * </p>
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.provider.cts.ProviderTestUtils"	"exists"	"CtsProviderTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/provider/src/android/provider/cts/ProviderTestUtils.java"	""	"public void test/*
 *
 */

package android.provider.cts;

import static com.google.common.truth.Truth.assertWithMessage;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import android.app.AppOpsManager;
import android.app.UiAutomation;
import android.content.Context;
import android.content.pm.PackageManager;
import android.content.res.AssetFileDescriptor;
import android.database.Cursor;
import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Rect;
import android.net.Uri;
import android.os.Bundle;
import android.os.Environment;
import android.os.FileUtils;
import android.os.ParcelFileDescriptor;
import android.os.Process;
import android.os.UserManager;
import android.os.storage.StorageManager;
import android.os.storage.StorageVolume;
import android.provider.MediaStore;
import android.provider.MediaStore.MediaColumns;
import android.provider.cts.media.MediaStoreUtils;
import android.provider.cts.media.MediaStoreUtils.PendingParams;
import android.provider.cts.media.MediaStoreUtils.PendingSession;
import android.system.ErrnoException;
import android.system.Os;
import android.system.OsConstants;
import android.util.Log;

import androidx.test.InstrumentationRegistry;

import com.android.compatibility.common.util.Timeout;

import com.google.common.io.BaseEncoding;

import java.io.BufferedInputStream;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.security.DigestInputStream;
import java.security.MessageDigest;
import java.util.HashSet;
import java.util.Objects;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Utility methods for provider cts tests.
 */
public class ProviderTestUtils {
    static final String TAG = ""ProviderTestUtils"";

    private static final int BACKUP_TIMEOUT_MILLIS = 4000;
    private static final Pattern BMGR_ENABLED_PATTERN = Pattern.compile(
            ""^Backup Manager currently (enabled|disabled)$"");

    private static final Pattern PATTERN_STORAGE_PATH = Pattern.compile(
            ""(?i)^/storage/[^/]+/(?:[0-9]+/)?"");

    private static final Timeout IO_TIMEOUT = new Timeout(""IO_TIMEOUT"", 2_000, 2, 2_000);

    public static Iterable<String> getSharedVolumeNames() {
        // We test both new and legacy volume names
        final HashSet<String> testVolumes = new HashSet<>();
        final Set<String> volumeNames = MediaStore.getExternalVolumeNames(
                InstrumentationRegistry.getTargetContext());
        // Run tests only on VISIBLE volumes which are FUSE mounted and indexed by MediaProvider
        for (String vol : volumeNames) {
            final File mountedPath = getVolumePath(vol);
            if (mountedPath == null || mountedPath.getAbsolutePath() == null) continue;
            if (mountedPath.getAbsolutePath().startsWith(""/storage/"")) {
                testVolumes.add(vol);
            }
        }
        testVolumes.add(MediaStore.VOLUME_EXTERNAL);
        return testVolumes;
    }

    public static String resolveVolumeName(String volumeName) {
        if (MediaStore.VOLUME_EXTERNAL.equals(volumeName)) {
            return MediaStore.VOLUME_EXTERNAL_PRIMARY;
        } else {
            return volumeName;
        }
    }

    static void setDefaultSmsApp(boolean setToSmsApp, String packageName, UiAutomation uiAutomation)
            throws Exception {
        String mode = setToSmsApp ? ""allow"" : ""default"";
        String cmd = ""appops set %s %s %s"";
        executeShellCommand(String.format(cmd, packageName, ""WRITE_SMS"", mode), uiAutomation);
        executeShellCommand(String.format(cmd, packageName, ""READ_SMS"", mode), uiAutomation);
    }

    public static String executeShellCommand(String command) throws IOException {
        return executeShellCommand(command,
                InstrumentationRegistry.getInstrumentation().getUiAutomation());
    }

    public static String executeShellCommand(String command, UiAutomation uiAutomation)
            throws IOException {
        Log.v(TAG, ""$ "" + command);
        ParcelFileDescriptor pfd = uiAutomation.executeShellCommand(command.toString());
        BufferedReader br = null;
        try (InputStream in = new FileInputStream(pfd.getFileDescriptor());) {
            br = new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8));
            String str = null;
            StringBuilder out = new StringBuilder();
            while ((str = br.readLine()) != null) {
                Log.v(TAG, ""> "" + str);
                out.append(str);
            }
            return out.toString();
        } finally {
            if (br != null) {
                br.close();
            }
        }
    }

    static String setBackupTransport(String transport, UiAutomation uiAutomation) throws Exception {
        String output = executeShellCommand(""bmgr transport "" + transport, uiAutomation);
        Pattern pattern = Pattern.compile(""\\(formerly (.*)\\)$"");
        Matcher matcher = pattern.matcher(output);
        if (matcher.find()) {
            return matcher.group(1);
        } else {
            throw new Exception(""non-parsable output setting bmgr transport: "" + output);
        }
    }

    static boolean setBackupEnabled(boolean enable, UiAutomation uiAutomation) throws Exception {
        // Check to see the previous state of the backup service
        boolean previouslyEnabled = false;
        String output = executeShellCommand(""bmgr enabled"", uiAutomation);
        Matcher matcher = BMGR_ENABLED_PATTERN.matcher(output.trim());
        if (matcher.find()) {
            previouslyEnabled = ""enabled"".equals(matcher.group(1));
        } else {
            throw new RuntimeException(""Backup output format changed.  No longer matches""
                    + "" expected regex: "" + BMGR_ENABLED_PATTERN + ""\nactual: '"" + output + ""'"");
        }

        executeShellCommand(""bmgr enable "" + enable, uiAutomation);
        return previouslyEnabled;
    }

    static boolean hasBackupTransport(String transport, UiAutomation uiAutomation)
            throws Exception {
        String output = executeShellCommand(""bmgr list transports"", uiAutomation);
        for (String t : output.split("" "")) {
            if (""*"".equals(t)) {
                // skip the current selection marker.
                continue;
            } else if (Objects.equals(transport, t)) {
                return true;
            }
        }
        return false;
    }

    static void runBackup(String packageName, UiAutomation uiAutomation) throws Exception {
        executeShellCommand(""bmgr backupnow "" + packageName, uiAutomation);
        Thread.sleep(BACKUP_TIMEOUT_MILLIS);
    }

    static void runRestore(String packageName, UiAutomation uiAutomation) throws Exception {
        executeShellCommand(""bmgr restore 1 "" + packageName, uiAutomation);
        Thread.sleep(BACKUP_TIMEOUT_MILLIS);
    }

    static void wipeBackup(String backupTransport, String packageName, UiAutomation uiAutomation)
            throws Exception {
        executeShellCommand(""bmgr wipe "" + backupTransport + "" "" + packageName, uiAutomation);
    }

    public static void waitForIdle() {
        MediaStore.waitForIdle(InstrumentationRegistry.getTargetContext().getContentResolver());
    }

    /**
     * Waits until a file exists, or fails.
     *
     * @return existing file.
     */
    public static File waitUntilExists(File file) throws IOException {
        try {
            return IO_TIMEOUT.run(""file '"" + file + ""' doesn't exist yet"", () -> {
                return file.exists() ? file : null; // will retry if it returns null
            });
        } catch (Exception e) {
            throw new IOException(e);
        }
    }

    public static File getVolumePath(String volumeName) {
        final Context context = InstrumentationRegistry.getTargetContext();
        return context.getSystemService(StorageManager.class)
                .getStorageVolume(MediaStore.Files.getContentUri(volumeName)).getDirectory();
    }

    public static File stageDir(String volumeName) throws IOException {
        if (MediaStore.VOLUME_EXTERNAL.equals(volumeName)) {
            volumeName = MediaStore.VOLUME_EXTERNAL_PRIMARY;
        }
        final StorageVolume vol = InstrumentationRegistry.getTargetContext()
                .getSystemService(StorageManager.class)
                .getStorageVolume(MediaStore.Files.getContentUri(volumeName));
        File dir = Environment.buildPath(vol.getDirectory(), ""Android"", ""media"",
                ""android.provider.cts"");
        Log.d(TAG, ""stageDir("" + volumeName + ""): returning "" + dir);
        return dir;
    }

    public static File stageDownloadDir(String volumeName) throws IOException {
        if (MediaStore.VOLUME_EXTERNAL.equals(volumeName)) {
            volumeName = MediaStore.VOLUME_EXTERNAL_PRIMARY;
        }
        final StorageVolume vol = InstrumentationRegistry.getTargetContext()
                .getSystemService(StorageManager.class)
                .getStorageVolume(MediaStore.Files.getContentUri(volumeName));
        return Environment.buildPath(vol.getDirectory(),
                Environment.DIRECTORY_DOWNLOADS, ""android.provider.cts"");
    }

    public static File stageFile(int resId, File file) throws IOException {
        // The caller may be trying to stage into a location only available to
        // the shell user, so we need to perform the entire copy as the shell
        final Context context = InstrumentationRegistry.getTargetContext();
        UserManager userManager = context.getSystemService(UserManager.class);
        if (userManager.isSystemUser() &&
                    FileUtils.contains(Environment.getStorageDirectory(), file)) {
            executeShellCommand(""mkdir -p "" + file.getParent());
            waitUntilExists(file.getParentFile());
            try (AssetFileDescriptor afd = context.getResources().openRawResourceFd(resId)) {
                final File source = ParcelFileDescriptor.getFile(afd.getFileDescriptor());
                final long skip = afd.getStartOffset();
                final long count = afd.getLength();

                try {
                    // Try to create the file as calling package so that calling package remains
                    // as owner of the file.
                    file.createNewFile();
                } catch (IOException ignored) {
                    // Apps can't create files in other app's private directories, but shell can. If
                    // file creation fails, we ignore and let `dd` command create it instead.
                }

                executeShellCommand(String.format(""dd bs=1 if=%s skip=%d count=%d of=%s"",
                        source.getAbsolutePath(), skip, count, file.getAbsolutePath()));

                // Force sync to try updating other views
                executeShellCommand(""sync"");
            }
        } else {
            final File dir = file.getParentFile();
            dir.mkdirs();
            if (!dir.exists()) {
                throw new FileNotFoundException(""Failed to create parent for "" + file);
            }
            try (InputStream source = context.getResources().openRawResource(resId);
                    OutputStream target = new FileOutputStream(file)) {
                FileUtils.copy(source, target);
            }
        }
        return waitUntilExists(file);
    }

    public static Uri stageMedia(int resId, Uri collectionUri) throws IOException {
        return stageMedia(resId, collectionUri, ""image/png"");
    }

    public static Uri stageMedia(int resId, Uri collectionUri, String mimeType) throws IOException {
        final Context context = InstrumentationRegistry.getTargetContext();
        final String displayName = ""cts"" + System.nanoTime();
        final PendingParams params = new PendingParams(collectionUri, displayName, mimeType);
        final Uri pendingUri = MediaStoreUtils.createPending(context, params);
        try (PendingSession session = MediaStoreUtils.openPending(context, pendingUri)) {
            try (InputStream source = context.getResources().openRawResource(resId);
                    OutputStream target = session.openOutputStream()) {
                FileUtils.copy(source, target);
            }
            return session.publish();
        }
    }

    public static Uri scanFile(File file) throws Exception {
        final Uri uri = MediaStore
                .scanFile(InstrumentationRegistry.getTargetContext().getContentResolver(), file);
        assertWithMessage(""no URI for '%s'"", file).that(uri).isNotNull();
        return uri;
    }

    public static Uri scanFileFromShell(File file) throws Exception {
        return scanFile(file);
    }

    public static void scanVolume(File file) throws Exception {
        final StorageVolume vol = InstrumentationRegistry.getTargetContext()
                .getSystemService(StorageManager.class).getStorageVolume(file);
        MediaStore.scanVolume(InstrumentationRegistry.getTargetContext().getContentResolver(),
                vol.getMediaStoreVolumeName());
    }

    public static void setOwner(Uri uri, String packageName) throws Exception {
        executeShellCommand(""content update""
                + "" --user "" + InstrumentationRegistry.getTargetContext().getUserId()
                + "" --uri "" + uri
                + "" --bind owner_package_name:s:"" + packageName);
    }

    public static void clearOwner(Uri uri) throws Exception {
        executeShellCommand(""content update""
                + "" --user "" + InstrumentationRegistry.getTargetContext().getUserId()
                + "" --uri "" + uri
                + "" --bind owner_package_name:n:"");
    }

    public static byte[] hash(InputStream in) throws Exception {
        try (DigestInputStream digestIn = new DigestInputStream(in,
                MessageDigest.getInstance(""SHA-1""));
                OutputStream out = new FileOutputStream(new File(""/dev/null""))) {
            FileUtils.copy(digestIn, out);
            return digestIn.getMessageDigest().digest();
        }
    }

    /**
     * Extract the average overall color of the given bitmap.
     * <p>
     * Internally takes advantage of gaussian blurring that is naturally applied
     * when downscaling an image.
     */
    public static int extractAverageColor(Bitmap bitmap) {
        final Bitmap res = Bitmap.createBitmap(1, 1, Bitmap.Config.ARGB_8888);
        final Canvas canvas = new Canvas(res);
        final Rect src = new Rect(0, 0, bitmap.getWidth(), bitmap.getHeight());
        final Rect dst = new Rect(0, 0, 1, 1);
        canvas.drawBitmap(bitmap, src, dst, null);
        return res.getPixel(0, 0);
    }

    public static void assertColorMostlyEquals(int expected, int actual) {
        assertTrue(""Expected "" + Integer.toHexString(expected) + "" but was ""
                + Integer.toHexString(actual), isColorMostlyEquals(expected, actual));
    }

    public static void assertColorMostlyNotEquals(int expected, int actual) {
        assertFalse(""Expected "" + Integer.toHexString(expected) + "" but was ""
                + Integer.toHexString(actual), isColorMostlyEquals(expected, actual));
    }

    private static boolean isColorMostlyEquals(int expected, int actual) {
        final float[] expectedHSV = new float[3];
        final float[] actualHSV = new float[3];
        Color.colorToHSV(expected, expectedHSV);
        Color.colorToHSV(actual, actualHSV);

        // Fail if more than a 10% difference in any component
        if (Math.abs(expectedHSV[0] - actualHSV[0]) > 36) return false;
        if (Math.abs(expectedHSV[1] - actualHSV[1]) > 0.1f) return false;
        if (Math.abs(expectedHSV[2] - actualHSV[2]) > 0.1f) return false;
        return true;
    }

    public static void assertExists(String path) throws IOException {
        assertExists(null, path);
    }

    public static void assertExists(File file) throws IOException {
        assertExists(null, file.getAbsolutePath());
    }

    public static void assertExists(String msg, String path) throws IOException {
        if (!access(path)) {
            if (msg != null) {
                fail(path + "": "" + msg);
            } else {
                fail(""File "" + path + "" does not exist"");
            }
        }
    }

    public static void assertNotExists(String path) throws IOException {
        assertNotExists(null, path);
    }

    public static void assertNotExists(File file) throws IOException {
        assertNotExists(null, file.getAbsolutePath());
    }

    public static void assertNotExists(String msg, String path) throws IOException {
        if (access(path)) {
            fail(msg);
        }
    }

    private static boolean access(String path) throws IOException {
        // The caller may be trying to stage into a location only available to
        // the shell user, so we need to perform the entire copy as the shell
        if (FileUtils.contains(Environment.getStorageDirectory(), new File(path))) {
            return executeShellCommand(""ls -la "" + path).contains(path);
        } else {
            try {
                Os.access(path, OsConstants.F_OK);
                return true;
            } catch (ErrnoException e) {
                if (e.errno == OsConstants.ENOENT) {
                    return false;
                } else {
                    throw new IOException(e.getMessage());
                }
            }
        }
    }

    public static boolean containsId(Uri uri, long id) {
        return containsId(uri, null, id);
    }

    public static boolean containsId(Uri uri, Bundle extras, long id) {
        try (Cursor c = InstrumentationRegistry.getTargetContext().getContentResolver().query(uri,
                new String[] { MediaColumns._ID }, extras, null)) {
            while (c.moveToNext()) {
                if (c.getLong(0) == id) return true;
            }
        }
        return false;
    }

    /**
     * Gets File corresponding to the uri.
     * This function assumes that the caller has access to the uri
     * @param uri uri to get File for
     * @return File file corresponding to the uri
     * @throws FileNotFoundException if either the file does not exist or the caller does not have
     * read access to the file
     */
    public static File getRawFile(Uri uri) throws Exception {
        String filePath;
        try (Cursor c = InstrumentationRegistry.getTargetContext().getContentResolver().query(uri,
                new String[] { MediaColumns.DATA }, null, null)) {
            assertTrue(c.moveToFirst());
            filePath = c.getString(0);
        }
        if (filePath != null) {
            return new File(filePath);
        } else {
            throw new FileNotFoundException(""Failed to find _data for "" + uri);
        }
    }

    public static String getRawFileHash(File file) throws Exception {
        MessageDigest digest = MessageDigest.getInstance(""SHA-1"");
        try (InputStream in = new BufferedInputStream(Files.newInputStream(file.toPath()))) {
            byte[] buf = new byte[4096];
            int n;
            while ((n = in.read(buf)) >= 0) {
                digest.update(buf, 0, n);
            }
        }

        byte[] hash = digest.digest();
        return BaseEncoding.base16().encode(hash);
    }

    public static File getRelativeFile(Uri uri) throws Exception {
        final String path = getRawFile(uri).getAbsolutePath();
        final Matcher matcher = PATTERN_STORAGE_PATH.matcher(path);
        if (matcher.find()) {
            return new File(path.substring(matcher.end()));
        } else {
            throw new IllegalArgumentException();
        }
    }

    /** Revokes ACCESS_MEDIA_LOCATION from the test app */
    public static void revokeMediaLocationPermission(Context context) throws Exception {
        try {
            InstrumentationRegistry.getInstrumentation().getUiAutomation()
                    .adoptShellPermissionIdentity(""android.permission.MANAGE_APP_OPS_MODES"",
                            ""android.permission.REVOKE_RUNTIME_PERMISSIONS"");

            // Revoking ACCESS_MEDIA_LOCATION permission will kill the test app.
            // Deny access_media_permission App op to revoke this permission.
            PackageManager packageManager = context.getPackageManager();
            String packageName = context.getPackageName();
            if (packageManager.checkPermission(android.Manifest.permission.ACCESS_MEDIA_LOCATION,
                    packageName) == PackageManager.PERMISSION_GRANTED) {
                context.getPackageManager().updatePermissionFlags(
                        android.Manifest.permission.ACCESS_MEDIA_LOCATION, packageName,
                        PackageManager.FLAG_PERMISSION_REVOKED_COMPAT,
                        PackageManager.FLAG_PERMISSION_REVOKED_COMPAT, context.getUser());
                context.getSystemService(AppOpsManager.class).setUidMode(
                        ""android:access_media_location"", Process.myUid(),
                        AppOpsManager.MODE_IGNORED);
            }
        } finally {
            InstrumentationRegistry.getInstrumentation().getUiAutomation().
                    dropShellPermissionIdentity();
        }
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.MultiStaConcurrencyWifiNetworkSpecifierTest"	"isStaConcurrencyForLocalOnlyConnectionsSupported"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/MultiStaConcurrencyWifiNetworkSpecifierTest.java"	""	"/*
 *.
 */

package android.net.wifi.cts;

import static android.os.Process.myUid;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import static org.junit.Assume.assumeTrue;

import android.content.Context;
import android.content.pm.PackageManager;
import android.location.LocationManager;
import android.net.ConnectivityManager;
import android.net.NetworkRequest;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiManager;
import android.net.wifi.WifiNetworkSpecifier;
import android.os.Build;
import android.platform.test.annotations.AppModeFull;
import android.support.test.uiautomator.UiDevice;

import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.filters.LargeTest;
import androidx.test.filters.SdkSuppress;
import androidx.test.platform.app.InstrumentationRegistry;

import com.android.compatibility.common.util.PollingCheck;
import com.android.compatibility.common.util.ShellIdentityUtils;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.List;

/**
 * Tests multiple concurrent connection flow on devices that support multi STA concurrency
 * (indicated via {@link WifiManager#isStaConcurrencyForLocalOnlyConnectionsSupported()}.
 *
 * Tests the entire connection flow using {@link WifiNetworkSpecifier} embedded in a
 * {@link NetworkRequest} & passed into {@link ConnectivityManager#requestNetwork(NetworkRequest,
 * ConnectivityManager.NetworkCallback)} along with a concurrent internet connection using
 * {@link WifiManager#connect(int, WifiManager.ActionListener)}.
 *
 * Assumes that all the saved networks is either open/WPA1/WPA2/WPA3 authenticated network.
 *
 * TODO(b/177591382): Refactor some of the utilities to a separate file that are copied over from
 * WifiManagerTest & WifiNetworkSpecifierTest.
 */
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)
@AppModeFull(reason = ""Cannot get WifiManager in instant app mode"")
@LargeTest
@RunWith(AndroidJUnit4.class)
public class MultiStaConcurrencyWifiNetworkSpecifierTest extends WifiJUnit4TestBase {
    private static final String TAG = ""MultiStaConcurrencyWifiNetworkSpecifierTest"";
    private static boolean sWasVerboseLoggingEnabled;
    private static boolean sWasScanThrottleEnabled;
    private static boolean sWasWifiEnabled;

    private Context mContext;
    private WifiManager mWifiManager;
    private ConnectivityManager mConnectivityManager;
    private UiDevice mUiDevice;
    private WifiConfiguration mTestNetworkForPeerToPeer;
    private WifiConfiguration mTestNetworkForInternetConnection;
    private ConnectivityManager.NetworkCallback mNetworkCallback;
    private ConnectivityManager.NetworkCallback mNrNetworkCallback;
    private TestHelper mTestHelper;

    private static final int DURATION = 10_000;
    private static final int DURATION_UI_INTERACTION = 25_000;
    private static final int DURATION_NETWORK_CONNECTION = 60_000;
    private static final int DURATION_SCREEN_TOGGLE = 2000;
    private static final int SCAN_RETRY_CNT_TO_FIND_MATCHING_BSSID = 3;

    @BeforeClass
    public static void setUpClass() throws Exception {
        Context context = InstrumentationRegistry.getInstrumentation().getContext();
        // skip the test if WiFi is not supported. Don't use assumeTrue in @BeforeClass
        if (!WifiFeature.isWifiSupported(context)) return;

        WifiManager wifiManager = context.getSystemService(WifiManager.class);
        assertThat(wifiManager).isNotNull();

        // turn on verbose logging for tests
        sWasVerboseLoggingEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.isVerboseLoggingEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setVerboseLoggingEnabled(true));
        // Disable scan throttling for tests.
        sWasScanThrottleEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.isScanThrottleEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setScanThrottleEnabled(false));

        // enable Wifi
        sWasWifiEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.isWifiEnabled());
        if (!wifiManager.isWifiEnabled()) {
            ShellIdentityUtils.invokeWithShellPermissions(() -> wifiManager.setWifiEnabled(true));
        }
        PollingCheck.check(""Wifi not enabled"", DURATION, () -> wifiManager.isWifiEnabled());
    }

    @AfterClass
    public static void tearDownClass() throws Exception {
        Context context = InstrumentationRegistry.getInstrumentation().getContext();
        if (!WifiFeature.isWifiSupported(context)) return;

        WifiManager wifiManager = context.getSystemService(WifiManager.class);
        assertThat(wifiManager).isNotNull();

        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setScanThrottleEnabled(sWasScanThrottleEnabled));
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setVerboseLoggingEnabled(sWasVerboseLoggingEnabled));
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setWifiEnabled(sWasWifiEnabled));
    }

    @Before
    public void setUp() throws Exception {
        mContext = InstrumentationRegistry.getInstrumentation().getContext();
        mWifiManager = mContext.getSystemService(WifiManager.class);
        mConnectivityManager = mContext.getSystemService(ConnectivityManager.class);
        mUiDevice = UiDevice.getInstance(InstrumentationRegistry.getInstrumentation());
        mTestHelper = new TestHelper(mContext, mUiDevice);

        // skip the test if WiFi is not supported
        assumeTrue(WifiFeature.isWifiSupported(mContext));
        // skip the test if location is not supported
        assumeTrue(mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_LOCATION));
        // skip if multi STA not supported.
        assumeTrue(mWifiManager.isStaConcurrencyForLocalOnlyConnectionsSupported());

        assertWithMessage(""Please enable location for this test!"")
                .that(mContext.getSystemService(LocationManager.class).isLocationEnabled())
                .isTrue();

        // turn screen on
        mTestHelper.turnScreenOn();

        // Clear any existing app state before each test.
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.removeAppState(myUid(), mContext.getPackageName()));

        // We need 2 AP's for the test. If there are 2 networks saved on the device and in range,
        // use those. Otherwise, check if there are 2 BSSID's in range for the only saved network.
        // This assumes a CTS test environment with at least 2 connectable bssid's (Is that ok?).
        List<WifiConfiguration> savedNetworks = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.getPrivilegedConfiguredNetworks());
        List<WifiConfiguration> matchingNetworksWithBssid =
                TestHelper.findMatchingSavedNetworksWithBssid(mWifiManager, savedNetworks);
        assertWithMessage(""Need at least 2 saved network bssids in range"")
                .that(matchingNetworksWithBssid.size()).isAtLeast(2);
        // Pick any 2 bssid for test.
        mTestNetworkForPeerToPeer = matchingNetworksWithBssid.get(0);
        // Try to find a bssid for another saved network in range. If none exists, fallback
        // to using 2 bssid's for the same network.
        mTestNetworkForInternetConnection = matchingNetworksWithBssid.stream()
                .filter(w -> !w.SSID.equals(mTestNetworkForPeerToPeer.SSID))
                .findAny()
                .orElse(matchingNetworksWithBssid.get(1));

        // Disconnect & disable auto-join on the saved network to prevent auto-connect from
        // interfering with the test.
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> {
                    for (WifiConfiguration savedNetwork : savedNetworks) {
                        mWifiManager.disableNetwork(savedNetwork.networkId);
                    }
                    mWifiManager.disconnect();
                });

        // Wait for Wifi to be disconnected.
        PollingCheck.check(
                ""Wifi not disconnected"",
                20_000,
                () -> mWifiManager.getConnectionInfo().getNetworkId() == -1);
    }

    @After
    public void tearDown() throws Exception {
        // Re-enable networks.
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> {
                    for (WifiConfiguration savedNetwork : mWifiManager.getConfiguredNetworks()) {
                        mWifiManager.enableNetwork(savedNetwork.networkId, false);
                    }
                });
        // Release the requests after the test.
        if (mNetworkCallback != null) {
            mConnectivityManager.unregisterNetworkCallback(mNetworkCallback);
        }
        if (mNrNetworkCallback != null) {
            mConnectivityManager.unregisterNetworkCallback(mNrNetworkCallback);
        }
        // Clear any existing app state after each test.
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.removeAppState(myUid(), mContext.getPackageName()));
        mTestHelper.turnScreenOff();
    }

    private void testSuccessfulConnectionWithSpecifier(
            WifiConfiguration network, WifiNetworkSpecifier specifier) throws Exception {
        mNrNetworkCallback = mTestHelper.testConnectionFlowWithSpecifier(
                network, specifier, false);
    }

    private void testUserRejectionWithSpecifier(
            WifiConfiguration network, WifiNetworkSpecifier specifier) throws Exception {
        mNrNetworkCallback = mTestHelper.testConnectionFlowWithSpecifier(
                network, specifier, true);
    }

    /**
     * Tests the concurrent connection flow.
     * 1. Connect to a network using internet connectivity API.
     * 2. Connect to a network using peer to peer API.
     * 3. Verify that both connections are active.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.bluetooth.BleScannerHardwareScanFilterActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/bluetooth/BleScannerHardwareScanFilterActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.bluetooth;

import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.ViewGroup;
import android.widget.BaseAdapter;
import android.widget.Button;
import android.widget.ListView;
import android.widget.TextView;

import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;

public class BleScannerHardwareScanFilterActivity extends PassFailButtons.Activity {

    private static final String TAG = ""BleScannerHardwareScanFilter"";

    private ListView mScanResultListView;
    private MapAdapter mAdapter;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.ble_scanner_hardware_scan_filter);
        setPassFailButtonClickListeners();
        setInfoResources(R.string.ble_scanner_scan_filter_name,
                         R.string.ble_scanner_scan_filter_info, -1);

        mScanResultListView = (ListView)findViewById(R.id.ble_scan_result_list);
        mAdapter = new MapAdapter();
        mScanResultListView.setAdapter(mAdapter);

        ((Button) findViewById(R.id.ble_scan_with_filter))
                .setOnClickListener(new OnClickListener() {
                    @Override
                    public void onClick(View v) {
                        Intent intent = new Intent(BleScannerHardwareScanFilterActivity.this,
                                BleScannerService.class);
                        intent.putExtra(BleScannerService.EXTRA_COMMAND,
                                BleScannerService.COMMAND_SCAN_WITH_FILTER);
                        startService(intent);
                    }
                });

        ((Button) findViewById(R.id.ble_scan_without_filter))
                .setOnClickListener(new OnClickListener() {
                    @Override
                    public void onClick(View v) {
                        Intent intent = new Intent(BleScannerHardwareScanFilterActivity.this,
                                BleScannerService.class);
                        intent.putExtra(BleScannerService.EXTRA_COMMAND,
                                BleScannerService.COMMAND_SCAN_WITHOUT_FILTER);
                        startService(intent);
                    }
                });
    }

    @Override
    public void onResume() {
        super.onResume();

        IntentFilter filter = new IntentFilter();
        filter.addAction(BleScannerService.BLE_SCAN_RESULT);
        registerReceiver(onBroadcast, filter);
    }


    private BroadcastReceiver onBroadcast = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            switch (intent.getAction()) {
                case BleScannerService.BLE_SCAN_RESULT:
                    String uuid = intent.getStringExtra(BleScannerService.EXTRA_UUID);
                    String data = intent.getStringExtra(BleScannerService.EXTRA_DATA);
                    if (data != null) {
                        mAdapter.addItem(uuid + "" : "" + data);
                    }
                    break;
            }
        }
    };

    @Override
    public void onPause() {
        super.onPause();
        unregisterReceiver(onBroadcast);
    }

    private void stop() {
        stopService(new Intent(this, BleScannerService.class));
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        stop();
    }

    public class MapAdapter extends BaseAdapter {
        private Map<String, Integer> mData;
        private ArrayList<String> mKeys;
        public MapAdapter() {
            mData = new HashMap<>();
            mKeys = new ArrayList<>();
        }

        @Override
        public int getCount() {
            return mData.size();
        }

        @Override
        public Object getItem(int position) {
            return mData.get(mKeys.get(position));
        }

        @Override
        public long getItemId(int arg0) {
            return arg0;
        }

        public void addItem(String key) {
            if (!mData.containsKey(key)) {
                mKeys.add(key);
                mData.put(key, new Integer(1));
            } else {
                mData.put(key, mData.get(key) + 1);
            }
            this.notifyDataSetChanged();
        }

        @Override
        public View getView(int pos, View view, ViewGroup parent) {
            if (view == null) {
                view = LayoutInflater.from(parent.getContext())
                    .inflate(android.R.layout.simple_list_item_2, parent, false);
            }
            String key = mKeys.get(pos);
            String value = getItem(pos).toString();
            TextView text1 = (TextView) view.findViewById(android.R.id.text1);
            TextView text2 = (TextView) view.findViewById(android.R.id.text2);
            text1.setText(key);
            text2.setText(value);
            return view;
        }
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.bluetooth.cts.HearingAidProfileTest"	"test_getConnectionStateChangedIntent"	"CtsBluetoothTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/bluetooth/src/android/bluetooth/cts/HearingAidProfileTest.java"	""	"public void test_getConnectionStateChangedIntent() {
        if (!(mIsBleSupported && mIsHearingAidSupported)) {
            return;
        }

        waitForProfileConnect();
        assertTrue(mIsProfileReady);
        assertNotNull(mService);

        // Find out how many Hearing Aid bonded devices
        List<BluetoothDevice> bondedDeviceList = new ArrayList();
        int numDevices = 0;
        for (int connectionState : mValidConnectionStates) {
            List<BluetoothDevice> deviceList;

            deviceList = mService.getDevicesMatchingConnectionStates(new int[]{connectionState});
            bondedDeviceList.addAll(deviceList);
            numDevices += deviceList.size();
        }

        if (numDevices <= 0) return;
        Log.d(TAG, ""Number Hearing Aids devices bonded="" + numDevices);

        mIntentCallbackDeviceList = new ArrayList();

        // Set up the Connection State Changed receiver
        IntentFilter filter = new IntentFilter();
        filter.addAction(BluetoothHearingAid.ACTION_CONNECTION_STATE_CHANGED);
        mIntentReceiver = new HearingAidIntentReceiver();
        mContext.registerReceiver(mIntentReceiver, filter);

        Log.d(TAG, ""test_getConnectionStateChangedIntent: disable adapter and wait"");
        assertTrue(BTAdapterUtils.disableAdapter(mBluetoothAdapter, mContext));

        Log.d(TAG, ""test_getConnectionStateChangedIntent: enable adapter and wait"");
        assertTrue(BTAdapterUtils.enableAdapter(mBluetoothAdapter, mContext));

        int sanityCount = WAIT_FOR_INTENT_TIMEOUT_MS;
        while ((numDevices != mIntentCallbackDeviceList.size()) && (sanityCount > 0)) {
            final int SLEEP_QUANTUM_MS = 100;
            sleep(SLEEP_QUANTUM_MS);
            sanityCount -= SLEEP_QUANTUM_MS;
        }

        // Tear down
        mContext.unregisterReceiver(mIntentReceiver);

        Log.d(TAG, ""test_getConnectionStateChangedIntent: number of bonded device=""
              + numDevices + "", mIntentCallbackDeviceList.size()=""
              + mIntentCallbackDeviceList.size());
        for (BluetoothDevice device : mIntentCallbackDeviceList) {
            assertTrue(bondedDeviceList.contains(device));
        }
    }

    private boolean waitForProfileConnect() {
        mProfileConnectedlock.lock();
        try {
            // Wait for the Adapter to be disabled
            while (!mIsProfileReady) {
                if (!mConditionProfileIsConnected.await(
                    PROXY_CONNECTION_TIMEOUT_MS, TimeUnit.MILLISECONDS)) {
                    // Timeout
                    Log.e(TAG, ""Timeout while waiting for Profile Connect"");
                    break;
                } // else spurious wakeups
            }
        } catch(InterruptedException e) {
            Log.e(TAG, ""waitForProfileConnect: interrrupted"");
        } finally {
            mProfileConnectedlock.unlock();
        }
        return mIsProfileReady;
    }

    private final class HearingAidsServiceListener
            implements BluetoothProfile.ServiceListener {

        public void onServiceConnected(int profile, BluetoothProfile proxy) {
            mProfileConnectedlock.lock();
            mService = (BluetoothHearingAid) proxy;
            mIsProfileReady = true;
            try {
                mConditionProfileIsConnected.signal();
            } finally {
                mProfileConnectedlock.unlock();
            }
        }

        public void onServiceDisconnected(int profile) {
            mProfileConnectedlock.lock();
            mIsProfileReady = false;
            mService = null;
            mProfileConnectedlock.unlock();
        }
    }

    private class HearingAidIntentReceiver extends BroadcastReceiver {
        @Override
        public void onReceive(Context context, Intent intent) {
            if (BluetoothHearingAid.ACTION_CONNECTION_STATE_CHANGED.equals(intent.getAction())) {
                int state = intent.getIntExtra(BluetoothProfile.EXTRA_STATE, -1);
                int previousState = intent.getIntExtra(BluetoothProfile.EXTRA_PREVIOUS_STATE, -1);
                BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);

                Log.d(TAG,""HearingAidIntentReceiver.onReceive: device="" + device
                      + "", state="" + state + "", previousState="" + previousState);

                checkValidConnectionState(state);
                checkValidConnectionState(previousState);

                mIntentCallbackDeviceList.add(device);
            }
        }
    }

    private void checkDeviceListAndStates(List<BluetoothDevice> deviceList, int connectionState) {
        Log.d(TAG, ""checkDeviceListAndStates(): size="" + deviceList.size()
              + "", connectionState="" + connectionState);
        for (BluetoothDevice device : deviceList) {
            int deviceConnectionState = mService.getConnectionState(device);
            assertEquals(""Mismatched connection state for "" + device,
                         connectionState, deviceConnectionState);
        }
    }

    private void checkValidConnectionState(int connectionState) {
        assertTrue(mValidConnectionStates.contains(connectionState));
    }

    // Returns whether offloaded scan batching is supported.
    private boolean isBleBatchScanSupported() {
        return mBluetoothAdapter.isOffloadedScanBatchingSupported();
    }

    // Check if Bluetooth LE feature is supported on DUT.
    private boolean isBleSupported() {
        return getContext().getPackageManager()
                .hasSystemFeature(PackageManager.FEATURE_BLUETOOTH_LE);
    }

    private static void sleep(long t) {
        try {
            Thread.sleep(t);
        } catch (InterruptedException e) {}
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.accessibilityservice.cts.AccessibilityGestureDispatchTest"	"testContinuedGesture_withLineDisconnect_isCancelled"	"CtsAccessibilityServiceTestCases"	"/home/gpoor/cts-12-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilityGestureDispatchTest.java"	""	"public void testContinuedGesture_withLineDisconnect_isCancelled() throws Exception {
        if (!mHasTouchScreen) {
            return;
        }

        PointF startPoint = new PointF(mStartPoint.x, mStartPoint.y);
        PointF midPoint = new PointF(mStartPoint.x + 10, mStartPoint.y);
        PointF endPoint = new PointF(mStartPoint.x + 10, mStartPoint.y + 10);
        int gestureTime = 500;

        StrokeDescription stroke1 =
                new StrokeDescription(lineWithinView(startPoint, midPoint), 0, gestureTime, true);
        dispatch(new GestureDescription.Builder().addStroke(stroke1).build(),
                gestureTime + GESTURE_COMPLETION_TIMEOUT);
        waitForMotionEvents(both(IS_ACTION_MOVE).and(isAtPoint(midPoint)), 1);

        StrokeDescription stroke2 =
                stroke1.continueStroke(lineWithinView(endPoint, midPoint), 0, gestureTime, false);
        mMotionEvents.clear();
        awaitCancellation(
                dispatchGesture(mService,
                        new GestureDescription.Builder().addStroke(stroke2).build()),
                gestureTime + GESTURE_COMPLETION_TIMEOUT, MILLISECONDS);

        waitForMotionEvents(IS_ACTION_CANCEL, 1);
        assertEquals(1, mMotionEvents.size());
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.accessibilityservice.cts.AccessibilityGestureDispatchTest"	"testContinuedGesture_nextGestureDoesntContinue_isCancelled"	"CtsAccessibilityServiceTestCases"	"/home/gpoor/cts-12-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilityGestureDispatchTest.java"	""	"public void testContinuedGesture_nextGestureDoesntContinue_isCancelled() throws Exception {
        if (!mHasTouchScreen) {
            return;
        }

        PointF startPoint = new PointF(mStartPoint.x, mStartPoint.y);
        PointF midPoint = new PointF(mStartPoint.x + 10, mStartPoint.y);
        PointF endPoint = new PointF(mStartPoint.x + 10, mStartPoint.y + 10);
        int gestureTime = 500;

        StrokeDescription stroke1 =
                new StrokeDescription(lineWithinView(startPoint, midPoint), 0, gestureTime, true);
        dispatch(new GestureDescription.Builder().addStroke(stroke1).build(),
                gestureTime + GESTURE_COMPLETION_TIMEOUT);

        StrokeDescription stroke2 =
                new StrokeDescription(lineWithinView(midPoint, endPoint), 0, gestureTime, false);
        dispatch(new GestureDescription.Builder().addStroke(stroke2).build(),
                gestureTime + GESTURE_COMPLETION_TIMEOUT);

        waitForMotionEvents(IS_ACTION_UP, 1);

        List<MotionEvent> cancelEvent = getEventsMatching(IS_ACTION_CANCEL);
        assertEquals(1, cancelEvent.size());
        // Confirm that a down follows the cancel
        assertThat(mMotionEvents.get(mMotionEvents.indexOf(cancelEvent.get(0)) + 1),
                both(IS_ACTION_DOWN).and(isAtPoint(midPoint)));
        // Confirm that the last point is an up
        assertThat(mMotionEvents.get(mMotionEvents.size() - 1),
                both(IS_ACTION_UP).and(isAtPoint(endPoint)));
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.accessibilityservice.cts.AccessibilityGestureDispatchTest"	"testContinuingGesture_withNothingToContinue_isCancelled"	"CtsAccessibilityServiceTestCases"	"/home/gpoor/cts-12-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilityGestureDispatchTest.java"	""	"public void testContinuingGesture_withNothingToContinue_isCancelled() {
        if (!mHasTouchScreen) {
            return;
        }

        PointF startPoint = new PointF(mStartPoint.x, mStartPoint.y);
        PointF midPoint = new PointF(mStartPoint.x + 10, mStartPoint.y);
        PointF endPoint = new PointF(mStartPoint.x + 10, mStartPoint.y + 10);
        int gestureTime = 500;

        StrokeDescription stroke1 =
                new StrokeDescription(lineWithinView(startPoint, midPoint), 0, gestureTime, true);

        StrokeDescription stroke2 =
                stroke1.continueStroke(lineWithinView(midPoint, endPoint), 0, gestureTime, false);
        awaitCancellation(
                dispatchGesture(mService,
                        new GestureDescription.Builder().addStroke(stroke2).build()),
                gestureTime + GESTURE_COMPLETION_TIMEOUT, MILLISECONDS);
    }

    public static class GestureDispatchActivity extends AccessibilityTestActivity {
        public GestureDispatchActivity() {
            super();
        }

        @Override
        public void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            setContentView(R.layout.full_screen_frame_layout);
        }
    }

    private void waitForMotionEvents(Matcher<MotionEvent> matcher, int numEventsExpected)
            throws InterruptedException {
        synchronized (mMotionEvents) {
            long endMillis = SystemClock.uptimeMillis() + MOTION_EVENT_TIMEOUT;
            boolean gotEvents = getEventsMatching(matcher).size() >= numEventsExpected;
            while (!gotEvents && (SystemClock.uptimeMillis() < endMillis)) {
                mMotionEvents.wait(endMillis - SystemClock.uptimeMillis());
                gotEvents = getEventsMatching(matcher).size() >= numEventsExpected;
            }
            assertTrue(""Did not receive required events. Got:\n"" + mMotionEvents + ""\n filtered:\n""
                    + getEventsMatching(matcher), gotEvents);
        }
    }

    private List<MotionEvent> getEventsMatching(Matcher<MotionEvent> matcher) {
        List<MotionEvent> events = new ArrayList<>();
        synchronized (mMotionEvents) {
            for (MotionEvent event : mMotionEvents) {
                if (matcher.matches(event)) {
                    events.add(event);
                }
            }
        }
        return events;
    }

    private float distance(MotionEvent.PointerCoords point1, MotionEvent.PointerCoords point2) {
        return (float) Math.hypot((double) (point1.x - point2.x), (double) (point1.y - point2.y));
    }

    private class MyTouchListener implements View.OnTouchListener {
        @Override
        public boolean onTouch(View view, MotionEvent motionEvent) {
            synchronized (mMotionEvents) {
                if (motionEvent.getActionMasked() == MotionEvent.ACTION_UP) {
                    mGotUpEvent = true;
                }
                mMotionEvents.add(MotionEvent.obtain(motionEvent));
                mMotionEvents.notifyAll();
                return true;
            }
        }
    }

    private GestureDescription clickWithinView(PointF clickPoint) {
        return new GestureDescription.Builder()
                .addStroke(click(withinView(clickPoint)))
                .build();
    }

    private GestureDescription longClickWithinView(PointF clickPoint) {
        return new GestureDescription.Builder()
                .addStroke(longClick(withinView(clickPoint)))
                .build();
    }

    private PointF withinView(PointF clickPoint) {
        return add(clickPoint, mViewLocation[0], mViewLocation[1]);
    }

    private GestureDescription swipeWithinView(PointF start, PointF end, long duration) {
        return new GestureDescription.Builder()
                .addStroke(new StrokeDescription(lineWithinView(start, end), 0, duration))
                .build();
    }

    private Path lineWithinView(PointF startPoint, PointF endPoint) {
        return path(withinView(startPoint), withinView(endPoint));
    }

    private GestureDescription pinchWithinView(PointF centerPoint, int startSpacing,
            int endSpacing, float orientation, long duration) {
        if ((startSpacing < 0) || (endSpacing < 0)) {
            throw new IllegalArgumentException(""Pinch spacing cannot be negative"");
        }
        PointF offsetCenter = withinView(centerPoint);
        float[] startPoint1 = new float[2];
        float[] endPoint1 = new float[2];
        float[] startPoint2 = new float[2];
        float[] endPoint2 = new float[2];

        /* Build points for a horizontal gesture centered at the origin */
        startPoint1[0] = startSpacing / 2;
        startPoint1[1] = 0;
        endPoint1[0] = endSpacing / 2;
        endPoint1[1] = 0;
        startPoint2[0] = -startSpacing / 2;
        startPoint2[1] = 0;
        endPoint2[0] = -endSpacing / 2;
        endPoint2[1] = 0;

        /* Rotate and translate the points */
        Matrix matrix = new Matrix();
        matrix.setRotate(orientation);
        matrix.postTranslate(offsetCenter.x, offsetCenter.y);
        matrix.mapPoints(startPoint1);
        matrix.mapPoints(endPoint1);
        matrix.mapPoints(startPoint2);
        matrix.mapPoints(endPoint2);

        Path path1 = new Path();
        path1.moveTo(startPoint1[0], startPoint1[1]);
        path1.lineTo(endPoint1[0], endPoint1[1]);
        Path path2 = new Path();
        path2.moveTo(startPoint2[0], startPoint2[1]);
        path2.lineTo(endPoint2[0], endPoint2[1]);

        return new GestureDescription.Builder()
                .addStroke(new StrokeDescription(path1, 0, duration))
                .addStroke(new StrokeDescription(path2, 0, duration))
                .build();
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.audio.USBAudioPeripheralNotificationsTest"	"ConnectListener"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/audio/USBAudioPeripheralNotificationsTest.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.audio;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;

import android.media.AudioDeviceCallback;
import android.media.AudioDeviceInfo;
import android.media.AudioManager;

import android.os.Bundle;
import android.os.Handler;

import android.util.Log;

import android.widget.TextView;

import com.android.compatibility.common.util.CddTest;
import com.android.compatibility.common.util.ReportLog;
import com.android.compatibility.common.util.ResultType;
import com.android.compatibility.common.util.ResultUnit;

import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;  // needed to access resource in CTSVerifier project namespace.

@CddTest(requirement=""7.8.2.2/H-2-1,H-3-1,H-4-2,H-4-3,H-4-4,H-4-5"")
public class USBAudioPeripheralNotificationsTest extends PassFailButtons.Activity {
    private static final String
            TAG = USBAudioPeripheralNotificationsTest.class.getSimpleName();

    private AudioManager    mAudioManager;

    private TextView mHeadsetInName;
    private TextView mHeadsetOutName;
    private TextView mUsbDeviceInName;
    private TextView mUsbDeviceOutName;

    // private TextView mHeadsetPlugText;
    private TextView mHeadsetPlugMessage;

    // Intents
    private HeadsetPlugReceiver mHeadsetPlugReceiver;
    private boolean mPlugIntentReceived;

    // Device
    private AudioDeviceInfo mUsbHeadsetInInfo;
    private AudioDeviceInfo mUsbHeadsetOutInfo;
    private AudioDeviceInfo mUsbDeviceInInfo;
    private AudioDeviceInfo mUsbDeviceOutInfo;

    private boolean mUsbHeadsetInReceived;
    private boolean mUsbHeadsetOutReceived;
    private boolean mUsbDeviceInReceived;
    private boolean mUsbDeviceOutReceived;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.uap_notifications_layout);

        mHeadsetInName = (TextView)findViewById(R.id.uap_messages_headset_in_name);
        mHeadsetOutName = (TextView)findViewById(R.id.uap_messages_headset_out_name);

        mUsbDeviceInName = (TextView)findViewById(R.id.uap_messages_usb_device_in_name);
        mUsbDeviceOutName = (TextView)findViewById(R.id.uap_messages_usb_device__out_name);

        mHeadsetPlugMessage = (TextView)findViewById(R.id.uap_messages_plug_message);

        mAudioManager = (AudioManager)getSystemService(AUDIO_SERVICE);
        mAudioManager.registerAudioDeviceCallback(new ConnectListener(), new Handler());

        mHeadsetPlugReceiver = new HeadsetPlugReceiver();
        IntentFilter filter = new IntentFilter();
        filter.addAction(Intent.ACTION_HEADSET_PLUG);
        registerReceiver(mHeadsetPlugReceiver, filter);

        setInfoResources(R.string.audio_uap_notifications_test, R.string.uapNotificationsTestInfo,
                -1);

        setPassFailButtonClickListeners();
        getPassButton().setEnabled(false);
    }

    //
    // UI
    //
    private void showConnectedDevices() {
        if (mUsbHeadsetInInfo != null) {
            mHeadsetInName.setText(
                    ""Headset INPUT Connected "" + mUsbHeadsetInInfo.getProductName());
        } else {
            mHeadsetInName.setText("""");
        }

        if (mUsbHeadsetOutInfo != null) {
            mHeadsetOutName.setText(
                    ""Headset OUTPUT Connected "" + mUsbHeadsetOutInfo.getProductName());
        } else {
            mHeadsetOutName.setText("""");
        }

        if (mUsbDeviceInInfo != null) {
            mUsbDeviceInName.setText(
                    ""USB DEVICE INPUT Connected "" + mUsbDeviceInInfo.getProductName());
        } else {
            mUsbDeviceInName.setText("""");
        }

        if (mUsbDeviceOutInfo != null) {
            mUsbDeviceOutName.setText(
                    ""USB DEVICE OUTPUT Connected "" + mUsbDeviceOutInfo.getProductName());
        } else {
            mUsbDeviceOutName.setText("""");
        }
    }

    private void reportPlugIntent(Intent intent) {
        // [ 7.8 .2.2/H-2-1] MUST broadcast Intent ACTION_HEADSET_PLUG with ""microphone"" extra
        // set to 0 when the USB audio terminal types 0x0302 is detected.
        // [ 7.8 .2.2/H-3-1] MUST broadcast Intent ACTION_HEADSET_PLUG with ""microphone"" extra
        // set to 1 when the USB audio terminal types 0x0402 is detected, they:
        mPlugIntentReceived = true;

        // state - 0 for unplugged, 1 for plugged.
        // name - Headset type, human readable string
        // microphone - 1 if headset has a microphone, 0 otherwise
        int state = intent.getIntExtra(""state"", -1);
        if (state != -1) {

            StringBuilder sb = new StringBuilder();
            sb.append(""ACTION_HEADSET_PLUG received - "" + (state == 0 ? ""Unplugged"" : ""Plugged""));

            String name = intent.getStringExtra(""name"");
            if (name != null) {
                sb.append("" - "" + name);
            }

            int hasMic = intent.getIntExtra(""microphone"", 0);
            if (hasMic == 1) {
                sb.append("" [mic]"");
            }

            mHeadsetPlugMessage.setText(sb.toString());
        }

        getReportLog().addValue(
                ""ACTION_HEADSET_PLUG Intent Received. State: "",
                state,
                ResultType.NEUTRAL,
                ResultUnit.NONE);

        getPassButton().setEnabled(calculatePass());
    }

    //
    // Test Status
    //
    private boolean calculatePass() {
        return mUsbHeadsetInReceived && mUsbHeadsetOutReceived &&
                mUsbDeviceInReceived && mUsbDeviceOutReceived &&
                mPlugIntentReceived;
    }

    //
    // Devices
    //
    private void scanDevices(AudioDeviceInfo[] devices) {
        mUsbHeadsetInInfo = mUsbHeadsetOutInfo =
                mUsbDeviceInInfo = mUsbDeviceOutInfo = null;

        for (AudioDeviceInfo devInfo : devices) {
            if (devInfo.getType() == AudioDeviceInfo.TYPE_USB_HEADSET) {
                if (devInfo.isSource()) {
                    // [ 7.8 .2.2/H-4-3] MUST list a device of type AudioDeviceInfo.TYPE_USB_HEADSET
                    // and role isSource() if the USB audio terminal type field is 0x0402.
                    mUsbHeadsetInReceived = true;
                    mUsbHeadsetInInfo = devInfo;
                    getReportLog().addValue(
                            ""USB Headset connected - INPUT"",
                            0,
                            ResultType.NEUTRAL,
                            ResultUnit.NONE);
                } else if (devInfo.isSink()) {
                    // [ 7.8 .2.2/H-4-2] MUST list a device of type AudioDeviceInfo.TYPE_USB_HEADSET
                    // and role isSink() if the USB audio terminal type field is 0x0402.
                    mUsbHeadsetOutReceived = true;
                    mUsbHeadsetOutInfo = devInfo;
                    getReportLog().addValue(
                            ""USB Headset connected - OUTPUT"",
                            0,
                            ResultType.NEUTRAL,
                            ResultUnit.NONE);
                }
            } else if (devInfo.getType() == AudioDeviceInfo.TYPE_USB_DEVICE) {
                if (devInfo.isSource()) {
                    // [ 7.8 .2.2/H-4-5] MUST list a device of type AudioDeviceInfo.TYPE_USB_DEVICE
                    // and role isSource() if the USB audio terminal type field is 0x604.
                    mUsbDeviceInReceived = true;
                    mUsbDeviceInInfo = devInfo;
                    getReportLog().addValue(
                            ""USB Device connected - INPUT"",
                            0,
                            ResultType.NEUTRAL,
                            ResultUnit.NONE);
                } else if (devInfo.isSink()) {
                    // [ 7.8 .2.2/H-4-4] MUST list a device of type AudioDeviceInfo.TYPE_USB_DEVICE
                    // and role isSink() if the USB audio terminal type field is 0x603.
                    mUsbDeviceOutReceived = true;
                    mUsbDeviceOutInfo = devInfo;
                    getReportLog().addValue(
                            ""USB Headset connected - OUTPUT"",
                            0,
                            ResultType.NEUTRAL,
                            ResultUnit.NONE);
                }
            }

            if (mUsbHeadsetInInfo != null &&
                    mUsbHeadsetOutInfo != null &&
                    mUsbDeviceInInfo != null &&
                    mUsbDeviceOutInfo != null) {
                break;
            }
        }


        showConnectedDevices();
        getPassButton().setEnabled(calculatePass());
    }

    private class ConnectListener extends AudioDeviceCallback {
        /*package*/ ConnectListener() {}

        //
        // AudioDevicesManager.OnDeviceConnectionListener
        //
        @Override
        public void onAudioDevicesAdded(AudioDeviceInfo[] addedDevices) {
            Log.i(TAG, ""onAudioDevicesAdded() num:"" + addedDevices.length);

            scanDevices(mAudioManager.getDevices(AudioManager.GET_DEVICES_ALL));
        }

        @Override
        public void onAudioDevicesRemoved(AudioDeviceInfo[] removedDevices) {
            Log.i(TAG, ""onAudioDevicesRemoved() num:"" + removedDevices.length);

            scanDevices(mAudioManager.getDevices(AudioManager.GET_DEVICES_ALL));
        }
    }

    // Intents
    private class HeadsetPlugReceiver extends BroadcastReceiver {
        @Override
        public void onReceive(Context context, Intent intent) {
            reportPlugIntent(intent);
        }
    }

}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.print.cts.PrintJobTest"	"createFirstMockPrinterDiscoverySessionCallbacks"	"CtsPrintTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/print/src/android/print/cts/PrintJobTest.java"	""	"/*
 *.
 */

package android.print.cts;

import static android.print.test.Utils.eventually;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;

import android.platform.test.annotations.AppModeFull;
import android.print.PrintAttributes;
import android.print.PrintAttributes.Margins;
import android.print.PrintAttributes.MediaSize;
import android.print.PrintAttributes.Resolution;
import android.print.PrintDocumentAdapter;
import android.print.PrintJobInfo;
import android.print.PrintManager;
import android.print.PrinterCapabilitiesInfo;
import android.print.PrinterId;
import android.print.PrinterInfo;
import android.print.test.BasePrintTest;
import android.print.test.services.CustomPrintOptionsActivity;
import android.print.test.services.FirstPrintService;
import android.print.test.services.PrintServiceCallbacks;
import android.print.test.services.PrinterDiscoverySessionCallbacks;
import android.print.test.services.SecondPrintService;
import android.print.test.services.StubbablePrinterDiscoverySession;
import android.printservice.PrintJob;

import androidx.test.runner.AndroidJUnit4;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.ArrayList;

/**
 * Tests all possible states of print jobs.
 */
@RunWith(AndroidJUnit4.class)
public class PrintJobTest extends BasePrintTest {
    private static final String PRINTER_NAME = ""TestPrinter"";

    private final static String VALID_NULL_KEY = ""validNullKey"";
    private final static String VALID_STRING_KEY = ""validStringKey"";
    private final static String STRING_VALUE = ""string value"";
    private final static String INVALID_STRING_KEY = ""invalidStringKey"";
    private final static String VALID_INT_KEY = ""validIntKey"";
    private final static int INT_VALUE = 23;
    private final static String INVALID_INT_KEY = ""invalidIntKey"";

    private final boolean testSuccess[] = new boolean[1];

    /** The printer discovery session used in this test */
    private static StubbablePrinterDiscoverySession sDiscoverySession;
    private static boolean sHasBeenSetUp;

    /**
     * Create a mock {@link PrinterDiscoverySessionCallbacks} that discovers a simple test printer.
     *
     * @return The mock session callbacks
     */
    private PrinterDiscoverySessionCallbacks createFirstMockPrinterDiscoverySessionCallbacks() {
        return createMockPrinterDiscoverySessionCallbacks(invocation -> {
            // Get the session.
            sDiscoverySession = ((PrinterDiscoverySessionCallbacks) invocation.getMock())
                    .getSession();

            if (sDiscoverySession.getPrinters().isEmpty()) {
                PrinterId printerId =
                        sDiscoverySession.getService().generatePrinterId(PRINTER_NAME);
                PrinterInfo.Builder printer = new PrinterInfo.Builder(
                        sDiscoverySession.getService().generatePrinterId(PRINTER_NAME),
                        PRINTER_NAME, PrinterInfo.STATUS_IDLE);

                printer.setCapabilities(new PrinterCapabilitiesInfo.Builder(printerId)
                        .addMediaSize(MediaSize.ISO_A4, true)
                        .addResolution(new Resolution(""300x300"", ""300dpi"", 300, 300), true)
                        .setColorModes(PrintAttributes.COLOR_MODE_COLOR,
                                PrintAttributes.COLOR_MODE_COLOR)
                        .setMinMargins(new Margins(0, 0, 0, 0)).build());

                ArrayList<PrinterInfo> printers = new ArrayList<>(1);
                printers.add(printer.build());

                sDiscoverySession.addPrinters(printers);
            }
            return null;
        }, null, null, invocation -> null, null, null, invocation -> {
            // Take a note onDestroy was called.
            onPrinterDiscoverySessionDestroyCalled();
            return null;
        });
    }

    private interface PrintJobTestFn {
        void onPrintJobQueued(PrintJob printJob) throws Throwable;
    }

    /**
     * Create mock service callback for a session. Once the job is queued the test function is
     * called.
     *
     * @param sessionCallbacks The callbacks of the session
     * @param printJobTest test function to call
     */
    private PrintServiceCallbacks createFirstMockPrinterServiceCallbacks(
            final PrinterDiscoverySessionCallbacks sessionCallbacks,
            final PrintJobTestFn printJobTest) {
        return createMockPrintServiceCallbacks(
                invocation -> sessionCallbacks, invocation -> {
                    PrintJob printJob = (PrintJob) invocation.getArguments()[0];

                    try {
                        printJobTest.onPrintJobQueued(printJob);
                        testSuccess[0] = true;
                    } catch (Throwable t) {
                        throw new RuntimeException(t);
                    }

                    onPrintJobQueuedCalled();

                    return null;
                }, null);
    }

    /**
     * Base test for the print job tests. Starts a print job and executes a testFn once the job is
     * queued.
     *
     * @throws Exception If anything is unexpected.
     */
    private void baseTest(PrintJobTestFn testFn) throws Throwable {
        testSuccess[0] = false;

        // Create the session of the printers that we will be checking.
        PrinterDiscoverySessionCallbacks sessionCallbacks
                = createFirstMockPrinterDiscoverySessionCallbacks();

        // Create the service callbacks for the first print service.
        PrintServiceCallbacks serviceCallbacks = createFirstMockPrinterServiceCallbacks(
                sessionCallbacks, testFn);

        // Configure the print services.
        FirstPrintService.setCallbacks(serviceCallbacks);

        // We don't use the second service, but we have to still configure it
        SecondPrintService.setCallbacks(createMockPrintServiceCallbacks(null, null, null));

        // Create a print adapter that respects the print contract.
        PrintDocumentAdapter adapter = createDefaultPrintDocumentAdapter(1);


        // Start printing.
        print(adapter);
        waitForWriteAdapterCallback(1);

        eventually(
                () -> {
                    mPrintHelper.submitPrintJob();

                    // Wait for print job to be queued
                    waitForServiceOnPrintJobQueuedCallbackCalled(1);
                },
                OPERATION_TIMEOUT_MILLIS * 2);

        // Wait for discovery session to be destroyed to isolate tests from each other
        waitForPrinterDiscoverySessionDestroyCallbackCalled(1);

        if (!testSuccess[0]) {
            throw new Exception(""Did not succeed"");
        }
    }

    private static void checkState(PrintJob job, int state) throws Throwable {
        eventually(() -> assertEquals(state, job.getInfo().getState()));
        switch (state) {
            case PrintJobInfo.STATE_QUEUED:
                eventually(() -> assertTrue(job.isQueued()));
                break;
            case PrintJobInfo.STATE_STARTED:
                eventually(() -> assertTrue(job.isStarted()));
                break;
            case PrintJobInfo.STATE_BLOCKED:
                eventually(() -> assertTrue(job.isBlocked()));
                break;
            case PrintJobInfo.STATE_COMPLETED:
                eventually(() -> assertTrue(job.isCompleted()));
                break;
            case PrintJobInfo.STATE_FAILED:
                eventually(() -> assertTrue(job.isFailed()));
                break;
            case PrintJobInfo.STATE_CANCELED:
                eventually(() -> assertTrue(job.isCancelled()));
                break;
            default:
                // not reached
                throw new IllegalArgumentException(""Cannot check "" + state);
        }
    }

    @Before
    public void setPrinter() throws Throwable {
        if (!sHasBeenSetUp) {
            resetCounters();
            PrinterDiscoverySessionCallbacks sessionCallbacks
                    = createFirstMockPrinterDiscoverySessionCallbacks();

            // Create the service callbacks for the first print service.
            PrintServiceCallbacks serviceCallbacks = createFirstMockPrinterServiceCallbacks(
                    sessionCallbacks, printJob -> { });

            // Configure the print services.
            FirstPrintService.setCallbacks(serviceCallbacks);

            // We don't use the second service, but we have to still configure it
            SecondPrintService.setCallbacks(createMockPrintServiceCallbacks(null, null, null));

            // Create a print adapter that respects the print contract.
            PrintDocumentAdapter adapter = createDefaultPrintDocumentAdapter(1);

            makeDefaultPrinter(adapter, PRINTER_NAME);

            sHasBeenSetUp = true;
        }

        resetCounters();
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.print.cts.PrintServicesTest"	"waitForPrinterDiscoverySessionCreateCallbackCalled"	"CtsPrintTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/print/src/android/print/cts/PrintServicesTest.java"	""	"public void getActivePrintJobs() throws Throwable {
        clearPrintSpoolerData();

        try {
            PrintManager pm = (PrintManager) getActivity().getSystemService(Context.PRINT_SERVICE);

            // Configure first print service
            PrinterDiscoverySessionCallbacks sessionCallbacks1 =
                    createMockPrinterDiscoverySessionCallbacks(""Printer1"");
            PrintServiceCallbacks serviceCallbacks1 = createMockPrinterServiceCallbacks(
                    sessionCallbacks1);
            FirstPrintService.setCallbacks(serviceCallbacks1);

            // Configure second print service
            PrinterDiscoverySessionCallbacks sessionCallbacks2 =
                    createMockPrinterDiscoverySessionCallbacks(""Printer2"");
            PrintServiceCallbacks serviceCallbacks2 = createMockPrinterServiceCallbacks(
                    sessionCallbacks2);
            SecondPrintService.setCallbacks(serviceCallbacks2);

            // Create a print adapter that respects the print contract.
            PrintDocumentAdapter adapter = createDefaultPrintDocumentAdapter(1);

            runOnMainThread(() -> pm.print(""job1"", adapter, null));

            // Init services
            waitForPrinterDiscoverySessionCreateCallbackCalled();

            waitForWriteAdapterCallback(1);
            selectPrinter(""Printer1"");

            StubbablePrintService firstService = serviceCallbacks1.getService();
            // Job is not yet confirmed, hence it is not yet ""active""
            runOnMainThread(() -> assertEquals(0, firstService.callGetActivePrintJobs().size()));

            mPrintHelper.submitPrintJob();

            eventually(() -> {
                answerPrintServicesWarning(true);
                waitForServiceOnPrintJobQueuedCallbackCalled(1);
            }, OPERATION_TIMEOUT_MILLIS * 2);

            eventually(() -> runOnMainThread(
                    () -> assertEquals(1, firstService.callGetActivePrintJobs().size())));

            // Add another print job to first service
            resetCounters();
            runOnMainThread(() -> pm.print(""job2"", adapter, null));
            waitForWriteAdapterCallback(1);
            mPrintHelper.submitPrintJob();
            waitForServiceOnPrintJobQueuedCallbackCalled(1);

            eventually(() -> runOnMainThread(
                    () -> assertEquals(2, firstService.callGetActivePrintJobs().size())));

            // Create print job in second service
            resetCounters();
            runOnMainThread(() -> pm.print(""job3"", adapter, null));

            waitForPrinterDiscoverySessionCreateCallbackCalled();

            waitForWriteAdapterCallback(1);
            selectPrinter(""Printer2"");
            mPrintHelper.submitPrintJob();

            StubbablePrintService secondService = serviceCallbacks2.getService();
            runOnMainThread(() -> assertEquals(0, secondService.callGetActivePrintJobs().size()));

            eventually(() -> {
                answerPrintServicesWarning(true);
                waitForServiceOnPrintJobQueuedCallbackCalled(1);
            }, OPERATION_TIMEOUT_MILLIS * 2);

            eventually(() -> runOnMainThread(
                    () -> assertEquals(1, secondService.callGetActivePrintJobs().size())));
            runOnMainThread(() -> assertEquals(2, firstService.callGetActivePrintJobs().size()));

            // Block last print job. Blocked jobs are still considered active
            runOnMainThread(() -> sPrintJob.block(null));
            eventually(() -> runOnMainThread(() -> assertTrue(sPrintJob.isBlocked())));
            runOnMainThread(() -> assertEquals(1, secondService.callGetActivePrintJobs().size()));

            // Fail last print job. Failed job are not active
            runOnMainThread(() -> sPrintJob.fail(null));
            eventually(() -> runOnMainThread(() -> assertTrue(sPrintJob.isFailed())));
            runOnMainThread(() -> assertEquals(0, secondService.callGetActivePrintJobs().size()));

            // Cancel job. Canceled jobs are not active
            runOnMainThread(() -> assertEquals(2, firstService.callGetActivePrintJobs().size()));
            android.print.PrintJob job2 = getPrintJob(pm, ""job2"");
            runOnMainThread(job2::cancel);
            eventually(() -> runOnMainThread(() -> assertTrue(job2.isCancelled())));
            runOnMainThread(() -> assertEquals(1, firstService.callGetActivePrintJobs().size()));

            waitForPrinterDiscoverySessionDestroyCallbackCalled(1);
        } finally {
            clearPrintSpoolerData();
        }
    }

    /**
     * Test that the icon get be updated.
     *
     * @throws Throwable If anything is unexpected.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"ProvisioningCallback"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void test/*
 *.
 */

package android.net.wifi.cts;

import static android.net.NetworkCapabilities.NET_CAPABILITY_NOT_METERED;
import static android.net.NetworkCapabilities.TRANSPORT_WIFI;
import static android.net.wifi.WifiAvailableChannel.OP_MODE_SAP;
import static android.net.wifi.WifiAvailableChannel.OP_MODE_STA;
import static android.net.wifi.WifiConfiguration.INVALID_NETWORK_ID;
import static android.net.wifi.WifiManager.COEX_RESTRICTION_SOFTAP;
import static android.net.wifi.WifiManager.COEX_RESTRICTION_WIFI_AWARE;
import static android.net.wifi.WifiManager.COEX_RESTRICTION_WIFI_DIRECT;
import static android.net.wifi.WifiScanner.WIFI_BAND_24_GHZ;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import static org.junit.Assert.assertNotEquals;

import android.annotation.NonNull;
import android.app.UiAutomation;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.content.pm.ResolveInfo;
import android.net.ConnectivityManager;
import android.net.MacAddress;
import android.net.Network;
import android.net.NetworkCapabilities;
import android.net.NetworkInfo;
import android.net.NetworkRequest;
import android.net.TetheringManager;
import android.net.Uri;
import android.net.wifi.CoexUnsafeChannel;
import android.net.wifi.ScanResult;
import android.net.wifi.SoftApCapability;
import android.net.wifi.SoftApConfiguration;
import android.net.wifi.SoftApInfo;
import android.net.wifi.WifiAvailableChannel;
import android.net.wifi.WifiClient;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiEnterpriseConfig;
import android.net.wifi.WifiInfo;
import android.net.wifi.WifiManager;
import android.net.wifi.WifiManager.SubsystemRestartTrackingCallback;
import android.net.wifi.WifiManager.WifiLock;
import android.net.wifi.WifiNetworkConnectionStatistics;
import android.net.wifi.WifiNetworkSuggestion;
import android.net.wifi.hotspot2.ConfigParser;
import android.net.wifi.hotspot2.OsuProvider;
import android.net.wifi.hotspot2.PasspointConfiguration;
import android.net.wifi.hotspot2.ProvisioningCallback;
import android.net.wifi.hotspot2.pps.Credential;
import android.net.wifi.hotspot2.pps.HomeSp;
import android.os.Build;
import android.os.Handler;
import android.os.HandlerExecutor;
import android.os.HandlerThread;
import android.os.Process;
import android.os.SystemClock;
import android.os.UserHandle;
import android.platform.test.annotations.AppModeFull;
import android.platform.test.annotations.AsbSecurityTest;
import android.provider.Settings;
import android.support.test.uiautomator.UiDevice;
import android.telephony.TelephonyManager;
import android.text.TextUtils;
import android.util.ArraySet;
import android.util.Log;
import android.util.SparseArray;
import android.util.SparseIntArray;

import androidx.test.filters.SdkSuppress;
import androidx.test.platform.app.InstrumentationRegistry;

import com.android.compatibility.common.util.ApiLevelUtil;
import com.android.compatibility.common.util.FeatureUtil;
import com.android.compatibility.common.util.PollingCheck;
import com.android.compatibility.common.util.PropertyUtil;
import com.android.compatibility.common.util.ShellIdentityUtils;
import com.android.compatibility.common.util.SystemUtil;
import com.android.compatibility.common.util.ThrowingRunnable;
import com.android.modules.utils.build.SdkLevel;
import com.android.net.module.util.MacAddressUtils;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.lang.reflect.Constructor;
import java.net.HttpURLConnection;
import java.net.InetAddress;
import java.net.URL;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

@AppModeFull(reason = ""Cannot get WifiManager in instant app mode"")
public class WifiManagerTest extends WifiJUnit3TestBase {
    private static class MySync {
        int expectedState = STATE_NULL;
    }

    private WifiManager mWifiManager;
    private ConnectivityManager mConnectivityManager;
    private TetheringManager mTetheringManager;
    private WifiLock mWifiLock;
    private static MySync mMySync;
    private List<ScanResult> mScanResults = null;
    private NetworkInfo mNetworkInfo =
            new NetworkInfo(ConnectivityManager.TYPE_WIFI, TelephonyManager.NETWORK_TYPE_UNKNOWN,
                    ""wifi"", ""unknown"");
    private final Object mLock = new Object();
    private UiDevice mUiDevice;
    private boolean mWasVerboseLoggingEnabled;
    private boolean mWasScanThrottleEnabled;
    private SoftApConfiguration mOriginalSoftApConfig = null;

    // Please refer to WifiManager
    private static final int MIN_RSSI = -100;
    private static final int MAX_RSSI = -55;

    private static final int STATE_NULL = 0;
    private static final int STATE_WIFI_CHANGING = 1;
    private static final int STATE_WIFI_ENABLED = 2;
    private static final int STATE_WIFI_DISABLED = 3;
    private static final int STATE_SCANNING = 4;
    private static final int STATE_SCAN_DONE = 5;

    private static final String TAG = ""WifiManagerTest"";
    private static final String SSID1 = ""\""WifiManagerTest\"""";
    // A full single scan duration is about 6-7 seconds if country code is set
    // to US. If country code is set to world mode (00), we would expect a scan
    // duration of roughly 8 seconds. So we set scan timeout as 9 seconds here.
    private static final int SCAN_TEST_WAIT_DURATION_MS = 9000;
    private static final int TEST_WAIT_DURATION_MS = 10_000;
    private static final int WIFI_CONNECT_TIMEOUT_MILLIS = 30_000;
    private static final int WAIT_MSEC = 60;
    private static final int DURATION_SCREEN_TOGGLE = 2000;
    private static final int DURATION_SETTINGS_TOGGLE = 1_000;
    private static final int WIFI_SCAN_TEST_CACHE_DELAY_MILLIS = 3 * 60 * 1000;

    private static final int ENFORCED_NUM_NETWORK_SUGGESTIONS_PER_APP = 50;

    private static final String TEST_PAC_URL = ""http://www.example.com/proxy.pac"";
    private static final String MANAGED_PROVISIONING_PACKAGE_NAME
            = ""com.android.managedprovisioning"";

    private static final String TEST_SSID_UNQUOTED = ""testSsid1"";
    private static final String TEST_IP_ADDRESS = ""192.168.5.5"";
    private static final String TEST_MAC_ADDRESS = ""aa:bb:cc:dd:ee:ff"";
    private static final MacAddress TEST_MAC = MacAddress.fromString(TEST_MAC_ADDRESS);
    private static final String TEST_PASSPHRASE = ""passphrase"";
    private static final String PASSPOINT_INSTALLATION_FILE_WITH_CA_CERT =
            ""assets/ValidPasspointProfile.base64"";
    private static final String TYPE_WIFI_CONFIG = ""application/x-wifi-config"";
    private static final String TEST_PSK_CAP = ""[RSN-PSK-CCMP]"";
    private static final String TEST_BSSID = ""00:01:02:03:04:05"";
    private static final String TEST_COUNTRY_CODE = ""JP"";
    private static final String TEST_DOM_SUBJECT_MATCH = ""domSubjectMatch"";
    private static final int TEST_SUB_ID = 2;

    private IntentFilter mIntentFilter;
    private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            final String action = intent.getAction();
            if (action.equals(WifiManager.SCAN_RESULTS_AVAILABLE_ACTION)) {

                synchronized (mMySync) {
                    if (intent.getBooleanExtra(WifiManager.EXTRA_RESULTS_UPDATED, false)) {
                        mScanResults = mWifiManager.getScanResults();
                    } else {
                        mScanResults = null;
                    }
                    mMySync.expectedState = STATE_SCAN_DONE;
                    mMySync.notifyAll();
                }
            } else if (action.equals(WifiManager.WIFI_STATE_CHANGED_ACTION)) {
                int newState = intent.getIntExtra(WifiManager.EXTRA_WIFI_STATE,
                        WifiManager.WIFI_STATE_UNKNOWN);
                synchronized (mMySync) {
                    if (newState == WifiManager.WIFI_STATE_ENABLED) {
                        Log.d(TAG, ""*** New WiFi state is ENABLED ***"");
                        mMySync.expectedState = STATE_WIFI_ENABLED;
                        mMySync.notifyAll();
                    } else if (newState == WifiManager.WIFI_STATE_DISABLED) {
                        Log.d(TAG, ""*** New WiFi state is DISABLED ***"");
                        mMySync.expectedState = STATE_WIFI_DISABLED;
                        mMySync.notifyAll();
                    }
                }
            } else if (action.equals(WifiManager.NETWORK_STATE_CHANGED_ACTION)) {
                synchronized (mMySync) {
                    mNetworkInfo =
                            (NetworkInfo) intent.getParcelableExtra(WifiManager.EXTRA_NETWORK_INFO);
                    if (mNetworkInfo.getState() == NetworkInfo.State.CONNECTED)
                        mMySync.notifyAll();
                }
            }
        }
    };
    // Initialize with an invalid status value (0)
    private int mProvisioningStatus = 0;
    // Initialize with an invalid status value (0)
    private int mProvisioningFailureStatus = 0;
    private boolean mProvisioningComplete = false;
    private ProvisioningCallback mProvisioningCallback = new ProvisioningCallback() {
        @Override
        public void onProvisioningFailure(int status) {
            synchronized (mLock) {
                mProvisioningFailureStatus = status;
                mLock.notify();
            }
        }

        @Override
        public void onProvisioningStatus(int status) {
            synchronized (mLock) {
                mProvisioningStatus = status;
                mLock.notify();
            }
        }

        @Override
        public void onProvisioningComplete() {
            mProvisioningComplete = true;
        }
    };
    private int mSubsystemRestartStatus = 0; // 0: nada, 1: restarting, 2: restarted
    private SubsystemRestartTrackingCallback mSubsystemRestartTrackingCallback =
            new SubsystemRestartTrackingCallback() {
                @Override
                public void onSubsystemRestarting() {
                    synchronized (mLock) {
                        mSubsystemRestartStatus = 1;
                        mLock.notify();
                    }
                }

                @Override
                public void onSubsystemRestarted() {
                    synchronized (mLock) {
                        mSubsystemRestartStatus = 2;
                        mLock.notify();
                    }
                }
            };
    private static final String TEST_SSID = ""TEST SSID"";
    private static final String TEST_FRIENDLY_NAME = ""Friendly Name"";
    private static final Map<String, String> TEST_FRIENDLY_NAMES =
            new HashMap<String, String>() {
                {
                    put(""en"", TEST_FRIENDLY_NAME);
                    put(""kr"", TEST_FRIENDLY_NAME + 2);
                    put(""jp"", TEST_FRIENDLY_NAME + 3);
                }
            };
    private static final String TEST_SERVICE_DESCRIPTION = ""Dummy Service"";
    private static final Uri TEST_SERVER_URI = Uri.parse(""https://test.com"");
    private static final String TEST_NAI = ""test.access.com"";
    private static final List<Integer> TEST_METHOD_LIST =
            Arrays.asList(1 /* METHOD_SOAP_XML_SPP */);
    private final HandlerThread mHandlerThread = new HandlerThread(""WifiManagerTest"");
    protected final Executor mExecutor;
    {
        mHandlerThread.start();
        mExecutor = new HandlerExecutor(new Handler(mHandlerThread.getLooper()));
    }

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        mMySync = new MySync();
        mIntentFilter = new IntentFilter();
        mIntentFilter.addAction(WifiManager.NETWORK_STATE_CHANGED_ACTION);
        mIntentFilter.addAction(WifiManager.SCAN_RESULTS_AVAILABLE_ACTION);
        mIntentFilter.addAction(WifiManager.SUPPLICANT_CONNECTION_CHANGE_ACTION);
        mIntentFilter.addAction(WifiManager.SUPPLICANT_STATE_CHANGED_ACTION);
        mIntentFilter.addAction(WifiManager.WIFI_STATE_CHANGED_ACTION);
        mIntentFilter.addAction(WifiManager.RSSI_CHANGED_ACTION);
        mIntentFilter.addAction(WifiManager.NETWORK_IDS_CHANGED_ACTION);
        mIntentFilter.addAction(WifiManager.ACTION_PICK_WIFI_NETWORK);

        mContext.registerReceiver(mReceiver, mIntentFilter);
        mWifiManager = (WifiManager) getContext().getSystemService(Context.WIFI_SERVICE);
        mConnectivityManager = getContext().getSystemService(ConnectivityManager.class);
        mTetheringManager = getContext().getSystemService(TetheringManager.class);
        assertNotNull(mWifiManager);
        assertNotNull(mTetheringManager);

        // turn on verbose logging for tests
        mWasVerboseLoggingEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.isVerboseLoggingEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setVerboseLoggingEnabled(true));
        // Disable scan throttling for tests.
        mWasScanThrottleEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.isScanThrottleEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setScanThrottleEnabled(false));

        mWifiLock = mWifiManager.createWifiLock(TAG);
        mWifiLock.acquire();
        // enable Wifi
        if (!mWifiManager.isWifiEnabled()) setWifiEnabled(true);
        PollingCheck.check(""Wifi not enabled"", TEST_WAIT_DURATION_MS,
                () -> mWifiManager.isWifiEnabled());

        mUiDevice = UiDevice.getInstance(InstrumentationRegistry.getInstrumentation());
        turnScreenOnNoDelay();

        synchronized (mMySync) {
            mMySync.expectedState = STATE_NULL;
        }

        List<WifiConfiguration> savedNetworks = ShellIdentityUtils.invokeWithShellPermissions(
                mWifiManager::getConfiguredNetworks);
        assertFalse(""Need at least one saved network"", savedNetworks.isEmpty());

        // Get original config for restore
        mOriginalSoftApConfig = ShellIdentityUtils.invokeWithShellPermissions(
                mWifiManager::getSoftApConfiguration);
    }

    @Override
    protected void tearDown() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            super.tearDown();
            return;
        }
        if (!mWifiManager.isWifiEnabled())
            setWifiEnabled(true);
        mWifiLock.release();
        mContext.unregisterReceiver(mReceiver);
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setScanThrottleEnabled(mWasScanThrottleEnabled));
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setVerboseLoggingEnabled(mWasVerboseLoggingEnabled));
        // restore original softap config
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setSoftApConfiguration(mOriginalSoftApConfig));
        Thread.sleep(TEST_WAIT_DURATION_MS);
        super.tearDown();
    }

    private void setWifiEnabled(boolean enable) throws Exception {
        synchronized (mMySync) {
            if (mWifiManager.isWifiEnabled() != enable) {
                // the new state is different, we expect it to change
                mMySync.expectedState = STATE_WIFI_CHANGING;
            } else {
                mMySync.expectedState = (enable ? STATE_WIFI_ENABLED : STATE_WIFI_DISABLED);
            }
            // now trigger the change using shell commands.
            SystemUtil.runShellCommand(""svc wifi "" + (enable ? ""enable"" : ""disable""));
            waitForExpectedWifiState(enable);
        }
    }

    private void waitForExpectedWifiState(boolean enabled) throws InterruptedException {
        synchronized (mMySync) {
            long timeout = System.currentTimeMillis() + TEST_WAIT_DURATION_MS;
            int expected = (enabled ? STATE_WIFI_ENABLED : STATE_WIFI_DISABLED);
            while (System.currentTimeMillis() < timeout
                    && mMySync.expectedState != expected) {
                mMySync.wait(WAIT_MSEC);
            }
        }
    }

    // Get the current scan status from sticky broadcast.
    private boolean isScanCurrentlyAvailable() {
        IntentFilter intentFilter = new IntentFilter();
        intentFilter.addAction(WifiManager.ACTION_WIFI_SCAN_AVAILABILITY_CHANGED);
        Intent intent = mContext.registerReceiver(null, intentFilter);
        assertNotNull(intent);
        if (intent.getAction().equals(WifiManager.ACTION_WIFI_SCAN_AVAILABILITY_CHANGED)) {
            return intent.getBooleanExtra(WifiManager.EXTRA_SCAN_AVAILABLE, false);
        }
        return false;
    }

    private void startScan() throws Exception {
        synchronized (mMySync) {
            mMySync.expectedState = STATE_SCANNING;
            mScanResults = null;
            assertTrue(mWifiManager.startScan());
            long timeout = System.currentTimeMillis() + SCAN_TEST_WAIT_DURATION_MS;
            while (System.currentTimeMillis() < timeout && mMySync.expectedState == STATE_SCANNING)
                mMySync.wait(WAIT_MSEC);
        }
    }

    private void waitForNetworkInfoState(NetworkInfo.State state, int timeoutMillis)
            throws Exception {
        synchronized (mMySync) {
            if (mNetworkInfo.getState() == state) return;
            long timeout = System.currentTimeMillis() + timeoutMillis;
            while (System.currentTimeMillis() < timeout
                    && mNetworkInfo.getState() != state)
                mMySync.wait(WAIT_MSEC);
            assertEquals(state, mNetworkInfo.getState());
        }
    }

    private void waitForConnection() throws Exception {
        waitForNetworkInfoState(NetworkInfo.State.CONNECTED, WIFI_CONNECT_TIMEOUT_MILLIS);
    }

    private void waitForDisconnection() throws Exception {
        waitForNetworkInfoState(NetworkInfo.State.DISCONNECTED, TEST_WAIT_DURATION_MS);
    }

    private void ensureNotNetworkInfoState(NetworkInfo.State state) throws Exception {
        synchronized (mMySync) {
            long timeout = System.currentTimeMillis() + TEST_WAIT_DURATION_MS + WAIT_MSEC;
            while (System.currentTimeMillis() < timeout) {
                assertNotEquals(state, mNetworkInfo.getState());
                mMySync.wait(WAIT_MSEC);
            }
        }
    }

    private void ensureNotConnected() throws Exception {
        ensureNotNetworkInfoState(NetworkInfo.State.CONNECTED);
    }

    private void ensureNotDisconnected() throws Exception {
        ensureNotNetworkInfoState(NetworkInfo.State.DISCONNECTED);
    }

    private boolean existSSID(String ssid) {
        for (final WifiConfiguration w : mWifiManager.getConfiguredNetworks()) {
            if (w.SSID.equals(ssid))
                return true;
        }
        return false;
    }

    private int findConfiguredNetworks(String SSID, List<WifiConfiguration> networks) {
        for (final WifiConfiguration w : networks) {
            if (w.SSID.equals(SSID))
                return networks.indexOf(w);
        }
        return -1;
    }

    /**
     * Test creation of WifiManager Lock.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testWifiManagerLock"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testWifiManagerLock() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        final String TAG = ""Test"";
        assertNotNull(mWifiManager.createWifiLock(TAG));
        assertNotNull(mWifiManager.createWifiLock(WifiManager.WIFI_MODE_FULL, TAG));
    }

    /**
     * Test wifi scanning when Wifi is off and location scanning is turned on.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testWifiManagerScanWhenWifiOffLocationTurnedOn"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testWifiManagerScanWhenWifiOffLocationTurnedOn() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        if (!hasLocationFeature()) {
            Log.d(TAG, ""Skipping test as location is not supported"");
            return;
        }
        if (!isLocationEnabled()) {
            fail(""Please enable location for this test - since Marshmallow WiFi scan results are""
                    + "" empty when location is disabled!"");
        }
        runWithScanningEnabled(() -> {
            setWifiEnabled(false);
            Thread.sleep(TEST_WAIT_DURATION_MS);
            startScan();
            if (mWifiManager.isScanAlwaysAvailable() && isScanCurrentlyAvailable()) {
                // Make sure at least one AP is found.
                assertNotNull(""mScanResult should not be null!"", mScanResults);
                assertFalse(""empty scan results!"", mScanResults.isEmpty());
            } else {
                // Make sure no scan results are available.
                assertNull(""mScanResult should be null!"", mScanResults);
            }
            final String TAG = ""Test"";
            assertNotNull(mWifiManager.createWifiLock(TAG));
            assertNotNull(mWifiManager.createWifiLock(WifiManager.WIFI_MODE_FULL, TAG));
        });
    }

    /**
     * Restart WiFi subsystem - verify that privileged call fails.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testWifiManagerProperties"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testWifiManagerProperties() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        setWifiEnabled(true);
        assertTrue(mWifiManager.isWifiEnabled());
        assertNotNull(mWifiManager.getDhcpInfo());
        assertEquals(WifiManager.WIFI_STATE_ENABLED, mWifiManager.getWifiState());
        mWifiManager.getConnectionInfo();
        setWifiEnabled(false);
        assertFalse(mWifiManager.isWifiEnabled());
    }

    /**
     * Test WiFi scan timestamp - fails when WiFi scan timestamps are inconsistent with
     * {@link SystemClock#elapsedRealtime()} on device.<p>
     * To run this test in cts-tradefed:
     * run cts --class android.net.wifi.cts.WifiManagerTest --method testWifiScanTimestamp
     */
    @VirtualDeviceNotSupported"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testWifiScanTimestamp"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testWifiScanTimestamp() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            Log.d(TAG, ""Skipping test as WiFi is not supported"");
            return;
        }
        if (!hasLocationFeature()) {
            Log.d(TAG, ""Skipping test as location is not supported"");
            return;
        }
        if (!isLocationEnabled()) {
            fail(""Please enable location for this test - since Marshmallow WiFi scan results are""
                    + "" empty when location is disabled!"");
        }
        if (!mWifiManager.isWifiEnabled()) {
            setWifiEnabled(true);
        }
        // Make sure the scan timestamps are consistent with the device timestamp within the range
        // of WIFI_SCAN_TEST_CACHE_DELAY_MILLIS.
        startScan();
        // Make sure at least one AP is found.
        assertTrue(""mScanResult should not be null. This may be due to a scan timeout"",
                   mScanResults != null);
        assertFalse(""empty scan results!"", mScanResults.isEmpty());
        long nowMillis = SystemClock.elapsedRealtime();
        // Keep track of how many APs are fresh in one scan.
        int numFreshAps = 0;
        for (ScanResult result : mScanResults) {
            long scanTimeMillis = TimeUnit.MICROSECONDS.toMillis(result.timestamp);
            if (Math.abs(nowMillis - scanTimeMillis)  < WIFI_SCAN_TEST_CACHE_DELAY_MILLIS) {
                numFreshAps++;
            }
        }
        // At least half of the APs in the scan should be fresh.
        int numTotalAps = mScanResults.size();
        String msg = ""Stale AP count: "" + (numTotalAps - numFreshAps) + "", fresh AP count: ""
                + numFreshAps;
        assertTrue(msg, numFreshAps * 2 >= mScanResults.size());
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testConvertBetweenChannelFrequencyMhz"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testConvertBetweenChannelFrequencyMhz() throws Exception {
        int[] testFrequency_2G = {2412, 2437, 2462, 2484};
        int[] testFrequency_5G = {5180, 5220, 5540, 5745};
        int[] testFrequency_6G = {5955, 6435, 6535, 7115};
        int[] testFrequency_60G = {58320, 64800};
        SparseArray<int[]> testData = new SparseArray<>() {{
            put(ScanResult.WIFI_BAND_24_GHZ, testFrequency_2G);
            put(ScanResult.WIFI_BAND_5_GHZ, testFrequency_5G);
            put(ScanResult.WIFI_BAND_6_GHZ, testFrequency_6G);
            put(ScanResult.WIFI_BAND_60_GHZ, testFrequency_60G);
        }};

        for (int i = 0; i < testData.size(); i++) {
            for (int frequency : testData.valueAt(i)) {
                assertEquals(frequency, ScanResult.convertChannelToFrequencyMhzIfSupported(
                      ScanResult.convertFrequencyMhzToChannelIfSupported(frequency), testData.keyAt(i)));
            }
        }
    }

    // Return true if location is enabled.
    private boolean isLocationEnabled() {
        return Settings.Secure.getInt(getContext().getContentResolver(),
                Settings.Secure.LOCATION_MODE, Settings.Secure.LOCATION_MODE_OFF) !=
                Settings.Secure.LOCATION_MODE_OFF;
    }

    // Returns true if the device has location feature.
    private boolean hasLocationFeature() {
        return getContext().getPackageManager().hasSystemFeature(PackageManager.FEATURE_LOCATION);
    }

    private boolean hasAutomotiveFeature() {
        return getContext().getPackageManager().hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE);
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testUpdateWifiUsabilityStatsScorePermission"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testUpdateWifiUsabilityStatsScorePermission() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        final PackageManager pm = getContext().getPackageManager();

        final List<PackageInfo> holding = pm.getPackagesHoldingPermissions(new String[] {
                android.Manifest.permission.WIFI_UPDATE_USABILITY_STATS_SCORE
        }, PackageManager.MATCH_UNINSTALLED_PACKAGES);

        Set<String> uniqueNonSystemPackageNames = new HashSet<>();
        for (PackageInfo pi : holding) {
            String packageName = pi.packageName;
            // Shell is allowed to hold this permission for testing.
            int uid = -1;
            try {
                uid = pm.getPackageUidAsUser(packageName, UserHandle.USER_SYSTEM);
            } catch (PackageManager.NameNotFoundException e) {
                continue;
            }
            if (uid == Process.SHELL_UID) continue;

            uniqueNonSystemPackageNames.add(packageName);
        }

        if (uniqueNonSystemPackageNames.size() > 1) {
            fail(""The WIFI_UPDATE_USABILITY_STATS_SCORE permission must not be held by more than ""
                + ""one application, but is held by "" + uniqueNonSystemPackageNames.size()
                + "" applications: "" + String.join("", "", uniqueNonSystemPackageNames));
        }
    }

    private void turnScreenOnNoDelay() throws Exception {
        mUiDevice.executeShellCommand(""input keyevent KEYCODE_WAKEUP"");
        mUiDevice.executeShellCommand(""wm dismiss-keyguard"");
    }

    private void turnScreenOn() throws Exception {
        turnScreenOnNoDelay();
        // Since the screen on/off intent is ordered, they will not be sent right now.
        Thread.sleep(DURATION_SCREEN_TOGGLE);
    }

    private void turnScreenOffNoDelay() throws Exception {
        mUiDevice.executeShellCommand(""input keyevent KEYCODE_SLEEP"");
    }

    private void turnScreenOff() throws Exception {
        turnScreenOffNoDelay();
        // Since the screen on/off intent is ordered, they will not be sent right now.
        Thread.sleep(DURATION_SCREEN_TOGGLE);
    }

    private void assertWifiScanningIsOn() {
        if (!mWifiManager.isScanAlwaysAvailable()) {
            fail(""Wi-Fi scanning should be on."");
        }
    }

    private void runWithScanningEnabled(ThrowingRunnable r) throws Exception {
        boolean wasScanEnabledForTest = false;
        if (!mWifiManager.isScanAlwaysAvailable()) {
            ShellIdentityUtils.invokeWithShellPermissions(
                    () -> mWifiManager.setScanAlwaysAvailable(true));
            wasScanEnabledForTest = true;
        }
        try {
            r.run();
        } finally {
            if (wasScanEnabledForTest) {
                ShellIdentityUtils.invokeWithShellPermissions(
                        () -> mWifiManager.setScanAlwaysAvailable(false));
            }
        }
    }

    /**
     * Verify that Wi-Fi scanning is not turned off when the screen turns off while wifi is disabled
     * but location is on.
     * @throws Exception
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testScreenOffDoesNotTurnOffWifiScanningWhenWifiDisabled"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testScreenOffDoesNotTurnOffWifiScanningWhenWifiDisabled() throws Exception {
        if (FeatureUtil.isTV() || FeatureUtil.isAutomotive()) {
            // TV and auto do not support the setting options of WIFI scanning and Bluetooth
            // scanning
            return;
        }
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        if (!hasLocationFeature()) {
            // skip the test if location is not supported
            return;
        }
        if (!isLocationEnabled()) {
            fail(""Please enable location for this test - since Marshmallow WiFi scan results are""
                    + "" empty when location is disabled!"");
        }
        runWithScanningEnabled(() -> {
            setWifiEnabled(false);
            turnScreenOn();
            assertWifiScanningIsOn();
            // Toggle screen and verify Wi-Fi scanning is still on.
            turnScreenOff();
            assertWifiScanningIsOn();
            turnScreenOn();
            assertWifiScanningIsOn();
        });
    }

    /**
     * Verify that Wi-Fi scanning is not turned off when the screen turns off while wifi is enabled.
     * @throws Exception
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testScreenOffDoesNotTurnOffWifiScanningWhenWifiEnabled"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testScreenOffDoesNotTurnOffWifiScanningWhenWifiEnabled() throws Exception {
        if (FeatureUtil.isTV() || FeatureUtil.isAutomotive()) {
            // TV and auto do not support the setting options of WIFI scanning and Bluetooth
            // scanning
            return;
        }
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        if (!hasLocationFeature()) {
            // skip the test if location is not supported
            return;
        }
        if (!isLocationEnabled()) {
            fail(""Please enable location for this test - since Marshmallow WiFi scan results are""
                    + "" empty when location is disabled!"");
        }
        runWithScanningEnabled(() -> {
            setWifiEnabled(true);
            turnScreenOn();
            assertWifiScanningIsOn();
            // Toggle screen and verify Wi-Fi scanning is still on.
            turnScreenOff();
            assertWifiScanningIsOn();
            turnScreenOn();
            assertWifiScanningIsOn();
        });
    }

    /**
     * Verify that the platform supports a reasonable number of suggestions per app.
     * @throws Exception
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testStartTetheredHotspotWithChannelConfigAndSoftApStateAndInfoCallback"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testStartTetheredHotspotWithChannelConfigAndSoftApStateAndInfoCallback()
            throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // check that softap mode is supported by the device
        if (!mWifiManager.isPortableHotspotSupported()) {
            return;
        }
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        TestExecutor executor = new TestExecutor();
        TestSoftApCallback callback = new TestSoftApCallback(mLock);
        try {
            uiAutomation.adoptShellPermissionIdentity();
            // check that tethering is supported by the device
            if (!mTetheringManager.isTetheringSupported()) {
                return;
            }
            turnOffWifiAndTetheredHotspotIfEnabled();
            verifyRegisterSoftApCallback(executor, callback);

            SparseIntArray testBandsAndChannels = getAvailableBandAndChannelForTesting(
                    callback.getCurrentSoftApCapability());

            if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
                assertNotEquals(0, testBandsAndChannels.size());
            }
            boolean isSupportCustomizedMac = callback.getCurrentSoftApCapability()
                    .areFeaturesSupported(
                    SoftApCapability.SOFTAP_FEATURE_MAC_ADDRESS_CUSTOMIZATION)
                    && PropertyUtil.isVndkApiLevelNewerThan(Build.VERSION_CODES.S);

            SoftApConfiguration.Builder testSoftApConfigBuilder = new SoftApConfiguration.Builder()
                    .setSsid(TEST_SSID_UNQUOTED)
                    .setPassphrase(TEST_PASSPHRASE, SoftApConfiguration.SECURITY_TYPE_WPA2_PSK)
                    .setChannel(testBandsAndChannels.valueAt(0), testBandsAndChannels.keyAt(0));

            if (isSupportCustomizedMac) testSoftApConfigBuilder.setBssid(TEST_MAC);

            SoftApConfiguration testSoftApConfig = testSoftApConfigBuilder.build();

            mWifiManager.setSoftApConfiguration(testSoftApConfig);

            // start tethering which used to verify startTetheredHotspot
            mTetheringManager.startTethering(ConnectivityManager.TETHERING_WIFI, executor,
                new TetheringManager.StartTetheringCallback() {
                    @Override
                    public void onTetheringFailed(final int result) {
                    }
                });

            // Verify state and info callback value as expected
            PollingCheck.check(
                    ""SoftAp channel and state mismatch!!!"", 10_000,
                    () -> {
                        executor.runAll();
                        int sapChannel = ScanResult.convertFrequencyMhzToChannelIfSupported(
                                callback.getCurrentSoftApInfo().getFrequency());
                        boolean isInfoCallbackSupported =
                                callback.getOnSoftapInfoChangedCalledCount() > 1;
                        if (isInfoCallbackSupported) {
                            return WifiManager.WIFI_AP_STATE_ENABLED == callback.getCurrentState()
                                && testBandsAndChannels.valueAt(0) == sapChannel;
                        }
                        return WifiManager.WIFI_AP_STATE_ENABLED == callback.getCurrentState();
                    });
            // After Soft Ap enabled, check SoftAp info if it supported
            if (isSupportCustomizedMac && callback.getOnSoftapInfoChangedCalledCount() > 1) {
                assertEquals(callback.getCurrentSoftApInfo().getBssid(), TEST_MAC);
            }
            if (PropertyUtil.isVndkApiLevelNewerThan(Build.VERSION_CODES.S)
                    && callback.getOnSoftapInfoChangedCalledCount() > 1) {
                assertNotEquals(callback.getCurrentSoftApInfo().getWifiStandard(),
                        ScanResult.WIFI_STANDARD_UNKNOWN);
            }

            if (callback.getOnSoftapInfoChangedCalledCount() > 1) {
                assertTrue(callback.getCurrentSoftApInfo().getAutoShutdownTimeoutMillis() > 0);
            }
        } finally {
            // stop tethering which used to verify stopSoftAp
            mTetheringManager.stopTethering(ConnectivityManager.TETHERING_WIFI);

            // Verify clean up
            PollingCheck.check(
                    ""Stop Softap failed"", 3_000,
                    () -> {
                        executor.runAll();
                        return WifiManager.WIFI_AP_STATE_DISABLED == callback.getCurrentState() &&
                                0 == callback.getCurrentSoftApInfo().getBandwidth() &&
                                0 == callback.getCurrentSoftApInfo().getFrequency();
                    });
            if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
                assertEquals(callback.getCurrentSoftApInfo().getBssid(), null);
                assertEquals(ScanResult.WIFI_STANDARD_UNKNOWN,
                        callback.getCurrentSoftApInfo().getWifiStandard());
            }
            mWifiManager.unregisterSoftApCallback(callback);
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    private static class TestActionListener implements WifiManager.ActionListener {
        private final Object mLock;
        public boolean onSuccessCalled = false;
        public boolean onFailedCalled = false;
        public int failureReason = -1;

        TestActionListener(Object lock) {
            mLock = lock;
        }

        @Override
        public void onSuccess() {
            synchronized (mLock) {
                onSuccessCalled = true;
                mLock.notify();
            }
        }

        @Override
        public void onFailure(int reason) {
            synchronized (mLock) {
                onFailedCalled = true;
                failureReason = reason;
                mLock.notify();
            }
        }
    }

    /**
     * Triggers connection to one of the saved networks using {@link WifiManager#connect(
     * int, WifiManager.ActionListener)} or {@link WifiManager#connect(WifiConfiguration,
     * WifiManager.ActionListener)}
     *
     * @param withNetworkId Use networkId for triggering connection, false for using
     *                      WifiConfiguration.
     * @throws Exception
     */
    private void testConnect(boolean withNetworkId) throws Exception {
        TestActionListener actionListener = new TestActionListener(mLock);
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        List<WifiConfiguration> savedNetworks = null;
        try {
            uiAutomation.adoptShellPermissionIdentity();
            // These below API's only work with privileged permissions (obtained via shell identity
            // for test)
            savedNetworks = mWifiManager.getConfiguredNetworks();

            // Disable all the saved networks to trigger disconnect & disable autojoin.
            for (WifiConfiguration network : savedNetworks) {
                assertTrue(mWifiManager.disableNetwork(network.networkId));
            }
            waitForDisconnection();

            // Now trigger connection to the last saved network.
            WifiConfiguration savedNetworkToConnect =
                    savedNetworks.get(savedNetworks.size() - 1);
            synchronized (mLock) {
                try {
                    if (withNetworkId) {
                        mWifiManager.connect(savedNetworkToConnect.networkId, actionListener);
                    } else {
                        mWifiManager.connect(savedNetworkToConnect, actionListener);
                    }
                    // now wait for callback
                    mLock.wait(TEST_WAIT_DURATION_MS);
                } catch (InterruptedException e) {
                }
            }
            // check if we got the success callback
            assertTrue(actionListener.onSuccessCalled);
            // Wait for connection to complete & ensure we are connected to the saved network.
            waitForConnection();
            if (SdkLevel.isAtLeastS()) {
                assertEquals(savedNetworkToConnect.networkId,
                        mWifiManager.getConnectionInfo().getNetworkId());
            } else {
                // In R, auto-upgraded network IDs may be different from the original saved network.
                // Since we may end up selecting the auto-upgraded network ID for connection and end
                // up connected to the original saved network with a different network ID, we should
                // instead match by SSID.
                assertEquals(savedNetworkToConnect.SSID,
                        mWifiManager.getConnectionInfo().getSSID());
            }
        } finally {
            // Re-enable all saved networks before exiting.
            if (savedNetworks != null) {
                for (WifiConfiguration network : savedNetworks) {
                    mWifiManager.enableNetwork(network.networkId, true);
                }
            }
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link WifiManager#connect(int, WifiManager.ActionListener)} to an existing saved
     * network.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testSave"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testSave() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        TestActionListener actionListener = new TestActionListener(mLock);
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        List<WifiConfiguration> savedNetworks = null;
        WifiConfiguration currentConfig = null;
        try {
            uiAutomation.adoptShellPermissionIdentity();
            // These below API's only work with privileged permissions (obtained via shell identity
            // for test)

            // Trigger a scan & wait for connection to one of the saved networks.
            mWifiManager.startScan();
            waitForConnection();

            WifiInfo wifiInfo = mWifiManager.getConnectionInfo();

            // find the current network's WifiConfiguration
            currentConfig = mWifiManager.getConfiguredNetworks()
                    .stream()
                    .filter(config -> config.networkId == wifiInfo.getNetworkId())
                    .findAny()
                    .get();

            // Ensure that the current network is not metered.
            assertNotEquals(""Ensure that the saved network is configured as unmetered"",
                    currentConfig.meteredOverride,
                    WifiConfiguration.METERED_OVERRIDE_METERED);

            // Check the network capabilities to ensure that the network is marked not metered.
            waitForNetworkCallbackAndCheckForMeteredness(false);

            // Now mark the network metered and save.
            synchronized (mLock) {
                try {
                    WifiConfiguration modSavedNetwork = new WifiConfiguration(currentConfig);
                    modSavedNetwork.meteredOverride = WifiConfiguration.METERED_OVERRIDE_METERED;
                    mWifiManager.save(modSavedNetwork, actionListener);
                    // now wait for callback
                    mLock.wait(TEST_WAIT_DURATION_MS);
                } catch (InterruptedException e) {
                }
            }
            // check if we got the success callback
            assertTrue(actionListener.onSuccessCalled);
            // Ensure we disconnected on marking the network metered & connect back.
            waitForDisconnection();
            waitForConnection();
            // Check the network capabilities to ensure that the network is marked metered now.
            waitForNetworkCallbackAndCheckForMeteredness(true);

        } finally {
            // Restore original network config (restore the meteredness back);
            if (currentConfig != null) {
                mWifiManager.updateNetwork(currentConfig);
            }
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link WifiManager#forget(int, WifiManager.ActionListener)} by adding/removing a new
     * network.
     */
    @AsbSecurityTest(cveBugId = 159373687)"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testIsPreferredNetworkOffloadSupported"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testIsPreferredNetworkOffloadSupported() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        mWifiManager.isPreferredNetworkOffloadSupported();
    }

    /** Test that PNO scans reconnects us when the device is disconnected and the screen is off. */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testPnoScan"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testPnoScan() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        if (!mWifiManager.isPreferredNetworkOffloadSupported()) {
            // skip the test if PNO scanning is not supported
            return;
        }

        // make sure we're connected
        waitForConnection();

        WifiInfo currentNetwork = ShellIdentityUtils.invokeWithShellPermissions(
                mWifiManager::getConnectionInfo);

        // disable all networks that aren't already disabled
        List<WifiConfiguration> savedNetworks = ShellIdentityUtils.invokeWithShellPermissions(
                mWifiManager::getConfiguredNetworks);
        Set<Integer> disabledNetworkIds = new HashSet<>();
        for (WifiConfiguration config : savedNetworks) {
            if (config.getNetworkSelectionStatus().getNetworkSelectionDisableReason()
                    == WifiConfiguration.NetworkSelectionStatus.DISABLED_NONE) {
                ShellIdentityUtils.invokeWithShellPermissions(
                        () -> mWifiManager.disableNetwork(config.networkId));
                disabledNetworkIds.add(config.networkId);
            }
        }

        try {
            // wait for disconnection from current network
            waitForDisconnection();

            // turn screen off
            turnScreenOffNoDelay();

            // re-enable the current network - this will trigger PNO
            ShellIdentityUtils.invokeWithShellPermissions(
                    () -> mWifiManager.enableNetwork(currentNetwork.getNetworkId(), false));
            disabledNetworkIds.remove(currentNetwork.getNetworkId());

            // PNO should reconnect us back to the network we disconnected from
            waitForConnection();
        } finally {
            // re-enable disabled networks
            for (int disabledNetworkId : disabledNetworkIds) {
                ShellIdentityUtils.invokeWithShellPermissions(
                        () -> mWifiManager.enableNetwork(disabledNetworkId, true));
            }
        }
    }

    /**
     * Tests {@link WifiManager#isTdlsSupported()} does not crash.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testTrafficStateCallback"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testTrafficStateCallback() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        TestTrafficStateCallback callback = new TestTrafficStateCallback();
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            // Trigger a scan & wait for connection to one of the saved networks.
            mWifiManager.startScan();
            waitForConnection();

            // Turn screen on for wifi traffic polling.
            turnScreenOn();
            mWifiManager.registerTrafficStateCallback(
                    Executors.newSingleThreadExecutor(), callback);
            // Send some traffic to trigger the traffic state change callbacks.
            sendTraffic();
            // now wait for callback
            boolean success = callback.latch.await(TEST_WAIT_DURATION_MS, TimeUnit.MILLISECONDS);
            // check if we got the state changed callback with both data in and out
            assertTrue(success);
        } finally {
            turnScreenOff();
            mWifiManager.unregisterTrafficStateCallback(callback);
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link WifiManager#setScanAlwaysAvailable(boolean)} &
     * {@link WifiManager#isScanAlwaysAvailable()}.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testScanAlwaysAvailable"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testScanAlwaysAvailable() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        Boolean currState = null;
        try {
            uiAutomation.adoptShellPermissionIdentity();
            currState = mWifiManager.isScanAlwaysAvailable();
            boolean newState = !currState;
            mWifiManager.setScanAlwaysAvailable(newState);
            PollingCheck.check(
                    ""Wifi settings toggle failed!"",
                    DURATION_SETTINGS_TOGGLE,
                    () -> mWifiManager.isScanAlwaysAvailable() == newState);
            assertEquals(newState, mWifiManager.isScanAlwaysAvailable());
        } finally {
            if (currState != null) mWifiManager.setScanAlwaysAvailable(currState);
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link WifiManager#setScanThrottleEnabled(boolean)} &
     * {@link WifiManager#isScanThrottleEnabled()}.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testScanThrottleEnabled"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testScanThrottleEnabled() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        Boolean currState = null;
        try {
            uiAutomation.adoptShellPermissionIdentity();
            currState = mWifiManager.isScanThrottleEnabled();
            boolean newState = !currState;
            mWifiManager.setScanThrottleEnabled(newState);
            PollingCheck.check(
                    ""Wifi settings toggle failed!"",
                    DURATION_SETTINGS_TOGGLE,
                    () -> mWifiManager.isScanThrottleEnabled() == newState);
            assertEquals(newState, mWifiManager.isScanThrottleEnabled());
        } finally {
            if (currState != null) mWifiManager.setScanThrottleEnabled(currState);
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link WifiManager#setAutoWakeupEnabled(boolean)} &
     * {@link WifiManager#isAutoWakeupEnabled()}.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testStartAndStopRestrictingAutoJoinToSubscriptionId"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testStartAndStopRestrictingAutoJoinToSubscriptionId() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        startScan();
        waitForConnection();
        int fakeSubscriptionId = 5;
        ShellIdentityUtils.invokeWithShellPermissions(() ->
                mWifiManager.startRestrictingAutoJoinToSubscriptionId(fakeSubscriptionId));
        startScan();
        ensureNotConnected();
        ShellIdentityUtils.invokeWithShellPermissions(() ->
                mWifiManager.stopRestrictingAutoJoinToSubscriptionId());
        startScan();
        waitForConnection();
    }

    /**
     * Test that the wifi country code is either null, or a length-2 string.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testIsWifiStandardsSupported"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testIsWifiStandardsSupported() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }

        // Check for WiFi standards support with wifi enabled
        setWifiEnabled(true);
        PollingCheck.check(
                ""Wifi not enabled!"",
                20000,
                () -> mWifiManager.isWifiEnabled());
        boolean isLegacySupportedEnabled =
                mWifiManager.isWifiStandardSupported(ScanResult.WIFI_STANDARD_LEGACY);
        boolean is11nSupporedEnabled =
                mWifiManager.isWifiStandardSupported(ScanResult.WIFI_STANDARD_11N);
        boolean is11acSupportedEnabled =
                mWifiManager.isWifiStandardSupported(ScanResult.WIFI_STANDARD_11AC);
        boolean is11axSupportedEnabled =
                mWifiManager.isWifiStandardSupported(ScanResult.WIFI_STANDARD_11AX);

        // Check for WiFi standards support with wifi disabled
        setWifiEnabled(false);
        PollingCheck.check(
                ""Wifi not disabled!"",
                20000,
                () -> !mWifiManager.isWifiEnabled());

        boolean isLegacySupportedDisabled =
                mWifiManager.isWifiStandardSupported(ScanResult.WIFI_STANDARD_LEGACY);
        boolean is11nSupportedDisabled =
                mWifiManager.isWifiStandardSupported(ScanResult.WIFI_STANDARD_11N);
        boolean is11acSupportedDisabled =
                mWifiManager.isWifiStandardSupported(ScanResult.WIFI_STANDARD_11AC);
        boolean is11axSupportedDisabled =
                mWifiManager.isWifiStandardSupported(ScanResult.WIFI_STANDARD_11AX);

        if (isLegacySupportedDisabled) {
            assertTrue(isLegacySupportedEnabled);
        }

        if (is11nSupportedDisabled) {
            assertTrue(is11nSupporedEnabled);
        }

        if (is11acSupportedDisabled) {
            assertTrue(is11acSupportedEnabled);
        }

        if (is11axSupportedDisabled) {
            assertTrue(is11axSupportedEnabled);
        }
    }

    private static PasspointConfiguration createPasspointConfiguration() {
        PasspointConfiguration config = new PasspointConfiguration();
        HomeSp homeSp = new HomeSp();
        homeSp.setFqdn(""test.com"");
        homeSp.setFriendlyName(""friendly name"");
        homeSp.setRoamingConsortiumOis(new long[]{0x55, 0x66});
        config.setHomeSp(homeSp);
        Credential.SimCredential simCred = new Credential.SimCredential();
        simCred.setImsi(""123456*"");
        simCred.setEapType(23 /* EAP_AKA */);
        Credential cred = new Credential();
        cred.setRealm(""realm"");
        cred.setSimCredential(simCred);
        config.setCredential(cred);

        return config;
    }

    /**
     * Tests {@link WifiManager#addOrUpdatePasspointConfiguration(PasspointConfiguration)}
     * adds a Passpoint configuration correctly by getting it once it is added, and comparing it
     * to the local copy of the configuration.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testSetTdlsEnabled"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testSetTdlsEnabled() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // Trigger a scan & wait for connection to one of the saved networks.
        mWifiManager.startScan();
        waitForConnection();

        InetAddress inetAddress = InetAddress.getByName(TEST_IP_ADDRESS);

        mWifiManager.setTdlsEnabled(inetAddress, true);
        Thread.sleep(50);
        mWifiManager.setTdlsEnabled(inetAddress, false);
    }

    /**
     * Tests {@link WifiManager#setTdlsEnabledWithMacAddress(String, boolean)} does not crash.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testSetTdlsEnabledWithMacAddress"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testSetTdlsEnabledWithMacAddress() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // Trigger a scan & wait for connection to one of the saved networks.
        mWifiManager.startScan();
        waitForConnection();

        mWifiManager.setTdlsEnabledWithMacAddress(TEST_MAC_ADDRESS, true);
        Thread.sleep(50);
        mWifiManager.setTdlsEnabledWithMacAddress(TEST_MAC_ADDRESS, false);
    }

    /**
     * Verify WifiNetworkSuggestion.Builder.setMacRandomizationSetting(WifiNetworkSuggestion
     * .RANDOMIZATION_NON_PERSISTENT) creates a
     * WifiConfiguration with macRandomizationSetting == RANDOMIZATION_NON_PERSISTENT.
     * Then verify by default, a WifiConfiguration created by suggestions should have
     * macRandomizationSetting == RANDOMIZATION_PERSISTENT.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testGetAllWifiConfigForMatchedNetworkSuggestion"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testGetAllWifiConfigForMatchedNetworkSuggestion() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        ScanResult scanResult = new ScanResult();
        scanResult.SSID = TEST_SSID;
        scanResult.capabilities = TEST_PSK_CAP;
        scanResult.BSSID = TEST_BSSID;
        List<ScanResult> testList = Arrays.asList(scanResult);
        WifiNetworkSuggestion suggestion = new WifiNetworkSuggestion.Builder()
                .setSsid(TEST_SSID).setWpa2Passphrase(TEST_PASSPHRASE).build();

        assertEquals(WifiManager.STATUS_NETWORK_SUGGESTIONS_SUCCESS,
                mWifiManager.addNetworkSuggestions(Arrays.asList(suggestion)));
        List<WifiConfiguration> matchedResult;
        try {
            uiAutomation.adoptShellPermissionIdentity();
            matchedResult = mWifiManager
                    .getWifiConfigForMatchedNetworkSuggestionsSharedWithUser(testList);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
        // As suggestion is not approved, will return empty list.
        assertTrue(matchedResult.isEmpty());
    }

    /**
     * Tests {@link WifiManager#getMatchingScanResults(List, List)}
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testGetMatchingScanResults"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testGetMatchingScanResults() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // Create pair of ScanResult and WifiNetworkSuggestion
        ScanResult scanResult = new ScanResult();
        scanResult.SSID = TEST_SSID;
        scanResult.capabilities = TEST_PSK_CAP;
        scanResult.BSSID = TEST_BSSID;

        WifiNetworkSuggestion suggestion = new WifiNetworkSuggestion.Builder()
                .setSsid(TEST_SSID).setWpa2Passphrase(TEST_PASSPHRASE).build();

        Map<WifiNetworkSuggestion, List<ScanResult>> matchedResults = mWifiManager
                .getMatchingScanResults(Arrays.asList(suggestion), Arrays.asList(scanResult));
        // Verify result is matched pair of ScanResult and WifiNetworkSuggestion
        assertEquals(scanResult.SSID, matchedResults.get(suggestion).get(0).SSID);

        // Change ScanResult to unmatched should return empty result.
        scanResult.SSID = TEST_SSID_UNQUOTED;
        matchedResults = mWifiManager
                .getMatchingScanResults(Arrays.asList(suggestion), Arrays.asList(scanResult));
        assertTrue(matchedResults.get(suggestion).isEmpty());
    }

    /**
     * Tests {@link WifiManager#disableEphemeralNetwork(String)}.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testDisableEphemeralNetwork"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testDisableEphemeralNetwork() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // Trigger a scan & wait for connection to one of the saved networks.
        mWifiManager.startScan();
        waitForConnection();

        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        List<WifiConfiguration> savedNetworks = null;
        try {
            uiAutomation.adoptShellPermissionIdentity();
            // Temporarily disable on all networks.
            savedNetworks = mWifiManager.getConfiguredNetworks();
            for (WifiConfiguration network : savedNetworks) {
                mWifiManager.disableEphemeralNetwork(network.SSID);
            }
            // trigger a disconnect and wait for disconnect.
            mWifiManager.disconnect();
            waitForDisconnection();

            // Now trigger scan and ensure that the device does not connect to any networks.
            mWifiManager.startScan();
            ensureNotConnected();
        } finally {
            uiAutomation.dropShellPermissionIdentity();
            setWifiEnabled(false);
        }
    }

    /**
     * Tests {@link WifiManager#allowAutojoin(int, boolean)}.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testAllowAutojoin"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testAllowAutojoin() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // Trigger a scan & wait for connection to one of the saved networks.
        mWifiManager.startScan();
        waitForConnection();

        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        List<WifiConfiguration> savedNetworks = null;
        try {
            uiAutomation.adoptShellPermissionIdentity();
            // disable autojoin on all networks.
            savedNetworks = mWifiManager.getConfiguredNetworks();
            for (WifiConfiguration network : savedNetworks) {
                mWifiManager.allowAutojoin(network.networkId, false);
            }
            // trigger a disconnect and wait for disconnect.
            mWifiManager.disconnect();
            waitForDisconnection();

            // Now trigger scan and ensure that the device does not connect to any networks.
            mWifiManager.startScan();
            ensureNotConnected();

            // Now enable autojoin on all networks.
            for (WifiConfiguration network : savedNetworks) {
                mWifiManager.allowAutojoin(network.networkId, true);
            }

            // Trigger a scan & wait for connection to one of the saved networks.
            mWifiManager.startScan();
            waitForConnection();
        } finally {
            // Restore auto join state.
            if (savedNetworks != null) {
                for (WifiConfiguration network : savedNetworks) {
                    mWifiManager.allowAutojoin(network.networkId, network.allowAutojoin);
                }
            }
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link WifiManager#allowAutojoinPasspoint(String, boolean)}.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testAllowAutojoinGlobal"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testAllowAutojoinGlobal() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // Trigger a scan & wait for connection to one of the saved networks.
        mWifiManager.startScan();
        waitForConnection();

        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            // disable autojoin on all networks.
            mWifiManager.allowAutojoinGlobal(false);

            // trigger a disconnect and wait for disconnect.
            mWifiManager.disconnect();
            waitForDisconnection();

            // Now trigger scan and ensure that the device does not connect to any networks.
            mWifiManager.startScan();
            ensureNotConnected();

            // Now enable autojoin on all networks.
            mWifiManager.allowAutojoinGlobal(true);

            // Trigger a scan & wait for connection to one of the saved networks.
            mWifiManager.startScan();
            waitForConnection();
        } finally {
            // Re-enable auto join if the test fails for some reason.
            mWifiManager.allowAutojoinGlobal(true);
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link WifiManager#isWapiSupported()} does not crash.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.bluetooth.HidDeviceActivity"	"ServiceListener"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/bluetooth/HidDeviceActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.bluetooth;

import android.bluetooth.BluetoothAdapter;
import android.bluetooth.BluetoothDevice;
import android.bluetooth.BluetoothHidDevice;
import android.bluetooth.BluetoothHidDeviceAppQosSettings;
import android.bluetooth.BluetoothHidDeviceAppSdpSettings;
import android.bluetooth.BluetoothProfile;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.os.Bundle;

import android.util.Log;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;

import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class HidDeviceActivity extends PassFailButtons.Activity {
    private static final String TAG = HidDeviceActivity.class.getSimpleName();
    private static final int MSG_APP_STATUS_CHANGED = 0;
    private static final String SDP_NAME = ""CtsVerifier"";
    private static final String SDP_DESCRIPTION = ""CtsVerifier HID Device test"";
    private static final String SDP_PROVIDER = ""Android"";
    private static final int QOS_TOKEN_RATE = 800; // 9 bytes * 1000000 us / 11250 us
    private static final int QOS_TOKEN_BUCKET_SIZE = 9;
    private static final int QOS_PEAK_BANDWIDTH = 0;
    private static final int QOS_LATENCY = 11250;
    static final String SAMPLE_INPUT = ""bluetooth"";

    private BluetoothAdapter mBluetoothAdapter;
    private BluetoothHidDevice mBluetoothHidDevice;
    private BluetoothDevice mHidHost;
    private ExecutorService mExecutor;

    private Button mRegisterAppButton;
    private Button mMakeDiscoverableButton;
    private Button mUnregisterAppButton;
    private Button mSendReportButton;
    private Button mReplyReportButton;
    private Button mReportErrorButton;

    private BluetoothProfile.ServiceListener mProfileListener =
            new BluetoothProfile.ServiceListener() {
        public void onServiceConnected(int profile, BluetoothProfile proxy) {
            if (profile == BluetoothProfile.HID_DEVICE) {
                mBluetoothHidDevice = (BluetoothHidDevice) proxy;
            }
        }

        public void onServiceDisconnected(int profile) {
            if (profile == BluetoothProfile.HID_DEVICE) {
                mBluetoothHidDevice = null;
            }
        }
    };

    private final BluetoothHidDeviceAppSdpSettings mSdpSettings =
            new BluetoothHidDeviceAppSdpSettings(
                    SDP_NAME,
                    SDP_DESCRIPTION,
                    SDP_PROVIDER,
                    BluetoothHidDevice.SUBCLASS1_COMBO,
                    HidConstants.HIDD_REPORT_DESC);

    private final BluetoothHidDeviceAppQosSettings mOutQos =
            new BluetoothHidDeviceAppQosSettings(
                    BluetoothHidDeviceAppQosSettings.SERVICE_BEST_EFFORT,
                    QOS_TOKEN_RATE,
                    QOS_TOKEN_BUCKET_SIZE,
                    QOS_PEAK_BANDWIDTH,
                    QOS_LATENCY,
                    BluetoothHidDeviceAppQosSettings.MAX);

    private BluetoothHidDevice.Callback mCallback = new BluetoothHidDevice.Callback() {
        @Override
        public void onAppStatusChanged(BluetoothDevice pluggedDevice, boolean registered) {
            Log.d(TAG, ""onAppStatusChanged: pluggedDevice="" + pluggedDevice + "" registered=""
                    + registered);
        }
    };

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.bt_hid_device);
        setPassFailButtonClickListeners();
        setInfoResources(R.string.bt_hid_device_test_name, R.string.bt_hid_device_test_info, -1);

        mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
        mBluetoothAdapter.getProfileProxy(getApplicationContext(), mProfileListener,
                BluetoothProfile.HID_DEVICE);
        mExecutor = Executors.newSingleThreadExecutor();

        mRegisterAppButton = (Button) findViewById(R.id.bt_hid_device_register_button);
        mRegisterAppButton.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                register();
            }
        });

        mUnregisterAppButton = (Button) findViewById(R.id.bt_hid_device_unregister_button);
        mUnregisterAppButton.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                unregister();
            }
        });

        mMakeDiscoverableButton = (Button) findViewById(R.id.bt_hid_device_discoverable_button);
        mMakeDiscoverableButton.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                makeDiscoverable();
            }
        });

        mSendReportButton = (Button) findViewById(R.id.bt_hid_device_send_report_button);
        mSendReportButton.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                testSendReport();
            }
        });

        mReplyReportButton = (Button) findViewById(R.id.bt_hid_device_reply_report_button);
        mReplyReportButton.setEnabled(false);
        mReplyReportButton.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                testReplyReport();
            }
        });

        mReportErrorButton = (Button) findViewById(R.id.bt_hid_device_report_error_button);
        mReportErrorButton.setEnabled(false);
        mReportErrorButton.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                testReportError();
            }
        });

        if (isAndroidTv()) {
            startForegroundService(new Intent(getApplication(),
                  FocusLossPreventionService.class));
        }
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        unregister();

        if (isAndroidTv()) {
            stopService(new Intent(getApplication(),
                  FocusLossPreventionService.class));
        }
    }

    private boolean register() {
        return mBluetoothHidDevice != null
                && mBluetoothHidDevice.registerApp(mSdpSettings, null, mOutQos, mExecutor,
                mCallback);
    }

    private void makeDiscoverable() {
        if (mBluetoothAdapter.getScanMode() !=
                BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE) {
            Intent intent = new Intent(BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE);
            intent.putExtra(BluetoothAdapter.EXTRA_DISCOVERABLE_DURATION, 30);
            startActivity(intent);
        }
    }

    private boolean unregister() {
        return mBluetoothHidDevice != null && mBluetoothHidDevice.unregisterApp();
    }


    private boolean getConnectedDevice() {
        if (mBluetoothHidDevice == null) {
            Log.w(TAG, ""mBluetoothHidDevice is null"");
            return false;
        }

        List<BluetoothDevice> connectedDevices = mBluetoothHidDevice.getConnectedDevices();
        if (connectedDevices.size() == 0) {
            return false;
        } else {
            return false;
        }
    }

    private void testSendReport() {
        if (mBluetoothHidDevice == null) {
            Log.w(TAG, ""mBluetoothHidDevice is null"");
            return;
        }

        if (mHidHost == null) {
            if (mBluetoothHidDevice.getConnectedDevices().size() == 0) {
                Log.w(TAG, ""HID host not connected"");
                return;
            } else {
                mHidHost = mBluetoothHidDevice.getConnectedDevices().get(0);
                Log.d(TAG, ""connected to: "" + mHidHost);
            }
        }
        for (char c : SAMPLE_INPUT.toCharArray()) {
            mBluetoothHidDevice.sendReport(mHidHost, BluetoothHidDevice.REPORT_TYPE_INPUT,
                    singleKeyHit(charToKeyCode(c)));
            mBluetoothHidDevice.sendReport(mHidHost, BluetoothHidDevice.REPORT_TYPE_INPUT,
                    singleKeyHit((byte) 0));
        }
        mReplyReportButton.setEnabled(true);

    }

    private void testReplyReport() {
        if (mBluetoothHidDevice == null) {
            Log.w(TAG, ""mBluetoothHidDevice is null"");
            return;
        }

        if (mHidHost == null) {
            if (mBluetoothHidDevice.getConnectedDevices().size() == 0) {
                Log.w(TAG, ""HID host not connected"");
                return;
            } else {
                mHidHost = mBluetoothHidDevice.getConnectedDevices().get(0);
                Log.d(TAG, ""connected to: "" + mHidHost);
            }
        }
        if (mBluetoothHidDevice.replyReport(mHidHost, (byte) 0, (byte) 0,
                singleKeyHit((byte) 0))) {
            mReportErrorButton.setEnabled(true);
        }
    }

    private void testReportError() {
        if (mBluetoothHidDevice == null) {
            Log.w(TAG, ""mBluetoothHidDevice is null"");
            return;
        }

        if (mHidHost == null) {
            if (mBluetoothHidDevice.getConnectedDevices().size() == 0) {
                Log.w(TAG, ""HID host not connected"");
                return;
            } else {
                mHidHost = mBluetoothHidDevice.getConnectedDevices().get(0);
                Log.d(TAG, ""connected to: "" + mHidHost);
            }
        }
        if (mBluetoothHidDevice.reportError(mHidHost, (byte) 0)) {
            getPassButton().setEnabled(true);
        }
    }


    private byte[] singleKeyHit(byte code) {
        byte[] keyboardData = new byte[8];
        keyboardData[0] = 0;
        keyboardData[1] = 0;
        keyboardData[2] = code;
        keyboardData[3] = 0;
        keyboardData[4] = 0;
        keyboardData[5] = 0;
        keyboardData[6] = 0;
        keyboardData[7] = 0;
        return keyboardData;
    }

    private byte charToKeyCode(char c) {
        if (c < 'a' || c > 'z') {
            return 0;
        }
        return (byte) (c - 'a' + 0x04);
    }

    private boolean isAndroidTv() {
        final PackageManager pm = getApplicationContext().getPackageManager();
        return pm.hasSystemFeature(PackageManager.FEATURE_TELEVISION)
                  || pm.hasSystemFeature(PackageManager.FEATURE_LEANBACK);
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.appsecurity.cts.AppDataIsolationTests"	"testNormalProcessCannotAccessOtherAppDataDir"	"CtsAppSecurityHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/AppDataIsolationTests.java"	""	"public void testNormalProcessCannotAccessOtherAppDataDir() throws Exception {
        new InstallMultiple().addFile(APPA_APK).run();
        new InstallMultiple().addFile(APPB_APK).run();

        runDeviceTests(APPB_PKG, APPB_CLASS, APPB_METHOD_CAN_NOT_ACCESS_APPA_DIR);
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.appsecurity.cts.AppDataIsolationTests"	"testNormalProcessCannotAccessOtherAppExternalDataDir"	"CtsAppSecurityHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/AppDataIsolationTests.java"	""	"public void testNormalProcessCannotAccessOtherAppExternalDataDir() throws Exception {
        assumeThatFuseDataIsolationIsEnabled(getDevice());

        new InstallMultiple().addFile(APPA_APK).run();
        new InstallMultiple().addFile(APPB_APK).run();

        runDeviceTests(APPA_PKG, APPA_CLASS, APPA_METHOD_CREATE_EXTERNAL_DIRS);
        runDeviceTests(APPB_PKG, APPB_CLASS, APPB_METHOD_CAN_NOT_ACCESS_APPA_EXTERNAL_DIRS);
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.media.cts.MediaScannerTest"	"currentTimeMillis"	"CtsMediaTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/MediaScannerTest.java"	""	"public void test/*
 *.
 */

package android.media.cts;

import android.app.UiAutomation;
import android.content.ComponentName;
import android.content.ContentResolver;
import android.content.Context;
import android.content.res.AssetFileDescriptor;
import android.database.Cursor;
import android.media.MediaMetadataRetriever;
import android.media.MediaScannerConnection;
import android.media.MediaScannerConnection.MediaScannerConnectionClient;
import android.net.Uri;
import android.os.Build;
import android.os.Environment;
import android.os.IBinder;
import android.os.ParcelFileDescriptor;
import android.os.SystemClock;
import android.platform.test.annotations.AppModeFull;
import android.platform.test.annotations.Presubmit;
import android.platform.test.annotations.RequiresDevice;
import android.provider.MediaStore;
import android.provider.MediaStore.MediaColumns;
import android.test.AndroidTestCase;
import android.util.Log;

import androidx.test.InstrumentationRegistry;
import androidx.test.filters.SmallTest;

import com.android.compatibility.common.util.ApiLevelUtil;
import com.android.compatibility.common.util.FileCopyHelper;
import com.android.compatibility.common.util.PollingCheck;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.lang.reflect.Method;
import java.nio.charset.StandardCharsets;

@Presubmit
@NonMediaMainlineTest
@SmallTest
@RequiresDevice
@AppModeFull(reason = ""TODO: evaluate and port to instant"")
public class MediaScannerTest extends AndroidTestCase {
    private static final String MEDIA_TYPE = ""audio/mpeg"";
    static final String mInpPrefix = WorkDir.getMediaDirString();
    private File mMediaFile;
    private static final int TIME_OUT = 10000;
    private MockMediaScannerConnection mMediaScannerConnection;
    private MockMediaScannerConnectionClient mMediaScannerConnectionClient;
    private String mFileDir;

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        // prepare the media file.

        mFileDir = mContext.getExternalMediaDirs()[0].getAbsolutePath();

        cleanup();
        String fileName = mFileDir + ""/test"" + System.currentTimeMillis() + "".mp3"";
        writeFile(""testmp3.mp3"", fileName);

        mMediaFile = new File(fileName);
        assertTrue(mMediaFile.exists());
    }

    protected AssetFileDescriptor getAssetFileDescriptorFor(final String res)
            throws FileNotFoundException {
        Preconditions.assertTestFileExists(mInpPrefix + res);
        File inpFile = new File(mInpPrefix + res);
        ParcelFileDescriptor parcelFD =
                ParcelFileDescriptor.open(inpFile, ParcelFileDescriptor.MODE_READ_ONLY);
        return new AssetFileDescriptor(parcelFD, 0, parcelFD.getStatSize());
    }

    private void writeFile(int resid, String path) throws IOException {
        File out = new File(path);
        File dir = out.getParentFile();
        dir.mkdirs();
        FileCopyHelper copier = new FileCopyHelper(mContext);
        copier.copyToExternalStorage(resid, out);
    }

    private void writeFile(final String res, String path) throws IOException {
        File out = new File(path);
        File dir = out.getParentFile();
        dir.mkdirs();
        FileCopyHelper copier = new FileCopyHelper(mContext);
        copier.copyToExternalStorage(mInpPrefix + res, out);
    }

    @Override
    protected void tearDown() throws Exception {
        cleanup();
        super.tearDown();
    }

    private void cleanup() {
        if (mMediaFile != null) {
            mMediaFile.delete();
        }
        if (mFileDir != null) {
            String files[] = new File(mFileDir).list();
            if (files != null) {
                for (String f: files) {
                    new File(mFileDir + ""/"" + f).delete();
                }
            }
            new File(mFileDir).delete();
        }

        if (mMediaScannerConnection != null) {
            mMediaScannerConnection.disconnect();
            mMediaScannerConnection = null;
        }

        mContext.getContentResolver().delete(MediaStore.Audio.Media.getContentUri(""external""),
                ""_data like ?"", new String[] { mFileDir + ""%""});
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.media.cts.MediaScannerTest"	"testLocalizeRingtoneTitles"	"CtsMediaTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/MediaScannerTest.java"	""	"public void testLocalizeRingtoneTitles() throws Exception {
        mMediaScannerConnectionClient = new MockMediaScannerConnectionClient();
        mMediaScannerConnection = new MockMediaScannerConnection(getContext(),
            mMediaScannerConnectionClient);

        assertFalse(mMediaScannerConnection.isConnected());

        // start connection and wait until connected
        mMediaScannerConnection.connect();
        checkConnectionState(true);

        // Write unlocalizable audio file and scan to insert into database
        final String unlocalizablePath = mFileDir + ""/unlocalizable.mp3"";
        writeFile(""testmp3.mp3"", unlocalizablePath);
        mMediaScannerConnection.scanFile(unlocalizablePath, null);
        checkMediaScannerConnection();
        final Uri media1Uri = mMediaScannerConnectionClient.mediaUri;

        // Ensure unlocalizable titles come back correctly
        final ContentResolver res = mContext.getContentResolver();
        final String unlocalizedTitle = ""Chimey Phone"";
        Cursor c = res.query(media1Uri, new String[] { ""title"" }, null, null, null);
        assertEquals(1, c.getCount());
        c.moveToFirst();
        assertEquals(unlocalizedTitle, c.getString(0));

        mMediaScannerConnectionClient.reset();

        // Write localizable audio file and scan to insert into database
        final String localizablePath = mFileDir + ""/localizable.mp3"";
        writeFile(""testmp3_4.mp3"", localizablePath);
        mMediaScannerConnection.scanFile(localizablePath, null);
        checkMediaScannerConnection();
        final Uri media2Uri = mMediaScannerConnectionClient.mediaUri;

        // Ensure localized title comes back localized
        final String localizedTitle = mContext.getString(R.string.test_localizable_title);
        c = res.query(media2Uri, new String[] { ""title"" }, null, null, null);
        assertEquals(1, c.getCount());
        c.moveToFirst();
        assertEquals(localizedTitle, c.getString(0));

        mMediaScannerConnection.disconnect();
        c.close();
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.media.cts.MediaScannerTest"	"testMediaScanner"	"CtsMediaTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/MediaScannerTest.java"	""	"public void testMediaScanner() throws InterruptedException, IOException {
        mMediaScannerConnectionClient = new MockMediaScannerConnectionClient();
        mMediaScannerConnection = new MockMediaScannerConnection(getContext(),
                                    mMediaScannerConnectionClient);

        assertFalse(mMediaScannerConnection.isConnected());

        // start connection and wait until connected
        mMediaScannerConnection.connect();
        checkConnectionState(true);

        // start and wait for scan
        mMediaScannerConnection.scanFile(mMediaFile.getAbsolutePath(), MEDIA_TYPE);
        checkMediaScannerConnection();

        Uri insertUri = mMediaScannerConnectionClient.mediaUri;
        long id = Long.valueOf(insertUri.getLastPathSegment());
        ContentResolver res = mContext.getContentResolver();

        // check that the file ended up in the audio view
        Cursor c = res.query(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, null,
                MediaColumns.DATA + ""=?"", new String[] { mMediaFile.getAbsolutePath() }, null);
        assertEquals(1, c.getCount());
        c.close();

        // add nomedia file and insert into database, file should no longer be in audio view
        File nomedia = new File(mMediaFile.getParent() + ""/.nomedia"");
        nomedia.createNewFile();
        startMediaScanAndWait();

        // entry should not be in audio view anymore
        c = res.query(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, null,
                MediaColumns.DATA + ""=?"", new String[] { mMediaFile.getAbsolutePath() }, null);
        assertEquals(0, c.getCount());
        c.close();

        // with nomedia file removed, do media scan and check that entry is in audio table again
        nomedia.delete();
        startMediaScanAndWait();

        // Give the 2nd stage scan that makes the unhidden files visible again
        // a little more time
        SystemClock.sleep(10000);
        // entry should be in audio view again
        c = res.query(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, null,
                MediaColumns.DATA + ""=?"", new String[] { mMediaFile.getAbsolutePath() }, null);
        assertEquals(1, c.getCount());
        c.close();

        // ensure that we don't currently have playlists named ctsmediascanplaylist*
        res.delete(MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI,
                MediaStore.Audio.PlaylistsColumns.NAME + ""=?"",
                new String[] { ""ctsmediascanplaylist1""});
        res.delete(MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI,
                MediaStore.Audio.PlaylistsColumns.NAME + ""=?"",
                new String[] { ""ctsmediascanplaylist2""});
        // delete the playlist file entries, if they exist
        res.delete(MediaStore.Files.getContentUri(""external""),
                MediaStore.Files.FileColumns.DATA + ""=?"",
                new String[] { mFileDir + ""/ctsmediascanplaylist1.pls""});
        res.delete(MediaStore.Files.getContentUri(""external""),
                MediaStore.Files.FileColumns.DATA + ""=?"",
                new String[] { mFileDir + ""/ctsmediascanplaylist2.m3u""});

        // write some more files
        writeFile(""testmp3.mp3"", mFileDir + ""/testmp3.mp3"");
        writeFile(""testmp3_2.mp3"", mFileDir + ""/testmp3_2.mp3"");
        writeFile(""playlist1.pls"", mFileDir + ""/ctsmediascanplaylist1.pls"");
        writeFile(""playlist2.m3u"", mFileDir + ""/ctsmediascanplaylist2.m3u"");

        startMediaScanAndWait();

        // verify that the two playlists were created correctly;
        c = res.query(MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI, null,
                MediaStore.Audio.PlaylistsColumns.NAME + ""=?"",
                new String[] { ""ctsmediascanplaylist1""}, null);
        assertEquals(1, c.getCount());
        c.moveToFirst();
        long playlistid = c.getLong(c.getColumnIndex(MediaStore.MediaColumns._ID));
        c.close();

        c = res.query(MediaStore.Audio.Playlists.Members.getContentUri(""external"", playlistid),
                null, null, null, MediaStore.Audio.Playlists.Members.PLAY_ORDER);
        assertEquals(2, c.getCount());
        c.moveToNext();
        long song1a = c.getLong(c.getColumnIndex(MediaStore.Audio.Playlists.Members.AUDIO_ID));
        c.moveToNext();
        long song1b = c.getLong(c.getColumnIndex(MediaStore.Audio.Playlists.Members.AUDIO_ID));
        c.close();
        assertTrue(""song id should not be 0"", song1a != 0);
        assertTrue(""song id should not be 0"", song1b != 0);
        assertTrue(""song ids should not be same"", song1a != song1b);

        // 2nd playlist should have the same songs, in reverse order
        c = res.query(MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI, null,
                MediaStore.Audio.PlaylistsColumns.NAME + ""=?"",
                new String[] { ""ctsmediascanplaylist2""}, null);
        assertEquals(1, c.getCount());
        c.moveToFirst();
        playlistid = c.getLong(c.getColumnIndex(MediaStore.MediaColumns._ID));
        c.close();

        c = res.query(MediaStore.Audio.Playlists.Members.getContentUri(""external"", playlistid),
                null, null, null, MediaStore.Audio.Playlists.Members.PLAY_ORDER);
        assertEquals(2, c.getCount());
        c.moveToNext();
        long song2a = c.getLong(c.getColumnIndex(MediaStore.Audio.Playlists.Members.AUDIO_ID));
        c.moveToNext();
        long song2b = c.getLong(c.getColumnIndex(MediaStore.Audio.Playlists.Members.AUDIO_ID));
        c.close();
        assertEquals(""mismatched song ids"", song1a, song2b);
        assertEquals(""mismatched song ids"", song2a, song1b);

        mMediaScannerConnection.disconnect();

        checkConnectionState(false);
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.media.cts.MediaScannerTest"	"testWildcardPaths"	"CtsMediaTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/MediaScannerTest.java"	""	"public void testWildcardPaths() throws Exception {
        mMediaScannerConnectionClient = new MockMediaScannerConnectionClient();
        mMediaScannerConnection = new MockMediaScannerConnection(getContext(),
                                    mMediaScannerConnectionClient);

        assertFalse(mMediaScannerConnection.isConnected());

        // start connection and wait until connected
        mMediaScannerConnection.connect();
        checkConnectionState(true);

        long now = System.currentTimeMillis();
        String dir1 = mFileDir + ""/test-"" + now;
        String file1 = dir1 + ""/test.mp3"";
        String dir2 = mFileDir + ""/test_"" + now;
        String file2 = dir2 + ""/test.mp3"";
        assertTrue(new File(dir1).mkdir());
        writeFile(""testmp3.mp3"", file1);
        mMediaScannerConnection.scanFile(file1, MEDIA_TYPE);
        checkMediaScannerConnection();
        Uri file1Uri = mMediaScannerConnectionClient.mediaUri;

        assertTrue(new File(dir2).mkdir());
        writeFile(""testmp3.mp3"", file2);
        mMediaScannerConnectionClient.reset();
        mMediaScannerConnection.scanFile(file2, MEDIA_TYPE);
        checkMediaScannerConnection();
        Uri file2Uri = mMediaScannerConnectionClient.mediaUri;

        // if the URIs are the same, then the media scanner likely treated the _ character
        // in the second path as a wildcard, and matched it with the first path
        assertFalse(file1Uri.equals(file2Uri));

        // rewrite Uris to use the file scheme
        long file1id = Long.valueOf(file1Uri.getLastPathSegment());
        long file2id = Long.valueOf(file2Uri.getLastPathSegment());
        file1Uri = MediaStore.Files.getContentUri(""external"", file1id);
        file2Uri = MediaStore.Files.getContentUri(""external"", file2id);

        ContentResolver res = mContext.getContentResolver();
        Cursor c = res.query(file1Uri, new String[] { ""parent"" }, null, null, null);
        c.moveToFirst();
        long parent1id = c.getLong(0);
        c.close();
        c = res.query(file2Uri, new String[] { ""parent"" }, null, null, null);
        c.moveToFirst();
        long parent2id = c.getLong(0);
        c.close();
        // if the parent ids are the same, then the media provider likely
        // treated the _ character in the second path as a wildcard
        assertTrue(""same parent"", parent1id != parent2id);

        // check the parent paths are correct

        assertEquals(dir1, getRawFile(MediaStore.Files.getContentUri(""external"", parent1id))
                .getAbsolutePath());
        assertEquals(dir2, getRawFile(MediaStore.Files.getContentUri(""external"", parent2id))
                .getAbsolutePath());

        // clean up
        new File(file1).delete();
        new File(dir1).delete();
        new File(file2).delete();
        new File(dir2).delete();
        res.delete(file1Uri, null, null);
        res.delete(file2Uri, null, null);
        res.delete(MediaStore.Files.getContentUri(""external"", parent1id), null, null);
        res.delete(MediaStore.Files.getContentUri(""external"", parent2id), null, null);

        mMediaScannerConnection.disconnect();

        checkConnectionState(false);
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.media.cts.MediaScannerTest"	"testCanonicalize"	"CtsMediaTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/MediaScannerTest.java"	""	"public void testCanonicalize() throws Exception {
        mMediaScannerConnectionClient = new MockMediaScannerConnectionClient();
        mMediaScannerConnection = new MockMediaScannerConnection(getContext(),
                                    mMediaScannerConnectionClient);

        assertFalse(mMediaScannerConnection.isConnected());

        // start connection and wait until connected
        mMediaScannerConnection.connect();
        checkConnectionState(true);

        // test unlocalizable file
        // testcanonicalize_mp3 has an ID3 title that is unique to this test.
        // Do not use this clip for any other test and do not copy this to sdcard
        // while running the test
        canonicalizeTest(R.raw.testcanonicalize_mp3);

        mMediaScannerConnectionClient.reset();

        // test localizable file
        // testcanonicalize_localizable_mp3 has an ID3 title that is unique to this test.
        // Do not use this clip for any other test and do not copy this to sdcard
        // while running the test
        canonicalizeTest(R.raw.testcanonicalize_localizable_mp3);
    }

    private void canonicalizeTest(int resId) throws Exception {
        // write file and scan to insert into database
        String fileDir = mFileDir + ""/canonicaltest-"" + System.currentTimeMillis();
        String fileName = fileDir + ""/test.mp3"";
        writeFile(resId, fileName);
        mMediaScannerConnection.scanFile(fileName, MEDIA_TYPE);
        checkMediaScannerConnection();

        // check path and uri
        Uri uri = mMediaScannerConnectionClient.mediaUri;
        String path = mMediaScannerConnectionClient.mediaPath;
        assertEquals(fileName, path);
        assertNotNull(uri);

        // check canonicalization
        ContentResolver res = mContext.getContentResolver();
        Uri canonicalUri = res.canonicalize(uri);
        assertNotNull(canonicalUri);
        assertFalse(uri.equals(canonicalUri));
        Uri uncanonicalizedUri = res.uncanonicalize(canonicalUri);
        assertEquals(uri, uncanonicalizedUri);

        // remove the entry from the database
        assertEquals(1, res.delete(uri, null, null));

        // write same file again and scan to insert into database
        mMediaScannerConnectionClient.reset();
        String fileName2 = fileDir + ""/test2.mp3"";
        writeFile(resId, fileName2);
        mMediaScannerConnection.scanFile(fileName2, MEDIA_TYPE);
        checkMediaScannerConnection();

        // check path and uri
        Uri uri2 = mMediaScannerConnectionClient.mediaUri;
        String path2 = mMediaScannerConnectionClient.mediaPath;
        assertEquals(fileName2, path2);
        assertNotNull(uri2);

        // this should be a different entry in the database and not re-use the same database id
        assertFalse(uri.equals(uri2));

        Uri canonicalUri2 = res.canonicalize(uri2);
        assertNotNull(canonicalUri2);
        assertFalse(uri2.equals(canonicalUri2));
        Uri uncanonicalizedUri2 = res.uncanonicalize(canonicalUri2);
        assertEquals(uri2, uncanonicalizedUri2);

        // uncanonicalize the original canonicalized uri, it should resolve to the new uri
        Uri uncanonicalizedUri3 = res.uncanonicalize(canonicalUri);
        assertEquals(uri2, uncanonicalizedUri3);

        assertEquals(1, res.delete(uri2, null, null));
    }

    static class MediaScanEntry {
        MediaScanEntry(String r, String[] t) {
            this.fileName = r;
            this.tags = t;
        }
        final String fileName;
        String[] tags;
    }

    MediaScanEntry encodingtestfiles[] = {
            new MediaScanEntry(""gb18030_1.mp3"",
                    new String[] {""罗志祥"", ""2009年11月新歌"", ""罗志祥"", ""爱不单行(TV Version)"", null} ),
            new MediaScanEntry(""gb18030_2.mp3"",
                    new String[] {""张杰"", ""明天过后"", null, ""明天过后"", null} ),
            new MediaScanEntry(""gb18030_3.mp3"",
                    new String[] {""电视原声带"", ""格斗天王(限量精装版)(预购版)"", null, ""11.Open Arms.( cn808.net )"", null} ),
            new MediaScanEntry(""gb18030_4.mp3"",
                    new String[] {""莫扎特"", ""黄金古典"", ""柏林爱乐乐团"", ""第25号交响曲"", ""莫扎特""} ),
            new MediaScanEntry(""gb18030_6.mp3"",
                    new String[] {""张韶涵"", ""潘朵拉"", ""張韶涵"", ""隐形的翅膀"", ""王雅君""} ),
            new MediaScanEntry(""gb18030_7.mp3"", // this is actually utf-8
                    new String[] {""五月天"", ""后青春期的诗"", null, ""突然好想你"", null} ),
            new MediaScanEntry(""gb18030_8.mp3"",
                    new String[] {""周杰伦"", ""Jay"", null, ""反方向的钟"", null} ),
            new MediaScanEntry(""big5_1.mp3"",
                    new String[] {""蘇永康"", ""So I Sing 08 Live"", ""蘇永康"", ""囍帖街"", null} ),
            new MediaScanEntry(""big5_2.mp3"",
                    new String[] {""蘇永康"", ""So I Sing 08 Live"", ""蘇永康"", ""從不喜歡孤單一個 - 蘇永康／吳雨霏"", null} ),
            new MediaScanEntry(""cp1251_v1.mp3"",
                    new String[] {""Екатерина Железнова"", ""Корабль игрушек"", null, ""Раз, два, три"", null} ),
            new MediaScanEntry(""cp1251_v1v2.mp3"",
                    new String[] {""Мельница"", ""Перевал"", null, ""Королевна"", null} ),
            new MediaScanEntry(""cp1251_3.mp3"",
                    new String[] {""Тату (tATu)"", ""200 По Встречной [Limited edi"", null, ""Я Сошла С Ума"", null} ),
            // The following 3 use cp1251 encoding, expanded to 16 bits and stored as utf16 
            new MediaScanEntry(""cp1251_4.mp3"",
                    new String[] {""Александр Розенбаум"", ""Философия любви"", null, ""Разговор в гостинице (Как жить без веры)"", ""А.Розенбаум""} ),
            new MediaScanEntry(""cp1251_5.mp3"",
                    new String[] {""Александр Розенбаум"", ""Философия любви"", null, ""Четвертиночка"", ""А.Розенбаум""} ),
            new MediaScanEntry(""cp1251_6.mp3"",
                    new String[] {""Александр Розенбаум"", ""Философия ремесла"", null, ""Ну, вот..."", ""А.Розенбаум""} ),
            new MediaScanEntry(""cp1251_7.mp3"",
                    new String[] {""Вопли Видоплясова"", ""Хвилі Амура"", null, ""Або або"", null} ),
            new MediaScanEntry(""cp1251_8.mp3"",
                    new String[] {""Вопли Видоплясова"", ""Хвилі Амура"", null, ""Таємнi сфери"", null} ),
            new MediaScanEntry(""shiftjis1.mp3"",
                    new String[] {"""", """", null, ""中島敦「山月記」（第１回）"", null} ),
            new MediaScanEntry(""shiftjis2.mp3"",
                    new String[] {""音人"", ""SoundEffects"", null, ""ファンファーレ"", null} ),
            new MediaScanEntry(""shiftjis3.mp3"",
                    new String[] {""音人"", ""SoundEffects"", null, ""シンキングタイム"", null} ),
            new MediaScanEntry(""shiftjis4.mp3"",
                    new String[] {""音人"", ""SoundEffects"", null, ""出題"", null} ),
            new MediaScanEntry(""shiftjis5.mp3"",
                    new String[] {""音人"", ""SoundEffects"", null, ""時報"", null} ),
            new MediaScanEntry(""shiftjis6.mp3"",
                    new String[] {""音人"", ""SoundEffects"", null, ""正解"", null} ),
            new MediaScanEntry(""shiftjis7.mp3"",
                    new String[] {""音人"", ""SoundEffects"", null, ""残念"", null} ),
            new MediaScanEntry(""shiftjis8.mp3"",
                    new String[] {""音人"", ""SoundEffects"", null, ""間違い"", null} ),
            new MediaScanEntry(""iso88591_1.ogg"",
                    new String[] {""Mozart"", ""Best of Mozart"", null, ""Overtüre (Die Hochzeit des Figaro)"", null} ),
            new MediaScanEntry(""iso88591_2.mp3"", // actually UTF16, but only uses iso8859-1 chars
                    new String[] {""Björk"", ""Telegram"", ""Björk"", ""Possibly Maybe (Lucy Mix)"", null} ),
            new MediaScanEntry(""hebrew.mp3"",
                    new String[] {""אריק סיני"", """", null, ""לי ולך"", null } ),
            new MediaScanEntry(""hebrew2.mp3"",
                    new String[] {""הפרוייקט של עידן רייכל"", ""Untitled - 11-11-02 (9)"", null, ""בואי"", null } ),
            new MediaScanEntry(""iso88591_3.mp3"",
                    new String[] {""Mobilé"", ""Kartographie"", null, ""Zu Wenig"", null }),
            new MediaScanEntry(""iso88591_4.mp3"",
                    new String[] {""Mobilé"", ""Kartographie"", null, ""Rotebeetesalat (Igel Stehlen)"", null }),
            new MediaScanEntry(""iso88591_5.mp3"",
                    new String[] {""The Creatures"", ""Hai! [UK Bonus DVD] Disc 1"", ""The Creatures"", ""Imagoró"", null }),
            new MediaScanEntry(""iso88591_6.mp3"",
                    new String[] {""¡Forward, Russia!"", ""Give Me a Wall"", ""Forward Russia"", ""Fifteen, Pt. 1"", ""Canning/Nicholls/Sarah Nicolls/Woodhead""}),
            new MediaScanEntry(""iso88591_7.mp3"",
                    new String[] {""Björk"", ""Homogenic"", ""Björk"", ""Jòga"", ""Björk/Sjòn""}),
            // this one has a genre of ""Indé"" which confused the detector
            new MediaScanEntry(""iso88591_8.mp3"",
                    new String[] {""The Black Heart Procession"", ""3"", null, ""A Heart Like Mine"", null}),
            new MediaScanEntry(""iso88591_9.mp3"",
                    new String[] {""DJ Tiësto"", ""Just Be"", ""DJ Tiësto"", ""Adagio For Strings"", ""Samuel Barber""}),
            new MediaScanEntry(""iso88591_10.mp3"",
                    new String[] {""Ratatat"", ""LP3"", null, ""Bruleé"", null}),
            new MediaScanEntry(""iso88591_11.mp3"",
                    new String[] {""Sempé"", ""Le Petit Nicolas vol. 1"", null, ""Les Cow-Boys"", null}),
            new MediaScanEntry(""iso88591_12.mp3"",
                    new String[] {""UUVVWWZ"", ""UUVVWWZ"", null, ""Neolaño"", null}),
            new MediaScanEntry(""iso88591_13.mp3"",
                    new String[] {""Michael Bublé"", ""Crazy Love"", ""Michael Bublé"", ""Haven't Met You Yet"", null}),
            new MediaScanEntry(""utf16_1.mp3"",
                    new String[] {""Shakira"", ""Latin Mix USA"", ""Shakira"", ""Estoy Aquí"", null}),
            // Tags are encoded in different charsets.
            new MediaScanEntry(""iso88591_utf8_mixed_1.mp3"",
                    new String[] {""刘昊霖/kidult."", ""鱼干铺里"", ""刘昊霖/kidult."", ""Colin Wine's Mailbox"", null}),
            new MediaScanEntry(""iso88591_utf8_mixed_2.mp3"",
                    new String[] {""冰块先生/郭美孜"", ""hey jude"", ""冰块先生/郭美孜"", ""Hey Jude"", null}),
            new MediaScanEntry(""iso88591_utf8_mixed_3.mp3"",
                    new String[] {""Toy王奕/Tizzy T/满舒克"", ""1993"", ""Toy王奕/Tizzy T/满舒克"", ""Me&Ma Bros"", null}),
            new MediaScanEntry(""gb18030_utf8_mixed_1.mp3"",
                    new String[] {""张国荣"", ""钟情张国荣"", null, ""左右手"", null}),
            new MediaScanEntry(""gb18030_utf8_mixed_2.mp3"",
                    new String[] {""纵贯线"", ""Live in Taipei 出发\\/终点站"", null, ""皇后大道东(Live)"", null}),
            new MediaScanEntry(""gb18030_utf8_mixed_3.mp3"",
                    new String[] {""谭咏麟"", ""二十年白金畅销金曲全记录"", null, ""知心当玩偶"", null})
    };"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.media.cts.MediaScannerTest"	"testEncodingDetection"	"CtsMediaTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/MediaScannerTest.java"	""	"public void testEncodingDetection() throws Exception {
        for (int i = 0; i< encodingtestfiles.length; i++) {
            MediaScanEntry entry = encodingtestfiles[i];
            String path =  mFileDir + ""/"" + entry.fileName;
            writeFile(entry.fileName, path);
        }

        startMediaScanAndWait();

        String columns[] = {
                MediaStore.Audio.Media.ARTIST,
                MediaStore.Audio.Media.ALBUM,
                MediaStore.Audio.Media.ALBUM_ARTIST,
                MediaStore.Audio.Media.TITLE,
                MediaStore.Audio.Media.COMPOSER
        };
        ContentResolver res = mContext.getContentResolver();
        for (int i = 0; i< encodingtestfiles.length; i++) {
            MediaScanEntry entry = encodingtestfiles[i];
            String path =  mFileDir + ""/"" + entry.fileName;
            Cursor c = res.query(MediaStore.Audio.Media.getContentUri(""external""), columns,
                    MediaStore.Audio.Media.DATA + ""=?"", new String[] {path}, null);
            assertNotNull(""null cursor"", c);
            assertEquals(""wrong number or results"", 1, c.getCount());
            assertTrue(""failed to move cursor"", c.moveToFirst());

            for (int j =0; j < 5; j++) {
                String expected = entry.tags[j];
                if ("""".equals(expected)) {
                    // empty entry in the table means an unset id3 tag that is filled in by
                    // the media scanner, e.g. by using ""<unknown>"". Since this may be localized,
                    // don't check it for any particular value.
                    assertNotNull(""unexpected null entry "" + i + "" field "" + j + ""("" + path + "")"",
                            c.getString(j));
                } else {
                    assertEquals(""mismatch on entry "" + i + "" field "" + j + ""("" + path + "")"",
                            expected, c.getString(j));
                }
            }
            // clean up
            new File(path).delete();
            res.delete(MediaStore.Audio.Media.getContentUri(""external""),
                    MediaStore.Audio.Media.DATA + ""=?"", new String[] {path});

            c.close();

            // also test with the MediaMetadataRetriever API
            MediaMetadataRetriever woodly = new MediaMetadataRetriever();
            AssetFileDescriptor afd = getAssetFileDescriptorFor(entry.fileName);
            woodly.setDataSource(afd.getFileDescriptor(),
                    afd.getStartOffset(), afd.getDeclaredLength());

            String[] actual = new String[5];
            actual[0] = woodly.extractMetadata(MediaMetadataRetriever.METADATA_KEY_ARTIST);
            actual[1] = woodly.extractMetadata(MediaMetadataRetriever.METADATA_KEY_ALBUM);
            actual[2] = woodly.extractMetadata(MediaMetadataRetriever.METADATA_KEY_ALBUMARTIST);
            actual[3] = woodly.extractMetadata(MediaMetadataRetriever.METADATA_KEY_TITLE);
            actual[4] = woodly.extractMetadata(MediaMetadataRetriever.METADATA_KEY_COMPOSER);

            for (int j = 0; j < 5; j++) {
                if ("""".equals(entry.tags[j])) {
                    // retriever doesn't insert ""unknown artist"" and such, it just returns null
                    assertNull(""retriever: unexpected non-null for entry "" + i + "" field "" + j,
                            actual[j]);
                } else {
                    Log.i(""@@@"", ""tags: @@"" + entry.tags[j] + ""@@"" + actual[j] + ""@@"");
                    assertEquals(""retriever: mismatch on entry "" + i + "" field "" + j,
                            entry.tags[j], actual[j]);
                }
            }
        }
    }

    private static void scanVolume() {
        if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.R)) {
            MediaStore.scanVolume(InstrumentationRegistry.getTargetContext().getContentResolver(),
                    MediaStore.VOLUME_EXTERNAL_PRIMARY);
        } else {
            // on Q, scanVolume(Context, String path) should be used
            try {
                Method scanVolumeMethod = MediaStore.class
                    .getMethod(""scanVolume"", Context.class, File.class);
                scanVolumeMethod.invoke(null,
                        InstrumentationRegistry.getTargetContext(),
                        Environment.getExternalStorageDirectory());
            } catch (Exception ex) {
                fail(""could not find scanVolume method"" + ex);
            }
        }
    }

    public static void startMediaScan() {
        new Thread(() -> { scanVolume(); }).start();
    }

    public static void startMediaScanAndWait() {
        scanVolume();
    }

    private void checkMediaScannerConnection() {
        new PollingCheck(TIME_OUT) {
            protected boolean check() {
                return mMediaScannerConnectionClient.isOnMediaScannerConnectedCalled;
            }
        }.run();
        new PollingCheck(TIME_OUT) {
            protected boolean check() {
                return mMediaScannerConnectionClient.mediaPath != null;
            }
        }.run();
    }

    private void checkConnectionState(final boolean expected) {
        new PollingCheck(TIME_OUT) {
            protected boolean check() {
                return mMediaScannerConnection.isConnected() == expected;
            }
        }.run();
    }

    class MockMediaScannerConnection extends MediaScannerConnection {

        public boolean mIsOnServiceConnectedCalled;
        public boolean mIsOnServiceDisconnectedCalled;
        public MockMediaScannerConnection(Context context, MediaScannerConnectionClient client) {
            super(context, client);
        }

        @Override
        public void onServiceConnected(ComponentName className, IBinder service) {
            super.onServiceConnected(className, service);
            mIsOnServiceConnectedCalled = true;
        }

        @Override
        public void onServiceDisconnected(ComponentName className) {
            super.onServiceDisconnected(className);
            mIsOnServiceDisconnectedCalled = true;
            // this is not called.
        }
    }

    class MockMediaScannerConnectionClient implements MediaScannerConnectionClient {

        public boolean isOnMediaScannerConnectedCalled;
        public String mediaPath;
        public Uri mediaUri;
        public void onMediaScannerConnected() {
            isOnMediaScannerConnectedCalled = true;
        }

        public void onScanCompleted(String path, Uri uri) {
            Log.v(""MediaScannerTest"", ""onScanCompleted for "" + path + "" to "" + uri);
            mediaPath = path;
            if (uri != null) {
                mediaUri = uri;
            }
        }

        public void reset() {
            mediaPath = null;
            mediaUri = null;
        }
    }

    static File getRawFile(Uri uri) throws Exception {
        final String res = executeShellCommand(
                ""content query --uri "" + uri
                        + "" --user "" + getCurrentUser() + "" --projection _data"",
                InstrumentationRegistry.getInstrumentation().getUiAutomation());
        final int i = res.indexOf(""_data="");
        if (i >= 0) {
            return new File(res.substring(i + 6));
        } else {
            throw new FileNotFoundException(""Failed to find _data for "" + uri + ""; found "" + res);
        }
    }

    static String executeShellCommand(String command) throws IOException {
        return executeShellCommand(command,
                InstrumentationRegistry.getInstrumentation().getUiAutomation());
    }

    static String executeShellCommand(String command, UiAutomation uiAutomation)
            throws IOException {
        ParcelFileDescriptor pfd = uiAutomation.executeShellCommand(command.toString());
        BufferedReader br = null;
        try (InputStream in = new FileInputStream(pfd.getFileDescriptor());) {
            br = new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8));
            String str = null;
            StringBuilder out = new StringBuilder();
            while ((str = br.readLine()) != null) {
                out.append(str);
            }
            return out.toString();
        } finally {
            if (br != null) {
                br.close();
            }
        }
    }

    private static int getCurrentUser() {
        return android.os.Process.myUserHandle().getIdentifier();
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiInfoTest"	"isNotNull"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiInfoTest.java"	""	"public void test/*
 *.
 */

package android.net.wifi.cts;

import static com.google.common.truth.Truth.assertThat;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.net.wifi.ScanResult;
import android.net.wifi.SupplicantState;
import android.net.wifi.WifiInfo;
import android.net.wifi.WifiManager;
import android.net.wifi.WifiManager.WifiLock;
import android.os.Build;
import android.platform.test.annotations.AppModeFull;
import android.telephony.SubscriptionManager;

import com.android.compatibility.common.util.ApiLevelUtil;
import com.android.compatibility.common.util.PollingCheck;
import com.android.compatibility.common.util.ShellIdentityUtils;
import com.android.compatibility.common.util.SystemUtil;

import java.nio.charset.StandardCharsets;

@AppModeFull(reason = ""Cannot get WifiManager in instant app mode"")
public class WifiInfoTest extends WifiJUnit3TestBase {
    private static class MySync {
        int expectedState = STATE_NULL;
    }

    private WifiManager mWifiManager;
    private WifiLock mWifiLock;
    private static MySync mMySync;

    private static final int STATE_NULL = 0;
    private static final int STATE_WIFI_CHANGING = 1;
    private static final int STATE_WIFI_CHANGED = 2;

    private static final String TEST_SSID = ""Test123"";
    private static final String TEST_BSSID = ""12:12:12:12:12:12"";
    private static final int TEST_RSSI = -60;
    private static final int TEST_NETWORK_ID = 5;
    private static final int TEST_NETWORK_ID2 = 6;

    private static final String TAG = ""WifiInfoTest"";
    private static final int TIMEOUT_MSEC = 6000;
    private static final int WAIT_MSEC = 60;
    private static final int DURATION = 10000;
    private static final int WIFI_CONNECT_TIMEOUT_MILLIS = 30_000;
    private IntentFilter mIntentFilter;
    private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            final String action = intent.getAction();
            if (action.equals(WifiManager.WIFI_STATE_CHANGED_ACTION)) {
                synchronized (mMySync) {
                    mMySync.expectedState = STATE_WIFI_CHANGED;
                    mMySync.notify();
                }
            }
        }
    };

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        mMySync = new MySync();
        mIntentFilter = new IntentFilter();
        mIntentFilter.addAction(WifiManager.WIFI_STATE_CHANGED_ACTION);

        mContext.registerReceiver(mReceiver, mIntentFilter);
        mWifiManager = (WifiManager) getContext().getSystemService(Context.WIFI_SERVICE);
        assertThat(mWifiManager).isNotNull();
        mWifiLock = mWifiManager.createWifiLock(TAG);
        mWifiLock.acquire();

        // enable Wifi
        if (!mWifiManager.isWifiEnabled()) setWifiEnabled(true);
        PollingCheck.check(""Wifi not enabled"", DURATION, () -> mWifiManager.isWifiEnabled());

        mMySync.expectedState = STATE_NULL;
    }

    @Override
    protected void tearDown() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            super.tearDown();
            return;
        }
        mWifiLock.release();
        mContext.unregisterReceiver(mReceiver);
        if (!mWifiManager.isWifiEnabled())
            setWifiEnabled(true);
        Thread.sleep(DURATION);
        super.tearDown();
    }

    private void setWifiEnabled(boolean enable) throws Exception {
        synchronized (mMySync) {
            mMySync.expectedState = STATE_WIFI_CHANGING;
            if (enable) {
                SystemUtil.runShellCommand(""svc wifi enable"");
            } else {
                SystemUtil.runShellCommand(""svc wifi disable"");
            }
            long timeout = System.currentTimeMillis() + TIMEOUT_MSEC;
            while (System.currentTimeMillis() < timeout
                    && mMySync.expectedState == STATE_WIFI_CHANGING)
                mMySync.wait(WAIT_MSEC);
        }
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiInfoTest"	"testWifiInfoProperties"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiInfoTest.java"	""	"public void testWifiInfoProperties() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }

        // ensure Wifi is connected
        ShellIdentityUtils.invokeWithShellPermissions(() -> mWifiManager.reconnect());
        PollingCheck.check(
                ""Wifi not connected - Please ensure there is a saved network in range of this ""
                        + ""device"",
                WIFI_CONNECT_TIMEOUT_MILLIS,
                () -> mWifiManager.getConnectionInfo().getNetworkId() != -1);

        // this test case should in Wifi environment
        WifiInfo wifiInfo = mWifiManager.getConnectionInfo();

        testWifiInfoPropertiesWhileConnected(wifiInfo);

        setWifiEnabled(false);

        PollingCheck.check(""getNetworkId not -1"", 20000,
                () -> mWifiManager.getConnectionInfo().getNetworkId() == -1);

        PollingCheck.check(""getWifiState not disabled"", 20000,
                () -> mWifiManager.getWifiState() == WifiManager.WIFI_STATE_DISABLED);
    }

    private void testWifiInfoPropertiesWhileConnected(WifiInfo wifiInfo) {
        assertThat(wifiInfo).isNotNull();
        assertThat(wifiInfo.toString()).isNotNull();
        SupplicantState.isValidState(wifiInfo.getSupplicantState());
        WifiInfo.getDetailedStateOf(SupplicantState.DISCONNECTED);
        String ssid = wifiInfo.getSSID();
        if (!ssid.startsWith(""0x"") && !ssid.equals(WifiManager.UNKNOWN_SSID)) {
            // Non-hex string should be quoted
            assertThat(ssid).startsWith(""\"""");
            assertThat(ssid).endsWith(""\"""");
        }

        assertThat(wifiInfo.getBSSID()).isNotNull();
        assertThat(wifiInfo.getFrequency()).isGreaterThan(0);
        assertThat(wifiInfo.getMacAddress()).isNotNull();

        wifiInfo.getRssi();
        wifiInfo.getIpAddress();
        wifiInfo.getHiddenSSID();
        wifiInfo.getScore();

        // null for saved networks
        assertThat(wifiInfo.getRequestingPackageName()).isNull();
        assertThat(wifiInfo.getPasspointFqdn()).isNull();
        assertThat(wifiInfo.getPasspointProviderFriendlyName()).isNull();

        // false for saved networks
        assertThat(wifiInfo.isEphemeral()).isFalse();
        assertThat(wifiInfo.isOsuAp()).isFalse();
        assertThat(wifiInfo.isPasspointAp()).isFalse();

        assertThat(wifiInfo.getWifiStandard()).isAnyOf(
                ScanResult.WIFI_STANDARD_UNKNOWN,
                ScanResult.WIFI_STANDARD_LEGACY,
                ScanResult.WIFI_STANDARD_11N,
                ScanResult.WIFI_STANDARD_11AC,
                ScanResult.WIFI_STANDARD_11AX
        );

        assertThat(wifiInfo.getLostTxPacketsPerSecond()).isAtLeast(0.0);
        assertThat(wifiInfo.getRetriedTxPacketsPerSecond()).isAtLeast(0.0);
        assertThat(wifiInfo.getSuccessfulRxPacketsPerSecond()).isAtLeast(0.0);
        assertThat(wifiInfo.getSuccessfulTxPacketsPerSecond()).isAtLeast(0.0);

        // Can be -1 if link speed is unknown
        assertThat(wifiInfo.getLinkSpeed()).isAtLeast(-1);
        assertThat(wifiInfo.getTxLinkSpeedMbps()).isAtLeast(-1);
        assertThat(wifiInfo.getRxLinkSpeedMbps()).isAtLeast(-1);
        assertThat(wifiInfo.getMaxSupportedTxLinkSpeedMbps()).isAtLeast(-1);
        assertThat(wifiInfo.getMaxSupportedRxLinkSpeedMbps()).isAtLeast(-1);
        if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(mContext)) {
            assertThat(wifiInfo.getCurrentSecurityType()).isNotEqualTo(
                    WifiInfo.SECURITY_TYPE_UNKNOWN);
        }
    }

    /**
     * Test that the WifiInfo Builder returns the same values that was set, and that
     * calling build multiple times returns different instances.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.provider.cts.media.MediaStore_DownloadsTest"	"testScannedDownload"	"CtsProviderTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/provider/src/android/provider/cts/media/MediaStore_DownloadsTest.java"	""	"public void testScannedDownload() throws Exception {
        Assume.assumeTrue(MediaStore.VOLUME_EXTERNAL.equals(mVolumeName)
                || MediaStore.VOLUME_EXTERNAL_PRIMARY.equals(mVolumeName));

        final File downloadFile = new File(mDownloadsDir, ""colors.txt"");
        downloadFile.createNewFile();
        final String fileContents = ""RED;GREEN;BLUE"";
        try (final PrintWriter pw = new PrintWriter(downloadFile)) {
            pw.print(fileContents);
        }
        verifyScannedDownload(downloadFile);
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.provider.cts.media.MediaStore_DownloadsTest"	"testScannedMediaDownload"	"CtsProviderTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/provider/src/android/provider/cts/media/MediaStore_DownloadsTest.java"	""	"public void testScannedMediaDownload() throws Exception {
        Assume.assumeTrue(MediaStore.VOLUME_EXTERNAL.equals(mVolumeName)
                || MediaStore.VOLUME_EXTERNAL_PRIMARY.equals(mVolumeName));

        final File downloadFile = new File(mDownloadsDir, ""scenery.png"");
        downloadFile.createNewFile();
        try (InputStream in = mContext.getResources().openRawResource(R.raw.scenery);
                OutputStream out = new FileOutputStream(downloadFile)) {
            FileUtils.copy(in, out);
        }
        verifyScannedDownload(downloadFile);
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.provider.cts.media.MediaStore_DownloadsTest"	"testThumbnails"	"CtsProviderTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/provider/src/android/provider/cts/media/MediaStore_DownloadsTest.java"	""	"public void testThumbnails() throws Exception {
        final Uri uri = ProviderTestUtils.stageMedia(R.raw.scenery, mExternalDownloads);
        final long id = ContentUris.parseId(uri);

        // Verify that we can get a thumbnail for this item regardless of which
        // collection we reference it through
        assertNotNull(mContentResolver.loadThumbnail(
                ContentUris.withAppendedId(mExternalFiles, id), new Size(320, 240), null));
        assertNotNull(mContentResolver.loadThumbnail(
                ContentUris.withAppendedId(mExternalImages, id), new Size(320, 240), null));
        assertNotNull(mContentResolver.loadThumbnail(
                ContentUris.withAppendedId(mExternalDownloads, id), new Size(320, 240), null));
    }

    private int getInitialDownloadsCount() {
        try (Cursor cursor = mContentResolver.query(mExternalDownloads,
                null, null, null, null)) {
            return cursor.getCount();
        }
    }

    private Uri insertImage(String displayName, String description,
            File file, String mimeType, int resourceId) throws Exception {
        file.createNewFile();
        try (InputStream in = mContext.getResources().openRawResource(resourceId);
             OutputStream out = new FileOutputStream(file)) {
            FileUtils.copy(in, out);
        }

        final ContentValues values = new ContentValues();
        values.put(Images.Media.DISPLAY_NAME, displayName);
        values.put(Images.Media.TITLE, displayName);
        values.put(Images.Media.DESCRIPTION, description);
        values.put(Images.Media.DATA, file.getAbsolutePath());
        values.put(Images.Media.DATE_ADDED, System.currentTimeMillis() / 1000);
        values.put(Images.Media.DATE_MODIFIED, System.currentTimeMillis() / 1000);
        values.put(Images.Media.MIME_TYPE, mimeType);

        final Uri insertUri = mContentResolver.insert(mExternalImages, values);
        assertNotNull(insertUri);
        return insertUri;
    }

    private void verifyScannedDownload(File file) throws Exception {
        final Uri mediaStoreUri = ProviderTestUtils.scanFile(file);
        Log.e(TAG, ""Scanned file "" + file.getAbsolutePath() + "": "" + mediaStoreUri);
        assertArrayEquals(""File hashes should match for "" + file + "" and "" + mediaStoreUri,
                hash(new FileInputStream(file)),
                hash(mContentResolver.openInputStream(mediaStoreUri)));

        // Verify the file is part of downloads collection.
        final long id = ContentUris.parseId(mediaStoreUri);
        final Cursor cursor = mContentResolver.query(mExternalDownloads,
                null, MediaStore.Downloads._ID + ""="" + id, null, null);
        assertEquals(1, cursor.getCount());
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"util.build.BuildUtilBase"	"exists"	""	"/home/gpoor/cts-12-source/cts/tools/vm-tests-tf/build/src/util/build/BuildUtilBase.java"	""	"public void test/*
 *.
 */

package util.build;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.StringReader;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;
import java.util.Map.Entry;
import java.util.Scanner;
import java.util.regex.MatchResult;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Helper base class for code generators.
 */
public abstract class BuildUtilBase {

    public static boolean DEBUG = true;

    public static class MethodData {
        String methodBody, constraint, title;
    }

    public interface TestHandler {
        public void handleTest(String fqcn, List<String> methods);
    }

    public void run(TestHandler handler) {
        System.out.println(""Collecting all junit tests..."");
        JUnitTestCollector tests = new JUnitTestCollector(getClass().getClassLoader());

        handleTests(tests, handler);
    }

    protected void handleTests(JUnitTestCollector tests, TestHandler handler) {
        System.out.println(""collected "" + tests.testMethodsCnt + "" test methods in "" +
                tests.testClassCnt + "" junit test classes"");

        for (Entry<String, List<String>> entry : tests.map.entrySet()) {
            handler.handleTest(entry.getKey(), entry.getValue());
        }
    }

    private static String readURL(URL in) {
        // Use common scanner idiom to read a complete InputStream into a string.
        try (Scanner scanner = new Scanner(in.openStream(), StandardCharsets.UTF_8.toString())) {
            scanner.useDelimiter(""\\A"");  // This delimits by ""start of content,"" of which there is
                                          // only one.
            return scanner.hasNext() ? scanner.next() : null;
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    protected MethodData parseTestMethod(String pname, String classOnlyName,
            String method) {
        String searchPath = ""src/"" + pname.replaceAll(""\\."", ""/"") + ""/"" + classOnlyName + "".java"";
        String content;
        {
            URL resource = getClass().getClassLoader().getResource(searchPath);
            if (resource == null) {
                throw new RuntimeException(""Could not find "" + searchPath);
            }
            content = readURL(resource);
            if (content == null) {
                throw new RuntimeException(""Could not retrieve content for "" + searchPath);
            }
        }

        final String methodPattern = ""public\\s+void\\s+"" + method + ""[^\\{]+\\{"";

        int methodSkip;
        try (Scanner scanner = new Scanner(content)) {
            String token = scanner.findWithinHorizon(methodPattern, content.length());
            if (token == null) {
                throw new RuntimeException(""cannot find method source of 'public void "" + method +
                        ""' in file '"" + searchPath + ""'"");
            }

            MatchResult result = scanner.match();
            result.start();
            methodSkip = result.end();
        }

        StringBuilder builder = new StringBuilder();

        try {
            StringReader reader = new StringReader(content);
            reader.skip(methodSkip);

            int readResult;
            int blocks = 1;
            while ((readResult = reader.read()) != -1 && blocks > 0) {
                char currentChar = (char) readResult;
                switch (currentChar) {
                    case '}': {
                        blocks--;
                        builder.append(currentChar);
                        break;
                    }
                    case '{': {
                        blocks++;
                        builder.append(currentChar);
                        break;
                    }
                    default: {
                        builder.append(currentChar);
                        break;
                    }
                }
            }
            if (reader != null) {
                reader.close();
            }
        } catch (Exception e) {
            throw new RuntimeException(""failed to parse"", e);
        }

        // find the @title/@constraint in javadoc comment for this method
        // using platform's default charset

        // System.out.println(""grepping javadoc found for method "" + method +
        // "" in "" + pname + "","" + classOnlyName);
        String commentPattern = ""/\\*\\*([^{]*)\\*/\\s*"" + methodPattern;
        Pattern p = Pattern.compile(commentPattern, Pattern.DOTALL);
        Matcher m = p.matcher(content);
        String title = null, constraint = null;
        if (m.find()) {
            String res = m.group(1);
            // System.out.println(""res: "" + res);
            // now grep @title and @constraint
            Matcher titleM = Pattern.compile(""@title (.*)"", Pattern.DOTALL)
            .matcher(res);
            if (titleM.find()) {
                title = titleM.group(1).replaceAll(""\\n     \\*"", """");
                title = title.replaceAll(""\\n"", "" "");
                title = title.trim();
                // System.out.println(""title: "" + title);
            } else {
                System.err.println(""warning: no @title found for method "" + method + "" in "" + pname +
                        "","" + classOnlyName);
            }
            // constraint can be one line only
            Matcher constraintM = Pattern.compile(""@constraint (.*)"").matcher(
                    res);
            if (constraintM.find()) {
                constraint = constraintM.group(1);
                constraint = constraint.trim();
                // System.out.println(""constraint: "" + constraint);
            } else if (method.contains(""VFE"")) {
                System.err
                .println(""warning: no @constraint for for a VFE method:"" + method + "" in "" +
                        pname + "","" + classOnlyName);
            }
        } else {
            System.err.println(""warning: no javadoc found for method "" + method + "" in "" + pname +
                    "","" + classOnlyName);
        }
        MethodData md = new MethodData();
        md.methodBody = builder.toString();
        md.constraint = constraint;
        md.title = title;
        return md;
    }

    /**
     * @param pName
     * @param classOnlyName
     * @param methodSource
     * @return testclass names
     */
    protected static List<String> parseTestClassName(String pName, String classOnlyName,
            String methodSource) {
        List<String> entries = new ArrayList<String>(2);
        String opcodeName = classOnlyName.substring(5);

        try (Scanner scanner = new Scanner(methodSource)) {
            String[] patterns = new String[] { ""new\\s(T_"" + opcodeName + ""\\w*)"",
                    ""(T_"" + opcodeName + ""\\w*)"", ""new\\s(T\\w*)"" };

            String token = null;
            for (String pattern : patterns) {
                token = scanner.findWithinHorizon(pattern, methodSource.length());
                if (token != null) {
                    break;
                }
            }

            if (token == null) {
                System.err.println(""warning: failed to find dependent test class name: "" + pName
                        + "", "" + classOnlyName + "" in methodSource:\n"" + methodSource);
                return entries;
            }

            MatchResult result = scanner.match();

            entries.add((pName + "".d."" + result.group(1)).trim());

            // search additional @uses directives
            Pattern p = Pattern.compile(""@uses\\s+(.*)\\s+"", Pattern.MULTILINE);
            Matcher m = p.matcher(methodSource);
            while (m.find()) {
                String res = m.group(1);
                entries.add(0, res.trim());
            }

            // search for "" load(\""...\"" "" and add as dependency
            Pattern loadPattern = Pattern.compile(""load\\(\""([^\""]*)\"""", Pattern.MULTILINE);
            Matcher loadMatcher = loadPattern.matcher(methodSource);
            while (loadMatcher.find()) {
                String res = loadMatcher.group(1);
                entries.add(res.trim());
            }

            // search for "" loadAndRun(\""...\"" "" and add as dependency
            Pattern loadAndRunPattern = Pattern.compile(""loadAndRun\\(\""([^\""]*)\"""",
                    Pattern.MULTILINE);
            Matcher loadAndRunMatcher = loadAndRunPattern.matcher(methodSource);
            while (loadAndRunMatcher.find()) {
                String res = loadAndRunMatcher.group(1);
                entries.add(res.trim());
            }

            // lines with the form @uses
            // dot.junit.opcodes.add_double.jm.T_add_double_2
            // one dependency per one @uses
            // TODO

            return entries;
        }
    }

    public static void writeToFileMkdir(File file, String content) {
        File parent = file.getParentFile();
        if (!parent.exists() && !parent.mkdirs()) {
            throw new RuntimeException(""failed to create directory: "" + parent.getAbsolutePath());
        }
        writeToFile(file, content);
    }

    public static void writeToFile(File file, String content) {
        try {
            if (file.exists() && file.length() == content.length()) {
                FileReader reader = new FileReader(file);
                char[] charContents = new char[(int) file.length()];
                reader.read(charContents);
                reader.close();
                String contents = new String(charContents);
                if (contents.equals(content)) {
                    // System.out.println(""skipping identical: ""
                    // + file.getAbsolutePath());
                    return;
                }
            }

            //System.out.println(""writing file "" + file.getAbsolutePath());

            BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(
                    new FileOutputStream(file), ""utf-8""));
            bw.write(content);
            bw.close();
        } catch (Exception e) {
            throw new RuntimeException(""error while writing to file: "" + e.getClass().getName() +
                    "", msg:"" + e.getMessage());
        }
    }

}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.graphics.cts.BitmapTest"	"testCreateBitmapFromColorsScalnlineTooLarge"	"CtsGraphicsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/graphics/src/android/graphics/cts/BitmapTest.java"	""	"(expected=ArrayIndexOutOfBoundsException.class)
    public void testCreateBitmapFromColorsScalnlineTooLarge() {
        int[] colors = createColors(100);

        // abnormal case: (lastScanline + width) bigger than colors' length
        Bitmap.createBitmap(colors, 10, 100, 50, 100, Config.RGB_565);
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.graphics.cts.BitmapTest"	"testSetPixelsLastScanlineNegative"	"CtsGraphicsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/graphics/src/android/graphics/cts/BitmapTest.java"	""	"(expected=ArrayIndexOutOfBoundsException.class)
    public void testSetPixelsLastScanlineNegative() {
        int[] colors = createColors(100);
        mBitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);

        // abnormal case: lastScanline less than 0
        mBitmap.setPixels(colors, 10, -50, 10, 10, 50, 50);
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.graphics.cts.BitmapTest"	"testSetPixelsLastScanlineTooBig"	"CtsGraphicsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/graphics/src/android/graphics/cts/BitmapTest.java"	""	"(expected=ArrayIndexOutOfBoundsException.class)
    public void testSetPixelsLastScanlineTooBig() {
        int[] colors = createColors(100);
        mBitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);

        // abnormal case: (lastScanline + width) bigger than the length of colors
        mBitmap.setPixels(colors, 10, 50, 10, 10, 50, 50);
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.permission.cts.SplitPermissionsSystemTest"	"getSplitPermissions"	"CtsPermissionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/SplitPermissionsSystemTest.java"	""	"/*
 *.
 */

package android.permission.cts;

import static android.Manifest.permission.ACCESS_BACKGROUND_LOCATION;
import static android.Manifest.permission.ACCESS_COARSE_LOCATION;
import static android.Manifest.permission.ACCESS_FINE_LOCATION;
import static android.Manifest.permission.ACCESS_MEDIA_LOCATION;
import static android.Manifest.permission.BLUETOOTH;
import static android.Manifest.permission.BLUETOOTH_ADMIN;
import static android.Manifest.permission.BLUETOOTH_CONNECT;
import static android.Manifest.permission.BLUETOOTH_SCAN;
import static android.Manifest.permission.READ_CALL_LOG;
import static android.Manifest.permission.READ_CONTACTS;
import static android.Manifest.permission.READ_EXTERNAL_STORAGE;
import static android.Manifest.permission.READ_PHONE_STATE;
import static android.Manifest.permission.READ_PRIVILEGED_PHONE_STATE;
import static android.Manifest.permission.WRITE_CALL_LOG;
import static android.Manifest.permission.WRITE_CONTACTS;
import static android.Manifest.permission.WRITE_EXTERNAL_STORAGE;

import static com.google.common.truth.Truth.assertThat;

import static org.junit.Assert.assertEquals;
import static org.junit.Assume.assumeTrue;

import android.content.Context;
import android.os.Build;
import android.permission.PermissionManager;
import android.permission.PermissionManager.SplitPermissionInfo;

import androidx.test.InstrumentationRegistry;
import androidx.test.runner.AndroidJUnit4;

import com.android.compatibility.common.util.ApiLevelUtil;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.HashSet;
import java.util.List;
import java.util.Set;

@RunWith(AndroidJUnit4.class)
public class SplitPermissionsSystemTest {

    private static final int NO_TARGET = Build.VERSION_CODES.CUR_DEVELOPMENT + 1;

    private List<SplitPermissionInfo> mSplitPermissions;

    @Before
    public void before() {
        Context context = InstrumentationRegistry.getContext();
        PermissionManager permissionManager = (PermissionManager) context.getSystemService(
                Context.PERMISSION_SERVICE);
        mSplitPermissions = permissionManager.getSplitPermissions();
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.permission.cts.SplitPermissionsSystemTest"	"getSplitPermission"	"CtsPermissionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/SplitPermissionsSystemTest.java"	""	"public void validateAndroidSystem() {
        assumeTrue(ApiLevelUtil.isAtLeast(Build.VERSION_CODES.Q));

        Set<SplitPermissionInfo> seenSplits = new HashSet<>(6);

        for (SplitPermissionInfo split : mSplitPermissions) {
            String splitPermission = split.getSplitPermission();
            boolean isAndroid = splitPermission.startsWith(""android"");

            if (!isAndroid) {
                continue;
            }

            assertThat(seenSplits).doesNotContain(split);
            seenSplits.add(split);

            List<String> newPermissions = split.getNewPermissions();

            switch (splitPermission) {
                case ACCESS_FINE_LOCATION:
                    // Q declares multiple for ACCESS_FINE_LOCATION, so assert both exist
                    if (newPermissions.contains(ACCESS_COARSE_LOCATION)) {
                        assertSplit(split, NO_TARGET, ACCESS_COARSE_LOCATION);
                    } else {
                        assertSplit(split, Build.VERSION_CODES.Q, ACCESS_BACKGROUND_LOCATION);
                    }
                    break;
                case WRITE_EXTERNAL_STORAGE:
                    assertSplit(split, NO_TARGET, READ_EXTERNAL_STORAGE);
                    break;
                case READ_CONTACTS:
                    assertSplit(split, Build.VERSION_CODES.JELLY_BEAN, READ_CALL_LOG);
                    break;
                case WRITE_CONTACTS:
                    assertSplit(split, Build.VERSION_CODES.JELLY_BEAN, WRITE_CALL_LOG);
                    break;
                case ACCESS_COARSE_LOCATION:
                    assertSplit(split, Build.VERSION_CODES.Q, ACCESS_BACKGROUND_LOCATION);
                    break;
                case READ_EXTERNAL_STORAGE:
                    assertSplit(split, Build.VERSION_CODES.Q, ACCESS_MEDIA_LOCATION);
                    break;
                case READ_PRIVILEGED_PHONE_STATE:
                    assertSplit(split, NO_TARGET, READ_PHONE_STATE);
                    break;
                case BLUETOOTH_CONNECT:
                    // STOPSHIP(b/184180558): replace with ""S"" once SDK is finalized
                    assertSplit(split, Build.VERSION_CODES.R + 1, BLUETOOTH, BLUETOOTH_ADMIN);
                    break;
                case BLUETOOTH_SCAN:
                    // STOPSHIP(b/184180558): replace with ""S"" once SDK is finalized
                    assertSplit(split, Build.VERSION_CODES.R + 1, BLUETOOTH, BLUETOOTH_ADMIN);
                    break;
            }
        }

        assertEquals(13, seenSplits.size());
    }

    private void assertSplit(SplitPermissionInfo split, int targetSdk, String... permission) {
        assertThat(split.getNewPermissions()).containsExactlyElementsIn(permission);
        assertThat(split.getTargetSdk()).isEqualTo(targetSdk);
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.host.multiuser.BaseMultiUserTest"	"TestName"	"CtsMultiUserHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/multiuser/src/android/host/multiuser/BaseMultiUserTest.java"	""	"public void test/*
 *
 */
package android.host.multiuser;

import static com.google.common.truth.Truth.assertWithMessage;

import static org.junit.Assume.assumeTrue;

import com.android.ddmlib.Log;
import com.android.tradefed.device.DeviceNotAvailableException;
import com.android.tradefed.log.LogUtil.CLog;
import com.android.tradefed.testtype.junit4.BaseHostJUnit4Test;

import org.junit.After;
import org.junit.AssumptionViolatedException;
import org.junit.Before;
import org.junit.Rule;
import org.junit.rules.TestName;
import org.junit.rules.TestRule;
import org.junit.runner.Description;
import org.junit.runners.model.Statement;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Scanner;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Base class for multi user tests.
 */
// Must be public because of @Rule
public abstract class BaseMultiUserTest extends BaseHostJUnit4Test {

    /** Guest flag value from android/content/pm/UserInfo.java */
    private static final int FLAG_GUEST = 0x00000004;

    /**
     * Feature flag for automotive devices
     * https://source.android.com/compatibility/android-cdd#2_5_automotive_requirements
     */
    private static final String FEATURE_AUTOMOTIVE = ""feature:android.hardware.type.automotive"";

    protected static final long LOGCAT_POLL_INTERVAL_MS = 1000;
    protected static final long USER_SWITCH_COMPLETE_TIMEOUT_MS = 360_000;

    /** Whether multi-user is supported. */
    protected int mInitialUserId;
    protected int mPrimaryUserId;

    /** Users we shouldn't delete in the tests. */
    private ArrayList<Integer> mFixedUsers;

    @Rule
    public final TestName mTestNameRule = new TestName();

    @Before
    public void setUp() throws Exception {
        mInitialUserId = getDevice().getCurrentUser();
        mPrimaryUserId = getDevice().getPrimaryUserId();

        // Test should not modify / remove any of the existing users.
        mFixedUsers = getDevice().listUsers();
    }

    @After
    public void tearDown() throws Exception {
        int currentUserId = getDevice().getCurrentUser();
        if (currentUserId != mInitialUserId) {
            CLog.w(""User changed during test (to %d). Switching back to %d"", currentUserId,
                    mInitialUserId);
            getDevice().switchUser(mInitialUserId);
        }
        // Remove the users created during this test.
        removeTestUsers();
    }

    protected String getTestName() {
        return mTestNameRule.getMethodName();
    }

    protected void assumeNotRoot() throws DeviceNotAvailableException {
        if (!getDevice().isAdbRoot()) return;

        String message = ""Cannot test "" + getTestName() + "" on rooted devices"";
        CLog.logAndDisplay(Log.LogLevel.WARN, message);
        throw new AssumptionViolatedException(message);
    }

    protected int createRestrictedProfile(int userId)
            throws DeviceNotAvailableException, IllegalStateException{
        final String command = ""pm create-user --profileOf "" + userId + "" --restricted ""
                + ""TestUser_"" + System.currentTimeMillis();
        final String output = getDevice().executeShellCommand(command);

        if (output.startsWith(""Success"")) {
            try {
                return Integer.parseInt(output.substring(output.lastIndexOf("" "")).trim());
            } catch (NumberFormatException e) {
                CLog.e(""Failed to parse result: %s"", output);
            }
        } else {
            CLog.e(""Failed to create restricted profile: %s"", output);
        }
        throw new IllegalStateException();
    }

    protected int createGuestUser() throws Exception {
        return getDevice().createUser(
                ""TestUser_"" + System.currentTimeMillis() /* name */,
                true /* guest */,
                false /* ephemeral */);
    }

    protected int getGuestUser() throws Exception {
        for (int userId : getDevice().listUsers()) {
            if ((getDevice().getUserFlags(userId) & FLAG_GUEST) != 0) {
                return userId;
            }
        }
        return -1;
    }

    protected void assumeGuestDoesNotExist() throws Exception {
        assumeTrue(""Device already has a guest user"", getGuestUser() == -1);
    }

    protected void assumeIsAutomotive() throws Exception {
        assumeTrue(""Device does not have "" + FEATURE_AUTOMOTIVE,
                getDevice().hasFeature(FEATURE_AUTOMOTIVE));
    }

    protected void assertSwitchToNewUser(int toUserId) throws Exception {
        final String exitString = ""Finished processing BOOT_COMPLETED for u"" + toUserId;
        final Set<String> appErrors = new LinkedHashSet<>();
        getDevice().executeAdbCommand(""logcat"", ""-b"", ""all"", ""-c""); // Reset log
        assertWithMessage(""Couldn't switch to user %s"", toUserId)
                .that(getDevice().switchUser(toUserId)).isTrue();
        final boolean result = waitForUserSwitchComplete(appErrors, toUserId, exitString);
        assertWithMessage(""Didn't receive BOOT_COMPLETED delivered notification. appErrors=%s"",
                appErrors).that(result).isTrue();
        if (!appErrors.isEmpty()) {
            throw new AppCrashOnBootError(appErrors);
        }
    }

    protected void assertSwitchToUser(int fromUserId, int toUserId) throws Exception {
        final String exitString = ""uc_continue_user_switch: ["" + fromUserId + "","" + toUserId + ""]"";
        final Set<String> appErrors = new LinkedHashSet<>();
        getDevice().executeAdbCommand(""logcat"", ""-b"", ""all"", ""-c""); // Reset log
        assertWithMessage(""Couldn't switch to user %s"", toUserId)
                .that(getDevice().switchUser(toUserId)).isTrue();
        final boolean result = waitForUserSwitchComplete(appErrors, toUserId, exitString);
        assertWithMessage(""Didn't reach \""Continue user switch\"" stage. appErrors=%s"", appErrors)
                .that(result).isTrue();
        if (!appErrors.isEmpty()) {
            throw new AppCrashOnBootError(appErrors);
        }
    }

    protected void assertUserNotPresent(int userId) throws Exception {
        assertWithMessage(""User ID %s should not be present"", userId)
                .that(getDevice().listUsers()).doesNotContain(userId);
    }

    protected void assertUserPresent(int userId) throws Exception {
        assertWithMessage(""User ID %s should be present"", userId)
                .that(getDevice().listUsers()).contains(userId);
    }

    /*
     * Waits for userId to removed or at removing state.
     * Returns true if user is removed or at removing state.
     * False if user is not removed by USER_SWITCH_COMPLETE_TIMEOUT_MS.
     */
    protected boolean waitForUserRemove(int userId)
            throws DeviceNotAvailableException, InterruptedException {
        // Example output from dumpsys when user is flagged for removal:
        // UserInfo{11:Driver:154} serialNo=50 <removing>  <partial>
        final String userSerialPatter = ""(.*\\{)(\\d+)(.*\\})(.*=)(\\d+)(.*)"";
        final Pattern pattern = Pattern.compile(userSerialPatter);
        long ti = System.currentTimeMillis();
        while (System.currentTimeMillis() - ti < USER_SWITCH_COMPLETE_TIMEOUT_MS) {
            if (!getDevice().listUsers().contains(userId)) {
                return true;
            }
            String commandOutput = getDevice().executeShellCommand(""dumpsys user"");
            Matcher matcher = pattern.matcher(commandOutput);
            while(matcher.find()) {
                if (Integer.parseInt(matcher.group(2)) == userId
                        && matcher.group(6).contains(""removing"")) {
                    return true;
                }
            }
            Thread.sleep(LOGCAT_POLL_INTERVAL_MS);
        }
        return false;
    }

    private boolean waitForUserSwitchComplete(Set<String> appErrors, int targetUserId,
            String exitString) throws DeviceNotAvailableException, InterruptedException {
        boolean mExitFound = false;
        long ti = System.currentTimeMillis();
        while (System.currentTimeMillis() - ti < USER_SWITCH_COMPLETE_TIMEOUT_MS) {
            String logs = getDevice().executeAdbCommand(""logcat"", ""-b"", ""all"", ""-d"",
                    ""ActivityManager:D"", ""AndroidRuntime:E"", ""*:I"");
            Scanner in = new Scanner(logs);
            while (in.hasNextLine()) {
                String line = in.nextLine();
                if (line.contains(""Showing crash dialog for package"")) {
                    appErrors.add(line);
                } else if (line.contains(exitString)) {
                    // Parse all logs in case crashes occur as a result of onUserChange callbacks
                    mExitFound = true;
                } else if (line.contains(""FATAL EXCEPTION IN SYSTEM PROCESS"")) {
                    throw new IllegalStateException(""System process crashed - "" + line);
                }
            }
            in.close();
            if (mExitFound) {
                if (!appErrors.isEmpty()) {
                    CLog.w(""App crash dialogs found: %s"", appErrors);
                }
                return true;
            }
            Thread.sleep(LOGCAT_POLL_INTERVAL_MS);
        }
        return false;
    }

    private void removeTestUsers() throws Exception {
        for (int userId : getDevice().listUsers()) {
            if (!mFixedUsers.contains(userId)) {
                getDevice().removeUser(userId);
            }
        }
    }

    static class AppCrashOnBootError extends AssertionError {
        private static final Pattern PACKAGE_NAME_PATTERN = Pattern.compile(""package ([^\\s]+)"");
        private Set<String> errorPackages;

        AppCrashOnBootError(Set<String> errorLogs) {
            super(""App error dialog(s) are present: "" + errorLogs);
            this.errorPackages = errorLogsToPackageNames(errorLogs);
        }

        private static Set<String> errorLogsToPackageNames(Set<String> errorLogs) {
            Set<String> result = new HashSet<>();
            for (String line : errorLogs) {
                Matcher matcher = PACKAGE_NAME_PATTERN.matcher(line);
                if (matcher.find()) {
                    result.add(matcher.group(1));
                } else {
                    throw new IllegalStateException(""Unrecognized line "" + line);
                }
            }
            return result;
        }
    }

    /**
     * Rule that retries the test if it failed due to {@link AppCrashOnBootError}
     */
    public static class AppCrashRetryRule implements TestRule {

        @Override
        public Statement apply(Statement base, Description description) {
            return new Statement() {
                @Override
                public void evaluate() throws Throwable {
                    Set<String> errors = evaluateAndReturnAppCrashes(base);
                    if (errors.isEmpty()) {
                        CLog.v(""Good News, Everyone! No App crashes on %s"",
                                description.getMethodName());
                        return;
                    }
                    CLog.e(""Retrying due to app crashes: %s"", errors);
                    // Fail only if same apps are crashing in both runs
                    errors.retainAll(evaluateAndReturnAppCrashes(base));
                    assertWithMessage(""App error dialog(s) are present after 2 attempts"")
                            .that(errors).isEmpty();
                }
            };
        }

        private static Set<String> evaluateAndReturnAppCrashes(Statement base) throws Throwable {
            try {
                base.evaluate();
            } catch (AppCrashOnBootError e) {
                return e.errorPackages;
            }
            return new HashSet<>();
        }
    }

    /**
     * Rule that skips a test if device does not support more than 1 user
     */
    protected static class SupportsMultiUserRule implements TestRule {

        private final BaseHostJUnit4Test mDeviceTest;

        SupportsMultiUserRule(BaseHostJUnit4Test deviceTest) {
            mDeviceTest = deviceTest;
        }

        @Override
        public Statement apply(Statement base, Description description) {
            return new Statement() {
                @Override
                public void evaluate() throws Throwable {
                    boolean supports = mDeviceTest.getDevice().getMaxNumberOfUsersSupported() > 1;
                    assumeTrue(""device does not support multi users"", supports);

                    base.evaluate();
                }
            };
        }
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.app.cts.ActivityManagerProcessStateTest"	"testBgRestrictedForegroundService"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerProcessStateTest.java"	""	"public void testBgRestrictedForegroundService() throws Exception {
        final Intent activityIntent = new Intent()
                .setClassName(SIMPLE_PACKAGE_NAME,
                        SIMPLE_PACKAGE_NAME + SIMPLE_ACTIVITY_START_FG_SERVICE)
                .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);

        PermissionUtils.grantPermission(
                STUB_PACKAGE_NAME, android.Manifest.permission.PACKAGE_USAGE_STATS);
        final ServiceProcessController controller = new ServiceProcessController(mContext,
                mInstrumentation, STUB_PACKAGE_NAME, mAllProcesses, WAIT_TIME);
        final WatchUidRunner uidWatcher = controller.getUidWatcher();

        final Intent homeIntent = new Intent()
                .setAction(Intent.ACTION_MAIN)
                .addCategory(Intent.CATEGORY_HOME)
                .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK
                        | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);

        final Intent serviceStartIntent = new Intent(mService3Intent)
                .setAction(ACTION_START_THEN_FG);
        activityIntent.putExtra(""service"", serviceStartIntent);
        boolean activityStarted = false;

        try {
            // First kill the process to start out in a stable state.
            controller.ensureProcessGone();

            // Do initial setup.
            controller.denyAnyInBackgroundOp();
            controller.makeUidIdle();
            controller.removeFromWhitelist();
            controller.setAppOpMode(AppOpsManager.OPSTR_START_FOREGROUND, ""allow"");

            // Start the activity, which will start the fg service as well, and wait
            // for the report that it's all up and running.
            WaitForBroadcast waiter = new WaitForBroadcast(mInstrumentation.getTargetContext());
            waiter.prepare(ACTION_SIMPLE_ACTIVITY_START_FG_SERVICE_RESULT);

            activityIntent.setAction(ACTION_SIMPLE_ACTIVITY_START_FG);
            mTargetContext.startActivity(activityIntent);
            activityStarted = true;

            Intent resultIntent = waiter.doWait(WAIT_TIME);
            int brCode = resultIntent.getIntExtra(""result"", Activity.RESULT_CANCELED);
            if (brCode != Activity.RESULT_FIRST_USER) {
                fail(""Failed starting service, result="" + brCode);
            }

            // activity is in front, fg service is running.  make sure that we see
            // the expected state at this point.
            uidWatcher.waitFor(WatchUidRunner.CMD_ACTIVE, null);
            uidWatcher.waitFor(WatchUidRunner.CMD_UNCACHED, null);
            uidWatcher.expect(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_TOP);

            // Switch to the home app; make sure the test app drops all the way
            // down to SERVICE, not FG_SERVICE
            mTargetContext.startActivity(homeIntent);
            uidWatcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_SERVICE);
        } finally {
            // tear down everything and we're done
            if (activityStarted) {
                activityIntent.setAction(ACTION_FINISH_EVERYTHING);
                mTargetContext.startActivity(activityIntent);
            }

            controller.cleanup();
        }

    }

    private boolean supportsCantSaveState() {
        if (mContext.getPackageManager().hasSystemFeature(
                PackageManager.FEATURE_CANT_SAVE_STATE)) {
            return true;
        }

        return false;
    }

    /**
     * Test that a single ""can't save state"" app has the proper process management semantics.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.app.cts.ActivityManagerProcessStateTest"	"testCantSaveStateLaunchAndBackground"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerProcessStateTest.java"	""	"public void testCantSaveStateLaunchAndBackground() throws Exception {
        if (!supportsCantSaveState()) {
            return;
        }

        final Intent activityIntent = new Intent();
        activityIntent.setPackage(CANT_SAVE_STATE_1_PACKAGE_NAME);
        activityIntent.setAction(Intent.ACTION_MAIN);
        activityIntent.addCategory(Intent.CATEGORY_LAUNCHER);
        activityIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);

        final Intent homeIntent = new Intent();
        homeIntent.setAction(Intent.ACTION_MAIN);
        homeIntent.addCategory(Intent.CATEGORY_HOME);
        homeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);

        ActivityManager am = mContext.getSystemService(ActivityManager.class);

        PermissionUtils.grantPermission(
                STUB_PACKAGE_NAME, android.Manifest.permission.PACKAGE_USAGE_STATS);

        // We don't want to wait for the uid to actually go idle, we can force it now.
        String cmd = ""am make-uid-idle "" + CANT_SAVE_STATE_1_PACKAGE_NAME;
        String result = SystemUtil.runShellCommand(mInstrumentation, cmd);

        ApplicationInfo appInfo = mContext.getPackageManager().getApplicationInfo(
                CANT_SAVE_STATE_1_PACKAGE_NAME, 0);

        // This test is also using UidImportanceListener to make sure the correct
        // heavy-weight state is reported there.
        UidImportanceListener uidForegroundListener = new UidImportanceListener(mContext,
                appInfo.uid, IMPORTANCE_FOREGROUND,
                WAIT_TIME);
        uidForegroundListener.register();
        UidImportanceListener uidBackgroundListener = new UidImportanceListener(mContext,
                appInfo.uid, ActivityManager.RunningAppProcessInfo.IMPORTANCE_CANT_SAVE_STATE - 1,
                WAIT_TIME);
        uidBackgroundListener.register();
        UidImportanceListener uidCachedListener = new UidImportanceListener(mContext,
                appInfo.uid, ActivityManager.RunningAppProcessInfo.IMPORTANCE_CANT_SAVE_STATE + 1,
                WAIT_TIME);
        uidCachedListener.register();

        WatchUidRunner uidWatcher = new WatchUidRunner(mInstrumentation, appInfo.uid,
                WAIT_TIME);

        UiDevice device = UiDevice.getInstance(mInstrumentation);

        try {
            // Start the heavy-weight app, should launch like a normal app.
            mTargetContext.startActivity(activityIntent);
            waitForAppFocus(CANT_SAVE_STATE_1_PACKAGE_NAME, WAIT_TIME);
            device.waitForIdle();

            // Wait for process state to reflect running activity.
            uidForegroundListener.waitForValue(
                    IMPORTANCE_FOREGROUND,
                    IMPORTANCE_FOREGROUND);
            assertEquals(IMPORTANCE_FOREGROUND,
                    am.getPackageImportance(CANT_SAVE_STATE_1_PACKAGE_NAME));

            // Also make sure the uid state reports are as expected.
            uidWatcher.waitFor(WatchUidRunner.CMD_ACTIVE, null);
            uidWatcher.waitFor(WatchUidRunner.CMD_UNCACHED, null);
            uidWatcher.expect(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_TOP);

            // Now go to home, leaving the app.  It should be put in the heavy weight state.
            mTargetContext.startActivity(homeIntent);

            final int expectedImportance =
                    (mContext.getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.O)
                            ? ActivityManager.RunningAppProcessInfo.IMPORTANCE_CANT_SAVE_STATE
                            : ActivityManager.RunningAppProcessInfo.IMPORTANCE_CANT_SAVE_STATE_PRE_26;
            // Wait for process to go down to background heavy-weight.
            uidBackgroundListener.waitForValue(expectedImportance, expectedImportance);
            assertEquals(expectedImportance,
                    am.getPackageImportance(CANT_SAVE_STATE_1_PACKAGE_NAME));

            uidWatcher.expect(WatchUidRunner.CMD_CACHED, null);
            uidWatcher.expect(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_HEAVY_WEIGHT);

            // While in background, should go in to normal idle state.
            // Force app to go idle now
            cmd = ""am make-uid-idle "" + CANT_SAVE_STATE_1_PACKAGE_NAME;
            result = SystemUtil.runShellCommand(mInstrumentation, cmd);
            uidWatcher.expect(WatchUidRunner.CMD_IDLE, null);

            // Switch back to heavy-weight app to see if it correctly returns to foreground.
            mTargetContext.startActivity(activityIntent);

            // Wait for process state to reflect running activity.
            uidForegroundListener.waitForValue(
                    IMPORTANCE_FOREGROUND,
                    IMPORTANCE_FOREGROUND);
            assertEquals(IMPORTANCE_FOREGROUND,
                    am.getPackageImportance(CANT_SAVE_STATE_1_PACKAGE_NAME));

            // Also make sure the uid state reports are as expected.
            uidWatcher.waitFor(WatchUidRunner.CMD_ACTIVE, null);
            uidWatcher.waitFor(WatchUidRunner.CMD_UNCACHED, null);
            uidWatcher.expect(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_TOP);

            waitForAppFocus(CANT_SAVE_STATE_1_PACKAGE_NAME, WAIT_TIME);
            device.waitForIdle();

            // Exit activity, check to see if we are now cached.
            final Intent finishIntent = new Intent();
            finishIntent.setPackage(CANT_SAVE_STATE_1_PACKAGE_NAME);
            finishIntent.setAction(ACTION_FINISH);
            finishIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            finishIntent.addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP);
            mTargetContext.startActivity(finishIntent);

            // Wait for process to become cached
            uidCachedListener.waitForValue(
                    IMPORTANCE_CACHED,
                    IMPORTANCE_CACHED);
            assertEquals(IMPORTANCE_CACHED,
                    am.getPackageImportance(CANT_SAVE_STATE_1_PACKAGE_NAME));

            uidWatcher.expect(WatchUidRunner.CMD_CACHED, null);
            uidWatcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_CACHED_RECENT);

            // While in background, should go in to normal idle state.
            // Force app to go idle now
            cmd = ""am make-uid-idle "" + CANT_SAVE_STATE_1_PACKAGE_NAME;
            result = SystemUtil.runShellCommand(mInstrumentation, cmd);
            uidWatcher.expect(WatchUidRunner.CMD_IDLE, null);

        } finally {
            uidWatcher.finish();
            uidForegroundListener.unregister();
            uidBackgroundListener.unregister();
            uidCachedListener.unregister();
        }
    }

    /**
     * Test that switching between two ""can't save state"" apps is handled properly.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.app.cts.ActivityManagerProcessStateTest"	"testCantSaveStateLaunchAndSwitch"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerProcessStateTest.java"	""	"public void testCantSaveStateLaunchAndSwitch() throws Exception {
        if (!supportsCantSaveState()) {
            return;
        }

        final Intent activity1Intent = new Intent();
        activity1Intent.setPackage(CANT_SAVE_STATE_1_PACKAGE_NAME);
        activity1Intent.setAction(Intent.ACTION_MAIN);
        activity1Intent.addCategory(Intent.CATEGORY_LAUNCHER);
        activity1Intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);

        final Intent activity2Intent = new Intent();
        activity2Intent.setPackage(CANT_SAVE_STATE_2_PACKAGE_NAME);
        activity2Intent.setAction(Intent.ACTION_MAIN);
        activity2Intent.addCategory(Intent.CATEGORY_LAUNCHER);
        activity2Intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);

        final Intent homeIntent = new Intent();
        homeIntent.setAction(Intent.ACTION_MAIN);
        homeIntent.addCategory(Intent.CATEGORY_HOME);
        homeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);

        ActivityManager am = mContext.getSystemService(ActivityManager.class);
        UiDevice device = UiDevice.getInstance(mInstrumentation);

        PermissionUtils.grantPermission(
                STUB_PACKAGE_NAME, android.Manifest.permission.PACKAGE_USAGE_STATS);

        // We don't want to wait for the uid to actually go idle, we can force it now.
        String cmd = ""am make-uid-idle "" + CANT_SAVE_STATE_1_PACKAGE_NAME;
        String result = SystemUtil.runShellCommand(mInstrumentation, cmd);
        cmd = ""am make-uid-idle "" + CANT_SAVE_STATE_2_PACKAGE_NAME;
        result = SystemUtil.runShellCommand(mInstrumentation, cmd);

        ApplicationInfo app1Info = mContext.getPackageManager().getApplicationInfo(
                CANT_SAVE_STATE_1_PACKAGE_NAME, 0);
        WatchUidRunner uid1Watcher = new WatchUidRunner(mInstrumentation, app1Info.uid,
                WAIT_TIME);

        ApplicationInfo app2Info = mContext.getPackageManager().getApplicationInfo(
                CANT_SAVE_STATE_2_PACKAGE_NAME, 0);
        WatchUidRunner uid2Watcher = new WatchUidRunner(mInstrumentation, app2Info.uid,
                WAIT_TIME);

        try {
            // Start the first heavy-weight app, should launch like a normal app.
            mTargetContext.startActivity(activity1Intent);
            waitForAppFocus(CANT_SAVE_STATE_1_PACKAGE_NAME, WAIT_TIME);
            device.waitForIdle();

            // Make sure the uid state reports are as expected.
            uid1Watcher.waitFor(WatchUidRunner.CMD_ACTIVE, null);
            uid1Watcher.waitFor(WatchUidRunner.CMD_UNCACHED, null);
            uid1Watcher.expect(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_TOP);

            // Now go to home, leaving the app.  It should be put in the heavy weight state.
            mTargetContext.startActivity(homeIntent);

            // Wait for process to go down to background heavy-weight.
            uid1Watcher.expect(WatchUidRunner.CMD_CACHED, null);
            uid1Watcher.expect(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_HEAVY_WEIGHT);

            // Start the second heavy-weight app, should ask us what to do with the two apps
            startActivityAndWaitForShow(activity2Intent);

            // First, let's try returning to the original app.
            maybeClick(device, new UiSelector().resourceId(""android:id/switch_old""));
            waitForAppFocus(CANT_SAVE_STATE_1_PACKAGE_NAME, WAIT_TIME);
            device.waitForIdle();

            // App should now be back in foreground.
            uid1Watcher.expect(WatchUidRunner.CMD_UNCACHED, null);
            uid1Watcher.expect(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_TOP);

            // Return to home.
            mTargetContext.startActivity(homeIntent);
            uid1Watcher.expect(WatchUidRunner.CMD_CACHED, null);
            uid1Watcher.expect(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_HEAVY_WEIGHT);

            // Again try starting second heavy-weight app to get prompt.
            startActivityAndWaitForShow(activity2Intent);

            // Now we'll switch to the new app.
            maybeClick(device, new UiSelector().resourceId(""android:id/switch_new""));
            waitForAppFocus(CANT_SAVE_STATE_2_PACKAGE_NAME, WAIT_TIME);
            device.waitForIdle();

            // The original app should now become cached.
            uid1Watcher.expect(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_CACHED_RECENT);

            // And the new app should start.
            uid2Watcher.waitFor(WatchUidRunner.CMD_ACTIVE, null);
            uid2Watcher.waitFor(WatchUidRunner.CMD_UNCACHED, null);
            uid2Watcher.expect(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_TOP);

            // Make sure the original app is idle for cleanliness
            cmd = ""am make-uid-idle "" + CANT_SAVE_STATE_1_PACKAGE_NAME;
            result = SystemUtil.runShellCommand(mInstrumentation, cmd);
            uid1Watcher.expect(WatchUidRunner.CMD_IDLE, null);

            // Return to home.
            mTargetContext.startActivity(homeIntent);
            uid2Watcher.waitFor(WatchUidRunner.CMD_CACHED, null);
            uid2Watcher.expect(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_HEAVY_WEIGHT);

            // Try starting the first heavy weight app, but return to the existing second.
            startActivityAndWaitForShow(activity1Intent);
            maybeClick(device, new UiSelector().resourceId(""android:id/switch_old""));
            waitForAppFocus(CANT_SAVE_STATE_2_PACKAGE_NAME, WAIT_TIME);
            device.waitForIdle();
            uid2Watcher.waitFor(WatchUidRunner.CMD_UNCACHED, null);
            uid2Watcher.expect(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_TOP);

            // Return to home.
            mTargetContext.startActivity(homeIntent);
            uid2Watcher.waitFor(WatchUidRunner.CMD_CACHED, null);
            uid2Watcher.expect(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_HEAVY_WEIGHT);

            // Again start the first heavy weight app, this time actually switching to it
            startActivityAndWaitForShow(activity1Intent);
            maybeClick(device, new UiSelector().resourceId(""android:id/switch_new""));
            waitForAppFocus(CANT_SAVE_STATE_1_PACKAGE_NAME, WAIT_TIME);
            device.waitForIdle();

            // The second app should now become cached.
            uid2Watcher.expect(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_CACHED_RECENT);

            // And the first app should start.
            uid1Watcher.waitFor(WatchUidRunner.CMD_ACTIVE, null);
            uid1Watcher.waitFor(WatchUidRunner.CMD_UNCACHED, null);
            uid1Watcher.expect(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_TOP);

            waitForAppFocus(CANT_SAVE_STATE_1_PACKAGE_NAME, WAIT_TIME);
            device.waitForIdle();

            // Exit activity, check to see if we are now cached.
            final Intent finishIntent = new Intent();
            finishIntent.setPackage(CANT_SAVE_STATE_1_PACKAGE_NAME);
            finishIntent.setAction(ACTION_FINISH);
            finishIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            finishIntent.addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP);
            mTargetContext.startActivity(finishIntent);

            uid1Watcher.expect(WatchUidRunner.CMD_CACHED, null);
            uid1Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_CACHED_RECENT);

            // Make both apps idle for cleanliness.
            cmd = ""am make-uid-idle "" + CANT_SAVE_STATE_1_PACKAGE_NAME;
            result = SystemUtil.runShellCommand(mInstrumentation, cmd);
            cmd = ""am make-uid-idle "" + CANT_SAVE_STATE_2_PACKAGE_NAME;
            result = SystemUtil.runShellCommand(mInstrumentation, cmd);

        } finally {
            uid2Watcher.finish();
            uid1Watcher.finish();
        }
    }

    /**
     * Test a service binding cycle between two apps, with one of them also running a foreground
     * service. The other app should also get an FGS proc state. On stopping the foreground service,
     * app should go back to cached state.
     *
     * @throws Exception
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.media.cts.VideoDecoderPerfTest"	"currentTimeMillis"	"CtsMediaTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/VideoDecoderPerfTest.java"	""	"public void test/*
 *.
 */

package android.media.cts;

import android.content.Context;
import android.media.MediaCodec;
import android.media.MediaCodecInfo.VideoCapabilities;
import android.media.MediaExtractor;
import android.media.MediaFormat;
import android.os.Build;
import android.os.Bundle;
import android.platform.test.annotations.AppModeFull;
import android.util.Log;
import android.util.Pair;
import android.text.TextUtils;
import android.view.Surface;
import androidx.test.platform.app.InstrumentationRegistry;

import com.android.compatibility.common.util.DeviceReportLog;
import com.android.compatibility.common.util.MediaPerfUtils;
import com.android.compatibility.common.util.MediaUtils;
import com.android.compatibility.common.util.ResultType;
import com.android.compatibility.common.util.ResultUnit;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.Scanner;

@MediaHeavyPresubmitTest
@AppModeFull(reason = ""TODO: evaluate and port to instant"")
public class VideoDecoderPerfTest extends MediaPlayerTestBase {
    private static final String TAG = ""VideoDecoderPerfTest"";
    private static final String REPORT_LOG_NAME = ""CtsMediaTestCases"";
    private static final int TOTAL_FRAMES = 30000;
    private static final int MIN_FRAMES = 3000;
    private static final int MAX_TIME_MS = 120000;  // 2 minutes
    private static final int MAX_TEST_TIMEOUT_MS = 300000;  // 5 minutes
    private static final int MIN_TEST_MS = 10000;  // 10 seconds
    private static final int NUMBER_OF_REPEATS = 2;

    private static final String AVC = MediaFormat.MIMETYPE_VIDEO_AVC;
    private static final String H263 = MediaFormat.MIMETYPE_VIDEO_H263;
    private static final String HEVC = MediaFormat.MIMETYPE_VIDEO_HEVC;
    private static final String MPEG2 = MediaFormat.MIMETYPE_VIDEO_MPEG2;
    private static final String MPEG4 = MediaFormat.MIMETYPE_VIDEO_MPEG4;
    private static final String VP8 = MediaFormat.MIMETYPE_VIDEO_VP8;
    private static final String VP9 = MediaFormat.MIMETYPE_VIDEO_VP9;

    private static final boolean GOOG = true;
    private static final boolean OTHER = false;

    private static final int MAX_SIZE_SAMPLES_IN_MEMORY_BYTES = 12 << 20;  // 12MB
    // each sample contains the buffer and the PTS offset from the frame index
    LinkedList<Pair<ByteBuffer, Double>> mSamplesInMemory = new LinkedList<Pair<ByteBuffer, Double>>();
    private MediaFormat mDecInputFormat;
    private MediaFormat mDecOutputFormat;
    private int mBitrate;

    private boolean mSkipRateChecking = false;
    static final String mInpPrefix = WorkDir.getMediaDirString();

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        Bundle bundle = InstrumentationRegistry.getArguments();
        mSkipRateChecking = TextUtils.equals(""true"", bundle.getString(""mts-media""));
    }

    @Override
    protected void tearDown() throws Exception {
        super.tearDown();
    }

    private void decode(String name, final String resource, MediaFormat format) throws Exception {
        int width = format.getInteger(MediaFormat.KEY_WIDTH);
        int height = format.getInteger(MediaFormat.KEY_HEIGHT);
        String mime = format.getString(MediaFormat.KEY_MIME);

        // Ensure we can finish this test within the test timeout. Allow 25% slack (4/5).
        long maxTimeMs = Math.min(
                MAX_TEST_TIMEOUT_MS * 4 / 5 / NUMBER_OF_REPEATS, MAX_TIME_MS);
        // reduce test run on non-real device
        if (MediaUtils.onFrankenDevice()) {
            maxTimeMs /= 10;
        }
        double measuredFps[] = new double[NUMBER_OF_REPEATS];

        for (int i = 0; i < NUMBER_OF_REPEATS; ++i) {
            // Decode to Surface.
            Log.d(TAG, ""round #"" + i + "": "" + name + "" for "" + maxTimeMs + "" msecs to surface"");
            Surface s = getActivity().getSurfaceHolder().getSurface();
            // only verify the result for decode to surface case.
            measuredFps[i] = doDecode(name, resource, width, height, s, i, maxTimeMs);

            // We don't test decoding to buffer.
            // Log.d(TAG, ""round #"" + i + "" decode to buffer"");
            // doDecode(name, video, width, height, null, i, maxTimeMs);
        }

        String error =
            MediaPerfUtils.verifyAchievableFrameRates(name, mime, width, height, measuredFps);
        // Performance numbers only make sense on real devices, so skip on non-real devices
        if ((MediaUtils.onFrankenDevice() || mSkipRateChecking) && error != null) {
            // ensure there is data, but don't insist that it is correct
            assertFalse(error, error.startsWith(""Failed to get ""));
        } else {
            assertNull(error, error);
        }
        mSamplesInMemory.clear();
    }

    private double doDecode(String name, final String filename, int w, int h, Surface surface,
            int round, long maxTimeMs) throws Exception {
        final String video = mInpPrefix + filename;
        Preconditions.assertTestFileExists(video);
        MediaExtractor extractor = new MediaExtractor();
        extractor.setDataSource(video);
        extractor.selectTrack(0);
        int trackIndex = extractor.getSampleTrackIndex();
        MediaFormat format = extractor.getTrackFormat(trackIndex);
        String mime = format.getString(MediaFormat.KEY_MIME);

        // use frame rate to calculate PTS offset used for PTS scaling
        double frameRate = 0.; // default - 0 is used for using zero PTS offset
        if (format.containsKey(MediaFormat.KEY_FRAME_RATE)) {
            frameRate = format.getInteger(MediaFormat.KEY_FRAME_RATE);
        } else if (!mime.equals(MediaFormat.MIMETYPE_VIDEO_VP8)
                && !mime.equals(MediaFormat.MIMETYPE_VIDEO_VP9)) {
            fail(""need framerate info for video file"");
        }

        ByteBuffer[] codecInputBuffers;
        ByteBuffer[] codecOutputBuffers;

        if (mSamplesInMemory.size() == 0) {
            int totalMemory = 0;
            ByteBuffer tmpBuf = ByteBuffer.allocate(w * h * 3 / 2);
            int sampleSize = 0;
            int index = 0;
            long firstPTS = 0;
            double presentationOffset = 0.;
            while ((sampleSize = extractor.readSampleData(tmpBuf, 0 /* offset */)) > 0) {
                if (totalMemory + sampleSize > MAX_SIZE_SAMPLES_IN_MEMORY_BYTES) {
                    break;
                }
                if (mSamplesInMemory.size() == 0) {
                    firstPTS = extractor.getSampleTime();
                }
                ByteBuffer copied = ByteBuffer.allocate(sampleSize);
                copied.put(tmpBuf);
                if (frameRate > 0.) {
                    // presentation offset is an offset from the frame index
                    presentationOffset =
                        (extractor.getSampleTime() - firstPTS) * frameRate / 1e6 - index;
                }
                mSamplesInMemory.addLast(Pair.create(copied, presentationOffset));
                totalMemory += sampleSize;
                ++index;
                extractor.advance();
            }
            Log.d(TAG, mSamplesInMemory.size() + "" samples in memory for "" +
                    (totalMemory / 1024) + "" KB."");
            // bitrate normalized to 30fps
            mBitrate = (int)Math.round(totalMemory * 30. * 8. / mSamplesInMemory.size());
        }
        format.setInteger(MediaFormat.KEY_BIT_RATE, mBitrate);

        int sampleIndex = 0;

        extractor.release();

        MediaCodec codec = MediaCodec.createByCodecName(name);
        VideoCapabilities cap = codec.getCodecInfo().getCapabilitiesForType(mime).getVideoCapabilities();
        frameRate = cap.getSupportedFrameRatesFor(w, h).getUpper();
        codec.configure(format, surface, null /* crypto */, 0 /* flags */);
        codec.start();
        codecInputBuffers = codec.getInputBuffers();
        codecOutputBuffers = codec.getOutputBuffers();
        mDecInputFormat = codec.getInputFormat();

        // start decode loop
        MediaCodec.BufferInfo info = new MediaCodec.BufferInfo();

        final long kTimeOutUs = 1000; // 1ms timeout
        double[] frameTimeUsDiff = new double[TOTAL_FRAMES - 1];
        long lastOutputTimeUs = 0;
        boolean sawInputEOS = false;
        boolean sawOutputEOS = false;
        int inputNum = 0;
        int outputNum = 0;
        long start = System.currentTimeMillis();
        while (!sawOutputEOS) {
            // handle input
            if (!sawInputEOS) {
                int inputBufIndex = codec.dequeueInputBuffer(kTimeOutUs);

                if (inputBufIndex >= 0) {
                    ByteBuffer dstBuf = codecInputBuffers[inputBufIndex];
                    // sample contains the buffer and the PTS offset normalized to frame index
                    Pair<ByteBuffer, Double> sample =
                            mSamplesInMemory.get(sampleIndex++ % mSamplesInMemory.size());
                    sample.first.rewind();
                    int sampleSize = sample.first.remaining();
                    dstBuf.put(sample.first);
                    // use max supported framerate to compute pts
                    long presentationTimeUs = (long)((inputNum + sample.second) * 1e6 / frameRate);

                    long elapsed = System.currentTimeMillis() - start;
                    sawInputEOS = ((++inputNum == TOTAL_FRAMES)
                                   || (elapsed > maxTimeMs)
                                   || (elapsed > MIN_TEST_MS && outputNum > MIN_FRAMES));
                    if (sawInputEOS) {
                        Log.d(TAG, ""saw input EOS (stop at sample)."");
                    }
                    codec.queueInputBuffer(
                            inputBufIndex,
                            0 /* offset */,
                            sampleSize,
                            presentationTimeUs,
                            sawInputEOS ? MediaCodec.BUFFER_FLAG_END_OF_STREAM : 0);
                } else {
                    assertEquals(
                            ""codec.dequeueInputBuffer() unrecognized return value: "" + inputBufIndex,
                            MediaCodec.INFO_TRY_AGAIN_LATER, inputBufIndex);
                }
            }

            // handle output
            int outputBufIndex = codec.dequeueOutputBuffer(info, kTimeOutUs);

            if (outputBufIndex >= 0) {
                if (info.size > 0) { // Disregard 0-sized buffers at the end.
                    long nowUs = (System.nanoTime() + 500) / 1000;
                    if (outputNum > 1) {
                        frameTimeUsDiff[outputNum - 1] = nowUs - lastOutputTimeUs;
                    }
                    lastOutputTimeUs = nowUs;
                    outputNum++;
                }
                codec.releaseOutputBuffer(outputBufIndex, false /* render */);
                if ((info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {
                    Log.d(TAG, ""saw output EOS."");
                    sawOutputEOS = true;
                }
            } else if (outputBufIndex == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {
                codecOutputBuffers = codec.getOutputBuffers();
                Log.d(TAG, ""output buffers have changed."");
            } else if (outputBufIndex == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {
                mDecOutputFormat = codec.getOutputFormat();
                int width = mDecOutputFormat.getInteger(MediaFormat.KEY_WIDTH);
                int height = mDecOutputFormat.getInteger(MediaFormat.KEY_HEIGHT);
                Log.d(TAG, ""output resolution "" + width + ""x"" + height);
            } else {
                assertEquals(
                        ""codec.dequeueOutputBuffer() unrecognized return index: ""
                                + outputBufIndex,
                        MediaCodec.INFO_TRY_AGAIN_LATER, outputBufIndex);
            }
        }
        long finish = System.currentTimeMillis();
        int validDataNum = outputNum - 1;
        frameTimeUsDiff = Arrays.copyOf(frameTimeUsDiff, validDataNum);
        codec.stop();
        codec.release();

        Log.d(TAG, ""input num "" + inputNum + "" vs output num "" + outputNum);

        DeviceReportLog log = new DeviceReportLog(REPORT_LOG_NAME, ""video_decoder_performance"");
        String message = MediaPerfUtils.addPerformanceHeadersToLog(
                log, ""decoder stats: decodeTo="" + ((surface == null) ? ""buffer"" : ""surface""),
                round, name, format, mDecInputFormat, mDecOutputFormat);
        log.addValue(""video_res"", video, ResultType.NEUTRAL, ResultUnit.NONE);
        log.addValue(""decode_to"", surface == null ? ""buffer"" : ""surface"",
                ResultType.NEUTRAL, ResultUnit.NONE);

        double fps = outputNum / ((finish - start) / 1000.0);
        log.addValue(""average_fps"", fps, ResultType.HIGHER_BETTER, ResultUnit.FPS);

        MediaUtils.Stats stats = new MediaUtils.Stats(frameTimeUsDiff);
        fps = MediaPerfUtils.addPerformanceStatsToLog(log, stats, message);
        log.submit(getInstrumentation());
        return fps;
    }

    private MediaFormat[] getVideoTrackFormats(String... resources) throws Exception {
        MediaFormat[] formats = new MediaFormat[resources.length];
        for (int i = 0; i < resources.length; ++i) {
            Preconditions.assertTestFileExists(mInpPrefix + resources[i]);
            formats[i] = MediaUtils.getTrackFormatForResource(mInpPrefix + resources[i], ""video/"");
        }
        return formats;
    }

    private void count(final String[] resources, int numGoog, int numOther) throws Exception {
        MediaFormat[] formats = getVideoTrackFormats(resources);
        MediaUtils.verifyNumCodecs(numGoog,  false /* isEncoder */, true /* isGoog */,  formats);
        MediaUtils.verifyNumCodecs(numOther, false /* isEncoder */, false /* isGoog */, formats);
    }

    private void perf(final String[] resources, boolean isGoog, int ix)  throws Exception {
        MediaFormat[] formats = getVideoTrackFormats(resources);
        String[] decoders = MediaUtils.getDecoderNames(isGoog, formats);
        String kind = isGoog ? ""Google"" : ""non-Google"";
        if (decoders.length == 0) {
            MediaUtils.skipTest(""No "" + kind + "" decoders for "" + Arrays.toString(formats));
            return;
        } else if (ix >= decoders.length) {
            Log.i(TAG, ""No more "" + kind + "" decoders for "" + Arrays.toString(formats));
            return;
        }

        String decoderName = decoders[ix];

        // Decode/measure the first supported video resource
        for (int i = 0; i < resources.length; ++i) {
            if (MediaUtils.supports(decoderName, formats[i])) {
                decode(decoderName, resources[i], formats[i]);
                break;
            }
        }
    }

    // Poor man's Parametrized test as this test must still run on CTSv1 runner.

    // The count tests are to ensure this Cts test covers all decoders. Add further
    // tests and change the count if there can be more decoders.

    // AVC tests

    private static final String[] sAvcMedia0320x0240 = {
        ""bbb_s1_320x240_mp4_h264_mp2_800kbps_30fps_aac_lc_5ch_240kbps_44100hz.mp4"",
    };"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.app.cts.DialogTest"	"testSetCancelMessage"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/DialogTest.java"	""	"public void testSetCancelMessage() throws Exception {
        mCalledCallback = false;
        startDialogActivity(DialogStubActivity.TEST_ONSTART_AND_ONSTOP);
        final TestDialog d = (TestDialog) mActivity.getDialog();
        final HandlerThread ht = new HandlerThread(""DialogTest"");
        ht.start();

        d.setCancelMessage(new MockDismissCancelHandler(d, ht.getLooper()).obtainMessage(CANCEL,
                new OnCancelListener() {
                    public void onCancel(DialogInterface dialog) {
                        mCalledCallback = true;
                    }
                }));
        assertTrue(d.isShowing());
        assertFalse(mCalledCallback);
        sendKeys(KeyEvent.KEYCODE_BACK);
        PollingCheck.waitFor(() -> mCalledCallback);
        PollingCheck.waitFor(() -> !d.isShowing());

        ht.join(100);
    }

    /*
     * Test point
     * 1. Set a listener to be invoked when the dialog is dismissed.
     * 2. set onDismissListener to null, it will not changed flag after dialog dismissed.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.app.cts.DialogTest"	"testSetDismissMessage"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/DialogTest.java"	""	"public void testSetDismissMessage() throws Throwable {
        mCalledCallback = false;
        startDialogActivity(DialogStubActivity.TEST_DIALOG_WITHOUT_THEME);
        final Dialog d = mActivity.getDialog();

        final HandlerThread ht = new HandlerThread(""DialogTest"");
        ht.start();

        d.setDismissMessage(new MockDismissCancelHandler(d, ht.getLooper()).obtainMessage(DISMISS,
                new OnDismissListener() {
                    public void onDismiss(DialogInterface dialog) {
                        mCalledCallback = true;
                    }
                }));
        assertTrue(d.isShowing());
        assertFalse(mCalledCallback);
        dialogDismiss(d);
        ht.join(100);
        assertTrue(mCalledCallback);
        assertFalse(d.isShowing());
    }

    private void dialogDismiss(final Dialog d) throws Throwable {
        mScenario.onActivity(activity -> {
            d.dismiss();
        });
        mInstrumentation.waitForIdleSync();
    }

    private void dialogCancel(final Dialog d) throws Throwable {
        mScenario.onActivity(activity -> {
            d.cancel();
        });
        mInstrumentation.waitForIdleSync();
    }

    private void sendKeys(int keyCode) {
        mInstrumentation.sendKeyDownUpSync(keyCode);
    }

    private static class MockDismissCancelHandler extends Handler {
        private WeakReference<DialogInterface> mDialog;

        public MockDismissCancelHandler(Dialog dialog, Looper looper) {
            super(looper);

            mDialog = new WeakReference<DialogInterface>(dialog);
        }

        @Override
        public void handleMessage(Message msg) {
            switch (msg.what) {
            case DISMISS:
                ((OnDismissListener) msg.obj).onDismiss(mDialog.get());
                break;
            case CANCEL:
                ((OnCancelListener) msg.obj).onCancel(mDialog.get());
                break;
            }
        }
    }

    private static class MockDrawable extends Drawable {
        @Override
        public void draw(Canvas canvas) {
        }

        @Override
        public int getOpacity() {
            return 0;
        }

        @Override
        public void setAlpha(int alpha) {
        }

        @Override
        public void setColorFilter(ColorFilter cf) {
        }
    }

    private static class MockView extends View {
        public boolean isShowContextMenuCalled;
        protected OnCreateContextMenuListener mOnCreateContextMenuListener;

        public MockView(Context context) {
            super(context);
        }

        public void setOnCreateContextMenuListener(OnCreateContextMenuListener l) {
            super.setOnCreateContextMenuListener(l);
            mOnCreateContextMenuListener = l;
        }

        @Override
        public boolean showContextMenu() {
            isShowContextMenuCalled = true;
            return super.showContextMenu();
        }
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.server.cts.ProtoDumpTestCase"	"CollectingTestListener"	"CtsIncidentHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/incident/src/com/android/server/cts/ProtoDumpTestCase.java"	""	"public void test/*
 *.
 */

package com.android.server.cts;

import com.android.compatibility.common.tradefed.build.CompatibilityBuildHelper;
import com.android.ddmlib.IShellOutputReceiver;
import com.android.ddmlib.testrunner.RemoteAndroidTestRunner;
import com.android.ddmlib.testrunner.TestResult.TestStatus;
import com.android.tradefed.build.IBuildInfo;
import com.android.tradefed.device.CollectingByteOutputReceiver;
import com.android.tradefed.device.CollectingOutputReceiver;
import com.android.tradefed.device.DeviceNotAvailableException;
import com.android.tradefed.log.LogUtil.CLog;
import com.android.tradefed.result.CollectingTestListener;
import com.android.tradefed.result.TestDescription;
import com.android.tradefed.result.TestResult;
import com.android.tradefed.result.TestRunResult;
import com.android.tradefed.testtype.DeviceTestCase;
import com.android.tradefed.testtype.IBuildReceiver;

import com.google.common.base.Charsets;
import com.google.protobuf.InvalidProtocolBufferException;
import com.google.protobuf.MessageLite;
import com.google.protobuf.Parser;

import java.io.FileNotFoundException;
import java.util.Map;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;

public class ProtoDumpTestCase extends DeviceTestCase implements IBuildReceiver {
    protected static final int PRIVACY_AUTO = 0;
    protected static final int PRIVACY_EXPLICIT = 1;
    protected static final int PRIVACY_LOCAL = 2;
    /** No privacy filtering has been done. All fields should be present. */
    protected static final int PRIVACY_NONE = 3;
    protected static String privacyToString(int privacy) {
        switch (privacy) {
            case PRIVACY_AUTO:
                return ""AUTO"";
            case PRIVACY_EXPLICIT:
                return ""EXPLICIT"";
            case PRIVACY_LOCAL:
                return ""LOCAL"";
            case PRIVACY_NONE:
                return ""NONE"";
            default:
                return ""UNKNOWN"";
        }
    }

    protected IBuildInfo mCtsBuild;

    private static final String TEST_RUNNER = ""androidx.test.runner.AndroidJUnitRunner"";

    @Override
    protected void setUp() throws Exception {
        super.setUp();

        assertNotNull(mCtsBuild);
    }

    @Override
    public void setBuild(IBuildInfo buildInfo) {
        mCtsBuild = buildInfo;
    }

    /**
     * Call onto the device with an adb shell command and get the results of
     * that as a proto of the given type.
     *
     * @param parser A protobuf parser object. e.g. MyProto.parser()
     * @param command The adb shell command to run. e.g. ""dumpsys fingerprint --proto""
     *
     * @throws DeviceNotAvailableException If there was a problem communicating with
     *      the test device.
     * @throws InvalidProtocolBufferException If there was an error parsing
     *      the proto. Note that a 0 length buffer is not necessarily an error.
     */
    public <T extends MessageLite> T getDump(Parser<T> parser, String command) throws Exception {
        final CollectingByteOutputReceiver receiver = new CollectingByteOutputReceiver();
        getDevice().executeShellCommand(command, receiver);
        return parser.parseFrom(receiver.getOutput());
    }

    /**
     * Install a device side test package.
     *
     * @param appFileName Apk file name, such as ""CtsNetStatsApp.apk"".
     * @param grantPermissions whether to give runtime permissions.
     */
    protected void installPackage(String appFileName, boolean grantPermissions)
            throws FileNotFoundException, DeviceNotAvailableException {
        CLog.d(""Installing app "" + appFileName);
        CompatibilityBuildHelper buildHelper = new CompatibilityBuildHelper(mCtsBuild);
        final String result = getDevice().installPackage(
                buildHelper.getTestFile(appFileName), true, grantPermissions);
        assertNull(""Failed to install "" + appFileName + "": "" + result, result);
    }

    /**
     * Run a device side test.
     *
     * @param pkgName Test package name, such as ""com.android.server.cts.netstats"".
     * @param testClassName Test class name; either a fully qualified name, or ""."" + a class name.
     * @param testMethodName Test method name.
     * @throws DeviceNotAvailableException
     */
    protected void runDeviceTests(@Nonnull String pkgName,
            @Nullable String testClassName, @Nullable String testMethodName)
            throws DeviceNotAvailableException {
        if (testClassName != null && testClassName.startsWith(""."")) {
            testClassName = pkgName + testClassName;
        }

        RemoteAndroidTestRunner testRunner = new RemoteAndroidTestRunner(
                pkgName, TEST_RUNNER, getDevice().getIDevice());
        if (testClassName != null && testMethodName != null) {
            testRunner.setMethodName(testClassName, testMethodName);
        } else if (testClassName != null) {
            testRunner.setClassName(testClassName);
        }

        CollectingTestListener listener = new CollectingTestListener();
        assertTrue(getDevice().runInstrumentationTests(testRunner, listener));

        final TestRunResult result = listener.getCurrentRunResults();
        if (result.isRunFailure()) {
            throw new AssertionError(""Failed to successfully run device tests for ""
                    + result.getName() + "": "" + result.getRunFailureMessage());
        }
        if (result.getNumTests() == 0) {
            throw new AssertionError(""No tests were run on the device"");
        }

        if (result.hasFailedTests()) {
            // build a meaningful error message
            StringBuilder errorBuilder = new StringBuilder(""On-device tests failed:\n"");
            for (Map.Entry<TestDescription, TestResult> resultEntry :
                    result.getTestResults().entrySet()) {
                if (!resultEntry.getValue().getStatus().equals(TestStatus.PASSED)) {
                    errorBuilder.append(resultEntry.getKey().toString());
                    errorBuilder.append("":\n"");
                    errorBuilder.append(resultEntry.getValue().getStackTrace());
                }
            }
            throw new AssertionError(errorBuilder.toString());
        }
    }

    /**
     * Execute the given command, and returns the output.
     */
    protected String execCommandAndGet(String command) throws Exception {
        final CollectingOutputReceiver receiver = new CollectingOutputReceiver();
        getDevice().executeShellCommand(command, receiver);
        return receiver.getOutput();
    }

    /**
     * Execute the given command, and find the given pattern with given flags and return the
     * resulting {@link Matcher}.
     */
    protected Matcher execCommandAndFind(String command, String pattern, int patternFlags)
            throws Exception {
        final String output = execCommandAndGet(command);
        final Matcher matcher = Pattern.compile(pattern, patternFlags).matcher(output);
        assertTrue(""Pattern '"" + pattern + ""' didn't match. Output=\n"" + output, matcher.find());
        return matcher;
    }

    /**
     * Execute the given command, and find the given pattern and return the resulting
     * {@link Matcher}.
     */
    protected Matcher execCommandAndFind(String command, String pattern) throws Exception {
        return execCommandAndFind(command, pattern, 0);
    }

    /**
     * Execute the given command, find the given pattern, and return the first captured group
     * as a String.
     */
    protected String execCommandAndGetFirstGroup(String command, String pattern) throws Exception {
        final Matcher matcher = execCommandAndFind(command, pattern);
        assertTrue(""No group found for pattern '"" + pattern + ""'"", matcher.groupCount() > 0);
        return matcher.group(1);
    }

    /**
     * Runs logcat and waits (for a maximumum of maxTimeMs) until the desired text is displayed with
     * the given tag.
     * Logcat is not cleared, so make sure that text is unique (won't get false hits from old data).
     * Note that, in practice, the actual max wait time seems to be about 10s longer than maxTimeMs.
     * Returns true means the desired log line is found.
     */
    protected boolean checkLogcatForText(String logcatTag, String text, int maxTimeMs) {
        IShellOutputReceiver receiver = new IShellOutputReceiver() {
            private final StringBuilder mOutputBuffer = new StringBuilder();
            private final AtomicBoolean mIsCanceled = new AtomicBoolean(false);

            @Override
            public void addOutput(byte[] data, int offset, int length) {
                if (!isCancelled()) {
                    synchronized (mOutputBuffer) {
                        String s = new String(data, offset, length, Charsets.UTF_8);
                        mOutputBuffer.append(s);
                        if (checkBufferForText()) {
                            mIsCanceled.set(true);
                        }
                    }
                }
            }

            private boolean checkBufferForText() {
                if (mOutputBuffer.indexOf(text) > -1) {
                    return true;
                } else {
                    // delete all old data (except the last few chars) since they don't contain text
                    // (presumably large chunks of data will be added at a time, so this is
                    // sufficiently efficient.)
                    int newStart = mOutputBuffer.length() - text.length();
                    if (newStart > 0) {
                        mOutputBuffer.delete(0, newStart);
                    }
                    return false;
                }
            }

            @Override
            public boolean isCancelled() {
                return mIsCanceled.get();
            }

            @Override
            public void flush() {
            }
        };

        try {
            // Wait for at most maxTimeMs for logcat to display the desired text.
            getDevice().executeShellCommand(String.format(""logcat -s %s -e '%s'"", logcatTag, text),
                    receiver, maxTimeMs, TimeUnit.MILLISECONDS, 0);
            return receiver.isCancelled();
        } catch (com.android.tradefed.device.DeviceNotAvailableException e) {
            System.err.println(e);
        }
        return false;
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.hardware.camera2.cts.CaptureRequestTest"	"testExtendedSceneModes"	"CtsCameraTestCases"	"/home/gpoor/cts-12-source/cts/tests/camera/src/android/hardware/camera2/cts/CaptureRequestTest.java"	""	"public void testExtendedSceneModes() throws Exception {
        for (String id : mCameraIdsUnderTest) {
            try {
                if (!mAllStaticInfo.get(id).isColorOutputSupported()) {
                    Log.i(TAG, ""Camera "" + id + "" does not support color outputs, skipping"");
                    continue;
                }
                openDevice(id);
                List<Range<Integer>> fpsRanges = getTargetFpsRangesUpTo30(mStaticInfo);
                extendedSceneModeTestByCamera(fpsRanges);
            } finally {
                closeDevice();
            }
        }
    }

    // TODO: add 3A state machine test.

    /**
     * Per camera dynamic black and white level test.
     */
    private void dynamicBlackWhiteLevelTestByCamera() throws Exception {
        SimpleCaptureCallback resultListener = new SimpleCaptureCallback();
        SimpleImageReaderListener imageListener = null;
        CaptureRequest.Builder previewBuilder =
                mCamera.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);
        CaptureRequest.Builder rawBuilder = null;
        Size previewSize =
                getMaxPreviewSize(mCamera.getId(), mCameraManager,
                getPreviewSizeBound(mWindowManager, PREVIEW_SIZE_BOUND));
        Size rawSize = null;
        boolean canCaptureBlackRaw =
                mStaticInfo.isCapabilitySupported(
                        CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_RAW) &&
                mStaticInfo.isOpticalBlackRegionSupported();
        if (canCaptureBlackRaw) {
            // Capture Raw16, then calculate the optical black, and use it to check with the dynamic
            // black level.
            rawBuilder =
                    mCamera.createCaptureRequest(CameraDevice.TEMPLATE_STILL_CAPTURE);
            rawSize = mStaticInfo.getRawDimensChecked();
            imageListener = new SimpleImageReaderListener();
            prepareRawCaptureAndStartPreview(previewBuilder, rawBuilder, previewSize, rawSize,
                    resultListener, imageListener);
        } else {
            startPreview(previewBuilder, previewSize, resultListener);
        }

        // Capture a sequence of frames with different sensitivities and validate the black/white
        // level values
        int[] sensitivities = getSensitivityTestValues();
        float[][] dynamicBlackLevels = new float[sensitivities.length][];
        int[] dynamicWhiteLevels = new int[sensitivities.length];
        float[][] opticalBlackLevels = new float[sensitivities.length][];
        for (int i = 0; i < sensitivities.length; i++) {
            CaptureResult result = null;
            if (canCaptureBlackRaw) {
                changeExposure(rawBuilder, DEFAULT_EXP_TIME_NS, sensitivities[i]);
                CaptureRequest rawRequest = rawBuilder.build();
                mSession.capture(rawRequest, resultListener, mHandler);
                result = resultListener.getCaptureResultForRequest(rawRequest,
                        NUM_RESULTS_WAIT_TIMEOUT);
                Image rawImage = imageListener.getImage(CAPTURE_IMAGE_TIMEOUT_MS);

                // Get max (area-wise) optical black region
                Rect[] opticalBlackRegions = mStaticInfo.getCharacteristics().get(
                        CameraCharacteristics.SENSOR_OPTICAL_BLACK_REGIONS);
                Rect maxRegion = opticalBlackRegions[0];
                for (Rect region : opticalBlackRegions) {
                    if (region.width() * region.height() > maxRegion.width() * maxRegion.height()) {
                        maxRegion = region;
                    }
                }

                // Get average black pixel values in the region (region is multiple of 2x2)
                Image.Plane rawPlane = rawImage.getPlanes()[0];
                ByteBuffer rawBuffer = rawPlane.getBuffer();
                float[] avgBlackLevels = {0, 0, 0, 0};
                final int rowSize = rawPlane.getRowStride();
                final int bytePerPixel = rawPlane.getPixelStride();
                if (VERBOSE) {
                    Log.v(TAG, ""maxRegion: "" + maxRegion + "", Row stride: "" +
                            rawPlane.getRowStride());
                }
                for (int row = maxRegion.top; row < maxRegion.bottom; row += 2) {
                    for (int col = maxRegion.left; col < maxRegion.right; col += 2) {
                        int startOffset = row * rowSize + col * bytePerPixel;
                        avgBlackLevels[0] += rawBuffer.getShort(startOffset);
                        avgBlackLevels[1] += rawBuffer.getShort(startOffset + bytePerPixel);
                        startOffset += rowSize;
                        avgBlackLevels[2] += rawBuffer.getShort(startOffset);
                        avgBlackLevels[3] += rawBuffer.getShort(startOffset + bytePerPixel);
                    }
                }
                int numBlackBlocks = maxRegion.width() * maxRegion.height() / (2 * 2);
                for (int m = 0; m < avgBlackLevels.length; m++) {
                    avgBlackLevels[m] /= numBlackBlocks;
                }
                opticalBlackLevels[i] = avgBlackLevels;

                if (VERBOSE) {
                    Log.v(TAG, String.format(""Optical black level results for sensitivity (%d): %s"",
                            sensitivities[i], Arrays.toString(avgBlackLevels)));
                }

                rawImage.close();
            } else {
                changeExposure(previewBuilder, DEFAULT_EXP_TIME_NS, sensitivities[i]);
                CaptureRequest previewRequest = previewBuilder.build();
                mSession.capture(previewRequest, resultListener, mHandler);
                result = resultListener.getCaptureResultForRequest(previewRequest,
                        NUM_RESULTS_WAIT_TIMEOUT);
            }

            dynamicBlackLevels[i] = getValueNotNull(result,
                    CaptureResult.SENSOR_DYNAMIC_BLACK_LEVEL);
            dynamicWhiteLevels[i] = getValueNotNull(result,
                    CaptureResult.SENSOR_DYNAMIC_WHITE_LEVEL);
        }

        if (VERBOSE) {
            Log.v(TAG, ""Different sensitivities tested: "" + Arrays.toString(sensitivities));
            Log.v(TAG, ""Dynamic black level results: "" + Arrays.deepToString(dynamicBlackLevels));
            Log.v(TAG, ""Dynamic white level results: "" + Arrays.toString(dynamicWhiteLevels));
            if (canCaptureBlackRaw) {
                Log.v(TAG, ""Optical black level results "" +
                        Arrays.deepToString(opticalBlackLevels));
            }
        }

        // check the dynamic black level against global black level.
        // Implicit guarantee: if the dynamic black level is supported, fixed black level must be
        // supported as well (tested in ExtendedCameraCharacteristicsTest#testOpticalBlackRegions).
        BlackLevelPattern blackPattern = mStaticInfo.getCharacteristics().get(
                CameraCharacteristics.SENSOR_BLACK_LEVEL_PATTERN);
        int[] fixedBlackLevels = new int[4];
        int fixedWhiteLevel = mStaticInfo.getCharacteristics().get(
                CameraCharacteristics.SENSOR_INFO_WHITE_LEVEL);
        blackPattern.copyTo(fixedBlackLevels, 0);
        float maxBlackDeviation = 0;
        int maxWhiteDeviation = 0;
        for (int i = 0; i < dynamicBlackLevels.length; i++) {
            for (int j = 0; j < dynamicBlackLevels[i].length; j++) {
                if (maxBlackDeviation < Math.abs(fixedBlackLevels[j] - dynamicBlackLevels[i][j])) {
                    maxBlackDeviation = Math.abs(fixedBlackLevels[j] - dynamicBlackLevels[i][j]);
                }
            }
            if (maxWhiteDeviation < Math.abs(dynamicWhiteLevels[i] - fixedWhiteLevel)) {
                maxWhiteDeviation = Math.abs(dynamicWhiteLevels[i] - fixedWhiteLevel);
            }
        }
        mCollector.expectLessOrEqual(""Max deviation of the dynamic black level vs fixed black level""
                + "" exceed threshold.""
                + "" Dynamic black level results: "" + Arrays.deepToString(dynamicBlackLevels),
                fixedBlackLevels[0] * DYNAMIC_VS_FIXED_BLK_WH_LVL_ERROR_MARGIN, maxBlackDeviation);
        mCollector.expectLessOrEqual(""Max deviation of the dynamic white level exceed threshold.""
                + "" Dynamic white level results: "" + Arrays.toString(dynamicWhiteLevels),
                fixedWhiteLevel * DYNAMIC_VS_FIXED_BLK_WH_LVL_ERROR_MARGIN,
                (float)maxWhiteDeviation);

        // Validate against optical black levels if it is available
        if (canCaptureBlackRaw) {
            maxBlackDeviation = 0;
            for (int i = 0; i < dynamicBlackLevels.length; i++) {
                for (int j = 0; j < dynamicBlackLevels[i].length; j++) {
                    if (maxBlackDeviation <
                            Math.abs(opticalBlackLevels[i][j] - dynamicBlackLevels[i][j])) {
                        maxBlackDeviation =
                                Math.abs(opticalBlackLevels[i][j] - dynamicBlackLevels[i][j]);
                    }
                }
            }

            mCollector.expectLessOrEqual(""Max deviation of the dynamic black level vs optical black""
                    + "" exceed threshold.""
                    + "" Dynamic black level results: "" + Arrays.deepToString(dynamicBlackLevels)
                    + "" Optical black level results: "" + Arrays.deepToString(opticalBlackLevels),
                    fixedBlackLevels[0] * DYNAMIC_VS_OPTICAL_BLK_LVL_ERROR_MARGIN,
                    maxBlackDeviation);
        }
    }

    private void noiseReductionModeTestByCamera(List<Range<Integer>> fpsRanges) throws Exception {
        Size maxPrevSize = mOrderedPreviewSizes.get(0);
        CaptureRequest.Builder requestBuilder =
                mCamera.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);
        int[] availableModes = mStaticInfo.getAvailableNoiseReductionModesChecked();

        for (int mode : availableModes) {
            requestBuilder.set(CaptureRequest.NOISE_REDUCTION_MODE, mode);

            // Test that OFF and FAST mode should not slow down the frame rate.
            if (mode == CaptureRequest.NOISE_REDUCTION_MODE_OFF ||
                    mode == CaptureRequest.NOISE_REDUCTION_MODE_FAST) {
                verifyFpsNotSlowDown(requestBuilder, NUM_FRAMES_VERIFIED, fpsRanges);
            }

            SimpleCaptureCallback resultListener = new SimpleCaptureCallback();
            startPreview(requestBuilder, maxPrevSize, resultListener);
            mSession.setRepeatingRequest(requestBuilder.build(), resultListener, mHandler);
            waitForSettingsApplied(resultListener, NUM_FRAMES_WAITED_FOR_UNKNOWN_LATENCY);

            verifyCaptureResultForKey(CaptureResult.NOISE_REDUCTION_MODE, mode,
                    resultListener, NUM_FRAMES_VERIFIED);
        }

        stopPreview();
    }

    private void focusDistanceTestByCamera() throws Exception {
        CaptureRequest.Builder requestBuilder =
                mCamera.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);
        requestBuilder.set(CaptureRequest.CONTROL_AF_MODE, CaptureRequest.CONTROL_AF_MODE_OFF);
        int calibrationStatus = mStaticInfo.getFocusDistanceCalibrationChecked();
        float errorMargin = FOCUS_DISTANCE_ERROR_PERCENT_UNCALIBRATED;
        if (calibrationStatus ==
                CameraMetadata.LENS_INFO_FOCUS_DISTANCE_CALIBRATION_CALIBRATED) {
            errorMargin = FOCUS_DISTANCE_ERROR_PERCENT_CALIBRATED;
        } else if (calibrationStatus ==
                CameraMetadata.LENS_INFO_FOCUS_DISTANCE_CALIBRATION_APPROXIMATE) {
            errorMargin = FOCUS_DISTANCE_ERROR_PERCENT_APPROXIMATE;
        }

        // Test changing focus distance with repeating request
        focusDistanceTestRepeating(requestBuilder, errorMargin);

        if (calibrationStatus ==
                CameraMetadata.LENS_INFO_FOCUS_DISTANCE_CALIBRATION_CALIBRATED)  {
            // Test changing focus distance with burst request
            focusDistanceTestBurst(requestBuilder, errorMargin);
        }
    }

    private void focusDistanceTestRepeating(CaptureRequest.Builder requestBuilder,
            float errorMargin) throws Exception {
        CaptureRequest request;
        float[] testDistances = getFocusDistanceTestValuesInOrder(0, 0);
        Size maxPrevSize = mOrderedPreviewSizes.get(0);
        SimpleCaptureCallback resultListener = new SimpleCaptureCallback();
        startPreview(requestBuilder, maxPrevSize, resultListener);

        float[] resultDistances = new float[testDistances.length];
        int[] resultLensStates = new int[testDistances.length];

        // Collect results
        for (int i = 0; i < testDistances.length; i++) {
            requestBuilder.set(CaptureRequest.LENS_FOCUS_DISTANCE, testDistances[i]);
            request = requestBuilder.build();
            resultListener = new SimpleCaptureCallback();
            mSession.setRepeatingRequest(request, resultListener, mHandler);
            waitForSettingsApplied(resultListener, NUM_FRAMES_WAITED_FOR_UNKNOWN_LATENCY);
            waitForResultValue(resultListener, CaptureResult.LENS_STATE,
                    CaptureResult.LENS_STATE_STATIONARY, NUM_RESULTS_WAIT_TIMEOUT);
            CaptureResult result = resultListener.getCaptureResultForRequest(request,
                    NUM_RESULTS_WAIT_TIMEOUT);

            resultDistances[i] = getValueNotNull(result, CaptureResult.LENS_FOCUS_DISTANCE);
            resultLensStates[i] = getValueNotNull(result, CaptureResult.LENS_STATE);

            if (VERBOSE) {
                Log.v(TAG, ""Capture repeating request focus distance: "" + testDistances[i]
                        + "" result: "" + resultDistances[i] + "" lens state "" + resultLensStates[i]);
            }
        }

        verifyFocusDistance(testDistances, resultDistances, resultLensStates,
                /*ascendingOrder*/true, /*noOvershoot*/false, /*repeatStart*/0, /*repeatEnd*/0,
                errorMargin);

        if (mStaticInfo.areKeysAvailable(CameraCharacteristics.LENS_INFO_HYPERFOCAL_DISTANCE)) {

            // Test hyperfocal distance optionally
            float hyperFocalDistance = mStaticInfo.getHyperfocalDistanceChecked();
            if (hyperFocalDistance > 0) {
                requestBuilder.set(CaptureRequest.LENS_FOCUS_DISTANCE, hyperFocalDistance);
                request = requestBuilder.build();
                resultListener = new SimpleCaptureCallback();
                mSession.setRepeatingRequest(request, resultListener, mHandler);
                waitForSettingsApplied(resultListener, NUM_FRAMES_WAITED_FOR_UNKNOWN_LATENCY);

                // Then wait for the lens.state to be stationary.
                waitForResultValue(resultListener, CaptureResult.LENS_STATE,
                        CaptureResult.LENS_STATE_STATIONARY, NUM_RESULTS_WAIT_TIMEOUT);
                CaptureResult result = resultListener.getCaptureResult(WAIT_FOR_RESULT_TIMEOUT_MS);
                Float focusDistance = getValueNotNull(result, CaptureResult.LENS_FOCUS_DISTANCE);
                mCollector.expectInRange(""Focus distance for hyper focal should be close enough to"" +
                        "" requested value"", focusDistance,
                        hyperFocalDistance * (1.0f - errorMargin),
                        hyperFocalDistance * (1.0f + errorMargin));
            }
        }
    }

    private void focusDistanceTestBurst(CaptureRequest.Builder requestBuilder,
            float errorMargin) throws Exception {

        Size maxPrevSize = mOrderedPreviewSizes.get(0);
        float[] testDistances = getFocusDistanceTestValuesInOrder(NUM_FOCUS_DISTANCES_REPEAT,
                NUM_FOCUS_DISTANCES_REPEAT);
        SimpleCaptureCallback resultListener = new SimpleCaptureCallback();
        startPreview(requestBuilder, maxPrevSize, resultListener);

        float[] resultDistances = new float[testDistances.length];
        int[] resultLensStates = new int[testDistances.length];

        final int maxPipelineDepth = mStaticInfo.getCharacteristics().get(
            CameraCharacteristics.REQUEST_PIPELINE_MAX_DEPTH);

        // Move lens to starting position, and wait for the lens.state to be stationary.
        CaptureRequest request;
        requestBuilder.set(CaptureRequest.LENS_FOCUS_DISTANCE, testDistances[0]);
        request = requestBuilder.build();
        mSession.setRepeatingRequest(request, resultListener, mHandler);
        waitForResultValue(resultListener, CaptureResult.LENS_STATE,
                CaptureResult.LENS_STATE_STATIONARY, NUM_RESULTS_WAIT_TIMEOUT);

        // Submit burst of requests with different focus distances
        List<CaptureRequest> burst = new ArrayList<>();
        for (int i = 0; i < testDistances.length; i ++) {
            requestBuilder.set(CaptureRequest.LENS_FOCUS_DISTANCE, testDistances[i]);
            burst.add(requestBuilder.build());
        }
        mSession.captureBurst(burst, resultListener, mHandler);

        for (int i = 0; i < testDistances.length; i++) {
            CaptureResult result = resultListener.getCaptureResultForRequest(
                    burst.get(i), maxPipelineDepth+1);

            resultDistances[i] = getValueNotNull(result, CaptureResult.LENS_FOCUS_DISTANCE);
            resultLensStates[i] = getValueNotNull(result, CaptureResult.LENS_STATE);

            if (VERBOSE) {
                Log.v(TAG, ""Capture burst request focus distance: "" + testDistances[i]
                        + "" result: "" + resultDistances[i] + "" lens state "" + resultLensStates[i]);
            }
        }

        verifyFocusDistance(testDistances, resultDistances, resultLensStates,
                /*ascendingOrder*/true, /*noOvershoot*/true,
                /*repeatStart*/NUM_FOCUS_DISTANCES_REPEAT, /*repeatEnd*/NUM_FOCUS_DISTANCES_REPEAT,
                errorMargin);

    }

    /**
     * Verify focus distance control.
     *
     * Assumption:
     * - First repeatStart+1 elements of requestedDistances share the same value
     * - Last repeatEnd+1 elements of requestedDistances share the same value
     * - All elements in between are monotonically increasing/decreasing depending on ascendingOrder.
     * - Focuser is at requestedDistances[0] at the beginning of the test.
     *
     * @param requestedDistances The requested focus distances
     * @param resultDistances The result focus distances
     * @param lensStates The result lens states
     * @param ascendingOrder The order of the expected focus distance request/output
     * @param noOvershoot Assert that focus control doesn't overshoot the requested value
     * @param repeatStart The number of times the starting focus distance is repeated
     * @param repeatEnd The number of times the ending focus distance is repeated
     * @param errorMargin The error margin between request and result
     */
    private void verifyFocusDistance(float[] requestedDistances, float[] resultDistances,
            int[] lensStates, boolean ascendingOrder, boolean noOvershoot, int repeatStart,
            int repeatEnd, float errorMargin) {

        float minValue = 0;
        float maxValue = mStaticInfo.getMinimumFocusDistanceChecked();
        float hyperfocalDistance = 0;
        if (mStaticInfo.areKeysAvailable(CameraCharacteristics.LENS_INFO_HYPERFOCAL_DISTANCE)) {
            hyperfocalDistance = mStaticInfo.getHyperfocalDistanceChecked();
        }

        // Verify lens and focus distance do not change for first repeatStart
        // results.
        for (int i = 0; i < repeatStart; i ++) {
            float marginMin = requestedDistances[i] * (1.0f - errorMargin);
            // HAL may choose to use hyperfocal distance for all distances between [0, hyperfocal].
            float marginMax =
                    Math.max(requestedDistances[i], hyperfocalDistance) * (1.0f + errorMargin);

            mCollector.expectEquals(""Lens moves even though focus_distance didn't change"",
                    lensStates[i], CaptureResult.LENS_STATE_STATIONARY);
            if (noOvershoot) {
                mCollector.expectInRange(""Focus distance in result should be close enough to "" +
                        ""requested value"", resultDistances[i], marginMin, marginMax);
            }
            mCollector.expectInRange(""Result focus distance is out of range"",
                    resultDistances[i], minValue, maxValue);
        }

        for (int i = repeatStart; i < resultDistances.length-1; i ++) {
            float marginMin = requestedDistances[i] * (1.0f - errorMargin);
            // HAL may choose to use hyperfocal distance for all distances between [0, hyperfocal].
            float marginMax =
                    Math.max(requestedDistances[i], hyperfocalDistance) * (1.0f + errorMargin);
            if (noOvershoot) {
                // Result focus distance shouldn't overshoot the request
                boolean condition;
                if (ascendingOrder) {
                    condition = resultDistances[i] <= marginMax;
               } else {
                    condition = resultDistances[i] >= marginMin;
                }
                mCollector.expectTrue(String.format(
                      ""Lens shouldn't move past request focus distance. result "" +
                      resultDistances[i] + "" vs target of "" +
                      (ascendingOrder ? marginMax : marginMin)), condition);
            }

            // Verify monotonically increased focus distance setting
            boolean condition;
            float compareDistance = resultDistances[i+1] - resultDistances[i];
            if (i < resultDistances.length-1-repeatEnd) {
                condition = (ascendingOrder ? compareDistance > 0 : compareDistance < 0);
            } else {
                condition = (ascendingOrder ? compareDistance >= 0 : compareDistance <= 0);
            }
            mCollector.expectTrue(String.format(""Adjacent [resultDistances, lens_state] results [""
                  + resultDistances[i] + "","" + lensStates[i] + ""], ["" + resultDistances[i+1] + "",""
                  + lensStates[i+1] + ""] monotonicity is broken""), condition);
        }

        mCollector.expectTrue(String.format(""All values of this array are equal: "" +
                resultDistances[0] + "" "" + resultDistances[resultDistances.length-1]),
                resultDistances[0] != resultDistances[resultDistances.length-1]);

        // Verify lens moved to destination location.
        mCollector.expectInRange(""Focus distance "" + resultDistances[resultDistances.length-1] +
                "" for minFocusDistance should be closed enough to requested value "" +
                requestedDistances[requestedDistances.length-1],
                resultDistances[resultDistances.length-1],
                requestedDistances[requestedDistances.length-1] * (1.0f - errorMargin),
                requestedDistances[requestedDistances.length-1] * (1.0f + errorMargin));
    }

    /**
     * Verify edge mode control results for fpsRanges
     */
    private void edgeModesTestByCamera(List<Range<Integer>> fpsRanges) throws Exception {
        Size maxPrevSize = mOrderedPreviewSizes.get(0);
        int[] edgeModes = mStaticInfo.getAvailableEdgeModesChecked();
        CaptureRequest.Builder requestBuilder =
                mCamera.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);

        for (int mode : edgeModes) {
            requestBuilder.set(CaptureRequest.EDGE_MODE, mode);

            // Test that OFF and FAST mode should not slow down the frame rate.
            if (mode == CaptureRequest.EDGE_MODE_OFF ||
                    mode == CaptureRequest.EDGE_MODE_FAST) {
                verifyFpsNotSlowDown(requestBuilder, NUM_FRAMES_VERIFIED, fpsRanges);
            }

            SimpleCaptureCallback resultListener = new SimpleCaptureCallback();
            startPreview(requestBuilder, maxPrevSize, resultListener);
            mSession.setRepeatingRequest(requestBuilder.build(), resultListener, mHandler);
            waitForSettingsApplied(resultListener, NUM_FRAMES_WAITED_FOR_UNKNOWN_LATENCY);

            verifyCaptureResultForKey(CaptureResult.EDGE_MODE, mode, resultListener,
                    NUM_FRAMES_VERIFIED);
       }

        stopPreview();
    }

    /**
     * Test color correction controls.
     *
     * <p>Test different color correction modes. For TRANSFORM_MATRIX, only test
     * the unit gain and identity transform.</p>
     */
    private void colorCorrectionTestByCamera() throws Exception {
        CaptureRequest request;
        CaptureResult result;
        Size maxPreviewSz = mOrderedPreviewSizes.get(0); // Max preview size.
        updatePreviewSurface(maxPreviewSz);
        CaptureRequest.Builder manualRequestBuilder = createRequestForPreview();
        CaptureRequest.Builder previewRequestBuilder = createRequestForPreview();
        SimpleCaptureCallback listener = new SimpleCaptureCallback();

        startPreview(previewRequestBuilder, maxPreviewSz, listener);

        // Default preview result should give valid color correction metadata.
        result = listener.getCaptureResult(WAIT_FOR_RESULT_TIMEOUT_MS);
        validateColorCorrectionResult(result,
                previewRequestBuilder.get(CaptureRequest.COLOR_CORRECTION_MODE));
        int colorCorrectionMode = CaptureRequest.COLOR_CORRECTION_MODE_TRANSFORM_MATRIX;
        // TRANSFORM_MATRIX mode
        // Only test unit gain and identity transform
        List<Integer> availableControlModes = Arrays.asList(
                CameraTestUtils.toObject(mStaticInfo.getAvailableControlModesChecked()));
        List<Integer> availableAwbModes = Arrays.asList(
                CameraTestUtils.toObject(mStaticInfo.getAwbAvailableModesChecked()));
        boolean isManualCCSupported =
                availableControlModes.contains(CaptureRequest.CONTROL_MODE_OFF) ||
                availableAwbModes.contains(CaptureRequest.CONTROL_AWB_MODE_OFF);
        if (isManualCCSupported) {
            if (!availableControlModes.contains(CaptureRequest.CONTROL_MODE_OFF)) {
                // Only manual AWB mode is supported
                manualRequestBuilder.set(CaptureRequest.CONTROL_MODE,
                        CaptureRequest.CONTROL_MODE_AUTO);
                manualRequestBuilder.set(CaptureRequest.CONTROL_AWB_MODE,
                        CaptureRequest.CONTROL_AWB_MODE_OFF);
            } else {
                // All 3A manual controls are supported, it doesn't matter what we set for AWB mode.
                manualRequestBuilder.set(CaptureRequest.CONTROL_MODE,
                        CaptureRequest.CONTROL_MODE_OFF);
            }

            RggbChannelVector UNIT_GAIN = new RggbChannelVector(1.0f, 1.0f, 1.0f, 1.0f);

            ColorSpaceTransform IDENTITY_TRANSFORM = new ColorSpaceTransform(
                new Rational[] {
                    ONE_R, ZERO_R, ZERO_R,
                    ZERO_R, ONE_R, ZERO_R,
                    ZERO_R, ZERO_R, ONE_R
                });

            manualRequestBuilder.set(CaptureRequest.COLOR_CORRECTION_MODE, colorCorrectionMode);
            manualRequestBuilder.set(CaptureRequest.COLOR_CORRECTION_GAINS, UNIT_GAIN);
            manualRequestBuilder.set(CaptureRequest.COLOR_CORRECTION_TRANSFORM, IDENTITY_TRANSFORM);
            request = manualRequestBuilder.build();
            mSession.capture(request, listener, mHandler);
            result = listener.getCaptureResultForRequest(request, NUM_RESULTS_WAIT_TIMEOUT);
            RggbChannelVector gains = result.get(CaptureResult.COLOR_CORRECTION_GAINS);
            ColorSpaceTransform transform = result.get(CaptureResult.COLOR_CORRECTION_TRANSFORM);
            validateColorCorrectionResult(result, colorCorrectionMode);
            mCollector.expectEquals(""control mode result/request mismatch"",
                    CaptureResult.CONTROL_MODE_OFF, result.get(CaptureResult.CONTROL_MODE));
            mCollector.expectEquals(""Color correction gain result/request mismatch"",
                    UNIT_GAIN, gains);
            mCollector.expectEquals(""Color correction gain result/request mismatch"",
                    IDENTITY_TRANSFORM, transform);

        }

        // FAST mode
        colorCorrectionMode = CaptureRequest.COLOR_CORRECTION_MODE_FAST;
        manualRequestBuilder.set(CaptureRequest.CONTROL_MODE, CaptureRequest.CONTROL_MODE_AUTO);
        manualRequestBuilder.set(CaptureRequest.COLOR_CORRECTION_MODE, colorCorrectionMode);
        request = manualRequestBuilder.build();
        mSession.capture(request, listener, mHandler);
        result = listener.getCaptureResultForRequest(request, NUM_RESULTS_WAIT_TIMEOUT);
        validateColorCorrectionResult(result, colorCorrectionMode);
        mCollector.expectEquals(""control mode result/request mismatch"",
                CaptureResult.CONTROL_MODE_AUTO, result.get(CaptureResult.CONTROL_MODE));

        // HIGH_QUALITY mode
        colorCorrectionMode = CaptureRequest.COLOR_CORRECTION_MODE_HIGH_QUALITY;
        manualRequestBuilder.set(CaptureRequest.CONTROL_MODE, CaptureRequest.CONTROL_MODE_AUTO);
        manualRequestBuilder.set(CaptureRequest.COLOR_CORRECTION_MODE, colorCorrectionMode);
        request = manualRequestBuilder.build();
        mSession.capture(request, listener, mHandler);
        result = listener.getCaptureResultForRequest(request, NUM_RESULTS_WAIT_TIMEOUT);
        validateColorCorrectionResult(result, colorCorrectionMode);
        mCollector.expectEquals(""control mode result/request mismatch"",
                CaptureResult.CONTROL_MODE_AUTO, result.get(CaptureResult.CONTROL_MODE));
    }

    private void validateColorCorrectionResult(CaptureResult result, int colorCorrectionMode) {
        final RggbChannelVector ZERO_GAINS = new RggbChannelVector(0, 0, 0, 0);
        final int TRANSFORM_SIZE = 9;
        Rational[] zeroTransform = new Rational[TRANSFORM_SIZE];
        Arrays.fill(zeroTransform, ZERO_R);
        final ColorSpaceTransform ZERO_TRANSFORM = new ColorSpaceTransform(zeroTransform);

        RggbChannelVector resultGain;
        if ((resultGain = mCollector.expectKeyValueNotNull(result,
                CaptureResult.COLOR_CORRECTION_GAINS)) != null) {
            mCollector.expectKeyValueNotEquals(result,
                    CaptureResult.COLOR_CORRECTION_GAINS, ZERO_GAINS);
        }

        ColorSpaceTransform resultTransform;
        if ((resultTransform = mCollector.expectKeyValueNotNull(result,
                CaptureResult.COLOR_CORRECTION_TRANSFORM)) != null) {
            mCollector.expectKeyValueNotEquals(result,
                    CaptureResult.COLOR_CORRECTION_TRANSFORM, ZERO_TRANSFORM);
        }

        mCollector.expectEquals(""color correction mode result/request mismatch"",
                colorCorrectionMode, result.get(CaptureResult.COLOR_CORRECTION_MODE));
    }

    /**
     * Test that flash can be turned off successfully with a given initial and final AE_CONTROL
     * states.
     *
     * This function expects that initialAeControl and flashOffAeControl will not be either
     * CaptureRequest.CONTROL_AE_MODE_ON or CaptureRequest.CONTROL_AE_MODE_OFF
     *
     * @param listener The Capture listener that is used to wait for capture result
     * @param initialAeControl The initial AE_CONTROL mode to start repeating requests with.
     * @param flashOffAeControl The final AE_CONTROL mode which is expected to turn flash off for
     *        TEMPLATE_PREVIEW repeating requests.
     */
    private void flashTurnOffTest(SimpleCaptureCallback listener, boolean isLegacy,
            int initialAeControl, int flashOffAeControl) throws Exception {
        CaptureResult result;
        final int NUM_FLASH_REQUESTS_TESTED = 10;
        CaptureRequest.Builder requestBuilder = createRequestForPreview();
        requestBuilder.set(CaptureRequest.CONTROL_MODE, CaptureRequest.CONTROL_MODE_AUTO);
        requestBuilder.set(CaptureRequest.CONTROL_AE_MODE, initialAeControl);

        mSession.setRepeatingRequest(requestBuilder.build(), listener, mHandler);
        waitForSettingsApplied(listener, NUM_FRAMES_WAITED_FOR_UNKNOWN_LATENCY);

        // Turn on torch using FLASH_MODE_TORCH
        requestBuilder.set(CaptureRequest.CONTROL_AE_MODE, CaptureRequest.CONTROL_AE_MODE_ON);
        requestBuilder.set(CaptureRequest.FLASH_MODE, CaptureRequest.FLASH_MODE_TORCH);
        CaptureRequest torchOnRequest = requestBuilder.build();
        mSession.setRepeatingRequest(torchOnRequest, listener, mHandler);
        waitForSettingsApplied(listener, NUM_FRAMES_WAITED_FOR_TORCH);
        result = listener.getCaptureResultForRequest(torchOnRequest, NUM_RESULTS_WAIT_TIMEOUT);
        // Test that the flash actually turned on continuously.
        mCollector.expectEquals(""Flash state result must be FIRED"", CaptureResult.FLASH_STATE_FIRED,
                result.get(CaptureResult.FLASH_STATE));
        mSession.stopRepeating();
        // Turn off the torch
        requestBuilder.set(CaptureRequest.CONTROL_AE_MODE, flashOffAeControl);
        // TODO: jchowdhary@, b/130323585, this line can be removed.
        requestBuilder.set(CaptureRequest.FLASH_MODE, CaptureRequest.FLASH_MODE_OFF);
        int numAllowedTransitionStates = NUM_PARTIAL_FRAMES_NPFC;
        if (mStaticInfo.isPerFrameControlSupported()) {
           numAllowedTransitionStates = NUM_PARTIAL_FRAMES_PFC;

        }
        // We submit 2 * numAllowedTransitionStates + 1 requests since we have two torch mode
        // transitions. The additional request is to check for at least 1 expected (FIRED / READY)
        // state.
        int numTorchTestSamples =  2 * numAllowedTransitionStates  + 1;
        CaptureRequest flashOffRequest = requestBuilder.build();
        int flashModeOffRequests = captureRequestsSynchronizedBurst(flashOffRequest,
                numTorchTestSamples, listener, mHandler);
        // Turn it on again.
        requestBuilder.set(CaptureRequest.FLASH_MODE, CaptureRequest.FLASH_MODE_TORCH);
        // We need to have CONTROL_AE_MODE be either CONTROL_AE_MODE_ON or CONTROL_AE_MODE_OFF to
        // turn the torch on again.
        requestBuilder.set(CaptureRequest.CONTROL_AE_MODE, CaptureRequest.CONTROL_AE_MODE_ON);
        CaptureRequest flashModeTorchRequest = requestBuilder.build();
        int flashModeTorchRequests = captureRequestsSynchronizedBurst(flashModeTorchRequest,
                numTorchTestSamples, listener, mHandler);

        CaptureResult[] torchStateResults =
                new CaptureResult[flashModeTorchRequests + flashModeOffRequests];
        Arrays.fill(torchStateResults, null);
        int i = 0;
        for (; i < flashModeOffRequests; i++) {
            torchStateResults[i] =
                    listener.getCaptureResultForRequest(flashOffRequest, NUM_RESULTS_WAIT_TIMEOUT);
            mCollector.expectNotEquals(""Result for flashModeOff request null"",
                    torchStateResults[i], null);
        }
        for (int j = i; j < torchStateResults.length; j++) {
            torchStateResults[j] =
                    listener.getCaptureResultForRequest(flashModeTorchRequest,
                            NUM_RESULTS_WAIT_TIMEOUT);
            mCollector.expectNotEquals(""Result for flashModeTorch request null"",
                    torchStateResults[j], null);
        }
        if (isLegacy) {
            // For LEGACY devices, flash state is null for all situations except:
            // android.control.aeMode == ON_ALWAYS_FLASH, where flash.state will be FIRED
            // android.flash.mode == TORCH, where flash.state will be FIRED
            testLegacyTorchStates(torchStateResults, 0, flashModeOffRequests - 1, flashOffRequest);
            testLegacyTorchStates(torchStateResults, flashModeOffRequests,
                    torchStateResults.length -1,
                    flashModeTorchRequest);
        } else {
            checkTorchStates(torchStateResults, numAllowedTransitionStates, flashModeOffRequests,
                    flashModeTorchRequests);
        }
    }

    private void testLegacyTorchStates(CaptureResult []torchStateResults, int beg, int end,
            CaptureRequest request) {
        for (int i = beg; i <= end; i++) {
            Integer requestControlAeMode = request.get(CaptureRequest.CONTROL_AE_MODE);
            Integer requestFlashMode = request.get(CaptureRequest.FLASH_MODE);
            Integer resultFlashState = torchStateResults[i].get(CaptureResult.FLASH_STATE);
            if (requestControlAeMode == CaptureRequest.CONTROL_AE_MODE_ON_ALWAYS_FLASH ||
                    requestFlashMode == CaptureRequest.FLASH_MODE_TORCH) {
                mCollector.expectEquals(""For LEGACY devices, flash state must be FIRED when"" +
                        ""CONTROL_AE_MODE == CONTROL_AE_MODE_ON_ALWAYS_FLASH or FLASH_MODE == "" +
                        ""TORCH, CONTROL_AE_MODE = "" + requestControlAeMode + "" FLASH_MODE = "" +
                        requestFlashMode, CaptureResult.FLASH_STATE_FIRED, resultFlashState);
                continue;
            }
            mCollector.expectTrue(""For LEGACY devices, flash state must be null when"" +
                        ""CONTROL_AE_MODE != CONTROL_AE_MODE_ON_ALWAYS_FLASH or FLASH_MODE != "" +
                        ""TORCH, CONTROL_AE_MODE = "" + requestControlAeMode + "" FLASH_MODE = "" +
                        requestFlashMode,  resultFlashState == null);
        }
    }
    // We check that torch states appear in the order expected. We don't necessarily know how many
    // times each state might appear, however we make sure that the states do not appear out of
    // order.
    private void checkTorchTransitionStates(CaptureResult []torchStateResults, int beg, int end,
            List<Integer> stateOrder, boolean isTurningOff) {
        Integer flashState;
        Integer curIndex = 0;
        for (int i = beg; i <= end; i++) {
            flashState = torchStateResults[i].get(CaptureResult.FLASH_STATE);
            int index = stateOrder.indexOf(flashState);
            mCollector.expectNotEquals(""Invalid state "" + flashState + "" not in expected list"" +
                    stateOrder, index, -1);
            mCollector.expectGreaterOrEqual(""state "" + flashState  + "" index "" + index +
                    "" is expected to be >= "" + curIndex,
                    curIndex, index);
            curIndex = index;
        }
    }

    private void checkTorchStates(CaptureResult []torchResults, int numAllowedTransitionStates,
            int numTorchOffSamples, int numTorchOnSamples) {
        // We test for flash states from request:
        // Request:       O(0) O(1) O(2) O(n)....O(nOFF) T(0) T(1) T(2) ....T(n) .... T(nON)
        // Valid Result : P/R  P/R  P/R  R R R...P/R P/R   P/F  P/F  P/F      F         F
        // For the FLASH_STATE_OFF requests, once FLASH_STATE READY has been seen, for the
        // transition states while switching the torch off, it must not transition to
        // FLASH_STATE_PARTIAL again till the next transition period which turns the torch on.
        // P - FLASH_STATE_PARTIAL
        // R - FLASH_STATE_READY
        // F - FLASH_STATE_FIRED
        // O(k) - kth FLASH_MODE_OFF request
        // T(k) - kth FLASH_MODE_TORCH request
        // nOFF - number of torch off samples
        // nON - number of torch on samples
        Integer flashState;
        // Check on -> off transition states
        List<Integer> onToOffStateOrderList = new ArrayList<Integer>();
        onToOffStateOrderList.add(CaptureRequest.FLASH_STATE_PARTIAL);
        onToOffStateOrderList.add(CaptureRequest.FLASH_STATE_READY);
        checkTorchTransitionStates(torchResults, 0, numAllowedTransitionStates,
                onToOffStateOrderList, true);
        // The next frames (before transition) must have its flash state as FLASH_STATE_READY
        for (int i = numAllowedTransitionStates + 1;
                i < numTorchOffSamples - numAllowedTransitionStates; i++) {
            flashState = torchResults[numAllowedTransitionStates].get(CaptureResult.FLASH_STATE);
            mCollector.expectEquals(""flash state result must be READY"",
                    CaptureResult.FLASH_STATE_READY, flashState);
        }
        // check off -> on transition states, before the FLASH_MODE_TORCH request was sent
        List<Integer> offToOnPreStateOrderList = new ArrayList<Integer>();
        offToOnPreStateOrderList.add(CaptureRequest.FLASH_STATE_READY);
        offToOnPreStateOrderList.add(CaptureRequest.FLASH_STATE_PARTIAL);
        checkTorchTransitionStates(torchResults,
                numTorchOffSamples - numAllowedTransitionStates, numTorchOffSamples - 1,
                offToOnPreStateOrderList, false);
        // check off -> on transition states
        List<Integer> offToOnPostStateOrderList = new ArrayList<Integer>();
        offToOnPostStateOrderList.add(CaptureRequest.FLASH_STATE_PARTIAL);
        offToOnPostStateOrderList.add(CaptureRequest.FLASH_STATE_FIRED);
        checkTorchTransitionStates(torchResults,
                numTorchOffSamples, numTorchOffSamples + numAllowedTransitionStates,
                offToOnPostStateOrderList, false);
        // check on states after off -> on transition
        // The next frames must have its flash state as FLASH_STATE_FIRED
        for (int i = numTorchOffSamples + numAllowedTransitionStates + 1;
                i < torchResults.length - 1; i++) {
            flashState = torchResults[i].get(CaptureResult.FLASH_STATE);
            mCollector.expectEquals(""flash state result must be FIRED for frame "" + i,
                    CaptureRequest.FLASH_STATE_FIRED, flashState);
        }
    }

    /**
     * Test flash mode control by AE mode.
     * <p>
     * Only allow AE mode ON or OFF, because other AE mode could run into conflict with
     * flash manual control. This function expects the camera to already have an active
     * repeating request and be sending results to the listener.
     * </p>
     *
     * @param listener The Capture listener that is used to wait for capture result
     * @param aeMode The AE mode for flash to test with
     */
    private void flashTestByAeMode(SimpleCaptureCallback listener, int aeMode) throws Exception {
        CaptureResult result;
        final int NUM_FLASH_REQUESTS_TESTED = 10;
        CaptureRequest.Builder requestBuilder = createRequestForPreview();

        if (aeMode == CaptureRequest.CONTROL_AE_MODE_ON) {
            requestBuilder.set(CaptureRequest.CONTROL_AE_MODE, aeMode);
        } else if (aeMode == CaptureRequest.CONTROL_AE_MODE_OFF) {
            changeExposure(requestBuilder, DEFAULT_EXP_TIME_NS, DEFAULT_SENSITIVITY);
        } else {
            throw new IllegalArgumentException(""This test only works when AE mode is ON or OFF"");
        }

        mSession.setRepeatingRequest(requestBuilder.build(), listener, mHandler);
        waitForSettingsApplied(listener, NUM_FRAMES_WAITED_FOR_UNKNOWN_LATENCY);

        // For camera that doesn't have flash unit, flash state should always be UNAVAILABLE.
        if (mStaticInfo.getFlashInfoChecked() == false) {
            for (int i = 0; i < NUM_FLASH_REQUESTS_TESTED; i++) {
                result = listener.getCaptureResult(CAPTURE_RESULT_TIMEOUT_MS);
                mCollector.expectEquals(""No flash unit available, flash state must be UNAVAILABLE""
                        + ""for AE mode "" + aeMode, CaptureResult.FLASH_STATE_UNAVAILABLE,
                        result.get(CaptureResult.FLASH_STATE));
            }

            return;
        }

        // Test flash SINGLE mode control. Wait for flash state to be READY first.
        if (mStaticInfo.isHardwareLevelAtLeastLimited()) {
            waitForResultValue(listener, CaptureResult.FLASH_STATE, CaptureResult.FLASH_STATE_READY,
                    NUM_RESULTS_WAIT_TIMEOUT);
        } // else the settings were already waited on earlier

        requestBuilder.set(CaptureRequest.FLASH_MODE, CaptureRequest.FLASH_MODE_SINGLE);
        CaptureRequest flashSinglerequest = requestBuilder.build();

        int flashModeSingleRequests = captureRequestsSynchronized(
                flashSinglerequest, listener, mHandler);
        waitForNumResults(listener, flashModeSingleRequests - 1);
        result = listener.getCaptureResultForRequest(flashSinglerequest, NUM_RESULTS_WAIT_TIMEOUT);
        // Result mode must be SINGLE, state must be FIRED.
        mCollector.expectEquals(""Flash mode result must be SINGLE"",
                CaptureResult.FLASH_MODE_SINGLE, result.get(CaptureResult.FLASH_MODE));
        mCollector.expectEquals(""Flash state result must be FIRED"",
                CaptureResult.FLASH_STATE_FIRED, result.get(CaptureResult.FLASH_STATE));

        // Test flash TORCH mode control.
        requestBuilder.set(CaptureRequest.FLASH_MODE, CaptureRequest.FLASH_MODE_TORCH);
        CaptureRequest torchRequest = requestBuilder.build();

        int flashModeTorchRequests = captureRequestsSynchronized(torchRequest,
                NUM_FLASH_REQUESTS_TESTED, listener, mHandler);
        waitForNumResults(listener, flashModeTorchRequests - NUM_FLASH_REQUESTS_TESTED);

        // Verify the results
        TorchSeqState state = TorchSeqState.RAMPING_UP;
        for (int i = 0; i < NUM_FLASH_REQUESTS_TESTED; i++) {
            result = listener.getCaptureResultForRequest(torchRequest,
                    NUM_RESULTS_WAIT_TIMEOUT);
            int flashMode = result.get(CaptureResult.FLASH_MODE);
            int flashState = result.get(CaptureResult.FLASH_STATE);
            // Result mode must be TORCH
            mCollector.expectEquals(""Flash mode result "" + i + "" must be TORCH"",
                    CaptureResult.FLASH_MODE_TORCH, result.get(CaptureResult.FLASH_MODE));
            if (state == TorchSeqState.RAMPING_UP &&
                    flashState == CaptureResult.FLASH_STATE_FIRED) {
                state = TorchSeqState.FIRED;
            } else if (state == TorchSeqState.FIRED &&
                    flashState == CaptureResult.FLASH_STATE_PARTIAL) {
                state = TorchSeqState.RAMPING_DOWN;
            }

            if (i == 0 && mStaticInfo.isPerFrameControlSupported()) {
                mCollector.expectTrue(
                        ""Per frame control device must enter FIRED state on first torch request"",
                        state == TorchSeqState.FIRED);
            }

            if (state == TorchSeqState.FIRED) {
                mCollector.expectEquals(""Flash state result "" + i + "" must be FIRED"",
                        CaptureResult.FLASH_STATE_FIRED, result.get(CaptureResult.FLASH_STATE));
            } else {
                mCollector.expectEquals(""Flash state result "" + i + "" must be PARTIAL"",
                        CaptureResult.FLASH_STATE_PARTIAL, result.get(CaptureResult.FLASH_STATE));
            }
        }
        mCollector.expectTrue(""Torch state FIRED never seen"",
                state == TorchSeqState.FIRED || state == TorchSeqState.RAMPING_DOWN);

        // Test flash OFF mode control
        requestBuilder.set(CaptureRequest.FLASH_MODE, CaptureRequest.FLASH_MODE_OFF);
        CaptureRequest flashOffrequest = requestBuilder.build();

        int flashModeOffRequests = captureRequestsSynchronized(flashOffrequest, listener, mHandler);
        waitForNumResults(listener, flashModeOffRequests - 1);
        result = listener.getCaptureResultForRequest(flashOffrequest, NUM_RESULTS_WAIT_TIMEOUT);
        mCollector.expectEquals(""Flash mode result must be OFF"", CaptureResult.FLASH_MODE_OFF,
                result.get(CaptureResult.FLASH_MODE));
    }

    private void verifyAntiBandingMode(SimpleCaptureCallback listener, int numFramesVerified,
            int mode, boolean isAeManual, long requestExpTime) throws Exception {
        // Skip the first a couple of frames as antibanding may not be fully up yet.
        final int NUM_FRAMES_SKIPPED = 5;
        for (int i = 0; i < NUM_FRAMES_SKIPPED; i++) {
            listener.getCaptureResult(WAIT_FOR_RESULT_TIMEOUT_MS);
        }

        for (int i = 0; i < numFramesVerified; i++) {
            CaptureResult result = listener.getCaptureResult(WAIT_FOR_RESULT_TIMEOUT_MS);
            Long resultExpTime = result.get(CaptureResult.SENSOR_EXPOSURE_TIME);
            assertNotNull(""Exposure time shouldn't be null"", resultExpTime);
            Integer flicker = result.get(CaptureResult.STATISTICS_SCENE_FLICKER);
            // Scene flicker result should be always available.
            assertNotNull(""Scene flicker must not be null"", flicker);
            assertTrue(""Scene flicker is invalid"", flicker >= STATISTICS_SCENE_FLICKER_NONE &&
                    flicker <= STATISTICS_SCENE_FLICKER_60HZ);

            Integer antiBandMode = result.get(CaptureResult.CONTROL_AE_ANTIBANDING_MODE);
            assertNotNull(""antiBanding mode shouldn't be null"", antiBandMode);
            assertTrue(""antiBanding Mode invalid, should be == "" + mode + "", is: "" + antiBandMode,
                    antiBandMode == mode);
            if (isAeManual) {
                // First, round down not up, second, need close enough.
                validateExposureTime(requestExpTime, resultExpTime);
                return;
            }

            long expectedExpTime = resultExpTime; // Default, no exposure adjustment.
            if (mode == CONTROL_AE_ANTIBANDING_MODE_50HZ) {
                // result exposure time must be adjusted by 50Hz illuminant source.
                expectedExpTime =
                        getAntiFlickeringExposureTime(ANTI_FLICKERING_50HZ, resultExpTime);
            } else if (mode == CONTROL_AE_ANTIBANDING_MODE_60HZ) {
                // result exposure time must be adjusted by 60Hz illuminant source.
                expectedExpTime =
                        getAntiFlickeringExposureTime(ANTI_FLICKERING_60HZ, resultExpTime);
            } else if (mode == CONTROL_AE_ANTIBANDING_MODE_AUTO){
                /**
                 * Use STATISTICS_SCENE_FLICKER to tell the illuminant source
                 * and do the exposure adjustment.
                 */
                expectedExpTime = resultExpTime;
                if (flicker == STATISTICS_SCENE_FLICKER_60HZ) {
                    expectedExpTime =
                            getAntiFlickeringExposureTime(ANTI_FLICKERING_60HZ, resultExpTime);
                } else if (flicker == STATISTICS_SCENE_FLICKER_50HZ) {
                    expectedExpTime =
                            getAntiFlickeringExposureTime(ANTI_FLICKERING_50HZ, resultExpTime);
                }
            }

            if (Math.abs(resultExpTime - expectedExpTime) > EXPOSURE_TIME_ERROR_MARGIN_NS) {
                mCollector.addMessage(String.format(""Result exposure time %dns diverges too much""
                        + "" from expected exposure time %dns for mode %d when AE is auto"",
                        resultExpTime, expectedExpTime, mode));
            }
        }
    }

    private void antiBandingTestByMode(Size size, int mode)
            throws Exception {
        if(VERBOSE) {
            Log.v(TAG, ""Anti-banding test for mode "" + mode + "" for camera "" + mCamera.getId());
        }
        CaptureRequest.Builder requestBuilder =
                mCamera.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);

        requestBuilder.set(CaptureRequest.CONTROL_AE_ANTIBANDING_MODE, mode);

        // Test auto AE mode anti-banding behavior
        SimpleCaptureCallback resultListener = new SimpleCaptureCallback();
        startPreview(requestBuilder, size, resultListener);
        waitForSettingsApplied(resultListener, NUM_FRAMES_WAITED_FOR_UNKNOWN_LATENCY);
        verifyAntiBandingMode(resultListener, NUM_FRAMES_VERIFIED, mode, /*isAeManual*/false,
                IGNORE_REQUESTED_EXPOSURE_TIME_CHECK);

        // Test manual AE mode anti-banding behavior
        // 65ms, must be supported by full capability devices.
        final long TEST_MANUAL_EXP_TIME_NS = 65000000L;
        long manualExpTime = mStaticInfo.getExposureClampToRange(TEST_MANUAL_EXP_TIME_NS);
        changeExposure(requestBuilder, manualExpTime);
        resultListener = new SimpleCaptureCallback();
        startPreview(requestBuilder, size, resultListener);
        waitForSettingsApplied(resultListener, NUM_FRAMES_WAITED_FOR_UNKNOWN_LATENCY);
        verifyAntiBandingMode(resultListener, NUM_FRAMES_VERIFIED, mode, /*isAeManual*/true,
                manualExpTime);

        stopPreview();
    }

    /**
     * Test the all available AE modes and AE lock.
     * <p>
     * For manual AE mode, test iterates through different sensitivities and
     * exposure times, validate the result exposure time correctness. For
     * CONTROL_AE_MODE_ON_ALWAYS_FLASH mode, the AE lock and flash are tested.
     * For the rest of the AUTO mode, AE lock is tested.
     * </p>
     *
     * @param mode
     */
    private void aeModeAndLockTestByMode(int mode)
            throws Exception {
        switch (mode) {
            case CONTROL_AE_MODE_OFF:
                if (mStaticInfo.isCapabilitySupported(
                        CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_MANUAL_SENSOR)) {
                    // Test manual exposure control.
                    aeManualControlTest();
                } else {
                    Log.w(TAG,
                            ""aeModeAndLockTestByMode - can't test AE mode OFF without "" +
                            ""manual sensor control"");
                }
                break;
            case CONTROL_AE_MODE_ON:
            case CONTROL_AE_MODE_ON_AUTO_FLASH:
            case CONTROL_AE_MODE_ON_AUTO_FLASH_REDEYE:
            case CONTROL_AE_MODE_ON_ALWAYS_FLASH:
            case CONTROL_AE_MODE_ON_EXTERNAL_FLASH:
                // Test AE lock for above AUTO modes.
                aeAutoModeTestLock(mode);
                break;
            default:
                throw new UnsupportedOperationException(""Unhandled AE mode "" + mode);
        }
    }

    /**
     * Test AE auto modes.
     * <p>
     * Use single request rather than repeating request to test AE lock per frame control.
     * </p>
     */
    private void aeAutoModeTestLock(int mode) throws Exception {
        CaptureRequest.Builder requestBuilder =
                mCamera.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);
        if (mStaticInfo.isAeLockSupported()) {
            requestBuilder.set(CaptureRequest.CONTROL_AE_LOCK, false);
        }
        requestBuilder.set(CaptureRequest.CONTROL_AE_MODE, mode);
        configurePreviewOutput(requestBuilder);

        final int MAX_NUM_CAPTURES_DURING_LOCK = 5;
        for (int i = 1; i <= MAX_NUM_CAPTURES_DURING_LOCK; i++) {
            autoAeMultipleCapturesThenTestLock(requestBuilder, mode, i);
        }
    }

    /**
     * Issue multiple auto AE captures, then lock AE, validate the AE lock vs.
     * the first capture result after the AE lock. The right AE lock behavior is:
     * When it is locked, it locks to the current exposure value, and all subsequent
     * request with lock ON will have the same exposure value locked.
     */
    private void autoAeMultipleCapturesThenTestLock(
            CaptureRequest.Builder requestBuilder, int aeMode, int numCapturesDuringLock)
            throws Exception {
        if (numCapturesDuringLock < 1) {
            throw new IllegalArgumentException(""numCapturesBeforeLock must be no less than 1"");
        }
        if (VERBOSE) {
            Log.v(TAG, ""Camera "" + mCamera.getId() + "": Testing auto AE mode and lock for mode ""
                    + aeMode + "" with "" + numCapturesDuringLock + "" captures before lock"");
        }

        final int NUM_CAPTURES_BEFORE_LOCK = 2;
        SimpleCaptureCallback listener =  new SimpleCaptureCallback();

        CaptureResult[] resultsDuringLock = new CaptureResult[numCapturesDuringLock];
        boolean canSetAeLock = mStaticInfo.isAeLockSupported();

        // Reset the AE lock to OFF, since we are reusing this builder many times
        if (canSetAeLock) {
            requestBuilder.set(CaptureRequest.CONTROL_AE_LOCK, false);
        }

        // Just send several captures with auto AE, lock off.
        CaptureRequest request = requestBuilder.build();
        for (int i = 0; i < NUM_CAPTURES_BEFORE_LOCK; i++) {
            mSession.capture(request, listener, mHandler);
        }
        waitForNumResults(listener, NUM_CAPTURES_BEFORE_LOCK);

        if (!canSetAeLock) {
            // Without AE lock, the remaining tests items won't work
            return;
        }

        // Then fire several capture to lock the AE.
        requestBuilder.set(CaptureRequest.CONTROL_AE_LOCK, true);

        int requestCount = captureRequestsSynchronized(
                requestBuilder.build(), numCapturesDuringLock, listener, mHandler);

        int[] sensitivities = new int[numCapturesDuringLock];
        long[] expTimes = new long[numCapturesDuringLock];
        Arrays.fill(sensitivities, -1);
        Arrays.fill(expTimes, -1L);

        // Get the AE lock on result and validate the exposure values.
        waitForNumResults(listener, requestCount - numCapturesDuringLock);
        for (int i = 0; i < resultsDuringLock.length; i++) {
            resultsDuringLock[i] = listener.getCaptureResult(WAIT_FOR_RESULT_TIMEOUT_MS);
        }

        for (int i = 0; i < numCapturesDuringLock; i++) {
            mCollector.expectKeyValueEquals(
                    resultsDuringLock[i], CaptureResult.CONTROL_AE_LOCK, true);
        }

        // Can't read manual sensor/exposure settings without manual sensor
        if (mStaticInfo.isCapabilitySupported(
                CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_READ_SENSOR_SETTINGS)) {
            int sensitivityLocked =
                    getValueNotNull(resultsDuringLock[0], CaptureResult.SENSOR_SENSITIVITY);
            long expTimeLocked =
                    getValueNotNull(resultsDuringLock[0], CaptureResult.SENSOR_EXPOSURE_TIME);
            for (int i = 1; i < resultsDuringLock.length; i++) {
                mCollector.expectKeyValueEquals(
                        resultsDuringLock[i], CaptureResult.SENSOR_EXPOSURE_TIME, expTimeLocked);
                mCollector.expectKeyValueEquals(
                        resultsDuringLock[i], CaptureResult.SENSOR_SENSITIVITY, sensitivityLocked);
            }
        }
    }

    /**
     * Iterate through exposure times and sensitivities for manual AE control.
     * <p>
     * Use single request rather than repeating request to test manual exposure
     * value change per frame control.
     * </p>
     */
    private void aeManualControlTest()
            throws Exception {
        CaptureRequest.Builder requestBuilder =
                mCamera.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);
        configurePreviewOutput(requestBuilder);

        // Warm up pipeline for more accurate timing
        SimpleCaptureCallback warmupListener =  new SimpleCaptureCallback();
        mSession.setRepeatingRequest(requestBuilder.build(), warmupListener, mHandler);
        warmupListener.getCaptureResult(WAIT_FOR_RESULT_TIMEOUT_MS);

        // Do manual captures
        requestBuilder.set(CaptureRequest.CONTROL_AE_MODE, CONTROL_AE_MODE_OFF);
        SimpleCaptureCallback listener =  new SimpleCaptureCallback();

        long[] expTimesNs = getExposureTimeTestValues();
        int[] sensitivities = getSensitivityTestValues();
        // Submit single request at a time, then verify the result.
        for (int i = 0; i < expTimesNs.length; i++) {
            for (int j = 0; j < sensitivities.length; j++) {
                if (VERBOSE) {
                    Log.v(TAG, ""Camera "" + mCamera.getId() + "": Testing sensitivity ""
                            + sensitivities[j] + "", exposure time "" + expTimesNs[i] + ""ns"");
                }

                changeExposure(requestBuilder, expTimesNs[i], sensitivities[j]);
                mSession.capture(requestBuilder.build(), listener, mHandler);

                // make sure timeout is long enough for long exposure time - add a 2x safety margin
                // to exposure time
                long timeoutMs = WAIT_FOR_RESULT_TIMEOUT_MS + 2 * expTimesNs[i] / 1000000;
                CaptureResult result = listener.getCaptureResult(timeoutMs);
                long resultExpTimeNs = getValueNotNull(result, CaptureResult.SENSOR_EXPOSURE_TIME);
                int resultSensitivity = getValueNotNull(result, CaptureResult.SENSOR_SENSITIVITY);
                validateExposureTime(expTimesNs[i], resultExpTimeNs);
                validateSensitivity(sensitivities[j], resultSensitivity);
                validateFrameDurationForCapture(result);
            }
        }
        mSession.stopRepeating();

        // TODO: Add another case to test where we can submit all requests, then wait for
        // results, which will hide the pipeline latency. this is not only faster, but also
        // test high speed per frame control and synchronization.
    }


    /**
     * Verify black level lock control.
     */
    private void verifyBlackLevelLockResults(SimpleCaptureCallback listener, int numFramesVerified,
            int maxLockOffCnt) throws Exception {
        int noLockCnt = 0;
        for (int i = 0; i < numFramesVerified; i++) {
            CaptureResult result = listener.getCaptureResult(WAIT_FOR_RESULT_TIMEOUT_MS);
            Boolean blackLevelLock = result.get(CaptureResult.BLACK_LEVEL_LOCK);
            assertNotNull(""Black level lock result shouldn't be null"", blackLevelLock);

            // Count the lock == false result, which could possibly occur at most once.
            if (blackLevelLock == false) {
                noLockCnt++;
            }

            if(VERBOSE) {
                Log.v(TAG, ""Black level lock result: "" + blackLevelLock);
            }
        }
        assertTrue(""Black level lock OFF occurs "" + noLockCnt + "" times,  expect at most ""
                + maxLockOffCnt + "" for camera "" + mCamera.getId(), noLockCnt <= maxLockOffCnt);
    }

    /**
     * Verify shading map for different shading modes.
     */
    private void verifyShadingMap(SimpleCaptureCallback listener, int numFramesVerified,
            int shadingMode) throws Exception {

        for (int i = 0; i < numFramesVerified; i++) {
            CaptureResult result = listener.getCaptureResult(WAIT_FOR_RESULT_TIMEOUT_MS);
            mCollector.expectEquals(""Shading mode result doesn't match request"",
                    shadingMode, result.get(CaptureResult.SHADING_MODE));
            LensShadingMap mapObj = result.get(
                    CaptureResult.STATISTICS_LENS_SHADING_CORRECTION_MAP);
            assertNotNull(""Map object must not be null"", mapObj);
            int numElementsInMap = mapObj.getGainFactorCount();
            float[] map = new float[numElementsInMap];
            mapObj.copyGainFactors(map, /*offset*/0);
            assertNotNull(""Map must not be null"", map);
            assertFalse(String.format(
                    ""Map size %d should be less than %d"", numElementsInMap, MAX_SHADING_MAP_SIZE),
                    numElementsInMap >= MAX_SHADING_MAP_SIZE);
            assertFalse(String.format(""Map size %d should be no less than %d"", numElementsInMap,
                    MIN_SHADING_MAP_SIZE), numElementsInMap < MIN_SHADING_MAP_SIZE);

            if (shadingMode == CaptureRequest.SHADING_MODE_FAST ||
                    shadingMode == CaptureRequest.SHADING_MODE_HIGH_QUALITY) {
                // shading mode is FAST or HIGH_QUALITY, expect to receive a map with all
                // elements >= 1.0f

                int badValueCnt = 0;
                // Detect the bad values of the map data.
                for (int j = 0; j < numElementsInMap; j++) {
                    if (Float.isNaN(map[j]) || map[j] < 1.0f) {
                        badValueCnt++;
                    }
                }
                assertEquals(""Number of value in the map is "" + badValueCnt + "" out of ""
                        + numElementsInMap, /*expected*/0, /*actual*/badValueCnt);
            } else if (shadingMode == CaptureRequest.SHADING_MODE_OFF) {
                float[] unityMap = new float[numElementsInMap];
                Arrays.fill(unityMap, 1.0f);
                // shading mode is OFF, expect to receive a unity map.
                assertTrue(""Result map "" + Arrays.toString(map) + "" must be an unity map"",
                        Arrays.equals(unityMap, map));
            }
        }
    }

    /**
     * Test face detection for a camera.
     */
    private void faceDetectionTestByCamera() throws Exception {
        int[] faceDetectModes = mStaticInfo.getAvailableFaceDetectModesChecked();

        SimpleCaptureCallback listener;
        CaptureRequest.Builder requestBuilder =
                mCamera.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);

        Size maxPreviewSz = mOrderedPreviewSizes.get(0); // Max preview size.
        for (int mode : faceDetectModes) {
            requestBuilder.set(CaptureRequest.STATISTICS_FACE_DETECT_MODE, mode);
            if (VERBOSE) {
                Log.v(TAG, ""Start testing face detection mode "" + mode);
            }

            // Create a new listener for each run to avoid the results from one run spill
            // into another run.
            listener = new SimpleCaptureCallback();
            startPreview(requestBuilder, maxPreviewSz, listener);
            waitForSettingsApplied(listener, NUM_FRAMES_WAITED_FOR_UNKNOWN_LATENCY);
            verifyFaceDetectionResults(listener, NUM_FACE_DETECTION_FRAMES_VERIFIED, mode);
        }

        stopPreview();
    }

    /**
     * Verify face detection results for different face detection modes.
     *
     * @param listener The listener to get capture result
     * @param numFramesVerified Number of results to be verified
     * @param faceDetectionMode Face detection mode to be verified against
     */
    private void verifyFaceDetectionResults(SimpleCaptureCallback listener, int numFramesVerified,
            int faceDetectionMode) {
        for (int i = 0; i < numFramesVerified; i++) {
            CaptureResult result = listener.getCaptureResult(WAIT_FOR_RESULT_TIMEOUT_MS);
            mCollector.expectEquals(""Result face detection mode should match the request"",
                    faceDetectionMode, result.get(CaptureResult.STATISTICS_FACE_DETECT_MODE));

            Face[] faces = result.get(CaptureResult.STATISTICS_FACES);
            List<Integer> faceIds = new ArrayList<Integer>(faces.length);
            List<Integer> faceScores = new ArrayList<Integer>(faces.length);
            if (faceDetectionMode == CaptureResult.STATISTICS_FACE_DETECT_MODE_OFF) {
                mCollector.expectEquals(""Number of detection faces should always 0 for OFF mode"",
                        0, faces.length);
            } else if (faceDetectionMode == CaptureResult.STATISTICS_FACE_DETECT_MODE_SIMPLE) {
                for (Face face : faces) {
                    mCollector.expectNotNull(""Face rectangle shouldn't be null"", face.getBounds());
                    faceScores.add(face.getScore());
                    mCollector.expectTrue(""Face id is expected to be -1 for SIMPLE mode"",
                            face.getId() == Face.ID_UNSUPPORTED);
                }
            } else if (faceDetectionMode == CaptureResult.STATISTICS_FACE_DETECT_MODE_FULL) {
                if (VERBOSE) {
                    Log.v(TAG, ""Number of faces detected: "" + faces.length);
                }

                for (Face face : faces) {
                    Rect faceBound;
                    boolean faceRectAvailable =  mCollector.expectTrue(""Face rectangle ""
                            + ""shouldn't be null"", face.getBounds() != null);
                    if (!faceRectAvailable) {
                        continue;
                    }
                    faceBound = face.getBounds();

                    faceScores.add(face.getScore());
                    faceIds.add(face.getId());

                    mCollector.expectTrue(""Face id is shouldn't be -1 for FULL mode"",
                            face.getId() != Face.ID_UNSUPPORTED);
                    boolean leftEyeAvailable =
                            mCollector.expectTrue(""Left eye position shouldn't be null"",
                                    face.getLeftEyePosition() != null);
                    boolean rightEyeAvailable =
                            mCollector.expectTrue(""Right eye position shouldn't be null"",
                                    face.getRightEyePosition() != null);
                    boolean mouthAvailable =
                            mCollector.expectTrue(""Mouth position shouldn't be null"",
                            face.getMouthPosition() != null);
                    // Eyes/mouth position should be inside of the face rect.
                    if (leftEyeAvailable) {
                        Point leftEye = face.getLeftEyePosition();
                        mCollector.expectTrue(""Left eye "" + leftEye + ""should be""
                                + ""inside of face rect "" + faceBound,
                                faceBound.contains(leftEye.x, leftEye.y));
                    }
                    if (rightEyeAvailable) {
                        Point rightEye = face.getRightEyePosition();
                        mCollector.expectTrue(""Right eye "" + rightEye + ""should be""
                                + ""inside of face rect "" + faceBound,
                                faceBound.contains(rightEye.x, rightEye.y));
                    }
                    if (mouthAvailable) {
                        Point mouth = face.getMouthPosition();
                        mCollector.expectTrue(""Mouth "" + mouth +  "" should be inside of""
                                + "" face rect "" + faceBound,
                                faceBound.contains(mouth.x, mouth.y));
                    }
                }
            }
            mCollector.expectValuesInRange(""Face scores are invalid"", faceScores,
                    Face.SCORE_MIN, Face.SCORE_MAX);
            mCollector.expectValuesUnique(""Face ids are invalid"", faceIds);
        }
    }

    /**
     * Test tone map mode and result by camera
     */
    private void toneMapTestByCamera() throws Exception {
        if (!mStaticInfo.isManualToneMapSupported()) {
            return;
        }

        CaptureRequest.Builder requestBuilder =
                mCamera.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);
        int[] toneMapModes = mStaticInfo.getAvailableToneMapModesChecked();
        // Test AUTO modes first. Note that FAST/HQ must both present or not present
        for (int i = 0; i < toneMapModes.length; i++) {
            if (toneMapModes[i] == CaptureRequest.TONEMAP_MODE_FAST && i > 0) {
                int tmpMode = toneMapModes[0];
                toneMapModes[0] = CaptureRequest.TONEMAP_MODE_FAST;
                toneMapModes[i] = tmpMode;
            }
            if (toneMapModes[i] == CaptureRequest.TONEMAP_MODE_HIGH_QUALITY && i > 1) {
                int tmpMode = toneMapModes[1];
                toneMapModes[1] = CaptureRequest.TONEMAP_MODE_HIGH_QUALITY;
                toneMapModes[i] = tmpMode;
            }
        }
        for (int mode : toneMapModes) {
            if (VERBOSE) {
                Log.v(TAG, ""Testing tonemap mode "" + mode);
            }

            requestBuilder.set(CaptureRequest.TONEMAP_MODE, mode);
            switch (mode) {
                case CaptureRequest.TONEMAP_MODE_CONTRAST_CURVE:
                    TonemapCurve toneCurve = new TonemapCurve(TONEMAP_CURVE_LINEAR,
                            TONEMAP_CURVE_LINEAR, TONEMAP_CURVE_LINEAR);
                    requestBuilder.set(CaptureRequest.TONEMAP_CURVE, toneCurve);
                    testToneMapMode(NUM_FRAMES_VERIFIED, requestBuilder);

                    toneCurve = new TonemapCurve(TONEMAP_CURVE_SRGB,
                            TONEMAP_CURVE_SRGB, TONEMAP_CURVE_SRGB);
                    requestBuilder.set(CaptureRequest.TONEMAP_CURVE, toneCurve);
                    testToneMapMode(NUM_FRAMES_VERIFIED, requestBuilder);
                    break;
                case CaptureRequest.TONEMAP_MODE_GAMMA_VALUE:
                    requestBuilder.set(CaptureRequest.TONEMAP_GAMMA, 1.0f);
                    testToneMapMode(NUM_FRAMES_VERIFIED, requestBuilder);
                    requestBuilder.set(CaptureRequest.TONEMAP_GAMMA, 2.2f);
                    testToneMapMode(NUM_FRAMES_VERIFIED, requestBuilder);
                    requestBuilder.set(CaptureRequest.TONEMAP_GAMMA, 5.0f);
                    testToneMapMode(NUM_FRAMES_VERIFIED, requestBuilder);
                    break;
                case CaptureRequest.TONEMAP_MODE_PRESET_CURVE:
                    requestBuilder.set(CaptureRequest.TONEMAP_PRESET_CURVE,
                            CaptureRequest.TONEMAP_PRESET_CURVE_REC709);
                    testToneMapMode(NUM_FRAMES_VERIFIED, requestBuilder);
                    requestBuilder.set(CaptureRequest.TONEMAP_PRESET_CURVE,
                            CaptureRequest.TONEMAP_PRESET_CURVE_SRGB);
                    testToneMapMode(NUM_FRAMES_VERIFIED, requestBuilder);
                    break;
                default:
                    testToneMapMode(NUM_FRAMES_VERIFIED, requestBuilder);
                    break;
            }
        }


    }

    /**
     * Test tonemap mode with speficied request settings
     *
     * @param numFramesVerified Number of results to be verified
     * @param requestBuilder the request builder of settings to be tested
     */
    private void testToneMapMode (int numFramesVerified,
            CaptureRequest.Builder requestBuilder)  throws Exception  {
        final int MIN_TONEMAP_CURVE_POINTS = 2;
        final Float ZERO = new Float(0);
        final Float ONE = new Float(1.0f);

        SimpleCaptureCallback listener = new SimpleCaptureCallback();
        int tonemapMode = requestBuilder.get(CaptureRequest.TONEMAP_MODE);
        Size maxPreviewSz = mOrderedPreviewSizes.get(0); // Max preview size.
        startPreview(requestBuilder, maxPreviewSz, listener);
        waitForSettingsApplied(listener, NUM_FRAMES_WAITED_FOR_UNKNOWN_LATENCY);

        int maxCurvePoints = mStaticInfo.getMaxTonemapCurvePointChecked();
        for (int i = 0; i < numFramesVerified; i++) {
            CaptureResult result = listener.getCaptureResult(WAIT_FOR_RESULT_TIMEOUT_MS);
            mCollector.expectEquals(""Capture result tonemap mode should match request"", tonemapMode,
                    result.get(CaptureResult.TONEMAP_MODE));
            TonemapCurve tc = getValueNotNull(result, CaptureResult.TONEMAP_CURVE);
            int pointCount = tc.getPointCount(TonemapCurve.CHANNEL_RED);
            float[] mapRed = new float[pointCount * TonemapCurve.POINT_SIZE];
            pointCount = tc.getPointCount(TonemapCurve.CHANNEL_GREEN);
            float[] mapGreen = new float[pointCount * TonemapCurve.POINT_SIZE];
            pointCount = tc.getPointCount(TonemapCurve.CHANNEL_BLUE);
            float[] mapBlue = new float[pointCount * TonemapCurve.POINT_SIZE];
            tc.copyColorCurve(TonemapCurve.CHANNEL_RED, mapRed, 0);
            tc.copyColorCurve(TonemapCurve.CHANNEL_GREEN, mapGreen, 0);
            tc.copyColorCurve(TonemapCurve.CHANNEL_BLUE, mapBlue, 0);
            if (tonemapMode == CaptureResult.TONEMAP_MODE_CONTRAST_CURVE) {
                /**
                 * TODO: need figure out a good way to measure the difference
                 * between request and result, as they may have different array
                 * size.
                 */
            } else if (tonemapMode == CaptureResult.TONEMAP_MODE_GAMMA_VALUE) {
                mCollector.expectEquals(""Capture result gamma value should match request"",
                        requestBuilder.get(CaptureRequest.TONEMAP_GAMMA),
                        result.get(CaptureResult.TONEMAP_GAMMA));
            } else if (tonemapMode == CaptureResult.TONEMAP_MODE_PRESET_CURVE) {
                mCollector.expectEquals(""Capture result preset curve should match request"",
                        requestBuilder.get(CaptureRequest.TONEMAP_PRESET_CURVE),
                        result.get(CaptureResult.TONEMAP_PRESET_CURVE));
            }

            // Tonemap curve result availability and basic validity check for all modes.
            mCollector.expectValuesInRange(""Tonemap curve red values are out of range"",
                    CameraTestUtils.toObject(mapRed), /*min*/ZERO, /*max*/ONE);
            mCollector.expectInRange(""Tonemap curve red length is out of range"",
                    mapRed.length, MIN_TONEMAP_CURVE_POINTS, maxCurvePoints * 2);
            mCollector.expectValuesInRange(""Tonemap curve green values are out of range"",
                    CameraTestUtils.toObject(mapGreen), /*min*/ZERO, /*max*/ONE);
            mCollector.expectInRange(""Tonemap curve green length is out of range"",
                    mapGreen.length, MIN_TONEMAP_CURVE_POINTS, maxCurvePoints * 2);
            mCollector.expectValuesInRange(""Tonemap curve blue values are out of range"",
                    CameraTestUtils.toObject(mapBlue), /*min*/ZERO, /*max*/ONE);
            mCollector.expectInRange(""Tonemap curve blue length is out of range"",
                    mapBlue.length, MIN_TONEMAP_CURVE_POINTS, maxCurvePoints * 2);

            // Make sure capture result tonemap has identical channels.
            if (mStaticInfo.isMonochromeCamera()) {
                mCollector.expectEquals(""Capture result tonemap of monochrome camera should "" +
                        ""have same dimension for all channels"", mapRed.length, mapGreen.length);
                mCollector.expectEquals(""Capture result tonemap of monochrome camera should "" +
                        ""have same dimension for all channels"", mapRed.length, mapBlue.length);

                if (mapRed.length == mapGreen.length && mapRed.length == mapBlue.length) {
                    boolean isIdentical = true;
                    for (int j = 0; j < mapRed.length; j++) {
                        isIdentical = (mapRed[j] == mapGreen[j] && mapRed[j] == mapBlue[j]);
                        if (!isIdentical)
                            break;
                    }
                    mCollector.expectTrue(""Capture result tonemap of monochrome camera should "" +
                            ""be identical between all channels"", isIdentical);
                }
            }
        }
        stopPreview();
    }

    /**
     * Test awb mode control.
     * <p>
     * Test each supported AWB mode, verify the AWB mode in capture result
     * matches request. When AWB is locked, the color correction gains and
     * transform should remain unchanged.
     * </p>
     */
    private void awbModeAndLockTestByCamera() throws Exception {
        int[] awbModes = mStaticInfo.getAwbAvailableModesChecked();
        Size maxPreviewSize = mOrderedPreviewSizes.get(0);
        boolean canSetAwbLock = mStaticInfo.isAwbLockSupported();
        CaptureRequest.Builder requestBuilder =
                mCamera.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);
        startPreview(requestBuilder, maxPreviewSize, /*listener*/null);

        for (int mode : awbModes) {
            SimpleCaptureCallback listener;
            requestBuilder.set(CaptureRequest.CONTROL_AWB_MODE, mode);
            listener = new SimpleCaptureCallback();
            mSession.setRepeatingRequest(requestBuilder.build(), listener, mHandler);
            waitForSettingsApplied(listener, NUM_FRAMES_WAITED_FOR_UNKNOWN_LATENCY);

            // Verify AWB mode in capture result.
            verifyCaptureResultForKey(CaptureResult.CONTROL_AWB_MODE, mode, listener,
                    NUM_FRAMES_VERIFIED);

            if (mode == CameraMetadata.CONTROL_AWB_MODE_AUTO && canSetAwbLock) {
                // Verify color correction transform and gains stay unchanged after a lock.
                requestBuilder.set(CaptureRequest.CONTROL_AWB_LOCK, true);
                listener = new SimpleCaptureCallback();
                mSession.setRepeatingRequest(requestBuilder.build(), listener, mHandler);
                waitForSettingsApplied(listener, NUM_FRAMES_WAITED_FOR_UNKNOWN_LATENCY);

                if (mStaticInfo.areKeysAvailable(CaptureResult.CONTROL_AWB_STATE)) {
                    waitForResultValue(listener, CaptureResult.CONTROL_AWB_STATE,
                            CaptureResult.CONTROL_AWB_STATE_LOCKED, NUM_RESULTS_WAIT_TIMEOUT);
                }

            }
            // Don't verify auto mode result if AWB lock is not supported
            if (mode != CameraMetadata.CONTROL_AWB_MODE_AUTO || canSetAwbLock) {
                verifyAwbCaptureResultUnchanged(listener, NUM_FRAMES_VERIFIED);
            }
        }
    }

    private void verifyAwbCaptureResultUnchanged(SimpleCaptureCallback listener,
            int numFramesVerified) {
        // Skip check if cc gains/transform/mode are not available
        if (!mStaticInfo.areKeysAvailable(
                CaptureResult.COLOR_CORRECTION_GAINS,
                CaptureResult.COLOR_CORRECTION_TRANSFORM,
                CaptureResult.COLOR_CORRECTION_MODE)) {
            return;
        }

        CaptureResult result = listener.getCaptureResult(WAIT_FOR_RESULT_TIMEOUT_MS);
        RggbChannelVector lockedGains =
                getValueNotNull(result, CaptureResult.COLOR_CORRECTION_GAINS);
        ColorSpaceTransform lockedTransform =
                getValueNotNull(result, CaptureResult.COLOR_CORRECTION_TRANSFORM);

        for (int i = 0; i < numFramesVerified; i++) {
            result = listener.getCaptureResult(WAIT_FOR_RESULT_TIMEOUT_MS);
            // Color correction mode check is skipped here, as it is checked in colorCorrectionTest.
            validateColorCorrectionResult(result, result.get(CaptureResult.COLOR_CORRECTION_MODE));

            RggbChannelVector gains = getValueNotNull(result, CaptureResult.COLOR_CORRECTION_GAINS);
            ColorSpaceTransform transform =
                    getValueNotNull(result, CaptureResult.COLOR_CORRECTION_TRANSFORM);
            mCollector.expectEquals(""Color correction gains should remain unchanged after awb lock"",
                    lockedGains, gains);
            mCollector.expectEquals(""Color correction transform should remain unchanged after""
                    + "" awb lock"", lockedTransform, transform);
        }
    }

    /**
     * Test AF mode control.
     * <p>
     * Test all supported AF modes, verify the AF mode in capture result matches
     * request. When AF mode is one of the CONTROL_AF_MODE_CONTINUOUS_* mode,
     * verify if the AF can converge to PASSIVE_FOCUSED or PASSIVE_UNFOCUSED
     * state within certain amount of frames.
     * </p>
     */
    private void afModeTestByCamera() throws Exception {
        int[] afModes = mStaticInfo.getAfAvailableModesChecked();
        Size maxPreviewSize = mOrderedPreviewSizes.get(0);
        CaptureRequest.Builder requestBuilder =
                mCamera.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);
        startPreview(requestBuilder, maxPreviewSize, /*listener*/null);

        for (int mode : afModes) {
            SimpleCaptureCallback listener;
            requestBuilder.set(CaptureRequest.CONTROL_AF_MODE, mode);
            listener = new SimpleCaptureCallback();
            mSession.setRepeatingRequest(requestBuilder.build(), listener, mHandler);
            waitForSettingsApplied(listener, NUM_FRAMES_WAITED_FOR_UNKNOWN_LATENCY);

            // Verify AF mode in capture result.
            verifyCaptureResultForKey(CaptureResult.CONTROL_AF_MODE, mode, listener,
                    NUM_FRAMES_VERIFIED);

            // Verify AF can finish a scan for CONTROL_AF_MODE_CONTINUOUS_* modes.
            // In LEGACY mode, a transition to one of the continuous AF modes does not necessarily
            // result in a passive AF call if the camera has already been focused, and the scene has
            // not changed enough to trigger an AF pass.  Skip this constraint for LEGACY.
            if (mStaticInfo.isHardwareLevelAtLeastLimited() &&
                    (mode == CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE ||
                    mode == CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_VIDEO)) {
                List<Integer> afStateList = new ArrayList<Integer>();
                afStateList.add(CaptureResult.CONTROL_AF_STATE_PASSIVE_FOCUSED);
                afStateList.add(CaptureResult.CONTROL_AF_STATE_PASSIVE_UNFOCUSED);
                waitForAnyResultValue(listener, CaptureResult.CONTROL_AF_STATE, afStateList,
                        NUM_RESULTS_WAIT_TIMEOUT);
            }
        }
    }

    /**
     * Test video and optical stabilizations if they are supported by a given camera.
     */
    private void stabilizationTestByCamera() throws Exception {
        // video stabilization test.
        List<Key<?>> keys = mStaticInfo.getCharacteristics().getKeys();

        Integer[] videoStabModes = (keys.contains(CameraCharacteristics.
                CONTROL_AVAILABLE_VIDEO_STABILIZATION_MODES)) ?
                CameraTestUtils.toObject(mStaticInfo.getAvailableVideoStabilizationModesChecked()) :
                    new Integer[0];
        int[] opticalStabModes = (keys.contains(
                CameraCharacteristics.LENS_INFO_AVAILABLE_OPTICAL_STABILIZATION)) ?
                mStaticInfo.getAvailableOpticalStabilizationChecked() : new int[0];

        Size maxPreviewSize = mOrderedPreviewSizes.get(0);
        CaptureRequest.Builder requestBuilder =
                mCamera.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);
        SimpleCaptureCallback listener = new SimpleCaptureCallback();
        startPreview(requestBuilder, maxPreviewSize, listener);

        for (Integer mode : videoStabModes) {
            listener = new SimpleCaptureCallback();
            requestBuilder.set(CaptureRequest.CONTROL_VIDEO_STABILIZATION_MODE, mode);
            mSession.setRepeatingRequest(requestBuilder.build(), listener, mHandler);
            waitForSettingsApplied(listener, NUM_FRAMES_WAITED_FOR_UNKNOWN_LATENCY);
            // Video stabilization could return any modes.
            verifyAnyCaptureResultForKey(CaptureResult.CONTROL_VIDEO_STABILIZATION_MODE,
                    videoStabModes, listener, NUM_FRAMES_VERIFIED);
        }

        for (int mode : opticalStabModes) {
            listener = new SimpleCaptureCallback();
            requestBuilder.set(CaptureRequest.LENS_OPTICAL_STABILIZATION_MODE, mode);
            mSession.setRepeatingRequest(requestBuilder.build(), listener, mHandler);
            waitForSettingsApplied(listener, NUM_FRAMES_WAITED_FOR_UNKNOWN_LATENCY);
            verifyCaptureResultForKey(CaptureResult.LENS_OPTICAL_STABILIZATION_MODE, mode,
                    listener, NUM_FRAMES_VERIFIED);
        }

        stopPreview();
    }

    private void digitalZoomTestByCamera(Size previewSize) throws Exception {
        final int ZOOM_STEPS = 15;
        final PointF[] TEST_ZOOM_CENTERS;
        final float maxZoom = mStaticInfo.getAvailableMaxDigitalZoomChecked();
        final float ZOOM_ERROR_MARGIN = 0.01f;
        if (Math.abs(maxZoom - 1.0f) < ZOOM_ERROR_MARGIN) {
            // It doesn't make much sense to test the zoom if the device effectively supports
            // no zoom.
            return;
        }

        final int croppingType = mStaticInfo.getScalerCroppingTypeChecked();
        if (croppingType == CameraCharacteristics.SCALER_CROPPING_TYPE_FREEFORM) {
            // Set the four corners in a way that the minimally allowed zoom factor is 2x.
            float normalizedLeft = 0.25f;
            float normalizedTop = 0.25f;
            float normalizedRight = 0.75f;
            float normalizedBottom = 0.75f;
            // If the max supported zoom is too small, make sure we at least test the max
            // Zoom is tested for the four corners.
            if (maxZoom < 2.0f) {
                normalizedLeft = 0.5f / maxZoom;
                normalizedTop = 0.5f / maxZoom;
                normalizedRight = 1.0f - normalizedLeft;
                normalizedBottom = 1.0f - normalizedTop;
            }
            TEST_ZOOM_CENTERS = new PointF[] {
                new PointF(0.5f, 0.5f),   // Center point
                new PointF(normalizedLeft, normalizedTop),     // top left corner zoom
                new PointF(normalizedRight, normalizedTop),    // top right corner zoom
                new PointF(normalizedLeft, normalizedBottom),  // bottom left corner zoom
                new PointF(normalizedRight, normalizedBottom), // bottom right corner zoom
            };

            if (VERBOSE) {
                Log.v(TAG, ""Testing zoom with CROPPING_TYPE = FREEFORM"");
            }
        } else {
            // CENTER_ONLY
            TEST_ZOOM_CENTERS = new PointF[] {
                    new PointF(0.5f, 0.5f),   // Center point
            };

            if (VERBOSE) {
                Log.v(TAG, ""Testing zoom with CROPPING_TYPE = CENTER_ONLY"");
            }
        }

        final Rect activeArraySize = mStaticInfo.getActiveArraySizeChecked();
        final Rect defaultCropRegion = new Rect(0, 0,
                activeArraySize.width(), activeArraySize.height());
        Rect[] cropRegions = new Rect[ZOOM_STEPS];
        MeteringRectangle[][] expectRegions = new MeteringRectangle[ZOOM_STEPS][];
        CaptureRequest.Builder requestBuilder =
                mCamera.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);
        SimpleCaptureCallback listener = new SimpleCaptureCallback();

        updatePreviewSurface(previewSize);
        configurePreviewOutput(requestBuilder);

        CaptureRequest[] requests = new CaptureRequest[ZOOM_STEPS];

        // Set algorithm regions
        final int METERING_RECT_RATIO = 10;
        final MeteringRectangle[][] defaultMeteringRects = new MeteringRectangle[][] {
                {
                    new MeteringRectangle (
                        /*x*/0, /*y*/0, activeArraySize.width(), activeArraySize.height(),
                        /*meteringWeight*/1), /* full active region */
                },
                {
                    new MeteringRectangle (
                        /*x*/0, /*y*/0, activeArraySize.width()/METERING_RECT_RATIO,
                        activeArraySize.height()/METERING_RECT_RATIO,
                        /*meteringWeight*/1),
                },
                {
                    new MeteringRectangle (
                        /*x*/(int)(activeArraySize.width() * (0.5f - 0.5f/METERING_RECT_RATIO)),
                        /*y*/(int)(activeArraySize.height() * (0.5f - 0.5f/METERING_RECT_RATIO)),
                        activeArraySize.width()/METERING_RECT_RATIO,
                        activeArraySize.height()/METERING_RECT_RATIO,
                        /*meteringWeight*/1),
                },
        };

        final int CAPTURE_SUBMIT_REPEAT;
        {
            int maxLatency = mStaticInfo.getSyncMaxLatency();
            if (maxLatency == CameraMetadata.SYNC_MAX_LATENCY_UNKNOWN) {
                CAPTURE_SUBMIT_REPEAT = NUM_FRAMES_WAITED_FOR_UNKNOWN_LATENCY + 1;
            } else {
                CAPTURE_SUBMIT_REPEAT = maxLatency + 1;
            }
        }

        if (VERBOSE) {
            Log.v(TAG, ""Testing zoom with CAPTURE_SUBMIT_REPEAT = "" + CAPTURE_SUBMIT_REPEAT);
        }

        for (MeteringRectangle[] meteringRect : defaultMeteringRects) {
            for (int algo = 0; algo < NUM_ALGORITHMS; algo++) {
                update3aRegion(requestBuilder, algo,  meteringRect);
            }

            for (PointF center : TEST_ZOOM_CENTERS) {
                Rect previousCrop = null;

                for (int i = 0; i < ZOOM_STEPS; i++) {
                    /*
                     * Submit capture request
                     */
                    float zoomFactor = (float) (1.0f + (maxZoom - 1.0) * i / ZOOM_STEPS);
                    cropRegions[i] = getCropRegionForZoom(zoomFactor, center,
                            maxZoom, defaultCropRegion);
                    if (VERBOSE) {
                        Log.v(TAG, ""Testing Zoom for factor "" + zoomFactor + "" and center "" +
                                center + "" The cropRegion is "" + cropRegions[i] +
                                "" Preview size is "" + previewSize);
                    }
                    requestBuilder.set(CaptureRequest.SCALER_CROP_REGION, cropRegions[i]);
                    requests[i] = requestBuilder.build();
                    for (int j = 0; j < CAPTURE_SUBMIT_REPEAT; ++j) {
                        if (VERBOSE) {
                            Log.v(TAG, ""submit crop region "" + cropRegions[i]);
                        }
                        mSession.capture(requests[i], listener, mHandler);
                    }

                    /*
                     * Validate capture result
                     */
                    waitForNumResults(listener, CAPTURE_SUBMIT_REPEAT - 1); // Drop first few frames
                    TotalCaptureResult result = listener.getTotalCaptureResultForRequest(
                            requests[i], NUM_RESULTS_WAIT_TIMEOUT);
                    List<CaptureResult> partialResults = result.getPartialResults();

                    Rect cropRegion = getValueNotNull(result, CaptureResult.SCALER_CROP_REGION);
                    for (CaptureResult partialResult : partialResults) {
                        Rect cropRegionInPartial =
                                partialResult.get(CaptureResult.SCALER_CROP_REGION);
                        if (cropRegionInPartial != null) {
                            mCollector.expectEquals(""SCALER_CROP_REGION in partial result must ""
                                    + ""match in final result"", cropRegionInPartial, cropRegion);
                        }
                    }

                    /*
                     * Validate resulting crop regions
                     */
                    if (previousCrop != null) {
                        Rect currentCrop = cropRegion;
                        mCollector.expectTrue(String.format(
                                ""Crop region should shrink or stay the same "" +
                                        ""(previous = %s, current = %s)"",
                                        previousCrop, currentCrop),
                                previousCrop.equals(currentCrop) ||
                                    (previousCrop.width() > currentCrop.width() &&
                                     previousCrop.height() > currentCrop.height()));
                    }

                    if (mStaticInfo.isHardwareLevelAtLeastLimited()) {
                        mCollector.expectRectsAreSimilar(
                                ""Request and result crop region should be similar"",
                                cropRegions[i], cropRegion, CROP_REGION_ERROR_PERCENT_DELTA);
                    }

                    if (croppingType == SCALER_CROPPING_TYPE_CENTER_ONLY) {
                        mCollector.expectRectCentered(
                                ""Result crop region should be centered inside the active array"",
                                new Size(activeArraySize.width(), activeArraySize.height()),
                                cropRegion, CROP_REGION_ERROR_PERCENT_CENTERED);
                    }

                    /*
                     * Validate resulting metering regions
                     */

                    // Use the actual reported crop region to calculate the resulting metering region
                    expectRegions[i] = getExpectedOutputRegion(
                            /*requestRegion*/meteringRect,
                            /*cropRect*/     cropRegion);

                    // Verify Output 3A region is intersection of input 3A region and crop region
                    for (int algo = 0; algo < NUM_ALGORITHMS; algo++) {
                        validate3aRegion(result, partialResults, algo, expectRegions[i],
                                false/*scaleByZoomRatio*/);
                    }

                    previousCrop = cropRegion;
                }

                if (maxZoom > 1.0f) {
                    mCollector.expectTrue(
                            String.format(""Most zoomed-in crop region should be smaller"" +
                                            ""than active array w/h"" +
                                            ""(last crop = %s, active array = %s)"",
                                            previousCrop, activeArraySize),
                                (previousCrop.width() < activeArraySize.width() &&
                                 previousCrop.height() < activeArraySize.height()));
                }
            }
        }
    }

    private void zoomRatioTestByCamera(Size previewSize) throws Exception {
        final int ZOOM_STEPS = 15;
        final Range<Float> zoomRatioRange = mStaticInfo.getZoomRatioRangeChecked();
        // The error margin is derive from a VGA size camera zoomed all the way to 10x, in which
        // case the cropping error can be as large as 480/46 - 480/48 = 0.435.
        final float ZOOM_ERROR_MARGIN = 0.05f;

        final Rect activeArraySize = mStaticInfo.getActiveArraySizeChecked();
        final Rect defaultCropRegion =
                new Rect(0, 0, activeArraySize.width(), activeArraySize.height());
        final Rect zoom2xCropRegion =
                new Rect(activeArraySize.width()/4, activeArraySize.height()/4,
                        activeArraySize.width()*3/4, activeArraySize.height()*3/4);
        MeteringRectangle[][] expectRegions = new MeteringRectangle[ZOOM_STEPS][];
        CaptureRequest.Builder requestBuilder =
                mCamera.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);
        requestBuilder.set(CaptureRequest.SCALER_CROP_REGION, defaultCropRegion);
        SimpleCaptureCallback listener = new SimpleCaptureCallback();

        updatePreviewSurface(previewSize);
        configurePreviewOutput(requestBuilder);

        // Set algorithm regions to full active region
        final MeteringRectangle[] defaultMeteringRect = new MeteringRectangle[] {
                new MeteringRectangle (
                        /*x*/0, /*y*/0, activeArraySize.width(), activeArraySize.height(),
                        /*meteringWeight*/1)
        };

        for (int algo = 0; algo < NUM_ALGORITHMS; algo++) {
            update3aRegion(requestBuilder, algo,  defaultMeteringRect);
        }

        final int captureSubmitRepeat;
        {
            int maxLatency = mStaticInfo.getSyncMaxLatency();
            if (maxLatency == CameraMetadata.SYNC_MAX_LATENCY_UNKNOWN) {
                captureSubmitRepeat = NUM_FRAMES_WAITED_FOR_UNKNOWN_LATENCY + 1;
            } else {
                captureSubmitRepeat = maxLatency + 1;
            }
        }

        float previousRatio = zoomRatioRange.getLower();
        for (int i = 0; i < ZOOM_STEPS; i++) {
            /*
             * Submit capture request
             */
            float zoomFactor = zoomRatioRange.getLower() + (zoomRatioRange.getUpper() -
                    zoomRatioRange.getLower()) * i / ZOOM_STEPS;
            if (VERBOSE) {
                Log.v(TAG, ""Testing Zoom ratio "" + zoomFactor + "" Preview size is "" + previewSize);
            }
            requestBuilder.set(CaptureRequest.CONTROL_ZOOM_RATIO, zoomFactor);
            requestBuilder.set(CaptureRequest.SCALER_CROP_REGION, defaultCropRegion);
            CaptureRequest request = requestBuilder.build();
            for (int j = 0; j < captureSubmitRepeat; ++j) {
                mSession.capture(request, listener, mHandler);
            }

            /*
             * Validate capture result
             */
            waitForNumResults(listener, captureSubmitRepeat - 1); // Drop first few frames
            TotalCaptureResult result = listener.getTotalCaptureResultForRequest(
                    request, NUM_RESULTS_WAIT_TIMEOUT);
            List<CaptureResult> partialResults = result.getPartialResults();
            float resultZoomRatio = getValueNotNull(result, CaptureResult.CONTROL_ZOOM_RATIO);
            Rect cropRegion = getValueNotNull(result, CaptureResult.SCALER_CROP_REGION);

            for (CaptureResult partialResult : partialResults) {
                Rect cropRegionInPartial =
                        partialResult.get(CaptureResult.SCALER_CROP_REGION);
                if (cropRegionInPartial != null) {
                    mCollector.expectEquals(""SCALER_CROP_REGION in partial result must ""
                            + ""match in final result"", cropRegionInPartial, cropRegion);
                }

                Float zoomRatioInPartial = partialResult.get(CaptureResult.CONTROL_ZOOM_RATIO);
                if (zoomRatioInPartial != null) {
                    mCollector.expectEquals(""CONTROL_ZOOM_RATIO in partial result must match""
                            + "" that in final result"", resultZoomRatio, zoomRatioInPartial);
                }
            }

            /*
             * Validate resulting crop regions and zoom ratio
             */
            mCollector.expectTrue(String.format(
                    ""Zoom ratio should increase or stay the same "" +
                            ""(previous = %f, current = %f)"",
                            previousRatio, resultZoomRatio),
                    Math.abs(previousRatio - resultZoomRatio) < ZOOM_ERROR_MARGIN ||
                        (previousRatio < resultZoomRatio));

            mCollector.expectTrue(String.format(
                    ""Request and result zoom ratio should be similar "" +
                    ""(requested = %f, result = %f"", zoomFactor, resultZoomRatio),
                    Math.abs(zoomFactor - resultZoomRatio)/zoomFactor <= ZOOM_ERROR_MARGIN);

            //In case zoom ratio is converted to crop region at HAL, due to error magnification
            //when converting to post-zoom crop region, scale the error threshold for crop region
            //check.
            float errorMultiplier = Math.max(1.0f, zoomFactor);
            if (mStaticInfo.isHardwareLevelAtLeastLimited()) {
                mCollector.expectRectsAreSimilar(
                        ""Request and result crop region should be similar"",
                        defaultCropRegion, cropRegion,
                        CROP_REGION_ERROR_PERCENT_DELTA * errorMultiplier);
            }

            mCollector.expectRectCentered(
                    ""Result crop region should be centered inside the active array"",
                    new Size(activeArraySize.width(), activeArraySize.height()),
                    cropRegion, CROP_REGION_ERROR_PERCENT_CENTERED * errorMultiplier);

            /*
             * Validate resulting metering regions
             */
            // Use the actual reported crop region to calculate the resulting metering region
            expectRegions[i] = getExpectedOutputRegion(
                    /*requestRegion*/defaultMeteringRect,
                    /*cropRect*/     cropRegion);

            // Verify Output 3A region is intersection of input 3A region and crop region
            boolean scaleByZoomRatio = zoomFactor > 1.0f;
            for (int algo = 0; algo < NUM_ALGORITHMS; algo++) {
                validate3aRegion(result, partialResults, algo, expectRegions[i], scaleByZoomRatio);
            }

            previousRatio = resultZoomRatio;

            /*
             * Set windowboxing cropRegion while zoomRatio is not 1.0x, and make sure the crop
             * region was overwritten.
             */
            if (zoomFactor != 1.0f) {
                requestBuilder.set(CaptureRequest.SCALER_CROP_REGION, zoom2xCropRegion);
                CaptureRequest requestWithCrop = requestBuilder.build();
                for (int j = 0; j < captureSubmitRepeat; ++j) {
                    mSession.capture(requestWithCrop, listener, mHandler);
                }

                waitForNumResults(listener, captureSubmitRepeat - 1); // Drop first few frames
                CaptureResult resultWithCrop = listener.getCaptureResultForRequest(
                        requestWithCrop, NUM_RESULTS_WAIT_TIMEOUT);
                float resultZoomRatioWithCrop = getValueNotNull(resultWithCrop,
                        CaptureResult.CONTROL_ZOOM_RATIO);
                Rect cropRegionWithCrop = getValueNotNull(resultWithCrop,
                        CaptureResult.SCALER_CROP_REGION);

                mCollector.expectTrue(String.format(
                        ""Result zoom ratio should remain the same (activeArrayCrop: %f, "" +
                        ""zoomedCrop: %f)"", resultZoomRatio, resultZoomRatioWithCrop),
                        Math.abs(resultZoomRatio - resultZoomRatioWithCrop) < ZOOM_ERROR_MARGIN);

                if (mStaticInfo.isHardwareLevelAtLeastLimited()) {
                    mCollector.expectRectsAreSimilar(
                            ""Result crop region should remain the same with or without crop"",
                            cropRegion, cropRegionWithCrop, CROP_REGION_ERROR_PERCENT_DELTA);
                }
            }
        }
    }

    private void digitalZoomPreviewCombinationTestByCamera() throws Exception {
        final double ASPECT_RATIO_THRESHOLD = 0.001;
        List<Double> aspectRatiosTested = new ArrayList<Double>();
        Size maxPreviewSize = mOrderedPreviewSizes.get(0);
        aspectRatiosTested.add((double)(maxPreviewSize.getWidth()) / maxPreviewSize.getHeight());

        for (Size size : mOrderedPreviewSizes) {
            // Max preview size was already tested in testDigitalZoom test. skip it.
            if (size.equals(maxPreviewSize)) {
                continue;
            }

            // Only test the largest size for each aspect ratio.
            double aspectRatio = (double)(size.getWidth()) / size.getHeight();
            if (isAspectRatioContained(aspectRatiosTested, aspectRatio, ASPECT_RATIO_THRESHOLD)) {
                continue;
            }

            if (VERBOSE) {
                Log.v(TAG, ""Test preview size "" + size.toString() + "" digital zoom"");
            }

            aspectRatiosTested.add(aspectRatio);
            digitalZoomTestByCamera(size);
        }
    }

    private static boolean isAspectRatioContained(List<Double> aspectRatioList,
            double aspectRatio, double delta) {
        for (Double ratio : aspectRatioList) {
            if (Math.abs(ratio - aspectRatio) < delta) {
                return true;
            }
        }

        return false;
    }

    private void sceneModeTestByCamera() throws Exception {
        int[] sceneModes = mStaticInfo.getAvailableSceneModesChecked();
        Size maxPreviewSize = mOrderedPreviewSizes.get(0);
        CaptureRequest.Builder requestBuilder =
                mCamera.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);
        SimpleCaptureCallback listener = new SimpleCaptureCallback();
        requestBuilder.set(CaptureRequest.CONTROL_MODE, CaptureRequest.CONTROL_MODE_USE_SCENE_MODE);
        startPreview(requestBuilder, maxPreviewSize, listener);

        for(int mode : sceneModes) {
            requestBuilder.set(CaptureRequest.CONTROL_SCENE_MODE, mode);
            listener = new SimpleCaptureCallback();
            mSession.setRepeatingRequest(requestBuilder.build(), listener, mHandler);
            waitForSettingsApplied(listener, NUM_FRAMES_WAITED_FOR_UNKNOWN_LATENCY);

            verifyCaptureResultForKey(CaptureResult.CONTROL_SCENE_MODE,
                    mode, listener, NUM_FRAMES_VERIFIED);
            // This also serves as purpose of showing preview for NUM_FRAMES_VERIFIED
            verifyCaptureResultForKey(CaptureResult.CONTROL_MODE,
                    CaptureRequest.CONTROL_MODE_USE_SCENE_MODE, listener, NUM_FRAMES_VERIFIED);
        }
    }

    private void effectModeTestByCamera() throws Exception {
        int[] effectModes = mStaticInfo.getAvailableEffectModesChecked();
        Size maxPreviewSize = mOrderedPreviewSizes.get(0);
        CaptureRequest.Builder requestBuilder =
                mCamera.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);
        requestBuilder.set(CaptureRequest.CONTROL_MODE, CaptureRequest.CONTROL_MODE_AUTO);
        SimpleCaptureCallback listener = new SimpleCaptureCallback();
        startPreview(requestBuilder, maxPreviewSize, listener);

        for(int mode : effectModes) {
            requestBuilder.set(CaptureRequest.CONTROL_EFFECT_MODE, mode);
            listener = new SimpleCaptureCallback();
            mSession.setRepeatingRequest(requestBuilder.build(), listener, mHandler);
            waitForSettingsApplied(listener, NUM_FRAMES_WAITED_FOR_UNKNOWN_LATENCY);

            verifyCaptureResultForKey(CaptureResult.CONTROL_EFFECT_MODE,
                    mode, listener, NUM_FRAMES_VERIFIED);
            // This also serves as purpose of showing preview for NUM_FRAMES_VERIFIED
            verifyCaptureResultForKey(CaptureResult.CONTROL_MODE,
                    CaptureRequest.CONTROL_MODE_AUTO, listener, NUM_FRAMES_VERIFIED);
        }
    }

    private void extendedSceneModeTestByCamera(List<Range<Integer>> fpsRanges) throws Exception {
        Capability[] extendedSceneModeCaps = mStaticInfo.getAvailableExtendedSceneModeCapsChecked();
        if (extendedSceneModeCaps.length == 0) {
            return;
        }

        Size maxPreviewSize = mOrderedPreviewSizes.get(0);
        CaptureRequest.Builder requestBuilder =
                mCamera.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);

        for (Capability cap : extendedSceneModeCaps) {
            int mode = cap.getMode();
            requestBuilder.set(CaptureRequest.CONTROL_EXTENDED_SCENE_MODE, mode);

            // Test that DISABLED and BOKEH_CONTINUOUS mode doesn't slow down the frame rate
            if (mode == CaptureRequest.CONTROL_EXTENDED_SCENE_MODE_DISABLED ||
                    mode == CaptureRequest.CONTROL_EXTENDED_SCENE_MODE_BOKEH_CONTINUOUS) {
                verifyFpsNotSlowDown(requestBuilder, NUM_FRAMES_VERIFIED, fpsRanges);
            }

            Range<Float> zoomRange = cap.getZoomRatioRange();
            float[] zoomRatios = new float[]{zoomRange.getLower(), zoomRange.getUpper()};
            for (float ratio : zoomRatios) {
                SimpleCaptureCallback listener = new SimpleCaptureCallback();
                requestBuilder.set(CaptureRequest.CONTROL_ZOOM_RATIO, ratio);
                startPreview(requestBuilder, maxPreviewSize, listener);
                waitForSettingsApplied(listener, NUM_FRAMES_WAITED_FOR_UNKNOWN_LATENCY);

                verifyCaptureResultForKey(CaptureResult.CONTROL_EXTENDED_SCENE_MODE,
                        mode, listener, NUM_FRAMES_VERIFIED);
                verifyCaptureResultForKey(CaptureResult.CONTROL_ZOOM_RATIO,
                        ratio, listener, NUM_FRAMES_VERIFIED);
            }
        }
    }

    //----------------------------------------------------------------
    //---------Below are common functions for all tests.--------------
    //----------------------------------------------------------------

    /**
     * Enable exposure manual control and change exposure and sensitivity and
     * clamp the value into the supported range.
     */
    private void changeExposure(CaptureRequest.Builder requestBuilder,
            long expTime, int sensitivity) {
        // Check if the max analog sensitivity is available and no larger than max sensitivity.  The
        // max analog sensitivity is not actually used here. This is only an extra correctness
        // check.
        mStaticInfo.getMaxAnalogSensitivityChecked();

        expTime = mStaticInfo.getExposureClampToRange(expTime);
        sensitivity = mStaticInfo.getSensitivityClampToRange(sensitivity);

        requestBuilder.set(CaptureRequest.CONTROL_AE_MODE, CONTROL_AE_MODE_OFF);
        requestBuilder.set(CaptureRequest.SENSOR_EXPOSURE_TIME, expTime);
        requestBuilder.set(CaptureRequest.SENSOR_SENSITIVITY, sensitivity);
    }
    /**
     * Enable exposure manual control and change exposure time and
     * clamp the value into the supported range.
     *
     * <p>The sensitivity is set to default value.</p>
     */
    private void changeExposure(CaptureRequest.Builder requestBuilder, long expTime) {
        changeExposure(requestBuilder, expTime, DEFAULT_SENSITIVITY);
    }

    /**
     * Get the exposure time array that contains multiple exposure time steps in
     * the exposure time range, in nanoseconds.
     */
    private long[] getExposureTimeTestValues() {
        long[] testValues = new long[DEFAULT_NUM_EXPOSURE_TIME_STEPS + 1];
        long maxExpTime = mStaticInfo.getExposureMaximumOrDefault(DEFAULT_EXP_TIME_NS);
        long minExpTime = mStaticInfo.getExposureMinimumOrDefault(DEFAULT_EXP_TIME_NS);

        long range = maxExpTime - minExpTime;
        double stepSize = range / (double)DEFAULT_NUM_EXPOSURE_TIME_STEPS;
        for (int i = 0; i < testValues.length; i++) {
            testValues[i] = maxExpTime - (long)(stepSize * i);
            testValues[i] = mStaticInfo.getExposureClampToRange(testValues[i]);
        }

        return testValues;
    }

    /**
     * Generate test focus distances in range of [0, minFocusDistance] in increasing order.
     *
     * @param repeatMin number of times minValue will be repeated.
     * @param repeatMax number of times maxValue will be repeated.
     */
    private float[] getFocusDistanceTestValuesInOrder(int repeatMin, int repeatMax) {
        int totalCount = NUM_TEST_FOCUS_DISTANCES + 1 + repeatMin + repeatMax;
        float[] testValues = new float[totalCount];
        float minValue = 0;
        float maxValue = mStaticInfo.getMinimumFocusDistanceChecked();

        float range = maxValue - minValue;
        float stepSize = range / NUM_TEST_FOCUS_DISTANCES;

        for (int i = 0; i < repeatMin; i++) {
            testValues[i] = minValue;
        }
        for (int i = 0; i <= NUM_TEST_FOCUS_DISTANCES; i++) {
            testValues[repeatMin+i] = minValue + stepSize * i;
        }
        for (int i = 0; i < repeatMax; i++) {
            testValues[repeatMin+NUM_TEST_FOCUS_DISTANCES+1+i] =
                    maxValue;
        }

        return testValues;
    }

    /**
     * Get the sensitivity array that contains multiple sensitivity steps in the
     * sensitivity range.
     * <p>
     * Sensitivity number of test values is determined by
     * {@value #DEFAULT_SENSITIVITY_STEP_SIZE} and sensitivity range, and
     * bounded by {@value #DEFAULT_NUM_SENSITIVITY_STEPS}.
     * </p>
     */
    private int[] getSensitivityTestValues() {
        int maxSensitivity = mStaticInfo.getSensitivityMaximumOrDefault(
                DEFAULT_SENSITIVITY);
        int minSensitivity = mStaticInfo.getSensitivityMinimumOrDefault(
                DEFAULT_SENSITIVITY);

        int range = maxSensitivity - minSensitivity;
        int stepSize = DEFAULT_SENSITIVITY_STEP_SIZE;
        int numSteps = range / stepSize;
        // Bound the test steps to avoid supper long test.
        if (numSteps > DEFAULT_NUM_SENSITIVITY_STEPS) {
            numSteps = DEFAULT_NUM_SENSITIVITY_STEPS;
            stepSize = range / numSteps;
        }
        int[] testValues = new int[numSteps + 1];
        for (int i = 0; i < testValues.length; i++) {
            testValues[i] = maxSensitivity - stepSize * i;
            testValues[i] = mStaticInfo.getSensitivityClampToRange(testValues[i]);
        }

        return testValues;
    }

    /**
     * Validate the AE manual control exposure time.
     *
     * <p>Exposure should be close enough, and only round down if they are not equal.</p>
     *
     * @param request Request exposure time
     * @param result Result exposure time
     */
    private void validateExposureTime(long request, long result) {
        long expTimeDelta = request - result;
        long expTimeErrorMargin = (long)(Math.max(EXPOSURE_TIME_ERROR_MARGIN_NS, request
                * EXPOSURE_TIME_ERROR_MARGIN_RATE));
        // First, round down not up, second, need close enough.
        mCollector.expectTrue(""Exposture time is invalid for AE manaul control test, request: ""
                + request + "" result: "" + result,
                expTimeDelta < expTimeErrorMargin && expTimeDelta >= 0);
    }

    /**
     * Validate AE manual control sensitivity.
     *
     * @param request Request sensitivity
     * @param result Result sensitivity
     */
    private void validateSensitivity(int request, int result) {
        float sensitivityDelta = request - result;
        float sensitivityErrorMargin = request * SENSITIVITY_ERROR_MARGIN_RATE;
        // First, round down not up, second, need close enough.
        mCollector.expectTrue(""Sensitivity is invalid for AE manaul control test, request: ""
                + request + "" result: "" + result,
                sensitivityDelta < sensitivityErrorMargin && sensitivityDelta >= 0);
    }

    /**
     * Validate frame duration for a given capture.
     *
     * <p>Frame duration should be longer than exposure time.</p>
     *
     * @param result The capture result for a given capture
     */
    private void validateFrameDurationForCapture(CaptureResult result) {
        long expTime = getValueNotNull(result, CaptureResult.SENSOR_EXPOSURE_TIME);
        long frameDuration = getValueNotNull(result, CaptureResult.SENSOR_FRAME_DURATION);
        if (VERBOSE) {
            Log.v(TAG, ""frame duration: "" + frameDuration + "" Exposure time: "" + expTime);
        }

        mCollector.expectTrue(String.format(""Frame duration (%d) should be longer than exposure""
                + "" time (%d) for a given capture"", frameDuration, expTime),
                frameDuration >= expTime);

        validatePipelineDepth(result);
    }

    /**
     * Basic verification for the control mode capture result.
     *
     * @param key The capture result key to be verified against
     * @param requestMode The request mode for this result
     * @param listener The capture listener to get capture results
     * @param numFramesVerified The number of capture results to be verified
     */
    private <T> void verifyCaptureResultForKey(CaptureResult.Key<T> key, T requestMode,
            SimpleCaptureCallback listener, int numFramesVerified) {
        for (int i = 0; i < numFramesVerified; i++) {
            CaptureResult result = listener.getCaptureResult(WAIT_FOR_RESULT_TIMEOUT_MS);
            validatePipelineDepth(result);
            T resultMode = getValueNotNull(result, key);
            if (VERBOSE) {
                Log.v(TAG, ""Expect value: "" + requestMode.toString() + "" result value: ""
                        + resultMode.toString());
            }
            mCollector.expectEquals(""Key "" + key.getName() + "" result should match request"",
                    requestMode, resultMode);
        }
    }

    /**
     * Basic verification that the value of a capture result key should be one of the expected
     * values.
     *
     * @param key The capture result key to be verified against
     * @param expectedModes The list of any possible expected modes for this result
     * @param listener The capture listener to get capture results
     * @param numFramesVerified The number of captur"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.widget.cts.util.ListScenario"	"getListView"	"CtsWidgetTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/util/ListScenario.java"	""	"public void test/*
 *.
 */

package android.widget.cts.util;

import android.app.Activity;
import android.graphics.Rect;
import android.os.Bundle;
import android.view.View;
import android.view.ViewGroup;
import android.view.Window;
import android.widget.AdapterView;
import android.widget.BaseAdapter;
import android.widget.EditText;
import android.widget.LinearLayout;
import android.widget.ListView;
import android.widget.TextView;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * Utility base class for creating various List scenarios.  Configurable by the number
 * of items, how tall each item should be (in relation to the screen height), and
 * what item should start with selection.
 */
public abstract class ListScenario extends Activity {

    private ListView mListView;
    private TextView mHeaderTextView;

    private int mNumItems;
    protected boolean mItemsFocusable;

    private int mStartingSelectionPosition;
    private double mItemScreenSizeFactor;
    private Map<Integer, Double> mOverrideItemScreenSizeFactors = new HashMap<>();

    private int mScreenHeight;

    // whether to include a text view above the list
    private boolean mIncludeHeader;

    // separators
    private Set<Integer> mUnselectableItems = new HashSet<Integer>();

    private boolean mStackFromBottom;

    private int mClickedPosition = -1;

    private int mLongClickedPosition = -1;

    private int mConvertMisses = 0;

    private int mHeaderViewCount;
    private boolean mHeadersFocusable;

    private int mFooterViewCount;
    private LinearLayout mLinearLayout;

    public ListView getListView() {
        return mListView;
    }

    /**
     * Return whether the item at position is selectable (i.e is a separator).
     * (external users can access this info using the adapter)
     */
    private boolean isItemAtPositionSelectable(int position) {
        return !mUnselectableItems.contains(position);
    }

    /**
     * Better way to pass in optional params than a honkin' paramater list :)
     */
    public static class Params {
        private int mNumItems = 4;
        private boolean mItemsFocusable = false;
        private int mStartingSelectionPosition = 0;
        private double mItemScreenSizeFactor = 1 / 5;
        private Double mFadingEdgeScreenSizeFactor = null;

        private Map<Integer, Double> mOverrideItemScreenSizeFactors = new HashMap<>();

        // separators
        private List<Integer> mUnselectableItems = new ArrayList<Integer>(8);
        // whether to include a text view above the list
        private boolean mIncludeHeader = false;
        private boolean mStackFromBottom = false;
        public boolean mMustFillScreen = true;
        private int mHeaderViewCount;
        private boolean mHeaderFocusable = false;
        private int mFooterViewCount;

        private boolean mConnectAdapter = true;

        /**
         * Set the number of items in the list.
         */
        public Params setNumItems(int numItems) {
            mNumItems = numItems;
            return this;
        }

        /**
         * Set whether the items are focusable.
         */
        public Params setItemsFocusable(boolean itemsFocusable) {
            mItemsFocusable = itemsFocusable;
            return this;
        }

        /**
         * Set the position that starts selected.
         *
         * @param startingSelectionPosition The selected position within the adapter's data set.
         * Pass -1 if you do not want to force a selection.
         * @return
         */
        public Params setStartingSelectionPosition(int startingSelectionPosition) {
            mStartingSelectionPosition = startingSelectionPosition;
            return this;
        }

        /**
         * Set the factor that determines how tall each item is in relation to the
         * screen height.
         */
        public Params setItemScreenSizeFactor(double itemScreenSizeFactor) {
            mItemScreenSizeFactor = itemScreenSizeFactor;
            return this;
        }

        /**
         * Override the item screen size factor for a particular item.  Useful for
         * creating lists with non-uniform item height.
         * @param position The position in the list.
         * @param itemScreenSizeFactor The screen size factor to use for the height.
         */
        public Params setPositionScreenSizeFactorOverride(
                int position, double itemScreenSizeFactor) {
            mOverrideItemScreenSizeFactors.put(position, itemScreenSizeFactor);
            return this;
        }

        /**
         * Set a position as unselectable (a.k.a a separator)
         * @param position
         * @return
         */
        public Params setPositionUnselectable(int position) {
            mUnselectableItems.add(position);
            return this;
        }

        /**
         * Set positions as unselectable (a.k.a a separator)
         */
        public Params setPositionsUnselectable(int ...positions) {
            for (int pos : positions) {
                setPositionUnselectable(pos);
            }
            return this;
        }

        /**
         * Include a header text view above the list.
         * @param includeHeader
         * @return
         */
        public Params includeHeaderAboveList(boolean includeHeader) {
            mIncludeHeader = includeHeader;
            return this;
        }

        /**
         * Sets the stacking direction
         * @param stackFromBottom
         * @return
         */
        public Params setStackFromBottom(boolean stackFromBottom) {
            mStackFromBottom = stackFromBottom;
            return this;
        }

        /**
         * Sets whether the sum of the height of the list items must be at least the
         * height of the list view.
         */
        public Params setMustFillScreen(boolean fillScreen) {
            mMustFillScreen = fillScreen;
            return this;
        }

        /**
         * Set the factor for the fading edge length.
         */
        public Params setFadingEdgeScreenSizeFactor(double fadingEdgeScreenSizeFactor) {
            mFadingEdgeScreenSizeFactor = fadingEdgeScreenSizeFactor;
            return this;
        }

        /**
         * Set the number of header views to appear within the list
         */
        public Params setHeaderViewCount(int headerViewCount) {
            mHeaderViewCount = headerViewCount;
            return this;
        }

        /**
         * Set whether the headers should be focusable.
         * @param headerFocusable Whether the headers should be focusable (i.e
         *   created as edit texts rather than text views).
         */
        public Params setHeaderFocusable(boolean headerFocusable) {
            mHeaderFocusable = headerFocusable;
            return this;
        }

        /**
         * Set the number of footer views to appear within the list
         */
        public Params setFooterViewCount(int footerViewCount) {
            mFooterViewCount = footerViewCount;
            return this;
        }

        /**
         * Sets whether the {@link ListScenario} will automatically set the
         * adapter on the list view. If this is false, the client MUST set it
         * manually (this is useful when adding headers to the list view, which
         * must be done before the adapter is set).
         */
        public Params setConnectAdapter(boolean connectAdapter) {
            mConnectAdapter = connectAdapter;
            return this;
        }
    }

    /**
     * How each scenario customizes its behavior.
     * @param params
     */
    protected abstract void init(Params params);

    /**
     * Override this if you want to know when something has been selected (perhaps
     * more importantly, that {@link android.widget.AdapterView.OnItemSelectedListener} has
     * been triggered).
     */
    protected void positionSelected(int positon) {
    }

    /**
     * Override this if you want to know that nothing is selected.
     */
    protected void nothingSelected() {
    }

    /**
     * Override this if you want to know when something has been clicked (perhaps
     * more importantly, that {@link android.widget.AdapterView.OnItemClickListener} has
     * been triggered).
     */
    protected void positionClicked(int position) {
        setClickedPosition(position);
    }

    @Override
    protected void onCreate(Bundle icicle) {
        super.onCreate(icicle);

        // for test stability, turn off title bar
        requestWindowFeature(Window.FEATURE_NO_TITLE);

        mScreenHeight = getWindowManager().getDefaultDisplay().getHeight();

        final Params params = createParams();
        init(params);

        readAndValidateParams(params);

        mListView = createListView();
        mListView.setLayoutParams(new ViewGroup.LayoutParams(
                ViewGroup.LayoutParams.MATCH_PARENT,
                ViewGroup.LayoutParams.MATCH_PARENT));
        mListView.setDrawSelectorOnTop(false);

        for (int i=0; i<mHeaderViewCount; i++) {
            TextView header = mHeadersFocusable ?
                    new EditText(this) :
                    new TextView(this);
            header.setText(""Header: "" + i);
            mListView.addHeaderView(header);
        }

        for (int i=0; i<mFooterViewCount; i++) {
            TextView header = new TextView(this);
            header.setText(""Footer: "" + i);
            mListView.addFooterView(header);
        }

        if (params.mConnectAdapter) {
            setAdapter(mListView);
        }

        mListView.setItemsCanFocus(mItemsFocusable);
        if (mStartingSelectionPosition >= 0) {
            mListView.setSelection(mStartingSelectionPosition);
        }
        mListView.setPadding(0, 0, 0, 0);
        mListView.setStackFromBottom(mStackFromBottom);
        mListView.setDivider(null);

        mListView.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {
            public void onItemSelected(AdapterView parent, View v, int position, long id) {
                positionSelected(position);
            }

            public void onNothingSelected(AdapterView parent) {
                nothingSelected();
            }
        });

        if (shouldRegisterItemClickListener()) {
            mListView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
                public void onItemClick(AdapterView parent, View v, int position, long id) {
                    positionClicked(position);
                }
            });
        }

        // set the fading edge length porportionally to the screen
        // height for test stability
        if (params.mFadingEdgeScreenSizeFactor != null) {
            mListView.setFadingEdgeLength((int) (params.mFadingEdgeScreenSizeFactor * mScreenHeight));
        } else {
            mListView.setFadingEdgeLength((int) ((64.0 / 480) * mScreenHeight));
        }

        if (mIncludeHeader) {
            mLinearLayout = new LinearLayout(this);

            mHeaderTextView = new TextView(this);
            mHeaderTextView.setText(""hi"");
            mHeaderTextView.setLayoutParams(new LinearLayout.LayoutParams(
                    ViewGroup.LayoutParams.MATCH_PARENT,
                    ViewGroup.LayoutParams.WRAP_CONTENT));
            mLinearLayout.addView(mHeaderTextView);

            mLinearLayout.setOrientation(LinearLayout.VERTICAL);
            mLinearLayout.setLayoutParams(new ViewGroup.LayoutParams(
                    ViewGroup.LayoutParams.MATCH_PARENT,
                    ViewGroup.LayoutParams.MATCH_PARENT));
            mListView.setLayoutParams((new LinearLayout.LayoutParams(
                    ViewGroup.LayoutParams.MATCH_PARENT,
                    0,
                    1f)));

            mLinearLayout.addView(mListView);
            setContentView(mLinearLayout);
        } else {
            mLinearLayout = new LinearLayout(this);
            mLinearLayout.setOrientation(LinearLayout.VERTICAL);
            mLinearLayout.setLayoutParams(new ViewGroup.LayoutParams(
                    ViewGroup.LayoutParams.MATCH_PARENT,
                    ViewGroup.LayoutParams.MATCH_PARENT));
            mListView.setLayoutParams((new LinearLayout.LayoutParams(
                    ViewGroup.LayoutParams.MATCH_PARENT,
                    0,
                    1f)));
            mLinearLayout.addView(mListView);
            setContentView(mLinearLayout);
        }
        mLinearLayout.restoreDefaultFocus();
    }

    /**
     * Override to return false if you don't want the activity to register a default item click
     * listener that redirects clicks to {@link #positionClicked(int)}.
     */
    protected boolean shouldRegisterItemClickListener() {
        return true;
    }

    /**
     * @return The newly created ListView widget.
     */
    protected ListView createListView() {
        return new ListView(this);
    }

    /**
     * @return The newly created Params object.
     */
    protected Params createParams() {
        return new Params();
    }

    /**
     * Sets an adapter on a ListView.
     *
     * @param listView The ListView to set the adapter on.
     */
    protected void setAdapter(ListView listView) {
        listView.setAdapter(new MyAdapter());
    }

    /**
     * Read in and validate all of the params passed in by the scenario.
     * @param params
     */
    protected void readAndValidateParams(Params params) {
        if (params.mMustFillScreen ) {
            double totalFactor = 0.0;
            for (int i = 0; i < params.mNumItems; i++) {
                if (params.mOverrideItemScreenSizeFactors.containsKey(i)) {
                    totalFactor += params.mOverrideItemScreenSizeFactors.get(i);
                } else {
                    totalFactor += params.mItemScreenSizeFactor;
                }
            }
            if (totalFactor < 1.0) {
                throw new IllegalArgumentException(""list items must combine to be at least "" +
                        ""the height of the screen.  this is not the case with "" + params.mNumItems
                        + "" items and "" + params.mItemScreenSizeFactor + "" screen factor and "" +
                        ""screen height of "" + mScreenHeight);
            }
        }

        mNumItems = params.mNumItems;
        mItemsFocusable = params.mItemsFocusable;
        mStartingSelectionPosition = params.mStartingSelectionPosition;
        mItemScreenSizeFactor = params.mItemScreenSizeFactor;

        mOverrideItemScreenSizeFactors.putAll(params.mOverrideItemScreenSizeFactors);

        mUnselectableItems.addAll(params.mUnselectableItems);
        mIncludeHeader = params.mIncludeHeader;
        mStackFromBottom = params.mStackFromBottom;
        mHeaderViewCount = params.mHeaderViewCount;
        mHeadersFocusable = params.mHeaderFocusable;
        mFooterViewCount = params.mFooterViewCount;
    }

    public final String getValueAtPosition(int position) {
        return isItemAtPositionSelectable(position)
                ?
                ""position "" + position:
                ""------- "" + position;
    }

    /**
     * @return The height that will be set for a particular position.
     */
    public int getHeightForPosition(int position) {
        int desiredHeight = (int) (mScreenHeight * mItemScreenSizeFactor);
        if (mOverrideItemScreenSizeFactors.containsKey(position)) {
            desiredHeight = (int) (mScreenHeight * mOverrideItemScreenSizeFactors.get(position));
        }
        return desiredHeight;
    }

    /**
     * @return The contents of the header above the list.
     * @throws IllegalArgumentException if there is no header.
     */
    public final String getHeaderValue() {
        if (!mIncludeHeader) {
            throw new IllegalArgumentException(""no header above list"");
        }
        return mHeaderTextView.getText().toString();
    }

    /**
     * @param value What to put in the header text view
     * @throws IllegalArgumentException if there is no header.
     */
    protected final void setHeaderValue(String value) {
        if (!mIncludeHeader) {
            throw new IllegalArgumentException(""no header above list"");
        }
        mHeaderTextView.setText(value);
    }

    /**
     * Create a view for a list item.  Override this to create a custom view beyond
     * the simple focusable / unfocusable text view.
     * @param position The position.
     * @param parent The parent
     * @param desiredHeight The height the view should be to respect the desired item
     *   to screen height ratio.
     * @return a view for the list.
     */
    protected View createView(int position, ViewGroup parent, int desiredHeight) {
        return ListItemFactory.text(position, parent.getContext(), getValueAtPosition(position),
                desiredHeight);
    }

    /**
     * Convert a non-null view.
     */
    public View convertView(int position, View convertView, ViewGroup parent) {
        return ListItemFactory.convertText(convertView, getValueAtPosition(position), position);
    }

    public void setClickedPosition(int clickedPosition) {
        mClickedPosition = clickedPosition;
    }

    public int getClickedPosition() {
        return mClickedPosition;
    }

    public void setLongClickedPosition(int longClickedPosition) {
        mLongClickedPosition = longClickedPosition;
    }

    public int getLongClickedPosition() {
        return mLongClickedPosition;
    }

    /**
     * Have a child of the list view call {@link View#requestRectangleOnScreen(android.graphics.Rect)}.
     * @param childIndex The index into the viewgroup children (i.e the children that are
     *   currently visible).
     * @param rect The rectangle, in the child's coordinates.
     */
    public void requestRectangleOnScreen(int childIndex, final Rect rect) {
        final View child = getListView().getChildAt(childIndex);

        child.post(new Runnable() {
            public void run() {
                child.requestRectangleOnScreen(rect);
            }
        });
    }

    /**
     * Return an item type for the specified position in the adapter. Override if your
     * adapter creates more than one type.
     */
    public int getItemViewType(int position) {
        return 0;
    }

    /**
     * Return an the number of types created by the adapter. Override if your
     * adapter creates more than one type.
     */
    public int getViewTypeCount() {
        return 1;
    }

    /**
     * @return The number of times convertView failed
     */
    public int getConvertMisses() {
        return mConvertMisses;
    }

    private class MyAdapter extends BaseAdapter {

        public int getCount() {
            return mNumItems;
        }

        public Object getItem(int position) {
            return getValueAtPosition(position);
        }

        public long getItemId(int position) {
            return position;
        }

        @Override
        public boolean areAllItemsEnabled() {
            return mUnselectableItems.isEmpty();
        }

        @Override
        public boolean isEnabled(int position) {
            return isItemAtPositionSelectable(position);
        }

        public View getView(int position, View convertView, ViewGroup parent) {
            View result = null;
            if (position >= mNumItems || position < 0) {
                throw new IllegalStateException(""position out of range for adapter!"");
            }

            if (convertView != null) {
                result = convertView(position, convertView, parent);
                if (result == null) {
                    mConvertMisses++;
                }
            }

            if (result == null) {
                int desiredHeight = getHeightForPosition(position);
                result = createView(position, parent, desiredHeight);
            }
            return result;
        }

        @Override
        public int getItemViewType(int position) {
            return ListScenario.this.getItemViewType(position);
        }

        @Override
        public int getViewTypeCount() {
            return ListScenario.this.getViewTypeCount();
        }

    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.bluetooth.cts.ScanFilterTest"	"testsetNameFilter"	"CtsBluetoothTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/bluetooth/src/android/bluetooth/cts/ScanFilterTest.java"	""	"public void testsetNameFilter() {
        if (mFilterBuilder == null) return;

        ScanFilter filter = mFilterBuilder.setDeviceName(LOCAL_NAME).build();
        assertEquals(LOCAL_NAME, filter.getDeviceName());
        assertTrue(""setName filter fails"", filter.matches(mScanResult));

        filter = mFilterBuilder.setDeviceName(""Pem"").build();
        assertFalse(""setName filter fails"", filter.matches(mScanResult));
    }

    @SmallTest"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.bluetooth.cts.ScanFilterTest"	"testDeviceAddressFilter"	"CtsBluetoothTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/bluetooth/src/android/bluetooth/cts/ScanFilterTest.java"	""	"public void testDeviceAddressFilter() {
        if (mFilterBuilder == null) return;

        ScanFilter filter = mFilterBuilder.setDeviceAddress(DEVICE_MAC).build();
        assertEquals(DEVICE_MAC, filter.getDeviceAddress());
        assertTrue(""device filter fails"", filter.matches(mScanResult));

        filter = mFilterBuilder.setDeviceAddress(""11:22:33:44:55:66"").build();
        assertFalse(""device filter fails"", filter.matches(mScanResult));
    }

    @SmallTest"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.bluetooth.cts.ScanFilterTest"	"testsetServiceUuidFilter"	"CtsBluetoothTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/bluetooth/src/android/bluetooth/cts/ScanFilterTest.java"	""	"public void testsetServiceUuidFilter() {
        if (mFilterBuilder == null) return;

        ScanFilter filter = mFilterBuilder.setServiceUuid(
                ParcelUuid.fromString(UUID1)).build();
        assertEquals(UUID1, filter.getServiceUuid().toString());
        assertTrue(""uuid filter fails"", filter.matches(mScanResult));

        filter = mFilterBuilder.setServiceUuid(
                ParcelUuid.fromString(UUID3)).build();
        assertEquals(UUID3, filter.getServiceUuid().toString());
        assertFalse(""uuid filter fails"", filter.matches(mScanResult));

        ParcelUuid mask = ParcelUuid.fromString(""FFFFFFF0-FFFF-FFFF-FFFF-FFFFFFFFFFFF"");
        filter = mFilterBuilder
                .setServiceUuid(ParcelUuid.fromString(UUID3),
                        mask)
                .build();
        assertEquals(mask.toString(), filter.getServiceUuidMask().toString());
        assertTrue(""uuid filter fails"", filter.matches(mScanResult));
    }

    @SmallTest"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.bluetooth.cts.ScanFilterTest"	"testsetServiceSolicitationUuidFilter"	"CtsBluetoothTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/bluetooth/src/android/bluetooth/cts/ScanFilterTest.java"	""	"public void testsetServiceSolicitationUuidFilter() {
        if (mFilterBuilder == null) return;

        ScanFilter filter = mFilterBuilder.setServiceSolicitationUuid(
                ParcelUuid.fromString(UUID1)).build();
        assertEquals(UUID1, filter.getServiceSolicitationUuid().toString());
        assertTrue(""uuid filter fails"", filter.matches(mScanResult));

        filter = mFilterBuilder.setServiceSolicitationUuid(
                ParcelUuid.fromString(UUID2)).build();
        assertEquals(UUID2, filter.getServiceSolicitationUuid().toString());
        assertFalse(""uuid filter fails"", filter.matches(mScanResult));

        ParcelUuid mask = ParcelUuid.fromString(""FFFFFFF0-FFFF-FFFF-FFFF-FFFFFFFFFFFF"");
        filter = mFilterBuilder
                .setServiceSolicitationUuid(ParcelUuid.fromString(UUID3), mask)
                .build();
        assertEquals(mask.toString(), filter.getServiceSolicitationUuidMask().toString());
        assertTrue(""uuid filter fails"", filter.matches(mScanResult));
    }

    @SmallTest"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.bluetooth.cts.ScanFilterTest"	"testsetServiceDataFilter"	"CtsBluetoothTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/bluetooth/src/android/bluetooth/cts/ScanFilterTest.java"	""	"public void testsetServiceDataFilter() {
        if (mFilterBuilder == null) return;

        byte[] setServiceData = new byte[] {
                0x50, 0x64 };
        ParcelUuid serviceDataUuid = ParcelUuid.fromString(UUID2);
        ScanFilter filter = mFilterBuilder.setServiceData(serviceDataUuid, setServiceData).build();
        assertEquals(serviceDataUuid, filter.getServiceDataUuid());
        assertTrue(""service data filter fails"", filter.matches(mScanResult));

        byte[] emptyData = new byte[0];
        filter = mFilterBuilder.setServiceData(serviceDataUuid, emptyData).build();
        assertTrue(""service data filter fails"", filter.matches(mScanResult));

        byte[] prefixData = new byte[] {
                0x50 };
        filter = mFilterBuilder.setServiceData(serviceDataUuid, prefixData).build();
        assertTrue(""service data filter fails"", filter.matches(mScanResult));

        byte[] nonMatchData = new byte[] {
                0x51, 0x64 };
        byte[] mask = new byte[] {
                (byte) 0x00, (byte) 0xFF };
        filter = mFilterBuilder.setServiceData(serviceDataUuid, nonMatchData, mask).build();
        assertEquals(nonMatchData, filter.getServiceData());
        assertEquals(mask, filter.getServiceDataMask());
        assertTrue(""partial service data filter fails"", filter.matches(mScanResult));

        filter = mFilterBuilder.setServiceData(serviceDataUuid, nonMatchData).build();
        assertFalse(""service data filter fails"", filter.matches(mScanResult));
    }

    @SmallTest"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.bluetooth.cts.ScanFilterTest"	"testManufacturerSpecificData"	"CtsBluetoothTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/bluetooth/src/android/bluetooth/cts/ScanFilterTest.java"	""	"public void testManufacturerSpecificData() {
        if (mFilterBuilder == null) return;

        byte[] manufacturerData = new byte[] {
                0x02, 0x15 };
        int manufacturerId = 0xE0;
        ScanFilter filter =
                mFilterBuilder.setManufacturerData(manufacturerId, manufacturerData).build();
        assertEquals(manufacturerId, filter.getManufacturerId());
        assertEquals(manufacturerData, filter.getManufacturerData());
        assertTrue(""manufacturer data filter fails"", filter.matches(mScanResult));

        byte[] emptyData = new byte[0];
        filter = mFilterBuilder.setManufacturerData(manufacturerId, emptyData).build();
        assertTrue(""manufacturer data filter fails"", filter.matches(mScanResult));

        byte[] prefixData = new byte[] {
                0x02 };
        filter = mFilterBuilder.setManufacturerData(manufacturerId, prefixData).build();
        assertTrue(""manufacturer data filter fails"", filter.matches(mScanResult));

        // Test data mask
        byte[] nonMatchData = new byte[] {
                0x02, 0x14 };
        filter = mFilterBuilder.setManufacturerData(manufacturerId, nonMatchData).build();
        assertFalse(""manufacturer data filter fails"", filter.matches(mScanResult));
        byte[] mask = new byte[] {
                (byte) 0xFF, (byte) 0x00
        };
        filter = mFilterBuilder.setManufacturerData(manufacturerId, nonMatchData, mask).build();
        assertEquals(manufacturerId, filter.getManufacturerId());
        assertEquals(nonMatchData, filter.getManufacturerData());
        assertEquals(mask, filter.getManufacturerDataMask());
        assertTrue(""partial setManufacturerData filter fails"", filter.matches(mScanResult));
    }

    @SmallTest"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.bluetooth.cts.ScanFilterTest"	"testReadWriteParcel"	"CtsBluetoothTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/bluetooth/src/android/bluetooth/cts/ScanFilterTest.java"	""	"public void testReadWriteParcel() {
        if (mFilterBuilder == null) return;

        ScanFilter filter = mFilterBuilder.build();
        testReadWriteParcelForFilter(filter);

        filter = mFilterBuilder.setDeviceName(LOCAL_NAME).build();
        testReadWriteParcelForFilter(filter);

        filter = mFilterBuilder.setDeviceAddress(""11:22:33:44:55:66"").build();
        testReadWriteParcelForFilter(filter);

        filter = mFilterBuilder.setServiceUuid(
                ParcelUuid.fromString(UUID3)).build();
        testReadWriteParcelForFilter(filter);

        filter = mFilterBuilder.setServiceUuid(
                ParcelUuid.fromString(UUID3),
                ParcelUuid.fromString(""FFFFFFF0-FFFF-FFFF-FFFF-FFFFFFFFFFFF"")).build();
        testReadWriteParcelForFilter(filter);

        byte[] serviceData = new byte[] {
                0x50, 0x64 };

        ParcelUuid serviceDataUuid = ParcelUuid.fromString(UUID2);
        filter = mFilterBuilder.setServiceData(serviceDataUuid, serviceData).build();
        testReadWriteParcelForFilter(filter);

        filter = mFilterBuilder.setServiceData(serviceDataUuid, new byte[0]).build();
        testReadWriteParcelForFilter(filter);

        byte[] serviceDataMask = new byte[] {
                (byte) 0xFF, (byte) 0xFF };
        filter = mFilterBuilder.setServiceData(serviceDataUuid, serviceData, serviceDataMask)
                .build();
        testReadWriteParcelForFilter(filter);

        byte[] manufacturerData = new byte[] {
                0x02, 0x15 };
        int manufacturerId = 0xE0;
        filter = mFilterBuilder.setManufacturerData(manufacturerId, manufacturerData).build();
        testReadWriteParcelForFilter(filter);

        filter = mFilterBuilder.setServiceData(serviceDataUuid, new byte[0]).build();
        testReadWriteParcelForFilter(filter);

        byte[] manufacturerDataMask = new byte[] {
                (byte) 0xFF, (byte) 0xFF
        };
        filter = mFilterBuilder.setManufacturerData(manufacturerId, manufacturerData,
                manufacturerDataMask).build();
        testReadWriteParcelForFilter(filter);
    }

    @SmallTest"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.bluetooth.cts.ScanFilterTest"	"testDescribeContents"	"CtsBluetoothTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/bluetooth/src/android/bluetooth/cts/ScanFilterTest.java"	""	"public void testDescribeContents() {
        final int expected = 0;
        assertEquals(expected, new ScanFilter.Builder().build().describeContents());
    }

    private void testReadWriteParcelForFilter(ScanFilter filter) {
        Parcel parcel = Parcel.obtain();
        filter.writeToParcel(parcel, 0);
        parcel.setDataPosition(0);
        ScanFilter filterFromParcel =
                ScanFilter.CREATOR.createFromParcel(parcel);
        assertEquals(filter, filterFromParcel);
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.view.cts.input.InputDeviceMultiDeviceKeyEventTest"	"assertNoKeyEvent"	"CtsViewTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/view/src/android/view/cts/input/InputDeviceMultiDeviceKeyEventTest.java"	""	"/*
 *.
 */

package android.view.cts;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;

import android.app.Instrumentation;
import android.hardware.input.InputManager;
import android.view.InputDevice;
import android.view.KeyEvent;

import androidx.annotation.NonNull;
import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.filters.MediumTest;
import androidx.test.platform.app.InstrumentationRegistry;
import androidx.test.rule.ActivityTestRule;

import com.android.compatibility.common.util.PollingCheck;
import com.android.cts.input.UinputDevice;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;
import org.junit.After;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.Arrays;

/**
 * CTS test cases for multi device key events verification.
 * This test utilize uinput command line tool to create multiple test devices, and configure the
 * virtual device to have keys need to be tested. The JSON format input for device configuration
 * and EV_KEY injection will be created directly from this test for uinput command.
 * The test cases will inject evdev events from different virtual input devices and verify the
 * received key events to verify the device Id, repeat count to be expected, as well as the key
 * repeat behavior is consistently meeting expectations with multi devices.
 */
@MediumTest
@RunWith(AndroidJUnit4.class)
public class InputDeviceMultiDeviceKeyEventTest {
    private static final String TAG = ""InputDeviceMultiDeviceKeyEventTest"";
    private static final String LABEL_PREFIX = ""KEYCODE_"";
    private static final int DEVICE_ID = 1;
    private static final int EV_SYN = 0;
    private static final int EV_KEY = 1;
    private static final int EV_KEY_DOWN = 1;
    private static final int EV_KEY_UP = 0;
    private static final int UI_SET_EVBIT = 100;
    private static final int UI_SET_KEYBIT = 101;
    private static final int EV_KEY_CODE_1 = 2;
    private static final int EV_KEY_CODE_2 = 3;
    private static final int GOOGLE_VENDOR_ID = 0x18d1;
    private static final int GOOGLE_VIRTUAL_KEYBOARD_ID = 0x001f;
    private static final int NUM_DEVICES = 2;
    private static final int POLL_EVENT_TIMEOUT_SECONDS = 1;
    private static final int RETRY_COUNT = 10;

    private Instrumentation mInstrumentation;
    private InputManager mInputManager;
    private UinputDevice[] mUinputDevices = new UinputDevice[NUM_DEVICES];
    private int[] mInputManagerDeviceIds = new int[NUM_DEVICES];
    private final int[] mEvKeys = {
            EV_KEY_CODE_1,
            EV_KEY_CODE_2
    };

    @Rule
    public ActivityTestRule<InputDeviceKeyLayoutMapTestActivity> mActivityRule =
            new ActivityTestRule<>(InputDeviceKeyLayoutMapTestActivity.class);

    @Before
    public void setup() {
        mInstrumentation = InstrumentationRegistry.getInstrumentation();
        PollingCheck.waitFor(mActivityRule.getActivity()::hasWindowFocus);
        for (int i = 0; i < NUM_DEVICES; i++) {
            final int jsonDeviceId = i + 1;
            mUinputDevices[i] = new UinputDevice(mInstrumentation, jsonDeviceId,
                GOOGLE_VENDOR_ID, GOOGLE_VIRTUAL_KEYBOARD_ID + jsonDeviceId,
                InputDevice.SOURCE_KEYBOARD,
                createDeviceRegisterCommand(jsonDeviceId, mEvKeys));
        }

        mInputManager = mInstrumentation.getContext().getSystemService(InputManager.class);
        final int[] inputDeviceIds = mInputManager.getInputDeviceIds();
        for (int inputDeviceId : inputDeviceIds) {
            final InputDevice inputDevice = mInputManager.getInputDevice(inputDeviceId);
            final int index = inputDevice.getProductId() - GOOGLE_VIRTUAL_KEYBOARD_ID - 1;
            if (inputDevice.getVendorId() == GOOGLE_VENDOR_ID
                    && index >= 0 && index < NUM_DEVICES) {
                mInputManagerDeviceIds[index] = inputDeviceId;
            }
        }
    }

    @After
    public void tearDown() {
        for (int i = 0; i < NUM_DEVICES; i++) {
            if (mUinputDevices[i] != null) {
                mUinputDevices[i].close();
            }
        }
    }

    /**
     * Create the uinput device registration command, in JSON format of uinput commandline tool.
     * Refer to {@link framework/base/cmds/uinput/README.md}
     */
    private String createDeviceRegisterCommand(int deviceId, int[] keys) {
        JSONObject json = new JSONObject();
        JSONArray arrayConfigs =  new JSONArray();
        try {
            json.put(""id"", deviceId);
            json.put(""type"", ""uinput"");
            json.put(""command"", ""register"");
            json.put(""name"", ""Virtual All Buttons Device (Test)"");
            json.put(""vid"", GOOGLE_VENDOR_ID);
            json.put(""pid"", GOOGLE_VIRTUAL_KEYBOARD_ID + deviceId);
            json.put(""bus"", ""bluetooth"");

            JSONObject jsonSetEvBit = new JSONObject();
            JSONArray arraySetEvBit =  new JSONArray();
            arraySetEvBit.put(EV_KEY);
            jsonSetEvBit.put(""type"", UI_SET_EVBIT);
            jsonSetEvBit.put(""data"", arraySetEvBit);
            arrayConfigs.put(jsonSetEvBit);

            // Configure device have all keys from key layout map.
            JSONArray arraySetKeyBit = new JSONArray();
            for (int i = 0; i < keys.length; i++) {
                arraySetKeyBit.put(keys[i]);
            }

            JSONObject jsonSetKeyBit = new JSONObject();
            jsonSetKeyBit.put(""type"", UI_SET_KEYBIT);
            jsonSetKeyBit.put(""data"", arraySetKeyBit);
            arrayConfigs.put(jsonSetKeyBit);
            json.put(""configuration"", arrayConfigs);
        } catch (JSONException e) {
            throw new RuntimeException(
                    ""Could not create JSON object"");
        }

        return json.toString();
    }

    /**
     * Get a KeyEvent from event queue or timeout.
     * The test activity instance may change in the middle, calling getKeyEvent with the old
     * activity instance will get timed out when test activity instance changed. Rather than
     * doing a long wait for timeout with same activity instance, break the polling into a number
     * of retries and each time of retry call the ActivityTestRule.getActivity for current activity
     * instance to avoid the test failure because of polling the old activity instance get timed
     * out consequently failed the test.
     *
     * @param retryCount The times to retry get KeyEvent from test activity.
     *
     * @return KeyEvent delivered to test activity, null if timeout.
     */
    private KeyEvent getKeyEvent(int retryCount) {
        for (int i = 0; i < retryCount; i++) {
            KeyEvent event = mActivityRule.getActivity().getKeyEvent(POLL_EVENT_TIMEOUT_SECONDS);
            if (event != null) {
                return event;
            }
        }
        return null;
    }

    private void assertNoKeyEvent() {
        assertNull(getKeyEvent(1 /* retryCount */));
    }

    /**
     * Asserts that the application received a {@link android.view.KeyEvent} with the given
     * metadata.
     *
     * If other KeyEvents are received by the application prior to the expected KeyEvent, or no
     * KeyEvents are received within a reasonable amount of time, then this will throw an
     * {@link AssertionError}.
     *
     * Only action, source, keyCode and metaState are being compared.
     */
    private void assertReceivedKeyEvent(@NonNull KeyEvent expectedKeyEvent) {
        assertNotEquals(expectedKeyEvent.getKeyCode(), KeyEvent.KEYCODE_UNKNOWN);

        KeyEvent receivedKeyEvent = getKeyEvent(RETRY_COUNT);
        String log = ""Expected "" + expectedKeyEvent + "" Received "" + receivedKeyEvent;
        assertNotNull(log, receivedKeyEvent);
        assertEquals(""DeviceId: "" + log, expectedKeyEvent.getDeviceId(),
                receivedKeyEvent.getDeviceId());
        assertEquals(""Action: "" + log, expectedKeyEvent.getAction(),
                receivedKeyEvent.getAction());
        assertEquals(""Source: "" + log, expectedKeyEvent.getSource(),
                receivedKeyEvent.getSource());
        assertEquals(""KeyCode: "" + log, expectedKeyEvent.getKeyCode(),
                receivedKeyEvent.getKeyCode());
        assertEquals(""RepeatCount: "" + log, expectedKeyEvent.getRepeatCount(),
                receivedKeyEvent.getRepeatCount());
    }

    /**
     * Generate a key event from the key label and action.
     * @param action KeyEvent.ACTION_DOWN or KeyEvent.ACTION_UP
     * @param label Key label from key layout mapping definition
     * @return KeyEvent expected to receive
     */
    private KeyEvent generateKeyEvent(int deviceId, int action, String label, int repeat) {
        int source = InputDevice.SOURCE_KEYBOARD;
        int keyCode = KeyEvent.keyCodeFromString(LABEL_PREFIX + label);
        // We will only check select fields of the KeyEvent. Times are not checked.
        KeyEvent event = new KeyEvent(/* downTime */ 0, /* eventTime */ 0, action, keyCode,
                repeat, /* metaState */ 0, mInputManagerDeviceIds[deviceId], /* scanCode */ 0,
                /* flags */ 0, source);

        return event;
    }

    /**
     * Simulate pressing a key.
     * @param evKeyCode The key scan code
     */
    private void pressKeyDown(int deviceId, int evKeyCode) {
        int[] evCodesDown = new int[] {
                EV_KEY, evKeyCode, EV_KEY_DOWN,
                EV_SYN, 0, 0};
        mUinputDevices[deviceId].injectEvents(Arrays.toString(evCodesDown));
    }

    /**
     * Simulate releasing a key.
     * @param evKeyCode The key scan code
     */
    private void pressKeyUp(int deviceId, int evKeyCode) {
        int[] evCodesUp = new int[] {
                EV_KEY, evKeyCode, EV_KEY_UP,
                EV_SYN, 0, 0 };
        mUinputDevices[deviceId].injectEvents(Arrays.toString(evCodesUp));
    }

    private void assertKeyRepeat(int deviceId, String label, int repeat, int count) {
        for (int i = 0; i < count; i++) {
            KeyEvent expectedDownEvent = generateKeyEvent(deviceId,
                    KeyEvent.ACTION_DOWN, label, repeat + i);
            assertReceivedKeyEvent(expectedDownEvent);
        }
    }

    private void assertKeyUp(int deviceId, String label) {
        KeyEvent expectedUpEvent = generateKeyEvent(deviceId,
                KeyEvent.ACTION_UP, label, /* repeat */ 0);
        assertReceivedKeyEvent(expectedUpEvent);
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.appsecurity.cts.ListeningPortsTest"	"installDeviceTestPkg"	"CtsAppSecurityHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/ListeningPortsTest.java"	""	"public void test/*
 *.
 */

package android.appsecurity.cts;

import com.android.compatibility.common.tradefed.build.CompatibilityBuildHelper;
import com.android.tradefed.build.IBuildInfo;
import com.android.tradefed.device.DeviceNotAvailableException;
import com.android.tradefed.testtype.DeviceTestCase;
import com.android.tradefed.testtype.IBuildReceiver;

import java.io.File;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;

/**
 * Runs the n portion of the listening ports test. With /proc/net access removed for third
 * party apps the device side test could no longer directly parse the file for listening ports. This
 * class pulls the /proc/net files from the device and passes their contents as a parameter to the
 * device side test that will then check for any listening ports and perform any necessary
 * localhost connection tests.
 */
public class ListeningPortsTest extends DeviceTestCase implements IBuildReceiver {

    private static final String DEVICE_TEST_APK = ""CtsListeningPortsTest.apk"";
    private static final String DEVICE_TEST_PKG = ""android.appsecurity.cts.listeningports"";
    private static final String DEVICE_TEST_CLASS = DEVICE_TEST_PKG + "".ListeningPortsTest"";
    private static final String DEVICE_TEST_METHOD = ""testNoAccessibleListeningPorts"";

    private static final String PROC_FILE_CONTENTS_PARAM = ""procFileContents"";
    private static final String IS_TCP_PARAM = ""isTcp"";
    private static final String LOOPBACK_PARAM = ""loopback"";

    private IBuildInfo mCtsBuild;

    @Override
    public void setBuild(IBuildInfo buildInfo) {
        mCtsBuild = buildInfo;
    }

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        Utils.prepareSingleUser(getDevice());
        assertNotNull(mCtsBuild);
        installDeviceTestPkg();
    }

    @Override
    protected void tearDown() throws Exception {
        try {
            uninstallDeviceTestPackage();
        } catch (DeviceNotAvailableException ignored) {
        } finally {
            super.tearDown();
        }
    }

    private void installDeviceTestPkg() throws Exception {
        CompatibilityBuildHelper buildHelper = new CompatibilityBuildHelper(mCtsBuild);
        File apk = buildHelper.getTestFile(DEVICE_TEST_APK);
        String result = getDevice().installPackage(apk, true);
        assertNull(""failed to install "" + DEVICE_TEST_APK + "", Reason: "" + result, result);
    }

    private String uninstallDeviceTestPackage() throws DeviceNotAvailableException {
        return getDevice().uninstallPackage(DEVICE_TEST_PKG);
    }

    /**
     * Remotely accessible ports are often used by attackers to gain
     * unauthorized access to computers systems without user knowledge or
     * awareness.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.appsecurity.cts.ListeningPortsTest"	"testNoListeningLoopbackUdp6Ports"	"CtsAppSecurityHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/ListeningPortsTest.java"	""	"public void testNoListeningLoopbackUdp6Ports() throws Exception {
        assertNoAccessibleListeningPorts(""/proc/net/udp6"", false, true);
    }

    private static final int RETRIES_MAX = 6;

    /**
     * UDP tests can be flaky due to DNS lookups.  Compensate.
     */
    private void assertNoRemotelyAccessibleListeningUdpPorts(String procFilePath, boolean loopback)
            throws Exception {
        for (int i = 0; i < RETRIES_MAX; i++) {
            try {
                assertNoAccessibleListeningPorts(procFilePath, false, loopback);
                return;
            } catch (AssertionError e) {
                // If an AssertionError is caught then a listening UDP port was detected on the
                // device; since this could be due to a DNS lookup sleep and retry the test. If
                // the test continues to fail then report the error.
                if (i == RETRIES_MAX - 1) {
                    throw e;
                }
                Thread.sleep(2 * 1000 * i);
            }
        }
        throw new IllegalStateException(""unreachable"");
    }


    /**
     * Passes the contents of the /proc/net file and the boolean arguments to the device side test
     * which performs the necessary checks to determine if the port is listening and if it is
     * accessible from the localhost.
     */
    private void assertNoAccessibleListeningPorts(String procFilePath, boolean isTcp,
            boolean loopback) throws Exception {
        Map<String, String> args = new HashMap<>();
        String procFileContents = parse(procFilePath);
        args.put(PROC_FILE_CONTENTS_PARAM, procFileContents);
        args.put(IS_TCP_PARAM, String.valueOf(isTcp));
        args.put(LOOPBACK_PARAM, String.valueOf(loopback));
        Utils.runDeviceTests(getDevice(), DEVICE_TEST_PKG, DEVICE_TEST_CLASS, DEVICE_TEST_METHOD,
                args);
    }

    /**
     * Since the device side test cannot directly access the /proc/net files this method pulls the
     * file from the device and returns a String with its contents which can then be passed as an
     * argument to the device side test.
     */
    private String parse(String procFilePath) throws IOException, DeviceNotAvailableException {
        File procFile = File.createTempFile(""ListeningPortsTest"", ""tmp"");
        boolean result = getDevice().pullFile(procFilePath, procFile);
        assertTrue(""failed to pull "" + procFilePath, result);
        procFile.deleteOnExit();

        Scanner scanner = null;
        StringBuilder contents = new StringBuilder();
        // When passing the file contents as an argument to the device side method a 'No
        // instrumentation found' error was reported due to spaces in the String. To prevent this
        // the entire contents of the file need to be quoted before passing it as an argument.
        contents.append(""'"");
        try {
            scanner = new Scanner(procFile);
            while (scanner.hasNextLine()) {
                contents.append(scanner.nextLine() + ""\n"");
            }
        } finally {
            if (scanner != null) {
                scanner.close();
            }
        }
        contents.append(""'"");
        return contents.toString();
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.jobscheduler.cts.TriggerContentTest"	"exists"	"CtsJobSchedulerTestCases"	"/home/gpoor/cts-12-source/cts/tests/JobScheduler/src/android/jobscheduler/cts/TriggerContentTest.java"	""	"public void test/*
 *.
 */

package android.jobscheduler.cts;

import android.annotation.TargetApi;
import android.app.job.JobInfo;
import android.app.job.JobParameters;
import android.content.ContentResolver;
import android.content.Context;
import android.jobscheduler.DummyJobContentProvider;
import android.jobscheduler.TriggerContentJobService;
import android.media.MediaScannerConnection;
import android.net.Uri;
import android.os.Environment;
import android.os.Process;
import android.provider.MediaStore;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

/**
 * Schedules jobs that look for content URI changes and ensures they are triggered correctly.
 */
@TargetApi(23)
public class TriggerContentTest extends BaseJobSchedulerTest {
    public static final int TRIGGER_CONTENT_JOB_ID = TriggerContentTest.class.hashCode();

    // The root URI of the media provider, to monitor for generic changes to its content.
    static final Uri MEDIA_URI = Uri.parse(""content://"" + MediaStore.AUTHORITY + ""/"");

    // Media URI for all external media content.
    static final Uri MEDIA_EXTERNAL_URI = Uri.parse(""content://"" + MediaStore.AUTHORITY
            + ""/external"");

    // Path segments for image-specific URIs in the provider.
    static final List<String> EXTERNAL_PATH_SEGMENTS
            = MediaStore.Images.Media.EXTERNAL_CONTENT_URI.getPathSegments();

    // This is the external storage directory where cameras place pictures.
    static final String DCIM_DIR = Environment.getExternalStoragePublicDirectory(
            Environment.DIRECTORY_DCIM).getPath();

    static final String PIC_1_NAME = ""TriggerContentTest1_"" + Process.myPid();
    static final String PIC_2_NAME = ""TriggerContentTest2_"" + Process.myPid();

    File[] mActiveFiles = new File[5];
    Uri[] mActiveUris = new Uri[5];

    static class MediaScanner implements MediaScannerConnection.OnScanCompletedListener {
        private static final long DEFAULT_TIMEOUT_MILLIS = 1000L; // 1 second.

        private CountDownLatch mLatch;
        private String mScannedPath;
        private Uri mScannedUri;

        public boolean scan(Context context, String file, String mimeType)
                throws InterruptedException {
            mLatch = new CountDownLatch(1);
            MediaScannerConnection.scanFile(context,
                    new String[] { file.toString() }, new String[] { mimeType }, this);
            return mLatch.await(DEFAULT_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);
        }

        public String getScannedPath() {
            synchronized (this) {
                return mScannedPath;
            }
        }

        public Uri getScannedUri() {
            synchronized (this) {
                return mScannedUri;
            }
        }

        @Override public void onScanCompleted(String path, Uri uri) {
            synchronized (this) {
                mScannedPath = path;
                mScannedUri = uri;
                mLatch.countDown();
            }
        }
    }

    private void cleanupActive(int which) {
        if (mActiveUris[which] != null) {
            getContext().getContentResolver().delete(mActiveUris[which], null, null);
            mActiveUris[which] = null;
        }
        if (mActiveFiles[which] != null) {
            mActiveFiles[which].delete();
            mActiveFiles[which] = null;
        }
    }

    @Override
    public void tearDown() throws Exception {
        for (int i=0; i<mActiveFiles.length; i++) {
            cleanupActive(i);
        }
        super.tearDown();
    }

    private JobInfo makeJobInfo(Uri uri, int flags) {
        JobInfo.Builder builder = new JobInfo.Builder(TRIGGER_CONTENT_JOB_ID,
                kTriggerContentServiceComponent);
        builder.addTriggerContentUri(new JobInfo.TriggerContentUri(uri, flags));
        // For testing purposes, react quickly.
        builder.setTriggerContentUpdateDelay(500);
        builder.setTriggerContentMaxDelay(500);
        return builder.build();
    }

    private JobInfo makePhotosJobInfo() {
        JobInfo.Builder builder = new JobInfo.Builder(TRIGGER_CONTENT_JOB_ID,
                kTriggerContentServiceComponent);
        // Look for general reports of changes in the overall provider.
        builder.addTriggerContentUri(new JobInfo.TriggerContentUri(
                MEDIA_URI,
                JobInfo.TriggerContentUri.FLAG_NOTIFY_FOR_DESCENDANTS));
        // For testing purposes, react quickly.
        builder.setTriggerContentUpdateDelay(500);
        builder.setTriggerContentMaxDelay(500);
        return builder.build();
    }

    public static void copyToFileOrThrow(InputStream inputStream, File destFile)
            throws IOException {
        if (destFile.exists()) {
            destFile.delete();
        }
        destFile.getParentFile().mkdirs();
        FileOutputStream out = new FileOutputStream(destFile);
        try {
            byte[] buffer = new byte[4096];
            int bytesRead;
            while ((bytesRead = inputStream.read(buffer)) >= 0) {
                out.write(buffer, 0, bytesRead);
            }
        } finally {
            out.flush();
            try {
                out.getFD().sync();
            } catch (IOException e) {
            }
            out.close();
            inputStream.close();
        }
    }

    public Uri createAndAddImage(File destFile, InputStream image) throws IOException,
            InterruptedException {
        copyToFileOrThrow(image, destFile);
        MediaScanner scanner = new MediaScanner();
        boolean success = scanner.scan(getContext(), destFile.toString(), ""image/jpeg"");
        if (success) {
            return scanner.getScannedUri();
        }
        return null;
    }

    public Uri makeActiveFile(int which, File file, InputStream source) throws IOException,
                InterruptedException {
        mActiveFiles[which] = file;
        mActiveUris[which] = createAndAddImage(file, source);
        return mActiveUris[which];
    }

    private static void assertUriArrayLength(int length, Uri[] uris) {
        if (uris.length != length) {
            StringBuilder sb = new StringBuilder();
            sb.append(""Expected "");
            sb.append(length);
            sb.append("" URI, got "");
            sb.append(uris.length);
            if (uris.length > 0) {
                sb.append("": "");
                for (int i=0; i<uris.length; i++) {
                    if (i > 0) {
                        sb.append("", "");
                    }
                    sb.append(uris[i]);
                }
            }
            fail(sb.toString());
        }
    }

    private static void assertHasUri(Uri wanted, Uri[] uris) {
        for (int i=0; i<uris.length; i++) {
            if (wanted.equals(uris[i])) {
                return;
            }
        }

        StringBuilder sb = new StringBuilder();
        sb.append(""Don't have uri "");
        sb.append(wanted);
        sb.append("" in: "");
        for (int i=0; i<uris.length; i++) {
            if (i > 0) {
                sb.append("", "");
            }
            sb.append(uris[i]);
        }
        fail(sb.toString());
    }

    private static void assertUriDecendant(Uri expected, Uri actual) {
        assertEquals(expected.getScheme(), expected.getScheme());
        assertEquals(expected.getAuthority(), expected.getAuthority());

        final List<String> expectedPath = expected.getPathSegments();
        final List<String> actualPath = actual.getPathSegments();
        for (int i = 0; i < expectedPath.size(); i++) {
            assertEquals(expectedPath.get(i), actualPath.get(i));
        }
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.graphics.cts.ImageDecoderTest"	"testConserveMemory"	"CtsGraphicsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/graphics/src/android/graphics/cts/ImageDecoderTest.java"	""	"public void testConserveMemory() {
        class Listener implements ImageDecoder.OnHeaderDecodedListener {
            boolean doPostProcess;
            boolean preferRamOverQuality;
            @Override
            public void onHeaderDecoded(ImageDecoder decoder, ImageDecoder.ImageInfo info,
                                        ImageDecoder.Source src) {
                if (preferRamOverQuality) {
                    decoder.setMemorySizePolicy(ImageDecoder.MEMORY_POLICY_LOW_RAM);
                }
                if (doPostProcess) {
                    decoder.setPostProcessor((c) -> {
                        c.drawColor(Color.BLACK);
                        return PixelFormat.TRANSLUCENT;
                    });
                }
                decoder.setAllocator(ImageDecoder.ALLOCATOR_SOFTWARE);
            }
        };
        Listener l = new Listener();
        // All of these images are opaque, so they can save RAM with
        // setConserveMemory.
        int resIds[] = new int[] { R.drawable.png_test, R.drawable.baseline_jpeg,
                                   // If this were stored in drawable/, it would
                                   // be converted from 16-bit to 8. FIXME: Is
                                   // behavior still desirable now that we have
                                   // F16? b/119760146
                                   R.raw.f16 };
        // An opaque image can be converted to 565, but postProcess will promote
        // to 8888 in case alpha is added. The third image defaults to F16, so
        // even with postProcess it will only be promoted to 8888.
        boolean postProcessCancels[] = new boolean[] { true, true, false };
        boolean trueFalse[] = new boolean[] { true, false };
        SourceCreator f = mCreators[0];
        for (int i = 0; i < resIds.length; ++i) {
            int resId = resIds[i];
            l.doPostProcess = false;
            l.preferRamOverQuality = false;
            Bitmap normal = null;
            try {
                normal = ImageDecoder.decodeBitmap(f.apply(resId), l);
            } catch (IOException e) {
                fail(""Failed with exception "" + e);
            }
            int normalByteCount = normal.getAllocationByteCount();
            for (boolean doPostProcess : trueFalse) {
                l.doPostProcess = doPostProcess;
                l.preferRamOverQuality = true;
                Bitmap saveRamOverQuality = null;
                try {
                    saveRamOverQuality = ImageDecoder.decodeBitmap(f.apply(resId), l);
                } catch (IOException e) {
                    fail(""Failed with exception "" + e);
                }
                int saveByteCount = saveRamOverQuality.getAllocationByteCount();
                if (doPostProcess && postProcessCancels[i]) {
                    // Promoted to normal.
                    assertEquals(normalByteCount, saveByteCount);
                } else {
                    assertTrue(saveByteCount < normalByteCount);
                }
            }
        }
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.permission.cts.NearbyDevicesPermissionTest"	"isEnabled"	"CtsPermissionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NearbyDevicesPermissionTest.java"	""	"/*
 *.
 */

package android.permission.cts;

import static android.Manifest.permission.ACCESS_BACKGROUND_LOCATION;
import static android.Manifest.permission.ACCESS_FINE_LOCATION;
import static android.Manifest.permission.BLUETOOTH_CONNECT;
import static android.Manifest.permission.BLUETOOTH_SCAN;
import static android.permission.cts.PermissionUtils.grantPermission;
import static android.permission.cts.PermissionUtils.install;
import static android.permission.cts.PermissionUtils.revokePermission;
import static android.permission.cts.PermissionUtils.uninstallApp;

import static com.android.compatibility.common.util.SystemUtil.runShellCommandOrThrow;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;
import static org.junit.Assume.assumeTrue;

import android.bluetooth.BluetoothAdapter;
import android.bluetooth.BluetoothManager;
import android.bluetooth.cts.BTAdapterUtils;
import android.content.ContentResolver;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.os.Build;
import android.os.Bundle;
import android.os.SystemClock;
import android.platform.test.annotations.AppModeFull;

import androidx.test.InstrumentationRegistry;
import androidx.test.filters.SdkSuppress;
import androidx.test.runner.AndroidJUnit4;

import com.android.compatibility.common.util.CddTest;

import org.junit.After;
import org.junit.Before;
import org.junit.Ignore;
import org.junit.Test;
import org.junit.runner.RunWith;

/**
 * Tests the behavior of the
 * {@link android.Manifest.permission_group#NEARBY_DEVICES} permission group
 * under various permutations of grant states.
 */
@RunWith(AndroidJUnit4.class)
@AppModeFull
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.S, codeName = ""S"")
public class NearbyDevicesPermissionTest {
    private static final String TEST_APP_PKG = ""android.permission.cts.appthatrequestpermission"";
    private static final String TEST_APP_AUTHORITY = ""appthatrequestpermission"";
    private static final String DISAVOWAL_APP_PKG = ""android.permission.cts.appneverforlocation"";

    private static final String TMP_DIR = ""/data/local/tmp/cts/permissions/"";
    private static final String APK_BLUETOOTH_30 = TMP_DIR
            + ""CtsAppThatRequestsBluetoothPermission30.apk"";
    private static final String APK_BLUETOOTH_31 = TMP_DIR
            + ""CtsAppThatRequestsBluetoothPermission31.apk"";
    private static final String APK_BLUETOOTH_NEVER_FOR_LOCATION_31 = TMP_DIR
            + ""CtsAppThatRequestsBluetoothPermissionNeverForLocation31.apk"";
    private static final String APK_BLUETOOTH_NEVER_FOR_LOCATION_NO_PROVIDER = TMP_DIR
            + ""CtsAppThatRequestsBluetoothPermissionNeverForLocationNoProvider.apk"";

    private enum Result {
        UNKNOWN, EXCEPTION, EMPTY, FILTERED, FULL
    }

    private Context mContext = InstrumentationRegistry.getInstrumentation().getContext();
    private BluetoothAdapter mBluetoothAdapter;
    private boolean mBluetoothAdapterWasEnabled;

    @Before
    public void enableBluetooth() {
        assumeTrue(supportsBluetooth());
        mBluetoothAdapter = mContext.getSystemService(BluetoothManager.class).getAdapter();
        mBluetoothAdapterWasEnabled = mBluetoothAdapter.isEnabled();
        assertTrue(BTAdapterUtils.enableAdapter(mBluetoothAdapter, mContext));
        enableTestMode();
    }

    @After
    public void disableBluetooth() {
        assumeTrue(supportsBluetooth());
        disableTestMode();
        if (!mBluetoothAdapterWasEnabled) {
            assertTrue(BTAdapterUtils.disableAdapter(mBluetoothAdapter, mContext));
        }
    }

    @Before
    @After
    public void uninstallTestApp() {
        uninstallApp(TEST_APP_PKG);
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.permission.cts.NearbyDevicesPermissionTest"	"testRequestBluetoothPermission30_Default"	"CtsPermissionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NearbyDevicesPermissionTest.java"	""	"@CddTest(requirement=""7.4.3/C-6-1"")
    public void testRequestBluetoothPermission30_Default() throws Throwable {
        install(APK_BLUETOOTH_30);
        assertScanBluetoothResult(Result.EMPTY);
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.permission.cts.NearbyDevicesPermissionTest"	"testRequestBluetoothPermission30_GrantLocation"	"CtsPermissionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NearbyDevicesPermissionTest.java"	""	"@CddTest(requirement=""7.4.3/C-6-1"")
    public void testRequestBluetoothPermission30_GrantLocation() throws Throwable {
        install(APK_BLUETOOTH_30);
        grantPermission(TEST_APP_PKG, ACCESS_FINE_LOCATION);
        grantPermission(TEST_APP_PKG, ACCESS_BACKGROUND_LOCATION);
        assertScanBluetoothResult(Result.FULL);
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.permission.cts.NearbyDevicesPermissionTest"	"testRequestBluetoothPermission31_Default"	"CtsPermissionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NearbyDevicesPermissionTest.java"	""	"@CddTest(requirement=""7.4.3/C-6-1"")
    public void testRequestBluetoothPermission31_Default() throws Throwable {
        install(APK_BLUETOOTH_31);
        assertScanBluetoothResult(Result.EXCEPTION);
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.permission.cts.NearbyDevicesPermissionTest"	"testRequestBluetoothPermission31_GrantNearby"	"CtsPermissionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NearbyDevicesPermissionTest.java"	""	"@CddTest(requirement=""7.4.3/C-6-1"")
    public void testRequestBluetoothPermission31_GrantNearby() throws Throwable {
        install(APK_BLUETOOTH_31);
        grantPermission(TEST_APP_PKG, BLUETOOTH_CONNECT);
        grantPermission(TEST_APP_PKG, BLUETOOTH_SCAN);
        assertScanBluetoothResult(Result.EMPTY);
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.permission.cts.NearbyDevicesPermissionTest"	"testRequestBluetoothPermission31_GrantLocation"	"CtsPermissionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NearbyDevicesPermissionTest.java"	""	"@CddTest(requirement=""7.4.3/C-6-1"")
    public void testRequestBluetoothPermission31_GrantLocation() throws Throwable {
        install(APK_BLUETOOTH_31);
        grantPermission(TEST_APP_PKG, ACCESS_FINE_LOCATION);
        grantPermission(TEST_APP_PKG, ACCESS_BACKGROUND_LOCATION);
        assertScanBluetoothResult(Result.EXCEPTION);
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.permission.cts.NearbyDevicesPermissionTest"	"testRequestBluetoothPermission31_GrantNearby_GrantLocation"	"CtsPermissionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NearbyDevicesPermissionTest.java"	""	"@CddTest(requirement=""7.4.3/C-6-1"")
    public void testRequestBluetoothPermission31_GrantNearby_GrantLocation() throws Throwable {
        install(APK_BLUETOOTH_31);
        grantPermission(TEST_APP_PKG, BLUETOOTH_CONNECT);
        grantPermission(TEST_APP_PKG, BLUETOOTH_SCAN);
        grantPermission(TEST_APP_PKG, ACCESS_FINE_LOCATION);
        grantPermission(TEST_APP_PKG, ACCESS_BACKGROUND_LOCATION);
        assertScanBluetoothResult(Result.FULL);
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.permission.cts.NearbyDevicesPermissionTest"	"testRequestBluetoothPermissionNeverForLocation31_Default"	"CtsPermissionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NearbyDevicesPermissionTest.java"	""	"@CddTest(requirement=""7.4.3/C-6-1"")
    public void testRequestBluetoothPermissionNeverForLocation31_Default() throws Throwable {
        install(APK_BLUETOOTH_NEVER_FOR_LOCATION_31);
        assertScanBluetoothResult(Result.EXCEPTION);
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.permission.cts.NearbyDevicesPermissionTest"	"testRequestBluetoothPermissionNeverForLocation31_GrantNearby"	"CtsPermissionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NearbyDevicesPermissionTest.java"	""	"@CddTest(requirement=""7.4.3/C-6-1"")
    public void testRequestBluetoothPermissionNeverForLocation31_GrantNearby() throws Throwable {
        install(APK_BLUETOOTH_NEVER_FOR_LOCATION_31);
        grantPermission(TEST_APP_PKG, BLUETOOTH_CONNECT);
        grantPermission(TEST_APP_PKG, BLUETOOTH_SCAN);
        assertScanBluetoothResult(Result.FILTERED);
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.permission.cts.NearbyDevicesPermissionTest"	"testRequestBluetoothPermissionNeverForLocation31_GrantLocation"	"CtsPermissionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NearbyDevicesPermissionTest.java"	""	"@CddTest(requirement=""7.4.3/C-6-1"")
    public void testRequestBluetoothPermissionNeverForLocation31_GrantLocation() throws Throwable {
        install(APK_BLUETOOTH_NEVER_FOR_LOCATION_31);
        grantPermission(TEST_APP_PKG, ACCESS_FINE_LOCATION);
        grantPermission(TEST_APP_PKG, ACCESS_BACKGROUND_LOCATION);
        assertScanBluetoothResult(Result.EXCEPTION);
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.permission.cts.NearbyDevicesPermissionTest"	"testRequestBluetoothPermissionNeverForLocation31_GrantNearby_GrantLocation"	"CtsPermissionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NearbyDevicesPermissionTest.java"	""	"@CddTest(requirement=""7.4.3/C-6-1"")
    public void testRequestBluetoothPermissionNeverForLocation31_GrantNearby_GrantLocation()
            throws Throwable {
        install(APK_BLUETOOTH_NEVER_FOR_LOCATION_31);
        grantPermission(TEST_APP_PKG, BLUETOOTH_CONNECT);
        grantPermission(TEST_APP_PKG, BLUETOOTH_SCAN);
        grantPermission(TEST_APP_PKG, ACCESS_FINE_LOCATION);
        grantPermission(TEST_APP_PKG, ACCESS_BACKGROUND_LOCATION);
        assertScanBluetoothResult(Result.FILTERED);
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.permission.cts.NearbyDevicesPermissionTest"	"testRequestBluetoothPermission31_OnBehalfOfDisavowingApp"	"CtsPermissionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NearbyDevicesPermissionTest.java"	""	"public void testRequestBluetoothPermission31_OnBehalfOfDisavowingApp() throws Throwable {
        install(APK_BLUETOOTH_31);
        install(APK_BLUETOOTH_NEVER_FOR_LOCATION_NO_PROVIDER);
        grantPermission(TEST_APP_PKG, BLUETOOTH_CONNECT);
        grantPermission(TEST_APP_PKG, BLUETOOTH_SCAN);
        grantPermission(DISAVOWAL_APP_PKG, BLUETOOTH_CONNECT);
        grantPermission(DISAVOWAL_APP_PKG, BLUETOOTH_SCAN);
        assertScanBluetoothResult(""PROXY"", Result.FILTERED);
    }

    /**
     * Verify that upgrading an app doesn't gain them any access to Bluetooth
     * scan results; they'd always need to involve the user to gain permissions.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.permission.cts.NearbyDevicesPermissionTest"	"testRequestBluetoothPermission_Upgrade"	"CtsPermissionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NearbyDevicesPermissionTest.java"	""	"@Ignore
    public void testRequestBluetoothPermission_Upgrade() throws Throwable {
        install(APK_BLUETOOTH_30);
        grantPermission(TEST_APP_PKG, ACCESS_FINE_LOCATION);
        grantPermission(TEST_APP_PKG, ACCESS_BACKGROUND_LOCATION);
        assertScanBluetoothResult(Result.FULL);

        // Upgrading to target a new SDK level means they need to explicitly
        // request the new runtime permission; by default it's denied
        install(APK_BLUETOOTH_31);
        assertScanBluetoothResult(Result.EXCEPTION);

        // If the user does grant it, they can scan again
        grantPermission(TEST_APP_PKG, BLUETOOTH_CONNECT);
        grantPermission(TEST_APP_PKG, BLUETOOTH_SCAN);
        assertScanBluetoothResult(Result.FULL);
    }

    /**
     * Verify that downgrading an app doesn't gain them any access to Bluetooth
     * scan results; they'd always need to involve the user to gain permissions.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.permission.cts.NearbyDevicesPermissionTest"	"testRequestBluetoothPermission_Downgrade"	"CtsPermissionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NearbyDevicesPermissionTest.java"	""	"public void testRequestBluetoothPermission_Downgrade() throws Throwable {
        install(APK_BLUETOOTH_31);
        grantPermission(TEST_APP_PKG, BLUETOOTH_CONNECT);
        grantPermission(TEST_APP_PKG, BLUETOOTH_SCAN);
        grantPermission(TEST_APP_PKG, ACCESS_FINE_LOCATION);
        grantPermission(TEST_APP_PKG, ACCESS_BACKGROUND_LOCATION);
        assertScanBluetoothResult(Result.FULL);

        // Revoking nearby permission means modern app can't scan
        revokePermission(TEST_APP_PKG, BLUETOOTH_CONNECT);
        revokePermission(TEST_APP_PKG, BLUETOOTH_SCAN);
        assertScanBluetoothResult(Result.EXCEPTION);

        // And if they attempt to downgrade, confirm that they can't obtain the
        // split-permission grant from the older non-runtime permissions
        install(APK_BLUETOOTH_30);
        assertScanBluetoothResult(Result.EXCEPTION);
    }

    private void assertScanBluetoothResult(Result expected) {
        assertScanBluetoothResult(null, expected);
    }

    private void assertScanBluetoothResult(String arg, Result expected) {
        SystemClock.sleep(1000); // Wait for location permissions to propagate
        final ContentResolver resolver = InstrumentationRegistry.getTargetContext()
                .getContentResolver();
        final Bundle res = resolver.call(TEST_APP_AUTHORITY, """", arg, null);
        Result actual = Result.values()[res.getInt(Intent.EXTRA_INDEX)];
        assertEquals(expected, actual);
    }

    private boolean supportsBluetooth() {
        return mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH);
    }

    private void enableTestMode() {
        runShellCommandOrThrow(""dumpsys activity service""
                + "" com.android.bluetooth/.btservice.AdapterService set-test-mode enabled"");
    }

    private void disableTestMode() {
        runShellCommandOrThrow(""dumpsys activity service""
                + "" com.android.bluetooth/.btservice.AdapterService set-test-mode disabled"");
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.server.wm.AmProfileTests"	"testAmStartStartProfilerSamplingStreaming"	"CtsWindowManagerDeviceTestCases"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/AmProfileTests.java"	""	"public void testAmStartStartProfilerSamplingStreaming() throws Exception {
        testProfile(false, true, true);
    }

    private void testProfile(final boolean startActivityFirst, final boolean sampling,
            final boolean streaming) throws Exception {
        final ActivitySession activitySession;
        if (startActivityFirst) {
            activitySession = createManagedActivityClientSession().startActivity(
                    new Intent().setComponent(PROFILEABLE_APP_ACTIVITY));
            startProfiling(PROFILEABLE_APP_ACTIVITY.getPackageName(), sampling, streaming);
        } else {
            activitySession = startActivityProfiling(PROFILEABLE_APP_ACTIVITY, sampling, streaming);
        }

        // Go to home screen and then warm start the activity to generate some interesting trace.
        launchHomeActivity();
        launchActivity(PROFILEABLE_APP_ACTIVITY);

        executeShellCommand(getStopProfileCmd(PROFILEABLE_APP_ACTIVITY));

        activitySession.sendCommandAndWaitReply(COMMAND_WAIT_FOR_PROFILE_OUTPUT);
        verifyOutputFileFormat(streaming);
    }

    /** Starts profiler on a started process. */
    private static void startProfiling(String processName, boolean sampling, boolean streaming) {
        final StringBuilder builder = new StringBuilder(""am profile start"");
        appendProfileParameters(builder, sampling, streaming);
        builder.append(String.format("" %s %s"", processName, OUTPUT_FILE_PATH));
        executeShellCommand(builder.toString());
    }

    /** Starts the activity with profiler. */
    private ActivitySession startActivityProfiling(ComponentName activityName, boolean sampling,
            boolean streaming) {
        return createManagedActivityClientSession().startActivity(new DefaultLaunchProxy() {

            @Override
            public boolean shouldWaitForLaunched() {
                // The shell command included ""-W"".
                return false;
            }

            @Override
            public void execute() {
                final StringBuilder builder = new StringBuilder();
                builder.append(String.format(""am start -n %s -W -S --start-profiler %s"",
                        getActivityName(activityName), OUTPUT_FILE_PATH));
                appendProfileParameters(builder, sampling, streaming);
                mLaunchInjector.setupShellCommand(builder);
                executeShellCommand(builder.toString());
            }
        });
    }

    private static void appendProfileParameters(StringBuilder builder, boolean sampling,
            boolean streaming) {
        if (sampling) {
            builder.append("" --sampling 1000"");
        }
        if (streaming) {
            builder.append("" --streaming"");
        }
    }

    private static String getStopProfileCmd(final ComponentName activityName) {
        return ""am profile stop "" + activityName.getPackageName();
    }

    private void verifyOutputFileFormat(final boolean streaming) throws Exception {
        // This is a hack. The am service has to write to /data/local/tmp because it doesn't have
        // access to the sdcard. The test cannot read from /data/local/tmp. This allows us to
        // scan the content to validate what is needed for this test.
        final String firstLine = executeShellCommand(""head -1 "" + OUTPUT_FILE_PATH);

        final String expectedFirstWord = streaming ? FIRST_WORD_STREAMING : FIRST_WORD_NO_STREAMING;
        assertThat(
                ""data size"", firstLine.length(), greaterThanOrEqualTo(expectedFirstWord.length()));
        final String actualFirstWord = firstLine.substring(0, expectedFirstWord.length());
        assertEquals(""Unexpected first word"", expectedFirstWord, actualFirstWord);

        // Clean up.
        executeShellCommand(""rm -f "" + OUTPUT_FILE_PATH);
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.bluetooth.BleClientService"	"disconnect"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/bluetooth/BleClientService.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.bluetooth;

import android.app.Service;
import android.bluetooth.BluetoothAdapter;
import android.bluetooth.BluetoothDevice;
import android.bluetooth.BluetoothGatt;
import android.bluetooth.BluetoothGattCallback;
import android.bluetooth.BluetoothGattCharacteristic;
import android.bluetooth.BluetoothGattDescriptor;
import android.bluetooth.BluetoothGattService;
import android.bluetooth.BluetoothManager;
import android.bluetooth.BluetoothProfile;
import android.bluetooth.le.BluetoothLeScanner;
import android.bluetooth.le.ScanCallback;
import android.bluetooth.le.ScanFilter;
import android.bluetooth.le.ScanResult;
import android.bluetooth.le.ScanSettings;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.Build;
import android.os.Handler;
import android.os.IBinder;
import android.os.ParcelUuid;
import android.text.TextUtils;
import android.util.Log;
import android.widget.Toast;

import com.android.cts.verifier.R;

import java.util.Arrays;
import java.util.List;
import java.util.Set;
import java.util.UUID;

public class BleClientService extends Service {

    public static final boolean DEBUG = true;
    public static final String TAG = ""BleClientService"";

    // Android N (2016 July 15, currently) BluetoothGatt#disconnect() does not work correct.
    // (termination signal will not be sent)
    // This flag switches to turn Bluetooth off instead of BluetoothGatt#disconnect().
    // If true, test will turn Bluetooth off. Otherwise, will call BluetoothGatt#disconnect().
    public static final boolean DISCONNECT_BY_TURN_BT_OFF_ON = (Build.VERSION.SDK_INT > Build.VERSION_CODES.M);

    // for Version 1 test
//    private static final int TRANSPORT_MODE_FOR_SECURE_CONNECTION = BluetoothDevice.TRANSPORT_AUTO;
    // for Version 2 test
    private static final int TRANSPORT_MODE_FOR_SECURE_CONNECTION = BluetoothDevice.TRANSPORT_LE;

    public static final int COMMAND_CONNECT = 0;
    public static final int COMMAND_DISCONNECT = 1;
    public static final int COMMAND_DISCOVER_SERVICE = 2;
    public static final int COMMAND_READ_RSSI = 3;
    public static final int COMMAND_WRITE_CHARACTERISTIC = 4;
    public static final int COMMAND_WRITE_CHARACTERISTIC_BAD_RESP = 5;
    public static final int COMMAND_READ_CHARACTERISTIC = 6;
    public static final int COMMAND_WRITE_DESCRIPTOR = 7;
    public static final int COMMAND_READ_DESCRIPTOR = 8;
    public static final int COMMAND_SET_NOTIFICATION = 9;
    public static final int COMMAND_BEGIN_WRITE = 10;
    public static final int COMMAND_EXECUTE_WRITE = 11;
    public static final int COMMAND_ABORT_RELIABLE = 12;
    public static final int COMMAND_SCAN_START = 13;
    public static final int COMMAND_SCAN_STOP = 14;

    public static final String BLE_BLUETOOTH_MISMATCH_SECURE =
            ""com.android.cts.verifier.bluetooth.BLE_BLUETOOTH_MISMATCH_SECURE"";
    public static final String BLE_BLUETOOTH_MISMATCH_INSECURE =
            ""com.android.cts.verifier.bluetooth.BLE_BLUETOOTH_MISMATCH_INSECURE"";
    public static final String BLE_BLUETOOTH_DISABLED =
            ""com.android.cts.verifier.bluetooth.BLE_BLUETOOTH_DISABLED"";
    public static final String BLE_BLUETOOTH_CONNECTED =
            ""com.android.cts.verifier.bluetooth.BLE_BLUETOOTH_CONNECTED"";
    public static final String BLE_BLUETOOTH_DISCONNECTED =
            ""com.android.cts.verifier.bluetooth.BLE_BLUETOOTH_DISCONNECTED"";
    public static final String BLE_SERVICES_DISCOVERED =
            ""com.android.cts.verifier.bluetooth.BLE_SERVICES_DISCOVERED"";
    public static final String BLE_MTU_CHANGED_23BYTES =
            ""com.android.cts.verifier.bluetooth.BLE_MTU_CHANGED_23BYTES"";
    public static final String BLE_MTU_CHANGED_512BYTES =
            ""com.android.cts.verifier.bluetooth.BLE_MTU_CHANGED_512BYTES"";
    public static final String BLE_CHARACTERISTIC_READ =
            ""com.android.cts.verifier.bluetooth.BLE_CHARACTERISTIC_READ"";
    public static final String BLE_CHARACTERISTIC_WRITE =
            ""com.android.cts.verifier.bluetooth.BLE_CHARACTERISTIC_WRITE"";
    public static final String BLE_CHARACTERISTIC_CHANGED =
            ""com.android.cts.verifier.bluetooth.BLE_CHARACTERISTIC_CHANGED"";
    public static final String BLE_CHARACTERISTIC_INDICATED =
            ""com.android.cts.verifier.bluetooth.BLE_CHARACTERISTIC_INDICATED"";
    public static final String BLE_DESCRIPTOR_READ =
            ""com.android.cts.verifier.bluetooth.BLE_DESCRIPTOR_READ"";
    public static final String BLE_DESCRIPTOR_WRITE =
            ""com.android.cts.verifier.bluetooth.BLE_DESCRIPTOR_WRITE"";
    public static final String BLE_RELIABLE_WRITE_COMPLETED =
            ""com.android.cts.verifier.bluetooth.BLE_RELIABLE_WRITE_COMPLETED"";
    public static final String BLE_RELIABLE_WRITE_BAD_RESP_COMPLETED =
            ""com.android.cts.verifier.bluetooth.BLE_RELIABLE_WRITE_BAD_RESP_COMPLETED"";
    public static final String BLE_READ_REMOTE_RSSI =
            ""com.android.cts.verifier.bluetooth.BLE_READ_REMOTE_RSSI"";
    public static final String BLE_ON_SERVICE_CHANGED =
            ""com.android.cts.verifier.bluetooth.BLE_ON_SERVICE_CHANGED"";
    public static final String BLE_CHARACTERISTIC_READ_NOPERMISSION =
            ""com.android.cts.verifier.bluetooth.BLE_CHARACTERISTIC_READ_NOPERMISSION"";
    public static final String BLE_CHARACTERISTIC_WRITE_NOPERMISSION =
            ""com.android.cts.verifier.bluetooth.BLE_CHARACTERISTIC_WRITE_NOPERMISSION"";
    public static final String BLE_DESCRIPTOR_READ_NOPERMISSION =
            ""com.android.cts.verifier.bluetooth.BLE_DESCRIPTOR_READ_NOPERMISSION"";
    public static final String BLE_DESCRIPTOR_WRITE_NOPERMISSION =
            ""com.android.cts.verifier.bluetooth.BLE_DESCRIPTOR_WRITE_NOPERMISSION"";
    public static final String BLE_CHARACTERISTIC_READ_NEED_ENCRYPTED =
            ""com.android.cts.verifier.bluetooth.BLE_CHARACTERISTIC_READ_NEED_ENCRYPTED"";
    public static final String BLE_CHARACTERISTIC_WRITE_NEED_ENCRYPTED =
            ""com.android.cts.verifier.bluetooth.BLE_CHARACTERISTIC_WRITE_NEED_ENCRYPTED"";
    public static final String BLE_DESCRIPTOR_READ_NEED_ENCRYPTED =
            ""com.android.cts.verifier.bluetooth.BLE_DESCRIPTOR_READ_NEED_ENCRYPTED"";
    public static final String BLE_DESCRIPTOR_WRITE_NEED_ENCRYPTED =
            ""com.android.cts.verifier.bluetooth.BLE_DESCRIPTOR_WRITE_NEED_ENCRYPTED"";
    public static final String BLE_CLIENT_ERROR =
            ""com.android.cts.verifier.bluetooth.BLE_CLIENT_ERROR"";

    public static final String EXTRA_COMMAND =
            ""com.android.cts.verifier.bluetooth.EXTRA_COMMAND"";
    public static final String EXTRA_WRITE_VALUE =
            ""com.android.cts.verifier.bluetooth.EXTRA_WRITE_VALUE"";
    public static final String EXTRA_BOOL =
            ""com.android.cts.verifier.bluetooth.EXTRA_BOOL"";


    // Literal for Client Action
    public static final String BLE_CLIENT_ACTION_CLIENT_CONNECT =
            ""com.android.cts.verifier.bluetooth.BLE_CLIENT_ACTION_CLIENT_CONNECT"";
    public static final String BLE_CLIENT_ACTION_CLIENT_CONNECT_SECURE =
            ""com.android.cts.verifier.bluetooth.BLE_CLIENT_ACTION_CLIENT_CONNECT_SECURE"";
    public static final String BLE_CLIENT_ACTION_BLE_DISCOVER_SERVICE =
            ""com.android.cts.verifier.bluetooth.BLE_CLIENT_ACTION_BLE_DISCOVER_SERVICE"";
    public static final String BLE_CLIENT_ACTION_REQUEST_MTU_23 =
            ""com.android.cts.verifier.bluetooth.BLE_CLIENT_ACTION_REQUEST_MTU_23"";
    public static final String BLE_CLIENT_ACTION_REQUEST_MTU_512 =
            ""com.android.cts.verifier.bluetooth.BLE_CLIENT_ACTION_REQUEST_MTU_512"";
    public static final String BLE_CLIENT_ACTION_READ_CHARACTERISTIC =
            ""com.android.cts.verifier.bluetooth.BLE_CLIENT_ACTION_READ_CHARACTERISTIC"";
    public static final String BLE_CLIENT_ACTION_WRITE_CHARACTERISTIC =
            ""com.android.cts.verifier.bluetooth.BLE_CLIENT_ACTION_WRITE_CHARACTERISTIC"";
    public static final String BLE_CLIENT_ACTION_RELIABLE_WRITE =
            ""com.android.cts.verifier.bluetooth.BLE_CLIENT_ACTION_RELIABLE_WRITE"";
    public static final String BLE_CLIENT_ACTION_RELIABLE_WRITE_BAD_RESP =
            ""com.android.cts.verifier.bluetooth.BLE_CLIENT_ACTION_RELIABLE_WRITE_BAD_RESP"";
    public static final String BLE_CLIENT_ACTION_NOTIFY_CHARACTERISTIC =
            ""com.android.cts.verifier.bluetooth.BLE_CLIENT_ACTION_NOTIFY_CHARACTERISTIC"";
    public static final String BLE_CLIENT_ACTION_INDICATE_CHARACTERISTIC =
            ""com.android.cts.verifier.bluetooth.BLE_CLIENT_ACTION_INDICATE_CHARACTERISTIC"";
    public static final String BLE_CLIENT_ACTION_READ_DESCRIPTOR =
            ""com.android.cts.verifier.bluetooth.BLE_CLIENT_ACTION_READ_DESCRIPTOR"";
    public static final String BLE_CLIENT_ACTION_WRITE_DESCRIPTOR =
            ""com.android.cts.verifier.bluetooth.BLE_CLIENT_ACTION_WRITE_DESCRIPTOR"";
    public static final String BLE_CLIENT_ACTION_READ_RSSI =
            ""com.android.cts.verifier.bluetooth.BLE_CLIENT_ACTION_READ_RSSI"";
    public static final String BLE_CLIENT_ACTION_TRIGGER_SERVICE_CHANGED =
            ""com.android.cts.verifier.bluetooth.BLE_CLIENT_ACTION_TRIGGER_SERVICE_CHANGED"";
    public static final String BLE_CLIENT_ACTION_CLIENT_DISCONNECT =
            ""com.android.cts.verifier.bluetooth.BLE_CLIENT_ACTION_CLIENT_DISCONNECT"";
    public static final String BLE_CLIENT_ACTION_READ_CHARACTERISTIC_NO_PERMISSION =
            ""com.android.cts.verifier.bluetooth.BLE_CLIENT_ACTION_READ_CHARACTERISTIC_NO_PERMISSION"";
    public static final String BLE_CLIENT_ACTION_WRITE_CHARACTERISTIC_NO_PERMISSION =
            ""com.android.cts.verifier.bluetooth.BLE_CLIENT_ACTION_WRITE_CHARACTERISTIC_NO_PERMISSION"";
    public static final String BLE_CLIENT_ACTION_READ_DESCRIPTOR_NO_PERMISSION =
            ""com.android.cts.verifier.bluetooth.BLE_CLIENT_ACTION_READ_DESCRIPTOR_NO_PERMISSION"";
    public static final String BLE_CLIENT_ACTION_WRITE_DESCRIPTOR_NO_PERMISSION =
            ""com.android.cts.verifier.bluetooth.BLE_CLIENT_ACTION_WRITE_DESCRIPTOR_NO_PERMISSION"";
    public static final String BLE_CLIENT_ACTION_READ_AUTHENTICATED_CHARACTERISTIC =
            ""com.android.cts.verifier.bluetooth.BLE_CLIENT_ACTION_READ_AUTHENTICATED_CHARACTERISTIC"";
    public static final String BLE_CLIENT_ACTION_WRITE_AUTHENTICATED_CHARACTERISTIC =
            ""com.android.cts.verifier.bluetooth.BLE_CLIENT_ACTION_WRITE_AUTHENTICATED_CHARACTERISTIC"";
    public static final String BLE_CLIENT_ACTION_READ_AUTHENTICATED_DESCRIPTOR =
            ""com.android.cts.verifier.bluetooth.BLE_CLIENT_ACTION_READ_AUTHENTICATED_DESCRIPTOR"";
    public static final String BLE_CLIENT_ACTION_WRITE_AUTHENTICATED_DESCRIPTOR =
            ""com.android.cts.verifier.bluetooth.BLE_CLIENT_ACTION_WRITE_AUTHENTICATED_DESCRIPTOR"";

    public static final String EXTRA_CHARACTERISTIC_VALUE =
            ""com.android.cts.verifier.bluetooth.EXTRA_CHARACTERISTIC_VALUE"";
    public static final String EXTRA_DESCRIPTOR_VALUE =
            ""com.android.cts.verifier.bluetooth.EXTRA_DESCRIPTOR_VALUE"";
    public static final String EXTRA_RSSI_VALUE =
            ""com.android.cts.verifier.bluetooth.EXTRA_RSSI_VALUE"";
    public static final String EXTRA_ERROR_MESSAGE =
            ""com.android.cts.verifier.bluetooth.EXTRA_ERROR_MESSAGE"";

    public static final String WRITE_VALUE_512BYTES_FOR_MTU = createTestData(512);
    public static final String WRITE_VALUE_507BYTES_FOR_RELIABLE_WRITE = createTestData(507);

    private static final UUID SERVICE_UUID =
            UUID.fromString(""00009999-0000-1000-8000-00805f9b34fb"");
    private static final UUID CHARACTERISTIC_UUID =
            UUID.fromString(""00009998-0000-1000-8000-00805f9b34fb"");
    private static final UUID CHARACTERISTIC_RESULT_UUID =
            UUID.fromString(""00009974-0000-1000-8000-00805f9b34fb"");
    private static final UUID UPDATE_CHARACTERISTIC_UUID =
            UUID.fromString(""00009997-0000-1000-8000-00805f9b34fb"");
    private static final UUID DESCRIPTOR_UUID =
            UUID.fromString(""00009996-0000-1000-8000-00805f9b34fb"");

    private static final UUID SERVICE_UUID_ADDITIONAL =
            UUID.fromString(""00009995-0000-1000-8000-00805f9b34fb"");

    // Literal for registration permission of Characteristic
    private static final UUID CHARACTERISTIC_NO_READ_UUID =
            UUID.fromString(""00009984-0000-1000-8000-00805f9b34fb"");
    private static final UUID CHARACTERISTIC_NO_WRITE_UUID =
            UUID.fromString(""00009983-0000-1000-8000-00805f9b34fb"");
    private static final UUID CHARACTERISTIC_NEED_ENCRYPTED_READ_UUID =
            UUID.fromString(""00009982-0000-1000-8000-00805f9b34fb"");
    private static final UUID CHARACTERISTIC_NEED_ENCRYPTED_WRITE_UUID =
            UUID.fromString(""00009981-0000-1000-8000-00805f9b34fb"");

    // Literal for registration permission of Descriptor
    private static final UUID DESCRIPTOR_NO_READ_UUID =
            UUID.fromString(""00009973-0000-1000-8000-00805f9b34fb"");
    private static final UUID DESCRIPTOR_NO_WRITE_UUID =
            UUID.fromString(""00009972-0000-1000-8000-00805f9b34fb"");
    private static final UUID DESCRIPTOR_NEED_ENCRYPTED_READ_UUID =
            UUID.fromString(""00009969-0000-1000-8000-00805f9b34fb"");
    private static final UUID DESCRIPTOR_NEED_ENCRYPTED_WRITE_UUID =
            UUID.fromString(""00009968-0000-1000-8000-00805f9b34fb"");

    //  Literal for registration upper limit confirmation of Characteristic
    private static final UUID UPDATE_CHARACTERISTIC_UUID_1 =
            UUID.fromString(""00009989-0000-1000-8000-00805f9b34fb"");
    private static final UUID UPDATE_CHARACTERISTIC_UUID_2 =
            UUID.fromString(""00009988-0000-1000-8000-00805f9b34fb"");
    private static final UUID UPDATE_CHARACTERISTIC_UUID_3 =
            UUID.fromString(""00009987-0000-1000-8000-00805f9b34fb"");
    private static final UUID UPDATE_CHARACTERISTIC_UUID_4 =
            UUID.fromString(""00009986-0000-1000-8000-00805f9b34fb"");
    private static final UUID UPDATE_CHARACTERISTIC_UUID_5 =
            UUID.fromString(""00009985-0000-1000-8000-00805f9b34fb"");
    private static final UUID UPDATE_CHARACTERISTIC_UUID_6 =
            UUID.fromString(""00009979-0000-1000-8000-00805f9b34fb"");
    private static final UUID UPDATE_CHARACTERISTIC_UUID_7 =
            UUID.fromString(""00009978-0000-1000-8000-00805f9b34fb"");
    private static final UUID UPDATE_CHARACTERISTIC_UUID_8 =
            UUID.fromString(""00009977-0000-1000-8000-00805f9b34fb"");
    private static final UUID UPDATE_CHARACTERISTIC_UUID_9 =
            UUID.fromString(""00009976-0000-1000-8000-00805f9b34fb"");
    private static final UUID UPDATE_CHARACTERISTIC_UUID_10 =
            UUID.fromString(""00009975-0000-1000-8000-00805f9b34fb"");
    private static final UUID UPDATE_CHARACTERISTIC_UUID_11 =
            UUID.fromString(""00009959-0000-1000-8000-00805f9b34fb"");
    private static final UUID UPDATE_CHARACTERISTIC_UUID_12 =
            UUID.fromString(""00009958-0000-1000-8000-00805f9b34fb"");
    private static final UUID UPDATE_CHARACTERISTIC_UUID_13 =
            UUID.fromString(""00009957-0000-1000-8000-00805f9b34fb"");
    private static final UUID UPDATE_CHARACTERISTIC_UUID_14 =
            UUID.fromString(""00009956-0000-1000-8000-00805f9b34fb"");
    private static final UUID UPDATE_CHARACTERISTIC_UUID_15 =
            UUID.fromString(""00009955-0000-1000-8000-00805f9b34fb"");

    private static final UUID SERVICE_CHANGED_CONTROL_CHARACTERISTIC_UUID =
        UUID.fromString(""00009949-0000-1000-8000-00805f9b34fb"");

    private static final UUID UPDATE_DESCRIPTOR_UUID =
            UUID.fromString(""00002902-0000-1000-8000-00805f9b34fb"");

    private static final UUID INDICATE_CHARACTERISTIC_UUID =
            UUID.fromString(""00009971-0000-1000-8000-00805f9b34fb"");

    public static final String WRITE_VALUE = ""CLIENT_TEST"";
    private static final String NOTIFY_VALUE = ""NOTIFY_TEST"";
    public static final String WRITE_VALUE_BAD_RESP = ""BAD_RESP_TEST"";
    public static final String SERVICE_CHANGED_VALUE = ""CLIENT_SVC_CHG"";

    // current test category
    private String mCurrentAction;

    private BluetoothManager mBluetoothManager;
    private BluetoothAdapter mBluetoothAdapter;
    private BluetoothDevice mDevice;
    private BluetoothGatt mBluetoothGatt;
    private BluetoothLeScanner mScanner;
    private Handler mHandler;
    private Context mContext;
    private boolean mSecure;
    private int mNotifyCount;
    private boolean mValidityService;
    private ReliableWriteState mExecReliableWrite;
    private byte[] mBuffer;

    // Handler for communicating task with peer.
    private TestTaskQueue mTaskQueue;

    // Lock for synchronization during notification request test.
    private final Object mRequestNotificationLock = new Object();

    // Lock for triggering service changed event on server side.
    private final Object mServiceChangedLock = new Object();
    private static final int SERVICE_CHANGED_FLAG_INIT = 0x00;
    private static final int SERVICE_CHANGED_FLAG_TRIGGER_ACTION = 0x01;
    private static final int SERVICE_CHANGED_FLAG_ON_SERVICE_CHANGED = 0x02;
    private static final int SERVICE_CHANGED_FLAG_ALL = 0x03;
    private static final int SERVOCE_CHANGED_FLAG_IGNORE = 0xFF;
    private int mServiceChangedFlag;

    private enum ReliableWriteState {
        RELIABLE_WRITE_NONE,
        RELIABLE_WRITE_WRITE_1ST_DATA,
        RELIABLE_WRITE_WRITE_2ND_DATA,
        RELIABLE_WRITE_EXECUTE,
        RELIABLE_WRITE_BAD_RESP
    }

    @Override
    public void onCreate() {
        super.onCreate();

        registerReceiver(mBondStatusReceiver, new IntentFilter(BluetoothDevice.ACTION_BOND_STATE_CHANGED));

        mBluetoothManager = (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE);
        mBluetoothAdapter = mBluetoothManager.getAdapter();
        mScanner = mBluetoothAdapter.getBluetoothLeScanner();
        mHandler = new Handler();
        mContext = this;
        mNotifyCount = 0;

        mTaskQueue = new TestTaskQueue(getClass().getName() + ""_taskHandlerThread"");
    }

    @Override
    public int onStartCommand(final Intent intent, int flags, int startId) {
        if (!mBluetoothAdapter.isEnabled()) {
            notifyBluetoothDisabled();
        } else {
            mTaskQueue.addTask(new Runnable() {
                @Override
                public void run() {
                    onTestFinish(intent.getAction());
                }
            }, 1500);
        }
        return START_NOT_STICKY;
    }

    private void onTestFinish(String action) {
        mCurrentAction = action;
        if (mCurrentAction != null) {
            switch (mCurrentAction) {
                case BLE_CLIENT_ACTION_CLIENT_CONNECT_SECURE:
                    mSecure = true;
                    mExecReliableWrite = ReliableWriteState.RELIABLE_WRITE_NONE;
                    startScan();
                    break;
                case BLE_CLIENT_ACTION_CLIENT_CONNECT:
                    mExecReliableWrite = ReliableWriteState.RELIABLE_WRITE_NONE;
                    startScan();
                    break;
                case BLE_CLIENT_ACTION_BLE_DISCOVER_SERVICE:
                    if (mBluetoothGatt != null && mBleState == BluetoothProfile.STATE_CONNECTED) {
                        mBluetoothGatt.discoverServices();
                    } else {
                        showMessage(""Bluetooth LE not cnnected."");
                    }
                    break;
                case BLE_CLIENT_ACTION_REQUEST_MTU_23:
                case BLE_CLIENT_ACTION_REQUEST_MTU_512: // fall through
                    requestMtu();
                    break;
                case BLE_CLIENT_ACTION_READ_CHARACTERISTIC:
                    readCharacteristic(CHARACTERISTIC_UUID);
                    break;
                case BLE_CLIENT_ACTION_WRITE_CHARACTERISTIC:
                    writeCharacteristic(CHARACTERISTIC_UUID, WRITE_VALUE);
                    break;
                case BLE_CLIENT_ACTION_RELIABLE_WRITE:
                case BLE_CLIENT_ACTION_RELIABLE_WRITE_BAD_RESP: // fall through
                    mTaskQueue.addTask(new Runnable() {
                        @Override
                        public void run() {
                            reliableWrite();
                        }
                    });
                break;
                case BLE_CLIENT_ACTION_INDICATE_CHARACTERISTIC:
                    setNotification(INDICATE_CHARACTERISTIC_UUID, true);
                    break;
                case BLE_CLIENT_ACTION_NOTIFY_CHARACTERISTIC:
                    // Registered the notify to characteristics in the service
                    mTaskQueue.addTask(new Runnable() {
                        @Override
                        public void run() {
                            mNotifyCount = 16;
                            setNotification(UPDATE_CHARACTERISTIC_UUID, true);
                            waitForDisableNotificationCompletion();
                            setNotification(SERVICE_UUID_ADDITIONAL, UPDATE_CHARACTERISTIC_UUID_1, true);
                            waitForDisableNotificationCompletion();
                            setNotification(SERVICE_UUID_ADDITIONAL, UPDATE_CHARACTERISTIC_UUID_2, true);
                            waitForDisableNotificationCompletion();
                            setNotification(SERVICE_UUID_ADDITIONAL, UPDATE_CHARACTERISTIC_UUID_3, true);
                            waitForDisableNotificationCompletion();
                            setNotification(SERVICE_UUID_ADDITIONAL, UPDATE_CHARACTERISTIC_UUID_4, true);
                            waitForDisableNotificationCompletion();
                            setNotification(SERVICE_UUID_ADDITIONAL, UPDATE_CHARACTERISTIC_UUID_5, true);
                            waitForDisableNotificationCompletion();
                            setNotification(UPDATE_CHARACTERISTIC_UUID_6, true);
                            waitForDisableNotificationCompletion();
                            setNotification(UPDATE_CHARACTERISTIC_UUID_7, true);
                            waitForDisableNotificationCompletion();
                            setNotification(UPDATE_CHARACTERISTIC_UUID_8, true);
                            waitForDisableNotificationCompletion();
                            setNotification(UPDATE_CHARACTERISTIC_UUID_9, true);
                            waitForDisableNotificationCompletion();
                            setNotification(UPDATE_CHARACTERISTIC_UUID_10, true);
                            waitForDisableNotificationCompletion();
                            setNotification(SERVICE_UUID_ADDITIONAL, UPDATE_CHARACTERISTIC_UUID_11, true);
                            waitForDisableNotificationCompletion();
                            setNotification(SERVICE_UUID_ADDITIONAL, UPDATE_CHARACTERISTIC_UUID_12, true);
                            waitForDisableNotificationCompletion();
                            setNotification(SERVICE_UUID_ADDITIONAL, UPDATE_CHARACTERISTIC_UUID_13, true);
                            waitForDisableNotificationCompletion();
                            setNotification(SERVICE_UUID_ADDITIONAL, UPDATE_CHARACTERISTIC_UUID_14, true);
                            waitForDisableNotificationCompletion();
                            setNotification(SERVICE_UUID_ADDITIONAL, UPDATE_CHARACTERISTIC_UUID_15, true);
                            waitForDisableNotificationCompletion();
                        }
                    });
                break;
                case BLE_CLIENT_ACTION_READ_DESCRIPTOR:
                    readDescriptor(DESCRIPTOR_UUID);
                    break;
                case BLE_CLIENT_ACTION_WRITE_DESCRIPTOR:
                    writeDescriptor(DESCRIPTOR_UUID, WRITE_VALUE);
                    break;
                case BLE_CLIENT_ACTION_READ_RSSI:
                    if (mBluetoothGatt != null) {
                        mBluetoothGatt.readRemoteRssi();
                    }
                    break;
                case BLE_CLIENT_ACTION_CLIENT_DISCONNECT:
                    if (mBluetoothGatt != null) {
                        mBluetoothGatt.disconnect();
                    }
                    break;
                case BLE_CLIENT_ACTION_READ_CHARACTERISTIC_NO_PERMISSION:
                    readCharacteristic(CHARACTERISTIC_NO_READ_UUID);
                    break;
                case BLE_CLIENT_ACTION_WRITE_CHARACTERISTIC_NO_PERMISSION:
                    writeCharacteristic(CHARACTERISTIC_NO_WRITE_UUID, WRITE_VALUE);
                    break;
                case BLE_CLIENT_ACTION_READ_DESCRIPTOR_NO_PERMISSION:
                    readDescriptor(DESCRIPTOR_NO_READ_UUID);
                    break;
                case BLE_CLIENT_ACTION_WRITE_DESCRIPTOR_NO_PERMISSION:
                    writeDescriptor(DESCRIPTOR_NO_WRITE_UUID, WRITE_VALUE);
                    break;
                case BLE_CLIENT_ACTION_READ_AUTHENTICATED_CHARACTERISTIC:
                    readCharacteristic(CHARACTERISTIC_NEED_ENCRYPTED_READ_UUID);
                    break;
                case BLE_CLIENT_ACTION_WRITE_AUTHENTICATED_CHARACTERISTIC:
                    writeCharacteristic(CHARACTERISTIC_NEED_ENCRYPTED_WRITE_UUID, WRITE_VALUE);
                    break;
                case BLE_CLIENT_ACTION_READ_AUTHENTICATED_DESCRIPTOR:
                    readDescriptor(CHARACTERISTIC_RESULT_UUID, DESCRIPTOR_NEED_ENCRYPTED_READ_UUID);
                    break;
                case BLE_CLIENT_ACTION_WRITE_AUTHENTICATED_DESCRIPTOR:
                    writeDescriptor(CHARACTERISTIC_RESULT_UUID, DESCRIPTOR_NEED_ENCRYPTED_WRITE_UUID, WRITE_VALUE);
                    break;
                case BLE_CLIENT_ACTION_TRIGGER_SERVICE_CHANGED:
                    initializeServiceChangedEvent();
                    writeCharacteristic(SERVICE_CHANGED_CONTROL_CHARACTERISTIC_UUID, WRITE_VALUE);
                    break;
            }
        }
    }

    @Override
    public IBinder onBind(Intent intent) {
        return null;
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        if (mBluetoothGatt != null) {
            mBluetoothGatt.disconnect();
            mBluetoothGatt.close();
            mBluetoothGatt = null;
        }
        stopScan();
        unregisterReceiver(mBondStatusReceiver);

        mTaskQueue.quit();
    }

    public static BluetoothGatt connectGatt(BluetoothDevice device, Context context, boolean autoConnect, boolean isSecure, BluetoothGattCallback callback) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
            if (isSecure) {
                if (TRANSPORT_MODE_FOR_SECURE_CONNECTION == BluetoothDevice.TRANSPORT_AUTO) {
                    Toast.makeText(context, ""connectGatt(transport=AUTO)"", Toast.LENGTH_SHORT).show();
                } else {
                    Toast.makeText(context, ""connectGatt(transport=LE)"", Toast.LENGTH_SHORT).show();
                }
                return device.connectGatt(context, autoConnect, callback, TRANSPORT_MODE_FOR_SECURE_CONNECTION);
            } else {
                Toast.makeText(context, ""connectGatt(transport=LE)"", Toast.LENGTH_SHORT).show();
                return device.connectGatt(context, autoConnect, callback, BluetoothDevice.TRANSPORT_LE);
            }
        } else {
            Toast.makeText(context, ""connectGatt"", Toast.LENGTH_SHORT).show();
            return device.connectGatt(context, autoConnect, callback);
        }
    }

    private void requestMtu() {
        if (mBluetoothGatt != null) {
            // MTU request test does not work on Android 6.0 in secure mode.
            // (BluetoothDevice#createBond() does not work on Android 6.0.
            //  So devices can't establish Bluetooth LE pairing.)
            boolean mtuTestExecutable = true;
            if (Build.VERSION.SDK_INT <= Build.VERSION_CODES.M) {
                mtuTestExecutable = !mSecure;
            }

            if (mtuTestExecutable) {
                int mtu = 0;
                if (BLE_CLIENT_ACTION_REQUEST_MTU_23.equals(mCurrentAction)) {
                    mtu = 23;
                } else if (BLE_CLIENT_ACTION_REQUEST_MTU_512.equals(mCurrentAction)) {
                    mtu = 512;
                } else {
                    throw new IllegalStateException(""unexpected action: "" + mCurrentAction);
                }
                mBluetoothGatt.requestMtu(mtu);
            } else {
                showMessage(""Skip MTU test."");
                notifyMtuChanged();
            }
        }
    }

    private void writeCharacteristic(BluetoothGattCharacteristic characteristic, String writeValue) {
        if (characteristic != null) {
            characteristic.setValue(writeValue);
            mBluetoothGatt.writeCharacteristic(characteristic);
        }
    }

    private void writeCharacteristic(UUID uid, String writeValue) {
        BluetoothGattCharacteristic characteristic = getCharacteristic(uid);
        if (characteristic != null){
            writeCharacteristic(characteristic, writeValue);
        }
    }

    private void readCharacteristic(UUID uuid) {
        BluetoothGattCharacteristic characteristic = getCharacteristic(uuid);
        if (characteristic != null) {
            mBluetoothGatt.readCharacteristic(characteristic);
        }
    }

    private void writeDescriptor(UUID uid, String writeValue) {
        BluetoothGattDescriptor descriptor = getDescriptor(uid);
        if (descriptor != null) {
            descriptor.setValue(writeValue.getBytes());
            mBluetoothGatt.writeDescriptor(descriptor);
        }
    }

    private void readDescriptor(UUID uuid) {
        BluetoothGattDescriptor descriptor = getDescriptor(uuid);
        if (descriptor != null) {
            mBluetoothGatt.readDescriptor(descriptor);
        }
    }

    private void writeDescriptor(UUID cuid, UUID duid, String writeValue) {
        BluetoothGattDescriptor descriptor = getDescriptor(cuid, duid);
        if (descriptor != null) {
            descriptor.setValue(writeValue.getBytes());
            mBluetoothGatt.writeDescriptor(descriptor);
        }
    }

    private void readDescriptor(UUID cuid, UUID duid) {
        BluetoothGattDescriptor descriptor = getDescriptor(cuid, duid);
        if (descriptor != null) {
            mBluetoothGatt.readDescriptor(descriptor);
        }
    }

    private void notifyDisableNotificationCompletion() {
        synchronized (mRequestNotificationLock) {
            mRequestNotificationLock.notify();
        }
    }

    private void waitForDisableNotificationCompletion() {
        synchronized (mRequestNotificationLock) {
            try {
                mRequestNotificationLock.wait();
            } catch (InterruptedException e) {
                Log.e(TAG, ""Error in waitForDisableNotificationCompletion"" + e);
            }
        }
    }

    private void initializeServiceChangedEvent() {
        synchronized (mServiceChangedLock) {
            mServiceChangedFlag = SERVICE_CHANGED_FLAG_INIT;
        }
    }

    private void sendServiceChangedEventIfReady(int flag) {
        boolean shouldSend = false;
        synchronized (mServiceChangedLock) {
            mServiceChangedFlag |= flag;
            if (mServiceChangedFlag == SERVICE_CHANGED_FLAG_ALL) {
                mServiceChangedFlag |= SERVOCE_CHANGED_FLAG_IGNORE;
                shouldSend = true;
            }
        }

        if (shouldSend) {
            writeCharacteristic(getCharacteristic(CHARACTERISTIC_RESULT_UUID),
                SERVICE_CHANGED_VALUE);
            notifyServiceChanged();
        }
    }

    private void setNotification(BluetoothGattCharacteristic characteristic, boolean enable) {
        if (characteristic != null) {
            mBluetoothGatt.setCharacteristicNotification(characteristic, enable);
            BluetoothGattDescriptor descriptor = characteristic.getDescriptor(UPDATE_DESCRIPTOR_UUID);
            if (enable) {
                if (characteristic.getUuid().equals(INDICATE_CHARACTERISTIC_UUID)) {
                    descriptor.setValue(BluetoothGattDescriptor.ENABLE_INDICATION_VALUE);
                } else {
                    descriptor.setValue(BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE);
                }
            } else {
                descriptor.setValue(BluetoothGattDescriptor.DISABLE_NOTIFICATION_VALUE);
            }
            mBluetoothGatt.writeDescriptor(descriptor);
        }
    }

    private void setNotification(UUID serviceUid, UUID characteristicUid,  boolean enable) {
        BluetoothGattCharacteristic characteristic = getCharacteristic(serviceUid, characteristicUid);
        if (characteristic != null) {
            setNotification(characteristic, enable);
        }
    }

    private void setNotification(UUID uid, boolean enable) {
        BluetoothGattCharacteristic characteristic = getCharacteristic(uid);
        if (characteristic != null) {
           setNotification(characteristic, enable);
        }
    }

    private void notifyError(String message) {
        showMessage(message);
        Log.i(TAG, message);

        Intent intent = new Intent(BLE_CLIENT_ERROR);
        sendBroadcast(intent);
    }

    private void notifyMismatchSecure() {
        Intent intent = new Intent(BLE_BLUETOOTH_MISMATCH_SECURE);
        sendBroadcast(intent);
    }

    private void notifyMismatchInsecure() {
        Intent intent = new Intent(BLE_BLUETOOTH_MISMATCH_INSECURE);
        sendBroadcast(intent);
    }

    private void notifyBluetoothDisabled() {
        Intent intent = new Intent(BLE_BLUETOOTH_DISABLED);
        sendBroadcast(intent);
    }

    private void notifyConnected() {
        showMessage(""Bluetooth LE connected"");
        Intent intent = new Intent(BLE_BLUETOOTH_CONNECTED);
        sendBroadcast(intent);
    }

    private void notifyDisconnected() {
        showMessage(""Bluetooth LE disconnected"");
        Intent intent = new Intent(BLE_BLUETOOTH_DISCONNECTED);
        sendBroadcast(intent);
    }

    private void notifyServicesDiscovered() {
        showMessage(""Service discovered"");
        Intent intent = new Intent(BLE_SERVICES_DISCOVERED);
        sendBroadcast(intent);
    }

    private void notifyMtuChanged() {
        Intent intent;
        if (BLE_CLIENT_ACTION_REQUEST_MTU_23.equals(mCurrentAction)) {
            intent = new Intent(BLE_MTU_CHANGED_23BYTES);
        } else if (BLE_CLIENT_ACTION_REQUEST_MTU_512.equals(mCurrentAction)) {
            intent = new Intent(BLE_MTU_CHANGED_512BYTES);
        } else {
            throw new IllegalStateException(""unexpected action: "" + mCurrentAction);
        }
        sendBroadcast(intent);
    }

    private void notifyCharacteristicRead(String value) {
        showMessage(""Characteristic read: "" + value);
        Intent intent = new Intent(BLE_CHARACTERISTIC_READ);
        intent.putExtra(EXTRA_CHARACTERISTIC_VALUE, value);
        sendBroadcast(intent);
    }

    private void notifyCharacteristicWrite(String value) {
        showMessage(""Characteristic write: "" + value);
        Intent intent = new Intent(BLE_CHARACTERISTIC_WRITE);
        sendBroadcast(intent);
    }

    private void notifyCharacteristicReadNoPermission() {
        showMessage(""Characteristic not read: No Permission"");
        Intent intent = new Intent(BLE_CHARACTERISTIC_READ_NOPERMISSION);
        sendBroadcast(intent);
    }

    private void notifyCharacteristicWriteNoPermission(String value) {
        showMessage(""Characteristic write: No Permission"");
        Intent intent = new Intent(BLE_CHARACTERISTIC_WRITE_NOPERMISSION);
        sendBroadcast(intent);
    }

    private void notifyCharacteristicReadNeedEncrypted(String value) {
        showMessage(""Characteristic read with encrypted: "" + value);
        Intent intent = new Intent(BLE_CHARACTERISTIC_READ_NEED_ENCRYPTED);
        sendBroadcast(intent);
    }

    private void notifyCharacteristicWriteNeedEncrypted(String value) {
        showMessage(""Characteristic write with encrypted: "" + value);
        Intent intent = new Intent(BLE_CHARACTERISTIC_WRITE_NEED_ENCRYPTED);
        sendBroadcast(intent);
    }

    private void notifyCharacteristicChanged() {
        showMessage(""Characteristic changed"");
        Intent intent = new Intent(BLE_CHARACTERISTIC_CHANGED);
        sendBroadcast(intent);
    }

    private void notifyCharacteristicIndicated() {
        showMessage(""Characteristic Indicated"");
        Intent intent = new Intent(BLE_CHARACTERISTIC_INDICATED);
        sendBroadcast(intent);
    }

    private void notifyDescriptorRead(String value) {
        showMessage(""Descriptor read: "" + value);
        Intent intent = new Intent(BLE_DESCRIPTOR_READ);
        intent.putExtra(EXTRA_DESCRIPTOR_VALUE, value);
        sendBroadcast(intent);
    }

    private void notifyDescriptorWrite(String value) {
        showMessage(""Descriptor write: "" + value);
        Intent intent = new Intent(BLE_DESCRIPTOR_WRITE);
        sendBroadcast(intent);
    }

    private void notifyDescriptorReadNoPermission() {
        showMessage(""Descriptor read: No Permission"");
        Intent intent = new Intent(BLE_DESCRIPTOR_READ_NOPERMISSION);
        sendBroadcast(intent);
    }

    private void notifyDescriptorWriteNoPermission() {
        showMessage(""Descriptor write: NoPermission"");
        Intent intent = new Intent(BLE_DESCRIPTOR_WRITE_NOPERMISSION);
        sendBroadcast(intent);
    }

    private void notifyDescriptorReadNeedEncrypted(String value) {
        showMessage(""Descriptor read with encrypted: "" + value);
        Intent intent = new Intent(BLE_DESCRIPTOR_READ_NEED_ENCRYPTED);
        sendBroadcast(intent);
    }

    private void notifyDescriptorWriteNeedEncrypted(String value) {
        showMessage(""Descriptor write with encrypted: "" + value);
        Intent intent = new Intent(BLE_DESCRIPTOR_WRITE_NEED_ENCRYPTED);
        sendBroadcast(intent);
    }

    private void notifyReliableWriteCompleted() {
        showMessage(""Reliable write complete"");
        Intent intent = new Intent(BLE_RELIABLE_WRITE_COMPLETED);
        sendBroadcast(intent);
    }

    private void notifyReliableWriteBadRespCompleted(String err) {
        showMessage(""Reliable write(bad response) complete"");
        Intent intent = new Intent(BLE_RELIABLE_WRITE_BAD_RESP_COMPLETED);
        if (err != null) {
            intent.putExtra(EXTRA_ERROR_MESSAGE, err);
        }
        sendBroadcast(intent);
    }

    private void notifyReadRemoteRssi(int rssi) {
        showMessage(""Remote rssi read: "" + rssi);
        Intent intent = new Intent(BLE_READ_REMOTE_RSSI);
        intent.putExtra(EXTRA_RSSI_VALUE, rssi);
        sendBroadcast(intent);
    }

    private void notifyServiceChanged() {
        showMessage(""Remote service changed"");
        Intent intent = new Intent(BLE_ON_SERVICE_CHANGED);
        sendBroadcast(intent);
    }

    private BluetoothGattService getService(UUID serverUid) {
        BluetoothGattService service = null;

        if (mBluetoothGatt != null) {
            service = mBluetoothGatt.getService(serverUid);
            if (service == null) {
                showMessage(""Service not found"");
            }
        }
        return service;
    }

    private BluetoothGattService getService() {
        BluetoothGattService service = null;

        if (mBluetoothGatt != null) {
            service = mBluetoothGatt.getService(SERVICE_UUID);
            if (service == null) {
                showMessage(""Service not found"");
            }
        }
        return service;
    }

    private BluetoothGattCharacteristic getCharacteristic(UUID serverUid, UUID characteristicUid) {
        BluetoothGattCharacteristic characteristic = null;

        BluetoothGattService service = getService(serverUid);
        if (service != null) {
            characteristic = service.getCharacteristic(characteristicUid);
            if (characteristic == null) {
                showMessage(""Characteristic not found"");
            }
        }
        return characteristic;
    }
    private BluetoothGattCharacteristic getCharacteristic(UUID uuid) {
        BluetoothGattCharacteristic characteristic = null;

        BluetoothGattService service = getService();
        if (service != null) {
            characteristic = service.getCharacteristic(uuid);
            if (characteristic == null) {
                showMessage(""Characteristic not found"");
            }
        }
        return characteristic;
    }

    private BluetoothGattDescriptor getDescriptor(UUID uid) {
        BluetoothGattDescriptor descriptor = null;

        BluetoothGattCharacteristic characteristic = getCharacteristic(CHARACTERISTIC_UUID);
        if (characteristic != null) {
            descriptor = characteristic.getDescriptor(uid);
            if (descriptor == null) {
                showMessage(""Descriptor not found"");
            }
        }
        return descriptor;
    }

    private BluetoothGattDescriptor getDescriptor(UUID cuid, UUID duid) {
        BluetoothGattDescriptor descriptor = null;

        BluetoothGattCharacteristic characteristic = getCharacteristic(cuid);
        if (characteristic != null) {
            descriptor = characteristic.getDescriptor(duid);
            if (descriptor == null) {
                showMessage(""Descriptor not found"");
            }
        }
        return descriptor;
    }

    private void showMessage(final String msg) {
        mHandler.post(new Runnable() {
            public void run() {
                Toast.makeText(BleClientService.this, msg, Toast.LENGTH_SHORT).show();
            }
        });
    }

    private void sleep(int millis) {
        try {
            Thread.sleep(millis);
        } catch (InterruptedException e) {
            Log.e(TAG, ""Error in thread sleep"", e);
        }
    }

    private void reliableWrite() {
        // aborting test
        mBluetoothGatt.beginReliableWrite();
        sleep(1000);
        mBluetoothGatt.abortReliableWrite();

        // writing test
        sleep(2000);
        mBluetoothGatt.beginReliableWrite();
        sleep(1000);

        if (BLE_CLIENT_ACTION_RELIABLE_WRITE.equals(mCurrentAction)) {
            mExecReliableWrite = ReliableWriteState.RELIABLE_WRITE_WRITE_1ST_DATA;
            writeCharacteristic(CHARACTERISTIC_UUID, WRITE_VALUE_507BYTES_FOR_RELIABLE_WRITE);
        } else {
            mExecReliableWrite = ReliableWriteState.RELIABLE_WRITE_BAD_RESP;
            writeCharacteristic(CHARACTERISTIC_UUID, WRITE_VALUE_BAD_RESP);
        }
    }

    private int mBleState = BluetoothProfile.STATE_DISCONNECTED;
    private final BluetoothGattCallback mGattCallbacks = new BluetoothGattCallback() {
        @Override
        public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) {
            if (DEBUG) Log.d(TAG, ""onConnectionStateChange: status= "" + status + "", newState= "" + newState);
            if (status == BluetoothGatt.GATT_SUCCESS) {
                if (newState == BluetoothProfile.STATE_CONNECTED) {
                    mBleState = newState;
                    int bond = gatt.getDevice().getBondState();
                    boolean bonded = false;
                    BluetoothDevice target = gatt.getDevice();
                    Set<BluetoothDevice> pairedDevices = mBluetoothAdapter.getBondedDevices();
                    if (pairedDevices.size() > 0) {
                        for (BluetoothDevice device : pairedDevices) {
                            if (device.getAddress().equals(target.getAddress())) {
                                bonded = true;
                                break;
                            }
                        }
                    }
                    if (mSecure && ((bond == BluetoothDevice.BOND_NONE) || !bonded)) {
                        // not pairing and execute Secure Test
                        mBluetoothGatt.disconnect();
                        notifyMismatchSecure();
                    } else if (!mSecure && ((bond != BluetoothDevice.BOND_NONE) || bonded)) {
                        // already pairing nad execute Insecure Test
                        mBluetoothGatt.disconnect();
                        notifyMismatchInsecure();
                    } else {
                        notifyConnected();
                    }
                } else if (status == BluetoothProfile.STATE_DISCONNECTED) {
                    mBleState = newState;
                    mSecure = false;
                    mBluetoothGatt.close();
                    notifyDisconnected();
                }
            } else {
                showMessage(""Failed to connect: "" + status + "" , newState = "" + newState);
                mBluetoothGatt.close();
                mBluetoothGatt = null;
            }
        }

        @Override
        public void onServicesDiscovered(BluetoothGatt gatt, int status) {
            if (DEBUG){
                Log.d(TAG, ""onServiceDiscovered"");
            }
            if ((status == BluetoothGatt.GATT_SUCCESS) && (mBluetoothGatt.getService(SERVICE_UUID) != null)) {
                notifyServicesDiscovered();
            }
        }

        @Override
        public void onMtuChanged(BluetoothGatt gatt, int mtu, int status) {
            super.onMtuChanged(gatt, mtu, status);
            if (DEBUG){
                Log.d(TAG, ""onMtuChanged"");
            }
            if (status == BluetoothGatt.GATT_SUCCESS) {
                // verify MTU size
                int requestedMtu;
                if (BLE_CLIENT_ACTION_REQUEST_MTU_23.equals(mCurrentAction)) {
                    requestedMtu = 23;
                } else if (BLE_CLIENT_ACTION_REQUEST_MTU_512.equals(mCurrentAction)) {
                    requestedMtu = 512;
                } else {
                    throw new IllegalStateException(""unexpected action: "" + mCurrentAction);
                }
                if (mtu != requestedMtu) {
                    String msg = String.format(getString(R.string.ble_mtu_mismatch_message),
                            requestedMtu, mtu);
                    showMessage(msg);
                }

                // test writing characteristic
                writeCharacteristic(CHARACTERISTIC_UUID, WRITE_VALUE_512BYTES_FOR_MTU);
            } else {
                notifyError(""Failed to request mtu: "" + status);
            }
        }

        @Override
        public void onCharacteristicWrite(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, final int status) {
            String value = characteristic.getStringValue(0);
            final UUID uid = characteristic.getUuid();
            if (DEBUG) {
                Log.d(TAG, ""onCharacteristicWrite: characteristic.val="" + value + "" status="" + status);
            }

            if (BLE_CLIENT_ACTION_TRIGGER_SERVICE_CHANGED.equals(mCurrentAction)) {
                sendServiceChangedEventIfReady(SERVICE_CHANGED_FLAG_TRIGGER_ACTION);
            } else if (BLE_CLIENT_ACTION_REQUEST_MTU_512.equals(mCurrentAction) ||
                    BLE_CLIENT_ACTION_REQUEST_MTU_23.equals(mCurrentAction)) {
                if (status == BluetoothGatt.GATT_SUCCESS) {
                    notifyMtuChanged();
                } else {
                    notifyError(""Failed to write characteristic: "" + status + "" : "" + uid);
                }
            } else {
                switch (mExecReliableWrite) {
                    case RELIABLE_WRITE_NONE:
                        if (status == BluetoothGatt.GATT_SUCCESS) {
                            if (characteristic.getUuid().equals(CHARACTERISTIC_NEED_ENCRYPTED_WRITE_UUID)) {
                                notifyCharacteristicWriteNeedEncrypted(value);
                            } else if (!characteristic.getUuid().equals(CHARACTERISTIC_RESULT_UUID)) {
                                // verify
                                if (Arrays.equals(BleClientService.WRITE_VALUE.getBytes(), characteristic.getValue())) {
                                    notifyCharacteristicWrite(value);
                                } else {
                                    notifyError(""Written data is not correct"");
                                }
                            }
                        } else if (status == BluetoothGatt.GATT_WRITE_NOT_PERMITTED) {
                            if (uid.equals(CHARACTERISTIC_NO_WRITE_UUID)) {
                                writeCharacteristic(getCharacteristic(CHARACTERISTIC_RESULT_UUID), BleServerService.WRITE_NO_PERMISSION);
                                notifyCharacteristicWriteNoPermission(value);
                            } else {
                                notifyError(""Not Permission Write: "" + status + "" : "" + uid);
                            }
                        } else if (status == BluetoothGatt.GATT_INSUFFICIENT_AUTHENTICATION) {
                            notifyError(""Not Authentication Write: "" + status + "" : "" + uid);
                        } else {
                            notifyError(""Failed to write characteristic: "" + status + "" : "" + uid);
                        }
                        break;
                    case RELIABLE_WRITE_WRITE_1ST_DATA:
                        // verify
                        if (WRITE_VALUE_507BYTES_FOR_RELIABLE_WRITE.equals(value)) {
                            // write next data
                            mExecReliableWrite = ReliableWriteState.RELIABLE_WRITE_WRITE_2ND_DATA;
                            writeCharacteristic(CHARACTERISTIC_UUID, WRITE_VALUE_507BYTES_FOR_RELIABLE_WRITE);
                        } else {
                            notifyError(""Failed to write characteristic: "" + status + "" : "" + uid);
                        }
                        break;
                    case RELIABLE_WRITE_WRITE_2ND_DATA:
                        // verify
                        if (WRITE_VALUE_507BYTES_FOR_RELIABLE_WRITE.equals(value)) {
                            // execute write
                            mTaskQueue.addTask(new Runnable() {
                                @Override
                                public void run() {
                                    mExecReliableWrite = ReliableWriteState.RELIABLE_WRITE_EXECUTE;
                                    if (!mBluetoothGatt.executeReliableWrite()) {
                                        notifyError(""reliable write failed"");
                                    }
                                }
                            }, 1000);
                        } else {
                            notifyError(""Failed to write characteristic: "" + status + "" : "" + uid);
                        }
                        break;
                    case RELIABLE_WRITE_BAD_RESP:
                        mExecReliableWrite = ReliableWriteState.RELIABLE_WRITE_NONE;
                        // verify response
                        //   Server sends empty response for this test.
                        //   Response must be empty.
                        String err = null;
                        if (!TextUtils.isEmpty(value)) {
                            err = ""response is not empty"";
                            showMessage(err);
                        }
                        // finish reliable write
                        final String errValue = err;
                        mTaskQueue.addTask(new Runnable() {
                            @Override
                            public void run() {
                                mBluetoothGatt.abortReliableWrite();
                                notifyReliableWriteBadRespCompleted(errValue);
                            }
                        }, 1000);
                        break;
                }
            }
        }

        @Override
        public void onCharacteristicRead(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) {
            UUID uid = characteristic.getUuid();
            if (DEBUG) {
                Log.d(TAG, ""onCharacteristicRead: status="" + status);
            }
            if (status == BluetoothGatt.GATT_SUCCESS) {
                String value = characteristic.getStringValue(0);
                if (characteristic.getUuid().equals(CHARACTERISTIC_NEED_ENCRYPTED_READ_UUID)) {
                    notifyCharacteristicReadNeedEncrypted(value);
                } else {
                    // verify
                    if (BleServerService.WRITE_VALUE.equals(value)) {
                        notifyCharacteristicRead(value);
                    } else {
                        notifyError(""Read data is not correct"");
                    }
                }
            } else if (status == BluetoothGatt.GATT_READ_NOT_PERMITTED) {
                if (uid.equals(CHARACTERISTIC_NO_READ_UUID)) {
                    writeCharacteristic(getCharacteristic(CHARACTERISTIC_RESULT_UUID), BleServerService.READ_NO_PERMISSION);
                    notifyCharacteristicReadNoPermission();
                } else {
                    notifyError(""Not Permission Read: "" + status + "" : "" + uid);
                }
            } else if(status == BluetoothGatt.GATT_INSUFFICIENT_AUTHENTICATION) {
                notifyError(""Not Authentication Read: "" + status + "" : "" + uid);
            } else {
                notifyError(""Failed to read characteristic: "" + status + "" : "" + uid);
            }
        }

        @Override
        public void onDescriptorWrite(BluetoothGatt gatt, BluetoothGattDescriptor descriptor, int status) {
            if (DEBUG) {
                Log.d(TAG, ""onDescriptorWrite"");
            }
            UUID uid = descriptor.getUuid();
            if ((status == BluetoothGatt.GATT_SUCCESS)) {
                if (uid.equals(UPDATE_DESCRIPTOR_UUID)) {
                    Log.d(TAG, ""write in update descriptor."");
                    if (descriptor.getValue() == BluetoothGattDescriptor.DISABLE_NOTIFICATION_VALUE) {
                        notifyDisableNotificationCompletion();
                    }
                } else if (uid.equals(DESCRIPTOR_UUID)) {
                    // verify
                    if (Arrays.equals(WRITE_VALUE.getBytes(), descriptor.getValue())) {
                        notifyDescriptorWrite(new String(descriptor.getValue()));
                    } else {
                        notifyError(""Written data is not correct"");
                    }
                } else if (uid.equals(DESCRIPTOR_NEED_ENCRYPTED_WRITE_UUID)) {
                    notifyDescriptorWriteNeedEncrypted(new String(descriptor.getValue()));
                }
            } else if (status == BluetoothGatt.GATT_WRITE_NOT_PERMITTED) {
                if (uid.equals(DESCRIPTOR_NO_WRITE_UUID)) {
                    writeCharacteristic(getCharacteristic(CHARACTERISTIC_RESULT_UUID), BleServerService.DESCRIPTOR_WRITE_NO_PERMISSION);
                    notifyDescriptorWriteNoPermission();
                } else {
                    notifyError(""Not Permission Write: "" + status + "" : "" + descriptor.getUuid());
                }
            } else {
                notifyError(""Failed to write descriptor"");
            }
        }

        @Override
        public void onDescriptorRead(BluetoothGatt gatt, BluetoothGattDescriptor descriptor, int status) {
            if (DEBUG) {
                Log.d(TAG, ""onDescriptorRead"");
            }

            UUID uid = descriptor.getUuid();
            if ((status == BluetoothGatt.GATT_SUCCESS)) {
                if ((uid != null) && (uid.equals(DESCRIPTOR_UUID))) {
                    // verify
                    if (Arrays.equals(BleServerService.WRITE_VALUE.getBytes(), descriptor.getValue())) {
                        notifyDescriptorRead(new String(descriptor.getValue()));
                    } else {
                        notifyError(""Read data is not correct"");
                    }
                } else if (uid.equals(DESCRIPTOR_NEED_ENCRYPTED_READ_UUID)) {
                    notifyDescriptorReadNeedEncrypted(new String(descriptor.getValue()));
                }
            } else if (status == BluetoothGatt.GATT_READ_NOT_PERMITTED) {
                if (uid.equals(DESCRIPTOR_NO_READ_UUID)) {
                    writeCharacteristic(getCharacteristic(CHARACTERISTIC_RESULT_UUID), BleServerService.DESCRIPTOR_READ_NO_PERMISSION);
                    notifyDescriptorReadNoPermission();
                } else {
                    notifyError(""Not Permission Read: "" + status + "" : "" + descriptor.getUuid());
                }
            } else {
                notifyError(""Failed to read descriptor: "" + status);
            }
        }

        @Override
        public void onCharacteristicChanged(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic) {
            UUID uid = characteristic.getUuid();
            if (DEBUG) {
                Log.d(TAG, ""onCharacteristicChanged: "" + uid);
            }
            if (uid != null) {
                if (uid.equals(INDICATE_CHARACTERISTIC_UUID)) {
                    setNotification(characteristic, false);
                    notifyCharacteristicIndicated();
                } else {
                    mNotifyCount--;
                    setNotification(characteristic, false);
                    if (mNotifyCount == 0) {
                        notifyCharacteristicChanged();
                    }
                }
            }
        }

        @Override
        public void onReliableWriteCompleted(BluetoothGatt gatt, int status) {
            if (DEBUG) {
                Log.d(TAG, ""onReliableWriteComplete: "" + status);
            }

            if (mExecReliableWrite != ReliableWriteState.RELIABLE_WRITE_NONE) {
                if (status == BluetoothGatt.GATT_SUCCESS) {
                    notifyReliableWriteCompleted();
                } else {
                    notifyError(""Failed to complete reliable write: "" + status);
                }
                mExecReliableWrite = ReliableWriteState.RELIABLE_WRITE_NONE;
            }
        }

        @Override
        public void onReadRemoteRssi(BluetoothGatt gatt, int rssi, int status) {
            if (DEBUG) {
                Log.d(TAG, ""onReadRemoteRssi"");
            }
            if (status == BluetoothGatt.GATT_SUCCESS) {
                notifyReadRemoteRssi(rssi);
            } else {
                notifyError(""Failed to read remote rssi"");
            }
        }

        @Override
        public void onServiceChanged(BluetoothGatt gatt) {
            if (DEBUG) {
                Log.d(TAG, ""onServiceChanged"");
            }

            if (BLE_CLIENT_ACTION_TRIGGER_SERVICE_CHANGED.equals(mCurrentAction)) {
                sendServiceChangedEventIfReady(SERVICE_CHANGED_FLAG_ON_SERVICE_CHANGED);
            }
        }
    };

    private final ScanCallback mScanCallback = new ScanCallback() {
        @Override
        public void onScanResult(int callbackType, ScanResult result) {
            if (mBluetoothGatt == null) {
                // verify the validity of the advertisement packet.
                mValidityService = false;
                List<ParcelUuid> uuids = result.getScanRecord().getServiceUuids();
                for (ParcelUuid uuid : uuids) {
                    if (uuid.getUuid().equals(BleServerService.ADV_SERVICE_UUID)) {
                        mValidityService = true;
                        break;
                    }
                }
                if (mValidityService) {
                    stopScan();

                    BluetoothDevice device = result.getDevice();
                    if (mSecure) {
                        if (device.getBondState() != BluetoothDevice.BOND_BONDED) {
                            if (!device.createBond()) {
                                notifyError(""Failed to call create bond"");
                            }
                        } else {
                            mBluetoothGatt = connectGatt(result.getDevice(), mContext, false, mSecure, mGattCallbacks);
                        }
                    } else {
                        mBluetoothGatt = connectGatt(result.getDevice(), mContext, false, mSecure, mGattCallbacks);
                    }
                } else {
                    notifyError(""There is no validity to Advertise servie."");
                }
            }
        }
    };

    private void startScan() {
        if (DEBUG) Log.d(TAG, ""startScan"");
        List<ScanFilter> filter = Arrays.asList(new ScanFilter.Builder().setServiceUuid(
                new ParcelUuid(BleServerService.ADV_SERVICE_UUID)).build());
        ScanSettings setting = new ScanSettings.Builder()
                .setScanMode(ScanSettings.SCAN_MODE_LOW_LATENCY).build();
        mScanner.startScan(filter, setting, mScanCallback);
    }

    private void stopScan() {
        if (DEBUG) Log.d(TAG, ""stopScan"");
        if (mScanner != null) {
            mScanner.stopScan(mScanCallback);
        }
    }

    private static String createTestData(int length) {
        StringBuilder builder = new StringBuilder();
        builder.append(""REQUEST_MTU"");
        int len = length - builder.length();
        for (int i = 0; i < len; ++i) {
            builder.append(""""+(i%10));
        }
        return builder.toString();
    }

    private final BroadcastReceiver mBondStatusReceiver = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            if (intent.getAction().equals(BluetoothDevice.ACTION_BOND_STATE_CHANGED)) {
                BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
                int state = intent.getIntExtra(BluetoothDevice.EXTRA_BOND_STATE, BluetoothDevice.BOND_NONE);
                switch (state) {
                    case BluetoothDevice.BOND_BONDED:
                        if ((mBluetoothGatt == null) &&
                            (device.getType() != BluetoothDevice.DEVICE_TYPE_CLASSIC)) {
                            if (DEBUG) {
                                Log.d(TAG, ""onReceive:BOND_BONDED: calling connectGatt device=""
                                             + device + "", mSecure="" + mSecure);
                            }
                            mBluetoothGatt = connectGatt(device, mContext, false, mSecure,
                                                         mGattCallbacks);
                        }
                        break;
                    case BluetoothDevice.BOND_NONE:
                        notifyError(""Failed to create bond."");
                        break;
                    case BluetoothDevice.BOND_BONDING:
                    default:    // fall through
                        // wait for next state
                        break;
                }
            }
        }
    };
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.bluetooth.BleEncryptedClientService"	"disconnect"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/bluetooth/BleEncryptedClientService.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.bluetooth;

import android.app.Service;
import android.bluetooth.BluetoothAdapter;
import android.bluetooth.BluetoothDevice;
import android.bluetooth.BluetoothGatt;
import android.bluetooth.BluetoothGattCallback;
import android.bluetooth.BluetoothGattCharacteristic;
import android.bluetooth.BluetoothGattDescriptor;
import android.bluetooth.BluetoothGattService;
import android.bluetooth.BluetoothManager;
import android.bluetooth.BluetoothProfile;
import android.bluetooth.le.BluetoothLeScanner;
import android.bluetooth.le.ScanCallback;
import android.bluetooth.le.ScanFilter;
import android.bluetooth.le.ScanResult;
import android.bluetooth.le.ScanSettings;
import android.content.Context;
import android.content.Intent;
import android.os.Handler;
import android.os.IBinder;
import android.os.ParcelUuid;
import android.util.Log;
import android.widget.Toast;

import java.util.Arrays;
import java.util.List;
import java.util.UUID;

public class BleEncryptedClientService extends Service {
    public static final boolean DEBUG = true;
    public static final String TAG = ""BleEncryptedClient"";

    public static final String ACTION_CONNECT_WITH_SECURE =
            ""com.android.cts.verifier.bluetooth.encripted.action.ACTION_CONNECT_WITH_SECURE"";
    public static final String ACTION_CONNECT_WITHOUT_SECURE =
            ""com.android.cts.verifier.bluetooth.encripted.action.ACTION_CONNECT_WITHOUT_SECURE"";

    public static final String INTENT_BLE_BLUETOOTH_DISABLED =
            ""com.android.cts.verifier.bluetooth.encripted.intent.BLE_BLUETOOTH_DISABLED"";
    public static final String INTENT_BLE_WRITE_ENCRYPTED_CHARACTERISTIC =
            ""com.android.cts.verifier.bluetooth.encripted.intent.BLE_WRITE_ENCRYPTED_CHARACTERISTIC"";
    public static final String INTENT_BLE_WRITE_NOT_ENCRYPTED_CHARACTERISTIC =
            ""com.android.cts.verifier.bluetooth.encripted.intent.BLE_WRITE_NOT_ENCRYPTED_CHARACTERISTIC"";
    public static final String INTENT_BLE_READ_ENCRYPTED_CHARACTERISTIC =
            ""com.android.cts.verifier.bluetooth.encripted.intent.BLE_READ_ENCRYPTED_CHARACTERISTIC"";
    public static final String INTENT_BLE_READ_NOT_ENCRYPTED_CHARACTERISTIC =
            ""com.android.cts.verifier.bluetooth.encripted.intent.BLE_READ_NOT_ENCRYPTED_CHARACTERISTIC"";
    public static final String INTENT_BLE_WRITE_ENCRYPTED_DESCRIPTOR =
            ""com.android.cts.verifier.bluetooth.encripted.intent.BLE_WRITE_ENCRYPTED_DESCRIPTOR"";
    public static final String INTENT_BLE_WRITE_NOT_ENCRYPTED_DESCRIPTOR =
            ""com.android.cts.verifier.bluetooth.encripted.intent.BLE_WRITE_NOT_ENCRYPTED_DESCRIPTOR"";
    public static final String INTENT_BLE_READ_ENCRYPTED_DESCRIPTOR =
            ""com.android.cts.verifier.bluetooth.encripted.intent.BLE_READ_ENCRYPTED_DESCRIPTOR"";
    public static final String INTENT_BLE_READ_NOT_ENCRYPTED_DESCRIPTOR =
            ""com.android.cts.verifier.bluetooth.encripted.intent.BLE_READ_NOT_ENCRYPTED_DESCRIPTOR"";
    public static final String INTENT_BLE_WRITE_FAIL_ENCRYPTED_CHARACTERISTIC =
            ""com.android.cts.verifier.bluetooth.encripted.intent.INTENT_BLE_WRITE_FAIL_ENCRYPTED_CHARACTERISTIC"";
    public static final String INTENT_BLE_READ_FAIL_ENCRYPTED_CHARACTERISTIC =
            ""com.android.cts.verifier.bluetooth.encripted.intent.INTENT_BLE_READ_FAIL_ENCRYPTED_CHARACTERISTIC"";
    public static final String INTENT_BLE_WRITE_FAIL_ENCRYPTED_DESCRIPTOR =
            ""com.android.cts.verifier.bluetooth.encripted.intent.INTENT_BLE_WRITE_FAIL_ENCRYPTED_DESCRIPTOR"";
    public static final String INTENT_BLE_READ_FAIL_ENCRYPTED_DESCRIPTOR =
            ""com.android.cts.verifier.bluetooth.encripted.intent.INTENT_BLE_READ_FAIL_ENCRYPTED_DESCRIPTOR"";

    public static final String ACTION_WRITE_ENCRYPTED_CHARACTERISTIC =
            ""com.android.cts.verifier.bluetooth.encripted.action.WRITE_ENCRYPTED_CHARACTERISTIC"";
    public static final String ACTION_READ_ENCRYPTED_CHARACTERISTIC =
            ""com.android.cts.verifier.bluetooth.encripted.action.READ_ENCRYPTED_CHARACTERISTIC"";
    public static final String ACTION_WRITE_ENCRYPTED_DESCRIPTOR =
            ""com.android.cts.verifier.bluetooth.encripted.action.WRITE_ENCRYPTED_DESCRIPTOR"";
    public static final String ACTION_READ_ENCRYPTED_DESCRIPTOR =
            ""com.android.cts.verifier.bluetooth.encripted.action.READ_ENCRYPTED_DESCRIPTOR"";

    public static final String ACTION_DISCONNECTED =
            ""com.android.cts.verifier.bluetooth.encripted.action.DISCONNECTED"";

    public static final String WRITE_VALUE = ""ENC_CLIENT_TEST"";

    private static final UUID SERVICE_UUID =
            UUID.fromString(""00009999-0000-1000-8000-00805f9b34fb"");
    private static final UUID CHARACTERISTIC_UUID =
            UUID.fromString(""00009998-0000-1000-8000-00805f9b34fb"");
    private static final UUID DESCRIPTOR_UUID =
            UUID.fromString(""00009997-0000-1000-8000-00805f9b34fb"");
    private static final UUID CHARACTERISTIC_ENCRYPTED_WRITE_UUID =
            UUID.fromString(""00009996-0000-1000-8000-00805f9b34fb"");
    private static final UUID CHARACTERISTIC_ENCRYPTED_READ_UUID =
            UUID.fromString(""00009995-0000-1000-8000-00805f9b34fb"");
    private static final UUID DESCRIPTOR_ENCRYPTED_WRITE_UUID =
            UUID.fromString(""00009994-0000-1000-8000-00805f9b34fb"");
    private static final UUID DESCRIPTOR_ENCRYPTED_READ_UUID =
            UUID.fromString(""00009993-0000-1000-8000-00805f9b34fb"");

    private BluetoothManager mBluetoothManager;
    private BluetoothAdapter mBluetoothAdapter;
    private BluetoothGatt mBluetoothGatt;
    private BluetoothLeScanner mScanner;
    private BluetoothDevice mDevice;
    private Handler mHandler;
    private Context mContext;
    private String mAction;
    private boolean mSecure;
    private String mTarget;

    private String mLastScanError;
    private TestTaskQueue mTaskQueue;

    public BleEncryptedClientService() {
    }

    @Override
    public IBinder onBind(Intent intent) {
        return null;
    }

    @Override
    public void onCreate() {
        super.onCreate();

        mTaskQueue = new TestTaskQueue(getClass().getName() + ""_enc_cli_taskHandlerThread"");

        mBluetoothManager = (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE);
        mBluetoothAdapter = mBluetoothManager.getAdapter();

        mScanner = mBluetoothAdapter.getBluetoothLeScanner();
        mHandler = new Handler();
        mContext = this;
        mSecure = false;
    }

    @Override
    public void onDestroy() {
        super.onDestroy();

        mTaskQueue.quit();

        if (mBluetoothGatt != null) {
            mBluetoothGatt.disconnect();
            mBluetoothGatt.close();
            mBluetoothGatt = null;
            mDevice = null;
        }
        stopScan();
    }

    private void notifyBluetoothDisabled() {
        Intent intent = new Intent(INTENT_BLE_BLUETOOTH_DISABLED);
        sendBroadcast(intent);
    }

    private void notifyDisconnected() {
        Intent intent = new Intent(ACTION_DISCONNECTED);
        sendBroadcast(intent);
    }

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        if (!mBluetoothAdapter.isEnabled()) {
            notifyBluetoothDisabled();
        } else {
            if (intent != null) {
                mAction = intent.getAction();
                if (mAction == null) {
                    mSecure = intent.getBooleanExtra(BleEncryptedServerService.EXTRA_SECURE, false);
                } else {
                    switch (mAction) {
                    case ACTION_CONNECT_WITH_SECURE:
                        mSecure = true;
                        break;
                    case ACTION_CONNECT_WITHOUT_SECURE:
                        mSecure = false;
                        break;
                    case ACTION_WRITE_ENCRYPTED_CHARACTERISTIC:
                        mTarget = BleEncryptedServerService.WRITE_CHARACTERISTIC;
                        startScan();
                        break;
                    case ACTION_READ_ENCRYPTED_CHARACTERISTIC:
                        mTarget = BleEncryptedServerService.READ_CHARACTERISTIC;
                        startScan();
                        break;
                    case ACTION_WRITE_ENCRYPTED_DESCRIPTOR:
                        mTarget = BleEncryptedServerService.WRITE_DESCRIPTOR;
                        startScan();
                        break;
                    case ACTION_READ_ENCRYPTED_DESCRIPTOR:
                        mTarget = BleEncryptedServerService.READ_DESCRIPTOR;
                        startScan();
                        break;
                    default:
                        return START_NOT_STICKY;
                    }
                }
            }
        }
        return START_NOT_STICKY;
    }

    private BluetoothGattService getService() {
        BluetoothGattService service = null;

        if (mBluetoothGatt != null) {
            service = mBluetoothGatt.getService(SERVICE_UUID);
            if (service == null) {
                showMessage(""Service not found"");
            }
        }
        return service;
    }

    private BluetoothGattCharacteristic getCharacteristic(UUID uuid) {
        BluetoothGattCharacteristic characteristic = null;

        BluetoothGattService service = getService();
        if (service != null) {
            characteristic = service.getCharacteristic(uuid);
            if (characteristic == null) {
                showMessage(""Characteristic not found"");
            }
        }
        return characteristic;
    }

    private BluetoothGattDescriptor getDescriptor(UUID uid) {
        BluetoothGattDescriptor descriptor = null;

        BluetoothGattCharacteristic characteristic = getCharacteristic(CHARACTERISTIC_UUID);
        if (characteristic != null) {
            descriptor = characteristic.getDescriptor(uid);
            if (descriptor == null) {
                showMessage(""Descriptor not found"");
            }
        }
        return descriptor;
    }

    private void sleep(int millis) {
        try {
            Thread.sleep(millis);
        } catch (InterruptedException e) {
            Log.e(TAG, ""Error in thread sleep"", e);
        }
    }

    private void startEncryptedAction() {
        BluetoothGattCharacteristic characteristic;
        BluetoothGattCharacteristic caseCharacteristic;
        BluetoothGattDescriptor descriptor;
        switch (mTarget) {
        case BleEncryptedServerService.WRITE_CHARACTERISTIC:
            Log.v(TAG, ""WRITE_CHARACTERISTIC"");
            characteristic = getCharacteristic(CHARACTERISTIC_ENCRYPTED_WRITE_UUID);
            characteristic.setValue(WRITE_VALUE);
            mBluetoothGatt.writeCharacteristic(characteristic);
            break;
        case BleEncryptedServerService.READ_CHARACTERISTIC:
            Log.v(TAG, ""READ_CHARACTERISTIC"");
            characteristic = getCharacteristic(CHARACTERISTIC_ENCRYPTED_READ_UUID);
            mBluetoothGatt.readCharacteristic(characteristic);
            break;
        case BleEncryptedServerService.WRITE_DESCRIPTOR:
            Log.v(TAG, ""WRITE_DESCRIPTOR"");
            descriptor = getDescriptor(DESCRIPTOR_ENCRYPTED_WRITE_UUID);
            descriptor.setValue(WRITE_VALUE.getBytes());
            mBluetoothGatt.writeDescriptor(descriptor);
            break;
        case BleEncryptedServerService.READ_DESCRIPTOR:
            Log.v(TAG, ""READ_DESCRIPTOR"");
            descriptor = getDescriptor(DESCRIPTOR_ENCRYPTED_READ_UUID);
            mBluetoothGatt.readDescriptor(descriptor);
            break;
        }
    }

    private void showMessage(final String msg) {
        mHandler.post(new Runnable() {
            public void run() {
                Toast.makeText(BleEncryptedClientService.this, msg, Toast.LENGTH_SHORT).show();
            }
        });
    }

    private final BluetoothGattCallback mGattCallbacks = new BluetoothGattCallback() {
        @Override
        public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) {
            if (DEBUG) Log.d(TAG, ""onConnectionStateChange: status = "" + status + "", newState = "" + newState);
            if (status == BluetoothGatt.GATT_SUCCESS) {
                if (newState == BluetoothProfile.STATE_CONNECTED) {
                    showMessage(""Bluetooth LE connected"");
                    mTaskQueue.addTask(new Runnable() {
                        @Override
                        public void run() {
                            mBluetoothGatt.discoverServices();
                        }
                    }, 1000);
                } else if (newState == BluetoothProfile.STATE_DISCONNECTED) {
                    showMessage(""Bluetooth LE disconnected"");
                    mTaskQueue.addTask(new Runnable() {
                        @Override
                        public void run() {
                            if (mBluetoothGatt != null) {
                                mBluetoothGatt.close();
                                mBluetoothGatt = null;
                                mTarget = null;
                                mDevice = null;
                                notifyDisconnected();
                            }
                        }
                    }, 1000);
                }
            } else {
                showMessage(""Connection Not Success."");
                if (mTarget != null) {
                    Intent intent;
                    switch (mTarget) {
                    case BleEncryptedServerService.READ_CHARACTERISTIC:
                        intent = new Intent(INTENT_BLE_READ_FAIL_ENCRYPTED_CHARACTERISTIC);
                        break;
                    case BleEncryptedServerService.WRITE_CHARACTERISTIC:
                        if (mSecure) {
                            intent = new Intent(INTENT_BLE_WRITE_FAIL_ENCRYPTED_CHARACTERISTIC);
                        } else {
                            intent = new Intent(INTENT_BLE_WRITE_ENCRYPTED_CHARACTERISTIC);
                        }
                        break;
                    case BleEncryptedServerService.READ_DESCRIPTOR:
                        intent = new Intent(INTENT_BLE_READ_FAIL_ENCRYPTED_DESCRIPTOR);
                        break;
                    case BleEncryptedServerService.WRITE_DESCRIPTOR:
                        if (mSecure) {
                            intent = new Intent(INTENT_BLE_WRITE_FAIL_ENCRYPTED_DESCRIPTOR);
                        } else {
                            intent = new Intent(INTENT_BLE_WRITE_ENCRYPTED_DESCRIPTOR);
                        }
                        break;
                    default:
                        return;
                    }
                    if (mBluetoothGatt != null) {
                        mBluetoothGatt.close();
                        mBluetoothGatt = null;
                        mDevice = null;
                        mTarget = null;
                    }
                    sendBroadcast(intent);
                }
            }
        }

        @Override
        public void onServicesDiscovered(BluetoothGatt gatt, int status) {
            if (DEBUG){
                Log.d(TAG, ""onServiceDiscovered"");
            }
            if ((status == BluetoothGatt.GATT_SUCCESS) && (mBluetoothGatt.getService(SERVICE_UUID) != null)) {
                showMessage(""Service discovered"");
                startEncryptedAction();
            }
        }

        @Override
        public void onCharacteristicWrite(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, final int status) {
            final String value = characteristic.getStringValue(0);
            UUID uid = characteristic.getUuid();
            if (DEBUG) {
                Log.d(TAG, ""onCharacteristicWrite: characteristic.val="" + value + "" status="" + status + "" uid="" + uid);
            }

            if (uid.equals(CHARACTERISTIC_ENCRYPTED_WRITE_UUID)) {
                mTaskQueue.addTask(new Runnable() {
                    @Override
                    public void run() {
                        if (status == BluetoothGatt.GATT_SUCCESS) {
                            if (mSecure) {
                                mBluetoothGatt.disconnect();
                                if (WRITE_VALUE.equals(value)) {
                                    Intent intent = new Intent(INTENT_BLE_WRITE_ENCRYPTED_CHARACTERISTIC);
                                    sendBroadcast(intent);
                                } else {
                                    showMessage(""Written data is not correct"");
                                }
                            }
                        } else {
                            if (!mSecure) {
                                mBluetoothGatt.disconnect();
                                Intent intent = new Intent(INTENT_BLE_WRITE_NOT_ENCRYPTED_CHARACTERISTIC);
                                sendBroadcast(intent);
                            } else {
                                mBluetoothGatt.disconnect();
                                Intent intent = new Intent(INTENT_BLE_WRITE_FAIL_ENCRYPTED_CHARACTERISTIC);
                                sendBroadcast(intent);
                            }
                        }
                    }
                }, 1000);
            }
        }

        @Override
        public void onCharacteristicRead(BluetoothGatt gatt, final BluetoothGattCharacteristic characteristic, final int status) {
            UUID uid = characteristic.getUuid();
            if (DEBUG) {
                Log.d(TAG, ""onCharacteristicRead: status="" + status);
            }
            if (uid.equals(CHARACTERISTIC_ENCRYPTED_READ_UUID)) {
                mTaskQueue.addTask(new Runnable() {
                    @Override
                    public void run() {
                        if (status == BluetoothGatt.GATT_SUCCESS) {
                            if (mSecure) {
                                mBluetoothGatt.disconnect();
                                if (Arrays.equals(BleEncryptedServerService.WRITE_VALUE.getBytes(), characteristic.getValue())) {
                                    Intent intent = new Intent(INTENT_BLE_READ_ENCRYPTED_CHARACTERISTIC);
                                    sendBroadcast(intent);
                                } else {
                                    showMessage(""Read data is not correct"");
                                }
                            } else {
                                mBluetoothGatt.disconnect();
                                Intent intent = new Intent(INTENT_BLE_READ_NOT_ENCRYPTED_CHARACTERISTIC);
                                sendBroadcast(intent);
                            }
                        } else {
                            if (!mSecure) {
                                mBluetoothGatt.disconnect();
                                Intent intent = new Intent(INTENT_BLE_READ_ENCRYPTED_CHARACTERISTIC);
                                sendBroadcast(intent);
                            } else {
                                mBluetoothGatt.disconnect();
                                Intent intent = new Intent(INTENT_BLE_READ_FAIL_ENCRYPTED_CHARACTERISTIC);
                                sendBroadcast(intent);
                            }
                        }
                    }
                }, 1000);
            }
        }

        @Override
        public void onDescriptorRead(BluetoothGatt gatt, final BluetoothGattDescriptor descriptor, final int status) {
            if (DEBUG) {
                Log.d(TAG, ""onDescriptorRead: status="" + status);
            }

            mTaskQueue.addTask(new Runnable() {
                @Override
                public void run() {
                    UUID uid = descriptor.getUuid();
                    if ((status == BluetoothGatt.GATT_SUCCESS)) {
                        if (uid.equals(DESCRIPTOR_ENCRYPTED_READ_UUID)) {
                            if (mSecure) {
                                mBluetoothGatt.disconnect();
                                if (Arrays.equals(BleEncryptedServerService.WRITE_VALUE.getBytes(), descriptor.getValue())) {
                                    Intent intent = new Intent(INTENT_BLE_READ_ENCRYPTED_DESCRIPTOR);
                                    sendBroadcast(intent);
                                } else {
                                    showMessage(""Read data is not correct"");
                                }
                            } else {
                                mBluetoothGatt.disconnect();
                                Intent intent = new Intent(INTENT_BLE_READ_NOT_ENCRYPTED_DESCRIPTOR);
                                sendBroadcast(intent);
                            }
                        }
                    } else {
                        if (!mSecure) {
                            mBluetoothGatt.disconnect();
                            Intent intent = new Intent(INTENT_BLE_READ_ENCRYPTED_DESCRIPTOR);
                            sendBroadcast(intent);
                        } else {
                            if (uid.equals(DESCRIPTOR_ENCRYPTED_READ_UUID)) {
                                mBluetoothGatt.disconnect();
                                Intent intent = new Intent(INTENT_BLE_READ_FAIL_ENCRYPTED_DESCRIPTOR);
                                sendBroadcast(intent);
                            }
                        }
                    }
                }
            }, 1000);
        }

        @Override
        public void onDescriptorWrite(BluetoothGatt gatt, final BluetoothGattDescriptor descriptor, final int status) {
            if (DEBUG) {
                Log.d(TAG, ""onDescriptorWrite: status="" + status);
            }

            mTaskQueue.addTask(new Runnable() {
                @Override
                public void run() {
                    UUID uid = descriptor.getUuid();
                    if (uid.equals(DESCRIPTOR_ENCRYPTED_WRITE_UUID)) {
                        if ((status == BluetoothGatt.GATT_SUCCESS)) {
                            if (mSecure) {
                                mBluetoothGatt.disconnect();
                                if (Arrays.equals(WRITE_VALUE.getBytes(), descriptor.getValue())) {
                                    Intent intent = new Intent(INTENT_BLE_WRITE_ENCRYPTED_DESCRIPTOR);
                                    sendBroadcast(intent);
                                } else {
                                    showMessage(""Written data is not correct"");
                                }
                            }
                        } else {
                            if (!mSecure) {
                                mBluetoothGatt.disconnect();
                                Intent intent = new Intent(INTENT_BLE_WRITE_NOT_ENCRYPTED_DESCRIPTOR);
                                sendBroadcast(intent);
                            } else {
                                mBluetoothGatt.disconnect();
                                Intent intent = new Intent(INTENT_BLE_WRITE_FAIL_ENCRYPTED_DESCRIPTOR);
                                sendBroadcast(intent);
                            }
                        }
                    }
                }
            }, 1000);
        }
    };

    private final ScanCallback mScanCallback = new ScanCallback() {
        @Override
        public void onScanResult(int callbackType, final ScanResult result) {
            if (mBluetoothGatt== null) {
                mDevice = result.getDevice();
                int bond_state = mDevice.getBondState();
                if (mSecure && bond_state != BluetoothDevice.BOND_BONDED) {
                    mLastScanError = ""This test is a test of Secure.\n Before running the test, please do the pairing."";
                    return;
                } else if (!mSecure && bond_state != BluetoothDevice.BOND_NONE) {
                    mLastScanError = ""This test is a test of Insecure\n Before running the test, please release the pairing."";
                    return;
                }
                mLastScanError = null;
                stopScan();
                mBluetoothGatt = BleClientService.connectGatt(mDevice, mContext, false, mSecure, mGattCallbacks);
            }
        }
    };

    private void startScan() {
        if (DEBUG) Log.d(TAG, ""startScan"");
        List<ScanFilter> filter = Arrays.asList(new ScanFilter.Builder().setServiceUuid(
                new ParcelUuid(BleEncryptedServerService.ADV_SERVICE_UUID)).build());
        ScanSettings setting = new ScanSettings.Builder()
                .setScanMode(ScanSettings.SCAN_MODE_LOW_LATENCY).build();
        mScanner.startScan(filter, setting, mScanCallback);

        mTaskQueue.addTask(new Runnable() {
            @Override
            public void run() {
                if (mLastScanError != null) {
                    stopScan();
                    Toast.makeText(BleEncryptedClientService.this, mLastScanError, Toast.LENGTH_LONG).show();
                    mLastScanError = null;
                }
            }
        }, 10000);
    }

    private void stopScan() {
        if (DEBUG) Log.d(TAG, ""stopScan"");
        if (mScanner != null) {
            mScanner.stopScan(mScanCallback);
        }
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.cts.statsdatom.bluetooth.BluetoothStatsTests"	"testBleScan"	"CtsStatsdAtomHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/bluetooth/BluetoothStatsTests.java"	""	"public void testBleScan() throws Exception {
        if (!DeviceUtils.hasFeature(getDevice(), FEATURE_BLUETOOTH_LE)) return;

        final int atomTag = AtomsProto.Atom.BLE_SCAN_STATE_CHANGED_FIELD_NUMBER;
        Set<Integer> onState = new HashSet<>(
                Collections.singletonList(AtomsProto.BleScanStateChanged.State.ON_VALUE));
        Set<Integer> offState = new HashSet<>(
                Collections.singletonList(AtomsProto.BleScanStateChanged.State.OFF_VALUE));
        final int expectedWait = 3_000;
        // Add state sets to the list in order.
        List<Set<Integer>> stateSet = Arrays.asList(onState, offState);
        ConfigUtils.uploadConfigForPushedAtomWithUid(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                atomTag, /*useAttributionChain=*/ true);

        DeviceUtils.runDeviceTestsOnStatsdApp(getDevice(), "".AtomTests"", ""testBleScanUnoptimized"");
        Thread.sleep(AtomTestUtils.WAIT_TIME_SHORT);

        List<StatsLog.EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());
        AtomTestUtils.assertStatesOccurred(stateSet, data, expectedWait,
                atom -> atom.getBleScanStateChanged().getState().getNumber());
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.cts.statsdatom.bluetooth.BluetoothStatsTests"	"testBleUnoptimizedScan"	"CtsStatsdAtomHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/bluetooth/BluetoothStatsTests.java"	""	"public void testBleUnoptimizedScan() throws Exception {
        if (!DeviceUtils.hasFeature(getDevice(), FEATURE_BLUETOOTH_LE)) return;

        final int atomTag = AtomsProto.Atom.BLE_SCAN_STATE_CHANGED_FIELD_NUMBER;
        Set<Integer> onState = new HashSet<>(
                Collections.singletonList(AtomsProto.BleScanStateChanged.State.ON_VALUE));
        Set<Integer> offState = new HashSet<>(
                Collections.singletonList(AtomsProto.BleScanStateChanged.State.OFF_VALUE));
        final int minTimeDiffMillis = 1_500;
        final int maxTimeDiffMillis = 3_000;
        // Add state sets to the list in order.
        List<Set<Integer>> stateSet = Arrays.asList(onState, offState);
        ConfigUtils.uploadConfigForPushedAtomWithUid(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                atomTag, /*useAttributionChain=*/ true);

        DeviceUtils.runDeviceTestsOnStatsdApp(getDevice(), "".AtomTests"", ""testBleScanUnoptimized"");
        Thread.sleep(AtomTestUtils.WAIT_TIME_SHORT);

        List<StatsLog.EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());
        AtomTestUtils.assertTimeDiffBetween(data.get(0), data.get(1), minTimeDiffMillis,
                maxTimeDiffMillis);
        AtomsProto.BleScanStateChanged a0 = data.get(0).getAtom().getBleScanStateChanged();
        assertThat(a0.getState().getNumber()).isEqualTo(
                AtomsProto.BleScanStateChanged.State.ON_VALUE);
        assertThat(a0.getIsFiltered()).isFalse();
        assertThat(a0.getIsFirstMatch()).isFalse();
        assertThat(a0.getIsOpportunistic()).isFalse();
        AtomsProto.BleScanStateChanged a1 = data.get(1).getAtom().getBleScanStateChanged();
        assertThat(a1.getState().getNumber()).isEqualTo(
                AtomsProto.BleScanStateChanged.State.OFF_VALUE);
        assertThat(a1.getIsFiltered()).isFalse();
        assertThat(a1.getIsFirstMatch()).isFalse();
        assertThat(a1.getIsOpportunistic()).isFalse();
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.cts.statsdatom.bluetooth.BluetoothStatsTests"	"testBleOpportunisticScan"	"CtsStatsdAtomHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/bluetooth/BluetoothStatsTests.java"	""	"public void testBleOpportunisticScan() throws Exception {
        if (!DeviceUtils.hasFeature(getDevice(), FEATURE_BLUETOOTH_LE)) return;

        final int atomTag = AtomsProto.Atom.BLE_SCAN_STATE_CHANGED_FIELD_NUMBER;
        Set<Integer> onState = new HashSet<>(
                Collections.singletonList(AtomsProto.BleScanStateChanged.State.ON_VALUE));
        Set<Integer> offState = new HashSet<>(
                Collections.singletonList(AtomsProto.BleScanStateChanged.State.OFF_VALUE));
        final int minTimeDiffMillis = 1_500;
        final int maxTimeDiffMillis = 3_000;
        // Add state sets to the list in order.
        List<Set<Integer>> stateSet = Arrays.asList(onState, offState);
        ConfigUtils.uploadConfigForPushedAtomWithUid(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                atomTag, /*useAttributionChain=*/ true);

        DeviceUtils.runDeviceTestsOnStatsdApp(getDevice(), "".AtomTests"",
                ""testBleScanOpportunistic"");

        List<StatsLog.EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());
        AtomTestUtils.assertTimeDiffBetween(data.get(0), data.get(1), minTimeDiffMillis,
                maxTimeDiffMillis);
        AtomsProto.BleScanStateChanged a0 = data.get(0).getAtom().getBleScanStateChanged();
        assertThat(a0.getState().getNumber()).isEqualTo(
                AtomsProto.BleScanStateChanged.State.ON_VALUE);
        assertThat(a0.getIsFiltered()).isFalse();
        assertThat(a0.getIsFirstMatch()).isFalse();
        assertThat(a0.getIsOpportunistic()).isTrue();  // This scan is opportunistic.
        AtomsProto.BleScanStateChanged a1 = data.get(1).getAtom().getBleScanStateChanged();
        assertThat(a1.getState().getNumber()).isEqualTo(
                AtomsProto.BleScanStateChanged.State.OFF_VALUE);
        assertThat(a1.getIsFiltered()).isFalse();
        assertThat(a1.getIsFirstMatch()).isFalse();
        assertThat(a1.getIsOpportunistic()).isTrue();
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.cts.statsdatom.bluetooth.BluetoothStatsTests"	"testBleScanResult"	"CtsStatsdAtomHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/bluetooth/BluetoothStatsTests.java"	""	"public void testBleScanResult() throws Exception {
        if (!DeviceUtils.hasFeature(getDevice(), FEATURE_BLUETOOTH_LE)) return;

        final int atom = AtomsProto.Atom.BLE_SCAN_RESULT_RECEIVED_FIELD_NUMBER;
        final int field = AtomsProto.BleScanResultReceived.NUM_RESULTS_FIELD_NUMBER;
        StatsdConfigProto.StatsdConfig.Builder config = ConfigUtils.createConfigBuilder(
                DeviceUtils.STATSD_ATOM_TEST_PKG);
        ConfigUtils.addEventMetric(config, atom, Arrays.asList(
                ConfigUtils.createUidFvm(/*useAttributionChain=*/ true,
                        DeviceUtils.STATSD_ATOM_TEST_PKG),
                ConfigUtils.createFvm(field).setGteInt(0)));
        ConfigUtils.uploadConfig(getDevice(), config);

        DeviceUtils.runDeviceTestsOnStatsdApp(getDevice(), "".AtomTests"", ""testBleScanResult"");

        List<StatsLog.EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());
        assertThat(data.size()).isAtLeast(1);
        AtomsProto.BleScanResultReceived a0 = data.get(0).getAtom().getBleScanResultReceived();
        assertThat(a0.getNumResults()).isAtLeast(1);
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.wifi.testcase.NetworkSuggestionTestCase"	"isEmpty"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/wifi/testcase/NetworkSuggestionTestCase.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.wifi.testcase;

import static android.net.NetworkCapabilities.NET_CAPABILITY_NOT_METERED;
import static android.net.NetworkCapabilities.TRANSPORT_WIFI;
import static android.net.wifi.WifiManager.STATUS_NETWORK_SUGGESTIONS_SUCCESS;

import static com.android.cts.verifier.wifi.TestUtils.SCAN_RESULT_TYPE_OPEN;
import static com.android.cts.verifier.wifi.TestUtils.SCAN_RESULT_TYPE_PSK;

import android.annotation.NonNull;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.net.ConnectivityManager;
import android.net.MacAddress;
import android.net.Network;
import android.net.NetworkRequest;
import android.net.wifi.ScanResult;
import android.net.wifi.WifiManager;
import android.net.wifi.WifiNetworkSuggestion;
import android.os.SystemClock;
import android.util.Log;
import android.util.Pair;

import androidx.core.os.BuildCompat;

import com.android.cts.verifier.R;
import com.android.cts.verifier.wifi.BaseTestCase;
import com.android.cts.verifier.wifi.CallbackUtils;
import com.android.cts.verifier.wifi.TestUtils;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

/**
 * Test cases for network suggestions {@link WifiNetworkSuggestion} added via
 * {@link WifiManager#addNetworkSuggestions(List)}.
 */
public class NetworkSuggestionTestCase extends BaseTestCase {
    private static final String TAG = ""NetworkSuggestionTestCase"";
    private static final boolean DBG = true;

    private static final int PERIODIC_SCAN_INTERVAL_MS = 10_000;
    private static final int CALLBACK_TIMEOUT_MS = 40_000;
    private static final int CAPABILITIES_CHANGED_FOR_METERED_TIMEOUT_MS = 80_000;

    private final Object mLock = new Object();
    private final ScheduledExecutorService mExecutorService;
    private final WifiNetworkSuggestion.Builder mNetworkSuggestionBuilder =
            new WifiNetworkSuggestion.Builder();

    private ConnectivityManager mConnectivityManager;
    private List<WifiNetworkSuggestion> mNetworkSuggestions;
    private NetworkRequest mNetworkRequest;
    private CallbackUtils.NetworkCallback mNetworkCallback;
    private ConnectionStatusListener mConnectionStatusListener;
    private UserApprovalStatusListener mUserApprovalStatusListener;
    private BroadcastReceiver mBroadcastReceiver;
    private String mFailureReason;
    private int mUserApprovedStatus = WifiManager.STATUS_SUGGESTION_APPROVAL_UNKNOWN;

    private final boolean mSetBssid;
    private final boolean mSetRequiresAppInteraction;
    private final boolean mSimulateConnectionFailure;
    private final boolean mSetMeteredPostConnection;

    public NetworkSuggestionTestCase(Context context, boolean setBssid,
            boolean setRequiresAppInteraction) {
        this(context, setBssid, setRequiresAppInteraction, false);
    }

    public NetworkSuggestionTestCase(Context context, boolean setBssid,
            boolean setRequiresAppInteraction, boolean simulateConnectionFailure) {
        this(context, setBssid, setRequiresAppInteraction, simulateConnectionFailure, false);
    }

    public NetworkSuggestionTestCase(Context context, boolean setBssid,
            boolean setRequiresAppInteraction, boolean simulateConnectionFailure,
            boolean setMeteredPostConnection) {
        super(context);
        mExecutorService = Executors.newSingleThreadScheduledExecutor();
        mSetBssid = setBssid;
        mSetRequiresAppInteraction = setRequiresAppInteraction;
        mSimulateConnectionFailure = simulateConnectionFailure;
        mSetMeteredPostConnection = setMeteredPostConnection;
    }

    // Create a network specifier based on the test type.
    private WifiNetworkSuggestion createNetworkSuggestion(@NonNull ScanResult scanResult) {
        mNetworkSuggestionBuilder.setSsid(scanResult.SSID);
        if (mSetBssid) {
            mNetworkSuggestionBuilder.setBssid(MacAddress.fromString(scanResult.BSSID));
        }
        if (mSetRequiresAppInteraction) {
            mNetworkSuggestionBuilder.setIsAppInteractionRequired(true);
        }
        if (mSimulateConnectionFailure) {
            // Use a random password to simulate connection failure.
            if (TestUtils.isScanResultForWpa2Network(scanResult)) {
                mNetworkSuggestionBuilder.setWpa2Passphrase(mTestUtils.generateRandomPassphrase());
            } else if (TestUtils.isScanResultForWpa3Network(scanResult)) {
                mNetworkSuggestionBuilder.setWpa3Passphrase(mTestUtils.generateRandomPassphrase());
            }
        } else if (!mPsk.isEmpty()) {
            if (TestUtils.isScanResultForWpa2Network(scanResult)) {
                mNetworkSuggestionBuilder.setWpa2Passphrase(mPsk);
            } else if (TestUtils.isScanResultForWpa3Network(scanResult)) {
                mNetworkSuggestionBuilder.setWpa3Passphrase(mPsk);
            }
        }
        mNetworkSuggestionBuilder.setIsMetered(false);
        return mNetworkSuggestionBuilder.build();
    }

    private void setFailureReason(String reason) {
        synchronized (mLock) {
            mFailureReason = reason;
        }
    }

    private static class ConnectionStatusListener implements
            WifiManager.SuggestionConnectionStatusListener {
        private final CountDownLatch mCountDownLatch;
        public WifiNetworkSuggestion wifiNetworkSuggestion = null;
        public int failureReason = -1;

        ConnectionStatusListener(CountDownLatch countDownLatch) {
            mCountDownLatch = countDownLatch;
        }

        @Override
        public void onConnectionStatus(
                WifiNetworkSuggestion wifiNetworkSuggestion, int failureReason) {
            this.wifiNetworkSuggestion = wifiNetworkSuggestion;
            this.failureReason = failureReason;
            mCountDownLatch.countDown();
        }
    }

    private class UserApprovalStatusListener implements
            WifiManager.SuggestionUserApprovalStatusListener{
        private final CountDownLatch mCountDownLatch;

        UserApprovalStatusListener(CountDownLatch countDownLatch) {
            mCountDownLatch = countDownLatch;
        }
        @Override
        public void onUserApprovalStatusChange(int status) {
            mUserApprovedStatus = status;
            if (status == WifiManager.STATUS_SUGGESTION_APPROVAL_PENDING
                    || status == WifiManager.STATUS_SUGGESTION_APPROVAL_UNKNOWN) {
                return;
            }
            mCountDownLatch.countDown();
        }
    }

    // TODO(b/150890482): Capabilities changed callback can occur multiple times (for ex: RSSI
    // change) & the sufficiency checks may result in ths change taking longer to take effect.
    // This method accounts for both of these situations.
    private boolean waitForNetworkToBeMetered() throws InterruptedException {
        long startTimeMillis = SystemClock.elapsedRealtime();
        while (SystemClock.elapsedRealtime()
                < startTimeMillis + CAPABILITIES_CHANGED_FOR_METERED_TIMEOUT_MS) {
            // Network marked metered.
            if (!mNetworkCallback.getNetworkCapabilities()
                    .hasCapability(NET_CAPABILITY_NOT_METERED)) {
                return true;
            } else {
                Log.w(TAG, ""Network meteredness check failed. ""
                        + mNetworkCallback.getNetworkCapabilities());
            }
            // Wait for the suggestion to be marked metered now.
            if (!mNetworkCallback.waitForCapabilitiesChanged()) {
                Log.w(TAG, ""Network capabilities did not change"");
            }
        }
        return false;
    }

    @Override
    protected boolean executeTest() throws InterruptedException {
        if (mSimulateConnectionFailure && mPsk.isEmpty()) {
            setFailureReason(mContext.getString(R.string.wifi_status_need_psk));
            return false;
        }
        // Step: Scan and find the network around.
        if (DBG) Log.v(TAG, ""Scan and find the network: "" + mSsid);
        ScanResult testNetwork = mTestUtils.startScanAndFindAnyMatchingNetworkInResults(
                mSsid, mPsk.isEmpty() ? SCAN_RESULT_TYPE_OPEN : SCAN_RESULT_TYPE_PSK);
        if (testNetwork == null) {
            setFailureReason(mContext.getString(R.string.wifi_status_scan_failure));
            return false;
        }

        // Step (Optional): Register for the post connection broadcast.
        final CountDownLatch countDownLatchForPostConnectionBcast = new CountDownLatch(1);
        IntentFilter intentFilter =
                new IntentFilter(WifiManager.ACTION_WIFI_NETWORK_SUGGESTION_POST_CONNECTION);
        // Post connection broadcast receiver.
        mBroadcastReceiver = new BroadcastReceiver() {
            @Override
            public void onReceive(Context context, Intent intent) {
                if (DBG) Log.v(TAG, ""Broadcast onReceive "" + intent);
                if (!intent.getAction().equals(
                        WifiManager.ACTION_WIFI_NETWORK_SUGGESTION_POST_CONNECTION)) {
                    return;
                }
                if (DBG) Log.v(TAG, ""Post connection broadcast received"");
                countDownLatchForPostConnectionBcast.countDown();
            }
        };
        // Register the receiver for post connection broadcast.
        mContext.registerReceiver(mBroadcastReceiver, intentFilter);
        final CountDownLatch countDownLatchForConnectionStatusListener = new CountDownLatch(1);
        mConnectionStatusListener =
                new ConnectionStatusListener(countDownLatchForConnectionStatusListener);
        mWifiManager.addSuggestionConnectionStatusListener(
                Executors.newSingleThreadExecutor(), mConnectionStatusListener);

        final CountDownLatch userApprovalCountDownLatch = new CountDownLatch(1);
        if (BuildCompat.isAtLeastS()) {
            mUserApprovalStatusListener = new UserApprovalStatusListener(
                    userApprovalCountDownLatch);
            mWifiManager.addSuggestionUserApprovalStatusListener(
                    Executors.newSingleThreadExecutor(), mUserApprovalStatusListener);

        }

        // Step: Register network callback to wait for connection state.
        mNetworkRequest = new NetworkRequest.Builder()
                .addTransportType(TRANSPORT_WIFI)
                .build();
        mNetworkCallback = new CallbackUtils.NetworkCallback(CALLBACK_TIMEOUT_MS);
        mConnectivityManager.registerNetworkCallback(mNetworkRequest, mNetworkCallback);

        // Step: Create a suggestion for the chosen open network depending on the type of test.
        WifiNetworkSuggestion networkSuggestion = createNetworkSuggestion(testNetwork);
        mNetworkSuggestions = Arrays.asList(networkSuggestion);

        // Step: Add a network suggestions.
        if (DBG) Log.v(TAG, ""Adding suggestion"");
        mListener.onTestMsgReceived(mContext.getString(R.string.wifi_status_suggestion_add));
        if (mWifiManager.addNetworkSuggestions(mNetworkSuggestions)
                != STATUS_NETWORK_SUGGESTIONS_SUCCESS) {
            setFailureReason(mContext.getString(R.string.wifi_status_suggestion_add_failure));
            return false;
        }
        // Step: Ask user to approval the suggestion.
        if (BuildCompat.isAtLeastS()) {
            if (mUserApprovedStatus != WifiManager.STATUS_SUGGESTION_APPROVAL_APPROVED_BY_USER) {
                mListener.onTestMsgReceived(mContext.getString(
                        R.string.wifi_status_suggestion_wait_for_user_approval));
            }
            if (!userApprovalCountDownLatch.await(CALLBACK_TIMEOUT_MS, TimeUnit.MILLISECONDS)) {
                setFailureReason(mContext.getString(
                        R.string.wifi_status_suggestion_user_approval_status_failure));
                return false;
            }
            if (mUserApprovedStatus != WifiManager.STATUS_SUGGESTION_APPROVAL_APPROVED_BY_USER) {
                setFailureReason(mContext.getString(
                        R.string.wifi_status_suggestion_user_approve_failure));
                return false;
            }
        } else {
            mListener.onTestMsgReceived(mContext.getString(
                    R.string.wifi_status_suggestion_wait_for_user_approval));
        }

        if (DBG) Log.v(TAG, ""Getting suggestion"");
        List<WifiNetworkSuggestion> retrievedSuggestions = mWifiManager.getNetworkSuggestions();
        if (!Objects.equals(mNetworkSuggestions, retrievedSuggestions)) {
            setFailureReason(mContext.getString(R.string.wifi_status_suggestion_get_failure));
            return false;
        }

        // Step: Trigger scans periodically to trigger network selection quicker.
        if (DBG) Log.v(TAG, ""Triggering scan periodically"");
        mExecutorService.scheduleAtFixedRate(() -> {
            if (!mWifiManager.startScan()) {
                Log.w(TAG, ""Failed to trigger scan"");
            }
        }, 0, PERIODIC_SCAN_INTERVAL_MS, TimeUnit.MILLISECONDS);

        // Step: Wait for connection/unavailable.
        if (!mSimulateConnectionFailure) {
            if (DBG) Log.v(TAG, ""Waiting for connection"");
            mListener.onTestMsgReceived(mContext.getString(
                    R.string.wifi_status_suggestion_wait_for_connect));
            Pair<Boolean, Network> cbStatusForAvailable = mNetworkCallback.waitForAvailable();
            if (!cbStatusForAvailable.first) {
                Log.e(TAG, ""Failed to get network available callback"");
                setFailureReason(mContext.getString(R.string.wifi_status_network_cb_timeout));
                return false;
            }
            mListener.onTestMsgReceived(
                    mContext.getString(R.string.wifi_status_suggestion_connect));
        } else {
            if (DBG) Log.v(TAG, ""Ensure no connection"");
            mListener.onTestMsgReceived(mContext.getString(
                    R.string.wifi_status_suggestion_ensure_no_connect));
            Pair<Boolean, Network> cbStatusForAvailable = mNetworkCallback.waitForAvailable();
            if (cbStatusForAvailable.first) {
                Log.e(TAG, ""Unexpectedly got network available callback"");
                setFailureReason(mContext.getString(R.string.wifi_status_network_available_error));
                return false;
            }
            mListener.onTestMsgReceived(
                    mContext.getString(R.string.wifi_status_suggestion_not_connected));
        }

        // Step: Ensure that we connected to the suggested network (optionally, the correct BSSID).
        if (!mSimulateConnectionFailure) {
            if (!mTestUtils.isConnected(""\"""" + testNetwork.SSID + ""\"""",
                    // TODO: This might fail if there are other BSSID's for the same network & the
                    //  device decided to connect/roam to a different BSSID. We don't turn off
                    //  roaming for suggestions.
                    mSetBssid ? testNetwork.BSSID : null)) {
                Log.e(TAG, ""Failed to connected to the network"");
                setFailureReason(
                        mContext.getString(R.string.wifi_status_connected_to_other_network));
                return false;
            }
        }

        // Step (Optional): Ensure we received the post connect broadcast.
        if (mSetRequiresAppInteraction) {
            if (DBG) Log.v(TAG, ""Wait for post connection broadcast"");
            mListener.onTestMsgReceived(
                    mContext.getString(
                            R.string.wifi_status_suggestion_wait_for_post_connect_bcast));
            if (!countDownLatchForPostConnectionBcast.await(
                    CALLBACK_TIMEOUT_MS, TimeUnit.MILLISECONDS)) {
                Log.e(TAG, ""Failed to get post connection broadcast"");
                setFailureReason(mContext.getString(
                        R.string.wifi_status_suggestion_post_connect_bcast_failure));
                return false;
            }
            mListener.onTestMsgReceived(
                    mContext.getString(R.string.wifi_status_suggestion_post_connect_bcast));
        }
        // Step (Optional): Ensure we received the connection status listener.
        if (mSimulateConnectionFailure) {
            if (DBG) Log.v(TAG, ""Wait for connection status listener"");
            mListener.onTestMsgReceived(
                    mContext.getString(
                            R.string.wifi_status_suggestion_wait_for_connection_status));
            if (!countDownLatchForConnectionStatusListener.await(
                    CALLBACK_TIMEOUT_MS, TimeUnit.MILLISECONDS)) {
                Log.e(TAG, ""Failed to receive connection status"");
                setFailureReason(mContext.getString(
                        R.string.wifi_status_suggestion_connection_status_failure));
                return false;
            }
            if (DBG) Log.v(TAG, ""Received connection status"");
            if (!Objects.equals(mConnectionStatusListener.wifiNetworkSuggestion, networkSuggestion)
                    || mConnectionStatusListener.failureReason
                    != WifiManager.STATUS_SUGGESTION_CONNECTION_FAILURE_AUTHENTICATION) {
                Log.e(TAG, ""Received wrong connection status for ""
                        + mConnectionStatusListener.wifiNetworkSuggestion
                        + "" with reason: "" + mConnectionStatusListener.failureReason);
                setFailureReason(mContext.getString(
                        R.string.wifi_status_suggestion_connection_status_failure));
                return false;
            }
            mListener.onTestMsgReceived(
                    mContext.getString(R.string.wifi_status_suggestion_connection_status));
        }

        if (mSetMeteredPostConnection) {
            // ensure that the network is not metered before change.
            if (!mNetworkCallback.getNetworkCapabilities()
                    .hasCapability(NET_CAPABILITY_NOT_METERED)) {
                Log.e(TAG, ""Network meteredness check failed ""
                        + mNetworkCallback.getNetworkCapabilities());
                setFailureReason(mContext.getString(
                        R.string.wifi_status_suggestion_metered_check_failed));
                return false;
            }
            if (DBG) Log.v(TAG, ""Mark suggestion metered after connection"");
            mListener.onTestMsgReceived(
                    mContext.getString(R.string.wifi_status_suggestion_metered_change));
            WifiNetworkSuggestion modifiedSuggestion = mNetworkSuggestionBuilder
                    .setIsMetered(true)
                    .build();
            if (mWifiManager.addNetworkSuggestions(Arrays.asList(modifiedSuggestion))
                    != STATUS_NETWORK_SUGGESTIONS_SUCCESS) {
                setFailureReason(mContext.getString(R.string.wifi_status_suggestion_add_failure));
                return false;
            }
            if (!waitForNetworkToBeMetered()) {
                Log.e(TAG, ""Network was not marked metered"");
                setFailureReason(mContext.getString(
                        R.string.wifi_status_suggestion_metered_check_failed));
                return false;
            }
            mListener.onTestMsgReceived(
                    mContext.getString(R.string.wifi_status_suggestion_metered_changed));
        }

        // Step: Remove the suggestions from the app.
        if (DBG) Log.v(TAG, ""Removing suggestion"");
        mListener.onTestMsgReceived(mContext.getString(R.string.wifi_status_suggestion_remove));
        if (mWifiManager.removeNetworkSuggestions(mNetworkSuggestions)
                != STATUS_NETWORK_SUGGESTIONS_SUCCESS) {
            setFailureReason(mContext.getString(R.string.wifi_status_suggestion_remove_failure));
            return false;
        }

        // Step: Ensure we disconnect immediately on suggestion removal.
        if (!mSimulateConnectionFailure) {
            mListener.onTestMsgReceived(
                    mContext.getString(R.string.wifi_status_suggestion_wait_for_disconnect));
            if (DBG) Log.v(TAG, ""Ensuring we disconnect immediately"");
            boolean cbStatusForLost = mNetworkCallback.waitForLost();
            if (!cbStatusForLost) {
                setFailureReason(
                        mContext.getString(R.string.wifi_status_suggestion_not_disconnected));
                return false;
            }
            mListener.onTestMsgReceived(
                    mContext.getString(R.string.wifi_status_suggestion_disconnected));
        }

        // All done!
        return true;
    }

    @Override
    protected String getFailureReason() {
        synchronized (mLock) {
            return mFailureReason;
        }
    }

    @Override
    protected void setUp() {
        super.setUp();
        mConnectivityManager = mContext.getSystemService(ConnectivityManager.class);
    }

    @Override
    protected void tearDown() {
        mExecutorService.shutdownNow();
        if (mBroadcastReceiver != null) {
            mContext.unregisterReceiver(mBroadcastReceiver);
        }
        if (mConnectionStatusListener != null) {
            mWifiManager.removeSuggestionConnectionStatusListener(mConnectionStatusListener);
        }
        mWifiManager.removeNetworkSuggestions(new ArrayList<>());
        super.tearDown();
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.webkit.cts.WebViewSslTest"	"testSecureServerRequiringClientCertDoesCancelRequest"	"CtsWebkitTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/webkit/src/android/webkit/cts/WebViewSslTest.java"	""	"public void testSecureServerRequiringClientCertDoesCancelRequest() throws Throwable {
        if (!NullWebViewUtils.isWebViewAvailable()) {
            return;
        }
        mWebServer = new CtsTestServer(getActivity(), CtsTestServer.SslMode.NEEDS_CLIENT_AUTH);
        final String url = mWebServer.getAssetUrl(TestHtmlConstants.HELLO_WORLD_URL);
        final SslErrorWebViewClient webViewClient = new SslErrorWebViewClient(mOnUiThread);
        mOnUiThread.setWebViewClient(webViewClient);
        mOnUiThread.clearSslPreferences();
        loadUrlUntilError(webViewClient, url, WebViewClient.ERROR_FAILED_SSL_HANDSHAKE);
        // Page NOT loaded OK...
        //
        // In this test, we expect both a recoverable and non-recoverable error:
        //
        //  1. WebView does not trust the test server's certificate. This is a recoverable error, so
        //     WebView invokes #onReceivedSslError (and the WebViewClient calls #proceed). We don't
        //     specifically intend to test this part of the scenario, but we can't easily mock out
        //     WebView's certificate roots.
        //  2. WebView proceeds with the handshake without providing client authentication. The
        //     server fails the client. This is non-recoverable, so WebView invokes
        //     #onReceivedError.
        //
        // We only assert the second error, since earlier WebView versions had a bug in which
        // WebView hit error 2 first, which prevented it from hitting error 1.
        assertFalse(""Title should not be updated, since page load should have failed"",
                TestHtmlConstants.HELLO_WORLD_TITLE.equals(mOnUiThread.getTitle()));
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.provider.cts.media.MediaStoreTest"	"testGetMediaScannerUri"	"CtsProviderTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/provider/src/android/provider/cts/media/MediaStoreTest.java"	""	"public void testGetMediaScannerUri() {
        // query
        Cursor c = mContentResolver.query(MediaStore.getMediaScannerUri(), null,
                null, null, null);
        assertEquals(1, c.getCount());
        c.close();
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.hardware.camera2.cts.helpers.Camera2Focuser"	"createCaptureListener"	""	"/home/gpoor/cts-12-source/cts/tests/camera/utils/src/android/hardware/camera2/cts/helpers/Camera2Focuser.java"	""	"public void test/*
 *.
 */

package android.hardware.camera2.cts.helpers;

import android.graphics.Rect;
import android.hardware.camera2.CameraAccessException;
import android.hardware.camera2.CameraCaptureSession;
import android.hardware.camera2.CameraCaptureSession.CaptureCallback;
import android.hardware.camera2.CameraCharacteristics;
import android.hardware.camera2.CameraDevice;
import android.hardware.camera2.params.MeteringRectangle;
import android.hardware.camera2.CaptureRequest;
import android.hardware.camera2.CaptureResult;
import android.hardware.camera2.TotalCaptureResult;
import android.os.Handler;
import android.util.Log;
import android.view.Surface;

import com.android.ex.camera2.pos.AutoFocusStateMachine;
import com.android.ex.camera2.pos.AutoFocusStateMachine.AutoFocusStateListener;

/**
 * A focuser utility class to assist camera to do auto focus.
 * <p>
 * This class need create repeating request and single request to do auto focus.
 * The repeating request is used to get the auto focus states; the single
 * request is used to trigger the auto focus. This class assumes the camera device
 * supports auto-focus. Don't use this class if the camera device doesn't have focuser
 * unit.
 * </p>
 */
public class Camera2Focuser implements AutoFocusStateListener {
    private static final String TAG = ""Focuser"";
    private static final boolean VERBOSE = Log.isLoggable(TAG, Log.VERBOSE);

    private final AutoFocusStateMachine mAutoFocus = new AutoFocusStateMachine(this);
    private final Handler mHandler;
    private final AutoFocusListener mAutoFocusListener;
    private final CameraDevice mCamera;
    private final CameraCaptureSession mSession;
    private final Surface mRequestSurface;
    private final StaticMetadata mStaticInfo;

    private int mAfRun = 0;
    private MeteringRectangle[] mAfRegions;
    private boolean mLocked = false;
    private boolean mSuccess = false;
    private CaptureRequest.Builder mRepeatingBuilder;

    /**
     * The callback interface to notify auto focus result.
     */
    public interface AutoFocusListener {
        /**
         * This callback is called when auto focus completes and locked.
         *
         * @param success true if focus was successful, false if otherwise
         */
        void onAutoFocusLocked(boolean success);
    }

    /**
     * Construct a focuser object, with given capture requestSurface, listener
     * and handler.
     * <p>
     * The focuser object will use camera and requestSurface to submit capture
     * request and receive focus state changes. The {@link AutoFocusListener} is
     * used to notify the auto focus callback.
     * </p>
     *
     * @param camera The camera device associated with this focuser
     * @param session The camera capture session associated with this focuser
     * @param requestSurface The surface to issue the capture request with
     * @param listener The auto focus listener to notify AF result
     * @param staticInfo The CameraCharacteristics of the camera device
     * @param handler The handler used to post auto focus callbacks
     * @throws CameraAccessException
     */
    public Camera2Focuser(CameraDevice camera, CameraCaptureSession session, Surface requestSurface,
            AutoFocusListener listener, CameraCharacteristics staticInfo, Handler handler)
            throws CameraAccessException {
        if (camera == null) {
            throw new IllegalArgumentException(""camera must not be null"");
        }
        if (session == null) {
            throw new IllegalArgumentException(""session must not be null"");
        }
        if (listener == null) {
            throw new IllegalArgumentException(""listener must not be null"");
        }
        if (handler == null) {
            throw new IllegalArgumentException(""handler must not be null"");
        }
        if (requestSurface == null) {
            throw new IllegalArgumentException(""requestSurface must not be null"");
        }
        if (staticInfo == null) {
            throw new IllegalArgumentException(""staticInfo must not be null"");
        }

        mCamera = camera;
        mSession = session;
        mRequestSurface = requestSurface;
        mAutoFocusListener = listener;
        mStaticInfo = new StaticMetadata(staticInfo,
                StaticMetadata.CheckLevel.ASSERT, /*collector*/null);
        mHandler = handler;

        if (!mStaticInfo.hasFocuser()) {
            throw new IllegalArgumentException(""this camera doesn't have a focuser"");
        }

        /**
         * Begin by always being in passive auto focus.
         */
        cancelAutoFocus();
    }

    @Override
    public synchronized void onAutoFocusSuccess(CaptureResult result, boolean locked) {
        mSuccess = true;
        mLocked = locked;

        if (locked) {
            dispatchAutoFocusStatusLocked(/*success*/true);
        }
    }

    @Override
    public synchronized void onAutoFocusFail(CaptureResult result, boolean locked) {
        mSuccess = false;
        mLocked = locked;

        if (locked) {
            dispatchAutoFocusStatusLocked(/*success*/false);
        }
    }

    @Override
    public synchronized void onAutoFocusScan(CaptureResult result) {
        mSuccess = false;
        mLocked = false;
    }

    @Override
    public synchronized void onAutoFocusInactive(CaptureResult result) {
        mSuccess = false;
        mLocked = false;
    }

    /**
     * Start a active auto focus scan based on the given regions.
     *
     * <p>This is usually used for touch for focus, it can make the auto-focus converge based
     * on some particular region aggressively. But it is usually slow as a full active scan
     * is initiated. After the auto focus is converged, the {@link cancelAutoFocus} must be called
     * to resume the continuous auto-focus.</p>
     *
     * @param afRegions The AF regions used by focuser auto focus, full active
     * array size is used if afRegions is null.
     * @throws CameraAccessException
     */
    public synchronized void touchForAutoFocus(MeteringRectangle[] afRegions)
            throws CameraAccessException {
        startAutoFocusLocked(/*active*/true, afRegions);
    }

    /**
     * Start auto focus scan.
     * <p>
     * Start an auto focus scan if it was not done yet. If AF passively focused,
     * lock it. If AF is already locked, return. Otherwise, initiate a full
     * active scan. This is suitable for still capture: focus should need to be
     * accurate, but the AF latency also need to be as short as possible.
     * </p>
     *
     * @param afRegions The AF regions used by focuser auto focus, full active
     *            array size is used if afRegions is null.
     * @throws CameraAccessException
     */
    public synchronized void startAutoFocus(MeteringRectangle[] afRegions)
            throws CameraAccessException {
        startAutoFocusLocked(/*forceActive*/false, afRegions);
    }

    /**
     * Cancel ongoing auto focus, unlock the auto-focus if it was locked, and
     * resume to passive continuous auto focus.
     *
     * @throws CameraAccessException
     */
    public synchronized void cancelAutoFocus() throws CameraAccessException {
        mSuccess = false;
        mLocked = false;

        // reset the AF regions:
        setAfRegions(null);

        // Create request builders, the af regions are automatically updated.
        mRepeatingBuilder = createRequestBuilder();
        CaptureRequest.Builder requestBuilder = createRequestBuilder();
        mAutoFocus.setPassiveAutoFocus(/*picture*/true, mRepeatingBuilder);
        mAutoFocus.unlockAutoFocus(mRepeatingBuilder, requestBuilder);
        CaptureCallback listener = createCaptureListener();
        mSession.setRepeatingRequest(mRepeatingBuilder.build(), listener, mHandler);
        mSession.capture(requestBuilder.build(), listener, mHandler);
    }

    /**
     * Get current AF mode.
     * @return current AF mode
     * @throws IllegalStateException if there auto focus is not running.
     */
    public synchronized int getCurrentAfMode() {
        if (mRepeatingBuilder == null) {
            throw new IllegalStateException(""Auto focus is not running, unable to get AF mode"");
        }

        return mRepeatingBuilder.get(CaptureRequest.CONTROL_AF_MODE);
    }

    private void startAutoFocusLocked(
            boolean forceActive, MeteringRectangle[] afRegions) throws CameraAccessException {

        setAfRegions(afRegions);
        mAfRun++;

        // Create request builders, the af regions are automatically updated.
        mRepeatingBuilder = createRequestBuilder();
        CaptureRequest.Builder requestBuilder = createRequestBuilder();
        if (forceActive) {
            startAutoFocusFullActiveLocked();
        } else {
            // Not forcing a full active scan. If AF passively focused, lock it. If AF is already
            // locked, return. Otherwise, initiate a full active scan.
            if (mSuccess && mLocked) {
                dispatchAutoFocusStatusLocked(/*success*/true);
                return;
            } else if (mSuccess) {
                mAutoFocus.lockAutoFocus(mRepeatingBuilder, requestBuilder);
                CaptureCallback listener = createCaptureListener();
                mSession.setRepeatingRequest(mRepeatingBuilder.build(), listener, mHandler);
                mSession.capture(requestBuilder.build(), listener, mHandler);
            } else {
                startAutoFocusFullActiveLocked();
            }
        }
    }

    private void startAutoFocusFullActiveLocked() throws CameraAccessException {
        // Create request builders, the af regions are automatically updated.
        mRepeatingBuilder = createRequestBuilder();
        CaptureRequest.Builder requestBuilder = createRequestBuilder();
        mAutoFocus.setActiveAutoFocus(mRepeatingBuilder, requestBuilder);
        if (mRepeatingBuilder.get(CaptureRequest.CONTROL_AF_TRIGGER)
                != CaptureRequest.CONTROL_AF_TRIGGER_IDLE) {
            throw new AssertionError(""Wrong trigger set in repeating request"");
        }
        if (requestBuilder.get(CaptureRequest.CONTROL_AF_TRIGGER)
                != CaptureRequest.CONTROL_AF_TRIGGER_START) {
            throw new AssertionError(""Wrong trigger set in queued request"");
        }
        mAutoFocus.resetState();

        CaptureCallback listener = createCaptureListener();
        mSession.setRepeatingRequest(mRepeatingBuilder.build(), listener, mHandler);
        mSession.capture(requestBuilder.build(), listener, mHandler);
    }

    private void dispatchAutoFocusStatusLocked(final boolean success) {
        mHandler.post(new Runnable() {
            @Override
            public void run() {
                mAutoFocusListener.onAutoFocusLocked(success);
            }
        });
    }

    /**
     * Create request builder, set the af regions.
     * @throws CameraAccessException
     */
    private CaptureRequest.Builder createRequestBuilder() throws CameraAccessException {
        CaptureRequest.Builder requestBuilder =
                mCamera.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);

        requestBuilder.set(CaptureRequest.CONTROL_AF_REGIONS, mAfRegions);
        requestBuilder.addTarget(mRequestSurface);

        return requestBuilder;
    }

    /**
     * Set AF regions, fall back to default region if afRegions is null.
     *
     * @param afRegions The AF regions to set
     * @throws IllegalArgumentException if the region is malformed (length is 0).
     */
    private void setAfRegions(MeteringRectangle[] afRegions) {
        if (afRegions == null) {
            setDefaultAfRegions();
            return;
        }
        // Throw IAE if AF regions are malformed.
        if (afRegions.length == 0) {
            throw new IllegalArgumentException(""afRegions is malformed, length: 0"");
        }

        mAfRegions = afRegions;
    }

    /**
     * Set default AF region to full active array size.
     */
    private void setDefaultAfRegions() {
        // Initialize AF regions with all zeros, meaning that it is up to camera device to device
        // the regions used by AF.
        mAfRegions = new MeteringRectangle[] {
                new MeteringRectangle(0, 0, 0, 0, MeteringRectangle.METERING_WEIGHT_DONT_CARE)};
    }
    private CaptureCallback createCaptureListener() {

        int thisAfRun;
        synchronized (this) {
            thisAfRun = mAfRun;
        }

        final int finalAfRun = thisAfRun;

        return new CaptureCallback() {
            private long mLatestFrameCount = -1;

            @Override
            public void onCaptureProgressed(CameraCaptureSession session, CaptureRequest request,
                    CaptureResult result) {
                // In case of a partial result, send to focuser if necessary
                // 3A fields are present
                if (result.get(CaptureResult.CONTROL_AF_STATE) != null &&
                        result.get(CaptureResult.CONTROL_AF_MODE) != null) {
                    if (VERBOSE) {
                        Log.v(TAG, ""Focuser - got early AF state"");
                    }

                    dispatchToFocuser(result);
                }
            }

            @Override
            public void onCaptureCompleted(CameraCaptureSession session, CaptureRequest request,
                    TotalCaptureResult result) {
                    dispatchToFocuser(result);
            }

            private void dispatchToFocuser(CaptureResult result) {
                int afRun;
                synchronized (Camera2Focuser.this) {
                    // In case of partial results, don't send AF update twice
                    long frameCount = result.getFrameNumber();
                    if (frameCount <= mLatestFrameCount) return;
                    mLatestFrameCount = frameCount;

                    afRun = mAfRun;
                }

                if (afRun != finalAfRun) {
                    if (VERBOSE) {
                        Log.w(TAG,
                                ""onCaptureCompleted - Ignoring results from previous AF run ""
                                + finalAfRun);
                    }
                    return;
                }

                mAutoFocus.onCaptureCompleted(result);
            }
        };
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.audio.AnalogHeadsetAudioActivity"	"ConnectListener"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/audio/AnalogHeadsetAudioActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.audio;

import com.android.compatibility.common.util.ReportLog;
import com.android.compatibility.common.util.ResultType;
import com.android.compatibility.common.util.ResultUnit;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;

import android.graphics.Color;

import android.media.AudioDeviceCallback;
import android.media.AudioDeviceInfo;
import android.media.AudioManager;

import android.os.Bundle;
import android.os.Handler;

import android.util.Log;

import android.view.KeyEvent;
import android.view.View;

import android.widget.Button;
import android.widget.TextView;

import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;  // needed to access resource in CTSVerifier project namespace.

// MegaPlayer
import org.hyphonate.megaaudio.player.AudioSourceProvider;
import org.hyphonate.megaaudio.player.JavaPlayer;
import org.hyphonate.megaaudio.player.PlayerBuilder;
import org.hyphonate.megaaudio.player.sources.SinAudioSourceProvider;

public class AnalogHeadsetAudioActivity
        extends PassFailButtons.Activity
        implements View.OnClickListener {
    private static final String TAG = AnalogHeadsetAudioActivity.class.getSimpleName();
    private static final boolean DEBUG = false;

    private AudioManager    mAudioManager;

    // UI
    private Button mHasAnalogPortYesBtn;
    private Button mHasAnalogPortNoBtn;

    private Button mPlayButton;
    private Button mStopButton;
    private Button mPlaybackSuccessBtn;
    private Button mPlaybackFailBtn;

    private TextView mHeadsetNameText;
    private TextView mHeadsetPlugMessage;

    private TextView mHeadsetHookText;
    private TextView mHeadsetVolUpText;
    private TextView mHeadsetVolDownText;

    // Devices
    private AudioDeviceInfo mHeadsetDeviceInfo;
    private boolean mHasHeadsetPort;
    private boolean mPlugIntentReceived;
    private boolean mPlaybackSuccess;

    // Intents
    private HeadsetPlugReceiver mHeadsetPlugReceiver;

    // Buttons
    private boolean mHasHeadsetHook;
    private boolean mHasPlayPause;
    private boolean mHasVolUp;
    private boolean mHasVolDown;

    // Player
    protected boolean mIsPlaying = false;

    // Mega Player
    static final int NUM_CHANNELS = 2;
    static final int SAMPLE_RATE = 48000;

    JavaPlayer mAudioPlayer;

    public AnalogHeadsetAudioActivity() {
        super();
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        setContentView(R.layout.audio_headset_audio_activity);

        mHeadsetNameText = (TextView)findViewById(R.id.headset_analog_name);
        mHeadsetPlugMessage = (TextView)findViewById(R.id.headset_analog_plug_message);

        // Analog Port?
        mHasAnalogPortYesBtn = (Button)findViewById(R.id.headset_analog_port_yes);
        mHasAnalogPortYesBtn.setOnClickListener(this);
        mHasAnalogPortNoBtn = (Button)findViewById(R.id.headset_analog_port_no);
        mHasAnalogPortNoBtn.setOnClickListener(this);

        // Player Controls.
        mPlayButton = (Button)findViewById(R.id.headset_analog_play);
        mPlayButton.setOnClickListener(this);
        mStopButton = (Button)findViewById(R.id.headset_analog_stop);
        mStopButton.setOnClickListener(this);

        // Play Status
        mPlaybackSuccessBtn = (Button)findViewById(R.id.headset_analog_play_yes);
        mPlaybackSuccessBtn.setOnClickListener(this);
        mPlaybackFailBtn = (Button)findViewById(R.id.headset_analog_play_no);
        mPlaybackFailBtn.setOnClickListener(this);
        mPlaybackSuccessBtn.setEnabled(false);
        mPlaybackFailBtn.setEnabled(false);

        // Keycodes
        mHeadsetHookText = (TextView)findViewById(R.id.headset_keycode_headsethook);
        mHeadsetVolUpText = (TextView)findViewById(R.id.headset_keycode_volume_up);
        mHeadsetVolDownText = (TextView)findViewById(R.id.headset_keycode_volume_down);

        mAudioManager = (AudioManager)getSystemService(AUDIO_SERVICE);

        setupPlayer();

        mAudioManager.registerAudioDeviceCallback(new ConnectListener(), new Handler());

        mHeadsetPlugReceiver = new HeadsetPlugReceiver();
        IntentFilter filter = new IntentFilter();
        filter.addAction(Intent.ACTION_HEADSET_PLUG);
        registerReceiver(mHeadsetPlugReceiver, filter);

        showKeyMessagesState();

        setInfoResources(R.string.analog_headset_test, R.string.analog_headset_test_info, -1);

        setPassFailButtonClickListeners();
        getPassButton().setEnabled(false);
    }

    //
    // Reporting
    //
    private boolean calculatePass() {
        if (!mHasHeadsetPort) {
            return true;
        } else {
            return mPlugIntentReceived &&
                    mHeadsetDeviceInfo != null &&
                    mPlaybackSuccess &&
                    (mHasHeadsetHook || mHasPlayPause) && mHasVolUp && mHasVolDown;
        }
    }

    private void reportHeadsetPort(boolean has) {
        mHasHeadsetPort = has;
        getReportLog().addValue(
                ""User Reports Headset Port"",
                has ? 1 : 0,
                ResultType.NEUTRAL,
                ResultUnit.NONE);
        if (has) {
            mHasAnalogPortNoBtn.setEnabled(false);
        } else {
            mHasAnalogPortYesBtn.setEnabled(false);
        }
        enablePlayerButtons(has && mHeadsetDeviceInfo != null);

        if (!has) {
            // no port, so can't test. Let them pass
            getPassButton().setEnabled(true);
        }
    }

    private void reportPlugIntent(Intent intent) {
        // [C-1-4] MUST trigger ACTION_HEADSET_PLUG upon a plug insert,
        // but only after all contacts on plug are touching their relevant segments on the jack.
        mPlugIntentReceived = true;

        // state - 0 for unplugged, 1 for plugged.
        // name - Headset type, human readable string
        // microphone - 1 if headset has a microphone, 0 otherwise

        int state = intent.getIntExtra(""state"", -1);
        if (state != -1) {

            StringBuilder sb = new StringBuilder();
            sb.append(""ACTION_HEADSET_PLUG received - "" + (state == 0 ? ""Unplugged"" : ""Plugged""));

            String name = intent.getStringExtra(""name"");
            if (name != null) {
                sb.append("" - "" + name);
            }

            int hasMic = intent.getIntExtra(""microphone"", 0);
            if (hasMic == 1) {
                sb.append("" [mic]"");
            }

            mHeadsetPlugMessage.setText(sb.toString());
        }
        getReportLog().addValue(
                ""ACTION_HEADSET_PLUG Intent Received. State: "",
                state,
                ResultType.NEUTRAL,
                ResultUnit.NONE);
    }

    private void reportPlaybackStatus(boolean success) {
        // [C-1-1] MUST support audio playback to stereo headphones
        // and stereo headsets with a microphone.
        mPlaybackSuccess = success;
        if (success) {
            mPlaybackFailBtn.setEnabled(false);
        } else {
            mPlaybackSuccessBtn.setEnabled(false);
        }

        mPlaybackSuccessBtn.setEnabled(success);
        mPlaybackFailBtn.setEnabled(success);

        getPassButton().setEnabled(calculatePass());

        getReportLog().addValue(
                ""User reported headset/headphones playback"",
                success ? 1 : 0,
                ResultType.NEUTRAL,
                ResultUnit.NONE);
    }

    //
    // UI
    //
    private void showConnectedDevice() {
        if (mHeadsetDeviceInfo != null) {
            mHeadsetNameText.setText(
                    mHeadsetDeviceInfo.getType() == AudioDeviceInfo.TYPE_WIRED_HEADSET
                    ? ""Headset Connected""
                    : ""Headphones Connected"");
        } else {
            mHeadsetNameText.setText(""No Headset/Headphones Connected"");
        }
    }

    private void enablePlayerButtons(boolean enabled) {
        mPlayButton.setEnabled(enabled);
        mStopButton.setEnabled(enabled);
    }

    private void showKeyMessagesState() {
        mHeadsetHookText.setTextColor((mHasHeadsetHook || mHasPlayPause)
                ? Color.WHITE : Color.GRAY);
        mHeadsetVolUpText.setTextColor(mHasVolUp ? Color.WHITE : Color.GRAY);
        mHeadsetVolDownText.setTextColor(mHasVolDown ? Color.WHITE : Color.GRAY);
    }

    //
    // Player
    //
    protected void setupPlayer() {
        //
        // Allocate the source provider for the sort of signal we want to play
        //
        AudioSourceProvider sourceProvider = new SinAudioSourceProvider();
        try {
            PlayerBuilder builder = new PlayerBuilder();
            mAudioPlayer = (JavaPlayer)builder
                    // choose one or the other of these for a Java or an Oboe player
                    .setPlayerType(PlayerBuilder.TYPE_JAVA)
                    // .setPlayerType(PlayerBuilder.PLAYER_OBOE)
                    .setSourceProvider(sourceProvider)
                    .build();
        } catch (PlayerBuilder.BadStateException ex) {
            Log.e(TAG, ""Failed MegaPlayer build."");
        }
    }

    protected void startPlay() {
        if (!mIsPlaying) {
            //TODO - explain the choice of 96 here.
            mAudioPlayer.setupStream(NUM_CHANNELS, SAMPLE_RATE, 96);
            mAudioPlayer.startStream();
            mIsPlaying = true;
        }
    }

    protected void stopPlay() {
        if (mIsPlaying) {
            mAudioPlayer.stopStream();
            mAudioPlayer.teardownStream();
            mIsPlaying = false;
        }
    }

    //
    // View.OnClickHandler
    //
    @Override
    public void onClick(View view) {
        switch (view.getId()) {
            case R.id.headset_analog_port_yes:
                reportHeadsetPort(true);
                break;

            case R.id.headset_analog_port_no:
                reportHeadsetPort(false);
                break;

            case R.id.headset_analog_play:
                startPlay();
                break;

            case R.id.headset_analog_stop:
                stopPlay();
                mPlaybackSuccessBtn.setEnabled(true);
                mPlaybackFailBtn.setEnabled(true);
                break;

            case R.id.headset_analog_play_yes:
                reportPlaybackStatus(true);
                break;

            case R.id.headset_analog_play_no:
                reportPlaybackStatus(false);
                break;
        }
    }

    //
    // Devices
    //
    private void scanPeripheralList(AudioDeviceInfo[] devices) {
        mHeadsetDeviceInfo = null;
        for(AudioDeviceInfo devInfo : devices) {
            if (devInfo.getType() == AudioDeviceInfo.TYPE_WIRED_HEADSET ||
                    devInfo.getType() == AudioDeviceInfo.TYPE_WIRED_HEADPHONES) {
                mHeadsetDeviceInfo = devInfo;

                getReportLog().addValue(
                        (devInfo.getType() == AudioDeviceInfo.TYPE_WIRED_HEADSET
                                ? ""Headset"" : ""Headphones"") + "" connected"",
                        0,
                        ResultType.NEUTRAL,
                        ResultUnit.NONE);
                break;
            }
        }

        showConnectedDevice();
        enablePlayerButtons(mHeadsetDeviceInfo != null);
    }

    private class ConnectListener extends AudioDeviceCallback {
        /*package*/ ConnectListener() {}

        //
        // AudioDevicesManager.OnDeviceConnectionListener
        //
        @Override
        public void onAudioDevicesAdded(AudioDeviceInfo[] addedDevices) {
            Log.i(TAG, ""onAudioDevicesAdded() num:"" + addedDevices.length);

            scanPeripheralList(mAudioManager.getDevices(AudioManager.GET_DEVICES_ALL));
        }

        @Override
        public void onAudioDevicesRemoved(AudioDeviceInfo[] removedDevices) {
            Log.i(TAG, ""onAudioDevicesRemoved() num:"" + removedDevices.length);

            scanPeripheralList(mAudioManager.getDevices(AudioManager.GET_DEVICES_ALL));
        }
    }

    private class HeadsetPlugReceiver extends BroadcastReceiver {
        @Override
        public void onReceive(Context context, Intent intent) {
            reportPlugIntent(intent);
        }
    }

    //
    // Keycodes
    //
    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event) {
        // Log.i(TAG, ""onKeyDown("" + keyCode + "")"");
        switch (keyCode) {
            case KeyEvent.KEYCODE_HEADSETHOOK:
                mHasHeadsetHook = true;
                showKeyMessagesState();
                getPassButton().setEnabled(calculatePass());
                getReportLog().addValue(
                        ""KEYCODE_HEADSETHOOK"", 1, ResultType.NEUTRAL, ResultUnit.NONE);
                break;

            case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
                mHasPlayPause = true;
                showKeyMessagesState();
                getPassButton().setEnabled(calculatePass());
                getReportLog().addValue(
                        ""KEYCODE_MEDIA_PLAY_PAUSE"", 1, ResultType.NEUTRAL, ResultUnit.NONE);
                break;

            case KeyEvent.KEYCODE_VOLUME_UP:
                mHasVolUp = true;
                showKeyMessagesState();
                getPassButton().setEnabled(calculatePass());
                getReportLog().addValue(
                        ""KEYCODE_VOLUME_UP"", 1, ResultType.NEUTRAL, ResultUnit.NONE);
                break;

            case KeyEvent.KEYCODE_VOLUME_DOWN:
                mHasVolDown = true;
                showKeyMessagesState();
                getPassButton().setEnabled(calculatePass());
                getReportLog().addValue(
                        ""KEYCODE_VOLUME_DOWN"", 1, ResultType.NEUTRAL, ResultUnit.NONE);
                break;
        }
        return super.onKeyDown(keyCode, event);
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.MixedDeviceOwnerTest"	"testStateOfSensorsRelatedPermissionsCannotBeRead"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/MixedDeviceOwnerTest.java"	""	"public void testStateOfSensorsRelatedPermissionsCannotBeRead() throws Exception {
        // Skip because in DO mode the admin can read permission state.
    }

    //TODO(b/180413140) Investigate why the test fails on DO mode.
    @Override"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.apicoverage.TestModuleConfigHandler"	"getTestClassName"	""	"/home/gpoor/cts-12-source/cts/tools/cts-api-coverage/src/com/android/cts/apicoverage/TestModuleConfigHandler.java"	""	"public void test/*
 *.
 */

package com.android.cts.apicoverage;

import com.android.cts.apicoverage.TestSuiteProto.*;

import org.xml.sax.Attributes;
import org.xml.sax.SAXException;
import org.xml.sax.helpers.DefaultHandler;

/**
 * {@link DefaultHandler} that builds an empty {@link ApiCoverage} object from scanning
 * TestModule.xml.
 */
class TestModuleConfigHandler extends DefaultHandler {
    private static final String CONFIGURATION_TAG = ""configuration"";
    private static final String DESCRIPTION_TAG = ""description"";
    private static final String OPTION_TAG = ""option"";
    private static final String TARGET_PREPARER_TAG = ""target_preparer"";
    private static final String TEST_TAG = ""test"";
    private static final String CLASS_TAG = ""class"";
    private static final String NAME_TAG = ""name"";
    private static final String KEY_TAG = ""key"";
    private static final String VALUE_TAG = ""value"";
    private static final String MODULE_NAME_TAG = ""module-name"";
    private static final String GTEST_CLASS_TAG = ""com.android.tradefed.testtype.GTest"";

    private FileMetadata.Builder mFileMetadata;
    private ConfigMetadata.Builder mConfigMetadata;
    private ConfigMetadata.TestClass.Builder mTestCase;
    private ConfigMetadata.TargetPreparer.Builder mTargetPreparer;
    private String mModuleName = null;

    TestModuleConfigHandler(String configFileName) {
        mFileMetadata = FileMetadata.newBuilder();
        mConfigMetadata = ConfigMetadata.newBuilder();
        mTestCase = null;
        mTargetPreparer = null;
        // Default Module Name is the Config File Name
        mModuleName = configFileName.replaceAll("".config$"", """");
    }

    @Override
    public void startElement(String uri, String localName, String name, Attributes attributes)
            throws SAXException {
        super.startElement(uri, localName, name, attributes);

        if (CONFIGURATION_TAG.equalsIgnoreCase(localName)) {
            if (null != attributes.getValue(DESCRIPTION_TAG)) {
                mFileMetadata.setDescription(attributes.getValue(DESCRIPTION_TAG));
            } else {
                mFileMetadata.setDescription(""WARNING: no description."");
            }
        } else if (TEST_TAG.equalsIgnoreCase(localName)) {
            mTestCase = ConfigMetadata.TestClass.newBuilder();
            mTestCase.setTestClass(attributes.getValue(CLASS_TAG));
        } else if (TARGET_PREPARER_TAG.equalsIgnoreCase(localName)) {
            mTargetPreparer = ConfigMetadata.TargetPreparer.newBuilder();
            mTargetPreparer.setTestClass(attributes.getValue(CLASS_TAG));
        } else if (OPTION_TAG.equalsIgnoreCase(localName)) {
            Option.Builder option = Option.newBuilder();
            option.setName(attributes.getValue(NAME_TAG));
            option.setValue(attributes.getValue(VALUE_TAG));
            String keyStr = attributes.getValue(KEY_TAG);
            if (null != keyStr) {
                option.setKey(keyStr);
            }
            if (null != mTestCase) {
                mTestCase.addOptions(option);
                if (MODULE_NAME_TAG.equalsIgnoreCase(option.getName())) {
                    mModuleName = option.getValue();
                }
            } else if (null != mTargetPreparer) {
                mTargetPreparer.addOptions(option);
            }
        }
    }

    @Override
    public void endElement(String uri, String localName, String name) throws SAXException {
        super.endElement(uri, localName, name);
        if (TEST_TAG.equalsIgnoreCase(localName)) {
            mConfigMetadata.addTestClasses(mTestCase);
            mTestCase = null;
        } else if (TARGET_PREPARER_TAG.equalsIgnoreCase(localName)) {
            mConfigMetadata.addTargetPreparers(mTargetPreparer);
            mTargetPreparer = null;
        } else if (CONFIGURATION_TAG.equalsIgnoreCase(localName)) {
            mFileMetadata.setConfigMetadata(mConfigMetadata);
        }
    }

    public String getModuleName() {
        return mModuleName;
    }

    public String getTestClassName() {
        //return the 1st Test Class
        return mFileMetadata.getConfigMetadata().getTestClassesList().get(0).getTestClass();
    }

    public FileMetadata getFileMetadata() {
        return mFileMetadata.build();
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.cts.statsdatom.statsd.AtomTestCase"	"getReportList"	"CtsStatsdAtomHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/statsd/AtomTestCase.java"	""	"public void test/*
 *.
 */
package android.cts.statsdatom.statsd;

import static android.cts.statsdatom.statsd.DeviceAtomTestCase.DEVICE_SIDE_TEST_APK;
import static android.cts.statsdatom.statsd.DeviceAtomTestCase.DEVICE_SIDE_TEST_PACKAGE;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import android.os.BatteryStatsProto;
import android.os.StatsDataDumpProto;
import android.service.battery.BatteryServiceDumpProto;
import android.service.batterystats.BatteryStatsServiceDumpProto;
import android.service.procstats.ProcessStatsServiceDumpProto;

import com.android.annotations.Nullable;
import com.android.internal.os.StatsdConfigProto.AtomMatcher;
import com.android.internal.os.StatsdConfigProto.EventMetric;
import com.android.internal.os.StatsdConfigProto.FieldFilter;
import com.android.internal.os.StatsdConfigProto.FieldMatcher;
import com.android.internal.os.StatsdConfigProto.FieldValueMatcher;
import com.android.internal.os.StatsdConfigProto.GaugeMetric;
import com.android.internal.os.StatsdConfigProto.Predicate;
import com.android.internal.os.StatsdConfigProto.SimpleAtomMatcher;
import com.android.internal.os.StatsdConfigProto.SimplePredicate;
import com.android.internal.os.StatsdConfigProto.StatsdConfig;
import com.android.internal.os.StatsdConfigProto.TimeUnit;
import com.android.os.AtomsProto.AppBreadcrumbReported;
import com.android.os.AtomsProto.Atom;
import com.android.os.AtomsProto.ProcessStatsPackageProto;
import com.android.os.AtomsProto.ProcessStatsProto;
import com.android.os.AtomsProto.ProcessStatsStateProto;
import com.android.os.StatsLog.ConfigMetricsReport;
import com.android.os.StatsLog.ConfigMetricsReportList;
import com.android.os.StatsLog.DurationMetricData;
import com.android.os.StatsLog.EventMetricData;
import com.android.os.StatsLog.GaugeBucketInfo;
import com.android.os.StatsLog.GaugeMetricData;
import com.android.os.StatsLog.CountMetricData;
import com.android.os.StatsLog.StatsLogReport;
import com.android.os.StatsLog.ValueMetricData;
import com.android.tradefed.device.DeviceNotAvailableException;
import com.android.tradefed.log.LogUtil;
import com.android.tradefed.util.CommandResult;
import com.android.tradefed.util.CommandStatus;

import com.google.common.collect.Range;
import com.google.common.io.Files;
import com.google.protobuf.ByteString;

import perfetto.protos.PerfettoConfig.DataSourceConfig;
import perfetto.protos.PerfettoConfig.FtraceConfig;
import perfetto.protos.PerfettoConfig.TraceConfig;

import java.io.File;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.Random;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.function.Function;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

/**
 * Base class for testing Statsd atoms.
 * Validates reporting of statsd logging based on different events
 */
public class AtomTestCase extends BaseTestCase {

    /**
     * Run tests that are optional; they are not valid CTS tests per se, since not all devices can
     * be expected to pass them, but can be run, if desired, to ensure they work when appropriate.
     */
    public static final boolean OPTIONAL_TESTS_ENABLED = false;

    public static final String UPDATE_CONFIG_CMD = ""cmd stats config update"";
    public static final String DUMP_REPORT_CMD = ""cmd stats dump-report"";
    public static final String DUMP_BATTERY_CMD = ""dumpsys battery"";
    public static final String DUMP_BATTERYSTATS_CMD = ""dumpsys batterystats"";
    public static final String DUMPSYS_STATS_CMD = ""dumpsys stats"";
    public static final String DUMP_PROCSTATS_CMD = ""dumpsys procstats"";
    public static final String REMOVE_CONFIG_CMD = ""cmd stats config remove"";
    /** ID of the config, which evaluates to -1572883457. */
    public static final long CONFIG_ID = ""cts_config"".hashCode();

    public static final String FEATURE_AUDIO_OUTPUT = ""android.hardware.audio.output"";
    public static final String FEATURE_AUTOMOTIVE = ""android.hardware.type.automotive"";
    public static final String FEATURE_BLUETOOTH = ""android.hardware.bluetooth"";
    public static final String FEATURE_BLUETOOTH_LE = ""android.hardware.bluetooth_le"";
    public static final String FEATURE_CAMERA = ""android.hardware.camera"";
    public static final String FEATURE_CAMERA_FLASH = ""android.hardware.camera.flash"";
    public static final String FEATURE_CAMERA_FRONT = ""android.hardware.camera.front"";
    public static final String FEATURE_LOCATION_GPS = ""android.hardware.location.gps"";
    public static final String FEATURE_PC = ""android.hardware.type.pc"";
    public static final String FEATURE_PICTURE_IN_PICTURE = ""android.software.picture_in_picture"";
    public static final String FEATURE_TELEPHONY = ""android.hardware.telephony"";
    public static final String FEATURE_WATCH = ""android.hardware.type.watch"";
    public static final String FEATURE_WIFI = ""android.hardware.wifi"";

    // Telephony phone types
    public static final int PHONE_TYPE_GSM = 1;
    public static final int PHONE_TYPE_CDMA = 2;
    public static final int PHONE_TYPE_CDMA_LTE = 6;

    protected static final int WAIT_TIME_SHORT = 500;
    protected static final int WAIT_TIME_LONG = 2_000;

    protected static final long SCREEN_STATE_CHANGE_TIMEOUT = 4000;
    protected static final long SCREEN_STATE_POLLING_INTERVAL = 500;

    protected static final long NS_PER_SEC = (long) 1E+9;

    @Override
    protected void setUp() throws Exception {
        super.setUp();

        // Uninstall to clear the history in case it's still on the device.
        removeConfig(CONFIG_ID);
        getReportList(); // Clears data.
    }

    @Override
    protected void tearDown() throws Exception {
        removeConfig(CONFIG_ID);
        getDevice().uninstallPackage(DEVICE_SIDE_TEST_PACKAGE);
        super.tearDown();
    }

    /**
     * Determines whether logcat indicates that incidentd fired since the given device date.
     */
    protected boolean didIncidentdFireSince(String date) throws Exception {
        final String INCIDENTD_TAG = ""incidentd"";
        final String INCIDENTD_STARTED_STRING = ""reportIncident"";
        // TODO: Do something more robust than this in case of delayed logging.
        Thread.sleep(1000);
        String log = getLogcatSince(date, String.format(
                ""-s %s -e %s"", INCIDENTD_TAG, INCIDENTD_STARTED_STRING));
        return log.contains(INCIDENTD_STARTED_STRING);
    }

    protected boolean checkDeviceFor(String methodName) throws Exception {
        try {
            installPackage(DEVICE_SIDE_TEST_APK, true);
            runDeviceTests(DEVICE_SIDE_TEST_PACKAGE, "".Checkers"", methodName);
            // Test passes, meaning that the answer is true.
            LogUtil.CLog.d(methodName + ""() indicates true."");
            return true;
        } catch (AssertionError e) {
            // Method is designed to fail if the answer is false.
            LogUtil.CLog.d(methodName + ""() indicates false."");
            return false;
        }
    }

    /**
     * Returns a protobuf-encoded perfetto config that enables the kernel
     * ftrace tracer with sched_switch for 10 seconds.
     */
    protected ByteString getPerfettoConfig() {
        TraceConfig.Builder builder = TraceConfig.newBuilder();

        TraceConfig.BufferConfig buffer = TraceConfig.BufferConfig
            .newBuilder()
            .setSizeKb(128)
            .build();
        builder.addBuffers(buffer);

        FtraceConfig ftraceConfig = FtraceConfig.newBuilder()
            .addFtraceEvents(""sched/sched_switch"")
            .build();
        DataSourceConfig dataSourceConfig = DataSourceConfig.newBuilder()
            .setName(""linux.ftrace"")
            .setTargetBuffer(0)
            .setFtraceConfig(ftraceConfig)
            .build();
        TraceConfig.DataSource dataSource = TraceConfig.DataSource
            .newBuilder()
            .setConfig(dataSourceConfig)
            .build();
        builder.addDataSources(dataSource);

        builder.setDurationMs(10000);
        builder.setAllowUserBuildTracing(true);

        // To avoid being hit with guardrails firing in multiple test runs back
        // to back, we set a unique session key for each config.
        Random random = new Random();
        StringBuilder sessionNameBuilder = new StringBuilder(""statsd-cts-"");
        sessionNameBuilder.append(random.nextInt() & Integer.MAX_VALUE);
        builder.setUniqueSessionName(sessionNameBuilder.toString());

        return builder.build().toByteString();
    }

    /**
     * Resets the state of the Perfetto guardrails. This avoids that the test fails if it's
     * run too close of for too many times and hits the upload limit.
     */
    protected void resetPerfettoGuardrails() throws Exception {
        final String cmd = ""perfetto --reset-guardrails"";
        CommandResult cr = getDevice().executeShellV2Command(cmd);
        if (cr.getStatus() != CommandStatus.SUCCESS)
            throw new Exception(String.format(""Error while executing %s: %s %s"", cmd, cr.getStdout(), cr.getStderr()));
    }

    private String probe(String path) throws Exception {
        return getDevice().executeShellCommand(""if [ -e "" + path + "" ] ; then""
                + "" cat "" + path + "" ; else echo -1 ; fi"");
    }

    /**
     * Determines whether perfetto enabled the kernel ftrace tracer.
     */
    protected boolean isSystemTracingEnabled() throws Exception {
        final String traceFsPath = ""/sys/kernel/tracing/tracing_on"";
        String tracing_on = probe(traceFsPath);
        if (tracing_on.startsWith(""0"")) return false;
        if (tracing_on.startsWith(""1"")) return true;

        // fallback to debugfs
        LogUtil.CLog.d(""Unexpected state for %s = %s. Falling back to debugfs"", traceFsPath,
                tracing_on);

        final String debugFsPath = ""/sys/kernel/debug/tracing/tracing_on"";
        tracing_on = probe(debugFsPath);
        if (tracing_on.startsWith(""0"")) return false;
        if (tracing_on.startsWith(""1"")) return true;
        throw new Exception(String.format(""Unexpected state for %s = %s"", traceFsPath, tracing_on));
    }

    protected static StatsdConfig.Builder createConfigBuilder() {
      return StatsdConfig.newBuilder()
          .setId(CONFIG_ID)
          .addAllowedLogSource(""AID_SYSTEM"")
          .addAllowedLogSource(""AID_BLUETOOTH"")
          // TODO(b/134091167): Fix bluetooth source name issue in Auto platform.
          .addAllowedLogSource(""com.android.bluetooth"")
          .addAllowedLogSource(""AID_LMKD"")
          .addAllowedLogSource(""AID_RADIO"")
          .addAllowedLogSource(""AID_ROOT"")
          .addAllowedLogSource(""AID_STATSD"")
          .addAllowedLogSource(""com.android.systemui"")
          .addAllowedLogSource(DeviceAtomTestCase.DEVICE_SIDE_TEST_PACKAGE)
          .addDefaultPullPackages(""AID_RADIO"")
          .addDefaultPullPackages(""AID_SYSTEM"")
          .addWhitelistedAtomIds(Atom.APP_BREADCRUMB_REPORTED_FIELD_NUMBER);
    }

    protected void createAndUploadConfig(int atomTag) throws Exception {
        StatsdConfig.Builder conf = createConfigBuilder();
        addAtomEvent(conf, atomTag);
        uploadConfig(conf);
    }

    protected void uploadConfig(StatsdConfig.Builder config) throws Exception {
        uploadConfig(config.build());
    }

    protected void uploadConfig(StatsdConfig config) throws Exception {
        LogUtil.CLog.d(""Uploading the following config:\n"" + config.toString());
        File configFile = File.createTempFile(""statsdconfig"", "".config"");
        configFile.deleteOnExit();
        Files.write(config.toByteArray(), configFile);
        String remotePath = ""/data/local/tmp/"" + configFile.getName();
        getDevice().pushFile(configFile, remotePath);
        getDevice().executeShellCommand(
                String.join("" "", ""cat"", remotePath, ""|"", UPDATE_CONFIG_CMD,
                        String.valueOf(CONFIG_ID)));
        getDevice().executeShellCommand(""rm "" + remotePath);
    }

    protected void removeConfig(long configId) throws Exception {
        getDevice().executeShellCommand(
                String.join("" "", REMOVE_CONFIG_CMD, String.valueOf(configId)));
    }

    /** Gets the statsd report and sorts it. Note that this also deletes that report from statsd. */
    protected List<EventMetricData> getEventMetricDataList() throws Exception {
        ConfigMetricsReportList reportList = getReportList();
        return getEventMetricDataList(reportList);
    }

    /**
     *  Gets a List of sorted ConfigMetricsReports from ConfigMetricsReportList.
     */
    protected List<ConfigMetricsReport> getSortedConfigMetricsReports(
            ConfigMetricsReportList configMetricsReportList) {
        return configMetricsReportList.getReportsList().stream()
                .sorted(Comparator.comparing(ConfigMetricsReport::getCurrentReportWallClockNanos))
                .collect(Collectors.toList());
    }

    /**
     * Extracts and sorts the EventMetricData from the given ConfigMetricsReportList (which must
     * contain a single report).
     */
    protected List<EventMetricData> getEventMetricDataList(ConfigMetricsReportList reportList)
            throws Exception {
        assertThat(reportList.getReportsCount()).isEqualTo(1);
        ConfigMetricsReport report = reportList.getReports(0);

        List<EventMetricData> data = new ArrayList<>();
        for (StatsLogReport metric : report.getMetricsList()) {
            data.addAll(metric.getEventMetrics().getDataList());
        }
        data.sort(Comparator.comparing(EventMetricData::getElapsedTimestampNanos));

        LogUtil.CLog.d(""Get EventMetricDataList as following:\n"");
        for (EventMetricData d : data) {
            LogUtil.CLog.d(""Atom at "" + d.getElapsedTimestampNanos() + "":\n"" + d.getAtom().toString());
        }
        return data;
    }

    protected List<Atom> getGaugeMetricDataList() throws Exception {
        return getGaugeMetricDataList(/*checkTimestampTruncated=*/false);
    }

    protected List<Atom> getGaugeMetricDataList(boolean checkTimestampTruncated) throws Exception {
        ConfigMetricsReportList reportList = getReportList();
        assertThat(reportList.getReportsCount()).isEqualTo(1);

        // only config
        ConfigMetricsReport report = reportList.getReports(0);
        assertThat(report.getMetricsCount()).isEqualTo(1);

        List<Atom> data = new ArrayList<>();
        for (GaugeMetricData gaugeMetricData :
                report.getMetrics(0).getGaugeMetrics().getDataList()) {
            assertThat(gaugeMetricData.getBucketInfoCount()).isEqualTo(1);
            GaugeBucketInfo bucketInfo = gaugeMetricData.getBucketInfo(0);
            for (Atom atom : bucketInfo.getAtomList()) {
                data.add(atom);
            }
            if (checkTimestampTruncated) {
                for (long timestampNs: bucketInfo.getElapsedTimestampNanosList()) {
                    assertTimestampIsTruncated(timestampNs);
                }
            }
        }

        LogUtil.CLog.d(""Get GaugeMetricDataList as following:\n"");
        for (Atom d : data) {
            LogUtil.CLog.d(""Atom:\n"" + d.toString());
        }
        return data;
    }

    /**
     * Gets the statsd report and extract duration metric data.
     * Note that this also deletes that report from statsd.
     */
    protected List<DurationMetricData> getDurationMetricDataList() throws Exception {
        ConfigMetricsReportList reportList = getReportList();
        assertThat(reportList.getReportsCount()).isEqualTo(1);
        ConfigMetricsReport report = reportList.getReports(0);

        List<DurationMetricData> data = new ArrayList<>();
        for (StatsLogReport metric : report.getMetricsList()) {
            data.addAll(metric.getDurationMetrics().getDataList());
        }

        LogUtil.CLog.d(""Got DurationMetricDataList as following:\n"");
        for (DurationMetricData d : data) {
            LogUtil.CLog.d(""Duration "" + d);
        }
        return data;
    }

    /**
     * Gets the statsd report and extract count metric data.
     * Note that this also deletes that report from statsd.
     */
    protected List<CountMetricData> getCountMetricDataList() throws Exception {
        ConfigMetricsReportList reportList = getReportList();
        assertThat(reportList.getReportsCount()).isEqualTo(1);
        ConfigMetricsReport report = reportList.getReports(0);

        List<CountMetricData> data = new ArrayList<>();
        for (StatsLogReport metric : report.getMetricsList()) {
            data.addAll(metric.getCountMetrics().getDataList());
        }

        LogUtil.CLog.d(""Got CountMetricDataList as following:\n"");
        for (CountMetricData d : data) {
            LogUtil.CLog.d(""Count "" + d);
        }
        return data;
    }

    /**
     * Gets the statsd report and extract value metric data.
     * Note that this also deletes that report from statsd.
     */
    protected List<ValueMetricData> getValueMetricDataList() throws Exception {
        ConfigMetricsReportList reportList = getReportList();
        assertThat(reportList.getReportsCount()).isEqualTo(1);
        ConfigMetricsReport report = reportList.getReports(0);

        List<ValueMetricData> data = new ArrayList<>();
        for (StatsLogReport metric : report.getMetricsList()) {
            data.addAll(metric.getValueMetrics().getDataList());
        }

        LogUtil.CLog.d(""Got ValueMetricDataList as following:\n"");
        for (ValueMetricData d : data) {
            LogUtil.CLog.d(""Value "" + d);
        }
        return data;
    }

    protected StatsLogReport getStatsLogReport() throws Exception {
        ConfigMetricsReport report = getConfigMetricsReport();
        assertThat(report.hasUidMap()).isTrue();
        assertThat(report.getMetricsCount()).isEqualTo(1);
        return report.getMetrics(0);
    }

    protected ConfigMetricsReport getConfigMetricsReport() throws Exception {
        ConfigMetricsReportList reportList = getReportList();
        assertThat(reportList.getReportsCount()).isEqualTo(1);
        return reportList.getReports(0);
    }

    /** Gets the statsd report. Note that this also deletes that report from statsd. */
    protected ConfigMetricsReportList getReportList() throws Exception {
        try {
            ConfigMetricsReportList reportList = getDump(ConfigMetricsReportList.parser(),
                    String.join("" "", DUMP_REPORT_CMD, String.valueOf(CONFIG_ID),
                            ""--include_current_bucket"", ""--proto""));
            return reportList;
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            LogUtil.CLog.e(""Failed to fetch and parse the statsd output report. ""
                    + ""Perhaps there is not a valid statsd config for the requested ""
                    + ""uid="" + getHostUid() + "", id="" + CONFIG_ID + ""."");
            throw (e);
        }
    }

    protected BatteryStatsProto getBatteryStatsProto() throws Exception {
        try {
            BatteryStatsProto batteryStatsProto = getDump(BatteryStatsServiceDumpProto.parser(),
                    String.join("" "", DUMP_BATTERYSTATS_CMD,
                            ""--proto"")).getBatterystats();
            LogUtil.CLog.d(""Got batterystats:\n "" + batteryStatsProto.toString());
            return batteryStatsProto;
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            LogUtil.CLog.e(""Failed to dump batterystats proto"");
            throw (e);
        }
    }

    protected List<ProcessStatsProto> getProcStatsProto() throws Exception {
        try {

            List<ProcessStatsProto> processStatsProtoList =
                new ArrayList<ProcessStatsProto>();
            android.service.procstats.ProcessStatsSectionProto sectionProto = getDump(
                    ProcessStatsServiceDumpProto.parser(),
                    String.join("" "", DUMP_PROCSTATS_CMD,
                            ""--proto"")).getProcstatsNow();
            for (android.service.procstats.ProcessStatsProto stats :
                    sectionProto.getProcessStatsList()) {
                ProcessStatsProto procStats = ProcessStatsProto.parser().parseFrom(
                    stats.toByteArray());
                processStatsProtoList.add(procStats);
            }
            LogUtil.CLog.d(""Got procstats:\n "");
            for (ProcessStatsProto processStatsProto : processStatsProtoList) {
                LogUtil.CLog.d(processStatsProto.toString());
            }
            return processStatsProtoList;
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            LogUtil.CLog.e(""Failed to dump procstats proto"");
            throw (e);
        }
    }

    /*
     * Get all procstats package data in proto
     */
    protected List<ProcessStatsPackageProto> getAllProcStatsProto() throws Exception {
        try {
            android.service.procstats.ProcessStatsSectionProto sectionProto = getDump(
                    ProcessStatsServiceDumpProto.parser(),
                    String.join("" "", DUMP_PROCSTATS_CMD,
                            ""--proto"")).getProcstatsOver24Hrs();
            List<ProcessStatsPackageProto> processStatsProtoList =
                new ArrayList<ProcessStatsPackageProto>();
            for (android.service.procstats.ProcessStatsPackageProto pkgStast :
                sectionProto.getPackageStatsList()) {
              ProcessStatsPackageProto pkgAtom =
                  ProcessStatsPackageProto.parser().parseFrom(pkgStast.toByteArray());
                processStatsProtoList.add(pkgAtom);
            }
            LogUtil.CLog.d(""Got procstats:\n "");
            for (ProcessStatsPackageProto processStatsProto : processStatsProtoList) {
                LogUtil.CLog.d(processStatsProto.toString());
            }
            return processStatsProtoList;
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            LogUtil.CLog.e(""Failed to dump procstats proto"");
            throw (e);
        }
    }

    /*
     * Get all processes' procstats statsd data in proto
     */
    protected List<android.service.procstats.ProcessStatsProto> getAllProcStatsProtoForStatsd()
            throws Exception {
        try {
            android.service.procstats.ProcessStatsSectionProto sectionProto = getDump(
                    android.service.procstats.ProcessStatsSectionProto.parser(),
                    String.join("" "", DUMP_PROCSTATS_CMD,
                            ""--statsd""));
            List<android.service.procstats.ProcessStatsProto> processStatsProtoList
                    = sectionProto.getProcessStatsList();
            LogUtil.CLog.d(""Got procstats:\n "");
            for (android.service.procstats.ProcessStatsProto processStatsProto
                    : processStatsProtoList) {
                LogUtil.CLog.d(processStatsProto.toString());
            }
            return processStatsProtoList;
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            LogUtil.CLog.e(""Failed to dump procstats proto"");
            throw (e);
        }
    }

    protected boolean hasBattery() throws Exception {
        try {
            BatteryServiceDumpProto batteryProto = getDump(BatteryServiceDumpProto.parser(),
                    String.join("" "", DUMP_BATTERY_CMD, ""--proto""));
            LogUtil.CLog.d(""Got battery service dump:\n "" + batteryProto.toString());
            return batteryProto.getIsPresent();
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            LogUtil.CLog.e(""Failed to dump batteryservice proto"");
            throw (e);
        }
    }

    /** Creates a FieldValueMatcher.Builder corresponding to the given field. */
    protected static FieldValueMatcher.Builder createFvm(int field) {
        return FieldValueMatcher.newBuilder().setField(field);
    }

    protected void addAtomEvent(StatsdConfig.Builder conf, int atomTag) throws Exception {
        addAtomEvent(conf, atomTag, new ArrayList<FieldValueMatcher.Builder>());
    }

    /**
     * Adds an event to the config for an atom that matches the given key.
     *
     * @param conf    configuration
     * @param atomTag atom tag (from atoms.proto)
     * @param fvm     FieldValueMatcher.Builder for the relevant key
     */
    protected void addAtomEvent(StatsdConfig.Builder conf, int atomTag,
            FieldValueMatcher.Builder fvm)
            throws Exception {
        addAtomEvent(conf, atomTag, Arrays.asList(fvm));
    }

    /**
     * Adds an event to the config for an atom that matches the given keys.
     *
     * @param conf   configuration
     * @param atomId atom tag (from atoms.proto)
     * @param fvms   list of FieldValueMatcher.Builders to attach to the atom. May be null.
     */
    protected void addAtomEvent(StatsdConfig.Builder conf, int atomId,
            List<FieldValueMatcher.Builder> fvms) throws Exception {

        final String atomName = ""Atom"" + System.nanoTime();
        final String eventName = ""Event"" + System.nanoTime();

        SimpleAtomMatcher.Builder sam = SimpleAtomMatcher.newBuilder().setAtomId(atomId);
        if (fvms != null) {
            for (FieldValueMatcher.Builder fvm : fvms) {
                sam.addFieldValueMatcher(fvm);
            }
        }
        conf.addAtomMatcher(AtomMatcher.newBuilder()
                .setId(atomName.hashCode())
                .setSimpleAtomMatcher(sam));
        conf.addEventMetric(EventMetric.newBuilder()
                .setId(eventName.hashCode())
                .setWhat(atomName.hashCode()));
    }

    /**
     * Adds an atom to a gauge metric of a config
     *
     * @param conf        configuration
     * @param atomId      atom id (from atoms.proto)
     * @param gaugeMetric the gauge metric to add
     */
    protected void addGaugeAtom(StatsdConfig.Builder conf, int atomId,
            GaugeMetric.Builder gaugeMetric) throws Exception {
        final String atomName = ""Atom"" + System.nanoTime();
        final String gaugeName = ""Gauge"" + System.nanoTime();
        final String predicateName = ""APP_BREADCRUMB"";
        SimpleAtomMatcher.Builder sam = SimpleAtomMatcher.newBuilder().setAtomId(atomId);
        conf.addAtomMatcher(AtomMatcher.newBuilder()
                .setId(atomName.hashCode())
                .setSimpleAtomMatcher(sam));
        final String predicateTrueName = ""APP_BREADCRUMB_1"";
        final String predicateFalseName = ""APP_BREADCRUMB_2"";
        conf.addAtomMatcher(AtomMatcher.newBuilder()
                .setId(predicateTrueName.hashCode())
                .setSimpleAtomMatcher(SimpleAtomMatcher.newBuilder()
                        .setAtomId(Atom.APP_BREADCRUMB_REPORTED_FIELD_NUMBER)
                        .addFieldValueMatcher(FieldValueMatcher.newBuilder()
                                .setField(AppBreadcrumbReported.LABEL_FIELD_NUMBER)
                                .setEqInt(1)
                        )
                )
        )
                // Used to trigger predicate
                .addAtomMatcher(AtomMatcher.newBuilder()
                        .setId(predicateFalseName.hashCode())
                        .setSimpleAtomMatcher(SimpleAtomMatcher.newBuilder()
                                .setAtomId(Atom.APP_BREADCRUMB_REPORTED_FIELD_NUMBER)
                                .addFieldValueMatcher(FieldValueMatcher.newBuilder()
                                        .setField(AppBreadcrumbReported.LABEL_FIELD_NUMBER)
                                        .setEqInt(2)
                                )
                        )
                );
        conf.addPredicate(Predicate.newBuilder()
                .setId(predicateName.hashCode())
                .setSimplePredicate(SimplePredicate.newBuilder()
                        .setStart(predicateTrueName.hashCode())
                        .setStop(predicateFalseName.hashCode())
                        .setCountNesting(false)
                )
        );
        gaugeMetric
                .setId(gaugeName.hashCode())
                .setWhat(atomName.hashCode())
                .setCondition(predicateName.hashCode());
        conf.addGaugeMetric(gaugeMetric.build());
    }

    /**
     * Adds an atom to a gauge metric of a config
     *
     * @param conf      configuration
     * @param atomId    atom id (from atoms.proto)
     * @param dimension dimension is needed for most pulled atoms
     */
    protected void addGaugeAtomWithDimensions(StatsdConfig.Builder conf, int atomId,
            @Nullable FieldMatcher.Builder dimension) throws Exception {
        GaugeMetric.Builder gaugeMetric = GaugeMetric.newBuilder()
                .setGaugeFieldsFilter(FieldFilter.newBuilder().setIncludeAll(true).build())
                .setSamplingType(GaugeMetric.SamplingType.CONDITION_CHANGE_TO_TRUE)
                .setMaxNumGaugeAtomsPerBucket(10000)
                .setBucket(TimeUnit.CTS);
        if (dimension != null) {
            gaugeMetric.setDimensionsInWhat(dimension.build());
        }
        addGaugeAtom(conf, atomId, gaugeMetric);
    }

    /**
     * Asserts that each set of states in stateSets occurs at least once in data.
     * Asserts that the states in data occur in the same order as the sets in stateSets.
     *
     * @param stateSets        A list of set of states, where each set represents an equivalent
     *                         state of the device for the purpose of CTS.
     * @param data             list of EventMetricData from statsd, produced by
     *                         getReportMetricListData()
     * @param wait             expected duration (in ms) between state changes; asserts that the
     *                         actual wait
     *                         time was wait/2 <= actual_wait <= 5*wait. Use 0 to ignore this
     *                         assertion.
     * @param getStateFromAtom expression that takes in an Atom and returns the state it contains
     */
    public void assertStatesOccurred(List<Set<Integer>> stateSets, List<EventMetricData> data,
            int wait, Function<Atom, Integer> getStateFromAtom) {
        // Sometimes, there are more events than there are states.
        // Eg: When the screen turns off, it may go into OFF and then DOZE immediately.
        assertWithMessage(""Too few states found"").that(data.size()).isAtLeast(stateSets.size());
        int stateSetIndex = 0; // Tracks which state set we expect the data to be in.
        for (int dataIndex = 0; dataIndex < data.size(); dataIndex++) {
            Atom atom = data.get(dataIndex).getAtom();
            int state = getStateFromAtom.apply(atom);
            // If state is in the current state set, we do not assert anything.
            // If it is not, we expect to have transitioned to the next state set.
            if (stateSets.get(stateSetIndex).contains(state)) {
                // No need to assert anything. Just log it.
                LogUtil.CLog.i(""The following atom at dataIndex="" + dataIndex + "" is ""
                        + ""in stateSetIndex "" + stateSetIndex + "":\n""
                        + data.get(dataIndex).getAtom().toString());
            } else {
                stateSetIndex += 1;
                LogUtil.CLog.i(""Assert that the following atom at dataIndex="" + dataIndex + "" is""
                        + "" in stateSetIndex "" + stateSetIndex + "":\n""
                        + data.get(dataIndex).getAtom().toString());
                assertWithMessage(""Missed first state"").that(dataIndex).isNotEqualTo(0);
                assertWithMessage(""Too many states"").that(stateSetIndex)
                    .isLessThan(stateSets.size());
                assertWithMessage(String.format(""Is in wrong state (%d)"", state))
                    .that(stateSets.get(stateSetIndex)).contains(state);
                if (wait > 0) {
                    assertTimeDiffBetween(data.get(dataIndex - 1), data.get(dataIndex),
                            wait / 2, wait * 5);
                }
            }
        }
        assertWithMessage(""Too few states"").that(stateSetIndex).isEqualTo(stateSets.size() - 1);
    }

    /**
     * Removes all elements from data prior to the first occurrence of an element of state. After
     * this method is called, the first element of data (if non-empty) is guaranteed to be an
     * element in state.
     *
     * @param getStateFromAtom expression that takes in an Atom and returns the state it contains
     */
    public void popUntilFind(List<EventMetricData> data, Set<Integer> state,
            Function<Atom, Integer> getStateFromAtom) {
        int firstStateIdx;
        for (firstStateIdx = 0; firstStateIdx < data.size(); firstStateIdx++) {
            Atom atom = data.get(firstStateIdx).getAtom();
            if (state.contains(getStateFromAtom.apply(atom))) {
                break;
            }
        }
        if (firstStateIdx == 0) {
            // First first element already is in state, so there's nothing to do.
            return;
        }
        data.subList(0, firstStateIdx).clear();
    }

    /**
     * Removes all elements from data after to the last occurrence of an element of state. After
     * this method is called, the last element of data (if non-empty) is guaranteed to be an
     * element in state.
     *
     * @param getStateFromAtom expression that takes in an Atom and returns the state it contains
     */
    public void popUntilFindFromEnd(List<EventMetricData> data, Set<Integer> state,
        Function<Atom, Integer> getStateFromAtom) {
        int lastStateIdx;
        for (lastStateIdx = data.size() - 1; lastStateIdx >= 0; lastStateIdx--) {
            Atom atom = data.get(lastStateIdx).getAtom();
            if (state.contains(getStateFromAtom.apply(atom))) {
                break;
            }
        }
        if (lastStateIdx == data.size()-1) {
            // Last element already is in state, so there's nothing to do.
            return;
        }
        data.subList(lastStateIdx+1, data.size()).clear();
    }

    /** Returns the UID of the host, which should always either be SHELL (2000) or ROOT (0). */
    protected int getHostUid() throws DeviceNotAvailableException {
        String strUid = """";
        try {
            strUid = getDevice().executeShellCommand(""id -u"");
            return Integer.parseInt(strUid.trim());
        } catch (NumberFormatException e) {
            LogUtil.CLog.e(""Failed to get host's uid via shell command. Found "" + strUid);
            // Fall back to alternative method...
            if (getDevice().isAdbRoot()) {
                return 0; // ROOT
            } else {
                return 2000; // SHELL
            }
        }
    }

    protected String getProperty(String prop) throws Exception {
        return getDevice().executeShellCommand(""getprop "" + prop).replace(""\n"", """");
    }

    protected void turnScreenOn() throws Exception {
        getDevice().executeShellCommand(""input keyevent KEYCODE_WAKEUP"");
        getDevice().executeShellCommand(""wm dismiss-keyguard"");
    }

    protected void turnScreenOff() throws Exception {
        getDevice().executeShellCommand(""input keyevent KEYCODE_SLEEP"");
    }

    protected void setChargingState(int state) throws Exception {
        getDevice().executeShellCommand(""cmd battery set status "" + state);
    }

    protected void unplugDevice() throws Exception {
        // On batteryless devices on Android P or above, the 'unplug' command
        // alone does not simulate the really unplugged state.
        //
        // This is because charging state is left as ""unknown"". Unless a valid
        // state like 3 = BatteryManager.BATTERY_STATUS_DISCHARGING is set,
        // framework does not consider the device as running on battery.
        setChargingState(3);

        getDevice().executeShellCommand(""cmd battery unplug"");
    }

    protected void plugInAc() throws Exception {
        getDevice().executeShellCommand(""cmd battery set ac 1"");
    }

    protected void enableLooperStats() throws Exception {
        getDevice().executeShellCommand(""cmd looper_stats enable"");
    }

    protected void resetLooperStats() throws Exception {
        getDevice().executeShellCommand(""cmd looper_stats reset"");
    }

    protected void disableLooperStats() throws Exception {
        getDevice().executeShellCommand(""cmd looper_stats disable"");
    }

    protected void enableBinderStats() throws Exception {
        getDevice().executeShellCommand(""dumpsys binder_calls_stats --enable"");
    }

    protected void resetBinderStats() throws Exception {
        getDevice().executeShellCommand(""dumpsys binder_calls_stats --reset"");
    }

    protected void disableBinderStats() throws Exception {
        getDevice().executeShellCommand(""dumpsys binder_calls_stats --disable"");
    }

    protected void binderStatsNoSampling() throws Exception {
        getDevice().executeShellCommand(""dumpsys binder_calls_stats --no-sampling"");
    }

    public void setAppBreadcrumbPredicate() throws Exception {
        doAppBreadcrumbReportedStart(1);
    }

    public void clearAppBreadcrumbPredicate() throws Exception {
        doAppBreadcrumbReportedStart(2);
    }

    public void doAppBreadcrumbReportedStart(int label) throws Exception {
        doAppBreadcrumbReported(label, AppBreadcrumbReported.State.START.ordinal());
    }

    public void doAppBreadcrumbReportedStop(int label) throws Exception {
        doAppBreadcrumbReported(label, AppBreadcrumbReported.State.STOP.ordinal());
    }

    public void doAppBreadcrumbReported(int label) throws Exception {
        doAppBreadcrumbReported(label, AppBreadcrumbReported.State.UNSPECIFIED.ordinal());
    }

    public void doAppBreadcrumbReported(int label, int state) throws Exception {
        getDevice().executeShellCommand(String.format(
                ""cmd stats log-app-breadcrumb %d %d"", label, state));
    }

    protected void rebootDevice() throws Exception {
        getDevice().rebootUntilOnline();
    }

    /**
     * Asserts that the two events are within the specified range of each other.
     *
     * @param d0        the event that should occur first
     * @param d1        the event that should occur second
     * @param minDiffMs d0 should precede d1 by at least this amount
     * @param maxDiffMs d0 should precede d1 by at most this amount
     */
    public static void assertTimeDiffBetween(EventMetricData d0, EventMetricData d1,
            int minDiffMs, int maxDiffMs) {
        long diffMs = (d1.getElapsedTimestampNanos() - d0.getElapsedTimestampNanos()) / 1_000_000;
        assertWithMessage(""Illegal time difference"")
            .that(diffMs).isIn(Range.closed((long) minDiffMs, (long) maxDiffMs));
    }

    protected String getCurrentLogcatDate() throws Exception {
        // TODO: Do something more robust than this for getting logcat markers.
        long timestampMs = getDevice().getDeviceDate();
        return new SimpleDateFormat(""MM-dd HH:mm:ss.SSS"")
                .format(new Date(timestampMs));
    }

    protected String getLogcatSince(String date, String logcatParams) throws Exception {
        return getDevice().executeShellCommand(String.format(
                ""logcat -v threadtime -t '%s' -d %s"", date, logcatParams));
    }

    // TODO: Remove this and migrate all usages to createConfigBuilder()
    protected StatsdConfig.Builder getPulledConfig() {
        return createConfigBuilder();
    }
    /**
     * Determines if the device has the given feature.
     * Prints a warning if its value differs from requiredAnswer.
     */
    protected boolean hasFeature(String featureName, boolean requiredAnswer) throws Exception {
        final String features = getDevice().executeShellCommand(""pm list features"");
        StringTokenizer featureToken = new StringTokenizer(features, ""\n"");
        boolean hasIt = false;

        while (featureToken.hasMoreTokens()) {
            if ((""feature:"" + featureName).equals(featureToken.nextToken())) {
                 hasIt = true;
                 break;
            }
        }

        if (hasIt != requiredAnswer) {
            LogUtil.CLog.w(""Device does "" + (requiredAnswer ? ""not "" : """") + ""have feature ""
                    + featureName);
        }
        return hasIt == requiredAnswer;
    }

    // Checks that a timestamp has been truncated to be a multiple of 5 min
    protected void assertTimestampIsTruncated(long timestampNs) {
        long fiveMinutesInNs = NS_PER_SEC * 5 * 60;
        assertWithMessage(""Timestamp is not truncated"")
                .that(timestampNs % fiveMinutesInNs).isEqualTo(0);
    }
}"	""	""	"probe"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.media.cts.bitstreams.app.MediaBitstreamsDeviceSideTest"	"isDebuggerConnected"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/media/bitstreams/app/src/android/media/cts/bitstreams/app/MediaBitstreamsDeviceSideTest.java"	""	"/*
 *.
 */

package android.media.cts.bitstreams.app;

import android.app.Instrumentation;
import android.content.Context;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.media.MediaCodec;
import android.media.MediaCodecInfo.CodecProfileLevel;
import android.media.MediaExtractor;
import android.media.MediaFormat;
import android.media.cts.bitstreams.MediaBitstreams;
import android.os.Bundle;
import android.os.Debug;
import android.os.Environment;
import android.util.Xml;

import androidx.test.InstrumentationRegistry;

import com.android.compatibility.common.util.DynamicConfigDeviceSide;
import com.android.compatibility.common.util.MediaUtils;

import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;
import org.xmlpull.v1.XmlSerializer;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.PrintStream;
import java.nio.file.Files;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;

/**
 * Test class that uses device-side media APIs to determine up to which resolution MediaPreparer
 * should copy media files for CtsMediaStressTestCases.
 */
@RunWith(JUnit4.class)
public class MediaBitstreamsDeviceSideTest {

    private static final String KEY_SIZE = ""size"";
    private static final String UTF_8 = ""utf-8"";
    /** Instrumentation status code used to write resolution to metrics */
    private static final int INST_STATUS_IN_PROGRESS = 2;

    private static File mAppCache = InstrumentationRegistry.getContext().getExternalCacheDir();
    private static String mDeviceBitstreamsPath = InstrumentationRegistry.getArguments().getString(
            MediaBitstreams.OPT_DEVICE_BITSTREAMS_PATH,
            MediaBitstreams.DEFAULT_DEVICE_BITSTEAMS_PATH);

    @BeforeClass
    public static void setUp() {
        Bundle args = InstrumentationRegistry.getArguments();
        String debugStr = args.getString(MediaBitstreams.OPT_DEBUG_TARGET_DEVICE, ""false"");
        boolean debug = Boolean.parseBoolean(debugStr);
        if (debug && !Debug.isDebuggerConnected()) {
            Debug.waitForDebugger();
        }
    }

    private static void fixFormat(MediaFormat format, String path) {
        // TODO(b/137684344): Revisit so that we can get this information from
        //                    the bitstream or the extractor.
        if (path.indexOf(""/10bit/"") < 0) {
            return;
        }
        String mime = format.getString(MediaFormat.KEY_MIME);
        int profile = -1, level = -1;
        if (mime.equals(MediaFormat.MIMETYPE_VIDEO_VP9)) {
            profile = CodecProfileLevel.VP9Profile2;
            level = CodecProfileLevel.VP9Level1;
        } else if (mime.equals(MediaFormat.MIMETYPE_VIDEO_HEVC)) {
            profile = CodecProfileLevel.HEVCProfileMain10;
            level = CodecProfileLevel.HEVCMainTierLevel1;
        } else if (mime.equals(MediaFormat.MIMETYPE_VIDEO_AV1)) {
            profile = CodecProfileLevel.AV1ProfileMain10;
            level = CodecProfileLevel.AV1Level2;
        } else {
            return;
        }

        if (!format.containsKey(MediaFormat.KEY_PROFILE)) {
            format.setInteger(MediaFormat.KEY_PROFILE, profile);
        }
        if (!format.containsKey(MediaFormat.KEY_LEVEL)) {
            format.setInteger(MediaFormat.KEY_LEVEL, level);
        }
    }

    static interface ReportCallback {
        void run(OutputStream out) throws Exception;
    }

    static class GenerateBitstreamsFormatsXml implements ReportCallback {
        @Override
        public void run(OutputStream out) throws Exception {

            String[] keys = new String[] {
                    MediaFormat.KEY_WIDTH,
                    MediaFormat.KEY_HEIGHT,
                    MediaFormat.KEY_FRAME_RATE,
                    MediaFormat.KEY_PROFILE,
                    MediaFormat.KEY_LEVEL,
                    MediaFormat.KEY_BIT_RATE};

            XmlSerializer formats = Xml.newSerializer();
            formats.setOutput(out, UTF_8);
            formats.startDocument(UTF_8, true);
            formats.startTag(null, MediaBitstreams.DYNAMIC_CONFIG);

            DynamicConfigDeviceSide config = new DynamicConfigDeviceSide(MediaBitstreams.K_MODULE);
            for (String path : config.keySet()) {

                formats.startTag(null, MediaBitstreams.DYNAMIC_CONFIG_ENTRY);
                formats.attribute(null, MediaBitstreams.DYNAMIC_CONFIG_KEY, path);
                formats.startTag(null, MediaBitstreams.DYNAMIC_CONFIG_VALUE);

                String formatStr = config.getValue(path);
                if (formatStr != null && !formatStr.isEmpty()) {
                    formats.text(formatStr);
                } else {
                    File media = new File(mDeviceBitstreamsPath, path);
                    String fullPath = media.getPath();
                    MediaFormat format = MediaUtils.getTrackFormatForPath(null, fullPath, ""video"");
                    StringBuilder formatStringBuilder = new StringBuilder(MediaFormat.KEY_MIME);
                    formatStringBuilder.append('=').append(format.getString(MediaFormat.KEY_MIME));
                    formatStringBuilder.append(',').append(KEY_SIZE)
                            .append('=').append(media.length());
                    for (String key : keys) {
                        formatStringBuilder.append(',').append(key).append('=');
                        if (format.containsKey(key)) {
                            formatStringBuilder.append(format.getInteger(key));
                        }
                    }
                    formats.text(formatStringBuilder.toString());
                }

                formats.endTag(null, MediaBitstreams.DYNAMIC_CONFIG_VALUE);
                formats.endTag(null, MediaBitstreams.DYNAMIC_CONFIG_ENTRY);

            }

            formats.endTag(null, MediaBitstreams.DYNAMIC_CONFIG);
            formats.endDocument();

        }
    }

    static class GenerateSupportedBitstreamsFormatsTxt implements ReportCallback {

        @Override
        public void run(OutputStream out) throws Exception {

            PrintStream ps = new PrintStream(out);
            Bundle args = InstrumentationRegistry.getArguments();
            String prefix = args.getString(MediaBitstreams.OPT_BITSTREAMS_PREFIX, """");
            DynamicConfigDeviceSide config = new DynamicConfigDeviceSide(MediaBitstreams.K_MODULE);

            for (String path : config.keySet()) {

                if (!path.startsWith(prefix)) {
                    continue;
                }

                String formatStr = config.getValue(path);
                if (formatStr == null || formatStr.isEmpty()) {
                    continue;
                }

                MediaFormat format = parseTrackFormat(formatStr);
                String mime = format.getString(MediaFormat.KEY_MIME);
                String[] decoders = MediaUtils.getDecoderNamesForMime(mime);
                fixFormat(format, path);

                ps.println(path);
                ps.println(decoders.length);
                for (String name : decoders) {
                    ps.println(name);
                    ps.println(MediaUtils.supports(name, format));
                }

            }

            ps.flush();
        }
    }

    static class TestBitstreamsConformance implements ReportCallback {

        ExecutorService mExecutorService;

        private SharedPreferences getSettings() {
            Context ctx = InstrumentationRegistry.getContext();
            SharedPreferences settings = ctx.getSharedPreferences(MediaBitstreams.K_MODULE, 0);
            return settings;
        }

        private void setup() {
            Bundle args = InstrumentationRegistry.getArguments();
            String lastCrash = args.getString(MediaBitstreams.OPT_LAST_CRASH);
            if (lastCrash != null) {
                SharedPreferences settings = getSettings();
                int n = settings.getInt(lastCrash, 0);
                Editor editor = settings.edit();
                editor.putInt(lastCrash, n + 1);
                editor.commit();
            }
        }

        @Override
        public void run(OutputStream out) throws Exception {
            setup();
            mExecutorService = Executors.newFixedThreadPool(3);
            try (
                Scanner sc = new Scanner(
                        new File(mDeviceBitstreamsPath, MediaBitstreams.K_BITSTREAMS_LIST_TXT));
                PrintStream ps = new PrintStream(out, true)
            ) {
                while (sc.hasNextLine()) {
                    verifyBitstream(ps, sc.nextLine());
                }
            } finally {
                mExecutorService.shutdown();
            }
        }

        private List<String> getDecodersForPath(String path) throws IOException {
            List<String> decoders = new ArrayList<>();
            MediaExtractor ex = new MediaExtractor();
            try {
                ex.setDataSource(path);
                MediaFormat format = ex.getTrackFormat(0);
                fixFormat(format, path);
                boolean[] vendors = new boolean[] {false, true};
                for (boolean v : vendors) {
                    for (String name : MediaUtils.getDecoderNames(v, format)) {
                        decoders.add(name);
                    }
                }
            } finally {
                ex.release();
            }
            return decoders;
        }

        private List<String> getFrameChecksumsForPath(String path) throws IOException {
            String md5Path = MediaBitstreams.getMd5Path(path);
            List<String> frameMD5Sums = Files.readAllLines(
                    new File(mDeviceBitstreamsPath, md5Path).toPath());
            for (int i = 0; i < frameMD5Sums.size(); i++) {
                String line = frameMD5Sums.get(i);
                frameMD5Sums.set(i, line.split("" "")[0]);
            }
            return frameMD5Sums;
        }

        private void verifyBitstream(PrintStream ps, String relativePath) {
            ps.println(relativePath);

            List<String> decoders = new ArrayList<>();
            List<String> frameChecksums = new ArrayList<>();
            SharedPreferences settings = getSettings();
            String fullPath = new File(mDeviceBitstreamsPath, relativePath).toString();
            try {
                String lastCrash = MediaBitstreams.generateCrashSignature(relativePath, """");
                if (settings.getInt(lastCrash, 0) >= 3) {
                    ps.println(MediaBitstreams.K_NATIVE_CRASH);
                    return;
                }
                decoders = getDecodersForPath(fullPath);
                frameChecksums = getFrameChecksumsForPath(relativePath);
                ps.println(false);
            } catch (Exception e) {
                ps.println(true);
                ps.println(e.toString());
                return;
            }

            ps.println(decoders.size());
            for (String name : decoders) {
                ps.println(name);
                String lastCrash = MediaBitstreams.generateCrashSignature(relativePath, name);
                if (settings.getInt(lastCrash, 0) >= 3) {
                    ps.println(MediaBitstreams.K_NATIVE_CRASH);
                } else {
                    ps.println(verifyBitstream(fullPath, name, frameChecksums));
                }
            }

        }

        private String verifyBitstream(String path, String name, List<String> frameChecksums)  {
            MediaExtractor ex = new MediaExtractor();
            MediaCodec d = null;
            try {
                Future<MediaCodec> dec = mExecutorService.submit(new Callable<MediaCodec>() {
                    @Override
                    public MediaCodec call() throws Exception {
                        return MediaCodec.createByCodecName(name);
                    }
                });
                MediaCodec decoder = d = dec.get(1, TimeUnit.SECONDS);
                Future<Boolean> conform = mExecutorService.submit(new Callable<Boolean>() {
                    @Override
                    public Boolean call() throws Exception {
                        ex.setDataSource(path);
                        ex.selectTrack(0);
                        ex.seekTo(0, MediaExtractor.SEEK_TO_NEXT_SYNC);
                        return MediaUtils.verifyDecoder(decoder, ex, frameChecksums);
                    }
                });
                return conform.get(15, TimeUnit.SECONDS).toString();
            } catch (Exception e) {
                return e.toString();
            } finally {
                ex.release();
                if (d != null) {
                    d.release();
                }
            }
        }

    }

    private void generateReportFile(String suffix, String reportKey, ReportCallback callback)
            throws IOException, FileNotFoundException, Exception {

        OutputStream out = new ByteArrayOutputStream(0);

        try {

            File tmpf = File.createTempFile(getClass().getSimpleName(), suffix, Environment.getExternalStorageDirectory());
            Instrumentation inst = InstrumentationRegistry.getInstrumentation();
            Bundle bundle = new Bundle();
            bundle.putString(MediaBitstreams.KEY_APP_CACHE_DIR, mAppCache.getCanonicalPath());
            bundle.putString(reportKey, tmpf.getCanonicalPath());
            inst.sendStatus(INST_STATUS_IN_PROGRESS, bundle);

            out = new FileOutputStream(tmpf);
            callback.run(out);
            out.flush();

        } finally {

            out.close();

        }
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.tests.getinfo.DeviceInfoInstrument"	"DisplayMetrics"	""	"/home/gpoor/cts-12-source/cts/tools/device-setup/TestDeviceSetup/src/android/tests/getinfo/DeviceInfoInstrument.java"	""	"public void test/*
 *.
 */

package android.tests.getinfo;

import android.app.Activity;
import android.app.ActivityManager;
import android.app.ActivityManager.MemoryInfo;
import android.app.Instrumentation;
import android.content.Context;
import android.content.Intent;
import android.content.pm.FeatureInfo;
import android.content.pm.PackageManager;
import android.content.res.Configuration;
import android.os.Build;
import android.os.Bundle;
import android.os.Environment;
import android.os.UserManager;
import android.os.SystemProperties;
import android.telephony.TelephonyManager;
import android.text.TextUtils;
import android.util.DisplayMetrics;
import android.util.Log;
import android.view.Display;
import android.view.WindowManager;

import com.android.compatibility.common.util.ShellIdentityUtils;

import java.io.IOException;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Scanner;
import java.util.Set;

public class DeviceInfoInstrument extends Instrumentation implements DeviceInfoConstants {

    private static final String TAG = ""DeviceInfoInstrument"";

    private static Bundle mResults = new Bundle();

    public DeviceInfoInstrument() {
        super();
    }

    @Override
    public void onCreate(Bundle arguments) {
        start();
    }

    @Override
    public void onStart() {
        addResult(BUILD_ID, Build.ID);
        addResult(PRODUCT_NAME, Build.PRODUCT);
        addResult(BUILD_DEVICE, Build.DEVICE);
        addResult(BUILD_BOARD, Build.BOARD);
        addResult(BUILD_MANUFACTURER, Build.MANUFACTURER);
        addResult(BUILD_BRAND, Build.BRAND);
        addResult(BUILD_MODEL, Build.MODEL);
        addResult(BUILD_TYPE, Build.TYPE);
        addResult(BUILD_FINGERPRINT, Build.FINGERPRINT);
        addResult(BUILD_ABI, Build.CPU_ABI);
        addResult(BUILD_ABI2, Build.CPU_ABI2);
        addResult(BUILD_ABIS, TextUtils.join("","", Build.SUPPORTED_ABIS));
        addResult(BUILD_ABIS_32, TextUtils.join("","", Build.SUPPORTED_32_BIT_ABIS));
        addResult(BUILD_ABIS_64, TextUtils.join("","", Build.SUPPORTED_64_BIT_ABIS));
        addResult(SERIAL_NUMBER, Build.SERIAL);

        addResult(REFERENCE_BUILD_FINGERPRINT,
            SystemProperties.get(""ro.build.reference.fingerprint"", """"));

        addResult(VERSION_RELEASE, Build.VERSION.RELEASE_OR_CODENAME);
        addResult(VERSION_SDK, Build.VERSION.SDK);
        addResult(VERSION_BASE_OS, Build.VERSION.BASE_OS);
        addResult(VERSION_SECURITY_PATCH, Build.VERSION.SECURITY_PATCH);

        DisplayMetrics metrics = new DisplayMetrics();
        WindowManager wm = (WindowManager) getContext().getSystemService(
                Context.WINDOW_SERVICE);
        Display d = wm.getDefaultDisplay();
        d.getRealMetrics(metrics);
        addResult(RESOLUTION, String.format(""%sx%s"", metrics.widthPixels, metrics.heightPixels));
        addResult(SCREEN_DENSITY, metrics.density);
        addResult(SCREEN_X_DENSITY, metrics.xdpi);
        addResult(SCREEN_Y_DENSITY, metrics.ydpi);

        String screenDensityBucket = getScreenDensityBucket(metrics);
        addResult(SCREEN_DENSITY_BUCKET, screenDensityBucket);

        String screenSize = getScreenSize();
        addResult(SCREEN_SIZE, screenSize);

        Configuration configuration = getContext().getResources().getConfiguration();
        addResult(SMALLEST_SCREEN_WIDTH_DP, configuration.smallestScreenWidthDp);

        Intent intent = new Intent();
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        intent.setClass(this.getContext(), DeviceInfoActivity.class);

        DeviceInfoActivity activity = (DeviceInfoActivity) startActivitySync(intent);
        waitForIdleSync();
        activity.waitForAcitityToFinish();

        TelephonyManager tm = (TelephonyManager) getContext().getSystemService(
                Context.TELEPHONY_SERVICE);
        // network
        String network = tm.getNetworkOperatorName();
        addResult(NETWORK, network.trim());
        // imei
        String imei = ShellIdentityUtils.invokeMethodWithShellPermissions(tm,
                (telephonyManager) -> telephonyManager.getDeviceId());
        addResult(IMEI, imei);

        // imsi
        String imsi = ShellIdentityUtils.invokeMethodWithShellPermissions(tm,
                (telephonyManager) -> telephonyManager.getSubscriberId());
        addResult(IMSI, imsi);

        // phone number
        String phoneNumber = tm.getLine1Number();
        addResult(PHONE_NUMBER, phoneNumber);

        // features
        String features = getFeatures();
        addResult(FEATURES, features);

        // processes
        String processes = getProcesses();
        addResult(PROCESSES, processes);

        // OpenGL ES version
        String openGlEsVersion = getOpenGlEsVersion();
        addResult(OPEN_GL_ES_VERSION, openGlEsVersion);

        // partitions
        String partitions = getPartitions();
        addResult(PARTITIONS, partitions);

        // System libraries
        String sysLibraries = getSystemLibraries();
        addResult(SYS_LIBRARIES, sysLibraries);

        // Storage devices
        addResult(STORAGE_DEVICES, getStorageDevices());

        // Multi-user support
        addResult(MULTI_USER, getMultiUserInfo());

        // Encrypted
        addResult(ENCRYPTED, getEncrypted());

        // Memory Info
        addResult(IS_LOW_RAM_DEVICE, isLowRamDevice());
        addResult(MEMORY_CLASS, getMemoryClass());
        addResult(LARGE_MEMORY_CLASS, getLargeMemoryClass());
        addResult(TOTAL_MEMORY, getTotalMemory());

        // CPU Info
        addResult(AVAILABLE_PROCESSORS, Runtime.getRuntime().availableProcessors());

        finish(Activity.RESULT_OK, mResults);
    }

    /**
     * Add string result.
     *
     * @param key the string of the key name.
     * @param value string value.
     */
    static void addResult(final String key, final String value){
        mResults.putString(key, value);
    }

    /**
     * Add integer result.
     *
     * @param key the string of the key name.
     * @param value integer value.
     */
    static void addResult(final String key, final int value){
        mResults.putInt(key, value);
    }

    /**
     * Add float result.
     *
     * @param key the string of the key name.
     * @param value float value.
     */
    static void addResult(final String key, final float value){
        mResults.putFloat(key, value);
    }

    private String getScreenSize() {
        Configuration config = getContext().getResources().getConfiguration();
        int screenLayout = config.screenLayout & Configuration.SCREENLAYOUT_SIZE_MASK;
        String screenSize = String.format(""0x%x"", screenLayout);
        switch (screenLayout) {
            case Configuration.SCREENLAYOUT_SIZE_SMALL:
                screenSize = ""small"";
                break;

            case Configuration.SCREENLAYOUT_SIZE_NORMAL:
                screenSize = ""normal"";
                break;

            case Configuration.SCREENLAYOUT_SIZE_LARGE:
                screenSize = ""large"";
                break;

            case Configuration.SCREENLAYOUT_SIZE_XLARGE:
                screenSize = ""xlarge"";
                break;

            case Configuration.SCREENLAYOUT_SIZE_UNDEFINED:
                screenSize = ""undefined"";
                break;
        }
        return screenSize;
    }

    private String getScreenDensityBucket(DisplayMetrics metrics) {
        switch (metrics.densityDpi) {
            case DisplayMetrics.DENSITY_LOW:
                return ""ldpi"";

            case DisplayMetrics.DENSITY_MEDIUM:
                return ""mdpi"";

            case DisplayMetrics.DENSITY_TV:
                return ""tvdpi"";

            case DisplayMetrics.DENSITY_HIGH:
                return ""hdpi"";

            case DisplayMetrics.DENSITY_XHIGH:
                return ""xdpi"";

            default:
                return """" + metrics.densityDpi;
        }
    }

    /**
     * Return a summary of the device's feature as a semi-colon-delimited list of colon separated
     * name and availability pairs like ""feature1:sdk:true;feature2:sdk:false;feature3:other:true;"".
     */
    private String getFeatures() {
        StringBuilder features = new StringBuilder();

        try {
            Set<String> checkedFeatures = new HashSet<String>();

            PackageManager packageManager = getContext().getPackageManager();
            for (String featureName : getPackageManagerFeatures()) {
                checkedFeatures.add(featureName);
                boolean hasFeature = packageManager.hasSystemFeature(featureName);
                addFeature(features, featureName, ""sdk"", hasFeature);
            }

            FeatureInfo[] featureInfos = packageManager.getSystemAvailableFeatures();
            if (featureInfos != null) {
                for (FeatureInfo featureInfo : featureInfos) {
                    if (featureInfo.name != null && !checkedFeatures.contains(featureInfo.name)) {
                        addFeature(features, featureInfo.name, ""other"", true);
                    }
                }
            }
        } catch (Exception exception) {
            Log.e(TAG, ""Error getting features: "" + exception.getMessage(), exception);
        }

        return features.toString();
    }

    private static void addFeature(StringBuilder features, String name, String type,
            boolean available) {
        features.append(name).append(':').append(type).append(':').append(available).append(';');
    }

    /**
     * Use reflection to get the features defined by the SDK. If there are features that do not fit
     * the convention of starting with ""FEATURE_"" then they will still be shown under the
     * ""Other Features"" section.
     *
     * @return list of feature names from sdk
     */
    private List<String> getPackageManagerFeatures() {
        try {
            List<String> features = new ArrayList<String>();
            Field[] fields = PackageManager.class.getFields();
            for (Field field : fields) {
                if (field.getName().startsWith(""FEATURE_"")) {
                    String feature = (String) field.get(null);
                    features.add(feature);
                }
            }
            return features;
        } catch (IllegalAccessException illegalAccess) {
            throw new RuntimeException(illegalAccess);
        }
    }

    /**
     * Return a semi-colon-delimited list of the root processes that were running on the phone
     * or an error message.
     */
    private static String getProcesses() {
        StringBuilder builder = new StringBuilder();

        try {
            String[] rootProcesses = RootProcessScanner.getRootProcesses();
            for (String rootProcess : rootProcesses) {
                builder.append(rootProcess).append(':').append(0).append(';');
            }
        } catch (Exception exception) {
            Log.e(TAG, ""Error getting processes: "" + exception.getMessage(), exception);
            builder.append(exception.getMessage());
        }

        return builder.toString();
    }

    /** @return a string containing the Open GL ES version number or an error message */
    private String getOpenGlEsVersion() {
        PackageManager packageManager = getContext().getPackageManager();
        FeatureInfo[] featureInfos = packageManager.getSystemAvailableFeatures();
        if (featureInfos != null && featureInfos.length > 0) {
            for (FeatureInfo featureInfo : featureInfos) {
                // Null feature name means this feature is the open gl es version feature.
                if (featureInfo.name == null) {
                    return featureInfo.getGlEsVersion();
                }
            }
        }
        return ""No feature for Open GL ES version."";
    }

    private String getPartitions() {
        try {
            StringBuilder builder = new StringBuilder();
            Process df = new ProcessBuilder(""df"").start();
            Scanner scanner = new Scanner(df.getInputStream());
            try {
                while (scanner.hasNextLine()) {
                    builder.append(scanner.nextLine()).append(';');
                }
                return builder.toString();
            } finally {
                scanner.close();
            }
        } catch (IOException e) {
            return ""Not able to run df for partition information."";
        }
    }

    private String getSystemLibraries() {
        PackageManager pm = getContext().getPackageManager();
        String list[] = pm.getSystemSharedLibraryNames();

        StringBuilder builder = new StringBuilder();
        for (String lib : list) {
            builder.append(lib);
            builder.append("";"");
        }

        return builder.toString();
    }

    private String getStorageDevices() {
        int count = 0;
        count = Math.max(count, getContext().getExternalCacheDirs().length);
        count = Math.max(count, getContext().getExternalFilesDirs(null).length);
        count = Math.max(
                count, getContext().getExternalFilesDirs(Environment.DIRECTORY_PICTURES).length);
        count = Math.max(count, getContext().getObbDirs().length);

        if (Environment.isExternalStorageEmulated()) {
            if (count == 1) {
                return ""1 emulated"";
            } else {
                return ""1 emulated, "" + (count - 1) + "" physical media"";
            }
        } else {
            return count + "" physical media"";
        }
    }

    private String getMultiUserInfo() {
        try {
            final Method method = UserManager.class.getMethod(""getMaxSupportedUsers"");
            final Integer maxUsers = (Integer) method.invoke(null);
            if (maxUsers == 1) {
                return ""single user"";
            } else {
                return maxUsers + "" users supported"";
            }
        } catch (ClassCastException e) {
        } catch (NoSuchMethodException e) {
        } catch (InvocationTargetException e) {
        } catch (IllegalAccessException e) {
        }

        return ""unknown"";
    }

    private static String getProperty(String property)
            throws IOException {
        Process process = new ProcessBuilder(""getprop"", property).start();
        Scanner scanner = null;
        String line = """";
        try {
            scanner = new Scanner(process.getInputStream());
            line = scanner.nextLine();
        } finally {
            if (scanner != null) {
                scanner.close();
            }
        }
        return line;
    }

    private int getEncrypted() {
        try {
            return ""encrypted"".equals(getProperty(""ro.crypto.state"")) ? 1 : 0;
        } catch (IOException e) {
        }

        return 0;
    }

    private String isLowRamDevice() {
        ActivityManager activityManager = (ActivityManager) getContext()
                .getSystemService(Context.ACTIVITY_SERVICE);
        return activityManager.isLowRamDevice() ? ""true"" : ""false"";
    }

    private String getMemoryClass() {
        ActivityManager activityManager = (ActivityManager) getContext()
                .getSystemService(Context.ACTIVITY_SERVICE);
        return String.valueOf(activityManager.getMemoryClass());
    }

    private String getLargeMemoryClass() {
        ActivityManager activityManager = (ActivityManager) getContext()
                .getSystemService(Context.ACTIVITY_SERVICE);
        return String.valueOf(activityManager.getLargeMemoryClass());
    }

    private String getTotalMemory() {
        ActivityManager activityManager = (ActivityManager) getContext()
                .getSystemService(Context.ACTIVITY_SERVICE);

        MemoryInfo memoryInfo = new MemoryInfo();
        activityManager.getMemoryInfo(memoryInfo);
        return String.valueOf(memoryInfo.totalMem);
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.telephony.cts.TelephonyLocationTests"	"testSdk28CellInfoUpdate"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyLocationTests.java"	""	"public void testSdk28CellInfoUpdate() {
        if (!mShouldTest) return;

        // Verify that a target-sdk 28 app still requires fine location access
        // to call requestCellInfoUpdate
        withRevokedPermission(LOCATION_ACCESS_APP_SDK28_PACKAGE, () -> {
            try {
                List<CellInfo> cis = (List<CellInfo>) performLocationAccessCommandSdk28(
                        CtsLocationAccessService.COMMAND_REQUEST_CELL_INFO_UPDATE);
                assertTrue(cis == null || cis.isEmpty());
            } catch (SecurityException e) {
                // expected
            }
        }, Manifest.permission.ACCESS_FINE_LOCATION);
    }

    private ICtsLocationAccessControl getLocationAccessAppControl() {
        Intent bindIntent = new Intent(CtsLocationAccessService.CONTROL_ACTION);
        bindIntent.setComponent(new ComponentName(
                LOCATION_ACCESS_APP_CURRENT_PACKAGE,
                CtsLocationAccessService.class.getName()));

        return bindLocationAccessControl(bindIntent);
    }

    private ICtsLocationAccessControl getLocationAccessAppControlSdk28() {
        Intent bindIntent = new Intent(CtsLocationAccessService.CONTROL_ACTION);
        bindIntent.setComponent(new ComponentName(
                LOCATION_ACCESS_APP_SDK28_PACKAGE,
                CtsLocationAccessService.class.getName()));

        return bindLocationAccessControl(bindIntent);
    }

    private ICtsLocationAccessControl bindLocationAccessControl(Intent bindIntent) {
        LinkedBlockingQueue<ICtsLocationAccessControl> pipe =
                new LinkedBlockingQueue<>();
        InstrumentationRegistry.getContext().bindService(bindIntent, new ServiceConnection() {
            @Override
            public void onServiceConnected(ComponentName name, IBinder service) {
                pipe.offer(ICtsLocationAccessControl.Stub.asInterface(service));
            }

            @Override
            public void onServiceDisconnected(ComponentName name) {

            }
        }, Context.BIND_AUTO_CREATE);

        try {
            return pipe.poll(TEST_TIMEOUT, TimeUnit.MILLISECONDS);
        } catch (InterruptedException e) {
            fail(""interrupted"");
        }
        fail(""Unable to connect to location access test app"");
        return null;
    }

    private Object performLocationAccessCommand(String command) {
        int tries = 0;
        while (tries < 5) {
            ICtsLocationAccessControl control = getLocationAccessAppControl();
            try {
                List ret = control.performCommand(command);
                if (!ret.isEmpty()) return ret.get(0);
            } catch (RemoteException e) {
                tries++;
            }
        }
        fail(""Too many remote exceptions"");
        return null;
    }

    private Object performLocationAccessCommandSdk28(String command) {
        ICtsLocationAccessControl control = getLocationAccessAppControlSdk28();
        try {
            List ret = control.performCommand(command);
            if (!ret.isEmpty()) return ret.get(0);
        } catch (RemoteException e) {
            fail(""Remote exception"");
        }
        return null;
    }

    private void withRevokedPermission(String packageName, Runnable r, String permission) {
        // Bind to the appropriate testapp first so that we know when the permission has been fully
        // revoked -- that way after we bind again we know it's not going to be killed
        // due to a race condition.

        Intent bindIntent = new Intent(CtsLocationAccessService.CONTROL_ACTION);
        bindIntent.setComponent(new ComponentName(packageName,
                CtsLocationAccessService.class.getName()));

        CompletableFuture<Void> bindSuccess = new CompletableFuture<>();
        CompletableFuture<Void> serviceKilled = new CompletableFuture<>();
        InstrumentationRegistry.getContext().bindService(bindIntent, new ServiceConnection() {
            @Override
            public void onServiceConnected(ComponentName name, IBinder service) {
                bindSuccess.complete(null);
            }

            @Override
            public void onServiceDisconnected(ComponentName name) {
                serviceKilled.complete(null);
            }
        }, Context.BIND_AUTO_CREATE);

        try {
            bindSuccess.get(TEST_TIMEOUT, TimeUnit.MILLISECONDS);
        } catch (Exception e) {
            fail(""unable to perform initial bind probe when revoking permissions:"" + e);
        }

        InstrumentationRegistry.getInstrumentation()
                .getUiAutomation().revokeRuntimePermission(packageName, permission);

        try {
            try {
                serviceKilled.get(TEST_TIMEOUT, TimeUnit.MILLISECONDS);
            } catch (Exception e) {
                fail(""unable to verify disconnect of initial bind probe when""
                        + "" revoking permissions:"" + e);
            }

            r.run();
        } finally {
            InstrumentationRegistry.getInstrumentation()
                    .getUiAutomation().grantRuntimePermission(packageName, permission);
        }
    }

    private void assertServiceStateSanitization(ServiceState state, boolean sanitizedForFineOnly) {
        if (state == null) return;

        if (state.getNetworkRegistrationInfoList() != null) {
            for (NetworkRegistrationInfo nrs : state.getNetworkRegistrationInfoList()) {
                assertNull(nrs.getCellIdentity());
            }
        }

        if (sanitizedForFineOnly) return;

        assertTrue(TextUtils.isEmpty(state.getOperatorAlphaLong()));
        assertTrue(TextUtils.isEmpty(state.getOperatorAlphaShort()));
        assertTrue(TextUtils.isEmpty(state.getOperatorNumeric()));
    }

}"	""	""	"probe"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.media.cts.Utils"	"isEmpty"	""	"/home/gpoor/cts-12-source/cts/tests/tests/media/common/src/android/media/cts/Utils.java"	""	"public void test/*
 *.
 */

package android.media.cts;

import android.app.Instrumentation;
import android.app.NotificationManager;
import android.app.UiAutomation;
import android.content.Context;
import android.media.AudioManager;
import android.media.AudioPlaybackConfiguration;
import android.media.MediaPlayer;
import android.media.session.MediaSessionManager.RemoteUserInfo;
import android.net.Uri;
import android.os.Bundle;
import android.os.Handler;
import android.os.HandlerThread;
import android.os.ParcelFileDescriptor;
import android.platform.test.annotations.AppModeFull;
import android.util.Log;
import androidx.test.platform.app.InstrumentationRegistry;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.List;
import java.util.Scanner;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

import junit.framework.Assert;

public class Utils {
    private static final String TAG = ""CtsMediaTestUtil"";
    private static final int TEST_TIMING_TOLERANCE_MS = 500;
    private static final String MEDIA_PATH_INSTR_ARG_KEY = ""media-path"";

    public static void enableAppOps(String packageName, String operation,
            Instrumentation instrumentation) {
        setAppOps(packageName, operation, instrumentation, true);
    }

    public static void disableAppOps(String packageName, String operation,
            Instrumentation instrumentation) {
        setAppOps(packageName, operation, instrumentation, false);
    }

    public static String convertStreamToString(InputStream is) {
        try (Scanner scanner = new Scanner(is).useDelimiter(""\\A"")) {
            return scanner.hasNext() ? scanner.next() : """";
        }
    }

    public static String getMediaPath() {
        Bundle bundle = InstrumentationRegistry.getArguments();
        String mediaPath = bundle.getString(MEDIA_PATH_INSTR_ARG_KEY);
        Log.i(TAG, ""Media Path value is: "" + mediaPath);

        if (mediaPath != null && !mediaPath.isEmpty()) {
            if (mediaPath.startsWith(""http"") || mediaPath.startsWith(""file"")) {
                return mediaPath;
            }
            // Otherwise, assume a file path that is not already Uri formatted
            return Uri.fromFile(new File(mediaPath)).toString();
        }
        return ""https://storage.googleapis.com/wvmedia"";
    }

    private static void setAppOps(String packageName, String operation,
            Instrumentation instrumentation, boolean enable) {
        StringBuilder cmd = new StringBuilder();
        cmd.append(""appops set "");
        cmd.append(packageName);
        cmd.append("" "");
        cmd.append(operation);
        cmd.append(enable ? "" allow"" : "" deny"");
        instrumentation.getUiAutomation().executeShellCommand(cmd.toString());

        StringBuilder query = new StringBuilder();
        query.append(""appops get "");
        query.append(packageName);
        query.append("" "");
        query.append(operation);
        String queryStr = query.toString();

        String expectedResult = enable ? ""allow"" : ""deny"";
        String result = """";
        while(!result.contains(expectedResult)) {
            ParcelFileDescriptor pfd = instrumentation.getUiAutomation().executeShellCommand(
                                                            queryStr);
            InputStream inputStream = new FileInputStream(pfd.getFileDescriptor());
            result = convertStreamToString(inputStream);
        }
    }

    public static void toggleNotificationPolicyAccess(String packageName,
            Instrumentation instrumentation, boolean on) throws IOException {

        String command = "" cmd notification "" + (on ? ""allow_dnd "" : ""disallow_dnd "") + packageName;

        // Get permission to enable accessibility
        UiAutomation uiAutomation = instrumentation.getUiAutomation();
        // Execute command
        try (ParcelFileDescriptor fd = uiAutomation.executeShellCommand(command)) {
            Assert.assertNotNull(""Failed to execute shell command: "" + command, fd);
            // Wait for the command to finish by reading until EOF
            try (InputStream in = new FileInputStream(fd.getFileDescriptor())) {
                byte[] buffer = new byte[4096];
                while (in.read(buffer) > 0) {}
            } catch (IOException e) {
                throw new IOException(""Could not read stdout of command: "" + command, e);
            }
        } finally {
            uiAutomation.destroy();
        }

        NotificationManager nm = (NotificationManager) instrumentation.getContext()
                .getSystemService(Context.NOTIFICATION_SERVICE);
        Assert.assertEquals(""Wrote setting should be the same as the read one"", on,
                nm.isNotificationPolicyAccessGranted());
    }

    static boolean compareRemoteUserInfo(RemoteUserInfo a, RemoteUserInfo b) {
        if (a == null && b == null) {
            return true;
        } else if (a == null || b == null) {
            return false;
        }
        return a.getPackageName().equals(b.getPackageName())
                && a.getPid() == b.getPid()
                && a.getUid() == b.getUid();
    }

    /**
     * Assert that a media playback is started and an active {@link AudioPlaybackConfiguration}
     * is created once. The playback will be stopped immediately after that.
     * <p>For a media session to receive media button events, an actual playback is needed.
     */
    @AppModeFull(reason = ""Instant apps cannot access the SD card"")
    static void assertMediaPlaybackStarted(Context context) {
        final AudioManager am = new AudioManager(context);
        final HandlerThread handlerThread = new HandlerThread(TAG);
        handlerThread.start();
        final TestAudioPlaybackCallback callback = new TestAudioPlaybackCallback();
        MediaPlayer mediaPlayer = null;
        final String mInpPrefix = WorkDir.getMediaDirString();

        try {
            final int activeConfigSizeBeforeStart = am.getActivePlaybackConfigurations().size();
            final Handler handler = new Handler(handlerThread.getLooper());

            am.registerAudioPlaybackCallback(callback, handler);
            File testAudioFile = new File(mInpPrefix + ""sine1khzm40db.wav"");
            Assert.assertTrue(""Test audio file does not exist! path=""
                            + testAudioFile.getAbsolutePath(), testAudioFile.exists());
            mediaPlayer = MediaPlayer.create(context, Uri.fromFile(testAudioFile));
            mediaPlayer.start();
            if (!callback.mCountDownLatch.await(TEST_TIMING_TOLERANCE_MS, TimeUnit.MILLISECONDS)
                    || callback.mActiveConfigSize != activeConfigSizeBeforeStart + 1) {
                Assert.fail(""Failed to create an active AudioPlaybackConfiguration"");
            }
        } catch (InterruptedException e) {
            Assert.fail(""Failed to create an active AudioPlaybackConfiguration"");
        } finally {
            am.unregisterAudioPlaybackCallback(callback);
            if (mediaPlayer != null) {
                mediaPlayer.stop();
                mediaPlayer.release();
                mediaPlayer = null;
            }
            handlerThread.quitSafely();
        }
    }

    private static class TestAudioPlaybackCallback extends AudioManager.AudioPlaybackCallback {
        private final CountDownLatch mCountDownLatch = new CountDownLatch(1);
        private int mActiveConfigSize;

        @Override
        public void onPlaybackConfigChanged(List<AudioPlaybackConfiguration> configs) {
            // For non-framework apps, only anonymized active AudioPlaybackCallbacks will be
            // notified.
            mActiveConfigSize = configs.size();
            mCountDownLatch.countDown();
        }
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.scopedstorage.cts.host.ScopedStorageHostTest"	"testManageExternalStorageDoesntSkipScanningDirtyNomediaDir"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/host/src/android/scopedstorage/cts/host/ScopedStorageHostTest.java"	""	"public void testManageExternalStorageDoesntSkipScanningDirtyNomediaDir() throws Exception {
        allowAppOps(""android:manage_external_storage"");
        try {
            runDeviceTest(""testManageExternalStorageDoesntSkipScanningDirtyNomediaDir"");
        } finally {
            denyAppOps(""android:manage_external_storage"");
        }
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.scopedstorage.cts.host.ScopedStorageHostTest"	"testScanDoesntSkipDirtySubtree"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/host/src/android/scopedstorage/cts/host/ScopedStorageHostTest.java"	""	"public void testScanDoesntSkipDirtySubtree() throws Exception {
        allowAppOps(""android:manage_external_storage"");
        try {
            runDeviceTest(""testScanDoesntSkipDirtySubtree"");
        } finally {
            denyAppOps(""android:manage_external_storage"");
        }
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.appsecurity.cts.PackageVisibilityTest"	"testUninstalledPackageVisibility_instant"	"CtsAppSecurityHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PackageVisibilityTest.java"	""	"@AppModeInstant(reason = ""'instant' portion of the hostside test"")
    public void testUninstalledPackageVisibility_instant() throws Exception {
        testUninstalledPackageVisibility(true);
    }
    private void testUninstalledPackageVisibility(boolean instant) throws Exception {
        if (!mSupportsMultiUser) {
            return;
        }

        int userId = mUsers[1];
        assertTrue(userId > 0);
        getDevice().startUser(userId);
        installTestAppForUser(TEST_APK, userId);
        installTestAppForUser(TEST_APK, mPrimaryUserId);

        installTestAppForUser(TINY_APK, mPrimaryUserId);

        // It is visible for the installed user, using shell commands
        assertTrue(isAppVisibleForUser(TINY_PKG, mPrimaryUserId, MATCH_NORMAL));
        assertTrue(isAppVisibleForUser(TINY_PKG, mPrimaryUserId, MATCH_UNINSTALLED));

        // Try the same from an app
        Utils.runDeviceTests(getDevice(), TEST_PKG,
                "".PackageAccessTest"", ""testPackageAccess_inUser"", mPrimaryUserId);
        Utils.runDeviceTests(getDevice(), TEST_PKG,
                "".PackageAccessTest"", ""testPackageAccess_inUserUninstalled"", mPrimaryUserId);

        // It is not visible for the other user using shell commands
        assertFalse(isAppVisibleForUser(TINY_PKG, userId, MATCH_NORMAL));
        assertFalse(isAppVisibleForUser(TINY_PKG, userId, MATCH_UNINSTALLED));

        // Try the same from an app
        Utils.runDeviceTests(getDevice(), TEST_PKG,
                "".PackageAccessTest"", ""testPackageAccess_notInOtherUser"", userId);
        Utils.runDeviceTests(getDevice(), TEST_PKG,
                "".PackageAccessTest"", ""testPackageAccess_notInOtherUserUninstalled"", userId);

        Utils.runDeviceTests(getDevice(), TEST_PKG,
                "".PackageAccessTest"", ""testPackageAccess_getPackagesCantSeeTiny"", userId);

        getDevice().uninstallPackage(TINY_PKG);

        // Install for the new user
        installTestAppForUser(TINY_APK, userId);

        // It is visible for the installed user
        assertTrue(isAppVisibleForUser(TINY_PKG, userId, MATCH_NORMAL));
        assertTrue(isAppVisibleForUser(TINY_PKG, userId, MATCH_UNINSTALLED));

        // It is not visible for the other user
        assertFalse(isAppVisibleForUser(TINY_PKG, mPrimaryUserId, MATCH_NORMAL));
        assertFalse(isAppVisibleForUser(TINY_PKG, mPrimaryUserId, MATCH_UNINSTALLED));

        // Uninstall with keep data and reboot
        uninstallWithKeepDataForUser(TINY_PKG, userId);
        getDevice().rebootUntilOnline();
        waitForBootCompleted();
        getDevice().startUser(userId);

        // It is visible for the installed user, but only if match uninstalled
        assertFalse(isAppVisibleForUser(TINY_PKG, userId, MATCH_NORMAL));
        assertTrue(isAppVisibleForUser(TINY_PKG, userId, MATCH_UNINSTALLED));

        Utils.runDeviceTests(getDevice(), TEST_PKG,
                "".PackageAccessTest"", ""testPackageAccess_notInOtherUser"", userId);
        Utils.runDeviceTests(getDevice(), TEST_PKG,
                "".PackageAccessTest"", ""testPackageAccess_getPackagesCanSeeTiny"", userId);

        Utils.runDeviceTests(getDevice(), TEST_PKG,
                "".PackageAccessTest"", ""testPackageAccess_notInOtherUserUninstalled"",
                mPrimaryUserId);
        Utils.runDeviceTests(getDevice(), TEST_PKG,
                "".PackageAccessTest"", ""testPackageAccess_getPackagesCantSeeTiny"", mPrimaryUserId);

        getDevice().uninstallPackage(TINY_PKG);
        getDevice().uninstallPackage(TEST_PKG);
    }

    private void uninstallWithKeepDataForUser(String packageName, int userId) throws Exception {
        final String command = ""pm uninstall -k --user "" + userId + "" "" + packageName;
        getDevice().executeShellCommand(command);
    }

    private void waitForBootCompleted() throws Exception {
        for (int i = 0; i < 45; i++) {
            if (isBootCompleted()) {
                return;
            }
            Thread.sleep(1000);
        }
        throw new AssertionError(""System failed to become ready!"");
    }

    private boolean isBootCompleted() throws Exception {
        return ""1"".equals(getDevice().executeShellCommand(""getprop sys.boot_completed"").trim());
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.scopedstorage.cts.host.LegacyStorageHostTest"	"testLegacySystemGalleryWithoutWESCannotRename"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/host/src/android/scopedstorage/cts/host/LegacyStorageHostTest.java"	""	"public void testLegacySystemGalleryWithoutWESCannotRename() throws Exception {
        revokePermissions(""android.permission.WRITE_EXTERNAL_STORAGE"");
        runDeviceTest(""testLegacySystemGalleryWithoutWESCannotRename"");
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.scopedstorage.cts.host.LegacyStorageHostTest"	"testLegacyWESCanRenameImagesAndVideosWithDbUpdates_hasW"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/host/src/android/scopedstorage/cts/host/LegacyStorageHostTest.java"	""	"public void testLegacyWESCanRenameImagesAndVideosWithDbUpdates_hasW() throws Exception {
        runDeviceTest(""testLegacyWESCanRenameImagesAndVideosWithDbUpdates_hasW"");
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.scopedstorage.cts.host.LegacyStorageHostTest"	"testScanUpdatesMetadataForNewlyAddedFile_hasRW"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/host/src/android/scopedstorage/cts/host/LegacyStorageHostTest.java"	""	"public void testScanUpdatesMetadataForNewlyAddedFile_hasRW() throws Exception {
        runDeviceTest(""testScanUpdatesMetadataForNewlyAddedFile_hasRW"");
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.usb.TestUsbTest"	"testInstantAppsCannotReadSerial"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/usb/src/com/android/cts/usb/TestUsbTest.java"	""	"public void testInstantAppsCannotReadSerial() throws Exception {
        installApp(true);

        runTestOnDevice(""verifySerialCannotBeRead"");
    }

    /**
     * Check if adb serial number, USB serial number, ro.serialno, and android.os.Build.SERIAL
     * all matches and meets the format requirement [a-zA-Z0-9]{6,20}
     */
    @AppModeFull(reason = ""serial can not be read by instant apps"")"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.DeviceAndProfileOwnerTest"	"testGrantOfSensorsRelatedPermissions"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java"	""	"public void testGrantOfSensorsRelatedPermissions() throws Exception {
        installAppPermissionAppAsUser();
        executeDeviceTestMethod("".PermissionsTest"", ""testSensorsRelatedPermissionsCannotBeGranted"");
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.DeviceAndProfileOwnerTest"	"testDenyOfSensorsRelatedPermissions"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java"	""	"public void testDenyOfSensorsRelatedPermissions() throws Exception {
        installAppPermissionAppAsUser();
        executeDeviceTestMethod("".PermissionsTest"", ""testSensorsRelatedPermissionsCanBeDenied"");
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.DeviceAndProfileOwnerTest"	"testStateOfSensorsRelatedPermissionsCannotBeRead"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java"	""	"public void testStateOfSensorsRelatedPermissionsCannotBeRead() throws Exception {
        installAppPermissionAppAsUser();
        executeDeviceTestMethod("".PermissionsTest"",
                ""testStateOfSensorsRelatedPermissionsCannotBeRead"");
    }

    /**
     * Require a device for tests that use the network stack. Headless Androids running in
     * data centres might need their network rules un-tampered-with in order to keep the ADB / VNC
     * connection alive.
     *
     * This is only a problem on device owner / profile owner running on USER_SYSTEM, because
     * network rules for this user will affect UID 0.
     */
    @RequiresDevice"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.security.cts.AdbUtils"	"emptyList"	"CtsSecurityBulletinHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/securitybulletin/src/android/security/cts/AdbUtils.java"	""	"public void test/*
 *.
 */

package android.security.cts;

import com.android.compatibility.common.util.CrashUtils;
import com.android.compatibility.common.util.MetricsReportLog;
import com.android.compatibility.common.util.ResultType;
import com.android.compatibility.common.util.ResultUnit;
import com.android.ddmlib.IShellOutputReceiver;
import com.android.ddmlib.NullOutputReceiver;
import com.android.ddmlib.CollectingOutputReceiver;
import com.android.tradefed.device.DeviceNotAvailableException;
import com.android.tradefed.device.ITestDevice;
import com.android.tradefed.device.NativeDevice;
import com.android.tradefed.log.LogUtil.CLog;

import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.concurrent.TimeoutException;
import java.util.List;
import java.util.Map;
import java.util.regex.Pattern;
import java.util.concurrent.TimeUnit;
import java.util.Scanner;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.concurrent.Callable;
import java.util.Collections;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.util.regex.Pattern;
import java.lang.Thread;

import static org.junit.Assert.*;
import static org.junit.Assume.*;

public class AdbUtils {

    final static String TMP_PATH = ""/data/local/tmp/"";
    final static int TIMEOUT_SEC = 9 * 60;
    final static String RESOURCE_ROOT = ""/"";

    public static class pocConfig {
        String binaryName;
        String arguments;
        Map<String, String> envVars;
        String inputFilesDestination;
        ITestDevice device;
        CrashUtils.Config config;
        List<String> inputFiles = Collections.emptyList();
        boolean checkCrash = true;

        pocConfig(String binaryName, ITestDevice device) {
            this.binaryName = binaryName;
            this.device = device;
        }
    }

    /** Runs a commandline on the specified device
     *
     * @param command the command to be ran
     * @param device device for the command to be ran on
     * @return the console output from running the command
     */
    public static String runCommandLine(String command, ITestDevice device) throws Exception {
        if (""reboot"".equals(command)) {
            throw new IllegalArgumentException(
                    ""You called a forbidden command! Please fix your tests."");
        }
        return device.executeShellCommand(command);
    }

    /**
     * Pushes and runs a binary to the selected device
     *
     * @param pocName name of the poc binary
     * @param device device to be ran on
     * @return the console output from the binary
     */
    public static String runPoc(String pocName, ITestDevice device) throws Exception {
        return runPoc(pocName, device, SecurityTestCase.TIMEOUT_NONDETERMINISTIC);
    }

    /**
     * Pushes and runs a binary to the selected device
     *
     * @param pocName name of the poc binary
     * @param device device to be ran on
     * @param timeout time to wait for output in seconds
     * @return the console output from the binary
     */
    public static String runPoc(String pocName, ITestDevice device, int timeout) throws Exception {
        return runPoc(pocName, device, timeout, null);
    }

    /**
     * Pushes and runs a binary to the selected device
     *
     * @param pocName name of the poc binary
     * @param device device to be ran on
     * @param timeout time to wait for output in seconds
     * @param arguments the input arguments for the poc
     * @return the console output from the binary
     */
    public static String runPoc(String pocName, ITestDevice device, int timeout, String arguments)
            throws Exception {
        CollectingOutputReceiver receiver = new CollectingOutputReceiver();
        runPoc(pocName, device, timeout, arguments, receiver);
        return receiver.getOutput();
    }

    /**
     * Pushes and runs a binary to the selected device and ignores any of its output.
     *
     * @param pocName name of the poc binary
     * @param device device to be ran on
     * @param timeout time to wait for output in seconds
     */
    public static void runPocNoOutput(String pocName, ITestDevice device, int timeout)
            throws Exception {
        runPocNoOutput(pocName, device, timeout, null);
    }

    /**
     * Pushes and runs a binary with arguments to the selected device and
     * ignores any of its output.
     *
     * @param pocName name of the poc binary
     * @param device device to be ran on
     * @param timeout time to wait for output in seconds
     * @param arguments input arguments for the poc
     */
    public static void runPocNoOutput(String pocName, ITestDevice device, int timeout,
            String arguments) throws Exception {
        runPoc(pocName, device, timeout, arguments, null);
    }

    /**
     * Pushes and runs a binary with arguments to the selected device and
     * ignores any of its output.
     *
     * @param pocName name of the poc binary
     * @param device device to be ran on
     * @param timeout time to wait for output in seconds
     * @param arguments input arguments for the poc
     * @param receiver the type of receiver to run against
     */
    public static int runPoc(String pocName, ITestDevice device, int timeout,
            String arguments, IShellOutputReceiver receiver) throws Exception {
              return runPoc(pocName, device, timeout, arguments, null, receiver);
    }

    /**
     * Pushes and runs a binary with arguments to the selected device and
     * ignores any of its output.
     *
     * @param pocName name of the poc binary
     * @param device device to be ran on
     * @param timeout time to wait for output in seconds
     * @param arguments input arguments for the poc
     * @param envVars run the poc with environment variables
     * @param receiver the type of receiver to run against
     */
    public static int runPoc(String pocName, ITestDevice device, int timeout,
            String arguments, Map<String, String> envVars,
            IShellOutputReceiver receiver) throws Exception {
        String remoteFile = String.format(""%s%s"", TMP_PATH, pocName);
        SecurityTestCase.getPocPusher(device).pushFile(pocName + ""_sts"", remoteFile);

        assertPocExecutable(pocName, device);
        if (receiver == null) {
            receiver = new NullOutputReceiver();
        }
        if (arguments == null) {
            arguments = """";
        }

        String env = """";
        if (envVars != null) {
            StringBuilder sb = new StringBuilder();
            for (Map.Entry<String, String> entry : envVars.entrySet()) {
                sb
                    .append(entry.getKey().trim())
                    .append('=')
                    .append(entry.getValue().trim())
                    .append(' ');
            }
            env = sb.toString();
            CLog.i(""Running poc '%s' with env variables '%s'"", pocName, env);
        }

        // since we have to return the exit status AND the poc stdout+stderr we redirect the exit
        // status to a file temporarily
        String exitStatusFilepath = TMP_PATH + ""exit_status"";
        runCommandLine(""rm "" + exitStatusFilepath, device); // remove any old exit status
        device.executeShellCommand(
                env + TMP_PATH + pocName + "" "" + arguments +
                ""; echo $? > "" + exitStatusFilepath, // echo exit status to file
                receiver, timeout, TimeUnit.SECONDS, 0);

        // cat the exit status
        String exitStatusString = runCommandLine(""cat "" + exitStatusFilepath, device).trim();

        MetricsReportLog reportLog = SecurityTestCase.buildMetricsReportLog(device);
        reportLog.addValue(""poc_name"", pocName, ResultType.NEUTRAL, ResultUnit.NONE);
        int exitStatus = -1;
        try {
            exitStatus = Integer.parseInt(exitStatusString);
            reportLog.addValue(""exit_status"", exitStatus, ResultType.NEUTRAL, ResultUnit.NONE);
        } catch (NumberFormatException e) {
            // Getting the exit status is a bonus. We can continue without it.
            CLog.w(""Could not parse exit status to int: %s"", exitStatusString);
        }
        reportLog.submit();

        runCommandLine(""rm "" + exitStatusFilepath, device);
        return exitStatus;
    }

    /**
     * Assert the poc is executable
     * @param pocName name of the poc binary
     * @param device device to be ran on
     */
    private static void assertPocExecutable(String pocName, ITestDevice device) throws Exception {
        String fullPocPath = TMP_PATH + pocName;
        device.executeShellCommand(""chmod 777 "" + fullPocPath);
        assertEquals(""'"" + pocName + ""' must exist and be readable."", 0,
                runCommandGetExitCode(""test -r "" + fullPocPath, device));
        assertEquals(""'"" + pocName + ""'poc must exist and be writable."", 0,
                runCommandGetExitCode(""test -w "" + fullPocPath, device));
        assertEquals(""'"" + pocName + ""'poc must exist and be executable."", 0,
                runCommandGetExitCode(""test -x "" + fullPocPath, device));
    }

    /**
     * Enables malloc debug on a given process.
     *
     * @param processName the name of the process to run with libc malloc debug
     * @param device the device to use
     * @return true if enabling malloc debug succeeded
     */
    public static boolean enableLibcMallocDebug(String processName, ITestDevice device) throws Exception {
        device.executeShellCommand(""setprop libc.debug.malloc.program "" + processName);
        device.executeShellCommand(""setprop libc.debug.malloc.options \""backtrace guard\"""");
        /**
         * The pidof command is being avoided because it does not exist on versions before M, and
         * it behaves differently between M and N.
         * Also considered was the ps -AoPID,CMDLINE command, but ps does not support options on
         * versions before O.
         * The [^]] prefix is being used for the grep command to avoid the case where the output of
         * ps includes the grep command itself.
         */
        String cmdOut = device.executeShellCommand(""ps -A | grep '[^]]"" + processName + ""'"");
        /**
         * .hasNextInt() checks if the next token can be parsed as an integer, not if any remaining
         * token is an integer.
         * Example command: $ ps | fgrep mediaserver
         * Out: media     269   1     77016  24416 binder_thr 00f35142ec S /system/bin/mediaserver
         * The second field of the output is the PID, which is needed to restart the process.
         */
        Scanner s = new Scanner(cmdOut).useDelimiter(""\\D+"");
        if(!s.hasNextInt()) {
            CLog.w(""Could not find pid for process: "" + processName);
            return false;
        }

        String result = device.executeShellCommand(""kill -9 "" + s.nextInt());
        if(!result.equals("""")) {
            CLog.w(""Could not restart process: "" + processName);
            return false;
        }

        TimeUnit.SECONDS.sleep(1);
        return true;
    }

    /**
     * Pushes and installs an apk to the selected device
     *
     * @param pathToApk a string path to apk from the /res folder
     * @param device device to be ran on
     * @return the output from attempting to install the apk
     */
    public static String installApk(String pathToApk, ITestDevice device) throws Exception {

        String fullResourceName = pathToApk;
        File apkFile = File.createTempFile(""apkFile"", "".apk"");
        try {
            apkFile = extractResource(fullResourceName, apkFile);
            return device.installPackage(apkFile, true);
        } finally {
            apkFile.delete();
        }
    }

    /**
     * Extracts a resource and pushes it to the device
     *
     * @param fullResourceName a string path to resource from the res folder
     * @param deviceFilePath the remote destination absolute file path
     * @param device device to be ran on
     */
    public static void pushResource(String fullResourceName, String deviceFilePath,
                                    ITestDevice device) throws Exception {
        File resFile = File.createTempFile(""CTSResource"", """");
        try {
            resFile = extractResource(fullResourceName, resFile);
            device.pushFile(resFile, deviceFilePath);
        } finally {
            resFile.delete();
        }
    }

    /**
     * Pushes the specified files to the specified destination directory
     *
     * @param inputFiles files required as input
     * @param inputFilesDestination destination directory to which input files are
     *        pushed
     * @param device device to be run on
     */
    public static void pushResources(String[] inputFiles, String inputFilesDestination,
            ITestDevice device) throws Exception {
        if (inputFiles == null || inputFilesDestination == null) {
            throw new IllegalArgumentException(
                    ""Can't push resources: input files or destination is null"");
        }
        for (String tempFile : inputFiles) {
            pushResource(RESOURCE_ROOT + tempFile, inputFilesDestination + tempFile, device);
        }
    }

    /**
     * Removes the specified files from the specified destination directory
     *
     * @param inputFiles files required as input
     * @param inputFilesDestination destination directory where input files are
     *        present
     * @param device device to be run on
     */
    public static void removeResources(String[] inputFiles, String inputFilesDestination,
            ITestDevice device) throws Exception {
        if (inputFiles == null || inputFilesDestination == null) {
            throw new IllegalArgumentException(
                    ""Can't remove resources: input files or destination is null"");
        }
        for (String tempFile : inputFiles) {
            runCommandLine(""rm "" + inputFilesDestination + tempFile, device);
        }
    }

   /**
     * Extracts the binary data from a resource and writes it to a temp file
     */
    private static File extractResource(String fullResourceName, File file) throws Exception {
        try (InputStream in = AdbUtils.class.getResourceAsStream(fullResourceName);
            OutputStream out = new BufferedOutputStream(new FileOutputStream(file))) {
            if (in == null) {
                throw new IllegalArgumentException(""Resource not found: "" + fullResourceName);
            }
            byte[] buf = new byte[65536];
            int chunkSize;
            while ((chunkSize = in.read(buf)) != -1) {
                out.write(buf, 0, chunkSize);
            }
            return file;
        }

    }
    /**
     * Utility function to help check the exit code of a shell command
     */
    public static int runCommandGetExitCode(String cmd, ITestDevice device) throws Exception {
        long time = System.currentTimeMillis();
        String exitStatusString = runCommandLine(
                ""("" + cmd + "") > /dev/null 2>&1; echo $?"", device).trim();
        time = System.currentTimeMillis() - time;

        try {
            int exitStatus = Integer.parseInt(exitStatusString);
            MetricsReportLog reportLog = SecurityTestCase.buildMetricsReportLog(device);
            reportLog.addValue(""command"", cmd, ResultType.NEUTRAL, ResultUnit.NONE);
            reportLog.addValue(""exit_status"", exitStatus, ResultType.NEUTRAL, ResultUnit.NONE);
            reportLog.submit();
            return exitStatus;
        } catch (NumberFormatException e) {
            throw new IllegalArgumentException(String.format(
                    ""Could not get the exit status (%s) for '%s' (%d ms)."",
                    exitStatusString, cmd, time));
        }
    }

    /**
     * Pushes and runs a binary to the selected device and checks exit code
     * Return code 113 is used to indicate the vulnerability
     *
     * @param pocName a string path to poc from the /res folder
     * @param device device to be ran on
     * @param timeout time to wait for output in seconds
     */
    @Deprecated
    public static boolean runPocCheckExitCode(String pocName, ITestDevice device,
                                              int timeout) throws Exception {

       //Refer to go/asdl-sts-guide Test section for knowing the significance of 113 code
       return runPocGetExitStatus(pocName, device, timeout) == 113;
    }

    /**
     * Pushes and runs a binary to the device and returns the exit status.
     * @param pocName a string path to poc from the /res folder
     * @param device device to be ran on
     * @param timeout time to wait for output in seconds

     */
    public static int runPocGetExitStatus(String pocName, ITestDevice device, int timeout)
            throws Exception {
       return runPocGetExitStatus(pocName, null, device, timeout);
    }

    /**
     * Pushes and runs a binary to the device and returns the exit status.
     * @param pocName a string path to poc from the /res folder
     * @param arguments input arguments for the poc
     * @param device device to be ran on
     * @param timeout time to wait for output in seconds
     */
    public static int runPocGetExitStatus(String pocName, String arguments, ITestDevice device,
            int timeout) throws Exception {
              return runPocGetExitStatus(pocName, arguments, null, device, timeout);
    }

    /**
     * Pushes and runs a binary to the device and returns the exit status.
     * @param pocName name of the poc binary
     * @param arguments input arguments for the poc
     * @param envVars run the poc with environment variables
     * @param device device to be run on
     * @param timeout time to wait for output in seconds
     */
    public static int runPocGetExitStatus(
            String pocName, String arguments, Map<String, String> envVars,
            ITestDevice device, int timeout) throws Exception {
        return runPoc(pocName, device, timeout, arguments, envVars, null);
    }

    /**
     * Pushes and runs a binary and asserts that the exit status isn't 113: vulnerable.
     * @param pocName a string path to poc from the /res folder
     * @param device device to be ran on
     * @param timeout time to wait for output in seconds
     */
    public static void runPocAssertExitStatusNotVulnerable(
            String pocName, ITestDevice device, int timeout) throws Exception {
        runPocAssertExitStatusNotVulnerable(pocName, null, device, timeout);
    }

    /**
     * Pushes and runs a binary and asserts that the exit status isn't 113: vulnerable.
     * @param pocName a string path to poc from the /res folder
     * @param arguments input arguments for the poc
     * @param device device to be ran on
     * @param timeout time to wait for output in seconds
     */
    public static void runPocAssertExitStatusNotVulnerable(String pocName, String arguments,
            ITestDevice device, int timeout) throws Exception {
              runPocGetExitStatus(pocName, arguments, null, device, timeout);
    }

    /**
     * Pushes and runs a binary and asserts that the exit status isn't 113: vulnerable.
     * @param pocName name of the poc binary
     * @param arguments input arguments for the poc
     * @param envVars run the poc with environment variables
     * @param device device to be ran on
     * @param timeout time to wait for output in seconds
     */
    public static void runPocAssertExitStatusNotVulnerable(
            String pocName, String arguments, Map<String, String> envVars,
            ITestDevice device, int timeout) throws Exception {
        assertTrue(""PoC returned exit status 113: vulnerable"",
                runPocGetExitStatus(pocName, arguments, envVars, device, timeout) != 113);
    }

    /**
     * Runs the poc binary and asserts that there are no security crashes that match the expected
     * process pattern.
     * @param pocName a string path to poc from the /res folder
     * @param device device to be ran on
     * @param processPatternStrings a Pattern string to match the crash tombstone process
     */
    public static void runPocAssertNoCrashes(String pocName, ITestDevice device,
            String... processPatternStrings) throws Exception {
        runPocAssertNoCrashes(pocName, device,
                new CrashUtils.Config().setProcessPatterns(processPatternStrings));
    }

    /**
     * Runs the poc binary and asserts that there are no security crashes that match the expected
     * process pattern.
     * @param pocName a string path to poc from the /res folder
     * @param device device to be ran on
     * @param config a crash parser configuration
     */
    public static void runPocAssertNoCrashes(String pocName, ITestDevice device,
            CrashUtils.Config config) throws Exception {
        runPocAssertNoCrashes(pocName, device, null, config);
    }

    /**
     * Runs the poc binary and asserts that there are no security crashes that match the expected
     * process pattern, including arguments when running.
     * @param pocName a string path to poc from the /res folder
     * @param device device to be ran on
     * @param arguments input arguments for the poc
     * @param config a crash parser configuration
     */
    public static void runPocAssertNoCrashes(String pocName, ITestDevice device, String arguments,
            CrashUtils.Config config) throws Exception {
        AdbUtils.runCommandLine(""logcat -c"", device);
        AdbUtils.runPocNoOutput(pocName, device,
                SecurityTestCase.TIMEOUT_NONDETERMINISTIC, arguments);
        assertNoCrashes(device, config);
    }

    /**
     * Runs the poc binary and asserts following 2 conditions.
     *  1. There are no security crashes in the binary.
     *  2. The exit status isn't 113 (Code 113 is used to indicate the vulnerability condition).
     *
     * @param binaryName name of the binary
     * @param arguments arguments for running the binary
     * @param device device to be run on
     */
    public static void runPocAssertNoCrashesNotVulnerable(String binaryName, String arguments,
            ITestDevice device) throws Exception {
        runPocAssertNoCrashesNotVulnerable(binaryName, arguments, null, null, device, null);
    }

    /**
     * Runs the poc binary and asserts following 2 conditions.
     *  1. There are no security crashes in the binary.
     *  2. The exit status isn't 113 (Code 113 is used to indicate the vulnerability condition).
     *
     * @param binaryName name of the binary
     * @param arguments arguments for running the binary
     * @param device device to be run on
     * @param processPatternStrings a Pattern string to match the crash tombstone
     *        process
     */
    public static void runPocAssertNoCrashesNotVulnerable(String binaryName, String arguments,
            ITestDevice device, String processPatternStrings[]) throws Exception {
        runPocAssertNoCrashesNotVulnerable(binaryName, arguments, null, null, device,
                processPatternStrings);
    }

    /**
     * Runs the poc binary and asserts following 2 conditions.
     *  1. There are no security crashes in the binary.
     *  2. The exit status isn't 113 (Code 113 is used to indicate the vulnerability condition).
     *
     * @param binaryName name of the binary
     * @param arguments arguments for running the binary
     * @param inputFiles files required as input
     * @param inputFilesDestination destination directory to which input files are
     *        pushed
     * @param device device to be run on
     */
    public static void runPocAssertNoCrashesNotVulnerable(String binaryName, String arguments,
            String inputFiles[], String inputFilesDestination, ITestDevice device)
            throws Exception {
        runPocAssertNoCrashesNotVulnerable(binaryName, arguments, inputFiles, inputFilesDestination,
                device, null);
    }

    /**
     * Runs the poc binary and asserts following 3 conditions.
     *  1. There are no security crashes in the binary.
     *  2. There are no security crashes that match the expected process pattern.
     *  3. The exit status isn't 113 (Code 113 is used to indicate the vulnerability condition).
     *
     * @param binaryName name of the binary
     * @param arguments arguments for running the binary
     * @param inputFiles files required as input
     * @param inputFilesDestination destination directory to which input files are
     *        pushed
     * @param device device to be run on
     * @param processPatternStrings a Pattern string to match the crash tombstone
     *        process
     */
    public static void runPocAssertNoCrashesNotVulnerable(String binaryName, String arguments,
            String inputFiles[], String inputFilesDestination, ITestDevice device,
            String processPatternStrings[]) throws Exception {
        runPocAssertNoCrashesNotVulnerable(binaryName, arguments, null,
                inputFiles, inputFilesDestination, device, processPatternStrings);
    }

    /**
     * Runs the poc binary and asserts following 3 conditions.
     *  1. There are no security crashes in the binary.
     *  2. There are no security crashes that match the expected process pattern.
     *  3. The exit status isn't 113 (Code 113 is used to indicate the vulnerability condition).
     *
     * @param binaryName name of the binary
     * @param arguments arguments for running the binary
     * @param envVars run the poc with environment variables
     * @param inputFiles files required as input
     * @param inputFilesDestination destination directory to which input files are
     *        pushed
     * @param device device to be run on
     * @param processPatternStrings a Pattern string (other than binary name) to match the crash
     *        tombstone process
     */
    public static void runPocAssertNoCrashesNotVulnerable(
            String binaryName, String arguments, Map<String, String> envVars,
            String inputFiles[], String inputFilesDestination, ITestDevice device,
            String... processPatternStrings) throws Exception {
        pocConfig testConfig = new pocConfig(binaryName, device);
        testConfig.arguments = arguments;
        testConfig.envVars = envVars;

        if (inputFiles != null) {
            testConfig.inputFiles = Arrays.asList(inputFiles);
            testConfig.inputFilesDestination = inputFilesDestination;
        }

        List<String> processPatternList = new ArrayList<>();
        if (processPatternStrings != null) {
            processPatternList.addAll(Arrays.asList(processPatternStrings));
        }
        processPatternList.add(binaryName);
        String[] processPatternStringsWithSelf = new String[processPatternList.size()];
        processPatternList.toArray(processPatternStringsWithSelf);
        testConfig.config =
                new CrashUtils.Config().setProcessPatterns(processPatternStringsWithSelf);

        runPocAssertNoCrashesNotVulnerable(testConfig);
    }

    /**
     * Runs the poc binary and asserts following 3 conditions.
     *  1. There are no security crashes in the binary.
     *  2. There are no security crashes that match the expected process pattern.
     *  3. The exit status isn't 113 (Code 113 is used to indicate the vulnerability condition).
     *
     * @param testConfig test configuration
     */
    public static void runPocAssertNoCrashesNotVulnerable(pocConfig testConfig) throws Exception {
        String[] inputFiles = null;
        if(!testConfig.inputFiles.isEmpty()) {
            inputFiles = testConfig.inputFiles.toArray(new String[testConfig.inputFiles.size()]);
            pushResources(inputFiles, testConfig.inputFilesDestination, testConfig.device);
        }
        runCommandLine(""logcat -c"", testConfig.device);
        try {
            runPocAssertExitStatusNotVulnerable(testConfig.binaryName, testConfig.arguments,
                    testConfig.envVars, testConfig.device, TIMEOUT_SEC);
        } catch (IllegalArgumentException e) {
            /*
             * Since 'runPocGetExitStatus' method raises IllegalArgumentException upon
             * hang/timeout, catching the exception here and ignoring it. Hangs are of
             * Moderate severity and hence patches may not be ported. This piece of code can
             * be removed once 'runPocGetExitStatus' is updated to handle hangs.
             */
            CLog.w(""Ignoring IllegalArgumentException: "" + e);
        } finally {
            if (!testConfig.inputFiles.isEmpty()) {
                removeResources(inputFiles, testConfig.inputFilesDestination, testConfig.device);
            }
        }
        if(testConfig.checkCrash) {
            if (testConfig.config == null) {
                testConfig.config = new CrashUtils.Config();
            }
            assertNoCrashes(testConfig.device, testConfig.config);
        }
    }

    /**
     * Dumps logcat and asserts that there are no security crashes that match the expected process.
     * By default, checks min crash addresses
     * pattern. Ensure that adb logcat -c is called beforehand.
     * @param device device to be ran on
     * @param processPatternStrings a Pattern string to match the crash tombstone process
     */
    public static void assertNoCrashes(ITestDevice device, String... processPatternStrings)
            throws Exception {
        assertNoCrashes(device, new CrashUtils.Config().setProcessPatterns(processPatternStrings));
    }

    /**
     * Dumps logcat and asserts that there are no security crashes that match the expected process
     * pattern. Ensure that adb logcat -c is called beforehand.
     * @param device device to be ran on
     * @param config a crash parser configuration
     */
    public static void assertNoCrashes(ITestDevice device,
            CrashUtils.Config config) throws Exception {
        String logcat = AdbUtils.runCommandLine(""logcat -d *:S DEBUG:V"", device);

        JSONArray crashes = CrashUtils.addAllCrashes(logcat, new JSONArray());
        JSONArray securityCrashes = CrashUtils.matchSecurityCrashes(crashes, config);

        MetricsReportLog reportLog = SecurityTestCase.buildMetricsReportLog(device);
        reportLog.addValue(""all_crashes"", crashes.toString(), ResultType.NEUTRAL, ResultUnit.NONE);
        reportLog.addValue(""security_crashes"", securityCrashes.toString(),
                ResultType.NEUTRAL, ResultUnit.NONE);
        reportLog.submit();

        if (securityCrashes.length() == 0) {
            return; // no security crashes detected
        }

        StringBuilder error = new StringBuilder();
        error.append(""Security crash detected:\n"");
        error.append(""Process patterns:"");
        for (Pattern pattern : config.getProcessPatterns()) {
            error.append(String.format("" '%s'"", pattern.toString()));
        }
        error.append(""\nCrashes:\n"");
        for (int i = 0; i < crashes.length(); i++) {
            try {
                JSONObject crash = crashes.getJSONObject(i);
                error.append(String.format(""%s\n"", crash));
            } catch (JSONException e) {}
        }
        fail(error.toString());
    }

    public static void assumeHasNfc(ITestDevice device) throws DeviceNotAvailableException {
        assumeTrue(""nfc not available on device"", device.hasFeature(""android.hardware.nfc""));
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.bluetooth.cts.ScanCallbackTest"	"testScanSuccess"	"CtsBluetoothTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/bluetooth/src/android/bluetooth/cts/ScanCallbackTest.java"	""	"public void testScanSuccess() {
        mMockScanCallback.mScanType = SCAN_TYPE_SUCCESS;
        mMockScanner.startScan(new ScanSettings.Builder().build(), mMockScanCallback);
    }

    @SmallTest"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.bluetooth.cts.ScanCallbackTest"	"testBatchScans"	"CtsBluetoothTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/bluetooth/src/android/bluetooth/cts/ScanCallbackTest.java"	""	"public void testBatchScans() {
        ScanSettings settings = new ScanSettings.Builder().setReportDelay(1000).build();
        mMockScanCallback.mScanType = SCAN_TYPE_BATCH;
        mMockScanner.startScan(settings, mMockScanCallback);
    }

    @SmallTest"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.bluetooth.cts.ScanCallbackTest"	"testScanFail"	"CtsBluetoothTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/bluetooth/src/android/bluetooth/cts/ScanCallbackTest.java"	""	"public void testScanFail() {
        ScanSettings settings = new ScanSettings.Builder().build();
        // The first scan is success.
        mMockScanCallback.mScanType = SCAN_TYPE_SUCCESS;
        mMockScanner.startScan(settings, mMockScanCallback);
        // A second scan with the same callback should fail.
        mMockScanCallback.mScanType = SCAN_TYPE_FAIL;
        mMockScanner.startScan(settings, mMockScanCallback);
    }

    // A mock scanner for mocking BLE scanner functionalities.
    private static class MockScanner {
        private Set<ScanCallback> mCallbacks = new HashSet<>();

        void startScan(ScanSettings settings, ScanCallback callback) {
            synchronized (mCallbacks) {
                if (mCallbacks.contains(callback)) {
                    callback.onScanFailed(ScanCallback.SCAN_FAILED_ALREADY_STARTED);
                    return;
                }
                mCallbacks.add(callback);
                if (settings.getReportDelayMillis() == 0) {
                    callback.onScanResult(0, null);
                } else {
                    callback.onBatchScanResults(null);
                }
            }
        }
    }

    private static class BleScanCallback extends ScanCallback {
        int mScanType = SCAN_TYPE_SUCCESS;

        @Override
        public void onScanResult(int callbackType, ScanResult result) {
            if (mScanType != SCAN_TYPE_SUCCESS) {
                fail(""scan should fail"");
            }
        }

        @Override
        public void onBatchScanResults(List<ScanResult> results) {
            if (mScanType != SCAN_TYPE_BATCH) {
                fail(""not a batch scan"");
            }
        }

        @Override
        public void onScanFailed(int errorCode) {
            if (mScanType != SCAN_TYPE_FAIL) {
                fail(""scan should not fail"");
            }
        }

    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.bluetooth.BleAdvertiserService"	"getBluetoothLeAdvertiser"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/bluetooth/BleAdvertiserService.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.bluetooth;

import java.util.UUID;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import android.app.Service;
import android.bluetooth.BluetoothAdapter;
import android.bluetooth.BluetoothGattServer;
import android.bluetooth.BluetoothGattServerCallback;
import android.bluetooth.BluetoothManager;
import android.bluetooth.le.BluetoothLeAdvertiser;
import android.bluetooth.le.AdvertiseCallback;
import android.bluetooth.le.AdvertiseData;
import android.bluetooth.le.AdvertiseSettings;
import android.content.Context;
import android.content.Intent;
import android.os.Handler;
import android.os.IBinder;
import android.os.ParcelUuid;
import android.util.Log;
import android.widget.Toast;

public class BleAdvertiserService extends Service {

    public static final boolean DEBUG = true;
    public static final String TAG = ""BleAdvertiserService"";

    public static final int COMMAND_START_ADVERTISE = 0;
    public static final int COMMAND_STOP_ADVERTISE = 1;
    public static final int COMMAND_START_POWER_LEVEL = 2;
    public static final int COMMAND_STOP_POWER_LEVEL = 3;
    public static final int COMMAND_START_SCANNABLE = 4;
    public static final int COMMAND_STOP_SCANNABLE = 5;
    public static final int COMMAND_START_UNSCANNABLE = 6;
    public static final int COMMAND_STOP_UNSCANNABLE = 7;

    public static final String BLE_ADV_NOT_SUPPORT =
            ""com.android.cts.verifier.bluetooth.BLE_ADV_NOT_SUPPORT"";
    public static final String BLE_START_ADVERTISE =
            ""com.android.cts.verifier.bluetooth.BLE_START_ADVERTISE"";
    public static final String BLE_STOP_ADVERTISE =
            ""com.android.cts.verifier.bluetooth.BLE_STOP_ADVERTISE"";
    public static final String BLE_START_POWER_LEVEL =
            ""com.android.cts.verifier.bluetooth.BLE_START_POWER_LEVEL"";
    public static final String BLE_STOP_POWER_LEVEL =
            ""com.android.cts.verifier.bluetooth.BLE_STOP_POWER_LEVEL"";
    public static final String BLE_START_SCANNABLE =
            ""com.android.cts.verifier.bluetooth.BLE_START_SCANNABLE"";
    public static final String BLE_START_UNSCANNABLE =
            ""com.android.cts.verifier.bluetooth.BLE_START_UNSCANNABLE"";
    public static final String BLE_STOP_SCANNABLE =
            ""com.android.cts.verifier.bluetooth.BLE_STOP_SCANNABLE"";
    public static final String BLE_STOP_UNSCANNABLE =
            ""com.android.cts.verifier.bluetooth.BLE_STOP_UNSCANNABLE"";

    public static final String EXTRA_COMMAND =
            ""com.android.cts.verifier.bluetooth.EXTRA_COMMAND"";

    protected static final UUID PRIVACY_MAC_UUID =
            UUID.fromString(""00009999-0000-1000-8000-00805f9b34fb"");
    protected static final UUID POWER_LEVEL_UUID =
            UUID.fromString(""00008888-0000-1000-8000-00805f9b34fb"");
    protected static final UUID SCAN_RESP_UUID =
            UUID.fromString(""00007777-0000-1000-8000-00805f9b34fb"");
    protected static final UUID SCANNABLE_UUID =
            UUID.fromString(""00006666-0000-1000-8000-00805f9b34fb"");
    protected static final UUID UNSCANNABLE_UUID =
            UUID.fromString(""00005555-0000-1000-8000-00805f9b34fb"");

    public static final byte MANUFACTURER_TEST_ID = (byte)0x07;
    public static final byte[] PRIVACY_MAC_DATA = new byte[]{3, 1, 4};
    public static final byte[] PRIVACY_RESPONSE = new byte[]{9, 2, 6};
    public static final byte[] POWER_LEVEL_DATA = new byte[]{1, 5, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0};  // 15 bytes
    public static final byte[] POWER_LEVEL_MASK = new byte[]{1, 1, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0};  // 15 bytes
    public static final int POWER_LEVEL_DATA_LENGTH = 15;
    public static final byte[] SCANNABLE_DATA = new byte[]{5, 3, 5};
    public static final byte[] UNSCANNABLE_DATA = new byte[]{8, 9, 7};

    private BluetoothManager mBluetoothManager;
    private BluetoothAdapter mBluetoothAdapter;
    private BluetoothLeAdvertiser mAdvertiser;
    private BluetoothGattServer mGattServer;
    private AdvertiseCallback mCallback;
    private Handler mHandler;

    private int[] mPowerLevel;
    private Map<Integer, AdvertiseCallback> mPowerCallback;
    private int mAdvertiserStatus;

    private AdvertiseCallback mScannableCallback;
    private AdvertiseCallback mUnscannableCallback;

    @Override
    public void onCreate() {
        super.onCreate();

        mBluetoothManager = (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE);
        mBluetoothAdapter = mBluetoothManager.getAdapter();
        mAdvertiser = mBluetoothAdapter.getBluetoothLeAdvertiser();
        mGattServer = mBluetoothManager.openGattServer(getApplicationContext(),
            new BluetoothGattServerCallback() {});
        mHandler = new Handler();
        mAdvertiserStatus = 0;

        mCallback = new BLEAdvertiseCallback();
        mScannableCallback = new BLEAdvertiseCallback();
        mUnscannableCallback = new BLEAdvertiseCallback();
        mPowerLevel = new int[]{
            AdvertiseSettings.ADVERTISE_TX_POWER_ULTRA_LOW,
            AdvertiseSettings.ADVERTISE_TX_POWER_LOW,
            AdvertiseSettings.ADVERTISE_TX_POWER_MEDIUM,
            AdvertiseSettings.ADVERTISE_TX_POWER_HIGH};
        mPowerCallback = new HashMap<Integer, AdvertiseCallback>();
        for (int x : mPowerLevel) {
            mPowerCallback.put(x, new BLEAdvertiseCallback());
        }
    }

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        if (intent != null) handleIntent(intent);
        return START_NOT_STICKY;
    }

    @Override
    public IBinder onBind(Intent intent) {
        return null;
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        if (mAdvertiser != null) {
            stopAdvertiser();
        }
    }

    private void stopAdvertiser() {
        if (mAdvertiser == null) {
            mAdvertiserStatus = 0;
            return;
        }
        if ((mAdvertiserStatus & (1 << COMMAND_START_ADVERTISE)) > 0) {
            mAdvertiser.stopAdvertising(mCallback);
        }
        if ((mAdvertiserStatus & (1 << COMMAND_START_POWER_LEVEL)) > 0) {
            for (int t : mPowerLevel) {
                mAdvertiser.stopAdvertising(mPowerCallback.get(t));
            }
        }
        if ((mAdvertiserStatus & (1 << COMMAND_START_SCANNABLE)) > 0) {
            mAdvertiser.stopAdvertising(mScannableCallback);
        }
        if ((mAdvertiserStatus & (1 << COMMAND_START_UNSCANNABLE)) > 0) {
            mAdvertiser.stopAdvertising(mUnscannableCallback);
        }
        mAdvertiserStatus = 0;
    }

    private AdvertiseData generateAdvertiseData(UUID uuid, byte[] data) {
        return new AdvertiseData.Builder()
            .addManufacturerData(MANUFACTURER_TEST_ID, new byte[]{MANUFACTURER_TEST_ID, 0})
            .addServiceData(new ParcelUuid(uuid), data)
            .setIncludeTxPowerLevel(true)
            .build();
    }

    private AdvertiseSettings generateSetting(int power) {
        return new AdvertiseSettings.Builder()
            .setAdvertiseMode(AdvertiseSettings.ADVERTISE_MODE_LOW_LATENCY)
            .setTxPowerLevel(power)
            .setConnectable(false)
            .build();
    }

    private void handleIntent(Intent intent) {
        if (mBluetoothAdapter != null && !mBluetoothAdapter.isMultipleAdvertisementSupported()) {
            showMessage(""Multiple advertisement is not supported."");
            sendBroadcast(new Intent(BLE_ADV_NOT_SUPPORT));
            return;
        } else if (mAdvertiser == null) {
            showMessage(""Cannot start advertising on this device."");
            return;
        }
        int command = intent.getIntExtra(EXTRA_COMMAND, -1);
        if (command >= 0) {
            stopAdvertiser();
            mAdvertiserStatus |= (1 << command);
        }

        switch (command) {
            case COMMAND_START_ADVERTISE:
                AdvertiseData data = generateAdvertiseData(PRIVACY_MAC_UUID, PRIVACY_MAC_DATA);
                AdvertiseData response = generateAdvertiseData(SCAN_RESP_UUID, PRIVACY_RESPONSE);
                AdvertiseSettings setting =
                        generateSetting(AdvertiseSettings.ADVERTISE_TX_POWER_MEDIUM);

                mAdvertiser.startAdvertising(setting, data, response, mCallback);
                sendBroadcast(new Intent(BLE_START_ADVERTISE));
                break;
            case COMMAND_STOP_ADVERTISE:
                sendBroadcast(new Intent(BLE_STOP_ADVERTISE));
                break;
            case COMMAND_START_POWER_LEVEL:
                for (int t : mPowerLevel) {
                    // Service data:
                    //    field overhead = 2 bytes
                    //    uuid = 2 bytes
                    //    data = 15 bytes
                    // Manufacturer data:
                    //    field overhead = 2 bytes
                    //    Specific data length = 2 bytes
                    //    data length = 2 bytes
                    // Include power level:
                    //    field overhead = 2 bytes
                    //    1 byte
                    // Connectable flag: 3 bytes (0 byte for Android 5.1+)
                    // SUM = 31 bytes
                    byte[] dataBytes = new byte[POWER_LEVEL_DATA_LENGTH];
                    dataBytes[0] = 0x01;
                    dataBytes[1] = 0x05;
                    for (int i = 2; i < POWER_LEVEL_DATA_LENGTH; i++) {
                        dataBytes[i] = (byte)t;
                    }
                    AdvertiseData d = generateAdvertiseData(POWER_LEVEL_UUID, dataBytes);
                    AdvertiseSettings settings = generateSetting(t);
                    mAdvertiser.startAdvertising(settings, d, mPowerCallback.get(t));
                }
                sendBroadcast(new Intent(BLE_START_POWER_LEVEL));
                break;
            case COMMAND_STOP_POWER_LEVEL:
                sendBroadcast(new Intent(BLE_STOP_POWER_LEVEL));
                break;
            case COMMAND_START_SCANNABLE:
                data = generateAdvertiseData(SCANNABLE_UUID, SCANNABLE_DATA);
                setting = generateSetting(AdvertiseSettings.ADVERTISE_TX_POWER_MEDIUM);

                mAdvertiser.startAdvertising(setting, data, mScannableCallback);
                sendBroadcast(new Intent(BLE_START_SCANNABLE));
                break;
            case COMMAND_START_UNSCANNABLE:
                data = generateAdvertiseData(UNSCANNABLE_UUID, UNSCANNABLE_DATA);
                setting = generateSetting(AdvertiseSettings.ADVERTISE_TX_POWER_MEDIUM);

                mAdvertiser.startAdvertising(setting, data, mUnscannableCallback);
                sendBroadcast(new Intent(BLE_START_UNSCANNABLE));
                break;
            case COMMAND_STOP_SCANNABLE:
                sendBroadcast(new Intent(BLE_STOP_SCANNABLE));
                break;
            case COMMAND_STOP_UNSCANNABLE:
                sendBroadcast(new Intent(BLE_STOP_UNSCANNABLE));
                break;
            default:
                showMessage(""Unrecognized command: "" + command);
                break;
        }
    }

    private void showMessage(final String msg) {
        mHandler.post(new Runnable() {
            public void run() {
                Toast.makeText(BleAdvertiserService.this, msg, Toast.LENGTH_SHORT).show();
            }
        });
    }

    private class BLEAdvertiseCallback extends AdvertiseCallback {
        @Override
        public void onStartFailure(int errorCode) {
            Log.e(TAG, ""fail. Error code: "" + errorCode);
        }

        @Override
        public void onStartSuccess(AdvertiseSettings setting) {
            if (DEBUG) Log.d(TAG, ""success."");
        }
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.display.cts.BrightnessTest"	"testAtMostOneAppHoldsBrightnessConfigurationPermission"	"CtsDisplayTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/display/src/android/display/cts/BrightnessTest.java"	""	"public void testAtMostOneAppHoldsBrightnessConfigurationPermission() {
        assertTrue(numberOfSystemAppsWithPermission(
                    Manifest.permission.CONFIGURE_DISPLAY_BRIGHTNESS) < 2);
    }

    private void assertValidLuxData(BrightnessChangeEvent event) {
        assertNotNull(event.luxTimestamps);
        assertNotNull(event.luxValues);
        assertTrue(event.luxTimestamps.length > 0);
        assertEquals(event.luxValues.length, event.luxTimestamps.length);
        for (int i = 1; i < event.luxTimestamps.length; ++i) {
            assertTrue(event.luxTimestamps[i - 1] <= event.luxTimestamps[i]);
        }
        for (int i = 0; i < event.luxValues.length; ++i) {
            assertTrue(event.luxValues[i] >= 0.0f);
            assertTrue(event.luxValues[i] <= Float.MAX_VALUE);
            assertFalse(Float.isNaN(event.luxValues[i]));
        }
    }

    /**
     * Returns the number of system apps with the given permission.
     */
    private int numberOfSystemAppsWithPermission(String permission) {
        List<PackageInfo> packages = mContext.getPackageManager().getPackagesHoldingPermissions(
                new String[]{permission}, PackageManager.MATCH_SYSTEM_ONLY);
        packages.removeIf(packageInfo -> packageInfo.packageName.equals(""com.android.shell""));
        return packages.size();
    }

    private List<BrightnessChangeEvent> getNewEvents(int expected)
            throws InterruptedException {
        List<BrightnessChangeEvent> newEvents = new ArrayList<>();
        for (int i = 0; newEvents.size() < expected && i < 20; ++i) {
            if (i != 0) {
                Thread.sleep(100);
            }
            newEvents.addAll(getNewEvents());
        }
        return newEvents;
    }

    private List<BrightnessChangeEvent> getNewEvents() {
        List<BrightnessChangeEvent> newEvents = new ArrayList<>();
        List<BrightnessChangeEvent> events = mDisplayManager.getBrightnessEvents();
        for (BrightnessChangeEvent event : events) {
            if (!mLastReadEvents.containsKey(event.timeStamp)) {
                newEvents.add(event);
            }
        }
        mLastReadEvents = new HashMap<>();
        for (BrightnessChangeEvent event : events) {
            mLastReadEvents.put(event.timeStamp, event);
        }
        return newEvents;
    }

    private void recordSliderEvents() {
        mLastReadEvents = new HashMap<>();
        List<BrightnessChangeEvent> eventsBefore = mDisplayManager.getBrightnessEvents();
        for (BrightnessChangeEvent event : eventsBefore) {
            mLastReadEvents.put(event.timeStamp, event);
        }
    }

    private void waitForFirstSliderEvent() throws  InterruptedException {
        // Keep changing brightness until we get an event to handle devices with sensors
        // that take a while to warm up.
        int brightness = 25;
        for (int i = 0; i < 20; ++i) {
            setSystemSetting(Settings.System.SCREEN_BRIGHTNESS, brightness);
            brightness = brightness == 25 ? 80 : 25;
            Thread.sleep(100);
            if (!getNewEvents().isEmpty()) {
                return;
            }
        }
        fail(""Failed to fetch first slider event. Is the ambient brightness sensor working?"");
    }

    private int getSystemSetting(String setting) {
        return Integer.parseInt(runShellCommand(""settings get system "" + setting));
    }

    private void setSystemSetting(String setting, int value) {
        runShellCommand(""settings put system "" + setting + "" "" + Integer.toString(value));
    }

    private void grantPermission(String permission) {
        InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .grantRuntimePermission(mContext.getPackageName(), permission);
    }

    private void revokePermission(String permission) {
        InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .revokeRuntimePermission(mContext.getPackageName(), permission);
    }

    private String runShellCommand(String cmd) {
        UiAutomation automation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        ParcelFileDescriptor output = automation.executeShellCommand(cmd);
        String result = convertFileDescriptorToString(output.getFileDescriptor());
        return result.trim();
    }

    private String convertFileDescriptorToString(FileDescriptor desc) {
        try (Scanner s = new Scanner(new FileInputStream(desc)).useDelimiter(""\\Z"")) {
            return s.hasNext() ? s.next() : """";
        }
    }

    private static void assertInRange(float[] values, float min, float max) {
        for (int i = 0; i < values.length; i++) {
            assertFalse(Float.isNaN(values[i]));
            assertTrue(values[i] >= min);
            assertTrue(values[i] <= max);
        }
    }

    private static void assertMonotonic(float[] values, boolean strictlyIncreasing, String name) {
        if (values.length <= 1) {
            return;
        }
        float prev = values[0];
        for (int i = 1; i < values.length; i++) {
            if (prev > values[i] || (prev == values[i] && strictlyIncreasing)) {
                String condition = strictlyIncreasing ? ""strictly increasing"" : ""monotonic"";
                fail(name + "" values must be "" + condition);
            }
            prev = values[i];
        }
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.cts.statsdatom.statsd.UidAtomTests"	"isNotNull"	"CtsStatsdAtomHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/statsd/UidAtomTests.java"	""	"public void test/*
 *.
 */
package android.cts.statsdatom.statsd;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import android.app.AppOpEnum;
import android.cts.statsdatom.lib.AtomTestUtils;
import android.cts.statsdatom.lib.ConfigUtils;
import android.cts.statsdatom.lib.DeviceUtils;
import android.cts.statsdatom.lib.ReportUtils;
import android.os.WakeLockLevelEnum;
import android.server.ErrorSource;

import com.android.compatibility.common.util.PropertyUtil;
import com.android.internal.os.StatsdConfigProto.FieldValueMatcher;
import com.android.internal.os.StatsdConfigProto.StatsdConfig;
import com.android.os.AtomsProto.ANROccurred;
import com.android.os.AtomsProto.AppBreadcrumbReported;
import com.android.os.AtomsProto.AppCrashOccurred;
import com.android.os.AtomsProto.AppUsageEventOccurred;
import com.android.os.AtomsProto.Atom;
import com.android.os.AtomsProto.AttributionNode;
import com.android.os.AtomsProto.AudioStateChanged;
import com.android.os.AtomsProto.CameraStateChanged;
import com.android.os.AtomsProto.DeviceCalculatedPowerBlameUid;
import com.android.os.AtomsProto.FlashlightStateChanged;
import com.android.os.AtomsProto.ForegroundServiceAppOpSessionEnded;
import com.android.os.AtomsProto.ForegroundServiceStateChanged;
import com.android.os.AtomsProto.GpsScanStateChanged;
import com.android.os.AtomsProto.LmkKillOccurred;
import com.android.os.AtomsProto.MediaCodecStateChanged;
import com.android.os.AtomsProto.OverlayStateChanged;
import com.android.os.AtomsProto.SyncStateChanged;
import com.android.os.AtomsProto.TestAtomReported;
import com.android.os.AtomsProto.UiEventReported;
import com.android.os.AtomsProto.VibratorStateChanged;
import com.android.os.AtomsProto.WakelockStateChanged;
import com.android.os.StatsLog.EventMetricData;
import com.android.tradefed.build.IBuildInfo;
import com.android.tradefed.log.LogUtil;
import com.android.tradefed.testtype.DeviceTestCase;
import com.android.tradefed.testtype.IBuildReceiver;
import com.android.tradefed.util.Pair;

import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.function.Function;
import java.util.stream.Collectors;

/**
 * Statsd atom tests that are done via app, for atoms that report a uid.
 */
public class UidAtomTests extends DeviceTestCase implements IBuildReceiver {

    private static final String TAG = ""Statsd.UidAtomTests"";

    private static final String TEST_PACKAGE_NAME = ""com.android.server.cts.device.statsd"";

    private static final String ACTION_SHOW_APPLICATION_OVERLAY = ""action.show_application_overlay"";

    private static final String FEATURE_AUDIO_OUTPUT = ""android.hardware.audio.output"";
    private static final String FEATURE_CAMERA = ""android.hardware.camera"";
    private static final String FEATURE_CAMERA_FLASH = ""android.hardware.camera.flash"";
    private static final String FEATURE_CAMERA_FRONT = ""android.hardware.camera.front"";
    private static final String FEATURE_LEANBACK_ONLY = ""android.software.leanback_only"";
    private static final String FEATURE_LOCATION_GPS = ""android.hardware.location.gps"";
    private static final String FEATURE_PICTURE_IN_PICTURE = ""android.software.picture_in_picture"";
    private static final String FEATURE_TV = ""android.hardware.type.television"";

    private IBuildInfo mCtsBuild;

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        assertThat(mCtsBuild).isNotNull();
        ConfigUtils.removeConfig(getDevice());
        ReportUtils.clearReports(getDevice());
        DeviceUtils.installStatsdTestApp(getDevice(), mCtsBuild);
        Thread.sleep(AtomTestUtils.WAIT_TIME_LONG);
    }

    @Override
    protected void tearDown() throws Exception {
        ConfigUtils.removeConfig(getDevice());
        ReportUtils.clearReports(getDevice());
        DeviceUtils.uninstallStatsdTestApp(getDevice());
        super.tearDown();
    }

    @Override
    public void setBuild(IBuildInfo buildInfo) {
        mCtsBuild = buildInfo;
    }

    /**
     * Tests that statsd correctly maps isolated uids to host uids by verifying that atoms logged
     * from an isolated process are seen as coming from their host process.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.cts.statsdatom.statsd.UidAtomTests"	"testGpsScan"	"CtsStatsdAtomHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/statsd/UidAtomTests.java"	""	"public void testGpsScan() throws Exception {
        if (!DeviceUtils.hasFeature(getDevice(), FEATURE_LOCATION_GPS)) return;
        // Whitelist this app against background location request throttling
        String origWhitelist = getDevice().executeShellCommand(
                ""settings get global location_background_throttle_package_whitelist"").trim();
        getDevice().executeShellCommand(String.format(
                ""settings put global location_background_throttle_package_whitelist %s"",
                DeviceUtils.STATSD_ATOM_TEST_PKG));

        try {
            final int atom = Atom.GPS_SCAN_STATE_CHANGED_FIELD_NUMBER;
            final int key = GpsScanStateChanged.STATE_FIELD_NUMBER;
            final int stateOn = GpsScanStateChanged.State.ON_VALUE;
            final int stateOff = GpsScanStateChanged.State.OFF_VALUE;
            final int minTimeDiffMillis = 500;
            final int maxTimeDiffMillis = 60_000;

            ConfigUtils.uploadConfigForPushedAtomWithUid(getDevice(),
                    DeviceUtils.STATSD_ATOM_TEST_PKG,
                    atom, /*useUidAttributionChain=*/true);

            DeviceUtils.runDeviceTestsOnStatsdApp(getDevice(), "".AtomTests"",
                    ""testGpsScan"");

            List<EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());
            assertThat(data).hasSize(2);
            GpsScanStateChanged a0 = data.get(0).getAtom().getGpsScanStateChanged();
            GpsScanStateChanged a1 = data.get(1).getAtom().getGpsScanStateChanged();
            AtomTestUtils.assertTimeDiffBetween(data.get(0), data.get(1), minTimeDiffMillis,
                    maxTimeDiffMillis);
            assertThat(a0.getState().getNumber()).isEqualTo(stateOn);
            assertThat(a1.getState().getNumber()).isEqualTo(stateOff);
        } finally {
            if (""null"".equals(origWhitelist) || """".equals(origWhitelist)) {
                getDevice().executeShellCommand(
                        ""settings delete global location_background_throttle_package_whitelist"");
            } else {
                getDevice().executeShellCommand(String.format(
                        ""settings put global location_background_throttle_package_whitelist %s"",
                        origWhitelist));
            }
        }
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.compatibility.dalvik.DalvikTestRunner"	"DalvikTestListener"	""	"/home/gpoor/cts-12-source/cts/tests/jdwp/runner/device-side/src/com/android/compatibility/dalvik/DalvikTestRunner.java"	""	"public void test/*
 *.
 */

package com.android.compatibility.dalvik;

import dalvik.system.DexFile;
import dalvik.system.PathClassLoader;

import junit.framework.AssertionFailedError;
import junit.framework.Test;
import junit.framework.TestCase;
import junit.framework.TestListener;
import junit.framework.TestResult;
import junit.framework.TestSuite;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.lang.annotation.Annotation;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Enumeration;
import java.util.HashSet;
import java.util.List;
import java.util.Scanner;
import java.util.Set;
import java.util.function.Consumer;

/**
 * Runs tests against the Dalvik VM.
 */
public class DalvikTestRunner {

    private static final String ABI = ""--abi="";
    private static final String INCLUDE = ""--include-filter="";
    private static final String EXCLUDE = ""--exclude-filter="";
    private static final String INCLUDE_FILE = ""--include-filter-file="";
    private static final String EXCLUDE_FILE = ""--exclude-filter-file="";
    private static final String COLLECT_TESTS_ONLY = ""--collect-tests-only"";
    private static final String JUNIT_IGNORE = ""org.junit.Ignore"";

    private static final String RUNNER_JAR = ""cts-dalvik-device-test-runner.jar"";

    public static void main(String[] args) {
        Config config;
        try {
            config = createConfig(args);
        } catch (Throwable t) {
            // Simulate one failed test.
            System.out.println(""start-run:1"");
            System.out.println(""start-test:FailedConfigCreation"");
            System.out.println(""failure:"" + DalvikTestListener.stringify(t));
            System.out.println(""end-run:1"");
            throw new RuntimeException(t);
        }
        run(config);
    }

    private static Config createConfig(String[] args) {
        String abiName = null;
        Config config = new Config();

        for (String arg : args) {
            if (arg.startsWith(ABI)) {
                abiName = arg.substring(ABI.length());
            } else if (arg.startsWith(INCLUDE)) {
                for (String include : arg.substring(INCLUDE.length()).split("","")) {
                    config.includes.add(include);
                }
            } else if (arg.startsWith(EXCLUDE)) {
                for (String exclude : arg.substring(EXCLUDE.length()).split("","")) {
                    config.excludes.add(exclude);
                }
            } else if (arg.startsWith(INCLUDE_FILE)) {
                loadFilters(arg.substring(INCLUDE_FILE.length()), config.includes);
            } else if (arg.startsWith(EXCLUDE_FILE)) {
                loadFilters(arg.substring(EXCLUDE_FILE.length()), config.excludes);
            } else if (COLLECT_TESTS_ONLY.equals(arg)) {
                config.collectTestsOnly = true;
            }
        }

        String[] classPathItems = System.getProperty(""java.class.path"").split(File.pathSeparator);
        List<Class<?>> classes = getClasses(classPathItems, abiName);
        config.suite = new FilterableTestSuite(classes, config.includes, config.excludes);

        return config;
    }

    private static void run(Config config) {
        TestListener listener = new DalvikTestListener();

        int count = config.suite.countTestCases();
        System.out.println(String.format(""start-run:%d"", count));
        long start = System.currentTimeMillis();

        if (config.collectTestsOnly) { // only simulate running/passing the tests with the listener
            collectTests(config.suite, listener, config.includes, config.excludes);
        } else { // run the tests
            TestResult result = new TestResult();
            result.addListener(listener);
            config.suite.run(result);
        }

        long end = System.currentTimeMillis();
        System.out.println(String.format(""end-run:%d"", end - start));
    }

    private static void iterateTests(Test test, Set<String> includes, Set<String> excludes,
            Consumer<Test> sink) {
        if (test instanceof TestSuite) {
            // If the test is a suite it could contain multiple tests, these need to be split
            // out into separate tests so they can be filtered
            TestSuite suite = (TestSuite) test;
            Enumeration<Test> enumerator = suite.tests();
            while (enumerator.hasMoreElements()) {
                iterateTests(enumerator.nextElement(), includes, excludes, sink);
            }
            return;
        }
        if (shouldRun(test, includes, excludes)) {
            sink.accept(test);
        }
    }

    /* Recursively collect tests, since Test elements of the TestSuite may also be TestSuite
     * objects containing Tests. */
    private static void collectTests(TestSuite suite, TestListener listener,
            Set<String> includes, Set<String> excludes) {
        iterateTests(suite, includes, excludes, test -> {
            listener.startTest(test);
            listener.endTest(test);
        });
    }

    private static boolean packageFilterApplies(String className, Set<String> filters) {
      // Traditional meaning: equality.
      int index = className.lastIndexOf('.');
      String packageName = index < 0 ? """" : className.substring(0, index);
      if (filters.contains(packageName)) {
        return true;
      }

      // See if it's a name prefix, for JarJared names.
      for (String filter : filters) {
        if (className.startsWith(filter) && className.length() > filter.length() &&
                className.charAt(filter.length()) == '_') {
            return true;
        }
      }

      return false;
    }

    private static boolean shouldRun(Test test, Set<String> includes, Set<String> excludes) {
        String fullName = test.toString();
        String[] parts = fullName.split(""[\\(\\)]"");
        String className = parts[1];
        String methodName = String.format(""%s#%s"", className, parts[0]);

        if (packageFilterApplies(className, excludes)) {
            // Skip package because it was excluded
            return false;
        }
        if (excludes.contains(className)) {
            // Skip class because it was excluded
            return false;
        }
        if (excludes.contains(methodName)) {
            // Skip method because it was excluded
            return false;
        }
        return includes.isEmpty()
                || includes.contains(methodName)
                || includes.contains(className)
                || packageFilterApplies(className, includes);
    }

    private static void loadFilters(String filename, Set<String> filters) {
        try {
            Scanner in = new Scanner(new File(filename));
            while (in.hasNextLine()) {
                filters.add(in.nextLine());
            }
            in.close();
        } catch (FileNotFoundException e) {
            System.out.println(String.format(""File %s not found when loading filters"", filename));
        }
    }

    private static List<Class<?>> getClasses(String[] jars, String abiName) {
        List<Class<?>> classes = new ArrayList<>();
        for (String jar : jars) {
            if (jar.contains(RUNNER_JAR)) {
                // The runner jar must be added to the class path to invoke DalvikTestRunner,
                // but should not be searched for test classes
                continue;
            }
            try {
                ClassLoader loader = createClassLoader(jar, abiName);
                DexFile file = new DexFile(jar);
                Enumeration<String> entries = file.entries();
                while (entries.hasMoreElements()) {
                    String e = entries.nextElement();
                    try {
                        Class<?> cls = loader.loadClass(e);
                        if (isTestClass(cls)) {
                            classes.add(cls);
                        }
                    } catch (ClassNotFoundException ex) {
                        System.out.println(String.format(
                                ""Skipping dex entry %s in %s"", e, jar));
                    }
                }
            } catch (IllegalAccessError | IOException e) {
                e.printStackTrace();
            } catch (Exception e) {
                throw new RuntimeException(jar, e);
            }
        }
        return classes;
    }

    private static ClassLoader createClassLoader(String jar, String abiName) {
        StringBuilder libPath = new StringBuilder();
        libPath.append(jar).append(""!/lib/"").append(abiName);
        return new PathClassLoader(
                jar, libPath.toString(), DalvikTestRunner.class.getClassLoader());
    }

    private static boolean isTestClass(Class<?> cls) {
        // FIXME(b/25154702): have to have a null check here because some
        // classes such as
        // SQLite.JDBC2z.JDBCPreparedStatement can be found in the classes.dex
        // by DexFile.entries
        // but trying to load them with DexFile.loadClass returns null.
        if (cls == null) {
            return false;
        }
        for (Annotation a : cls.getAnnotations()) {
            if (a.annotationType().getName().equals(JUNIT_IGNORE)) {
                return false;
            }
        }

        try {
            if (!hasPublicTestMethods(cls)) {
                return false;
            }
        } catch (Throwable exc) {
            throw new RuntimeException(cls.toString(), exc);
        }

        // TODO: Add junit4 support here
        int modifiers = cls.getModifiers();
        return (Test.class.isAssignableFrom(cls)
                && Modifier.isPublic(modifiers)
                && !Modifier.isStatic(modifiers)
                && !Modifier.isInterface(modifiers)
                && !Modifier.isAbstract(modifiers));
    }

    private static boolean hasPublicTestMethods(Class<?> cls) {
        for (Method m : cls.getDeclaredMethods()) {
            if (isPublicTestMethod(m)) {
                return true;
            }
        }
        return false;
    }

    private static boolean isPublicTestMethod(Method m) {
        boolean hasTestName = m.getName().startsWith(""test"");
        boolean takesNoParameters = (m.getParameterTypes().length == 0);
        boolean returnsVoid = m.getReturnType().equals(Void.TYPE);
        boolean isPublic = Modifier.isPublic(m.getModifiers());
        return hasTestName && takesNoParameters && returnsVoid && isPublic;
    }

    // TODO: expand this to setup and teardown things needed by Dalvik tests.
    private static class DalvikTestListener implements TestListener {
        /**
         * {@inheritDoc}
         */
        @Override
        public void startTest(Test test) {
            System.out.println(String.format(""start-test:%s"", getId(test)));
        }

        /**
         * {@inheritDoc}
         */
        @Override
        public void endTest(Test test) {
            System.out.println(String.format(""end-test:%s"", getId(test)));
        }

        /**
         * {@inheritDoc}
         */
        @Override
        public void addFailure(Test test, AssertionFailedError error) {
            System.out.println(String.format(""failure:%s"", stringify(error)));
        }

        /**
         * {@inheritDoc}
         */
        @Override
        public void addError(Test test, Throwable error) {
            System.out.println(String.format(""failure:%s"", stringify(error)));
        }

        private String getId(Test test) {
            String className = test.getClass().getName();
            if (test instanceof TestCase) {
                return String.format(""%s#%s"", className, ((TestCase) test).getName());
            }
            return className;
        }

        public static String stringify(Throwable error) {
            String output = null;
            try {
              try (StringWriter sw = new StringWriter()) {
                try (PrintWriter pw = new PrintWriter(sw)) {
                  error.printStackTrace(pw);
                }
                output = sw.toString();
              }
            } catch (Exception e) {
              if (output == null) {
                output = error.toString() + Arrays.toString(error.getStackTrace());
              }
            }
            return output.replace(""\n"", ""^~^"");
        }
    }

    private static class Config {
        Set<String> includes = new HashSet<>();
        Set<String> excludes = new HashSet<>();
        boolean collectTestsOnly = false;
        TestSuite suite;
    }

    /**
     * A {@link TestSuite} that can filter which tests run, given the include and exclude filters.
     *
     * This had to be private inner class because the test runner would find it and think it was a
     * suite of tests, but it has no tests in it, causing a crash.
     */
    private static class FilterableTestSuite extends TestSuite {

        private Set<String> mIncludes;
        private Set<String> mExcludes;

        public FilterableTestSuite(List<Class<?>> classes, Set<String> includes,
                Set<String> excludes) {
            super(classes.toArray(new Class<?>[classes.size()]));
            mIncludes = includes;
            mExcludes = excludes;
        }

        private static class CountConsumer implements Consumer<Test> {
            public int count = 0;

            @Override
            public void accept(Test t) {
                count++;
            }
        }

        @Override
        public int countTestCases() {
            CountConsumer counter = new CountConsumer();
            iterateTests(this, mIncludes, mExcludes, counter);
            return counter.count;
        }

        @Override
        public void runTest(Test test, TestResult result) {
            iterateTests(test, mIncludes, mExcludes, t -> t.run(result));
        }
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.devicepolicy.cts.DevicePolicyManagerTest"	"isEmpty"	"CtsDevicePolicyTestCases"	"/home/gpoor/cts-12-source/cts/tests/devicepolicy/src/android/devicepolicy/cts/DevicePolicyManagerTest.java"	""	"public void getPolicyExemptAppsCanOnlyBeDefinedOnAutomotiveBuilds() throws Exception {
        assertWithMessage(""list of policy-exempt apps"")
                .that(sDevicePolicyManager.getPolicyExemptApps())
                .isEmpty();
    }

    FullyManagedDeviceProvisioningParams.Builder
            createDefaultManagedDeviceProvisioningParamsBuilder() {
        return new FullyManagedDeviceProvisioningParams.Builder(
                DEVICE_ADMIN_COMPONENT_NAME,
                DEVICE_OWNER_NAME)
                // Don't remove system apps during provisioning until the testing
                // infrastructure supports restoring uninstalled apps.
                .setLeaveAllSystemAppsEnabled(true);
    }

    private void resetUserSetupCompletedFlag() {
        try (PermissionContext p = sTestApis.permissions().withPermission(WRITE_SECURE_SETTINGS)) {
            Settings.Secure.putInt(sContext.getContentResolver(), USER_SETUP_COMPLETE_KEY, 0);
        }
        sDevicePolicyManager.forceUpdateUserSetupComplete(sContext.getUserId());
    }

    private void setUserSetupCompletedFlag() {
        try (PermissionContext p = sTestApis.permissions().withPermission(WRITE_SECURE_SETTINGS)) {
            Settings.Secure.putInt(sContext.getContentResolver(), USER_SETUP_COMPLETE_KEY, 1);
        }
        sDevicePolicyManager.forceUpdateUserSetupComplete(sContext.getUserId());
    }

    private Set<String> findSystemApps() {
        return sPackageManager.getInstalledApplications(PackageManager.MATCH_SYSTEM_ONLY)
                .stream()
                .map(applicationInfo -> applicationInfo.packageName)
                .collect(Collectors.toSet());
    }

    // TODO(b/175380793): Add remaining cts test for DPM#provisionManagedDevice and
    //  DPM#createAndProvisionManagedProfile.
    //  Currently the following methods are not used.
    /**
     * Allows {@link #restorePreProvisioningApps} to be called to restore the pre-provisioning apps
     * that were uninstalled during provisioning.
     */
    private void persistPreProvisioningApps() {
        SystemUtil.runShellCommand(SET_DEVICE_OWNER_ACTIVE_ADMIN_COMMAND);
        SystemUtil.runShellCommand(SET_DEVICE_OWNER_COMMAND);

        Set<String> systemApps = findSystemApps();
        sSharedPreferences.edit()
                .putStringSet(KEY_PRE_PROVISIONING_SYSTEM_APPS, systemApps)
                .commit();
        Set<String> nonSystemApps = findNonSystemApps(systemApps);
        sSharedPreferences.edit()
                .putStringSet(KEY_PRE_PROVISIONING_NON_SYSTEM_APPS, nonSystemApps)
                .commit();
        sDevicePolicyManager.setKeepUninstalledPackages(
                DEVICE_ADMIN_COMPONENT_NAME, new ArrayList<>(nonSystemApps));

        SystemUtil.runShellCommand(REMOVE_ACTIVE_ADMIN_COMMAND);
    }

    /**
     * Restores apps that were uninstalled prior to provisioning. No-op if {@link
     * #persistPreProvisioningApps()} was not called prior to provisioning. Subsequent
     * calls will need another prior call to {@link #persistPreProvisioningApps()} to avoid being a
     * no-op.
     */
    public void restorePreProvisioningApps() {
        SystemUtil.runShellCommand(SET_DEVICE_OWNER_ACTIVE_ADMIN_COMMAND);
        SystemUtil.runShellCommand(SET_DEVICE_OWNER_COMMAND);

        Set<String> postProvisioningSystemApps = findSystemApps();
        restorePreProvisioningSystemApps(postProvisioningSystemApps);
        restorePreProvisioningNonSystemApps(postProvisioningSystemApps);
        sSharedPreferences.edit().clear().commit();
        sDevicePolicyManager.setKeepUninstalledPackages(
                DEVICE_ADMIN_COMPONENT_NAME, new ArrayList<>());

        SystemUtil.runShellCommand(REMOVE_ACTIVE_ADMIN_COMMAND);
    }

    private void restorePreProvisioningSystemApps(Set<String> postProvisioningSystemApps) {
        Set<String> preProvisioningSystemApps = sSharedPreferences.getStringSet(
                KEY_PRE_PROVISIONING_SYSTEM_APPS, Collections.emptySet());
        for (String preProvisioningSystemApp : preProvisioningSystemApps) {
            if (postProvisioningSystemApps.contains(preProvisioningSystemApp)) {
                continue;
            }
            sDevicePolicyManager.enableSystemApp(
                    DEVICE_ADMIN_COMPONENT_NAME, preProvisioningSystemApp);
        }
    }

    private void restorePreProvisioningNonSystemApps(Set<String> postProvisioningSystemApps) {
        Set<String> preProvisioningNonSystemApps = sSharedPreferences.getStringSet(
                KEY_PRE_PROVISIONING_NON_SYSTEM_APPS, Collections.emptySet());
        Set<String> postProvisioningNonSystemApps = findNonSystemApps(postProvisioningSystemApps);
        for (String preProvisioningNonSystemApp : preProvisioningNonSystemApps) {
            if (postProvisioningNonSystemApps.contains(preProvisioningNonSystemApp)) {
                continue;
            }
            sDevicePolicyManager.installExistingPackage(
                    DEVICE_ADMIN_COMPONENT_NAME, preProvisioningNonSystemApp);
        }
    }

    private Set<String> findNonSystemApps(Set<String> systemApps) {
        return sPackageManager.getInstalledApplications(PackageManager.MATCH_ALL)
                .stream()
                .map(applicationInfo -> applicationInfo.packageName)
                .filter(packageName -> !systemApps.contains(packageName))
                .collect(Collectors.toSet());
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.ScanResultTest"	"isNotNull"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ScanResultTest.java"	""	"public void test/*
 *.
 */

package android.net.wifi.cts;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import java.nio.ByteBuffer;
import java.util.List;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.net.wifi.ScanResult;
import android.net.wifi.ScanResult.InformationElement;
import android.net.wifi.WifiInfo;
import android.net.wifi.WifiManager;
import android.net.wifi.WifiManager.WifiLock;
import android.platform.test.annotations.AppModeFull;
import android.test.AndroidTestCase;

import com.android.compatibility.common.util.PollingCheck;
import com.android.compatibility.common.util.ShellIdentityUtils;
import com.android.compatibility.common.util.SystemUtil;

@AppModeFull(reason = ""Cannot get WifiManager in instant app mode"")
public class ScanResultTest extends WifiJUnit3TestBase {
    private static class MySync {
        int expectedState = STATE_NULL;
    }

    private WifiManager mWifiManager;
    private WifiLock mWifiLock;
    private static MySync mMySync;
    private boolean mWasVerboseLoggingEnabled;
    private boolean mWasScanThrottleEnabled;

    private static final int STATE_NULL = 0;
    private static final int STATE_WIFI_CHANGING = 1;
    private static final int STATE_WIFI_CHANGED = 2;
    private static final int STATE_START_SCAN = 3;
    private static final int STATE_SCAN_RESULTS_AVAILABLE = 4;
    private static final int STATE_SCAN_FAILURE = 5;

    private static final String TAG = ""WifiInfoTest"";
    private static final int TIMEOUT_MSEC = 6000;
    private static final int WAIT_MSEC = 60;
    private static final int ENABLE_WAIT_MSEC = 10000;
    private static final int SCAN_WAIT_MSEC = 10000;
    private static final int SCAN_MAX_RETRY_COUNT = 6;
    private static final int SCAN_FIND_BSSID_MAX_RETRY_COUNT = 5;
    private static final long SCAN_FIND_BSSID_WAIT_MSEC = 5_000L;
    private static final int WIFI_CONNECT_TIMEOUT_MILLIS = 30_000;

    private static final String TEST_SSID = ""TEST_SSID"";
    public static final String TEST_BSSID = ""04:ac:fe:45:34:10"";
    public static final String TEST_CAPS = ""CCMP"";
    public static final int TEST_LEVEL = -56;
    public static final int TEST_FREQUENCY = 2412;
    public static final long TEST_TIMESTAMP = 4660L;

    private IntentFilter mIntentFilter;
    private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            final String action = intent.getAction();
            if (action.equals(WifiManager.SUPPLICANT_STATE_CHANGED_ACTION)) {
                synchronized (mMySync) {
                    mMySync.expectedState = STATE_WIFI_CHANGED;
                    mMySync.notify();
                }
            } else if (action.equals(WifiManager.SCAN_RESULTS_AVAILABLE_ACTION)) {
                synchronized (mMySync) {
                    if (intent.getBooleanExtra(WifiManager.EXTRA_RESULTS_UPDATED, false)) {
                        mMySync.expectedState = STATE_SCAN_RESULTS_AVAILABLE;
                    } else {
                        mMySync.expectedState = STATE_SCAN_FAILURE;
                    }
                    mMySync.notify();
                }
            }
        }
    };

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        mMySync = new MySync();
        mIntentFilter = new IntentFilter();
        mIntentFilter.addAction(WifiManager.NETWORK_STATE_CHANGED_ACTION);
        mIntentFilter.addAction(WifiManager.SCAN_RESULTS_AVAILABLE_ACTION);
        mIntentFilter.addAction(WifiManager.SUPPLICANT_CONNECTION_CHANGE_ACTION);
        mIntentFilter.addAction(WifiManager.SUPPLICANT_STATE_CHANGED_ACTION);
        mIntentFilter.addAction(WifiManager.WIFI_STATE_CHANGED_ACTION);
        mIntentFilter.addAction(WifiManager.RSSI_CHANGED_ACTION);
        mIntentFilter.addAction(WifiManager.NETWORK_IDS_CHANGED_ACTION);
        mIntentFilter.addAction(WifiManager.ACTION_PICK_WIFI_NETWORK);

        mContext.registerReceiver(mReceiver, mIntentFilter);
        mWifiManager = (WifiManager) getContext().getSystemService(Context.WIFI_SERVICE);
        assertThat(mWifiManager).isNotNull();

        // turn on verbose logging for tests
        mWasVerboseLoggingEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.isVerboseLoggingEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setVerboseLoggingEnabled(true));
        // Disable scan throttling for tests.
        mWasScanThrottleEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.isScanThrottleEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setScanThrottleEnabled(false));

        mWifiLock = mWifiManager.createWifiLock(TAG);
        mWifiLock.acquire();

        // enable Wifi
        if (!mWifiManager.isWifiEnabled()) setWifiEnabled(true);
        PollingCheck.check(""Wifi not enabled"", ENABLE_WAIT_MSEC,
                () -> mWifiManager.isWifiEnabled());

        mMySync.expectedState = STATE_NULL;
    }

    @Override
    protected void tearDown() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            super.tearDown();
            return;
        }
        mWifiLock.release();
        mContext.unregisterReceiver(mReceiver);
        if (!mWifiManager.isWifiEnabled())
            setWifiEnabled(true);
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setScanThrottleEnabled(mWasScanThrottleEnabled));
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setVerboseLoggingEnabled(mWasVerboseLoggingEnabled));
        Thread.sleep(ENABLE_WAIT_MSEC);
        super.tearDown();
    }

    private void setWifiEnabled(boolean enable) throws Exception {
        synchronized (mMySync) {
            mMySync.expectedState = STATE_WIFI_CHANGING;
            if (enable) {
                SystemUtil.runShellCommand(""svc wifi enable"");
            } else {
                SystemUtil.runShellCommand(""svc wifi disable"");
            }
            waitForBroadcast(TIMEOUT_MSEC, STATE_WIFI_CHANGED);
       }
    }

    private boolean waitForBroadcast(long timeout, int expectedState) throws Exception {
        long waitTime = System.currentTimeMillis() + timeout;
        while (System.currentTimeMillis() < waitTime
                && mMySync.expectedState != expectedState)
            mMySync.wait(WAIT_MSEC);
        return mMySync.expectedState == expectedState;
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.ScanResultTest"	"testScanResultProperties"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ScanResultTest.java"	""	"public void testScanResultProperties() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // this test case should in Wifi environment
        for (ScanResult scanResult : mWifiManager.getScanResults()) {
            assertThat(scanResult.toString()).isNotNull();

            for (InformationElement ie : scanResult.getInformationElements()) {
                testInformationElementCopyConstructor(ie);
                testInformationElementFields(ie);
            }

            assertThat(scanResult.getWifiStandard()).isAnyOf(
                    ScanResult.WIFI_STANDARD_UNKNOWN,
                    ScanResult.WIFI_STANDARD_LEGACY,
                    ScanResult.WIFI_STANDARD_11N,
                    ScanResult.WIFI_STANDARD_11AC,
                    ScanResult.WIFI_STANDARD_11AX
            );

            scanResult.isPasspointNetwork();
        }
    }

    private void testInformationElementCopyConstructor(InformationElement ie) {
        InformationElement copy = new InformationElement(ie);

        assertThat(copy.getId()).isEqualTo(ie.getId());
        assertThat(copy.getIdExt()).isEqualTo(ie.getIdExt());
        assertThat(copy.getBytes()).isEqualTo(ie.getBytes());
    }

    private void testInformationElementFields(InformationElement ie) {
        // id is 1 octet
        int id = ie.getId();
        assertThat(id).isAtLeast(0);
        assertThat(id).isAtMost(255);

        // idExt is 0 or 1 octet
        int idExt = ie.getIdExt();
        assertThat(idExt).isAtLeast(0);
        assertThat(idExt).isAtMost(255);

        ByteBuffer bytes = ie.getBytes();
        assertThat(bytes).isNotNull();
    }

    /* Multiple scans to ensure bssid is updated */
    private void scanAndWait() throws Exception {
        synchronized (mMySync) {
            for (int retry  = 0; retry < SCAN_MAX_RETRY_COUNT; retry++) {
                mMySync.expectedState = STATE_START_SCAN;
                mWifiManager.startScan();
                if (waitForBroadcast(SCAN_WAIT_MSEC, STATE_SCAN_RESULTS_AVAILABLE)) {
                    break;
                }
            }
        }
   }

    @VirtualDeviceNotSupported"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.ScanResultTest"	"testScanResultTimeStamp"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ScanResultTest.java"	""	"public void testScanResultTimeStamp() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }

        long timestamp = 0;
        String BSSID = null;

        scanAndWait();

        List<ScanResult> scanResults = mWifiManager.getScanResults();
        for (ScanResult result : scanResults) {
            BSSID = result.BSSID;
            timestamp = result.timestamp;
            assertThat(timestamp).isNotEqualTo(0);
            break;
        }

        scanAndWait();

        scanResults = mWifiManager.getScanResults();
        for (ScanResult result : scanResults) {
            if (result.BSSID.equals(BSSID)) {
                long timeDiff = (result.timestamp - timestamp) / 1000;
                assertThat(timeDiff).isGreaterThan(0L);
                assertThat(timeDiff).isLessThan(6L * SCAN_WAIT_MSEC);
            }
        }
    }

    /** Test that the copy constructor copies fields correctly. */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.ScanResultTest"	"testScanResultConstructors"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ScanResultTest.java"	""	"public void testScanResultConstructors() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }

        ScanResult scanResult = new ScanResult();
        scanResult.SSID = TEST_SSID;
        scanResult.BSSID = TEST_BSSID;
        scanResult.capabilities = TEST_CAPS;
        scanResult.level = TEST_LEVEL;
        scanResult.frequency = TEST_FREQUENCY;
        scanResult.timestamp = TEST_TIMESTAMP;

        ScanResult scanResult2 = new ScanResult(scanResult);
        assertThat(scanResult2.SSID).isEqualTo(TEST_SSID);
        assertThat(scanResult2.BSSID).isEqualTo(TEST_BSSID);
        assertThat(scanResult2.capabilities).isEqualTo(TEST_CAPS);
        assertThat(scanResult2.level).isEqualTo(TEST_LEVEL);
        assertThat(scanResult2.frequency).isEqualTo(TEST_FREQUENCY);
        assertThat(scanResult2.timestamp).isEqualTo(TEST_TIMESTAMP);
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.ScanResultTest"	"testScanResultMatchesWifiInfo"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ScanResultTest.java"	""	"public void testScanResultMatchesWifiInfo() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }

        // ensure Wifi is connected
        ShellIdentityUtils.invokeWithShellPermissions(() -> mWifiManager.reconnect());
        PollingCheck.check(
                ""Wifi not connected"",
                WIFI_CONNECT_TIMEOUT_MILLIS,
                () -> mWifiManager.getConnectionInfo().getNetworkId() != -1);

        final WifiInfo wifiInfo = mWifiManager.getConnectionInfo();
        assertThat(wifiInfo).isNotNull();

        ScanResult currentNetwork = null;
        for (int i = 0; i < SCAN_FIND_BSSID_MAX_RETRY_COUNT; i++) {
            scanAndWait();
            final List<ScanResult> scanResults = mWifiManager.getScanResults();
            currentNetwork = scanResults.stream().filter(r -> r.BSSID.equals(wifiInfo.getBSSID()))
                    .findAny().orElse(null);

            if (currentNetwork != null) {
                break;
            }
            Thread.sleep(SCAN_FIND_BSSID_WAIT_MSEC);
        }
        assertWithMessage(""Current network not found in scan results"")
                .that(currentNetwork).isNotNull();

        String wifiInfoSsidQuoted = wifiInfo.getSSID();
        String scanResultSsidUnquoted = currentNetwork.SSID;

        assertWithMessage(
                ""SSID mismatch: make sure this isn't a hidden network or an SSID containing ""
                        + ""non-UTF-8 characters - neither is supported by this CTS test."")
                .that(""\"""" + scanResultSsidUnquoted + ""\"""")
                .isEqualTo(wifiInfoSsidQuoted);
        assertThat(currentNetwork.frequency).isEqualTo(wifiInfo.getFrequency());
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.audio.AudioLoopbackBaseActivity"	"isMMapSupported"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/audio/AudioLoopbackBaseActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.audio;

import android.app.AlertDialog;
import android.media.AudioDeviceCallback;
import android.media.AudioDeviceInfo;
import android.media.AudioManager;
import android.media.MediaRecorder;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.util.Log;
import android.view.View;
import android.view.ViewGroup;
import android.widget.Button;
import android.widget.ProgressBar;
import android.widget.SeekBar;
import android.widget.TextView;

import com.android.compatibility.common.util.ResultType;
import com.android.compatibility.common.util.ResultUnit;
import com.android.cts.verifier.audio.audiolib.AudioSystemFlags;
import com.android.cts.verifier.audio.audiolib.StatUtils;
import com.android.cts.verifier.audio.audiolib.AudioUtils;
import com.android.cts.verifier.CtsVerifierReportLog;
import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;

import static com.android.cts.verifier.TestListActivity.sCurrentDisplayMode;
import static com.android.cts.verifier.TestListAdapter.setTestNameSuffix;

/**
 * Base class for testing activitiees that require audio loopback hardware..
 */
public class AudioLoopbackBaseActivity extends PassFailButtons.Activity {
    private static final String TAG = ""AudioLoopbackBaseActivity"";

    // JNI load
    static {
        try {
            System.loadLibrary(""audioloopback_jni"");
        } catch (UnsatisfiedLinkError e) {
            Log.e(TAG, ""Error loading Audio Loopback JNI library"");
            Log.e(TAG, ""e: "" + e);
            e.printStackTrace();
        }

        /* TODO: gracefully fail/notify if the library can't be loaded */
    }
    protected AudioManager mAudioManager;

    // UI
    TextView mInputDeviceTxt;
    TextView mOutputDeviceTxt;

    TextView mAudioLevelText;
    SeekBar mAudioLevelSeekbar;

    TextView mTestPathTxt;

    TextView mResultText;
    ProgressBar mProgressBar;
    int mMaxLevel;

    String mYesString;
    String mNoString;

    // These flags determine the maximum allowed latency
    private boolean mClaimsProAudio;
    private boolean mClaimsOutput;
    private boolean mClaimsInput;

    // Useful info
    private boolean mSupportsMMAP = AudioUtils.isMMapSupported();
    private boolean mSupportsMMAPExclusive = AudioUtils.isMMapExclusiveSupported();

    // Peripheral(s)
    boolean mIsPeripheralAttached;  // CDD ProAudio section C-1-3
    AudioDeviceInfo mOutputDevInfo;
    AudioDeviceInfo mInputDevInfo;

    protected static final int TESTPERIPHERAL_NONE          = 0;
    protected static final int TESTPERIPHERAL_ANALOG_JACK   = 1;
    protected static final int TESTPERIPHERAL_USB           = 2;
    protected static final int TESTPERIPHERAL_DEVICE        = 3; // device speaker + mic
    protected int mTestPeripheral = TESTPERIPHERAL_NONE;

    // Loopback Logic
    NativeAnalyzerThread mNativeAnalyzerThread = null;

    protected static final int NUM_TEST_PHASES = 5;
    protected int mTestPhase = 0;

    protected double[] mLatencyMillis = new double[NUM_TEST_PHASES];
    protected double[] mConfidence = new double[NUM_TEST_PHASES];

    protected double mMeanLatencyMillis;
    protected double mMeanAbsoluteDeviation;
    protected double mMeanConfidence;

    protected static final double CONFIDENCE_THRESHOLD = 0.6;
    // impossibly low latencies (indicating something in the test went wrong).
    protected static final float EPSILON = 1.0f;
    protected static final double PROAUDIO_RECOMMENDED_LATENCY_MS = 20.0;
    protected static final double PROAUDIO_RECOMMENDED_USB_LATENCY_MS = 25.0;
    protected static final double PROAUDIO_MUST_LATENCY_MS = 20.0;
    protected static final double BASIC_RECOMMENDED_LATENCY_MS = 50.0;
    protected static final double BASIC_MUST_LATENCY_MS = 800.0;
    protected double mMustLatency;
    protected double mRecommendedLatency;

    // The audio stream callback threads should stop and close
    // in less than a few hundred msec. This is a generous timeout value.
    private static final int STOP_TEST_TIMEOUT_MSEC = 2 * 1000;

    //
    // Common UI Handling
    //
    private void connectLoopbackUI() {
        // Connected Device
        mInputDeviceTxt = ((TextView)findViewById(R.id.audioLoopbackInputLbl));
        mOutputDeviceTxt = ((TextView)findViewById(R.id.audioLoopbackOutputLbl));

        mAudioLevelText = (TextView)findViewById(R.id.audio_loopback_level_text);
        mAudioLevelSeekbar = (SeekBar)findViewById(R.id.audio_loopback_level_seekbar);
        mMaxLevel = mAudioManager.getStreamMaxVolume(AudioManager.STREAM_MUSIC);
        mAudioLevelSeekbar.setMax(mMaxLevel);
        mAudioManager.setStreamVolume(AudioManager.STREAM_MUSIC, (int)(0.7 * mMaxLevel), 0);
        refreshLevel();

        mAudioLevelSeekbar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {
            @Override
            public void onStopTrackingTouch(SeekBar seekBar) {}

            @Override
            public void onStartTrackingTouch(SeekBar seekBar) {}

            @Override
            public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
                mAudioManager.setStreamVolume(AudioManager.STREAM_MUSIC,
                        progress, 0);
                Log.i(TAG,""Level set to: "" + progress);
                refreshLevel();
            }
        });

        mResultText = (TextView)findViewById(R.id.audio_loopback_results_text);
        mProgressBar = (ProgressBar)findViewById(R.id.audio_loopback_progress_bar);
        showWait(false);
    }

    //
    // Peripheral Connection Logic
    //
    protected void scanPeripheralList(AudioDeviceInfo[] devices) {
        // CDD Section C-1-3: USB port, host-mode support

        // Can't just use the first record because then we will only get
        // Source OR sink, not both even on devices that are both.
        mOutputDevInfo = null;
        mInputDevInfo = null;

        // Any valid peripherals
        // Do we leave in the Headset test to support a USB-Dongle?
        for (AudioDeviceInfo devInfo : devices) {
            if (devInfo.getType() == AudioDeviceInfo.TYPE_USB_DEVICE || // USB Peripheral
                    devInfo.getType() == AudioDeviceInfo.TYPE_USB_HEADSET || // USB dongle+LBPlug
                    devInfo.getType() == AudioDeviceInfo.TYPE_WIRED_HEADSET || // Loopback Plug?
                    devInfo.getType() == AudioDeviceInfo.TYPE_AUX_LINE) { // Aux-cable loopback?
                if (devInfo.isSink()) {
                    mOutputDevInfo = devInfo;
                }
                if (devInfo.isSource()) {
                    mInputDevInfo = devInfo;
                }
            }  else {
                handleDeviceConnection(devInfo);
            }
        }

        // need BOTH input and output to test
        mIsPeripheralAttached = mOutputDevInfo != null && mInputDevInfo != null;
        calculateTestPeripheral();
        showConnectedAudioPeripheral();
        calculateLatencyThresholds();
        displayLatencyThresholds();
    }

    protected void handleDeviceConnection(AudioDeviceInfo deviceInfo) {
        // NOP
    }

    private class ConnectListener extends AudioDeviceCallback {
        /*package*/ ConnectListener() {}

        //
        // AudioDevicesManager.OnDeviceConnectionListener
        //
        @Override
        public void onAudioDevicesAdded(AudioDeviceInfo[] addedDevices) {
            scanPeripheralList(mAudioManager.getDevices(AudioManager.GET_DEVICES_ALL));
        }

        @Override
        public void onAudioDevicesRemoved(AudioDeviceInfo[] removedDevices) {
            scanPeripheralList(mAudioManager.getDevices(AudioManager.GET_DEVICES_ALL));
        }
    }

    protected void calculateTestPeripheral() {
        if (!mIsPeripheralAttached) {
            mTestPeripheral = TESTPERIPHERAL_DEVICE;
        } else if (mInputDevInfo.getType() == AudioDeviceInfo.TYPE_USB_DEVICE ||
                mInputDevInfo.getType() == AudioDeviceInfo.TYPE_USB_HEADSET) {
            mTestPeripheral = TESTPERIPHERAL_USB;
        } else if (mInputDevInfo.getType() == AudioDeviceInfo.TYPE_WIRED_HEADSET ||
                mInputDevInfo.getType() == AudioDeviceInfo.TYPE_AUX_LINE) {
            mTestPeripheral = TESTPERIPHERAL_ANALOG_JACK;
        } else {
            // Huh?
            Log.e(TAG, ""No valid peripheral found!?"");
            mTestPeripheral = TESTPERIPHERAL_NONE;
        }
    }

    protected boolean isPeripheralValidForTest() {
        return mTestPeripheral == TESTPERIPHERAL_ANALOG_JACK
                || mTestPeripheral == TESTPERIPHERAL_USB;

    }
    protected void showConnectedAudioPeripheral() {
        mInputDeviceTxt.setText(
                mInputDevInfo != null ? mInputDevInfo.getProductName().toString()
                        : """");
        mOutputDeviceTxt.setText(
                mOutputDevInfo != null ? mOutputDevInfo.getProductName().toString()
                        : """");

        String pathName;
        switch (mTestPeripheral) {
            case TESTPERIPHERAL_ANALOG_JACK:
                pathName = ""Headset Jack"";
                break;

            case TESTPERIPHERAL_USB:
                pathName = ""USB"";
                break;

            case TESTPERIPHERAL_DEVICE:
                pathName = ""Device Speaker + Microphone"";
                break;

            case TESTPERIPHERAL_NONE:
            default:
                pathName = ""Error. Unknown Test Path"";
                break;
        }
        mTestPathTxt.setText(pathName);
    }

    private void calculateLatencyThresholds() {
        switch (mTestPeripheral) {
            case TESTPERIPHERAL_ANALOG_JACK:
                mRecommendedLatency = mClaimsProAudio
                        ? PROAUDIO_RECOMMENDED_LATENCY_MS : BASIC_RECOMMENDED_LATENCY_MS;
                mMustLatency =  mClaimsProAudio
                        ? PROAUDIO_RECOMMENDED_LATENCY_MS : BASIC_MUST_LATENCY_MS;
                break;

            case TESTPERIPHERAL_USB:
                mRecommendedLatency = mClaimsProAudio
                        ? PROAUDIO_RECOMMENDED_USB_LATENCY_MS : BASIC_RECOMMENDED_LATENCY_MS;
                mMustLatency = mClaimsProAudio
                        ? PROAUDIO_RECOMMENDED_USB_LATENCY_MS : BASIC_MUST_LATENCY_MS;
                break;

            case TESTPERIPHERAL_DEVICE:
                // This isn't a valid case so we won't pass it, but it can be run
                mRecommendedLatency = mClaimsProAudio
                        ? PROAUDIO_RECOMMENDED_LATENCY_MS : BASIC_RECOMMENDED_LATENCY_MS;
                mMustLatency = mClaimsProAudio
                        ? PROAUDIO_RECOMMENDED_LATENCY_MS :BASIC_MUST_LATENCY_MS;
                break;

            case TESTPERIPHERAL_NONE:
            default:
                mRecommendedLatency = BASIC_RECOMMENDED_LATENCY_MS;
                mMustLatency = BASIC_MUST_LATENCY_MS;
                break;
        }
    }

    private void displayLatencyThresholds() {
        if (isPeripheralValidForTest()) {
            ((TextView) findViewById(R.id.audio_loopback_must_latency)).setText("""" + mMustLatency);
            ((TextView) findViewById(R.id.audio_loopback_recommended_latency)).setText(
                    """" + mRecommendedLatency);
        } else {
            String naStr = getResources().getString(R.string.audio_proaudio_NA);
            ((TextView) findViewById(R.id.audio_loopback_must_latency)).setText(naStr);
            ((TextView) findViewById(R.id.audio_loopback_recommended_latency)).setText(naStr);
        }
    }

    /**
     * refresh Audio Level seekbar and text
     */
    private void refreshLevel() {
        int currentLevel = mAudioManager.getStreamVolume(AudioManager.STREAM_MUSIC);
        mAudioLevelSeekbar.setProgress(currentLevel);

        String levelText = String.format(""%s: %d/%d"",
                getResources().getString(R.string.audio_loopback_level_text),
                currentLevel, mMaxLevel);
        mAudioLevelText.setText(levelText);
    }

    //
    // show active progress bar
    //
    protected void showWait(boolean show) {
        mProgressBar.setVisibility(show ? View.VISIBLE : View.INVISIBLE);
    }

    //
    // Common loging
    //
    // Schema
    private static final String KEY_LATENCY = ""latency"";
    private static final String KEY_CONFIDENCE = ""confidence"";
    private static final String KEY_SAMPLE_RATE = ""sample_rate"";
    private static final String KEY_IS_PRO_AUDIO = ""is_pro_audio"";
    private static final String KEY_IS_LOW_LATENCY = ""is_low_latency"";
    private static final String KEY_IS_PERIPHERAL_ATTACHED = ""is_peripheral_attached"";
    private static final String KEY_INPUT_PERIPHERAL_NAME = ""input_peripheral"";
    private static final String KEY_OUTPUT_PERIPHERAL_NAME = ""output_peripheral"";
    private static final String KEY_TEST_PERIPHERAL = ""test_peripheral"";
    private static final String KEY_TEST_MMAP = ""supports_mmap"";
    private static final String KEY_TEST_MMAPEXCLUSIVE = ""supports_mmap_exclusive"";

    @Override
    public String getTestId() {
        return setTestNameSuffix(sCurrentDisplayMode, getClass().getName());
    }

    //
    // Subclasses should call this explicitly. SubClasses should call submit() after their logs
    //
    @Override
    public void recordTestResults() {
        if (mNativeAnalyzerThread == null) {
            return; // no results to report
        }

        CtsVerifierReportLog reportLog = getReportLog();
        reportLog.addValue(
                KEY_LATENCY,
                mMeanLatencyMillis,
                ResultType.LOWER_BETTER,
                ResultUnit.MS);

        reportLog.addValue(
                KEY_CONFIDENCE,
                mMeanConfidence,
                ResultType.HIGHER_BETTER,
                ResultUnit.NONE);

        reportLog.addValue(
                KEY_SAMPLE_RATE,
                mNativeAnalyzerThread.getSampleRate(),
                ResultType.NEUTRAL,
                ResultUnit.NONE);

        reportLog.addValue(
                KEY_IS_LOW_LATENCY,
                mNativeAnalyzerThread.isLowLatencyStream(),
                ResultType.NEUTRAL,
                ResultUnit.NONE);

        reportLog.addValue(
                KEY_IS_PERIPHERAL_ATTACHED,
                mIsPeripheralAttached,
                ResultType.NEUTRAL,
                ResultUnit.NONE);

        reportLog.addValue(
                KEY_IS_PRO_AUDIO,
                mClaimsProAudio,
                ResultType.NEUTRAL,
                ResultUnit.NONE);

        reportLog.addValue(
                KEY_TEST_PERIPHERAL,
                mTestPeripheral,
                ResultType.NEUTRAL,
                ResultUnit.NONE);

        reportLog.addValue(
                KEY_TEST_MMAP,
                mSupportsMMAP,
                ResultType.NEUTRAL,
                ResultUnit.NONE);

        reportLog.addValue(
                KEY_TEST_MMAPEXCLUSIVE ,
                mSupportsMMAPExclusive,
                ResultType.NEUTRAL,
                ResultUnit.NONE);

        if (mIsPeripheralAttached) {
            reportLog.addValue(
                    KEY_INPUT_PERIPHERAL_NAME,
                    mInputDevInfo != null ? mInputDevInfo.getProductName().toString() : ""None"",
                    ResultType.NEUTRAL,
                    ResultUnit.NONE);

            reportLog.addValue(
                    KEY_OUTPUT_PERIPHERAL_NAME,
                    mOutputDevInfo != null ? mOutputDevInfo.getProductName().toString() : ""None"",
                    ResultType.NEUTRAL,
                    ResultUnit.NONE);
        }
    }

    private static final String KEY_LOOPBACK_AVAILABLE = ""loopback_available"";
    private void recordLoopbackStatus(boolean has) {
        getReportLog().addValue(
                KEY_LOOPBACK_AVAILABLE,
                has,
                ResultType.NEUTRAL,
                ResultUnit.NONE);
    }

    protected void startAudioTest(Handler messageHandler) {
        getPassButton().setEnabled(false);

        mTestPhase = 0;
        java.util.Arrays.fill(mLatencyMillis, 0.0);
        java.util.Arrays.fill(mConfidence, 0.0);

        mNativeAnalyzerThread = new NativeAnalyzerThread(this);
        if (mNativeAnalyzerThread != null) {
            mNativeAnalyzerThread.setMessageHandler(messageHandler);
            // This value matches AAUDIO_INPUT_PRESET_VOICE_RECOGNITION
            mNativeAnalyzerThread.setInputPreset(MediaRecorder.AudioSource.VOICE_RECOGNITION);
            startTestPhase();
        } else {
            Log.e(TAG, ""Couldn't allocate native analyzer thread"");
            mResultText.setText(getResources().getString(R.string.audio_loopback_failure));
        }
    }

    private void startTestPhase() {
        if (mNativeAnalyzerThread != null) {
            mNativeAnalyzerThread.startTest();

            // what is this for?
            try {
                Thread.sleep(200);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    protected void handleTestCompletion() {
        mMeanLatencyMillis = StatUtils.calculateMean(mLatencyMillis);
        mMeanAbsoluteDeviation =
                StatUtils.calculateMeanAbsoluteDeviation(mMeanLatencyMillis, mLatencyMillis);
        mMeanConfidence = StatUtils.calculateMean(mConfidence);


        String result;
        if (mMeanConfidence < CONFIDENCE_THRESHOLD) {
            result = String.format(
                    ""Test Finished\nInsufficient Confidence (%.2f < %.2f). No Results."",
                    mMeanConfidence, CONFIDENCE_THRESHOLD);
        } else {
            result = String.format(
                    ""Test Finished\nMean Latency:%.2f ms (required:%.2f)\n"" +
                            ""Mean Absolute Deviation: %.2f\n"" +
                            "" Confidence: %.2f\n"" +
                            "" Low Latency Path: %s"",
                    mMeanLatencyMillis,
                    mMustLatency,
                    mMeanAbsoluteDeviation,
                    mMeanConfidence,
                    mNativeAnalyzerThread.isLowLatencyStream() ? mYesString : mNoString);
        }

        // Make sure the test thread is finished. It should already be done.
        if (mNativeAnalyzerThread != null) {
            try {
                mNativeAnalyzerThread.stopTest(STOP_TEST_TIMEOUT_MSEC);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        mResultText.setText(result);
    }

    protected void handleTestPhaseCompletion() {
        if (mNativeAnalyzerThread != null && mTestPhase < NUM_TEST_PHASES) {
            mLatencyMillis[mTestPhase] = mNativeAnalyzerThread.getLatencyMillis();
            mConfidence[mTestPhase] = mNativeAnalyzerThread.getConfidence();

            String result = String.format(
                    ""Test %d Finished\nLatency: %.2f ms\nConfidence: %.2f\n"",
                    mTestPhase,
                    mLatencyMillis[mTestPhase],
                    mConfidence[mTestPhase]);

            mResultText.setText(result);
            try {
                mNativeAnalyzerThread.stopTest(STOP_TEST_TIMEOUT_MSEC);
                // Thread.sleep(/*STOP_TEST_TIMEOUT_MSEC*/500);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            mTestPhase++;
            if (mTestPhase >= NUM_TEST_PHASES) {
                handleTestCompletion();
            } else {
                startTestPhase();
            }
        }
    }

    /**
     * handler for messages from audio thread
     */
    protected Handler mMessageHandler = new Handler() {
        public void handleMessage(Message msg) {
            super.handleMessage(msg);
            switch(msg.what) {
                case NativeAnalyzerThread.NATIVE_AUDIO_THREAD_MESSAGE_REC_STARTED:
                    Log.v(TAG,""got message native rec started!!"");
                    showWait(true);
                    mResultText.setText(String.format(""[phase: %d] - Test Running..."",
                            (mTestPhase + 1)));
                    break;
                case NativeAnalyzerThread.NATIVE_AUDIO_THREAD_MESSAGE_OPEN_ERROR:
                    Log.v(TAG,""got message native rec can't start!!"");
                    mResultText.setText(""Test Error opening streams."");
                    handleTestCompletion();
                    break;
                case NativeAnalyzerThread.NATIVE_AUDIO_THREAD_MESSAGE_REC_ERROR:
                    Log.v(TAG,""got message native rec can't start!!"");
                    mResultText.setText(""Test Error while recording."");
                    handleTestCompletion();
                    break;
                case NativeAnalyzerThread.NATIVE_AUDIO_THREAD_MESSAGE_REC_COMPLETE_ERRORS:
                    mResultText.setText(""Test FAILED due to errors."");
                    handleTestCompletion();
                    break;
                case NativeAnalyzerThread.NATIVE_AUDIO_THREAD_MESSAGE_ANALYZING:
                    Log.i(TAG, ""NATIVE_AUDIO_THREAD_MESSAGE_ANALYZING"");
                    mResultText.setText(String.format(""[phase: %d] - Analyzing ..."",
                            mTestPhase + 1));
                    break;
                case NativeAnalyzerThread.NATIVE_AUDIO_THREAD_MESSAGE_REC_COMPLETE:
                    Log.i(TAG, ""NATIVE_AUDIO_THREAD_MESSAGE_REC_COMPLETE"");
                    handleTestPhaseCompletion();
                    break;
                default:
                    break;
            }
        }
    };

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        mClaimsOutput = AudioSystemFlags.claimsOutput(this);
        mClaimsInput = AudioSystemFlags.claimsInput(this);
        mClaimsProAudio = AudioSystemFlags.claimsProAudio(this);

        mYesString = getResources().getString(R.string.audio_general_yes);
        mNoString = getResources().getString(R.string.audio_general_no);

        // Pro Audio
        ((TextView)findViewById(R.id.audio_loopback_pro_audio)).setText(
                """" + (mClaimsProAudio ? mYesString : mNoString));

        // MMAP
        ((TextView)findViewById(R.id.audio_loopback_mmap)).setText(
                """" + (mSupportsMMAP ? mYesString : mNoString));
        ((TextView)findViewById(R.id.audio_loopback_mmap_exclusive)).setText(
                """" + (mSupportsMMAPExclusive ? mYesString : mNoString));

        // Low Latency
        ((TextView)findViewById(R.id.audio_loopback_low_latency)).setText(
                """" + (AudioSystemFlags.claimsLowLatencyAudio(this) ? mYesString : mNoString));

        mTestPathTxt = ((TextView)findViewById(R.id.audio_loopback_testpath));

        mAudioManager = (AudioManager)getSystemService(AUDIO_SERVICE);

        mAudioManager.registerAudioDeviceCallback(new ConnectListener(), new Handler());

        connectLoopbackUI();

        calculateLatencyThresholds();
        displayLatencyThresholds();
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.permission.cts.FileSystemPermissionTest"	"testProcNetSane"	"CtsPermissionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/FileSystemPermissionTest.java"	""	"public void testProcNetSane() throws Exception {
        if (PropertyUtil.isVendorApiLevelNewerThan(28)) {
            for (String file : procNetFiles) {
                procNetSane(""/proc/net/"" + file);
            }
        }
    }

    private static int readInt(File f) throws FileNotFoundException {
        try (Scanner s = new Scanner(f)) {
            return s.nextInt();
        }
    }

    private static boolean writeInt(File f, int value) throws IOException {
        try (FileOutputStream os = new FileOutputStream(f)) {
            try {
                os.write(Integer.toString(value).getBytes());
                return true;
            } catch (IOException e) {
                return false;
            }
        }
    }

    @MediumTest"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.apicoverage.CtsApiCoverage"	"isDirectory"	""	"/home/gpoor/cts-12-source/cts/tools/cts-api-coverage/src/com/android/cts/apicoverage/CtsApiCoverage.java"	""	"public void test/*
 *.
 */

package com.android.cts.apicoverage;

import com.android.compatibility.common.util.CddTest;
import com.android.compatibility.common.util.ReadElf;

import org.jf.dexlib2.DexFileFactory;
import org.jf.dexlib2.Opcodes;
import org.jf.dexlib2.iface.Annotation;
import org.jf.dexlib2.iface.AnnotationElement;
import org.jf.dexlib2.iface.ClassDef;
import org.jf.dexlib2.iface.DexFile;
import org.jf.dexlib2.iface.Method;
import org.jf.dexlib2.iface.value.StringEncodedValue;

import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.XMLReader;
import org.xml.sax.helpers.XMLReaderFactory;

import java.io.File;
import java.io.FilenameFilter;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.OutputStream;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Locale;
import java.util.Set;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

import javax.xml.transform.TransformerException;

/**
 * Tool that generates a report of what Android framework methods are being called from a given
 * set of APKS. See the {@link #printUsage()} method for more details.
 */
public class CtsApiCoverage {

    private static final FilenameFilter SUPPORTED_FILE_NAME_FILTER = new FilenameFilter() {
        public boolean accept(File dir, String name) {
            String fileName = name.toLowerCase();
            return fileName.endsWith("".apk"") || fileName.endsWith("".jar"");
        }
    };

    private static final int FORMAT_TXT = 0;

    private static final int FORMAT_XML = 1;

    private static final int FORMAT_HTML = 2;

    private static final String CDD_REQUIREMENT_ANNOTATION = ""Lcom/android/compatibility/common/util/CddTest;"";

    private static final String CDD_REQUIREMENT_ELEMENT_NAME = ""requirement"";

    private static final String NDK_PACKAGE_NAME = ""ndk"";

    private static void printUsage() {
        System.out.println(""Usage: cts-api-coverage [OPTION]... [APK]..."");
        System.out.println();
        System.out.println(""Generates a report about what Android framework methods are called "");
        System.out.println(""from the given APKs."");
        System.out.println();
        System.out.println(""Use the Makefiles rules in CtsCoverage.mk to generate the report "");
        System.out.println(""rather than executing this directly. If you still want to run this "");
        System.out.println(""directly, then this must be used from the $ANDROID_BUILD_TOP "");
        System.out.println(""directory and dexdeps must be built via \""make dexdeps\""."");
        System.out.println();
        System.out.println(""Options:"");
        System.out.println(""  -o FILE                output file or standard out if not given"");
        System.out.println(""  -f [txt|xml|html]      format of output"");
        System.out.println(""  -d PATH                path to dexdeps or expected to be in $PATH"");
        System.out.println(""  -a PATH                path to the API XML file"");
        System.out.println(
                ""  -n PATH                path to the NDK API XML file, which can be updated via ndk-api-report with the ndk target"");
        System.out.println(""  -p PACKAGENAMEPREFIX   report coverage only for package that start with"");
        System.out.println(""  -t TITLE               report title"");
        System.out.println(""  -a API                 the Android API Level"");
        System.out.println(""  -b BITS                64 or 32 bits, default 64"");
        System.out.println();
        System.exit(1);
    }

    public static void main(String[] args) throws Exception {
        List<File> testApks = new ArrayList<File>();
        File outputFile = null;
        int format = FORMAT_TXT;
        String dexDeps = ""dexDeps"";
        String apiXmlPath = """";
        String napiXmlPath = """";
        PackageFilter packageFilter = new PackageFilter();
        String reportTitle = ""CTS API Coverage"";
        int apiLevel = Integer.MAX_VALUE;
        String testCasesFolder = """";
        String bits = ""64"";

        List<File> notFoundTestApks = new ArrayList<File>();
        int numTestApkArgs = 0;
        for (int i = 0; i < args.length; i++) {
            if (args[i].startsWith(""-"")) {
                if (""-o"".equals(args[i])) {
                    outputFile = new File(getExpectedArg(args, ++i));
                } else if (""-f"".equals(args[i])) {
                    String formatSpec = getExpectedArg(args, ++i);
                    if (""xml"".equalsIgnoreCase(formatSpec)) {
                        format = FORMAT_XML;
                    } else if (""txt"".equalsIgnoreCase(formatSpec)) {
                        format = FORMAT_TXT;
                    } else if (""html"".equalsIgnoreCase(formatSpec)) {
                        format = FORMAT_HTML;
                    } else {
                        printUsage();
                    }
                } else if (""-d"".equals(args[i])) {
                    dexDeps = getExpectedArg(args, ++i);
                } else if (""-a"".equals(args[i])) {
                    apiXmlPath = getExpectedArg(args, ++i);
                } else if (""-n"".equals(args[i])) {
                    napiXmlPath = getExpectedArg(args, ++i);
                } else if (""-p"".equals(args[i])) {
                    packageFilter.addPrefixToFilter(getExpectedArg(args, ++i));
                } else if (""-t"".equals(args[i])) {
                    reportTitle = getExpectedArg(args, ++i);
                } else if (""-a"".equals(args[i])) {
                    apiLevel = Integer.parseInt(getExpectedArg(args, ++i));
                } else if (""-b"".equals(args[i])) {
                    bits = getExpectedArg(args, ++i);
                } else {
                    printUsage();
                }
            } else {
                File file = new File(args[i]);
                numTestApkArgs++;
                if (file.isDirectory()) {
                    testApks.addAll(Arrays.asList(file.listFiles(SUPPORTED_FILE_NAME_FILTER)));
                    testCasesFolder = args[i];
                } else if (file.isFile()) {
                    testApks.add(file);
                } else {
                    notFoundTestApks.add(file);
                }
            }
        }

        if (!notFoundTestApks.isEmpty()) {
            String msg = String.format(Locale.US, ""%d/%d testApks not found: %s"",
                    notFoundTestApks.size(), numTestApkArgs, notFoundTestApks);
            throw new IllegalArgumentException(msg);
        }

        /*
         * 1. Create an ApiCoverage object that is a tree of Java objects representing the API
         *    in current.xml. The object will have no information about the coverage for each
         *    constructor or method yet.
         *
         * 2. For each provided APK, scan it using dexdeps, parse the output of dexdeps, and
         *    call methods on the ApiCoverage object to cumulatively add coverage stats.
         *
         * 3. Output a report based on the coverage stats in the ApiCoverage object.
         */

        ApiCoverage apiCoverage = getEmptyApiCoverage(apiXmlPath);
        CddCoverage cddCoverage = getEmptyCddCoverage();

        if (!napiXmlPath.equals("""")) {
            System.out.println(""napiXmlPath: "" + napiXmlPath);
            ApiCoverage napiCoverage = getEmptyApiCoverage(napiXmlPath);
            ApiPackage napiPackage = napiCoverage.getPackage(NDK_PACKAGE_NAME);
            System.out.println(
                    String.format(
                            ""%s, NDK Methods = %d, MemberSize = %d"",
                            napiXmlPath,
                            napiPackage.getTotalMethods(),
                            napiPackage.getMemberSize()));
            apiCoverage.addPackage(napiPackage);
        }

        // Add superclass information into api coverage.
        apiCoverage.resolveSuperClasses();

        ExecutorService service =
            Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
        List<Future> tasks = new ArrayList<>();
        for (File testApk : testApks) {
            tasks.add(addApiCoverage(service, apiCoverage, testApk, dexDeps));
            tasks.add(addCddCoverage(service, cddCoverage, testApk, apiLevel));
        }
        // Wait until all tasks finish.
        for (Future task : tasks) {
            task.get();
        }
        service.shutdown();

        // The below two coverage methods assume all classes and methods have been already
        // registered, which is why we don't run them parallelly with others.

        try {
            // Add coverage for GTest modules
            addGTestNdkApiCoverage(apiCoverage, testCasesFolder, bits);
        } catch (Exception e) {
            System.out.println(""warning: addGTestNdkApiCoverage failed to add to apiCoverage:"");
            e.printStackTrace();
        }

        try {
            // Add coverage for APK with Share Objects
            addNdkApiCoverage(apiCoverage, testCasesFolder, bits);
        } catch (Exception e) {
            System.out.println(""warning: addNdkApiCoverage failed to add to apiCoverage:"");
            e.printStackTrace();
        }

        outputCoverageReport(apiCoverage, cddCoverage, testApks, outputFile,
            format, packageFilter, reportTitle);
    }

    /** Get the argument or print out the usage and exit. */
    private static String getExpectedArg(String[] args, int index) {
        if (index < args.length) {
            return args[index];
        } else {
            printUsage();
            return null;    // Never will happen because printUsage will call exit(1)
        }
    }

    /**
     * Creates an object representing the API that will be used later to collect coverage
     * statistics as we iterate over the test APKs.
     *
     * @param apiXmlPath to the API XML file
     * @return an {@link ApiCoverage} object representing the API in current.xml without any
     *     coverage statistics yet
     */
    private static ApiCoverage getEmptyApiCoverage(String apiXmlPath)
            throws SAXException, IOException {
        XMLReader xmlReader = XMLReaderFactory.createXMLReader();
        CurrentXmlHandler currentXmlHandler = new CurrentXmlHandler();
        xmlReader.setContentHandler(currentXmlHandler);

        File currentXml = new File(apiXmlPath);
        FileReader fileReader = null;
        try {
            fileReader = new FileReader(currentXml);
            xmlReader.parse(new InputSource(fileReader));
        } finally {
            if (fileReader != null) {
                fileReader.close();
            }
        }

        return currentXmlHandler.getApi();
    }

    /**
     * Adds coverage information gleamed from running dexdeps on the APK to the
     * {@link ApiCoverage} object.
     *
     * @param apiCoverage object to which the coverage statistics will be added to
     * @param testApk containing the tests that will be scanned by dexdeps
     */
    private static Future addApiCoverage(
        ExecutorService service, ApiCoverage apiCoverage, File testApk, String dexdeps) {
        return service.submit(() -> {
            String apkPath = testApk.getPath();
            try {
                XMLReader xmlReader = XMLReaderFactory.createXMLReader();
                String testApkName = testApk.getName();
                DexDepsXmlHandler dexDepsXmlHandler = new DexDepsXmlHandler(apiCoverage, testApkName);
                xmlReader.setContentHandler(dexDepsXmlHandler);

                Process process = new ProcessBuilder(dexdeps, ""--format=xml"", apkPath).start();
                xmlReader.parse(new InputSource(process.getInputStream()));
            } catch (SAXException e) {
                // Catch this exception, but continue. SAXException is acceptable in cases
                // where the apk does not contain a classes.dex and therefore parsing won't work.
                System.err.println(""warning: dexdeps failed for: "" + apkPath);
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        });
    }

    /**
     * Adds coverage information from native code symbol array to the {@link ApiCoverage} object.
     *
     * @param apiPackage object to which the coverage statistics will be added to
     * @param symArr containing native code symbols
     * @param testModules containing a list of TestModule
     * @param moduleName test module name
     */
    private static void addNdkSymArrToApiCoverage(
            ApiCoverage apiCoverage, List<TestModule> testModules)
            throws SAXException, IOException {

        final List<String> parameterTypes = new ArrayList<String>();
        final ApiPackage apiPackage = apiCoverage.getPackage(NDK_PACKAGE_NAME);

        if (apiPackage != null) {
            for (TestModule tm : testModules) {
                final String moduleName = tm.getModuleName();
                final ReadElf.Symbol[] symArr = tm.getDynSymArr();
                if (symArr != null) {
                    for (ReadElf.Symbol sym : symArr) {
                        if (sym.isGlobalUnd()) {
                            String className = sym.getExternalLibFileName();
                            ApiClass apiClass = apiPackage.getClass(className);
                            if (apiClass != null) {
                                apiClass.markMethodCovered(
                                        sym.name,
                                        parameterTypes,
                                        moduleName);
                            } else {
                                System.err.println(
                                        String.format(
                                                ""warning: addNdkApiCoverage failed to getClass: %s"",
                                                className));
                            }
                        }
                    }
                } else {
                    System.err.println(
                            String.format(
                                    ""warning: addNdkSymbolArrToApiCoverage failed to getSymArr: %s"",
                                    moduleName));
                }
            }
        } else {
            System.err.println(
                    String.format(
                            ""warning: addNdkApiCoverage failed to getPackage: %s"",
                            NDK_PACKAGE_NAME));
        }
    }

    /**
     * Adds coverage information gleamed from readelf on so in the APK to the {@link ApiCoverage}
     * object.
     *
     * @param apiCoverage object to which the coverage statistics will be added to
     * @param testCasesFolder containing GTest modules
     * @param bits 64 or 32 bits of executiable
     */
    private static void addNdkApiCoverage(
            ApiCoverage apiCoverage, String testCasesFolder, String bits)
            throws SAXException, IOException {
        ApkNdkApiReport apiReport = ApkNdkApiReport.parseTestcasesFolder(testCasesFolder, bits);
        if (apiReport != null) {
            addNdkSymArrToApiCoverage(apiCoverage, apiReport.getTestModules());
        } else {
            System.err.println(
                    String.format(
                            ""warning: addNdkApiCoverage failed to get GTestApiReport from: %s @ %s bits"",
                            testCasesFolder, bits));
        }
    }

    /**
     * Adds GTest coverage information gleamed from running ReadElf on the executiable to the {@link
     * ApiCoverage} object.
     *
     * @param apiCoverage object to which the coverage statistics will be added to
     * @param testCasesFolder containing GTest modules
     * @param bits 64 or 32 bits of executiable
     */
    private static void addGTestNdkApiCoverage(
            ApiCoverage apiCoverage, String testCasesFolder, String bits)
            throws SAXException, IOException {
        GTestApiReport apiReport = GTestApiReport.parseTestcasesFolder(testCasesFolder, bits);
        if (apiReport != null) {
            addNdkSymArrToApiCoverage(apiCoverage, apiReport.getTestModules());
        } else {
            System.err.println(
                    String.format(
                            ""warning: addGTestNdkApiCoverage failed to get GTestApiReport from: %s @ %s bits"",
                            testCasesFolder, bits));
        }
    }

    private static Future addCddCoverage(
        ExecutorService service, CddCoverage cddCoverage, File testSource, int api) {
        return service.submit(() -> {
            try {
                if (testSource.getName().endsWith("".apk"")) {
                    addCddApkCoverage(cddCoverage, testSource, api);
                } else if (testSource.getName().endsWith("".jar"")) {
                    addCddJarCoverage(cddCoverage, testSource);
                } else {
                    System.err
                        .println(""Unsupported file type for CDD coverage: "" + testSource.getPath());
                }
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        });
    }

    private static void addCddJarCoverage(CddCoverage cddCoverage, File testSource)
            throws IOException {

        Collection<Class<?>> classes = JarTestFinder.getClasses(testSource);
        for (Class<?> c : classes) {
            for (java.lang.reflect.Method m : c.getMethods()) {
                if (m.isAnnotationPresent(CddTest.class)) {
                    CddTest cddTest = m.getAnnotation(CddTest.class);
                    CddCoverage.TestMethod testMethod =
                            new CddCoverage.TestMethod(
                                    testSource.getName(), c.getName(), m.getName());
                    cddCoverage.addCoverage(cddTest.requirement(), testMethod);
                }
            }
        }
    }

    private static void addCddApkCoverage(
        CddCoverage cddCoverage, File testSource, int api)
            throws IOException {

        DexFile dexFile = null;
        try {
            dexFile = DexFileFactory.loadDexFile(testSource, Opcodes.forApi(api));
        } catch (IOException | DexFileFactory.DexFileNotFoundException e) {
            System.err.println(""Unable to load dex file: "" + testSource.getPath());
            return;
        }

        String moduleName = testSource.getName();
        for (ClassDef classDef : dexFile.getClasses()) {
            String className = classDef.getType();
            handleAnnotations(
                cddCoverage, moduleName, className, null /*methodName*/,
                classDef.getAnnotations());

            for (Method method : classDef.getMethods()) {
                String methodName = method.getName();
                handleAnnotations(
                    cddCoverage, moduleName, className, methodName, method.getAnnotations());
            }
        }
    }

    private static void handleAnnotations(
            CddCoverage cddCoverage, String moduleName, String className,
                    String methodName, Set<? extends Annotation> annotations) {
        for (Annotation annotation : annotations) {
            if (annotation.getType().equals(CDD_REQUIREMENT_ANNOTATION)) {
                for (AnnotationElement annotationElement : annotation.getElements()) {
                    if (annotationElement.getName().equals(CDD_REQUIREMENT_ELEMENT_NAME)) {
                        String cddRequirement =
                                ((StringEncodedValue) annotationElement.getValue()).getValue();
                        CddCoverage.TestMethod testMethod =
                                new CddCoverage.TestMethod(
                                        moduleName, dexToJavaName(className), methodName);
                        cddCoverage.addCoverage(cddRequirement, testMethod);
                    }
                }
            }
        }
    }

    /**
     * Given a string like Landroid/app/cts/DownloadManagerTest;
     * return android.app.cts.DownloadManagerTest.
     */
    private static String dexToJavaName(String dexName) {
        if (!dexName.startsWith(""L"") || !dexName.endsWith("";"")) {
            return dexName;
        }
        dexName = dexName.replace('/', '.');
        if (dexName.length() > 2) {
            dexName = dexName.substring(1, dexName.length() - 1);
        }
        return dexName;
    }

    private static CddCoverage getEmptyCddCoverage() {
        CddCoverage cddCoverage = new CddCoverage();
        // TODO(nicksauer): Read in the valid list of requirements
        return cddCoverage;
    }

    private static void outputCoverageReport(ApiCoverage apiCoverage, CddCoverage cddCoverage,
            List<File> testApks, File outputFile, int format, PackageFilter packageFilter,
            String reportTitle)
                throws IOException, TransformerException, InterruptedException {

        OutputStream out = outputFile != null
                ? new FileOutputStream(outputFile)
                : System.out;

        try {
            switch (format) {
                case FORMAT_TXT:
                    TextReport.printTextReport(apiCoverage, cddCoverage, packageFilter, out);
                    break;

                case FORMAT_XML:
                    XmlReport.printXmlReport(testApks, apiCoverage, cddCoverage,
                        packageFilter, reportTitle, out);
                    break;

                case FORMAT_HTML:
                    HtmlReport.printHtmlReport(testApks, apiCoverage, cddCoverage,
                        packageFilter, reportTitle, out);
                    break;
            }
        } finally {
            out.close();
        }
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.content.cts.MockSyncAdapter"	"isInitialized"	"CtsContentTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/MockSyncAdapter.java"	""	"public void test/*
 *.
 */

package android.content.cts;

import android.accounts.Account;
import android.content.ContentResolver;
import android.content.ISyncAdapter;
import android.content.ISyncAdapterUnsyncableAccountCallback;
import android.content.ISyncContext;
import android.os.Bundle;
import android.os.RemoteException;

import java.util.ArrayList;
import java.util.concurrent.CountDownLatch;

public class MockSyncAdapter extends ISyncAdapter.Stub {

    private static MockSyncAdapter sSyncAdapter = null;

    private volatile ArrayList<Account> mAccounts = new ArrayList<Account>();
    private volatile String mAuthority;
    private volatile Bundle mExtras;
    private volatile boolean mInitialized;
    private volatile boolean mStartSync;
    private volatile boolean mCancelSync;
    private volatile CountDownLatch mLatch;

    public ArrayList<Account> getAccounts() {
        return mAccounts;
    }

    public String getAuthority() {
        return mAuthority;
    }

    public Bundle getExtras() {
        return mExtras;
    }

    public boolean isInitialized() {
        return mInitialized;
    }

    public boolean isStartSync() {
        return mStartSync;
    }

    public boolean isCancelSync() {
        return mCancelSync;
    }

    public void clearData() {
        mAccounts.clear();
        mAuthority = null;
        mExtras = null;
        mInitialized = false;
        mStartSync = false;
        mCancelSync = false;
        mLatch = null;
    }

    public void setLatch(CountDownLatch mLatch) {
        this.mLatch = mLatch;
    }

    @Override
    public void onUnsyncableAccount(ISyncAdapterUnsyncableAccountCallback cb)
            throws RemoteException {
        cb.onUnsyncableAccountDone(true);
    }

    public void startSync(ISyncContext syncContext, String authority, Account account,
            Bundle extras) throws RemoteException {

        mAccounts.add(account);
        mAuthority = authority;
        mExtras = extras;

        if (null != extras && extras.getBoolean(ContentResolver.SYNC_EXTRAS_INITIALIZE)) {
            mInitialized = true;
            mStartSync = false;
            mCancelSync = false;
        } else {
            mInitialized = false;
            mStartSync = true;
            mCancelSync = false;
        }

        countDownLatch();
    }

    public void cancelSync(ISyncContext syncContext) throws RemoteException {
        mAccounts.clear();
        mAuthority = null;
        mExtras = null;

        mInitialized = false;
        mStartSync = false;
        mCancelSync = true;

        countDownLatch();
    }

    public void initialize(android.accounts.Account account, java.lang.String authority)
            throws android.os.RemoteException {

        mAccounts.add(account);
        mAuthority = authority;

        mInitialized = true;
        mStartSync = false;
        mCancelSync = false;

        countDownLatch();
    }

    private void countDownLatch() {
        final CountDownLatch latch = mLatch;
        if (latch != null) {
            latch.countDown();
        }
    }

    public static MockSyncAdapter getMockSyncAdapter() {
        if (null == sSyncAdapter) {
            sSyncAdapter = new MockSyncAdapter();
        }
        return sSyncAdapter;
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.mediastorageapp.MediaStorageTest"	"testLegacy"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/MediaStorageApp/src/com/android/cts/mediastorageapp/MediaStorageTest.java"	""	"public void testLegacy() throws Exception {
        assertTrue(Environment.isExternalStorageLegacy());

        // We can always see mounted state
        assertEquals(Environment.MEDIA_MOUNTED, Environment.getExternalStorageState());

        // We might have top-level access
        final File probe = new File(Environment.getExternalStorageDirectory(),
                ""cts"" + System.nanoTime());
        assertTrue(probe.createNewFile());
        assertNotNull(Environment.getExternalStorageDirectory().list());

        // We always have our package directories
        final File probePackage = new File(mContext.getExternalFilesDir(null),
                ""cts"" + System.nanoTime());
        assertTrue(probePackage.createNewFile());

        assertTrue(TEST_JPG.exists());
        assertTrue(TEST_PDF.exists());

        final Uri jpgUri = MediaStore.scanFile(mContentResolver, TEST_JPG);
        final Uri pdfUri = MediaStore.scanFile(mContentResolver, TEST_PDF);

        final HashSet<Long> seen = new HashSet<>();
        try (Cursor c = mContentResolver.query(
                MediaStore.Files.getContentUri(MediaStore.VOLUME_EXTERNAL),
                new String[] { MediaColumns._ID }, null, null)) {
            while (c.moveToNext()) {
                seen.add(c.getLong(0));
            }
        }

        assertTrue(seen.contains(ContentUris.parseId(jpgUri)));
        assertTrue(seen.contains(ContentUris.parseId(pdfUri)));
    }"	""	""	"probe scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.mediastorageapp.MediaStorageTest"	"testClearFiles"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/MediaStorageApp/src/com/android/cts/mediastorageapp/MediaStorageTest.java"	""	"public void testClearFiles() throws Exception {
        TEST_JPG.delete();
        assertNull(MediaStore.scanFile(mContentResolver, TEST_JPG));
        TEST_PDF.delete();
        assertNull(MediaStore.scanFile(mContentResolver, TEST_PDF));
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.mediastorageapp.MediaStorageTest"	"testMediaEscalation_RequestWriteFilePathSupport"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/MediaStorageApp/src/com/android/cts/mediastorageapp/MediaStorageTest.java"	""	"public void testMediaEscalation_RequestWriteFilePathSupport() throws Exception {
        doMediaEscalation_RequestWrite_withFilePathSupport(MediaStorageTest::createAudio);
        doMediaEscalation_RequestWrite_withFilePathSupport(MediaStorageTest::createVideo);
        doMediaEscalation_RequestWrite_withFilePathSupport(MediaStorageTest::createImage);
        doMediaEscalation_RequestWrite_withFilePathSupport(MediaStorageTest::createPlaylist);
        doMediaEscalation_RequestWrite_withFilePathSupport(MediaStorageTest::createSubtitle);
    }

    private void doMediaEscalation_RequestWrite_withFilePathSupport(
            Callable<Uri> create) throws Exception {
        final Uri red = create.call();
        assertNotNull(red);
        String path = queryForSingleColumn(red, MediaColumns.DATA);
        File file = new File(path);
        assertThat(file.exists()).isTrue();
        assertThat(file.canRead()).isTrue();
        assertThat(file.canWrite()).isTrue();

        clearMediaOwner(red, mUserId);
        assertThat(file.canWrite()).isFalse();

        try (ParcelFileDescriptor pfd = mContentResolver.openFileDescriptor(red, ""w"")) {
            fail(""Expected write access to be blocked"");
        } catch (SecurityException expected) {
        }

        doEscalation(MediaStore.createWriteRequest(mContentResolver, Arrays.asList(red)));

        try (ParcelFileDescriptor pfd = mContentResolver.openFileDescriptor(red, ""w"")) {
        }
        // Wait for MediaStore to be idle to avoid flakiness due to race conditions between
        // MediaStore.scanFile (which is called above in #openFileDescriptor) and rename (which is
        // called below). This is a known issue: b/158982091
        MediaStore.waitForIdle(mContentResolver);

        // Check File API support
        assertAccessFileAPISupport(file);
        assertReadWriteFileAPISupport(file);
        assertRenameFileAPISupport(file);
        assertDeleteFileAPISupport(file);
    }

    private void assertAccessFileAPISupport(File file) throws Exception {
        assertThat(file.canRead()).isTrue();
        assertThat(file.canWrite()).isTrue();
    }

    private void assertReadWriteFileAPISupport(File file) throws Exception {
        final String str = ""Just some random text"";
        final byte[] bytes = str.getBytes();
        // Write to file
        try (FileOutputStream fos = new FileOutputStream(file)) {
            fos.write(bytes);
        }
        // Read the same data from file
        try (FileInputStream fis = new FileInputStream(file)) {
            assertThat(ByteStreams.toByteArray(fis)).isEqualTo(bytes);
        }
    }

    public void assertRenameFileAPISupport(File oldFile) throws Exception {
        final String oldName = oldFile.getAbsolutePath();
        final String extension = oldName.substring(oldName.lastIndexOf('.')).trim();
        // TODO(b/178816495): Changing the extension changes the media-type and hence the media-URI
        // corresponding to the new file is not accessible to the caller. Rename to the same
        // extension so that the test app does not lose access and is able to delete the file.
        final String newName = ""cts"" + System.nanoTime() + extension;
        final File newFile = Environment.buildPath(Environment.getExternalStorageDirectory(),
                Environment.DIRECTORY_DOWNLOADS, newName);
        assertThat(oldFile.renameTo(newFile)).isTrue();
        // Rename back to oldFile for other ops like delete
        assertThat(newFile.renameTo(oldFile)).isTrue();
    }

    private void assertDeleteFileAPISupport(File file) throws Exception {
        assertThat(file.delete()).isTrue();
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.display.cts.VirtualDisplayTest"	"testGetHdrCapabilitiesWithUserDisabledFormats"	"CtsDisplayTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/display/src/android/display/cts/VirtualDisplayTest.java"	""	"public void testGetHdrCapabilitiesWithUserDisabledFormats() {
        VirtualDisplay virtualDisplay = mDisplayManager.createVirtualDisplay(NAME,
                WIDTH, HEIGHT, DENSITY, mSurface, /*flags*/ 0);
        mDisplayManager.setAreUserDisabledHdrTypesAllowed(false);
        int[] userDisabledHdrTypes = {
                Display.HdrCapabilities.HDR_TYPE_DOLBY_VISION,
                Display.HdrCapabilities.HDR_TYPE_HLG};
        mDisplayManager.setUserDisabledHdrTypes(userDisabledHdrTypes);

        try {
            assertFalse(virtualDisplay.getDisplay().isHdr());
            assertNull(virtualDisplay.getDisplay().getHdrCapabilities());
        } finally {
            virtualDisplay.release();
        }
    }

    private void assertDisplayRegistered(Display display, int flags) {
        assertNotNull(""display object must not be null"", display);
        assertTrue(""display must be valid"", display.isValid());
        assertTrue(""display id must be unique"",
                display.getDisplayId() != Display.DEFAULT_DISPLAY);
        assertEquals(""display must have correct flags"", flags, display.getFlags());
        assertEquals(""display name must match supplied name"", NAME, display.getName());
        Point size = new Point();
        display.getSize(size);
        assertEquals(""display width must match supplied width"", WIDTH, size.x);
        assertEquals(""display height must match supplied height"", HEIGHT, size.y);
        assertEquals(""display rotation must be 0"",
                Surface.ROTATION_0, display.getRotation());
        assertNotNull(""display must be registered"",
                findDisplay(mDisplayManager.getDisplays(), NAME));

        if ((flags & Display.FLAG_PRESENTATION) != 0) {
            assertNotNull(""display must be registered as a presentation display"",
                    findDisplay(mDisplayManager.getDisplays(
                            DisplayManager.DISPLAY_CATEGORY_PRESENTATION), NAME));
        } else {
            assertNull(""display must not be registered as a presentation display"",
                    findDisplay(mDisplayManager.getDisplays(
                            DisplayManager.DISPLAY_CATEGORY_PRESENTATION), NAME));
        }
    }

    private void assertDisplayUnregistered(Display display) {
        assertNull(""display must no longer be registered after being removed"",
                findDisplay(mDisplayManager.getDisplays(), NAME));
        assertFalse(""display must no longer be valid"", display.isValid());
    }

    private void assertDisplayCanShowPresentation(String message, final Display display,
            final int color, final int windowFlags) {
        // At this point, we should not have seen any blue.
        assertTrue(message + "": display should not show content before window is shown"",
                mImageListener.getColor() != color);

        final TestPresentation[] presentation = new TestPresentation[1];
        try {
            // Show the presentation.
            runOnUiThread(new Runnable() {
                @Override
                public void run() {
                    presentation[0] = new TestPresentation(mContext, display,
                            color, windowFlags);
                    presentation[0].show();
                }
            });

            // Wait for the blue to be seen.
            assertTrue(message + "": display should show content after window is shown"",
                    mImageListener.waitForColor(color, TIMEOUT));
        } finally {
            if (presentation[0] != null) {
                runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        presentation[0].dismiss();
                    }
                });
            }
        }
    }

    private void runOnUiThread(Runnable runnable) {
        Runnable waiter = new Runnable() {
            @Override
            public void run() {
                synchronized (this) {
                    notifyAll();
                }
            }
        };
        synchronized (waiter) {
            mHandler.post(runnable);
            mHandler.post(waiter);
            try {
                waiter.wait(TIMEOUT);
            } catch (InterruptedException ex) {
            }
        }
    }

    private Display findDisplay(Display[] displays, String name) {
        for (int i = 0; i < displays.length; i++) {
            if (displays[i].getName().equals(name)) {
                return displays[i];
            }
        }
        return null;
    }

    private final class TestPresentation extends Presentation {
        private final int mColor;
        private final int mWindowFlags;

        public TestPresentation(Context context, Display display,
                int color, int windowFlags) {
            super(context, display);
            mColor = color;
            mWindowFlags = windowFlags;
        }

        @Override
        protected void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);

            setTitle(TAG);
            getWindow().addFlags(mWindowFlags);

            // Create a solid color image to use as the content of the presentation.
            ImageView view = new ImageView(getContext());
            view.setImageDrawable(new ColorDrawable(mColor));
            view.setLayoutParams(new LayoutParams(
                    LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
            setContentView(view);
        }
    }

    /**
     * Watches for an image with a large amount of some particular solid color to be shown.
     */
    private final class ImageListener
            implements ImageReader.OnImageAvailableListener {
        private int mColor = -1;

        public int getColor() {
            synchronized (this) {
                return mColor;
            }
        }

        public boolean waitForColor(int color, long timeoutMillis) {
            long timeoutTime = SystemClock.uptimeMillis() + timeoutMillis;
            synchronized (this) {
                while (mColor != color) {
                    long now = SystemClock.uptimeMillis();
                    if (now >= timeoutTime) {
                        return false;
                    }
                    try {
                        wait(timeoutTime - now);
                    } catch (InterruptedException ex) {
                    }
                }
                return true;
            }
        }

        @Override
        public void onImageAvailable(ImageReader reader) {
            mImageReaderLock.lock();
            try {
                if (reader != mImageReader) {
                    return;
                }

                Log.d(TAG, ""New image available from virtual display."");
                // Get the latest buffer
                Image image = reader.acquireLatestImage();
                if (image != null) {
                    try {
                        // Scan for colors.
                        int color = scanImage(image);
                        synchronized (this) {
                            if (mColor != color) {
                                mColor = color;
                                notifyAll();
                            }
                        }
                    } finally {
                        image.close();
                    }
                }
            } finally {
                mImageReaderLock.unlock();
            }
        }

        private int scanImage(Image image) {
            final Image.Plane plane = image.getPlanes()[0];
            final ByteBuffer buffer = plane.getBuffer();
            final int width = image.getWidth();
            final int height = image.getHeight();
            final int pixelStride = plane.getPixelStride();
            final int rowStride = plane.getRowStride();
            final int rowPadding = rowStride - pixelStride * width;

            Log.d(TAG, ""- Scanning image: width="" + width + "", height="" + height
                    + "", pixelStride="" + pixelStride + "", rowStride="" + rowStride);

            int offset = 0;
            int blackPixels = 0;
            int bluePixels = 0;
            int greenPixels = 0;
            int otherPixels = 0;
            for (int y = 0; y < height; y++) {
                for (int x = 0; x < width; x++) {
                    int pixel = 0;
                    pixel |= (buffer.get(offset) & 0xff) << 16;     // R
                    pixel |= (buffer.get(offset + 1) & 0xff) << 8;  // G
                    pixel |= (buffer.get(offset + 2) & 0xff);       // B
                    pixel |= (buffer.get(offset + 3) & 0xff) << 24; // A
                    if (pixel == Color.BLACK || pixel == 0) {
                        blackPixels += 1;
                    } else if (pixel == BLUEISH) {
                        bluePixels += 1;
                    } else if (pixel == GREENISH) {
                        greenPixels += 1;
                    } else {
                        otherPixels += 1;
                        if (otherPixels < 10) {
                            Log.d(TAG, ""- Found unexpected color: "" + Integer.toHexString(pixel));
                        }
                    }
                    offset += pixelStride;
                }
                offset += rowPadding;
            }

            // Return a color if it represents more than one quarter of the pixels.
            // We use this threshold in case the display is being letterboxed when
            // mirroring so there might be large black bars on the sides, which is normal.
            Log.d(TAG, ""- Pixels: "" + blackPixels + "" black, ""
                    + bluePixels + "" blue, ""
                    + greenPixels + "" green, ""
                    + otherPixels + "" other"");
            final int threshold = width * height / 4;
            if (bluePixels > threshold) {
                Log.d(TAG, ""- Reporting blue."");
                return BLUEISH;
            }
            if (greenPixels > threshold) {
                Log.d(TAG, ""- Reporting green."");
                return GREENISH;
            }
            if (blackPixels > threshold) {
                Log.d(TAG, ""- Reporting black."");
                return Color.BLACK;
            }
            Log.d(TAG, ""- Reporting other."");
            return -1;
        }
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.audio.USBAudioPeripheralActivity"	"OnBtnClickListener"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/audio/USBAudioPeripheralActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.audio;

import android.app.AlertDialog;
import android.media.AudioDeviceCallback;
import android.media.AudioDeviceInfo;
import android.media.AudioManager;
import android.os.Bundle;
import android.os.Handler;
import android.util.Log;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.TextView;

import com.android.compatibility.common.util.ResultType;
import com.android.compatibility.common.util.ResultUnit;
import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;
import com.android.cts.verifier.audio.peripheralprofile.PeripheralProfile;
import com.android.cts.verifier.audio.peripheralprofile.ProfileManager;

public abstract class USBAudioPeripheralActivity extends PassFailButtons.Activity {
    private static final String TAG = ""USBAudioPeripheralActivity"";
    private static final boolean DEBUG = false;

    // Profile
    protected ProfileManager mProfileManager = new ProfileManager();
    protected PeripheralProfile mSelectedProfile;

    // Peripheral
    AudioManager mAudioManager;
    protected boolean mIsPeripheralAttached;
    protected AudioDeviceInfo mOutputDevInfo;
    protected AudioDeviceInfo mInputDevInfo;

    protected final boolean mIsMandatedRequired;

    // Widgets
    private TextView mProfileNameTx;
    private TextView mProfileDescriptionTx;

    private TextView mPeripheralNameTx;

    private OnBtnClickListener mBtnClickListener = new OnBtnClickListener();

    // ReportLog Schema
    private static final String KEY_CLAIMS_HOST = ""claims_host_mode"";

    //
    // Common UI Handling
    //
    protected void connectUSBPeripheralUI() {
        findViewById(R.id.uap_tests_yes_btn).setOnClickListener(mBtnClickListener);
        findViewById(R.id.uap_tests_no_btn).setOnClickListener(mBtnClickListener);
        findViewById(R.id.uap_test_info_btn).setOnClickListener(mBtnClickListener);

        // Leave the default state in tact
        // enableTestUI(false);
    }

    private void showUAPInfoDialog() {
        new AlertDialog.Builder(this)
                .setTitle(R.string.uap_mic_dlg_caption)
                .setMessage(R.string.uap_mic_dlg_text)
                .setPositiveButton(R.string.audio_general_ok, null)
                .show();
    }

    private class OnBtnClickListener implements OnClickListener {
        @Override
        public void onClick(View v) {
            switch (v.getId()) {
                case R.id.uap_tests_yes_btn:
                    recordUSBAudioStatus(true);
                    enableTestUI(true);
                    // disable test button so that they will now run the test(s)
                    getPassButton().setEnabled(false);
                    break;

                case R.id.uap_tests_no_btn:
                    recordUSBAudioStatus(false);
                    enableTestUI(false);
                    // Allow the user to ""pass"" the test.
                    getPassButton().setEnabled(true);
                    break;

                case R.id.uap_test_info_btn:
                    showUAPInfoDialog();
                    break;
            }
        }
    }

    private void recordUSBAudioStatus(boolean has) {
        getReportLog().addValue(
                KEY_CLAIMS_HOST,
                has,
                ResultType.NEUTRAL,
                ResultUnit.NONE);
    }

    //
    // Overrides
    //
    void enableTestUI(boolean enable) {

    }

    public USBAudioPeripheralActivity(boolean mandatedRequired) {
        super();

        // determine if to show ""UNSUPPORTED"" if the mandated peripheral is required.
        mIsMandatedRequired = mandatedRequired;

        mProfileManager.loadProfiles();
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        mAudioManager = (AudioManager)getSystemService(AUDIO_SERVICE);
        mAudioManager.registerAudioDeviceCallback(new ConnectListener(), new Handler());
    }

    protected void connectPeripheralStatusWidgets() {
        mProfileNameTx = (TextView)findViewById(R.id.uap_profileNameTx);
        mProfileDescriptionTx =
            (TextView)findViewById(R.id.uap_profileDescriptionTx);
        mPeripheralNameTx = (TextView)findViewById(R.id.uap_peripheralNameTx);
    }

    private void showProfileStatus() {
        if (DEBUG) {
            Log.d(TAG, ""showProfileStatus()"" + (mSelectedProfile != null));
        }
        if (mSelectedProfile != null) {
            mProfileNameTx.setText(mSelectedProfile.getName());
            mProfileDescriptionTx.setText(mSelectedProfile.getDescription());
        } else {
            mProfileNameTx.setText("""");
            mProfileDescriptionTx.setText("""");
        }
    }

    private void showPeripheralStatus() {
        if (mIsPeripheralAttached) {
            String productName = """";
            if (mOutputDevInfo != null) {
                productName = mOutputDevInfo.getProductName().toString();
            } else if (mInputDevInfo != null) {
                productName = mInputDevInfo.getProductName().toString();
            }
            String ctrlText;
            if (mSelectedProfile == null && mIsMandatedRequired) {
                ctrlText = productName + "" - UNSUPPORTED"";
            } else {
                ctrlText = productName;
            }
            mPeripheralNameTx.setText(ctrlText);
        } else {
            mPeripheralNameTx.setText(""Disconnected"");
        }
    }

    private void scanPeripheralList(AudioDeviceInfo[] devices) {
        // Can't just use the first record because then we will only get
        // Source OR sink, not both even on devices that are both.
        mOutputDevInfo = null;
        mInputDevInfo = null;

        // Any valid peripherals
        for(AudioDeviceInfo devInfo : devices) {
            if (devInfo.getType() == AudioDeviceInfo.TYPE_USB_DEVICE ||
                devInfo.getType() == AudioDeviceInfo.TYPE_USB_HEADSET) {
                if (devInfo.isSink()) {
                    mOutputDevInfo = devInfo;
                }
                if (devInfo.isSource()) {
                    mInputDevInfo = devInfo;
                }
            }
        }
        mIsPeripheralAttached = mOutputDevInfo != null || mInputDevInfo != null;
        if (DEBUG) {
            Log.d(TAG, ""mIsPeripheralAttached: "" + mIsPeripheralAttached);
        }

        // any associated profiles?
        if (mIsPeripheralAttached) {
            if (mOutputDevInfo != null) {
                mSelectedProfile =
                    mProfileManager.getProfile(mOutputDevInfo.getProductName().toString());
            } else if (mInputDevInfo != null) {
                mSelectedProfile =
                    mProfileManager.getProfile(mInputDevInfo.getProductName().toString());
            }
        } else {
            mSelectedProfile = null;
        }

    }

    private class ConnectListener extends AudioDeviceCallback {
        /*package*/ ConnectListener() {}

        //
        // AudioDevicesManager.OnDeviceConnectionListener
        //
        @Override
        public void onAudioDevicesAdded(AudioDeviceInfo[] addedDevices) {
            // Log.i(TAG, ""onAudioDevicesAdded() num:"" + addedDevices.length);

            scanPeripheralList(mAudioManager.getDevices(AudioManager.GET_DEVICES_ALL));

            showProfileStatus();
            showPeripheralStatus();
            updateConnectStatus();
        }

        @Override
        public void onAudioDevicesRemoved(AudioDeviceInfo[] removedDevices) {
            // Log.i(TAG, ""onAudioDevicesRemoved() num:"" + removedDevices.length);

            scanPeripheralList(mAudioManager.getDevices(AudioManager.GET_DEVICES_ALL));

            showProfileStatus();
            showPeripheralStatus();
            updateConnectStatus();
        }
    }

    abstract public void updateConnectStatus();
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.bluetooth.BleInsecureClientTestListActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/bluetooth/BleInsecureClientTestListActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.bluetooth;

import android.bluetooth.BluetoothAdapter;
import android.os.Bundle;

import com.android.cts.verifier.ManifestTestListAdapter;
import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;

import java.util.ArrayList;
import java.util.List;

public class BleInsecureClientTestListActivity extends PassFailButtons.TestListActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.pass_fail_list);
        setPassFailButtonClickListeners();
        setInfoResources(R.string.ble_insecure_client_test_list_name,
                R.string.ble_insecure_client_test_list_info,
                -1);

        BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
        List<String> disabledTest = new ArrayList<String>();
        if (adapter == null || !adapter.isOffloadedFilteringSupported()) {
            disabledTest.add(
                    ""com.android.cts.verifier.bluetooth.BleAdvertiserHardwareScanFilterActivity."");
        }

        setTestListAdapter(new ManifestTestListAdapter(this, getClass().getName(),
                disabledTest.toArray(new String[disabledTest.size()])));
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.net.wifi.nl80211.cts.NativeScanResultTest"	"testGetters"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/nl80211/cts/NativeScanResultTest.java"	""	"public void testGetters() {
        NativeScanResult result = new NativeScanResult();
        assertThat(result.isAssociated()).isFalse();
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.bluetooth.cts.BTAdapterUtils"	"isEnabled"	""	"/home/gpoor/cts-12-source/cts/tests/tests/bluetooth/bluetoothTestUtilLib/src/android/bluetooth/cts/BTAdapterUtils.java"	""	"public void test/*
 *.
 */

package android.bluetooth.cts;

import android.bluetooth.BluetoothAdapter;
import android.bluetooth.le.ScanRecord;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageManager;
import android.provider.Settings;
import android.util.Log;

import junit.framework.Assert;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

/**
 * Utility for controlling the Bluetooth adapter from CTS test.
 */
public class BTAdapterUtils {
    private static final String TAG = ""BTAdapterUtils"";

    // ADAPTER_ENABLE_TIMEOUT_MS = AdapterState.BLE_START_TIMEOUT_DELAY +
    //                              AdapterState.BREDR_START_TIMEOUT_DELAY
    private static final int ADAPTER_ENABLE_TIMEOUT_MS = 8000;
    // ADAPTER_DISABLE_TIMEOUT_MS = AdapterState.BLE_STOP_TIMEOUT_DELAY +
    //                                  AdapterState.BREDR_STOP_TIMEOUT_DELAY
    private static final int ADAPTER_DISABLE_TIMEOUT_MS = 5000;

    private static BroadcastReceiver mAdapterIntentReceiver;

    private static Condition mConditionAdapterIsEnabled;
    private static ReentrantLock mAdapterStateEnablinglock;

    private static Condition mConditionAdapterIsDisabled;
    private static ReentrantLock mAdapterStateDisablinglock;
    private static boolean mAdapterVarsInitialized;

    private static class AdapterIntentReceiver extends BroadcastReceiver {
        @Override
        public void onReceive(Context context, Intent intent) {
            if (BluetoothAdapter.ACTION_STATE_CHANGED.equals(intent.getAction())) {
                int previousState = intent.getIntExtra(BluetoothAdapter.EXTRA_PREVIOUS_STATE, -1);
                int newState = intent.getIntExtra(BluetoothAdapter.EXTRA_STATE, -1);
                Log.d(TAG, ""Previous state: "" + previousState + "" New state: "" + newState);

                if (newState == BluetoothAdapter.STATE_ON) {
                    mAdapterStateEnablinglock.lock();
                    try {
                        Log.d(TAG, ""Signaling to mConditionAdapterIsEnabled"");
                        mConditionAdapterIsEnabled.signal();
                    } finally {
                        mAdapterStateEnablinglock.unlock();
                    }
                } else if (newState == BluetoothAdapter.STATE_OFF) {
                    mAdapterStateDisablinglock.lock();
                    try {
                        Log.d(TAG, ""Signaling to mConditionAdapterIsDisabled"");
                        mConditionAdapterIsDisabled.signal();
                    } finally {
                        mAdapterStateDisablinglock.unlock();
                    }
                }
            }
        }
    }

    /** Enables the Bluetooth Adapter. Return true if it is already enabled or is enabled. */
    public static boolean enableAdapter(BluetoothAdapter bluetoothAdapter, Context context) {
        if (!mAdapterVarsInitialized) {
            initAdapterStateVariables(context);
        }

        if (bluetoothAdapter.isEnabled()) return true;

        Log.d(TAG, ""Enabling bluetooth adapter"");
        bluetoothAdapter.enable();
        mAdapterStateEnablinglock.lock();
        try {
            // Wait for the Adapter to be enabled
            while (!bluetoothAdapter.isEnabled()) {
                if (!mConditionAdapterIsEnabled.await(
                        ADAPTER_ENABLE_TIMEOUT_MS, TimeUnit.MILLISECONDS)) {
                    // Timeout
                    Log.e(TAG, ""Timeout while waiting for the Bluetooth Adapter enable"");
                    break;
                } // else spurious wakeups
            }
        } catch(InterruptedException e) {
            Log.e(TAG, ""enableAdapter: interrrupted"");
        } finally {
            mAdapterStateEnablinglock.unlock();
        }
        return bluetoothAdapter.isEnabled();
    }

    /** Disable the Bluetooth Adapter. Return true if it is already disabled or is disabled. */
    public static boolean disableAdapter(BluetoothAdapter bluetoothAdapter, Context context) {
        if (!mAdapterVarsInitialized) {
            initAdapterStateVariables(context);
        }

        if (bluetoothAdapter.getState() == BluetoothAdapter.STATE_OFF) return true;

        Log.d(TAG, ""Disabling bluetooth adapter"");
        bluetoothAdapter.disable();
        mAdapterStateDisablinglock.lock();
        try {
            // Wait for the Adapter to be disabled
            while (bluetoothAdapter.getState() != BluetoothAdapter.STATE_OFF) {
                if (!mConditionAdapterIsDisabled.await(
                        ADAPTER_DISABLE_TIMEOUT_MS, TimeUnit.MILLISECONDS)) {
                    // Timeout
                    Log.e(TAG, ""Timeout while waiting for the Bluetooth Adapter disable"");
                    break;
                } // else spurious wakeups
            }
        } catch(InterruptedException e) {
            Log.e(TAG, ""enableAdapter: interrrupted"");
        } finally {
            mAdapterStateDisablinglock.unlock();
        }
        return bluetoothAdapter.getState() == BluetoothAdapter.STATE_OFF;
    }

    // Initialize variables required for TestUtils#enableAdapter and TestUtils#disableAdapter
    private static void initAdapterStateVariables(Context context) {
        Log.d(TAG, ""Initializing adapter state variables"");
        mAdapterIntentReceiver = new AdapterIntentReceiver();
        IntentFilter filter = new IntentFilter(BluetoothAdapter.ACTION_STATE_CHANGED);
        context.registerReceiver(mAdapterIntentReceiver, filter);

        mAdapterStateEnablinglock = new ReentrantLock();
        mConditionAdapterIsEnabled = mAdapterStateEnablinglock.newCondition();
        mAdapterStateDisablinglock = new ReentrantLock();
        mConditionAdapterIsDisabled = mAdapterStateDisablinglock.newCondition();

        mAdapterVarsInitialized = true;
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.graphics.pdf.cts.PdfRendererTest"	"testPrintScalePDF16None"	"CtsPdfTestCases"	"/home/gpoor/cts-12-source/cts/tests/pdf/src/android/graphics/pdf/cts/PdfRendererTest.java"	""	"public void testPrintScalePDF16None() throws Exception {
        try (PdfRenderer renderer = createRenderer(A5_PORTRAIT_PRINTSCALING_NONE, mContext)) {
            assertFalse(renderer.shouldScaleForPrinting());
        }
    }

    /**
     * Take 16 color probes in the middle of the 16 segments of the page in the following pattern:
     * <pre>
     * +----+----+----+----+
     * |  0 :  1 :  2 :  3 |
     * +....:....:....:....+
     * |  4 :  5 :  6 :  7 |
     * +....:....:....:....+
     * |  8 :  9 : 10 : 11 |
     * +....:....:....:....+
     * | 12 : 13 : 14 : 15 |
     * +----+----+----+----+
     * </pre>
     *
     * @param bm The bitmap to probe
     *
     * @return The color at the probes
     */
    private @NonNull int[] getColorProbes(@NonNull Bitmap bm) {
        int[] probes = new int[16];

        for (int row = 0; row < 4; row++) {
            for (int column = 0; column < 4; column++) {
                probes[row * 4 + column] = bm.getPixel((int) (bm.getWidth() * (column + 0.5) / 4),
                        (int) (bm.getHeight() * (row + 0.5) / 4));
            }
        }

        return probes;
    }

    /**
     * Implementation for {@link #renderNoTransformationAndComparePointsForScreen} and {@link
     * #renderNoTransformationAndComparePointsForPrint}.
     *
     * @param renderMode The render mode to use
     *
     * @throws Exception If anything was unexpected
     */
    private void renderNoTransformationAndComparePoints(int renderMode) throws Exception {
        Bitmap bm = renderWithTransform(A4_WIDTH_PTS, A4_HEIGHT_PTS, A4_PORTRAIT, null, null,
                renderMode, mContext);
        int[] probes = getColorProbes(bm);

        // Compare rendering to expected result. This ensures that all other tests in this class do
        // not accidentally all compare empty bitmaps.
        assertEquals(Color.RED, probes[0]);
        assertEquals(Color.RED, probes[1]);
        assertEquals(Color.GREEN, probes[2]);
        assertEquals(Color.GREEN, probes[3]);
        assertEquals(Color.RED, probes[4]);
        assertEquals(Color.RED, probes[5]);
        assertEquals(Color.GREEN, probes[6]);
        assertEquals(Color.GREEN, probes[7]);
        assertEquals(Color.BLUE, probes[8]);
        assertEquals(Color.BLUE, probes[9]);
        assertEquals(Color.BLACK, probes[10]);
        assertEquals(Color.BLACK, probes[11]);
        assertEquals(Color.BLUE, probes[12]);
        assertEquals(Color.BLUE, probes[13]);
        assertEquals(Color.BLACK, probes[14]);
        assertEquals(Color.BLACK, probes[15]);
    }"	""	""	"probe"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.widget.cts.ExpandableListWithHeaders"	"getExpandableListView"	"CtsWidgetTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/ExpandableListWithHeaders.java"	""	"public void test/*
 *.
 */

package android.widget.cts;

import android.os.Bundle;
import android.widget.Button;
import android.widget.ExpandableListView;
import android.widget.cts.util.ExpandableListScenario;

public class ExpandableListWithHeaders extends ExpandableListScenario {
    private static final int[] CHILD_COUNT = {1, 4, 3, 2, 6};
    private static final int HEADER_FOOTER_COUNT = 12;

    @Override
    protected void init(ExpandableParams params) {
        params.setStackFromBottom(false)
                .setStartingSelectionPosition(-1)
                .setNumChildren(CHILD_COUNT)
                .setItemScreenSizeFactor(0.14)
                .setConnectAdapter(false);
    }

    @Override
    protected void onCreate(Bundle icicle) {
        super.onCreate(icicle);

        final ExpandableListView expandableListView = getExpandableListView();
        expandableListView.setItemsCanFocus(true);

        for (int i = 0; i < HEADER_FOOTER_COUNT; i++) {
            Button header = new Button(this);
            header.setText(""Header View"");
            expandableListView.addHeaderView(header);
        }

        for (int i = 0; i < HEADER_FOOTER_COUNT; i++) {
            Button footer = new Button(this);
            footer.setText(""Footer View"");
            expandableListView.addFooterView(footer);
        }

        // Set adapter here AFTER we set header and footer views
        setAdapter(expandableListView);
    }

    /**
     * @return The number of headers (and the same number of footers)
     */
    public int getNumOfHeadersAndFooters() {
        return HEADER_FOOTER_COUNT;
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.server.wm.WindowInsetsAnimationUtils"	"WindowInsetsAnimationControlListener"	""	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/util/src/android/server/wm/WindowInsetsAnimationUtils.java"	""	"public void test/*
 *.
 */

package android.server.wm;

import android.animation.Animator;
import android.animation.AnimatorListenerAdapter;
import android.animation.TypeEvaluator;
import android.animation.ValueAnimator;
import android.graphics.Insets;
import android.view.WindowInsetsAnimationControlListener;
import android.view.WindowInsetsAnimationController;
import android.view.WindowInsetsController;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

public class WindowInsetsAnimationUtils {

    private static final int DURATION = 1000;

    /** Interpolates {@link Insets} for use with {@link ValueAnimator}. */
    public static TypeEvaluator<Insets> INSETS_EVALUATOR =
            (fraction, startValue, endValue) -> Insets.of(
                    (int) (startValue.left + fraction * (endValue.left - startValue.left)),
                    (int) (startValue.top + fraction * (endValue.top - startValue.top)),
                    (int) (startValue.right + fraction * (endValue.right - startValue.right)),
                    (int) (startValue.bottom + fraction * (endValue.bottom - startValue.bottom)));


    /**
     * Requests control of the given {@code types} and animates them according to {@code show}.
     *
     * @param show if true, animate the inset in, otherwise animate it out.
     */
    public static void requestControlThenTransitionToVisibility(WindowInsetsController wic,
            int types, boolean show) {
        wic.controlWindowInsetsAnimation(types, -1, null,
                null, new WindowInsetsAnimationControlListener() {
                    Animator mAnimator;

                    @Override
                    public void onReady(@NonNull WindowInsetsAnimationController controller,
                            int types) {
                        mAnimator = runTransition(controller, show);
                    }

                    @Override
                    public void onFinished(
                            @NonNull WindowInsetsAnimationController controller) {
                    }

                    @Override
                    public void onCancelled(
                            @Nullable WindowInsetsAnimationController controller) {
                        if (mAnimator != null) {
                            mAnimator.cancel();
                        }
                    }
                });
    }

    private static ValueAnimator runTransition(WindowInsetsAnimationController controller,
            boolean show) {
        ValueAnimator animator = ValueAnimator.ofObject(
                INSETS_EVALUATOR,
                show ? controller.getHiddenStateInsets()
                        : controller.getShownStateInsets(),
                show ? controller.getShownStateInsets()
                        : controller.getHiddenStateInsets()
        );
        animator.setDuration(DURATION);
        animator.addUpdateListener((animator1) -> {
            if (!controller.isReady()) {
                // Lost control
                animator.cancel();
                return;
            }
            Insets insets = (Insets) animator.getAnimatedValue();
            controller.setInsetsAndAlpha(insets, 1.0f, animator.getAnimatedFraction());
        });
        animator.addListener(new AnimatorListenerAdapter() {
            @Override
            public void onAnimationEnd(Animator animation) {
                if (!controller.isCancelled()) {
                    controller.finish(show);
                }
            }
        });
        animator.start();
        return animator;
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.writeexternalstorageapp.WriteGiftTest"	"testClearingWrite"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/WriteExternalStorageApp/src/com/android/cts/writeexternalstorageapp/WriteGiftTest.java"	""	"public void testClearingWrite() throws Exception {
        for (File dir : getAllPackageSpecificPaths(getContext())) {
            dir.mkdirs();
            new File(dir, ""probe"").createNewFile();
            assertTrue(new File(dir, ""probe"").exists());
        }
    }"	""	""	"probe"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.writeexternalstorageapp.WriteGiftTest"	"testClearingRead"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/WriteExternalStorageApp/src/com/android/cts/writeexternalstorageapp/WriteGiftTest.java"	""	"public void testClearingRead() throws Exception {
        for (File dir : getAllPackageSpecificPaths(getContext())) {
            assertFalse(new File(dir, ""probe"").exists());
        }
    }"	""	""	"probe"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.net.wifi.rtt.cts.WifiRttTest"	"testRangingToTest11mcAp"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/rtt/cts/WifiRttTest.java"	""	"public void testRangingToTest11mcAp() throws InterruptedException {
        if (!shouldTestWifiRtt(getContext())) {
            return;
        }

        // Scan for IEEE 802.11mc supporting APs
        ScanResult testAp = scanForTest11mcCapableAp(NUM_SCANS_SEARCHING_FOR_IEEE80211MC_AP);
        assertNotNull(
                ""Cannot find any test APs which support RTT / IEEE 802.11mc - please verify that ""
                        + ""your test setup includes them!"", testAp);

        // Perform RTT operations
        RangingRequest.Builder builder = new RangingRequest.Builder();
        builder.addAccessPoint(testAp);
        if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(getContext())) {
            builder.setRttBurstSize(RangingRequest.getMaxRttBurstSize());
            assertTrue(RangingRequest.getDefaultRttBurstSize()
                    >= RangingRequest.getMinRttBurstSize());
            assertTrue(RangingRequest.getDefaultRttBurstSize()
                    <= RangingRequest.getMaxRttBurstSize());
        }
        RangingRequest request = builder.build();
        if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(getContext())) {
            assertEquals(1, request.getRttResponders().size());
        }

        List<RangingResult> allResults = new ArrayList<>();
        int numFailures = 0;
        int distanceSum = 0;
        int distanceMin = 0;
        int distanceMax = 0;
        int[] statuses = new int[NUM_OF_RTT_ITERATIONS];
        int[] distanceMms = new int[NUM_OF_RTT_ITERATIONS];
        int[] distanceStdDevMms = new int[NUM_OF_RTT_ITERATIONS];
        int[] rssis = new int[NUM_OF_RTT_ITERATIONS];
        int[] numAttempted = new int[NUM_OF_RTT_ITERATIONS];
        int[] numSuccessful = new int[NUM_OF_RTT_ITERATIONS];
        long[] timestampsMs = new long[NUM_OF_RTT_ITERATIONS];
        byte[] lastLci = null;
        byte[] lastLcr = null;
        for (int i = 0; i < NUM_OF_RTT_ITERATIONS; ++i) {
            ResultCallback callback = new ResultCallback();
            mWifiRttManager.startRanging(request, mExecutor, callback);
            assertTrue(""Wi-Fi RTT results: no callback on iteration "" + i,
                    callback.waitForCallback());

            List<RangingResult> currentResults = callback.getResults();
            assertNotNull(""Wi-Fi RTT results: null results (onRangingFailure) on iteration "" + i,
                    currentResults);
            assertEquals(""Wi-Fi RTT results: unexpected # of results (expect 1) on iteration "" + i,
                    1, currentResults.size());
            RangingResult result = currentResults.get(0);
            assertEquals(""Wi-Fi RTT results: invalid result (wrong BSSID) entry on iteration "" + i,
                    result.getMacAddress().toString(), testAp.BSSID);
            assertNull(""Wi-Fi RTT results: invalid result (non-null PeerHandle) entry on iteration ""
                    + i, result.getPeerHandle());

            allResults.add(result);
            int status = result.getStatus();
            statuses[i] = status;
            if (status == RangingResult.STATUS_SUCCESS) {
                if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(getContext())) {
                    assertEquals(
                            ""Wi-Fi RTT results: invalid result (wrong rttBurstSize) entry on ""
                                    + ""iteration ""
                                    + i,
                            result.getNumAttemptedMeasurements(),
                            RangingRequest.getMaxRttBurstSize());
                    assertTrue(""Wi-Fi RTT results: should be a 802.11MC measurement"",
                            result.is80211mcMeasurement());
                }
                distanceSum += result.getDistanceMm();
                if (i == 0) {
                    distanceMin = result.getDistanceMm();
                    distanceMax = result.getDistanceMm();
                } else {
                    distanceMin = Math.min(distanceMin, result.getDistanceMm());
                    distanceMax = Math.max(distanceMax, result.getDistanceMm());
                }

                assertTrue(""Wi-Fi RTT results: invalid RSSI on iteration "" + i,
                        result.getRssi() >= MIN_VALID_RSSI);

                distanceMms[i - numFailures] = result.getDistanceMm();
                distanceStdDevMms[i - numFailures] = result.getDistanceStdDevMm();
                rssis[i - numFailures] = result.getRssi();
                numAttempted[i - numFailures] = result.getNumAttemptedMeasurements();
                numSuccessful[i - numFailures] = result.getNumSuccessfulMeasurements();
                timestampsMs[i - numFailures] = result.getRangingTimestampMillis();

                byte[] currentLci = result.getLci();
                byte[] currentLcr = result.getLcr();
                if (i - numFailures > 0) {
                    assertTrue(""Wi-Fi RTT results: invalid result (LCI mismatch) on iteration "" + i,
                            Arrays.equals(currentLci, lastLci));
                    assertTrue(""Wi-Fi RTT results: invalid result (LCR mismatch) on iteration "" + i,
                            Arrays.equals(currentLcr, lastLcr));
                }
                lastLci = currentLci;
                lastLcr = currentLcr;
            } else {
                numFailures++;
            }
            // Sleep a while to avoid stress AP.
            Thread.sleep(intervalMs);
        }

        // Save results to log
        int numGoodResults = NUM_OF_RTT_ITERATIONS - numFailures;
        DeviceReportLog reportLog = new DeviceReportLog(TAG, ""testRangingToTestAp"");
        reportLog.addValues(""status_codes"", statuses, ResultType.NEUTRAL, ResultUnit.NONE);
        reportLog.addValues(""distance_mm"", Arrays.copyOf(distanceMms, numGoodResults),
                ResultType.NEUTRAL, ResultUnit.NONE);
        reportLog.addValues(""distance_stddev_mm"", Arrays.copyOf(distanceStdDevMms, numGoodResults),
                ResultType.NEUTRAL, ResultUnit.NONE);
        reportLog.addValues(""rssi_dbm"", Arrays.copyOf(rssis, numGoodResults), ResultType.NEUTRAL,
                ResultUnit.NONE);
        reportLog.addValues(""num_attempted"", Arrays.copyOf(numAttempted, numGoodResults),
                ResultType.NEUTRAL, ResultUnit.NONE);
        reportLog.addValues(""num_successful"", Arrays.copyOf(numSuccessful, numGoodResults),
                ResultType.NEUTRAL, ResultUnit.NONE);
        reportLog.addValues(""timestamps"", Arrays.copyOf(timestampsMs, numGoodResults),
                ResultType.NEUTRAL, ResultUnit.NONE);
        reportLog.submit();

        // Analyze results
        assertTrue(""Wi-Fi RTT failure rate exceeds threshold: FAIL="" + numFailures + "", ITERATIONS=""
                        + NUM_OF_RTT_ITERATIONS + "", AP RSSI="" + testAp.level
                        + "", AP SSID="" + testAp.SSID,
                numFailures <= NUM_OF_RTT_ITERATIONS * MAX_FAILURE_RATE_PERCENT / 100);
        if (numFailures != NUM_OF_RTT_ITERATIONS) {
            double distanceAvg = (double) distanceSum / (NUM_OF_RTT_ITERATIONS - numFailures);
            assertTrue(""Wi-Fi RTT: Variation (max direction) exceeds threshold, Variation =""
                            + (distanceMax - distanceAvg),
                    (distanceMax - distanceAvg) <= MAX_VARIATION_FROM_AVERAGE_DISTANCE_MM);
            assertTrue(""Wi-Fi RTT: Variation (min direction) exceeds threshold, Variation =""
                            + (distanceAvg - distanceMin),
                    (distanceAvg - distanceMin) <= MAX_VARIATION_FROM_AVERAGE_DISTANCE_MM);
            for (int i = 0; i < numGoodResults; ++i) {
                assertNotSame(""Number of attempted measurements is 0"", 0, numAttempted[i]);
                assertNotSame(""Number of successful measurements is 0"", 0, numSuccessful[i]);
            }
        }
    }

    /**
     * Validate that when a request contains more range operations than allowed (by API) that we
     * get an exception.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.net.wifi.rtt.cts.WifiRttTest"	"testRequestTooLarge"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/rtt/cts/WifiRttTest.java"	""	"public void testRequestTooLarge() throws InterruptedException {
        if (!shouldTestWifiRtt(getContext())) {
            return;
        }
        ScanResult testAp = scanForTest11mcCapableAp(NUM_SCANS_SEARCHING_FOR_IEEE80211MC_AP);
        assertNotNull(
                ""Cannot find any test APs which support RTT / IEEE 802.11mc - please verify that ""
                        + ""your test setup includes them!"", testAp);

        RangingRequest.Builder builder = new RangingRequest.Builder();
        List<ScanResult> scanResults = new ArrayList<>();
        for (int i = 0; i < RangingRequest.getMaxPeers() - 2; ++i) {
            scanResults.add(testAp);
        }
        builder.addAccessPoints(scanResults);

        ScanResult testApNon80211mc = null;
        if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(getContext())) {
            testApNon80211mc = scanForTestNon11mcCapableAp(NUM_SCANS_SEARCHING_FOR_IEEE80211MC_AP);
        }
        if (testApNon80211mc == null) {
            builder.addAccessPoints(List.of(testAp, testAp, testAp));
        } else {
            builder.addNon80211mcCapableAccessPoints(List.of(testApNon80211mc, testApNon80211mc,
                    testApNon80211mc));
        }

        try {
            mWifiRttManager.startRanging(builder.build(), mExecutor, new ResultCallback());
        } catch (IllegalArgumentException e) {
            return;
        }

        fail(""Did not receive expected IllegalArgumentException when tried to range to too ""
                + ""many peers"");
    }

    /**
     * Verify ResponderLocation API
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.net.wifi.rtt.cts.WifiRttTest"	"testRangingToTestApWithResponderLocation"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/rtt/cts/WifiRttTest.java"	""	"public void testRangingToTestApWithResponderLocation() throws InterruptedException {
        if (!shouldTestWifiRtt(getContext())) {
            return;
        }
        // Scan for IEEE 802.11mc supporting APs
        ScanResult testAp = scanForTest11mcCapableAp(NUM_SCANS_SEARCHING_FOR_IEEE80211MC_AP);
        assertNotNull(
                ""Cannot find any test APs which support RTT / IEEE 802.11mc - please verify that ""
                        + ""your test setup includes them!"", testAp);

        // Perform RTT operations
        RangingRequest request = new RangingRequest.Builder().addAccessPoint(testAp).build();
        ResultCallback callback = new ResultCallback();
        mWifiRttManager.startRanging(request, mExecutor, callback);
        assertTrue(""Wi-Fi RTT results: no callback! "",
                callback.waitForCallback());

        RangingResult result = callback.getResults().get(0);
        assertEquals(""Ranging request not success"",
                result.getStatus(), RangingResult.STATUS_SUCCESS);
        ResponderLocation responderLocation = result.getUnverifiedResponderLocation();
        if (responderLocation == null) {
            return;
        }
        assertTrue(""ResponderLocation is not valid"", responderLocation.isLciSubelementValid());

        // Check LCI related APIs
        int exceptionCount = 0;
        int apiCount = 0;
        try {
            apiCount++;
            responderLocation.getLatitudeUncertainty();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }
        try {
            apiCount++;
            responderLocation.getLatitude();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }
        try {
            apiCount++;
            responderLocation.getLongitudeUncertainty();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }
        try {
            apiCount++;
            responderLocation.getLongitude();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }
        try {
            apiCount++;
            responderLocation.getAltitudeType();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }
        try {
            apiCount++;
            responderLocation.getAltitudeUncertainty();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }
        try {
            apiCount++;
            responderLocation.getAltitude();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }
        try {
            apiCount++;
            responderLocation.getDatum();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }
        try {
            apiCount++;
            responderLocation.getRegisteredLocationAgreementIndication();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }
        try {
            apiCount++;
            responderLocation.getLciVersion();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }
        try {
            apiCount++;
            assertNotNull(responderLocation.toLocation());
        } catch (IllegalStateException e) {
            exceptionCount++;
        }
        // If LCI is not valid, all APIs should throw exception, otherwise no exception.
        assertEquals(""Exception number should equal to API number"",
                responderLocation.isLciSubelementValid()? 0 : apiCount, exceptionCount);

        // Verify ZaxisSubelement APIs
        apiCount = 0;
        exceptionCount = 0;

        try {
            apiCount++;
            responderLocation.getExpectedToMove();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }

        try {
            apiCount++;
            responderLocation.getFloorNumber();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }

        try {
            apiCount++;
            responderLocation.getHeightAboveFloorMeters();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }

        try {
            apiCount++;
            responderLocation.getHeightAboveFloorUncertaintyMeters();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }
        // If Zaxis is not valid, all APIs should throw exception, otherwise no exception.
        assertEquals(""Exception number should equal to API number"",
                responderLocation.isZaxisSubelementValid() ? 0 : apiCount, exceptionCount);
        // Verify civic location
        if (responderLocation.toCivicLocationAddress() == null) {
            assertNull(responderLocation.toCivicLocationSparseArray());
        } else {
            assertNotNull(responderLocation.toCivicLocationSparseArray());
        }
        // Verify map image
        if (responderLocation.getMapImageUri() == null) {
            assertNull(responderLocation.getMapImageMimeType());
        } else {
            assertNotNull(responderLocation.getMapImageMimeType());
        }
        boolean extraInfoOnAssociationIndication =
                responderLocation.getExtraInfoOnAssociationIndication();
        assertNotNull(""ColocatedBSSID list should be nonNull"",
                responderLocation.getColocatedBssids());
    }

    /**
     * Verify ranging request with aware peer Mac address and peer handle.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.net.wifi.rtt.cts.WifiRttTest"	"testAwareRttWithPeerHandle"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/rtt/cts/WifiRttTest.java"	""	"public void testAwareRttWithPeerHandle() throws InterruptedException {
        if (!(shouldTestWifiRtt(getContext()) && shouldTestWifiAware(getContext()))) {
            return;
        }
        PeerHandle peerHandle = mock(PeerHandle.class);
        RangingRequest request = new RangingRequest.Builder()
                .addWifiAwarePeer(peerHandle).build();
        ResultCallback callback = new ResultCallback();
        mWifiRttManager.startRanging(request, mExecutor, callback);
        assertTrue(""Wi-Fi RTT results: no callback"",
                callback.waitForCallback());
        List<RangingResult> rangingResults = callback.getResults();
        assertNotNull(""Wi-Fi RTT results: null results"", rangingResults);
        assertEquals(""Invalid peerHandle should return 0 result"", 0, rangingResults.size());
    }

    /**
     * Test Wi-Fi One-sided RTT ranging operation:
     * - Scan for visible APs for the test AP (which do not support IEEE 802.11mc) and are operating
     * - in the 5GHz band.
     * - Perform N (constant) RTT operations
     * - Remove outliers while insuring greater than 50% of the results still remain
     * - Validate:
     *   - Failure ratio < threshold (constant)
     *   - Result margin < threshold (constant)
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.net.wifi.rtt.cts.WifiRttTest"	"testRangingToTestNon11mcAp"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/rtt/cts/WifiRttTest.java"	""	"public void testRangingToTestNon11mcAp() throws InterruptedException {
        if (!shouldTestWifiRtt(getContext())
                || !WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(getContext())) {
            return;
        }

        // Scan for Non-IEEE 802.11mc supporting APs
        ScanResult testAp = scanForTestNon11mcCapableAp(NUM_SCANS_SEARCHING_FOR_IEEE80211MC_AP);
        assertNotNull(
                ""Cannot find any test APs which are Non-IEEE 802.11mc - please verify that""
                        + "" your test setup includes them!"", testAp);

        // Perform RTT operations
        RangingRequest.Builder builder = new RangingRequest.Builder();
        builder.addNon80211mcCapableAccessPoint(testAp);
        builder.setRttBurstSize(RangingRequest.getMaxRttBurstSize());
        RangingRequest request = builder.build();

        List<RangingResult> allResults = new ArrayList<>();
        int numFailures = 0;
        int distanceSum = 0;
        int distanceMin = 0;
        int distanceMax = 0;
        int[] statuses = new int[NUM_OF_RTT_ITERATIONS];
        int[] distanceMms = new int[NUM_OF_RTT_ITERATIONS];
        boolean[] distanceInclusionMap = new boolean[NUM_OF_RTT_ITERATIONS];
        int[] distanceStdDevMms = new int[NUM_OF_RTT_ITERATIONS];
        int[] rssis = new int[NUM_OF_RTT_ITERATIONS];
        int[] numAttempted = new int[NUM_OF_RTT_ITERATIONS];
        int[] numSuccessful = new int[NUM_OF_RTT_ITERATIONS];
        long[] timestampsMs = new long[NUM_OF_RTT_ITERATIONS];
        byte[] lastLci = null;
        byte[] lastLcr = null;
        for (int i = 0; i < NUM_OF_RTT_ITERATIONS; ++i) {
            ResultCallback callback = new ResultCallback();
            mWifiRttManager.startRanging(request, mExecutor, callback);
            assertTrue(""Wi-Fi RTT results: no callback on iteration "" + i,
                    callback.waitForCallback());

            List<RangingResult> currentResults = callback.getResults();
            assertNotNull(
                    ""Wi-Fi RTT results: null results (onRangingFailure) on iteration "" + i,
                    currentResults);
            assertEquals(
                    ""Wi-Fi RTT results: unexpected # of results (expect 1) on iteration "" + i,
                    1, currentResults.size());
            RangingResult result = currentResults.get(0);
            assertEquals(
                    ""Wi-Fi RTT results: invalid result (wrong BSSID) entry on iteration "" + i,
                    result.getMacAddress().toString(), testAp.BSSID);

            assertNull(
                    ""Wi-Fi RTT results: invalid result (non-null PeerHandle) entry on iteration ""
                            + i, result.getPeerHandle());

            allResults.add(result);
            int status = result.getStatus();
            statuses[i] = status;
            if (status == RangingResult.STATUS_SUCCESS) {
                assertFalse(""Wi-Fi RTT results: should not be a 802.11MC measurement"",
                        result.is80211mcMeasurement());
                distanceSum += result.getDistanceMm();

                assertTrue(""Wi-Fi RTT results: invalid RSSI on iteration "" + i,
                        result.getRssi() >= MIN_VALID_RSSI);

                distanceMms[i - numFailures] = result.getDistanceMm();
                distanceStdDevMms[i - numFailures] = result.getDistanceStdDevMm();
                rssis[i - numFailures] = result.getRssi();
                // For one-sided RTT the number of packets attempted in a burst is not available,
                // So we set the result to be the same as used in the request.
                numAttempted[i - numFailures] = request.getRttBurstSize();
                numSuccessful[i - numFailures] = result.getNumSuccessfulMeasurements();
                timestampsMs[i - numFailures] = result.getRangingTimestampMillis();

                byte[] currentLci = result.getLci();
                byte[] currentLcr = result.getLcr();
                if (i - numFailures > 0) {
                    assertTrue(""Wi-Fi RTT results: invalid result (LCI mismatch) on iteration "" + i,
                            Arrays.equals(currentLci, lastLci));
                    assertTrue(""Wi-Fi RTT results: invalid result (LCR mismatch) on iteration "" + i,
                            Arrays.equals(currentLcr, lastLcr));
                }
                lastLci = currentLci;
                lastLcr = currentLcr;
            } else {
                numFailures++;
            }
            // Sleep a while to avoid stress AP.
            Thread.sleep(intervalMs);
        }
        // Save results to log
        int numGoodResults = NUM_OF_RTT_ITERATIONS - numFailures;
        DeviceReportLog reportLog = new DeviceReportLog(TAG, ""testRangingToTestAp"");
        reportLog.addValues(""status_codes"", statuses, ResultType.NEUTRAL, ResultUnit.NONE);
        reportLog.addValues(""distance_mm"", Arrays.copyOf(distanceMms, numGoodResults),
                ResultType.NEUTRAL, ResultUnit.NONE);
        reportLog.addValues(""distance_stddev_mm"",
                Arrays.copyOf(distanceStdDevMms, numGoodResults),
                ResultType.NEUTRAL, ResultUnit.NONE);
        reportLog.addValues(""rssi_dbm"", Arrays.copyOf(rssis, numGoodResults),
                ResultType.NEUTRAL,
                ResultUnit.NONE);
        reportLog.addValues(""num_attempted"", Arrays.copyOf(numAttempted, numGoodResults),
                ResultType.NEUTRAL, ResultUnit.NONE);
        reportLog.addValues(""num_successful"", Arrays.copyOf(numSuccessful, numGoodResults),
                ResultType.NEUTRAL, ResultUnit.NONE);
        reportLog.addValues(""timestamps"", Arrays.copyOf(timestampsMs, numGoodResults),
                ResultType.NEUTRAL, ResultUnit.NONE);
        reportLog.submit();

        /** TODO(b/192909380): enable the performance verification after device fix.
            // Analyze results
            assertTrue(""Wi-Fi RTT failure rate exceeds threshold: FAIL="" + numFailures
                            + "", ITERATIONS=""
                            + NUM_OF_RTT_ITERATIONS + "", AP RSSI="" + testAp.level
                            + "", AP SSID="" + testAp.SSID,
                    numFailures <= NUM_OF_RTT_ITERATIONS * MAX_NON11MC_FAILURE_RATE_PERCENT / 100);

            if (numFailures != NUM_OF_RTT_ITERATIONS) {
                // Calculate an initial average using all measurements to determine distance outliers
                double distanceAvg = (double) distanceSum / (NUM_OF_RTT_ITERATIONS - numFailures);
                // Now figure out the distance outliers and mark them in the distance inclusion map
                int validDistances = 0;
                for (int i = 0; i < (NUM_OF_RTT_ITERATIONS - numFailures); i++) {
                    if (distanceMms[i] - MAX_VARIATION_FROM_AVERAGE_DISTANCE_MM < distanceAvg) {
                        // Distances that are in range for the distribution are included in the map
                        distanceInclusionMap[i] = true;
                        validDistances++;
                    } else {
                        // Distances that are out of range for the distribution are excluded in the map
                        distanceInclusionMap[i] = false;
                    }
                }

                assertTrue(""After fails+outlier removal greater that 50% distances must remain: "" +
                        NUM_OF_RTT_ITERATIONS / 2, validDistances > NUM_OF_RTT_ITERATIONS / 2);

                // Remove the distance outliers and find the new average, min and max.
                distanceSum = 0;
                distanceMax = Integer.MIN_VALUE;
                distanceMin = Integer.MAX_VALUE;
                for (int i = 0; i < (NUM_OF_RTT_ITERATIONS - numFailures); i++) {
                    if (distanceInclusionMap[i]) {
                        distanceSum += distanceMms[i];
                        distanceMin = Math.min(distanceMin, distanceMms[i]);
                        distanceMax = Math.max(distanceMax, distanceMms[i]);
                    }
                }
                distanceAvg = (double) distanceSum / validDistances;
                assertTrue(""Wi-Fi RTT: Variation (max direction) exceeds threshold, Variation =""
                                + (distanceMax - distanceAvg),
                        (distanceMax - distanceAvg) <= MAX_VARIATION_FROM_AVERAGE_DISTANCE_MM);
                assertTrue(""Wi-Fi RTT: Variation (min direction) exceeds threshold, Variation =""
                                + (distanceAvg - distanceMin),
                        (distanceAvg - distanceMin) <= MAX_VARIATION_FROM_AVERAGE_DISTANCE_MM);
                for (int i = 0; i < numGoodResults; ++i) {
                    assertNotSame(""Number of attempted measurements is 0"", 0, numAttempted[i]);
                    assertNotSame(""Number of successful measurements is 0"", 0, numSuccessful[i]);
                }
         */
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.telecom.cts.BaseTelecomTestWithMockServices"	"disableCarMode"	"CtsTelecomTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/BaseTelecomTestWithMockServices.java"	""	"public void test/*
 *.
 */

package android.telecom.cts;

import static android.telecom.cts.TestUtils.PACKAGE;
import static android.telecom.cts.TestUtils.TAG;
import static android.telecom.cts.TestUtils.WAIT_FOR_STATE_CHANGE_TIMEOUT_MS;

import static org.hamcrest.CoreMatchers.equalTo;
import static org.hamcrest.CoreMatchers.not;
import static org.junit.Assert.assertNotEquals;
import static org.junit.Assert.assertThat;

import android.app.AppOpsManager;
import android.app.UiAutomation;
import android.app.UiModeManager;
import android.content.Context;
import android.content.Intent;
import android.content.res.Configuration;
import android.content.pm.PackageManager;
import android.database.ContentObserver;
import android.database.Cursor;
import android.media.AudioManager;
import android.net.Uri;
import android.os.Bundle;
import android.os.Handler;
import android.os.HandlerThread;
import android.os.Looper;
import android.os.RemoteException;
import android.os.Process;
import android.os.UserHandle;
import android.provider.CallLog;
import android.telecom.Call;
import android.telecom.CallAudioState;
import android.telecom.Conference;
import android.telecom.Connection;
import android.telecom.ConnectionRequest;
import android.telecom.InCallService;
import android.telecom.PhoneAccount;
import android.telecom.PhoneAccountHandle;
import android.telecom.TelecomManager;
import android.telecom.VideoProfile;
import android.telecom.cts.MockInCallService.InCallServiceCallbacks;
import android.telecom.cts.carmodetestapp.ICtsCarModeInCallServiceControl;
import android.telephony.PhoneStateListener;
import android.telephony.TelephonyCallback;
import android.telephony.TelephonyManager;
import android.telephony.emergency.EmergencyNumber;
import android.test.InstrumentationTestCase;
import android.text.TextUtils;
import android.util.Log;
import android.util.Pair;

import androidx.test.InstrumentationRegistry;

import com.android.compatibility.common.util.ShellIdentityUtils;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Random;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

/**
 * Base class for Telecom CTS tests that require a {@link CtsConnectionService} and
 * {@link MockInCallService} to verify Telecom functionality.
 */
public class BaseTelecomTestWithMockServices extends InstrumentationTestCase {

    public static final int FLAG_REGISTER = 0x1;
    public static final int FLAG_ENABLE = 0x2;
    public static final int FLAG_SET_DEFAULT = 0x4;

    // Don't accidently use emergency number.
    private static int sCounter = 5553638;

    public static final String TEST_EMERGENCY_NUMBER = ""5553637"";
    public static final Uri TEST_EMERGENCY_URI = Uri.fromParts(""tel"", TEST_EMERGENCY_NUMBER, null);
    public static final String PKG_NAME = ""android.telecom.cts"";
    public static final String PERMISSION_PROCESS_OUTGOING_CALLS =
            ""android.permission.PROCESS_OUTGOING_CALLS"";

    Context mContext;
    TelecomManager mTelecomManager;
    TelephonyManager mTelephonyManager;
    UiModeManager mUiModeManager;

    TestUtils.InvokeCounter mOnBringToForegroundCounter;
    TestUtils.InvokeCounter mOnCallAudioStateChangedCounter;
    TestUtils.InvokeCounter mOnPostDialWaitCounter;
    TestUtils.InvokeCounter mOnCannedTextResponsesLoadedCounter;
    TestUtils.InvokeCounter mOnSilenceRingerCounter;
    TestUtils.InvokeCounter mOnConnectionEventCounter;
    TestUtils.InvokeCounter mOnExtrasChangedCounter;
    TestUtils.InvokeCounter mOnPropertiesChangedCounter;
    TestUtils.InvokeCounter mOnRttModeChangedCounter;
    TestUtils.InvokeCounter mOnRttStatusChangedCounter;
    TestUtils.InvokeCounter mOnRttInitiationFailedCounter;
    TestUtils.InvokeCounter mOnRttRequestCounter;
    TestUtils.InvokeCounter mOnHandoverCompleteCounter;
    TestUtils.InvokeCounter mOnHandoverFailedCounter;
    TestUtils.InvokeCounter mOnPhoneAccountChangedCounter;
    Bundle mPreviousExtras;
    int mPreviousProperties = -1;
    PhoneAccountHandle mPreviousPhoneAccountHandle = null;

    InCallServiceCallbacks mInCallCallbacks;
    String mPreviousDefaultDialer = null;
    PhoneAccountHandle mPreviousDefaultOutgoingAccount = null;
    boolean mShouldRestoreDefaultOutgoingAccount = false;
    MockConnectionService connectionService = null;
    boolean mIsEmergencyCallingSetup = false;

    HandlerThread mTelephonyCallbackThread;
    Handler mTelephonyCallbackHandler;
    TestTelephonyCallback mTelephonyCallback;
    TestCallStateListener mTestCallStateListener;
    Handler mHandler;

    /**
     * Uses the control interface to disable car mode.
     * @param expectedUiMode
     */
    protected void disableAndVerifyCarMode(ICtsCarModeInCallServiceControl control,
            int expectedUiMode) {
        if (control == null) {
            return;
        }
        try {
            control.disableCarMode();
        } catch (RemoteException re) {
            fail(""Bee-boop; can't control the incall service"");
        }
        assertUiMode(expectedUiMode);
    }

    protected void disconnectAllCallsAndVerify(ICtsCarModeInCallServiceControl controlBinder) {
        if (controlBinder == null) {
            return;
        }
        try {
            controlBinder.disconnectCalls();
        } catch (RemoteException re) {
            fail(""Bee-boop; can't control the incall service"");
        }
        assertCarModeCallCount(controlBinder, 0);
    }

    /**
     * Verify the car mode ICS has an expected call count.
     * @param expected
     */
    protected void assertCarModeCallCount(ICtsCarModeInCallServiceControl control, int expected) {
        waitUntilConditionIsTrueOrTimeout(
                new Condition() {
                    @Override
                    public Object expected() {
                        return expected;
                    }

                    @Override
                    public Object actual() {
                        int callCount = 0;
                        try {
                            callCount = control.getCallCount();
                        } catch (RemoteException re) {
                            fail(""Bee-boop; can't control the incall service"");
                        }
                        return callCount;
                    }
                },
                WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                ""Expected "" + expected + "" calls.""
        );
    }

    static class TestCallStateListener extends TelephonyCallback
            implements TelephonyCallback.CallStateListener {

        private CountDownLatch mCountDownLatch = new CountDownLatch(1);
        private int mLastState = -1;

        @Override
        public void onCallStateChanged(int state) {
            Log.i(TAG, ""onCallStateChanged: state="" + state);
            mLastState = state;
            mCountDownLatch.countDown();
            mCountDownLatch = new CountDownLatch(1);
        }

        public CountDownLatch getCountDownLatch() {
            return mCountDownLatch;
        }

        public int getLastState() {
            return mLastState;
        }
    }

    static class TestTelephonyCallback extends TelephonyCallback implements
            TelephonyCallback.CallStateListener,
            TelephonyCallback.OutgoingEmergencyCallListener,
            TelephonyCallback.EmergencyNumberListListener {
        /** Semaphore released for every callback invocation. */
        public Semaphore mCallbackSemaphore = new Semaphore(0);

        List<Integer> mCallStates = new ArrayList<>();
        EmergencyNumber mLastOutgoingEmergencyNumber;

        LinkedBlockingQueue<Map<Integer, List<EmergencyNumber>>> mEmergencyNumberListQueue =
               new LinkedBlockingQueue<>(2);

        @Override
        public void onCallStateChanged(int state) {
            Log.i(TAG, ""onCallStateChanged: state="" + state);
            mCallStates.add(state);
            mCallbackSemaphore.release();
        }

        @Override
        public void onOutgoingEmergencyCall(EmergencyNumber emergencyNumber, int subscriptionId) {
            Log.i(TAG, ""onOutgoingEmergencyCall: emergencyNumber="" + emergencyNumber);
            mLastOutgoingEmergencyNumber = emergencyNumber;
            mCallbackSemaphore.release();
        }

        @Override
        public void onEmergencyNumberListChanged(
                Map<Integer, List<EmergencyNumber>> emergencyNumberList) {
            Log.i(TAG, ""onEmergencyNumberChanged, total size="" + emergencyNumberList.values()
                    .stream().mapToInt(List::size).sum());
            mEmergencyNumberListQueue.offer(emergencyNumberList);
        }

        public Map<Integer, List<EmergencyNumber>> waitForEmergencyNumberListUpdate(
                long timeoutMillis) throws Throwable {
            return mEmergencyNumberListQueue.poll(timeoutMillis, TimeUnit.MILLISECONDS);
        }
    }

    boolean mShouldTestTelecom = true;

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        mContext = getInstrumentation().getContext();
        mHandler = new Handler(Looper.getMainLooper());
        mShouldTestTelecom = TestUtils.shouldTestTelecom(mContext);
        if (!mShouldTestTelecom) {
            return;
        }

        // Assume we start in normal mode at the start of all Telecom tests; a failure to leave car
        // mode in any of the tests would cause subsequent test failures.
        // For Watch, UI_MODE shouldn't be normal mode.
        mUiModeManager = mContext.getSystemService(UiModeManager.class);
        TestUtils.executeShellCommand(getInstrumentation(), ""telecom reset-car-mode"");

        if (mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WATCH)) {
             assertUiMode(Configuration.UI_MODE_TYPE_WATCH);
        } else {
             assertUiMode(Configuration.UI_MODE_TYPE_NORMAL);
        }

        AppOpsManager aom = mContext.getSystemService(AppOpsManager.class);
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(aom,
                (appOpsMan) -> appOpsMan.setUidMode(AppOpsManager.OPSTR_PROCESS_OUTGOING_CALLS,
                Process.myUid(), AppOpsManager.MODE_ALLOWED));

        mTelecomManager = (TelecomManager) mContext.getSystemService(Context.TELECOM_SERVICE);
        mTelephonyManager = (TelephonyManager) mContext.getSystemService(Context.TELEPHONY_SERVICE);

        mPreviousDefaultDialer = TestUtils.getDefaultDialer(getInstrumentation());
        TestUtils.setDefaultDialer(getInstrumentation(), PACKAGE);
        setupCallbacks();

       // Register a call state listener.
        mTestCallStateListener = new TestCallStateListener();
        CountDownLatch latch = mTestCallStateListener.getCountDownLatch();
        mTelephonyManager.registerTelephonyCallback(r -> r.run(), mTestCallStateListener);
        latch.await(
                TestUtils.WAIT_FOR_PHONE_STATE_LISTENER_REGISTERED_TIMEOUT_S, TimeUnit.SECONDS);
        // Create a new thread for the telephony callback.
        mTelephonyCallbackThread = new HandlerThread(""PhoneStateListenerThread"");
        mTelephonyCallbackThread.start();
        mTelephonyCallbackHandler = new Handler(mTelephonyCallbackThread.getLooper());

        mTelephonyCallback = new TestTelephonyCallback();
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mTelephonyManager,
                (tm) -> tm.registerTelephonyCallback(
                        mTelephonyCallbackHandler::post,
                        mTelephonyCallback));
        UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        uiAutomation.grantRuntimePermissionAsUser(PKG_NAME, PERMISSION_PROCESS_OUTGOING_CALLS,
                UserHandle.CURRENT);
    }

    @Override
    protected void tearDown() throws Exception {
        super.tearDown();
        if (!mShouldTestTelecom) {
            return;
        }

        mTelephonyManager.unregisterTelephonyCallback(mTestCallStateListener);

        mTelephonyManager.unregisterTelephonyCallback(mTelephonyCallback);
        mTelephonyCallbackThread.quit();

        cleanupCalls();
        if (!TextUtils.isEmpty(mPreviousDefaultDialer)) {
            TestUtils.setDefaultDialer(getInstrumentation(), mPreviousDefaultDialer);
        }
        tearDownConnectionService(TestUtils.TEST_PHONE_ACCOUNT_HANDLE);
        tearDownEmergencyCalling();
        try {
            assertMockInCallServiceUnbound();
        } catch (Throwable t) {
            // If we haven't unbound, that means there's some dirty state in Telecom that needs
            // cleaning up. Forcibly unbind and clean up Telecom state so that we don't have a
            // cascading failure of tests.
            TestUtils.executeShellCommand(getInstrumentation(), ""telecom cleanup-stuck-calls"");
            throw t;
        }
        UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        uiAutomation.revokeRuntimePermissionAsUser(PKG_NAME, PERMISSION_PROCESS_OUTGOING_CALLS,
                UserHandle.CURRENT);
    }

    protected PhoneAccount setupConnectionService(MockConnectionService connectionService,
            int flags) throws Exception {
        Log.i(TAG, ""Setting up mock connection service"");
        if (connectionService != null) {
            this.connectionService = connectionService;
        } else {
            // Generate a vanilla mock connection service, if not provided.
            this.connectionService = new MockConnectionService();
        }
        CtsConnectionService.setUp(this.connectionService);

        if ((flags & FLAG_REGISTER) != 0) {
            mTelecomManager.registerPhoneAccount(TestUtils.TEST_PHONE_ACCOUNT);
        }
        if ((flags & FLAG_ENABLE) != 0) {
            TestUtils.enablePhoneAccount(getInstrumentation(), TestUtils.TEST_PHONE_ACCOUNT_HANDLE);
            // Wait till the adb commands have executed and account is enabled in Telecom database.
            assertPhoneAccountEnabled(TestUtils.TEST_PHONE_ACCOUNT_HANDLE);
        }

        if ((flags & FLAG_SET_DEFAULT) != 0) {
            mPreviousDefaultOutgoingAccount = mTelecomManager.getUserSelectedOutgoingPhoneAccount();
            mShouldRestoreDefaultOutgoingAccount = true;
            TestUtils.setDefaultOutgoingPhoneAccount(getInstrumentation(),
                    TestUtils.TEST_PHONE_ACCOUNT_HANDLE);
            // Wait till the adb commands have executed and the default has changed.
            assertPhoneAccountIsDefault(TestUtils.TEST_PHONE_ACCOUNT_HANDLE);
        }

        return TestUtils.TEST_PHONE_ACCOUNT;
    }

    protected void tearDownConnectionService(PhoneAccountHandle accountHandle) throws Exception {
        Log.i(TAG, ""Tearing down mock connection service"");
        if (this.connectionService != null) {
            assertNumConnections(this.connectionService, 0);
        }
        mTelecomManager.unregisterPhoneAccount(accountHandle);
        CtsConnectionService.tearDown();
        assertCtsConnectionServiceUnbound();
        if (mShouldRestoreDefaultOutgoingAccount) {
            TestUtils.setDefaultOutgoingPhoneAccount(getInstrumentation(),
                    mPreviousDefaultOutgoingAccount);
        }
        this.connectionService = null;
        mPreviousDefaultOutgoingAccount = null;
        mShouldRestoreDefaultOutgoingAccount = false;
    }

    protected void setupForEmergencyCalling(String testNumber) throws Exception {
        TestUtils.setSystemDialerOverride(getInstrumentation());
        TestUtils.addTestEmergencyNumber(getInstrumentation(), testNumber);
        TestUtils.setTestEmergencyPhoneAccountPackageFilter(getInstrumentation(), mContext);
        // Emergency calls require special capabilities.
        TestUtils.registerEmergencyPhoneAccount(getInstrumentation(),
                TestUtils.TEST_EMERGENCY_PHONE_ACCOUNT_HANDLE,
                TestUtils.ACCOUNT_LABEL + ""E"", ""tel:555-EMER"");
        mIsEmergencyCallingSetup = true;
    }

    protected void tearDownEmergencyCalling() throws Exception {
        if (!mIsEmergencyCallingSetup) return;

        TestUtils.clearSystemDialerOverride(getInstrumentation());
        TestUtils.clearTestEmergencyNumbers(getInstrumentation());
        TestUtils.clearTestEmergencyPhoneAccountPackageFilter(getInstrumentation());
        mTelecomManager.unregisterPhoneAccount(TestUtils.TEST_EMERGENCY_PHONE_ACCOUNT_HANDLE);
    }

    protected void startCallTo(Uri address, PhoneAccountHandle accountHandle) {
        final Intent intent = new Intent(Intent.ACTION_CALL, address);
        if (accountHandle != null) {
            intent.putExtra(TelecomManager.EXTRA_PHONE_ACCOUNT_HANDLE, accountHandle);
        }
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        mContext.startActivity(intent);
    }

    void sleep(long ms) {
        try {
            Thread.sleep(ms);
        } catch (InterruptedException e) {
        }
    }

    private void setupCallbacks() {
        mInCallCallbacks = new InCallServiceCallbacks() {
            @Override
            public void onCallAdded(Call call, int numCalls) {
                Log.i(TAG, ""onCallAdded, Call: "" + call + "", Num Calls: "" + numCalls);
                this.lock.release();
                mPreviousPhoneAccountHandle = call.getDetails().getAccountHandle();
            }
            @Override
            public void onCallRemoved(Call call, int numCalls) {
                Log.i(TAG, ""onCallRemoved, Call: "" + call + "", Num Calls: "" + numCalls);
            }
            @Override
            public void onParentChanged(Call call, Call parent) {
                Log.i(TAG, ""onParentChanged, Call: "" + call + "", Parent: "" + parent);
                this.lock.release();
            }
            @Override
            public void onChildrenChanged(Call call, List<Call> children) {
                Log.i(TAG, ""onChildrenChanged, Call: "" + call + ""Children: "" + children);
                this.lock.release();
            }
            @Override
            public void onConferenceableCallsChanged(Call call, List<Call> conferenceableCalls) {
                Log.i(TAG, ""onConferenceableCallsChanged, Call: "" + call + "", Conferenceables: "" +
                        conferenceableCalls);
            }
            @Override
            public void onDetailsChanged(Call call, Call.Details details) {
                Log.i(TAG, ""onDetailsChanged, Call: "" + call + "", Details: "" + details);
                if (!areBundlesEqual(mPreviousExtras, details.getExtras())) {
                    mOnExtrasChangedCounter.invoke(call, details);
                }
                mPreviousExtras = details.getExtras();

                if (mPreviousProperties != details.getCallProperties()) {
                    mOnPropertiesChangedCounter.invoke(call, details);
                    Log.i(TAG, ""onDetailsChanged; properties changed from "" + Call.Details.propertiesToString(mPreviousProperties) +
                            "" to "" + Call.Details.propertiesToString(details.getCallProperties()));
                }
                mPreviousProperties = details.getCallProperties();

                if (details.getAccountHandle() != null &&
                        !details.getAccountHandle().equals(mPreviousPhoneAccountHandle)) {
                    mOnPhoneAccountChangedCounter.invoke(call, details.getAccountHandle());
                }
                mPreviousPhoneAccountHandle = details.getAccountHandle();
            }
            @Override
            public void onCallDestroyed(Call call) {
                Log.i(TAG, ""onCallDestroyed, Call: "" + call);
            }
            @Override
            public void onCallStateChanged(Call call, int newState) {
                Log.i(TAG, ""onCallStateChanged, Call: "" + call + "", New State: "" + newState);
            }
            @Override
            public void onBringToForeground(boolean showDialpad) {
                mOnBringToForegroundCounter.invoke(showDialpad);
            }
            @Override
            public void onCallAudioStateChanged(CallAudioState audioState) {
                Log.i(TAG, ""onCallAudioStateChanged, audioState: "" + audioState);
                mOnCallAudioStateChangedCounter.invoke(audioState);
            }
            @Override
            public void onPostDialWait(Call call, String remainingPostDialSequence) {
                mOnPostDialWaitCounter.invoke(call, remainingPostDialSequence);
            }
            @Override
            public void onCannedTextResponsesLoaded(Call call, List<String> cannedTextResponses) {
                mOnCannedTextResponsesLoadedCounter.invoke(call, cannedTextResponses);
            }
            @Override
            public void onConnectionEvent(Call call, String event, Bundle extras) {
                mOnConnectionEventCounter.invoke(call, event, extras);
            }

            @Override
            public void onSilenceRinger() {
                Log.i(TAG, ""onSilenceRinger"");
                mOnSilenceRingerCounter.invoke();
            }

            @Override
            public void onRttModeChanged(Call call, int mode) {
                mOnRttModeChangedCounter.invoke(call, mode);
            }

            @Override
            public void onRttStatusChanged(Call call, boolean enabled, Call.RttCall rttCall) {
                mOnRttStatusChangedCounter.invoke(call, enabled, rttCall);
            }

            @Override
            public void onRttRequest(Call call, int id) {
                mOnRttRequestCounter.invoke(call, id);
            }

            @Override
            public void onRttInitiationFailure(Call call, int reason) {
                mOnRttInitiationFailedCounter.invoke(call, reason);
            }

            @Override
            public void onHandoverComplete(Call call) {
                mOnHandoverCompleteCounter.invoke(call);
            }

            @Override
            public void onHandoverFailed(Call call, int reason) {
                mOnHandoverFailedCounter.invoke(call, reason);
            }
        };

        MockInCallService.setCallbacks(mInCallCallbacks);

        // TODO: If more InvokeCounters are added in the future, consider consolidating them into a
        // single Collection.
        mOnBringToForegroundCounter = new TestUtils.InvokeCounter(""OnBringToForeground"");
        mOnCallAudioStateChangedCounter = new TestUtils.InvokeCounter(""OnCallAudioStateChanged"");
        mOnPostDialWaitCounter = new TestUtils.InvokeCounter(""OnPostDialWait"");
        mOnCannedTextResponsesLoadedCounter = new TestUtils.InvokeCounter(""OnCannedTextResponsesLoaded"");
        mOnSilenceRingerCounter = new TestUtils.InvokeCounter(""OnSilenceRinger"");
        mOnConnectionEventCounter = new TestUtils.InvokeCounter(""OnConnectionEvent"");
        mOnExtrasChangedCounter = new TestUtils.InvokeCounter(""OnDetailsChangedCounter"");
        mOnPropertiesChangedCounter = new TestUtils.InvokeCounter(""OnPropertiesChangedCounter"");
        mOnRttModeChangedCounter = new TestUtils.InvokeCounter(""mOnRttModeChangedCounter"");
        mOnRttStatusChangedCounter = new TestUtils.InvokeCounter(""mOnRttStatusChangedCounter"");
        mOnRttInitiationFailedCounter =
                new TestUtils.InvokeCounter(""mOnRttInitiationFailedCounter"");
        mOnRttRequestCounter = new TestUtils.InvokeCounter(""mOnRttRequestCounter"");
        mOnHandoverCompleteCounter = new TestUtils.InvokeCounter(""mOnHandoverCompleteCounter"");
        mOnHandoverFailedCounter = new TestUtils.InvokeCounter(""mOnHandoverFailedCounter"");
        mOnPhoneAccountChangedCounter = new TestUtils.InvokeCounter(
                ""mOnPhoneAccountChangedCounter"");
    }

    void addAndVerifyNewFailedIncomingCall(Uri incomingHandle, Bundle extras) {
        assertEquals(""Lock should have no permits!"", 0, mInCallCallbacks.lock.availablePermits());
        int currentCallCount = 0;
        if (mInCallCallbacks.getService() != null) {
            currentCallCount = mInCallCallbacks.getService().getCallCount();
        }

        if (extras == null) {
            extras = new Bundle();
        }
        extras.putParcelable(TelecomManager.EXTRA_INCOMING_CALL_ADDRESS, incomingHandle);
        mTelecomManager.addNewIncomingCall(TestUtils.TEST_PHONE_ACCOUNT_HANDLE, extras);

        if (!connectionService.waitForEvent(
                MockConnectionService.EVENT_CONNECTION_SERVICE_CREATE_CONNECTION_FAILED)) {
            fail(""Incoming Connection failure indication did not get called."");
        }

        assertEquals(""ConnectionService did not receive failed connection"",
                1, connectionService.failedConnections.size());

        assertEquals(""Address is not correct for failed connection"",
                connectionService.failedConnections.get(0).getAddress(), incomingHandle);

        assertEquals(""InCallService should contain the same number of calls."",
                currentCallCount,
                mInCallCallbacks.getService().getCallCount());
    }

    /**
     * Puts Telecom in a state where there is an incoming call provided by the
     * {@link CtsConnectionService} which can be tested.
     */
    void addAndVerifyNewIncomingCall(Uri incomingHandle, Bundle extras) {
        int currentCallCount = addNewIncomingCall(incomingHandle, extras);
        verifyNewIncomingCall(currentCallCount);
    }

    int addNewIncomingCall(Uri incomingHandle, Bundle extras) {
        assertEquals(""Lock should have no permits!"", 0, mInCallCallbacks.lock.availablePermits());
        int currentCallCount = 0;
        if (mInCallCallbacks.getService() != null) {
            currentCallCount = mInCallCallbacks.getService().getCallCount();
        }

        if (extras == null) {
            extras = new Bundle();
        }
        extras.putParcelable(TelecomManager.EXTRA_INCOMING_CALL_ADDRESS, incomingHandle);
        mTelecomManager.addNewIncomingCall(TestUtils.TEST_PHONE_ACCOUNT_HANDLE, extras);

        return currentCallCount;
    }

    void verifyNewIncomingCall(int currentCallCount) {
        try {
            if (!mInCallCallbacks.lock.tryAcquire(TestUtils.WAIT_FOR_CALL_ADDED_TIMEOUT_S,
                    TimeUnit.SECONDS)) {
                fail(""No call added to InCallService."");
            }
        } catch (InterruptedException e) {
            Log.i(TAG, ""Test interrupted!"");
        }

        assertEquals(""InCallService should contain 1 more call after adding a call."",
                currentCallCount + 1,
                mInCallCallbacks.getService().getCallCount());
    }

    /**
     *  Puts Telecom in a state where there is an active call provided by the
     *  {@link CtsConnectionService} which can be tested.
     */
    void placeAndVerifyCall() {
        placeAndVerifyCall(null);
    }

    void placeAndVerifyCallByRedirection(boolean wasCancelled) {
        placeAndVerifyCallByRedirection(null, wasCancelled);
    }

    /**
     *  Puts Telecom in a state where there is an active call provided by the
     *  {@link CtsConnectionService} which can be tested.
     */
    void placeAndVerifyCallByRedirection(Bundle extras, boolean wasCancelled) {
        int currentCallCount = (getInCallService() == null) ? 0 : getInCallService().getCallCount();
        int currentConnections = getNumberOfConnections();
        // We expect a new connection if it wasn't cancelled.
        if (!wasCancelled) {
            currentConnections++;
            currentCallCount++;
        }
        placeAndVerifyCall(extras, VideoProfile.STATE_AUDIO_ONLY, currentConnections,
                currentCallCount);
        // Ensure the new outgoing call broadcast fired for the outgoing call.
        assertOutgoingCallBroadcastReceived(true);

        // CTS test does not have read call log permission so should not get the phone number.
        assertNull(NewOutgoingCallBroadcastReceiver.getReceivedNumber());
    }

    /**
     *  Puts Telecom in a state where there is an active call provided by the
     *  {@link CtsConnectionService} which can be tested.
     *
     *  @param videoState the video state of the call.
     */
    void placeAndVerifyCall(int videoState) {
        placeAndVerifyCall(null, videoState);
    }

    /**
     *  Puts Telecom in a state where there is an active call provided by the
     *  {@link CtsConnectionService} which can be tested.
     */
    void placeAndVerifyCall(Bundle extras) {
        placeAndVerifyCall(extras, VideoProfile.STATE_AUDIO_ONLY);
    }

    /**
     *  Puts Telecom in a state where there is an active call provided by the
     *  {@link CtsConnectionService} which can be tested.
     */
    void placeAndVerifyCall(Bundle extras, int videoState) {
        int currentCallCount = (getInCallService() == null) ? 0 : getInCallService().getCallCount();
        // We expect placing the call adds a new call/connection.
        placeAndVerifyCall(extras, videoState, getNumberOfConnections() + 1, currentCallCount + 1);
        assertOutgoingCallBroadcastReceived(true);

        // CTS test does not have read call log permission so should not get the phone number.
        assertNull(NewOutgoingCallBroadcastReceiver.getReceivedNumber());
    }

    /**
     *  Puts Telecom in a state where there is an active call provided by the
     *  {@link CtsConnectionService} which can be tested.
     */
    void placeAndVerifyCall(Bundle extras, int videoState, int expectedConnectionCount,
            int expectedCallCount) {
        assertEquals(""Lock should have no permits!"", 0, mInCallCallbacks.lock.availablePermits());
        placeNewCallWithPhoneAccount(extras, videoState);

        try {
            if (!mInCallCallbacks.lock.tryAcquire(TestUtils.WAIT_FOR_CALL_ADDED_TIMEOUT_S,
                        TimeUnit.SECONDS)) {
                fail(""No call added to InCallService."");
            }
        } catch (InterruptedException e) {
            Log.i(TAG, ""Test interrupted!"");
        }

        // Make sure any procedures to disconnect existing calls (makeRoomForOutgoingCall)
        // complete successfully
        TestUtils.waitOnLocalMainLooper(WAIT_FOR_STATE_CHANGE_TIMEOUT_MS);
        TestUtils.waitOnAllHandlers(getInstrumentation());

        assertEquals(""InCallService should match the expected count."", expectedCallCount,
                mInCallCallbacks.getService().getCallCount());

        // The connectionService.lock is released in
        // MockConnectionService#onCreateOutgoingConnection, however the connection will not
        // actually be added to the list of connections in the ConnectionService until shortly
        // afterwards.  So there is still a potential for the lock to be released before it would
        // be seen by calls to ConnectionService#getAllConnections().
        // We will wait here until the list of connections includes one more connection to ensure
        // that placing the call has fully completed.
        assertCSConnections(expectedConnectionCount);
    }

    /**
     * Place an emergency call and verify that it has been setup properly.
     *
     * @param supportsHold If telecom supports holding emergency calls, this will expect two
     * calls. If telecom does not support holding emergency calls, this will expect only the
     * emergency call to be active.
     * @return The emergency connection
     */
    public Connection placeAndVerifyEmergencyCall(boolean supportsHold) {
        Bundle extras = new Bundle();
        extras.putParcelable(TestUtils.EXTRA_PHONE_NUMBER, TEST_EMERGENCY_URI);
        int currentConnectionCount = supportsHold ?
                getNumberOfConnections() + 1 : getNumberOfConnections();
        int currentCallCount = (getInCallService() == null) ? 0 : getInCallService().getCallCount();
        currentCallCount = supportsHold ? currentCallCount + 1 : currentCallCount;
        // The device only supports a max of two calls active at any one time
        currentCallCount = Math.min(currentCallCount, 2);
        placeAndVerifyCall(extras, VideoProfile.STATE_AUDIO_ONLY, currentConnectionCount,
                currentCallCount);
        assertOutgoingCallBroadcastReceived(true);
        Connection connection = verifyConnectionForOutgoingCall(TEST_EMERGENCY_URI);
        TestUtils.waitOnAllHandlers(getInstrumentation());
        return connection;
    }

    int getNumberOfConnections() {
        return CtsConnectionService.getAllConnectionsFromTelecom().size();
    }

    Connection getConnection(Uri address) {
        return CtsConnectionService.getAllConnectionsFromTelecom().stream()
                .filter(c -> c.getAddress().equals(address)).findFirst().orElse(null);
    }

    MockConnection verifyConnectionForOutgoingCall() {
        // Assuming only 1 connection present
        return verifyConnectionForOutgoingCall(0);
    }

    MockConnection verifyConnectionForOutgoingCall(int connectionIndex) {
        try {
            if (!connectionService.lock.tryAcquire(TestUtils.WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                    TimeUnit.MILLISECONDS)) {
                fail(""No outgoing call connection requested by Telecom"");
            }
        } catch (InterruptedException e) {
            Log.i(TAG, ""Test interrupted!"");
        }

        assertThat(""Telecom should create outgoing connection for outgoing call"",
                connectionService.outgoingConnections.size(), not(equalTo(0)));
        MockConnection connection = connectionService.outgoingConnections.get(connectionIndex);
        return connection;
    }

    MockConnection verifyConnectionForOutgoingCall(Uri address) {
        if (!connectionService.waitForEvent(
                MockConnectionService.EVENT_CONNECTION_SERVICE_CREATE_CONNECTION)) {
            fail(""No outgoing call connection requested by Telecom"");
        }
        assertThat(""Telecom should create outgoing connection for outgoing call"",
                connectionService.outgoingConnections.size(), not(equalTo(0)));

        // There is a subtle race condition in ConnectionService.  When onCreateIncomingConnection
        // or onCreateOutgoingConnection completes, ConnectionService then adds the connection to
        // the list of tracked connections.  It's very possible for the lock to be released and
        // the connection to have not yet been added to the connection list yet.
        waitUntilConditionIsTrueOrTimeout(new Condition() {
                                              @Override
                                              public Object expected() {
                                                  return true;
                                              }

                                              @Override
                                              public Object actual() {
                                                  return getConnection(address) != null;
                                              }
                                          },
                WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                ""Expected call from number "" + address);
        Connection connection = getConnection(address);

        if (connection instanceof MockConnection) {
            if (connectionService.outgoingConnections.contains(connection)) {
                return (MockConnection) connection;
            }
        }
        return null;
    }

    MockConnection verifyConnectionForIncomingCall() {
        // Assuming only 1 connection present
        return verifyConnectionForIncomingCall(0);
    }

    MockConnection verifyConnectionForIncomingCall(int connectionIndex) {
        try {
            if (!connectionService.lock.tryAcquire(TestUtils.WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                    TimeUnit.MILLISECONDS)) {
                fail(""No outgoing call connection requested by Telecom"");
            }
        } catch (InterruptedException e) {
            Log.i(TAG, ""Test interrupted!"");
        }

        assertThat(""Telecom should create incoming connections for incoming calls"",
                connectionService.incomingConnections.size(), not(equalTo(0)));
        MockConnection connection = connectionService.incomingConnections.get(connectionIndex);
        setAndVerifyConnectionForIncomingCall(connection);
        return connection;
    }

    MockConference verifyConference(int permit) {
        try {
            if (!connectionService.lock.tryAcquire(permit, WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                    TimeUnit.MILLISECONDS)) {
                fail(""No conference requested by Telecom"");
            }
        } catch (InterruptedException e) {
            Log.i(TAG, ""Test interrupted!"");
        }
        return connectionService.conferences.get(0);
    }

    void setAndVerifyConnectionForIncomingCall(MockConnection connection) {
        if (connection.getState() == Connection.STATE_ACTIVE) {
            // If the connection is already active (like if it got picked up immediately), don't
            // bother with setting it back to ringing.
            return;
        }
        connection.setRinging();
        assertConnectionState(connection, Connection.STATE_RINGING);
    }

    void setAndVerifyConferenceablesForOutgoingConnection(int connectionIndex) {
        assertEquals(""Lock should have no permits!"", 0, mInCallCallbacks.lock.availablePermits());
        // Make all other outgoing connections as conferenceable with this connection.
        MockConnection connection = connectionService.outgoingConnections.get(connectionIndex);
        List<Connection> confConnections =
                new ArrayList<>(connectionService.outgoingConnections.size());
        for (Connection c : connectionService.outgoingConnections) {
            if (c != connection) {
                confConnections.add(c);
            }
        }
        connection.setConferenceableConnections(confConnections);
        assertEquals(connection.getConferenceables(), confConnections);
    }

    void addConferenceCall(Call call1, Call call2) {
        assertEquals(""Lock should have no permits!"", 0, mInCallCallbacks.lock.availablePermits());
        int currentConfCallCount = 0;
        if (mInCallCallbacks.getService() != null) {
            currentConfCallCount = mInCallCallbacks.getService().getConferenceCallCount();
        }
        // Verify that the calls have each other on their conferenceable list before proceeding
        List<Call> callConfList = new ArrayList<>();
        callConfList.add(call2);
        assertCallConferenceableList(call1, callConfList);

        callConfList.clear();
        callConfList.add(call1);
        assertCallConferenceableList(call2, callConfList);

        call1.conference(call2);

        /**
         * We should have 1 onCallAdded, 2 onChildrenChanged and 2 onParentChanged invoked, so
         * we should have 5 available permits on the incallService lock.
         */
        try {
            if (!mInCallCallbacks.lock.tryAcquire(5, 3, TimeUnit.SECONDS)) {
                fail(""Conference addition failed."");
            }
        } catch (InterruptedException e) {
            Log.i(TAG, ""Test interrupted!"");
        }

        assertEquals(""InCallService should contain 1 more call after adding a conf call."",
                currentConfCallCount + 1,
                mInCallCallbacks.getService().getConferenceCallCount());
    }

    void splitFromConferenceCall(Call call1) {
        assertEquals(""Lock should have no permits!"", 0, mInCallCallbacks.lock.availablePermits());

        call1.splitFromConference();
        /**
         * We should have 1 onChildrenChanged and 1 onParentChanged invoked, so
         * we should have 2 available permits on the incallService lock.
         */
        try {
            if (!mInCallCallbacks.lock.tryAcquire(2, 3, TimeUnit.SECONDS)) {
                fail(""Conference split failed"");
            }
        } catch (InterruptedException e) {
            Log.i(TAG, ""Test interrupted!"");
        }
    }

    MockConference verifyConferenceForOutgoingCall() {
        try {
            if (!connectionService.lock.tryAcquire(TestUtils.WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                    TimeUnit.MILLISECONDS)) {
                fail(""No outgoing conference requested by Telecom"");
            }
        } catch (InterruptedException e) {
            Log.i(TAG, ""Test interrupted!"");
        }
        // Return the newly created conference object to the caller
        MockConference conference = connectionService.conferences.get(0);
        setAndVerifyConferenceForOutgoingCall(conference);
        return conference;
    }

    Pair<Conference, ConnectionRequest> verifyAdhocConferenceCall() {
        try {
            if (!connectionService.lock.tryAcquire(2, WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                    TimeUnit.MILLISECONDS)) {
                fail(""No conference requested by Telecom"");
            }
        } catch (InterruptedException e) {
            Log.i(TAG, ""Test interrupted!"");
        }
        return new Pair<>(connectionService.conferences.get(0),
                connectionService.connectionRequest);
    }

    void setAndVerifyConferenceForOutgoingCall(MockConference conference) {
        conference.setActive();
        assertConferenceState(conference, Connection.STATE_ACTIVE);
    }

    void verifyCallStateListener(int expectedCallState) throws InterruptedException {
        mTestCallStateListener.getCountDownLatch().await(
                TestUtils.WAIT_FOR_PHONE_STATE_LISTENER_CALLBACK_TIMEOUT_S, TimeUnit.SECONDS);
        assertEquals(expectedCallState, mTestCallStateListener.getLastState());
    }

    void verifyPhoneStateListenerCallbacksForCall(int expectedCallState, String expectedNumber)
            throws Exception {
        assertTrue(mTelephonyCallback.mCallbackSemaphore.tryAcquire(
                TestUtils.WAIT_FOR_PHONE_STATE_LISTENER_CALLBACK_TIMEOUT_S, TimeUnit.SECONDS));
        // At this point we can only be sure that we got AN update, but not necessarily the one we
        // are looking for; wait until we see the state we want before verifying further.
        waitUntilConditionIsTrueOrTimeout(new Condition() {
                                              @Override
                                              public Object expected() {
                                                  return true;
                                              }

                                              @Override
                                              public Object actual() {
                                                  return mTelephonyCallback.mCallStates
                                                          .stream()
                                                          .filter(p -> p == expectedCallState)
                                                          .count() > 0;
                                              }
                                          },
                WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                ""Expected call state "" + expectedCallState + "" and number ""
                        + expectedNumber);


        // Get the most recent callback; it is possible that there was an initial state reported due
        // to the fact that TelephonyManager will sometimes give an initial state back to the caller
        // when the listener is registered.
        int callState = mTelephonyCallback.mCallStates.get(
                mTelephonyCallback.mCallStates.size() - 1);
        assertEquals(expectedCallState, callState);
        // Note: We do NOT check the phone number here.  Due to changes in how the phone state
        // broadcast is sent, the caller may receive multiple broadcasts, and the number will be
        // present in one or the other.  We waited for a full matching broadcast above so we can
        // be sure the number was reported as expected.
    }

    void verifyPhoneStateListenerCallbacksForEmergencyCall(String expectedNumber)
        throws Exception {
        assertTrue(mTelephonyCallback.mCallbackSemaphore.tryAcquire(
            TestUtils.WAIT_FOR_PHONE_STATE_LISTENER_CALLBACK_TIMEOUT_S, TimeUnit.SECONDS));
        // At this point we can only be sure that we got AN update, but not necessarily the one we
        // are looking for; wait until we see the state we want before verifying further.
        waitUntilConditionIsTrueOrTimeout(new Condition() {
                                              @Override
                                              public Object expected() {
                                                  return true;
                                              }

                                              @Override
                                              public Object actual() {
                                                  return mTelephonyCallback
                                                      .mLastOutgoingEmergencyNumber != null
                                                      && mTelephonyCallback
                                                      .mLastOutgoingEmergencyNumber.getNumber()
                                                      .equals(expectedNumber);
                                              }
                                          },
            WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
            ""Expected emergency number: "" + expectedNumber);

        assertEquals(mTelephonyCallback.mLastOutgoingEmergencyNumber.getNumber(),
            expectedNumber);
    }

    /**
     * Disconnect the created test call and verify that Telecom has cleared all calls.
     */
    void cleanupCalls() {
        if (mInCallCallbacks != null && mInCallCallbacks.getService() != null) {
            mInCallCallbacks.getService().disconnectAllConferenceCalls();
            mInCallCallbacks.getService().disconnectAllCalls();
            assertNumConferenceCalls(mInCallCallbacks.getService(), 0);
            assertNumCalls(mInCallCallbacks.getService(), 0);
        }
    }

    /**
     * Place a new outgoing call via the {@link CtsConnectionService}
     */
    private void placeNewCallWithPhoneAccount(Bundle extras, int videoState) {
        if (extras == null) {
            extras = new Bundle();
        }
        if (!extras.containsKey(TelecomManager.EXTRA_PHONE_ACCOUNT_HANDLE)) {
            extras.putParcelable(TelecomManager.EXTRA_PHONE_ACCOUNT_HANDLE,
                    TestUtils.TEST_PHONE_ACCOUNT_HANDLE);
        }

        if (!VideoProfile.isAudioOnly(videoState)) {
            extras.putInt(TelecomManager.EXTRA_START_CALL_WITH_VIDEO_STATE, videoState);
        }
        Uri number;
        if (extras.containsKey(TestUtils.EXTRA_PHONE_NUMBER)) {
            number = extras.getParcelable(TestUtils.EXTRA_PHONE_NUMBER);
        } else {
            number = createTestNumber();
        }
        mTelecomManager.placeCall(number, extras);
    }

    /**
     * Create a new number each time for a new test. Telecom has special logic to reuse certain
     * calls if multiple calls to the same number are placed within a short period of time which
     * can cause certain tests to fail.
     */
    Uri createTestNumber() {
        return Uri.fromParts(""tel"", String.valueOf(++sCounter), null);
    }

    /**
     * Creates a new random phone number in the range:
     * 000-000-0000
     * to
     * 999-999-9999
     * @return Randomized phone number.
     */
    Uri createRandomTestNumber() {
        return Uri.fromParts(""tel"", String.format(""16%05d"", new Random().nextInt(99999))
                + String.format(""%04d"", new Random().nextInt(9999)), null);
    }

    public static Uri getTestNumber() {
        return Uri.fromParts(""tel"", String.valueOf(sCounter), null);
    }

    public boolean isLoggedCall(PhoneAccountHandle handle) {
        PhoneAccount phoneAccount = mTelecomManager.getPhoneAccount(handle);
        Bundle extras = phoneAccount.getExtras();
        if (extras == null) {
            extras = new Bundle();
        }
        boolean isSelfManaged = (phoneAccount.getCapabilities()
                & PhoneAccount.CAPABILITY_SELF_MANAGED) == PhoneAccount.CAPABILITY_SELF_MANAGED;
        // Calls are logged if:
        // 1. They're not self-managed
        // 2. They're self-managed and are configured to request logging.
        return (!isSelfManaged
                || (isSelfManaged
                && extras.getBoolean(PhoneAccount.EXTRA_LOG_SELF_MANAGED_CALLS)
                && (phoneAccount.getSupportedUriSchemes().contains(PhoneAccount.SCHEME_TEL)
                || phoneAccount.getSupportedUriSchemes().contains(PhoneAccount.SCHEME_SIP))));
    }

    public CountDownLatch getCallLogEntryLatch() {
        CountDownLatch changeLatch = new CountDownLatch(1);
        mContext.getContentResolver().registerContentObserver(
                CallLog.Calls.CONTENT_URI, true,
                new ContentObserver(mHandler) {
                    @Override
                    public void onChange(boolean selfChange, Uri uri) {
                        mContext.getContentResolver().unregisterContentObserver(this);
                        changeLatch.countDown();
                        super.onChange(selfChange);
                    }
                });
        return changeLatch;
    }


    public void verifyCallLogging(CountDownLatch logLatch, boolean isCallLogged, Uri testNumber) {
        Cursor logCursor = getLatestCallLogCursorIfMatchesUri(logLatch, isCallLogged, testNumber);
        if (isCallLogged) {
            assertNotNull(""Call log entry not found for test number"", logCursor);
        }
    }

    public void verifyCallLogging(Uri testNumber, int expectedLogType) {
        CountDownLatch logLatch = getCallLogEntryLatch();
        Cursor logCursor = getLatestCallLogCursorIfMatchesUri(logLatch, true /*isCallLogged*/,
                testNumber);
        assertNotNull(""Call log entry not found for test number"", logCursor);
        int typeIndex = logCursor.getColumnIndex(CallLog.Calls.TYPE);
        int type = logCursor.getInt(typeIndex);
        assertEquals(""recorded type does not match expected"", expectedLogType, type);
    }

    public Cursor getLatestCallLogCursorIfMatchesUri(CountDownLatch latch, boolean newLogExpected,
            Uri testNumber) {
        if (newLogExpected) {
            // Wait for the content observer to report that we have gotten a new call log entry.
            try {
                latch.await(WAIT_FOR_STATE_CHANGE_TIMEOUT_MS, TimeUnit.MILLISECONDS);
            } catch (InterruptedException ie) {
                fail(""Expected log latch"");
            }
        }

        // Query the latest entry into the call log.
        Cursor callsCursor = mContext.getContentResolver().query(CallLog.Calls.CONTENT_URI, null,
                null, null, CallLog.Calls._ID + "" DESC limit 1;"");
        int numberIndex = callsCursor.getColumnIndex(CallLog.Calls.NUMBER);
        if (callsCursor.moveToNext()) {
            String number = callsCursor.getString(numberIndex);
            if (testNumber.getSchemeSpecificPart().equals(number)) {
                return callsCursor;
            } else {
                // Last call log entry doesnt match expected number.
                return null;
            }
        }
        // No Calls
        return null;
    }

    void assertNumCalls(final MockInCallService inCallService, final int numCalls) {
        waitUntilConditionIsTrueOrTimeout(new Condition() {
            @Override
            public Object expected() {
                return numCalls;
            }
            @Override
            public Object actual() {
                return inCallService.getCallCount();
            }
        },
        WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
        ""InCallService should contain "" + numCalls + "" calls.""
    );
    }

    void assertNumConferenceCalls(final MockInCallService inCallService, final int numCalls) {
        waitUntilConditionIsTrueOrTimeout(new Condition() {
            @Override
            public Object expected() {
                return numCalls;
            }
            @Override
            public Object actual() {
                return inCallService.getConferenceCallCount();
            }
        },
        WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
        ""InCallService should contain "" + numCalls + "" conference calls.""
    );
    }

    void assertCSConnections(final int numConnections) {
        waitUntilConditionIsTrueOrTimeout(new Condition() {
                                              @Override
                                              public Object expected() {
                                                  return numConnections;
                                              }

                                              @Override
                                              public Object actual() {
                                                  return CtsConnectionService
                                                          .getAllConnectionsFromTelecom()
                                                          .size();
                                              }
                                          },
                WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                ""ConnectionService should contain "" + numConnections + "" connections.""
        );
    }

    void assertNumConnections(final MockConnectionService connService, final int numConnections) {
        waitUntilConditionIsTrueOrTimeout(new Condition() {
                                              @Override
                                              public Object expected() {
                                                  return numConnections;
                                              }
                                              @Override
                                              public Object actual() {
                                                  return connService.getAllConnections().size();
                                              }
                                          },
                WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                ""ConnectionService should contain "" + numConnections + "" connections.""
        );
    }

    void assertMuteState(final InCallService incallService, final boolean isMuted) {
        waitUntilConditionIsTrueOrTimeout(
                new Condition() {
                    @Override
                    public Object expected() {
                        return isMuted;
                    }

                    @Override
                    public Object actual() {
                        final CallAudioState state = incallService.getCallAudioState();
                        return state == null ? null : state.isMuted();
                    }
                },
                WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                ""Phone's mute state should be: "" + isMuted
        );
    }

    void assertMuteState(final MockConnection connection, final boolean isMuted) {
        waitUntilConditionIsTrueOrTimeout(
                new Condition() {
                    @Override
                    public Object expected() {
                        return isMuted;
                    }

                    @Override
                    public Object actual() {
                        final CallAudioState state = connection.getCallAudioState();
                        return state == null ? null : state.isMuted();
                    }
                },
                WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                ""Connection's mute state should be: "" + isMuted
        );
    }

    void assertAudioRoute(final InCallService incallService, final int route) {
        waitUntilConditionIsTrueOrTimeout(
                new Condition() {
                    @Override
                    public Object expected() {
                        return route;
                    }

                    @Override
                    public Object actual() {
                        final CallAudioState state = incallService.getCallAudioState();
                        return state == null ? null : state.getRoute();
                    }
                },
                WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                ""Phone's audio route should be: "" + route
        );
    }

    void assertNotAudioRoute(final InCallService incallService, final int route) {
        waitUntilConditionIsTrueOrTimeout(
                new Condition() {
                    @Override
                    public Object expected() {
                        return new Boolean(true);
                    }

                    @Override
                    public Object actual() {
                        final CallAudioState state = incallService.getCallAudioState();
                        return route != state.getRoute();
                    }
                },
                WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                ""Phone's audio route should not be: "" + route
        );
    }

    void assertAudioRoute(final MockConnection connection, final int route) {
        waitUntilConditionIsTrueOrTimeout(
                new Condition() {
                    @Override
                    public Object expected() {
                        return route;
                    }

                    @Override
                    public Object actual() {
                        final CallAudioState state = ((Connection) connection).getCallAudioState();
                        return state == null ? null : state.getRoute();
                    }
                },
                WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                ""Connection's audio route should be: "" + route
        );
    }

    void assertConnectionState(final Connection connection, final int state) {
        waitUntilConditionIsTrueOrTimeout(
                new Condition() {
                    @Override
                    public Object expected() {
                        return state;
                    }

                    @Override
                    public Object actual() {
                        return connection.getState();
                    }
                },
                WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                ""Connection should be in state "" + state
        );
    }

    void assertCallState(final Call call, final int state) {
        waitUntilConditionIsTrueOrTimeout(
                new Condition() {
                    @Override
                    public Object expected() {
                        return true;
                    }

                    @Override
                    public Object actual() {
                        return call.getState() == state && call.getDetails().getState() == state;
                    }
                },
                WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                ""Expected state: "" + state + "", callState="" + call.getState() + "", detailState=""
                    + call.getDetails().getState()
        );
    }

    void assertCallConferenceableList(final Call call, final List<Call> conferenceableList) {
        waitUntilConditionIsTrueOrTimeout(
                new Condition() {
                    @Override
                    public Object expected() {
                        return conferenceableList;
                    }

                    @Override
                    public Object actual() {
                        return call.getConferenceableCalls();
                    }
                },
                WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                ""Call: "" + call + "" does not have the correct conferenceable call list.""
        );
    }

    void assertDtmfString(final MockConnection connection, final String dtmfString) {
        waitUntilConditionIsTrueOrTimeout(new Condition() {
                @Override
                public Object expected() {
                    return dtmfString;
                }

                @Override
                public Object actual() {
                    return connection.getDtmfString();
                }
            },
            WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
            ""DTMF string should be equivalent to entered DTMF characters: "" + dtmfString
        );
    }

    void assertDtmfString(final MockConference conference, final String dtmfString) {
        waitUntilConditionIsTrueOrTimeout(new Condition() {
                @Override
                public Object expected() {
                    return dtmfString;
                }

                @Override
                public Object actual() {
                    return conference.getDtmfString();
                }
            },
            WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
            ""DTMF string should be equivalent to entered DTMF characters: "" + dtmfString
        );
    }

    void assertCallDisplayName(final Call call, final String name) {
        waitUntilConditionIsTrueOrTimeout(
                new Condition() {
                    @Override
                    public Object expected() {
                        return name;
                    }

                    @Override
                    public Object actual() {
                        return call.getDetails().getCallerDisplayName();
                    }
                },
                WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                ""Call should have display name: "" + name
        );
    }

    void assertCallHandle(final Call call, final Uri expectedHandle) {
        waitUntilConditionIsTrueOrTimeout(
                new Condition() {
                    @Override
                    public Object expected() {
                        return expectedHandle;
                    }

                    @Override
                    public Object actual() {
                        return call.getDetails().getHandle();
                    }
                },
                WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                ""Call should have handle name: "" + expectedHandle
        );
    }

    void assertCallConnectTimeChanged(final Call call, final long time) {
        waitUntilConditionIsTrueOrTimeout(
                new Condition() {
                    @Override
                    public Object expected() {
                        return true;
                    }

                    @Override
                    public Object actual() {
                        return call.getDetails().getConnectTimeMillis() != time;
                    }
                },
                WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                ""Call have connect time: "" + time
        );
    }

    void assertConnectionCallDisplayName(final Connection connection, final String name) {
        waitUntilConditionIsTrueOrTimeout(
                new Condition() {
                    @Override
                    public Object expected() {
                        return name;
                    }

                    @Override
                    public Object actual() {
                        return connection.getCallerDisplayName();
                    }
                },
                WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                ""Connection should have display name: "" + name
        );
    }

    void assertDisconnectReason(final Connection connection, final String disconnectReason) {
        waitUntilConditionIsTrueOrTimeout(
                new Condition() {
                    @Override
                    public Object expected() {
                        return disconnectReason;
                    }

                    @Override
                    public Object actual() {
                        return connection.getDisconnectCause().getReason();
                    }
                },
                WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                ""Connection should have been disconnected with reason: "" + disconnectReason
        );
    }

    void assertConferenceState(final Conference conference, final int state) {
        waitUntilConditionIsTrueOrTimeout(
                new Condition() {
                    @Override
                    public Object expected() {
                        return state;
                    }

                    @Override
                    public Object actual() {
                        return conference.getState();
                    }
                },
                WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                ""Conference should be in state "" + state
        );
    }


    void assertOutgoingCallBroadcastReceived(boolean received) {
        waitUntilConditionIsTrueOrTimeout(
                new Condition() {
                    @Override
                    public Object expected() {
                        return received;
                    }

                    @Override
                    public Object actual() {
                        return NewOutgoingCallBroadcastReceiver
                                .isNewOutgoingCallBroadcastReceived();
                    }
                },
                WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                received ? ""Outgoing Call Broadcast should be received""
                        : ""Outgoing Call Broadcast should not be received""
        );
    }

    void assertCallDetailsConstructed(Call mCall, boolean constructed) {
        waitUntilConditionIsTrueOrTimeout(
                new Condition() {
                    @Override
                    public Object expected() {
                        return constructed;
                    }

                    @Override
                    public Object actual() {
                        return mCall != null && mCall.getDetails() != null;
                    }
                },
                WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                constructed ? ""Call Details should be constructed""
                        : ""Call Details should not be constructed""
        );
    }

    void assertCallGatewayConstructed(Call mCall, boolean constructed) {
        waitUntilConditionIsTrueOrTimeout(
                new Condition() {
                    @Override
                    public Object expected() {
                        return constructed;
                    }

                    @Override
                    public Object actual() {
                        return mCall != null && mCall.getDetails() != null
                                && mCall.getDetails().getGatewayInfo() != null;
                    }
                },
                WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                constructed ? ""Call Gateway should be constructed""
                        : ""Call Gateway should not be constructed""
        );
    }

    void assertCallNotNull(Call mCall, boolean notNull) {
        waitUntilConditionIsTrueOrTimeout(
                new Condition() {
                    @Override
                    public Object expected() {
                        return notNull;
                    }

                    @Override
                    public Object actual() {
                        return mCall != null;
                    }
                },
                WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                notNull ? ""Call should not be null"" : ""Call should be null""
        );
    }

    /**
     * Checks all fields of two PhoneAccounts for equality, with the exception of the enabled state.
     * Should only be called after assertPhoneAccountRegistered when it can be guaranteed
     * that the PhoneAccount is registered.
     * @param expected The expected PhoneAccount.
     * @param actual The actual PhoneAccount.
     */
    void assertPhoneAccountEquals(final PhoneAccount expected,
            final PhoneAccount actual) {
        assertEquals(expected.getAddress(), actual.getAddress());
        assertEquals(expected.getAccountHandle(), actual.getAccountHandle());
        assertEquals(expected.getCapabilities(), actual.getCapabilities());
        assertTrue(areBundlesEqual(expected.getExtras(), actual.getExtras()));
        assertEquals(expected.getHighlightColor(), actual.getHighlightColor());
        assertEquals(expected.getIcon(), actual.getIcon());
        assertEquals(expected.getLabel(), actual.getLabel());
        assertEquals(expected.getShortDescription(), actual.getShortDescription());
        assertEquals(expected.getSubscriptionAddress(), actual.getSubscriptionAddress());
        assertEquals(expected.getSupportedUriSchemes(), actual.getSupportedUriSchemes());
    }

    void assertPhoneAccountRegistered(final PhoneAccountHandle handle) {
        waitUntilConditionIsTrueOrTimeout(
                new Condition() {
                    @Override
                    public Object expected() {
                        return true;
                    }

                    @Override
                    public Object actual() {
                        return mTelecomManager.getPhoneAccount(handle) != null;
                    }
                },
                WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                ""Phone account registration failed for "" + handle
        );
    }

    void assertPhoneAccountEnabled(final PhoneAccountHandle handle) {
        waitUntilConditionIsTrueOrTimeout(
                new Condition() {
                    @Override
                    public Object expected() {
                        return true;
                    }

                    @Override
                    public Object actual() {
                        PhoneAccount phoneAccount = mTelecomManager.getPhoneAccount(handle);
                        return (phoneAccount != null && phoneAccount.isEnabled());
                    }
                },
                WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                ""Phone account enable failed for "" + handle
        );
    }

    void assertPhoneAccountIsDefault(final PhoneAccountHandle handle) {
        waitUntilConditionIsTrueOrTimeout(
                new Condition() {
                    @Override
                    public Object expected() {
                        return true;
                    }

                    @Override
                    public Object actual() {
                        PhoneAccountHandle phoneAccountHandle =
                                mTelecomManager.getUserSelectedOutgoingPhoneAccount();
                        return (phoneAccountHandle != null && phoneAccountHandle.equals(handle));
                    }
                },
                WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                ""Failed to set default phone account to "" + handle
        );
    }

    void assertCtsConnectionServiceUnbound() {
        if (CtsConnectionService.isBound()) {
            assertTrue(""CtsConnectionService not yet unbound!"",
                    CtsConnectionService.waitForUnBinding());
        }
    }

    void assertMockInCallServiceUnbound() {
        waitUntilConditionIsTrueOrTimeout(
                new Condition() {
                    @Override
                    public Object expected() {
                        return false;
                    }

                    @Override
                    public Object actual() {
                        return MockInCallService.isServiceBound();
                    }
                },
                WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                ""MockInCallService not yet unbound!""
        );
    }

    void assertIsOutgoingCallPermitted(boolean isPermitted, PhoneAccountHandle handle) {
        waitUntilConditionIsTrueOrTimeout(
                new Condition() {
                    @Override
                    public Object expected() {
                        return isPermitted;
                    }

                    @Override
                    public Object actual() {
                        return mTelecomManager.isOutgoingCallPermitted(handle);
                    }
                },
                WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                ""Expected isOutgoingCallPermitted to be "" + isPermitted
        );
    }

    void assertIsIncomingCallPermitted(boolean isPermitted, PhoneAccountHandle handle) {
        waitUntilConditionIsTrueOrTimeout(
                new Condition() {
                    @Override
                    public Object expected() {
                        return isPermitted;
                    }

                    @Override
                    public Object actual() {
                        return mTelecomManager.isIncomingCallPermitted(handle);
                    }
                },
                WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                ""Expected isIncomingCallPermitted to be "" + isPermitted
        );
    }

    void assertIsInCall(boolean isIncall) {
        waitUntilConditionIsTrueOrTimeout(
                new Condition() {
                    @Override
                    public Object expected() {
                        return isIncall;
                    }

                    @Override
                    public Object actual() {
                        return mTelecomManager.isInCall();
                    }
                },
                WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                ""Expected isInCall to be "" + isIncall
        );
    }

    void assertIsInManagedCall(boolean isIncall) {
        waitUntilConditionIsTrueOrTimeout(
                new Condition() {
                    @Override
                    public Object expected() {
                        return isIncall;
                    }

                    @Override
                    public Object actual() {
                        return mTelecomManager.isInManagedCall();
                    }
                },
                WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                ""Expected isInManagedCall to be "" + isIncall
        );
    }

    /**
     * Asserts that a call's properties are as expected.
     *
     * @param call The call.
     * @param properties The expected properties.
     */
    public void assertCallProperties(final Call call, final int properties) {
        waitUntilConditionIsTrueOrTimeout(
                new Condition() {
                    @Override
                    public Object expected() {
                        return true;
                    }

                    @Override
                    public Object actual() {
                        return call.getDetails().hasProperty(properties);
                    }
                },
                TestUtils.WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                ""Call should have properties "" + properties
        );
    }

    /**
     * Asserts that a call does not have any of the specified call capability bits specified.
     *
     * @param call The call.
     * @param capabilities The capability or capabilities which are not expected.
     */
    public void assertDoesNotHaveCallCapabilities(final Call call, final int capabilities) {
        waitUntilConditionIsTrueOrTimeout(
                new Condition() {
                    @Override
                    public Object expected() {
                        return true;
                    }

                    @Override
                    public Object actual() {
                        int callCapabilities = call.getDetails().getCallCapabilities();
                        return !Call.Details.hasProperty(callCapabilities, capabilities);
                    }
                },
                TestUtils.WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                ""Call should not have capabilities "" + capabilities
        );
    }

    /**
     * Asserts that a call does not have any of the specified call property bits specified.
     *
     * @param call The call.
     * @param properties The property or properties which are not expected.
     */
    public void assertDoesNotHaveCallProperties(final Call call, final int properties) {
        waitUntilConditionIsTrueOrTimeout(
                new Condition() {
                    @Override
                    public Object expected() {
                        return true;
                    }

                    @Override
                    public Object actual() {
                        return !call.getDetails().hasProperty(properties);
                    }
                },
                TestUtils.WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                ""Call should not have properties "" + properties
        );
    }

    /**
     * Asserts that the audio manager reports the specified audio mode.
     *
     * @param audioManager The audio manager to check.
     * @param expectedMode The expected audio mode.
     */
    public void assertAudioMode(final AudioManager audioManager, final int expectedMode) {
        waitUntilConditionIsTrueOrTimeout(
                new Condition() {
                    @Override
                    public Object expected() {
                        return true;
                    }

                    @Override
                    public Object actual() {
                        return audioManager.getMode() == expectedMode;
                    }
                },
                TestUtils.WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                ""Audio mode was expected to be "" + expectedMode
        );
    }

    /**
     * Asserts that a call's capabilities are as expected.
     *
     * @param call The call.
     * @param capabilities The expected capabiltiies.
     */
    public void assertCallCapabilities(final Call call, final int capabilities) {
        waitUntilConditionIsTrueOrTimeout(
                new Condition() {
                    @Override
                    public Object expected() {
                        return true;
                    }

                    @Override
                    public Object actual() {
                        return (call.getDetails().getCallCapabilities() & capabilities) ==
                                capabilities;
                    }
                },
                TestUtils.WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                ""Call should have properties "" + capabilities
        );
    }

    MockInCallService getInCallService() {
        return (mInCallCallbacks == null) ? null : mInCallCallbacks.getService();
    }

    /**
     * Asserts that the {@link UiModeManager} mode matches the specified mode.
     *
     * @param uiMode The expected ui mode.
     */
    public void assertUiMode(final int uiMode) {
        waitUntilConditionIsTrueOrTimeout(
                new Condition() {
                    @Override
                    public Object expected() {
                        return uiMode;
                    }

                    @Override
                    public Object actual() {
                        return mUiModeManager.getCurrentModeType();
                    }
                },
                TestUtils.WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                ""Expected ui mode "" + uiMode
        );
    }

    void waitUntilConditionIsTrueOrTimeout(Condition condition, long timeout,
            String description) {
        final long start = System.currentTimeMillis();
        while (!Objects.equals(condition.expected(), condition.actual())
                && System.currentTimeMillis() - start < timeout) {
            sleep(50);
        }
        assertEquals(description, condition.expected(), condition.actual());
    }

    /**
     * Performs some work, and waits for the condition to be met.  If the condition is not met in
     * each step of the loop, the work is performed again.
     *
     * @param work The work to perform.
     * @param condition The condition.
     * @param timeout The timeout.
     * @param description Description of the work being performed.
     */
    void doWorkAndWaitUntilConditionIsTrueOrTimeout(Work work, Condition condition, long timeout,
            String description) {
        final long start = System.currentTimeMillis();
        work.doWork();
        while (!condition.expected().equals(condition.actual())
                && System.currentTimeMillis() - start < timeout) {
            sleep(50);
            work.doWork();
        }
        assertEquals(description, condition.expected(), condition.actual());
    }

    protected interface Condition {
        Object expected();
        Object actual();
    }

    protected interface Work {
        void doWork();
    }

    public static boolean areBundlesEqual(Bundle extras, Bundle newExtras) {
        if (extras == null || newExtras == null) {
            return extras == newExtras;
        }

        if (extras.size() != newExtras.size()) {
            return false;
        }

        for (String key : extras.keySet()) {
            if (key != null) {
                final Object value = extras.get(key);
                final Object newValue = newExtras.get(key);
                if (!Objects.equals(value, newValue)) {
                    return false;
                }
            }
        }
        return true;
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.monkey.MonkeyTest"	"testNotMonkey"	"CtsMonkeyTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/monkey/src/com/android/cts/monkey/MonkeyTest.java"	""	"public void testNotMonkey() throws Exception {
        mDevice.executeShellCommand(""am start -W -a android.intent.action.MAIN ""
                + ""-n com.android.cts.monkey/com.android.cts.monkey.MonkeyActivity"",
                new NullOutputReceiver());
        assertIsUserAMonkey(false);
    }

    private void assertIsUserAMonkey(boolean isMonkey) throws DeviceNotAvailableException {
        String logs = mDevice.executeAdbCommand(
                ""logcat"", ""-v"", ""brief"", ""-d"", ""MonkeyActivity:I"", ""*:S"");
        boolean monkeyLogsFound = false;
        Scanner s = new Scanner(logs);
        try {
            while (s.hasNextLine()) {
                String line = s.nextLine();
                if (line.contains(isMonkey ? MONKEY : HUMAN)) {
                    monkeyLogsFound = true;
                }
            }
            assertTrue(monkeyLogsFound);
        } finally {
            s.close();
        }
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.app.TriggerScanAndReturnStatusActivity"	"finish"	""	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/CtsWifiLocationTestApp/src/android/net/wifi/cts/app/TriggerScanAndReturnStatusActivity.java"	""	"public void test/*
 *.
 */

package android.net.wifi.cts.app;

import android.app.Activity;
import android.content.Intent;
import android.net.wifi.WifiManager;
import android.os.Bundle;
import android.util.Log;

/**
 * An activity that triggers a wifi scan and returns status.
 */
public class TriggerScanAndReturnStatusActivity extends Activity {
    private static final String TAG = ""TriggerScanAndReturnStatusActivity"";
    private static final String SCAN_STATUS_EXTRA = ""android.net.wifi.cts.app.extra.STATUS"";

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        WifiManager wifiManager = getSystemService(WifiManager.class);
        boolean succeeded;
        try {
            succeeded = wifiManager.startScan();
        } catch (SecurityException e) {
            succeeded = false;
        }
        if (succeeded) {
            Log.v(TAG, ""Scan trigger succeeded"");
        } else {
            Log.v(TAG, ""Failed to trigger scan"");
        }
        setResult(RESULT_OK, new Intent().putExtra(SCAN_STATUS_EXTRA, succeeded));
        finish();
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.security.SELinuxTargetSdkTestBase"	"exists"	""	"/home/gpoor/cts-12-source/cts/tests/tests/selinux/common/src/android/security/SELinuxTargetSdkTestBase.java"	""	"public void testpackage android.security;

import android.system.Os;
import android.test.AndroidTestCase;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.Scanner;
import java.io.File;
import java.io.IOException;
import java.net.NetworkInterface;
import java.util.Collections;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import org.junit.Assert;

abstract class SELinuxTargetSdkTestBase extends AndroidTestCase
{
    static {
        System.loadLibrary(""ctsselinux_jni"");
    }

    static final byte[] ANONYMIZED_HARDWARE_ADDRESS = { 0x02, 0x00, 0x00, 0x00, 0x00, 0x00 };

    protected static String getFile(String filename) throws IOException {
        BufferedReader in = null;
        try {
            in = new BufferedReader(new FileReader(filename));
            return in.readLine().trim();
        } finally {
            if (in != null) {
                in.close();
            }
        }
    }

    protected static String getProperty(String property)
            throws IOException {
        Process process = new ProcessBuilder(""getprop"", property).start();
        Scanner scanner = null;
        String line = """";
        try {
            scanner = new Scanner(process.getInputStream());
            line = scanner.nextLine();
        } finally {
            if (scanner != null) {
                scanner.close();
            }
        }
        return line;
    }

    /**
     * Verify that net.dns properties may not be read
     */
    protected static void noDns() throws IOException {
        String[] dnsProps = {""net.dns1"", ""net.dns2"", ""net.dns3"", ""net.dns4""};
        for(int i = 0; i < dnsProps.length; i++) {
            String dns = getProperty(dnsProps[i]);
            assertEquals(""DNS properties may not be readable by apps past "" +
                    ""targetSdkVersion 26"", """", dns);
        }
    }

    protected static void noNetlinkRouteGetlink() throws IOException {
        assertEquals(
                ""RTM_GETLINK is not allowed on netlink route sockets. Verify that the""
                    + "" following patch has been applied to your kernel: ""
                    + ""https://android-review.googlesource.com/q/I7b44ce60ad98f858c412722d41b9842f8577151f"",
                13,
                checkNetlinkRouteGetlink());
    }

    protected static void checkNetlinkRouteGetneigh(boolean expectAllowed) throws IOException {
        if (!expectAllowed) {
            assertEquals(
                    ""RTM_GETNEIGH is not allowed on netlink route sockets. Verify that the""
                        + "" following patch has been applied to your kernel: ""
                        + ""https://r.android.com/1690896"",
                    3,
                    checkNetlinkRouteGetneigh());
        } else {
            assertEquals(
                    ""RTM_GETNEIGH should be allowed on netlink route sockets for apps with ""
                            + ""targetSdkVersion <= S"",
                    0,
                    checkNetlinkRouteGetneigh());
        }
    }

    protected static void noNetlinkRouteBind() throws IOException {
        assertEquals(
                ""bind() is not allowed on netlink route sockets"",
                13,
                checkNetlinkRouteBind());
    }

    /**
     * Check expectations of being able to read/execute dex2oat.
     */
    protected static void checkDex2oatAccess(boolean expectedAllowed) throws Exception {
        // Check the dex2oat binary in its current and legacy locations.
        String[] locations = {""/apex/com.android.art/bin"",
                              ""/apex/com.android.runtime/bin"",
                              ""/system/bin""};
        for (String loc : locations) {
            File dex2oatBinary = new File(loc + ""/dex2oat"");
            if (dex2oatBinary.exists()) {
                checkDex2oatBinaryAccess(dex2oatBinary, expectedAllowed);
            }
        }
    }

    private static void checkDex2oatBinaryAccess(File dex2oatBinary, boolean expectedAllowed)
        throws Exception {
        // Check permissions.
        assertEquals(expectedAllowed, dex2oatBinary.canRead());
        assertEquals(expectedAllowed, dex2oatBinary.canExecute());

        // Try to execute dex2oat.
        try {
            Runtime rt = Runtime.getRuntime();
            Process p = rt.exec(dex2oatBinary.getAbsolutePath());
            p.waitFor();
            assertEquals(expectedAllowed, true);
        } catch (IOException ex) {
            assertEquals(expectedAllowed, false);
            assertEquals(ex.getMessage(),
                    ""Cannot run program \"""" + dex2oatBinary.getAbsolutePath() +
                    ""\"": error=13, Permission denied"");
        }
    }

    /**
     * Verify that selinux context is the expected domain based on
     * targetSdkVersion,
     */
    protected void appDomainContext(String contextRegex, String errorMsg) throws IOException {
        Pattern p = Pattern.compile(contextRegex);
        Matcher m = p.matcher(getFile(""/proc/self/attr/current""));
        String context = getFile(""/proc/self/attr/current"");
        String msg = errorMsg + context;
        assertTrue(msg, m.matches());
    }

    /**
     * Verify that selinux context is the expected type based on
     * targetSdkVersion,
     */
    protected void appDataContext(String contextRegex, String errorMsg) throws Exception {
        Pattern p = Pattern.compile(contextRegex);
        File appDataDir = getContext().getFilesDir();
        Matcher m = p.matcher(getFileContext(appDataDir.getAbsolutePath()));
        String context = getFileContext(appDataDir.getAbsolutePath());
        String msg = errorMsg + context;
        assertTrue(msg, m.matches());
    }

    protected boolean canExecuteFromHomeDir() throws Exception {
        File appDataDir = getContext().getFilesDir();
        File temp = File.createTempFile(""badbin"", ""exe"", appDataDir);
        temp.deleteOnExit();
        String path = temp.getPath();
        Os.chmod(path, 0700);
        try {
            Process process = new ProcessBuilder(path).start();
        } catch (IOException e) {
            return !e.toString().contains(""Permission denied"");
        } finally {
            temp.delete();
        }
        return true;
    }

    /**
     * Verify that apps are not able to see MAC addresses of ethernet devices.
     */
    protected static void checkNetworkInterfaceHardwareAddress_returnsNull() throws Exception {
        assertNotNull(NetworkInterface.getNetworkInterfaces());
        for (NetworkInterface nif : Collections.list(NetworkInterface.getNetworkInterfaces())) {
            assertNull(nif.getHardwareAddress());
        }
    }

    /**
     * Verify that apps having targetSdkVersion <= 29 get an anonymized MAC
     * address (02:00:00:00:00:00) instead of a null MAC for ethernet interfaces.
     */
    protected static void checkNetworkInterface_returnsAnonymizedHardwareAddresses()
        throws Exception {
        assertNotNull(NetworkInterface.getNetworkInterfaces());
        for (NetworkInterface nif : Collections.list(NetworkInterface.getNetworkInterfaces())) {
            if (isEthernet(nif.getName())) {
                Assert.assertArrayEquals(ANONYMIZED_HARDWARE_ADDRESS, nif.getHardwareAddress());
            }
        }
    }

    /**
     * Checks whether a network interface is an ethernet interface.
     */
    private static Pattern ethernetNamePattern = Pattern.compile(""^(eth|wlan)[0-9]+$"");
    private static boolean isEthernet(String ifName) throws Exception {
        return ethernetNamePattern.matcher(ifName).matches();
    }

    private static final native int checkNetlinkRouteGetlink();
    private static final native int checkNetlinkRouteGetneigh();
    private static final native int checkNetlinkRouteBind();
    private static final native String getFileContext(String path);
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.media.cts.AudioTrackSurroundTest"	"isSink"	"CtsMediaTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/AudioTrackSurroundTest.java"	""	"public void test/*
 *.
 */

package android.media.cts;

import android.annotation.RawRes;
import android.app.ActivityManager;
import android.content.Context;
import android.content.pm.PackageManager;
import android.content.res.AssetFileDescriptor;
import android.content.res.Resources;
import android.media.AudioAttributes;
import android.media.AudioDeviceInfo;
import android.media.AudioFormat;
import android.media.AudioManager;
import android.media.AudioTimestamp;
import android.media.AudioTrack;
import android.platform.test.annotations.AppModeFull;
import android.util.Log;

import com.android.compatibility.common.util.CtsAndroidTestCase;

import java.io.BufferedInputStream;
import java.io.ByteArrayOutputStream;
import java.io.FileInputStream;
import java.io.InputStream;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.ShortBuffer;
import java.util.ArrayList;
import java.util.Random;

// Test the Java AudioTrack surround sound and HDMI passthrough.
// Most tests involve creating a track with a given format and then playing
// a few seconds of audio. The playback is verified by measuring the output
// sample rate based on the AudioTimestamps.

@NonMediaMainlineTest
@AppModeFull(reason = ""Instant apps cannot access the SD card"")
public class AudioTrackSurroundTest extends CtsAndroidTestCase {
    private static final String TAG = ""AudioTrackSurroundTest"";

    private static final double MAX_RATE_TOLERANCE_FRACTION = 0.01;
    private static final boolean LOG_TIMESTAMPS = false; // set true for debugging
    // just long enough to measure the rate
    private static final long SAMPLE_RATE_SHORT_TEST_DURATION_MILLIS = 5000;
    // AC3 and IEC61937 tracks require more time
    private static final long SAMPLE_RATE_LONG_TEST_DURATION_MILLIS = 12000;

    // Set this true to prefer the device that supports the particular encoding.
    // But note that as of 3/25/2016, a bug causes Direct tracks to fail.
    // So only set true when debugging that problem.
    private static final boolean USE_PREFERRED_DEVICE = false;

    // Should we fail if there is no PCM16 device reported by device enumeration?
    // This can happen if, for example, an ATV set top box does not have its HDMI cable plugged in.
    private static final boolean REQUIRE_PCM_DEVICE = false;

    private final static long NANOS_PER_MILLISECOND = 1000000L;
    private final static int MILLIS_PER_SECOND = 1000;
    private final static long NANOS_PER_SECOND = NANOS_PER_MILLISECOND * MILLIS_PER_SECOND;

    private final static String RES_AC3_SPDIF_VOICE_32000 = ""voice12_32k_128kbps_15s_ac3_spdif.raw"";
    private final static String RES_AC3_SPDIF_VOICE_44100 = ""voice12_44k_128kbps_15s_ac3_spdif.raw"";
    private final static String RES_AC3_SPDIF_VOICE_48000 = ""voice12_48k_128kbps_15s_ac3_spdif.raw"";
    private final static String RES_AC3_VOICE_48000 = ""voice12_48k_128kbps_15s_ac3.raw"";

    private static int mLastPlayedEncoding = AudioFormat.ENCODING_INVALID;

    // Devices that support various encodings.
    private static boolean mDeviceScanComplete = false;
    private static AudioDeviceInfo mInfoPCM16 = null;
    private static AudioDeviceInfo mInfoAC3 = null;
    private static AudioDeviceInfo mInfoE_AC3 = null;
    private static AudioDeviceInfo mInfoDTS = null;
    private static AudioDeviceInfo mInfoDTS_HD = null;
    private static AudioDeviceInfo mInfoIEC61937 = null;

    private static void log(String testName, String message) {
        Log.i(TAG, ""["" + testName + ""] "" + message);
    }

    private static void logw(String testName, String message) {
        Log.w(TAG, ""["" + testName + ""] "" + message);
    }

    private static void loge(String testName, String message) {
        Log.e(TAG, ""["" + testName + ""] "" + message);
    }

    // This is a special method that is called automatically before each test.
    @Override
    protected void setUp() throws Exception {
        // Note that I tried to only scan for encodings once but the static
        // data did not persist properly. That may be a bug.
        // For now, just scan before every test.
        scanDevicesForEncodings();
    }

    private void scanDevicesForEncodings() throws Exception {
        final String MTAG = ""scanDevicesForEncodings"";
        // Scan devices to see which encodings are supported.
        AudioManager audioManager = (AudioManager) getContext()
                .getSystemService(Context.AUDIO_SERVICE);
        AudioDeviceInfo[] infos = audioManager.getDevices(AudioManager.GET_DEVICES_OUTPUTS);
        for (AudioDeviceInfo info : infos) {
            log(MTAG, ""scanning devices, name = "" + info.getProductName()
                    + "", id = "" + info.getId()
                    + "", "" + (info.isSink() ? ""sink"" : ""source"")
                    + "", type = "" + info.getType()
                    + "" ------"");
            String text = ""{"";
            for (int encoding : info.getEncodings()) {
                text += String.format(""0x%08X, "", encoding);
            }
            text += ""}"";
            log(MTAG, ""  encodings = "" + text);
            text = ""{"";
            for (int rate : info.getSampleRates()) {
                text += rate + "", "";
            }
            text += ""}"";
            log(MTAG, ""  sample rates = "" + text);
            if (info.isSink()) {
                for (int encoding : info.getEncodings()) {
                    switch (encoding) {
                        case AudioFormat.ENCODING_PCM_16BIT:
                            mInfoPCM16 = info;
                            log(MTAG, ""mInfoPCM16 set to "" + info);
                            break;
                        case AudioFormat.ENCODING_AC3:
                            mInfoAC3 = info;
                            log(MTAG, ""mInfoAC3 set to "" + info);
                            break;
                        case AudioFormat.ENCODING_E_AC3:
                            mInfoE_AC3 = info;
                            log(MTAG, ""mInfoE_AC3 set to "" + info);
                            break;
                        case AudioFormat.ENCODING_DTS:
                            mInfoDTS = info;
                            log(MTAG, ""mInfoDTS set to "" + info);
                            break;
                        case AudioFormat.ENCODING_DTS_HD:
                            mInfoDTS_HD = info;
                            log(MTAG, ""mInfoDTS_HD set to "" + info);
                            break;
                        case AudioFormat.ENCODING_IEC61937:
                            mInfoIEC61937 = info;
                            log(MTAG, ""mInfoIEC61937 set to "" + info);
                            break;
                        default:
                            // This is OK. It is just an encoding that we don't care about.
                            break;
                    }
                }
            }
        }
    }

    // Load a resource into a byte[]
    private byte[] loadRawResourceBytes(@RawRes final String res) throws Exception {
        final String mInpPrefix = WorkDir.getMediaDirString();
        Preconditions.assertTestFileExists(mInpPrefix + res);
        InputStream is = new FileInputStream(mInpPrefix + res);
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        try (BufferedInputStream bis = new BufferedInputStream(is)) {
            for (int b = bis.read(); b != -1; b = bis.read()) {
                bos.write(b);
            }
        }
        return bos.toByteArray();
    }

    // Load a resource into a short[]
    private short[] loadRawResourceShorts(@RawRes final String res) throws Exception {
        byte[] byteBuffer = loadRawResourceBytes(res);
        ShortBuffer shortBuffer =
                ByteBuffer.wrap(byteBuffer).order(ByteOrder.LITTLE_ENDIAN).asShortBuffer();
        // Unfortunately, ShortBuffer.array() works with allocated buffers only.
        short[] mainBuffer = new short[byteBuffer.length / 2];
        for (int i = 0; i < mainBuffer.length; i++) {
            mainBuffer[i] = shortBuffer.get();
        }
        return mainBuffer;
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.bluetooth.BluetoothTestActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/bluetooth/BluetoothTestActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.bluetooth;

import android.bluetooth.BluetoothAdapter;
import android.os.Bundle;
import android.widget.Toast;

import com.android.cts.verifier.ManifestTestListAdapter;
import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;


import java.util.ArrayList;
import java.util.List;

public class BluetoothTestActivity extends PassFailButtons.TestListActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.pass_fail_list);
        setPassFailButtonClickListeners();
        setInfoResources(R.string.bluetooth_test, R.string.bluetooth_test_info, -1);

        BluetoothAdapter bluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
        if (bluetoothAdapter == null) {
            Toast.makeText(this, ""bluetooth not supported"", Toast.LENGTH_SHORT);
            return;
        }

        List<String> disabledTestArray = new ArrayList<String>();
        for (String s : this.getResources().getStringArray(R.array.disabled_tests)) {
            disabledTestArray.add(s);
        }
        if (!this.getPackageManager().hasSystemFeature(""android.hardware.bluetooth_le"")) {
            disabledTestArray.add(
                  ""com.android.cts.verifier.bluetooth.BleAdvertiserTestActivity"");
            disabledTestArray.add(
                  ""com.android.cts.verifier.bluetooth.BleScannerTestActivity"");
            disabledTestArray.add(
                  ""com.android.cts.verifier.bluetooth.BleClientTestActivity"");
            disabledTestArray.add(
                  ""com.android.cts.verifier.bluetooth.BleServerTestBaseActivity"");
            disabledTestArray.add(
                  ""com.android.cts.verifier.bluetooth.BleConnectionPriorityServerBaseActivity"");
            disabledTestArray.add(
                  ""com.android.cts.verifier.bluetooth.BleConnectionPriorityClientBaseActivity"");
        } else if (!bluetoothAdapter.isMultipleAdvertisementSupported()) {
            disabledTestArray.add(
                  ""com.android.cts.verifier.bluetooth.BleAdvertiserTestActivity"");
            disabledTestArray.add(
                  ""com.android.cts.verifier.bluetooth.BleServerTestBaseActivity"");
            disabledTestArray.add(
                  ""com.android.cts.verifier.bluetooth.BleScannerTestActivity"");
            disabledTestArray.add(
                  ""com.android.cts.verifier.bluetooth.BleConnectionPriorityServerBaseActivity"");
            disabledTestArray.add(
                  ""com.android.cts.verifier.bluetooth.BleInsecureServerTestListActivity"");
            disabledTestArray.add(
                  ""com.android.cts.verifier.bluetooth.BleSecureServerTestListActivity"");
            disabledTestArray.add(
                  ""com.android.cts.verifier.bluetooth.BleCocSecureServerTestListActivity"");
            disabledTestArray.add(
                  ""com.android.cts.verifier.bluetooth.BleCocInsecureServerTestListActivity"");
        }
        setTestListAdapter(new ManifestTestListAdapter(this, getClass().getName(),
                disabledTestArray.toArray(new String[disabledTestArray.size()])));
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.bluetooth.BleSecureClientTestListActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/bluetooth/BleSecureClientTestListActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.bluetooth;

import android.bluetooth.BluetoothAdapter;
import android.content.pm.PackageManager;
import android.os.Build;
import android.os.Bundle;
import android.os.SystemProperties;

import com.android.cts.verifier.ManifestTestListAdapter;
import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;

import java.util.ArrayList;
import java.util.List;

public class BleSecureClientTestListActivity extends PassFailButtons.TestListActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.pass_fail_list);
        setPassFailButtonClickListeners();
        setInfoResources(R.string.ble_secure_client_test_list_name, R.string.ble_secure_client_test_list_info, -1);

        BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
        List<String> disabledTest = new ArrayList<String>();
        if (adapter == null || !adapter.isOffloadedFilteringSupported()) {
            disabledTest.add(
                    ""com.android.cts.verifier.bluetooth.BleAdvertiserHardwareScanFilterActivity."");
        }

        // RPA is optional on TVs already released before Android 11
        boolean isTv = getPackageManager().hasSystemFeature(PackageManager.FEATURE_LEANBACK);
        int firstSdk = SystemProperties.getInt(""ro.product.first_api_level"", 0);
        if (isTv && (firstSdk <= Build.VERSION_CODES.Q)) {
            disabledTest.add(
                    ""com.android.cts.verifier.bluetooth.BleSecureConnectionPriorityClientTestActivity"");
            disabledTest.add(
                    ""com.android.cts.verifier.bluetooth.BleSecureEncryptedClientTestActivity"");
        }

        setTestListAdapter(new ManifestTestListAdapter(this, getClass().getName(),
                disabledTest.toArray(new String[disabledTest.size()])));
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.content.cts.AvailableIntentsTest"	"testLocationScanningSettings"	"CtsContentTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/AvailableIntentsTest.java"	""	"public void testLocationScanningSettings() {
        PackageManager packageManager = mContext.getPackageManager();
        if (packageManager.hasSystemFeature(PackageManager.FEATURE_WATCH)) {
            // Skip the test for wearable device.
            return;
        }
        if (packageManager.hasSystemFeature(PackageManager.FEATURE_WIFI)
                || packageManager.hasSystemFeature(PackageManager.FEATURE_BLUETOOTH_LE)) {
            assertCanBeHandled(new Intent(""android.settings.LOCATION_SCANNING_SETTINGS""));
        }
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.hardware.camera2.cts.helpers.StaticMetadat"	"getCharacteristics"	""	"/home/gpoor/cts-12-source/cts/tests/camera/utils/src/android/hardware/camera2/cts/helpers/StaticMetadata.java"	""	"public void test/*
 *.
 */

package android.hardware.camera2.cts.helpers;

import android.graphics.Rect;
import android.graphics.ImageFormat;
import android.hardware.camera2.CameraCharacteristics;
import android.hardware.camera2.CameraCharacteristics.Key;
import android.hardware.camera2.CameraMetadata;
import android.hardware.camera2.CaptureRequest;
import android.hardware.camera2.CaptureResult;
import android.hardware.camera2.cts.CameraTestUtils;
import android.hardware.camera2.params.StreamConfigurationMap;
import android.hardware.camera2.params.Capability;
import android.util.Range;
import android.util.Size;
import android.util.Log;
import android.util.Rational;

import junit.framework.Assert;

import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import static android.hardware.camera2.cts.helpers.AssertHelpers.*;
import static android.hardware.camera2.CameraCharacteristics.*;

/**
 * Helpers to get common static info out of the camera.
 *
 * <p>Avoid boiler plate by putting repetitive get/set patterns in this class.</p>
 *
 * <p>Attempt to be durable against the camera device having bad or missing metadata
 * by providing reasonable defaults and logging warnings when that happens.</p>
 */
public class StaticMetadata {

    private static final String TAG = ""StaticMetadata"";
    private static final int IGNORE_SIZE_CHECK = -1;

    private static final long SENSOR_INFO_EXPOSURE_TIME_RANGE_MIN_AT_MOST = 100000L; // 100us
    private static final long SENSOR_INFO_EXPOSURE_TIME_RANGE_MAX_AT_LEAST = 100000000; // 100ms
    private static final int SENSOR_INFO_SENSITIVITY_RANGE_MIN_AT_MOST = 100;
    private static final int SENSOR_INFO_SENSITIVITY_RANGE_MAX_AT_LEAST = 800;
    private static final int STATISTICS_INFO_MAX_FACE_COUNT_MIN_AT_LEAST = 4;
    private static final int TONEMAP_MAX_CURVE_POINTS_AT_LEAST = 64;
    private static final int CONTROL_AE_COMPENSATION_RANGE_DEFAULT_MIN = -2;
    private static final int CONTROL_AE_COMPENSATION_RANGE_DEFAULT_MAX = 2;
    private static final Rational CONTROL_AE_COMPENSATION_STEP_DEFAULT = new Rational(1, 2);
    private static final byte REQUEST_PIPELINE_MAX_DEPTH_MAX = 8;
    private static final int MAX_REPROCESS_MAX_CAPTURE_STALL = 4;

    // TODO: Consider making this work across any metadata object, not just camera characteristics
    private final CameraCharacteristics mCharacteristics;
    private final CheckLevel mLevel;
    private final CameraErrorCollector mCollector;

    // Last defined capability enum, for iterating over all of them
    public static final int LAST_CAPABILITY_ENUM =
            CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_REMOSAIC_REPROCESSING;

    // Access via getAeModeName() to account for vendor extensions
    public static final String[] AE_MODE_NAMES = new String[] {
        ""AE_MODE_OFF"",
        ""AE_MODE_ON"",
        ""AE_MODE_ON_AUTO_FLASH"",
        ""AE_MODE_ON_ALWAYS_FLASH"",
        ""AE_MODE_ON_AUTO_FLASH_REDEYE""
    };

    // Access via getAfModeName() to account for vendor extensions
    public static final String[] AF_MODE_NAMES = new String[] {
        ""AF_MODE_OFF"",
        ""AF_MODE_AUTO"",
        ""AF_MODE_MACRO"",
        ""AF_MODE_CONTINUOUS_VIDEO"",
        ""AF_MODE_CONTINUOUS_PICTURE"",
        ""AF_MODE_EDOF""
    };

    // Index with android.control.aeState
    public static final String[] AE_STATE_NAMES = new String[] {
        ""AE_STATE_INACTIVE"",
        ""AE_STATE_SEARCHING"",
        ""AE_STATE_CONVERGED"",
        ""AE_STATE_LOCKED"",
        ""AE_STATE_FLASH_REQUIRED"",
        ""AE_STATE_PRECAPTURE""
    };

    // Index with android.control.afState
    public static final String[] AF_STATE_NAMES = new String[] {
        ""AF_STATE_INACTIVE"",
        ""AF_STATE_PASSIVE_SCAN"",
        ""AF_STATE_PASSIVE_FOCUSED"",
        ""AF_STATE_ACTIVE_SCAN"",
        ""AF_STATE_FOCUSED_LOCKED"",
        ""AF_STATE_NOT_FOCUSED_LOCKED"",
        ""AF_STATE_PASSIVE_UNFOCUSED""
    };

    // Index with android.control.aePrecaptureTrigger
    public static final String[] AE_TRIGGER_NAMES = new String[] {
        ""AE_TRIGGER_IDLE"",
        ""AE_TRIGGER_START"",
        ""AE_TRIGGER_CANCEL""
    };

    // Index with android.control.afTrigger
    public static final String[] AF_TRIGGER_NAMES = new String[] {
        ""AF_TRIGGER_IDLE"",
        ""AF_TRIGGER_START"",
        ""AF_TRIGGER_CANCEL""
    };

    public enum CheckLevel {
        /** Only log warnings for metadata check failures. Execution continues. */
        WARN,
        /**
         * Use ErrorCollector to collect the metadata check failures, Execution
         * continues.
         */
        COLLECT,
        /** Assert the metadata check failures. Execution aborts. */
        ASSERT
    }

    /**
     * Construct a new StaticMetadata object.
     *
     *<p> Default constructor, only log warnings for the static metadata check failures</p>
     *
     * @param characteristics static info for a camera
     * @throws IllegalArgumentException if characteristics was null
     */
    public StaticMetadata(CameraCharacteristics characteristics) {
        this(characteristics, CheckLevel.WARN, /*collector*/null);
    }

    /**
     * Construct a new StaticMetadata object with {@link CameraErrorCollector}.
     * <p>
     * When level is not {@link CheckLevel.COLLECT}, the {@link CameraErrorCollector} will be
     * ignored, otherwise, it will be used to log the check failures.
     * </p>
     *
     * @param characteristics static info for a camera
     * @param collector The {@link CameraErrorCollector} used by this StaticMetadata
     * @throws IllegalArgumentException if characteristics or collector was null.
     */
    public StaticMetadata(CameraCharacteristics characteristics, CameraErrorCollector collector) {
        this(characteristics, CheckLevel.COLLECT, collector);
    }

    /**
     * Construct a new StaticMetadata object with {@link CheckLevel} and
     * {@link CameraErrorCollector}.
     * <p>
     * When level is not {@link CheckLevel.COLLECT}, the {@link CameraErrorCollector} will be
     * ignored, otherwise, it will be used to log the check failures.
     * </p>
     *
     * @param characteristics static info for a camera
     * @param level The {@link CheckLevel} of this StaticMetadata
     * @param collector The {@link CameraErrorCollector} used by this StaticMetadata
     * @throws IllegalArgumentException if characteristics was null or level was
     *         {@link CheckLevel.COLLECT} but collector was null.
     */
    public StaticMetadata(CameraCharacteristics characteristics, CheckLevel level,
            CameraErrorCollector collector) {
        if (characteristics == null) {
            throw new IllegalArgumentException(""characteristics was null"");
        }
        if (level == CheckLevel.COLLECT && collector == null) {
            throw new IllegalArgumentException(""collector must valid when COLLECT level is set"");
        }

        mCharacteristics = characteristics;
        mLevel = level;
        mCollector = collector;
    }

    /**
     * Get the CameraCharacteristics associated with this StaticMetadata.
     *
     * @return A non-null CameraCharacteristics object
     */
    public CameraCharacteristics getCharacteristics() {
        return mCharacteristics;
    }

    /**
     * Whether or not the hardware level reported by android.info.supportedHardwareLevel
     * is at least {@value CameraMetadata#INFO_SUPPORTED_HARDWARE_LEVEL_FULL}.
     *
     * <p>If the camera device is not reporting the hardwareLevel, this
     * will cause the test to fail.</p>
     *
     * @return {@code true} if the device is {@code FULL}, {@code false} otherwise.
     */
    public boolean isHardwareLevelAtLeastFull() {
        return isHardwareLevelAtLeast(CameraMetadata.INFO_SUPPORTED_HARDWARE_LEVEL_FULL);
    }

    /**
     * Whether or not the hardware level reported by android.info.supportedHardwareLevel is
     * at least the desired one (but could be higher)
     */
    public boolean isHardwareLevelAtLeast(int level) {
        final int[] sortedHwLevels = {
            CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL_LEGACY,
            CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL_EXTERNAL,
            CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED,
            CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL_FULL,
            CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL_3
        };
        int deviceLevel = getHardwareLevelChecked();
        if (level == deviceLevel) {
            return true;
        }

        for (int sortedlevel : sortedHwLevels) {
            if (sortedlevel == level) {
                return true;
            } else if (sortedlevel == deviceLevel) {
                return false;
            }
        }
        Assert.fail(""Unknown hardwareLevel "" + level + "" and device hardware level "" + deviceLevel);
        return false;
    }

    /**
     * Whether or not the camera is an external camera. If so the hardware level
     * reported by android.info.supportedHardwareLevel is
     * {@value CameraMetadata#INFO_SUPPORTED_HARDWARE_LEVEL_EXTERNAL}.
     *
     * <p>If the camera device is not reporting the hardwareLevel, this
     * will cause the test to fail.</p>
     *
     * @return {@code true} if the device is external, {@code false} otherwise.
     */
    public boolean isExternalCamera() {
        int deviceLevel = getHardwareLevelChecked();
        return deviceLevel == CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL_EXTERNAL;
    }

    /**
     * Whether or not the hardware level reported by android.info.supportedHardwareLevel
     * Return the supported hardware level of the device, or fail if no value is reported.
     *
     * @return the supported hardware level as a constant defined for
     *      {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL}.
     */
    public int getHardwareLevelChecked() {
        Integer hwLevel = getValueFromKeyNonNull(
                CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL);
        if (hwLevel == null) {
            Assert.fail(""No supported hardware level reported."");
        }
        return hwLevel;
    }

    /**
     * Whether or not the hardware level reported by android.info.supportedHardwareLevel
     * is {@value CameraMetadata#INFO_SUPPORTED_HARDWARE_LEVEL_LEGACY}.
     *
     * <p>If the camera device is not reporting the hardwareLevel, this
     * will cause the test to fail.</p>
     *
     * @return {@code true} if the device is {@code LEGACY}, {@code false} otherwise.
     */
    public boolean isHardwareLevelLegacy() {
        return getHardwareLevelChecked() == CameraMetadata.INFO_SUPPORTED_HARDWARE_LEVEL_LEGACY;
    }

    /**
     * Whether or not the per frame control is supported by the camera device.
     *
     * @return {@code true} if per frame control is supported, {@code false} otherwise.
     */
    public boolean isPerFrameControlSupported() {
        return getSyncMaxLatency() == CameraMetadata.SYNC_MAX_LATENCY_PER_FRAME_CONTROL;
    }

    /**
     * Get the maximum number of frames to wait for a request settings being applied
     *
     * @return CameraMetadata.SYNC_MAX_LATENCY_UNKNOWN for unknown latency
     *         CameraMetadata.SYNC_MAX_LATENCY_PER_FRAME_CONTROL for per frame control
     *         a positive int otherwise
     */
    public int getSyncMaxLatency() {
        Integer value = getValueFromKeyNonNull(CameraCharacteristics.SYNC_MAX_LATENCY);
        if (value == null) {
            return CameraMetadata.SYNC_MAX_LATENCY_UNKNOWN;
        }
        return value;
    }

    /**
     * Get the color filter arrangement for this camera device.
     *
     * @return Color Filter arrangement of this camera device
     */
    public int getCFAChecked() {
        Integer cfa = getValueFromKeyNonNull(
                CameraCharacteristics.SENSOR_INFO_COLOR_FILTER_ARRANGEMENT);
        if (cfa == null) {
            Assert.fail(""No color filter array (CFA) reported."");
        }
        return cfa;
    }

    public boolean isNIRColorFilter() {
        Integer cfa = mCharacteristics.get(
                CameraCharacteristics.SENSOR_INFO_COLOR_FILTER_ARRANGEMENT);
        if (cfa == null) {
            return false;
        }
        return cfa == CameraCharacteristics.SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_NIR;
    }

    /**
     * Whether or not the hardware level reported by android.info.supportedHardwareLevel
     * is {@value CameraMetadata#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED}.
     *
     * <p>If the camera device is incorrectly reporting the hardwareLevel, this
     * will always return {@code true}.</p>
     *
     * @return {@code true} if the device is {@code LIMITED}, {@code false} otherwise.
     */
    public boolean isHardwareLevelLimited() {
        return getHardwareLevelChecked() == CameraMetadata.INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED;
    }

    /**
     * Whether or not the hardware level reported by {@code android.info.supportedHardwareLevel}
     * is at least {@link CameraMetadata#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED}.
     *
     * <p>If the camera device is incorrectly reporting the hardwareLevel, this
     * will always return {@code false}.</p>
     *
     * @return
     *          {@code true} if the device is {@code LIMITED} or {@code FULL},
     *          {@code false} otherwise (i.e. LEGACY).
     */
    public boolean isHardwareLevelAtLeastLimited() {
        return isHardwareLevelAtLeast(CameraMetadata.INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED);
    }

    /**
     * Get the maximum number of partial result a request can expect
     *
     * @return 1 if partial result is not supported.
     *         a integer value larger than 1 if partial result is supported.
     */
    public int getPartialResultCount() {
        Integer value = mCharacteristics.get(CameraCharacteristics.REQUEST_PARTIAL_RESULT_COUNT);
        if (value == null) {
            // Optional key. Default value is 1 if key is missing.
            return 1;
        }
        return value;
    }

    /**
     * Get the exposure time value and clamp to the range if needed.
     *
     * @param exposure Input exposure time value to check.
     * @return Exposure value in the legal range.
     */
    public long getExposureClampToRange(long exposure) {
        long minExposure = getExposureMinimumOrDefault(Long.MAX_VALUE);
        long maxExposure = getExposureMaximumOrDefault(Long.MIN_VALUE);
        if (minExposure > SENSOR_INFO_EXPOSURE_TIME_RANGE_MIN_AT_MOST) {
            failKeyCheck(CameraCharacteristics.SENSOR_INFO_EXPOSURE_TIME_RANGE,
                    String.format(
                    ""Min value %d is too large, set to maximal legal value %d"",
                    minExposure, SENSOR_INFO_EXPOSURE_TIME_RANGE_MIN_AT_MOST));
            minExposure = SENSOR_INFO_EXPOSURE_TIME_RANGE_MIN_AT_MOST;
        }
        if (isHardwareLevelAtLeastFull() &&
                maxExposure < SENSOR_INFO_EXPOSURE_TIME_RANGE_MAX_AT_LEAST) {
            failKeyCheck(CameraCharacteristics.SENSOR_INFO_EXPOSURE_TIME_RANGE,
                    String.format(
                    ""Max value %d is too small, set to minimal legal value %d"",
                    maxExposure, SENSOR_INFO_EXPOSURE_TIME_RANGE_MAX_AT_LEAST));
            maxExposure = SENSOR_INFO_EXPOSURE_TIME_RANGE_MAX_AT_LEAST;
        }

        return Math.max(minExposure, Math.min(maxExposure, exposure));
    }

    /**
     * Check if the camera device support focuser.
     *
     * @return true if camera device support focuser, false otherwise.
     */
    public boolean hasFocuser() {
        if (areKeysAvailable(CameraCharacteristics.LENS_INFO_MINIMUM_FOCUS_DISTANCE)) {
            // LEGACY devices don't have lens.info.minimumFocusDistance, so guard this query
            return (getMinimumFocusDistanceChecked() > 0);
        } else {
            // Check available AF modes
            int[] availableAfModes = mCharacteristics.get(
                    CameraCharacteristics.CONTROL_AF_AVAILABLE_MODES);

            if (availableAfModes == null) {
                return false;
            }

            // Assume that if we have an AF mode which doesn't ignore AF trigger, we have a focuser
            boolean hasFocuser = false;
            loop: for (int mode : availableAfModes) {
                switch (mode) {
                    case CameraMetadata.CONTROL_AF_MODE_AUTO:
                    case CameraMetadata.CONTROL_AF_MODE_CONTINUOUS_PICTURE:
                    case CameraMetadata.CONTROL_AF_MODE_CONTINUOUS_VIDEO:
                    case CameraMetadata.CONTROL_AF_MODE_MACRO:
                        hasFocuser = true;
                        break loop;
                }
            }

            return hasFocuser;
        }
    }

    /**
     * Check if the camera device has flash unit.
     * @return true if flash unit is available, false otherwise.
     */
    public boolean hasFlash() {
        return getFlashInfoChecked();
    }

    /**
     * Get minimum focus distance.
     *
     * @return minimum focus distance, 0 if minimum focus distance is invalid.
     */
    public float getMinimumFocusDistanceChecked() {
        Key<Float> key = CameraCharacteristics.LENS_INFO_MINIMUM_FOCUS_DISTANCE;
        Float minFocusDistance;

        /**
         * android.lens.info.minimumFocusDistance - required for FULL and MANUAL_SENSOR-capable
         *   devices; optional for all other devices.
         */
        if (isHardwareLevelAtLeastFull() || isCapabilitySupported(
                CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_MANUAL_SENSOR)) {
            minFocusDistance = getValueFromKeyNonNull(key);
        } else {
            minFocusDistance = mCharacteristics.get(key);
        }

        if (minFocusDistance == null) {
            return 0.0f;
        }

        checkTrueForKey(key, "" minFocusDistance value shouldn't be negative"",
                minFocusDistance >= 0);
        if (minFocusDistance < 0) {
            minFocusDistance = 0.0f;
        }

        return minFocusDistance;
    }

    /**
     * Get focusDistanceCalibration.
     *
     * @return focusDistanceCalibration, UNCALIBRATED if value is invalid.
     */
    public int getFocusDistanceCalibrationChecked() {
        Key<Integer> key = CameraCharacteristics.LENS_INFO_FOCUS_DISTANCE_CALIBRATION;
        Integer calibration = getValueFromKeyNonNull(key);

        if (calibration == null) {
            return CameraMetadata.LENS_INFO_FOCUS_DISTANCE_CALIBRATION_UNCALIBRATED;
        }

        checkTrueForKey(key, "" value is out of range"" ,
                calibration >= CameraMetadata.LENS_INFO_FOCUS_DISTANCE_CALIBRATION_UNCALIBRATED &&
                calibration <= CameraMetadata.LENS_INFO_FOCUS_DISTANCE_CALIBRATION_CALIBRATED);

        return calibration;
    }

    public static String getAeModeName(int aeMode) {
        return (aeMode >= AE_MODE_NAMES.length) ? String.format(""VENDOR_AE_MODE_%d"", aeMode) :
                AE_MODE_NAMES[aeMode];
    }

    public static String getAfModeName(int afMode) {
        return (afMode >= AF_MODE_NAMES.length) ? String.format(""VENDOR_AF_MODE_%d"", afMode) :
                AF_MODE_NAMES[afMode];
    }

    /**
     * Get max AE regions and do validity check.
     *
     * @return AE max regions supported by the camera device
     */
    public int getAeMaxRegionsChecked() {
        Integer regionCount = mCharacteristics.get(CameraCharacteristics.CONTROL_MAX_REGIONS_AE);
        if (regionCount == null) {
            return 0;
        }
        return regionCount;
    }

    /**
     * Get max AWB regions and do validity check.
     *
     * @return AWB max regions supported by the camera device
     */
    public int getAwbMaxRegionsChecked() {
        Integer regionCount = mCharacteristics.get(CameraCharacteristics.CONTROL_MAX_REGIONS_AWB);
        if (regionCount == null) {
            return 0;
        }
        return regionCount;
    }

    /**
     * Get max AF regions and do validity check.
     *
     * @return AF max regions supported by the camera device
     */
    public int getAfMaxRegionsChecked() {
        Integer regionCount = mCharacteristics.get(CameraCharacteristics.CONTROL_MAX_REGIONS_AF);
        if (regionCount == null) {
            return 0;
        }
        return regionCount;
    }
    /**
     * Get the available anti-banding modes.
     *
     * @return The array contains available anti-banding modes.
     */
    public int[] getAeAvailableAntiBandingModesChecked() {
        Key<int[]> key = CameraCharacteristics.CONTROL_AE_AVAILABLE_ANTIBANDING_MODES;
        int[] modes = getValueFromKeyNonNull(key);

        boolean foundAuto = false;
        boolean found50Hz = false;
        boolean found60Hz = false;
        for (int mode : modes) {
            checkTrueForKey(key, ""mode value "" + mode + "" is out if range"",
                    mode >= CameraMetadata.CONTROL_AE_ANTIBANDING_MODE_OFF ||
                    mode <= CameraMetadata.CONTROL_AE_ANTIBANDING_MODE_AUTO);
            if (mode == CameraMetadata.CONTROL_AE_ANTIBANDING_MODE_AUTO) {
                foundAuto = true;
            } else if (mode == CameraMetadata.CONTROL_AE_ANTIBANDING_MODE_50HZ) {
                found50Hz = true;
            } else if (mode == CameraMetadata.CONTROL_AE_ANTIBANDING_MODE_60HZ) {
                found60Hz = true;
            }
        }
        // Must contain AUTO mode or one of 50/60Hz mode.
        checkTrueForKey(key, ""Either AUTO mode or both 50HZ/60HZ mode should present"",
                foundAuto || (found50Hz && found60Hz));

        return modes;
    }

    /**
     * Check if the antibanding OFF mode is supported.
     *
     * @return true if antibanding OFF mode is supported, false otherwise.
     */
    public boolean isAntiBandingOffModeSupported() {
        List<Integer> antiBandingModes =
                Arrays.asList(CameraTestUtils.toObject(getAeAvailableAntiBandingModesChecked()));

        return antiBandingModes.contains(CameraMetadata.CONTROL_AE_ANTIBANDING_MODE_OFF);
    }

    public Boolean getFlashInfoChecked() {
        Key<Boolean> key = CameraCharacteristics.FLASH_INFO_AVAILABLE;
        Boolean hasFlash = getValueFromKeyNonNull(key);

        // In case the failOnKey only gives warning.
        if (hasFlash == null) {
            return false;
        }

        return hasFlash;
    }

    public int[] getAvailableTestPatternModesChecked() {
        Key<int[]> key =
                CameraCharacteristics.SENSOR_AVAILABLE_TEST_PATTERN_MODES;
        int[] modes = getValueFromKeyNonNull(key);

        if (modes == null) {
            return new int[0];
        }

        int expectValue = CameraCharacteristics.SENSOR_TEST_PATTERN_MODE_OFF;
        Integer[] boxedModes = CameraTestUtils.toObject(modes);
        checkTrueForKey(key, "" value must contain OFF mode"",
                Arrays.asList(boxedModes).contains(expectValue));

        return modes;
    }

    /**
     * Get available thumbnail sizes and do the validity check.
     *
     * @return The array of available thumbnail sizes
     */
    public Size[] getAvailableThumbnailSizesChecked() {
        Key<Size[]> key = CameraCharacteristics.JPEG_AVAILABLE_THUMBNAIL_SIZES;
        Size[] sizes = getValueFromKeyNonNull(key);
        final List<Size> sizeList = Arrays.asList(sizes);

        // Size must contain (0, 0).
        checkTrueForKey(key, ""size should contain (0, 0)"", sizeList.contains(new Size(0, 0)));

        // Each size must be distinct.
        checkElementDistinct(key, sizeList);

        // Must be sorted in ascending order by area, by width if areas are same.
        List<Size> orderedSizes =
                CameraTestUtils.getAscendingOrderSizes(sizeList, /*ascending*/true);
        checkTrueForKey(key, ""Sizes should be in ascending order: Original "" + sizeList.toString()
                + "", Expected "" + orderedSizes.toString(), orderedSizes.equals(sizeList));

        // TODO: Aspect ratio match, need wait for android.scaler.availableStreamConfigurations
        // implementation see b/12958122.

        return sizes;
    }

    /**
     * Get available focal lengths and do the validity check.
     *
     * @return The array of available focal lengths
     */
    public float[] getAvailableFocalLengthsChecked() {
        Key<float[]> key = CameraCharacteristics.LENS_INFO_AVAILABLE_FOCAL_LENGTHS;
        float[] focalLengths = getValueFromKeyNonNull(key);

        checkTrueForKey(key, ""Array should contain at least one element"", focalLengths.length >= 1);

        for (int i = 0; i < focalLengths.length; i++) {
            checkTrueForKey(key,
                    String.format(""focalLength[%d] %f should be positive."", i, focalLengths[i]),
                    focalLengths[i] > 0);
        }
        checkElementDistinct(key, Arrays.asList(CameraTestUtils.toObject(focalLengths)));

        return focalLengths;
    }

    /**
     * Get available apertures and do the validity check.
     *
     * @return The non-null array of available apertures
     */
    public float[] getAvailableAperturesChecked() {
        Key<float[]> key = CameraCharacteristics.LENS_INFO_AVAILABLE_APERTURES;
        float[] apertures = getValueFromKeyNonNull(key);

        checkTrueForKey(key, ""Array should contain at least one element"", apertures.length >= 1);

        for (int i = 0; i < apertures.length; i++) {
            checkTrueForKey(key,
                    String.format(""apertures[%d] %f should be positive."", i, apertures[i]),
                    apertures[i] > 0);
        }
        checkElementDistinct(key, Arrays.asList(CameraTestUtils.toObject(apertures)));

        return apertures;
    }

    /**
     * Get and check the available hot pixel map modes.
     *
     * @return the available hot pixel map modes
     */
    public int[] getAvailableHotPixelModesChecked() {
        Key<int[]> key = CameraCharacteristics.HOT_PIXEL_AVAILABLE_HOT_PIXEL_MODES;
        int[] modes = getValueFromKeyNonNull(key);

        if (modes == null) {
            return new int[0];
        }

        List<Integer> modeList = Arrays.asList(CameraTestUtils.toObject(modes));
        if (isHardwareLevelAtLeastFull()) {
            checkTrueForKey(key, ""Full-capability camera devices must support FAST mode"",
                    modeList.contains(CameraMetadata.HOT_PIXEL_MODE_FAST));
        }

        if (isHardwareLevelAtLeastLimited()) {
            // FAST and HIGH_QUALITY mode must be both present or both not present
            List<Integer> coupledModes = Arrays.asList(new Integer[] {
                    CameraMetadata.HOT_PIXEL_MODE_FAST,
                    CameraMetadata.HOT_PIXEL_MODE_HIGH_QUALITY
            });
            checkTrueForKey(
                    key, "" FAST and HIGH_QUALITY mode must both present or both not present"",
                    containsAllOrNone(modeList, coupledModes));
        }
        checkElementDistinct(key, modeList);
        checkArrayValuesInRange(key, modes, CameraMetadata.HOT_PIXEL_MODE_OFF,
                CameraMetadata.HOT_PIXEL_MODE_HIGH_QUALITY);

        return modes;
    }

    /**
     * Get and check available face detection modes.
     *
     * @return The non-null array of available face detection modes
     */
    public int[] getAvailableFaceDetectModesChecked() {
        Key<int[]> key = CameraCharacteristics.STATISTICS_INFO_AVAILABLE_FACE_DETECT_MODES;
        int[] modes = getValueFromKeyNonNull(key);

        if (modes == null) {
            return new int[0];
        }

        List<Integer> modeList = Arrays.asList(CameraTestUtils.toObject(modes));
        checkTrueForKey(key, ""Array should contain OFF mode"",
                modeList.contains(CameraMetadata.STATISTICS_FACE_DETECT_MODE_OFF));
        checkElementDistinct(key, modeList);
        checkArrayValuesInRange(key, modes, CameraMetadata.STATISTICS_FACE_DETECT_MODE_OFF,
                CameraMetadata.STATISTICS_FACE_DETECT_MODE_FULL);

        return modes;
    }

    /**
     * Get and check max face detected count.
     *
     * @return max number of faces that can be detected
     */
    public int getMaxFaceCountChecked() {
        Key<Integer> key = CameraCharacteristics.STATISTICS_INFO_MAX_FACE_COUNT;
        Integer count = getValueFromKeyNonNull(key);

        if (count == null) {
            return 0;
        }

        List<Integer> faceDetectModes =
                Arrays.asList(CameraTestUtils.toObject(getAvailableFaceDetectModesChecked()));
        if (faceDetectModes.contains(CameraMetadata.STATISTICS_FACE_DETECT_MODE_OFF) &&
                faceDetectModes.size() == 1) {
            checkTrueForKey(key, "" value must be 0 if only OFF mode is supported in ""
                    + ""availableFaceDetectionModes"", count == 0);
        } else {
            int maxFaceCountAtLeast = STATISTICS_INFO_MAX_FACE_COUNT_MIN_AT_LEAST;

            // Legacy mode may support fewer than STATISTICS_INFO_MAX_FACE_COUNT_MIN_AT_LEAST faces.
            if (isHardwareLevelLegacy()) {
                maxFaceCountAtLeast = 1;
            }
            checkTrueForKey(key, "" value must be no less than "" + maxFaceCountAtLeast + "" if SIMPLE""
                    + ""or FULL is also supported in availableFaceDetectionModes"",
                    count >= maxFaceCountAtLeast);
        }

        return count;
    }

    /**
     * Get and check the available tone map modes.
     *
     * @return the available tone map modes
     */
    public int[] getAvailableToneMapModesChecked() {
        Key<int[]> key = CameraCharacteristics.TONEMAP_AVAILABLE_TONE_MAP_MODES;
        int[] modes = mCharacteristics.get(key);

        if (modes == null) {
            return new int[0];
        }

        List<Integer> modeList = Arrays.asList(CameraTestUtils.toObject(modes));
        checkTrueForKey(key, "" Camera devices must always support FAST mode"",
                modeList.contains(CameraMetadata.TONEMAP_MODE_FAST));
        // Qualification check for MANUAL_POSTPROCESSING capability is in
        // StaticMetadataTest#testCapabilities

        if (isHardwareLevelAtLeastLimited()) {
            // FAST and HIGH_QUALITY mode must be both present or both not present
            List<Integer> coupledModes = Arrays.asList(new Integer[] {
                    CameraMetadata.TONEMAP_MODE_FAST,
                    CameraMetadata.TONEMAP_MODE_HIGH_QUALITY
            });
            checkTrueForKey(
                    key, "" FAST and HIGH_QUALITY mode must both present or both not present"",
                    containsAllOrNone(modeList, coupledModes));
        }
        checkElementDistinct(key, modeList);
        checkArrayValuesInRange(key, modes, CameraMetadata.TONEMAP_MODE_CONTRAST_CURVE,
                CameraMetadata.TONEMAP_MODE_PRESET_CURVE);

        return modes;
    }

    /**
     * Get and check max tonemap curve point.
     *
     * @return Max tonemap curve points.
     */
    public int getMaxTonemapCurvePointChecked() {
        Key<Integer> key = CameraCharacteristics.TONEMAP_MAX_CURVE_POINTS;
        Integer count = getValueFromKeyNonNull(key);
        List<Integer> modeList =
                Arrays.asList(CameraTestUtils.toObject(getAvailableToneMapModesChecked()));
        boolean tonemapCurveOutputSupported =
                modeList.contains(CameraMetadata.TONEMAP_MODE_CONTRAST_CURVE) ||
                modeList.contains(CameraMetadata.TONEMAP_MODE_GAMMA_VALUE) ||
                modeList.contains(CameraMetadata.TONEMAP_MODE_PRESET_CURVE);

        if (count == null) {
            if (tonemapCurveOutputSupported) {
                Assert.fail(""Tonemap curve output is supported but MAX_CURVE_POINTS is null"");
            }
            return 0;
        }

        if (tonemapCurveOutputSupported) {
            checkTrueForKey(key, ""Tonemap curve output supported camera device must support ""
                    + ""maxCurvePoints >= "" + TONEMAP_MAX_CURVE_POINTS_AT_LEAST,
                    count >= TONEMAP_MAX_CURVE_POINTS_AT_LEAST);
        }

        return count;
    }

    /**
     * Get and check pixel array size.
     */
    public Size getPixelArraySizeChecked() {
        return getPixelArraySizeChecked(/*maxResolution*/ false);
    }

    /**
     * Get and check pixel array size.
     */
    public Size getPixelArraySizeChecked(boolean maxResolution) {
        Key<Size> key = maxResolution ?
                CameraCharacteristics.SENSOR_INFO_PIXEL_ARRAY_SIZE_MAXIMUM_RESOLUTION :
                CameraCharacteristics.SENSOR_INFO_PIXEL_ARRAY_SIZE;
        Size pixelArray = getValueFromKeyNonNull(key);
        if (pixelArray == null) {
            return new Size(0, 0);
        }

        return pixelArray;
    }

    /**
     * Get and check pre-correction active array size.
     */
    public Rect getPreCorrectedActiveArraySizeChecked() {
        return getPreCorrectedActiveArraySizeChecked(/*maxResolution*/ false);
    }

    /**
     * Get and check pre-correction active array size.
     */
    public Rect getPreCorrectedActiveArraySizeChecked(boolean maxResolution) {
        Key<Rect> key = maxResolution ?
                CameraCharacteristics.SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE_MAXIMUM_RESOLUTION :
                        CameraCharacteristics.SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE;
        Rect activeArray = getValueFromKeyNonNull(key);

        if (activeArray == null) {
            return new Rect(0, 0, 0, 0);
        }

        Size pixelArraySize = getPixelArraySizeChecked(maxResolution);
        checkTrueForKey(key, ""values left/top are invalid"", activeArray.left >= 0 && activeArray.top >= 0);
        checkTrueForKey(key, ""values width/height are invalid"",
                activeArray.width() <= pixelArraySize.getWidth() &&
                activeArray.height() <= pixelArraySize.getHeight());

        return activeArray;
    }

    /**
     * Get and check active array size.
     */
    public Rect getActiveArraySizeChecked() {
        return getActiveArraySizeChecked(/*maxResolution*/ false);
    }

    /**
     * Get and check active array size.
     */
    public Rect getActiveArraySizeChecked(boolean maxResolution) {
        Key<Rect> key = maxResolution ?
                CameraCharacteristics.SENSOR_INFO_ACTIVE_ARRAY_SIZE_MAXIMUM_RESOLUTION :
                        CameraCharacteristics.SENSOR_INFO_ACTIVE_ARRAY_SIZE;
        Rect activeArray = getValueFromKeyNonNull(key);

        if (activeArray == null) {
            return new Rect(0, 0, 0, 0);
        }

        Size pixelArraySize = getPixelArraySizeChecked(maxResolution);
        checkTrueForKey(key, ""values left/top are invalid"", activeArray.left >= 0 && activeArray.top >= 0);
        checkTrueForKey(key, ""values width/height are invalid"",
                activeArray.width() <= pixelArraySize.getWidth() &&
                activeArray.height() <= pixelArraySize.getHeight());

        return activeArray;
    }

    /**
     * Get the dimensions to use for RAW16 buffers.
     */
    public Size getRawDimensChecked() throws Exception {
        return getRawDimensChecked(/*maxResolution*/ false);
    }

    /**
     * Get the dimensions to use for RAW16 buffers.
     */
    public Size getRawDimensChecked(boolean maxResolution) throws Exception {
        Size[] targetCaptureSizes = getAvailableSizesForFormatChecked(ImageFormat.RAW_SENSOR,
                        StaticMetadata.StreamDirection.Output, /*fastSizes*/true, /*slowSizes*/true,
                        maxResolution);
        Assert.assertTrue(""No capture sizes available for RAW format!"",
                targetCaptureSizes.length != 0);
        Rect activeArray = getPreCorrectedActiveArraySizeChecked(maxResolution);
        Size preCorrectionActiveArraySize =
                new Size(activeArray.width(), activeArray.height());
        Size pixelArraySize = getPixelArraySizeChecked(maxResolution);
        Assert.assertTrue(""Missing pre-correction active array size"", activeArray.width() > 0 &&
                activeArray.height() > 0);
        Assert.assertTrue(""Missing pixel array size"", pixelArraySize.getWidth() > 0 &&
                pixelArraySize.getHeight() > 0);
        Size[] allowedArraySizes = new Size[] { preCorrectionActiveArraySize,
                pixelArraySize };
        return assertArrayContainsAnyOf(""Available sizes for RAW format"" +
                "" must include either the pre-corrected active array size, or the full "" +
                ""pixel array size"", targetCaptureSizes, allowedArraySizes);
    }

    /**
     * Get the sensitivity value and clamp to the range if needed.
     *
     * @param sensitivity Input sensitivity value to check.
     * @return Sensitivity value in legal range.
     */
    public int getSensitivityClampToRange(int sensitivity) {
        int minSensitivity = getSensitivityMinimumOrDefault();
        int maxSensitivity = getSensitivityMaximumOrDefault();
        if (minSensitivity > SENSOR_INFO_SENSITIVITY_RANGE_MIN_AT_MOST) {
            failKeyCheck(CameraCharacteristics.SENSOR_INFO_SENSITIVITY_RANGE,
                    String.format(
                    ""Min value %d is too large, set to maximal legal value %d"",
                    minSensitivity, SENSOR_INFO_SENSITIVITY_RANGE_MIN_AT_MOST));
            minSensitivity = SENSOR_INFO_SENSITIVITY_RANGE_MIN_AT_MOST;
        }
        if (maxSensitivity < SENSOR_INFO_SENSITIVITY_RANGE_MAX_AT_LEAST) {
            failKeyCheck(CameraCharacteristics.SENSOR_INFO_SENSITIVITY_RANGE,
                    String.format(
                    ""Max value %d is too small, set to minimal legal value %d"",
                    maxSensitivity, SENSOR_INFO_SENSITIVITY_RANGE_MAX_AT_LEAST));
            maxSensitivity = SENSOR_INFO_SENSITIVITY_RANGE_MAX_AT_LEAST;
        }

        return Math.max(minSensitivity, Math.min(maxSensitivity, sensitivity));
    }

    /**
     * Get maxAnalogSensitivity for a camera device.
     * <p>
     * This is only available for FULL capability device, return 0 if it is unavailable.
     * </p>
     *
     * @return maxAnalogSensitivity, 0 if it is not available.
     */
    public int getMaxAnalogSensitivityChecked() {

        Key<Integer> key = CameraCharacteristics.SENSOR_MAX_ANALOG_SENSITIVITY;
        Integer maxAnalogsensitivity = mCharacteristics.get(key);
        if (maxAnalogsensitivity == null) {
            if (isHardwareLevelAtLeastFull()) {
                Assert.fail(""Full device should report max analog sensitivity"");
            }
            return 0;
        }

        int minSensitivity = getSensitivityMinimumOrDefault();
        int maxSensitivity = getSensitivityMaximumOrDefault();
        checkTrueForKey(key, "" Max analog sensitivity "" + maxAnalogsensitivity
                + "" should be no larger than max sensitivity "" + maxSensitivity,
                maxAnalogsensitivity <= maxSensitivity);
        checkTrueForKey(key, "" Max analog sensitivity "" + maxAnalogsensitivity
                + "" should be larger than min sensitivity "" + maxSensitivity,
                maxAnalogsensitivity > minSensitivity);

        return maxAnalogsensitivity;
    }

    /**
     * Get hyperfocalDistance and do the validity check.
     * <p>
     * Note that, this tag is optional, will return -1 if this tag is not
     * available.
     * </p>
     *
     * @return hyperfocalDistance of this device, -1 if this tag is not available.
     */
    public float getHyperfocalDistanceChecked() {
        Key<Float> key = CameraCharacteristics.LENS_INFO_HYPERFOCAL_DISTANCE;
        Float hyperfocalDistance = getValueFromKeyNonNull(key);
        if (hyperfocalDistance == null) {
            return -1;
        }

        if (hasFocuser()) {
            float minFocusDistance = getMinimumFocusDistanceChecked();
            checkTrueForKey(key, String.format("" hyperfocal distance %f should be in the range of""
                    + "" should be in the range of (%f, %f]"", hyperfocalDistance, 0.0f,
                    minFocusDistance),
                    hyperfocalDistance > 0 && hyperfocalDistance <= minFocusDistance);
        }

        return hyperfocalDistance;
    }

    /**
     * Get the minimum value for a sensitivity range from android.sensor.info.sensitivityRange.
     *
     * <p>If the camera is incorrectly reporting values, log a warning and return
     * the default value instead, which is the largest minimum value required to be supported
     * by all camera devices.</p>
     *
     * @return The value reported by the camera device or the defaultValue otherwise.
     */
    public int getSensitivityMinimumOrDefault() {
        return getSensitivityMinimumOrDefault(SENSOR_INFO_SENSITIVITY_RANGE_MIN_AT_MOST);
    }

    /**
     * Get the minimum value for a sensitivity range from android.sensor.info.sensitivityRange.
     *
     * <p>If the camera is incorrectly reporting values, log a warning and return
     * the default value instead.</p>
     *
     * @param defaultValue Value to return if no legal value is available
     * @return The value reported by the camera device or the defaultValue otherwise.
     */
    public int getSensitivityMinimumOrDefault(int defaultValue) {
        Range<Integer> range = mCharacteristics.get(
                CameraCharacteristics.SENSOR_INFO_SENSITIVITY_RANGE);
        if (range == null) {
            if (isHardwareLevelAtLeastFull()) {
                failKeyCheck(CameraCharacteristics.SENSOR_INFO_SENSITIVITY_RANGE,
                        ""had no valid minimum value; using default of "" + defaultValue);
            }
            return defaultValue;
        }
        return range.getLower();
    }

    /**
     * Get the maximum value for a sensitivity range from android.sensor.info.sensitivityRange.
     *
     * <p>If the camera is incorrectly reporting values, log a warning and return
     * the default value instead, which is the smallest maximum value required to be supported
     * by all camera devices.</p>
     *
     * @return The value reported by the camera device or the defaultValue otherwise.
     */
    public int getSensitivityMaximumOrDefault() {
        return getSensitivityMaximumOrDefault(SENSOR_INFO_SENSITIVITY_RANGE_MAX_AT_LEAST);
    }

    /**
     * Get the maximum value for a sensitivity range from android.sensor.info.sensitivityRange.
     *
     * <p>If the camera is incorrectly reporting values, log a warning and return
     * the default value instead.</p>
     *
     * @param defaultValue Value to return if no legal value is available
     * @return The value reported by the camera device or the defaultValue otherwise.
     */
    public int getSensitivityMaximumOrDefault(int defaultValue) {
        Range<Integer> range = mCharacteristics.get(
                CameraCharacteristics.SENSOR_INFO_SENSITIVITY_RANGE);
        if (range == null) {
            if (isHardwareLevelAtLeastFull()) {
                failKeyCheck(CameraCharacteristics.SENSOR_INFO_SENSITIVITY_RANGE,
                        ""had no valid maximum value; using default of "" + defaultValue);
            }
            return defaultValue;
        }
        return range.getUpper();
    }

    /**
     * Get the minimum value for an exposure range from android.sensor.info.exposureTimeRange.
     *
     * <p>If the camera is incorrectly reporting values, log a warning and return
     * the default value instead.</p>
     *
     * @param defaultValue Value to return if no legal value is available
     * @return The value reported by the camera device or the defaultValue otherwise.
     */
    public long getExposureMinimumOrDefault(long defaultValue) {
        Range<Long> range = getValueFromKeyNonNull(
                CameraCharacteristics.SENSOR_INFO_EXPOSURE_TIME_RANGE);
        if (range == null) {
            failKeyCheck(CameraCharacteristics.SENSOR_INFO_EXPOSURE_TIME_RANGE,
                    ""had no valid minimum value; using default of "" + defaultValue);
            return defaultValue;
        }
        return range.getLower();
    }

    /**
     * Get the minimum value for an exposure range from android.sensor.info.exposureTimeRange.
     *
     * <p>If the camera is incorrectly reporting values, log a warning and return
     * the default value instead, which is the largest minimum value required to be supported
     * by all camera devices.</p>
     *
     * @return The value reported by the camera device or the defaultValue otherwise.
     */
    public long getExposureMinimumOrDefault() {
        return getExposureMinimumOrDefault(SENSOR_INFO_EXPOSURE_TIME_RANGE_MIN_AT_MOST);
    }

    /**
     * Get the maximum value for an exposure range from android.sensor.info.exposureTimeRange.
     *
     * <p>If the camera is incorrectly reporting values, log a warning and return
     * the default value instead.</p>
     *
     * @param defaultValue Value to return if no legal value is available
     * @return The value reported by the camera device or the defaultValue otherwise.
     */
    public long getExposureMaximumOrDefault(long defaultValue) {
        Range<Long> range = getValueFromKeyNonNull(
                CameraCharacteristics.SENSOR_INFO_EXPOSURE_TIME_RANGE);
        if (range == null) {
            failKeyCheck(CameraCharacteristics.SENSOR_INFO_EXPOSURE_TIME_RANGE,
                    ""had no valid maximum value; using default of "" + defaultValue);
            return defaultValue;
        }
        return range.getUpper();
    }

    /**
     * Get the maximum value for an exposure range from android.sensor.info.exposureTimeRange.
     *
     * <p>If the camera is incorrectly reporting values, log a warning and return
     * the default value instead, which is the smallest maximum value required to be supported
     * by all camera devices.</p>
     *
     * @return The value reported by the camera device or the defaultValue otherwise.
     */
    public long getExposureMaximumOrDefault() {
        return getExposureMaximumOrDefault(SENSOR_INFO_EXPOSURE_TIME_RANGE_MAX_AT_LEAST);
    }

    /**
     * get android.control.availableModes and do the validity check.
     *
     * @return available control modes.
     */
    public int[] getAvailableControlModesChecked() {
        Key<int[]> modesKey = CameraCharacteristics.CONTROL_AVAILABLE_MODES;
        int[] modes = getValueFromKeyNonNull(modesKey);
        if (modes == null) {
            modes = new int[0];
        }

        List<Integer> modeList = Arrays.asList(CameraTestUtils.toObject(modes));
        checkTrueForKey(modesKey, ""value is empty"", !modeList.isEmpty());

        // All camera device must support AUTO
        checkTrueForKey(modesKey, ""values "" + modeList.toString() + "" must contain AUTO mode"",
                modeList.contains(CameraMetadata.CONTROL_MODE_AUTO));

        boolean isAeOffSupported =  Arrays.asList(
                CameraTestUtils.toObject(getAeAvailableModesChecked())).contains(
                        CameraMetadata.CONTROL_AE_MODE_OFF);
        boolean isAfOffSupported =  Arrays.asList(
                CameraTestUtils.toObject(getAfAvailableModesChecked())).contains(
                        CameraMetadata.CONTROL_AF_MODE_OFF);
        boolean isAwbOffSupported =  Arrays.asList(
                CameraTestUtils.toObject(getAwbAvailableModesChecked())).contains(
                        CameraMetadata.CONTROL_AWB_MODE_OFF);
        if (isAeOffSupported && isAfOffSupported && isAwbOffSupported) {
            // 3A OFF controls are supported, OFF mode must be supported here.
            checkTrueForKey(modesKey, ""values "" + modeList.toString() + "" must contain OFF mode"",
                    modeList.contains(CameraMetadata.CONTROL_MODE_OFF));
        }

        if (isSceneModeSupported()) {
            checkTrueForKey(modesKey, ""values "" + modeList.toString() + "" must contain""
                    + "" USE_SCENE_MODE"",
                    modeList.contains(CameraMetadata.CONTROL_MODE_USE_SCENE_MODE));
        }

        return modes;
    }

    public boolean isSceneModeSupported() {
        List<Integer> availableSceneModes = Arrays.asList(
                CameraTestUtils.toObject(getAvailableSceneModesChecked()));

        if (availableSceneModes.isEmpty()) {
            return false;
        }

        // If sceneMode is not supported, camera device will contain single entry: DISABLED.
        return availableSceneModes.size() > 1 ||
                !availableSceneModes.contains(CameraMetadata.CONTROL_SCENE_MODE_DISABLED);
    }

    /**
     * Get aeAvailableModes and do the validity check.
     *
     * <p>Depending on the check level this class has, for WAR or COLLECT levels,
     * If the aeMode list is invalid, return an empty mode array. The the caller doesn't
     * have to abort the execution even the aeMode list is invalid.</p>
     * @return AE available modes
     */
    public int[] getAeAvailableModesChecked() {
        Key<int[]> modesKey = CameraCharacteristics.CONTROL_AE_AVAILABLE_MODES;
        int[] modes = getValueFromKeyNonNull(modesKey);
        if (modes == null) {
            modes = new int[0];
        }
        List<Integer> modeList = new ArrayList<Integer>();
        for (int mode : modes) {
            // Skip vendor-added modes
            if (mode <= CameraMetadata.CONTROL_AE_MODE_ON_AUTO_FLASH_REDEYE) {
                modeList.add(mode);
            }
        }
        checkTrueForKey(modesKey, ""value is empty"", !modeList.isEmpty());
        modes = new int[modeList.size()];
        for (int i = 0; i < modeList.size(); i++) {
            modes[i] = modeList.get(i);
        }

        // All camera device must support ON
        checkTrueForKey(modesKey, ""values "" + modeList.toString() + "" must contain ON mode"",
                modeList.contains(CameraMetadata.CONTROL_AE_MODE_ON));

        // All camera devices with flash units support ON_AUTO_FLASH and ON_ALWAYS_FLASH
        Key<Boolean> flashKey= CameraCharacteristics.FLASH_INFO_AVAILABLE;
        Boolean hasFlash = getValueFromKeyNonNull(flashKey);
        if (hasFlash == null) {
            hasFlash = false;
        }
        if (hasFlash) {
            boolean flashModeConsistentWithFlash =
                    modeList.contains(CameraMetadata.CONTROL_AE_MODE_ON_AUTO_FLASH) &&
                    modeList.contains(CameraMetadata.CONTROL_AE_MODE_ON_ALWAYS_FLASH);
            checkTrueForKey(modesKey,
                    ""value must contain ON_AUTO_FLASH and ON_ALWAYS_FLASH and  when flash is"" +
                    ""available"", flashModeConsistentWithFlash);
        } else {
            boolean flashModeConsistentWithoutFlash =
                    !(modeList.contains(CameraMetadata.CONTROL_AE_MODE_ON_AUTO_FLASH) ||
                    modeList.contains(CameraMetadata.CONTROL_AE_MODE_ON_ALWAYS_FLASH) ||
                    modeList.contains(CameraMetadata.CONTROL_AE_MODE_ON_AUTO_FLASH_REDEYE));
            checkTrueForKey(modesKey,
                    ""value must not contain ON_AUTO_FLASH, ON_ALWAYS_FLASH and"" +
                    ""ON_AUTO_FLASH_REDEYE when flash is unavailable"",
                    flashModeConsistentWithoutFlash);
        }

        // FULL mode camera devices always support OFF mode.
        boolean condition =
                !isHardwareLevelAtLeastFull() || modeList.contains(CameraMetadata.CONTROL_AE_MODE_OFF);
        checkTrueForKey(modesKey, ""Full capability device must have OFF mode"", condition);

        // Boundary check.
        for (int mode : modes) {
            checkTrueForKey(modesKey, ""Value "" + mode + "" is out of bound"",
                    mode >= CameraMetadata.CONTROL_AE_MODE_OFF
                    && mode <= CameraMetadata.CONTROL_AE_MODE_ON_AUTO_FLASH_REDEYE);
        }

        return modes;
    }

    /**
     * Get available AWB modes and do the validity check.
     *
     * @return array that contains available AWB modes, empty array if awbAvailableModes is
     * unavailable.
     */
    public int[] getAwbAvailableModesChecked() {
        Key<int[]> key =
                CameraCharacteristics.CONTROL_AWB_AVAILABLE_MODES;
        int[] awbModes = getValueFromKeyNonNull(key);

        if (awbModes == null) {
            return new int[0];
        }

        List<Integer> modesList = Arrays.asList(CameraTestUtils.toObject(awbModes));
        checkTrueForKey(key, "" All camera devices must support AUTO mode"",
                modesList.contains(CameraMetadata.CONTROL_AWB_MODE_AUTO));
        if (isHardwareLevelAtLeastFull()) {
            checkTrueForKey(key, "" Full capability camera devices must support OFF mode"",
                    modesList.contains(CameraMetadata.CONTROL_AWB_MODE_OFF));
        }

        return awbModes;
    }

    /**
     * Get available AF modes and do the validity check.
     *
     * @return array that contains available AF modes, empty array if afAvailableModes is
     * unavailable.
     */
    public int[] getAfAvailableModesChecked() {
        Key<int[]> key =
                CameraCharacteristics.CONTROL_AF_AVAILABLE_MODES;
        int[] afModes = getValueFromKeyNonNull(key);

        if (afModes == null) {
            return new int[0];
        }

        List<Integer> modesList = new ArrayList<Integer>();
        for (int afMode : afModes) {
            // Skip vendor-added AF modes
            if (afMode > CameraCharacteristics.CONTROL_AF_MODE_EDOF) continue;
            modesList.add(afMode);
        }
        afModes = new int[modesList.size()];
        for (int i = 0; i < modesList.size(); i++) {
            afModes[i] = modesList.get(i);
        }

        if (isHardwareLevelAtLeastLimited()) {
            // Some LEGACY mode devices do not support AF OFF
            checkTrueForKey(key, "" All camera devices must support OFF mode"",
                    modesList.contains(CameraMetadata.CONTROL_AF_MODE_OFF));
        }
        if (hasFocuser()) {
            checkTrueForKey(key, "" Camera devices that have focuser units must support AUTO mode"",
                    modesList.contains(CameraMetadata.CONTROL_AF_MODE_AUTO));
        }

        return afModes;
    }

    /**
     * Get supported raw output sizes and do the check.
     *
     * @return Empty size array if raw output is not supported
     */
    public Size[] getRawOutputSizesChecked() {
        return getAvailableSizesForFormatChecked(ImageFormat.RAW_SENSOR,
                StreamDirection.Output);
    }

    /**
     * Get supported jpeg output sizes and do the check.
     *
     * @return Empty size array if jpeg output is not supported
     */
    public Size[] getJpegOutputSizesChecked() {
        return getAvailableSizesForFormatChecked(ImageFormat.JPEG,
                StreamDirection.Output);
    }

    /**
     * Get supported heic output sizes and do the check.
     *
     * @return Empty size array if heic output is not supported
     */
    public Size[] getHeicOutputSizesChecked() {
        return getAvailableSizesForFormatChecked(ImageFormat.HEIC,
                StreamDirection.Output);
    }

    /**
     * Used to determine the stream direction for various helpers that look up
     * format or size information.
     */
    public enum StreamDirection {
        /** Stream is used with {@link android.hardware.camera2.CameraDevice#configureOutputs} */
        Output,
        /** Stream is used with {@code CameraDevice#configureInputs} -- NOT YET PUBLIC */
        Input
    }

    /**
     * Get available formats for a given direction.
     *
     * @param direction The stream direction, input or output.
     * @return The formats of the given direction, empty array if no available format is found.
     */
    public int[] getAvailableFormats(StreamDirection direction) {
        Key<StreamConfigurationMap> key =
                CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP;
        StreamConfigurationMap config = getValueFromKeyNonNull(key);

        if (config == null) {
            return new int[0];
        }

        switch (direction) {
            case Output:
                return config.getOutputFormats();
            case Input:
                return config.getInputFormats();
            default:
                throw new IllegalArgumentException(""direction must be output or input"");
        }
    }

    /**
     * Get valid output formats for a given input format.
     *
     * @param inputFormat The input format used to produce the output images.
     * @return The output formats for the given input format, empty array if
     *         no available format is found.
     */
    public int[] getValidOutputFormatsForInput(int inputFormat) {
        Key<StreamConfigurationMap> key =
                CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP;
        StreamConfigurationMap config = getValueFromKeyNonNull(key);

        if (config == null) {
            return new int[0];
        }

        return config.getValidOutputFormatsForInput(inputFormat);
    }

    /**
     * Get available sizes for given format and direction.
     *
     * @param format The format for the requested size array.
     * @param direction The stream direction, input or output.
     * @return The sizes of the given format, empty array if no available size is found.
     */
    public Size[] getAvailableSizesForFormatChecked(int format, StreamDirection direction) {
        return getAvailableSizesForFormatChecked(format, direction,
                /*fastSizes*/true, /*slowSizes*/true, /*maxResolution*/false);
    }

    /**
     * Get available sizes for given format and direction, and whether to limit to slow or fast
     * resolutions.
     *
     * @param format The format for the requested size array.
     * @param direction The stream direction, input or output.
     * @param fastSizes whether to include getOutputSizes() sizes (generally faster)
     * @param slowSizes whether to include getHighResolutionOutputSizes() sizes (generally slower)
     * @return The sizes of the given format, empty array if no available size is found.
     */
    public Size[] getAvailableSizesForFormatChecked(int format, StreamDirection direction,
            boolean fastSizes, boolean slowSizes) {
        return  getAvailableSizesForFormatChecked(format, direction, fastSizes, slowSizes,
                /*maxResolution*/ false);
    }

    /**
     * Get available sizes for given format and direction, and whether to limit to slow or fast
     * resolutions.
     *
     * @param format The format for the requested size array.
     * @param direction The stream direction, input or output.
     * @param fastSizes whether to include getOutputSizes() sizes (generally faster)
     * @param slowSizes whether to include getHighResolutionOutputSizes() sizes (generally slower)
     * @return The sizes of the given format, empty array if no available size is found.
     */
    public Size[] getAvailableSizesForFormatChecked(int format, StreamDirection direction,
            boolean fastSizes, boolean slowSizes, boolean maxResolution) {
        Key<StreamConfigurationMap> key = maxResolution ?
                CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP_MAXIMUM_RESOLUTION :
                CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP;
        StreamConfigurationMap config = getValueFromKeyNonNull(key);

        if (config == null) {
            return new Size[0];
        }

        Size[] sizes = null;

        switch (direction) {
            case Output:
                Size[] fastSizeList = null;
                Size[] slowSizeList = null;
                if (fastSizes) {
                    fastSizeList = config.getOutputSizes(format);
                }
                if (slowSizes) {
                    slowSizeList = config.getHighResolutionOutputSizes(format);
                }
                if (fastSizeList != null && slowSizeList != null) {
                    sizes = new Size[slowSizeList.length + fastSizeList.length];
                    System.arraycopy(fastSizeList, 0, sizes, 0, fastSizeList.length);
                    System.arraycopy(slowSizeList, 0, sizes, fastSizeList.length, slowSizeList.length);
                } else if (fastSizeList != null) {
                    sizes = fastSizeList;
                } else if (slowSizeList != null) {
                    sizes = slowSizeList;
                }
                break;
            case Input:
                sizes = config.getInputSizes(format);
                break;
            default:
                throw new IllegalArgumentException(""direction must be output or input"");
        }

        if (sizes == null) {
            sizes = new Size[0];
        }

        return sizes;
    }

    /**
     * Get available AE target fps ranges.
     *
     * @return Empty int array if aeAvailableTargetFpsRanges is invalid.
     */
    @SuppressWarnings(""raw"")
    public Range<Integer>[] getAeAvailableTargetFpsRangesChecked() {
        Key<Range<Integer>[]> key =
                CameraCharacteristics.CONTROL_AE_AVAILABLE_TARGET_FPS_RANGES;
        Range<Integer>[] fpsRanges = getValueFromKeyNonNull(key);

        if (fpsRanges == null) {
            return new Range[0];
        }

        // Round down to 2 boundary if it is not integer times of 2, to avoid array out of bound
        // in case the above check fails.
        int fpsRangeLength = fpsRanges.length;
        int minFps, maxFps;
        long maxFrameDuration = getMaxFrameDurationChecked();
        for (int i = 0; i < fpsRangeLength; i += 1) {
            minFps = fpsRanges[i].getLower();
            maxFps = fpsRanges[i].getUpper();
            checkTrueForKey(key, "" min fps must be no larger than max fps!"",
                    minFps > 0 && maxFps >= minFps);
            long maxDuration = (long) (1e9 / minFps);
            checkTrueForKey(key, String.format(
                    "" the frame duration %d for min fps %d must smaller than maxFrameDuration %d"",
                    maxDuration, minFps, maxFrameDuration), maxDuration <= maxFrameDuration);
        }
        return fpsRanges;
    }

    /**
     * Get the highest supported target FPS range.
     * Prioritizes maximizing the min FPS, then the max FPS without lowering min FPS.
     */
    public Range<Integer> getAeMaxTargetFpsRange() {
        Range<Integer>[] fpsRanges = getAeAvailableTargetFpsRangesChecked();

        Range<Integer> targetRange = fpsRanges[0];
        // Assume unsorted list of target FPS ranges, so use two passes, first maximize min FPS
        for (Range<Integer> candidateRange : fpsRanges) {
            if (candidateRange.getLower() > targetRange.getLower()) {
                targetRange = candidateRange;
            }
        }
        // Then maximize max FPS while not lowering min FPS
        for (Range<Integer> candidateRange : fpsRanges) {
            if (candidateRange.getLower() >= targetRange.getLower() &&
                    candidateRange.getUpper() > targetRange.getUpper()) {
                targetRange = candidateRange;
            }
        }
        return targetRange;
    }

    /**
     * Get max frame duration.
     *
     * @return 0 if maxFrameDuration is null
     */
    public long getMaxFrameDurationChecked() {
        Key<Long> key =
                CameraCharacteristics.SENSOR_INFO_MAX_FRAME_DURATION;
        Long maxDuration = getValueFromKeyNonNull(key);

        if (maxDuration == null) {
            return 0;
        }

        return maxDuration;
    }

    /**
     * Get available minimal frame durations for a given format.
     *
     * @param format One of the format from {@link ImageFormat}.
     * @return HashMap of minimal frame durations for different sizes, empty HashMap
     *         if availableMinFrameDurations is null.
     */
    public HashMap<Size, Long> getAvailableMinFrameDurationsForFormatChecked(int format) {

        HashMap<Size, Long> minDurationMap = new HashMap<Size, Long>();

        Key<StreamConfigurationMap> key =
                CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP;
        StreamConfigurationMap config = getValueFromKeyNonNull(key);

        if (config == null) {
            return minDurationMap;
        }

        for (android.util.Size size : getAvailableSizesForFormatChecked(format,
                StreamDirection.Output)) {
            long minFrameDuration = config.getOutputMinFrameDuration(format, size);

            if (minFrameDuration != 0) {
                minDurationMap.put(new Size(size.getWidth(), size.getHeight()), minFrameDuration);
            }
        }

        return minDurationMap;
    }

    public int[] getAvailableEdgeModesChecked() {
        Key<int[]> key = CameraCharacteristics.EDGE_AVAILABLE_EDGE_MODES;
        int[] edgeModes = getValueFromKeyNonNull(key);

        if (edgeModes == null) {
            return new int[0];
        }

        List<Integer> modeList = Arrays.asList(CameraTestUtils.toObject(edgeModes));
        // Full device should always include OFF and FAST
        if (isHardwareLevelAtLeastFull()) {
            checkTrueForKey(key, ""Full device must contain OFF and FAST edge modes"",
                    modeList.contains(CameraMetadata.EDGE_MODE_OFF) &&
                    modeList.contains(CameraMetadata.EDGE_MODE_FAST));
        }

        if (isHardwareLevelAtLeastLimited()) {
            // FAST and HIGH_QUALITY mode must be both present or both not present
            List<Integer> coupledModes = Arrays.asList(new Integer[] {
                    CameraMetadata.EDGE_MODE_FAST,
                    CameraMetadata.EDGE_MODE_HIGH_QUALITY
            });
            checkTrueForKey(
                    key, "" FAST and HIGH_QUALITY mode must both present or both not present"",
                    containsAllOrNone(modeList, coupledModes));
        }

        return edgeModes;
    }

      public int[] getAvailableShadingModesChecked() {
        Key<int[]> key = CameraCharacteristics.SHADING_AVAILABLE_MODES;
        int[] shadingModes = getValueFromKeyNonNull(key);

        if (shadingModes == null) {
            return new int[0];
        }

        List<Integer> modeList = Arrays.asList(CameraTestUtils.toObject(shadingModes));
        // Full device should always include OFF and FAST
        if (isHardwareLevelAtLeastFull()) {
            checkTrueForKey(key, ""Full device must contain OFF and FAST shading modes"",
                    modeList.contains(CameraMetadata.SHADING_MODE_OFF) &&
                    modeList.contains(CameraMetadata.SHADING_MODE_FAST));
        }

        if (isHardwareLevelAtLeastLimited()) {
            // FAST and HIGH_QUALITY mode must be both present or both not present
            List<Integer> coupledModes = Arrays.asList(new Integer[] {
                    CameraMetadata.SHADING_MODE_FAST,
                    CameraMetadata.SHADING_MODE_HIGH_QUALITY
            });
            checkTrueForKey(
                    key, "" FAST and HIGH_QUALITY mode must both present or both not present"",
                    containsAllOrNone(modeList, coupledModes));
        }

        return shadingModes;
    }

    public int[] getAvailableNoiseReductionModesChecked() {
        Key<int[]> key =
                CameraCharacteristics.NOISE_REDUCTION_AVAILABLE_NOISE_REDUCTION_MODES;
        int[] noiseReductionModes = getValueFromKeyNonNull(key);

        if (noiseReductionModes == null) {
            return new int[0];
        }

        List<Integer> modeList = Arrays.asList(CameraTestUtils.toObject(noiseReductionModes));
        // Full device should always include OFF and FAST
        if (isHardwareLevelAtLeastFull()) {

            checkTrueForKey(key, ""Full device must contain OFF and FAST noise reduction modes"",
                    modeList.contains(CameraMetadata.NOISE_REDUCTION_MODE_OFF) &&
                    modeList.contains(CameraMetadata.NOISE_REDUCTION_MODE_FAST));
        }

        if (isHardwareLevelAtLeastLimited()) {
            // FAST and HIGH_QUALITY mode must be both present or both not present
            List<Integer> coupledModes = Arrays.asList(new Integer[] {
                    CameraMetadata.NOISE_REDUCTION_MODE_FAST,
                    CameraMetadata.NOISE_REDUCTION_MODE_HIGH_QUALITY
            });
            checkTrueForKey(
                    key, "" FAST and HIGH_QUALITY mode must both present or both not present"",
                    containsAllOrNone(modeList, coupledModes));
        }
        return noiseReductionModes;
    }

    /**
     * Get value of key android.control.aeCompensationStep and do the validity check.
     *
     * @return default value if the value is null.
     */
    public Rational getAeCompensationStepChecked() {
        Key<Rational> key =
                CameraCharacteristics.CONTROL_AE_COMPENSATION_STEP;
        Rational compensationStep = getValueFromKeyNonNull(key);

        if (compensationStep == null) {
            // Return default step.
            return CONTROL_AE_COMPENSATION_STEP_DEFAULT;
        }

        // Legacy devices don't have a minimum step requirement
        if (isHardwareLevelAtLeastLimited()) {
            float compensationStepF =
                    (float) compensationStep.getNumerator() / compensationStep.getDenominator();
            checkTrueForKey(key, "" value must be no more than 1/2"", compensationStepF <= 0.5f);
        }

        return compensationStep;
    }

    /**
     * Get value of key android.control.aeCompensationRange and do the validity check.
     *
     * @return default value if the value is null or malformed.
     */
    public Range<Integer> getAeCompensationRangeChecked() {
        Key<Range<Integer>> key =
                CameraCharacteristics.CONTROL_AE_COMPENSATION_RANGE;
        Range<Integer> compensationRange = getValueFromKeyNonNull(key);
        Rational compensationStep = getAeCompensationStepChecked();
        float compensationStepF = compensationStep.floatValue();
        final Range<Integer> DEFAULT_RANGE = Range.create(
                (int)(CONTROL_AE_COMPENSATION_RANGE_DEFAULT_MIN / compensationStepF),
                (int)(CONTROL_AE_COMPENSATION_RANGE_DEFAULT_MAX / compensationStepF));
        final Range<Integer> ZERO_RANGE = Range.create(0, 0);
        if (compensationRange == null) {
            return ZERO_RANGE;
        }

        // Legacy devices don't have a minimum range requirement
        if (isHardwareLevelAtLeastLimited() && !compensationRange.equals(ZERO_RANGE)) {
            checkTrueForKey(key, "" range value must be at least "" + DEFAULT_RANGE
                    + "", actual "" + compensationRange + "", compensation step "" + compensationStep,
                   compensationRange.getLower() <= DEFAULT_RANGE.getLower() &&
                   compensationRange.getUpper() >= DEFAULT_RANGE.getUpper());
        }

        return compensationRange;
    }

    /**
     * Get availableVideoStabilizationModes and do the validity check.
     *
     * @return available video stabilization modes, empty array if it is unavailable.
     */
    public int[] getAvailableVideoStabilizationModesChecked() {
        Key<int[]> key =
                CameraCharacteristics.CONTROL_AVAILABLE_VIDEO_STABILIZATION_MODES;
        int[] modes = getValueFromKeyNonNull(key);

        if (modes == null) {
            return new int[0];
        }

        List<Integer> modeList = Arrays.asList(CameraTestUtils.toObject(modes));
        checkTrueForKey(key, "" All device should support OFF mode"",
                modeList.contains(CameraMetadata.CONTROL_VIDEO_STABILIZATION_MODE_OFF));
        checkArrayValuesInRange(key, modes,
                CameraMetadata.CONTROL_VIDEO_STABILIZATION_MODE_OFF,
                CameraMetadata.CONTROL_VIDEO_STABILIZATION_MODE_ON);

        return modes;
    }

    public boolean isVideoStabilizationSupported() {
        Integer[] videoStabModes =
                CameraTestUtils.toObject(getAvailableVideoStabilizationModesChecked());
        return Arrays.asList(videoStabModes).contains(
                CameraMetadata.CONTROL_VIDEO_STABILIZATION_MODE_ON);
    }

    /**
     * Get availableOpticalStabilization and do the validity check.
     *
     * @return available optical stabilization modes, empty array if it is unavailable.
     */
    public int[] getAvailableOpticalStabilizationChecked() {
        Key<int[]> key =
                CameraCharacteristics.LENS_INFO_AVAILABLE_OPTICAL_STABILIZATION;
        int[] modes = getValueFromKeyNonNull(key);

        if (modes == null) {
            return new int[0];
        }

        checkArrayValuesInRange(key, modes,
                CameraMetadata.LENS_OPTICAL_STABILIZATION_MODE_OFF,
                CameraMetadata.LENS_OPTICAL_STABILIZATION_MODE_ON);

        return modes;
    }

    /**
     * Get the scaler's max digital zoom ({@code >= 1.0f}) ratio between crop and active array
     * @return the max zoom ratio, or {@code 1.0f} if the value is unavailable
     */
    public float getAvailableMaxDigitalZoomChecked() {
        Key<Float> key =
                CameraCharacteristics.SCALER_AVAILABLE_MAX_DIGITAL_ZOOM;

        Float maxZoom = getValueFromKeyNonNull(key);
        if (maxZoom == null) {
            return 1.0f;
        }

        checkTrueForKey(key, "" max digital zoom should be no less than 1"",
                maxZoom >= 1.0f && !Float.isNaN(maxZoom) && !Float.isInfinite(maxZoom));

        return maxZoom;
    }

    public Range<Float> getZoomRatioRangeChecked() {
        Key<Range<Float>> key =
                CameraCharacteristics.CONTROL_ZOOM_RATIO_RANGE;

        Range<Float> zoomRatioRange = getValueFromKeyNonNull(key);
        if (zoomRatioRange == null) {
            return new Range<Float>(1.0f, 1.0f);
        }

        checkTrueForKey(key, String.format("" min zoom ratio %f should be no more than 1"",
                zoomRatioRange.getLower()), zoomRatioRange.getLower() <= 1.0);
        checkTrueForKey(key, String.format("" max zoom ratio %f should be no less than 1"",
                zoomRatioRange.getUpper()), zoomRatioRange.getUpper() >= 1.0);
        final float ZOOM_MIN_RANGE = 0.01f;
        checkTrueForKey(key, "" zoom ratio range should be reasonably large"",
                zoomRatioRange.getUpper().equals(zoomRatioRange.getLower()) ||
                zoomRatioRange.getUpper() - zoomRatioRange.getLower() > ZOOM_MIN_RANGE);
        return zoomRatioRange;
    }

    public int[] getAvailableSceneModesChecked() {
        Key<int[]> key =
                CameraCharacteristics.CONTROL_AVAILABLE_SCENE_MODES;
        int[] modes = getValueFromKeyNonNull(key);

        if (modes == null) {
            return new int[0];
        }

        List<Integer> modeList = Arrays.asList(CameraTestUtils.toObject(modes));
        // FACE_PRIORITY must be included if face detection is supported.
        if (areKeysAvailable(CameraCharacteristics.STATISTICS_INFO_MAX_FACE_COUNT) &&
                getMaxFaceCountChecked() > 0) {
            checkTrueForKey(key, "" FACE_PRIORITY must be included if face detection is supported"",
                    modeList.contains(CameraMetadata.CONTROL_SCENE_MODE_FACE_PRIORITY));
        }

        return modes;
    }

    public int[] getAvailableEffectModesChecked() {
        Key<int[]> key =
                CameraCharacteristics.CONTROL_AVAILABLE_EFFECTS;
        int[] modes = getValueFromKeyNonNull(key);

        if (modes == null) {
            return new int[0];
        }

        List<Integer> modeList = Arrays.asList(CameraTestUtils.toObject(modes));
        // OFF must be included.
        checkTrueForKey(key, "" OFF must be included"",
                modeList.contains(CameraMetadata.CONTROL_EFFECT_MODE_OFF));

        return modes;
    }

    public Capability[] getAvailableExtendedSceneModeCapsChecked() {
        final Size FULL_HD = new Size(1920, 1080);
        Rect activeRect = getValueFromKeyNonNull(
                CameraCharacteristics.SENSOR_INFO_ACTIVE_ARRAY_SIZE);
        Key<Capability[]> key =
                CameraCharacteristics.CONTROL_AVAILABLE_EXTENDED_SCENE_MODE_CAPABILITIES;
        Capability[] caps = mCharacteristics.get(key);
        if (caps == null) {
            return new Capability[0];
        }

        Size[] yuvSizes = getAvailableSizesForFormatChecked(ImageFormat.YUV_420_888,
                StaticMetadata.StreamDirection.Output);
        List<Size> yuvSizesList = Arrays.asList(yuvSizes);
        for (Capability cap : caps) {
            int extendedSceneMode = cap.getMode();
            Size maxStreamingSize = cap.getMaxStreamingSize();
            boolean maxStreamingSizeIsZero =
                    maxStreamingSize.getWidth() == 0 && maxStreamingSize.getHeight() == 0;
            switch (extendedSceneMode) {
                case CameraMetadata.CONTROL_EXTENDED_SCENE_MODE_BOKEH_STILL_CAPTURE:
                    // STILL_CAPTURE: Must either be (0, 0), or one of supported yuv/private sizes.
                    // Because spec requires yuv and private sizes match, only check YUV sizes here.
                    checkTrueForKey(key,
                            String.format("" maxStreamingSize [%d, %d] for extended scene mode "" +
                            ""%d must be a supported YCBCR_420_888 size, or (0, 0)"",
                            maxStreamingSize.getWidth(), maxStreamingSize.getHeight(),
                            extendedSceneMode),
                            yuvSizesList.contains(maxStreamingSize) || maxStreamingSizeIsZero);
                    break;
                case CameraMetadata.CONTROL_EXTENDED_SCENE_MODE_BOKEH_CONTINUOUS:
                    // CONTINUOUS: Must be one of supported yuv/private stream sizes.
                    checkTrueForKey(key,
                            String.format("" maxStreamingSize [%d, %d] for extended scene mode "" +
                            ""%d must be a supported YCBCR_420_888 size."",
                            maxStreamingSize.getWidth(), maxStreamingSize.getHeight(),
                            extendedSceneMode), yuvSizesList.contains(maxStreamingSize));
                    // Must be at least 1080p if sensor is at least 1080p.
                    if (activeRect.width() >= FULL_HD.getWidth() &&
                            activeRect.height() >= FULL_HD.getHeight()) {
                        checkTrueForKey(key,
                                String.format("" maxStreamingSize [%d, %d] for extended scene "" +
                                ""mode %d must be at least 1080p"", maxStreamingSize.getWidth(),
                                maxStreamingSize.getHeight(), extendedSceneMode),
                                maxStreamingSize.getWidth() >= FULL_HD.getWidth() &&
                                maxStreamingSize.getHeight() >= FULL_HD.getHeight());
                    }
                    break;
                default:
                    break;
            }
        }

        return caps;
    }

    /**
     * Get and check the available color aberration modes
     *
     * @return the available color aberration modes
     */
    public int[] getAvailableColorAberrationModesChecked() {
        Key<int[]> key =
                CameraCharacteristics.COLOR_CORRECTION_AVAILABLE_ABERRATION_MODES;
        int[] modes = getValueFromKeyNonNull(key);

        if (modes == null) {
            return new int[0];
        }

        List<Integer> modeList = Arrays.asList(CameraTestUtils.toObject(modes));
        checkTrueForKey(key, "" Camera devices must always support either OFF or FAST mode"",
                modeList.contains(CameraMetadata.COLOR_CORRECTION_ABERRATION_MODE_OFF) ||
                modeList.contains(CameraMetadata.COLOR_CORRECTION_ABERRATION_MODE_FAST));

        if (isHardwareLevelAtLeastLimited()) {
            // FAST and HIGH_QUALITY mode must be both present or both not present
            List<Integer> coupledModes = Arrays.asList(new Integer[] {
                    CameraMetadata.COLOR_CORRECTION_ABERRATION_MODE_FAST,
                    CameraMetadata.COLOR_CORRECTION_ABERRATION_MODE_HIGH_QUALITY
            });
            checkTrueForKey(
                    key, "" FAST and HIGH_QUALITY mode must both present or both not present"",
                    containsAllOrNone(modeList, coupledModes));
        }
        checkElementDistinct(key, modeList);
        checkArrayValuesInRange(key, modes,
                CameraMetadata.COLOR_CORRECTION_ABERRATION_MODE_OFF,
                CameraMetadata.COLOR_CORRECTION_ABERRATION_MODE_HIGH_QUALITY);

        return modes;
    }

    /**
     * Get max pipeline depth and do the validity check.
     *
     * @return max pipeline depth, default value if it is not available.
     */
    public byte getPipelineMaxDepthChecked() {
        Key<Byte> key =
                CameraCharacteristics.REQUEST_PIPELINE_MAX_DEPTH;
        Byte maxDepth = getValueFromKeyNonNull(key);

        if (maxDepth == null) {
            return REQUEST_PIPELINE_MAX_DEPTH_MAX;
        }

        checkTrueForKey(key, "" max pipeline depth should be no larger than ""
                + REQUEST_PIPELINE_MAX_DEPTH_MAX, maxDepth <= REQUEST_PIPELINE_MAX_DEPTH_MAX);

        return maxDepth;
    }

    /**
     * Get available lens shading modes.
     */
     public int[] getAvailableLensShadingModesChecked() {
         Key<int[]> key =
                 CameraCharacteristics.SHADING_AVAILABLE_MODES;
         int[] modes = getValueFromKeyNonNull(key);
         if (modes == null) {
             return new int[0];
         }

         List<Integer> modeList = Arrays.asList(CameraTestUtils.toObject(modes));
         // FAST must be included.
         checkTrueForKey(key, "" FAST must be included"",
                 modeList.contains(CameraMetadata.SHADING_MODE_FAST));

         if (isCapabilitySupported(
                 CameraMetadata.REQUEST_AVAILABLE_CAPABILITIES_MANUAL_POST_PROCESSING)) {
             checkTrueForKey(key, "" OFF must be included for MANUAL_POST_PROCESSING devices"",
                     modeList.contains(CameraMetadata.SHADING_MODE_OFF));
         }
         return modes;
     }

     /**
      * Get available lens shading map modes.
      */
      public int[] getAvailableLensShadingMapModesChecked() {
          Key<int[]> key =
                  CameraCharacteristics.STATISTICS_INFO_AVAILABLE_LENS_SHADING_MAP_MODES;
          int[] modes = getValueFromKeyNonNull(key);
          if (modes == null) {
              return new int[0];
          }

          List<Integer> modeList = Arrays.asList(CameraTestUtils.toObject(modes));

          if (isCapabilitySupported(
                  CameraMetadata.REQUEST_AVAILABLE_CAPABILITIES_RAW)) {
              checkTrueForKey(key, "" ON must be included for RAW capability devices"",
                      modeList.contains(CameraMetadata.STATISTICS_LENS_SHADING_MAP_MODE_ON));
          }
          return modes;
      }


    /**
     * Get available capabilities and do the validity check.
     *
     * @return reported available capabilities list, empty list if the value is unavailable.
     */
    public List<Integer> getAvailableCapabilitiesChecked() {
        Key<int[]> key =
                CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES;
        int[] availableCaps = getValueFromKeyNonNull(key);
        List<Integer> capList;

        if (availableCaps == null) {
            return new ArrayList<Integer>();
        }

        checkArrayValuesInRange(key, availableCaps,
                CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_BACKWARD_COMPATIBLE,
                LAST_CAPABILITY_ENUM);
        capList = Arrays.asList(CameraTestUtils.toObject(availableCaps));
        return capList;
    }

    /**
     * Determine whether the current device supports a capability or not.
     *
     * @param capability (non-negative)
     *
     * @return {@code true} if the capability is supported, {@code false} otherwise.
     *
     * @throws IllegalArgumentException if {@code capability} was negative
     *
     * @see CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES
     */
    public boolean isCapabilitySupported(int capability) {
        if (capability < 0) {
            throw new IllegalArgumentException(""capability must be non-negative"");
        }

        List<Integer> availableCapabilities = getAvailableCapabilitiesChecked();

        return availableCapabilities.contains(capability);
    }

    /**
     * Determine whether the current device supports a private reprocessing capability or not.
     *
     * @return {@code true} if the capability is supported, {@code false} otherwise.
     *
     * @throws IllegalArgumentException if {@code capability} was negative
     */
    public boolean isPrivateReprocessingSupported() {
        return isCapabilitySupported(
                CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_PRIVATE_REPROCESSING);
    }

    /**
     * Get sorted (descending order) size list for given input format. Remove the sizes larger than
     * the bound. If the bound is null, don't do the size bound filtering.
     *
     * @param format input format
     * @param bound maximum allowed size bound
     *
     * @return Sorted input size list (descending order)
     */
    public List<Size> getSortedSizesForInputFormat(int format, Size bound) {
        Size[] availableSizes = getAvailableSizesForFormatChecked(format, StreamDirection.Input);
        if (bound == null) {
            return CameraTestUtils.getAscendingOrderSizes(Arrays.asList(availableSizes),
                    /*ascending*/false);
        }

        List<Size> sizes = new ArrayList<Size>();
        for (Size sz: availableSizes) {
            if (sz.getWidth() <= bound.getWidth() && sz.getHeight() <= bound.getHeight()) {
                sizes.add(sz);
            }
        }

        return CameraTestUtils.getAscendingOrderSizes(sizes, /*ascending*/false);
    }


    /**
     * Determine whether or not all the {@code keys} are available characteristics keys
     * (as in {@link CameraCharacteristics#getKeys}.
     *
     * <p>If this returns {@code true}, then querying for this key from a characteristics
     * object will always return a non-{@code null} value.</p>
     *
     * @param keys collection of camera characteristics keys
     * @return whether or not all characteristics keys are available
     */
    public final boolean areCharacteristicsKeysAvailable(
            Collection<CameraCharacteristics.Key<?>> keys) {
        return mCharacteristics.getKeys().containsAll(keys);
    }

    /**
     * Determine whether or not all the {@code keys} are available result keys
     * (as in {@link CameraCharacteristics#getAvailableCaptureResultKeys}.
     *
     * <p>If this returns {@code true}, then querying for this key from a result
     * object will almost always return a non-{@code null} value.</p>
     *
     * <p>In some cases (e.g. lens shading map), the request must have additional settings
     * configured in order for the key to correspond to a value.</p>
     *
     * @param keys collection of capture result keys
     * @return whether or not all result keys are available
     */
    public final boolean areResultKeysAvailable(Collection<CaptureResult.Key<?>> keys) {
        return mCharacteristics.getAvailableCaptureResultKeys().containsAll(keys);
    }

    /**
     * Determine whether or not all the {@code keys} are available request keys
     * (as in {@link CameraCharacteristics#getAvailableCaptureRequestKeys}.
     *
     * <p>If this returns {@code true}, then setting this key in the request builder
     * may have some effect (and if it's {@code false}, then the camera device will
     * definitely ignore it).</p>
     *
     * <p>In some cases (e.g. manual control of exposure), other keys must be also be set
     * in order for a key to take effect (e.g. control.mode set to OFF).</p>
     *
     * @param keys collection of capture request keys
     * @return whether or not all result keys are available
     */
    public final boolean areRequestKeysAvailable(Collection<CaptureRequest.Key<?>> keys) {
        return mCharacteristics.getAvailableCaptureRequestKeys().containsAll(keys);
    }

    /**
     * Determine whether or not all the {@code keys} are available characteristics keys
     * (as in {@link CameraCharacteristics#getKeys}.
     *
     * <p>If this returns {@code true}, then querying for this key from a characteristics
     * object will always return a non-{@code null} value.</p>
     *
     * @param keys one or more camera characteristic keys
     * @return whether or not all characteristics keys are available
     */
    @SafeVarargs
    public final boolean areKeysAvailable(CameraCharacteristics.Key<?>... keys) {
        return areCharacteristicsKeysAvailable(Arrays.asList(keys));
    }

    /**
     * Determine whether or not all the {@code keys} are available result keys
     * (as in {@link CameraCharacteristics#getAvailableCaptureResultKeys}.
     *
     * <p>If this returns {@code true}, then querying for this key from a result
     * object will almost always return a non-{@code null} value.</p>
     *
     * <p>In some cases (e.g. lens shading map), the request must have additional settings
     * configured in order for the key to correspond to a value.</p>
     *
     * @param keys one or more capture result keys
     * @return whether or not all result keys are available
     */
    @SafeVarargs
    public final boolean areKeysAvailable(CaptureResult.Key<?>... keys) {
        return areResultKeysAvailable(Arrays.asList(keys));
    }

    /**
     * Determine whether or not all the {@code keys} are available request keys
     * (as in {@link CameraCharacteristics#getAvailableCaptureRequestKeys}.
     *
     * <p>If this returns {@code true}, then setting this key in the request builder
     * may have some effect (and if it's {@code false}, then the camera device will
     * definitely ignore it).</p>
     *
     * <p>In some cases (e.g. manual control of exposure), other keys must be also be set
     * in order for a key to take effect (e.g. control.mode set to OFF).</p>
     *
     * @param keys one or more capture request keys
     * @return whether or not all result keys are available
     */
    @SafeVarargs
    public final boolean areKeysAvailable(CaptureRequest.Key<?>... keys) {
        return areRequestKeysAvailable(Arrays.asList(keys));
    }

    /*
     * Determine if camera device support AE lock control
     *
     * @return {@code true} if AE lock control is supported
     */
    public boolean isAeLockSupported() {
        return getValueFromKeyNonNull(CameraCharacteristics.CONTROL_AE_LOCK_AVAILABLE);
    }

    /*
     * Determine if camera device supports keys that must be supported by
     * ULTRA_HIGH_RESOLUTION_SENSORs
     *
     * @return {@code true} if minimum set of keys are supported
     */
    public boolean areMaximumResolutionKeysSupported() {
        return mCharacteristics.get(
                CameraCharacteristics.SENSOR_INFO_ACTIVE_ARRAY_SIZE_MAXIMUM_RESOLUTION) != null &&
                mCharacteristics.get(
                        SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE_MAXIMUM_RESOLUTION) != null &&
                mCharacteristics.get(
                        SENSOR_INFO_PIXEL_ARRAY_SIZE_MAXIMUM_RESOLUTION) != null &&
                mCharacteristics.get(
                        SCALER_STREAM_CONFIGURATION_MAP_MAXIMUM_RESOLUTION) != null;
    }

    /*
     * Determine if camera device support AWB lock control
     *
     * @return {@code true} if AWB lock control is supported
     */
    public boolean isAwbLockSupported() {
        return getValueFromKeyNonNull(CameraCharacteristics.CONTROL_AWB_LOCK_AVAILABLE);
    }


    /*
     * Determine if camera device support manual lens shading map control
     *
     * @return {@code true} if manual lens shading map control is supported
     */
    public boolean isManualLensShadingMapSupported() {
        return areKeysAvailable(CaptureRequest.SHADING_MODE);
    }

    /**
     * Determine if camera device support manual color correction control
     *
     * @return {@code true} if manual color correction control is supported
     */
    public boolean isColorCorrectionSupported() {
        return areKeysAvailable(CaptureRequest.COLOR_CORRECTION_MODE);
    }

    /**
     * Determine if camera device support manual tone mapping control
     *
     * @return {@code true} if manual tone mapping control is supported
     */
    public boolean isManualToneMapSupported() {
        return areKeysAvailable(CaptureRequest.TONEMAP_MODE);
    }

    /**
     * Determine if camera device support manual color aberration control
     *
     * @return {@code true} if manual color aberration control is supported
     */
    public boolean isManualColorAberrationControlSupported() {
        return areKeysAvailable(CaptureRequest.COLOR_CORRECTION_ABERRATION_MODE);
    }

    /**
     * Determine if camera device support edge mode control
     *
     * @return {@code true} if edge mode control is supported
     */
    public boolean isEdgeModeControlSupported() {
        return areKeysAvailable(CaptureRequest.EDGE_MODE);
    }

    /**
     * Determine if camera device support hot pixel mode control
     *
     * @return {@code true} if hot pixel mode control is supported
     */
    public boolean isHotPixelMapModeControlSupported() {
        return areKeysAvailable(CaptureRequest.HOT_PIXEL_MODE);
    }

    /**
     * Determine if camera device support noise reduction mode control
     *
     * @return {@code true} if noise reduction mode control is supported
     */
    public boolean isNoiseReductionModeControlSupported() {
        return areKeysAvailable(CaptureRequest.NOISE_REDUCTION_MODE);
    }

    /**
     * Get max number of output raw streams and do the basic validity check.
     *
     * @return reported max number of raw output stream
     */
    public int getMaxNumOutputStreamsRawChecked() {
        Integer maxNumStreams =
                getValueFromKeyNonNull(CameraCharacteristics.REQUEST_MAX_NUM_OUTPUT_RAW);
        if (maxNumStreams == null)
            return 0;
        return maxNumStreams;
    }

    /**
     * Get max number of output processed streams and do the basic validity check.
     *
     * @return reported max number of processed output stream
     */
    public int getMaxNumOutputStreamsProcessedChecked() {
        Integer maxNumStreams =
                getValueFromKeyNonNull(CameraCharacteristics.REQUEST_MAX_NUM_OUTPUT_PROC);
        if (maxNumStreams == null)
            return 0;
        return maxNumStreams;
    }

    /**
     * Get max number of output stalling processed streams and do the basic validity check.
     *
     * @return reported max number of stalling processed output stream
     */
    public int getMaxNumOutputStreamsProcessedStallChecked() {
        Integer maxNumStreams =
                getValueFromKeyNonNull(CameraCharacteristics.REQUEST_MAX_NUM_OUTPUT_PROC_STALLING);
        if (maxNumStreams == null)
            return 0;
        return maxNumStreams;
    }

    /**
     * Get lens facing and do the validity check
     * @return lens facing, return default value (BACK) if value is unavailable.
     */
    public int getLensFacingChecked() {
        Key<Integer> key =
                CameraCharacteristics.LENS_FACING;
        Integer facing = getValueFromKeyNonNull(key);

        if (facing == null) {
            return CameraCharacteristics.LENS_FACING_BACK;
        }

        checkTrueForKey(key, "" value is out of range "",
                facing >= CameraCharacteristics.LENS_FACING_FRONT &&
                facing <= CameraCharacteristics.LENS_FACING_EXTERNAL);
        return facing;
    }

    /**
     * Get maxCaptureStall frames or default value (if value doesn't exist)
     * @return maxCaptureStall frames or default value.
     */
    public int getMaxCaptureStallOrDefault() {
        Key<Integer> key =
                CameraCharacteristics.REPROCESS_MAX_CAPTURE_STALL;
        Integer value = getValueFromKeyNonNull(key);

        if (value == null) {
            return MAX_REPROCESS_MAX_CAPTURE_STALL;
        }

        checkTrueForKey(key, "" value is out of range "",
                value >= 0 &&
                value <= MAX_REPROCESS_MAX_CAPTURE_STALL);

        return value;
    }

    /**
     * Get the scaler's cropping type (center only or freeform)
     * @return cropping type, return default value (CENTER_ONLY) if value is unavailable
     */
    public int getScalerCroppingTypeChecked() {
        Key<Integer> key =
                CameraCharacteristics.SCALER_CROPPING_TYPE;
        Integer value = getValueFromKeyNonNull(key);

        if (value == null) {
            return CameraCharacteristics.SCALER_CROPPING_TYPE_CENTER_ONLY;
        }

        checkTrueForKey(key, "" value is out of range "",
                value >= CameraCharacteristics.SCALER_CROPPING_TYPE_CENTER_ONLY &&
                value <= CameraCharacteristics.SCALER_CROPPING_TYPE_FREEFORM);

        return value;
    }

    /**
     * Check if the constrained high speed video is supported by the camera device.
     * The high speed FPS ranges and sizes are sanitized in
     * ExtendedCameraCharacteristicsTest#testConstrainedHighSpeedCapability.
     *
     * @return true if the constrained high speed video is supported, false otherwise.
     */
    public boolean isConstrainedHighSpeedVideoSupported() {
        List<Integer> availableCapabilities = getAvailableCapabilitiesChecked();
        return (availableCapabilities.contains(
                CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_CONSTRAINED_HIGH_SPEED_VIDEO));
    }

    /**
     * Check if this camera device is a logical multi-camera backed by multiple
     * physical cameras.
     *
     * @return true if this is a logical multi-camera.
     */
    public boolean isLogicalMultiCamera() {
        List<Integer> availableCapabilities = getAvailableCapabilitiesChecked();
        return (availableCapabilities.contains(
                CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_LOGICAL_MULTI_CAMERA));
    }

    /**
     * Check if this camera device is an ULTRA_HIGH_RESOLUTION_SENSOR
     *
     * @return true if this is an ultra high resolution sensor
     */
    public boolean isUltraHighResolutionSensor() {
        List<Integer> availableCapabilities = getAvailableCapabilitiesChecked();
        return (availableCapabilities.contains(
                CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_ULTRA_HIGH_RESOLUTION_SENSOR));
    }
    /**
     * Check if this camera device is a monochrome camera with Y8 support.
     *
     * @return true if this is a monochrome camera with Y8 support.
     */
    public boolean isMonochromeWithY8() {
        int[] supportedFormats = getAvailableFormats(
                StaticMetadata.StreamDirection.Output);
        return (isColorOutputSupported()
                && isCapabilitySupported(
                        CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_MONOCHROME)
                && CameraTestUtils.contains(supportedFormats, ImageFormat.Y8));
    }

    /**
     * Check if high speed video is supported (HIGH_SPEED_VIDEO scene mode is
     * supported, supported high speed fps ranges and sizes are valid).
     *
     * @return true if high speed video is supported.
     */
    public boolean isHighSpeedVideoSupported() {
        List<Integer> sceneModes =
                Arrays.asList(CameraTestUtils.toObject(getAvailableSceneModesChecked()));
        if (sceneModes.contains(CameraCharacteristics.CONTROL_SCENE_MODE_HIGH_SPEED_VIDEO)) {
            StreamConfigurationMap config =
                    getValueFromKeyNonNull(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);
            if (config == null) {
                return false;
            }
            Size[] availableSizes = config.getHighSpeedVideoSizes();
            if (availableSizes.length == 0) {
                return false;
            }

            for (Size size : availableSizes) {
                Range<Integer>[] availableFpsRanges = config.getHighSpeedVideoFpsRangesFor(size);
                if (availableFpsRanges.length == 0) {
                    return false;
                }
            }

            return true;
        } else {
            return false;
        }
    }

    /**
     * Check if depth output is supported, based on the depth capability
     */
    public boolean isDepthOutputSupported() {
        return isCapabilitySupported(
                CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_DEPTH_OUTPUT);
    }

    /**
     * Check if offline processing is supported, based on the respective capability
     */
    public boolean isOfflineProcessingSupported() {
        return isCapabilitySupported(
                CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_OFFLINE_PROCESSING);
    }

    /**
     * Check if standard outputs (PRIVATE, YUV, JPEG) outputs are supported, based on the
     * backwards-compatible capability
     */
    public boolean isColorOutputSupported() {
        return isCapabilitySupported(
                CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_BACKWARD_COMPATIBLE);
    }

    /**
     * Check if this camera is a MONOCHROME camera.
     */
    public boolean isMonochromeCamera() {
        return isCapabilitySupported(
                CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_MONOCHROME);
    }

    /**
     * Check if optical black regions key is supported.
     */
    public boolean isOpticalBlackRegionSupported() {
        return areKeysAvailable(CameraCharacteristics.SENSOR_OPTICAL_BLACK_REGIONS);
    }

    /**
     * Check if HEIC format is supported
     */
    public boolean isHeicSupported() {
        int[] formats = getAvailableFormats(StaticMetadata.StreamDirection.Output);
        return CameraTestUtils.contains(formats, ImageFormat.HEIC);
    }

    /**
     * Check if Depth Jpeg format is supported
     */
    public boolean isDepthJpegSupported() {
        int[] formats = getAvailableFormats(StaticMetadata.StreamDirection.Output);
        return CameraTestUtils.contains(formats, ImageFormat.DEPTH_JPEG);
    }

    /**
     * Check if the dynamic black level is supported.
     *
     * <p>
     * Note that: This also indicates if the white level is supported, as dynamic black and white
     * level must be all supported or none of them is supported.
     * </p>
     */
    public boolean isDynamicBlackLevelSupported() {
        return areKeysAvailable(CaptureResult.SENSOR_DYNAMIC_BLACK_LEVEL);
    }

    /**
     * Check if the enable ZSL key is supported.
     */
    public boolean isEnableZslSupported() {
        return areKeysAvailable(CaptureRequest.CONTROL_ENABLE_ZSL);
    }

    /**
     * Check if AF scene change key is supported.
     */
    public boolean isAfSceneChangeSupported() {
        return areKeysAvailable(CaptureResult.CONTROL_AF_SCENE_CHANGE);
    }

    /**
     * Check if OIS data mode is supported.
     */
    public boolean isOisDataModeSupported() {
        int[] availableOisDataModes = mCharacteristics.get(
                CameraCharacteristics.STATISTICS_INFO_AVAILABLE_OIS_DATA_MODES);

        if (availableOisDataModes == null) {
            return false;
        }

        for (int mode : availableOisDataModes) {
            if (mode == CameraMetadata.STATISTICS_OIS_DATA_MODE_ON) {
                return true;
            }
        }

        return false;
    }

    /**
     * Check if rotate and crop is supported
     */
    public boolean isRotateAndCropSupported() {
        int[] availableRotateAndCropModes = mCharacteristics.get(
                CameraCharacteristics.SCALER_AVAILABLE_ROTATE_AND_CROP_MODES);

        if (availableRotateAndCropModes == null) {
            return false;
        }

        for (int mode : availableRotateAndCropModes) {
            if (mode != CameraMetadata.SCALER_ROTATE_AND_CROP_NONE) {
                return true;
            }
        }

        return false;
    }

    /**
     * Check if distortion correction is supported.
     */
    public boolean isDistortionCorrectionSupported() {
        boolean distortionCorrectionSupported = false;
        int[] distortionModes = mCharacteristics.get(
                CameraCharacteristics.DISTORTION_CORRECTION_AVAILABLE_MODES);
        if (distortionModes == null) {
            return false;
        }

        for (int mode : distortionModes) {
            if (mode != CaptureRequest.DISTORTION_CORRECTION_MODE_OFF) {
                return true;
            }
        }

        return false;
    }

    /**
     * Check if active physical camera Id metadata is supported.
     */
    public boolean isActivePhysicalCameraIdSupported() {
        return areKeysAvailable(CaptureResult.LOGICAL_MULTI_CAMERA_ACTIVE_PHYSICAL_ID);
    }

    /**
     * Get the value in index for a fixed-size array from a given key.
     *
     * <p>If the camera device is incorrectly reporting values, log a warning and return
     * the default value instead.</p>
     *
     * @param key Key to fetch
     * @param defaultValue Default value to return if camera device uses invalid values
     * @param name Human-readable name for the array index (logging only)
     * @param index Array index of the subelement
     * @param size Expected fixed size of the array
     *
     * @return The value reported by the camera device, or the defaultValue otherwise.
     */
    private <T> T getArrayElementOrDefault(Key<?> key, T defaultValue, String name, int index,
            int size) {
        T elementValue = getArrayElementCheckRangeNonNull(
                key,
                index,
                size);

        if (elementValue == null) {
            failKeyCheck(key,
                    ""had no valid "" + name + "" value; using default of "" + defaultValue);
            elementValue = defaultValue;
        }

        return elementValue;
    }

    /**
     * Fetch an array sub-element from an array value given by a key.
     *
     * <p>
     * Prints a warning if the sub-element was null.
     * </p>
     *
     * <p>Use for variable-size arrays since this does not check the array size.</p>
     *
     * @param key Metadata key to look up
     * @param element A non-negative index value.
     * @return The array sub-element, or null if the checking failed.
     */
    private <T> T getArrayElementNonNull(Key<?> key, int element) {
        return getArrayElementCheckRangeNonNull(key, element, IGNORE_SIZE_CHECK);
    }

    /**
     * Fetch an array sub-element from an array value given by a key.
     *
     * <p>
     * Prints a warning if the array size does not match the size, or if the sub-element was null.
     * </p>
     *
     * @param key Metadata key to look up
     * @param element The index in [0,size)
     * @param size A positive size value or otherwise {@value #IGNORE_SIZE_CHECK}
     * @return The array sub-element, or null if the checking failed.
     */
    private <T> T getArrayElementCheckRangeNonNull(Key<?> key, int element, int size) {
        Object array = getValueFromKeyNonNull(key);

        if (array == null) {
            // Warning already printed
            return null;
        }

        if (size != IGNORE_SIZE_CHECK) {
            int actualLength = Array.getLength(array);
            if (actualLength != size) {
                failKeyCheck(key,
                        String.format(""had the wrong number of elements (%d), expected (%d)"",
                                actualLength, size));
                return null;
            }
        }

        @SuppressWarnings(""unchecked"")
        T val = (T) Array.get(array, element);

        if (val == null) {
            failKeyCheck(key, ""had a null element at index"" + element);
            return null;
        }

        return val;
    }

    /**
     * Gets the key, logging warnings for null values.
     */
    public <T> T getValueFromKeyNonNull(Key<T> key) {
        if (key == null) {
            throw new IllegalArgumentException(""key was null"");
        }

        T value = mCharacteristics.get(key);

        if (value == null) {
            failKeyCheck(key, ""was null"");
        }

        return value;
    }

    private void checkArrayValuesInRange(Key<int[]> key, int[] array, int min, int max) {
        for (int value : array) {
            checkTrueForKey(key, String.format("" value is out of range [%d, %d]"", min, max),
                    value <= max && value >= min);
        }
    }

    private void checkArrayValuesInRange(Key<byte[]> key, byte[] array, byte min, byte max) {
        for (byte value : array) {
            checkTrueForKey(key, String.format("" value is out of range [%d, %d]"", min, max),
                    value <= max && value >= min);
        }
    }

    /**
     * Check the uniqueness of the values in a list.
     *
     * @param key The key to be checked
     * @param list The list contains the value of the key
     */
    private <U, T> void checkElementDistinct(Key<U> key, List<T> list) {
        // Each size must be distinct.
        Set<T> sizeSet = new HashSet<T>(list);
        checkTrueForKey(key, ""Each size must be distinct"", sizeSet.size() == list.size());
    }

    private <T> void checkTrueForKey(Key<T> key, String message, boolean condition) {
        if (!condition) {
            failKeyCheck(key, message);
        }
    }

    /* Helper function to check if the coupled modes are either all present or all non-present */
    private <T> boolean containsAllOrNone(Collection<T> observedModes, Collection<T> coupledModes) {
        if (observedModes.containsAll(coupledModes)) {
            return true;
        }
        for (T mode : coupledModes) {
            if (observedModes.contains(mode)) {
                return false;
            }
        }
        return true;
    }

    private <T> void failKeyCheck(Key<T> key, String message) {
        // TODO: Consider only warning once per key/message combination if it's too spammy.
        // TODO: Consider offering other options such as throwing an assertion exception
        String failureCause = String.format(""The static info key '%s' %s"", key.getName(), message);
        switch (mLevel) {
            case WARN:
                Log.w(TAG, failureCause);
                break;
            case COLLECT:
                mCollector.addMessage(failureCause);
                break;
            case ASSERT:
                Assert.fail(failureCause);
            default:
                throw new UnsupportedOperationException(""Unhandled level "" + mLevel);
        }
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.scopedstorage.cts.device.ScopedStorageDeviceTest"	"testContributeMediaFile"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/device/src/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java"	""	"public void testContributeMediaFile() throws Exception {
        final File imageFile = new File(getDcimDir(), IMAGE_FILE_NAME);

        try {
            assertThat(imageFile.createNewFile()).isTrue();

            // Ensure that the file was successfully added to the MediaProvider database
            assertThat(getFileOwnerPackageFromDatabase(imageFile)).isEqualTo(THIS_PACKAGE_NAME);

            // Try to write random data to the file
            try (FileOutputStream fos = new FileOutputStream(imageFile)) {
                fos.write(BYTES_DATA1);
                fos.write(BYTES_DATA2);
            }

            final byte[] expected = (STR_DATA1 + STR_DATA2).getBytes();
            assertFileContent(imageFile, expected);

            // Closing the file after writing will not trigger a MediaScan. Call scanFile to update
            // file's entry in MediaProvider's database.
            assertThat(MediaStore.scanFile(getContentResolver(), imageFile)).isNotNull();

            // Ensure that the scan was completed and the file's size was updated.
            assertThat(getFileSizeFromDatabase(imageFile)).isEqualTo(
                    BYTES_DATA1.length + BYTES_DATA2.length);
        } finally {
            imageFile.delete();
        }
        // Ensure that delete makes a call to MediaProvider to remove the file from its database.
        assertThat(getFileRowIdFromDatabase(imageFile)).isEqualTo(-1);
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.scopedstorage.cts.device.ScopedStorageDeviceTest"	"testDeleteAlreadyUnlinkedFile"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/device/src/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java"	""	"public void testDeleteAlreadyUnlinkedFile() throws Exception {
        final File nonMediaFile = new File(getDownloadDir(), NONMEDIA_FILE_NAME);
        try {
            assertTrue(nonMediaFile.createNewFile());
            final Uri uri = MediaStore.scanFile(getContentResolver(), nonMediaFile);
            assertNotNull(uri);

            // Delete the file via filePath
            assertTrue(nonMediaFile.delete());

            // If we delete nonMediaFile with ContentResolver#delete, it shouldn't result in a
            // security exception.
            assertThat(getContentResolver().delete(uri, Bundle.EMPTY)).isEqualTo(0);
        } finally {
            nonMediaFile.delete();
        }
    }

    /**
     * This test relies on the fact that {@link File#list} uses opendir internally, and that it
     * returns {@code null} if opendir fails.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.scopedstorage.cts.device.ScopedStorageDeviceTest"	"testContentResolverUpdate"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/device/src/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java"	""	"public void testContentResolverUpdate() throws Exception {
        String oldDisplayName = ""content_resolver_update_old.jpg"";
        String newDisplayName = ""content_resolver_update_new.jpg"";
        File oldFile = new File(getDcimDir(), oldDisplayName);
        File newFile = new File(getDcimDir(), newDisplayName);

        try {
            assertThat(oldFile.createNewFile()).isTrue();
            // Publish the pending oldFile before updating with MediaProvider. Not publishing the
            // file will make MP consider pending from FUSE as explicit IS_PENDING
            final Uri uri = MediaStore.scanFile(getContentResolver(), oldFile);
            assertNotNull(uri);

            updateDisplayNameWithMediaProvider(uri,
                    Environment.DIRECTORY_DCIM, oldDisplayName, newDisplayName);

            assertThat(oldFile.exists()).isFalse();
            assertThat(oldFile.createNewFile()).isTrue();
            assertThat(newFile.exists()).isTrue();
            assertThat(newFile.createNewFile()).isFalse();
        } finally {
            oldFile.delete();
            newFile.delete();
        }
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.scopedstorage.cts.device.ScopedStorageDeviceTest"	"testSystemGalleryCanRenameImagesAndVideos"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/device/src/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java"	""	"public void testSystemGalleryCanRenameImagesAndVideos() throws Exception {
        final File otherAppVideoFile = new File(getDcimDir(), ""other_"" + VIDEO_FILE_NAME);
        final File imageFile = new File(getPicturesDir(), IMAGE_FILE_NAME);
        final File videoFile = new File(getPicturesDir(), VIDEO_FILE_NAME);
        final File topLevelVideoFile = new File(getExternalStorageDir(), VIDEO_FILE_NAME);
        final File musicFile = new File(getMusicDir(), AUDIO_FILE_NAME);
        try {
            allowAppOpsToUid(Process.myUid(), SYSTEM_GALERY_APPOPS);

            // Have another app create a video file
            assertThat(createFileAs(APP_B_NO_PERMS, otherAppVideoFile.getPath())).isTrue();
            assertThat(otherAppVideoFile.exists()).isTrue();

            // Write some data to the file
            try (FileOutputStream fos = new FileOutputStream(otherAppVideoFile)) {
                fos.write(BYTES_DATA1);
            }
            assertFileContent(otherAppVideoFile, BYTES_DATA1);

            // Assert we can rename the file and ensure the file has the same content
            assertCanRenameFile(otherAppVideoFile, videoFile);
            assertFileContent(videoFile, BYTES_DATA1);
            // We can even move it to the top level directory
            assertCanRenameFile(videoFile, topLevelVideoFile);
            assertFileContent(topLevelVideoFile, BYTES_DATA1);
            // And we can even convert it into an image file, because why not?
            assertCanRenameFile(topLevelVideoFile, imageFile);
            assertFileContent(imageFile, BYTES_DATA1);

            // We can convert it to a music file, but we won't have access to music file after
            // renaming.
            assertThat(imageFile.renameTo(musicFile)).isTrue();
            assertThat(getFileRowIdFromDatabase(musicFile)).isEqualTo(-1);
        } finally {
            deleteFileAsNoThrow(APP_B_NO_PERMS, otherAppVideoFile.getAbsolutePath());
            imageFile.delete();
            videoFile.delete();
            topLevelVideoFile.delete();
            executeShellCommand(""rm  "" + musicFile.getAbsolutePath());
            MediaStore.scanFile(getContentResolver(), musicFile);
            denyAppOpsToUid(Process.myUid(), SYSTEM_GALERY_APPOPS);
        }
    }

    /**
     * Test that basic file path restrictions are enforced on file rename.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.scopedstorage.cts.device.ScopedStorageDeviceTest"	"testRenameAndReplaceFile"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/device/src/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java"	""	"public void testRenameAndReplaceFile() throws Exception {
        final File videoFile1 = new File(getDcimDir(), VIDEO_FILE_NAME);
        final File videoFile2 = new File(getMoviesDir(), VIDEO_FILE_NAME);
        final ContentResolver cr = getContentResolver();
        try {
            assertThat(videoFile1.createNewFile()).isTrue();
            assertThat(videoFile2.createNewFile()).isTrue();
            final Uri uriVideoFile1 = MediaStore.scanFile(cr, videoFile1);
            final Uri uriVideoFile2 = MediaStore.scanFile(cr, videoFile2);

            // Renaming a file which replaces file in newPath videoFile2 is allowed.
            assertCanRenameFile(videoFile1, videoFile2);

            // Uri of videoFile2 should be accessible after rename.
            assertThat(cr.openFileDescriptor(uriVideoFile2, ""rw"")).isNotNull();
            // Uri of videoFile1 should not be accessible after rename.
            assertThrows(FileNotFoundException.class,
                    () -> {
                        cr.openFileDescriptor(uriVideoFile1, ""rw"");
                    });
        } finally {
            videoFile1.delete();
            videoFile2.delete();
        }
    }

    /**
     * Test that ScanFile() after renaming file extension updates the right
     * MIME type from the file metadata.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.scopedstorage.cts.device.ScopedStorageDeviceTest"	"testScanUpdatesMimeTypeForRenameFileExtension"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/device/src/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java"	""	"public void testScanUpdatesMimeTypeForRenameFileExtension() throws Exception {
        final String audioFileName = ""ScopedStorageDeviceTest_"" + NONCE;
        final File mpegFile = new File(getMusicDir(), audioFileName + "".mp3"");
        final File nonMpegFile = new File(getMusicDir(), audioFileName + "".snd"");
        try {
            // Copy audio content to mpegFile
            try (InputStream in =
                         getContext().getResources().openRawResource(R.raw.test_audio);
                 FileOutputStream out = new FileOutputStream(mpegFile)) {
                FileUtils.copy(in, out);
                out.getFD().sync();
            }
            assertThat(MediaStore.scanFile(getContentResolver(), mpegFile)).isNotNull();
            assertThat(getFileMimeTypeFromDatabase(mpegFile)).isEqualTo(""audio/mpeg"");

            // This rename changes MIME type from audio/mpeg to audio/basic
            assertCanRenameFile(mpegFile, nonMpegFile);
            assertThat(getFileMimeTypeFromDatabase(nonMpegFile)).isNotEqualTo(""audio/mpeg"");

            assertThat(MediaStore.scanFile(getContentResolver(), nonMpegFile)).isNotNull();
            // Above scan should read file metadata and update the MIME type to audio/mpeg
            assertThat(getFileMimeTypeFromDatabase(nonMpegFile)).isEqualTo(""audio/mpeg"");
        } finally {
            mpegFile.delete();
            nonMpegFile.delete();
        }
    }

    /**
     * Test that app without write permission for file can't update the file.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.scopedstorage.cts.device.ScopedStorageDeviceTest"	"testInodeStatConsistency"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/device/src/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java"	""	"public void testInodeStatConsistency() throws Exception {
        File file = new File(getDcimDir(), IMAGE_FILE_NAME);

        try {
            byte[] writeBuffer = new byte[10];
            Arrays.fill(writeBuffer, (byte) 1);

            assertThat(file.createNewFile()).isTrue();
            // Scanning a file is essential as files created via filepath will be marked
            // as isPending, and we do not set listener for pending files as it can lead to
            // performance overhead. See: I34611f0ee897dc676e7653beb7943aa6de58c55a.
            MediaStore.scanFile(getContentResolver(), file);

            // File operation #1 (to lower-fs)
            ParcelFileDescriptor writePfd = openWithMediaProvider(file, ""rw"");

            // File operation #2 (to fuse). This caches the inode for the file.
            file.exists();

            // Write bytes directly to lower-fs
            Os.pwrite(writePfd.getFileDescriptor(), writeBuffer, 0, 10, 0);

            // Close should invalidate inode cache for this file.
            writePfd.close();
            Thread.sleep(1000);

            long fuseFileSize = file.length();
            assertThat(writeBuffer.length).isEqualTo(fuseFileSize);
        } finally {
            file.delete();
        }
    }

    /**
     * Test that apps can rename a hidden file.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.scopedstorage.cts.device.ScopedStorageDeviceTest"	"testHiddenDirectory_nomedia"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/device/src/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java"	""	"public void testHiddenDirectory_nomedia() throws Exception {
        final File directoryNoMedia = new File(getDownloadDir(), ""nomedia"" + TEST_DIRECTORY_NAME);
        final File noMediaFile = new File(directoryNoMedia, "".nomedia"");
        final File imageFile = new File(directoryNoMedia, IMAGE_FILE_NAME);
        final File videoFile = new File(directoryNoMedia, VIDEO_FILE_NAME);
        try {
            if (!directoryNoMedia.exists()) {
                assertThat(directoryNoMedia.mkdir()).isTrue();
            }
            assertThat(noMediaFile.createNewFile()).isTrue();
            assertThat(imageFile.createNewFile()).isTrue();

            assertNotMediaTypeImage(imageFile);

            // Deleting the .nomedia file makes the parent directory non hidden.
            noMediaFile.delete();
            MediaStore.scanFile(getContentResolver(), directoryNoMedia);
            assertIsMediaTypeImage(imageFile);

            // Creating the .nomedia file makes the parent directory hidden again
            assertThat(noMediaFile.createNewFile()).isTrue();
            MediaStore.scanFile(getContentResolver(), directoryNoMedia);
            assertNotMediaTypeImage(imageFile);

            // Renaming the .nomedia file to non hidden file makes the parent directory non hidden.
            assertCanRenameFile(noMediaFile, videoFile);
            assertIsMediaTypeImage(imageFile);
        } finally {
            noMediaFile.delete();
            imageFile.delete();
            videoFile.delete();
            directoryNoMedia.delete();
        }
    }

    /**
     * Test that only file manager and app that created the hidden file can list it.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.scopedstorage.cts.device.ScopedStorageDeviceTest"	"testSystemGalleryCanRenameImageAndVideoDirs"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/device/src/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java"	""	"public void testSystemGalleryCanRenameImageAndVideoDirs() throws Exception {
        final File dirInDcim = new File(getDcimDir(), TEST_DIRECTORY_NAME);
        final File dirInPictures = new File(getPicturesDir(), TEST_DIRECTORY_NAME);
        final File dirInPodcasts = new File(getPodcastsDir(), TEST_DIRECTORY_NAME);
        final File otherAppImageFile1 = new File(dirInDcim, ""other_"" + IMAGE_FILE_NAME);
        final File otherAppVideoFile1 = new File(dirInDcim, ""other_"" + VIDEO_FILE_NAME);
        final File otherAppPdfFile1 = new File(dirInDcim, ""other_"" + NONMEDIA_FILE_NAME);
        final File otherAppImageFile2 = new File(dirInPictures, ""other_"" + IMAGE_FILE_NAME);
        final File otherAppVideoFile2 = new File(dirInPictures, ""other_"" + VIDEO_FILE_NAME);
        final File otherAppPdfFile2 = new File(dirInPictures, ""other_"" + NONMEDIA_FILE_NAME);
        try {
            assertThat(dirInDcim.exists() || dirInDcim.mkdir()).isTrue();

            executeShellCommand(""touch "" + otherAppPdfFile1);
            MediaStore.scanFile(getContentResolver(), otherAppPdfFile1);

            allowAppOpsToUid(Process.myUid(), SYSTEM_GALERY_APPOPS);

            assertCreateFilesAs(APP_A_HAS_RES, otherAppImageFile1, otherAppVideoFile1);

            // System gallery privileges don't go beyond DCIM, Movies and Pictures boundaries.
            assertCantRenameDirectory(dirInDcim, dirInPodcasts, /*oldFilesList*/ null);

            // Rename should succeed, but System Gallery still can't access that PDF file!
            assertCanRenameDirectory(dirInDcim, dirInPictures,
                    new File[] {otherAppImageFile1, otherAppVideoFile1},
                    new File[] {otherAppImageFile2, otherAppVideoFile2});
            assertThat(getFileRowIdFromDatabase(otherAppPdfFile1)).isEqualTo(-1);
            assertThat(getFileRowIdFromDatabase(otherAppPdfFile2)).isEqualTo(-1);
        } finally {
            executeShellCommand(""rm "" + otherAppPdfFile1);
            executeShellCommand(""rm "" + otherAppPdfFile2);
            MediaStore.scanFile(getContentResolver(), otherAppPdfFile1);
            MediaStore.scanFile(getContentResolver(), otherAppPdfFile2);
            otherAppImageFile1.delete();
            otherAppImageFile2.delete();
            otherAppVideoFile1.delete();
            otherAppVideoFile2.delete();
            otherAppPdfFile1.delete();
            otherAppPdfFile2.delete();
            dirInDcim.delete();
            dirInPictures.delete();
            denyAppOpsToUid(Process.myUid(), SYSTEM_GALERY_APPOPS);
        }
    }

    /**
     * Test that row ID corresponding to deleted path is restored on subsequent create.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.scopedstorage.cts.device.ScopedStorageDeviceTest"	"testCreateCanRestoreDeletedRowId"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/device/src/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java"	""	"public void testCreateCanRestoreDeletedRowId() throws Exception {
        final File imageFile = new File(getDcimDir(), IMAGE_FILE_NAME);
        final ContentResolver cr = getContentResolver();

        try {
            assertThat(imageFile.createNewFile()).isTrue();
            final long oldRowId = getFileRowIdFromDatabase(imageFile);
            assertThat(oldRowId).isNotEqualTo(-1);
            final Uri uriOfOldFile = MediaStore.scanFile(cr, imageFile);
            assertThat(uriOfOldFile).isNotNull();

            assertThat(imageFile.delete()).isTrue();
            // We should restore old row Id corresponding to deleted imageFile.
            assertThat(imageFile.createNewFile()).isTrue();
            assertThat(getFileRowIdFromDatabase(imageFile)).isEqualTo(oldRowId);
            assertThat(cr.openFileDescriptor(uriOfOldFile, ""rw"")).isNotNull();

            assertThat(imageFile.delete()).isTrue();
            assertThat(createFileAs(APP_B_NO_PERMS, imageFile.getAbsolutePath())).isTrue();

            final Uri uriOfNewFile = MediaStore.scanFile(getContentResolver(), imageFile);
            assertThat(uriOfNewFile).isNotNull();
            // We shouldn't restore deleted row Id if delete & create are called from different apps
            assertThat(Integer.getInteger(uriOfNewFile.getLastPathSegment()))
                    .isNotEqualTo(oldRowId);
        } finally {
            imageFile.delete();
            deleteFileAsNoThrow(APP_B_NO_PERMS, imageFile.getAbsolutePath());
        }
    }

    /**
     * Test that row ID corresponding to deleted path is restored on subsequent rename.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.scopedstorage.cts.device.ScopedStorageDeviceTest"	"testRenameCanRestoreDeletedRowId"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/device/src/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java"	""	"public void testRenameCanRestoreDeletedRowId() throws Exception {
        final File imageFile = new File(getDcimDir(), IMAGE_FILE_NAME);
        final File temporaryFile = new File(getDownloadDir(), IMAGE_FILE_NAME + ""_.tmp"");
        final ContentResolver cr = getContentResolver();

        try {
            assertThat(imageFile.createNewFile()).isTrue();
            final Uri oldUri = MediaStore.scanFile(cr, imageFile);
            assertThat(oldUri).isNotNull();

            Files.copy(imageFile, temporaryFile);
            assertThat(imageFile.delete()).isTrue();
            assertCanRenameFile(temporaryFile, imageFile);

            final Uri newUri = MediaStore.scanFile(cr, imageFile);
            assertThat(newUri).isNotNull();
            assertThat(newUri.getLastPathSegment()).isEqualTo(oldUri.getLastPathSegment());
            // oldUri of imageFile is still accessible after delete and rename.
            assertThat(cr.openFileDescriptor(oldUri, ""rw"")).isNotNull();
        } finally {
            imageFile.delete();
            temporaryFile.delete();
        }
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.scopedstorage.cts.device.ScopedStorageDeviceTest"	"testPendingFromFuse"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/device/src/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java"	""	"public void testPendingFromFuse() throws Exception {
        final File pendingFile = new File(getDcimDir(), IMAGE_FILE_NAME);
        final File otherPendingFile = new File(getDcimDir(), VIDEO_FILE_NAME);
        try {
            assertTrue(pendingFile.createNewFile());
            // Newly created file should have IS_PENDING set
            try (Cursor c = queryFile(pendingFile, MediaStore.MediaColumns.IS_PENDING)) {
                assertTrue(c.moveToFirst());
                assertThat(c.getInt(0)).isEqualTo(1);
            }

            // If we query with MATCH_EXCLUDE, we should still see this pendingFile
            try (Cursor c = queryFileExcludingPending(pendingFile,
                    MediaStore.MediaColumns.IS_PENDING)) {
                assertThat(c.getCount()).isEqualTo(1);
                assertTrue(c.moveToFirst());
                assertThat(c.getInt(0)).isEqualTo(1);
            }

            assertNotNull(MediaStore.scanFile(getContentResolver(), pendingFile));

            // IS_PENDING should be unset after the scan
            try (Cursor c = queryFile(pendingFile, MediaStore.MediaColumns.IS_PENDING)) {
                assertTrue(c.moveToFirst());
                assertThat(c.getInt(0)).isEqualTo(0);
            }

            assertCreateFilesAs(APP_A_HAS_RES, otherPendingFile);
            // We can't query other apps pending file from FUSE with MATCH_EXCLUDE
            try (Cursor c = queryFileExcludingPending(otherPendingFile,
                    MediaStore.MediaColumns.IS_PENDING)) {
                assertThat(c.getCount()).isEqualTo(0);
            }
        } finally {
            pendingFile.delete();
            deleteFileAsNoThrow(APP_A_HAS_RES, otherPendingFile.getAbsolutePath());
        }
    }

    /**
     * Test that we don't allow renaming to top level directory
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.scopedstorage.cts.device.ScopedStorageDeviceTest"	"testNoMediaDoesntHideSpecialDirectories"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/device/src/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java"	""	"public void testNoMediaDoesntHideSpecialDirectories() throws Exception {
        for (File directory : new File [] {
                getDcimDir(),
                getDownloadDir(),
                new File(getDcimDir(), ""Camera""),
                new File(getPicturesDir(), Environment.DIRECTORY_SCREENSHOTS),
                new File(getMoviesDir(), Environment.DIRECTORY_SCREENSHOTS),
                new File(getExternalStorageDir(), Environment.DIRECTORY_SCREENSHOTS)
        }) {
            assertNoMediaDoesntHideSpecialDirectories(directory);
        }
    }

    private void assertNoMediaDoesntHideSpecialDirectories(File directory) throws Exception {
        final File nomediaFile = new File(directory, "".nomedia"");
        final File videoFile = new File(directory, VIDEO_FILE_NAME);
        Log.d(TAG, ""Directory "" + directory);

        try {
            // Recreate required file and directory
            if (!directory.exists()) {
                Log.d(TAG, ""mkdir directory "" + directory);
                createDirectoryAsLegacyApp(directory);
            }
            assertWithMessage(""Exists "" + directory).that(directory.exists()).isTrue();

            Log.d(TAG, ""CreateFileAs "" + nomediaFile);
            createFileAsLegacyApp(nomediaFile);
            assertWithMessage(""Exists "" + nomediaFile).that(nomediaFile.exists()).isTrue();

            createFileAsLegacyApp(videoFile);
            assertWithMessage(""Exists "" + videoFile).that(videoFile.exists()).isTrue();
            final Uri targetUri = MediaStore.scanFile(getContentResolver(), videoFile);
            assertWithMessage(""Scan result for "" + videoFile).that(targetUri)
                    .isNotNull();

            assertWithMessage(""Uri path segment for "" + targetUri)
                    .that(targetUri.getPathSegments()).contains(""video"");

            // Verify that the imageFile is not hidden because of .nomedia presence
            assertWithMessage(""Query as other app "")
                    .that(canQueryOnUri(APP_A_HAS_RES, targetUri)).isTrue();
        } finally {
            deleteAsLegacyApp(videoFile);
            deleteAsLegacyApp(nomediaFile);
            deleteAsLegacyApp(directory);
        }
    }

    /**
     * Test that readdir lists unsupported file types in default directories.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.scopedstorage.cts.device.ScopedStorageDeviceTest"	"testListUnsupportedFileType"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/device/src/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java"	""	"public void testListUnsupportedFileType() throws Exception {
        final File pdfFile = new File(getDcimDir(), NONMEDIA_FILE_NAME);
        final File videoFile = new File(getMusicDir(), VIDEO_FILE_NAME);
        try {
            // TEST_APP_A with storage permission should not see pdf file in DCIM
            createFileAsLegacyApp(pdfFile);
            assertThat(pdfFile.exists()).isTrue();
            assertThat(MediaStore.scanFile(getContentResolver(), pdfFile)).isNotNull();

            assertThat(listAs(APP_A_HAS_RES, getDcimDir().getPath()))
                    .doesNotContain(NONMEDIA_FILE_NAME);

            createFileAsLegacyApp(videoFile);
            // We don't insert files to db for files created by shell.
            assertThat(MediaStore.scanFile(getContentResolver(), videoFile)).isNotNull();
            // TEST_APP_A with storage permission should see video file in Music directory.
            assertThat(listAs(APP_A_HAS_RES, getMusicDir().getPath())).contains(VIDEO_FILE_NAME);
        } finally {
            deleteAsLegacyApp(pdfFile);
            deleteAsLegacyApp(videoFile);
            MediaStore.scanFile(getContentResolver(), pdfFile);
            MediaStore.scanFile(getContentResolver(), videoFile);
        }
    }

    /**
     * Test that normal apps cannot access Android/data and Android/obb dirs of other apps
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.scopedstorage.cts.device.ScopedStorageDeviceTest"	"testCantSetAttrOtherAppsFile"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/device/src/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java"	""	"public void testCantSetAttrOtherAppsFile() throws Exception {
        // This path's permission is checked in MediaProvider (directory/external media dir)
        final File externalMediaPath = new File(getExternalMediaDir(), VIDEO_FILE_NAME);

        try {
            // Create the files
            if (!externalMediaPath.exists()) {
                assertThat(externalMediaPath.createNewFile()).isTrue();
            }

            // APP A should not be able to setattr to other app's files.
            assertWithMessage(
                    ""setattr on directory/external media path [%s]"", externalMediaPath.getPath())
                    .that(setAttrAs(APP_A_HAS_RES, externalMediaPath.getPath()))
                    .isFalse();
        } finally {
            externalMediaPath.delete();
        }
    }

    /**
     * b/171768780: Test that scan doesn't skip scanning renamed hidden file.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.scopedstorage.cts.device.ScopedStorageDeviceTest"	"testScanUpdatesMetadataForRenamedHiddenFile"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/device/src/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java"	""	"public void testScanUpdatesMetadataForRenamedHiddenFile() throws Exception {
        final File hiddenFile = new File(getPicturesDir(), "".hidden_"" + IMAGE_FILE_NAME);
        final File jpgFile = new File(getPicturesDir(), IMAGE_FILE_NAME);
        try {
            // Copy the image content to hidden file
            try (InputStream in =
                         getContext().getResources().openRawResource(R.raw.img_with_metadata);
                 FileOutputStream out = new FileOutputStream(hiddenFile)) {
                FileUtils.copy(in, out);
                out.getFD().sync();
            }
            Uri scanUri = MediaStore.scanFile(getContentResolver(), hiddenFile);
            assertNotNull(scanUri);

            // Rename hidden file to non-hidden
            assertCanRenameFile(hiddenFile, jpgFile);

            try (Cursor c = queryFile(jpgFile, MediaStore.MediaColumns.DATE_TAKEN)) {
                assertTrue(c.moveToFirst());
                // The file is not scanned yet, hence the metadata is not updated yet.
                assertThat(c.getString(0)).isNull();
            }

            // Scan the file to update the metadata for renamed hidden file.
            scanUri = MediaStore.scanFile(getContentResolver(), jpgFile);
            assertNotNull(scanUri);

            // Scan should be able to update metadata even if File.lastModifiedTime hasn't changed.
            try (Cursor c = queryFile(jpgFile, MediaStore.MediaColumns.DATE_TAKEN)) {
                assertTrue(c.moveToFirst());
                assertThat(c.getString(0)).isNotNull();
            }
        } finally {
            hiddenFile.delete();
            jpgFile.delete();
        }
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.scopedstorage.cts.device.ScopedStorageDeviceTest"	"testDeferredScanHidesPartialDatabaseRows"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/device/src/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java"	""	"public void testDeferredScanHidesPartialDatabaseRows() throws Exception {
        ContentValues values = new ContentValues();
        values.put(MediaStore.MediaColumns.IS_PENDING, 1);
        // Insert a pending row
        final Uri targetUri = getContentResolver().insert(getImageContentUri(), values, null);
        try (InputStream in =
                     getContext().getResources().openRawResource(R.raw.img_with_metadata)) {
            try (ParcelFileDescriptor pfd =
                         getContentResolver().openFileDescriptor(targetUri, ""w"")) {
                // Write image content to the file
                FileUtils.copy(in, new ParcelFileDescriptor.AutoCloseOutputStream(pfd));
            }
        }

        // Verify that metadata is not updated yet.
        try (Cursor c = getContentResolver().query(targetUri, new String[] {
                MediaStore.Images.ImageColumns.DATE_TAKEN}, null, null)) {
            assertThat(c.moveToFirst()).isTrue();
            assertThat(c.getString(0)).isNull();
        }
        // Get file path to use in the next query().
        final String imageFilePath = getFilePathFromUri(targetUri);

        values.put(MediaStore.MediaColumns.IS_PENDING, 0);
        Bundle extras = new Bundle();
        extras.putBoolean(MediaStore.QUERY_ARG_DEFER_SCAN, true);
        // Publish the file, but, defer the scan on update().
        assertThat(getContentResolver().update(targetUri, values, extras)).isEqualTo(1);

        // The update() above can return before scanning is complete. Verify that either we don't
        // see the file in published files or if the file appears in the collection, it means that
        // deferred scan is now complete, hence verify metadata is intact.
        try (Cursor c = getContentResolver().query(getImageContentUri(),
                new String[] {MediaStore.Images.ImageColumns.DATE_TAKEN},
                MediaStore.Files.FileColumns.DATA + ""=?"", new String[] {imageFilePath}, null)) {
            if (c.getCount() == 1) {
                // If the file appears in media collection as published file, verify that metadata
                // is correct.
                assertThat(c.moveToFirst()).isTrue();
                assertThat(c.getString(0)).isNotNull();
                Log.i(TAG, ""Verified that deferred scan on "" + imageFilePath + "" is complete""
                        + "" and hence metadata is updated"");

            } else {
                assertThat(c.getCount()).isEqualTo(0);
                Log.i(TAG, ""Verified that "" + imageFilePath + "" was excluded in default query"");
            }
        }
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.scopedstorage.cts.device.ScopedStorageDeviceTest"	"testExternalStorageProviderAndDownloadsProvider"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/device/src/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java"	""	"@SdkSuppress(minSdkVersion = 31, codeName = ""S"")
    public void testExternalStorageProviderAndDownloadsProvider() throws Exception {
        assertWritableMountModeForProvider(DocumentsContract.EXTERNAL_STORAGE_PROVIDER_AUTHORITY);
        assertWritableMountModeForProvider(DocumentsContract.DOWNLOADS_PROVIDER_AUTHORITY);
    }

    private void assertWritableMountModeForProvider(String auth) {
        final ProviderInfo provider = getContext().getPackageManager()
                .resolveContentProvider(auth, 0);
        int uid = provider.applicationInfo.uid;
        final String packageName = provider.applicationInfo.packageName;

        assertMountMode(packageName, uid, StorageManager.MOUNT_MODE_EXTERNAL_ANDROID_WRITABLE);
    }

    private boolean canRenameFile(File file) {
        return file.renameTo(new File(file.getAbsolutePath() + ""test""));
    }

    private void testTransformsDirCommon(File file) throws Exception {
        assertThat(file.delete()).isFalse();
        assertThat(canRenameFile(file)).isFalse();

        final File newFile = new File(file.getAbsolutePath(), ""test"");
        assertThat(newFile.mkdir()).isFalse();
        assertThrows(IOException.class, () -> newFile.createNewFile());
    }

    private void assertCanWriteAndRead(File file, byte[] data) throws Exception {
        // Assert we can write to images/videos
        try (FileOutputStream fos = new FileOutputStream(file)) {
            fos.write(data);
        }
        assertFileContent(file, data);
    }

    /**
     * Checks restrictions for opening pending and trashed files by different apps. Assumes that
     * given {@code testApp} is already installed and has READ_EXTERNAL_STORAGE permission. This
     * method doesn't uninstall given {@code testApp} at the end.
     */
    private void assertOpenPendingOrTrashed(Uri uri, boolean isImageOrVideo)
            throws Exception {
        final File pendingOrTrashedFile = new File(getFilePathFromUri(uri));

        // App can open its pending or trashed file for read or write
        assertTrue(canOpen(pendingOrTrashedFile, /*forWrite*/ false));
        assertTrue(canOpen(pendingOrTrashedFile, /*forWrite*/ true));

        // App with READ_EXTERNAL_STORAGE can't open other app's pending or trashed file for read or
        // write
        assertFalse(canOpenFileAs(APP_A_HAS_RES, pendingOrTrashedFile, /*forWrite*/ false));
        assertFalse(canOpenFileAs(APP_A_HAS_RES, pendingOrTrashedFile, /*forWrite*/ true));

        assertTrue(canOpenFileAs(APP_FM, pendingOrTrashedFile, /*forWrite*/ false));
        assertTrue(canOpenFileAs(APP_FM, pendingOrTrashedFile, /*forWrite*/ true));

        final int resAppUid =
                getContext().getPackageManager().getPackageUid(APP_A_HAS_RES.getPackageName(), 0);
        try {
            allowAppOpsToUid(resAppUid, SYSTEM_GALERY_APPOPS);
            if (isImageOrVideo) {
                // System Gallery can open any pending or trashed image/video file for read or write
                assertTrue(isMediaTypeImageOrVideo(pendingOrTrashedFile));
                assertTrue(canOpenFileAs(APP_A_HAS_RES, pendingOrTrashedFile, /*forWrite*/ false));
                assertTrue(canOpenFileAs(APP_A_HAS_RES, pendingOrTrashedFile, /*forWrite*/ true));
            } else {
                // System Gallery can't open other app's pending or trashed non-media file for read
                // or write
                assertFalse(isMediaTypeImageOrVideo(pendingOrTrashedFile));
                assertFalse(canOpenFileAs(APP_A_HAS_RES, pendingOrTrashedFile, /*forWrite*/ false));
                assertFalse(canOpenFileAs(APP_A_HAS_RES, pendingOrTrashedFile, /*forWrite*/ true));
            }
        } finally {
            denyAppOpsToUid(resAppUid, SYSTEM_GALERY_APPOPS);
        }
    }

    /**
     * Checks restrictions for listing pending and trashed files by different apps.
     */
    private void assertListPendingOrTrashed(Uri uri, File file, boolean isImageOrVideo)
            throws Exception {
        final String parentDirPath = file.getParent();
        assertTrue(new File(parentDirPath).isDirectory());

        final List<String> listedFileNames = Arrays.asList(new File(parentDirPath).list());
        assertThat(listedFileNames).doesNotContain(file);

        final File pendingOrTrashedFile = new File(getFilePathFromUri(uri));

        assertThat(listedFileNames).contains(pendingOrTrashedFile.getName());

        // App with READ_EXTERNAL_STORAGE can't see other app's pending or trashed file.
        assertThat(listAs(APP_A_HAS_RES, parentDirPath)).doesNotContain(
                pendingOrTrashedFile.getName());

        final int resAppUid =
                getContext().getPackageManager().getPackageUid(APP_A_HAS_RES.getPackageName(), 0);
        // File Manager can see any pending or trashed file.
        assertThat(listAs(APP_FM, parentDirPath)).contains(pendingOrTrashedFile.getName());


        try {
            allowAppOpsToUid(resAppUid, SYSTEM_GALERY_APPOPS);
            if (isImageOrVideo) {
                // System Gallery can see any pending or trashed image/video file.
                assertTrue(isMediaTypeImageOrVideo(pendingOrTrashedFile));
                assertThat(listAs(APP_A_HAS_RES, parentDirPath)).contains(
                        pendingOrTrashedFile.getName());
            } else {
                // System Gallery can't see other app's pending or trashed non media file.
                assertFalse(isMediaTypeImageOrVideo(pendingOrTrashedFile));
                assertThat(listAs(APP_A_HAS_RES, parentDirPath))
                        .doesNotContain(pendingOrTrashedFile.getName());
            }
        } finally {
            denyAppOpsToUid(resAppUid, SYSTEM_GALERY_APPOPS);
        }
    }

    private Uri createPendingFile(File pendingFile) throws Exception {
        assertTrue(pendingFile.createNewFile());

        final ContentResolver cr = getContentResolver();
        final Uri trashedFileUri = MediaStore.scanFile(cr, pendingFile);
        assertNotNull(trashedFileUri);

        final ContentValues values = new ContentValues();
        values.put(MediaStore.MediaColumns.IS_PENDING, 1);
        assertEquals(1, cr.update(trashedFileUri, values, Bundle.EMPTY));

        return trashedFileUri;
    }

    private Uri createTrashedFile(File trashedFile) throws Exception {
        assertTrue(trashedFile.createNewFile());

        final ContentResolver cr = getContentResolver();
        final Uri trashedFileUri = MediaStore.scanFile(cr, trashedFile);
        assertNotNull(trashedFileUri);

        trashFile(trashedFileUri);
        return trashedFileUri;
    }

    private void trashFile(Uri uri) throws Exception {
        final ContentValues values = new ContentValues();
        values.put(MediaStore.MediaColumns.IS_TRASHED, 1);
        assertEquals(1, getContentResolver().update(uri, values, Bundle.EMPTY));
    }

    /**
     * Gets file path corresponding to the db row pointed by {@code uri}. If {@code uri} points to
     * multiple db rows, file path is extracted from the first db row of the database query result.
     */
    private String getFilePathFromUri(Uri uri) {
        final String[] projection = new String[] {MediaStore.MediaColumns.DATA};
        try (Cursor c = getContentResolver().query(uri, projection, null, null)) {
            assertTrue(c.moveToFirst());
            return c.getString(0);
        }
    }

    private boolean isMediaTypeImageOrVideo(File file) {
        return queryImageFile(file).getCount() == 1 || queryVideoFile(file).getCount() == 1;
    }

    private static void assertIsMediaTypeImage(File file) {
        final Cursor c = queryImageFile(file);
        assertEquals(1, c.getCount());
    }

    private static void assertNotMediaTypeImage(File file) {
        final Cursor c = queryImageFile(file);
        assertEquals(0, c.getCount());
    }

    private static void assertCantQueryFile(File file) {
        assertThat(getFileUri(file)).isNull();
        // Confirm that file exists in the database.
        assertNotNull(MediaStore.scanFile(getContentResolver(), file));
    }

    private static void assertCreateFilesAs(TestApp testApp, File... files) throws Exception {
        for (File file : files) {
            assertFalse(""File already exists: "" + file, file.exists());
            assertTrue(""Failed to create file "" + file + "" on behalf of ""
                    + testApp.getPackageName(), createFileAs(testApp, file.getPath()));
        }
    }

    /**
     * Makes {@code testApp} create {@code files}. Publishes {@code files} by scanning the file.
     * Pending files from FUSE are not visible to other apps via MediaStore APIs. We have to publish
     * the file or make the file non-pending to make the file visible to other apps.
     * <p>
     * Note that this method can only be used for scannable files.
     */
    private static void assertCreatePublishedFilesAs(TestApp testApp, File... files)
            throws Exception {
        for (File file : files) {
            assertTrue(""Failed to create published file "" + file + "" on behalf of ""
                    + testApp.getPackageName(), createFileAs(testApp, file.getPath()));
            assertNotNull(""Failed to scan "" + file,
                    MediaStore.scanFile(getContentResolver(), file));
        }
    }


    private static void deleteFilesAs(TestApp testApp, File... files) throws Exception {
        for (File file : files) {
            deleteFileAs(testApp, file.getPath());
        }
    }
    private static void assertCanDeletePathsAs(TestApp testApp, String... filePaths)
            throws Exception {
        for (String path: filePaths) {
            assertTrue(""Failed to delete file "" + path + "" on behalf of ""
                    + testApp.getPackageName(), deleteFileAs(testApp, path));
        }
    }

    private static void assertCantDeletePathsAs(TestApp testApp, String... filePaths)
            throws Exception {
        for (String path: filePaths) {
            assertFalse(""Deleting "" + path + "" on behalf of "" + testApp.getPackageName()
                    + "" was expected to fail"", deleteFileAs(testApp, path));
        }
    }

    private void deleteFiles(File... files) {
        for (File file: files) {
            if (file == null) continue;
            file.delete();
        }
    }

    private void deletePaths(String... paths) {
        for (String path: paths) {
            if (path == null) continue;
            new File(path).delete();
        }
    }

    private static void assertCanDeletePaths(String... filePaths) {
        for (String filePath : filePaths) {
            assertTrue(""Failed to delete "" + filePath,
                    new File(filePath).delete());
        }
    }

    /**
     * For possible values of {@code mode}, look at {@link android.content.ContentProvider#openFile}
     */
    private static void assertCanQueryAndOpenFile(File file, String mode) throws IOException {
        // This call performs the query
        final Uri fileUri = getFileUri(file);
        // The query succeeds iff it didn't return null
        assertThat(fileUri).isNotNull();
        // Now we assert that we can open the file through ContentResolver
        try (ParcelFileDescriptor pfd =
                     getContentResolver().openFileDescriptor(fileUri, mode)) {
            assertThat(pfd).isNotNull();
        }
    }

    /**
     * Assert that the last read in: read - write - read using {@code readFd} and {@code writeFd}
     * see the last write. {@code readFd} and {@code writeFd} are fds pointing to the same
     * underlying file on disk but may be derived from different mount points and in that case
     * have separate VFS caches.
     */
    private void assertRWR(ParcelFileDescriptor readPfd, ParcelFileDescriptor writePfd)
            throws Exception {
        FileDescriptor readFd = readPfd.getFileDescriptor();
        FileDescriptor writeFd = writePfd.getFileDescriptor();

        byte[] readBuffer = new byte[10];
        byte[] writeBuffer = new byte[10];
        Arrays.fill(writeBuffer, (byte) 1);

        // Write so readFd has content to read from next
        Os.pwrite(readFd, readBuffer, 0, 10, 0);
        // Read so readBuffer is in readFd's mount VFS cache
        Os.pread(readFd, readBuffer, 0, 10, 0);

        // Assert that readBuffer is zeroes
        assertThat(readBuffer).isEqualTo(new byte[10]);

        // Write so writeFd and readFd should now see writeBuffer
        Os.pwrite(writeFd, writeBuffer, 0, 10, 0);

        // Read so the last write can be verified on readFd
        Os.pread(readFd, readBuffer, 0, 10, 0);

        // Assert that the last write is indeed visible via readFd
        assertThat(readBuffer).isEqualTo(writeBuffer);
        assertThat(readPfd.getStatSize()).isEqualTo(writePfd.getStatSize());
    }

    private void assertStartsWith(String actual, String prefix) throws Exception {
        String message = ""String \"""" + actual + ""\"" should start with \"""" + prefix + ""\"""";

        assertWithMessage(message).that(actual).startsWith(prefix);
    }

    private void assertLowerFsFd(ParcelFileDescriptor pfd) throws Exception {
        String path = Os.readlink(""/proc/self/fd/"" + pfd.getFd());
        String prefix = ""/storage"";

        assertStartsWith(path, prefix);
    }

    private void assertUpperFsFd(ParcelFileDescriptor pfd) throws Exception {
        String path = Os.readlink(""/proc/self/fd/"" + pfd.getFd());
        String prefix = ""/mnt/user"";

        assertStartsWith(path, prefix);
    }

    private void assertLowerFsFdWithPassthrough(ParcelFileDescriptor pfd) throws Exception {
        if (getBoolean(""persist.sys.fuse.passthrough.enable"", false)) {
            assertUpperFsFd(pfd);
        } else {
            assertLowerFsFd(pfd);
        }
    }

    private static void assertCanCreateFile(File file) throws IOException {
        // If the file somehow managed to survive a previous run, then the test app was uninstalled
        // and MediaProvider will remove our its ownership of the file, so it's not guaranteed that
        // we can create nor delete it.
        if (!file.exists()) {
            assertThat(file.createNewFile()).isTrue();
            assertThat(file.delete()).isTrue();
        } else {
            Log.w(TAG,
                    ""Couldn't assertCanCreateFile("" + file + "") because file existed prior to ""
                            + ""running the test!"");
        }
    }

    private static void assertCannotReadOrWrite(File file)
            throws Exception {
        // App data directories have different 'x' bits on upgrading vs new devices. Let's not
        // check 'exists', by passing checkExists=false. But assert this app cannot read or write
        // the other app's file.
        assertAccess(file, false /* value is moot */, false /* canRead */,
                false /* canWrite */, false /* checkExists */);
    }

    private static void assertAccess(File file, boolean exists, boolean canRead, boolean canWrite)
            throws Exception {
        assertAccess(file, exists, canRead, canWrite, true /* checkExists */);
    }

    private static void assertAccess(File file, boolean exists, boolean canRead, boolean canWrite,
            boolean checkExists) throws Exception {
        if (checkExists) {
            assertThat(file.exists()).isEqualTo(exists);
        }
        assertThat(file.canRead()).isEqualTo(canRead);
        assertThat(file.canWrite()).isEqualTo(canWrite);
        if (file.isDirectory()) {
            if (checkExists) {
                assertThat(file.canExecute()).isEqualTo(exists);
            }
        } else {
            assertThat(file.canExecute()).isFalse(); // Filesytem is mounted with MS_NOEXEC
        }

        // Test some combinations of mask.
        assertAccess(file, R_OK, canRead);
        assertAccess(file, W_OK, canWrite);
        assertAccess(file, R_OK | W_OK, canRead && canWrite);
        assertAccess(file, W_OK | F_OK, canWrite);

        if (checkExists) {
            assertAccess(file, F_OK, exists);
        }
    }

    private static void assertAccess(File file, int mask, boolean expected) throws Exception {
        if (expected) {
            assertThat(Os.access(file.getAbsolutePath(), mask)).isTrue();
        } else {
            assertThrows(ErrnoException.class, () -> {
                Os.access(file.getAbsolutePath(), mask);
            });
        }
    }

    /**
     * Creates a file at any location on storage (except external app data directory).
     * The owner of the file is not the caller app.
     */
    private void createFileAsLegacyApp(File file) throws Exception {
        // Use a legacy app to create this file, since it could be outside shared storage.
        Log.d(TAG, ""Creating file "" + file);
        assertThat(createFileAs(APP_D_LEGACY_HAS_RW, file.getAbsolutePath())).isTrue();
    }

    /**
     * Creates a file at any location on storage (except external app data directory).
     * The owner of the file is not the caller app.
     */
    private void createDirectoryAsLegacyApp(File file) throws Exception {
        // Use a legacy app to create this file, since it could be outside shared storage.
        Log.d(TAG, ""Creating directory "" + file);
        // Create a tmp file in the target directory, this would also create the required
        // directory, then delete the tmp file. It would leave only new directory.
        assertThat(createFileAs(APP_D_LEGACY_HAS_RW, file.getAbsolutePath() + ""/tmp.txt"")).isTrue();
        assertThat(deleteFileAs(APP_D_LEGACY_HAS_RW, file.getAbsolutePath() + ""/tmp.txt"")).isTrue();
    }

    /**
     * Deletes a file or directory at any location on storage (except external app data directory).
     */
    private void deleteAsLegacyApp(File file) throws Exception {
        // Use a legacy app to delete this file, since it could be outside shared storage.
        Log.d(TAG, ""Deleting file "" + file);
        deleteFileAs(APP_D_LEGACY_HAS_RW, file.getAbsolutePath());
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.providerui.cts.MediaStoreUiTest"	"testGetMediaUriAccess_MediaDocumentsProvider"	"CtsProviderUiTestCases"	"/home/gpoor/cts-12-source/cts/tests/providerui/src/android/providerui/cts/MediaStoreUiTest.java"	""	"public void testGetMediaUriAccess_MediaDocumentsProvider() throws Exception {
        if (!supportsHardware()) return;

        prepareFile();
        clearDocumentsUi();
        final Intent intent = new Intent();
        intent.setAction(Intent.ACTION_OPEN_DOCUMENT);
        intent.addCategory(Intent.CATEGORY_OPENABLE);
        intent.setType(""*/*"");
        mActivity.startActivityForResult(intent, REQUEST_CODE);
        mDevice.waitForIdle();

        findDocument(mFile.getName()).click();
        final Result result = mActivity.getResult();
        final Uri uri = result.data.getData();
        assertEquals(MEDIA_DOCUMENTS_PROVIDER_AUTHORITY, uri.getAuthority());
        final Uri mediaUri = MediaStore.getMediaUri(mActivity, uri);

        assertAccessToMediaUri(mediaUri, mFile);
    }

    private void assertAccessToMediaUri(Uri mediaUri, File file) {
        final String[] projection = {MediaStore.MediaColumns.DISPLAY_NAME};
        try (Cursor c = mContext.getContentResolver().query(
                mediaUri, projection, null, null, null)) {
            assertTrue(c.moveToFirst());
            assertEquals(file.getName(), c.getString(0));
        }
    }

    /**
     * Clears the DocumentsUI package data.
     */
    protected void clearDocumentsUi() throws Exception {
        executeShellCommand(""pm clear "" + getDocumentsUiPackageId());
    }

    private UiObject findDocument(String label) throws UiObjectNotFoundException {
        final UiSelector docList = new UiSelector().resourceId(getDocumentsUiPackageId()
                + "":id/dir_list"");

        // Wait for the first list item to appear
        assertTrue(""First list item"",
                new UiObject(docList.childSelector(new UiSelector()))
                        .waitForExists(TIMEOUT_MILLIS));

        try {
            //Enforce to set the list mode
            //Because UiScrollable can't reach the real bottom (when WEB_LINKABLE_FILE item)
            // in grid mode when screen landscape mode
            new UiObject(new UiSelector().resourceId(getDocumentsUiPackageId()
                    + "":id/sub_menu_list"")).click();
            mDevice.waitForIdle();
        }catch (UiObjectNotFoundException e){
            //do nothing, already be in list mode.
        }

        // Repeat swipe gesture to find our item
        // (UiScrollable#scrollIntoView does not seem to work well with SwipeRefreshLayout)
        UiObject targetObject = new UiObject(docList.childSelector(new UiSelector().text(label)));
        UiObject saveButton = findSaveButton();
        int stepLimit = 10;
        while (stepLimit-- > 0) {
            if (targetObject.exists()) {
                boolean targetObjectFullyVisible = !saveButton.exists()
                        || targetObject.getVisibleBounds().bottom
                        <= saveButton.getVisibleBounds().top;
                if (targetObjectFullyVisible) {
                    break;
                }
            }

            mDevice.swipe(/* startX= */ mDevice.getDisplayWidth() / 2,
                    /* startY= */ mDevice.getDisplayHeight() / 2,
                    /* endX= */ mDevice.getDisplayWidth() / 2,
                    /* endY= */ 0,
                    /* steps= */ 40);
        }
        return targetObject;
    }

    private UiObject findSaveButton() throws UiObjectNotFoundException {
        return new UiObject(new UiSelector().resourceId(
                getDocumentsUiPackageId() + "":id/container_save"")
                .childSelector(new UiSelector().resourceId(""android:id/button1"")));
    }

    private String getDocumentsUiPackageId() {
        return mDocumentsUiPackageId;
    }

    private boolean supportsHardware() {
        final PackageManager pm = mContext.getPackageManager();
        return !pm.hasSystemFeature(""android.hardware.type.television"")
                && !pm.hasSystemFeature(""android.hardware.type.watch"");
    }

    public File getVolumePath(String volumeName) {
        return mContext.getSystemService(StorageManager.class)
                .getStorageVolume(MediaStore.Files.getContentUri(volumeName)).getDirectory();
    }

    private void prepareFile() throws Exception {
        final File dir = new File(getVolumePath(mVolumeName),
                Environment.DIRECTORY_DOCUMENTS);
        final File file = new File(dir, ""cts"" + System.nanoTime() + "".txt"");

        mFile = stageFile(R.raw.text, file);
        mMediaStoreUri = MediaStore.scanFile(mContext.getContentResolver(), mFile);

        Log.v(TAG, ""Staged "" + mFile + "" as "" + mMediaStoreUri);
    }

    private void assertToolbarTitleEquals(String targetPackageName, String label)
            throws UiObjectNotFoundException {
        final UiSelector toolbarUiSelector = new UiSelector().resourceId(
                targetPackageName + "":id/toolbar"");
        final UiSelector titleTextSelector = new UiSelector().className(
                ""android.widget.TextView"").text(label);
        final UiObject title = new UiObject(toolbarUiSelector.childSelector(titleTextSelector));

        assertTrue(title.waitForExists(TIMEOUT_MILLIS));
    }

    private Uri acquireAccess(File file, String directoryName) throws Exception {
        StorageManager storageManager =
                (StorageManager) mActivity.getSystemService(Context.STORAGE_SERVICE);

        // Request access from DocumentsUI
        final StorageVolume volume = storageManager.getStorageVolume(file);
        final Intent intent = volume.createOpenDocumentTreeIntent();

        // launch the directory directly to avoid unexpected UiObject not found issue
        final Uri rootUri = intent.getParcelableExtra(DocumentsContract.EXTRA_INITIAL_URI);
        final String rootId = DocumentsContract.getRootId(rootUri);
        final String documentId = rootId + "":"" + directoryName;
        intent.putExtra(DocumentsContract.EXTRA_INITIAL_URI,
                DocumentsContract.buildDocumentUri(rootUri.getAuthority(), documentId));
        mActivity.startActivityForResult(intent, REQUEST_CODE);

        if (mTargetPackageName == null) {
            mTargetPackageName = getTargetPackageName(mActivity);
        }
        mDevice.waitForIdle();
        assertToolbarTitleEquals(mTargetPackageName, directoryName);

        // Granting the access
        BySelector buttonPanelSelector = By.pkg(mTargetPackageName)
                .res(mTargetPackageName + "":id/container_save"");
        mDevice.wait(Until.hasObject(buttonPanelSelector), TIMEOUT_MILLIS);
        final UiObject2 buttonPanel = mDevice.findObject(buttonPanelSelector);
        final UiObject2 allowButton = buttonPanel.findObject(By.res(""android:id/button1""));
        allowButton.click();
        mDevice.waitForIdle();

        // Granting the access by click ""allow"" in confirm dialog
        final BySelector dialogButtonPanelSelector = By.pkg(mTargetPackageName)
                .res(mTargetPackageName + "":id/buttonPanel"");
        mDevice.wait(Until.hasObject(dialogButtonPanelSelector), TIMEOUT_MILLIS);
        final UiObject2 positiveButton = mDevice.findObject(dialogButtonPanelSelector)
                .findObject(By.res(""android:id/button1""));
        positiveButton.click();
        mDevice.waitForIdle();

        // Check granting result and take persistent permission
        final Result result = mActivity.getResult();
        assertEquals(Activity.RESULT_OK, result.resultCode);

        final Intent resultIntent = result.data;
        final Uri resultUri = resultIntent.getData();
        final int flags = resultIntent.getFlags()
                & (Intent.FLAG_GRANT_READ_URI_PERMISSION
                | Intent.FLAG_GRANT_WRITE_URI_PERMISSION);
        mActivity.getContentResolver().takePersistableUriPermission(resultUri, flags);
        return resultUri;
    }

    private static String getTargetPackageName(Context context) {
        final PackageManager pm = context.getPackageManager();

        final Intent intent = new Intent(Intent.ACTION_OPEN_DOCUMENT);
        intent.addCategory(Intent.CATEGORY_OPENABLE);
        intent.setType(""*/*"");
        final ResolveInfo ri = pm.resolveActivity(intent, 0);
        return ri.activityInfo.packageName;
    }

    // TODO: replace with ProviderTestUtils
    static String executeShellCommand(String command) throws IOException {
        return executeShellCommand(command,
                InstrumentationRegistry.getInstrumentation().getUiAutomation());
    }

    // TODO: replace with ProviderTestUtils
    static String executeShellCommand(String command, UiAutomation uiAutomation)
            throws IOException {
        Log.v(TAG, ""$ "" + command);
        ParcelFileDescriptor pfd = uiAutomation.executeShellCommand(command.toString());
        BufferedReader br = null;
        try (InputStream in = new FileInputStream(pfd.getFileDescriptor());) {
            br = new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8));
            String str = null;
            StringBuilder out = new StringBuilder();
            while ((str = br.readLine()) != null) {
                Log.v(TAG, ""> "" + str);
                out.append(str);
            }
            return out.toString();
        } finally {
            if (br != null) {
                br.close();
            }
        }
    }

    // TODO: replace with ProviderTestUtils
    static File stageFile(int resId, File file) throws IOException {
        // The caller may be trying to stage into a location only available to
        // the shell user, so we need to perform the entire copy as the shell
        final Context context = InstrumentationRegistry.getTargetContext();
        UserManager userManager = context.getSystemService(UserManager.class);
        if (userManager.isSystemUser() &&
                 FileUtils.contains(Environment.getStorageDirectory(), file)) {
            executeShellCommand(""mkdir -p "" + file.getParent());

            try (AssetFileDescriptor afd = context.getResources().openRawResourceFd(resId)) {
                final File source = ParcelFileDescriptor.getFile(afd.getFileDescriptor());
                final long skip = afd.getStartOffset();
                final long count = afd.getLength();

                executeShellCommand(String.format(""dd bs=1 if=%s skip=%d count=%d of=%s"",
                        source.getAbsolutePath(), skip, count, file.getAbsolutePath()));

                // Force sync to try updating other views
                executeShellCommand(""sync"");
            }
        } else {
            final File dir = file.getParentFile();
            dir.mkdirs();
            if (!dir.exists()) {
                throw new FileNotFoundException(""Failed to create parent for "" + file);
            }
            try (InputStream source = context.getResources().openRawResource(resId);
                    OutputStream target = new FileOutputStream(file)) {
                FileUtils.copy(source, target);
            }
        }
        return file;
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.mediaprovidertranscode.cts.TranscodeTestUtils"	"exists"	""	"/home/gpoor/cts-12-source/cts/tests/MediaProviderTranscode/src/android/mediaprovidertranscode/cts/TranscodeTestUtils.java"	""	"public void test/*
 *.
 */

package android.mediaprovidertranscode.cts;

import static androidx.test.InstrumentationRegistry.getContext;

import static android.mediaprovidertranscode.cts.TranscodeTestConstants.INTENT_EXTRA_CALLING_PKG;
import static android.mediaprovidertranscode.cts.TranscodeTestConstants.INTENT_EXTRA_PATH;
import static android.mediaprovidertranscode.cts.TranscodeTestConstants.OPEN_FILE_QUERY;
import static android.mediaprovidertranscode.cts.TranscodeTestConstants.INTENT_QUERY_TYPE;

import static com.google.common.truth.Truth.assertThat;

import static org.junit.Assert.assertTrue;
import static org.junit.Assert.assertEquals;

import android.Manifest;
import android.app.ActivityManager;
import android.app.AppOpsManager;
import android.app.UiAutomation;
import android.content.BroadcastReceiver;
import android.content.ContentResolver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageManager;
import android.net.Uri;
import android.os.Bundle;
import android.os.Environment;
import android.os.FileUtils;
import android.os.ParcelFileDescriptor;
import android.os.Process;
import android.os.SystemClock;
import android.os.storage.StorageManager;
import android.os.storage.StorageVolume;
import android.provider.MediaStore;
import android.system.Os;
import android.system.OsConstants;
import android.util.Log;

import androidx.test.InstrumentationRegistry;

import com.android.cts.install.lib.Install;
import com.android.cts.install.lib.InstallUtils;
import com.android.cts.install.lib.TestApp;
import com.android.cts.install.lib.Uninstall;

import com.google.common.io.ByteStreams;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InterruptedIOException;
import java.util.Arrays;
import java.util.UUID;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.function.Supplier;

public class TranscodeTestUtils {
    private static final String TAG = ""TranscodeTestUtils"";

    private static final long POLLING_TIMEOUT_MILLIS = TimeUnit.SECONDS.toMillis(20);
    private static final long POLLING_SLEEP_MILLIS = 100;

    public static Uri stageHEVCVideoFile(File videoFile) throws IOException {
        return stageVideoFile(videoFile, R.raw.testvideo_HEVC);
    }

    public static Uri stageSmallHevcVideoFile(File videoFile) throws IOException {
        return stageVideoFile(videoFile, R.raw.testVideo_HEVC_small);
    }

    public static Uri stageMediumHevcVideoFile(File videoFile) throws IOException {
        return stageVideoFile(videoFile, R.raw.testVideo_HEVC_medium);
    }

    public static Uri stageLongHevcVideoFile(File videoFile) throws IOException {
        return stageVideoFile(videoFile, R.raw.testVideo_HEVC_long);
    }

    public static Uri stageLegacyVideoFile(File videoFile) throws IOException {
        return stageVideoFile(videoFile, R.raw.testVideo_Legacy);
    }

    private static Uri stageVideoFile(File videoFile, int resourceId) throws IOException {
        if (!videoFile.getParentFile().exists()) {
            assertTrue(videoFile.getParentFile().mkdirs());
        }
        try (InputStream in =
                     getContext().getResources().openRawResource(resourceId);
             FileOutputStream out = new FileOutputStream(videoFile)) {
            FileUtils.copy(in, out);
            // Sync file to disk to ensure file is fully written to the lower fs before scanning
            // Otherwise, media provider might try to read the file on the lower fs and not see
            // the fully written bytes
            out.getFD().sync();
        }
        return MediaStore.scanFile(getContext().getContentResolver(), videoFile);
    }

    public static ParcelFileDescriptor open(File file, boolean forWrite) throws Exception {
        return ParcelFileDescriptor.open(file, forWrite ? ParcelFileDescriptor.MODE_READ_WRITE
                : ParcelFileDescriptor.MODE_READ_ONLY);
    }

    public static ParcelFileDescriptor open(Uri uri, boolean forWrite, Bundle bundle)
            throws Exception {
        ContentResolver resolver = getContext().getContentResolver();
        if (bundle == null) {
            return resolver.openFileDescriptor(uri, forWrite ? ""rw"" : ""r"");
        } else {
            return resolver.openTypedAssetFileDescriptor(uri, ""*/*"", bundle)
                    .getParcelFileDescriptor();
        }
    }

    static byte[] read(ParcelFileDescriptor parcelFileDescriptor, int byteCount, int fileOffset)
            throws Exception {
        assertThat(byteCount).isGreaterThan(-1);
        assertThat(fileOffset).isGreaterThan(-1);

        Os.lseek(parcelFileDescriptor.getFileDescriptor(), fileOffset, OsConstants.SEEK_SET);

        byte[] bytes = new byte[byteCount];
        int numBytesRead = Os.read(parcelFileDescriptor.getFileDescriptor(), bytes,
                0 /* byteOffset */, byteCount);
        assertThat(numBytesRead).isGreaterThan(-1);
        return bytes;
    }

    static void write(ParcelFileDescriptor parcelFileDescriptor, byte[] bytes, int byteCount,
            int fileOffset) throws Exception {
        assertThat(byteCount).isGreaterThan(-1);
        assertThat(fileOffset).isGreaterThan(-1);

        Os.lseek(parcelFileDescriptor.getFileDescriptor(), fileOffset, OsConstants.SEEK_SET);

        int numBytesWritten = Os.write(parcelFileDescriptor.getFileDescriptor(), bytes,
                0 /* byteOffset */, byteCount);
        assertThat(numBytesWritten).isNotEqualTo(-1);
        assertThat(numBytesWritten).isEqualTo(byteCount);
    }

    public static void enableTranscodingForPackage(String packageName) throws Exception {
        executeShellCommand(""device_config put storage_native_boot transcode_compat_manifest ""
                + packageName + "",0"");
        SystemClock.sleep(1000);
    }

    public static void forceEnableAppCompatHevc(String packageName) throws IOException {
        final String command = ""am compat enable 174228127 "" + packageName;
        executeShellCommand(command);
    }

    public static void forceDisableAppCompatHevc(String packageName) throws IOException {
        final String command = ""am compat enable 174227820 "" + packageName;
        executeShellCommand(command);
    }

    public static void resetAppCompat(String packageName) throws IOException {
        final String command = ""am compat reset-all "" + packageName;
        executeShellCommand(command);
    }

    public static void disableTranscodingForAllPackages() throws IOException {
        executeShellCommand(""device_config delete storage_native_boot transcode_compat_manifest"");
        SystemClock.sleep(1000);
    }

    /**
     * Executes a shell command.
     */
    public static String executeShellCommand(String command) throws IOException {
        int attempt = 0;
        while (attempt++ < 5) {
            try {
                return executeShellCommandInternal(command);
            } catch (InterruptedIOException e) {
                // Hmm, we had trouble executing the shell command; the best we
                // can do is try again a few more times
                Log.v(TAG, ""Trouble executing "" + command + ""; trying again"", e);
            }
        }
        throw new IOException(""Failed to execute "" + command);
    }

    private static String executeShellCommandInternal(String cmd) throws IOException {
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try (FileInputStream output = new FileInputStream(
                uiAutomation.executeShellCommand(cmd).getFileDescriptor())) {
            return new String(ByteStreams.toByteArray(output));
        }
    }

    /**
     * Polls for external storage to be mounted.
     */
    public static void pollForExternalStorageState() throws Exception {
        pollForCondition(
                () -> Environment.getExternalStorageState(Environment.getExternalStorageDirectory())
                        .equals(Environment.MEDIA_MOUNTED),
                ""Timed out while waiting for ExternalStorageState to be MEDIA_MOUNTED"");
    }

    private static void pollForCondition(Supplier<Boolean> condition, String errorMessage)
            throws Exception {
        for (int i = 0; i < POLLING_TIMEOUT_MILLIS / POLLING_SLEEP_MILLIS; i++) {
            if (condition.get()) {
                return;
            }
            Thread.sleep(POLLING_SLEEP_MILLIS);
        }
        throw new TimeoutException(errorMessage);
    }

    public static void grantPermission(String packageName, String permission) {
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        uiAutomation.adoptShellPermissionIdentity(""android.permission.GRANT_RUNTIME_PERMISSIONS"");
        try {
            uiAutomation.grantRuntimePermission(packageName, permission);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Polls until we're granted or denied a given permission.
     */
    public static void pollForPermission(String perm, boolean granted) throws Exception {
        pollForCondition(() -> granted == checkPermissionAndAppOp(perm),
                ""Timed out while waiting for permission "" + perm + "" to be ""
                        + (granted ? ""granted"" : ""revoked""));
    }


    /**
     * Checks if the given {@code permission} is granted and corresponding AppOp is MODE_ALLOWED.
     */
    private static boolean checkPermissionAndAppOp(String permission) {
        final int pid = Os.getpid();
        final int uid = Os.getuid();
        final Context context = getContext();
        final String packageName = context.getPackageName();
        if (context.checkPermission(permission, pid, uid) != PackageManager.PERMISSION_GRANTED) {
            return false;
        }

        final String op = AppOpsManager.permissionToOp(permission);
        // No AppOp associated with the given permission, skip AppOp check.
        if (op == null) {
            return true;
        }

        final AppOpsManager appOps = context.getSystemService(AppOpsManager.class);
        try {
            appOps.checkPackage(uid, packageName);
        } catch (SecurityException e) {
            return false;
        }

        return appOps.unsafeCheckOpNoThrow(op, uid, packageName) == AppOpsManager.MODE_ALLOWED;
    }

    /**
     * Installs a {@link TestApp} and grants it storage permissions.
     */
    public static void installAppWithStoragePermissions(TestApp testApp)
            throws Exception {
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            final String packageName = testApp.getPackageName();
            uiAutomation.adoptShellPermissionIdentity(
                    Manifest.permission.INSTALL_PACKAGES, Manifest.permission.DELETE_PACKAGES);
            if (InstallUtils.getInstalledVersion(packageName) != -1) {
                Uninstall.packages(packageName);
            }
            Install.single(testApp).commit();
            assertThat(InstallUtils.getInstalledVersion(packageName)).isEqualTo(1);

            grantPermission(packageName, Manifest.permission.WRITE_EXTERNAL_STORAGE);
            grantPermission(packageName, Manifest.permission.READ_EXTERNAL_STORAGE);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Uninstalls a {@link TestApp}.
     */
    public static void uninstallApp(TestApp testApp) throws Exception {
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            final String packageName = testApp.getPackageName();
            uiAutomation.adoptShellPermissionIdentity(Manifest.permission.DELETE_PACKAGES);

            Uninstall.packages(packageName);
            assertThat(InstallUtils.getInstalledVersion(packageName)).isEqualTo(-1);
        } catch (Exception e) {
            Log.e(TAG, ""Exception occurred while uninstalling app: "" + testApp, e);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Makes the given {@code testApp} open a file for read or write.
     *
     * <p>This method drops shell permission identity.
     */
    public static ParcelFileDescriptor openFileAs(TestApp testApp, File dirPath)
            throws Exception {
        String actionName = getContext().getPackageName() + "".open_file"";
        Bundle bundle = getFromTestApp(testApp, dirPath.getPath(), actionName);
        return getContext().getContentResolver().openFileDescriptor(
                bundle.getParcelable(actionName), ""rw"");
    }

    /**
     * <p>This method drops shell permission identity.
     */
    private static Bundle getFromTestApp(TestApp testApp, String dirPath, String actionName)
            throws Exception {
        final CountDownLatch latch = new CountDownLatch(1);
        final Bundle[] bundle = new Bundle[1];
        BroadcastReceiver broadcastReceiver = new BroadcastReceiver() {
            @Override
            public void onReceive(Context context, Intent intent) {
                bundle[0] = intent.getExtras();
                latch.countDown();
            }
        };

        sendIntentToTestApp(testApp, dirPath, actionName, broadcastReceiver, latch);
        return bundle[0];
    }

    /**
     * <p>This method drops shell permission identity.
     */
    private static void sendIntentToTestApp(TestApp testApp, String dirPath, String actionName,
            BroadcastReceiver broadcastReceiver, CountDownLatch latch) throws Exception {
        final String packageName = testApp.getPackageName();
        forceStopApp(packageName);
        // Register broadcast receiver
        final IntentFilter intentFilter = new IntentFilter();
        intentFilter.addAction(actionName);
        intentFilter.addCategory(Intent.CATEGORY_DEFAULT);
        getContext().registerReceiver(broadcastReceiver, intentFilter);

        // Launch the test app.
        final Intent intent = new Intent(Intent.ACTION_MAIN);
        intent.setPackage(packageName);
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        intent.putExtra(INTENT_QUERY_TYPE, actionName);
        intent.putExtra(INTENT_EXTRA_CALLING_PKG, getContext().getPackageName());
        intent.putExtra(INTENT_EXTRA_PATH, dirPath);
        intent.addCategory(Intent.CATEGORY_LAUNCHER);
        getContext().startActivity(intent);
        if (!latch.await(POLLING_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS)) {
            final String errorMessage = ""Timed out while waiting to receive "" + actionName
                    + "" intent from "" + packageName;
            throw new TimeoutException(errorMessage);
        }
        getContext().unregisterReceiver(broadcastReceiver);
    }

    /**
     * <p>This method drops shell permission identity.
     */
    private static void forceStopApp(String packageName) throws Exception {
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity(Manifest.permission.FORCE_STOP_PACKAGES);

            getContext().getSystemService(ActivityManager.class).forceStopPackage(packageName);
            Thread.sleep(1000);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    public static void assertFileContent(File file1, File file2, ParcelFileDescriptor pfd1,
            ParcelFileDescriptor pfd2, boolean assertSame) throws Exception {
        final int len = 1024;
        byte[] bytes1;
        byte[] bytes2;
        int size1 = 0;
        int size2 = 0;

        boolean isSame = true;
        do {
            bytes1 = new byte[len];
            bytes2 = new byte[len];

            size1 = Os.read(pfd1.getFileDescriptor(), bytes1, 0, len);
            size2 = Os.read(pfd2.getFileDescriptor(), bytes2, 0, len);

            assertTrue(size1 >= 0);
            assertTrue(size2 >= 0);

            isSame = (size1 == size2) && Arrays.equals(bytes1, bytes2);
            if (!isSame) {
                break;
            }
        } while (size1 > 0 && size2 > 0);

        String message = String.format(""Files: %s and %s. isSame=%b. assertSame=%s"",
                file1, file2, isSame, assertSame);
        assertEquals(message, isSame, assertSame);
    }

    public static void assertTranscode(Uri uri, boolean transcode) throws Exception {
        long start = SystemClock.elapsedRealtimeNanos();
        assertTranscode(open(uri, true, null /* bundle */), transcode);
    }

    public static void assertTranscode(File file, boolean transcode) throws Exception {
        assertTranscode(open(file, false), transcode);
    }

    public static void assertTranscode(ParcelFileDescriptor pfd, boolean transcode)
            throws Exception {
        long start = SystemClock.elapsedRealtimeNanos();
        assertEquals(10, Os.pread(pfd.getFileDescriptor(), new byte[10], 0, 10, 0));
        long end = SystemClock.elapsedRealtimeNanos();
        long readDuration = end - start;

        // With transcoding read(2) > 100ms (usually > 1s)
        // Without transcoding read(2) < 10ms (usually < 1ms)
        String message = ""readDuration="" + readDuration + ""ns"";
        if (transcode) {
            assertTrue(message, readDuration > TimeUnit.MILLISECONDS.toNanos(100));
        } else {
            assertTrue(message, readDuration < TimeUnit.MILLISECONDS.toNanos(10));
        }
    }

    public static boolean isAppIoBlocked(StorageManager sm, UUID uuid) {
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        uiAutomation.adoptShellPermissionIdentity(""android.permission.WRITE_MEDIA_STORAGE"");
        try {
            return sm.isAppIoBlocked(uuid, Process.myUid(), Process.myTid(),
                    StorageManager.APP_IO_BLOCKED_REASON_TRANSCODING);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.view.cts.KeyEventTest"	"testWriteToParcel"	"CtsViewTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/view/src/android/view/cts/KeyEventTest.java"	""	"public void testWriteToParcel() {
        KeyEvent keyEvent = parcelUnparcel(mKeyEvent);

        assertEquals(mKeyEvent.getAction(), keyEvent.getAction());
        assertEquals(mKeyEvent.getKeyCode(), keyEvent.getKeyCode());
        assertEquals(mKeyEvent.getRepeatCount(), keyEvent.getRepeatCount());
        assertEquals(mKeyEvent.getMetaState(), keyEvent.getMetaState());
        assertEquals(mKeyEvent.getDeviceId(), keyEvent.getDeviceId());
        assertEquals(mKeyEvent.getScanCode(), keyEvent.getScanCode());
        assertEquals(mKeyEvent.getFlags(), keyEvent.getFlags());
        assertEquals(mKeyEvent.getDownTime(), keyEvent.getDownTime());
        assertEquals(mKeyEvent.getEventTime(), keyEvent.getEventTime());
        assertEquals(mKeyEvent.getCharacters(), keyEvent.getCharacters());
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.view.cts.KeyEventTest"	"testGetScanCode"	"CtsViewTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/view/src/android/view/cts/KeyEventTest.java"	""	"public void testGetScanCode() {
        int scanCode = 1;
        mKeyEvent = new KeyEvent(mDownTime, mEventTime, KeyEvent.ACTION_DOWN,
                KeyEvent.KEYCODE_0, 5, KeyEvent.META_SHIFT_ON, 1, scanCode);
        assertEquals(scanCode, mKeyEvent.getScanCode());
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.acceleration.AcceleratedView"	"isHardwareAccelerated"	"CtsAccelerationTestCases"	"/home/gpoor/cts-12-source/cts/tests/acceleration/src/android/acceleration/AcceleratedView.java"	""	"public void test/*
 *.
 */

package android.acceleration;

import android.content.Context;
import android.graphics.Canvas;
import android.util.AttributeSet;
import android.view.View;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

public class AcceleratedView extends View {

    private final CountDownLatch mDrawLatch = new CountDownLatch(1);

    private boolean mIsHardwareAccelerated;

    public AcceleratedView(Context context) {
        super(context);
    }

    public AcceleratedView(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public AcceleratedView(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
    }

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);
        synchronized (this) {
            mIsHardwareAccelerated = canvas.isHardwareAccelerated();
        }
        mDrawLatch.countDown();
    }

    public boolean isCanvasHardwareAccelerated() {
        try {
            if (mDrawLatch.await(1, TimeUnit.SECONDS)) {
                synchronized (this) {
                    return mIsHardwareAccelerated;
                }
            } else {
                throw new IllegalStateException(""View was not drawn..."");
            }
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.security.cts.CVE_2021_0523"	"testPocCVE_2021_0523"	"CtsSecurityBulletinHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/securitybulletin/src/android/security/cts/CVE_2021_0523.java"	""	"@AsbSecurityTest(cveBugId = 174047492)
    public void testPocCVE_2021_0523() throws Exception {
        final int SLEEP_INTERVAL_MILLISEC = 30 * 1000;
        String apkName = ""CVE-2021-0523.apk"";
        String appPath = AdbUtils.TMP_PATH + apkName;
        String packageName = ""android.security.cts.cve_2021_0523"";
        String crashPattern =
            ""Device is vulnerable to b/174047492 hence any app with "" +
            ""SYSTEM_ALERT_WINDOW can overlay the WifiScanModeActivity screen"";
        ITestDevice device = getDevice();

        try {
            /* Push the app to /data/local/tmp */
            pocPusher.appendBitness(false);
            pocPusher.pushFile(apkName, appPath);

            /* Wake up the screen */
            AdbUtils.runCommandLine(""input keyevent KEYCODE_WAKEUP"", device);
            AdbUtils.runCommandLine(""input keyevent KEYCODE_MENU"", device);
            AdbUtils.runCommandLine(""input keyevent KEYCODE_HOME"", device);

            /* Install the application */
            AdbUtils.runCommandLine(""pm install "" + appPath, device);

            /* Grant ""Draw over other apps"" permission */
            AdbUtils.runCommandLine(
                    ""pm grant "" + packageName + "" android.permission.SYSTEM_ALERT_WINDOW"", device);

            /* Start the application */
            AdbUtils.runCommandLine(""am start -n "" + packageName + ""/.PocActivity"", getDevice());
            Thread.sleep(SLEEP_INTERVAL_MILLISEC);

            /* Get screen width and height */
            int[] displaySize = new int[2];
            extractInt(AdbUtils.runCommandLine(""wm size"", device), displaySize);
            int width = displaySize[0];
            int height = displaySize[1];

            /* Give a tap command for center of screen */
            AdbUtils.runCommandLine(""input tap "" + width / 2 + "" "" + height / 2, device);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            /* Un-install the app after the test */
            AdbUtils.runCommandLine(""pm uninstall "" + packageName, device);

            /* Detection of crash pattern in the logs */
            String logcat = AdbUtils.runCommandLine(""logcat -d *:S AndroidRuntime:E"", device);
            Pattern pattern = Pattern.compile(crashPattern, Pattern.MULTILINE);
            assertThat(crashPattern, pattern.matcher(logcat).find(), is(false));
        }
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.server.wm.app.KeyguardDismissLoggerCallback"	"onDismissError"	""	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/app/src/android/server/wm/app/KeyguardDismissLoggerCallback.java"	""	"public void test/*
 *
 */

package android.server.wm.app;

import static android.server.wm.app.Components.KeyguardDismissLoggerCallback.ENTRY_ON_DISMISS_CANCELLED;
import static android.server.wm.app.Components.KeyguardDismissLoggerCallback.ENTRY_ON_DISMISS_ERROR;
import static android.server.wm.app.Components.KeyguardDismissLoggerCallback.ENTRY_ON_DISMISS_SUCCEEDED;
import static android.server.wm.app.Components.KeyguardDismissLoggerCallback.KEYGUARD_DISMISS_LOG_TAG;

import android.app.KeyguardManager;
import android.app.KeyguardManager.KeyguardDismissCallback;
import android.content.ComponentName;
import android.content.Context;
import android.server.wm.TestJournalProvider;
import android.util.Log;

public class KeyguardDismissLoggerCallback extends KeyguardDismissCallback {

    private final Context mContext;
    private final ComponentName mOwnerName;

    KeyguardDismissLoggerCallback(Context context, ComponentName name) {
        mContext = context;
        mOwnerName = name;
    }

    @Override
    public void onDismissError() {
        Log.i(KEYGUARD_DISMISS_LOG_TAG, ENTRY_ON_DISMISS_ERROR);
        putCallbackResult(ENTRY_ON_DISMISS_ERROR);
    }

    @Override
    public void onDismissSucceeded() {
        if (mContext.getSystemService(KeyguardManager.class).isDeviceLocked()) {
            // Device is still locked? What a fail. Don't print ""onDismissSucceeded"" such that the
            // log fails.
            Log.i(KEYGUARD_DISMISS_LOG_TAG,
                    ""dismiss succeeded was called but device is still locked."");
        } else {
            Log.i(KEYGUARD_DISMISS_LOG_TAG, ENTRY_ON_DISMISS_SUCCEEDED);
            putCallbackResult(ENTRY_ON_DISMISS_SUCCEEDED);
        }
    }

    @Override
    public void onDismissCancelled() {
        Log.i(KEYGUARD_DISMISS_LOG_TAG, ENTRY_ON_DISMISS_CANCELLED);
        putCallbackResult(ENTRY_ON_DISMISS_CANCELLED);
    }

    private void putCallbackResult(String callbackName) {
        TestJournalProvider.putExtras(mContext, mOwnerName,
                extras -> extras.putBoolean(callbackName, true));
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.text.cts.TextShaperTest"	"shapeText_multiStyle"	"CtsTextTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/text/src/android/text/cts/TextShaperTest.java"	""	"public void shapeText_multiStyle() {
        // Setup
        TextPaint paint = new TextPaint();
        paint.setTextSize(100f);

        SpannableString text = new SpannableString(""Hello, World."");

        // Act
        // If the text is not styled, the result should be equal to TextShaper.shapeTextRun.
        text.setSpan(new AbsoluteSizeSpan(240), 0, 7, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);
        text.setSpan(new TypefaceSpan(""serif""), 7, 13, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);
        List<Pair<PositionedGlyphs, TextPaint>> result = shapeText(text, paint);

        // Asserts
        assertThat(result.size()).isEqualTo(2);
        assertThat(result.get(0).first.getOffsetX()).isEqualTo(0f);
        assertThat(result.get(1).first.getOffsetX()).isGreaterThan(0f);
        // Styled text shaper doesn't support vertical layout, so Y origin is always 0
        assertThat(result.get(0).first.getOffsetY()).isEqualTo(0f);
        assertThat(result.get(1).first.getOffsetY()).isEqualTo(0f);


        // OEM may remove serif font, so expect only when there is a serif font.
        if (!Typeface.SERIF.equals(Typeface.DEFAULT)) {
            // The first character should be rendered by default font, Roboto. The last character
            // should be rendered by serif font.
            assertThat(result.get(0).first.getFont(0)).isNotEqualTo(result.get(1).first.getFont(0));
        }

        assertThat(result.get(0).second.getTextSize()).isEqualTo(240f);
        assertThat(result.get(1).second.getTextSize()).isEqualTo(100f);
    }

    public void assertSameDrawResult(CharSequence text, TextPaint paint,
            TextDirectionHeuristic textDir) {
        // For some reasons, StaticLayout breaks text even if we give the exact the same amount
        // of width. To avoid unexpected line breaking, adding 10px as a workaround.
        int width = (int) Math.ceil(Layout.getDesiredWidth(text, paint)) + 10;
        StaticLayout layout = StaticLayout.Builder.obtain(
                text, 0, text.length(), paint, width)
                .setTextDirection(textDir)
                .setIncludePad(false).build();
        int height = layout.getHeight();

        // Expected bitmap output
        Bitmap layoutResult = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
        Canvas layoutCanvas = new Canvas(layoutResult);
        layout.draw(layoutCanvas);

        // actual bitmap output
        Bitmap glyphsResult = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
        Canvas glyphsCanvas = new Canvas(glyphsResult);

        // StaticLayout uses the default font's ascent for baseline
        Paint.FontMetricsInt fmi = paint.getFontMetricsInt();
        // In the RTL paragraph, the shape result goes from right to left. StaticLayout
        // automatically moves the drawing offset to the right most position. We do it by manual.
        if (textDir.isRtl(text, 0, text.length())) {
            glyphsCanvas.translate(width, -fmi.ascent);
        } else {
            glyphsCanvas.translate(0, -fmi.ascent);
        }

        // Draws text.
        TextShaper.shapeText(text, 0, text.length(), textDir, paint,
                (start, end, glyphs, drawPaint) -> {
                    for (int i = 0; i < glyphs.glyphCount(); ++i) {
                        glyphsCanvas.drawGlyphs(
                                new int[] { glyphs.getGlyphId(i) },
                                0,
                                new float[] { glyphs.getGlyphX(i), glyphs.getGlyphY(i) },
                                0,
                                1,
                                glyphs.getFont(i),
                                drawPaint
                        );
                    }
                });
        assertThat(glyphsResult.sameAs(layoutResult)).isTrue();
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.deviceowner.WifiNetworkConfigurationWithoutFineLocationPermissionTest"	"testAddAndRetrieveCallerConfiguredNetworks"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceOwner/src/com/android/cts/deviceowner/WifiNetworkConfigurationWithoutFineLocationPermissionTest.java"	""	"public void testAddAndRetrieveCallerConfiguredNetworks() throws Exception {
        assertWithMessage(""wifi is enabled"").that(mWifiManager.isWifiEnabled()).isTrue();
        assertWithMessage(""permission status (denied=%s) for %s on user %s"",
                PackageManager.PERMISSION_DENIED, Manifest.permission.ACCESS_FINE_LOCATION, mUserId)
                        .that(mContext.checkSelfPermission(
                                        Manifest.permission.ACCESS_FINE_LOCATION))
                        .isEqualTo(PackageManager.PERMISSION_DENIED);

        int netId = mWifiConfigCreator.addNetwork(NETWORK_SSID, /* hidden */ false,
                SECURITY_TYPE_NONE, /* password */ null);
        assertWithMessage(""id of added network"").that(netId).isNotEqualTo(INVALID_NETWORK_ID);

        try {
            List<WifiConfiguration> configs = mWifiManager.getCallerConfiguredNetworks();
            assertWithMessage(""configured networks"").that(configs).isNotEmpty();
            assertWithMessage(""SSID of configured networks"").that(configs.get(0).SSID)
                    .isEqualTo('""' + NETWORK_SSID + '""');
        } finally {
            Log.d(TAG, ""Removing network "" + netId);
            mWifiManager.removeNetwork(netId);
        }
    }

    private void awaitWifiEnabled()  {
        for (int probes = 0; probes * UPDATE_INTERVAL_MS <= UPDATE_TIMEOUT_MS; probes++) {
            if (probes != 0) {
                SystemClock.sleep(UPDATE_INTERVAL_MS);
            }
            if (mWifiManager.isWifiEnabled()) {
                return;
            }
        }
        fail(""Waited too long for wifi enabled"");
    }
}"	""	""	"probe"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.media.tv.cts.TvContractTest"	"testGenresIsCanonical"	"CtsTvTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/tv/src/android/media/tv/cts/TvContractTest.java"	""	"public void testGenresIsCanonical() {
        if (!Utils.hasTvInputFramework(getContext())) {
            return;
        }
        assertTrue(Genres.isCanonical(Genres.DRAMA));
        assertFalse(Genres.isCanonical(""Not a genre""));
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.bluetooth.BleSecureServerTestListActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/bluetooth/BleSecureServerTestListActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.bluetooth;

import android.bluetooth.BluetoothAdapter;
import android.os.Bundle;

import com.android.cts.verifier.ManifestTestListAdapter;
import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;

import java.util.ArrayList;
import java.util.List;

public class BleSecureServerTestListActivity extends PassFailButtons.TestListActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.pass_fail_list);
        setPassFailButtonClickListeners();
        setInfoResources(R.string.ble_secure_server_test_list_name, R.string.ble_secure_server_test_list_info, -1);

        BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
        List<String> disabledTest = new ArrayList<String>();
        if (adapter == null || !adapter.isOffloadedFilteringSupported()) {
            disabledTest.add(
                    ""com.android.cts.verifier.bluetooth.BleAdvertiserHardwareScanFilterActivity."");
        }

        setTestListAdapter(new ManifestTestListAdapter(this, getClass().getName(),
                disabledTest.toArray(new String[disabledTest.size()])));
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.media.cts.AudioManagerTest"	"testPriorityOnlyChannelsCanBypassDnd"	"CtsMediaTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/AudioManagerTest.java"	""	"public void testPriorityOnlyChannelsCanBypassDnd() throws Exception {
        if (mSkipRingerTests) {
            return;
        }

        Utils.toggleNotificationPolicyAccess(
                mContext.getPackageName(), getInstrumentation(), true);

        final String NOTIFICATION_CHANNEL_ID = ""test_id_"" + SystemClock.uptimeMillis();
        NotificationChannel channel = new NotificationChannel(NOTIFICATION_CHANNEL_ID, ""TEST"",
                NotificationManager.IMPORTANCE_DEFAULT);
        try {
            // ensure volume is not muted/0 to start test
            mAudioManager.setStreamVolume(STREAM_MUSIC, 1, 0);
            mAudioManager.setStreamVolume(STREAM_ALARM, 1, 0);
            mAudioManager.setStreamVolume(STREAM_SYSTEM, 1, 0);
            mAudioManager.setStreamVolume(STREAM_RING, 1, 0);

            // create a channel that can bypass dnd
            channel.setBypassDnd(true);
            mNm.createNotificationChannel(channel);

            // allow nothing
            mNm.setNotificationPolicy(new NotificationManager.Policy(0,0, 0));
            setInterruptionFilter(NotificationManager.INTERRUPTION_FILTER_PRIORITY);

            assertStreamMuted(STREAM_MUSIC, true,
                    ""Music (media) stream should be muted"");
            assertStreamMuted(STREAM_SYSTEM, true,
                    ""System stream should be muted"");
            assertStreamMuted(STREAM_ALARM, true,
                    ""Alarm stream should be muted"");
            assertStreamMuted(STREAM_RING, false,
                    ""Ringer stream should not be muted.""
                            + "" areChannelsBypassing=""
                            + NotificationManager.getService().areChannelsBypassingDnd());

            // delete the channel that can bypass dnd
            mNm.deleteNotificationChannel(NOTIFICATION_CHANNEL_ID);

            assertStreamMuted(STREAM_MUSIC, true,
                    ""Music (media) stream should be muted"");
            assertStreamMuted(STREAM_SYSTEM, true,
                    ""System stream should be muted"");
            assertStreamMuted(STREAM_ALARM, true,
                    ""Alarm stream should be muted"");
            // if channels cannot bypass DND, the Ringer stream should be muted, else it
            // shouldn't be muted
            assertStreamMuted(STREAM_RING, !mAppsBypassingDnd,
                    ""Ringer stream should be muted if apps are bypassing dnd""
                            + "" areChannelsBypassing=""
                            + NotificationManager.getService().areChannelsBypassingDnd());
        } finally {
            setInterruptionFilter(NotificationManager.INTERRUPTION_FILTER_ALL);
            mNm.deleteNotificationChannel(NOTIFICATION_CHANNEL_ID);
            Utils.toggleNotificationPolicyAccess(mContext.getPackageName(), getInstrumentation(),
                    false);
        }
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.systemui.cts.WindowInsetsBehaviorTests"	"swipeOutsideLimit_systemUiVisible_allEventsCanceled"	"CtsSystemUiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/systemui/src/android/systemui/cts/WindowInsetsBehaviorTests.java"	""	"public void swipeOutsideLimit_systemUiVisible_allEventsCanceled() throws Throwable {
        assumeTrue(hasSystemGestureFeature());

        assumeGestureNavigationMode();

        final int swipeCount = 1;
        final boolean insideLimit = false;
        testSystemGestureExclusionLimit(swipeCount, insideLimit, SYSTEM_UI_FLAG_VISIBLE);

        assertEquals(""Swipe must be always canceled."", swipeCount, mActionCancelPoints.size());
        assertEquals(""Action up points."", 0, mActionUpPoints.size());
        assertEquals(""Action down points."", swipeCount, mActionDownPoints.size());
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.server.wm.WindowInsetsAnimationControllerTests"	"testImeControl_isntInterruptedByStartingInput"	"CtsWindowManagerDeviceTestCases"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/WindowInsetsAnimationControllerTests.java"	""	"public void testImeControl_isntInterruptedByStartingInput() throws Throwable {
        if (mType != ime()) {
            return;
        }

        retryIfCancelled(() -> {
            setVisibilityAndWait(mType, false);

            runOnUiThread(() -> {
                setupAnimationListener();
                mRootView.getWindowInsetsController().controlWindowInsetsAnimation(mType, 0,
                        null, null, mListener);
            });

            mListener.awaitAndAssert(READY);

            runTransition(true);
            runOnUiThread(() -> {
                mActivity.getSystemService(InputMethodManager.class).restartInput(
                        mActivity.mEditor);
            });

            mListener.awaitAndAssert(FINISHED);
            mListener.assertWasNotCalled(CANCELLED);
        });
    }

    private void setupAnimationListener() {
        WindowInsets initialInsets = mActivity.mLastWindowInsets;
        VerifyingCallback callback = new VerifyingCallback(
                new Callback(Callback.DISPATCH_MODE_STOP) {
            @Override
            public void onPrepare(@NonNull WindowInsetsAnimation animation) {
                mErrorCollector.checkThat(""onPrepare"",
                        mActivity.mLastWindowInsets.getInsets(mType),
                        equalTo(initialInsets.getInsets(mType)));
            }

            @NonNull
            @Override
            public WindowInsetsAnimation.Bounds onStart(
                    @NonNull WindowInsetsAnimation animation,
                    @NonNull WindowInsetsAnimation.Bounds bounds) {
                mErrorCollector.checkThat(""onStart"",
                        mActivity.mLastWindowInsets, not(equalTo(initialInsets)));
                mErrorCollector.checkThat(""onStart"",
                        animation.getInterpolator(), sameInstance(mInterpolator));
                return bounds;
            }

            @NonNull
            @Override
            public WindowInsets onProgress(@NonNull WindowInsets insets,
                    @NonNull List<WindowInsetsAnimation> runningAnimations) {
                mOnProgressCalled = true;
                if (mAnimator != null) {
                    float fraction = runningAnimations.get(0).getFraction();
                    mErrorCollector.checkThat(
                            String.format(Locale.US, ""onProgress(%.2f)"", fraction),
                            insets.getInsets(mType), equalTo(mAnimator.getAnimatedValue()));
                    mErrorCollector.checkThat(""onProgress"",
                            fraction, equalTo(mAnimator.getAnimatedFraction()));

                    Interpolator interpolator =
                            mInterpolator != null ? mInterpolator
                                    : new LinearInterpolator();
                    mErrorCollector.checkThat(""onProgress"",
                            runningAnimations.get(0).getInterpolatedFraction(),
                            equalTo(interpolator.getInterpolation(
                                    mAnimator.getAnimatedFraction())));
                }
                return insets;
            }

            @Override
            public void onEnd(@NonNull WindowInsetsAnimation animation) {
                mRootView.setWindowInsetsAnimationCallback(null);
            }
        });
        mCallbacks.add(callback);
        mRootView.setWindowInsetsAnimationCallback(callback);
    }

    private void runTransition(boolean show) throws Throwable {
        runTransition(show, 1000);
    }

    private void runTransition(boolean show, long durationMillis) throws Throwable {
        runOnUiThread(() -> {
            mAnimator = ValueAnimator.ofObject(
                    INSETS_EVALUATOR,
                    show ? mListener.mController.getHiddenStateInsets()
                            : mListener.mController.getShownStateInsets(),
                    show ? mListener.mController.getShownStateInsets()
                            : mListener.mController.getHiddenStateInsets()
            );
            mAnimator.setDuration(durationMillis);
            mAnimator.addUpdateListener((animator1) -> {
                if (!mListener.mController.isReady()) {
                    // Lost control - Don't crash the instrumentation below.
                    if (!mLossOfControlExpected) {
                        mErrorCollector.addError(new AssertionError(""Unexpectedly lost control.""));
                    }
                    mAnimator.cancel();
                    return;
                }
                Insets insets = (Insets) mAnimator.getAnimatedValue();
                mOnProgressCalled = false;
                mListener.mController.setInsetsAndAlpha(insets, 1.0f,
                        mAnimator.getAnimatedFraction());
                mErrorCollector.checkThat(
                        ""setInsetsAndAlpha() must synchronously call onProgress() but didn't"",
                        mOnProgressCalled, is(true));
            });
            mAnimator.addListener(new AnimatorListenerAdapter() {
                @Override
                public void onAnimationEnd(Animator animation) {
                    if (!mListener.mController.isCancelled()) {
                        mListener.mController.finish(show);
                    }
                }
            });

            mAnimator.start();
        });
    }

    private void setVisibilityAndWait(int type, boolean visible) throws Throwable {
        assertThat(""setVisibilityAndWait must only be called before any""
                + "" WindowInsetsAnimation.Callback was registered"", mCallbacks, equalTo(List.of()));


        final Set<WindowInsetsAnimation> runningAnimations = new HashSet<>();
        Callback callback = new Callback(Callback.DISPATCH_MODE_STOP) {

            @NonNull
            @Override
            public void onPrepare(@NonNull WindowInsetsAnimation animation) {
                synchronized (runningAnimations) {
                    runningAnimations.add(animation);
                }
            }

            @NonNull
            @Override
            public WindowInsetsAnimation.Bounds onStart(@NonNull WindowInsetsAnimation animation,
                    @NonNull WindowInsetsAnimation.Bounds bounds) {
                synchronized (runningAnimations) {
                    runningAnimations.add(animation);
                }
                return bounds;
            }

            @NonNull
            @Override
            public WindowInsets onProgress(@NonNull WindowInsets insets,
                    @NonNull List<WindowInsetsAnimation> runningAnimations) {
                return insets;
            }

            @Override
            public void onEnd(@NonNull WindowInsetsAnimation animation) {
                synchronized (runningAnimations) {
                    runningAnimations.remove(animation);
                }
            }
        };
        runOnUiThread(() -> {
            mRootView.setWindowInsetsAnimationCallback(callback);
            if (visible) {
                mRootView.getWindowInsetsController().show(type);
            } else {
                mRootView.getWindowInsetsController().hide(type);
            }
        });

        waitForOrFail(""Timeout waiting for inset to become "" + (visible ? ""visible"" : ""invisible""),
                () -> mActivity.mLastWindowInsets.isVisible(mType) == visible);
        waitForOrFail(""Timeout waiting for animations to end, running="" + runningAnimations,
                () -> {
                    synchronized (runningAnimations) {
                        return runningAnimations.isEmpty();
                    }
                });

        runOnUiThread(() -> {
            mRootView.setWindowInsetsAnimationCallback(null);
        });
    }

    static class ControlListener implements WindowInsetsAnimationControlListener {
        private final ErrorCollector mErrorCollector;

        WindowInsetsAnimationController mController = null;
        int mTypes = -1;
        RuntimeException mCancelledStack = null;

        ControlListener(ErrorCollector errorCollector) {
            mErrorCollector = errorCollector;
        }

        enum Event {
            READY, FINISHED, CANCELLED;
        }

        /** Latch for every callback event. */
        private CountDownLatch[] mLatches = {
                new CountDownLatch(1),
                new CountDownLatch(1),
                new CountDownLatch(1),
        };

        @Override
        public void onReady(@NonNull WindowInsetsAnimationController controller, int types) {
            mController = controller;
            mTypes = types;

            // Collect errors here and below, so we don't crash the main thread.
            mErrorCollector.checkThat(controller, notNullValue());
            mErrorCollector.checkThat(types, not(equalTo(0)));
            mErrorCollector.checkThat(""isReady"", controller.isReady(), is(true));
            mErrorCollector.checkThat(""isFinished"", controller.isFinished(), is(false));
            mErrorCollector.checkThat(""isCancelled"", controller.isCancelled(), is(false));
            report(READY);
        }

        @Override
        public void onFinished(@NonNull WindowInsetsAnimationController controller) {
            mErrorCollector.checkThat(controller, notNullValue());
            mErrorCollector.checkThat(controller, sameInstance(mController));
            mErrorCollector.checkThat(""isReady"", controller.isReady(), is(false));
            mErrorCollector.checkThat(""isFinished"", controller.isFinished(), is(true));
            mErrorCollector.checkThat(""isCancelled"", controller.isCancelled(), is(false));
            report(FINISHED);
        }

        @Override
        public void onCancelled(@Nullable WindowInsetsAnimationController controller) {
            mErrorCollector.checkThat(controller, sameInstance(mController));
            if (controller != null) {
                mErrorCollector.checkThat(""isReady"", controller.isReady(), is(false));
                mErrorCollector.checkThat(""isFinished"", controller.isFinished(), is(false));
                mErrorCollector.checkThat(""isCancelled"", controller.isCancelled(), is(true));
            }
            mCancelledStack = new RuntimeException(""onCancelled called here"");
            report(CANCELLED);
        }

        private void report(Event event) {
            CountDownLatch latch = mLatches[event.ordinal()];
            mErrorCollector.checkThat(event + "": count"", latch.getCount(), is(1L));
            latch.countDown();
        }

        void awaitAndAssert(Event event) {
            CountDownLatch latch = mLatches[event.ordinal()];
            try {
                if (!latch.await(10, TimeUnit.SECONDS)) {
                    if (event == READY && mCancelledStack != null) {
                        throw new CancelledWhileWaitingForReadyException(
                                ""expected "" + event + "" but instead got "" + CANCELLED,
                                mCancelledStack);
                    }
                    fail(""Timeout waiting for "" + event + ""; reported events: "" + reportedEvents());
                }
            } catch (InterruptedException e) {
                throw new AssertionError(""Interrupted"", e);
            }
        }

        void assertWasCalled(Event event) {
            CountDownLatch latch = mLatches[event.ordinal()];
            assertEquals(event + "" expected, but never called; called: "" + reportedEvents(),
                    0, latch.getCount());
        }

        void assertWasNotCalled(Event event) {
            CountDownLatch latch = mLatches[event.ordinal()];
            assertEquals(event + "" not expected, but was called; called: "" + reportedEvents(),
                    1, latch.getCount());
        }

        String reportedEvents() {
            return Arrays.stream(Event.values())
                    .filter((e) -> mLatches[e.ordinal()].getCount() == 0)
                    .map(Enum::toString)
                    .collect(Collectors.joining("","", ""<"", "">""));
        }
    }


    private class VerifyingCallback extends Callback {
        private final Callback mInner;
        private final Set<WindowInsetsAnimation> mPreparedAnimations = new HashSet<>();
        private final Set<WindowInsetsAnimation> mRunningAnimations = new HashSet<>();
        private final Set<WindowInsetsAnimation> mEndedAnimations = new HashSet<>();

        public VerifyingCallback(Callback callback) {
            super(callback.getDispatchMode());
            mInner = callback;
        }

        @Override
        public void onPrepare(@NonNull WindowInsetsAnimation animation) {
            mErrorCollector.checkThat(""onPrepare: animation"", animation, notNullValue());
            mErrorCollector.checkThat(""onPrepare"", mPreparedAnimations, not(hasItem(animation)));
            mPreparedAnimations.add(animation);
            mInner.onPrepare(animation);
        }

        @NonNull
        @Override
        public WindowInsetsAnimation.Bounds onStart(@NonNull WindowInsetsAnimation animation,
                @NonNull WindowInsetsAnimation.Bounds bounds) {
            mErrorCollector.checkThat(""onStart: animation"", animation, notNullValue());
            mErrorCollector.checkThat(""onStart: bounds"", bounds, notNullValue());

            mErrorCollector.checkThat(""onStart: mPreparedAnimations"",
                    mPreparedAnimations, hasItem(animation));
            mErrorCollector.checkThat(""onStart: mRunningAnimations"",
                    mRunningAnimations, not(hasItem(animation)));
            mRunningAnimations.add(animation);
            mPreparedAnimations.remove(animation);
            return mInner.onStart(animation, bounds);
        }

        @NonNull
        @Override
        public WindowInsets onProgress(@NonNull WindowInsets insets,
                @NonNull List<WindowInsetsAnimation> runningAnimations) {
            mErrorCollector.checkThat(""onProgress: insets"", insets, notNullValue());
            mErrorCollector.checkThat(""onProgress: runningAnimations"",
                    runningAnimations, notNullValue());

            mErrorCollector.checkThat(""onProgress"", new HashSet<>(runningAnimations),
                    is(equalTo(mRunningAnimations)));
            return mInner.onProgress(insets, runningAnimations);
        }

        @Override
        public void onEnd(@NonNull WindowInsetsAnimation animation) {
            mErrorCollector.checkThat(""onEnd: animation"", animation, notNullValue());

            mErrorCollector.checkThat(""onEnd for this animation was already dispatched"",
                    mEndedAnimations, not(hasItem(animation)));
            mErrorCollector.checkThat(""onEnd: animation must be either running or prepared"",
                    mRunningAnimations.contains(animation)
                            || mPreparedAnimations.contains(animation),
                    is(true));
            mRunningAnimations.remove(animation);
            mPreparedAnimations.remove(animation);
            mEndedAnimations.add(animation);
            mInner.onEnd(animation);
        }

        public void assertNoPendingAnimations() {
            mErrorCollector.checkThat(""Animations with onStart but missing onEnd:"",
                    mRunningAnimations, equalTo(Set.of()));
            mErrorCollector.checkThat(""Animations with onPrepare but missing onStart:"",
                    mPreparedAnimations, equalTo(Set.of()));
        }
    }

    public static final class LimitedErrorCollector extends ErrorCollector {
        private static final int THROW_LIMIT = 1;
        private static final int LOG_LIMIT = 10;
        private static final boolean REPORT_SUPPRESSED_ERRORS_AS_THROWABLE = false;
        private int mCount = 0;
        private List<Throwable> mSuppressedErrors = new ArrayList<>();

        @Override
        public void addError(Throwable error) {
            if (mCount < THROW_LIMIT) {
                super.addError(error);
            } else if (mCount < LOG_LIMIT) {
                mSuppressedErrors.add(error);
            }
            mCount++;
        }

        @Override
        protected void verify() throws Throwable {
            if (mCount > THROW_LIMIT) {
                if (REPORT_SUPPRESSED_ERRORS_AS_THROWABLE) {
                    super.addError(
                            new AssertionError((mCount - THROW_LIMIT) + "" errors suppressed.""));
                } else {
                    Log.i(""LimitedErrorCollector"", (mCount - THROW_LIMIT) + "" errors suppressed; ""
                            + ""additional errors:"");
                    for (Throwable t : mSuppressedErrors) {
                        Log.e(""LimitedErrorCollector"", """", t);
                    }
                }
            }
            super.verify();
        }
    }

    private interface ThrowableThrowingRunnable {
        void run() throws Throwable;
    }

    private static class CancelledWhileWaitingForReadyException extends AssertionError {
        public CancelledWhileWaitingForReadyException(String message, Throwable cause) {
            super(message, cause);
        }
    };
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.view.inputmethod.cts.InputMethodServiceTest"	"testHandlesConfigChanges"	"CtsInputMethodTestCases"	"/home/gpoor/cts-12-source/cts/tests/inputmethod/src/android/view/inputmethod/cts/InputMethodServiceTest.java"	""	"public void testHandlesConfigChanges() throws Exception {
        try (MockImeSession imeSession = MockImeSession.create(
                InstrumentationRegistry.getInstrumentation().getContext(),
                InstrumentationRegistry.getInstrumentation().getUiAutomation(),
                new ImeSettings.Builder())) {
            final ImeEventStream stream = imeSession.openEventStream();

            // Case 1: Activity handles configChanges=""fontScale""
            createTestActivity(SOFT_INPUT_STATE_ALWAYS_VISIBLE);
            expectEvent(stream, event -> ""onStartInput"".equals(event.getEventName()), TIMEOUT);
            expectEvent(stream, event -> ""showSoftInput"".equals(event.getEventName()), TIMEOUT);
            // MockIme handles fontScale. Make sure changing fontScale doesn't restart IME.
            enableFontScale();
            expectImeVisible(TIMEOUT);
            // Make sure IME was not restarted.
            notExpectEvent(stream, event -> ""onCreate"".equals(event.getEventName()),
                    EXPECTED_TIMEOUT);
            notExpectEvent(stream, event -> ""showSoftInput"".equals(event.getEventName()),
                    EXPECTED_TIMEOUT);

            eraseFontScale();

            // Case 2: Activity *doesn't* handle configChanges=""fontScale"" and restarts.
            createTestActivity2(SOFT_INPUT_STATE_ALWAYS_VISIBLE);
            expectEvent(stream, event -> ""onStartInput"".equals(event.getEventName()), TIMEOUT);
            // MockIme handles fontScale. Make sure changing fontScale doesn't restart IME.
            enableFontScale();
            expectImeVisible(TIMEOUT);
            // Make sure IME was not restarted.
            notExpectEvent(stream, event -> ""onCreate"".equals(event.getEventName()),
                    EXPECTED_TIMEOUT);
        } finally {
            eraseFontScale();
        }
    }

    /**
     * Font scale is a global configuration.
     * This function will apply font scale changes.
     */
    private void enableFontScale() {
        try {
            final Instrumentation instrumentation = InstrumentationRegistry.getInstrumentation();
            SystemUtil.runShellCommand(instrumentation, PUT_FONT_SCALE_CMD);
            instrumentation.waitForIdleSync();
        } catch (IOException io) {
            fail(""Couldn't apply font scale."");
        }
    }

    /**
     * Font scale is a global configuration.
     * This function will apply font scale changes.
     */
    private void eraseFontScale() {
        try {
            final Instrumentation instrumentation = InstrumentationRegistry.getInstrumentation();
            SystemUtil.runShellCommand(instrumentation, ERASE_FONT_SCALE_CMD);
            instrumentation.waitForIdleSync();
        } catch (IOException io) {
            fail(""Couldn't apply font scale."");
        }
    }

    private static void assertSynthesizedSoftwareKeyEvent(KeyEvent keyEvent, int expectedAction,
            int expectedKeyCode, long expectedEventTimeBefore, long expectedEventTimeAfter) {
        if (keyEvent.getEventTime() < expectedEventTimeBefore
                || expectedEventTimeAfter < keyEvent.getEventTime()) {
            fail(String.format(""EventTime must be within [%d, %d],""
                            + "" which was %d"", expectedEventTimeBefore, expectedEventTimeAfter,
                    keyEvent.getEventTime()));
        }
        assertEquals(expectedAction, keyEvent.getAction());
        assertEquals(expectedKeyCode, keyEvent.getKeyCode());
        assertEquals(KeyCharacterMap.VIRTUAL_KEYBOARD, keyEvent.getDeviceId());
        assertEquals(0, keyEvent.getScanCode());
        assertEquals(0, keyEvent.getRepeatCount());
        assertEquals(0, keyEvent.getRepeatCount());
        final int mustHaveFlags = KeyEvent.FLAG_SOFT_KEYBOARD | KeyEvent.FLAG_KEEP_TOUCH_MODE;
        final int mustNotHaveFlags = KeyEvent.FLAG_FROM_SYSTEM;
        if ((keyEvent.getFlags() & mustHaveFlags) == 0
                || (keyEvent.getFlags() & mustNotHaveFlags) != 0) {
            fail(String.format(""Flags must have FLAG_SOFT_KEYBOARD|""
                    + ""FLAG_KEEP_TOUCH_MODE and must not have FLAG_FROM_SYSTEM, ""
                    + ""which was 0x%08X"", keyEvent.getFlags()));
        }
    }

    /**
     * Test compatibility requirements of {@link InputMethodService#sendDownUpKeyEvents(int)}.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.bluetooth.BleConnectionPriorityClientService"	"disconnect"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/bluetooth/BleConnectionPriorityClientService.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.bluetooth;

import android.app.Service;
import android.bluetooth.BluetoothAdapter;
import android.bluetooth.BluetoothDevice;
import android.bluetooth.BluetoothGatt;
import android.bluetooth.BluetoothGattCallback;
import android.bluetooth.BluetoothGattCharacteristic;
import android.bluetooth.BluetoothGattService;
import android.bluetooth.BluetoothManager;
import android.bluetooth.BluetoothProfile;
import android.bluetooth.le.BluetoothLeScanner;
import android.bluetooth.le.ScanCallback;
import android.bluetooth.le.ScanFilter;
import android.bluetooth.le.ScanResult;
import android.bluetooth.le.ScanSettings;
import android.content.Context;
import android.content.Intent;
import android.os.DeadObjectException;
import android.os.Handler;
import android.os.IBinder;
import android.os.ParcelUuid;
import android.util.Log;
import android.widget.Toast;

import java.util.Arrays;
import java.util.Date;
import java.util.List;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;

public class BleConnectionPriorityClientService extends Service {
    public static final boolean DEBUG = true;
    public static final String TAG = ""BlePriorityClient"";

    public static final String ACTION_BLUETOOTH_DISABLED =
            ""com.android.cts.verifier.bluetooth.action.BLUETOOTH_DISABLED"";

    public static final String ACTION_CONNECTION_SERVICES_DISCOVERED =
            ""com.android.cts.verifier.bluetooth.action.CONNECTION_SERVICES_DISCOVERED"";

    public static final String ACTION_BLUETOOTH_MISMATCH_SECURE =
            ""com.android.cts.verifier.bluetooth.action.ACTION_BLUETOOTH_MISMATCH_SECURE"";
    public static final String ACTION_BLUETOOTH_MISMATCH_INSECURE =
            ""com.android.cts.verifier.bluetooth.action.ACTION_BLUETOOTH_MISMATCH_INSECURE"";

    public static final String ACTION_CONNECTION_PRIORITY_START =
            ""com.android.cts.verifier.bluetooth.action.CONNECTION_PRIORITY_LOW_POWER"";

    public static final String ACTION_CONNECTION_PRIORITY_FINISH =
            ""com.android.cts.verifier.bluetooth.action.CONNECTION_PRIORITY_FINISH"";

    public static final String ACTION_CLIENT_CONNECT_SECURE =
            ""com.android.cts.verifier.bluetooth.action.CLIENT_CONNECT_SECURE"";

    public static final String ACTION_DISCONNECT =
            ""com.android.cts.verifier.bluetooth.action.DISCONNECT"";
    public static final String ACTION_FINISH_DISCONNECT =
            ""com.android.cts.verifier.bluetooth.action.FINISH_DISCONNECT"";

    public static final int NOT_UNDER_TEST = -1;

    private BluetoothManager mBluetoothManager;
    private BluetoothAdapter mBluetoothAdapter;
    private BluetoothGatt mBluetoothGatt;
    private BluetoothLeScanner mScanner;
    private Handler mHandler;
    private Timer mConnectionTimer;
    private Context mContext;

    private String mAction;
    private boolean mSecure;

    private int mPriority = NOT_UNDER_TEST;
    private int interval_low = 0;
    private int interval_balanced = 0;
    private int interval_high = 0;

    private TestTaskQueue mTaskQueue;

    @Override
    public void onCreate() {
        super.onCreate();

        mTaskQueue = new TestTaskQueue(getClass().getName() + ""__taskHandlerThread"");

        mBluetoothManager = (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE);
        mBluetoothAdapter = mBluetoothManager.getAdapter();
        mScanner = mBluetoothAdapter.getBluetoothLeScanner();
        mHandler = new Handler();
        mContext = this;

        startScan();
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        if (mBluetoothGatt != null) {
            try {
                mBluetoothGatt.disconnect();
                mBluetoothGatt.close();
            } catch (Exception e) {}
            finally {
                mBluetoothGatt = null;
            }
        }
        stopScan();

        mTaskQueue.quit();
    }

    @Override
    public IBinder onBind(Intent intent) {
        return null;
    }

    private void notifyBluetoothDisabled() {
        Intent intent = new Intent(ACTION_BLUETOOTH_DISABLED);
        sendBroadcast(intent);
    }

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        if (intent != null) {
            mAction = intent.getAction();
            if (mAction != null) {
                switch (mAction) {
                case ACTION_CLIENT_CONNECT_SECURE:
                    mSecure = true;
                    break;
                case ACTION_CONNECTION_PRIORITY_START:
                    myRequestConnectionPriority(BluetoothGatt.CONNECTION_PRIORITY_LOW_POWER);
                    break;
                case ACTION_DISCONNECT:
                    if (mBluetoothGatt != null) {
                        mBluetoothGatt.disconnect();
                    } else {
                        notifyDisconnect();
                    }
                    break;
                }
            }
        }
        return START_NOT_STICKY;
    }

    private void myRequestConnectionPriority(final int priority) {
        mTaskQueue.addTask(new Runnable() {
                                @Override
                                public void run() {
                                    mPriority = priority;
                                    mBluetoothGatt.requestConnectionPriority(mPriority);
                                    //continue in onConnectionUpdated() callback
                                }
                            });
    }


    private void sleep(int millis) {
        try {
            Thread.sleep(millis);
        } catch (InterruptedException e) {
            Log.e(TAG, ""Error in thread sleep"", e);
        }
    }

    private void showMessage(final String msg) {
        mHandler.post(new Runnable() {
            public void run() {
                Toast.makeText(BleConnectionPriorityClientService.this, msg, Toast.LENGTH_SHORT).show();
            }
        });
    }

    private final BluetoothGattCallback mGattCallbacks = new BluetoothGattCallback() {
        @Override
        public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) {
            if (DEBUG) Log.d(TAG, ""onConnectionStateChange"");
            if (status == BluetoothGatt.GATT_SUCCESS) {
                if (newState == BluetoothProfile.STATE_CONNECTED) {
                    int bond = gatt.getDevice().getBondState();
                    boolean bonded = false;
                    BluetoothDevice target = gatt.getDevice();
                    Set<BluetoothDevice> pairedDevices = mBluetoothAdapter.getBondedDevices();
                    if (pairedDevices.size() > 0) {
                        for (BluetoothDevice device : pairedDevices) {
                            if (device.getAddress().equals(target.getAddress())) {
                                bonded = true;
                                break;
                            }
                        }
                    }
                    if (mSecure && ((bond == BluetoothDevice.BOND_NONE) || !bonded)) {
                        // not pairing and execute Secure Test
                        mBluetoothGatt.disconnect();
                        notifyMismatchSecure();
                    } else if (!mSecure && ((bond != BluetoothDevice.BOND_NONE) || bonded)) {
                        // already pairing nad execute Insecure Test
                        mBluetoothGatt.disconnect();
                        notifyMismatchInsecure();
                    } else {
                        showMessage(""Bluetooth LE connected"");
                        mBluetoothGatt.discoverServices();
                    }
                } else if (newState == BluetoothProfile.STATE_DISCONNECTED) {
                    showMessage(""Bluetooth LE disconnected"");

                    notifyDisconnect();
                }
            } else {
                showMessage(""Failed to connect"");
                mBluetoothGatt.close();
                mBluetoothGatt = null;
            }
        }

        @Override
        public void onServicesDiscovered(BluetoothGatt gatt, int status) {
            if (DEBUG){
                Log.d(TAG, ""onServiceDiscovered"");
            }
            if (status == BluetoothGatt.GATT_SUCCESS) {
                showMessage(""Service discovered"");
                Intent intent = new Intent(ACTION_CONNECTION_SERVICES_DISCOVERED);
                sendBroadcast(intent);
            }

            //onConnectionUpdated is hidden callback, can't be marked as @Override.
            // We must have a call to it, otherwise compiler will delete it during optimization.
            if (status == 0xFFEFFEE) {
                // This should never execute, but will make compiler not remove onConnectionUpdated 
                onConnectionUpdated(null, 0, 0, 0, 0);
                throw new IllegalStateException(""This should never happen!"");
            }
        }
 
        // @Override uncomment once this becomes public API
        public void onConnectionUpdated(BluetoothGatt gatt, int interval, int latency, int timeout,
            int status) {
            if (mPriority == NOT_UNDER_TEST) return;

            if (status != 0) {
                showMessage(""onConnectionUpdated() error, status="" + status );
                Log.e(TAG, ""onConnectionUpdated() status="" + status);
                return;
            }

            Log.i(TAG, ""onConnectionUpdated() status="" + status + "", interval="" + interval);
            if (mPriority == BluetoothGatt.CONNECTION_PRIORITY_LOW_POWER) {
                interval_low = interval;
                myRequestConnectionPriority(BluetoothGatt.CONNECTION_PRIORITY_BALANCED);
            } else if (mPriority == BluetoothGatt.CONNECTION_PRIORITY_BALANCED) {
                interval_balanced = interval;
                myRequestConnectionPriority(BluetoothGatt.CONNECTION_PRIORITY_HIGH);
            } else if (mPriority == BluetoothGatt.CONNECTION_PRIORITY_HIGH) {
                interval_high = interval;

                if (interval_low < interval_balanced || interval_balanced < interval_high) {
                   showMessage(""interval value should be descending - failure!"");
                   Log.e(TAG, ""interval values should be descending: interval_low="" + interval_low +
                            "", interval_balanced="" + interval_balanced + "", interval_high="" + interval_high);
                   return;
                }

                showMessage(""intervals: "" + interval_low +"" > "" + interval_balanced + "" > "" + interval_high);
         
                Intent intent = new Intent();
                intent.setAction(ACTION_CONNECTION_PRIORITY_FINISH);
                sendBroadcast(intent);
        
                mPriority = NOT_UNDER_TEST;
            }
        }
    };

    private final ScanCallback mScanCallback = new ScanCallback() {
        @Override
        public void onScanResult(int callbackType, ScanResult result) {
            if (mBluetoothGatt == null) {
                stopScan();
                mBluetoothGatt = BleClientService.connectGatt(result.getDevice(), mContext, false, mSecure, mGattCallbacks);
            }
        }
    };

    private void startScan() {
        if (DEBUG) {
            Log.d(TAG, ""startScan"");
        }
        if (!mBluetoothAdapter.isEnabled()) {
            notifyBluetoothDisabled();
        } else {
            List<ScanFilter> filter = Arrays.asList(new ScanFilter.Builder().setServiceUuid(
                    new ParcelUuid(BleConnectionPriorityServerService.ADV_SERVICE_UUID)).build());
            ScanSettings setting = new ScanSettings.Builder()
                    .setScanMode(ScanSettings.SCAN_MODE_LOW_LATENCY).build();
            mScanner.startScan(filter, setting, mScanCallback);
        }
    }

    private void stopScan() {
        if (DEBUG) {
            Log.d(TAG, ""stopScan"");
        }
        if (mScanner != null) {
            mScanner.stopScan(mScanCallback);
        }
    }

    private void notifyMismatchSecure() {
        Intent intent = new Intent(ACTION_BLUETOOTH_MISMATCH_SECURE);
        sendBroadcast(intent);
    }

    private void notifyMismatchInsecure() {
        Intent intent = new Intent(ACTION_BLUETOOTH_MISMATCH_INSECURE);
        sendBroadcast(intent);
    }

    private void notifyDisconnect() {
        Intent intent = new Intent(ACTION_FINISH_DISCONNECT);
        sendBroadcast(intent);
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.leanbackjank.app.Utils"	"getDefaultDisplay"	""	"/home/gpoor/cts-12-source/cts/tests/leanbackjank/app/src/android/leanbackjank/app/Utils.java"	""	"public void test/*
 *.
 */

package android.leanbackjank.app;

import com.android.compatibility.common.util.ApiLevelUtil;

import android.app.Activity;
import android.content.Context;
import android.graphics.Point;
import android.media.MediaMetadataRetriever;
import android.os.Build;
import android.util.DisplayMetrics;
import android.view.Display;
import android.view.WindowManager;
import android.widget.FrameLayout;
import android.widget.Toast;
import android.widget.VideoView;

import java.util.HashMap;

/**
 * A collection of utility methods, all static.
 */
public class Utils {

    public interface MediaDimensions {
        double MEDIA_HEIGHT = 0.95;
        double MEDIA_WIDTH = 0.95;
        double MEDIA_TOP_MARGIN = 0.025;
        double MEDIA_RIGHT_MARGIN = 0.025;
        double MEDIA_BOTTOM_MARGIN = 0.025;
        double MEDIA_LEFT_MARGIN = 0.025;
    }

    /*
     * Making sure public utility methods remain static
     */
    private Utils() {
    }

    /**
     * Returns the screen/display size
     */
    public static Point getDisplaySize(Context context) {
        WindowManager wm = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
        Display display = wm.getDefaultDisplay();
        Point size = new Point();
        display.getSize(size);
        return size;
    }

    /**
     * Shows a (long) toast
     */
    public static void showToast(Context context, String msg) {
        Toast.makeText(context, msg, Toast.LENGTH_LONG).show();
    }

    /**
     * Shows a (long) toast.
     */
    public static void showToast(Context context, int resourceId) {
        Toast.makeText(context, context.getString(resourceId), Toast.LENGTH_LONG).show();
    }

    public static int convertDpToPixel(Context ctx, int dp) {
        float density = ctx.getResources().getDisplayMetrics().density;
        return Math.round((float) dp * density);
    }


    /**
     * Example for handling resizing content for overscan.  Typically you won't need to resize
     * when using the Leanback support library.
     */
    public void overScan(Activity activity, VideoView videoView) {
        DisplayMetrics metrics = new DisplayMetrics();
        activity.getWindowManager().getDefaultDisplay().getMetrics(metrics);
        int w = (int) (metrics.widthPixels * MediaDimensions.MEDIA_WIDTH);
        int h = (int) (metrics.heightPixels * MediaDimensions.MEDIA_HEIGHT);
        int marginLeft = (int) (metrics.widthPixels * MediaDimensions.MEDIA_LEFT_MARGIN);
        int marginTop = (int) (metrics.heightPixels * MediaDimensions.MEDIA_TOP_MARGIN);
        int marginRight = (int) (metrics.widthPixels * MediaDimensions.MEDIA_RIGHT_MARGIN);
        int marginBottom = (int) (metrics.heightPixels * MediaDimensions.MEDIA_BOTTOM_MARGIN);
        FrameLayout.LayoutParams lp = new FrameLayout.LayoutParams(w, h);
        lp.setMargins(marginLeft, marginTop, marginRight, marginBottom);
        videoView.setLayoutParams(lp);
    }


    public static long getDuration(String videoUrl) {
        MediaMetadataRetriever mmr = new MediaMetadataRetriever();
        if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.ICE_CREAM_SANDWICH)) {
            mmr.setDataSource(videoUrl, new HashMap<String, String>());
        } else {
            mmr.setDataSource(videoUrl);
        }
        return Long.parseLong(mmr.extractMetadata(MediaMetadataRetriever.METADATA_KEY_DURATION));
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"android.systemui.cts.LightBarTests"	"testLegacyFlagsCannotOverwriteAppearance"	"CtsSystemUiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/systemui/src/android/systemui/cts/LightBarTests.java"	""	"@AppModeFull // Instant apps cannot create notifications
    public void testLegacyFlagsCannotOverwriteAppearance() throws Throwable {
        assumeHasColoredStatusBar(mActivityRule);

        runInNotificationSession(() -> {
            final LightBarActivity activity = mActivityRule.getActivity();
            activity.runOnUiThread(() -> {
                activity.getWindow().setStatusBarColor(LIGHT_BG_COLOR);
                activity.getWindow().setNavigationBarColor(LIGHT_BG_COLOR);

                activity.setLightStatusBarAppearance(false);
                activity.setLightNavigationBarAppearance(false);

                // Once the client starts using the new appearance APIs, the legacy flags won't
                // change the appearance anymore.
                activity.setLightStatusBarLegacy(true);
                activity.setLightNavigationBarLegacy(true);
            });
            Thread.sleep(WAIT_TIME);

            Bitmap bitmap = takeStatusBarScreenshot(mActivityRule.getActivity());
            Stats s = evaluateDarkBarBitmap(bitmap, LIGHT_BG_COLOR, 0);
            assertStats(bitmap, s, false /* light */);
        });
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-9"	"7.4.2/C-1-9"	"07040200.670109"	"""C-1-9] MUST iterate probe request sequence number as normal (sequentially) between the probe requests in a scan."""	""	""	"probe scan"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.bluetooth.BleInsecureServerTestListActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/bluetooth/BleInsecureServerTestListActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.bluetooth;

import android.bluetooth.BluetoothAdapter;
import android.os.Bundle;

import com.android.cts.verifier.ManifestTestListAdapter;
import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;

import java.util.ArrayList;
import java.util.List;

public class BleInsecureServerTestListActivity extends PassFailButtons.TestListActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.pass_fail_list);
        setPassFailButtonClickListeners();
        setInfoResources(R.string.ble_insecure_server_test_list_name, R.string.ble_insecure_server_test_list_info, -1);

        BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
        List<String> disabledTest = new ArrayList<String>();
        if (adapter == null || !adapter.isOffloadedFilteringSupported()) {
            disabledTest.add(
                    ""com.android.cts.verifier.bluetooth.BleAdvertiserHardwareScanFilterActivity."");
        }

        setTestListAdapter(new ManifestTestListAdapter(this, getClass().getName(),
                disabledTest.toArray(new String[disabledTest.size()])));
    }
}"	""	""	"scan scan"	""	""	""	""	""	""	""	""	""	""
