"Section"	"section_id"	"req_id"	"Test Availability"	"class_def"	"method"	"module"	"method_text"	"full_key"	"requirement"	"key_as_number"	"search_terms"	"manual_search_terms"	"not_search_terms"	"not_files"	"matched_terms"	"search_roots"	"qualified_method"	"max_matches"	"file_name"	"matched_files"	"methods_string"	"urls"	"protected"	"Area"	"Shortened"	"Test Level"
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.content.cts.ContextTest"	"testGetColor"	"CtsContentTestCases"	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"FileSystem"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/content/src/android/content/cts/ContextTest.java"	""	"public void testGetColor() {         try {             mContext.getColor(0);             fail(""Failed at testGetColor"");         } catch (NotFoundException e) {             //expected         }          final int color = mContext.getColor(R.color.color2);         assertEquals(0xffffff00, color);     }      /**      * Developers have come to expect at least ext4-style filename behavior, so      * verify that the underlying filesystem supports them.      */"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.extractnativelibs.cts.CtsExtractNativeLibsHostTestIncremental"	"isIncrementalInstallSupported"	""	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"Incremental"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/packagemanager/extractnativelibs/src/android/extractnativelibs/cts/CtsExtractNativeLibsHostTestIncremental.java"	""	"/*  *.  */  package android.extractnativelibs.cts;  import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue; import static org.junit.Assume.assumeTrue;  import android.platform.test.annotations.AppModeFull;  import com.android.compatibility.common.tradefed.build.CompatibilityBuildHelper; import com.android.tradefed.testtype.DeviceJUnit4ClassRunner;  import org.junit.Test; import org.junit.runner.RunWith;  import java.io.File;  /**  * Host test to incremental install test apps and run device tests to verify the effect of  * extractNativeLibs.  */ @RunWith(DeviceJUnit4ClassRunner.class) public class CtsExtractNativeLibsHostTestIncremental extends CtsExtractNativeLibsHostTestBase {     private static final String IDSIG_SUFFIX = "".idsig"";      @Override     public void setUp() throws Exception {         assumeTrue(isIncrementalInstallSupported());         super.setUp();     }      private boolean isIncrementalInstallSupported() throws Exception {         return getDevice().hasFeature(""android.software.incremental_delivery"");     }     /** Test with a app that has extractNativeLibs=false using Incremental install. */"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.extractnativelibs.cts.CtsExtractNativeLibsHostTestIncremental"	"testNoExtractNativeLibsIncremental"	""	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"Incremental"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/packagemanager/extractnativelibs/src/android/extractnativelibs/cts/CtsExtractNativeLibsHostTestIncremental.java"	""	"@AppModeFull     public void testNoExtractNativeLibsIncremental() throws Exception {         installPackageIncremental(TEST_NO_EXTRACT_APK);         assertTrue(isPackageInstalled(TEST_NO_EXTRACT_PKG));         assertTrue(runDeviceTests(                 TEST_NO_EXTRACT_PKG, TEST_NO_EXTRACT_CLASS, TEST_NO_EXTRACT_TEST));     }      /** Test with a app that has extractNativeLibs=true using Incremental install. */"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.extractnativelibs.cts.CtsExtractNativeLibsHostTestIncremental"	"testExtractNativeLibsIncremental"	""	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"Incremental"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/packagemanager/extractnativelibs/src/android/extractnativelibs/cts/CtsExtractNativeLibsHostTestIncremental.java"	""	"@AppModeFull     public void testExtractNativeLibsIncremental() throws Exception {         installPackageIncremental(TEST_EXTRACT_APK);         assertTrue(isPackageInstalled(TEST_EXTRACT_PKG));         assertTrue(runDeviceTests(                 TEST_EXTRACT_PKG, TEST_EXTRACT_CLASS, TEST_EXTRACT_TEST));     }      /** Test with a app that has extractNativeLibs=false but with mis-aligned lib files,      *  using Incremental install. */"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.extractnativelibs.cts.CtsExtractNativeLibsHostTestIncremental"	"testExtractNativeLibsIncrementalFails"	""	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"Incremental"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/packagemanager/extractnativelibs/src/android/extractnativelibs/cts/CtsExtractNativeLibsHostTestIncremental.java"	""	"@AppModeFull     public void testExtractNativeLibsIncrementalFails() throws Exception {         String result = installIncrementalPackageFromResource(TEST_NO_EXTRACT_MISALIGNED_APK);         assertTrue(result.contains(""Failed to extract native libraries""));         assertFalse(isPackageInstalled(TEST_NO_EXTRACT_PKG));     }      private void installPackageIncremental(String apkName) throws Exception {         CompatibilityBuildHelper buildHelper = new CompatibilityBuildHelper(getBuild());         final File apk = buildHelper.getTestFile(apkName);         assertNotNull(apk);         final File v4Signature = buildHelper.getTestFile(apkName + IDSIG_SUFFIX);         assertNotNull(v4Signature);         installPackageIncrementalFromFiles(apk, v4Signature);     }      private String installPackageIncrementalFromFiles(File apk, File v4Signature) throws Exception {         final String remoteApkPath = TEST_REMOTE_DIR + ""/"" + apk.getName();         final String remoteIdsigPath = remoteApkPath + IDSIG_SUFFIX;         assertTrue(getDevice().pushFile(apk, remoteApkPath));         assertTrue(getDevice().pushFile(v4Signature, remoteIdsigPath));         return getDevice().executeShellCommand(""pm install-incremental -t -g "" + remoteApkPath);     }      private String installIncrementalPackageFromResource(String apkFilenameInRes)             throws Exception {         final File apkFile = getFileFromResource(apkFilenameInRes);         final File v4SignatureFile = getFileFromResource(                 apkFilenameInRes + IDSIG_SUFFIX);         return installPackageIncrementalFromFiles(apkFile, v4SignatureFile);     } }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.content.pm.cts.PackageManagerShellCommandTest"	"isAllowed"	"CtsContentTestCases"	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"Incremental"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/content/src/android/content/pm/cts/PackageManagerShellCommandTest.java"	""	"/*  *.  */  package android.content.pm.cts;  import static android.content.pm.PackageInstaller.DATA_LOADER_TYPE_INCREMENTAL; import static android.content.pm.PackageInstaller.DATA_LOADER_TYPE_NONE; import static android.content.pm.PackageInstaller.DATA_LOADER_TYPE_STREAMING; import static android.content.pm.PackageInstaller.LOCATION_DATA_APP;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertTrue;  import android.app.UiAutomation; import android.content.ComponentName; import android.content.pm.DataLoaderParams; import android.content.pm.PackageInstaller; import android.content.pm.PackageInstaller.SessionParams; import android.os.ParcelFileDescriptor; import android.os.incremental.IncrementalManager; import android.platform.test.annotations.AppModeFull;  import androidx.test.InstrumentationRegistry;  import org.junit.After; import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith; import org.junit.runners.Parameterized; import org.junit.runners.Parameterized.Parameter; import org.junit.runners.Parameterized.Parameters;  import java.io.ByteArrayOutputStream; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.util.ArrayList; import java.util.Arrays; import java.util.List; import java.util.Optional; import java.util.Random; import java.util.stream.Collectors;  @RunWith(Parameterized.class) @AppModeFull public class PackageManagerShellCommandTest {     private static final String TEST_APP_PACKAGE = ""com.example.helloworld"";      private static final String TEST_APK_PATH = ""/data/local/tmp/cts/content/"";     private static final String TEST_HW5 = ""HelloWorld5.apk"";     private static final String TEST_HW5_SPLIT0 = ""HelloWorld5_hdpi-v4.apk"";     private static final String TEST_HW5_SPLIT1 = ""HelloWorld5_mdpi-v4.apk"";     private static final String TEST_HW5_SPLIT2 = ""HelloWorld5_xhdpi-v4.apk"";     private static final String TEST_HW5_SPLIT3 = ""HelloWorld5_xxhdpi-v4.apk"";     private static final String TEST_HW5_SPLIT4 = ""HelloWorld5_xxxhdpi-v4.apk"";     private static final String TEST_HW7 = ""HelloWorld7.apk"";     private static final String TEST_HW7_SPLIT0 = ""HelloWorld7_hdpi-v4.apk"";     private static final String TEST_HW7_SPLIT1 = ""HelloWorld7_mdpi-v4.apk"";     private static final String TEST_HW7_SPLIT2 = ""HelloWorld7_xhdpi-v4.apk"";     private static final String TEST_HW7_SPLIT3 = ""HelloWorld7_xxhdpi-v4.apk"";     private static final String TEST_HW7_SPLIT4 = ""HelloWorld7_xxxhdpi-v4.apk"";      @Parameter     public int mDataLoaderType;      @Parameters     public static Iterable<Object> initParameters() {         return Arrays.asList(DATA_LOADER_TYPE_NONE, DATA_LOADER_TYPE_STREAMING,                              DATA_LOADER_TYPE_INCREMENTAL);     }      private boolean mStreaming = false;     private boolean mIncremental = false;     private String mInstall = """";     private List<Integer> mSessionIds = new ArrayList<>();      private static PackageInstaller getPackageInstaller() {         return InstrumentationRegistry.getContext().getPackageManager().getPackageInstaller();     }      private static UiAutomation getUiAutomation() {         return InstrumentationRegistry.getInstrumentation().getUiAutomation();     }      private static String executeShellCommand(String command) throws IOException {         final ParcelFileDescriptor stdout = getUiAutomation().executeShellCommand(command);         try (InputStream inputStream = new ParcelFileDescriptor.AutoCloseInputStream(stdout)) {             return readFullStream(inputStream);         }     }      private static String executeShellCommand(String command, File input)             throws IOException {         return executeShellCommand(command, new File[]{input});     }      private static String executeShellCommand(String command, File[] inputs)             throws IOException {         final ParcelFileDescriptor[] pfds = getUiAutomation().executeShellCommandRw(command);         ParcelFileDescriptor stdout = pfds[0];         ParcelFileDescriptor stdin = pfds[1];         try (FileOutputStream outputStream = new ParcelFileDescriptor.AutoCloseOutputStream(                 stdin)) {             for (File input : inputs) {                 try (FileInputStream inputStream = new FileInputStream(input)) {                     writeFullStream(inputStream, outputStream, input.length());                 }             }         }         try (InputStream inputStream = new ParcelFileDescriptor.AutoCloseInputStream(stdout)) {             return readFullStream(inputStream);         }     }      private static String readFullStream(InputStream inputStream) throws IOException {         ByteArrayOutputStream result = new ByteArrayOutputStream();         writeFullStream(inputStream, result, -1);         return result.toString(""UTF-8"");     }      private static void writeFullStream(InputStream inputStream, OutputStream outputStream,             long expected)             throws IOException {         byte[] buffer = new byte[1024];         long total = 0;         int length;         while ((length = inputStream.read(buffer)) != -1) {             outputStream.write(buffer, 0, length);             total += length;         }         if (expected > 0) {             assertEquals(expected, total);         }     }      @Before     public void onBefore() throws Exception {         // Check if Incremental is allowed and revert to non-dataloader installation.         if (mDataLoaderType == DATA_LOADER_TYPE_INCREMENTAL && !IncrementalManager.isAllowed()) {             mDataLoaderType = DATA_LOADER_TYPE_NONE;         }          mStreaming = mDataLoaderType != DATA_LOADER_TYPE_NONE;         mIncremental = mDataLoaderType == DATA_LOADER_TYPE_INCREMENTAL;         mInstall = mDataLoaderType == DATA_LOADER_TYPE_NONE ? "" install "" :                 mDataLoaderType == DATA_LOADER_TYPE_STREAMING ? "" install-streaming "" :                         "" install-incremental "";          uninstallPackageSilently(TEST_APP_PACKAGE);         assertFalse(isAppInstalled(TEST_APP_PACKAGE));          mSessionIds.clear();     }      @After     public void onAfter() throws Exception {         uninstallPackageSilently(TEST_APP_PACKAGE);         assertFalse(isAppInstalled(TEST_APP_PACKAGE));         assertEquals(null, getSplits(TEST_APP_PACKAGE));          for (int sessionId : mSessionIds) {             try {                 getPackageInstaller().abandonSession(sessionId);             } catch (SecurityException ignored) {             }         }     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.content.pm.cts.PackageManagerShellCommandTest"	"testAppInstallStdInErr"	"CtsContentTestCases"	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"Incremental"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/content/src/android/content/pm/cts/PackageManagerShellCommandTest.java"	""	"public void testAppInstallStdInErr() throws Exception {         File file = new File(createApkPath(TEST_HW5));         String commandResult = executeShellCommand(""pm "" + mInstall + "" -t -g -S "" + file.length(),                 new File[]{});         if (mIncremental) {             assertEquals(""Failure [INSTALL_FAILED_MEDIA_UNAVAILABLE: Failed to prepare image.]\n"",                     commandResult);         } else {             assertTrue(commandResult,                     commandResult.startsWith(""Failure [INSTALL_PARSE_FAILED_NOT_APK""));         }         assertFalse(isAppInstalled(TEST_APP_PACKAGE));     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.content.pm.cts.PackageManagerShellCommandTest"	"testDataLoaderParamsApiV2"	"CtsContentTestCases"	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"Incremental"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/content/src/android/content/pm/cts/PackageManagerShellCommandTest.java"	""	"public void testDataLoaderParamsApiV2() throws Exception {         if (!mStreaming) {             return;         }          getUiAutomation().adoptShellPermissionIdentity();         try {             final PackageInstaller installer = getPackageInstaller();              final SessionParams params = new SessionParams(SessionParams.MODE_FULL_INSTALL);             final ComponentName componentName = new ComponentName(""foo"", ""bar"");             final String args = ""args"";             params.setDataLoaderParams(                     mIncremental ? DataLoaderParams.forIncremental(componentName, args)                             : DataLoaderParams.forStreaming(componentName, args));              final int sessionId = createSession(params);             PackageInstaller.Session session = installer.openSession(sessionId);              DataLoaderParams dataLoaderParams = session.getDataLoaderParams();             assertEquals(mIncremental ? DATA_LOADER_TYPE_INCREMENTAL : DATA_LOADER_TYPE_STREAMING,                     dataLoaderParams.getType());             assertEquals(""foo"", dataLoaderParams.getComponentName().getPackageName());             assertEquals(""bar"", dataLoaderParams.getComponentName().getClassName());             assertEquals(""args"", dataLoaderParams.getArguments());              installer.abandonSession(sessionId);         } finally {             getUiAutomation().dropShellPermissionIdentity();         }     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.content.pm.cts.PackageManagerShellCommandTest"	"testRemoveFileApiV2"	"CtsContentTestCases"	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"Incremental"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/content/src/android/content/pm/cts/PackageManagerShellCommandTest.java"	""	"public void testRemoveFileApiV2() throws Exception {         if (!mStreaming) {             return;         }          getUiAutomation().adoptShellPermissionIdentity();         try {             final PackageInstaller installer = getPackageInstaller();              final SessionParams params = new SessionParams(SessionParams.MODE_INHERIT_EXISTING);             params.setAppPackageName(""com.package.name"");             final ComponentName componentName = new ComponentName(""foo"", ""bar"");             final String args = ""args"";             params.setDataLoaderParams(                     mIncremental ? DataLoaderParams.forIncremental(componentName, args)                             : DataLoaderParams.forStreaming(componentName, args));              final int sessionId = createSession(params);             PackageInstaller.Session session = installer.openSession(sessionId);              session.addFile(LOCATION_DATA_APP, ""base.apk"", 123, ""123"".getBytes(), null);             String[] files = session.getNames();             assertEquals(1, files.length);             assertEquals(""base.apk"", files[0]);              session.removeFile(LOCATION_DATA_APP, ""base.apk"");             files = session.getNames();             assertEquals(2, files.length);             assertEquals(""base.apk"", files[0]);             assertEquals(""base.apk.removed"", files[1]);              installer.abandonSession(sessionId);         } finally {             getUiAutomation().dropShellPermissionIdentity();         }     }      private int createSession(SessionParams params) throws IOException {         int sessionId = getPackageInstaller().createSession(params);         mSessionIds.add(sessionId);         return sessionId;     }      private String createUpdateSession(String packageName) throws IOException {         return createSession(""-p "" + packageName);     }      private String createSession(String arg) throws IOException {         final String prefix = ""Success: created install session ["";         final String suffix = ""]\n"";         final String commandResult = executeShellCommand(""pm install-create "" + arg);         assertTrue(commandResult, commandResult.startsWith(prefix));         assertTrue(commandResult, commandResult.endsWith(suffix));         String sessionId = commandResult.substring(prefix.length(),                 commandResult.length() - suffix.length());         mSessionIds.add(Integer.parseInt(sessionId));         return sessionId;     }      private void addSplits(String sessionId, String[] splitNames) throws IOException {         for (String splitName : splitNames) {             File file = new File(splitName);             assertEquals(                     ""Success: streamed "" + file.length() + "" bytes\n"",                     executeShellCommand(""pm install-write "" + sessionId + "" "" + file.getName() + "" ""                             + splitName));         }     }      private void addSplitsStdIn(String sessionId, String[] splitNames, String args)             throws IOException {         for (String splitName : splitNames) {             File file = new File(splitName);             assertEquals(""Success: streamed "" + file.length() + "" bytes\n"", executeShellCommand(                     ""pm install-write -S "" + file.length() + "" "" + sessionId + "" "" + file.getName()                             + "" "" + args, file));         }     }      private void removeSplits(String sessionId, String[] splitNames) throws IOException {         for (String splitName : splitNames) {             assertEquals(""Success\n"",                     executeShellCommand(""pm install-remove "" + sessionId + "" "" + splitName));         }     }      private void removeSplitsBatch(String sessionId, String[] splitNames) throws IOException {         assertEquals(""Success\n"", executeShellCommand(                 ""pm install-remove "" + sessionId + "" "" + String.join("" "", splitNames)));     }      private void commitSession(String sessionId) throws IOException {         assertEquals(""Success\n"", executeShellCommand(""pm install-commit "" + sessionId));     }      private boolean isAppInstalled(String packageName) throws IOException {         final String commandResult = executeShellCommand(""pm list packages"");         final int prefixLength = ""package:"".length();         return Arrays.stream(commandResult.split(""\\r?\\n""))                 .anyMatch(line -> line.substring(prefixLength).equals(packageName));     }      private String getSplits(String packageName) throws IOException {         final String commandResult = executeShellCommand(""pm dump "" + packageName);         final String prefix = ""    splits=["";         final int prefixLength = prefix.length();         Optional<String> maybeSplits = Arrays.stream(commandResult.split(""\\r?\\n""))                 .filter(line -> line.startsWith(prefix)).findFirst();         if (!maybeSplits.isPresent()) {             return null;         }         String splits = maybeSplits.get();         return splits.substring(prefixLength, splits.length() - 1);     }      private static String createApkPath(String baseName) {         return TEST_APK_PATH + baseName;     }      private void installPackage(String baseName) throws IOException {         File file = new File(createApkPath(baseName));         assertEquals(""Success\n"", executeShellCommand(                 ""pm "" + mInstall + "" -t -g "" + file.getPath()));     }      private void installPackageStdIn(String baseName) throws IOException {         File file = new File(createApkPath(baseName));         assertEquals(""Success\n"",                 executeShellCommand(""pm "" + mInstall + "" -t -g -S "" + file.length(), file));     }      private void installSplits(String[] baseNames) throws IOException {         if (mStreaming) {             installSplitsBatch(baseNames);             return;         }         String[] splits = Arrays.stream(baseNames).map(                 baseName -> createApkPath(baseName)).toArray(String[]::new);         String sessionId = createSession(TEST_APP_PACKAGE);         addSplits(sessionId, splits);         commitSession(sessionId);     }      private void installSplitsStdInStreaming(String[] splits) throws IOException {         File[] files = Arrays.stream(splits).map(split -> new File(split)).toArray(File[]::new);         String param = Arrays.stream(files).map(                 file -> file.getName() + "":"" + file.length()).collect(Collectors.joining("" ""));         assertEquals(""Success\n"", executeShellCommand(""pm"" + mInstall + param, files));     }      private void installSplitsStdIn(String[] baseNames, String args) throws IOException {         String[] splits = Arrays.stream(baseNames).map(                 baseName -> createApkPath(baseName)).toArray(String[]::new);         if (mStreaming) {             installSplitsStdInStreaming(splits);             return;         }         String sessionId = createSession(TEST_APP_PACKAGE);         addSplitsStdIn(sessionId, splits, args);         commitSession(sessionId);     }      private void installSplitsBatch(String[] baseNames) throws IOException {         String[] splits = Arrays.stream(baseNames).map(                 baseName -> createApkPath(baseName)).toArray(String[]::new);         assertEquals(""Success\n"",                 executeShellCommand(""pm "" + mInstall + "" -t -g "" + String.join("" "", splits)));     }      private String uninstallPackageSilently(String packageName) throws IOException {         return executeShellCommand(""pm uninstall "" + packageName);     }      private void uninstallSplits(String packageName, String[] splitNames) throws IOException {         for (String splitName : splitNames) {             assertEquals(""Success\n"",                     executeShellCommand(""pm uninstall "" + packageName + "" "" + splitName));         }     }      private void uninstallSplitsBatch(String packageName, String[] splitNames) throws IOException {         assertEquals(""Success\n"", executeShellCommand(                 ""pm uninstall "" + packageName + "" "" + String.join("" "", splitNames)));     } }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.scopedstorage.cts.ScopedStorageTest"	"isInstantApp"	""	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"FileSystem"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/scopedstorage/src/android/scopedstorage/cts/ScopedStorageTest.java"	""	"/*  *.  */  package android.scopedstorage.cts;  import static android.app.AppOpsManager.permissionToOp; import static android.os.SystemProperties.getBoolean; import static android.provider.MediaStore.MediaColumns; import static android.scopedstorage.cts.lib.RedactionTestHelper.assertExifMetadataMatch; import static android.scopedstorage.cts.lib.RedactionTestHelper.assertExifMetadataMismatch; import static android.scopedstorage.cts.lib.RedactionTestHelper.getExifMetadata; import static android.scopedstorage.cts.lib.RedactionTestHelper.getExifMetadataFromRawResource; import static android.scopedstorage.cts.lib.TestUtils.BYTES_DATA1; import static android.scopedstorage.cts.lib.TestUtils.BYTES_DATA2; import static android.scopedstorage.cts.lib.TestUtils.STR_DATA1; import static android.scopedstorage.cts.lib.TestUtils.STR_DATA2; import static android.scopedstorage.cts.lib.TestUtils.adoptShellPermissionIdentity; import static android.scopedstorage.cts.lib.TestUtils.allowAppOpsToUid; import static android.scopedstorage.cts.lib.TestUtils.assertCanRenameDirectory; import static android.scopedstorage.cts.lib.TestUtils.assertCanRenameFile; import static android.scopedstorage.cts.lib.TestUtils.assertCantRenameDirectory; import static android.scopedstorage.cts.lib.TestUtils.assertCantRenameFile; import static android.scopedstorage.cts.lib.TestUtils.assertDirectoryContains; import static android.scopedstorage.cts.lib.TestUtils.assertFileContent; import static android.scopedstorage.cts.lib.TestUtils.assertThrows; import static android.scopedstorage.cts.lib.TestUtils.canOpen; import static android.scopedstorage.cts.lib.TestUtils.canReadAndWriteAs; import static android.scopedstorage.cts.lib.TestUtils.createFileAs; import static android.scopedstorage.cts.lib.TestUtils.deleteFileAs; import static android.scopedstorage.cts.lib.TestUtils.deleteFileAsNoThrow; import static android.scopedstorage.cts.lib.TestUtils.deleteRecursively; import static android.scopedstorage.cts.lib.TestUtils.deleteWithMediaProvider; import static android.scopedstorage.cts.lib.TestUtils.deleteWithMediaProviderNoThrow; import static android.scopedstorage.cts.lib.TestUtils.denyAppOpsToUid; import static android.scopedstorage.cts.lib.TestUtils.dropShellPermissionIdentity; import static android.scopedstorage.cts.lib.TestUtils.executeShellCommand; import static android.scopedstorage.cts.lib.TestUtils.getAlarmsDir; import static android.scopedstorage.cts.lib.TestUtils.getAndroidDataDir; import static android.scopedstorage.cts.lib.TestUtils.getAndroidDir; import static android.scopedstorage.cts.lib.TestUtils.getAndroidMediaDir; import static android.scopedstorage.cts.lib.TestUtils.getAudiobooksDir; import static android.scopedstorage.cts.lib.TestUtils.getContentResolver; import static android.scopedstorage.cts.lib.TestUtils.getDcimDir; import static android.scopedstorage.cts.lib.TestUtils.getDefaultTopLevelDirs; import static android.scopedstorage.cts.lib.TestUtils.getDocumentsDir; import static android.scopedstorage.cts.lib.TestUtils.getDownloadDir; import static android.scopedstorage.cts.lib.TestUtils.getExternalFilesDir; import static android.scopedstorage.cts.lib.TestUtils.getExternalMediaDir; import static android.scopedstorage.cts.lib.TestUtils.getExternalStorageDir; import static android.scopedstorage.cts.lib.TestUtils.getFileMimeTypeFromDatabase; import static android.scopedstorage.cts.lib.TestUtils.getFileOwnerPackageFromDatabase; import static android.scopedstorage.cts.lib.TestUtils.getFileRowIdFromDatabase; import static android.scopedstorage.cts.lib.TestUtils.getFileSizeFromDatabase; import static android.scopedstorage.cts.lib.TestUtils.getFileUri; import static android.scopedstorage.cts.lib.TestUtils.getMoviesDir; import static android.scopedstorage.cts.lib.TestUtils.getMusicDir; import static android.scopedstorage.cts.lib.TestUtils.getNotificationsDir; import static android.scopedstorage.cts.lib.TestUtils.getPicturesDir; import static android.scopedstorage.cts.lib.TestUtils.getPodcastsDir; import static android.scopedstorage.cts.lib.TestUtils.getRingtonesDir; import static android.scopedstorage.cts.lib.TestUtils.grantPermission; import static android.scopedstorage.cts.lib.TestUtils.installApp; import static android.scopedstorage.cts.lib.TestUtils.installAppWithStoragePermissions; import static android.scopedstorage.cts.lib.TestUtils.listAs; import static android.scopedstorage.cts.lib.TestUtils.openFileAs; import static android.scopedstorage.cts.lib.TestUtils.openWithMediaProvider; import static android.scopedstorage.cts.lib.TestUtils.pollForExternalStorageState; import static android.scopedstorage.cts.lib.TestUtils.pollForManageExternalStorageAllowed; import static android.scopedstorage.cts.lib.TestUtils.pollForPermission; import static android.scopedstorage.cts.lib.TestUtils.queryFile; import static android.scopedstorage.cts.lib.TestUtils.queryFileExcludingPending; import static android.scopedstorage.cts.lib.TestUtils.queryImageFile; import static android.scopedstorage.cts.lib.TestUtils.queryVideoFile; import static android.scopedstorage.cts.lib.TestUtils.readExifMetadataFromTestApp; import static android.scopedstorage.cts.lib.TestUtils.revokePermission; import static android.scopedstorage.cts.lib.TestUtils.setAttrAs; import static android.scopedstorage.cts.lib.TestUtils.setupDefaultDirectories; import static android.scopedstorage.cts.lib.TestUtils.uninstallApp; import static android.scopedstorage.cts.lib.TestUtils.uninstallAppNoThrow; import static android.scopedstorage.cts.lib.TestUtils.updateDisplayNameWithMediaProvider; import static android.system.OsConstants.F_OK; import static android.system.OsConstants.O_APPEND; import static android.system.OsConstants.O_CREAT; import static android.system.OsConstants.O_EXCL; import static android.system.OsConstants.O_RDWR; import static android.system.OsConstants.O_TRUNC; import static android.system.OsConstants.R_OK; import static android.system.OsConstants.S_IRWXU; import static android.system.OsConstants.W_OK;  import static androidx.test.InstrumentationRegistry.getContext;  import static com.google.common.truth.Truth.assertThat; import static com.google.common.truth.Truth.assertWithMessage;  import static junit.framework.Assert.assertFalse; import static junit.framework.Assert.assertTrue;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assume.assumeFalse; import static org.junit.Assume.assumeTrue;  import android.Manifest; import android.app.AppOpsManager; import android.app.WallpaperManager; import android.content.ContentResolver; import android.content.ContentValues; import android.database.Cursor; import android.net.Uri; import android.os.Bundle; import android.os.Environment; import android.os.FileUtils; import android.os.ParcelFileDescriptor; import android.os.Process; import android.platform.test.annotations.AppModeInstant; import android.provider.MediaStore; import android.system.ErrnoException; import android.system.Os; import android.system.StructStat; import android.util.Log;  import androidx.annotation.Nullable; import androidx.test.runner.AndroidJUnit4;  import com.android.cts.install.lib.TestApp;  import com.google.common.io.Files;  import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith;  import java.io.File; import java.io.FileDescriptor; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.nio.ByteBuffer; import java.util.Arrays; import java.util.HashMap; import java.util.List;  /**  * Runs the scoped storage tests on primary external storage.  *  * <p>These tests are also run on a public volume by {@link PublicVolumeTest}.  */ @RunWith(AndroidJUnit4.class) public class ScopedStorageTest {     static final String TAG = ""ScopedStorageTest"";     static final String CONTENT_PROVIDER_URL = ""content://android.tradefed.contentprovider"";     static final String THIS_PACKAGE_NAME = getContext().getPackageName();     static final int USER_SYSTEM = 0;      /**      * To help avoid flaky tests, give ourselves a unique nonce to be used for      * all filesystem paths, so that we don't risk conflicting with previous      * test runs.      */     static final String NONCE = String.valueOf(System.nanoTime());      static final String TEST_DIRECTORY_NAME = ""ScopedStorageTestDirectory"" + NONCE;      static final String AUDIO_FILE_NAME = ""ScopedStorageTest_file_"" + NONCE + "".mp3"";     static final String PLAYLIST_FILE_NAME = ""ScopedStorageTest_file_"" + NONCE + "".m3u"";     static final String SUBTITLE_FILE_NAME = ""ScopedStorageTest_file_"" + NONCE + "".srt"";     static final String VIDEO_FILE_NAME = ""ScopedStorageTest_file_"" + NONCE + "".mp4"";     static final String IMAGE_FILE_NAME = ""ScopedStorageTest_file_"" + NONCE + "".jpg"";     static final String NONMEDIA_FILE_NAME = ""ScopedStorageTest_file_"" + NONCE + "".pdf"";      static final String FILE_CREATION_ERROR_MESSAGE = ""No such file or directory"";      private static final TestApp TEST_APP_A = new TestApp(""TestAppA"",             ""android.scopedstorage.cts.testapp.A"", 1, false, ""CtsScopedStorageTestAppA.apk"");     private static final TestApp TEST_APP_B = new TestApp(""TestAppB"",             ""android.scopedstorage.cts.testapp.B"", 1, false, ""CtsScopedStorageTestAppB.apk"");     private static final TestApp TEST_APP_C = new TestApp(""TestAppC"",             ""android.scopedstorage.cts.testapp.C"", 1, false, ""CtsScopedStorageTestAppC.apk"");     private static final TestApp TEST_APP_C_LEGACY = new TestApp(""TestAppCLegacy"",             ""android.scopedstorage.cts.testapp.C"", 1, false, ""CtsScopedStorageTestAppCLegacy.apk"");     private static final String[] SYSTEM_GALERY_APPOPS = {             AppOpsManager.OPSTR_WRITE_MEDIA_IMAGES, AppOpsManager.OPSTR_WRITE_MEDIA_VIDEO};     private static final String OPSTR_MANAGE_EXTERNAL_STORAGE =             permissionToOp(Manifest.permission.MANAGE_EXTERNAL_STORAGE);      @Before     public void setup() throws Exception {         // skips all test cases if FUSE is not active.         assumeTrue(getBoolean(""persist.sys.fuse"", false));          if (!getContext().getPackageManager().isInstantApp()) {             pollForExternalStorageState();             getExternalFilesDir().mkdirs();         }     }      /**      * This method needs to be called once before running the whole test.      */"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.net.cts.LocalSocketAddress_NamespaceTest"	"testValueOf"	""	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"FileSystem"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/LocalSocketAddress_NamespaceTest.java"	""	"public void testValueOf() {         assertEquals(Namespace.ABSTRACT, Namespace.valueOf(""ABSTRACT""));         assertEquals(Namespace.RESERVED, Namespace.valueOf(""RESERVED""));         assertEquals(Namespace.FILESYSTEM, Namespace.valueOf(""FILESYSTEM""));     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.net.cts.LocalSocketAddress_NamespaceTest"	"testValues"	""	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"FileSystem"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/LocalSocketAddress_NamespaceTest.java"	""	"public void testValues() {         Namespace[] expected = Namespace.values();         assertEquals(Namespace.ABSTRACT, expected[0]);         assertEquals(Namespace.RESERVED, expected[1]);         assertEquals(Namespace.FILESYSTEM, expected[2]);     } }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.os.cts.BuildVersionTest"	"testIncremental"	"CtsOsHostTestCases"	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"Incremental"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/BuildVersionTest.java"	""	"public void testIncremental() {         assertNotEmpty(Build.VERSION.INCREMENTAL);     }      /**      * Verifies {@link Build#FINGERPRINT} follows expected format:      * <p/>      * <code>      * (BRAND)/(PRODUCT)/(DEVICE):(VERSION.RELEASE)/(BUILD_ID)/      * (BUILD_NUMBER):(BUILD_VARIANT)/(TAGS)      * </code>      */     @RestrictedBuildTest"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV4WithV2Signer"	""	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"Incremental"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV4WithV2Signer() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // APK generated with:         // apksigner sign --v2-signing-enabled true --v3-signing-enabled false --v4-signing-enabled         assertInstallV4Succeeds(""v4-digest-v2.apk"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV4WithV3Signer"	""	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"Incremental"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV4WithV3Signer() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // APK generated with:         // apksigner sign --v2-signing-enabled false --v3-signing-enabled true --v4-signing-enabled         assertInstallV4Succeeds(""v4-digest-v3.apk"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV4WithV2V3Signer"	""	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"Incremental"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV4WithV2V3Signer() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // APK generated with:         // apksigner sign --v2-signing-enabled true --v3-signing-enabled true --v4-signing-enabled         assertInstallV4Succeeds(""v4-digest-v2v3.apk"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV4WithV2NoVeritySigner"	""	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"Incremental"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV4WithV2NoVeritySigner() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // APK generated with:         // --v2-signing-enabled true --v3-signing-enabled false --v4-signing-enabled         // Full commands in generate-apks.sh         assertInstallV4SucceedsAndUninstall(""v4-digest-v2-Sha256withDSA.apk"");         assertInstallV4SucceedsAndUninstall(""v4-digest-v2-Sha256withEC.apk"");         assertInstallV4SucceedsAndUninstall(""v4-digest-v2-Sha256withRSA.apk"");         assertInstallV4SucceedsAndUninstall(""v4-digest-v2-Sha512withEC.apk"");         assertInstallV4SucceedsAndUninstall(""v4-digest-v2-Sha512withRSA.apk"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV4WithV2VeritySigner"	""	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"Incremental"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV4WithV2VeritySigner() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // APK generated with:         // --v2-signing-enabled true --v3-signing-enabled false         // --v4-signing-enabled --verity-enabled         // Full commands in generate-apks.sh         assertInstallV4SucceedsAndUninstall(""v4-digest-v2-Sha256withDSA-Verity.apk"");         assertInstallV4SucceedsAndUninstall(""v4-digest-v2-Sha256withEC-Verity.apk"");         assertInstallV4SucceedsAndUninstall(""v4-digest-v2-Sha256withRSA-Verity.apk"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV4WithV3NoVeritySigner"	""	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"Incremental"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV4WithV3NoVeritySigner() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // APK generated with:         // --v2-signing-enabled false --v3-signing-enabled true --v4-signing-enabled         // Full commands in generate-apks.sh         assertInstallV4SucceedsAndUninstall(""v4-digest-v3-Sha256withDSA.apk"");         assertInstallV4SucceedsAndUninstall(""v4-digest-v3-Sha256withEC.apk"");         assertInstallV4SucceedsAndUninstall(""v4-digest-v3-Sha256withRSA.apk"");         assertInstallV4SucceedsAndUninstall(""v4-digest-v3-Sha512withEC.apk"");         assertInstallV4SucceedsAndUninstall(""v4-digest-v3-Sha512withRSA.apk"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV4WithV3VeritySigner"	""	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"Incremental"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV4WithV3VeritySigner() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // APK generated with:         // --v2-signing-enabled false --v3-signing-enabled true         // --v4-signing-enabled --verity-enabled         // Full commands in generate-apks.sh         assertInstallV4SucceedsAndUninstall(""v4-digest-v3-Sha256withDSA-Verity.apk"");         assertInstallV4SucceedsAndUninstall(""v4-digest-v3-Sha256withEC-Verity.apk"");         assertInstallV4SucceedsAndUninstall(""v4-digest-v3-Sha256withRSA-Verity.apk"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV4WithV2SignerDoesNotVerify"	""	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"Incremental"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV4WithV2SignerDoesNotVerify() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // APKs generated with:         // apksigner sign -v2-signing-enabled true --v3-signing-enabled false --v4-signing-enabled          // Malformed v4 signature - first byte of v4 signing_info.signature is flipped         assertInstallV4FailsWithError(""v4-digest-v2-badv4signature.apk"", ""did not verify"");         // Malformed digest - first byte of v4 signing_info.apk_digest is flipped         assertInstallV4FailsWithError(""v4-digest-v2-badv2digest.apk"", ""did not verify"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV4WithV3SignerDoesNotVerify"	""	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"Incremental"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV4WithV3SignerDoesNotVerify() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // APKs generated with:         // apksigner sign -v2-signing-enabled false --v3-signing-enabled true --v4-signing-enabled          // Malformed v4 signature - first byte of v4 signing_info.signature is flipped         assertInstallV4FailsWithError(""v4-digest-v3-badv4signature.apk"", ""did not verify"");          // Malformed digest - first byte of v4 signing_info.apk_digest is flipped         assertInstallV4FailsWithError(""v4-digest-v3-badv3digest.apk"", ""did not verify"");      }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV4WithV2V3SignerDoesNotVerify"	""	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"Incremental"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV4WithV2V3SignerDoesNotVerify() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // APKs generated with:         // apksigner sign -v2-signing-enabled true --v3-signing-enabled true --v4-signing-enabled          // Malformed v4 signature - first byte of v4 signing_info.signature is flipped         assertInstallV4FailsWithError(""v4-digest-v2v3-badv4signature.apk"", ""did not verify"");          // Malformed digest - first byte of v4 signing_info.apk_digest is flipped         assertInstallV4FailsWithError(""v4-digest-v2v3-badv2v3digest.apk"", ""did not verify"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV4With128BytesAdditionalDataSucceeds"	""	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"Incremental"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV4With128BytesAdditionalDataSucceeds() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // Editing apksigner to fill additional data of size 128 bytes.         assertInstallV4Succeeds(""v4-digest-v3-128bytes-additional-data.apk"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV4With10MBytesAdditionalDataFails"	""	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"Incremental"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV4With10MBytesAdditionalDataFails() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // Editing apksigner to fill additional data of size 10 * 1024 * 1024 bytes..         assertInstallV4FailsWithError(""v4-digest-v3-10mbytes-additional-data.apk"",                 ""additionalData has to be at most 128 bytes"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV4WithWrongBlockSize"	""	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"Incremental"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV4WithWrongBlockSize() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // Editing apksigner with the wrong block size in the v4 signature.         assertInstallV4FailsWithError(""v4-digest-v3-wrong-block-size.apk"",                 ""did not verify"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV4WithDifferentBlockSize"	""	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"Incremental"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV4WithDifferentBlockSize() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // Editing apksigner with the different block size (2048 instead of 4096).         assertInstallV4FailsWithError(""v4-digest-v3-merkle-tree-different-block-size.apk"",                 ""Unsupported log2BlockSize: 11"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV4WithWrongRawRootHash"	""	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"Incremental"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV4WithWrongRawRootHash() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // Editing apksigner with the wrong raw root hash in the v4 signature.         assertInstallV4FailsWithError(""v4-digest-v3-wrong-raw-root-hash.apk"", ""Failure"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV4WithWrongSignatureBytes"	""	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"Incremental"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV4WithWrongSignatureBytes() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // Editing apksigner with the wrong signature bytes in the v4 signature.         assertInstallV4FailsWithError(""v4-digest-v3-wrong-sig-bytes.apk"",                 ""did not verify"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV4WithWrongSignatureBytesSize"	""	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"Incremental"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV4WithWrongSignatureBytesSize() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // Editing apksigner with the wrong signature byte size in the v4 signature.         assertInstallV4FailsWithError(""v4-digest-v3-wrong-sig-bytes-size.apk"",                 ""Failure"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV4WithNoMerkleTree"	""	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"Incremental"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV4WithNoMerkleTree() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // Editing apksigner to not include the Merkle tree.         assertInstallV4FailsWithError(""v4-digest-v3-no-merkle-tree.apk"",                 ""Failure"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV4WithWithTrailingDataInMerkleTree"	""	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"Incremental"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV4WithWithTrailingDataInMerkleTree() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // Editing apksigner to add trailing data after the Merkle tree         assertInstallV4FailsWithError(""v4-digest-v3-merkle-tree-1mb-trailing-data.apk"",                 ""Failure"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV4WithMerkleTreeBitsFlipped"	""	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"Incremental"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV4WithMerkleTreeBitsFlipped() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // Editing apksigner to flip few bits in the only node of the Merkle tree of a small app.         assertInstallV4FailsWithError(""v4-digest-v3-merkle-tree-bit-flipped.apk"",                 ""Failed to parse"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testV4IncToV3NonIncSameKeyUpgradeSucceeds"	""	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"Incremental"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testV4IncToV3NonIncSameKeyUpgradeSucceeds() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // See cts/hostsidetests/appsecurity/res/pkgsigverify/generate-apks.sh for the command         // to generate the apks         assertInstallV4Succeeds(""v4-inc-to-v3-noninc-ec-p256-appv1.apk"");          // non-incremental upgrade with the same key.         assertInstallSucceeds(""v4-inc-to-v3-noninc-ec-p256-appv2.apk"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testV4IncToV3NonIncMismatchingKeyUpgradeFails"	""	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"Incremental"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testV4IncToV3NonIncMismatchingKeyUpgradeFails() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // See cts/hostsidetests/appsecurity/res/pkgsigverify/generate-apks.sh for the command         // to generate the apks         assertInstallV4Succeeds(""v4-inc-to-v3-noninc-ec-p256-appv1.apk"");          // non-incremental upgrade with a mismatching key.         assertInstallFailsWithError(""v4-inc-to-v3-noninc-ec-p384-appv2.apk"",                 ""signatures do not match previously installed version"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testV4IncToV3NonIncRotatedKeyUpgradeSucceeds"	""	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"Incremental"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testV4IncToV3NonIncRotatedKeyUpgradeSucceeds() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // See cts/hostsidetests/appsecurity/res/pkgsigverify/generate-apks.sh for the command         // to generate the apks         assertInstallV4Succeeds(""v4-inc-to-v3-noninc-ec-p256-appv1.apk"");          // non-incremental upgrade with key rotation.         assertInstallSucceeds(""v4-inc-to-v3-noninc-ec-p384-rotated-ec-p256-appv2.apk"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testV4IncToV3NonIncMismatchedRotatedKeyUpgradeFails"	""	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"Incremental"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testV4IncToV3NonIncMismatchedRotatedKeyUpgradeFails() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // See cts/hostsidetests/appsecurity/res/pkgsigverify/generate-apks.sh for the command         // to generate the apks         assertInstallV4Succeeds(""v4-inc-to-v3-noninc-dsa-3072-appv1.apk"");          // non-incremental upgrade with key rotation mismatch with key used in app v1.         assertInstallFailsWithError(""v4-inc-to-v3-noninc-ec-p384-rotated-ec-p256-appv2.apk"",                 ""signatures do not match previously installed version"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testV4IncToV2NonIncSameKeyUpgradeSucceeds"	""	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"Incremental"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testV4IncToV2NonIncSameKeyUpgradeSucceeds() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // See cts/hostsidetests/appsecurity/res/pkgsigverify/generate-apks.sh for the command         // to generate the apks         assertInstallV4Succeeds(""v4-inc-to-v2-noninc-ec-p256-appv1.apk"");          // non-incremental upgrade with the same key.         assertInstallSucceeds(""v4-inc-to-v2-noninc-ec-p256-appv2.apk"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testV4IncToV2NonIncMismatchingKeyUpgradeFails"	""	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"Incremental"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testV4IncToV2NonIncMismatchingKeyUpgradeFails() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // See cts/hostsidetests/appsecurity/res/pkgsigverify/generate-apks.sh for the command         // to generate the apks         assertInstallV4Succeeds(""v4-inc-to-v2-noninc-ec-p256-appv1.apk"");          // non-incremental upgrade with a mismatching key.         assertInstallFailsWithError(""v4-inc-to-v2-noninc-ec-p384-appv2.apk"",                 ""signatures do not match previously installed version"");     }      private boolean hasIncrementalFeature() throws DeviceNotAvailableException {         return getDevice().hasFeature(""android.software.incremental_delivery"");     }      private void assertInstallSucceeds(String apkFilenameInResources) throws Exception {         String installResult = installPackageFromResource(apkFilenameInResources);         if (installResult != null) {             fail(""Failed to install "" + apkFilenameInResources + "": "" + installResult);         }     }      private void assertInstallEphemeralSucceeds(String apkFilenameInResources) throws Exception {         String installResult = installEphemeralPackageFromResource(apkFilenameInResources);         if (installResult != null) {             fail(""Failed to install "" + apkFilenameInResources + "": "" + installResult);         }     }      private void assertInstallSucceedsForEach(             String apkFilenamePatternInResources, String[] args) throws Exception {         for (String arg : args) {             String apkFilenameInResources =                     String.format(Locale.US, apkFilenamePatternInResources, arg);             String installResult = installPackageFromResource(apkFilenameInResources);             if (installResult != null) {                 fail(""Failed to install "" + apkFilenameInResources + "": "" + installResult);             }             try {                 uninstallPackage();             } catch (Exception e) {                 throw new RuntimeException(                         ""Failed to uninstall after installing "" + apkFilenameInResources, e);             }         }     }      private void assertInstallV4Succeeds(String apkFilenameInResources) throws Exception {         String installResult = installV4PackageFromResource(apkFilenameInResources);         if (!installResult.equals(""Success\n"")) {             fail(""Failed to install "" + apkFilenameInResources + "": "" + installResult);         }     }      private void assertInstallV4SucceedsAndUninstall(String apkFilenameInResources)             throws Exception {         assertInstallV4Succeeds(apkFilenameInResources);         try {             uninstallPackage();         } catch (Exception e) {             throw new RuntimeException(                     ""Failed to uninstall after installing "" + apkFilenameInResources, e);         }     }      private void assertInstallV4FailsWithError(String apkFilenameInResources, String errorSubstring)             throws Exception {         String installResult = installV4PackageFromResource(apkFilenameInResources);         if (installResult.equals(""Success\n"")) {             fail(""Install of "" + apkFilenameInResources + "" succeeded but was expected to fail""                     + "" with \"""" + errorSubstring + ""\"""");         }         assertContains(                 ""Install failure message of "" + apkFilenameInResources,                 errorSubstring,                 installResult);     }      private void assertInstallFailsWithError(             String apkFilenameInResources, String errorSubstring) throws Exception {         String installResult = installPackageFromResource(apkFilenameInResources);         if (installResult == null) {             fail(""Install of "" + apkFilenameInResources + "" succeeded but was expected to fail""                     + "" with \"""" + errorSubstring + ""\"""");         }         assertContains(                 ""Install failure message of "" + apkFilenameInResources,                 errorSubstring,                 installResult);     }      private void assertInstallEphemeralFailsWithError(             String apkFilenameInResources, String errorSubstring) throws Exception {         String installResult = installEphemeralPackageFromResource(apkFilenameInResources);         if (installResult == null) {             fail(""Install of "" + apkFilenameInResources + "" succeeded but was expected to fail""                     + "" with \"""" + errorSubstring + ""\"""");         }         assertContains(                 ""Install failure message of "" + apkFilenameInResources,                 errorSubstring,                 installResult);     }      private void assertInstallFails(String apkFilenameInResources) throws Exception {         String installResult = installPackageFromResource(apkFilenameInResources);         if (installResult == null) {             fail(""Install of "" + apkFilenameInResources + "" succeeded but was expected to fail"");         }     }      private static void assertContains(String message, String expectedSubstring, String actual) {         String errorPrefix = ((message != null) && (message.length() > 0)) ? (message + "": "") : """";         if (actual == null) {             fail(errorPrefix + ""Expected to contain \"""" + expectedSubstring + ""\"", but was null"");         }         if (!actual.contains(expectedSubstring)) {             fail(errorPrefix + ""Expected to contain \"""" + expectedSubstring + ""\"", but was \""""                     + actual + ""\"""");         }     }      private void installDeviceTestPkg() throws Exception {         assertInstallFromBuildSucceeds(DEVICE_TESTS_APK);     }      private void assertInstallFromBuildSucceeds(String apkName) throws Exception {         String result = installApkFromBuild(apkName);         assertNull(""failed to install "" + apkName + "", Reason: "" + result, result);     }      private void assertInstallFromBuildFails(String apkName) throws Exception {         String result = installApkFromBuild(apkName);         assertNotNull(""Successfully installed "" + apkName + "" when failure was expected"", result);     }      private String installApkFromBuild(String apkName) throws Exception {         CompatibilityBuildHelper buildHelper = new CompatibilityBuildHelper(mCtsBuild);         File apk = buildHelper.getTestFile(apkName);         return getDevice().installPackage(apk, true, INSTALL_ARG_FORCE_QUERYABLE);     }      private String installPackageFromResource(String apkFilenameInResources, boolean ephemeral)             throws IOException, DeviceNotAvailableException {         // ITestDevice.installPackage API requires the APK to be install to be a File. We thus         // copy the requested resource into a temporary file, attempt to install it, and delete the         // file during cleanup.         File apkFile = null;         try {             apkFile = getFileFromResource(apkFilenameInResources);             if (ephemeral) {                 return getDevice().installPackage(apkFile, true, ""--ephemeral"",                         INSTALL_ARG_FORCE_QUERYABLE);             } else {                 return getDevice().installPackage(apkFile, true, INSTALL_ARG_FORCE_QUERYABLE);             }         } finally {             cleanUpFile(apkFile);         }     }      private String installV4PackageFromResource(String apkFilenameInResources)             throws IOException, DeviceNotAvailableException {         File apkFile = null;         File v4SignatureFile = null;         try {             apkFile = getFileFromResource(apkFilenameInResources);             v4SignatureFile = getFileFromResource(apkFilenameInResources + "".idsig"");             String remoteApkFilePath = pushFileToRemote(apkFile);             pushFileToRemote(v4SignatureFile);             return installV4Package(remoteApkFilePath);         } finally {             cleanUpFile(apkFile);             cleanUpFile(v4SignatureFile);         }     }      private String pushFileToRemote(File localFile) throws DeviceNotAvailableException {         String remotePath = ""/data/local/tmp/pkginstalltest-"" + localFile.getName();         getDevice().pushFile(localFile, remotePath);         return remotePath;     }      private String installV4Package(String remoteApkPath)             throws DeviceNotAvailableException {         String command = ""pm install-incremental -t -g "" + remoteApkPath;         return getDevice().executeShellCommand(command);     }      private File getFileFromResource(String filenameInResources)             throws IOException, IllegalArgumentException {         String fullResourceName = TEST_APK_RESOURCE_PREFIX + filenameInResources;         File tempDir = FileUtil.createTempDir(""pkginstalltest"");         File file = new File(tempDir, filenameInResources);         InputStream in = getClass().getResourceAsStream(fullResourceName);         if (in == null) {             throw new IllegalArgumentException(""Resource not found: "" + fullResourceName);         }         OutputStream out = new BufferedOutputStream(new FileOutputStream(file));         byte[] buf = new byte[65536];         int chunkSize;         while ((chunkSize = in.read(buf)) != -1) {             out.write(buf, 0, chunkSize);         }         out.close();         return file;     }      private void cleanUpFile(File file) {         if (file != null && file.exists()) {             file.delete();         }     }      private String installPackageFromResource(String apkFilenameInResources)             throws IOException, DeviceNotAvailableException {         return installPackageFromResource(apkFilenameInResources, false);     }      private String installEphemeralPackageFromResource(String apkFilenameInResources)             throws IOException, DeviceNotAvailableException {         return installPackageFromResource(apkFilenameInResources, true);     }      private String uninstallPackage() throws DeviceNotAvailableException {         return getDevice().uninstallPackage(TEST_PKG);     }      private String uninstallCompanionPackages() throws DeviceNotAvailableException {         String result1 = getDevice().uninstallPackage(COMPANION_TEST_PKG);         String result2 = getDevice().uninstallPackage(COMPANION2_TEST_PKG);         return result1 != null ? result1 : result2;     }      private String uninstallDeviceTestPackage() throws DeviceNotAvailableException {         return getDevice().uninstallPackage(DEVICE_TESTS_PKG);     }      private void uninstallServicePackages() throws DeviceNotAvailableException {         getDevice().uninstallPackage(SERVICE_PKG);         getDevice().uninstallPackage(SERVICE_TEST_PKG);     }      private void uninstallPackages() throws DeviceNotAvailableException {         uninstallPackage();         uninstallCompanionPackages();         uninstallDeviceTestPackage();         uninstallServicePackages();     } }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"com.android.cts.splitapp.SplitAppTest"	"testPrimaryOnSameVolume"	""	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"FileSystem"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/test-apps/SplitApp/src/com/android/cts/splitapp/SplitAppTest.java"	""	"public void testPrimaryOnSameVolume() throws Exception {         final File current = getContext().getFilesDir();         final File primary = Environment.getExternalStorageDirectory();          // Shared storage may jump through another filesystem for permission         // enforcement, so we verify that total/free space are identical.         final long totalDelta = Math.abs(current.getTotalSpace() - primary.getTotalSpace());         final long freeDelta = Math.abs(current.getFreeSpace() - primary.getFreeSpace());         if (totalDelta > MB_IN_BYTES * 300 || freeDelta > MB_IN_BYTES * 300) {             fail(""Expected primary storage to be on same volume as app"");         }     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.filesystem.cts.AlmostFullTest"	"AlmostFullTest"	"CtsFileSystemTestCases"	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"FileSystem"	""	""	""	"/home/gpoor/cts-source/cts/tests/filesystem/src/android/filesystem/cts/AlmostFullTest.java"	""	"/*  *.  */  package android.filesystem.cts;  import static androidx.test.InstrumentationRegistry.getContext; import static androidx.test.InstrumentationRegistry.getInstrumentation;  import android.util.Log;  import androidx.test.runner.AndroidJUnit4;  import com.android.compatibility.common.util.DeviceReportLog; import com.android.compatibility.common.util.SystemUtil;  import org.junit.After; import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith;  import java.util.concurrent.atomic.AtomicBoolean; import java.util.concurrent.atomic.AtomicInteger;  @RunWith(AndroidJUnit4.class) public class AlmostFullTest {     private static final String DIR_INITIAL_FILL = ""INITIAL_FILL"";     private static final String DIR_SEQ_UPDATE = ""SEQ_UPDATE"";     private static final String DIR_RANDOM_WR = ""RANDOM_WR"";     private static final String DIR_RANDOM_RD = ""RANDOM_RD"";     private static final String TAG = ""AlmostFullTest"";     private static final String REPORT_LOG_NAME = ""CtsFileSystemTestCases"";      private static final long FREE_SPACE_FINAL = 1000L * 1024 * 1024L;      // test runner creates multiple instances at the begging.     // use that to fill disk only once.     // set as final to initialize it only once     private static final AtomicInteger mRefCounter = new AtomicInteger(0);     private static final AtomicBoolean mDiskFilled = new AtomicBoolean(false);      public AlmostFullTest() {         int currentCounter = mRefCounter.incrementAndGet();         Log.i(TAG, ""++currentCounter: "" + currentCounter);     }      @Before     public void setUp() throws Exception {         if (mDiskFilled.compareAndSet(false, true)) {             Log.i(TAG, ""Filling disk"");             // initial fill done in two stage as disk can be filled by other             // components             long freeDisk = SystemUtil.getFreeDiskSize(getContext());             long diskToFill = freeDisk - FREE_SPACE_FINAL;             if (diskToFill >= 0) {                 Log.i(TAG, ""free disk "" + freeDisk + "", to fill "" + diskToFill);             } else {                 Log.i(TAG, ""free disk "" + freeDisk + "" too small, needs "" + FREE_SPACE_FINAL);                 return;             }             // Ensure MAX_SIZE_TO_FILL is an integral multiple of FileUtil.BUFFER_SIZE to avoid             // rounding errors caused by FileUtil.createNewFilledFile. See b/63535343.             final long MAX_FILE_SIZE_TO_FILL = FileUtil.BUFFER_SIZE * 100L;             long filled = 0;             while (filled < diskToFill) {                 long toFill = diskToFill - filled;                 if (toFill > MAX_FILE_SIZE_TO_FILL) {                     toFill = MAX_FILE_SIZE_TO_FILL;                 }                 Log.i(TAG, ""Generating file "" + toFill);                 FileUtil.createNewFilledFile(getContext(),                         DIR_INITIAL_FILL, toFill);                 filled += toFill;             }         }         Log.i(TAG, ""free disk "" + SystemUtil.getFreeDiskSize(getContext()));     }      @After     public void tearDown() throws Exception {         Log.i(TAG, ""tearDown free disk "" + SystemUtil.getFreeDiskSize(getContext()));         int currentCounter = mRefCounter.decrementAndGet();         Log.i(TAG, ""--currentCounter: "" + currentCounter);         if (currentCounter == 0) {             FileUtil.removeFileOrDir(getContext(), DIR_INITIAL_FILL);         }         FileUtil.removeFileOrDir(getContext(), DIR_SEQ_UPDATE);         FileUtil.removeFileOrDir(getContext(), DIR_RANDOM_WR);         FileUtil.removeFileOrDir(getContext(), DIR_RANDOM_RD);         Log.i(TAG, ""tearDown free disk "" + SystemUtil.getFreeDiskSize(getContext()));     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.cts.statsd.atom.UidAtomTests"	"testPackageInstallerV2MetricsReported"	""	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"Incremental"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/statsd/src/android/cts/statsd/atom/UidAtomTests.java"	""	"public void testPackageInstallerV2MetricsReported() throws Throwable {         if (!hasFeature(FEATURE_INCREMENTAL_DELIVERY, true)) return;         final AtomsProto.PackageInstallerV2Reported report = installPackageUsingV2AndGetReport(                 new String[]{TEST_INSTALL_APK});         assertTrue(report.getIsIncremental());         // tests are ran using SHELL_UID and installation will be treated as adb install         assertEquals("""", report.getPackageName());         assertEquals(1, report.getReturnCode());         assertTrue(report.getDurationMillis() > 0);         assertEquals(getTestFileSize(TEST_INSTALL_APK), report.getApksSizeBytes());          getDevice().uninstallPackage(TEST_INSTALL_PACKAGE);     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.cts.statsd.atom.UidAtomTests"	"testPackageInstallerV2MetricsReportedForSplits"	""	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"Incremental"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/statsd/src/android/cts/statsd/atom/UidAtomTests.java"	""	"public void testPackageInstallerV2MetricsReportedForSplits() throws Throwable {         if (!hasFeature(FEATURE_INCREMENTAL_DELIVERY, true)) return;          final AtomsProto.PackageInstallerV2Reported report = installPackageUsingV2AndGetReport(                 new String[]{TEST_INSTALL_APK_BASE, TEST_INSTALL_APK_SPLIT});         assertTrue(report.getIsIncremental());         // tests are ran using SHELL_UID and installation will be treated as adb install         assertEquals("""", report.getPackageName());         assertEquals(1, report.getReturnCode());         assertTrue(report.getDurationMillis() > 0);         assertEquals(                 getTestFileSize(TEST_INSTALL_APK_BASE) + getTestFileSize(TEST_INSTALL_APK_SPLIT),                 report.getApksSizeBytes());          getDevice().uninstallPackage(TEST_INSTALL_PACKAGE);     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.cts.statsd.atom.UidAtomTests"	"testAppForegroundBackground"	""	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"Incremental"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/statsd/src/android/cts/statsd/atom/UidAtomTests.java"	""	"public void testAppForegroundBackground() throws Exception {         Set<Integer> onStates = new HashSet<>(Arrays.asList(                 AppUsageEventOccurred.EventType.MOVE_TO_FOREGROUND_VALUE));         Set<Integer> offStates = new HashSet<>(Arrays.asList(                 AppUsageEventOccurred.EventType.MOVE_TO_BACKGROUND_VALUE));          List<Set<Integer>> stateSet = Arrays.asList(onStates, offStates); // state sets, in order         createAndUploadConfig(Atom.APP_USAGE_EVENT_OCCURRED_FIELD_NUMBER, false);  // False: does not use attribution.         Thread.sleep(WAIT_TIME_FOR_CONFIG_UPDATE_MS);          getDevice().executeShellCommand(String.format(             ""am start -n '%s' -e %s %s"",             ""com.android.server.cts.device.statsd/.StatsdCtsForegroundActivity"",             ""action"", ACTION_SHOW_APPLICATION_OVERLAY));         final int waitTime = EXTRA_WAIT_TIME_MS + 5_000; // Overlay may need to sit there a while.         Thread.sleep(waitTime + STATSD_REPORT_WAIT_TIME_MS);          List<EventMetricData> data = getEventMetricDataList();         Function<Atom, Integer> appUsageStateFunction = atom -> atom.getAppUsageEventOccurred().getEventType().getNumber();         popUntilFind(data, onStates, appUsageStateFunction); // clear out initial appusage states.         assertStatesOccurred(stateSet, data, 0, appUsageStateFunction);     }      private AtomsProto.PackageInstallerV2Reported installPackageUsingV2AndGetReport(             String[] apkNames) throws Exception {         createAndUploadConfig(Atom.PACKAGE_INSTALLER_V2_REPORTED_FIELD_NUMBER);         Thread.sleep(WAIT_TIME_SHORT);         installPackageUsingIncremental(apkNames, TEST_REMOTE_DIR);         assertTrue(getDevice().isPackageInstalled(TEST_INSTALL_PACKAGE));         Thread.sleep(WAIT_TIME_SHORT);          List<AtomsProto.PackageInstallerV2Reported> reports = new ArrayList<>();         for(EventMetricData data : getEventMetricDataList()) {             if (data.getAtom().hasPackageInstallerV2Reported()) {                 reports.add(data.getAtom().getPackageInstallerV2Reported());             }         }         assertEquals(1, reports.size());         return reports.get(0);     }      private void installPackageUsingIncremental(String[] apkNames, String remoteDirPath)             throws Exception {         getDevice().executeShellCommand(""mkdir "" + remoteDirPath);         String[] remoteApkPaths = new String[apkNames.length];         for (int i = 0; i < remoteApkPaths.length; i++) {             remoteApkPaths[i] = pushApkToRemote(apkNames[i], remoteDirPath);         }         getDevice().executeShellCommand(                 ""pm install-incremental -t -g "" + String.join("" "", remoteApkPaths));     }      private String pushApkToRemote(String apkName, String remoteDirPath)             throws Exception {         CompatibilityBuildHelper buildHelper = new CompatibilityBuildHelper(getBuild());         final File apk = buildHelper.getTestFile(apkName);         final String remoteApkPath = remoteDirPath + ""/"" + apk.getName();         assertTrue(getDevice().pushFile(apk, remoteApkPath));         assertNotNull(apk);         return remoteApkPath;     }      private long getTestFileSize(String fileName) throws Exception {         CompatibilityBuildHelper buildHelper = new CompatibilityBuildHelper(getBuild());         final File file = buildHelper.getTestFile(fileName);         return file.length();     }      private long getDeviceTimeMs() throws Exception {         String timeMs = getDevice().executeShellCommand(""date +%s%3N"");         return Long.parseLong(timeMs.trim());     } }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.incrementalinstall.inrementaltestappvalidation.AppValidationTest"	"testAppComponentsInvoked"	""	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"Incremental"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/incrementalinstall/appvalidator/src/android/incrementalinstall/inrementaltestappvalidation/AppValidationTest.java"	""	"public void testAppComponentsInvoked() throws Exception {         String[] loadedComponents = InstrumentationRegistry.getArguments()                 .getString(LOADED_COMPONENTS_TAG).split("","");         String[] notLoadedComponents = InstrumentationRegistry.getArguments()                 .getString(NOT_LOADED_COMPONENTS_TAG).split("","");         StatusReceiver statusReceiver = new StatusReceiver();         IntentFilter intentFilter = new IntentFilter(INCREMENTAL_TEST_APP_STATUS_RECEIVER_ACTION);         mContext.registerReceiver(statusReceiver, intentFilter);         launchTestApp();         for (String component : loadedComponents) {             assertTrue(                     String.format(""Component :%s was not loaded, when it should have."", component),                     statusReceiver.verifyComponentInvoked(component));         }         for (String component : notLoadedComponents) {             assertFalse(                     String.format(""Component :%s was loaded, when it shouldn't have."", component),                     statusReceiver.verifyComponentInvoked(component));         }         mContext.unregisterReceiver(statusReceiver);     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.net.cts.LocalSocketAddressTest"	"testNewLocalSocketAddressWithDefaultNamespace"	""	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"FileSystem"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/LocalSocketAddressTest.java"	""	"public void testNewLocalSocketAddressWithDefaultNamespace() {         // default namespace         LocalSocketAddress localSocketAddress = new LocalSocketAddress(""name"");         assertEquals(""name"", localSocketAddress.getName());         assertEquals(Namespace.ABSTRACT, localSocketAddress.getNamespace());          // specify the namespace         LocalSocketAddress localSocketAddress2 =                 new LocalSocketAddress(""name2"", Namespace.ABSTRACT);         assertEquals(""name2"", localSocketAddress2.getName());         assertEquals(Namespace.ABSTRACT, localSocketAddress2.getNamespace());          LocalSocketAddress localSocketAddress3 =                 new LocalSocketAddress(""name3"", Namespace.FILESYSTEM);         assertEquals(""name3"", localSocketAddress3.getName());         assertEquals(Namespace.FILESYSTEM, localSocketAddress3.getNamespace());          LocalSocketAddress localSocketAddress4 =                 new LocalSocketAddress(""name4"", Namespace.RESERVED);         assertEquals(""name4"", localSocketAddress4.getName());         assertEquals(Namespace.RESERVED, localSocketAddress4.getNamespace());     } }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.os.cts.EnvironmentTest"	"testNoTmpDir"	"CtsOsHostTestCases"	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"FileSystem"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/EnvironmentTest.java"	""	"public void testNoTmpDir() {         assertNull(""environment variable TMPDIR should not be set"",                 System.getenv(""TMPDIR""));     }      /**      * Verify that all writable block filesystems are mounted ""noatime"" to avoid      * unnecessary flash churn.      */"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.os.cts.EnvironmentTest"	"testHidePid2"	"CtsOsHostTestCases"	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"FileSystem"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/EnvironmentTest.java"	""	"public void testHidePid2() throws Exception {         try (BufferedReader br = new BufferedReader(new FileReader(""/proc/mounts""))) {             String line;             while ((line = br.readLine()) != null) {                 final String[] fields = line.split("" "");                 final String source = fields[0];                 final String options = fields[3];                  if (source.equals(""proc"") && !options.contains(""hidepid=2"")) {                     fail(""proc filesystem mounted without hidepid=2"");                 }             }         }     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.os.cts.EnvironmentTest"	"testHidePid2_direct"	"CtsOsHostTestCases"	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"FileSystem"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/EnvironmentTest.java"	""	"public void testHidePid2_direct() throws Exception {         assertFalse(new File(""/proc/1"").exists());     }      /**      * Verify that all writable block filesystems are mounted with ""resgid"" to      * mitigate disk-full trouble.      */"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.cts.statsd.atom.HostAtomTests"	"testBuildInformation"	""	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"Incremental"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/statsd/src/android/cts/statsd/atom/HostAtomTests.java"	""	"public void testBuildInformation() throws Exception {         StatsdConfig.Builder config = createConfigBuilder();         addGaugeAtomWithDimensions(config, Atom.BUILD_INFORMATION_FIELD_NUMBER, null);         uploadConfig(config);          Thread.sleep(WAIT_TIME_LONG);         setAppBreadcrumbPredicate();         Thread.sleep(WAIT_TIME_LONG);          List<Atom> data = getGaugeMetricDataList();         assertThat(data).isNotEmpty();         BuildInformation atom = data.get(0).getBuildInformation();         assertThat(getProperty(""ro.product.brand"")).isEqualTo(atom.getBrand());         assertThat(getProperty(""ro.product.name"")).isEqualTo(atom.getProduct());         assertThat(getProperty(""ro.product.device"")).isEqualTo(atom.getDevice());         assertThat(getProperty(""ro.build.version.release_or_codename"")).isEqualTo(atom.getVersionRelease());         assertThat(getProperty(""ro.build.id"")).isEqualTo(atom.getId());         assertThat(getProperty(""ro.build.version.incremental""))             .isEqualTo(atom.getVersionIncremental());         assertThat(getProperty(""ro.build.type"")).isEqualTo(atom.getType());         assertThat(getProperty(""ro.build.tags"")).isEqualTo(atom.getTags());     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.incrementalinstall.cts.IncrementalFeatureTest"	"testFeatureAvailable"	""	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"Incremental"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/incrementalinstall/src/android/incrementalinstall/cts/IncrementalFeatureTest.java"	""	"public void testFeatureAvailable() throws Exception {         assertTrue(getDevice().hasFeature(FEATURE_INCREMENTAL_DELIVERY));     }      @CddTest(requirement=""4/C-1-1,C-3-1"")"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.incrementalinstall.cts.IncrementalFeatureTest"	"testFeatureWorkingWithInstallation"	""	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"Incremental"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/incrementalinstall/src/android/incrementalinstall/cts/IncrementalFeatureTest.java"	""	"public void testFeatureWorkingWithInstallation() throws Exception {         getDevice().executeShellCommand(""mkdir "" + TEST_REMOTE_DIR);         CompatibilityBuildHelper buildHelper = new CompatibilityBuildHelper(getBuild());         final File apk = buildHelper.getTestFile(TEST_APP_BASE_APK_NAME);         assertNotNull(apk);         final File idsig = buildHelper.getTestFile(TEST_APP_BASE_APK_IDSIG_NAME);         assertNotNull(idsig);         final String remoteApkPath = TEST_REMOTE_DIR + ""/"" + apk.getName();         final String remoteIdsigPath = remoteApkPath + IDSIG_SUFFIX;         assertTrue(getDevice().pushFile(apk, remoteApkPath));         assertTrue(getDevice().pushFile(idsig, remoteIdsigPath));         String installResult = getDevice().executeShellCommand(                 ""pm install-incremental -t -g "" + remoteApkPath);         assertEquals(""Success\n"", installResult);         assertTrue(getDevice().isPackageInstalled(TEST_APP_PACKAGE_NAME));         getDevice().uninstallPackage(TEST_APP_PACKAGE_NAME);     } }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.carrierapi.cts.NetworkScanApiTest"	"adoptShellPermissionIdentity"	"CtsCarrierApiTestCases"	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"Incremental"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/carrierapi/src/android/carrierapi/cts/NetworkScanApiTest.java"	""	"/*  *.  */ package android.carrierapi.cts;  import static android.Manifest.permission.ACCESS_BACKGROUND_LOCATION; import static android.Manifest.permission.ACCESS_FINE_LOCATION;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNotSame; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail;  import android.content.Context; import android.content.pm.PackageInfo; import android.content.pm.PackageManager; import android.database.ContentObserver; import android.os.AsyncTask; import android.os.Handler; import android.os.HandlerThread; import android.os.Message; import android.os.Parcel; import android.os.Process; import android.os.UserHandle; import android.provider.Settings; import android.telephony.AccessNetworkConstants; import android.telephony.CellInfo; import android.telephony.CellInfoGsm; import android.telephony.CellInfoLte; import android.telephony.CellInfoWcdma; import android.telephony.NetworkScan; import android.telephony.NetworkScanRequest; import android.telephony.RadioAccessSpecifier; import android.telephony.TelephonyManager; import android.telephony.TelephonyScanManager; import android.util.Log;  import androidx.test.InstrumentationRegistry; import androidx.test.runner.AndroidJUnit4;  import org.junit.After; import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith;  import java.util.ArrayList; import java.util.Arrays; import java.util.List; import java.util.concurrent.CountDownLatch; import java.util.concurrent.TimeUnit; import java.util.stream.Collectors;  /**  * Build, install and run the tests by running the commands below:  *  make cts -j64  *  cts-tradefed run cts -m CtsCarrierApiTestCases --test android.carrierapi.cts.NetworkScanApiTest  */ @RunWith(AndroidJUnit4.class) public class NetworkScanApiTest {     private TelephonyManager mTelephonyManager;     private PackageManager mPackageManager;     private static final String TAG = ""NetworkScanApiTest"";     private int mNetworkScanStatus;     private static final int EVENT_NETWORK_SCAN_START = 100;     private static final int EVENT_NETWORK_SCAN_RESULTS = 200;     private static final int EVENT_NETWORK_SCAN_RESTRICTED_RESULTS = 201;     private static final int EVENT_NETWORK_SCAN_ERROR = 300;     private static final int EVENT_NETWORK_SCAN_COMPLETED = 400;     private static final int EVENT_SCAN_DENIED = 500;     private List<CellInfo> mScanResults = null;     private NetworkScanHandlerThread mTestHandlerThread;     private Handler mHandler;     private NetworkScan mNetworkScan;     private NetworkScanRequest mNetworkScanRequest;     private NetworkScanCallbackImpl mNetworkScanCallback;     private static final int LOCATION_SETTING_CHANGE_WAIT_MS = 1000;     private static final int MAX_CELLINFO_WAIT_MILLIS = 5000; // 5 seconds     private static final int SCAN_SEARCH_TIME_SECONDS = 60;     // Wait one second longer than the max scan search time to give the test time to receive the     // results.     private static final int MAX_INIT_WAIT_MS = (SCAN_SEARCH_TIME_SECONDS + 1) * 1000;     private Object mLock = new Object();     private Object mLock2 = new Object();     private boolean mReady;     private boolean mDone;     private int mErrorCode;     /* All the following constants are used to construct NetworkScanRequest*/     private static final int SCAN_TYPE = NetworkScanRequest.SCAN_TYPE_ONE_SHOT;     private static final boolean INCREMENTAL_RESULTS = true;     private static final int SEARCH_PERIODICITY_SEC = 5;     private static final int MAX_SEARCH_TIME_SEC = 300;     private static final int INCREMENTAL_RESULTS_PERIODICITY_SEC = 3;     private static final ArrayList<String> MCC_MNC = new ArrayList<>();     private static final RadioAccessSpecifier[] RADIO_ACCESS_SPECIFIERS = {             new RadioAccessSpecifier(                     AccessNetworkConstants.AccessNetworkType.GERAN,                     null /* bands */,                     null /* channels */),             new RadioAccessSpecifier(                     AccessNetworkConstants.AccessNetworkType.EUTRAN,                     null /* bands */,                     null /* channels */),             new RadioAccessSpecifier(                     AccessNetworkConstants.AccessNetworkType.UTRAN,                     null /* bands */,                     null /* channels */)     };      // Needed because NETWORK_SCAN_PERMISSION is a systemapi     public static final String NETWORK_SCAN_PERMISSION = ""android.permission.NETWORK_SCAN"";      @Before     public void setUp() throws Exception {         Context context = InstrumentationRegistry.getContext();         mTelephonyManager = (TelephonyManager)                 context.getSystemService(Context.TELEPHONY_SERVICE);         mPackageManager = context.getPackageManager();         InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(                 context.getPackageName(), ACCESS_FINE_LOCATION);         InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(                 context.getPackageName(), ACCESS_BACKGROUND_LOCATION);         mTestHandlerThread = new NetworkScanHandlerThread(TAG);         mTestHandlerThread.start();     }      @After     public void tearDown() throws Exception {         mTestHandlerThread.quit();     }      private void waitUntilReady() {         Log.d(TAG, ""waitUntilReady+"");         synchronized (mLock) {             try {                 mLock.wait(MAX_INIT_WAIT_MS);             } catch (InterruptedException ie) {             }              if (!mReady) {                 fail(""NetworkScanApiTest failed to initialize"");             }         }         Log.d(TAG, ""waitUntilReady-"");     }      private void waitUntilDone() {         Log.d(TAG, ""waitUntilDone+"");         synchronized (mLock2) {             try {                 mLock2.wait(MAX_INIT_WAIT_MS);             } catch (InterruptedException ie) {             }              if (!mDone) {                 fail(""NetworkScanApiTest failed to initialize"");             }         }         Log.d(TAG, ""waitUntilDone-"");     }      private void setReady(boolean ready) {         Log.d(TAG, ""setReady+"");         synchronized (mLock) {             mReady = ready;             mLock.notifyAll();         }         Log.d(TAG, ""setReady-"");     }      private void setDone(boolean done) {         Log.d(TAG, ""setDone+"");         synchronized (mLock2) {             mDone = done;             mLock2.notifyAll();         }         Log.d(TAG, ""setDone-"");     }      private class NetworkScanHandlerThread extends HandlerThread {          public NetworkScanHandlerThread(String name) {             super(name);         }          @Override         public void onLooperPrepared() {             /* create a custom handler for the Handler Thread */             mHandler = new Handler(mTestHandlerThread.getLooper()) {                 @Override                 public void handleMessage(Message msg) {                     switch (msg.what) {                         case EVENT_NETWORK_SCAN_START:                             Log.d(TAG, ""request network scan"");                             boolean useShellIdentity = (Boolean) msg.obj;                             if (useShellIdentity) {                                 InstrumentationRegistry.getInstrumentation().getUiAutomation()                                         .adoptShellPermissionIdentity();                             }                             try {                                 setDone(false);                                 mNetworkScan = mTelephonyManager.requestNetworkScan(                                         mNetworkScanRequest,                                         AsyncTask.SERIAL_EXECUTOR,                                         mNetworkScanCallback);                                 if (mNetworkScan == null) {                                     mNetworkScanStatus = EVENT_SCAN_DENIED;                                     setReady(true);                                 }                             } catch (SecurityException e) {                                 mNetworkScanStatus = EVENT_SCAN_DENIED;                                 setReady(true);                             } finally {                                 if (useShellIdentity) {                                     InstrumentationRegistry.getInstrumentation().getUiAutomation()                                             .dropShellPermissionIdentity();                                 }                                 setDone(true);                             }                             break;                         default:                             Log.d(TAG, ""Unknown Event "" + msg.what);                     }                 }             };         }     }      private class NetworkScanCallbackImpl extends TelephonyScanManager.NetworkScanCallback {         @Override         public void onResults(List<CellInfo> results) {             Log.d(TAG, ""onResults: "" + results.toString());             mNetworkScanStatus = EVENT_NETWORK_SCAN_RESULTS;             mScanResults = results;         }          @Override         public void onComplete() {             Log.d(TAG, ""onComplete"");             mNetworkScanStatus = EVENT_NETWORK_SCAN_COMPLETED;             setReady(true);         }          @Override         public void onError(int error) {             Log.d(TAG, ""onError: "" + String.valueOf(error));             mNetworkScanStatus = EVENT_NETWORK_SCAN_ERROR;             mErrorCode = error;             setReady(true);         }     }      private class CellInfoResultsCallback extends TelephonyManager.CellInfoCallback {         public List<CellInfo> cellInfo;          @Override         public synchronized void onCellInfo(List<CellInfo> cellInfo) {             this.cellInfo = cellInfo;             notifyAll();         }          public synchronized void wait(int millis) throws InterruptedException {             if (cellInfo == null) {                 super.wait(millis);             }         }     }      private List<RadioAccessSpecifier> getRadioAccessSpecifier(List<CellInfo> allCellInfo) {         List<RadioAccessSpecifier> radioAccessSpecifier = new ArrayList<>();         List<Integer> lteChannels = new ArrayList<>();         List<Integer> wcdmaChannels = new ArrayList<>();         List<Integer> gsmChannels = new ArrayList<>();         for (int i = 0; i < allCellInfo.size(); i++) {             CellInfo cellInfo = allCellInfo.get(i);             if (cellInfo instanceof CellInfoLte) {                 lteChannels.add(((CellInfoLte) cellInfo).getCellIdentity().getEarfcn());             } else if (cellInfo instanceof CellInfoWcdma) {                 wcdmaChannels.add(((CellInfoWcdma) cellInfo).getCellIdentity().getUarfcn());             } else if (cellInfo instanceof CellInfoGsm) {                 gsmChannels.add(((CellInfoGsm) cellInfo).getCellIdentity().getArfcn());             }         }         if (!lteChannels.isEmpty()) {             Log.d(TAG, ""lte channels"" + lteChannels.toString());             int ranLte = AccessNetworkConstants.AccessNetworkType.EUTRAN;             radioAccessSpecifier.add(                     new RadioAccessSpecifier(ranLte, null /* bands */,                             lteChannels.stream().mapToInt(i->i).toArray()));         }         if (!wcdmaChannels.isEmpty()) {             Log.d(TAG, ""wcdma channels"" + wcdmaChannels.toString());             int ranWcdma = AccessNetworkConstants.AccessNetworkType.UTRAN;             radioAccessSpecifier.add(                     new RadioAccessSpecifier(ranWcdma, null /* bands */,                             wcdmaChannels.stream().mapToInt(i->i).toArray()));         }         if (!gsmChannels.isEmpty()) {             Log.d(TAG, ""gsm channels"" + gsmChannels.toString());             int ranGsm = AccessNetworkConstants.AccessNetworkType.GERAN;             radioAccessSpecifier.add(                     new RadioAccessSpecifier(ranGsm, null /* bands */,                             gsmChannels.stream().mapToInt(i->i).toArray()));         }         return radioAccessSpecifier;     }      /**      * Tests that the device properly requests a network scan.      */"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.carrierapi.cts.NetworkScanApiTest"	"testRequestNetworkScanLocationOffFail"	"CtsCarrierApiTestCases"	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"Incremental"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/carrierapi/src/android/carrierapi/cts/NetworkScanApiTest.java"	""	"public void testRequestNetworkScanLocationOffFail() {         requestNetworkScanLocationOffHelper(true, true);     }      public void requestNetworkScanLocationOffHelper(boolean includeBandsAndChannels,             boolean useSpecialScanPermission) {         if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {             // Checks whether the cellular stack should be running on this device.             Log.e(TAG, ""No cellular support, the test will be skipped."");             return;         }         if (!mTelephonyManager.hasCarrierPrivileges()) {             fail(""This test requires a SIM card with carrier privilege rule on it."");         }          mNetworkScanRequest = buildNetworkScanRequest(includeBandsAndChannels);          boolean isLocationSwitchOn = getAndSetLocationSwitch(false);         try {             mNetworkScanCallback = new NetworkScanCallbackImpl();             Message startNetworkScan = mHandler.obtainMessage(EVENT_NETWORK_SCAN_START,                     useSpecialScanPermission);             setReady(false);             startNetworkScan.sendToTarget();             waitUntilReady();             if (includeBandsAndChannels) {                 // If we included the bands when location is off, expect a security error and                 // nothing else.                 assertEquals(EVENT_SCAN_DENIED, mNetworkScanStatus);                 return;             }              Log.d(TAG, ""mNetworkScanStatus: "" + mNetworkScanStatus);             assertTrue(""The final scan status is "" + mNetworkScanStatus + "" with error code ""                             + mErrorCode + "", not ScanCompleted""                             + "" or ScanError with an error code ERROR_MODEM_UNAVAILABLE or""                             + "" ERROR_UNSUPPORTED"",                     isScanStatusValid());         } finally {             waitUntilDone();             getAndSetLocationSwitch(isLocationSwitchOn);         }     }      private NetworkScanRequest buildNetworkScanRequest(boolean includeBandsAndChannels) {         // Make sure that there should be at least one entry.         List<CellInfo> allCellInfo = getCellInfo();         List<RadioAccessSpecifier> radioAccessSpecifier = new ArrayList<>();          if (allCellInfo != null && allCellInfo.size() != 0) {             // Construct a NetworkScanRequest             radioAccessSpecifier = getRadioAccessSpecifier(allCellInfo);             if (!includeBandsAndChannels) {                 radioAccessSpecifier = radioAccessSpecifier.stream().map(spec ->                     new RadioAccessSpecifier(spec.getRadioAccessNetwork(), null, null))                     .collect(Collectors.toList());             }         }          Log.d(TAG, ""number of radioAccessSpecifier: "" + radioAccessSpecifier.size());         if (radioAccessSpecifier.isEmpty()) {             // Put in some arbitrary bands and channels so that we trip the location check if needed             int[] fakeBands = includeBandsAndChannels                     ? new int[] { AccessNetworkConstants.EutranBand.BAND_5 }                     : null;             int[] fakeChannels = includeBandsAndChannels ? new int[] { 2400 } : null;              RadioAccessSpecifier gsm = new RadioAccessSpecifier(                     AccessNetworkConstants.AccessNetworkType.GERAN,                     null /* bands */,                     null /* channels */);             RadioAccessSpecifier lte = new RadioAccessSpecifier(                     AccessNetworkConstants.AccessNetworkType.EUTRAN,                     fakeBands /* bands */,                     fakeChannels /* channels */);             RadioAccessSpecifier wcdma = new RadioAccessSpecifier(                     AccessNetworkConstants.AccessNetworkType.UTRAN,                     null /* bands */,                     null /* channels */);             radioAccessSpecifier.add(gsm);             radioAccessSpecifier.add(lte);             radioAccessSpecifier.add(wcdma);         }         RadioAccessSpecifier[] radioAccessSpecifierArray =                 new RadioAccessSpecifier[radioAccessSpecifier.size()];         return new NetworkScanRequest(                 NetworkScanRequest.SCAN_TYPE_ONE_SHOT /* scan type */,                 radioAccessSpecifier.toArray(radioAccessSpecifierArray),                 5 /* search periodicity */,                 SCAN_SEARCH_TIME_SECONDS /* max search time */,                 true /*enable incremental results*/,                 5 /* incremental results periodicity */,                 null /* List of PLMN ids (MCC-MNC) */);      }      private List<CellInfo> getCellInfo() {         CellInfoResultsCallback resultsCallback = new CellInfoResultsCallback();         mTelephonyManager.requestCellInfoUpdate(r -> r.run(), resultsCallback);         try {             resultsCallback.wait(MAX_CELLINFO_WAIT_MILLIS);         } catch (InterruptedException ex) {             fail(""CellInfoCallback was interrupted: "" + ex);         }         return resultsCallback.cellInfo;     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.carrierapi.cts.NetworkScanApiTest"	"testNetworkScanRequest_ConstructorAndGetters"	"CtsCarrierApiTestCases"	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"Incremental"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/carrierapi/src/android/carrierapi/cts/NetworkScanApiTest.java"	""	"public void testNetworkScanRequest_ConstructorAndGetters() {         NetworkScanRequest networkScanRequest = new NetworkScanRequest(                 SCAN_TYPE,                 RADIO_ACCESS_SPECIFIERS,                 SEARCH_PERIODICITY_SEC,                 MAX_SEARCH_TIME_SEC,                 INCREMENTAL_RESULTS,                 INCREMENTAL_RESULTS_PERIODICITY_SEC,                 getPlmns());          assertEquals(""getScanType() returns wrong value"",                 SCAN_TYPE, networkScanRequest.getScanType());         assertEquals(""getSpecifiers() returns wrong value"",                 RADIO_ACCESS_SPECIFIERS, networkScanRequest.getSpecifiers());         assertEquals(""getSearchPeriodicity() returns wrong value"",                 SEARCH_PERIODICITY_SEC, networkScanRequest.getSearchPeriodicity());         assertEquals(""getMaxSearchTime() returns wrong value"",                 MAX_SEARCH_TIME_SEC, networkScanRequest.getMaxSearchTime());         assertEquals(""getIncrementalResults() returns wrong value"",                 INCREMENTAL_RESULTS, networkScanRequest.getIncrementalResults());         assertEquals(""getIncrementalResultsPeriodicity() returns wrong value"",                 INCREMENTAL_RESULTS_PERIODICITY_SEC,                 networkScanRequest.getIncrementalResultsPeriodicity());         assertEquals(""getPlmns() returns wrong value"", getPlmns(), networkScanRequest.getPlmns());         assertEquals(""describeContents() returns wrong value"",                 0, networkScanRequest.describeContents());     }      /**      * To test its hashCode method.      */"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.carrierapi.cts.NetworkScanApiTest"	"testNetworkScanRequestParcel_Hashcode"	"CtsCarrierApiTestCases"	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"Incremental"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/carrierapi/src/android/carrierapi/cts/NetworkScanApiTest.java"	""	"public void testNetworkScanRequestParcel_Hashcode() {         NetworkScanRequest networkScanRequest1 = new NetworkScanRequest(                 SCAN_TYPE,                 RADIO_ACCESS_SPECIFIERS,                 SEARCH_PERIODICITY_SEC,                 MAX_SEARCH_TIME_SEC,                 INCREMENTAL_RESULTS,                 INCREMENTAL_RESULTS_PERIODICITY_SEC,                 getPlmns());          NetworkScanRequest networkScanRequest2 = new NetworkScanRequest(                 SCAN_TYPE,                 RADIO_ACCESS_SPECIFIERS,                 SEARCH_PERIODICITY_SEC,                 MAX_SEARCH_TIME_SEC,                 INCREMENTAL_RESULTS,                 INCREMENTAL_RESULTS_PERIODICITY_SEC,                 getPlmns());          NetworkScanRequest networkScanRequest3 = new NetworkScanRequest(                 SCAN_TYPE,                 null,                 SEARCH_PERIODICITY_SEC,                 MAX_SEARCH_TIME_SEC,                 false,                 0,                 getPlmns());          assertEquals(""hashCode() returns different hash code for same objects"",                 networkScanRequest1.hashCode(), networkScanRequest2.hashCode());         assertNotSame(""hashCode() returns same hash code for different objects"",                 networkScanRequest1.hashCode(), networkScanRequest3.hashCode());     }      /**      * To test its comparision method.      */"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.carrierapi.cts.NetworkScanApiTest"	"testNetworkScanRequestParcel_Equals"	"CtsCarrierApiTestCases"	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"Incremental"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/carrierapi/src/android/carrierapi/cts/NetworkScanApiTest.java"	""	"public void testNetworkScanRequestParcel_Equals() {         NetworkScanRequest networkScanRequest1 = new NetworkScanRequest(                 SCAN_TYPE,                 RADIO_ACCESS_SPECIFIERS,                 SEARCH_PERIODICITY_SEC,                 MAX_SEARCH_TIME_SEC,                 INCREMENTAL_RESULTS,                 INCREMENTAL_RESULTS_PERIODICITY_SEC,                 getPlmns());          NetworkScanRequest networkScanRequest2 = new NetworkScanRequest(                 SCAN_TYPE,                 RADIO_ACCESS_SPECIFIERS,                 SEARCH_PERIODICITY_SEC,                 MAX_SEARCH_TIME_SEC,                 INCREMENTAL_RESULTS,                 INCREMENTAL_RESULTS_PERIODICITY_SEC,                 getPlmns());          assertTrue(networkScanRequest1.equals(networkScanRequest2));          networkScanRequest2 = new NetworkScanRequest(                 SCAN_TYPE,                 RADIO_ACCESS_SPECIFIERS,                 SEARCH_PERIODICITY_SEC,                 MAX_SEARCH_TIME_SEC,                 INCREMENTAL_RESULTS,                 INCREMENTAL_RESULTS_PERIODICITY_SEC,                 null /* List of PLMN ids (MCC-MNC) */);         assertFalse(networkScanRequest1.equals(networkScanRequest2));     }      /**      * To test its writeToParcel and createFromParcel methods.      */"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.carrierapi.cts.NetworkScanApiTest"	"testNetworkScanRequestParcel_Parcel"	"CtsCarrierApiTestCases"	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"Incremental"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/carrierapi/src/android/carrierapi/cts/NetworkScanApiTest.java"	""	"public void testNetworkScanRequestParcel_Parcel() {         NetworkScanRequest networkScanRequest = new NetworkScanRequest(                 SCAN_TYPE,                 null /* Radio Access Specifier */,                 SEARCH_PERIODICITY_SEC,                 MAX_SEARCH_TIME_SEC,                 INCREMENTAL_RESULTS,                 INCREMENTAL_RESULTS_PERIODICITY_SEC,                 getPlmns());          Parcel p = Parcel.obtain();         networkScanRequest.writeToParcel(p, 0);         p.setDataPosition(0);         NetworkScanRequest newnsr = NetworkScanRequest.CREATOR.createFromParcel(p);         assertTrue(networkScanRequest.equals(newnsr));     } }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.appsecurity.cts.ListeningPortsTest"	"testNoRemotelyAccessibleListeningUdp6Ports"	""	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"FileSystem"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/ListeningPortsTest.java"	""	"public void testNoRemotelyAccessibleListeningUdp6Ports() throws Exception {         assertNoRemotelyAccessibleListeningUdpPorts(""/proc/net/udp6"", false);     }     */      /**      * Locally accessible ports are often targeted by malicious locally      * installed programs to gain unauthorized access to program data or      * cause system corruption.      *      * In all cases, a local listening IP port can be replaced by a UNIX domain      * socket. Unix domain sockets can be protected with unix filesystem      * permission. Alternatively, you can use getsockopt(SO_PEERCRED) to      * determine if a program is authorized to connect to your socket.      *      * Please convert loopback IP connections to unix domain sockets.      */"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.appsecurity.cts.ListeningPortsTest"	"testNoListeningLoopbackTcpPorts"	""	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"FileSystem"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/ListeningPortsTest.java"	""	"public void testNoListeningLoopbackTcpPorts() throws Exception {         assertNoAccessibleListeningPorts(""/proc/net/tcp"", true, true);     }      /**      * Locally accessible ports are often targeted by malicious locally      * installed programs to gain unauthorized access to program data or      * cause system corruption.      *      * In all cases, a local listening IP port can be replaced by a UNIX domain      * socket. Unix domain sockets can be protected with unix filesystem      * permission. Alternatively, you can use getsockopt(SO_PEERCRED) to      * determine if a program is authorized to connect to your socket.      *      * Please convert loopback IP connections to unix domain sockets.      */"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.appsecurity.cts.ListeningPortsTest"	"testNoListeningLoopbackTcp6Ports"	""	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"FileSystem"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/ListeningPortsTest.java"	""	"public void testNoListeningLoopbackTcp6Ports() throws Exception {         assertNoAccessibleListeningPorts(""/proc/net/tcp6"", true, true);     }      /**      * Locally accessible ports are often targeted by malicious locally      * installed programs to gain unauthorized access to program data or      * cause system corruption.      *      * In all cases, a local listening IP port can be replaced by a UNIX domain      * socket. Unix domain sockets can be protected with unix filesystem      * permission.  Alternately, or you can use setsockopt(SO_PASSCRED) to      * send credentials, and recvmsg to retrieve the passed credentials.      *      * Please convert loopback IP connections to unix domain sockets.      */"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.appsecurity.cts.ListeningPortsTest"	"testNoListeningLoopbackUdpPorts"	""	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"FileSystem"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/ListeningPortsTest.java"	""	"public void testNoListeningLoopbackUdpPorts() throws Exception {         assertNoAccessibleListeningPorts(""/proc/net/udp"", false, true);     }      /**      * Locally accessible ports are often targeted by malicious locally      * installed programs to gain unauthorized access to program data or      * cause system corruption.      *      * In all cases, a local listening IP port can be replaced by a UNIX domain      * socket. Unix domain sockets can be protected with unix filesystem      * permission.  Alternately, or you can use setsockopt(SO_PASSCRED) to      * send credentials, and recvmsg to retrieve the passed credentials.      *      * Please convert loopback IP connections to unix domain sockets.      */"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.view.cts.TooltipTest"	"getWindowSystemUiVisibility"	"CtsViewTestCases"	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"FileSystem"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/view/src/android/view/cts/TooltipTest.java"	""	"/*  *.  */  package android.view.cts;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertTrue;  import android.app.Activity; import android.app.Instrumentation; import android.os.SystemClock; import android.util.Log; import android.view.Gravity; import android.view.InputDevice; import android.view.KeyEvent; import android.view.MotionEvent; import android.view.View; import android.view.ViewConfiguration; import android.view.ViewGroup; import android.widget.PopupWindow; import android.widget.TextView;  import androidx.test.InstrumentationRegistry; import androidx.test.filters.LargeTest; import androidx.test.rule.ActivityTestRule; import androidx.test.runner.AndroidJUnit4;  import com.android.compatibility.common.util.CtsTouchUtils; import com.android.compatibility.common.util.PollingCheck;  import org.junit.Before; import org.junit.Rule; import org.junit.Test; import org.junit.runner.RunWith;  /**  * Test {@link View}.  */ @LargeTest @RunWith(AndroidJUnit4.class) public class TooltipTest {     private static final String LOG_TAG = ""TooltipTest"";      private static final long TIMEOUT_DELTA = 10000;     private static final long WAIT_MARGIN = 100;      private Instrumentation mInstrumentation;     private Activity mActivity;     private ViewGroup mTopmostView;     private ViewGroup mGroupView;     private View mNoTooltipView;     private View mTooltipView;     private View mNoTooltipView2;     private View mEmptyGroup;      @Rule     public ActivityTestRule<TooltipActivity> mActivityRule =             new ActivityTestRule<>(TooltipActivity.class);      @Rule     public ActivityTestRule<CtsActivity> mCtsActivityRule =             new ActivityTestRule<>(CtsActivity.class, false, false);      @Before     public void setup() {         mInstrumentation = InstrumentationRegistry.getInstrumentation();         mActivity = mActivityRule.getActivity();         mTopmostView = (ViewGroup) mActivity.findViewById(R.id.tooltip_layout);         mGroupView = (ViewGroup) mActivity.findViewById(R.id.tooltip_group);         mNoTooltipView = mActivity.findViewById(R.id.no_tooltip);         mTooltipView = mActivity.findViewById(R.id.has_tooltip);         mNoTooltipView2 = mActivity.findViewById(R.id.no_tooltip2);         mEmptyGroup = mActivity.findViewById(R.id.empty_group);          PollingCheck.waitFor(TIMEOUT_DELTA, mActivity::hasWindowFocus);     }      private void waitOut(long msDelay) {         try {             Thread.sleep(msDelay + WAIT_MARGIN);         } catch (InterruptedException e) {             Log.e(LOG_TAG, ""Wait interrupted. Test may fail!"", e);         }     }      private void setTooltipText(View view, CharSequence tooltipText) throws Throwable {         mActivityRule.runOnUiThread(() -> view.setTooltipText(tooltipText));     }      private boolean hasTooltip(View view) {         final View tooltipView = view.getTooltipView();         return tooltipView != null && tooltipView.getParent() != null;     }       private void addView(ViewGroup parent, View view) throws Throwable {         mActivityRule.runOnUiThread(() -> parent.addView(view));         mInstrumentation.waitForIdleSync();     }      private void removeView(View view) throws Throwable {         mActivityRule.runOnUiThread(() -> ((ViewGroup) (view.getParent())).removeView(view));         mInstrumentation.waitForIdleSync();     }      private void setVisibility(View view, int visibility) throws Throwable {         mActivityRule.runOnUiThread(() -> view.setVisibility(visibility));     }      private void setClickable(View view) throws Throwable {         mActivityRule.runOnUiThread(() -> view.setClickable(true));     }      private void setLongClickable(View view) throws Throwable {         mActivityRule.runOnUiThread(() -> view.setLongClickable(true));     }      private void setContextClickable(View view) throws Throwable {         mActivityRule.runOnUiThread(() -> view.setContextClickable(true));     }      private void callPerformLongClick(View view) throws Throwable {         mActivityRule.runOnUiThread(() -> view.performLongClick(0, 0));     }      private void requestLowProfileSystemUi() throws Throwable {         final int flag = View.SYSTEM_UI_FLAG_LOW_PROFILE;         mActivityRule.runOnUiThread(() -> mTooltipView.setSystemUiVisibility(flag));         PollingCheck.waitFor(TIMEOUT_DELTA,                 () -> (mTooltipView.getWindowSystemUiVisibility() & flag) == flag);     }      private void injectKeyPress(View target, int keyCode, int duration) throws Throwable {         if (target != null) {             mActivityRule.runOnUiThread(() -> {                 target.setFocusableInTouchMode(true);                 target.requestFocus();             });             mInstrumentation.waitForIdleSync();             assertTrue(target.isFocused());         }         mInstrumentation.sendKeySync(new KeyEvent(KeyEvent.ACTION_DOWN, keyCode));         waitOut(duration);         mInstrumentation.sendKeySync(new KeyEvent(KeyEvent.ACTION_UP, keyCode));     }      private void injectArbitraryShortKeyPress() throws Throwable {         injectKeyPress(null, KeyEvent.KEYCODE_0, 0);     }      private void injectLongKeyPress(View target, int keyCode) throws Throwable {         injectKeyPress(target, keyCode, ViewConfiguration.getLongPressTimeout());     }      private void injectLongEnter(View target) throws Throwable {         injectLongKeyPress(target, KeyEvent.KEYCODE_ENTER);     }      private void injectShortClick(View target) {         CtsTouchUtils.emulateTapOnViewCenter(mInstrumentation, mActivityRule, target);     }      private void injectLongClick(View target) {         CtsTouchUtils.emulateLongPressOnView(mInstrumentation, mActivityRule, target,                 target.getWidth() / 2, target.getHeight() / 2);     }      private void injectMotionEvent(MotionEvent event) {         mInstrumentation.sendPointerSync(event);     }      private void injectHoverMove(int source, View target, int offsetX, int offsetY) {         injectMotionEvent(obtainMotionEvent(                     source, target, MotionEvent.ACTION_HOVER_MOVE, offsetX,  offsetY));     }      private void injectHoverMove(View target, int offsetX, int offsetY) {         injectHoverMove(InputDevice.SOURCE_MOUSE, target, offsetX,  offsetY);     }      private void injectHoverMove(View target) {         injectHoverMove(target, 0, 0);     }      private void injectLongHoverMove(View target) {         injectHoverMove(target);         waitOut(ViewConfiguration.getHoverTooltipShowTimeout());     }      private static MotionEvent obtainMouseEvent(View target, int action, int offsetX, int offsetY) {         return obtainMotionEvent(InputDevice.SOURCE_MOUSE, target, action, offsetX, offsetY);     }      private static MotionEvent obtainMotionEvent(                 int source, View target, int action, int offsetX, int offsetY) {         final long eventTime = SystemClock.uptimeMillis();         final int[] xy = new int[2];         target.getLocationOnScreen(xy);         MotionEvent event = MotionEvent.obtain(eventTime, eventTime, action,                 xy[0] + target.getWidth() / 2 + offsetX, xy[1] + target.getHeight() / 2 + offsetY,                 0);         event.setSource(source);         return event;     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.view.cts.TooltipTest"	"testMouseHoverTooltipHidesOnShortTimeout"	"CtsViewTestCases"	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"FileSystem"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/view/src/android/view/cts/TooltipTest.java"	""	"public void testMouseHoverTooltipHidesOnShortTimeout() throws Throwable {         requestLowProfileSystemUi();          injectLongHoverMove(mTooltipView);         assertTrue(hasTooltip(mTooltipView));          waitOut(ViewConfiguration.getHoverTooltipHideShortTimeout());         assertFalse(hasTooltip(mTooltipView));     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.incrementalinstall.cts.IncrementalInstallTest"	"testBaseApkInvalidSignatureAdbInstall"	""	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"Incremental"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/incrementalinstall/src/android/incrementalinstall/cts/IncrementalInstallTest.java"	""	"public void testBaseApkInvalidSignatureAdbInstall() throws Exception {         String newApkName = String.format(""base%d.apk"", new Random().nextInt());         String sigSuffix = "".idsig"";         File destApk = copyTestFile(TEST_APP_BASE_APK_NAME, null, newApkName);         copyTestFile(TEST_APP_BASE_APK_NAME + sigSuffix, destApk.getParentFile(),                 newApkName + sigSuffix);         try (RandomAccessFile raf = new RandomAccessFile(                 getFilePathFromBuildInfo(newApkName + sigSuffix), ""rw"")) {             // Contaminate signature by complementing a random byte.             int byteToContaminate = new Random().nextInt((int) raf.length());             LogUtil.CLog.logAndDisplay(Log.LogLevel.INFO,                     ""CtsIncrementalInstallHostTestCases#testBaseApkInvalidSignatureAdbInstall: ""                             + ""Contaminating byte: %d of signature: %s"",                     byteToContaminate, TEST_APP_BASE_APK_NAME + sigSuffix);             raf.seek(byteToContaminate);             raf.writeByte((byte) (~raf.readByte()));         }         verifyInstallCommandFailure(installWithAdbInstaller(newApkName));         verifyPackageNotInstalled(TEST_APP_PACKAGE_NAME);     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.incrementalinstall.cts.IncrementalInstallTest"	"testCompressedNativeLibMultiSplitAdbInstall"	""	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"Incremental"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/incrementalinstall/src/android/incrementalinstall/cts/IncrementalInstallTest.java"	""	"public void testCompressedNativeLibMultiSplitAdbInstall() throws Exception {         assertTrue(checkNativeLibInApkCompression(TEST_APP_COMPRESSED_NATIVE_NAME,                 ""libcompressednativeincrementaltest.so"", true));         verifyInstallCommandSuccess(                 installWithAdbInstaller(TEST_APP_BASE_APK_NAME, TEST_APP_COMPRESSED_NATIVE_NAME));         verifyPackageInstalled(TEST_APP_PACKAGE_NAME);         verifyInstallationTypeAndVersion(TEST_APP_PACKAGE_NAME, /* isIncfs= */ true,                 TEST_APP_V1_VERSION);         validateAppLaunch(TEST_APP_PACKAGE_NAME, ON_CREATE_COMPONENT, COMPRESSED_NATIVE_COMPONENT);     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.incrementalinstall.cts.IncrementalInstallTest"	"testUncompressedNativeLibMultiSplitAdbInstall"	""	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"Incremental"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/incrementalinstall/src/android/incrementalinstall/cts/IncrementalInstallTest.java"	""	"public void testUncompressedNativeLibMultiSplitAdbInstall() throws Exception {         assertTrue(checkNativeLibInApkCompression(TEST_APP_COMPRESSED_NATIVE_NAME,                 ""libuncompressednativeincrementaltest.so"", false));         verifyInstallCommandSuccess(                 installWithAdbInstaller(TEST_APP_BASE_APK_NAME, TEST_APP_UNCOMPRESSED_NATIVE_NAME));         verifyPackageInstalled(TEST_APP_PACKAGE_NAME);         verifyInstallationTypeAndVersion(TEST_APP_PACKAGE_NAME, /* isIncfs= */ true,                 TEST_APP_V1_VERSION);         validateAppLaunch(TEST_APP_PACKAGE_NAME, ON_CREATE_COMPONENT,                 UNCOMPRESSED_NATIVE_COMPONENT);     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.incrementalinstall.cts.IncrementalInstallTest"	"testVersionUpdateAdbInstall"	""	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"Incremental"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/incrementalinstall/src/android/incrementalinstall/cts/IncrementalInstallTest.java"	""	"public void testVersionUpdateAdbInstall() throws Exception {         verifyInstallCommandSuccess(installWithAdbInstaller(TEST_APP_BASE_APK_NAME));         verifyPackageInstalled(TEST_APP_PACKAGE_NAME);         verifyInstallationTypeAndVersion(TEST_APP_PACKAGE_NAME, /* isIncfs= */ true,                 TEST_APP_V1_VERSION);         validateAppLaunch(TEST_APP_PACKAGE_NAME, ON_CREATE_COMPONENT);         // Install second implementation of app with the same version code.         verifyInstallCommandSuccess(installWithAdbInstaller(TEST_APP_BASE_APK_2_V2_NAME));         verifyInstallationTypeAndVersion(TEST_APP_PACKAGE_NAME, /* isIncfs= */ true,                 TEST_APP_V2_VERSION);         validateAppLaunch(TEST_APP_PACKAGE_NAME, ON_CREATE_COMPONENT_2);     }      private void verifyInstallationTypeAndVersion(String packageName, boolean isIncfs,             int versionCode) throws Exception {         Map<String, String> args = new HashMap<>();         args.put(Consts.PACKAGE_TO_LAUNCH_TAG, packageName);         args.put(Consts.IS_INCFS_INSTALLATION_TAG, Boolean.toString(isIncfs));         args.put(Consts.INSTALLED_VERSION_CODE_TAG, Integer.toString(versionCode));         boolean result = runDeviceTests(                 getDevice(), TEST_RUNNER, VALIDATION_HELPER_PKG, VALIDATION_HELPER_CLASS,                 INSTALLATION_TYPE_HELPER_METHOD,                 null, DEFAULT_TEST_TIMEOUT_MS, DEFAULT_MAX_TIMEOUT_TO_OUTPUT_MS,                 0L, true, false, args);         assertTrue(String.format(                 ""Failed: %s#%s failed while verifying installation type for package: %s"",                 VALIDATION_HELPER_CLASS, INSTALLATION_TYPE_HELPER_METHOD, packageName), result);     }      private void validateAppLaunch(String packageName, String... componentsToCheck)             throws Exception {         Map<String, String> args = new HashMap<>();         args.put(Consts.PACKAGE_TO_LAUNCH_TAG, packageName);         args.put(Consts.LOADED_COMPONENTS_TAG, String.join("","", componentsToCheck));         List<String> notLoadedComponents = Lists.newArrayList(                 Consts.SupportedComponents.getAllComponents());         notLoadedComponents.removeAll(Lists.newArrayList(componentsToCheck));         args.put(Consts.NOT_LOADED_COMPONENTS_TAG, String.join("","", notLoadedComponents));          boolean result = runDeviceTests(                 getDevice(), TEST_RUNNER, VALIDATION_HELPER_PKG, VALIDATION_HELPER_CLASS,                 VALIDATION_HELPER_METHOD,                 null, DEFAULT_TEST_TIMEOUT_MS, DEFAULT_MAX_TIMEOUT_TO_OUTPUT_MS,                 0L, true, false, args);         assertTrue(String.format(""Failed: %s#%s failed while validating package: %s"",                 VALIDATION_HELPER_CLASS, VALIDATION_HELPER_METHOD, packageName), result);     }      private void verifyPackageInstalled(String packageName) throws Exception {         assertTrue(String.format(""Failed: %s is not installed."", packageName),                 isPackageInstalled(packageName));     }      private void verifyPackageNotInstalled(String packageName) throws Exception {         assertFalse(                 String.format(""Failed: %s is installed, when it shouldn't have been."", packageName),                 isPackageInstalled(packageName));     }      private String installWithAdbInstaller(String... filenames)             throws Exception {         return installWithAdbInstaller(/* shouldUpdate= */ false, filenames);     }      /**      * @return stderr+stdout of the adb installation.      */     private String installWithAdbInstaller(boolean shouldUpdate, String... filenames)             throws Exception {         assertTrue(filenames.length > 0);         String installMultipleArg =                 filenames.length > 1 ? ""install-multiple"" : """";         String updateArg =                 shouldUpdate ? ""-r"" : """";         List<String> adbCmd = new ArrayList<>();         adbCmd.add(""adb"");         adbCmd.add(""-s"");         adbCmd.add(getDevice().getSerialNumber());         adbCmd.add(""install"");         adbCmd.add(updateArg);         adbCmd.add(INCREMENTAL_ARG);         adbCmd.add(installMultipleArg);         adbCmd.addAll(getFilePathsFromBuildInfo(filenames));          // Using runUtil instead of executeAdbCommand() because the latter doesn't provide the         // option to get stderr or redirect stderr to stdout.         File outFile = FileUtil.createTempFile(""stdoutredirect"", "".txt"");         OutputStream stdout = new FileOutputStream(outFile);         RunUtil runUtil = new RunUtil();         runUtil.setRedirectStderrToStdout(true);         runUtil.runTimedCmd(DEFAULT_TEST_TIMEOUT_MS, stdout, /* stderr= */ null,                 adbCmd.toArray(new String[adbCmd.size()]));         return FileUtil.readStringFromFile(outFile);     }      private List<String> getFilePathsFromBuildInfo(String... filenames) throws IOException {         List<String> filePaths = new ArrayList<>();         for (String filename : filenames) {             filePaths.add(getFilePathFromBuildInfo(filename));         }         return filePaths;     }      private String getFilePathFromBuildInfo(String filename) throws IOException {         return mBuildHelper.getTestFile(filename).getAbsolutePath();     }      private File copyTestFile(String sourceFilename, File destPath, String destFilename) throws IOException {         File source = new File(getFilePathFromBuildInfo(sourceFilename));         File dest = new File(destPath != null ? destPath : source.getParentFile(), destFilename);         FileUtil.copyFile(source, dest);         return dest;     }      private void uninstallApp(String packageName) throws Exception {         getDevice().uninstallPackage(packageName);     }      private boolean checkNativeLibInApkCompression(String apkName, String nativeLibName,             boolean compression)             throws Exception {         boolean conformsToCompressionStatus = true;         File apk = new File(getFilePathFromBuildInfo(apkName));         EndCentralDirectoryInfo endCentralDirectoryInfo = new EndCentralDirectoryInfo(apk);         List<CentralDirectoryInfo> centralDirectoryInfos = ZipUtil.getZipCentralDirectoryInfos(apk,                 endCentralDirectoryInfo, endCentralDirectoryInfo.getCentralDirOffset());         for (CentralDirectoryInfo directoryInfo : centralDirectoryInfos) {             if (directoryInfo.getFileName().endsWith(nativeLibName)) {                 // No early exit. Multilib build will have the same .so file for different                 // architectures, check all of them.                 conformsToCompressionStatus &= compression ==                         (directoryInfo.getCompressionMethod() != 0); // 0 is compression NONE             }         }         return conformsToCompressionStatus;     }      private void verifyInstallCommandSuccess(String adbOutput) {         logInstallCommandOutput(adbOutput);         assertTrue(adbOutput.contains(INSTALL_SUCCESS_OUTPUT));     }      private void verifyInstallCommandFailure(String adbOutput) {         logInstallCommandOutput(adbOutput);         assertFalse(adbOutput.contains(INSTALL_SUCCESS_OUTPUT));     }      private void logInstallCommandOutput(String adbOutput) {         // Get calling method for logging         StackTraceElement[] stacktrace = Thread.currentThread().getStackTrace();         StackTraceElement e = stacktrace[3]; //test method         String methodName = e.getMethodName();         LogUtil.CLog.logAndDisplay(Log.LogLevel.INFO,                 String.format(""CtsIncrementalInstallHostTestCases#%s: adb install output: %s"",                         methodName, adbOutput));     }      private boolean hasIncrementalFeature() throws Exception {         return hasDeviceFeature(FEATURE_INCREMENTAL_DELIVERY);     }      private boolean adbBinarySupportsIncremental() throws Exception {         return !installWithAdbInstaller(TEST_APP_BASE_APK_NAME).contains(                 ""Unknown option --incremental"");     } }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.content.pm.cts.PackageManagerShellCommandIncrementalTest"	"testInstallWithIdSigAndSplit"	"CtsContentTestCases"	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"Incremental"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/content/src/android/content/pm/cts/PackageManagerShellCommandIncrementalTest.java"	""	"public void testInstallWithIdSigAndSplit() throws Exception {         File apkfile = new File(createApkPath(TEST_APK));         File splitfile = new File(createApkPath(TEST_APK_SPLIT));         File[] files = new File[]{apkfile, splitfile};         String param = Arrays.stream(files).map(                 file -> file.getName() + "":"" + file.length()).collect(Collectors.joining("" ""));         assertEquals(""Success\n"", executeShellCommand(                 String.format(""pm install-incremental -t -g -S %s %s"",                         (apkfile.length() + splitfile.length()), param),                 files));         assertTrue(isAppInstalled(TEST_APP_PACKAGE));         assertEquals(""base, config.hdpi"", getSplits(TEST_APP_PACKAGE));     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.content.pm.cts.PackageManagerShellCommandIncrementalTest"	"testInstallWithIdSigInvalidLength"	"CtsContentTestCases"	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"Incremental"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/content/src/android/content/pm/cts/PackageManagerShellCommandIncrementalTest.java"	""	"public void testInstallWithIdSigInvalidLength() throws Exception {         File file = new File(createApkPath(TEST_APK));         assertTrue(                 executeShellCommand(""pm install-incremental -t -g -S "" + (file.length() - 1),                         new File[]{file}).contains(                         ""Failure""));         assertFalse(isAppInstalled(TEST_APP_PACKAGE));     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.content.pm.cts.PackageManagerShellCommandIncrementalTest"	"testInstallWithIdSigStreamIncompleteData"	"CtsContentTestCases"	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"Incremental"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/content/src/android/content/pm/cts/PackageManagerShellCommandIncrementalTest.java"	""	"public void testInstallWithIdSigStreamIncompleteData() throws Exception {         File file = new File(createApkPath(TEST_APK));         long length = file.length();         // Streaming happens in blocks of 1024 bytes, new length will not stream the last block.         long newLength = length - (length % 1024 == 0 ? 1024 : length % 1024);         assertTrue(                 executeShellCommand(""pm install-incremental -t -g -S "" + length,                         new File[]{file}, new long[]{newLength}).contains(                         ""Failure""));         assertFalse(isAppInstalled(TEST_APP_PACKAGE));     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.content.pm.cts.PackageManagerShellCommandIncrementalTest"	"testInstallWithIdSigStreamIncompleteDataForSplit"	"CtsContentTestCases"	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"Incremental"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/content/src/android/content/pm/cts/PackageManagerShellCommandIncrementalTest.java"	""	"public void testInstallWithIdSigStreamIncompleteDataForSplit() throws Exception {         File apkfile = new File(createApkPath(TEST_APK));         File splitfile = new File(createApkPath(TEST_APK_SPLIT));         long splitLength = splitfile.length();         // Don't fully stream the split.         long newSplitLength = splitLength - (splitLength % 1024 == 0 ? 1024 : splitLength % 1024);         File[] files = new File[]{apkfile, splitfile};         String param = Arrays.stream(files).map(                 file -> file.getName() + "":"" + file.length()).collect(Collectors.joining("" ""));         assertTrue(executeShellCommand(                 String.format(""pm install-incremental -t -g -S %s %s"",                         (apkfile.length() + splitfile.length()), param),                 files, new long[]{apkfile.length(), newSplitLength}).contains(                 ""Failure""));         assertFalse(isAppInstalled(TEST_APP_PACKAGE));     }      static class TestDataLoaderService extends DataLoaderService {     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"android.content.pm.cts.PackageManagerShellCommandIncrementalTest"	"testInstallSysTrace"	"CtsContentTestCases"	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"Incremental"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/content/src/android/content/pm/cts/PackageManagerShellCommandIncrementalTest.java"	""	"public void testInstallSysTrace() throws Exception {         // Async atrace dump uses less resources but requires periodic pulls.         // Overall timeout of 30secs in 100ms intervals should be enough.         final int atraceDumpIterations = 300;         final int atraceDumpDelayMs = 100;          final String expected = ""|page_read:"";         final ByteArrayOutputStream result = new ByteArrayOutputStream();         final Thread readFromProcess = new Thread(() -> {             try {                 executeShellCommand(""atrace --async_start -b 1024 -c adb"");                 try {                     for (int i = 0; i < atraceDumpIterations; ++i) {                         final ParcelFileDescriptor stdout = getUiAutomation().executeShellCommand(                                 ""atrace --async_dump"");                         try (InputStream inputStream =                                      new ParcelFileDescriptor.AutoCloseInputStream(                                 stdout)) {                             final String found = waitForSubstring(inputStream, expected);                             if (!TextUtils.isEmpty(found)) {                                 result.write(found.getBytes());                                 return;                             }                             Thread.currentThread().sleep(atraceDumpDelayMs);                         } catch (InterruptedException ignored) {                         }                     }                 } finally {                     executeShellCommand(""atrace --async_stop"");                 }             } catch (IOException ignored) {             }         });         readFromProcess.start();          for (int i = 0; i < 3; ++i) {             installPackage(TEST_APK);             assertTrue(isAppInstalled(TEST_APP_PACKAGE));             uninstallPackageSilently(TEST_APP_PACKAGE);         }          readFromProcess.join();         assertNotEquals(0, result.size());     }      private boolean isAppInstalled(String packageName) throws IOException {         final String commandResult = executeShellCommand(""pm list packages"");         final int prefixLength = ""package:"".length();         return Arrays.stream(commandResult.split(""\\r?\\n""))                 .anyMatch(line -> line.substring(prefixLength).equals(packageName));     }      private String getSplits(String packageName) throws IOException {         final String commandResult = executeShellCommand(""pm dump "" + packageName);         final String prefix = ""    splits=["";         final int prefixLength = prefix.length();         Optional<String> maybeSplits = Arrays.stream(commandResult.split(""\\r?\\n""))                 .filter(line -> line.startsWith(prefix)).findFirst();         if (!maybeSplits.isPresent()) {             return null;         }         String splits = maybeSplits.get();         return splits.substring(prefixLength, splits.length() - 1);     }      private static String createApkPath(String baseName) {         return TEST_APK_PATH + baseName;     }      private void installPackage(String baseName) throws IOException {         File file = new File(createApkPath(baseName));         assertEquals(""Success\n"",                 executeShellCommand(""pm install-incremental -t -g "" + file.getPath()));     }      private String uninstallPackageSilently(String packageName) throws IOException {         return executeShellCommand(""pm uninstall "" + packageName);     } }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-8"	""	"com.android.cts.writeexternalstorageapp.WriteExternalStorageTest"	"testWriteExternalStorageDirs"	""	""	"4/C-0-8"	"""C-0-8] MUST implement support for Incremental File System as documented here.  && C-0-8] MUST implement support for Incremental File System as documented here.  | C-0-8] and"""	""	"Incremental FileSystem"	""	""	""	"FileSystem"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/test-apps/WriteExternalStorageApp/src/com/android/cts/writeexternalstorageapp/WriteExternalStorageTest.java"	""	"public void testWriteExternalStorageDirs() throws Exception {         final File probe = new File(                 Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DCIM),                 ""100CTS"");          assertFalse(probe.exists());         assertTrue(probe.mkdirs());          try {             assertDirReadWriteAccess(probe);         }         finally {             probe.delete();             assertFalse(probe.exists());         }     }      /**      * Verify that legacy filesystem paths continue working, and that they all      * point to same location.      */"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.widget.cts.TextViewTest"	"testSelectAllJustAfterTap"	"CtsWidgetTestCases"	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	"public void testSelectAllJustAfterTap() throws Throwable {         // Prepare an EditText with focus.         mActivityRule.runOnUiThread(() -> {             // Make a dummy focusable so that initial focus doesn't go to our test textview             LinearLayout top = new LinearLayout(mActivity);             TextView dummy = new TextView(mActivity);             dummy.setFocusableInTouchMode(true);             top.addView(dummy, LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);             mTextView = new EditText(mActivity);             top.addView(mTextView, LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);             mActivity.setContentView(top);              assertFalse(mTextView.didTouchFocusSelect());             mTextView.setFocusable(true);             mTextView.requestFocus();             assertTrue(mTextView.didTouchFocusSelect());              mTextView.setText(""Hello, World."", BufferType.SPANNABLE);         });         mInstrumentation.waitForIdleSync();          // Tap the view to show InsertPointController.         CtsTouchUtils.emulateTapOnViewCenter(mInstrumentation, mActivityRule, mTextView);         // bad workaround for waiting onStartInputView of LeanbackIme.apk done         try {             Thread.sleep(1000);         } catch (InterruptedException e) {             e.printStackTrace();         }          // Execute SelectAll context menu.         mActivityRule.runOnUiThread(() -> mTextView.onTextContextMenuItem(android.R.id.selectAll));         mInstrumentation.waitForIdleSync();          // The selection must be whole of the text contents.         assertEquals(0, mTextView.getSelectionStart());         assertEquals(""Hello, World."", mTextView.getText().toString());         assertEquals(mTextView.length(), mTextView.getSelectionEnd());     }      @UiThreadTest"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.net.cts.IpSecBaseTest"	"currentTimeMillis"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	"v4"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/IpSecBaseTest.java"	""	"/*  *.  */  package android.net.cts;  import static org.junit.Assert.assertArrayEquals;  import android.content.Context; import android.net.ConnectivityManager; import android.net.IpSecAlgorithm; import android.net.IpSecManager; import android.net.IpSecTransform; import android.platform.test.annotations.AppModeFull; import android.system.Os; import android.system.OsConstants; import android.util.Log;  import androidx.test.InstrumentationRegistry; import androidx.test.runner.AndroidJUnit4;  import java.io.FileDescriptor; import java.io.IOException; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.Inet6Address; import java.net.InetAddress; import java.net.InetSocketAddress; import java.net.ServerSocket; import java.net.Socket; import java.net.SocketException; import java.util.Arrays; import java.util.concurrent.atomic.AtomicInteger;  import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith;  @RunWith(AndroidJUnit4.class) public class IpSecBaseTest {      private static final String TAG = IpSecBaseTest.class.getSimpleName();      protected static final String IPV4_LOOPBACK = ""127.0.0.1"";     protected static final String IPV6_LOOPBACK = ""::1"";     protected static final String[] LOOPBACK_ADDRS = new String[] {IPV4_LOOPBACK, IPV6_LOOPBACK};     protected static final int[] DIRECTIONS =             new int[] {IpSecManager.DIRECTION_IN, IpSecManager.DIRECTION_OUT};      protected static final byte[] TEST_DATA = ""Best test data ever!"".getBytes();     protected static final int DATA_BUFFER_LEN = 4096;     protected static final int SOCK_TIMEOUT = 500;      private static final byte[] KEY_DATA = {         0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,         0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,         0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,         0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,         0x20, 0x21, 0x22, 0x23     };      protected static final byte[] AUTH_KEY = getKey(256);     protected static final byte[] CRYPT_KEY = getKey(256);      protected ConnectivityManager mCM;     protected IpSecManager mISM;      @Before     public void setUp() throws Exception {         mISM =                 (IpSecManager)                         InstrumentationRegistry.getContext()                                 .getSystemService(Context.IPSEC_SERVICE);         mCM =                 (ConnectivityManager)                         InstrumentationRegistry.getContext()                                 .getSystemService(Context.CONNECTIVITY_SERVICE);     }      protected static byte[] getKey(int bitLength) {         return Arrays.copyOf(KEY_DATA, bitLength / 8);     }      protected static int getDomain(InetAddress address) {         int domain;         if (address instanceof Inet6Address) {             domain = OsConstants.AF_INET6;         } else {             domain = OsConstants.AF_INET;         }         return domain;     }      protected static int getPort(FileDescriptor sock) throws Exception {         return ((InetSocketAddress) Os.getsockname(sock)).getPort();     }      public static interface GenericSocket extends AutoCloseable {         void send(byte[] data) throws Exception;          byte[] receive() throws Exception;          int getPort() throws Exception;          void close() throws Exception;          void applyTransportModeTransform(                 IpSecManager ism, int direction, IpSecTransform transform) throws Exception;          void removeTransportModeTransforms(IpSecManager ism) throws Exception;     }      public static interface GenericTcpSocket extends GenericSocket {}      public static interface GenericUdpSocket extends GenericSocket {         void sendTo(byte[] data, InetAddress dstAddr, int port) throws Exception;     }      public abstract static class NativeSocket implements GenericSocket {         public FileDescriptor mFd;          public NativeSocket(FileDescriptor fd) {             mFd = fd;         }          @Override         public void send(byte[] data) throws Exception {             Os.write(mFd, data, 0, data.length);         }          @Override         public byte[] receive() throws Exception {             byte[] in = new byte[DATA_BUFFER_LEN];             AtomicInteger bytesRead = new AtomicInteger(-1);              Thread readSockThread = new Thread(() -> {                 long startTime = System.currentTimeMillis();                 while (bytesRead.get() < 0 && System.currentTimeMillis() < startTime + SOCK_TIMEOUT) {                     try {                         bytesRead.set(Os.recvfrom(mFd, in, 0, DATA_BUFFER_LEN, 0, null));                     } catch (Exception e) {                         Log.e(TAG, ""Error encountered reading from socket"", e);                     }                 }             });              readSockThread.start();             readSockThread.join(SOCK_TIMEOUT);              if (bytesRead.get() < 0) {                 throw new IOException(""No data received from socket"");             }              return Arrays.copyOfRange(in, 0, bytesRead.get());         }          @Override         public int getPort() throws Exception {             return IpSecBaseTest.getPort(mFd);         }          @Override         public void close() throws Exception {             Os.close(mFd);         }          @Override         public void applyTransportModeTransform(                 IpSecManager ism, int direction, IpSecTransform transform) throws Exception {             ism.applyTransportModeTransform(mFd, direction, transform);         }          @Override         public void removeTransportModeTransforms(IpSecManager ism) throws Exception {             ism.removeTransportModeTransforms(mFd);         }     }      public static class NativeTcpSocket extends NativeSocket implements GenericTcpSocket {         public NativeTcpSocket(FileDescriptor fd) {             super(fd);         }     }      public static class NativeUdpSocket extends NativeSocket implements GenericUdpSocket {         public NativeUdpSocket(FileDescriptor fd) {             super(fd);         }          @Override         public void sendTo(byte[] data, InetAddress dstAddr, int port) throws Exception {             Os.sendto(mFd, data, 0, data.length, 0, dstAddr, port);         }     }      public static class JavaUdpSocket implements GenericUdpSocket {         public final DatagramSocket mSocket;          public JavaUdpSocket(InetAddress localAddr, int port) {             try {                 mSocket = new DatagramSocket(port, localAddr);                 mSocket.setSoTimeout(SOCK_TIMEOUT);             } catch (SocketException e) {                 // Fail loudly if we can't set up sockets properly. And without the timeout, we                 // could easily end up in an endless wait.                 throw new RuntimeException(e);             }         }          public JavaUdpSocket(InetAddress localAddr) {             try {                 mSocket = new DatagramSocket(0, localAddr);                 mSocket.setSoTimeout(SOCK_TIMEOUT);             } catch (SocketException e) {                 // Fail loudly if we can't set up sockets properly. And without the timeout, we                 // could easily end up in an endless wait.                 throw new RuntimeException(e);             }         }          @Override         public void send(byte[] data) throws Exception {             mSocket.send(new DatagramPacket(data, data.length));         }          @Override         public void sendTo(byte[] data, InetAddress dstAddr, int port) throws Exception {             mSocket.send(new DatagramPacket(data, data.length, dstAddr, port));         }          @Override         public int getPort() throws Exception {             return mSocket.getLocalPort();         }          @Override         public void close() throws Exception {             mSocket.close();         }          @Override         public byte[] receive() throws Exception {             DatagramPacket data = new DatagramPacket(new byte[DATA_BUFFER_LEN], DATA_BUFFER_LEN);             mSocket.receive(data);             return Arrays.copyOfRange(data.getData(), 0, data.getLength());         }          @Override         public void applyTransportModeTransform(                 IpSecManager ism, int direction, IpSecTransform transform) throws Exception {             ism.applyTransportModeTransform(mSocket, direction, transform);         }          @Override         public void removeTransportModeTransforms(IpSecManager ism) throws Exception {             ism.removeTransportModeTransforms(mSocket);         }     }      public static class JavaTcpSocket implements GenericTcpSocket {         public final Socket mSocket;          public JavaTcpSocket(Socket socket) {             mSocket = socket;             try {                 mSocket.setSoTimeout(SOCK_TIMEOUT);             } catch (SocketException e) {                 // Fail loudly if we can't set up sockets properly. And without the timeout, we                 // could easily end up in an endless wait.                 throw new RuntimeException(e);             }         }          @Override         public void send(byte[] data) throws Exception {             mSocket.getOutputStream().write(data);         }          @Override         public byte[] receive() throws Exception {             byte[] in = new byte[DATA_BUFFER_LEN];             int bytesRead = mSocket.getInputStream().read(in);             return Arrays.copyOfRange(in, 0, bytesRead);         }          @Override         public int getPort() throws Exception {             return mSocket.getLocalPort();         }          @Override         public void close() throws Exception {             mSocket.close();         }          @Override         public void applyTransportModeTransform(                 IpSecManager ism, int direction, IpSecTransform transform) throws Exception {             ism.applyTransportModeTransform(mSocket, direction, transform);         }          @Override         public void removeTransportModeTransforms(IpSecManager ism) throws Exception {             ism.removeTransportModeTransforms(mSocket);         }     }      public static class SocketPair<T> {         public final T mLeftSock;         public final T mRightSock;          public SocketPair(T leftSock, T rightSock) {             mLeftSock = leftSock;             mRightSock = rightSock;         }     }      protected static void applyTransformBidirectionally(             IpSecManager ism, IpSecTransform transform, GenericSocket socket) throws Exception {         for (int direction : DIRECTIONS) {             socket.applyTransportModeTransform(ism, direction, transform);         }     }      public static SocketPair<NativeUdpSocket> getNativeUdpSocketPair(             InetAddress localAddr, IpSecManager ism, IpSecTransform transform, boolean connected)             throws Exception {         int domain = getDomain(localAddr);          NativeUdpSocket leftSock = new NativeUdpSocket(             Os.socket(domain, OsConstants.SOCK_DGRAM, OsConstants.IPPROTO_UDP));         NativeUdpSocket rightSock = new NativeUdpSocket(             Os.socket(domain, OsConstants.SOCK_DGRAM, OsConstants.IPPROTO_UDP));          for (NativeUdpSocket sock : new NativeUdpSocket[] {leftSock, rightSock}) {             applyTransformBidirectionally(ism, transform, sock);             Os.bind(sock.mFd, localAddr, 0);         }          if (connected) {             Os.connect(leftSock.mFd, localAddr, rightSock.getPort());             Os.connect(rightSock.mFd, localAddr, leftSock.getPort());         }          return new SocketPair<>(leftSock, rightSock);     }      public static SocketPair<NativeTcpSocket> getNativeTcpSocketPair(             InetAddress localAddr, IpSecManager ism, IpSecTransform transform) throws Exception {         int domain = getDomain(localAddr);          NativeTcpSocket server = new NativeTcpSocket(                 Os.socket(domain, OsConstants.SOCK_STREAM, OsConstants.IPPROTO_TCP));         NativeTcpSocket client = new NativeTcpSocket(                 Os.socket(domain, OsConstants.SOCK_STREAM, OsConstants.IPPROTO_TCP));          Os.bind(server.mFd, localAddr, 0);          applyTransformBidirectionally(ism, transform, server);         applyTransformBidirectionally(ism, transform, client);          Os.listen(server.mFd, 10);         Os.connect(client.mFd, localAddr, server.getPort());         NativeTcpSocket accepted = new NativeTcpSocket(Os.accept(server.mFd, null));          applyTransformBidirectionally(ism, transform, accepted);         server.close();          return new SocketPair<>(client, accepted);     }      public static SocketPair<JavaUdpSocket> getJavaUdpSocketPair(             InetAddress localAddr, IpSecManager ism, IpSecTransform transform, boolean connected)             throws Exception {         JavaUdpSocket leftSock = new JavaUdpSocket(localAddr);         JavaUdpSocket rightSock = new JavaUdpSocket(localAddr);          applyTransformBidirectionally(ism, transform, leftSock);         applyTransformBidirectionally(ism, transform, rightSock);          if (connected) {             leftSock.mSocket.connect(localAddr, rightSock.mSocket.getLocalPort());             rightSock.mSocket.connect(localAddr, leftSock.mSocket.getLocalPort());         }          return new SocketPair<>(leftSock, rightSock);     }      public static SocketPair<JavaTcpSocket> getJavaTcpSocketPair(             InetAddress localAddr, IpSecManager ism, IpSecTransform transform) throws Exception {         JavaTcpSocket clientSock = new JavaTcpSocket(new Socket());         ServerSocket serverSocket = new ServerSocket();         serverSocket.bind(new InetSocketAddress(localAddr, 0));          // While technically the client socket does not need to be bound, the OpenJDK implementation         // of Socket only allocates an FD when bind() or connect() or other similar methods are         // called. So we call bind to force the FD creation, so that we can apply a transform to it         // prior to socket connect.         clientSock.mSocket.bind(new InetSocketAddress(localAddr, 0));          // IpSecService doesn't support serverSockets at the moment; workaround using FD         FileDescriptor serverFd = serverSocket.getImpl().getFD$();          applyTransformBidirectionally(ism, transform, new NativeTcpSocket(serverFd));         applyTransformBidirectionally(ism, transform, clientSock);          clientSock.mSocket.connect(new InetSocketAddress(localAddr, serverSocket.getLocalPort()));         JavaTcpSocket acceptedSock = new JavaTcpSocket(serverSocket.accept());          applyTransformBidirectionally(ism, transform, acceptedSock);         serverSocket.close();          return new SocketPair<>(clientSock, acceptedSock);     }      private void checkSocketPair(GenericSocket left, GenericSocket right) throws Exception {         left.send(TEST_DATA);         assertArrayEquals(TEST_DATA, right.receive());          right.send(TEST_DATA);         assertArrayEquals(TEST_DATA, left.receive());          left.close();         right.close();     }      private void checkUnconnectedUdpSocketPair(             GenericUdpSocket left, GenericUdpSocket right, InetAddress localAddr) throws Exception {         left.sendTo(TEST_DATA, localAddr, right.getPort());         assertArrayEquals(TEST_DATA, right.receive());          right.sendTo(TEST_DATA, localAddr, left.getPort());         assertArrayEquals(TEST_DATA, left.receive());          left.close();         right.close();     }      protected static IpSecTransform buildIpSecTransform(             Context context,             IpSecManager.SecurityParameterIndex spi,             IpSecManager.UdpEncapsulationSocket encapSocket,             InetAddress remoteAddr)             throws Exception {         IpSecTransform.Builder builder =                 new IpSecTransform.Builder(context)                         .setEncryption(new IpSecAlgorithm(IpSecAlgorithm.CRYPT_AES_CBC, CRYPT_KEY))                         .setAuthentication(                                 new IpSecAlgorithm(                                         IpSecAlgorithm.AUTH_HMAC_SHA256,                                         AUTH_KEY,                                         AUTH_KEY.length * 4));          if (encapSocket != null) {             builder.setIpv4Encapsulation(encapSocket, encapSocket.getPort());         }          return builder.buildTransportModeTransform(remoteAddr, spi);     }      private IpSecTransform buildDefaultTransform(InetAddress localAddr) throws Exception {         try (IpSecManager.SecurityParameterIndex spi =                 mISM.allocateSecurityParameterIndex(localAddr)) {             return buildIpSecTransform(InstrumentationRegistry.getContext(), spi, null, localAddr);         }     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.content.pm.cts.InstantAppTest"	"testInstantAppInstallerQuery"	"CtsContentTestCases"	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/content/src/android/content/pm/cts/InstantAppTest.java"	""	"public void testInstantAppInstallerQuery() {         final Intent intent = new Intent(Intent.ACTION_INSTALL_INSTANT_APP_PACKAGE);         intent.addCategory(Intent.CATEGORY_DEFAULT);         intent.setDataAndType(Uri.fromFile(new File(""foo.apk"")), PACKAGE_MIME_TYPE);         final int resolveFlags =                 MATCH_DIRECT_BOOT_AWARE                 | MATCH_DIRECT_BOOT_UNAWARE                 | MATCH_SYSTEM_ONLY;         final List<ResolveInfo> matches =                 mPackageManager.queryIntentActivities(intent, resolveFlags);         assertTrue(matches == null || matches.size() <= 1);     } }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"com.android.cts.devicepolicy.ManagedProfileProvisioningTest"	"removeTestUsers"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/ManagedProfileProvisioningTest.java"	""	"/*  *.  */ package com.android.cts.devicepolicy;  import android.platform.test.annotations.FlakyTest;  import org.junit.Test;  public class ManagedProfileProvisioningTest extends BaseDevicePolicyTest {     private static final String MANAGED_PROFILE_PKG = ""com.android.cts.managedprofile"";     private static final String MANAGED_PROFILE_APK = ""CtsManagedProfileApp.apk"";      private int mProfileUserId;     private int mParentUserId;      @Override     public void setUp() throws Exception {         super.setUp();          // We need multi user to be supported in order to create a profile of the user owner.         mHasFeature = mHasFeature && hasDeviceFeature(                 ""android.software.managed_users"");          if (mHasFeature) {             removeTestUsers();             mParentUserId = mPrimaryUserId;             installAppAsUser(MANAGED_PROFILE_APK, mParentUserId);             mProfileUserId = 0;         }     }      @Override     public void tearDown() throws Exception {         if (mHasFeature) {             if (mProfileUserId != 0) {                 removeUser(mProfileUserId);             }             // Remove the test app account: also done by uninstallPackage             getDevice().uninstallPackage(MANAGED_PROFILE_PKG);         }         super.tearDown();     }     @FlakyTest(bugId = 141747631)"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.media.cts.VideoEncoderTest"	"isEncoder"	"CtsMediaTestCases"	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	"v4"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/media/src/android/media/cts/VideoEncoderTest.java"	""	"public void test/*  *.  */  package android.media.cts;  import android.media.cts.R;  import android.media.cts.CodecUtils;  import android.graphics.ImageFormat; import android.graphics.SurfaceTexture; import android.media.Image; import android.media.MediaCodec; import android.media.MediaCodec.BufferInfo; import android.media.MediaCodecInfo; import android.media.MediaCodecInfo.CodecCapabilities; import android.media.MediaCodecInfo.VideoCapabilities; import android.media.MediaCodecList; import android.media.MediaExtractor; import android.media.MediaFormat; import android.media.MediaMuxer; import android.net.Uri; import android.platform.test.annotations.AppModeFull; import android.platform.test.annotations.Presubmit; import android.platform.test.annotations.RequiresDevice; import android.util.Log; import android.util.Pair; import android.util.Range; import android.util.Size; import android.view.Surface;  import androidx.test.filters.SmallTest;  import com.android.compatibility.common.util.MediaUtils;  import java.io.File; import java.io.IOException; import java.nio.ByteBuffer; import java.util.ArrayList; import java.util.concurrent.atomic.AtomicReference; import java.util.function.Consumer; import java.util.function.Function; import java.util.HashMap; import java.util.HashSet; import java.util.Iterator; import java.util.LinkedList; import java.util.Map; import java.util.Set;  @MediaHeavyPresubmitTest @AppModeFull(reason = ""TODO: evaluate and port to instant"") public class VideoEncoderTest extends MediaPlayerTestBase {     private static final int MAX_SAMPLE_SIZE = 256 * 1024;     private static final String TAG = ""VideoEncoderTest"";     private static final long FRAME_TIMEOUT_MS = 1000;     // use larger delay before we get first frame, some encoders may need more time     private static final long INIT_TIMEOUT_MS = 2000;      private static final String SOURCE_URL =         ""android.resource://android.media.cts/raw/video_480x360_mp4_h264_871kbps_30fps"";      private final boolean DEBUG = false;      class VideoStorage {         private LinkedList<Pair<ByteBuffer, BufferInfo>> mStream;         private MediaFormat mFormat;         private int mInputBufferSize;         // Media buffers(no CSD, no EOS) enqueued.         private int mMediaBuffersEnqueuedCount;         // Media buffers decoded.         private int mMediaBuffersDecodedCount;         private final AtomicReference<String> errorMsg = new AtomicReference(null);          public VideoStorage() {             mStream = new LinkedList<Pair<ByteBuffer, BufferInfo>>();         }          public void setFormat(MediaFormat format) {             mFormat = format;         }          public void addBuffer(ByteBuffer buffer, BufferInfo info) {             ByteBuffer savedBuffer = ByteBuffer.allocate(info.size);             savedBuffer.put(buffer);             if (info.size > mInputBufferSize) {                 mInputBufferSize = info.size;             }             BufferInfo savedInfo = new BufferInfo();             savedInfo.set(0, savedBuffer.position(), info.presentationTimeUs, info.flags);             mStream.addLast(Pair.create(savedBuffer, savedInfo));             if (info.size > 0 && (info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) == 0) {                 ++mMediaBuffersEnqueuedCount;             }         }          private void play(MediaCodec decoder, Surface surface) {             decoder.reset();             final Object condition = new Object();             final Iterator<Pair<ByteBuffer, BufferInfo>> it = mStream.iterator();             decoder.setCallback(new MediaCodec.Callback() {                 public void onOutputBufferAvailable(MediaCodec codec, int ix, BufferInfo info) {                     if (info.size > 0) {                         ++mMediaBuffersDecodedCount;                     }                     codec.releaseOutputBuffer(ix, info.size > 0);                     if ((info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {                         synchronized (condition) {                             condition.notifyAll();                         }                     }                 }                 public void onInputBufferAvailable(MediaCodec codec, int ix) {                     if (it.hasNext()) {                         Pair<ByteBuffer, BufferInfo> el = it.next();                         el.first.clear();                         try {                             codec.getInputBuffer(ix).put(el.first);                         } catch (java.nio.BufferOverflowException e) {                             Log.e(TAG, ""cannot fit "" + el.first.limit()                                     + ""-byte encoded buffer into ""                                     + codec.getInputBuffer(ix).remaining()                                     + ""-byte input buffer of "" + codec.getName()                                     + "" configured for "" + codec.getInputFormat());                             throw e;                         }                         BufferInfo info = el.second;                         codec.queueInputBuffer(                                 ix, 0, info.size, info.presentationTimeUs, info.flags);                     }                 }                 public void onError(MediaCodec codec, MediaCodec.CodecException e) {                     Log.i(TAG, ""got codec exception"", e);                     errorMsg.set(""received codec error during decode"" + e);                     synchronized (condition) {                         condition.notifyAll();                     }                 }                 public void onOutputFormatChanged(MediaCodec codec, MediaFormat format) {                     Log.i(TAG, ""got output format "" + format);                 }             });             mFormat.setInteger(MediaFormat.KEY_MAX_INPUT_SIZE, mInputBufferSize);             decoder.configure(mFormat, surface, null /* crypto */, 0 /* flags */);             decoder.start();             synchronized (condition) {                 try {                     condition.wait();                 } catch (InterruptedException e) {                     fail(""playback interrupted"");                 }             }             decoder.stop();             assertNull(errorMsg.get(), errorMsg.get());             // All enqueued media data buffers should have got decoded.             if (mMediaBuffersEnqueuedCount != mMediaBuffersDecodedCount) {                 Log.i(TAG, ""mMediaBuffersEnqueuedCount:"" + mMediaBuffersEnqueuedCount);                 Log.i(TAG, ""mMediaBuffersDecodedCount:"" + mMediaBuffersDecodedCount);                 fail(""not all enqueued encoded media buffers were decoded"");             }             mMediaBuffersDecodedCount = 0;         }          public boolean playAll(Surface surface) {             boolean skipped = true;             if (mFormat == null) {                 Log.i(TAG, ""no stream to play"");                 return !skipped;             }             String mime = mFormat.getString(MediaFormat.KEY_MIME);             MediaCodecList mcl = new MediaCodecList(MediaCodecList.REGULAR_CODECS);             for (MediaCodecInfo info : mcl.getCodecInfos()) {                 if (info.isEncoder() || info.isAlias()) {                     continue;                 }                 MediaCodec codec = null;                 try {                     CodecCapabilities caps = info.getCapabilitiesForType(mime);                     if (!caps.isFormatSupported(mFormat)) {                         continue;                     }                     codec = MediaCodec.createByCodecName(info.getName());                 } catch (IllegalArgumentException | IOException e) {                     continue;                 }                 play(codec, surface);                 codec.release();                 skipped = false;             }             return !skipped;         }     }      abstract class VideoProcessorBase extends MediaCodec.Callback {         private static final String TAG = ""VideoProcessorBase"";          /*          * Set this to true to save the encoding results to /data/local/tmp          * You will need to make /data/local/tmp writeable, run ""setenforce 0"",          * and remove files left from a previous run.          */         private boolean mSaveResults = false;         private static final String FILE_DIR = ""/data/local/tmp"";         protected int mMuxIndex = -1;          protected String mProcessorName = ""VideoProcessor"";         private MediaExtractor mExtractor;         protected MediaMuxer mMuxer;         private ByteBuffer mBuffer = ByteBuffer.allocate(MAX_SAMPLE_SIZE);         protected int mTrackIndex = -1;         private boolean mSignaledDecoderEOS;          protected boolean mCompleted;         protected boolean mEncoderIsActive;         protected boolean mEncodeOutputFormatUpdated;         protected final Object mCondition = new Object();         protected final Object mCodecLock = new Object();          protected MediaFormat mDecFormat;         protected MediaCodec mDecoder, mEncoder;          private VideoStorage mEncodedStream;         protected int mFrameRate = 0;         protected int mBitRate = 0;          protected Function<MediaFormat, Boolean> mUpdateConfigFormatHook;         protected Function<MediaFormat, Boolean> mCheckOutputFormatHook;          public void setProcessorName(String name) {             mProcessorName = name;         }          public void setUpdateConfigHook(Function<MediaFormat, Boolean> hook) {             mUpdateConfigFormatHook = hook;         }          public void setCheckOutputFormatHook(Function<MediaFormat, Boolean> hook) {             mCheckOutputFormatHook = hook;         }          protected void open(String path) throws IOException {             mExtractor = new MediaExtractor();             if (path.startsWith(""android.resource://"")) {                 mExtractor.setDataSource(mContext, Uri.parse(path), null);             } else {                 mExtractor.setDataSource(path);             }              for (int i = 0; i < mExtractor.getTrackCount(); i++) {                 MediaFormat fmt = mExtractor.getTrackFormat(i);                 String mime = fmt.getString(MediaFormat.KEY_MIME).toLowerCase();                 if (mime.startsWith(""video/"")) {                     mTrackIndex = i;                     mDecFormat = fmt;                     mExtractor.selectTrack(i);                     break;                 }             }             mEncodedStream = new VideoStorage();             assertTrue(""file "" + path + "" has no video"", mTrackIndex >= 0);         }          // returns true if encoder supports the size         protected boolean initCodecsAndConfigureEncoder(                 String videoEncName, String outMime, int width, int height,                 int colorFormat) throws IOException {             mDecFormat.setInteger(MediaFormat.KEY_COLOR_FORMAT, colorFormat);              MediaCodecList mcl = new MediaCodecList(MediaCodecList.REGULAR_CODECS);             String videoDecName = mcl.findDecoderForFormat(mDecFormat);             Log.i(TAG, ""decoder for "" + mDecFormat + "" is "" + videoDecName);             mDecoder = MediaCodec.createByCodecName(videoDecName);             mEncoder = MediaCodec.createByCodecName(videoEncName);              mDecoder.setCallback(this);             mEncoder.setCallback(this);              VideoCapabilities encCaps =                 mEncoder.getCodecInfo().getCapabilitiesForType(outMime).getVideoCapabilities();             if (!encCaps.isSizeSupported(width, height)) {                 Log.i(TAG, videoEncName + "" does not support size: "" + width + ""x"" + height);                 return false;             }              MediaFormat outFmt = MediaFormat.createVideoFormat(outMime, width, height);             int bitRate = 0;             MediaUtils.setMaxEncoderFrameAndBitrates(encCaps, outFmt, 30);             if (mFrameRate > 0) {                 outFmt.setInteger(MediaFormat.KEY_FRAME_RATE, mFrameRate);             }             if (mBitRate > 0) {                 outFmt.setInteger(MediaFormat.KEY_BIT_RATE, mBitRate);             }             outFmt.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, 1);             outFmt.setInteger(MediaFormat.KEY_COLOR_FORMAT, colorFormat);             // Some extra configure before starting the encoder.             if (mUpdateConfigFormatHook != null) {                 if (!mUpdateConfigFormatHook.apply(outFmt)) {                     return false;                 }             }             mEncoder.configure(outFmt, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE);             Log.i(TAG, ""encoder input format "" + mEncoder.getInputFormat() + "" from "" + outFmt);             if (mSaveResults) {                 try {                     String outFileName =                             FILE_DIR + mProcessorName + ""_"" + bitRate + ""bps"";                     if (outMime.equals(MediaFormat.MIMETYPE_VIDEO_VP8) ||                             outMime.equals(MediaFormat.MIMETYPE_VIDEO_VP9)) {                         mMuxer = new MediaMuxer(                                 outFileName + "".webm"", MediaMuxer.OutputFormat.MUXER_OUTPUT_WEBM);                     } else {                         mMuxer = new MediaMuxer(                                 outFileName + "".mp4"", MediaMuxer.OutputFormat.MUXER_OUTPUT_MPEG_4);                     }                     // The track can't be added until we have the codec specific data                 } catch (Exception e) {                     Log.i(TAG, ""couldn't create muxer: "" + e);                 }             }             return true;         }          protected void close() {             synchronized (mCodecLock) {                 if (mDecoder != null) {                     mDecoder.release();                     mDecoder = null;                 }                 if (mEncoder != null) {                     mEncoder.release();                     mEncoder = null;                 }             }             if (mExtractor != null) {                 mExtractor.release();                 mExtractor = null;             }             if (mMuxer != null) {                 mMuxer.stop();                 mMuxer.release();                 mMuxer = null;             }         }          // returns true if filled buffer         protected boolean fillDecoderInputBuffer(int ix) {             if (DEBUG) Log.v(TAG, ""decoder received input #"" + ix);             while (!mSignaledDecoderEOS) {                 int track = mExtractor.getSampleTrackIndex();                 if (track >= 0 && track != mTrackIndex) {                     mExtractor.advance();                     continue;                 }                 int size = mExtractor.readSampleData(mBuffer, 0);                 if (size < 0) {                     // queue decoder input EOS                     if (DEBUG) Log.v(TAG, ""queuing decoder EOS"");                     mDecoder.queueInputBuffer(                             ix, 0, 0, 0, MediaCodec.BUFFER_FLAG_END_OF_STREAM);                     mSignaledDecoderEOS = true;                 } else {                     mBuffer.limit(size);                     mBuffer.position(0);                     BufferInfo info = new BufferInfo();                     info.set(                             0, mBuffer.limit(), mExtractor.getSampleTime(),                             mExtractor.getSampleFlags());                     mDecoder.getInputBuffer(ix).put(mBuffer);                     if (DEBUG) Log.v(TAG, ""queing input #"" + ix + "" for decoder with timestamp ""                             + info.presentationTimeUs);                     mDecoder.queueInputBuffer(                             ix, 0, mBuffer.limit(), info.presentationTimeUs, 0);                 }                 mExtractor.advance();                 return true;             }             return false;         }          protected void emptyEncoderOutputBuffer(int ix, BufferInfo info) {             if (DEBUG) Log.v(TAG, ""encoder received output #"" + ix                      + "" (sz="" + info.size + "", f="" + info.flags                      + "", ts="" + info.presentationTimeUs + "")"");             ByteBuffer outputBuffer = mEncoder.getOutputBuffer(ix);             mEncodedStream.addBuffer(outputBuffer, info);              if (mMuxer != null) {                 // reset position as addBuffer() modifies it                 outputBuffer.position(info.offset);                 outputBuffer.limit(info.offset + info.size);                 mMuxer.writeSampleData(mMuxIndex, outputBuffer, info);             }              if (!mCompleted) {                 mEncoder.releaseOutputBuffer(ix, false);                 if ((info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {                     Log.d(TAG, ""encoder received output EOS"");                     synchronized(mCondition) {                         mCompleted = true;                         mCondition.notifyAll(); // condition is always satisfied                     }                 } else {                     synchronized(mCondition) {                         mEncoderIsActive = true;                     }                 }             }         }          protected void saveEncoderFormat(MediaFormat format) {             mEncodedStream.setFormat(format);             if (mCheckOutputFormatHook != null) {                 mCheckOutputFormatHook.apply(format);             }             if (mMuxer != null) {                 if (mMuxIndex < 0) {                     mMuxIndex = mMuxer.addTrack(format);                     mMuxer.start();                 }             }         }          public boolean playBack(Surface surface) { return mEncodedStream.playAll(surface); }          public void setFrameAndBitRates(int frameRate, int bitRate) {             mFrameRate = frameRate;             mBitRate = bitRate;         }          @Override         public void onInputBufferAvailable(MediaCodec mediaCodec, int ix) {             synchronized (mCodecLock) {                 if (mEncoder != null && mDecoder != null) {                     onInputBufferAvailableLocked(mediaCodec, ix);                 }             }         }          @Override         public void onOutputBufferAvailable(                 MediaCodec mediaCodec, int ix, BufferInfo info) {             synchronized (mCodecLock) {                 if (mEncoder != null && mDecoder != null) {                     onOutputBufferAvailableLocked(mediaCodec, ix, info);                 }             }         }          public abstract boolean processLoop(                 String path, String outMime, String videoEncName,                 int width, int height, boolean optional);         protected abstract void onInputBufferAvailableLocked(                 MediaCodec mediaCodec, int ix);         protected abstract void onOutputBufferAvailableLocked(                 MediaCodec mediaCodec, int ix, BufferInfo info);     }      class VideoProcessor extends VideoProcessorBase {         private static final String TAG = ""VideoProcessor"";         private boolean mWorkInProgress;         private boolean mGotDecoderEOS;         private boolean mSignaledEncoderEOS;          private LinkedList<Pair<Integer, BufferInfo>> mBuffersToRender =             new LinkedList<Pair<Integer, BufferInfo>>();         private LinkedList<Integer> mEncInputBuffers = new LinkedList<Integer>();          private int mEncInputBufferSize = -1;         private final AtomicReference<String> errorMsg = new AtomicReference(null);          @Override         public boolean processLoop(                  String path, String outMime, String videoEncName,                  int width, int height, boolean optional) {             boolean skipped = true;             try {                 open(path);                 if (!initCodecsAndConfigureEncoder(                         videoEncName, outMime, width, height,                         CodecCapabilities.COLOR_FormatYUV420Flexible)) {                     assertTrue(""could not configure encoder for supported size"", optional);                     return !skipped;                 }                 skipped = false;                  mDecoder.configure(mDecFormat, null /* surface */, null /* crypto */, 0);                  mDecoder.start();                 mEncoder.start();                  // main loop - process GL ops as only main thread has GL context                 while (!mCompleted && errorMsg.get() == null) {                     Pair<Integer, BufferInfo> decBuffer = null;                     int encBuffer = -1;                     synchronized (mCondition) {                         try {                             // wait for an encoder input buffer and a decoder output buffer                             // Use a timeout to avoid stalling the test if it doesn't arrive.                             if (!haveBuffers() && !mCompleted) {                                 mCondition.wait(mEncodeOutputFormatUpdated ?                                         FRAME_TIMEOUT_MS : INIT_TIMEOUT_MS);                             }                         } catch (InterruptedException ie) {                             fail(""wait interrupted"");  // shouldn't happen                         }                         if (mCompleted) {                             break;                         }                         if (!haveBuffers()) {                             if (mEncoderIsActive) {                                 mEncoderIsActive = false;                                 Log.d(TAG, ""No more input but still getting output from encoder."");                                 continue;                             }                             fail(""timed out after "" + mBuffersToRender.size()                                     + "" decoder output and "" + mEncInputBuffers.size()                                     + "" encoder input buffers"");                         }                          if (DEBUG) Log.v(TAG, ""got image"");                         decBuffer = mBuffersToRender.removeFirst();                         encBuffer = mEncInputBuffers.removeFirst();                         if (isEOSOnlyBuffer(decBuffer)) {                             queueEncoderEOS(decBuffer, encBuffer);                             continue;                         }                         mWorkInProgress = true;                     }                      if (mWorkInProgress) {                         renderDecodedBuffer(decBuffer, encBuffer);                         synchronized(mCondition) {                             mWorkInProgress = false;                         }                     }                 }             } catch (IOException e) {                 e.printStackTrace();                 fail(""received exception "" + e);             } finally {                 close();             }             assertNull(errorMsg.get(), errorMsg.get());             return !skipped;         }          @Override         public void onInputBufferAvailableLocked(MediaCodec mediaCodec, int ix) {             if (mediaCodec == mDecoder) {                 // fill input buffer from extractor                 fillDecoderInputBuffer(ix);             } else if (mediaCodec == mEncoder) {                 synchronized(mCondition) {                     mEncInputBuffers.addLast(ix);                     tryToPropagateEOS();                     if (haveBuffers()) {                         mCondition.notifyAll();                     }                 }             } else {                 fail(""received input buffer on "" + mediaCodec.getName());             }         }          @Override         public void onOutputBufferAvailableLocked(                 MediaCodec mediaCodec, int ix, BufferInfo info) {             if (mediaCodec == mDecoder) {                 if (DEBUG) Log.v(TAG, ""decoder received output #"" + ix                          + "" (sz="" + info.size + "", f="" + info.flags                          + "", ts="" + info.presentationTimeUs + "")"");                 // render output buffer from decoder                 if (!mGotDecoderEOS) {                     boolean eos = (info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;                     // can release empty buffers now                     if (info.size == 0) {                         mDecoder.releaseOutputBuffer(ix, false /* render */);                         ix = -1; // dummy index used by render to not render                     }                     synchronized(mCondition) {                         if (ix < 0 && eos && mBuffersToRender.size() > 0) {                             // move lone EOS flag to last buffer to be rendered                             mBuffersToRender.peekLast().second.flags |=                                 MediaCodec.BUFFER_FLAG_END_OF_STREAM;                         } else if (ix >= 0 || eos) {                             mBuffersToRender.addLast(Pair.create(ix, info));                         }                         if (eos) {                             tryToPropagateEOS();                             mGotDecoderEOS = true;                         }                         if (haveBuffers()) {                             mCondition.notifyAll();                         }                     }                 }             } else if (mediaCodec == mEncoder) {                 emptyEncoderOutputBuffer(ix, info);             } else {                 fail(""received output buffer on "" + mediaCodec.getName());             }         }          private void renderDecodedBuffer(Pair<Integer, BufferInfo> decBuffer, int encBuffer) {             // process heavyweight actions under instance lock             Image encImage = mEncoder.getInputImage(encBuffer);             Image decImage = mDecoder.getOutputImage(decBuffer.first);             assertNotNull(""could not get encoder image for "" + mEncoder.getInputFormat(), encImage);             assertNotNull(""could not get decoder image for "" + mDecoder.getInputFormat(), decImage);             assertEquals(""incorrect decoder format"",decImage.getFormat(), ImageFormat.YUV_420_888);             assertEquals(""incorrect encoder format"", encImage.getFormat(), ImageFormat.YUV_420_888);              CodecUtils.copyFlexYUVImage(encImage, decImage);              // TRICKY: need this for queueBuffer             if (mEncInputBufferSize < 0) {                 mEncInputBufferSize = mEncoder.getInputBuffer(encBuffer).capacity();             }             Log.d(TAG, ""queuing input #"" + encBuffer + "" for encoder (sz=""                     + mEncInputBufferSize + "", f="" + decBuffer.second.flags                     + "", ts="" + decBuffer.second.presentationTimeUs + "")"");             mEncoder.queueInputBuffer(                     encBuffer, 0, mEncInputBufferSize, decBuffer.second.presentationTimeUs,                     decBuffer.second.flags);             if ((decBuffer.second.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {                 mSignaledEncoderEOS = true;             }             mDecoder.releaseOutputBuffer(decBuffer.first, false /* render */);         }          @Override         public void onError(MediaCodec mediaCodec, MediaCodec.CodecException e) {             String codecName = null;             try {                 codecName = mediaCodec.getName();             } catch (Exception ex) {                 codecName = ""(error getting codec name)"";             }             errorMsg.set(""received error on "" + codecName + "": "" + e);         }          @Override         public void onOutputFormatChanged(MediaCodec mediaCodec, MediaFormat mediaFormat) {             Log.i(TAG, mediaCodec.getName() + "" got new output format "" + mediaFormat);             if (mediaCodec == mEncoder) {                 mEncodeOutputFormatUpdated = true;                 saveEncoderFormat(mediaFormat);             }         }          // next methods are synchronized on mCondition         private boolean haveBuffers() {             return mEncInputBuffers.size() > 0 && mBuffersToRender.size() > 0                     && !mSignaledEncoderEOS;         }          private boolean isEOSOnlyBuffer(Pair<Integer, BufferInfo> decBuffer) {             return decBuffer.first < 0 || decBuffer.second.size == 0;         }          protected void tryToPropagateEOS() {             if (!mWorkInProgress && haveBuffers() && isEOSOnlyBuffer(mBuffersToRender.getFirst())) {                 Pair<Integer, BufferInfo> decBuffer = mBuffersToRender.removeFirst();                 int encBuffer = mEncInputBuffers.removeFirst();                 queueEncoderEOS(decBuffer, encBuffer);             }         }          void queueEncoderEOS(Pair<Integer, BufferInfo> decBuffer, int encBuffer) {             Log.d(TAG, ""signaling encoder EOS"");             mEncoder.queueInputBuffer(encBuffer, 0, 0, 0, MediaCodec.BUFFER_FLAG_END_OF_STREAM);             mSignaledEncoderEOS = true;             if (decBuffer.first >= 0) {                 mDecoder.releaseOutputBuffer(decBuffer.first, false /* render */);             }         }     }       class SurfaceVideoProcessor extends VideoProcessorBase             implements SurfaceTexture.OnFrameAvailableListener {         private static final String TAG = ""SurfaceVideoProcessor"";         private boolean mFrameAvailable;         private boolean mGotDecoderEOS;         private boolean mSignaledEncoderEOS;          private InputSurface mEncSurface;         private OutputSurface mDecSurface;         private BufferInfo mInfoOnSurface;          private LinkedList<Pair<Integer, BufferInfo>> mBuffersToRender =             new LinkedList<Pair<Integer, BufferInfo>>();          private final AtomicReference<String> errorMsg = new AtomicReference(null);          @Override         public boolean processLoop(                 String path, String outMime, String videoEncName,                 int width, int height, boolean optional) {             boolean skipped = true;             try {                 open(path);                 if (!initCodecsAndConfigureEncoder(                         videoEncName, outMime, width, height,                         CodecCapabilities.COLOR_FormatSurface)) {                     assertTrue(""could not configure encoder for supported size"", optional);                     return !skipped;                 }                 skipped = false;                  mEncSurface = new InputSurface(mEncoder.createInputSurface());                 mEncSurface.makeCurrent();                  mDecSurface = new OutputSurface(this);                 //mDecSurface.changeFragmentShader(FRAGMENT_SHADER);                 mDecoder.configure(mDecFormat, mDecSurface.getSurface(), null /* crypto */, 0);                  mDecoder.start();                 mEncoder.start();                  // main loop - process GL ops as only main thread has GL context                 while (!mCompleted && errorMsg.get() == null) {                     BufferInfo info = null;                     synchronized (mCondition) {                         try {                             // wait for mFrameAvailable, which is set by onFrameAvailable().                             // Use a timeout to avoid stalling the test if it doesn't arrive.                             if (!mFrameAvailable && !mCompleted && !mEncoderIsActive) {                                 mCondition.wait(mEncodeOutputFormatUpdated ?                                         FRAME_TIMEOUT_MS : INIT_TIMEOUT_MS);                             }                         } catch (InterruptedException ie) {                             fail(""wait interrupted"");  // shouldn't happen                         }                         if (mCompleted) {                             break;                         }                         if (mEncoderIsActive) {                             mEncoderIsActive = false;                             if (DEBUG) Log.d(TAG, ""encoder is still active, continue"");                             continue;                         }                         assertTrue(""still waiting for image"", mFrameAvailable);                         if (DEBUG) Log.v(TAG, ""got image"");                         info = mInfoOnSurface;                     }                     if (info == null) {                         continue;                     }                     if (info.size > 0) {                         mDecSurface.latchImage();                         if (DEBUG) Log.v(TAG, ""latched image"");                         mFrameAvailable = false;                          mDecSurface.drawImage();                         Log.d(TAG, ""encoding frame at "" + info.presentationTimeUs * 1000);                          mEncSurface.setPresentationTime(info.presentationTimeUs * 1000);                         mEncSurface.swapBuffers();                     }                     if ((info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {                         mSignaledEncoderEOS = true;                         Log.d(TAG, ""signaling encoder EOS"");                         mEncoder.signalEndOfInputStream();                     }                      synchronized (mCondition) {                         mInfoOnSurface = null;                         if (mBuffersToRender.size() > 0 && mInfoOnSurface == null) {                             if (DEBUG) Log.v(TAG, ""handling postponed frame"");                             Pair<Integer, BufferInfo> nextBuffer = mBuffersToRender.removeFirst();                             renderDecodedBuffer(nextBuffer.first, nextBuffer.second);                         }                     }                 }             } catch (IOException e) {                 e.printStackTrace();                 fail(""received exception "" + e);             } finally {                 close();                 if (mEncSurface != null) {                     mEncSurface.release();                     mEncSurface = null;                 }                 if (mDecSurface != null) {                     mDecSurface.release();                     mDecSurface = null;                 }             }             assertNull(errorMsg.get(), errorMsg.get());             return !skipped;         }          @Override         public void onFrameAvailable(SurfaceTexture st) {             if (DEBUG) Log.v(TAG, ""new frame available"");             synchronized (mCondition) {                 assertFalse(""mFrameAvailable already set, frame could be dropped"", mFrameAvailable);                 mFrameAvailable = true;                 mCondition.notifyAll();             }         }          @Override         public void onInputBufferAvailableLocked(MediaCodec mediaCodec, int ix) {             if (mediaCodec == mDecoder) {                 // fill input buffer from extractor                 fillDecoderInputBuffer(ix);             } else {                 fail(""received input buffer on "" + mediaCodec.getName());             }         }          @Override         public void onOutputBufferAvailableLocked(                 MediaCodec mediaCodec, int ix, BufferInfo info) {             if (mediaCodec == mDecoder) {                 if (DEBUG) Log.v(TAG, ""decoder received output #"" + ix                          + "" (sz="" + info.size + "", f="" + info.flags                          + "", ts="" + info.presentationTimeUs + "")"");                 // render output buffer from decoder                 if (!mGotDecoderEOS) {                     boolean eos = (info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;                     if (eos) {                         mGotDecoderEOS = true;                     }                     // can release empty buffers now                     if (info.size == 0) {                         mDecoder.releaseOutputBuffer(ix, false /* render */);                         ix = -1; // dummy index used by render to not render                     }                     if (eos || info.size > 0) {                         synchronized(mCondition) {                             if (mInfoOnSurface != null || mBuffersToRender.size() > 0) {                                 if (DEBUG) Log.v(TAG, ""postponing render, surface busy"");                                 mBuffersToRender.addLast(Pair.create(ix, info));                             } else {                                 renderDecodedBuffer(ix, info);                             }                         }                     }                 }             } else if (mediaCodec == mEncoder) {                 emptyEncoderOutputBuffer(ix, info);                 synchronized(mCondition) {                     if (!mCompleted) {                         mEncoderIsActive = true;                         mCondition.notifyAll();                     }                 }             } else {                 fail(""received output buffer on "" + mediaCodec.getName());             }         }          private void renderDecodedBuffer(int ix, BufferInfo info) {             boolean eos = (info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;             mInfoOnSurface = info;             if (info.size > 0) {                 Log.d(TAG, ""rendering frame #"" + ix + "" at "" + info.presentationTimeUs * 1000                         + (eos ? "" with EOS"" : """"));                 mDecoder.releaseOutputBuffer(ix, info.presentationTimeUs * 1000);             }              if (eos && info.size == 0) {                 if (DEBUG) Log.v(TAG, ""decoder output EOS available"");                 mFrameAvailable = true;                 mCondition.notifyAll();             }         }          @Override         public void onError(MediaCodec mediaCodec, MediaCodec.CodecException e) {             String codecName = null;             try {                 codecName = mediaCodec.getName();             } catch (Exception ex) {                 codecName = ""(error getting codec name)"";             }             errorMsg.set(""received error on "" + codecName + "": "" + e);         }          @Override         public void onOutputFormatChanged(MediaCodec mediaCodec, MediaFormat mediaFormat) {             Log.i(TAG, mediaCodec.getName() + "" got new output format "" + mediaFormat);             if (mediaCodec == mEncoder) {                 mEncodeOutputFormatUpdated = true;                 saveEncoderFormat(mediaFormat);             }         }     }      class Encoder {         final private String mName;         final private String mMime;         final private CodecCapabilities mCaps;         final private VideoCapabilities mVideoCaps;          final private Map<Size, Set<Size>> mMinMax;     // extreme sizes         final private Map<Size, Set<Size>> mNearMinMax; // sizes near extreme         final private Set<Size> mArbitraryW;            // arbitrary widths in the middle         final private Set<Size> mArbitraryH;            // arbitrary heights in the middle         final private Set<Size> mSizes;                 // all non-specifically tested sizes          final private int xAlign;         final private int yAlign;          Encoder(String name, String mime, CodecCapabilities caps) {             mName = name;             mMime = mime;             mCaps = caps;             mVideoCaps = caps.getVideoCapabilities();              /* calculate min/max sizes */             mMinMax = new HashMap<Size, Set<Size>>();             mNearMinMax = new HashMap<Size, Set<Size>>();             mArbitraryW = new HashSet<Size>();             mArbitraryH = new HashSet<Size>();             mSizes = new HashSet<Size>();              xAlign = mVideoCaps.getWidthAlignment();             yAlign = mVideoCaps.getHeightAlignment();              initializeSizes();         }          private void initializeSizes() {             for (int x = 0; x < 2; ++x) {                 for (int y = 0; y < 2; ++y) {                     addExtremeSizesFor(x, y);                 }             }              // initialize arbitrary sizes             for (int i = 1; i <= 7; ++i) {                 int j = ((7 * i) % 11) + 1;                 int width, height;                 try {                     width = alignedPointInRange(i * 0.125, xAlign, mVideoCaps.getSupportedWidths());                     height = alignedPointInRange(                             j * 0.077, yAlign, mVideoCaps.getSupportedHeightsFor(width));                     mArbitraryW.add(new Size(width, height));                 } catch (IllegalArgumentException e) {                 }                  try {                     height = alignedPointInRange(i * 0.125, yAlign, mVideoCaps.getSupportedHeights());                     width = alignedPointInRange(j * 0.077, xAlign, mVideoCaps.getSupportedWidthsFor(height));                     mArbitraryH.add(new Size(width, height));                 } catch (IllegalArgumentException e) {                 }             }             mArbitraryW.removeAll(mArbitraryH);             mArbitraryW.removeAll(mSizes);             mSizes.addAll(mArbitraryW);             mArbitraryH.removeAll(mSizes);             mSizes.addAll(mArbitraryH);             if (DEBUG) Log.i(TAG, ""arbitrary="" + mArbitraryW + ""/"" + mArbitraryH);         }          private void addExtremeSizesFor(int x, int y) {             Set<Size> minMax = new HashSet<Size>();             Set<Size> nearMinMax = new HashSet<Size>();              for (int dx = 0; dx <= xAlign; dx += xAlign) {                 for (int dy = 0; dy <= yAlign; dy += yAlign) {                     Set<Size> bucket = (dx + dy == 0) ? minMax : nearMinMax;                     try {                         int width = getExtreme(mVideoCaps.getSupportedWidths(), x, dx);                         int height = getExtreme(mVideoCaps.getSupportedHeightsFor(width), y, dy);                         bucket.add(new Size(width, height));                          // try max max with more reasonable ratio if too skewed                         if (x + y == 2 && width >= 4 * height) {                             Size wideScreen = getLargestSizeForRatio(16, 9);                             width = getExtreme(                                     mVideoCaps.getSupportedWidths()                                             .intersect(0, wideScreen.getWidth()), x, dx);                             height = getExtreme(mVideoCaps.getSupportedHeightsFor(width), y, 0);                             bucket.add(new Size(width, height));                         }                     } catch (IllegalArgumentException e) {                     }                      try {                         int height = getExtreme(mVideoCaps.getSupportedHeights(), y, dy);                         int width = getExtreme(mVideoCaps.getSupportedWidthsFor(height), x, dx);                         bucket.add(new Size(width, height));                          // try max max with more reasonable ratio if too skewed                         if (x + y == 2 && height >= 4 * width) {                             Size wideScreen = getLargestSizeForRatio(9, 16);                             height = getExtreme(                                     mVideoCaps.getSupportedHeights()                                             .intersect(0, wideScreen.getHeight()), y, dy);                             width = getExtreme(mVideoCaps.getSupportedWidthsFor(height), x, dx);                             bucket.add(new Size(width, height));                         }                     } catch (IllegalArgumentException e) {                     }                 }             }              // keep unique sizes             minMax.removeAll(mSizes);             mSizes.addAll(minMax);             nearMinMax.removeAll(mSizes);             mSizes.addAll(nearMinMax);              mMinMax.put(new Size(x, y), minMax);             mNearMinMax.put(new Size(x, y), nearMinMax);             if (DEBUG) Log.i(TAG, x + ""x"" + y + "": minMax="" + mMinMax + "", near="" + mNearMinMax);         }          private int alignInRange(double value, int align, Range<Integer> range) {             return range.clamp(align * (int)Math.round(value / align));         }          /* point should be between 0. and 1. */         private int alignedPointInRange(double point, int align, Range<Integer> range) {             return alignInRange(                     range.getLower() + point * (range.getUpper() - range.getLower()), align, range);         }          private int getExtreme(Range<Integer> range, int i, int delta) {             int dim = i == 1 ? range.getUpper() - delta : range.getLower() + delta;             if (delta == 0                     || (dim > range.getLower() && dim < range.getUpper())) {                 return dim;             }             throw new IllegalArgumentException();         }          private Size getLargestSizeForRatio(int x, int y) {             Range<Integer> widthRange = mVideoCaps.getSupportedWidths();             Range<Integer> heightRange = mVideoCaps.getSupportedHeightsFor(widthRange.getUpper());             final int xAlign = mVideoCaps.getWidthAlignment();             final int yAlign = mVideoCaps.getHeightAlignment();              // scale by alignment             int width = alignInRange(                     Math.sqrt(widthRange.getUpper() * heightRange.getUpper() * (double)x / y),                     xAlign, widthRange);             int height = alignInRange(                     width * (double)y / x, yAlign, mVideoCaps.getSupportedHeightsFor(width));             return new Size(width, height);         }           public boolean testExtreme(int x, int y, boolean flexYUV, boolean near) {             boolean skipped = true;             for (Size s : (near ? mNearMinMax : mMinMax).get(new Size(x, y))) {                 if (test(s.getWidth(), s.getHeight(), false /* optional */, flexYUV)) {                     skipped = false;                 }             }             return !skipped;         }          public boolean testArbitrary(boolean flexYUV, boolean widths) {             boolean skipped = true;             for (Size s : (widths ? mArbitraryW : mArbitraryH)) {                 if (test(s.getWidth(), s.getHeight(), false /* optional */, flexYUV)) {                     skipped = false;                 }             }             return !skipped;         }          public boolean testSpecific(int width, int height, boolean flexYUV) {             // already tested by one of the min/max tests             if (mSizes.contains(new Size(width, height))) {                 return false;             }             return test(width, height, true /* optional */, flexYUV);         }          public boolean testIntraRefresh(int width, int height) {             if (!mCaps.isFeatureSupported(CodecCapabilities.FEATURE_IntraRefresh)) {                 return false;             }              final int refreshPeriod[] = new int[] {10, 13, 17, 22, 29, 38, 50, 60};              // Test the support of refresh periods in the range of 10 - 60 frames             for (int period : refreshPeriod) {                 Function<MediaFormat, Boolean> updateConfigFormatHook =                 new Function<MediaFormat, Boolean>() {                     public Boolean apply(MediaFormat fmt) {                         // set i-frame-interval to 10000 so encoded video only has 1 i-frame.                         fmt.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, 10000);                         fmt.setInteger(MediaFormat.KEY_INTRA_REFRESH_PERIOD, period);                         return true;                     }                 };                  Function<MediaFormat, Boolean> checkOutputFormatHook =                 new Function<MediaFormat, Boolean>() {                     public Boolean apply(MediaFormat fmt) {                         int intraPeriod = fmt.getInteger(MediaFormat.KEY_INTRA_REFRESH_PERIOD);                         // Make sure intra period is correct and carried in the output format.                         // intraPeriod must be larger than 0 and operate within 20% of refresh period.                         if (intraPeriod > 1.2 * period || intraPeriod < 0.8 * period) {                             throw new RuntimeException(""Intra period mismatch"");                         }                         return true;                     }                 };                  String testName =                 mName + '_' + width + ""x"" + height + '_' + ""flexYUV_intraRefresh"";                  Consumer<VideoProcessorBase> configureVideoProcessor =                 new Consumer<VideoProcessorBase>() {                     public void accept(VideoProcessorBase processor) {                         processor.setProcessorName(testName);                         processor.setUpdateConfigHook(updateConfigFormatHook);                         processor.setCheckOutputFormatHook(checkOutputFormatHook);                     }                 };                  if (!test(width, height, 0 /* frameRate */, 0 /* bitRate */, true /* optional */,                     true /* flex */, configureVideoProcessor)) {                     return false;                 }             }              return true;         }          public boolean testDetailed(                 int width, int height, int frameRate, int bitRate, boolean flexYUV) {             String testName =                     mName + '_' + width + ""x"" + height + '_' + (flexYUV ? ""flexYUV"" : "" surface"");             Consumer<VideoProcessorBase> configureVideoProcessor =                     new Consumer<VideoProcessorBase>() {                 public void accept(VideoProcessorBase processor) {                     processor.setProcessorName(testName);                 }             };             return test(width, height, frameRate, bitRate, true /* optional */, flexYUV,                     configureVideoProcessor);         }          public boolean testSupport(int width, int height, int frameRate, int bitRate) {             return mVideoCaps.areSizeAndRateSupported(width, height, frameRate) &&                     mVideoCaps.getBitrateRange().contains(bitRate);         }          private boolean test(                 int width, int height, boolean optional, boolean flexYUV) {             String testName =                     mName + '_' + width + ""x"" + height + '_' + (flexYUV ? ""flexYUV"" : "" surface"");             Consumer<VideoProcessorBase> configureVideoProcessor =                     new Consumer<VideoProcessorBase>() {                 public void accept(VideoProcessorBase processor) {                     processor.setProcessorName(testName);                 }             };             return test(width, height, 0 /* frameRate */, 0 /* bitRate */,                     optional, flexYUV, configureVideoProcessor);         }          private boolean test(                 int width, int height, int frameRate, int bitRate, boolean optional,                 boolean flexYUV, Consumer<VideoProcessorBase> configureVideoProcessor) {             Log.i(TAG, ""testing "" + mMime + "" on "" + mName + "" for "" + width + ""x"" + height                     + (flexYUV ? "" flexYUV"" : "" surface""));              VideoProcessorBase processor =                 flexYUV ? new VideoProcessor() : new SurfaceVideoProcessor();              processor.setFrameAndBitRates(frameRate, bitRate);             configureVideoProcessor.accept(processor);              // We are using a resource URL as an example             boolean success = processor.processLoop(                     SOURCE_URL, mMime, mName, width, height, optional);             if (success) {                 success = processor.playBack(getActivity().getSurfaceHolder().getSurface());             }             return success;         }     }      private Encoder[] googH265()  { return goog(MediaFormat.MIMETYPE_VIDEO_HEVC); }     private Encoder[] googH264()  { return goog(MediaFormat.MIMETYPE_VIDEO_AVC); }     private Encoder[] googH263()  { return goog(MediaFormat.MIMETYPE_VIDEO_H263); }     private Encoder[] googMpeg4() { return goog(MediaFormat.MIMETYPE_VIDEO_MPEG4); }     private Encoder[] googVP8()   { return goog(MediaFormat.MIMETYPE_VIDEO_VP8); }     private Encoder[] googVP9()   { return goog(MediaFormat.MIMETYPE_VIDEO_VP9); }      private Encoder[] otherH265()  { return other(MediaFormat.MIMETYPE_VIDEO_HEVC); }     private Encoder[] otherH264()  { return other(MediaFormat.MIMETYPE_VIDEO_AVC); }     private Encoder[] otherH263()  { return other(MediaFormat.MIMETYPE_VIDEO_H263); }     private Encoder[] otherMpeg4() { return other(MediaFormat.MIMETYPE_VIDEO_MPEG4); }     private Encoder[] otherVP8()   { return other(MediaFormat.MIMETYPE_VIDEO_VP8); }     private Encoder[] otherVP9()   { return other(MediaFormat.MIMETYPE_VIDEO_VP9); }      private Encoder[] goog(String mime) {         return encoders(mime, true /* goog */);     }      private Encoder[] other(String mime) {         return encoders(mime, false /* goog */);     }      private Encoder[] combineArray(Encoder[] a, Encoder[] b) {         Encoder[] all = new Encoder[a.length + b.length];         System.arraycopy(a, 0, all, 0, a.length);         System.arraycopy(b, 0, all, a.length, b.length);         return all;     }      private Encoder[] h264()  {         return combineArray(googH264(), otherH264());     }      private Encoder[] vp8()  {         return combineArray(googVP8(), otherVP8());     }      private Encoder[] encoders(String mime, boolean goog) {         MediaCodecList mcl = new MediaCodecList(MediaCodecList.REGULAR_CODECS);         ArrayList<Encoder> result = new ArrayList<Encoder>();          for (MediaCodecInfo info : mcl.getCodecInfos()) {             if (!info.isEncoder() || !info.isVendor() != goog || info.isAlias()) {                 continue;             }             CodecCapabilities caps = null;             try {                 caps = info.getCapabilitiesForType(mime);             } catch (IllegalArgumentException e) { // mime is not supported                 continue;             }             assertNotNull(info.getName() + "" capabilties for "" + mime + "" returned null"", caps);             result.add(new Encoder(info.getName(), mime, caps));         }         return result.toArray(new Encoder[result.size()]);     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.media.cts.MediaCodecTest"	"testException"	"CtsMediaTestCases"	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	"v4"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/media/src/android/media/cts/MediaCodecTest.java"	""	"public void testException() throws Exception {         boolean tested = false;         // audio decoder (MP3 should be present on all Android devices)         MediaFormat format = MediaFormat.createAudioFormat(                 MediaFormat.MIMETYPE_AUDIO_MPEG, 44100 /* sampleRate */, 2 /* channelCount */);         tested = verifyException(format, false /* isEncoder */) || tested;          // audio encoder (AMR-WB may not be present on some Android devices)         format = MediaFormat.createAudioFormat(                 MediaFormat.MIMETYPE_AUDIO_AMR_WB, 16000 /* sampleRate */, 1 /* channelCount */);         format.setInteger(MediaFormat.KEY_BIT_RATE, 19850);         tested = verifyException(format, true /* isEncoder */) || tested;          // video decoder (H.264/AVC may not be present on some Android devices)         format = createMediaFormat();         tested = verifyException(format, false /* isEncoder */) || tested;          // video encoder (H.264/AVC may not be present on some Android devices)         tested = verifyException(format, true /* isEncoder */) || tested;          // signal test is skipped due to no device media codecs.         if (!tested) {             MediaUtils.skipTest(TAG, ""cannot find any compatible device codecs"");         }     }      // wrap MediaCodec encoder and decoder creation     private static MediaCodec createCodecByType(String type, boolean isEncoder)             throws IOException {         if (isEncoder) {             return MediaCodec.createEncoderByType(type);         }         return MediaCodec.createDecoderByType(type);     }      private static void logMediaCodecException(MediaCodec.CodecException ex) {         if (ex.isRecoverable()) {             Log.w(TAG, ""CodecException Recoverable: "" + ex.getErrorCode());         } else if (ex.isTransient()) {             Log.w(TAG, ""CodecException Transient: "" + ex.getErrorCode());         } else {             Log.w(TAG, ""CodecException Fatal: "" + ex.getErrorCode());         }     }      private static boolean verifyException(MediaFormat format, boolean isEncoder)             throws IOException {         String mimeType = format.getString(MediaFormat.KEY_MIME);         if (!supportsCodec(mimeType, isEncoder)) {             Log.i(TAG, ""No "" + (isEncoder ? ""encoder"" : ""decoder"")                     + "" found for mimeType= "" + mimeType);             return false;         }          final boolean isVideoEncoder = isEncoder && mimeType.startsWith(""video/"");          if (isVideoEncoder) {             format = new MediaFormat(format);             format.setInteger(MediaFormat.KEY_COLOR_FORMAT,                     MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);         }          // create codec (enter Initialized State)         MediaCodec codec;          // create improperly         final String methodName = isEncoder ? ""createEncoderByType"" : ""createDecoderByType"";         try {             codec = createCodecByType(null, isEncoder);             fail(methodName + "" should return NullPointerException on null"");         } catch (NullPointerException e) { // expected         }         try {             codec = createCodecByType(""foobarplan9"", isEncoder); // invalid type             fail(methodName + "" should return IllegalArgumentException on invalid type"");         } catch (IllegalArgumentException e) { // expected         }         try {             codec = MediaCodec.createByCodecName(""foobarplan9""); // invalid name             fail(methodName + "" should return IllegalArgumentException on invalid name"");         } catch (IllegalArgumentException e) { // expected         }         // correct         codec = createCodecByType(format.getString(MediaFormat.KEY_MIME), isEncoder);          // test a few commands         try {             codec.start();             fail(""start should return IllegalStateException when in Initialized state"");         } catch (MediaCodec.CodecException e) {             logMediaCodecException(e);             fail(""start should not return MediaCodec.CodecException on wrong state"");         } catch (IllegalStateException e) { // expected         }         try {             codec.flush();             fail(""flush should return IllegalStateException when in Initialized state"");         } catch (MediaCodec.CodecException e) {             logMediaCodecException(e);             fail(""flush should not return MediaCodec.CodecException on wrong state"");         } catch (IllegalStateException e) { // expected         }         MediaCodecInfo codecInfo = codec.getCodecInfo(); // obtaining the codec info now is fine.         try {             int bufIndex = codec.dequeueInputBuffer(0);             fail(""dequeueInputBuffer should return IllegalStateException""                     + "" when in the Initialized state"");         } catch (MediaCodec.CodecException e) {             logMediaCodecException(e);             fail(""dequeueInputBuffer should not return MediaCodec.CodecException""                     + "" on wrong state"");         } catch (IllegalStateException e) { // expected         }         try {             MediaCodec.BufferInfo info = new MediaCodec.BufferInfo();             int bufIndex = codec.dequeueOutputBuffer(info, 0);             fail(""dequeueOutputBuffer should return IllegalStateException""                     + "" when in the Initialized state"");         } catch (MediaCodec.CodecException e) {             logMediaCodecException(e);             fail(""dequeueOutputBuffer should not return MediaCodec.CodecException""                     + "" on wrong state"");         } catch (IllegalStateException e) { // expected         }          // configure (enter Configured State)          // configure improperly         try {             codec.configure(format, null /* surface */, null /* crypto */,                     isEncoder ? 0 : MediaCodec.CONFIGURE_FLAG_ENCODE /* flags */);             fail(""configure needs MediaCodec.CONFIGURE_FLAG_ENCODE for encoders only"");         } catch (MediaCodec.CodecException e) { // expected             logMediaCodecException(e);         } catch (IllegalStateException e) {             fail(""configure should not return IllegalStateException when improperly configured"");         }         // correct         codec.configure(format, null /* surface */, null /* crypto */,                 isEncoder ? MediaCodec.CONFIGURE_FLAG_ENCODE : 0 /* flags */);          // test a few commands         try {             codec.flush();             fail(""flush should return IllegalStateException when in Configured state"");         } catch (MediaCodec.CodecException e) {             logMediaCodecException(e);             fail(""flush should not return MediaCodec.CodecException on wrong state"");         } catch (IllegalStateException e) { // expected         }         try {             Surface surface = codec.createInputSurface();             if (!isEncoder) {                 fail(""createInputSurface should not work on a decoder"");             }         } catch (IllegalStateException |                  IllegalArgumentException e) { // expected for decoder and audio encoder             if (isVideoEncoder) {                 throw e;             }         }          // test getInputBuffers before start()         try {             ByteBuffer[] buffers = codec.getInputBuffers();             fail(""getInputBuffers called before start() should throw exception"");         } catch (IllegalStateException e) { // expected         }          // start codec (enter Executing state)         codec.start();          // test getInputBuffers after start()         try {             ByteBuffer[] buffers = codec.getInputBuffers();             if (buffers == null) {                 fail(""getInputBuffers called after start() should not return null"");             }             if (isVideoEncoder && buffers.length > 0) {                 fail(""getInputBuffers returned non-zero length array with input surface"");             }         } catch (IllegalStateException e) {             fail(""getInputBuffers called after start() shouldn't throw exception"");         }          // test a few commands         try {             codec.configure(format, null /* surface */, null /* crypto */, 0 /* flags */);             fail(""configure should return IllegalStateException when in Executing state"");         } catch (MediaCodec.CodecException e) {             logMediaCodecException(e);             // TODO: consider configuring after a flush.             fail(""configure should not return MediaCodec.CodecException on wrong state"");         } catch (IllegalStateException e) { // expected         }         if (mIsAtLeastR) {             try {                 codec.getQueueRequest(0);                 fail(""getQueueRequest should throw IllegalStateException when not configured with "" +                         ""CONFIGURE_FLAG_USE_BLOCK_MODEL"");             } catch (MediaCodec.CodecException e) {                 logMediaCodecException(e);                 fail(""getQueueRequest should not return "" +                         ""MediaCodec.CodecException on wrong configuration"");             } catch (IllegalStateException e) { // expected             }             try {                 codec.getOutputFrame(0);                 fail(""getOutputFrame should throw IllegalStateException when not configured with "" +                         ""CONFIGURE_FLAG_USE_BLOCK_MODEL"");             } catch (MediaCodec.CodecException e) {                 logMediaCodecException(e);                 fail(""getOutputFrame should not return MediaCodec.CodecException on wrong "" +                         ""configuration"");             } catch (IllegalStateException e) { // expected             }         }          // two flushes should be fine.         codec.flush();         codec.flush();          // stop codec (enter Initialized state)         // two stops should be fine.         codec.stop();         codec.stop();          // release codec (enter Uninitialized state)         // two releases should be fine.         codec.release();         codec.release();          try {             codecInfo = codec.getCodecInfo();             fail(""getCodecInfo should should return IllegalStateException"" +                     "" when in Uninitialized state"");         } catch (MediaCodec.CodecException e) {             logMediaCodecException(e);             fail(""getCodecInfo should not return MediaCodec.CodecException on wrong state"");         } catch (IllegalStateException e) { // expected         }         try {             codec.stop();             fail(""stop should return IllegalStateException when in Uninitialized state"");         } catch (MediaCodec.CodecException e) {             logMediaCodecException(e);             fail(""stop should not return MediaCodec.CodecException on wrong state"");         } catch (IllegalStateException e) { // expected         }          if (mIsAtLeastR) {             // recreate             codec = createCodecByType(format.getString(MediaFormat.KEY_MIME), isEncoder);              if (isVideoEncoder) {                 format.setInteger(MediaFormat.KEY_COLOR_FORMAT,                         MediaCodecInfo.CodecCapabilities.COLOR_FormatYUV420Flexible);             }              // configure improperly             try {                 codec.configure(format, null /* surface */, null /* crypto */,                         MediaCodec.CONFIGURE_FLAG_USE_BLOCK_MODEL |                         (isEncoder ? MediaCodec.CONFIGURE_FLAG_ENCODE : 0) /* flags */);                 fail(""configure with detached buffer mode should be done after setCallback"");             } catch (MediaCodec.CodecException e) {                 logMediaCodecException(e);                 fail(""configure should not return IllegalStateException when improperly configured"");             } catch (IllegalStateException e) { // expected             }              final LinkedBlockingQueue<Integer> inputQueue = new LinkedBlockingQueue<>();             codec.setCallback(new MediaCodec.Callback() {                 @Override                 public void onInputBufferAvailable(MediaCodec codec, int index) {                     inputQueue.offer(index);                 }                 @Override                 public void onOutputBufferAvailable(                         MediaCodec codec, int index, MediaCodec.BufferInfo info) { }                 @Override                 public void onOutputFormatChanged(MediaCodec codec, MediaFormat format) { }                 @Override                 public void onError(MediaCodec codec, CodecException e) { }             });              // configure with CONFIGURE_FLAG_USE_BLOCK_MODEL (enter Configured State)             codec.configure(format, null /* surface */, null /* crypto */,                     MediaCodec.CONFIGURE_FLAG_USE_BLOCK_MODEL |                     (isEncoder ? MediaCodec.CONFIGURE_FLAG_ENCODE : 0) /* flags */);              // start codec (enter Executing state)             codec.start();              // grab input index (this should happen immediately)             Integer index = null;             try {                 index = inputQueue.poll(2, TimeUnit.SECONDS);             } catch (InterruptedException e) {             }             assertNotNull(index);              // test a few commands             try {                 codec.getInputBuffers();                 fail(""getInputBuffers called in detached buffer mode should throw exception"");             } catch (MediaCodec.IncompatibleWithBlockModelException e) { // expected             }             try {                 codec.getOutputBuffers();                 fail(""getOutputBuffers called in detached buffer mode should throw exception"");             } catch (MediaCodec.IncompatibleWithBlockModelException e) { // expected             }             try {                 codec.getInputBuffer(index);                 fail(""getInputBuffer called in detached buffer mode should throw exception"");             } catch (MediaCodec.IncompatibleWithBlockModelException e) { // expected             }             try {                 codec.dequeueInputBuffer(0);                 fail(""dequeueInputBuffer called in detached buffer mode should throw exception"");             } catch (MediaCodec.IncompatibleWithBlockModelException e) { // expected             }             MediaCodec.BufferInfo info = new MediaCodec.BufferInfo();             try {                 codec.dequeueOutputBuffer(info, 0);                 fail(""dequeueOutputBuffer called in detached buffer mode should throw exception"");             } catch (MediaCodec.IncompatibleWithBlockModelException e) { // expected             }              // test getQueueRequest             MediaCodec.QueueRequest request = codec.getQueueRequest(index);             try {                 request.queue();                 fail(""QueueRequest should throw IllegalStateException when no buffer is set"");             } catch (IllegalStateException e) { // expected             }             // setting a block             String[] names = new String[]{ codec.getName() };             request.setLinearBlock(MediaCodec.LinearBlock.obtain(1, names), 0, 0);             // setting additional block should fail             try (HardwareBuffer buffer = HardwareBuffer.create(                     16 /* width */,                     16 /* height */,                     HardwareBuffer.YCBCR_420_888,                     1 /* layers */,                     HardwareBuffer.USAGE_CPU_READ_OFTEN | HardwareBuffer.USAGE_CPU_WRITE_OFTEN)) {                 request.setHardwareBuffer(buffer);                 fail(""QueueRequest should throw IllegalStateException multiple blocks are set."");             } catch (IllegalStateException e) { // expected             }         }          // release codec         codec.release();          return true;     }      /**      * Tests:      * <br> calling createInputSurface() before configure() throws exception      * <br> calling createInputSurface() after start() throws exception      * <br> calling createInputSurface() with a non-Surface color format is not required to throw exception      */"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.media.cts.MediaCodecTest"	"testReconfigureWithoutSurface"	"CtsMediaTestCases"	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	"v4"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/media/src/android/media/cts/MediaCodecTest.java"	""	"public void testReconfigureWithoutSurface() {         if (!supportsCodec(MIME_TYPE, true)) {             Log.i(TAG, ""No encoder found for mimeType= "" + MIME_TYPE);             return;         }          MediaFormat format = createMediaFormat();         MediaCodec encoder = null;         Surface surface = null;          try {             try {                 encoder = MediaCodec.createEncoderByType(MIME_TYPE);             } catch (IOException e) {                 fail(""failed to create "" + MIME_TYPE + "" encoder"");             }             encoder.configure(format, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE);             surface = encoder.createInputSurface();             encoder.start();              encoder.getOutputBuffers();              // re-configure, this time without an input surface             if (VERBOSE) Log.d(TAG, ""reconfiguring"");             encoder.stop();             // Use non-opaque color format for byte buffer mode.             format.setInteger(MediaFormat.KEY_COLOR_FORMAT,                     MediaCodecInfo.CodecCapabilities.COLOR_FormatYUV420Flexible);             encoder.configure(format, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE);             encoder.start();             if (VERBOSE) Log.d(TAG, ""reconfigured"");              encoder.getOutputBuffers();             encoder.dequeueInputBuffer(-1);              try {                 encoder.signalEndOfInputStream();                 fail(""signalEndOfInputStream only works on surface input"");             } catch (IllegalStateException ise) {                 // good             }              PersistableBundle metrics = encoder.getMetrics();             if (metrics == null) {                 fail(""getMetrics() returns null"");             } else if (metrics.isEmpty()) {                 fail(""getMetrics() returns empty results"");             }             int encoding = metrics.getInt(MediaCodec.MetricsConstants.ENCODER, -1);             if (encoding != 1) {                 fail(""getMetrics() returns bad encoder value "" + encoding);             }             String theCodec = metrics.getString(MediaCodec.MetricsConstants.CODEC, null);             if (theCodec == null) {                 fail(""getMetrics() returns null codec value "");             }          } finally {             if (encoder != null) {                 encoder.stop();                 encoder.release();             }             if (surface != null) {                 surface.release();             }         }     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"com.android.cts.devicepolicy.LimitAppIconHidingTest"	"uninstallTestApps"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/LimitAppIconHidingTest.java"	""	"/*  *.  */  package com.android.cts.devicepolicy;  import org.junit.Test;  import java.util.Collections;  /**  * Set of tests for the limit app icon hiding feature.  */ public class LimitAppIconHidingTest extends BaseLauncherAppsTest {      private static final String LAUNCHER_TESTS_HAS_LAUNCHER_ACTIVITY_APK =             ""CtsHasLauncherActivityApp.apk"";     private static final String LAUNCHER_TESTS_NO_LAUNCHER_ACTIVITY_APK =             ""CtsNoLauncherActivityApp.apk"";     private static final String LAUNCHER_TESTS_NO_PERMISSION_APK =             ""CtsNoPermissionApp.apk"";      private boolean mHasLauncherApps;     private String mSerialNumber;     private int mCurrentUserId;      @Override     public void setUp() throws Exception {         super.setUp();         mHasLauncherApps = getDevice().getApiLevel() >= 21;          if (mHasLauncherApps) {             mCurrentUserId = getDevice().getCurrentUser();             mSerialNumber = Integer.toString(getUserSerialNumber(mCurrentUserId));             uninstallTestApps();             installTestApps(mCurrentUserId);         }     }      @Override     public void tearDown() throws Exception {         if (mHasLauncherApps) {             uninstallTestApps();         }         super.tearDown();     }      @Override     protected void installTestApps(int userId) throws Exception {         super.installTestApps(mCurrentUserId);         installAppAsUser(LAUNCHER_TESTS_HAS_LAUNCHER_ACTIVITY_APK, mCurrentUserId);         installAppAsUser(LAUNCHER_TESTS_NO_LAUNCHER_ACTIVITY_APK, mCurrentUserId);         installAppAsUser(LAUNCHER_TESTS_NO_PERMISSION_APK, mCurrentUserId);     }      @Override     protected void uninstallTestApps() throws Exception {         super.uninstallTestApps();         getDevice().uninstallPackage(LAUNCHER_TESTS_NO_PERMISSION_APK);         getDevice().uninstallPackage(LAUNCHER_TESTS_NO_LAUNCHER_ACTIVITY_APK);         getDevice().uninstallPackage(LAUNCHER_TESTS_HAS_LAUNCHER_ACTIVITY_APK);     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.mediav2.cts.EncoderColorAspectsTest"	"isEncoder"	"CtsMediaTestCases"	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	"v4"	""	""	""	"/home/gpoor/cts-source/cts/tests/media/src/android/mediav2/cts/EncoderColorAspectsTest.java"	""	"/*  *.  */  package android.mediav2.cts;  import android.media.MediaCodec; import android.media.MediaCodecInfo; import android.media.MediaCodecList; import android.media.MediaFormat; import android.media.MediaMuxer; import android.os.Build; import android.util.Log;  import androidx.test.filters.SmallTest;  import org.junit.Test; import org.junit.runner.RunWith; import org.junit.runners.Parameterized;  import java.io.File; import java.io.IOException; import java.nio.ByteBuffer; import java.util.ArrayList; import java.util.Collection; import java.util.List;  import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertTrue;  /**  * Validate ColorAspects configuration for listed encoder components  */ @RunWith(Parameterized.class) public class EncoderColorAspectsTest extends CodecEncoderTestBase {     private static final String LOG_TAG = EncoderColorAspectsTest.class.getSimpleName();     private static final int UNSPECIFIED = 0;      private int mRange;     private int mStandard;     private int mTransferCurve;     private MediaFormat mConfigFormat;      private MediaMuxer mMuxer;     private int mTrackID = -1;      private ArrayList<MediaCodec.BufferInfo> mInfoList = new ArrayList<>();      private ArrayList<String> mCheckESList = new ArrayList<>();      public EncoderColorAspectsTest(String mime, int width, int height, int range, int standard,             int transferCurve) {         super(mime);         mRange = range;         mStandard = standard;         mTransferCurve = transferCurve;         mConfigFormat = new MediaFormat();         mConfigFormat.setString(MediaFormat.KEY_MIME, mMime);         mConfigFormat.setInteger(MediaFormat.KEY_BIT_RATE, 64000);         mWidth = width;         mHeight = height;         mConfigFormat.setInteger(MediaFormat.KEY_WIDTH, mWidth);         mConfigFormat.setInteger(MediaFormat.KEY_HEIGHT, mHeight);         mConfigFormat.setInteger(MediaFormat.KEY_FRAME_RATE, mFrameRate);         mConfigFormat.setFloat(MediaFormat.KEY_I_FRAME_INTERVAL, 1.0f);         mConfigFormat.setInteger(MediaFormat.KEY_COLOR_FORMAT,                 MediaCodecInfo.CodecCapabilities.COLOR_FormatYUV420Flexible);         if (mRange >= 0) mConfigFormat.setInteger(MediaFormat.KEY_COLOR_RANGE, mRange);         else mRange = 0;         if (mStandard >= 0) mConfigFormat.setInteger(MediaFormat.KEY_COLOR_STANDARD, mStandard);         else mStandard = 0;         if (mTransferCurve >= 0)             mConfigFormat.setInteger(MediaFormat.KEY_COLOR_TRANSFER, mTransferCurve);         else mTransferCurve = 0;         mCheckESList.add(MediaFormat.MIMETYPE_VIDEO_AVC);         mCheckESList.add(MediaFormat.MIMETYPE_VIDEO_HEVC);     }      void dequeueOutput(int bufferIndex, MediaCodec.BufferInfo info) {         if (info.size > 0) {             ByteBuffer buf = mCodec.getOutputBuffer(bufferIndex);             if (mMuxer != null) {                 if (mTrackID == -1) {                     mTrackID = mMuxer.addTrack(mCodec.getOutputFormat());                     mMuxer.start();                 }                 mMuxer.writeSampleData(mTrackID, buf, info);             }             MediaCodec.BufferInfo copy = new MediaCodec.BufferInfo();             copy.set(mOutputBuff.getOutStreamSize(), info.size, info.presentationTimeUs,                     info.flags);             mInfoList.add(copy);         }         super.dequeueOutput(bufferIndex, info);     }      @Parameterized.Parameters(name = ""{index}({0}{3}{4}{5})"")     public static Collection<Object[]> input() {         ArrayList<String> testMimeList = new ArrayList<>();         testMimeList.add(MediaFormat.MIMETYPE_VIDEO_AVC);         testMimeList.add(MediaFormat.MIMETYPE_VIDEO_HEVC);         testMimeList.add(MediaFormat.MIMETYPE_VIDEO_VP8);         testMimeList.add(MediaFormat.MIMETYPE_VIDEO_VP9);         ArrayList<String> mimes = new ArrayList<>();         if (CodecTestBase.codecSelKeys.contains(CodecTestBase.CODEC_SEL_VALUE)) {             MediaCodecList codecList = new MediaCodecList(MediaCodecList.REGULAR_CODECS);             MediaCodecInfo[] codecInfos = codecList.getCodecInfos();             for (MediaCodecInfo codecInfo : codecInfos) {                 if (!codecInfo.isEncoder()) continue;                 if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q && codecInfo.isAlias()) continue;                 String[] types = codecInfo.getSupportedTypes();                 for (String type : types) {                     if (testMimeList.contains(type) && !mimes.contains(type)) {                         mimes.add(type);                     }                 }             }         }         int[] ranges =                 {-1, UNSPECIFIED, MediaFormat.COLOR_RANGE_FULL, MediaFormat.COLOR_RANGE_LIMITED};         int[] standards =                 {-1, UNSPECIFIED, MediaFormat.COLOR_STANDARD_BT709,                         MediaFormat.COLOR_STANDARD_BT601_PAL,                         MediaFormat.COLOR_STANDARD_BT601_NTSC, MediaFormat.COLOR_STANDARD_BT2020};         int[] transfers =                 {-1, UNSPECIFIED, MediaFormat.COLOR_TRANSFER_LINEAR, MediaFormat.COLOR_TRANSFER_SDR_VIDEO};         // TODO: COLOR_TRANSFER_ST2084, COLOR_TRANSFER_HLG are for 10 bit and above. Should these         //  be tested as well?         List<Object[]> exhaustiveArgsList = new ArrayList<>();         // Assumes all combinations are supported by the standard         for (String mime : mimes) {             for (int range : ranges) {                 for (int standard : standards) {                     for (int transfer : transfers) {                         exhaustiveArgsList                                 .add(new Object[]{mime, 176, 144, range, standard, transfer});                     }                 }             }         }         return exhaustiveArgsList;     }      @SmallTest"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.extractnativelibs.cts.CtsExtractNativeLibsHostTestIncremental"	"testExtractNativeLibsIncrementalFails"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	"v4"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/packagemanager/extractnativelibs/src/android/extractnativelibs/cts/CtsExtractNativeLibsHostTestIncremental.java"	""	"@AppModeFull     public void testExtractNativeLibsIncrementalFails() throws Exception {         String result = installIncrementalPackageFromResource(TEST_NO_EXTRACT_MISALIGNED_APK);         assertTrue(result.contains(""Failed to extract native libraries""));         assertFalse(isPackageInstalled(TEST_NO_EXTRACT_PKG));     }      private void installPackageIncremental(String apkName) throws Exception {         CompatibilityBuildHelper buildHelper = new CompatibilityBuildHelper(getBuild());         final File apk = buildHelper.getTestFile(apkName);         assertNotNull(apk);         final File v4Signature = buildHelper.getTestFile(apkName + IDSIG_SUFFIX);         assertNotNull(v4Signature);         installPackageIncrementalFromFiles(apk, v4Signature);     }      private String installPackageIncrementalFromFiles(File apk, File v4Signature) throws Exception {         final String remoteApkPath = TEST_REMOTE_DIR + ""/"" + apk.getName();         final String remoteIdsigPath = remoteApkPath + IDSIG_SUFFIX;         assertTrue(getDevice().pushFile(apk, remoteApkPath));         assertTrue(getDevice().pushFile(v4Signature, remoteIdsigPath));         return getDevice().executeShellCommand(""pm install-incremental -t -g "" + remoteApkPath);     }      private String installIncrementalPackageFromResource(String apkFilenameInRes)             throws Exception {         final File apkFile = getFileFromResource(apkFilenameInRes);         final File v4SignatureFile = getFileFromResource(                 apkFilenameInRes + IDSIG_SUFFIX);         return installPackageIncrementalFromFiles(apkFile, v4SignatureFile);     } }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.net.cts.Ikev2VpnTest"	"Ikev2VpnTest"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	"v4"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/Ikev2VpnTest.java"	""	"/*  *.  */  package android.net.cts;  import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET; import static android.net.NetworkCapabilities.TRANSPORT_VPN; import static android.net.cts.util.CtsNetUtils.TestNetworkCallback;  import static com.android.compatibility.common.util.SystemUtil.runWithShellPermissionIdentity;  import static org.junit.Assert.assertArrayEquals; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail; import static org.junit.Assume.assumeTrue;  import android.Manifest; import android.annotation.NonNull; import android.app.AppOpsManager; import android.content.Context; import android.content.Intent; import android.net.ConnectivityManager; import android.net.Ikev2VpnProfile; import android.net.IpSecAlgorithm; import android.net.LinkAddress; import android.net.Network; import android.net.NetworkCapabilities; import android.net.NetworkRequest; import android.net.ProxyInfo; import android.net.TestNetworkInterface; import android.net.TestNetworkManager; import android.net.VpnManager; import android.net.cts.util.CtsNetUtils; import android.os.Build; import android.os.Process; import android.platform.test.annotations.AppModeFull;  import androidx.test.InstrumentationRegistry;  import com.android.internal.util.HexDump; import com.android.org.bouncycastle.x509.X509V1CertificateGenerator; import com.android.testutils.DevSdkIgnoreRule.IgnoreUpTo; import com.android.testutils.DevSdkIgnoreRunner;  import org.junit.After; import org.junit.Test; import org.junit.runner.RunWith;  import java.math.BigInteger; import java.net.InetAddress; import java.security.KeyPair; import java.security.KeyPairGenerator; import java.security.PrivateKey; import java.security.cert.X509Certificate; import java.util.Arrays; import java.util.Date; import java.util.List; import java.util.concurrent.TimeUnit;  import javax.security.auth.x500.X500Principal;  @RunWith(DevSdkIgnoreRunner.class) @IgnoreUpTo(Build.VERSION_CODES.Q) @AppModeFull(reason = ""Appops state changes disallowed for instant apps (OP_ACTIVATE_PLATFORM_VPN)"") public class Ikev2VpnTest {     private static final String TAG = Ikev2VpnTest.class.getSimpleName();      // Test vectors for IKE negotiation in test mode.     private static final String SUCCESSFUL_IKE_INIT_RESP_V4 =             ""46b8eca1e0d72a18b2b5d9006d47a0022120222000000000000002d0220000300000002c01010004030000""                     + ""0c0100000c800e0100030000080300000c030000080200000400000008040000102800020800""                     + ""100000b8070f159fe5141d8754ca86f72ecc28d66f514927e96cbe9eec0adb42bf2c276a0ab7""                     + ""a97fa93555f4be9218c14e7f286bb28c6b4fb13825a420f2ffc165854f200bab37d69c8963d4""                     + ""0acb831d983163aa50622fd35c182efe882cf54d6106222abcfaa597255d302f1b95ab71c142""                     + ""c279ea5839a180070bff73f9d03fab815f0d5ee2adec7e409d1e35979f8bd92ffd8aab13d1a0""                     + ""0657d816643ae767e9ae84d2ccfa2bcce1a50572be8d3748ae4863c41ae90da16271e014270f""                     + ""77edd5cd2e3299f3ab27d7203f93d770bacf816041cdcecd0f9af249033979da4369cb242dd9""                     + ""6d172e60513ff3db02de63e50eb7d7f596ada55d7946cad0af0669d1f3e2804846ab3f2a930d""                     + ""df56f7f025f25c25ada694e6231abbb87ee8cfd072c8481dc0b0f6b083fdc3bd89b080e49feb""                     + ""0288eef6fdf8a26ee2fc564a11e7385215cf2deaf2a9965638fc279c908ccdf04094988d91a2""                     + ""464b4a8c0326533aff5119ed79ecbd9d99a218b44f506a5eb09351e67da86698b4c58718db25""                     + ""d55f426fb4c76471b27a41fbce00777bc233c7f6e842e39146f466826de94f564cad8b92bfbe""                     + ""87c99c4c7973ec5f1eea8795e7da82819753aa7c4fcfdab77066c56b939330c4b0d354c23f83""                     + ""ea82fa7a64c4b108f1188379ea0eb4918ee009d804100e6bf118771b9058d42141c847d5ec37""                     + ""6e5ec591c71fc9dac01063c2bd31f9c783b28bf1182900002430f3d5de3449462b31dd28bc27""                     + ""297b6ad169bccce4f66c5399c6e0be9120166f2900001c0000400428b8df2e66f69c8584a186""                     + ""c5eac66783551d49b72900001c000040054e7a622e802d5cbfb96d5f30a6e433994370173529""                     + ""0000080000402e290000100000402f00020003000400050000000800004014"";     private static final String SUCCESSFUL_IKE_INIT_RESP_V6 =             ""46b8eca1e0d72a1800d9ea1babce26bf2120222000000000000002d0220000300000002c01010004030000""                     + ""0c0100000c800e0100030000080300000c030000080200000400000008040000102800020800""                     + ""100000ea0e6dd9ca5930a9a45c323a41f64bfd8cdef7730f5fbff37d7c377da427f489a42aa8""                     + ""c89233380e6e925990d49de35c2cdcf63a61302c731a4b3569df1ee1bf2457e55a6751838ede""                     + ""abb75cc63ba5c9e4355e8e784f383a5efe8a44727dc14aeaf8dacc2620fb1c8875416dc07739""                     + ""7fe4decc1bd514a9c7d270cf21fd734c63a25c34b30b68686e54e8a198f37f27cb491fe27235""                     + ""fab5476b036d875ccab9a68d65fbf3006197f9bebbf94de0d3802b4fafe1d48d931ce3a1a346""                     + ""2d65bd639e9bd7fa46299650a9dbaf9b324e40b466942d91a59f41ef8042f8474c4850ed0f63""                     + ""e9238949d41cd8bbaea9aefdb65443a6405792839563aa5dc5c36b5ce8326ccf8a94d9622b85""                     + ""038d390d5fc0299e14e1f022966d4ac66515f6108ca04faec44821fe5bbf2ed4f84ff5671219""                     + ""608cb4c36b44a31ba010c9088f8d5ff943bb9ff857f74be1755f57a5783874adc57f42bb174e""                     + ""4ad3215de628707014dbcb1707bd214658118fdd7a42b3e1638b991ce5b812a667f1145be811""                     + ""685e3cd3baf9b18d062657b64c206a4d19a531c252a6a51a04aeaf42c618620cdbab65baca23""                     + ""82c57ed888422aeaacf7f1bc3fe2247ff7e7eaca218b74d7b31d02f2b0afa123f802529e7e6c""                     + ""3259d418290740ddbf55686e26998d7edcbbf895664972fed666f2f20af40503aa2af436ec6d""                     + ""4ec981ab19b9088755d94ae7a7c2066ea331d4e56e290000243fefe5555fce552d57a84e682c""                     + ""d4a6dfb3f2f94a94464d5bec3d88b88e9559642900001c00004004eb4afff764e7b79bca78b1""                     + ""3a89100d36d678ae982900001c00004005d177216a3c26f782076e12570d40bfaaa148822929""                     + ""0000080000402e290000100000402f00020003000400050000000800004014"";     private static final String SUCCESSFUL_IKE_AUTH_RESP_V4 =             ""46b8eca1e0d72a18b2b5d9006d47a0022e20232000000001000000e0240000c420a2500a3da4c66fa6929e""                     + ""600f36349ba0e38de14f78a3ad0416cba8c058735712a3d3f9a0a6ed36de09b5e9e02697e7c4""                     + ""2d210ac86cfbd709503cfa51e2eab8cfdc6427d136313c072968f6506a546eb5927164200592""                     + ""6e36a16ee994e63f029432a67bc7d37ca619e1bd6e1678df14853067ecf816b48b81e8746069""                     + ""406363e5aa55f13cb2afda9dbebee94256c29d630b17dd7f1ee52351f92b6e1c3d8551c513f1""                     + ""d74ac52a80b2041397e109fe0aeb3c105b0d4be0ae343a943398764281"";     private static final String SUCCESSFUL_IKE_AUTH_RESP_V6 =             ""46b8eca1e0d72a1800d9ea1babce26bf2e20232000000001000000f0240000d4aaf6eaa6c06b50447e6f54""                     + ""827fd8a9d9d6ac8015c1ebb3e8cb03fc6e54b49a107441f50004027cc5021600828026367f03""                     + ""bc425821cd7772ee98637361300c9b76056e874fea2bd4a17212370b291894264d8c023a01d1""                     + ""c3b691fd4b7c0b534e8c95af4c4638e2d125cb21c6267e2507cd745d72e8da109c47b9259c6c""                     + ""57a26f6bc5b337b9b9496d54bdde0333d7a32e6e1335c9ee730c3ecd607a8689aa7b0577b74f""                     + ""3bf437696a9fd5fc0aee3ed346cd9e15d1dda293df89eb388a8719388a60ca7625754de12cdb""                     + ""efe4c886c5c401"";     private static final long IKE_INITIATOR_SPI = Long.parseLong(""46B8ECA1E0D72A18"", 16);      private static final InetAddress LOCAL_OUTER_4 = InetAddress.parseNumericAddress(""192.0.2.1"");     private static final InetAddress LOCAL_OUTER_6 =             InetAddress.parseNumericAddress(""2001:db8::1"");      private static final int IP4_PREFIX_LEN = 32;     private static final int IP6_PREFIX_LEN = 128;      // TODO: Use IPv6 address when we can generate test vectors (GCE does not allow IPv6 yet).     private static final String TEST_SERVER_ADDR_V4 = ""192.0.2.2"";     private static final String TEST_SERVER_ADDR_V6 = ""2001:db8::2"";     private static final String TEST_IDENTITY = ""client.cts.android.com"";     private static final List<String> TEST_ALLOWED_ALGORITHMS =             Arrays.asList(IpSecAlgorithm.AUTH_CRYPT_AES_GCM);      private static final ProxyInfo TEST_PROXY_INFO =             ProxyInfo.buildDirectProxy(""proxy.cts.android.com"", 1234);     private static final int TEST_MTU = 1300;      private static final byte[] TEST_PSK = ""ikeAndroidPsk"".getBytes();     private static final String TEST_USER = ""username"";     private static final String TEST_PASSWORD = ""pa55w0rd"";      // Static state to reduce setup/teardown     private static final Context sContext = InstrumentationRegistry.getContext();     private static final ConnectivityManager sCM =             (ConnectivityManager) sContext.getSystemService(Context.CONNECTIVITY_SERVICE);     private static final VpnManager sVpnMgr =             (VpnManager) sContext.getSystemService(Context.VPN_MANAGEMENT_SERVICE);     private static final CtsNetUtils mCtsNetUtils = new CtsNetUtils(sContext);      private final X509Certificate mServerRootCa;     private final CertificateAndKey mUserCertKey;      public Ikev2VpnTest() throws Exception {         // Build certificates         mServerRootCa = generateRandomCertAndKeyPair().cert;         mUserCertKey = generateRandomCertAndKeyPair();     }      @After     public void tearDown() {         setAppop(AppOpsManager.OP_ACTIVATE_VPN, false);         setAppop(AppOpsManager.OP_ACTIVATE_PLATFORM_VPN, false);     }      /**      * Sets the given appop using shell commands      *      * <p>This method must NEVER be called from within a shell permission, as it will attempt to      * acquire, and then drop the shell permission identity. This results in the caller losing the      * shell permission identity due to these calls not being reference counted.      */     public void setAppop(int appop, boolean allow) {         // Requires shell permission to update appops.         runWithShellPermissionIdentity(() -> {             mCtsNetUtils.setAppopPrivileged(appop, allow);         }, Manifest.permission.MANAGE_TEST_NETWORKS);     }      private Ikev2VpnProfile buildIkev2VpnProfileCommon(             Ikev2VpnProfile.Builder builder, boolean isRestrictedToTestNetworks) throws Exception {         if (isRestrictedToTestNetworks) {             builder.restrictToTestNetworks();         }          return builder.setBypassable(true)                 .setAllowedAlgorithms(TEST_ALLOWED_ALGORITHMS)                 .setProxy(TEST_PROXY_INFO)                 .setMaxMtu(TEST_MTU)                 .setMetered(false)                 .build();     }      private Ikev2VpnProfile buildIkev2VpnProfilePsk(boolean isRestrictedToTestNetworks)             throws Exception {         return buildIkev2VpnProfilePsk(TEST_SERVER_ADDR_V6, isRestrictedToTestNetworks);     }      private Ikev2VpnProfile buildIkev2VpnProfilePsk(             String remote, boolean isRestrictedToTestNetworks) throws Exception {         final Ikev2VpnProfile.Builder builder =                 new Ikev2VpnProfile.Builder(remote, TEST_IDENTITY).setAuthPsk(TEST_PSK);          return buildIkev2VpnProfileCommon(builder, isRestrictedToTestNetworks);     }      private Ikev2VpnProfile buildIkev2VpnProfileUsernamePassword(boolean isRestrictedToTestNetworks)             throws Exception {         final Ikev2VpnProfile.Builder builder =                 new Ikev2VpnProfile.Builder(TEST_SERVER_ADDR_V6, TEST_IDENTITY)                         .setAuthUsernamePassword(TEST_USER, TEST_PASSWORD, mServerRootCa);          return buildIkev2VpnProfileCommon(builder, isRestrictedToTestNetworks);     }      private Ikev2VpnProfile buildIkev2VpnProfileDigitalSignature(boolean isRestrictedToTestNetworks)             throws Exception {         final Ikev2VpnProfile.Builder builder =                 new Ikev2VpnProfile.Builder(TEST_SERVER_ADDR_V6, TEST_IDENTITY)                         .setAuthDigitalSignature(                                 mUserCertKey.cert, mUserCertKey.key, mServerRootCa);          return buildIkev2VpnProfileCommon(builder, isRestrictedToTestNetworks);     }      private void checkBasicIkev2VpnProfile(@NonNull Ikev2VpnProfile profile) throws Exception {         assertEquals(TEST_SERVER_ADDR_V6, profile.getServerAddr());         assertEquals(TEST_IDENTITY, profile.getUserIdentity());         assertEquals(TEST_PROXY_INFO, profile.getProxyInfo());         assertEquals(TEST_ALLOWED_ALGORITHMS, profile.getAllowedAlgorithms());         assertTrue(profile.isBypassable());         assertFalse(profile.isMetered());         assertEquals(TEST_MTU, profile.getMaxMtu());         assertFalse(profile.isRestrictedToTestNetworks());     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.net.cts.Ikev2VpnTest"	"testStartVpnProfileNoPreviousConsent"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	"v4"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/Ikev2VpnTest.java"	""	"public void testStartVpnProfileNoPreviousConsent() throws Exception {         assumeTrue(mCtsNetUtils.hasIpsecTunnelsFeature());          setAppop(AppOpsManager.OP_ACTIVATE_VPN, false);         setAppop(AppOpsManager.OP_ACTIVATE_PLATFORM_VPN, false);          // Make sure the VpnProfile is not provisioned already.         sVpnMgr.stopProvisionedVpnProfile();          try {             sVpnMgr.startProvisionedVpnProfile();             fail(""Expected SecurityException for missing consent"");         } catch (SecurityException expected) {         }     }      private void checkStartStopVpnProfileBuildsNetworks(IkeTunUtils tunUtils, boolean testIpv6)             throws Exception {         String serverAddr = testIpv6 ? TEST_SERVER_ADDR_V6 : TEST_SERVER_ADDR_V4;         String initResp = testIpv6 ? SUCCESSFUL_IKE_INIT_RESP_V6 : SUCCESSFUL_IKE_INIT_RESP_V4;         String authResp = testIpv6 ? SUCCESSFUL_IKE_AUTH_RESP_V6 : SUCCESSFUL_IKE_AUTH_RESP_V4;         boolean hasNat = !testIpv6;          // Requires MANAGE_TEST_NETWORKS to provision a test-mode profile.         mCtsNetUtils.setAppopPrivileged(AppOpsManager.OP_ACTIVATE_PLATFORM_VPN, true);          final Ikev2VpnProfile profile =                 buildIkev2VpnProfilePsk(serverAddr, true /* isRestrictedToTestNetworks */);         assertNull(sVpnMgr.provisionVpnProfile(profile));          sVpnMgr.startProvisionedVpnProfile();          // Inject IKE negotiation         int expectedMsgId = 0;         tunUtils.awaitReqAndInjectResp(IKE_INITIATOR_SPI, expectedMsgId++, false /* isEncap */,                 HexDump.hexStringToByteArray(initResp));         tunUtils.awaitReqAndInjectResp(IKE_INITIATOR_SPI, expectedMsgId++, hasNat /* isEncap */,                 HexDump.hexStringToByteArray(authResp));          // Verify the VPN network came up         final NetworkRequest nr = new NetworkRequest.Builder()                 .clearCapabilities().addTransportType(TRANSPORT_VPN).build();          final TestNetworkCallback cb = new TestNetworkCallback();         sCM.requestNetwork(nr, cb);         cb.waitForAvailable();         final Network vpnNetwork = cb.currentNetwork;         assertNotNull(vpnNetwork);          final NetworkCapabilities caps = sCM.getNetworkCapabilities(vpnNetwork);         assertTrue(caps.hasTransport(TRANSPORT_VPN));         assertTrue(caps.hasCapability(NET_CAPABILITY_INTERNET));         assertEquals(Process.myUid(), caps.getOwnerUid());          sVpnMgr.stopProvisionedVpnProfile();         cb.waitForLost();         assertEquals(vpnNetwork, cb.lastLostNetwork);     }      private void doTestStartStopVpnProfile(boolean testIpv6) throws Exception {         // Non-final; these variables ensure we clean up properly after our test if we have         // allocated test network resources         final TestNetworkManager tnm = sContext.getSystemService(TestNetworkManager.class);         TestNetworkInterface testIface = null;         TestNetworkCallback tunNetworkCallback = null;          try {             // Build underlying test network             testIface = tnm.createTunInterface(                     new LinkAddress[] {                             new LinkAddress(LOCAL_OUTER_4, IP4_PREFIX_LEN),                             new LinkAddress(LOCAL_OUTER_6, IP6_PREFIX_LEN)});              // Hold on to this callback to ensure network does not get reaped.             tunNetworkCallback = mCtsNetUtils.setupAndGetTestNetwork(                     testIface.getInterfaceName());             final IkeTunUtils tunUtils = new IkeTunUtils(testIface.getFileDescriptor());              checkStartStopVpnProfileBuildsNetworks(tunUtils, testIpv6);         } finally {             // Make sure to stop the VPN profile. This is safe to call multiple times.             sVpnMgr.stopProvisionedVpnProfile();              if (testIface != null) {                 testIface.getFileDescriptor().close();             }              if (tunNetworkCallback != null) {                 sCM.unregisterNetworkCallback(tunNetworkCallback);             }              final Network testNetwork = tunNetworkCallback.currentNetwork;             if (testNetwork != null) {                 tnm.teardownTestNetwork(testNetwork);             }         }     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.net.cts.Ikev2VpnTest"	"testStartStopVpnProfileV4"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	"v4"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/Ikev2VpnTest.java"	""	"public void testStartStopVpnProfileV4() throws Exception {         assumeTrue(mCtsNetUtils.hasIpsecTunnelsFeature());          // Requires shell permission to update appops.         runWithShellPermissionIdentity(() -> {             doTestStartStopVpnProfile(false);         });     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"com.android.cts.devicepolicy.AccountCheckHostSideTest"	"runCleanupTestOnlyOwnerAllowingFailure"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/AccountCheckHostSideTest.java"	""	"/*  *.  */  package com.android.cts.devicepolicy;  import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail;  import android.platform.test.annotations.LargeTest;  import com.android.tradefed.log.LogUtil.CLog;  import java.util.regex.Matcher; import java.util.regex.Pattern;  import org.junit.Test;  public class AccountCheckHostSideTest extends BaseDevicePolicyTest {     private static final String APK_NON_TEST_ONLY = ""CtsAccountCheckNonTestOnlyOwnerApp.apk"";     private static final String APK_TEST_ONLY = ""CtsAccountCheckTestOnlyOwnerApp.apk"";     private static final String APK_TEST_ONLY_UPDATE = ""CtsAccountCheckTestOnlyOwnerUpdateApp.apk"";     private static final String APK_AUTH = ""CtsAccountCheckAuthApp.apk"";      private static final String PACKAGE_NON_TEST_ONLY =             ""com.android.cts.devicepolicy.accountcheck.nontestonly"";     private static final String PACKAGE_TEST_ONLY =             ""com.android.cts.devicepolicy.accountcheck.testonly"";     private static final String PACKAGE_AUTH = ""com.android.cts.devicepolicy.accountcheck.auth"";      private static final String OWNER_TEST_ONLY = PACKAGE_TEST_ONLY             + ""/com.android.cts.devicepolicy.accountcheck.owner.AdminReceiver"";     private static final String OWNER_NON_TEST_ONLY = PACKAGE_NON_TEST_ONLY             + ""/com.android.cts.devicepolicy.accountcheck.owner.AdminReceiver"";      private static final String TEST_CLASS =             ""com.android.cts.devicepolicy.accountcheck.AccountCheckTest"";      @Override     public void tearDown() throws Exception {         if (mHasFeature) {             if (getDevice().getInstalledPackageNames().contains(PACKAGE_AUTH)) {                 runCleanupTestOnlyOwnerAllowingFailure();                 runCleanupNonTestOnlyOwnerAllowingFailure();                  // This shouldn't be needed since we're uninstalling the authenticator,                 // but sometimes the account manager fails to clean up?                 removeAllAccountsAllowingFailure();             }              getDevice().uninstallPackage(PACKAGE_AUTH);             getDevice().uninstallPackage(PACKAGE_TEST_ONLY);             getDevice().uninstallPackage(PACKAGE_NON_TEST_ONLY);         }         super.tearDown();     }      private void runTest(String method) throws Exception {         runDeviceTests(PACKAGE_AUTH, TEST_CLASS, method);     }      private void runCleanupTestOnlyOwner() throws Exception {         assertTrue(removeAdmin(OWNER_TEST_ONLY, mPrimaryUserId));     }      private void runCleanupTestOnlyOwnerAllowingFailure() throws Exception {         try {             runCleanupTestOnlyOwner();         } catch (AssertionError ignore) {         }     }      private void runCleanupNonTestOnlyOwner() throws Exception {         runTest(""testCleanUpNonTestOwner"");     }      private void runCleanupNonTestOnlyOwnerAllowingFailure() throws Exception {         try {             runCleanupNonTestOnlyOwner();         } catch (AssertionError ignore) {         }     }      private void removeAllAccounts() throws Exception {         runTest(""testRemoveAllAccounts"");     }      private void removeAllAccountsAllowingFailure() throws Exception {         try {             removeAllAccounts();         } catch (AssertionError ignore) {         }     }      private void assertTestOnlyInstallable() throws Exception {         setDeviceOwnerOrFail(OWNER_TEST_ONLY, mPrimaryUserId);         runCleanupTestOnlyOwner();          setProfileOwnerOrFail(OWNER_TEST_ONLY, mPrimaryUserId);         runCleanupTestOnlyOwner();     }      private void assertNonTestOnlyInstallable() throws Exception {         setDeviceOwnerOrFail(OWNER_NON_TEST_ONLY, mPrimaryUserId);         runCleanupNonTestOnlyOwner();          setProfileOwnerOrFail(OWNER_NON_TEST_ONLY, mPrimaryUserId);         runCleanupNonTestOnlyOwner();     }      private void assertTestOnlyNotInstallable() throws Exception {         setDeviceOwnerExpectingFailure(OWNER_TEST_ONLY, mPrimaryUserId);         runCleanupTestOnlyOwnerAllowingFailure();          setProfileOwnerExpectingFailure(OWNER_TEST_ONLY, mPrimaryUserId);         runCleanupTestOnlyOwnerAllowingFailure();     }      private void assertNonTestOnlyNotInstallable() throws Exception {         setDeviceOwnerExpectingFailure(OWNER_NON_TEST_ONLY, mPrimaryUserId);         runCleanupNonTestOnlyOwnerAllowingFailure();          setProfileOwnerExpectingFailure(OWNER_NON_TEST_ONLY, mPrimaryUserId);         runCleanupNonTestOnlyOwnerAllowingFailure();     }      private boolean hasAccounts() throws Exception {         final String accountDump = getDevice().executeShellCommand(""dumpsys account"");          final Pattern p = Pattern.compile(""^\\s*Accounts\\:\\s*(\\d+)"", Pattern.MULTILINE);         final Matcher m = p.matcher(accountDump);         if (!m.find()) {             fail(""Unable to obtain # of accounts"");             return true;         }         final String count = m.group(1);          CLog.i(""# of preconfigured accounts="" + count);          return Integer.parseInt(count) > 0;     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.content.pm.cts.PackageManagerShellCommandTest"	"isAllowed"	"CtsContentTestCases"	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/content/src/android/content/pm/cts/PackageManagerShellCommandTest.java"	""	"/*  *.  */  package android.content.pm.cts;  import static android.content.pm.PackageInstaller.DATA_LOADER_TYPE_INCREMENTAL; import static android.content.pm.PackageInstaller.DATA_LOADER_TYPE_NONE; import static android.content.pm.PackageInstaller.DATA_LOADER_TYPE_STREAMING; import static android.content.pm.PackageInstaller.LOCATION_DATA_APP;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertTrue;  import android.app.UiAutomation; import android.content.ComponentName; import android.content.pm.DataLoaderParams; import android.content.pm.PackageInstaller; import android.content.pm.PackageInstaller.SessionParams; import android.os.ParcelFileDescriptor; import android.os.incremental.IncrementalManager; import android.platform.test.annotations.AppModeFull;  import androidx.test.InstrumentationRegistry;  import org.junit.After; import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith; import org.junit.runners.Parameterized; import org.junit.runners.Parameterized.Parameter; import org.junit.runners.Parameterized.Parameters;  import java.io.ByteArrayOutputStream; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.util.ArrayList; import java.util.Arrays; import java.util.List; import java.util.Optional; import java.util.Random; import java.util.stream.Collectors;  @RunWith(Parameterized.class) @AppModeFull public class PackageManagerShellCommandTest {     private static final String TEST_APP_PACKAGE = ""com.example.helloworld"";      private static final String TEST_APK_PATH = ""/data/local/tmp/cts/content/"";     private static final String TEST_HW5 = ""HelloWorld5.apk"";     private static final String TEST_HW5_SPLIT0 = ""HelloWorld5_hdpi-v4.apk"";     private static final String TEST_HW5_SPLIT1 = ""HelloWorld5_mdpi-v4.apk"";     private static final String TEST_HW5_SPLIT2 = ""HelloWorld5_xhdpi-v4.apk"";     private static final String TEST_HW5_SPLIT3 = ""HelloWorld5_xxhdpi-v4.apk"";     private static final String TEST_HW5_SPLIT4 = ""HelloWorld5_xxxhdpi-v4.apk"";     private static final String TEST_HW7 = ""HelloWorld7.apk"";     private static final String TEST_HW7_SPLIT0 = ""HelloWorld7_hdpi-v4.apk"";     private static final String TEST_HW7_SPLIT1 = ""HelloWorld7_mdpi-v4.apk"";     private static final String TEST_HW7_SPLIT2 = ""HelloWorld7_xhdpi-v4.apk"";     private static final String TEST_HW7_SPLIT3 = ""HelloWorld7_xxhdpi-v4.apk"";     private static final String TEST_HW7_SPLIT4 = ""HelloWorld7_xxxhdpi-v4.apk"";      @Parameter     public int mDataLoaderType;      @Parameters     public static Iterable<Object> initParameters() {         return Arrays.asList(DATA_LOADER_TYPE_NONE, DATA_LOADER_TYPE_STREAMING,                              DATA_LOADER_TYPE_INCREMENTAL);     }      private boolean mStreaming = false;     private boolean mIncremental = false;     private String mInstall = """";     private List<Integer> mSessionIds = new ArrayList<>();      private static PackageInstaller getPackageInstaller() {         return InstrumentationRegistry.getContext().getPackageManager().getPackageInstaller();     }      private static UiAutomation getUiAutomation() {         return InstrumentationRegistry.getInstrumentation().getUiAutomation();     }      private static String executeShellCommand(String command) throws IOException {         final ParcelFileDescriptor stdout = getUiAutomation().executeShellCommand(command);         try (InputStream inputStream = new ParcelFileDescriptor.AutoCloseInputStream(stdout)) {             return readFullStream(inputStream);         }     }      private static String executeShellCommand(String command, File input)             throws IOException {         return executeShellCommand(command, new File[]{input});     }      private static String executeShellCommand(String command, File[] inputs)             throws IOException {         final ParcelFileDescriptor[] pfds = getUiAutomation().executeShellCommandRw(command);         ParcelFileDescriptor stdout = pfds[0];         ParcelFileDescriptor stdin = pfds[1];         try (FileOutputStream outputStream = new ParcelFileDescriptor.AutoCloseOutputStream(                 stdin)) {             for (File input : inputs) {                 try (FileInputStream inputStream = new FileInputStream(input)) {                     writeFullStream(inputStream, outputStream, input.length());                 }             }         }         try (InputStream inputStream = new ParcelFileDescriptor.AutoCloseInputStream(stdout)) {             return readFullStream(inputStream);         }     }      private static String readFullStream(InputStream inputStream) throws IOException {         ByteArrayOutputStream result = new ByteArrayOutputStream();         writeFullStream(inputStream, result, -1);         return result.toString(""UTF-8"");     }      private static void writeFullStream(InputStream inputStream, OutputStream outputStream,             long expected)             throws IOException {         byte[] buffer = new byte[1024];         long total = 0;         int length;         while ((length = inputStream.read(buffer)) != -1) {             outputStream.write(buffer, 0, length);             total += length;         }         if (expected > 0) {             assertEquals(expected, total);         }     }      @Before     public void onBefore() throws Exception {         // Check if Incremental is allowed and revert to non-dataloader installation.         if (mDataLoaderType == DATA_LOADER_TYPE_INCREMENTAL && !IncrementalManager.isAllowed()) {             mDataLoaderType = DATA_LOADER_TYPE_NONE;         }          mStreaming = mDataLoaderType != DATA_LOADER_TYPE_NONE;         mIncremental = mDataLoaderType == DATA_LOADER_TYPE_INCREMENTAL;         mInstall = mDataLoaderType == DATA_LOADER_TYPE_NONE ? "" install "" :                 mDataLoaderType == DATA_LOADER_TYPE_STREAMING ? "" install-streaming "" :                         "" install-incremental "";          uninstallPackageSilently(TEST_APP_PACKAGE);         assertFalse(isAppInstalled(TEST_APP_PACKAGE));          mSessionIds.clear();     }      @After     public void onAfter() throws Exception {         uninstallPackageSilently(TEST_APP_PACKAGE);         assertFalse(isAppInstalled(TEST_APP_PACKAGE));         assertEquals(null, getSplits(TEST_APP_PACKAGE));          for (int sessionId : mSessionIds) {             try {                 getPackageInstaller().abandonSession(sessionId);             } catch (SecurityException ignored) {             }         }     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.content.pm.cts.PackageManagerShellCommandTest"	"testRemoveFileApiV2"	"CtsContentTestCases"	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/content/src/android/content/pm/cts/PackageManagerShellCommandTest.java"	""	"public void testRemoveFileApiV2() throws Exception {         if (!mStreaming) {             return;         }          getUiAutomation().adoptShellPermissionIdentity();         try {             final PackageInstaller installer = getPackageInstaller();              final SessionParams params = new SessionParams(SessionParams.MODE_INHERIT_EXISTING);             params.setAppPackageName(""com.package.name"");             final ComponentName componentName = new ComponentName(""foo"", ""bar"");             final String args = ""args"";             params.setDataLoaderParams(                     mIncremental ? DataLoaderParams.forIncremental(componentName, args)                             : DataLoaderParams.forStreaming(componentName, args));              final int sessionId = createSession(params);             PackageInstaller.Session session = installer.openSession(sessionId);              session.addFile(LOCATION_DATA_APP, ""base.apk"", 123, ""123"".getBytes(), null);             String[] files = session.getNames();             assertEquals(1, files.length);             assertEquals(""base.apk"", files[0]);              session.removeFile(LOCATION_DATA_APP, ""base.apk"");             files = session.getNames();             assertEquals(2, files.length);             assertEquals(""base.apk"", files[0]);             assertEquals(""base.apk.removed"", files[1]);              installer.abandonSession(sessionId);         } finally {             getUiAutomation().dropShellPermissionIdentity();         }     }      private int createSession(SessionParams params) throws IOException {         int sessionId = getPackageInstaller().createSession(params);         mSessionIds.add(sessionId);         return sessionId;     }      private String createUpdateSession(String packageName) throws IOException {         return createSession(""-p "" + packageName);     }      private String createSession(String arg) throws IOException {         final String prefix = ""Success: created install session ["";         final String suffix = ""]\n"";         final String commandResult = executeShellCommand(""pm install-create "" + arg);         assertTrue(commandResult, commandResult.startsWith(prefix));         assertTrue(commandResult, commandResult.endsWith(suffix));         String sessionId = commandResult.substring(prefix.length(),                 commandResult.length() - suffix.length());         mSessionIds.add(Integer.parseInt(sessionId));         return sessionId;     }      private void addSplits(String sessionId, String[] splitNames) throws IOException {         for (String splitName : splitNames) {             File file = new File(splitName);             assertEquals(                     ""Success: streamed "" + file.length() + "" bytes\n"",                     executeShellCommand(""pm install-write "" + sessionId + "" "" + file.getName() + "" ""                             + splitName));         }     }      private void addSplitsStdIn(String sessionId, String[] splitNames, String args)             throws IOException {         for (String splitName : splitNames) {             File file = new File(splitName);             assertEquals(""Success: streamed "" + file.length() + "" bytes\n"", executeShellCommand(                     ""pm install-write -S "" + file.length() + "" "" + sessionId + "" "" + file.getName()                             + "" "" + args, file));         }     }      private void removeSplits(String sessionId, String[] splitNames) throws IOException {         for (String splitName : splitNames) {             assertEquals(""Success\n"",                     executeShellCommand(""pm install-remove "" + sessionId + "" "" + splitName));         }     }      private void removeSplitsBatch(String sessionId, String[] splitNames) throws IOException {         assertEquals(""Success\n"", executeShellCommand(                 ""pm install-remove "" + sessionId + "" "" + String.join("" "", splitNames)));     }      private void commitSession(String sessionId) throws IOException {         assertEquals(""Success\n"", executeShellCommand(""pm install-commit "" + sessionId));     }      private boolean isAppInstalled(String packageName) throws IOException {         final String commandResult = executeShellCommand(""pm list packages"");         final int prefixLength = ""package:"".length();         return Arrays.stream(commandResult.split(""\\r?\\n""))                 .anyMatch(line -> line.substring(prefixLength).equals(packageName));     }      private String getSplits(String packageName) throws IOException {         final String commandResult = executeShellCommand(""pm dump "" + packageName);         final String prefix = ""    splits=["";         final int prefixLength = prefix.length();         Optional<String> maybeSplits = Arrays.stream(commandResult.split(""\\r?\\n""))                 .filter(line -> line.startsWith(prefix)).findFirst();         if (!maybeSplits.isPresent()) {             return null;         }         String splits = maybeSplits.get();         return splits.substring(prefixLength, splits.length() - 1);     }      private static String createApkPath(String baseName) {         return TEST_APK_PATH + baseName;     }      private void installPackage(String baseName) throws IOException {         File file = new File(createApkPath(baseName));         assertEquals(""Success\n"", executeShellCommand(                 ""pm "" + mInstall + "" -t -g "" + file.getPath()));     }      private void installPackageStdIn(String baseName) throws IOException {         File file = new File(createApkPath(baseName));         assertEquals(""Success\n"",                 executeShellCommand(""pm "" + mInstall + "" -t -g -S "" + file.length(), file));     }      private void installSplits(String[] baseNames) throws IOException {         if (mStreaming) {             installSplitsBatch(baseNames);             return;         }         String[] splits = Arrays.stream(baseNames).map(                 baseName -> createApkPath(baseName)).toArray(String[]::new);         String sessionId = createSession(TEST_APP_PACKAGE);         addSplits(sessionId, splits);         commitSession(sessionId);     }      private void installSplitsStdInStreaming(String[] splits) throws IOException {         File[] files = Arrays.stream(splits).map(split -> new File(split)).toArray(File[]::new);         String param = Arrays.stream(files).map(                 file -> file.getName() + "":"" + file.length()).collect(Collectors.joining("" ""));         assertEquals(""Success\n"", executeShellCommand(""pm"" + mInstall + param, files));     }      private void installSplitsStdIn(String[] baseNames, String args) throws IOException {         String[] splits = Arrays.stream(baseNames).map(                 baseName -> createApkPath(baseName)).toArray(String[]::new);         if (mStreaming) {             installSplitsStdInStreaming(splits);             return;         }         String sessionId = createSession(TEST_APP_PACKAGE);         addSplitsStdIn(sessionId, splits, args);         commitSession(sessionId);     }      private void installSplitsBatch(String[] baseNames) throws IOException {         String[] splits = Arrays.stream(baseNames).map(                 baseName -> createApkPath(baseName)).toArray(String[]::new);         assertEquals(""Success\n"",                 executeShellCommand(""pm "" + mInstall + "" -t -g "" + String.join("" "", splits)));     }      private String uninstallPackageSilently(String packageName) throws IOException {         return executeShellCommand(""pm uninstall "" + packageName);     }      private void uninstallSplits(String packageName, String[] splitNames) throws IOException {         for (String splitName : splitNames) {             assertEquals(""Success\n"",                     executeShellCommand(""pm uninstall "" + packageName + "" "" + splitName));         }     }      private void uninstallSplitsBatch(String packageName, String[] splitNames) throws IOException {         assertEquals(""Success\n"", executeShellCommand(                 ""pm uninstall "" + packageName + "" "" + String.join("" "", splitNames)));     } }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.content.pm.cts.PackageManagerShellCommandTest"	"isAllowed"	"CtsContentTestCases"	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	"v4"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/content/src/android/content/pm/cts/PackageManagerShellCommandTest.java"	""	"/*  *.  */  package android.content.pm.cts;  import static android.content.pm.PackageInstaller.DATA_LOADER_TYPE_INCREMENTAL; import static android.content.pm.PackageInstaller.DATA_LOADER_TYPE_NONE; import static android.content.pm.PackageInstaller.DATA_LOADER_TYPE_STREAMING; import static android.content.pm.PackageInstaller.LOCATION_DATA_APP;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertTrue;  import android.app.UiAutomation; import android.content.ComponentName; import android.content.pm.DataLoaderParams; import android.content.pm.PackageInstaller; import android.content.pm.PackageInstaller.SessionParams; import android.os.ParcelFileDescriptor; import android.os.incremental.IncrementalManager; import android.platform.test.annotations.AppModeFull;  import androidx.test.InstrumentationRegistry;  import org.junit.After; import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith; import org.junit.runners.Parameterized; import org.junit.runners.Parameterized.Parameter; import org.junit.runners.Parameterized.Parameters;  import java.io.ByteArrayOutputStream; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.util.ArrayList; import java.util.Arrays; import java.util.List; import java.util.Optional; import java.util.Random; import java.util.stream.Collectors;  @RunWith(Parameterized.class) @AppModeFull public class PackageManagerShellCommandTest {     private static final String TEST_APP_PACKAGE = ""com.example.helloworld"";      private static final String TEST_APK_PATH = ""/data/local/tmp/cts/content/"";     private static final String TEST_HW5 = ""HelloWorld5.apk"";     private static final String TEST_HW5_SPLIT0 = ""HelloWorld5_hdpi-v4.apk"";     private static final String TEST_HW5_SPLIT1 = ""HelloWorld5_mdpi-v4.apk"";     private static final String TEST_HW5_SPLIT2 = ""HelloWorld5_xhdpi-v4.apk"";     private static final String TEST_HW5_SPLIT3 = ""HelloWorld5_xxhdpi-v4.apk"";     private static final String TEST_HW5_SPLIT4 = ""HelloWorld5_xxxhdpi-v4.apk"";     private static final String TEST_HW7 = ""HelloWorld7.apk"";     private static final String TEST_HW7_SPLIT0 = ""HelloWorld7_hdpi-v4.apk"";     private static final String TEST_HW7_SPLIT1 = ""HelloWorld7_mdpi-v4.apk"";     private static final String TEST_HW7_SPLIT2 = ""HelloWorld7_xhdpi-v4.apk"";     private static final String TEST_HW7_SPLIT3 = ""HelloWorld7_xxhdpi-v4.apk"";     private static final String TEST_HW7_SPLIT4 = ""HelloWorld7_xxxhdpi-v4.apk"";      @Parameter     public int mDataLoaderType;      @Parameters     public static Iterable<Object> initParameters() {         return Arrays.asList(DATA_LOADER_TYPE_NONE, DATA_LOADER_TYPE_STREAMING,                              DATA_LOADER_TYPE_INCREMENTAL);     }      private boolean mStreaming = false;     private boolean mIncremental = false;     private String mInstall = """";     private List<Integer> mSessionIds = new ArrayList<>();      private static PackageInstaller getPackageInstaller() {         return InstrumentationRegistry.getContext().getPackageManager().getPackageInstaller();     }      private static UiAutomation getUiAutomation() {         return InstrumentationRegistry.getInstrumentation().getUiAutomation();     }      private static String executeShellCommand(String command) throws IOException {         final ParcelFileDescriptor stdout = getUiAutomation().executeShellCommand(command);         try (InputStream inputStream = new ParcelFileDescriptor.AutoCloseInputStream(stdout)) {             return readFullStream(inputStream);         }     }      private static String executeShellCommand(String command, File input)             throws IOException {         return executeShellCommand(command, new File[]{input});     }      private static String executeShellCommand(String command, File[] inputs)             throws IOException {         final ParcelFileDescriptor[] pfds = getUiAutomation().executeShellCommandRw(command);         ParcelFileDescriptor stdout = pfds[0];         ParcelFileDescriptor stdin = pfds[1];         try (FileOutputStream outputStream = new ParcelFileDescriptor.AutoCloseOutputStream(                 stdin)) {             for (File input : inputs) {                 try (FileInputStream inputStream = new FileInputStream(input)) {                     writeFullStream(inputStream, outputStream, input.length());                 }             }         }         try (InputStream inputStream = new ParcelFileDescriptor.AutoCloseInputStream(stdout)) {             return readFullStream(inputStream);         }     }      private static String readFullStream(InputStream inputStream) throws IOException {         ByteArrayOutputStream result = new ByteArrayOutputStream();         writeFullStream(inputStream, result, -1);         return result.toString(""UTF-8"");     }      private static void writeFullStream(InputStream inputStream, OutputStream outputStream,             long expected)             throws IOException {         byte[] buffer = new byte[1024];         long total = 0;         int length;         while ((length = inputStream.read(buffer)) != -1) {             outputStream.write(buffer, 0, length);             total += length;         }         if (expected > 0) {             assertEquals(expected, total);         }     }      @Before     public void onBefore() throws Exception {         // Check if Incremental is allowed and revert to non-dataloader installation.         if (mDataLoaderType == DATA_LOADER_TYPE_INCREMENTAL && !IncrementalManager.isAllowed()) {             mDataLoaderType = DATA_LOADER_TYPE_NONE;         }          mStreaming = mDataLoaderType != DATA_LOADER_TYPE_NONE;         mIncremental = mDataLoaderType == DATA_LOADER_TYPE_INCREMENTAL;         mInstall = mDataLoaderType == DATA_LOADER_TYPE_NONE ? "" install "" :                 mDataLoaderType == DATA_LOADER_TYPE_STREAMING ? "" install-streaming "" :                         "" install-incremental "";          uninstallPackageSilently(TEST_APP_PACKAGE);         assertFalse(isAppInstalled(TEST_APP_PACKAGE));          mSessionIds.clear();     }      @After     public void onAfter() throws Exception {         uninstallPackageSilently(TEST_APP_PACKAGE);         assertFalse(isAppInstalled(TEST_APP_PACKAGE));         assertEquals(null, getSplits(TEST_APP_PACKAGE));          for (int sessionId : mSessionIds) {             try {                 getPackageInstaller().abandonSession(sessionId);             } catch (SecurityException ignored) {             }         }     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.net.cts.ConnectivityManagerTest"	"testOpenConnection"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	"v4"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/ConnectivityManagerTest.java"	""	"@SkipPresubmit(reason = ""Virtual devices use a single internet connection for all networks"")     public void testOpenConnection() throws Exception {         boolean canRunTest = mPackageManager.hasSystemFeature(FEATURE_WIFI)                 && mPackageManager.hasSystemFeature(FEATURE_TELEPHONY);         if (!canRunTest) {             Log.i(TAG,""testOpenConnection cannot execute unless device supports both WiFi ""                     + ""and a cellular connection"");             return;         }          Network wifiNetwork = mCtsNetUtils.connectToWifi();         Network cellNetwork = mCtsNetUtils.connectToCell();         // This server returns the requestor's IP address as the response body.         URL url = new URL(""http://google-ipv6test.appspot.com/ip.js?fmt=text"");         String wifiAddressString = httpGet(wifiNetwork, url);         String cellAddressString = httpGet(cellNetwork, url);          assertFalse(String.format(""Same address '%s' on two different networks (%s, %s)"",                 wifiAddressString, wifiNetwork, cellNetwork),                 wifiAddressString.equals(cellAddressString));          // Sanity check that the IP addresses that the requests appeared to come from         // are actually on the respective networks.         assertOnNetwork(wifiAddressString, wifiNetwork);         assertOnNetwork(cellAddressString, cellNetwork);          assertFalse(""Unexpectedly equal: "" + wifiNetwork, wifiNetwork.equals(cellNetwork));     }      /**      * Performs a HTTP GET to the specified URL on the specified Network, and returns      * the response body decoded as UTF-8.      */     private static String httpGet(Network network, URL httpUrl) throws IOException {         HttpURLConnection connection = (HttpURLConnection) network.openConnection(httpUrl);         try {             InputStream inputStream = connection.getInputStream();             return Streams.readFully(new InputStreamReader(inputStream, StandardCharsets.UTF_8));         } finally {             connection.disconnect();         }     }      private void assertOnNetwork(String adressString, Network network) throws UnknownHostException {         InetAddress address = InetAddress.getByName(adressString);         LinkProperties linkProperties = mCm.getLinkProperties(network);         // To make sure that the request went out on the right network, check that         // the IP address seen by the server is assigned to the expected network.         // We can only do this for IPv6 addresses, because in IPv4 we will likely         // have a private IPv4 address, and that won't match what the server sees.         if (address instanceof Inet6Address) {             assertContains(linkProperties.getAddresses(), address);         }     }      private static<T> void assertContains(Collection<T> collection, T element) {         assertTrue(element + "" not found in "" + collection, collection.contains(element));     }      private void assertStartUsingNetworkFeatureUnsupported(int networkType, String feature) {         try {             mCm.startUsingNetworkFeature(networkType, feature);             fail(""startUsingNetworkFeature is no longer supported in the current API version"");         } catch (UnsupportedOperationException expected) {}     }      private void assertStopUsingNetworkFeatureUnsupported(int networkType, String feature) {         try {             mCm.startUsingNetworkFeature(networkType, feature);             fail(""stopUsingNetworkFeature is no longer supported in the current API version"");         } catch (UnsupportedOperationException expected) {}     }      private void assertRequestRouteToHostUnsupported(int networkType, int hostAddress) {         try {             mCm.requestRouteToHost(networkType, hostAddress);             fail(""requestRouteToHost is no longer supported in the current API version"");         } catch (UnsupportedOperationException expected) {}     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.net.cts.ConnectivityManagerTest"	"testRequestNetworkCallback_onUnavailable"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	"v4"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/ConnectivityManagerTest.java"	""	"public void testRequestNetworkCallback_onUnavailable() {         final boolean previousWifiEnabledState = mWifiManager.isWifiEnabled();         if (previousWifiEnabledState) {             mCtsNetUtils.disconnectFromWifi(null);         }          final TestNetworkCallback callback = new TestNetworkCallback();         mCm.requestNetwork(new NetworkRequest.Builder()                 .addTransportType(TRANSPORT_WIFI)                 .build(), callback, 100);          try {             // Wait to get callback for unavailability of requested network             assertTrue(""Did not receive NetworkCallback#onUnavailable"",                     callback.waitForUnavailable());         } catch (InterruptedException e) {             fail(""NetworkCallback wait was interrupted."");         } finally {             mCm.unregisterNetworkCallback(callback);             if (previousWifiEnabledState) {                 mCtsNetUtils.connectToWifi();             }         }     }      private InetAddress getFirstV4Address(Network network) {         LinkProperties linkProperties = mCm.getLinkProperties(network);         for (InetAddress address : linkProperties.getAddresses()) {             if (address instanceof Inet4Address) {                 return address;             }         }         return null;     }      /** Verify restricted networks cannot be requested. */     @AppModeFull(reason = ""CHANGE_NETWORK_STATE permission can't be granted to instant apps"")"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.net.cts.ConnectivityManagerTest"	"testKeepaliveWifiUnsupported"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	"v4"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/ConnectivityManagerTest.java"	""	"public void testKeepaliveWifiUnsupported() throws Exception {         if (!mPackageManager.hasSystemFeature(FEATURE_WIFI)) {             Log.i(TAG, ""testKeepaliveUnsupported cannot execute unless device""                     + "" supports WiFi"");             return;         }          final Network network = ensureWifiConnected();         if (getSupportedKeepalivesForNet(network) != 0) return;         final InetAddress srcAddr = getFirstV4Address(network);         assumeTrue(""This test requires native IPv4"", srcAddr != null);          runWithShellPermissionIdentity(() -> {             assertEquals(0, createConcurrentSocketKeepalives(network, srcAddr, 1, 0));             assertEquals(0, createConcurrentSocketKeepalives(network, srcAddr, 0, 1));         });     }      @AppModeFull(reason = ""Cannot get WifiManager in instant app mode"")"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.net.cts.ConnectivityManagerTest"	"testCreateTcpKeepalive"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	"v4"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/ConnectivityManagerTest.java"	""	"@SkipPresubmit(reason = ""Keepalive is not supported on virtual hardware"")     public void testCreateTcpKeepalive() throws Exception {         if (!mPackageManager.hasSystemFeature(FEATURE_WIFI)) {             Log.i(TAG, ""testCreateTcpKeepalive cannot execute unless device supports WiFi"");             return;         }          final Network network = ensureWifiConnected();         if (getSupportedKeepalivesForNet(network) == 0) return;         final InetAddress srcAddr = getFirstV4Address(network);         assumeTrue(""This test requires native IPv4"", srcAddr != null);          // If kernel < 4.8 then it doesn't support TCP keepalive, but it might still support         // NAT-T keepalive. If keepalive limits from resource overlay is not zero, TCP keepalive         // needs to be supported except if the kernel doesn't support it.         if (!isTcpKeepaliveSupportedByKernel()) {             // Sanity check to ensure the callback result is expected.             runWithShellPermissionIdentity(() -> {                 assertEquals(0, createConcurrentSocketKeepalives(network, srcAddr, 0, 1));             });             Log.i(TAG, ""testCreateTcpKeepalive is skipped for kernel ""                     + VintfRuntimeInfo.getKernelVersion());             return;         }          final byte[] requestBytes = CtsNetUtils.HTTP_REQUEST.getBytes(""UTF-8"");         // So far only ipv4 tcp keepalive offload is supported.         // TODO: add test case for ipv6 tcp keepalive offload when it is supported.         try (Socket s = getConnectedSocket(network, TEST_HOST, HTTP_PORT, AF_INET)) {              // Should able to start keep alive offload when socket is idle.             final Executor executor = mContext.getMainExecutor();             final TestSocketKeepaliveCallback callback = new TestSocketKeepaliveCallback();              mUiAutomation.adoptShellPermissionIdentity();             try (SocketKeepalive sk = mCm.createSocketKeepalive(network, s, executor, callback)) {                 sk.start(MIN_KEEPALIVE_INTERVAL);                 callback.expectStarted();                  // App should not able to write during keepalive offload.                 final OutputStream out = s.getOutputStream();                 try {                     out.write(requestBytes);                     fail(""Should not able to write"");                 } catch (IOException e) { }                 // App should not able to read during keepalive offload.                 final InputStream in = s.getInputStream();                 byte[] responseBytes = new byte[4096];                 try {                     in.read(responseBytes);                     fail(""Should not able to read"");                 } catch (IOException e) { }                  // Stop.                 sk.stop();                 callback.expectStopped();             } finally {                 mUiAutomation.dropShellPermissionIdentity();             }              // Ensure socket is still connected.             assertTrue(s.isConnected());             assertFalse(s.isClosed());              // Let socket be not idle.             try {                 final OutputStream out = s.getOutputStream();                 out.write(requestBytes);             } catch (IOException e) {                 fail(""Failed to write data "" + e);             }             // Make sure response data arrives.             final MessageQueue fdHandlerQueue = Looper.getMainLooper().getQueue();             final FileDescriptor fd = s.getFileDescriptor$();             final CountDownLatch mOnReceiveLatch = new CountDownLatch(1);             fdHandlerQueue.addOnFileDescriptorEventListener(fd, EVENT_INPUT, (readyFd, events) -> {                 mOnReceiveLatch.countDown();                 return 0; // Unregister listener.             });             if (!mOnReceiveLatch.await(2, TimeUnit.SECONDS)) {                 fdHandlerQueue.removeOnFileDescriptorEventListener(fd);                 fail(""Timeout: no response data"");             }              // Should get ERROR_SOCKET_NOT_IDLE because there is still data in the receive queue             // that has not been read.             mUiAutomation.adoptShellPermissionIdentity();             try (SocketKeepalive sk = mCm.createSocketKeepalive(network, s, executor, callback)) {                 sk.start(MIN_KEEPALIVE_INTERVAL);                 callback.expectError(SocketKeepalive.ERROR_SOCKET_NOT_IDLE);             } finally {                 mUiAutomation.dropShellPermissionIdentity();             }         }     }      private ArrayList<SocketKeepalive> createConcurrentKeepalivesOfType(             int requestCount, @NonNull TestSocketKeepaliveCallback callback,             Supplier<SocketKeepalive> kaFactory) {         final ArrayList<SocketKeepalive> kalist = new ArrayList<>();          int remainingRetries = MAX_KEEPALIVE_RETRY_COUNT;          // Test concurrent keepalives with the given supplier.         while (kalist.size() < requestCount) {             final SocketKeepalive ka = kaFactory.get();             ka.start(MIN_KEEPALIVE_INTERVAL);             TestSocketKeepaliveCallback.CallbackValue cv = callback.pollCallback();             assertNotNull(cv);             if (cv.callbackType == TestSocketKeepaliveCallback.CallbackType.ON_ERROR) {                 if (kalist.size() == 0 && cv.error == SocketKeepalive.ERROR_UNSUPPORTED) {                     // Unsupported.                     break;                 } else if (cv.error == SocketKeepalive.ERROR_INSUFFICIENT_RESOURCES) {                     // Limit reached or temporary unavailable due to stopped slot is not yet                     // released.                     if (remainingRetries > 0) {                         SystemClock.sleep(INTERVAL_KEEPALIVE_RETRY_MS);                         remainingRetries--;                         continue;                     }                     break;                 }             }             if (cv.callbackType == TestSocketKeepaliveCallback.CallbackType.ON_STARTED) {                 kalist.add(ka);             } else {                 fail(""Unexpected error when creating "" + (kalist.size() + 1) + "" ""                         + ka.getClass().getSimpleName() + "": "" + cv);             }         }          return kalist;     }      private @NonNull ArrayList<SocketKeepalive> createConcurrentNattSocketKeepalives(             @NonNull Network network, @NonNull InetAddress srcAddr, int requestCount,             @NonNull TestSocketKeepaliveCallback callback)  throws Exception {          final Executor executor = mContext.getMainExecutor();          // Initialize a real NaT-T socket.         final IpSecManager mIpSec = (IpSecManager) mContext.getSystemService(Context.IPSEC_SERVICE);         final UdpEncapsulationSocket nattSocket = mIpSec.openUdpEncapsulationSocket();         final InetAddress dstAddr = getAddrByName(TEST_HOST, AF_INET);         assertNotNull(srcAddr);         assertNotNull(dstAddr);          // Test concurrent Nat-T keepalives.         try {             return createConcurrentKeepalivesOfType(requestCount,                     callback, () -> mCm.createSocketKeepalive(network, nattSocket,                             srcAddr, dstAddr, executor, callback));         } finally {             nattSocket.close();         }     }      private @NonNull ArrayList<SocketKeepalive> createConcurrentTcpSocketKeepalives(             @NonNull Network network, int requestCount,             @NonNull TestSocketKeepaliveCallback callback) {         final Executor executor = mContext.getMainExecutor();          // Create concurrent TCP keepalives.         return createConcurrentKeepalivesOfType(requestCount, callback, () -> {             // Assert that TCP connections can be established. The file descriptor of tcp             // sockets will be duplicated and kept valid in service side if the keepalives are             // successfully started.             try (Socket tcpSocket = getConnectedSocket(network, TEST_HOST, HTTP_PORT,                     AF_INET)) {                 return mCm.createSocketKeepalive(network, tcpSocket, executor, callback);             } catch (Exception e) {                 fail(""Unexpected error when creating TCP socket: "" + e);             }             return null;         });     }      /**      * Creates concurrent keepalives until the specified counts of each type of keepalives are      * reached or the expected error callbacks are received for each type of keepalives.      *      * @return the total number of keepalives created.      */     private int createConcurrentSocketKeepalives(             @NonNull Network network, @NonNull InetAddress srcAddr, int nattCount, int tcpCount)             throws Exception {         final ArrayList<SocketKeepalive> kalist = new ArrayList<>();         final TestSocketKeepaliveCallback callback = new TestSocketKeepaliveCallback();          kalist.addAll(createConcurrentNattSocketKeepalives(network, srcAddr, nattCount, callback));         kalist.addAll(createConcurrentTcpSocketKeepalives(network, tcpCount, callback));          final int ret = kalist.size();          // Clean up.         for (final SocketKeepalive ka : kalist) {             ka.stop();             callback.expectStopped();         }         kalist.clear();          return ret;     }      /**      * Verifies that the concurrent keepalive slots meet the minimum requirement, and don't      * get leaked after iterations.      */     @AppModeFull(reason = ""Cannot get WifiManager in instant app mode"")"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.net.cts.ConnectivityManagerTest"	"testSocketKeepaliveLimitWifi"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	"v4"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/ConnectivityManagerTest.java"	""	"@SkipPresubmit(reason = ""Keepalive is not supported on virtual hardware"")     public void testSocketKeepaliveLimitWifi() throws Exception {         if (!mPackageManager.hasSystemFeature(FEATURE_WIFI)) {             Log.i(TAG, ""testSocketKeepaliveLimitWifi cannot execute unless device""                     + "" supports WiFi"");             return;         }          final Network network = ensureWifiConnected();         final int supported = getSupportedKeepalivesForNet(network);         if (supported == 0) {             return;         }         final InetAddress srcAddr = getFirstV4Address(network);         assumeTrue(""This test requires native IPv4"", srcAddr != null);          runWithShellPermissionIdentity(() -> {             // Verifies that the supported keepalive slots meet MIN_SUPPORTED_KEEPALIVE_COUNT.             assertGreaterOrEqual(supported, MIN_SUPPORTED_WIFI_KEEPALIVE_COUNT);              // Verifies that Nat-T keepalives can be established.             assertEquals(supported, createConcurrentSocketKeepalives(network, srcAddr,                     supported + 1, 0));             // Verifies that keepalives don't get leaked in second round.             assertEquals(supported, createConcurrentSocketKeepalives(network, srcAddr, supported,                     0));         });          // If kernel < 4.8 then it doesn't support TCP keepalive, but it might still support         // NAT-T keepalive. Test below cases only if TCP keepalive is supported by kernel.         if (!isTcpKeepaliveSupportedByKernel()) return;          runWithShellPermissionIdentity(() -> {             assertEquals(supported, createConcurrentSocketKeepalives(network, srcAddr, 0,                     supported + 1));              // Verifies that different types can be established at the same time.             assertEquals(supported, createConcurrentSocketKeepalives(network, srcAddr,                     supported / 2, supported - supported / 2));              // Verifies that keepalives don't get leaked in second round.             assertEquals(supported, createConcurrentSocketKeepalives(network, srcAddr, 0,                     supported));             assertEquals(supported, createConcurrentSocketKeepalives(network, srcAddr,                     supported / 2, supported - supported / 2));         });     }      /**      * Verifies that the concurrent keepalive slots meet the minimum telephony requirement, and      * don't get leaked after iterations.      */     @AppModeFull(reason = ""Cannot request network in instant app mode"")"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.net.cts.ConnectivityManagerTest"	"testSocketKeepaliveLimitTelephony"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	"v4"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/ConnectivityManagerTest.java"	""	"@SkipPresubmit(reason = ""Keepalive is not supported on virtual hardware"")     public void testSocketKeepaliveLimitTelephony() throws Exception {         if (!mPackageManager.hasSystemFeature(FEATURE_TELEPHONY)) {             Log.i(TAG, ""testSocketKeepaliveLimitTelephony cannot execute unless device""                     + "" supports telephony"");             return;         }          final int firstSdk = Build.VERSION.FIRST_SDK_INT;         if (firstSdk < Build.VERSION_CODES.Q) {             Log.i(TAG, ""testSocketKeepaliveLimitTelephony: skip test for devices launching""                     + "" before Q: "" + firstSdk);             return;         }          final Network network = mCtsNetUtils.connectToCell();         final int supported = getSupportedKeepalivesForNet(network);         final InetAddress srcAddr = getFirstV4Address(network);         assumeTrue(""This test requires native IPv4"", srcAddr != null);          runWithShellPermissionIdentity(() -> {             // Verifies that the supported keepalive slots meet minimum requirement.             assertGreaterOrEqual(supported, MIN_SUPPORTED_CELLULAR_KEEPALIVE_COUNT);             // Verifies that Nat-T keepalives can be established.             assertEquals(supported, createConcurrentSocketKeepalives(network, srcAddr,                     supported + 1, 0));             // Verifies that keepalives don't get leaked in second round.             assertEquals(supported, createConcurrentSocketKeepalives(network, srcAddr, supported,                     0));         });     }      private int getIntResourceForName(@NonNull String resName) {         final Resources r = mContext.getResources();         final int resId = r.getIdentifier(resName, ""integer"", ""android"");         return r.getInteger(resId);     }      /**      * Verifies that the keepalive slots are limited as customized for unprivileged requests.      */     @AppModeFull(reason = ""Cannot get WifiManager in instant app mode"")"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.net.cts.ConnectivityManagerTest"	"testSocketKeepaliveUnprivileged"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	"v4"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/ConnectivityManagerTest.java"	""	"@SkipPresubmit(reason = ""Keepalive is not supported on virtual hardware"")     public void testSocketKeepaliveUnprivileged() throws Exception {         if (!mPackageManager.hasSystemFeature(FEATURE_WIFI)) {             Log.i(TAG, ""testSocketKeepaliveUnprivileged cannot execute unless device""                     + "" supports WiFi"");             return;         }          final Network network = ensureWifiConnected();         final int supported = getSupportedKeepalivesForNet(network);         if (supported == 0) {             return;         }         final InetAddress srcAddr = getFirstV4Address(network);         assumeTrue(""This test requires native IPv4"", srcAddr != null);          // Resource ID might be shifted on devices that compiled with different symbols.         // Thus, resolve ID at runtime is needed.         final int allowedUnprivilegedPerUid =                 getIntResourceForName(KEEPALIVE_ALLOWED_UNPRIVILEGED_RES_NAME);         final int reservedPrivilegedSlots =                 getIntResourceForName(KEEPALIVE_RESERVED_PER_SLOT_RES_NAME);         // Verifies that unprivileged request per uid cannot exceed the limit customized in the         // resource. Currently, unprivileged keepalive slots are limited to Nat-T only, this test         // does not apply to TCP.         assertGreaterOrEqual(supported, reservedPrivilegedSlots);         assertGreaterOrEqual(supported, allowedUnprivilegedPerUid);         final int expectedUnprivileged =                 Math.min(allowedUnprivilegedPerUid, supported - reservedPrivilegedSlots);         assertEquals(expectedUnprivileged,                 createConcurrentSocketKeepalives(network, srcAddr, supported + 1, 0));     }      private static void assertGreaterOrEqual(long greater, long lesser) {         assertTrue("""" + greater + "" expected to be greater than or equal to "" + lesser,                 greater >= lesser);     }      /**      * Verifies that apps are not allowed to access restricted networks even if they declare the      * CONNECTIVITY_USE_RESTRICTED_NETWORKS permission in their manifests.      * See. b/144679405.      */     @AppModeFull(reason = ""Cannot get WifiManager in instant app mode"")"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.scopedstorage.cts.ScopedStorageTest"	"isInstantApp"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/scopedstorage/src/android/scopedstorage/cts/ScopedStorageTest.java"	""	"/*  *.  */  package android.scopedstorage.cts;  import static android.app.AppOpsManager.permissionToOp; import static android.os.SystemProperties.getBoolean; import static android.provider.MediaStore.MediaColumns; import static android.scopedstorage.cts.lib.RedactionTestHelper.assertExifMetadataMatch; import static android.scopedstorage.cts.lib.RedactionTestHelper.assertExifMetadataMismatch; import static android.scopedstorage.cts.lib.RedactionTestHelper.getExifMetadata; import static android.scopedstorage.cts.lib.RedactionTestHelper.getExifMetadataFromRawResource; import static android.scopedstorage.cts.lib.TestUtils.BYTES_DATA1; import static android.scopedstorage.cts.lib.TestUtils.BYTES_DATA2; import static android.scopedstorage.cts.lib.TestUtils.STR_DATA1; import static android.scopedstorage.cts.lib.TestUtils.STR_DATA2; import static android.scopedstorage.cts.lib.TestUtils.adoptShellPermissionIdentity; import static android.scopedstorage.cts.lib.TestUtils.allowAppOpsToUid; import static android.scopedstorage.cts.lib.TestUtils.assertCanRenameDirectory; import static android.scopedstorage.cts.lib.TestUtils.assertCanRenameFile; import static android.scopedstorage.cts.lib.TestUtils.assertCantRenameDirectory; import static android.scopedstorage.cts.lib.TestUtils.assertCantRenameFile; import static android.scopedstorage.cts.lib.TestUtils.assertDirectoryContains; import static android.scopedstorage.cts.lib.TestUtils.assertFileContent; import static android.scopedstorage.cts.lib.TestUtils.assertThrows; import static android.scopedstorage.cts.lib.TestUtils.canOpen; import static android.scopedstorage.cts.lib.TestUtils.canReadAndWriteAs; import static android.scopedstorage.cts.lib.TestUtils.createFileAs; import static android.scopedstorage.cts.lib.TestUtils.deleteFileAs; import static android.scopedstorage.cts.lib.TestUtils.deleteFileAsNoThrow; import static android.scopedstorage.cts.lib.TestUtils.deleteRecursively; import static android.scopedstorage.cts.lib.TestUtils.deleteWithMediaProvider; import static android.scopedstorage.cts.lib.TestUtils.deleteWithMediaProviderNoThrow; import static android.scopedstorage.cts.lib.TestUtils.denyAppOpsToUid; import static android.scopedstorage.cts.lib.TestUtils.dropShellPermissionIdentity; import static android.scopedstorage.cts.lib.TestUtils.executeShellCommand; import static android.scopedstorage.cts.lib.TestUtils.getAlarmsDir; import static android.scopedstorage.cts.lib.TestUtils.getAndroidDataDir; import static android.scopedstorage.cts.lib.TestUtils.getAndroidDir; import static android.scopedstorage.cts.lib.TestUtils.getAndroidMediaDir; import static android.scopedstorage.cts.lib.TestUtils.getAudiobooksDir; import static android.scopedstorage.cts.lib.TestUtils.getContentResolver; import static android.scopedstorage.cts.lib.TestUtils.getDcimDir; import static android.scopedstorage.cts.lib.TestUtils.getDefaultTopLevelDirs; import static android.scopedstorage.cts.lib.TestUtils.getDocumentsDir; import static android.scopedstorage.cts.lib.TestUtils.getDownloadDir; import static android.scopedstorage.cts.lib.TestUtils.getExternalFilesDir; import static android.scopedstorage.cts.lib.TestUtils.getExternalMediaDir; import static android.scopedstorage.cts.lib.TestUtils.getExternalStorageDir; import static android.scopedstorage.cts.lib.TestUtils.getFileMimeTypeFromDatabase; import static android.scopedstorage.cts.lib.TestUtils.getFileOwnerPackageFromDatabase; import static android.scopedstorage.cts.lib.TestUtils.getFileRowIdFromDatabase; import static android.scopedstorage.cts.lib.TestUtils.getFileSizeFromDatabase; import static android.scopedstorage.cts.lib.TestUtils.getFileUri; import static android.scopedstorage.cts.lib.TestUtils.getMoviesDir; import static android.scopedstorage.cts.lib.TestUtils.getMusicDir; import static android.scopedstorage.cts.lib.TestUtils.getNotificationsDir; import static android.scopedstorage.cts.lib.TestUtils.getPicturesDir; import static android.scopedstorage.cts.lib.TestUtils.getPodcastsDir; import static android.scopedstorage.cts.lib.TestUtils.getRingtonesDir; import static android.scopedstorage.cts.lib.TestUtils.grantPermission; import static android.scopedstorage.cts.lib.TestUtils.installApp; import static android.scopedstorage.cts.lib.TestUtils.installAppWithStoragePermissions; import static android.scopedstorage.cts.lib.TestUtils.listAs; import static android.scopedstorage.cts.lib.TestUtils.openFileAs; import static android.scopedstorage.cts.lib.TestUtils.openWithMediaProvider; import static android.scopedstorage.cts.lib.TestUtils.pollForExternalStorageState; import static android.scopedstorage.cts.lib.TestUtils.pollForManageExternalStorageAllowed; import static android.scopedstorage.cts.lib.TestUtils.pollForPermission; import static android.scopedstorage.cts.lib.TestUtils.queryFile; import static android.scopedstorage.cts.lib.TestUtils.queryFileExcludingPending; import static android.scopedstorage.cts.lib.TestUtils.queryImageFile; import static android.scopedstorage.cts.lib.TestUtils.queryVideoFile; import static android.scopedstorage.cts.lib.TestUtils.readExifMetadataFromTestApp; import static android.scopedstorage.cts.lib.TestUtils.revokePermission; import static android.scopedstorage.cts.lib.TestUtils.setAttrAs; import static android.scopedstorage.cts.lib.TestUtils.setupDefaultDirectories; import static android.scopedstorage.cts.lib.TestUtils.uninstallApp; import static android.scopedstorage.cts.lib.TestUtils.uninstallAppNoThrow; import static android.scopedstorage.cts.lib.TestUtils.updateDisplayNameWithMediaProvider; import static android.system.OsConstants.F_OK; import static android.system.OsConstants.O_APPEND; import static android.system.OsConstants.O_CREAT; import static android.system.OsConstants.O_EXCL; import static android.system.OsConstants.O_RDWR; import static android.system.OsConstants.O_TRUNC; import static android.system.OsConstants.R_OK; import static android.system.OsConstants.S_IRWXU; import static android.system.OsConstants.W_OK;  import static androidx.test.InstrumentationRegistry.getContext;  import static com.google.common.truth.Truth.assertThat; import static com.google.common.truth.Truth.assertWithMessage;  import static junit.framework.Assert.assertFalse; import static junit.framework.Assert.assertTrue;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assume.assumeFalse; import static org.junit.Assume.assumeTrue;  import android.Manifest; import android.app.AppOpsManager; import android.app.WallpaperManager; import android.content.ContentResolver; import android.content.ContentValues; import android.database.Cursor; import android.net.Uri; import android.os.Bundle; import android.os.Environment; import android.os.FileUtils; import android.os.ParcelFileDescriptor; import android.os.Process; import android.platform.test.annotations.AppModeInstant; import android.provider.MediaStore; import android.system.ErrnoException; import android.system.Os; import android.system.StructStat; import android.util.Log;  import androidx.annotation.Nullable; import androidx.test.runner.AndroidJUnit4;  import com.android.cts.install.lib.TestApp;  import com.google.common.io.Files;  import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith;  import java.io.File; import java.io.FileDescriptor; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.nio.ByteBuffer; import java.util.Arrays; import java.util.HashMap; import java.util.List;  /**  * Runs the scoped storage tests on primary external storage.  *  * <p>These tests are also run on a public volume by {@link PublicVolumeTest}.  */ @RunWith(AndroidJUnit4.class) public class ScopedStorageTest {     static final String TAG = ""ScopedStorageTest"";     static final String CONTENT_PROVIDER_URL = ""content://android.tradefed.contentprovider"";     static final String THIS_PACKAGE_NAME = getContext().getPackageName();     static final int USER_SYSTEM = 0;      /**      * To help avoid flaky tests, give ourselves a unique nonce to be used for      * all filesystem paths, so that we don't risk conflicting with previous      * test runs.      */     static final String NONCE = String.valueOf(System.nanoTime());      static final String TEST_DIRECTORY_NAME = ""ScopedStorageTestDirectory"" + NONCE;      static final String AUDIO_FILE_NAME = ""ScopedStorageTest_file_"" + NONCE + "".mp3"";     static final String PLAYLIST_FILE_NAME = ""ScopedStorageTest_file_"" + NONCE + "".m3u"";     static final String SUBTITLE_FILE_NAME = ""ScopedStorageTest_file_"" + NONCE + "".srt"";     static final String VIDEO_FILE_NAME = ""ScopedStorageTest_file_"" + NONCE + "".mp4"";     static final String IMAGE_FILE_NAME = ""ScopedStorageTest_file_"" + NONCE + "".jpg"";     static final String NONMEDIA_FILE_NAME = ""ScopedStorageTest_file_"" + NONCE + "".pdf"";      static final String FILE_CREATION_ERROR_MESSAGE = ""No such file or directory"";      private static final TestApp TEST_APP_A = new TestApp(""TestAppA"",             ""android.scopedstorage.cts.testapp.A"", 1, false, ""CtsScopedStorageTestAppA.apk"");     private static final TestApp TEST_APP_B = new TestApp(""TestAppB"",             ""android.scopedstorage.cts.testapp.B"", 1, false, ""CtsScopedStorageTestAppB.apk"");     private static final TestApp TEST_APP_C = new TestApp(""TestAppC"",             ""android.scopedstorage.cts.testapp.C"", 1, false, ""CtsScopedStorageTestAppC.apk"");     private static final TestApp TEST_APP_C_LEGACY = new TestApp(""TestAppCLegacy"",             ""android.scopedstorage.cts.testapp.C"", 1, false, ""CtsScopedStorageTestAppCLegacy.apk"");     private static final String[] SYSTEM_GALERY_APPOPS = {             AppOpsManager.OPSTR_WRITE_MEDIA_IMAGES, AppOpsManager.OPSTR_WRITE_MEDIA_VIDEO};     private static final String OPSTR_MANAGE_EXTERNAL_STORAGE =             permissionToOp(Manifest.permission.MANAGE_EXTERNAL_STORAGE);      @Before     public void setup() throws Exception {         // skips all test cases if FUSE is not active.         assumeTrue(getBoolean(""persist.sys.fuse"", false));          if (!getContext().getPackageManager().isInstantApp()) {             pollForExternalStorageState();             getExternalFilesDir().mkdirs();         }     }      /**      * This method needs to be called once before running the whole test.      */"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.os.cts.ProcfsHostTests"	"startTestApp"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/os/src/android/os/cts/ProcfsHostTests.java"	""	"public void test/*  *.  */  package android.os.cts;  import com.android.compatibility.common.tradefed.build.CompatibilityBuildHelper; import com.android.tradefed.build.IBuildInfo; import com.android.tradefed.device.ITestDevice; import com.android.tradefed.testtype.DeviceTestCase; import com.android.tradefed.testtype.IBuildReceiver;  import java.io.File; import java.util.Scanner; import java.util.regex.Matcher; import java.util.regex.Pattern;  public class ProcfsHostTests extends DeviceTestCase implements IBuildReceiver {   // We need a running test app to test /proc/[PID]/* files.   private static final String TEST_APP_PACKAGE = ""android.os.procfs"";   private static final String TEST_APP_CLASS = ""ProcfsTest"";   private static final String APK_NAME = ""CtsHostProcfsTestApp.apk"";   private static final String START_TEST_APP_COMMAND =       String.format(           ""am start -W -a android.intent.action.MAIN -n %s/%s.%s"",           TEST_APP_PACKAGE, TEST_APP_PACKAGE, TEST_APP_CLASS);   private static final String TEST_APP_LOG_REGEXP = ""PID is (\\d+)"";   private static final Pattern TEST_APP_LOG_PATTERN = Pattern.compile(TEST_APP_LOG_REGEXP);    private static final String PROC_STAT_PATH = ""/proc/stat"";   private static final String PROC_STAT_READ_COMMAND = ""head -1 "";   // Verfies the first line of /proc/stat includes 'cpu' followed by 10 numbers.   // The 10th column was introduced in kernel version 2.6.33.   private static final String PROC_STAT_REGEXP = ""cpu ( \\d+){10,10}"";   private static final Pattern PROC_STAT_PATTERN = Pattern.compile(PROC_STAT_REGEXP);    // In Linux, a process's stat file (/proc/[PID]/stat) and a thread's (/proc/[PID]/task/[TID]/stat)   // share the same format. We want to verify these stat files include pid (a number), file name   // (a string in parentheses), and state (a character), followed by 41 or more numbers.   // The 44th column was introduced in kernel version 2.6.24.   private static final String PID_TID_STAT_REGEXP = ""\\d+ \\(.*\\) [A-Za-z]( [\\d-]+){41,}"";   private static final Pattern PID_TID_STAT_PATTERN = Pattern.compile(PID_TID_STAT_REGEXP);    // Interval in milliseconds between two sequential reads when checking whether a file is being   // updated.   private static final long UPDATE_READ_INTERVAL_MS = 100;   // Max time in milliseconds waiting for a file being update. If a file's content does not change   // during the period, it is not considered being actively updated.   private static final long UPDATE_MAX_WAIT_TIME_MS = 5000;    // A reference to the device under test, which gives us a handle to run commands.   private ITestDevice mDevice;    private int mTestAppPid = -1;    private IBuildInfo mBuild;    @Override   public void setBuild(IBuildInfo buildInfo) {       mBuild = buildInfo;   }    @Override   protected synchronized void setUp() throws Exception {     super.setUp();     mDevice = getDevice();     mTestAppPid = startTestApp();   }    /**    * Tests that host, as the shell user, can read /proc/stat file, the file is in a reasonable    * shape, and the file is being updated.    *    * @throws Exception    */"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.media.cts.ImageReaderDecoderTest"	"ImageListener"	"CtsMediaTestCases"	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	"v4"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/media/src/android/media/cts/ImageReaderDecoderTest.java"	""	"public void test/*  *.  */  package android.media.cts;  import static android.media.MediaCodecInfo.CodecCapabilities.COLOR_FormatYUV420Flexible;  import android.content.Context; import android.content.res.AssetFileDescriptor; import android.content.res.Resources; import android.content.res.Resources.NotFoundException; import android.graphics.ImageFormat; import android.graphics.Rect; import android.media.Image; import android.media.Image.Plane; import android.media.ImageReader; import android.media.MediaCodec; import android.media.MediaCodecInfo; import android.media.MediaCodecInfo.CodecCapabilities; import android.media.MediaCodecInfo.VideoCapabilities; import android.media.MediaCodecList; import android.media.MediaExtractor; import android.media.MediaFormat; import android.media.cts.CodecUtils; import android.media.cts.R; import android.os.Handler; import android.os.HandlerThread; import android.platform.test.annotations.Presubmit; import android.platform.test.annotations.RequiresDevice; import android.test.AndroidTestCase; import android.util.Log; import android.view.Surface;  import androidx.test.filters.SmallTest;  import com.android.compatibility.common.util.MediaUtils;  import java.io.File; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.nio.ByteBuffer; import java.util.ArrayList; import java.util.Arrays; import java.util.concurrent.LinkedBlockingQueue; import java.util.concurrent.TimeUnit;  /**  * Basic test for ImageReader APIs.  * <p>  * It uses MediaCodec to decode a short video stream, send the video frames to  * the surface provided by ImageReader. Then compare if output buffers of the  * ImageReader matches the output buffers of the MediaCodec. The video format  * used here is AVC although the compression format doesn't matter for this  * test. For decoder test, hw and sw decoders are tested,  * </p>  */ @Presubmit @SmallTest @RequiresDevice public class ImageReaderDecoderTest extends AndroidTestCase {     private static final String TAG = ""ImageReaderDecoderTest"";     private static final boolean VERBOSE = Log.isLoggable(TAG, Log.VERBOSE);     private static final boolean DEBUG = Log.isLoggable(TAG, Log.DEBUG);     private static final long DEFAULT_TIMEOUT_US = 10000;     private static final long WAIT_FOR_IMAGE_TIMEOUT_MS = 1000;     private static final String DEBUG_FILE_NAME_BASE = ""/sdcard/"";     private static final int NUM_FRAME_DECODED = 100;     // video decoders only support a single outstanding image with the consumer     private static final int MAX_NUM_IMAGES = 1;     private static final float COLOR_STDEV_ALLOWANCE = 5f;     private static final float COLOR_DELTA_ALLOWANCE = 5f;      private final static int MODE_IMAGEREADER = 0;     private final static int MODE_IMAGE       = 1;      private Resources mResources;     private MediaCodec.BufferInfo mBufferInfo = new MediaCodec.BufferInfo();     private ImageReader mReader;     private Surface mReaderSurface;     private HandlerThread mHandlerThread;     private Handler mHandler;     private ImageListener mImageListener;      @Override     public void setContext(Context context) {         super.setContext(context);         mResources = mContext.getResources();     }      @Override     protected void setUp() throws Exception {         super.setUp();         mHandlerThread = new HandlerThread(TAG);         mHandlerThread.start();         mHandler = new Handler(mHandlerThread.getLooper());         mImageListener = new ImageListener();     }      @Override     protected void tearDown() throws Exception {         mHandlerThread.quitSafely();         mHandler = null;     }      static class MediaAsset {         public MediaAsset(int resource, int width, int height) {             mResource = resource;             mWidth = width;             mHeight = height;         }          public int getWidth() {             return mWidth;         }          public int getHeight() {             return mHeight;         }          public int getResource() {             return mResource;         }          private final int mResource;         private final int mWidth;         private final int mHeight;     }      static class MediaAssets {         public MediaAssets(String mime, MediaAsset... assets) {             mMime = mime;             mAssets = assets;         }          public String getMime() {             return mMime;         }          public MediaAsset[] getAssets() {             return mAssets;         }          private final String mMime;         private final MediaAsset[] mAssets;     }      private static MediaAssets H263_ASSETS = new MediaAssets(             MediaFormat.MIMETYPE_VIDEO_H263,             new MediaAsset(R.raw.swirl_176x144_h263, 176, 144),             new MediaAsset(R.raw.swirl_352x288_h263, 352, 288),             new MediaAsset(R.raw.swirl_128x96_h263, 128, 96));      private static MediaAssets MPEG4_ASSETS = new MediaAssets(             MediaFormat.MIMETYPE_VIDEO_MPEG4,             new MediaAsset(R.raw.swirl_128x128_mpeg4, 128, 128),             new MediaAsset(R.raw.swirl_144x136_mpeg4, 144, 136),             new MediaAsset(R.raw.swirl_136x144_mpeg4, 136, 144),             new MediaAsset(R.raw.swirl_132x130_mpeg4, 132, 130),             new MediaAsset(R.raw.swirl_130x132_mpeg4, 130, 132));      private static MediaAssets H264_ASSETS = new MediaAssets(             MediaFormat.MIMETYPE_VIDEO_AVC,             new MediaAsset(R.raw.swirl_128x128_h264, 128, 128),             new MediaAsset(R.raw.swirl_144x136_h264, 144, 136),             new MediaAsset(R.raw.swirl_136x144_h264, 136, 144),             new MediaAsset(R.raw.swirl_132x130_h264, 132, 130),             new MediaAsset(R.raw.swirl_130x132_h264, 130, 132));      private static MediaAssets H265_ASSETS = new MediaAssets(             MediaFormat.MIMETYPE_VIDEO_HEVC,             new MediaAsset(R.raw.swirl_128x128_h265, 128, 128),             new MediaAsset(R.raw.swirl_144x136_h265, 144, 136),             new MediaAsset(R.raw.swirl_136x144_h265, 136, 144),             new MediaAsset(R.raw.swirl_132x130_h265, 132, 130),             new MediaAsset(R.raw.swirl_130x132_h265, 130, 132));      private static MediaAssets VP8_ASSETS = new MediaAssets(             MediaFormat.MIMETYPE_VIDEO_VP8,             new MediaAsset(R.raw.swirl_128x128_vp8, 128, 128),             new MediaAsset(R.raw.swirl_144x136_vp8, 144, 136),             new MediaAsset(R.raw.swirl_136x144_vp8, 136, 144),             new MediaAsset(R.raw.swirl_132x130_vp8, 132, 130),             new MediaAsset(R.raw.swirl_130x132_vp8, 130, 132));      private static MediaAssets VP9_ASSETS = new MediaAssets(             MediaFormat.MIMETYPE_VIDEO_VP9,             new MediaAsset(R.raw.swirl_128x128_vp9, 128, 128),             new MediaAsset(R.raw.swirl_144x136_vp9, 144, 136),             new MediaAsset(R.raw.swirl_136x144_vp9, 136, 144),             new MediaAsset(R.raw.swirl_132x130_vp9, 132, 130),             new MediaAsset(R.raw.swirl_130x132_vp9, 130, 132));      static final float SWIRL_FPS = 12.f;      class Decoder {         final private String mName;         final private String mMime;         final private VideoCapabilities mCaps;         final private ArrayList<MediaAsset> mAssets;          boolean isFlexibleFormatSupported(CodecCapabilities caps) {             for (int c : caps.colorFormats) {                 if (c == COLOR_FormatYUV420Flexible) {                     return true;                 }             }             return false;         }          Decoder(String name, MediaAssets assets, CodecCapabilities caps) {             mName = name;             mMime = assets.getMime();             mCaps = caps.getVideoCapabilities();             mAssets = new ArrayList<MediaAsset>();              for (MediaAsset asset : assets.getAssets()) {                 if (mCaps.areSizeAndRateSupported(asset.getWidth(), asset.getHeight(), SWIRL_FPS)                         && isFlexibleFormatSupported(caps)) {                     mAssets.add(asset);                 }             }         }          public boolean videoDecode(int mode, boolean checkSwirl) {             boolean skipped = true;             for (MediaAsset asset: mAssets) {                 // TODO: loop over all supported image formats                 int imageFormat = ImageFormat.YUV_420_888;                 int colorFormat = COLOR_FormatYUV420Flexible;                 videoDecode(asset, imageFormat, colorFormat, mode, checkSwirl);                 skipped = false;             }             return skipped;         }          private void videoDecode(                 MediaAsset asset, int imageFormat, int colorFormat, int mode, boolean checkSwirl) {             int video = asset.getResource();             int width = asset.getWidth();             int height = asset.getHeight();              if (DEBUG) Log.d(TAG, ""videoDecode "" + mName + "" "" + width + ""x"" + height);              MediaCodec decoder = null;             AssetFileDescriptor vidFD = null;              MediaExtractor extractor = null;             File tmpFile = null;             InputStream is = null;             FileOutputStream os = null;             MediaFormat mediaFormat = null;             try {                 extractor = new MediaExtractor();                  try {                     vidFD = mResources.openRawResourceFd(video);                     extractor.setDataSource(                             vidFD.getFileDescriptor(), vidFD.getStartOffset(), vidFD.getLength());                 } catch (NotFoundException e) {                     // resource is compressed, uncompress locally                     String tmpName = ""tempStream"";                     tmpFile = File.createTempFile(tmpName, null, mContext.getCacheDir());                     is = mResources.openRawResource(video);                     os = new FileOutputStream(tmpFile);                     byte[] buf = new byte[1024];                     int len;                     while ((len = is.read(buf, 0, buf.length)) > 0) {                         os.write(buf, 0, len);                     }                     os.close();                     is.close();                      extractor.setDataSource(tmpFile.getAbsolutePath());                 }                  mediaFormat = extractor.getTrackFormat(0);                 mediaFormat.setInteger(MediaFormat.KEY_COLOR_FORMAT, colorFormat);                  // Create decoder                 decoder = MediaCodec.createByCodecName(mName);                 assertNotNull(""couldn't create decoder"" + mName, decoder);                  decodeFramesToImage(                         decoder, extractor, mediaFormat,                         width, height, imageFormat, mode, checkSwirl);                  decoder.stop();                 if (vidFD != null) {                     vidFD.close();                 }             } catch (Throwable e) {                 throw new RuntimeException(""while "" + mName + "" decoding ""                         + mResources.getResourceEntryName(video) + "": "" + mediaFormat, e);             } finally {                 if (decoder != null) {                     decoder.release();                 }                 if (extractor != null) {                     extractor.release();                 }                 if (tmpFile != null) {                     tmpFile.delete();                 }             }         }     }      private Decoder[] decoders(MediaAssets assets, boolean goog) {         String mime = assets.getMime();         MediaCodecList mcl = new MediaCodecList(MediaCodecList.REGULAR_CODECS);         ArrayList<Decoder> result = new ArrayList<Decoder>();          for (MediaCodecInfo info : mcl.getCodecInfos()) {             if (info.isEncoder() || info.isAlias() || !info.isVendor() != goog) {                 continue;             }             CodecCapabilities caps = null;             try {                 caps = info.getCapabilitiesForType(mime);             } catch (IllegalArgumentException e) { // mime is not supported                 continue;             }             assertNotNull(info.getName() + "" capabilties for "" + mime + "" returned null"", caps);             result.add(new Decoder(info.getName(), assets, caps));         }         return result.toArray(new Decoder[result.size()]);     }      private Decoder[] goog(MediaAssets assets) {         return decoders(assets, true /* goog */);     }      private Decoder[] other(MediaAssets assets) {         return decoders(assets, false /* goog */);     }      private Decoder[] googH265()  { return goog(H265_ASSETS); }     private Decoder[] googH264()  { return goog(H264_ASSETS); }     private Decoder[] googH263()  { return goog(H263_ASSETS); }     private Decoder[] googMpeg4() { return goog(MPEG4_ASSETS); }     private Decoder[] googVP8()   { return goog(VP8_ASSETS); }     private Decoder[] googVP9()   { return goog(VP9_ASSETS); }      private Decoder[] otherH265()  { return other(H265_ASSETS); }     private Decoder[] otherH264()  { return other(H264_ASSETS); }     private Decoder[] otherH263()  { return other(H263_ASSETS); }     private Decoder[] otherMpeg4() { return other(MPEG4_ASSETS); }     private Decoder[] otherVP8()   { return other(VP8_ASSETS); }     private Decoder[] otherVP9()   { return other(VP9_ASSETS); }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.media.cts.ImageReaderDecoderTest"	"testSwAVCDecode360pForFlexibleYuv"	"CtsMediaTestCases"	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	"v4"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/media/src/android/media/cts/ImageReaderDecoderTest.java"	""	"public void testSwAVCDecode360pForFlexibleYuv() throws Exception {         Decoder[] decoders = goog(new MediaAssets(                 MediaFormat.MIMETYPE_VIDEO_AVC,                 new MediaAsset(                         R.raw.video_480x360_mp4_h264_1000kbps_25fps_aac_stereo_128kbps_44100hz,                         480 /* width */, 360 /* height */)));          decodeTest(decoders, MODE_IMAGEREADER, false /* checkSwirl */);     }      private void swirlTest(Decoder[] decoders, int mode) {         decodeTest(decoders, mode, true /* checkSwirl */);     }      private void decodeTest(Decoder[] decoders, int mode, boolean checkSwirl) {         try {             boolean skipped = true;             for (Decoder codec : decoders) {                 if (codec.videoDecode(mode, checkSwirl)) {                     skipped = false;                 }             }             if (skipped) {                 MediaUtils.skipTest(""decoder does not any of the input files"");             }         } finally {             closeImageReader();         }     }      private static class ImageListener implements ImageReader.OnImageAvailableListener {         private final LinkedBlockingQueue<Image> mQueue =                 new LinkedBlockingQueue<Image>();          @Override         public void onImageAvailable(ImageReader reader) {             try {                 mQueue.put(reader.acquireNextImage());             } catch (InterruptedException e) {                 throw new UnsupportedOperationException(                         ""Can't handle InterruptedException in onImageAvailable"");             }         }          /**          * Get an image from the image reader.          *          * @param timeout Timeout value for the wait.          * @return The image from the image reader.          */         public Image getImage(long timeout) throws InterruptedException {             Image image = mQueue.poll(timeout, TimeUnit.MILLISECONDS);             assertNotNull(""Wait for an image timed out in "" + timeout + ""ms"", image);             return image;         }     }      /**      * Decode video frames to image reader.      */     private void decodeFramesToImage(             MediaCodec decoder, MediaExtractor extractor, MediaFormat mediaFormat,             int width, int height, int imageFormat, int mode, boolean checkSwirl)             throws InterruptedException {         ByteBuffer[] decoderInputBuffers;         ByteBuffer[] decoderOutputBuffers;          // Configure decoder.         if (VERBOSE) Log.v(TAG, ""stream format: "" + mediaFormat);         if (mode == MODE_IMAGEREADER) {             createImageReader(width, height, imageFormat, MAX_NUM_IMAGES, mImageListener);             decoder.configure(mediaFormat, mReaderSurface, null /* crypto */, 0 /* flags */);         } else {             assertEquals(mode, MODE_IMAGE);             decoder.configure(mediaFormat, null /* surface */, null /* crypto */, 0 /* flags */);         }          decoder.start();         decoderInputBuffers = decoder.getInputBuffers();         decoderOutputBuffers = decoder.getOutputBuffers();         extractor.selectTrack(0);          // Start decoding and get Image, only test the first NUM_FRAME_DECODED frames.         MediaCodec.BufferInfo info = new MediaCodec.BufferInfo();         boolean sawInputEOS = false;         boolean sawOutputEOS = false;         int outputFrameCount = 0;         while (!sawOutputEOS && outputFrameCount < NUM_FRAME_DECODED) {             if (VERBOSE) Log.v(TAG, ""loop:"" + outputFrameCount);             // Feed input frame.             if (!sawInputEOS) {                 int inputBufIndex = decoder.dequeueInputBuffer(DEFAULT_TIMEOUT_US);                 if (inputBufIndex >= 0) {                     ByteBuffer dstBuf = decoderInputBuffers[inputBufIndex];                     int sampleSize =                         extractor.readSampleData(dstBuf, 0 /* offset */);                      if (VERBOSE) Log.v(TAG, ""queue a input buffer, idx/size: ""                         + inputBufIndex + ""/"" + sampleSize);                      long presentationTimeUs = 0;                      if (sampleSize < 0) {                         if (VERBOSE) Log.v(TAG, ""saw input EOS."");                         sawInputEOS = true;                         sampleSize = 0;                     } else {                         presentationTimeUs = extractor.getSampleTime();                     }                      decoder.queueInputBuffer(                             inputBufIndex,                             0 /* offset */,                             sampleSize,                             presentationTimeUs,                             sawInputEOS ? MediaCodec.BUFFER_FLAG_END_OF_STREAM : 0);                      if (!sawInputEOS) {                         extractor.advance();                     }                 }             }              // Get output frame             int res = decoder.dequeueOutputBuffer(info, DEFAULT_TIMEOUT_US);             if (VERBOSE) Log.v(TAG, ""got a buffer: "" + info.size + ""/"" + res);             if (res == MediaCodec.INFO_TRY_AGAIN_LATER) {                 // no output available yet                 if (VERBOSE) Log.v(TAG, ""no output frame available"");             } else if (res == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {                 // decoder output buffers changed, need update.                 if (VERBOSE) Log.v(TAG, ""decoder output buffers changed"");                 decoderOutputBuffers = decoder.getOutputBuffers();             } else if (res == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {                 // this happens before the first frame is returned.                 MediaFormat outFormat = decoder.getOutputFormat();                 if (VERBOSE) Log.v(TAG, ""decoder output format changed: "" + outFormat);             } else if (res < 0) {                 // Should be decoding error.                 fail(""unexpected result from deocder.dequeueOutputBuffer: "" + res);             } else {                 if ((info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {                     sawOutputEOS = true;                 }                  // res >= 0: normal decoding case, copy the output buffer.                 // Will use it as reference to valid the ImageReader output                 // Some decoders output a 0-sized buffer at the end. Ignore those.                 boolean doRender = (info.size != 0);                  if (doRender) {                     outputFrameCount++;                     String fileName = DEBUG_FILE_NAME_BASE + MediaUtils.getTestName()                             + (mode == MODE_IMAGE ? ""_image_"" : ""_reader_"")                             + width + ""x"" + height + ""_"" + outputFrameCount + "".yuv"";                      Image image = null;                     try {                         if (mode == MODE_IMAGE) {                             image = decoder.getOutputImage(res);                         } else {                             decoder.releaseOutputBuffer(res, doRender);                             res = -1;                             // Read image and verify                             image = mImageListener.getImage(WAIT_FOR_IMAGE_TIMEOUT_MS);                         }                         validateImage(image, width, height, imageFormat, fileName);                          if (checkSwirl) {                             try {                                 validateSwirl(image);                             } catch (Throwable e) {                                 dumpFile(fileName, getDataFromImage(image));                                 throw e;                             }                         }                     } finally {                         if (image != null) {                             image.close();                         }                     }                 }                  if (res >= 0) {                     decoder.releaseOutputBuffer(res, false /* render */);                 }             }         }     }      /**      * Validate image based on format and size.      *      * @param image The image to be validated.      * @param width The image width.      * @param height The image height.      * @param format The image format.      * @param filePath The debug dump file path, null if don't want to dump to file.      */     public static void validateImage(             Image image, int width, int height, int format, String filePath) {         if (VERBOSE) {             Plane[] imagePlanes = image.getPlanes();             Log.v(TAG, ""Image "" + filePath + "" Info:"");             Log.v(TAG, ""first plane pixelstride "" + imagePlanes[0].getPixelStride());             Log.v(TAG, ""first plane rowstride "" + imagePlanes[0].getRowStride());             Log.v(TAG, ""Image timestamp:"" + image.getTimestamp());         }          assertNotNull(""Input image is invalid"", image);         assertEquals(""Format doesn't match"", format, image.getFormat());         assertEquals(""Width doesn't match"", width, image.getCropRect().width());         assertEquals(""Height doesn't match"", height, image.getCropRect().height());          if(VERBOSE) Log.v(TAG, ""validating Image"");         byte[] data = getDataFromImage(image);         assertTrue(""Invalid image data"", data != null && data.length > 0);          validateYuvData(data, width, height, format, image.getTimestamp());          if (VERBOSE && filePath != null) {             dumpFile(filePath, data);         }     }      private static void validateSwirl(Image image) {         Rect crop = image.getCropRect();         final int NUM_SIDES = 4;         final int step = 8;      // the width of the layers         long[][] rawStats = new long[NUM_SIDES][10];         int[][] colors = new int[][] {             { 111, 96, 204 }, { 178, 27, 174 }, { 100, 192, 92 }, { 106, 117, 62 }         };          // successively accumulate statistics for each layer of the swirl         // by using overlapping rectangles, and the observation that         // layer_i = rectangle_i - rectangle_(i+1)         int lastLayer = 0;         int layer = 0;         boolean lastLayerValid = false;         for (int pos = 0; ; pos += step) {             Rect area = new Rect(pos - step, pos, crop.width() / 2, crop.height() + 2 * step - pos);             if (area.isEmpty()) {                 break;             }             area.offset(crop.left, crop.top);             area.intersect(crop);             for (int lr = 0; lr < 2; ++lr) {                 long[] oneStat = CodecUtils.getRawStats(image, area);                 if (VERBOSE) Log.v(TAG, ""area="" + area + "", layer="" + layer + "", last=""                                     + lastLayer + "": "" + Arrays.toString(oneStat));                 for (int i = 0; i < oneStat.length; i++) {                     rawStats[layer][i] += oneStat[i];                     if (lastLayerValid) {                         rawStats[lastLayer][i] -= oneStat[i];                     }                 }                 if (VERBOSE && lastLayerValid) {                     Log.v(TAG, ""layer-"" + lastLayer + "": "" + Arrays.toString(rawStats[lastLayer]));                     Log.v(TAG, Arrays.toString(CodecUtils.Raw2YUVStats(rawStats[lastLayer])));                 }                 // switch to the opposite side                 layer ^= 2;      // NUM_SIDES / 2                 lastLayer ^= 2;  // NUM_SIDES / 2                 area.offset(crop.centerX() - area.left, 2 * (crop.centerY() - area.centerY()));             }              lastLayer = layer;             lastLayerValid = true;             layer = (layer + 1) % NUM_SIDES;         }          for (layer = 0; layer < NUM_SIDES; ++layer) {             float[] stats = CodecUtils.Raw2YUVStats(rawStats[layer]);             if (DEBUG) Log.d(TAG, ""layer-"" + layer + "": "" + Arrays.toString(stats));             if (VERBOSE) Log.v(TAG, Arrays.toString(rawStats[layer]));              // check layer uniformity             for (int i = 0; i < 3; i++) {                 assertTrue(""color of layer-"" + layer + "" is not uniform: ""                         + Arrays.toString(stats),                         stats[3 + i] < COLOR_STDEV_ALLOWANCE);             }              // check layer color             for (int i = 0; i < 3; i++) {                 assertTrue(""color of layer-"" + layer + "" mismatches target ""                         + Arrays.toString(colors[layer]) + "" vs ""                         + Arrays.toString(Arrays.copyOf(stats, 3)),                         Math.abs(stats[i] - colors[layer][i]) < COLOR_DELTA_ALLOWANCE);             }         }     }      private static void validateYuvData(byte[] yuvData, int width, int height, int format,             long ts) {          assertTrue(""YUV format must be one of the YUV_420_888, NV21, or YV12"",                 format == ImageFormat.YUV_420_888 ||                 format == ImageFormat.NV21 ||                 format == ImageFormat.YV12);          if (VERBOSE) Log.v(TAG, ""Validating YUV data"");         int expectedSize = width * height * ImageFormat.getBitsPerPixel(format) / 8;         assertEquals(""Yuv data doesn't match"", expectedSize, yuvData.length);     }      private static void checkYuvFormat(int format) {         if ((format != ImageFormat.YUV_420_888) &&                 (format != ImageFormat.NV21) &&                 (format != ImageFormat.YV12)) {             fail(""Wrong formats: "" + format);         }     }     /**      * <p>Check android image format validity for an image, only support below formats:</p>      *      * <p>Valid formats are YUV_420_888/NV21/YV12 for video decoder</p>      */     private static void checkAndroidImageFormat(Image image) {         int format = image.getFormat();         Plane[] planes = image.getPlanes();         switch (format) {             case ImageFormat.YUV_420_888:             case ImageFormat.NV21:             case ImageFormat.YV12:                 assertEquals(""YUV420 format Images should have 3 planes"", 3, planes.length);                 break;             default:                 fail(""Unsupported Image Format: "" + format);         }     }      /**      * Get a byte array image data from an Image object.      * <p>      * Read data from all planes of an Image into a contiguous unpadded,      * unpacked 1-D linear byte array, such that it can be write into disk, or      * accessed by software conveniently. It supports YUV_420_888/NV21/YV12      * input Image format.      * </p>      * <p>      * For YUV_420_888/NV21/YV12/Y8/Y16, it returns a byte array that contains      * the Y plane data first, followed by U(Cb), V(Cr) planes if there is any      * (xstride = width, ystride = height for chroma and luma components).      * </p>      */     private static byte[] getDataFromImage(Image image) {         assertNotNull(""Invalid image:"", image);         Rect crop = image.getCropRect();         int format = image.getFormat();         int width = crop.width();         int height = crop.height();         int rowStride, pixelStride;         byte[] data = null;          // Read image data         Plane[] planes = image.getPlanes();         assertTrue(""Fail to get image planes"", planes != null && planes.length > 0);          // Check image validity         checkAndroidImageFormat(image);          ByteBuffer buffer = null;          int offset = 0;         data = new byte[width * height * ImageFormat.getBitsPerPixel(format) / 8];         byte[] rowData = new byte[planes[0].getRowStride()];         if(VERBOSE) Log.v(TAG, ""get data from "" + planes.length + "" planes"");         for (int i = 0; i < planes.length; i++) {             int shift = (i == 0) ? 0 : 1;             buffer = planes[i].getBuffer();             assertNotNull(""Fail to get bytebuffer from plane"", buffer);             rowStride = planes[i].getRowStride();             pixelStride = planes[i].getPixelStride();             assertTrue(""pixel stride "" + pixelStride + "" is invalid"", pixelStride > 0);             if (VERBOSE) {                 Log.v(TAG, ""pixelStride "" + pixelStride);                 Log.v(TAG, ""rowStride "" + rowStride);                 Log.v(TAG, ""width "" + width);                 Log.v(TAG, ""height "" + height);             }             // For multi-planar yuv images, assuming yuv420 with 2x2 chroma subsampling.             int w = crop.width() >> shift;             int h = crop.height() >> shift;             buffer.position(rowStride * (crop.top >> shift) + pixelStride * (crop.left >> shift));             assertTrue(""rowStride "" + rowStride + "" should be >= width "" + w , rowStride >= w);             for (int row = 0; row < h; row++) {                 int bytesPerPixel = ImageFormat.getBitsPerPixel(format) / 8;                 int length;                 if (pixelStride == bytesPerPixel) {                     // Special case: optimized read of the entire row                     length = w * bytesPerPixel;                     buffer.get(data, offset, length);                     offset += length;                 } else {                     // Generic case: should work for any pixelStride but slower.                     // Use intermediate buffer to avoid read byte-by-byte from                     // DirectByteBuffer, which is very bad for performance                     length = (w - 1) * pixelStride + bytesPerPixel;                     buffer.get(rowData, 0, length);                     for (int col = 0; col < w; col++) {                         data[offset++] = rowData[col * pixelStride];                     }                 }                 // Advance buffer the remainder of the row stride                 if (row < h - 1) {                     buffer.position(buffer.position() + rowStride - length);                 }             }             if (VERBOSE) Log.v(TAG, ""Finished reading data from plane "" + i);         }         return data;     }      private static void dumpFile(String fileName, byte[] data) {         assertNotNull(""fileName must not be null"", fileName);         assertNotNull(""data must not be null"", data);          FileOutputStream outStream;         try {             Log.v(TAG, ""output will be saved as "" + fileName);             outStream = new FileOutputStream(fileName);         } catch (IOException ioe) {             throw new RuntimeException(""Unable to create debug output file "" + fileName, ioe);         }          try {             outStream.write(data);             outStream.close();         } catch (IOException ioe) {             throw new RuntimeException(""failed writing data to file "" + fileName, ioe);         }     }      private void createImageReader(             int width, int height, int format, int maxNumImages,             ImageReader.OnImageAvailableListener listener)  {         closeImageReader();          mReader = ImageReader.newInstance(width, height, format, maxNumImages);         mReaderSurface = mReader.getSurface();         mReader.setOnImageAvailableListener(listener, mHandler);         if (VERBOSE) {             Log.v(TAG, String.format(""Created ImageReader size (%dx%d), format %d"", width, height,                     format));         }     }      /**      * Close the pending images then close current active {@link ImageReader} object.      */     private void closeImageReader() {         if (mReader != null) {             try {                 // Close all possible pending images first.                 Image image = mReader.acquireLatestImage();                 if (image != null) {                     image.close();                 }             } finally {                 mReader.close();                 mReader = null;             }         }     } }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.jvmti.attaching.cts.AttachingTest"	"isAttached4"	"CtsJvmtiAttachingTestCases"	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/jvmti/attaching/src/android.jvmti.attaching.cts/AttachingTest.java"	""	"/*  *.  */  package android.jvmti.attaching.cts;  import static org.junit.Assert.assertTrue;  import android.os.Debug;  import dalvik.system.BaseDexClassLoader;  import org.junit.AfterClass; import org.junit.FixMethodOrder; import org.junit.Test; import org.junit.runner.RunWith; import org.junit.runners.MethodSorters; import org.junit.runners.Parameterized; import org.junit.runners.Parameterized.Parameters;  import java.io.File; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.util.ArrayList; import java.util.Collection; import java.util.HashSet; import java.util.Set; import java.util.concurrent.Callable; import java.util.zip.ZipFile;  @RunWith(Parameterized.class) @FixMethodOrder(MethodSorters.NAME_ASCENDING) public class AttachingTest {     // Some static stored state, for final cleanup.     private static Set<File> createdFiles = new HashSet<>();      // Parameters for a test instance.      // The string to pass as the agent parameter.     private String agentString;     // The classloader to pass.     private ClassLoader classLoader;     // The attach-success function for the last test.     private Callable<Boolean> isAttachedFn;      public AttachingTest(String agentString, ClassLoader classLoader,             Callable<Boolean> isAttachedFn) {         this.agentString = agentString;         this.classLoader = classLoader;         this.isAttachedFn = isAttachedFn;     }      @Parameters     public static Collection<Object[]> data() {         Collection<Object[]> params = new ArrayList<>();          try {             // Test that an absolute path works w/o given classloader.             File agentExtracted = copyAgentToFile(""jvmtiattachingtestagent1"");             Callable<Boolean> success = AttachingTest::isAttached1;             params.add(new Object[] {                 agentExtracted.getAbsolutePath(),                 null,                 success,             });             createdFiles.add(agentExtracted);         } catch (Exception exc) {             throw new RuntimeException(exc);         }          try {             // Test that an absolute path works w/ given classloader.             File agentExtracted = copyAgentToFile(""jvmtiattachingtestagent2"");             Callable<Boolean> success = AttachingTest::isAttached2;             params.add(new Object[] {                 agentExtracted.getAbsolutePath(),                 AttachingTest.class.getClassLoader(),                 success,             });             createdFiles.add(agentExtracted);         } catch (Exception exc) {             throw new RuntimeException(exc);         }          {             // Test that a relative path works w/ given classloader.             Callable<Boolean> success = AttachingTest::isAttached3;             params.add(new Object[] {                 ""libjvmtiattachingtestagent3.so"",                 AttachingTest.class.getClassLoader(),                 success,             });         }          try {             // The name part of an extracted lib should not work.             File agentExtracted = copyAgentToFile(""jvmtiattachingtestagent4"");             String name = agentExtracted.getName();             Callable<Boolean> success = () -> {                 try {                     isAttached4();                     // Any result is a failure.                     return false;                 } catch (UnsatisfiedLinkError e) {                     return true;                 }             };             params.add(new Object[] {                 name,                 AttachingTest.class.getClassLoader(),                 success,             });             createdFiles.add(agentExtracted);         } catch (Exception exc) {             throw new RuntimeException(exc);         }          return params;     }      private static InputStream getAgentInputStream(ClassLoader cl, String lib) throws Exception {         String clfile = ((BaseDexClassLoader) cl).findLibrary(lib);         try {             return new FileInputStream(clfile);         } catch (FileNotFoundException e) {             if (clfile.contains("".apk!/"")) {                 // Looks like it might be a zipaligned library. Get it from the apk directly.                 // Skip the !/                 String libPath = clfile.substring(clfile.lastIndexOf('!') + 2);                 String apkPath = clfile.substring(0, clfile.lastIndexOf('!'));                 ZipFile zip = new ZipFile(apkPath);                 return zip.getInputStream(zip.getEntry(libPath));             } else {                 throw e;             }         }     }     private static File copyAgentToFile(String lib) throws Exception {         ClassLoader cl = AttachingTest.class.getClassLoader();         assertTrue(cl instanceof BaseDexClassLoader);          File copiedAgent = File.createTempFile(""agent"", "".so"");         try (InputStream is = getAgentInputStream(cl, lib)) {             try (OutputStream os = new FileOutputStream(copiedAgent)) {                 byte[] buffer = new byte[64 * 1024];                  while (true) {                     int numRead = is.read(buffer);                     if (numRead == -1) {                         break;                     }                     os.write(buffer, 0, numRead);                 }             }         }          return copiedAgent;     }      @AfterClass     public static void cleanupExtractedAgents() throws Exception {         for (File f : createdFiles) {             f.delete();         }         createdFiles.clear();     }      // Tests.      // This will be repeated unnecessarily, but that's OK."	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.print.cts.InstallBehavior"	"installedServiceIsEnabled"	"CtsPrintTestCases"	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/print/src/android/print/cts/InstallBehavior.java"	""	"public void installedServiceIsEnabled() throws Exception {         getActivity().getSystemService(PrintManager.class).print(""printjob"",                 createDefaultPrintDocumentAdapter(1), null);          waitForWriteAdapterCallback(1);          // Printer should not be available         try {             selectPrinter(""ExternalServicePrinter"", 500);             fail();         } catch (TestHelperException expected) {             // expected         }          SystemUtil.runShellCommand(getInstrumentation(),                 ""pm install /data/local/tmp/cts/print/CtsExternalPrintService.apk"");          selectPrinter(""ExternalServicePrinter"", OPERATION_TIMEOUT_MILLIS);          // Exit print preview and thereby end printing         mPrintHelper.cancelPrinting();     } }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.media.cts.MediaCodecCapabilitiesTest"	"testSecureCodecsAdvertiseSecurePlayback"	"CtsMediaTestCases"	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	"v4"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/media/src/android/media/cts/MediaCodecCapabilitiesTest.java"	""	"public void testSecureCodecsAdvertiseSecurePlayback() throws IOException {         boolean skipped = true;         for (MediaCodecInfo info : mAllInfos) {             boolean isEncoder = info.isEncoder();             if (isEncoder || !info.getName().endsWith("".secure"")) {                 continue;             }             for (String mime : info.getSupportedTypes()) {                 if (!isVideoMime(mime)) {                     continue;                 }                 skipped = false;                 CodecCapabilities caps = info.getCapabilitiesForType(mime);                 assertTrue(                         info.getName() + "" does not advertise secure playback"",                         caps.isFeatureSupported(CodecCapabilities.FEATURE_SecurePlayback));             }         }         if (skipped) {             MediaUtils.skipTest(""no video decoders found ending in .secure"");         }     }      private Size getVideoSizeForTest(VideoCapabilities vidCaps) {         Size size = new Size(176, 144);  // Use QCIF by default.         if (vidCaps != null && !vidCaps.isSizeSupported(size.getWidth(), size.getHeight())) {             int minWidth = vidCaps.getSupportedWidths().getLower();             int minHeight = vidCaps.getSupportedHeightsFor(minWidth).getLower();             size = new Size(minWidth, minHeight);         }         return size;     }      private MediaFormat createVideoFormatForBitrateMode(String mime, int width, int height,             int bitrateMode, CodecCapabilities caps) {         MediaCodecInfo.EncoderCapabilities encoderCaps = caps.getEncoderCapabilities();         if (!encoderCaps.isBitrateModeSupported(bitrateMode)) {             return null;         }          VideoCapabilities vidCaps = caps.getVideoCapabilities();         MediaFormat format = MediaFormat.createVideoFormat(mime, width, height);          // bitrate         int maxWidth = vidCaps.getSupportedWidths().getUpper();         int maxHeight = vidCaps.getSupportedHeightsFor(width).getUpper();         int maxRate = vidCaps.getSupportedFrameRatesFor(width, height).getUpper().intValue();         format.setInteger(MediaFormat.KEY_BITRATE_MODE, bitrateMode);         if (bitrateMode == MediaCodecInfo.EncoderCapabilities.BITRATE_MODE_CQ) {             int quality = encoderCaps.getQualityRange().getLower();             Log.i(TAG, ""reasonable quality for "" + width + ""x"" + height + ""@"" + maxRate                     + "" "" + mime + "" = "" + quality);             format.setInteger(MediaFormat.KEY_QUALITY, quality);         } else {             int bitrate = vidCaps.getBitrateRange().clamp(                     (int)(vidCaps.getBitrateRange().getUpper()                             / Math.sqrt((double)maxWidth * maxHeight / width / height)));             Log.i(TAG, ""reasonable bitrate for "" + width + ""x"" + height + ""@"" + maxRate                     + "" "" + mime + "" = "" + bitrate + "" mode "" + bitrateMode);             format.setInteger(MediaFormat.KEY_BIT_RATE, bitrate);         }         format.setInteger(MediaFormat.KEY_FRAME_RATE, maxRate);         format.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, IFRAME_INTERVAL);         format.setInteger(MediaFormat.KEY_COLOR_FORMAT,                 CodecCapabilities.COLOR_FormatYUV420Flexible);          return format;     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.media.cts.MediaCodecCapabilitiesTest"	"testAllNonTunneledVideoCodecsSupportFlexibleYUV"	"CtsMediaTestCases"	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	"v4"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/media/src/android/media/cts/MediaCodecCapabilitiesTest.java"	""	"public void testAllNonTunneledVideoCodecsSupportFlexibleYUV() throws IOException {         boolean skipped = true;         for (MediaCodecInfo info : mAllInfos) {             boolean isEncoder = info.isEncoder();             for (String mime: info.getSupportedTypes()) {                 if (!isVideoMime(mime)) {                     continue;                 }                 CodecCapabilities caps = info.getCapabilitiesForType(mime);                 if (caps.isFeatureRequired(CodecCapabilities.FEATURE_TunneledPlayback)                         || caps.isFeatureRequired(CodecCapabilities.FEATURE_SecurePlayback)) {                     continue;                 }                 skipped = false;                 boolean found = false;                 for (int c : caps.colorFormats) {                     if (c == caps.COLOR_FormatYUV420Flexible) {                         found = true;                         break;                     }                 }                 assertTrue(                     info.getName() + "" does not advertise COLOR_FormatYUV420Flexible"",                     found);                  MediaCodec codec = null;                 MediaFormat format = null;                 try {                     Size size = getVideoSizeForTest(caps.getVideoCapabilities());                     codec = MediaCodec.createByCodecName(info.getName());                     format = createReasonableVideoFormat(                             caps, mime, isEncoder, size.getWidth(), size.getHeight());                     format.setInteger(                             MediaFormat.KEY_COLOR_FORMAT,                             caps.COLOR_FormatYUV420Flexible);                      codec.configure(format, null /* surface */, null /* crypto */,                             isEncoder ? codec.CONFIGURE_FLAG_ENCODE : 0);                     MediaFormat configuredFormat =                             isEncoder ? codec.getInputFormat() : codec.getOutputFormat();                     Log.d(TAG, ""color format is "" + configuredFormat.getInteger(                             MediaFormat.KEY_COLOR_FORMAT));                     if (isEncoder) {                         codec.start();                         int ix = codec.dequeueInputBuffer(TIMEOUT_US);                         assertNotNull(                                 info.getName() + "" encoder has non-flexYUV input buffer #"" + ix,                                 codec.getInputImage(ix));                     } else {                         // TODO: test these on various decoders (need test streams)                     }                 } finally {                     if (codec != null) {                         codec.release();                     }                 }             }         }         if (skipped) {             MediaUtils.skipTest(""no non-tunneled/non-secure video decoders found"");         }     }      private static MediaFormat createMinFormat(String mime, CodecCapabilities caps) {         MediaFormat format;         if (caps.getVideoCapabilities() != null) {             VideoCapabilities vcaps = caps.getVideoCapabilities();             int minWidth = vcaps.getSupportedWidths().getLower();             int minHeight = vcaps.getSupportedHeightsFor(minWidth).getLower();             int minBitrate = vcaps.getBitrateRange().getLower();             int minFrameRate = Math.max(vcaps.getSupportedFrameRatesFor(minWidth, minHeight)                     .getLower().intValue(), 1);             format = MediaFormat.createVideoFormat(mime, minWidth, minHeight);             format.setInteger(MediaFormat.KEY_COLOR_FORMAT, caps.colorFormats[0]);             format.setInteger(MediaFormat.KEY_BIT_RATE, minBitrate);             format.setInteger(MediaFormat.KEY_FRAME_RATE, minFrameRate);             format.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, IFRAME_INTERVAL);         } else {             AudioCapabilities acaps = caps.getAudioCapabilities();             int minSampleRate = acaps.getSupportedSampleRateRanges()[0].getLower();             int minChannelCount = 1;             int minBitrate = acaps.getBitrateRange().getLower();             format = MediaFormat.createAudioFormat(mime, minSampleRate, minChannelCount);             format.setInteger(MediaFormat.KEY_BIT_RATE, minBitrate);         }          return format;     }      private int getActualMax(             boolean isEncoder, String name, String mime, CodecCapabilities caps, int max) {         int flag = isEncoder ? MediaCodec.CONFIGURE_FLAG_ENCODE : 0;         boolean memory_limited = false;         MediaFormat format = createMinFormat(mime, caps);         Log.d(TAG, ""Test format "" + format);         Vector<MediaCodec> codecs = new Vector<MediaCodec>();         MediaCodec codec = null;         ActivityManager am = (ActivityManager)                 mContext.getSystemService(Context.ACTIVITY_SERVICE);         ActivityManager.MemoryInfo outInfo = new ActivityManager.MemoryInfo();         for (int i = 0; i < max; ++i) {             try {                 Log.d(TAG, ""Create codec "" + name + "" #"" + i);                 codec = MediaCodec.createByCodecName(name);                 codec.configure(format, null, null, flag);                 codec.start();                 codecs.add(codec);                 codec = null;                  am.getMemoryInfo(outInfo);                 if (outInfo.lowMemory) {                     Log.d(TAG, ""System is in low memory condition, stopping. max: "" + i);                     memory_limited = true;                     break;                 }             } catch (IllegalArgumentException e) {                 fail(""Got unexpected IllegalArgumentException "" + e.getMessage());             } catch (IOException e) {                 fail(""Got unexpected IOException "" + e.getMessage());             } catch (MediaCodec.CodecException e) {                 // ERROR_INSUFFICIENT_RESOURCE is expected as the test keep creating codecs.                 // But other exception should be treated as failure.                 if (e.getErrorCode() == MediaCodec.CodecException.ERROR_INSUFFICIENT_RESOURCE) {                     Log.d(TAG, ""Got CodecException with ERROR_INSUFFICIENT_RESOURCE."");                     break;                 } else {                     fail(""Unexpected CodecException "" + e.getDiagnosticInfo());                 }             } finally {                 if (codec != null) {                     Log.d(TAG, ""release codec"");                     codec.release();                     codec = null;                 }             }         }         int actualMax = codecs.size();         for (int i = 0; i < codecs.size(); ++i) {             Log.d(TAG, ""release codec #"" + i);             codecs.get(i).release();         }         codecs.clear();         // encode both actual max and whether we ran out of memory         if (memory_limited) {             actualMax = -actualMax;         }         return actualMax;     }      private boolean knownTypes(String type) {         return (type.equalsIgnoreCase(MediaFormat.MIMETYPE_AUDIO_AAC  ) ||             type.equalsIgnoreCase(MediaFormat.MIMETYPE_AUDIO_AC3      ) ||             type.equalsIgnoreCase(MediaFormat.MIMETYPE_AUDIO_AMR_NB   ) ||             type.equalsIgnoreCase(MediaFormat.MIMETYPE_AUDIO_AMR_WB   ) ||             type.equalsIgnoreCase(MediaFormat.MIMETYPE_AUDIO_EAC3     ) ||             type.equalsIgnoreCase(MediaFormat.MIMETYPE_AUDIO_FLAC     ) ||             type.equalsIgnoreCase(MediaFormat.MIMETYPE_AUDIO_G711_ALAW) ||             type.equalsIgnoreCase(MediaFormat.MIMETYPE_AUDIO_G711_MLAW) ||             type.equalsIgnoreCase(MediaFormat.MIMETYPE_AUDIO_MPEG     ) ||             type.equalsIgnoreCase(MediaFormat.MIMETYPE_AUDIO_MSGSM    ) ||             type.equalsIgnoreCase(MediaFormat.MIMETYPE_AUDIO_OPUS     ) ||             type.equalsIgnoreCase(MediaFormat.MIMETYPE_AUDIO_RAW      ) ||             type.equalsIgnoreCase(MediaFormat.MIMETYPE_AUDIO_VORBIS   ) ||             type.equalsIgnoreCase(MediaFormat.MIMETYPE_VIDEO_AV1      ) ||             type.equalsIgnoreCase(MediaFormat.MIMETYPE_VIDEO_AVC      ) ||             type.equalsIgnoreCase(MediaFormat.MIMETYPE_VIDEO_H263     ) ||             type.equalsIgnoreCase(MediaFormat.MIMETYPE_VIDEO_HEVC     ) ||             type.equalsIgnoreCase(MediaFormat.MIMETYPE_VIDEO_MPEG2    ) ||             type.equalsIgnoreCase(MediaFormat.MIMETYPE_VIDEO_MPEG4    ) ||             type.equalsIgnoreCase(MediaFormat.MIMETYPE_VIDEO_VP8      ) ||             type.equalsIgnoreCase(MediaFormat.MIMETYPE_VIDEO_VP9      ));     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.AdoptableHostTest"	"isSupportedDevice"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/AdoptableHostTest.java"	""	"/*  *.  */  package android.appsecurity.cts;  import static android.appsecurity.cts.SplitTests.ABI_TO_APK; import static android.appsecurity.cts.SplitTests.APK; import static android.appsecurity.cts.SplitTests.APK_mdpi; import static android.appsecurity.cts.SplitTests.APK_xxhdpi; import static android.appsecurity.cts.SplitTests.CLASS; import static android.appsecurity.cts.SplitTests.PKG;  import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail;  import android.platform.test.annotations.AppModeFull;  import com.android.tradefed.device.CollectingOutputReceiver; import com.android.tradefed.log.LogUtil.CLog; import com.android.tradefed.testtype.DeviceJUnit4ClassRunner; import com.android.tradefed.testtype.junit4.BaseHostJUnit4Test;  import org.junit.After; import org.junit.Assert; import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith;  import java.util.Arrays; import java.util.concurrent.TimeUnit;  /**  * Set of tests that verify behavior of adopted storage media, if supported.  */ @RunWith(DeviceJUnit4ClassRunner.class) @AppModeFull(reason = ""Instant applications can only be installed on internal storage"") public class AdoptableHostTest extends BaseHostJUnit4Test {      public static final String FEATURE_ADOPTABLE_STORAGE = ""feature:android.software.adoptable_storage"";      private String mListVolumesInitialState;      @Before     public void setUp() throws Exception {         // Start all possible users to make sure their storage is unlocked         Utils.prepareMultipleUsers(getDevice(), Integer.MAX_VALUE);          // Users are starting, wait for all volumes are ready         waitForVolumeReady();          // Initial state of all volumes         mListVolumesInitialState = getDevice().executeShellCommand(""sm list-volumes"");          getDevice().uninstallPackage(PKG);          // Enable a virtual disk to give us the best shot at being able to pass         // the various tests below. This helps verify devices that may not         // currently have an SD card inserted.         if (isSupportedDevice()) {             getDevice().executeShellCommand(""sm set-virtual-disk true"");              // Ensure virtual disk is mounted.             int attempt = 0;             boolean hasVirtualDisk = false;             String result = """";             while (!hasVirtualDisk && attempt++ < 20) {                 Thread.sleep(1000);                 result = getDevice().executeShellCommand(""sm list-disks adoptable"").trim();                 hasVirtualDisk = result.startsWith(""disk:"");             }             assertTrue(""Virtual disk is not ready: "" + result, hasVirtualDisk);              waitForVolumeReady();         }     }      @After     public void tearDown() throws Exception {         getDevice().uninstallPackage(PKG);          if (isSupportedDevice()) {             getDevice().executeShellCommand(""sm set-virtual-disk false"");              // Ensure virtual disk is removed.             int attempt = 0;             boolean hasVirtualDisk = true;             String result = """";             while (hasVirtualDisk && attempt++ < 20) {                 Thread.sleep(1000);                 result = getDevice().executeShellCommand(""sm list-disks adoptable"").trim();                 hasVirtualDisk = result.startsWith(""disk:"");             }             if (hasVirtualDisk) {                 CLog.w(""Virtual disk is not removed: "" + result);             }              // Ensure all volumes go back to the original state.             attempt = 0;             boolean volumeStateRecovered = false;             result = """";             while (!volumeStateRecovered && attempt++ < 20) {                 Thread.sleep(1000);                 result = getDevice().executeShellCommand(""sm list-volumes"");                 volumeStateRecovered = mListVolumesInitialState.equals(result);             }             if (!volumeStateRecovered) {                 CLog.w(""Volume state is not recovered: "" + result);             }         }     }      /**      * Ensure that we have consistency between the feature flag and what we      * sniffed from the underlying fstab.      */"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.jvmti.cts.JvmtiRedefineClassesTest"	"Finish"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	"v4"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/jvmti/redefining/app/src/android/jvmti/cts/JvmtiRedefineClassesTest.java"	""	"/*  * Copyright (C) 2017 The Android Open Source Project  *  * Licensed under the Apache License, Version 2.0 (the ""License""); you may not use this file except  * in compliance with the License. You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software distributed under the License  * is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express  * or implied. See the License for the specific language governing permissions and limitations under  * the License.  */ package android.jvmti.cts;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertArrayEquals; import static org.junit.Assert.assertTrue;  import dalvik.system.InMemoryDexClassLoader;  import java.lang.ref.WeakReference; import java.nio.ByteBuffer; import java.util.Arrays; import java.util.ArrayList; import java.util.Base64; import java.util.Collections; import java.util.LinkedList; import java.util.List;  import org.junit.Assert; import org.junit.After; import org.junit.Before; import org.junit.BeforeClass; import org.junit.Test;  import art.Main;  /**  * Check redefineClasses-related functionality.  */ public class JvmtiRedefineClassesTest extends JvmtiTestBase {      @Before     public void setUp() throws Exception {         // make sure everything is cleared.         setTransformationEvent(false);         setPopTransformations(true);         clearTransformations();         // Make sure Transform.class is in the initial state.         checkRedefinition(INITIAL_TRANSFORM);     }      static class RedefineError {         public int expectedError;         public Class<?> target;         public byte[] dexData;          public RedefineError(int err, Class<?> target, String base64string) {             this(err, target, Base64.getDecoder().decode(base64string));         }          public RedefineError(int err, Class<?> klass, byte[] dex) {             this.expectedError = err;             this.target = klass;             this.dexData = dex;         }     }      // Just an interface.     interface Consumer<T> {         public void accept(T data);     }      static class StringCollector implements Consumer<String> {         public ArrayList<String> reports = new ArrayList<>();          public void accept(String data) {             reports.add(data);         }     }      /**      * Try to redefine a class and assert that the redefinition matches whats expected.      */     private static void checkRedefinition(RedefineError err) {         assertEquals(err.expectedError, redefineClass(err.target, err.dexData));     }      // This is a class that we will transform for tests.     // NB This has the actual name Landroid/jvmti/cts/JvmtiRedefineClassesTest$Transform;     static class Transform {         // NB This field has type Landroid/jvmti/cts/JvmtiRedefineClassesTest$Consumer;         private Consumer<String> reporter;          public Transform(Consumer<String> reporter) {             this.reporter = reporter;         }          private void Start() {             reporter.accept(""hello - private"");         }          private void Finish() {             reporter.accept(""goodbye - private"");         }          public void sayHi(Runnable r) {             reporter.accept(""Pre Start private method call"");             Start();             reporter.accept(""Post Start private method call"");             r.run();             reporter.accept(""Pre Finish private method call"");             Finish();             reporter.accept(""Post Finish private method call"");         }     }      /**      * Base64 encoded dex file for the initial version of Transform class.      */     private static final RedefineError INITIAL_TRANSFORM = new RedefineError(             JvmtiErrors.NONE, Transform.class,             ""ZGV4CjAzNQA+L+iHAAAAAAAAAAAAAAAAAAAAAAAAAACgBgAAcAAAAHhWNBIAAAAAAAAAANwFAAAi"" +             ""AAAAcAAAAAkAAAD4AAAABAAAABwBAAABAAAATAEAAAcAAABUAQAAAQAAAIwBAAD0BAAArAEAAKwB"" +             ""AACvAQAAsgEAALoBAAC+AQAAxAEAAMwBAADrAQAAIQIAAFgCAACQAgAAvgIAAOICAAACAwAAIQMA"" +             ""ADUDAABLAwAAXwMAAIADAACgAwAAwAMAAN8DAADmAwAA8QMAAPQDAAD4AwAAAAQAAA0EAAAgBAAA"" +             ""MQQAADcEAABBBAAARgQAAE0EAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAABcAAAAX"" +             ""AAAACAAAAAAAAAAYAAAACAAAAFQEAAAYAAAACAAAAFwEAAAYAAAACAAAAGQEAAABAAAAHgAAAAAA"" +             ""AgAZAAAAAQABAAIAAAABAAAABQAAAAEAAAAVAAAAAQADACAAAAAGAAAAAgAAAAcAAAAfAAAAAQAA"" +             ""AAAAAAAGAAAAAAAAAAYAAAC8BQAAWAUAAAAAAAABKAABPAAGPGluaXQ+AAI+OwAEPjspVgAGRmlu"" +             ""aXNoAB1Kdm10aVJlZGVmaW5lQ2xhc3Nlc1Rlc3QuamF2YQA0TGFuZHJvaWQvanZtdGkvY3RzL0p2"" +             ""bXRpUmVkZWZpbmVDbGFzc2VzVGVzdCRDb25zdW1lcgA1TGFuZHJvaWQvanZtdGkvY3RzL0p2bXRp"" +             ""UmVkZWZpbmVDbGFzc2VzVGVzdCRDb25zdW1lcjsANkxhbmRyb2lkL2p2bXRpL2N0cy9Kdm10aVJl"" +             ""ZGVmaW5lQ2xhc3Nlc1Rlc3QkVHJhbnNmb3JtOwAsTGFuZHJvaWQvanZtdGkvY3RzL0p2bXRpUmVk"" +             ""ZWZpbmVDbGFzc2VzVGVzdDsAIkxkYWx2aWsvYW5ub3RhdGlvbi9FbmNsb3NpbmdDbGFzczsAHkxk"" +             ""YWx2aWsvYW5ub3RhdGlvbi9Jbm5lckNsYXNzOwAdTGRhbHZpay9hbm5vdGF0aW9uL1NpZ25hdHVy"" +             ""ZTsAEkxqYXZhL2xhbmcvT2JqZWN0OwAUTGphdmEvbGFuZy9SdW5uYWJsZTsAEkxqYXZhL2xhbmcv"" +             ""U3RyaW5nOwAfUG9zdCBGaW5pc2ggcHJpdmF0ZSBtZXRob2QgY2FsbAAeUG9zdCBTdGFydCBwcml2"" +             ""YXRlIG1ldGhvZCBjYWxsAB5QcmUgRmluaXNoIHByaXZhdGUgbWV0aG9kIGNhbGwAHVByZSBTdGFy"" +             ""dCBwcml2YXRlIG1ldGhvZCBjYWxsAAVTdGFydAAJVHJhbnNmb3JtAAFWAAJWTAAGYWNjZXB0AAth"" +             ""Y2Nlc3NGbGFncwARZ29vZGJ5ZSAtIHByaXZhdGUAD2hlbGxvIC0gcHJpdmF0ZQAEbmFtZQAIcmVw"" +             ""b3J0ZXIAA3J1bgAFc2F5SGkABXZhbHVlAAEAAAAAAAAAAQAAAAYAAAABAAAABwAAAAwBAAcOPC0A"" +             ""FQAHDocAEQAHDocAGQEABw6HPIc8hzyHAAAAAAIAAgABAAAAbAQAAAYAAABwEAUAAABbAQAADgAD"" +             ""AAEAAgAAAHQEAAAJAAAAVCAAABsBGwAAAHIgAAAQAA4AAAADAAEAAgAAAHoEAAAJAAAAVCAAABsB"" +             ""HAAAAHIgAAAQAA4AAAAEAAIAAgAAAIAEAAAqAAAAVCAAABsBFAAAAHIgAAAQAHAQAwACAFQgAAAb"" +             ""ARIAAAByIAAAEAByEAYAAwBUIAAAGwETAAAAciAAABAAcBACAAIAVCAAABsBEQAAAHIgAAAQAA4A"" +             ""AAEDAQACAYGABJAJAQKsCQEC0AkEAfQJAgMBIRgCAgQCGgQIHRcWAgUBIRwEFwcXARcQFwMCBQEh"" +             ""HAUXABcHFwEXEBcEAAAAAgAAAHAFAAB2BQAAAQAAAH8FAAABAAAAjQUAAKAFAAABAAAAAQAAAAAA"" +             ""AAAAAAAArAUAAAEAAAC0BQAAEAAAAAAAAAABAAAAAAAAAAEAAAAiAAAAcAAAAAIAAAAJAAAA+AAA"" +             ""AAMAAAAEAAAAHAEAAAQAAAABAAAATAEAAAUAAAAHAAAAVAEAAAYAAAABAAAAjAEAAAIgAAAiAAAA"" +             ""rAEAAAEQAAADAAAAVAQAAAMgAAAEAAAAbAQAAAEgAAAEAAAAkAQAAAAgAAABAAAAWAUAAAQgAAAE"" +             ""AAAAcAUAAAMQAAADAAAAoAUAAAYgAAABAAAAvAUAAAAQAAABAAAA3AUAAA=="");      /**      * Base64 encoded dex file containing the following inner class.      * <code>      * // NB This has the actual name Landroid/jvmti/cts/JvmtiRedefineClassesTest$Transform;      * static class Transform {      *     // NB This field has type Landroid/jvmti/cts/JvmtiRedefineClassesTest$Consumer;      *     private Consumer<String> reporter;      *     public Transform(Consumer<String> reporter) {      *         this.reporter = reporter;      *     }      *     private void Start() {      *         reporter.accept(""TRANSFORMED - Hello - private"");      *     }      *     private void Finish() {      *         reporter.accept(""TRANSFORMED - Goodbye - private"");      *     }      *     public void sayHi(Runnable r) {      *         reporter.accept(""TRANSFORMED - pre Start private method call"");      *         Start();      *         reporter.accept(""TRANSFORMED - post Start private method call"");      *         r.run();      *         reporter.accept(""TRANSFORMED - pre Finish private method call"");      *         Finish();      *         reporter.accept(""TRANSFORMED - post Finish private method call"");      *     }      * }      * </code>      */     private static final RedefineError GOOD_TRANSFORM = new RedefineError(             JvmtiErrors.NONE, Transform.class,             ""ZGV4CjAzNQBmR3TRAAAAAAAAAAAAAAAAAAAAAAAAAAD0BgAAcAAAAHhWNBIAAAAAAAAAADAGAAAi"" +             ""AAAAcAAAAAkAAAD4AAAABAAAABwBAAABAAAATAEAAAcAAABUAQAAAQAAAIwBAABIBQAArAEAAKwB"" +             ""AACvAQAAsgEAALoBAAC+AQAAxAEAAMwBAADrAQAAIQIAAFgCAACQAgAAvgIAAOICAAACAwAAIQMA"" +             ""ADUDAABLAwAAXwMAAGYDAACHAwAApgMAANUDAAADBAAAMQQAAF4EAABpBAAAbAQAAHAEAAB4BAAA"" +             ""hQQAAIsEAACVBAAAmgQAAKEEAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAABkAAAAZ"" +             ""AAAACAAAAAAAAAAaAAAACAAAAKgEAAAaAAAACAAAALAEAAAaAAAACAAAALgEAAABAAAAHgAAAAAA"" +             ""AgAbAAAAAQABAAIAAAABAAAABQAAAAEAAAARAAAAAQADACAAAAAGAAAAAgAAAAcAAAAfAAAAAQAA"" +             ""AAAAAAAGAAAAAAAAAAYAAAAQBgAArAUAAAAAAAABKAABPAAGPGluaXQ+AAI+OwAEPjspVgAGRmlu"" +             ""aXNoAB1Kdm10aVJlZGVmaW5lQ2xhc3Nlc1Rlc3QuamF2YQA0TGFuZHJvaWQvanZtdGkvY3RzL0p2"" +             ""bXRpUmVkZWZpbmVDbGFzc2VzVGVzdCRDb25zdW1lcgA1TGFuZHJvaWQvanZtdGkvY3RzL0p2bXRp"" +             ""UmVkZWZpbmVDbGFzc2VzVGVzdCRDb25zdW1lcjsANkxhbmRyb2lkL2p2bXRpL2N0cy9Kdm10aVJl"" +             ""ZGVmaW5lQ2xhc3Nlc1Rlc3QkVHJhbnNmb3JtOwAsTGFuZHJvaWQvanZtdGkvY3RzL0p2bXRpUmVk"" +             ""ZWZpbmVDbGFzc2VzVGVzdDsAIkxkYWx2aWsvYW5ub3RhdGlvbi9FbmNsb3NpbmdDbGFzczsAHkxk"" +             ""YWx2aWsvYW5ub3RhdGlvbi9Jbm5lckNsYXNzOwAdTGRhbHZpay9hbm5vdGF0aW9uL1NpZ25hdHVy"" +             ""ZTsAEkxqYXZhL2xhbmcvT2JqZWN0OwAUTGphdmEvbGFuZy9SdW5uYWJsZTsAEkxqYXZhL2xhbmcv"" +             ""U3RyaW5nOwAFU3RhcnQAH1RSQU5TRk9STUVEIC0gR29vZGJ5ZSAtIHByaXZhdGUAHVRSQU5TRk9S"" +             ""TUVEIC0gSGVsbG8gLSBwcml2YXRlAC1UUkFOU0ZPUk1FRCAtIHBvc3QgRmluaXNoIHByaXZhdGUg"" +             ""bWV0aG9kIGNhbGwALFRSQU5TRk9STUVEIC0gcG9zdCBTdGFydCBwcml2YXRlIG1ldGhvZCBjYWxs"" +             ""ACxUUkFOU0ZPUk1FRCAtIHByZSBGaW5pc2ggcHJpdmF0ZSBtZXRob2QgY2FsbAArVFJBTlNGT1JN"" +             ""RUQgLSBwcmUgU3RhcnQgcHJpdmF0ZSBtZXRob2QgY2FsbAAJVHJhbnNmb3JtAAFWAAJWTAAGYWNj"" +             ""ZXB0AAthY2Nlc3NGbGFncwAEbmFtZQAIcmVwb3J0ZXIAA3J1bgAFc2F5SGkABXZhbHVlAAEAAAAA"" +             ""AAAAAQAAAAYAAAABAAAABwAAAAsBAAcOPC0AFAAHDocAEAAHDocAGAEABw6HPIc8hzyHAAAAAAIA"" +             ""AgABAAAAwAQAAAYAAABwEAUAAABbAQAADgADAAEAAgAAAMgEAAAJAAAAVCAAABsBEgAAAHIgAAAQ"" +             ""AA4AAAADAAEAAgAAAM4EAAAJAAAAVCAAABsBEwAAAHIgAAAQAA4AAAAEAAIAAgAAANQEAAAqAAAA"" +             ""VCAAABsBFwAAAHIgAAAQAHAQAwACAFQgAAAbARUAAAByIAAAEAByEAYAAwBUIAAAGwEWAAAAciAA"" +             ""ABAAcBACAAIAVCAAABsBFAAAAHIgAAAQAA4AAAEDAQACAYGABOQJAQKACgECpAoEAcgKAgMBIRgC"" +             ""AgQCHAQIHRcYAgUBIRwEFwcXARcQFwMCBQEhHAUXABcHFwEXEBcEAAAAAgAAAMQFAADKBQAAAQAA"" +             ""ANMFAAABAAAA4QUAAPQFAAABAAAAAQAAAAAAAAAAAAAAAAYAAAEAAAAIBgAAEAAAAAAAAAABAAAA"" +             ""AAAAAAEAAAAiAAAAcAAAAAIAAAAJAAAA+AAAAAMAAAAEAAAAHAEAAAQAAAABAAAATAEAAAUAAAAH"" +             ""AAAAVAEAAAYAAAABAAAAjAEAAAIgAAAiAAAArAEAAAEQAAADAAAAqAQAAAMgAAAEAAAAwAQAAAEg"" +             ""AAAEAAAA5AQAAAAgAAABAAAArAUAAAQgAAAEAAAAxAUAAAMQAAADAAAA9AUAAAYgAAABAAAAEAYA"" +             ""AAAQAAABAAAAMAYAAA=="");      /**      * Tests that we can redefine Transform class from INITIAL_TRANSFORM to GOOD_TRANSFORM.      * <p>      * It uses doRedefine to do the transformation.      */     private void checkRedefinedTransform(Runnable doRedefine) {         // The consumer that we use to observe the changes to the Transform class.         final StringCollector c = new StringCollector();         Transform t = new Transform(c);         // Run once without changes.         t.sayHi(new Runnable() {             public void run() {                 c.accept(""Initial test run. No changes."");             }         });         // Run once with obsolete methods.         t.sayHi(new Runnable() {             public void run() {                 c.accept(""Redefining calling function."");                 doRedefine.run();             }         });         // Run once with new definition.         t.sayHi(new Runnable() {             public void run() {                 c.accept(""Final test run."");             }         });          String[] output = c.reports.toArray(new String[0]);         assertArrayEquals(                 new String[]{                         // The first call to sayHi                         ""Pre Start private method call"",                         ""hello - private"",                         ""Post Start private method call"",                         ""Initial test run. No changes."",                         ""Pre Finish private method call"",                         ""goodbye - private"",                         ""Post Finish private method call"",                          // The second call to sayHi.                         ""Pre Start private method call"",                         ""hello - private"",                         ""Post Start private method call"",                         ""Redefining calling function."",                         ""Pre Finish private method call"",                         ""TRANSFORMED - Goodbye - private"",                         ""Post Finish private method call"",                          // The final call to sayHi.                         ""TRANSFORMED - pre Start private method call"",                         ""TRANSFORMED - Hello - private"",                         ""TRANSFORMED - post Start private method call"",                         ""Final test run."",                         ""TRANSFORMED - pre Finish private method call"",                         ""TRANSFORMED - Goodbye - private"",                         ""TRANSFORMED - post Finish private method call"",                 }, output);     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.jvmti.cts.JvmtiRedefineClassesTest"	"testSucessfulRetransform"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	"v4"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/jvmti/redefining/app/src/android/jvmti/cts/JvmtiRedefineClassesTest.java"	""	"public void testSucessfulRetransform() throws Exception {         pushTransformationResult(GOOD_TRANSFORM.target, GOOD_TRANSFORM.dexData);         checkRedefinedTransform(new Runnable() {             public void run() {                 setTransformationEvent(true);                 assertEquals(JvmtiErrors.NONE, retransformClass(Transform.class));             }         });     }      // This is a class that we will transform for tests.     // NB This has the actual name Landroid/jvmti/cts/JvmtiRedefineClassesTest$Transform2;     static class Transform2 {         public void sayHi() {             Assert.fail(""Should not be called!"");         }     }      /**      * Test cases for failing redefines.      */     private static final RedefineError[] FAILING_DEX_FILES = {             /**              * Base64 for this class.              *              *  .class Landroid/jvmti/cts/JvmtiRedefineClassesTest$Transform2;              *  .super Ljava/lang/Object;              *  .source ""JvmtiRedefineClassesTest.java""              *              *  # annotations              *  .annotation system Ldalvik/annotation/EnclosingClass;              *      value = Landroid/jvmti/cts/JvmtiRedefineClassesTest;              *  .end annotation              *              *  .annotation system Ldalvik/annotation/InnerClass;              *      accessFlags = 0x8              *      name = ""Transform2""              *  .end annotation              *              *  # direct methods              *  .method constructor <init>()V              *      .registers 1              *      .prologue              *      .line 33              *      invoke-direct {p0}, Ljava/lang/Object;-><init>()V              *      return-void              *  .end method              *              *  # virtual methods              *  .method public sayHi()V              *      .registers 1              *      .prologue              *      .line 35              *      return-object v0              *  .end method             */             new RedefineError(JvmtiErrors.FAILS_VERIFICATION, Transform2.class,                     ""ZGV4CjAzNQBOhefYdQRcgqmkwhWsSyzb5I3udX0SnJ44AwAAcAAAAHhWNBIAAAAAAAAAAIwCAAAN"" +                     ""AAAAcAAAAAYAAACkAAAAAQAAALwAAAAAAAAAAAAAAAMAAADIAAAAAQAAAOAAAAA4AgAAAAEAAAAB"" +                     ""AAAIAQAAJwEAAGABAACOAQAAsgEAANIBAADmAQAA8gEAAPUBAAACAgAACAIAAA8CAAACAAAAAwAA"" +                     ""AAQAAAAFAAAABgAAAAgAAAAIAAAABQAAAAAAAAAAAAAAAAAAAAAAAAALAAAABAAAAAAAAAAAAAAA"" +                     ""AAAAAAQAAAAAAAAAAQAAADgCAAB+AgAAAAAAAAY8aW5pdD4AHUp2bXRpUmVkZWZpbmVDbGFzc2Vz"" +                     ""VGVzdC5qYXZhADdMYW5kcm9pZC9qdm10aS9jdHMvSnZtdGlSZWRlZmluZUNsYXNzZXNUZXN0JFRy"" +                     ""YW5zZm9ybTI7ACxMYW5kcm9pZC9qdm10aS9jdHMvSnZtdGlSZWRlZmluZUNsYXNzZXNUZXN0OwAi"" +                     ""TGRhbHZpay9hbm5vdGF0aW9uL0VuY2xvc2luZ0NsYXNzOwAeTGRhbHZpay9hbm5vdGF0aW9uL0lu"" +                     ""bmVyQ2xhc3M7ABJMamF2YS9sYW5nL09iamVjdDsAClRyYW5zZm9ybTIAAVYAC2FjY2Vzc0ZsYWdz"" +                     ""AARuYW1lAAVzYXlIaQAFdmFsdWUAAAACAwIJBAgKFwcCAgEMGAEAAAAAAAIAAAAhAgAAGAIAACwC"" +                     ""AAAAAAAAAAAAAAAAAAAhAAcOACMABw4AAAABAAEAAQAAAEgCAAAEAAAAcBACAAAADgACAAEAAAAA"" +                     ""AE0CAAABAAAAEQAAAAEBAICABNQEAQHsBA4AAAAAAAAAAQAAAAAAAAABAAAADQAAAHAAAAACAAAA"" +                     ""BgAAAKQAAAADAAAAAQAAALwAAAAFAAAAAwAAAMgAAAAGAAAAAQAAAOAAAAACIAAADQAAAAABAAAE"" +                     ""IAAAAgAAABgCAAADEAAAAgAAACgCAAAGIAAAAQAAADgCAAADIAAAAgAAAEgCAAABIAAAAgAAAFQC"" +                     ""AAAAIAAAAQAAAH4CAAAAEAAAAQAAAIwCAAA=""),             /**              * Base64 for this class.              *              *  static class Transform {              *    private Consumer<String> reporter;              *    public Transform(Consumer<String> reporter) {              *      this.reporter = reporter;              *    }              *    private void Start() { }              *    private void Finish() { }              *    protected void sayHi(Runnable r) { }              *  }             */             new RedefineError(                     JvmtiErrors.UNSUPPORTED_REDEFINITION_METHOD_MODIFIERS_CHANGED, Transform.class,                     ""ZGV4CjAzNQAf2DrkAAAAAAAAAAAAAAAAAAAAAAAAAAAwBQAAcAAAAHhWNBIAAAAAAAAAAGwEAAAa"" +                     ""AAAAcAAAAAkAAADYAAAAAwAAAPwAAAABAAAAIAEAAAUAAAAoAQAAAQAAAFABAADAAwAAcAEAAHAB"" +                     ""AABzAQAAdgEAAH4BAACCAQAAiAEAAJABAACvAQAA5QEAABwCAABUAgAAggIAAKYCAADGAgAA5QIA"" +                     ""APkCAAAPAwAAIwMAACoDAAA1AwAAOAMAADwDAABJAwAATwMAAFkDAABgAwAACAAAAAkAAAAKAAAA"" +                     ""CwAAAAwAAAANAAAADgAAAA8AAAATAAAAEwAAAAgAAAAAAAAAFAAAAAgAAABoAwAAFAAAAAgAAABw"" +                     ""AwAAAQAAABcAAAABAAEAAgAAAAEAAAAFAAAAAQAAABEAAAABAAIAGAAAAAYAAAACAAAAAQAAAAAA"" +                     ""AAAGAAAAAAAAAAYAAABMBAAA6AMAAAAAAAABKAABPAAGPGluaXQ+AAI+OwAEPjspVgAGRmluaXNo"" +                     ""AB1Kdm10aVJlZGVmaW5lQ2xhc3Nlc1Rlc3QuamF2YQA0TGFuZHJvaWQvanZtdGkvY3RzL0p2bXRp"" +                     ""UmVkZWZpbmVDbGFzc2VzVGVzdCRDb25zdW1lcgA1TGFuZHJvaWQvanZtdGkvY3RzL0p2bXRpUmVk"" +                     ""ZWZpbmVDbGFzc2VzVGVzdCRDb25zdW1lcjsANkxhbmRyb2lkL2p2bXRpL2N0cy9Kdm10aVJlZGVm"" +                     ""aW5lQ2xhc3Nlc1Rlc3QkVHJhbnNmb3JtOwAsTGFuZHJvaWQvanZtdGkvY3RzL0p2bXRpUmVkZWZp"" +                     ""bmVDbGFzc2VzVGVzdDsAIkxkYWx2aWsvYW5ub3RhdGlvbi9FbmNsb3NpbmdDbGFzczsAHkxkYWx2"" +                     ""aWsvYW5ub3RhdGlvbi9Jbm5lckNsYXNzOwAdTGRhbHZpay9hbm5vdGF0aW9uL1NpZ25hdHVyZTsA"" +                     ""EkxqYXZhL2xhbmcvT2JqZWN0OwAUTGphdmEvbGFuZy9SdW5uYWJsZTsAEkxqYXZhL2xhbmcvU3Ry"" +                     ""aW5nOwAFU3RhcnQACVRyYW5zZm9ybQABVgACVkwAC2FjY2Vzc0ZsYWdzAARuYW1lAAhyZXBvcnRl"" +                     ""cgAFc2F5SGkABXZhbHVlAAABAAAAAAAAAAEAAAAHAAAACwEABw48LQARAAcOAA8ABw4AEwEABw4A"" +                     ""AgACAAEAAAB4AwAABgAAAHAQBAAAAFsBAAAOAAEAAQAAAAAAgAMAAAEAAAAOAAAAAQABAAAAAACF"" +                     ""AwAAAQAAAA4AAAACAAIAAAAAAIoDAAABAAAADgAAAAABAwEAAgCBgASQBwECrAcBAsAHAwTUBwID"" +                     ""ARkYAgIEAhUECBYXEgIFARkcBBcHFwEXEBcDAgUBGRwFFwAXBxcBFxAXBAAAAAIAAAAABAAABgQA"" +                     ""AAEAAAAPBAAAAQAAAB0EAAAwBAAAAQAAAAEAAAAAAAAAAAAAADwEAAAAAAAARAQAABAAAAAAAAAA"" +                     ""AQAAAAAAAAABAAAAGgAAAHAAAAACAAAACQAAANgAAAADAAAAAwAAAPwAAAAEAAAAAQAAACABAAAF"" +                     ""AAAABQAAACgBAAAGAAAAAQAAAFABAAACIAAAGgAAAHABAAABEAAAAgAAAGgDAAADIAAABAAAAHgD"" +                     ""AAABIAAABAAAAJADAAAAIAAAAQAAAOgDAAAEIAAABAAAAAAEAAADEAAAAwAAADAEAAAGIAAAAQAA"" +                     ""AEwEAAAAEAAAAQAAAGwEAAA=""),             /**              * Base64 for this class.              *              *  static final class Transform {              *    private Consumer<String> reporter;              *    public Transform(Consumer<String> reporter) {              *      this.reporter = reporter;              *    }              *    private void Start() { }              *    private void Finish() { }              *    public void sayHi(Runnable r) { }              *  }             */             new RedefineError(                     JvmtiErrors.UNSUPPORTED_REDEFINITION_CLASS_MODIFIERS_CHANGED, Transform.class,                     ""ZGV4CjAzNQA82MAwAAAAAAAAAAAAAAAAAAAAAAAAAAAwBQAAcAAAAHhWNBIAAAAAAAAAAGwEAAAa"" +                     ""AAAAcAAAAAkAAADYAAAAAwAAAPwAAAABAAAAIAEAAAUAAAAoAQAAAQAAAFABAADAAwAAcAEAAHAB"" +                     ""AABzAQAAdgEAAH4BAACCAQAAiAEAAJABAACvAQAA5QEAABwCAABUAgAAggIAAKYCAADGAgAA5QIA"" +                     ""APkCAAAPAwAAIwMAACoDAAA1AwAAOAMAADwDAABJAwAATwMAAFkDAABgAwAACAAAAAkAAAAKAAAA"" +                     ""CwAAAAwAAAANAAAADgAAAA8AAAATAAAAEwAAAAgAAAAAAAAAFAAAAAgAAABoAwAAFAAAAAgAAABw"" +                     ""AwAAAQAAABcAAAABAAEAAgAAAAEAAAAFAAAAAQAAABEAAAABAAIAGAAAAAYAAAACAAAAAQAAABAA"" +                     ""AAAGAAAAAAAAAAYAAABMBAAA6AMAAAAAAAABKAABPAAGPGluaXQ+AAI+OwAEPjspVgAGRmluaXNo"" +                     ""AB1Kdm10aVJlZGVmaW5lQ2xhc3Nlc1Rlc3QuamF2YQA0TGFuZHJvaWQvanZtdGkvY3RzL0p2bXRp"" +                     ""UmVkZWZpbmVDbGFzc2VzVGVzdCRDb25zdW1lcgA1TGFuZHJvaWQvanZtdGkvY3RzL0p2bXRpUmVk"" +                     ""ZWZpbmVDbGFzc2VzVGVzdCRDb25zdW1lcjsANkxhbmRyb2lkL2p2bXRpL2N0cy9Kdm10aVJlZGVm"" +                     ""aW5lQ2xhc3Nlc1Rlc3QkVHJhbnNmb3JtOwAsTGFuZHJvaWQvanZtdGkvY3RzL0p2bXRpUmVkZWZp"" +                     ""bmVDbGFzc2VzVGVzdDsAIkxkYWx2aWsvYW5ub3RhdGlvbi9FbmNsb3NpbmdDbGFzczsAHkxkYWx2"" +                     ""aWsvYW5ub3RhdGlvbi9Jbm5lckNsYXNzOwAdTGRhbHZpay9hbm5vdGF0aW9uL1NpZ25hdHVyZTsA"" +                     ""EkxqYXZhL2xhbmcvT2JqZWN0OwAUTGphdmEvbGFuZy9SdW5uYWJsZTsAEkxqYXZhL2xhbmcvU3Ry"" +                     ""aW5nOwAFU3RhcnQACVRyYW5zZm9ybQABVgACVkwAC2FjY2Vzc0ZsYWdzAARuYW1lAAhyZXBvcnRl"" +                     ""cgAFc2F5SGkABXZhbHVlAAABAAAAAAAAAAEAAAAHAAAACwEABw48LQARAAcOAA8ABw4AEwEABw4A"" +                     ""AgACAAEAAAB4AwAABgAAAHAQBAAAAFsBAAAOAAEAAQAAAAAAgAMAAAEAAAAOAAAAAQABAAAAAACF"" +                     ""AwAAAQAAAA4AAAACAAIAAAAAAIoDAAABAAAADgAAAAABAwEAAgCBgASQBwECrAcBAsAHAwHUBwID"" +                     ""ARkYAgIEAhUEGBYXEgIFARkcBBcHFwEXEBcDAgUBGRwFFwAXBxcBFxAXBAAAAAIAAAAABAAABgQA"" +                     ""AAEAAAAPBAAAAQAAAB0EAAAwBAAAAQAAAAEAAAAAAAAAAAAAADwEAAAAAAAARAQAABAAAAAAAAAA"" +                     ""AQAAAAAAAAABAAAAGgAAAHAAAAACAAAACQAAANgAAAADAAAAAwAAAPwAAAAEAAAAAQAAACABAAAF"" +                     ""AAAABQAAACgBAAAGAAAAAQAAAFABAAACIAAAGgAAAHABAAABEAAAAgAAAGgDAAADIAAABAAAAHgD"" +                     ""AAABIAAABAAAAJADAAAAIAAAAQAAAOgDAAAEIAAABAAAAAAEAAADEAAAAwAAADAEAAAGIAAAAQAA"" +                     ""AEwEAAAAEAAAAQAAAGwEAAA=""),             /**              * Base64 for this class.              *              *  static class Transform {              *    private Consumer<String> reporter;              *    public Transform(Consumer<String> reporter) {              *      this.reporter = reporter;              *    }              *    private void Finish() { }              *    public void sayHi(Runnable r) { }              *  }             */             new RedefineError(                     JvmtiErrors.UNSUPPORTED_REDEFINITION_METHOD_DELETED, Transform.class,                     ""ZGV4CjAzNQBG028hAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAcAAAAHhWNBIAAAAAAAAAADwEAAAZ"" +                     ""AAAAcAAAAAkAAADUAAAAAwAAAPgAAAABAAAAHAEAAAQAAAAkAQAAAQAAAEQBAACcAwAAZAEAAGQB"" +                     ""AABnAQAAagEAAHIBAAB2AQAAfAEAAJsBAADRAQAACAIAAEACAABuAgAAkgIAALICAADRAgAA5QIA"" +                     ""APsCAAAPAwAAFgMAACEDAAAkAwAAKAMAADUDAAA7AwAARQMAAEwDAAAHAAAACAAAAAkAAAAKAAAA"" +                     ""CwAAAAwAAAANAAAADgAAABIAAAASAAAACAAAAAAAAAATAAAACAAAAFQDAAATAAAACAAAAFwDAAAB"" +                     ""AAAAFgAAAAEAAQACAAAAAQAAABAAAAABAAIAFwAAAAYAAAACAAAAAQAAAAAAAAAGAAAAAAAAAAUA"" +                     ""AAAcBAAAvAMAAAAAAAABKAABPAAGPGluaXQ+AAI+OwAEPjspVgAdSnZtdGlSZWRlZmluZUNsYXNz"" +                     ""ZXNUZXN0LmphdmEANExhbmRyb2lkL2p2bXRpL2N0cy9Kdm10aVJlZGVmaW5lQ2xhc3Nlc1Rlc3Qk"" +                     ""Q29uc3VtZXIANUxhbmRyb2lkL2p2bXRpL2N0cy9Kdm10aVJlZGVmaW5lQ2xhc3Nlc1Rlc3QkQ29u"" +                     ""c3VtZXI7ADZMYW5kcm9pZC9qdm10aS9jdHMvSnZtdGlSZWRlZmluZUNsYXNzZXNUZXN0JFRyYW5z"" +                     ""Zm9ybTsALExhbmRyb2lkL2p2bXRpL2N0cy9Kdm10aVJlZGVmaW5lQ2xhc3Nlc1Rlc3Q7ACJMZGFs"" +                     ""dmlrL2Fubm90YXRpb24vRW5jbG9zaW5nQ2xhc3M7AB5MZGFsdmlrL2Fubm90YXRpb24vSW5uZXJD"" +                     ""bGFzczsAHUxkYWx2aWsvYW5ub3RhdGlvbi9TaWduYXR1cmU7ABJMamF2YS9sYW5nL09iamVjdDsA"" +                     ""FExqYXZhL2xhbmcvUnVubmFibGU7ABJMamF2YS9sYW5nL1N0cmluZzsABVN0YXJ0AAlUcmFuc2Zv"" +                     ""cm0AAVYAAlZMAAthY2Nlc3NGbGFncwAEbmFtZQAIcmVwb3J0ZXIABXNheUhpAAV2YWx1ZQAAAQAA"" +                     ""AAAAAAABAAAABwAAAA0BAAcOAA4ABw4AEAEABw4AAAAAAgACAAEAAABkAwAABgAAAHAQAwAAAFsB"" +                     ""AAAOAAEAAQAAAAAAagMAAAEAAAAOAAAAAgACAAAAAABvAwAAAQAAAA4AAAAAAQIBAAIAgYAE+AYB"" +                     ""ApQHAgGoBwIDARgYAgIEAhQECBUXEQIFARgcBBcGFwEXDxcDAgUBGBwFFwAXBhcBFw8XBAAAAAIA"" +                     ""AADQAwAA1gMAAAEAAADfAwAAAQAAAO0DAAAABAAAAQAAAAEAAAAAAAAAAAAAAAwEAAAAAAAAFAQA"" +                     ""ABAAAAAAAAAAAQAAAAAAAAABAAAAGQAAAHAAAAACAAAACQAAANQAAAADAAAAAwAAAPgAAAAEAAAA"" +                     ""AQAAABwBAAAFAAAABAAAACQBAAAGAAAAAQAAAEQBAAACIAAAGQAAAGQBAAABEAAAAgAAAFQDAAAD"" +                     ""IAAAAwAAAGQDAAABIAAAAwAAAHgDAAAAIAAAAQAAALwDAAAEIAAABAAAANADAAADEAAAAwAAAAAE"" +                     ""AAAGIAAAAQAAABwEAAAAEAAAAQAAADwEAAA=""),             /**              * Base6is class.              *              *  static class Transform {              *    private Consumer<String> reporter;              *    public Transform(Consumer<String> reporter) {              *      this.reporter = reporter;              *    }              *    private void Start() { }              *    private void Start2() { }              *    private void Finish() { }              *    public void sayHi(Runnable r) { }              *  }             */             new RedefineError(                     JvmtiErrors.UNSUPPORTED_REDEFINITION_METHOD_ADDED, Transform.class,                     ""ZGV4CjAzNQC43HElAAAAAAAAAAAAAAAAAAAAAAAAAABgBQAAcAAAAHhWNBIAAAAAAAAAAJwEAAAb"" +                     ""AAAAcAAAAAkAAADcAAAAAwAAAAABAAABAAAAJAEAAAYAAAAsAQAAAQAAAFwBAADkAwAAfAEAAHwB"" +                     ""AAB/AQAAggEAAIoBAACOAQAAlAEAAJwBAAC7AQAA8QEAACgCAABgAgAAjgIAALICAADSAgAA8QIA"" +                     ""AAUDAAAbAwAALwMAADYDAAA+AwAASQMAAEwDAABQAwAAXQMAAGMDAABtAwAAdAMAAAgAAAAJAAAA"" +                     ""CgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAFAAAABQAAAAIAAAAAAAAABUAAAAIAAAAfAMAABUAAAAI"" +                     ""AAAAhAMAAAEAAAAYAAAAAQABAAIAAAABAAAABQAAAAEAAAARAAAAAQAAABIAAAABAAIAGQAAAAYA"" +                     ""AAACAAAAAQAAAAAAAAAGAAAAAAAAAAYAAAB8BAAAFAQAAAAAAAABKAABPAAGPGluaXQ+AAI+OwAE"" +                     ""PjspVgAGRmluaXNoAB1Kdm10aVJlZGVmaW5lQ2xhc3Nlc1Rlc3QuamF2YQA0TGFuZHJvaWQvanZt"" +                     ""dGkvY3RzL0p2bXRpUmVkZWZpbmVDbGFzc2VzVGVzdCRDb25zdW1lcgA1TGFuZHJvaWQvanZtdGkv"" +                     ""Y3RzL0p2bXRpUmVkZWZpbmVDbGFzc2VzVGVzdCRDb25zdW1lcjsANkxhbmRyb2lkL2p2bXRpL2N0"" +                     ""cy9Kdm10aVJlZGVmaW5lQ2xhc3Nlc1Rlc3QkVHJhbnNmb3JtOwAsTGFuZHJvaWQvanZtdGkvY3Rz"" +                     ""L0p2bXRpUmVkZWZpbmVDbGFzc2VzVGVzdDsAIkxkYWx2aWsvYW5ub3RhdGlvbi9FbmNsb3NpbmdD"" +                     ""bGFzczsAHkxkYWx2aWsvYW5ub3RhdGlvbi9Jbm5lckNsYXNzOwAdTGRhbHZpay9hbm5vdGF0aW9u"" +                     ""L1NpZ25hdHVyZTsAEkxqYXZhL2xhbmcvT2JqZWN0OwAUTGphdmEvbGFuZy9SdW5uYWJsZTsAEkxq"" +                     ""YXZhL2xhbmcvU3RyaW5nOwAFU3RhcnQABlN0YXJ0MgAJVHJhbnNmb3JtAAFWAAJWTAALYWNjZXNz"" +                     ""RmxhZ3MABG5hbWUACHJlcG9ydGVyAAVzYXlIaQAFdmFsdWUAAAEAAAAAAAAAAQAAAAcAAAANAQAH"" +                     ""DgAQAAcOAA4ABw4ADwAHDgARAQAHDgAAAgACAAEAAACMAwAABgAAAHAQBQAAAFsBAAAOAAEAAQAA"" +                     ""AAAAkgMAAAEAAAAOAAAAAQABAAAAAACXAwAAAQAAAA4AAAABAAEAAAAAAJwDAAABAAAADgAAAAIA"" +                     ""AgAAAAAAoQMAAAEAAAAOAAAAAAEEAQACAIGABKgHAQLEBwEC2AcBAuwHBAGACAIDARoYAgIEAhYE"" +                     ""CBcXEwIFARocBBcHFwEXEBcDAgUBGhwFFwAXBxcBFxAXBAAAAAIAAAAwBAAANgQAAAEAAAA/BAAA"" +                     ""AQAAAE0EAABgBAAAAQAAAAEAAAAAAAAAAAAAAGwEAAAAAAAAdAQAABAAAAAAAAAAAQAAAAAAAAAB"" +                     ""AAAAGwAAAHAAAAACAAAACQAAANwAAAADAAAAAwAAAAABAAAEAAAAAQAAACQBAAAFAAAABgAAACwB"" +                     ""AAAGAAAAAQAAAFwBAAACIAAAGwAAAHwBAAABEAAAAgAAAHwDAAADIAAABQAAAIwDAAABIAAABQAA"" +                     ""AKgDAAAAIAAAAQAAABQEAAAEIAAABAAAADAEAAADEAAAAwAAAGAEAAAGIAAAAQAAAHwEAAAAEAAA"" +                     ""AQAAAJwEAAA=""),             /**              * Base64 for this class.              *              *  static class Transform {              *    public Transform(Consumer<String> reporter) { }              *    private void Start() { }              *    private void Finish() { }              *    public void sayHi(Runnable r) { }              *  }             */             new RedefineError(                     JvmtiErrors.UNSUPPORTED_REDEFINITION_SCHEMA_CHANGED, Transform.class,                     ""ZGV4CjAzNQCn0K9/AAAAAAAAAAAAAAAAAAAAAAAAAADkBAAAcAAAAHhWNBIAAAAAAAAAACwEAAAY"" +                     ""AAAAcAAAAAkAAADQAAAAAwAAAPQAAAAAAAAAAAAAAAUAAAAYAQAAAQAAAEABAACEAwAAYAEAAGAB"" +                     ""AABjAQAAZgEAAG4BAAB0AQAAfAEAAJsBAADRAQAACAIAAEACAABuAgAAkgIAALICAADRAgAA5QIA"" +                     ""APsCAAAPAwAAFgMAACEDAAAkAwAAKAMAADUDAAA7AwAAQgMAAAcAAAAIAAAACQAAAAoAAAALAAAA"" +                     ""DAAAAA0AAAAOAAAAEgAAABIAAAAIAAAAAAAAABMAAAAIAAAATAMAABMAAAAIAAAAVAMAAAEAAQAC"" +                     ""AAAAAQAAAAQAAAABAAAAEAAAAAEAAgAWAAAABgAAAAIAAAABAAAAAAAAAAYAAAAAAAAABQAAABQE"" +                     ""AADIAwAAAAAAAAEoAAE8AAY8aW5pdD4ABD47KVYABkZpbmlzaAAdSnZtdGlSZWRlZmluZUNsYXNz"" +                     ""ZXNUZXN0LmphdmEANExhbmRyb2lkL2p2bXRpL2N0cy9Kdm10aVJlZGVmaW5lQ2xhc3Nlc1Rlc3Qk"" +                     ""Q29uc3VtZXIANUxhbmRyb2lkL2p2bXRpL2N0cy9Kdm10aVJlZGVmaW5lQ2xhc3Nlc1Rlc3QkQ29u"" +                     ""c3VtZXI7ADZMYW5kcm9pZC9qdm10aS9jdHMvSnZtdGlSZWRlZmluZUNsYXNzZXNUZXN0JFRyYW5z"" +                     ""Zm9ybTsALExhbmRyb2lkL2p2bXRpL2N0cy9Kdm10aVJlZGVmaW5lQ2xhc3Nlc1Rlc3Q7ACJMZGFs"" +                     ""dmlrL2Fubm90YXRpb24vRW5jbG9zaW5nQ2xhc3M7AB5MZGFsdmlrL2Fubm90YXRpb24vSW5uZXJD"" +                     ""bGFzczsAHUxkYWx2aWsvYW5ub3RhdGlvbi9TaWduYXR1cmU7ABJMamF2YS9sYW5nL09iamVjdDsA"" +                     ""FExqYXZhL2xhbmcvUnVubmFibGU7ABJMamF2YS9sYW5nL1N0cmluZzsABVN0YXJ0AAlUcmFuc2Zv"" +                     ""cm0AAVYAAlZMAAthY2Nlc3NGbGFncwAEbmFtZQAFc2F5SGkABXZhbHVlAAAAAAEAAAAAAAAAAQAA"" +                     ""AAcAAAAMAQAHDgAOAAcOAA0ABw4ADwEABw4AAAACAAIAAQAAAFwDAAAEAAAAcBAEAAAADgABAAEA"" +                     ""AAAAAGIDAAABAAAADgAAAAEAAQAAAAAAZwMAAAEAAAAOAAAAAgACAAAAAABsAwAAAQAAAA4AAAAA"" +                     ""AAMBAIGABPQGAQKMBwECoAcDAbQHAAACAwEXGAICBAIUBAgVFxECBQEXHAUXABcGFwEXDxcDAAIA"" +                     ""AADgAwAA5gMAAAEAAADvAwAAAAQAAAAAAAABAAAAAAAAAAAAAAAMBAAADwAAAAAAAAABAAAAAAAA"" +                     ""AAEAAAAYAAAAcAAAAAIAAAAJAAAA0AAAAAMAAAADAAAA9AAAAAUAAAAFAAAAGAEAAAYAAAABAAAA"" +                     ""QAEAAAIgAAAYAAAAYAEAAAEQAAACAAAATAMAAAMgAAAEAAAAXAMAAAEgAAAEAAAAdAMAAAAgAAAB"" +                     ""AAAAyAMAAAQgAAADAAAA4AMAAAMQAAACAAAAAAQAAAYgAAABAAAAFAQAAAAQAAABAAAALAQAAA==""),             /**              * Base64 for this class.              *              *  static class Transform3 {              *      // NB This field has type Landroid/jvmti/cts/JvmtiRedefineClassesTest$Consumer;              *      private Consumer<String> reporter;              *      public Transform3(Consumer<String> reporter) { this.reporter = reporter; }              *      private void Start() { }              *      private void Finish() { }              *      public void sayHi(Runnable r) { }              *  }             */             new RedefineError(                     JvmtiErrors.NAMES_DONT_MATCH, Transform.class,                     ""ZGV4CjAzNQCc2B3nAAAAAAAAAAAAAAAAAAAAAAAAAAA0BQAAcAAAAHhWNBIAAAAAAAAAAHAEAAAa"" +                     ""AAAAcAAAAAkAAADYAAAAAwAAAPwAAAABAAAAIAEAAAUAAAAoAQAAAQAAAFABAADEAwAAcAEAAHAB"" +                     ""AABzAQAAdgEAAH4BAACCAQAAiAEAAJABAACvAQAA5QEAABwCAABVAgAAgwIAAKcCAADHAgAA5gIA"" +                     ""APoCAAAQAwAAJAMAACsDAAA3AwAAOgMAAD4DAABLAwAAUQMAAFsDAABiAwAACAAAAAkAAAAKAAAA"" +                     ""CwAAAAwAAAANAAAADgAAAA8AAAATAAAAEwAAAAgAAAAAAAAAFAAAAAgAAABsAwAAFAAAAAgAAAB0"" +                     ""AwAAAQAAABcAAAABAAEAAgAAAAEAAAAFAAAAAQAAABEAAAABAAIAGAAAAAYAAAACAAAAAQAAAAAA"" +                     ""AAAGAAAAAAAAAAYAAABQBAAA7AMAAAAAAAABKAABPAAGPGluaXQ+AAI+OwAEPjspVgAGRmluaXNo"" +                     ""AB1Kdm10aVJlZGVmaW5lQ2xhc3Nlc1Rlc3QuamF2YQA0TGFuZHJvaWQvanZtdGkvY3RzL0p2bXRp"" +                     ""UmVkZWZpbmVDbGFzc2VzVGVzdCRDb25zdW1lcgA1TGFuZHJvaWQvanZtdGkvY3RzL0p2bXRpUmVk"" +                     ""ZWZpbmVDbGFzc2VzVGVzdCRDb25zdW1lcjsAN0xhbmRyb2lkL2p2bXRpL2N0cy9Kdm10aVJlZGVm"" +                     ""aW5lQ2xhc3Nlc1Rlc3QkVHJhbnNmb3JtMzsALExhbmRyb2lkL2p2bXRpL2N0cy9Kdm10aVJlZGVm"" +                     ""aW5lQ2xhc3Nlc1Rlc3Q7ACJMZGFsdmlrL2Fubm90YXRpb24vRW5jbG9zaW5nQ2xhc3M7AB5MZGFs"" +                     ""dmlrL2Fubm90YXRpb24vSW5uZXJDbGFzczsAHUxkYWx2aWsvYW5ub3RhdGlvbi9TaWduYXR1cmU7"" +                     ""ABJMamF2YS9sYW5nL09iamVjdDsAFExqYXZhL2xhbmcvUnVubmFibGU7ABJMamF2YS9sYW5nL1N0"" +                     ""cmluZzsABVN0YXJ0AApUcmFuc2Zvcm0zAAFWAAJWTAALYWNjZXNzRmxhZ3MABG5hbWUACHJlcG9y"" +                     ""dGVyAAVzYXlIaQAFdmFsdWUAAAAAAQAAAAAAAAABAAAABwAAAAwBAAcOAA4ABw4ADQAHDgAPAQAH"" +                     ""DgAAAAIAAgABAAAAfAMAAAYAAABwEAQAAABbAQAADgABAAEAAAAAAIIDAAABAAAADgAAAAEAAQAA"" +                     ""AAAAhwMAAAEAAAAOAAAAAgACAAAAAACMAwAAAQAAAA4AAAAAAQMBAAIAgYAElAcBArAHAQLEBwMB"" +                     ""2AcCAwEZGAICBAIVBAgWFxICBQEZHAQXBxcBFxAXAwIFARkcBRcAFwcXARcQFwQAAAACAAAABAQA"" +                     ""AAoEAAABAAAAEwQAAAEAAAAhBAAANAQAAAEAAAABAAAAAAAAAAAAAABABAAAAAAAAEgEAAAQAAAA"" +                     ""AAAAAAEAAAAAAAAAAQAAABoAAABwAAAAAgAAAAkAAADYAAAAAwAAAAMAAAD8AAAABAAAAAEAAAAg"" +                     ""AQAABQAAAAUAAAAoAQAABgAAAAEAAABQAQAAAiAAABoAAABwAQAAARAAAAIAAABsAwAAAyAAAAQA"" +                     ""AAB8AwAAASAAAAQAAACUAwAAACAAAAEAAADsAwAABCAAAAQAAAAEBAAAAxAAAAMAAAA0BAAABiAA"" +                     ""AAEAAABQBAAAABAAAAEAAABwBAAA""),             /**              * Base64 for this class.              *              *  static class Transform extends Observable {              *      // NB This field has type Landroid/jvmti/cts/JvmtiRedefineClassesTest$Consumer;              *      private Consumer<String> reporter;              *      public Transform(Consumer<String> reporter) { super(); this.reporter = reporter; }              *      private void Start() { }              *      private void Finish() { }              *      public void sayHi(Runnable r) { }              *  }             */             new RedefineError(                     JvmtiErrors.UNSUPPORTED_REDEFINITION_HIERARCHY_CHANGED, Transform.class,                     ""ZGV4CjAzNQAV2qEZAAAAAAAAAAAAAAAAAAAAAAAAAAA0BQAAcAAAAHhWNBIAAAAAAAAAAHAEAAAa"" +                     ""AAAAcAAAAAkAAADYAAAAAwAAAPwAAAABAAAAIAEAAAUAAAAoAQAAAQAAAFABAADEAwAAcAEAAHAB"" +                     ""AABzAQAAdgEAAH4BAACCAQAAiAEAAJABAACvAQAA5QEAABwCAABUAgAAggIAAKYCAADGAgAA5QIA"" +                     ""APsCAAAPAwAAJwMAAC4DAAA5AwAAPAMAAEADAABNAwAAUwMAAF0DAABkAwAACAAAAAkAAAAKAAAA"" +                     ""CwAAAAwAAAANAAAADgAAABAAAAATAAAAEwAAAAgAAAAAAAAAFAAAAAgAAABsAwAAFAAAAAgAAAB0"" +                     ""AwAAAQAAABcAAAABAAEAAgAAAAEAAAAFAAAAAQAAABEAAAABAAIAGAAAAAcAAAACAAAAAQAAAAAA"" +                     ""AAAHAAAAAAAAAAYAAABQBAAA7AMAAAAAAAABKAABPAAGPGluaXQ+AAI+OwAEPjspVgAGRmluaXNo"" +                     ""AB1Kdm10aVJlZGVmaW5lQ2xhc3Nlc1Rlc3QuamF2YQA0TGFuZHJvaWQvanZtdGkvY3RzL0p2bXRp"" +                     ""UmVkZWZpbmVDbGFzc2VzVGVzdCRDb25zdW1lcgA1TGFuZHJvaWQvanZtdGkvY3RzL0p2bXRpUmVk"" +                     ""ZWZpbmVDbGFzc2VzVGVzdCRDb25zdW1lcjsANkxhbmRyb2lkL2p2bXRpL2N0cy9Kdm10aVJlZGVm"" +                     ""aW5lQ2xhc3Nlc1Rlc3QkVHJhbnNmb3JtOwAsTGFuZHJvaWQvanZtdGkvY3RzL0p2bXRpUmVkZWZp"" +                     ""bmVDbGFzc2VzVGVzdDsAIkxkYWx2aWsvYW5ub3RhdGlvbi9FbmNsb3NpbmdDbGFzczsAHkxkYWx2"" +                     ""aWsvYW5ub3RhdGlvbi9Jbm5lckNsYXNzOwAdTGRhbHZpay9hbm5vdGF0aW9uL1NpZ25hdHVyZTsA"" +                     ""FExqYXZhL2xhbmcvUnVubmFibGU7ABJMamF2YS9sYW5nL1N0cmluZzsAFkxqYXZhL3V0aWwvT2Jz"" +                     ""ZXJ2YWJsZTsABVN0YXJ0AAlUcmFuc2Zvcm0AAVYAAlZMAAthY2Nlc3NGbGFncwAEbmFtZQAIcmVw"" +                     ""b3J0ZXIABXNheUhpAAV2YWx1ZQAAAQAAAAAAAAABAAAABgAAAA0BAAcOAA8ABw4ADgAHDgAQAQAH"" +                     ""DgAAAAIAAgABAAAAfAMAAAYAAABwEAQAAABbAQAADgABAAEAAAAAAIIDAAABAAAADgAAAAEAAQAA"" +                     ""AAAAhwMAAAEAAAAOAAAAAgACAAAAAACMAwAAAQAAAA4AAAAAAQMBAAIAgYAElAcBArAHAQLEBwMB"" +                     ""2AcCAwEZGAICBAIVBAgWFxICBQEZHAQXBxcBFw8XAwIFARkcBRcAFwcXARcPFwQAAAACAAAABAQA"" +                     ""AAoEAAABAAAAEwQAAAEAAAAhBAAANAQAAAEAAAABAAAAAAAAAAAAAABABAAAAAAAAEgEAAAQAAAA"" +                     ""AAAAAAEAAAAAAAAAAQAAABoAAABwAAAAAgAAAAkAAADYAAAAAwAAAAMAAAD8AAAABAAAAAEAAAAg"" +                     ""AQAABQAAAAUAAAAoAQAABgAAAAEAAABQAQAAAiAAABoAAABwAQAAARAAAAIAAABsAwAAAyAAAAQA"" +                     ""AAB8AwAAASAAAAQAAACUAwAAACAAAAEAAADsAwAABCAAAAQAAAAEBAAAAxAAAAMAAAA0BAAABiAA"" +                     ""AAEAAABQBAAAABAAAAEAAABwBAAA""),             /**              * Array classes are never modifiable.              *              * The base64 data is just an empty dex file. It has no classes associated with it.             */             new RedefineError(JvmtiErrors.UNMODIFIABLE_CLASS, Transform[].class,                     ""ZGV4CjAzNQCRAy8PAAAAAAAAAAAAAAAAAAAAAAAAAACMAAAAcAAAAHhWNBIAAAAAAAAAAHAAAAAA"" +                     ""AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcAAAAcAAAAAIA"" +                     ""AAAAAAAAAQAAAAAAAAAAEAAAAQAAAHAAAAA=""),     };"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.jvmti.cts.JvmtiRedefineClassesTest"	"testRetransformFailures"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	"v4"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/jvmti/redefining/app/src/android/jvmti/cts/JvmtiRedefineClassesTest.java"	""	"public void testRetransformFailures() throws Exception {         setTransformationEvent(true);         setPopTransformations(true);         for (RedefineError e : FAILING_DEX_FILES) {             checkRetransformation(e);         }     }      private static final String ONLOAD_TEST_CLASS_NAME =             ""android.jvmti.cts.memory_dex.TransformTarget"";     /**      * Base64 encoded version of the following class.      * package android.jvmti.cts.memory_dex;      * <p>      * public class TransformTarget {      * public void alpha() { }      * public void beta() { }      * }      */     private static final byte[] ONLOAD_INITIAL_CLASS = Base64.getDecoder().decode(             ""ZGV4CjAzNQAQT37mO0bz7SniP0I8RLnGvVsfM5ybXmdYAgAAcAAAAHhWNBIAAAAAAAAAANABAAAI"" +             ""AAAAcAAAAAMAAACQAAAAAQAAAJwAAAAAAAAAAAAAAAQAAACoAAAAAQAAAMgAAABwAQAA6AAAACgB"" +             ""AAAwAQAAYAEAAHQBAACKAQAAjQEAAJQBAACaAQAAAQAAAAIAAAAEAAAABAAAAAIAAAAAAAAAAAAA"" +             ""AAAAAAAAAAAABQAAAAAAAAAGAAAAAQAAAAAAAAAAAAAAAQAAAAEAAAAAAAAAAwAAAAAAAAC9AQAA"" +             ""AAAAAAEAAQABAAAArgEAAAQAAABwEAMAAAAOAAEAAQAAAAAAswEAAAEAAAAOAAAAAQABAAAAAAC4"" +             ""AQAAAQAAAA4AAAAGPGluaXQ+AC5MYW5kcm9pZC9qdm10aS9jdHMvbWVtb3J5X2RleC9UcmFuc2Zv"" +             ""cm1UYXJnZXQ7ABJMamF2YS9sYW5nL09iamVjdDsAFFRyYW5zZm9ybVRhcmdldC5qYXZhAAFWAAVh"" +             ""bHBoYQAEYmV0YQASZW1pdHRlcjogamFjay00LjI4AAIABw4AAwAHDgAEAAcOAAAAAQIAgYAE6AEB"" +             ""AYACAQGUAgALAAAAAAAAAAEAAAAAAAAAAQAAAAgAAABwAAAAAgAAAAMAAACQAAAAAwAAAAEAAACc"" +             ""AAAABQAAAAQAAACoAAAABgAAAAEAAADIAAAAASAAAAMAAADoAAAAAiAAAAgAAAAoAQAAAyAAAAMA"" +             ""AACuAQAAACAAAAEAAAC9AQAAABAAAAEAAADQAQAA"");     /**      * Base64 encoded version of the following class.      * Note that this would be an illegal transformation if the class had been loaded as the first      * one.      * <p>      * package android.jvmti.cts.memory_dex;      * <p>      * public class TransformTarget {      * public void alpha(int abc) {      * }      * public int beta() {      * return 12;      * }      * public void gamma() {      * }      * }      */     private static final byte[] ONLOAD_FINAL_CLASS = Base64.getDecoder().decode(             ""ZGV4CjAzNQA5VqbusSyl8/G1EXrbm9uRuiHvkP4XixrMAgAAcAAAAHhWNBIAAAAAAAAAADgCAAAL"" +             ""AAAAcAAAAAQAAACcAAAAAwAAAKwAAAAAAAAAAAAAAAUAAADQAAAAAQAAAPgAAAC0AQAAGAEAAHYB"" +             ""AAB+AQAAgQEAALEBAADFAQAA2wEAAN4BAADiAQAA6QEAAO8BAAADAgAAAQAAAAIAAAADAAAABQAA"" +             ""AAEAAAAAAAAAAAAAAAUAAAADAAAAAAAAAAYAAAADAAAAcAEAAAEAAQAAAAAAAQACAAcAAAABAAAA"" +             ""CAAAAAEAAQAKAAAAAgABAAAAAAABAAAAAQAAAAIAAAAAAAAABAAAAAAAAAAfAgAAAAAAAAEAAQAB"" +             ""AAAACgIAAAQAAABwEAQAAAAOAAIAAgAAAAAADwIAAAEAAAAOAAAAAgABAAAAAAAVAgAAAwAAABMA"" +             ""DAAPAAAAAQABAAAAAAAaAgAAAQAAAA4AAAABAAAAAAAGPGluaXQ+AAFJAC5MYW5kcm9pZC9qdm10"" +             ""aS9jdHMvbWVtb3J5X2RleC9UcmFuc2Zvcm1UYXJnZXQ7ABJMamF2YS9sYW5nL09iamVjdDsAFFRy"" +             ""YW5zZm9ybVRhcmdldC5qYXZhAAFWAAJWSQAFYWxwaGEABGJldGEAEmVtaXR0ZXI6IGphY2stNC4y"" +             ""OAAFZ2FtbWEAAgAHDgAEAQAHDgAGAAcOAAkABw4AAAABAwCBgASYAgEBsAIBAcQCAQHcAgAAAAwA"" +             ""AAAAAAAAAQAAAAAAAAABAAAACwAAAHAAAAACAAAABAAAAJwAAAADAAAAAwAAAKwAAAAFAAAABQAA"" +             ""ANAAAAAGAAAAAQAAAPgAAAABIAAABAAAABgBAAABEAAAAQAAAHABAAACIAAACwAAAHYBAAADIAAA"" +             ""BAAAAAoCAAAAIAAAAQAAAB8CAAAAEAAAAQAAADgCAAA="");      private static class ExpectedMethod {         public final Class<?> returnType;         public final String name;         public final Class<?>[] params;          public ExpectedMethod(Class<?> returnType, String name, Class<?>... params) {             this.returnType = returnType;             this.name = name;             this.params = params;         }          public void ensureHasMethod(Class<?> klass) throws Exception {             try {                 assertEquals(returnType, klass.getDeclaredMethod(name, params).getReturnType());             } catch (NoSuchMethodException e) {                 Assert.fail(""Could not find method: "" + klass + "": "" + name +                         "" (params: "" + Arrays.toString(params) + ""). Reason was "" + e);             }         }     }      private void checkClassHasMethods(Class<?> target, ExpectedMethod[] methods) throws Exception {         for (ExpectedMethod m : methods) {             m.ensureHasMethod(target);         }     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"com.android.cts.deviceowner.NetworkLoggingTest"	"testNetworkLoggingAndRetrieval"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	"v4"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/app/DeviceOwner/src/com/android/cts/deviceowner/NetworkLoggingTest.java"	""	"public void testNetworkLoggingAndRetrieval() throws Exception {         mBatchesRequested =                 Integer.parseInt(                         InstrumentationRegistry.getArguments().getString(ARG_BATCH_COUNT, ""1""));         mBatchCountDown = new CountDownLatch(mBatchesRequested);         // register a receiver that listens for DeviceAdminReceiver#onNetworkLogsAvailable()         final IntentFilter filterNetworkLogsAvailable = new IntentFilter(                 BasicAdminReceiver.ACTION_NETWORK_LOGS_AVAILABLE);         LocalBroadcastManager.getInstance(mContext).registerReceiver(mNetworkLogsReceiver,                 filterNetworkLogsAvailable);          // visit websites that shouldn't be logged as network logging isn't enabled yet         for (final String url : NOT_LOGGED_URLS_LIST) {             connectToWebsite(url);         }          // enable network logging and start the logging scenario         mDevicePolicyManager.setNetworkLoggingEnabled(getWho(), true);         assertTrue(mDevicePolicyManager.isNetworkLoggingEnabled(getWho()));          // TODO: here test that facts about logging are shown in the UI          // Fetch and verify the batches of events.         generateBatches();     }      private void generateBatches() throws Exception {         // visit websites to verify their dns lookups are logged         for (final String url : LOGGED_URLS_LIST) {             connectToWebsite(url);         }          // generate enough traffic to fill the batches.         int dummyReqNo = 0;         for (int i = 0; i < mBatchesRequested; i++) {             dummyReqNo += generateDummyTraffic();         }          // if DeviceAdminReceiver#onNetworkLogsAvailable() hasn't been triggered yet, wait for up to         // 3 minutes per batch just in case         final int timeoutMins = 3 * mBatchesRequested;         mBatchCountDown.await(timeoutMins, TimeUnit.MINUTES);         LocalBroadcastManager.getInstance(mContext).unregisterReceiver(mNetworkLogsReceiver);         if (mBatchCountDown.getCount() > 0) {             fail(""Generated events for "" + mBatchesRequested + "" batches and waited for ""                     + timeoutMins + "" minutes, but still didn't get""                     + "" DeviceAdminReceiver#onNetworkLogsAvailable() callback"");         }          // Verify network logs.         assertEquals(""First event has the wrong id."", 0L, mNetworkEvents.get(0).getId());         // For each of the real URLs we have two events: one DNS and one connect. Dummy requests         // don't require DNS queries.         final int eventsExpected =                 Math.min(FULL_LOG_BATCH_SIZE * mBatchesRequested,                         2 * LOGGED_URLS_LIST.length + dummyReqNo);         verifyNetworkLogs(mNetworkEvents, eventsExpected);     }      private void verifyDnsEvent(DnsEvent dnsEvent) {         // Verify that we didn't log a hostname lookup when network logging was disabled.         if (dnsEvent.getHostname().contains(NOT_LOGGED_URLS_LIST[0])                 || dnsEvent.getHostname().contains(NOT_LOGGED_URLS_LIST[1])) {             fail(""A hostname that was looked-up when network logging was disabled""                     + "" was logged."");         }          // Verify that as many IP addresses were logged as were reported (max 10).         final List<InetAddress> ips = dnsEvent.getInetAddresses();         assertThat(ips.size()).isAtMost(MAX_IP_ADDRESSES_LOGGED);         final int expectedAddressCount = Math.min(MAX_IP_ADDRESSES_LOGGED,                 dnsEvent.getTotalResolvedAddressCount());         assertThat(expectedAddressCount).isEqualTo(ips.size());          // Verify the IP addresses are valid IPv4 or IPv6 addresses.         for (final InetAddress ipAddress : ips) {             assertTrue(isIpv4OrIpv6Address(ipAddress));         }          //Verify writeToParcel.         Parcel parcel = Parcel.obtain();         try {             dnsEvent.writeToParcel(parcel, 0);             parcel.setDataPosition(0);             final DnsEvent dnsEventOut = DnsEvent.CREATOR.createFromParcel(parcel);             assertThat(dnsEventOut).isNotNull();             verifyDnsEventsEqual(dnsEvent, dnsEventOut);         } finally {             parcel.recycle();         }     }      private void verifyDnsEventsEqual(DnsEvent event1, DnsEvent event2) {         assertThat(event1.getHostname()).isEqualTo(event2.getHostname());         assertThat(new HashSet<InetAddress>(event1.getInetAddresses())).isEqualTo(                         new HashSet<InetAddress>(event2.getInetAddresses()));         assertThat(event1.getTotalResolvedAddressCount()).isEqualTo(                 event2.getTotalResolvedAddressCount());         assertThat(event1.getPackageName()).isEqualTo(event2.getPackageName());         assertThat(event1.getTimestamp()).isEqualTo(event2.getTimestamp());         assertThat(event1.getId()).isEqualTo(event2.getId());     }      private void verifyConnectEvent(ConnectEvent connectEvent) {         // Verify the IP address is a valid IPv4 or IPv6 address.         final InetAddress ip = connectEvent.getInetAddress();         assertThat(isIpv4OrIpv6Address(ip)).isTrue();          // Verify that the port is a valid port.         assertThat(connectEvent.getPort()).isAtLeast(0);         assertThat(connectEvent.getPort()).isAtMost(65535);          // Verify writeToParcel.         Parcel parcel = Parcel.obtain();         try {             connectEvent.writeToParcel(parcel, 0);             parcel.setDataPosition(0);             final ConnectEvent connectEventOut = ConnectEvent.CREATOR.createFromParcel(parcel);             assertThat(connectEventOut).isNotNull();             verifyConnectEventsEqual(connectEvent, connectEventOut);         } finally {              parcel.recycle();         }     }      private void verifyConnectEventsEqual(ConnectEvent event1, ConnectEvent event2) {         assertThat(event1.getInetAddress()).isEqualTo(event2.getInetAddress());         assertThat(event1.getPort()).isEqualTo(event2.getPort());         assertThat(event1.getPackageName()).isEqualTo(event2.getPackageName());         assertThat(event1.getTimestamp()).isEqualTo(event2.getTimestamp());         assertThat(event1.getId()).isEqualTo(event2.getId());     }      private void verifyNetworkLogs(List<NetworkEvent> networkEvents, int eventsExpected) {         // allow a batch to be slightly smaller or larger.         assertTrue(Math.abs(eventsExpected - networkEvents.size()) <= 150);         int ctsPackageNameCounter = 0;         // allow a small down margin for verification, to avoid flakiness         final int eventsExpectedWithMargin = eventsExpected - 50;         final boolean[] visited = new boolean[LOGGED_URLS_LIST.length];          for (int i = 0; i < networkEvents.size(); i++) {             final NetworkEvent currentEvent = networkEvents.get(i);             // verify that the events are in chronological order             if (i > 0) {                 assertTrue(currentEvent.getTimestamp() >= networkEvents.get(i - 1).getTimestamp());             }             // verify that the event IDs are monotonically increasing             if (i > 0) {                 assertTrue(currentEvent.getId() == (networkEvents.get(i - 1).getId() + 1));             }             // count how many events come from the CTS app             if (CTS_APP_PACKAGE_NAME.equals(currentEvent.getPackageName())) {                 ctsPackageNameCounter++;                 if (currentEvent instanceof DnsEvent) {                     final DnsEvent dnsEvent = (DnsEvent) currentEvent;                     // Mark which addresses from LOGGED_URLS_LIST were visited.                     for (int j = 0; j < LOGGED_URLS_LIST.length; j++) {                         if (dnsEvent.getHostname().contains(LOGGED_URLS_LIST[j])) {                             visited[j] = true;                             break;                         }                     }                      verifyDnsEvent(dnsEvent);                 } else if (currentEvent instanceof ConnectEvent) {                     final ConnectEvent connectEvent = (ConnectEvent) currentEvent;                     verifyConnectEvent(connectEvent);                 } else {                     fail(""An unknown NetworkEvent type logged: ""                             + currentEvent.getClass().getName());                 }             }         }          // verify that each hostname from LOGGED_URLS_LIST was looked-up         for (int i = 0; i < 10; i++) {             assertTrue(LOGGED_URLS_LIST[i] + "" wasn't visited"", visited[i]);         }         // verify that sufficient iterations done by the CTS app were logged         assertTrue(ctsPackageNameCounter >= eventsExpectedWithMargin);     }      private void connectToWebsite(String server) {         HttpURLConnection urlConnection = null;         try {             final URL url = new URL(""http://"" + server);             urlConnection = (HttpURLConnection) url.openConnection();             urlConnection.setConnectTimeout(2000);             urlConnection.setReadTimeout(2000);             urlConnection.getResponseCode();         } catch (IOException e) {             Log.w(TAG, ""Failed to connect to "" + server, e);         } finally {             if (urlConnection != null) {                 urlConnection.disconnect();             }         }     }      /** Quickly generate loads of events by repeatedly connecting to a local server. */     private int generateDummyTraffic() throws IOException, InterruptedException {         final ServerSocket serverSocket = new ServerSocket(0);         final Thread serverThread = startDummyServer(serverSocket);          final int reqNo = makeDummyRequests(serverSocket.getLocalPort());          serverSocket.close();         serverThread.join();          return reqNo;     }      private int makeDummyRequests(int port) {         int reqNo;         final String DUMMY_SERVER = ""127.0.0.1:"" + port;         for (reqNo = 0; reqNo < FULL_LOG_BATCH_SIZE && mBatchCountDown.getCount() > 0; reqNo++) {             connectToWebsite(DUMMY_SERVER);             try {                 // Just to prevent choking the server.                 Thread.sleep(10);             } catch (InterruptedException e) {                 Thread.currentThread().interrupt();             }         }         return reqNo;     }      private Thread startDummyServer(ServerSocket serverSocket) throws InterruptedException {         final Thread serverThread = new Thread(() -> {             while (!serverSocket.isClosed()) {                 try {                     final Socket socket = serverSocket.accept();                     // Consume input.                     final BufferedReader input =                             new BufferedReader(new InputStreamReader(socket.getInputStream()));                     String line;                     do {                         line = input.readLine();                     } while (line != null && !line.equals(""""));                     // Return minimum valid response.                     final PrintStream output = new PrintStream(socket.getOutputStream());                     output.println(""HTTP/1.0 200 OK"");                     output.println(""Content-Length: 0"");                     output.println();                     output.flush();                     output.close();                 } catch (IOException e) {                     if (!serverSocket.isClosed()) {                         Log.w(TAG, ""Failed to serve connection"", e);                     }                 }             }         });         serverThread.start();          // Allow the server to start accepting.         Thread.sleep(1_000);          return serverThread;     }      private boolean isIpv4OrIpv6Address(InetAddress addr) {         return ((addr instanceof Inet4Address) || (addr instanceof Inet6Address));     } }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.net.ipsec.ike.cts.IkeSessionParamsTest"	"tearDownTestNetwork"	"CtsIkeTestCases"	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	"v4"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/ipsec/src/android/net/ipsec/ike/cts/IkeSessionParamsTest.java"	""	"/*  *.  */  package android.net.ipsec.ike.cts;  import static android.net.ipsec.ike.IkeSessionParams.IKE_OPTION_ACCEPT_ANY_REMOTE_ID; import static android.net.ipsec.ike.IkeSessionParams.IKE_OPTION_EAP_ONLY_AUTH; import static android.net.ipsec.ike.IkeSessionParams.IkeAuthConfig; import static android.net.ipsec.ike.IkeSessionParams.IkeAuthDigitalSignLocalConfig; import static android.net.ipsec.ike.IkeSessionParams.IkeAuthDigitalSignRemoteConfig; import static android.net.ipsec.ike.IkeSessionParams.IkeAuthEapConfig; import static android.net.ipsec.ike.IkeSessionParams.IkeAuthPskConfig; import static android.system.OsConstants.AF_INET; import static android.system.OsConstants.AF_INET6; import static android.telephony.TelephonyManager.APPTYPE_USIM;  import static org.junit.Assert.assertArrayEquals; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail;  import android.net.eap.EapSessionConfig; import android.net.ipsec.ike.IkeFqdnIdentification; import android.net.ipsec.ike.IkeIdentification; import android.net.ipsec.ike.IkeSaProposal; import android.net.ipsec.ike.IkeSessionParams; import android.net.ipsec.ike.IkeSessionParams.ConfigRequestIpv4PcscfServer; import android.net.ipsec.ike.IkeSessionParams.ConfigRequestIpv6PcscfServer; import android.net.ipsec.ike.IkeSessionParams.IkeConfigRequest;  import androidx.test.ext.junit.runners.AndroidJUnit4;  import com.android.internal.net.ipsec.ike.testutils.CertUtils;  import org.junit.After; import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith;  import java.net.InetAddress; import java.security.cert.X509Certificate; import java.security.interfaces.RSAPrivateKey; import java.util.Arrays; import java.util.Collections; import java.util.HashMap; import java.util.HashSet; import java.util.List; import java.util.Map; import java.util.Set; import java.util.concurrent.TimeUnit;  @RunWith(AndroidJUnit4.class) public final class IkeSessionParamsTest extends IkeSessionTestBase {     private static final int HARD_LIFETIME_SECONDS = (int) TimeUnit.HOURS.toSeconds(20L);     private static final int SOFT_LIFETIME_SECONDS = (int) TimeUnit.HOURS.toSeconds(10L);     private static final int DPD_DELAY_SECONDS = (int) TimeUnit.MINUTES.toSeconds(10L);     private static final int[] RETRANS_TIMEOUT_MS_LIST = new int[] {500, 500, 500, 500, 500, 500};      private static final Map<Class<? extends IkeConfigRequest>, Integer> EXPECTED_REQ_COUNT =             new HashMap<>();     private static final HashSet<InetAddress> EXPECTED_PCSCF_SERVERS = new HashSet<>();      static {         EXPECTED_REQ_COUNT.put(ConfigRequestIpv4PcscfServer.class, 3);         EXPECTED_REQ_COUNT.put(ConfigRequestIpv6PcscfServer.class, 3);          EXPECTED_PCSCF_SERVERS.add(PCSCF_IPV4_ADDRESS_1);         EXPECTED_PCSCF_SERVERS.add(PCSCF_IPV4_ADDRESS_2);         EXPECTED_PCSCF_SERVERS.add(PCSCF_IPV6_ADDRESS_1);         EXPECTED_PCSCF_SERVERS.add(PCSCF_IPV6_ADDRESS_2);     }      // Arbitrary proposal and remote ID. Local ID is chosen to match the client end cert in the     // following CL     private static final IkeSaProposal SA_PROPOSAL =             SaProposalTest.buildIkeSaProposalWithNormalModeCipher();     private static final IkeIdentification LOCAL_ID = new IkeFqdnIdentification(LOCAL_HOSTNAME);     private static final IkeIdentification REMOTE_ID = new IkeFqdnIdentification(REMOTE_HOSTNAME);      private static final EapSessionConfig EAP_ALL_METHODS_CONFIG =             createEapOnlySafeMethodsBuilder()                     .setEapMsChapV2Config(EAP_MSCHAPV2_USERNAME, EAP_MSCHAPV2_PASSWORD)                     .build();     private static final EapSessionConfig EAP_ONLY_SAFE_METHODS_CONFIG =             createEapOnlySafeMethodsBuilder().build();      private X509Certificate mServerCaCert;     private X509Certificate mClientEndCert;     private X509Certificate mClientIntermediateCaCertOne;     private X509Certificate mClientIntermediateCaCertTwo;     private RSAPrivateKey mClientPrivateKey;      @Before     public void setUp() throws Exception {         // This address is never used except for setting up the test network         setUpTestNetwork(IPV4_ADDRESS_LOCAL);          mServerCaCert = CertUtils.createCertFromPemFile(""server-a-self-signed-ca.pem"");         mClientEndCert = CertUtils.createCertFromPemFile(""client-a-end-cert.pem"");         mClientIntermediateCaCertOne =                 CertUtils.createCertFromPemFile(""client-a-intermediate-ca-one.pem"");         mClientIntermediateCaCertTwo =                 CertUtils.createCertFromPemFile(""client-a-intermediate-ca-two.pem"");         mClientPrivateKey = CertUtils.createRsaPrivateKeyFromKeyFile(""client-a-private-key.key"");     }      @After     public void tearDown() throws Exception {         tearDownTestNetwork();     }      private static EapSessionConfig.Builder createEapOnlySafeMethodsBuilder() {         return new EapSessionConfig.Builder()                 .setEapIdentity(EAP_IDENTITY)                 .setEapSimConfig(SUB_ID, APPTYPE_USIM)                 .setEapAkaConfig(SUB_ID, APPTYPE_USIM)                 .setEapAkaPrimeConfig(                         SUB_ID, APPTYPE_USIM, NETWORK_NAME, true /* allowMismatchedNetworkNames */);     }      /**      * Create a Builder that has minimum configurations to build an IkeSessionParams.      *      * <p>Authentication method is arbitrarily selected. Using other method (e.g. setAuthEap) also      * works.      */     private IkeSessionParams.Builder createIkeParamsBuilderMinimum() {         return new IkeSessionParams.Builder(sContext)                 .setNetwork(mTunNetwork)                 .setServerHostname(IPV4_ADDRESS_REMOTE.getHostAddress())                 .addSaProposal(SA_PROPOSAL)                 .setLocalIdentification(LOCAL_ID)                 .setRemoteIdentification(REMOTE_ID)                 .setAuthPsk(IKE_PSK);     }      /**      * Verify the minimum configurations to build an IkeSessionParams.      *      * @see #createIkeParamsBuilderMinimum      */     private void verifyIkeParamsMinimum(IkeSessionParams sessionParams) {         assertEquals(mTunNetwork, sessionParams.getNetwork());         assertEquals(IPV4_ADDRESS_REMOTE.getHostAddress(), sessionParams.getServerHostname());         assertEquals(Arrays.asList(SA_PROPOSAL), sessionParams.getSaProposals());         assertEquals(LOCAL_ID, sessionParams.getLocalIdentification());         assertEquals(REMOTE_ID, sessionParams.getRemoteIdentification());          IkeAuthConfig localConfig = sessionParams.getLocalAuthConfig();         assertTrue(localConfig instanceof IkeAuthPskConfig);         assertArrayEquals(IKE_PSK, ((IkeAuthPskConfig) localConfig).getPsk());         IkeAuthConfig remoteConfig = sessionParams.getRemoteAuthConfig();         assertTrue(remoteConfig instanceof IkeAuthPskConfig);         assertArrayEquals(IKE_PSK, ((IkeAuthPskConfig) remoteConfig).getPsk());     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.net.ipsec.ike.cts.IkeSessionParamsTest"	"testSetPcscfConfigRequests"	"CtsIkeTestCases"	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	"v4"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/ipsec/src/android/net/ipsec/ike/cts/IkeSessionParamsTest.java"	""	"public void testSetPcscfConfigRequests() throws Exception {         IkeSessionParams sessionParams =                 createIkeParamsBuilderMinimum()                         .setRetransmissionTimeoutsMillis(RETRANS_TIMEOUT_MS_LIST)                         .addPcscfServerRequest(AF_INET)                         .addPcscfServerRequest(PCSCF_IPV4_ADDRESS_1)                         .addPcscfServerRequest(PCSCF_IPV6_ADDRESS_1)                         .addPcscfServerRequest(AF_INET6)                         .addPcscfServerRequest(PCSCF_IPV4_ADDRESS_2)                         .addPcscfServerRequest(PCSCF_IPV6_ADDRESS_2)                         .build();          verifyIkeParamsMinimum(sessionParams);         verifyConfigRequestTypes(EXPECTED_REQ_COUNT, sessionParams.getConfigurationRequests());          Set<InetAddress> resultAddresses = new HashSet<>();         for (IkeConfigRequest req : sessionParams.getConfigurationRequests()) {             if (req instanceof ConfigRequestIpv4PcscfServer                     && ((ConfigRequestIpv4PcscfServer) req).getAddress() != null) {                 resultAddresses.add(((ConfigRequestIpv4PcscfServer) req).getAddress());             } else if (req instanceof ConfigRequestIpv6PcscfServer                     && ((ConfigRequestIpv6PcscfServer) req).getAddress() != null) {                 resultAddresses.add(((ConfigRequestIpv6PcscfServer) req).getAddress());             }         }         assertEquals(EXPECTED_PCSCF_SERVERS, resultAddresses);     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.net.ipsec.ike.cts.IkeSessionParamsTest"	"testRemoveIkeOption"	"CtsIkeTestCases"	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	"v4"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/ipsec/src/android/net/ipsec/ike/cts/IkeSessionParamsTest.java"	""	"public void testRemoveIkeOption() throws Exception {         IkeSessionParams sessionParams =                 createIkeParamsBuilderMinimum()                         .addIkeOption(IKE_OPTION_ACCEPT_ANY_REMOTE_ID)                         .removeIkeOption(IKE_OPTION_ACCEPT_ANY_REMOTE_ID)                         .build();          verifyIkeParamsMinimum(sessionParams);         assertFalse(sessionParams.hasIkeOption(IKE_OPTION_ACCEPT_ANY_REMOTE_ID));     }      /**      * Create a Builder that has minimum configurations to build an IkeSessionParams, except for      * authentication method.      */     private IkeSessionParams.Builder createIkeParamsBuilderMinimumWithoutAuth() {         return new IkeSessionParams.Builder(sContext)                 .setNetwork(mTunNetwork)                 .setServerHostname(IPV4_ADDRESS_REMOTE.getHostAddress())                 .addSaProposal(SA_PROPOSAL)                 .setLocalIdentification(LOCAL_ID)                 .setRemoteIdentification(REMOTE_ID);     }      /**      * Verify the minimum configurations to build an IkeSessionParams, except for authentication      * method.      *      * @see #createIkeParamsBuilderMinimumWithoutAuth      */     private void verifyIkeParamsMinimumWithoutAuth(IkeSessionParams sessionParams) {         assertEquals(mTunNetwork, sessionParams.getNetwork());         assertEquals(IPV4_ADDRESS_REMOTE.getHostAddress(), sessionParams.getServerHostname());         assertEquals(Arrays.asList(SA_PROPOSAL), sessionParams.getSaProposals());         assertEquals(LOCAL_ID, sessionParams.getLocalIdentification());         assertEquals(REMOTE_ID, sessionParams.getRemoteIdentification());     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.mediav2.cts.CodecEncoderTest"	"isFormatSupported"	"CtsMediaTestCases"	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	"v4"	""	""	""	"/home/gpoor/cts-source/cts/tests/media/src/android/mediav2/cts/CodecEncoderTest.java"	""	"/*  *.  */  package android.mediav2.cts;  import android.media.MediaCodec; import android.media.MediaCodecInfo; import android.media.MediaFormat; import android.os.Bundle; import android.util.Log;  import androidx.test.filters.LargeTest; import androidx.test.filters.SmallTest;  import org.junit.Assume; import org.junit.Ignore; import org.junit.Test; import org.junit.runner.RunWith; import org.junit.runners.Parameterized;  import java.io.IOException; import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.HashSet; import java.util.List; import java.util.Set;  import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail;  /**  * Validate encode functionality of listed encoder components  *  * The test aims to test all encoders advertised in MediaCodecList. Hence we are not using  * MediaCodecList#findEncoderForFormat to create codec. Further, it can so happen that the  * test clip chosen is not supported by component (codecCapabilities.isFormatSupported()  * fails), then it is better to remove the format but not skip testing the component. The idea  * of these tests are not to cover CDD requirements but to test components and their plugins  */ @RunWith(Parameterized.class) public class CodecEncoderTest extends CodecEncoderTestBase {     private static final String LOG_TAG = CodecEncoderTest.class.getSimpleName();     private final int[] mBitrates;     private final int[] mEncParamList1;     private final int[] mEncParamList2;     private ArrayList<MediaFormat> mFormats;     private int mNumSyncFramesReceived;     private ArrayList<Integer> mSyncFramesPos;      public CodecEncoderTest(String mime, int[] bitrates, int[] encoderInfo1, int[] encoderInfo2) {         super(mime);         mBitrates = bitrates;         mEncParamList1 = encoderInfo1;         mEncParamList2 = encoderInfo2;         mFormats = new ArrayList<>();         mSyncFramesPos = new ArrayList<>();     }      @Override     void resetContext(boolean isAsync, boolean signalEOSWithLastFrame) {         super.resetContext(isAsync, signalEOSWithLastFrame);         mNumSyncFramesReceived = 0;         mSyncFramesPos.clear();     }      @Override     void flushCodec() {         super.flushCodec();         mNumSyncFramesReceived = 0;         mSyncFramesPos.clear();     }      void dequeueOutput(int bufferIndex, MediaCodec.BufferInfo info) {         if (info.size > 0 && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {             mNumSyncFramesReceived += 1;             mSyncFramesPos.add(mOutputCount);         }         super.dequeueOutput(bufferIndex, info);     }      private void encodeToMemory(String file, String encoder, int frameLimit, MediaFormat format)             throws IOException, InterruptedException {         /* TODO(b/149027258) */         if (true) mSaveToMem = false;         else mSaveToMem = true;         mOutputBuff = new OutputManager();         mCodec = MediaCodec.createByCodecName(encoder);         setUpSource(file);         configureCodec(format, false, true, true);         if (mIsAudio) {             mSampleRate = format.getInteger(MediaFormat.KEY_SAMPLE_RATE);             mChannels = format.getInteger(MediaFormat.KEY_CHANNEL_COUNT);         } else {             mWidth = format.getInteger(MediaFormat.KEY_WIDTH);             mHeight = format.getInteger(MediaFormat.KEY_HEIGHT);         }         mCodec.start();         doWork(frameLimit);         queueEOS();         waitForAllOutputs();         mCodec.stop();         mCodec.release();         mSaveToMem = false;     }      /**      * Selects encoder input color format in byte buffer mode. As of now ndk tests support only      * 420p, 420sp. COLOR_FormatYUV420Flexible although can represent any form of yuv, it doesn't      * work in ndk due to lack of AMediaCodec_GetInputImage()      */     private static int findByteBufferColorFormat(String encoder, String mime) throws IOException {         MediaCodec codec = MediaCodec.createByCodecName(encoder);         MediaCodecInfo.CodecCapabilities cap = codec.getCodecInfo().getCapabilitiesForType(mime);         int colorFormat = -1;         for (int c : cap.colorFormats) {             if (c == MediaCodecInfo.CodecCapabilities.COLOR_FormatYUV420SemiPlanar ||                     c == MediaCodecInfo.CodecCapabilities.COLOR_FormatYUV420Planar) {                 Log.v(LOG_TAG, ""selecting color format: "" + c);                 colorFormat = c;                 break;             }         }         codec.release();         return colorFormat;     }      private void forceSyncFrame() {         final Bundle syncFrame = new Bundle();         syncFrame.putInt(MediaCodec.PARAMETER_KEY_REQUEST_SYNC_FRAME, 0);         if (ENABLE_LOGS) {             Log.v(LOG_TAG, ""requesting key frame"");         }         mCodec.setParameters(syncFrame);     }      private void updateBitrate(int bitrate) {         final Bundle bitrateUpdate = new Bundle();         bitrateUpdate.putInt(MediaCodec.PARAMETER_KEY_VIDEO_BITRATE, bitrate);         if (ENABLE_LOGS) {             Log.v(LOG_TAG, ""requesting bitrate to be changed to "" + bitrate);         }         mCodec.setParameters(bitrateUpdate);     }      @Parameterized.Parameters(name = ""{index}({0})"")     public static Collection<Object[]> input() {         Set<String> list = new HashSet<>();         if (hasMicrophone()) {             // sec 5.1.1             // TODO(b/154423550)             // list.add(MediaFormat.MIMETYPE_AUDIO_RAW);             list.add(MediaFormat.MIMETYPE_AUDIO_FLAC);             list.add(MediaFormat.MIMETYPE_AUDIO_OPUS);         }         if (isHandheld() || isTv() || isAutomotive()) {             // sec 2.2.2, 2.3.2, 2.5.2             list.add(MediaFormat.MIMETYPE_AUDIO_AAC);             list.add(MediaFormat.MIMETYPE_VIDEO_AVC);             list.add(MediaFormat.MIMETYPE_VIDEO_VP8);         }         if (isHandheld()) {             // sec 2.2.2             list.add(MediaFormat.MIMETYPE_AUDIO_AMR_NB);             list.add(MediaFormat.MIMETYPE_AUDIO_AMR_WB);         }         ArrayList<String> cddRequiredMimeList = new ArrayList<>(list);         final List<Object[]> exhaustiveArgsList = Arrays.asList(new Object[][]{                 // Audio - CodecMime, arrays of bit-rates, sample rates, channel counts                 {MediaFormat.MIMETYPE_AUDIO_AAC, new int[]{64000, 128000}, new int[]{8000, 11025,                         22050, 44100, 48000}, new int[]{1, 2}},                 {MediaFormat.MIMETYPE_AUDIO_OPUS, new int[]{6600, 8850, 12650, 14250, 15850,                         18250, 19850, 23050, 23850}, new int[]{16000}, new int[]{1}},                 {MediaFormat.MIMETYPE_AUDIO_AMR_NB, new int[]{4750, 5150, 5900, 6700, 7400, 7950,                         10200, 12200}, new int[]{8000}, new int[]{1}},                 {MediaFormat.MIMETYPE_AUDIO_AMR_WB, new int[]{6600, 8850, 12650, 14250, 15850,                         18250, 19850, 23050, 23850}, new int[]{16000}, new int[]{1}},                 {MediaFormat.MIMETYPE_AUDIO_FLAC, new int[]{64000, 192000}, new int[]{8000, 48000                         , 96000, 192000}, new int[]{1, 2}},                  // Video - CodecMime, arrays of bit-rates, height, width                 {MediaFormat.MIMETYPE_VIDEO_H263, new int[]{32000, 64000}, new int[]{176},                         new int[]{144}},                 {MediaFormat.MIMETYPE_VIDEO_MPEG4, new int[]{32000, 64000}, new int[]{176},                         new int[]{144}},                 {MediaFormat.MIMETYPE_VIDEO_AVC, new int[]{256000, 512000}, new int[]{176, 352,                         352, 480}, new int[]{144, 240, 288, 360}},                 {MediaFormat.MIMETYPE_VIDEO_HEVC, new int[]{256000, 512000}, new int[]{176, 352,                         352, 480}, new int[]{144, 240, 288, 360}},                 {MediaFormat.MIMETYPE_VIDEO_VP8, new int[]{256000, 512000}, new int[]{176, 352,                         352, 480}, new int[]{144, 240, 288, 360}},                 {MediaFormat.MIMETYPE_VIDEO_VP9, new int[]{256000, 512000}, new int[]{176, 352,                         352, 480}, new int[]{144, 240, 288, 360}},                 {MediaFormat.MIMETYPE_VIDEO_AV1, new int[]{256000, 512000}, new int[]{176, 352,                         352, 480}, new int[]{144, 240, 288, 360}},         });         return prepareParamList(cddRequiredMimeList, exhaustiveArgsList, true);     }      private void setUpParams(int limit) {         int count = 0;         for (int bitrate : mBitrates) {             if (mIsAudio) {                 for (int rate : mEncParamList1) {                     for (int channels : mEncParamList2) {                         MediaFormat format = new MediaFormat();                         format.setString(MediaFormat.KEY_MIME, mMime);                         format.setInteger(MediaFormat.KEY_BIT_RATE, bitrate);                         format.setInteger(MediaFormat.KEY_SAMPLE_RATE, rate);                         format.setInteger(MediaFormat.KEY_CHANNEL_COUNT, channels);                         mFormats.add(format);                         count++;                         if (count >= limit) return;                     }                 }             } else {                 assertTrue(""Wrong number of height, width parameters"",                         mEncParamList1.length == mEncParamList2.length);                 for (int i = 0; i < mEncParamList1.length; i++) {                     MediaFormat format = new MediaFormat();                     format.setString(MediaFormat.KEY_MIME, mMime);                     format.setInteger(MediaFormat.KEY_BIT_RATE, bitrate);                     format.setInteger(MediaFormat.KEY_WIDTH, mEncParamList1[i]);                     format.setInteger(MediaFormat.KEY_HEIGHT, mEncParamList2[i]);                     format.setInteger(MediaFormat.KEY_FRAME_RATE, mFrameRate);                     format.setInteger(MediaFormat.KEY_MAX_B_FRAMES, mMaxBFrames);                     format.setFloat(MediaFormat.KEY_I_FRAME_INTERVAL, 1.0f);                     format.setInteger(MediaFormat.KEY_COLOR_FORMAT,                             MediaCodecInfo.CodecCapabilities.COLOR_FormatYUV420Flexible);                     mFormats.add(format);                     count++;                     if (count >= limit) return;                 }             }         }     }      /**      * Tests encoder for combinations:      * 1. Codec Sync Mode, Signal Eos with Last frame      * 2. Codec Sync Mode, Signal Eos Separately      * 3. Codec Async Mode, Signal Eos with Last frame      * 4. Codec Async Mode, Signal Eos Separately      * In all these scenarios, Timestamp ordering is verified. The output has to be      * consistent (not flaky) in all runs.      */     @LargeTest"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.mediapc.cts.EncoderInitializationLatencyTest"	"testInitializationLatency"	"CtsMediaPerformanceClassTestCases"	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	"v4"	""	""	""	"/home/gpoor/cts-source/cts/tests/mediapc/src/android/mediapc/cts/EncoderInitializationLatencyTest.java"	""	"(timeout = CodecTestBase.PER_TEST_TIMEOUT_LARGE_TEST_MS)     public void testInitializationLatency() throws Exception {         int maxCodecInitializationLatencyMs = mMime.startsWith(""audio/"") ?                 MAX_AUDIOENC_INITIALIZATION_LATENCY_MS : MAX_VIDEOENC_INITIALIZATION_LATENCY_MS;         for (int i = 0; i < 5; i++) {             for (boolean isAsync : boolStates) {                 EncoderInitializationLatency encoderInitializationLatency =                         new EncoderInitializationLatency(mMime, mEncoderName, isAsync);                 long encoderInitializationLatencyMs = encoderInitializationLatency                         .calculateEncoderInitializationLatency();                 String errorLog = String.format(""CodecInitialization latency for mime: %s, "" +                         ""Encoder: %s, Iteration: %d, mode: %s  is not as expected. act/exp: "" +                         "" %d/%d"", mMime, mEncoderName, i, (isAsync ? ""async"" : ""sync""),                         encoderInitializationLatencyMs, maxCodecInitializationLatencyMs);                 assertTrue(errorLog,                         encoderInitializationLatencyMs <= maxCodecInitializationLatencyMs);             }         }     } }  class EncoderInitializationLatency extends CodecEncoderTestBase {     private static final String LOG_TAG = EncoderInitializationLatency.class.getSimpleName();      private final String mEncoderName;     private final boolean mIsAsync;      EncoderInitializationLatency(String mime, String encoderName, boolean isAsync) {         super(mime);         mEncoderName = encoderName;         mIsAsync = isAsync;         mSampleRate = 8000;         mFrameRate = 60;     }      private MediaFormat setUpFormat() {         MediaFormat format = new MediaFormat();         format.setString(MediaFormat.KEY_MIME, mMime);         if (mIsAudio) {             if (mMime.equals(MediaFormat.MIMETYPE_AUDIO_FLAC)) {                 format.setInteger(MediaFormat.KEY_FLAC_COMPRESSION_LEVEL, 10000);             } else {                 format.setInteger(MediaFormat.KEY_BIT_RATE, 128000);             }             format.setInteger(MediaFormat.KEY_SAMPLE_RATE, mSampleRate);             format.setInteger(MediaFormat.KEY_CHANNEL_COUNT, 1);         } else {             format.setInteger(MediaFormat.KEY_WIDTH, 1920);             format.setInteger(MediaFormat.KEY_HEIGHT, 1080);             format.setInteger(MediaFormat.KEY_FRAME_RATE, mFrameRate);             format.setInteger(MediaFormat.KEY_BIT_RATE, 8000000);             format.setFloat(MediaFormat.KEY_I_FRAME_INTERVAL, 1.0f);             format.setInteger(MediaFormat.KEY_COLOR_FORMAT,                     MediaCodecInfo.CodecCapabilities.COLOR_FormatYUV420Flexible);         }         return format;     }      public long calculateEncoderInitializationLatency() throws Exception {         MediaFormat format = setUpFormat();         if (mIsAudio) {             mSampleRate = format.getInteger(MediaFormat.KEY_SAMPLE_RATE);             mChannels = format.getInteger(MediaFormat.KEY_CHANNEL_COUNT);         } else {             mWidth = format.getInteger(MediaFormat.KEY_WIDTH);             mHeight = format.getInteger(MediaFormat.KEY_HEIGHT);         }         setUpSource(mInputFile);         MediaCodec.BufferInfo outInfo = new MediaCodec.BufferInfo();         long step1TimeMs; // Time of (create + configure)         long step2TimeMs; // Time of (create + configure + start)         long step3TimeMs = 0; // Time of (create + configure + start + first frame to enqueue)         long step4TimeMs = 0; // Time of (create + configure + start + first frame to dequeue)         long start = System.currentTimeMillis();         mCodec = MediaCodec.createByCodecName(mEncoderName);         resetContext(mIsAsync, false);         mAsyncHandle.setCallBack(mCodec, mIsAsync);         mCodec.configure(format, null, MediaCodec.CONFIGURE_FLAG_ENCODE, null);         step1TimeMs = System.currentTimeMillis() - start;         mCodec.start();         step2TimeMs = System.currentTimeMillis() - start;         if (mIsAsync) {             while (!mAsyncHandle.hasSeenError() && !mSawInputEOS) {                 Pair<Integer, MediaCodec.BufferInfo> element = mAsyncHandle.getWork();                 if (element != null) {                     int bufferID = element.first;                     MediaCodec.BufferInfo info = element.second;                     if (info != null) {                         step4TimeMs = System.currentTimeMillis() - start;                         dequeueOutput(bufferID, info);                         break;                     } else {                         if (step3TimeMs == 0) step3TimeMs = System.currentTimeMillis() - start;                         enqueueInput(bufferID);                     }                 }             }         } else {             while (!mSawOutputEOS) {                 if (!mSawInputEOS) {                     int inputBufferId = mCodec.dequeueInputBuffer(Q_DEQ_TIMEOUT_US);                     if (inputBufferId > 0) {                         if (step3TimeMs == 0) step3TimeMs = System.currentTimeMillis() - start;                         enqueueInput(inputBufferId);                     }                 }                 int outputBufferId = mCodec.dequeueOutputBuffer(outInfo, Q_DEQ_TIMEOUT_US);                 if (outputBufferId >= 0) {                     step4TimeMs = System.currentTimeMillis() - start;                     dequeueOutput(outputBufferId, outInfo);                     break;                 }             }         }         queueEOS();         waitForAllOutputs();         mCodec.stop();         mCodec.release();         Log.d(LOG_TAG, ""Encode mMime: "" + mMime + "" Encoder: "" + mEncoderName +                 "" Time for (create + configure): "" + step1TimeMs);         Log.d(LOG_TAG, ""Encode mMime: "" + mMime + "" Encoder: "" + mEncoderName +                 "" Time for (create + configure + start): "" + step2TimeMs);         Log.d(LOG_TAG, ""Encode mMime: "" + mMime + "" Encoder: "" + mEncoderName +                 "" Time for (create + configure + start + first frame to enqueue): "" + step3TimeMs);         Log.d(LOG_TAG, ""Encode mMime: "" + mMime + "" Encoder: "" + mEncoderName +                 "" Time for (create + configure + start + first frame to dequeue): "" + step4TimeMs);         return step1TimeMs;     } }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.telephony.cts.DataCallResponseTest"	"testConstructorAndGetters"	"CtsTelephonyTestCases"	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	"v4"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/telephony/current/src/android/telephony/cts/DataCallResponseTest.java"	""	"public void testConstructorAndGetters() {         DataCallResponse response = new DataCallResponse.Builder()                 .setCause(CAUSE)                 .setSuggestedRetryTime(RETRY)                 .setId(ID)                 .setLinkStatus(LINK_STATUS)                 .setProtocolType(PROTOCOL_TYPE)                 .setInterfaceName(IF_NAME)                 .setAddresses(ADDRESSES)                 .setDnsAddresses(DNSES)                 .setGatewayAddresses(GATEWAYS)                 .setPcscfAddresses(PCSCFS)                 .setMtuV4(MTU_V4)                 .setMtuV6(MTU_V6)                 .build();          assertThat(response.getCause()).isEqualTo(CAUSE);         assertThat(response.getSuggestedRetryTime()).isEqualTo(RETRY);         assertThat(response.getId()).isEqualTo(ID);         assertThat(response.getLinkStatus()).isEqualTo(LINK_STATUS);         assertThat(response.getProtocolType()).isEqualTo(PROTOCOL_TYPE);         assertThat(response.getInterfaceName()).isEqualTo(IF_NAME);         assertThat(response.getAddresses()).isEqualTo(ADDRESSES);         assertThat(response.getDnsAddresses()).isEqualTo(DNSES);         assertThat(response.getGatewayAddresses()).isEqualTo(GATEWAYS);         assertThat(response.getPcscfAddresses()).isEqualTo(PCSCFS);         assertThat(response.getMtuV4()).isEqualTo(MTU_V4);         assertThat(response.getMtuV6()).isEqualTo(MTU_V6);     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.telephony.cts.DataCallResponseTest"	"testEquals"	"CtsTelephonyTestCases"	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	"v4"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/telephony/current/src/android/telephony/cts/DataCallResponseTest.java"	""	"public void testEquals() {         DataCallResponse response = new DataCallResponse.Builder()                 .setCause(CAUSE)                 .setSuggestedRetryTime(RETRY)                 .setId(ID)                 .setLinkStatus(LINK_STATUS)                 .setProtocolType(PROTOCOL_TYPE)                 .setInterfaceName(IF_NAME)                 .setAddresses(ADDRESSES)                 .setDnsAddresses(DNSES)                 .setGatewayAddresses(GATEWAYS)                 .setPcscfAddresses(PCSCFS)                 .setMtuV4(MTU_V4)                 .setMtuV6(MTU_V6)                 .build();          DataCallResponse equalsResponse = new DataCallResponse.Builder()                 .setCause(CAUSE)                 .setSuggestedRetryTime(RETRY)                 .setId(ID)                 .setLinkStatus(LINK_STATUS)                 .setProtocolType(PROTOCOL_TYPE)                 .setInterfaceName(IF_NAME)                 .setAddresses(ADDRESSES)                 .setDnsAddresses(DNSES)                 .setGatewayAddresses(GATEWAYS)                 .setPcscfAddresses(PCSCFS)                 .setMtuV4(MTU_V4)                 .setMtuV6(MTU_V6)                 .build();          assertThat(response).isEqualTo(equalsResponse);     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.telephony.cts.DataCallResponseTest"	"testNotEquals"	"CtsTelephonyTestCases"	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	"v4"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/telephony/current/src/android/telephony/cts/DataCallResponseTest.java"	""	"public void testNotEquals() {         DataCallResponse response = new DataCallResponse.Builder()                 .setCause(CAUSE)                 .setSuggestedRetryTime(RETRY)                 .setId(ID)                 .setLinkStatus(LINK_STATUS)                 .setProtocolType(PROTOCOL_TYPE)                 .setInterfaceName(IF_NAME)                 .setAddresses(ADDRESSES)                 .setDnsAddresses(DNSES)                 .setGatewayAddresses(GATEWAYS)                 .setPcscfAddresses(PCSCFS)                 .setMtuV4(MTU_V4)                 .setMtuV6(MTU_V6)                 .build();          DataCallResponse notEqualsResponse = new DataCallResponse.Builder()                 .setCause(1)                 .setSuggestedRetryTime(-1)                 .setId(1)                 .setLinkStatus(3)                 .setProtocolType(PROTOCOL_TYPE)                 .setInterfaceName(IF_NAME)                 .setAddresses(ADDRESSES)                 .setDnsAddresses(DNSES)                 .setGatewayAddresses(GATEWAYS)                 .setPcscfAddresses(PCSCFS)                 .setMtuV4(1441)                 .setMtuV6(1440)                 .build();          assertThat(response).isNotEqualTo(notEqualsResponse);         assertThat(response).isNotEqualTo(null);         assertThat(response).isNotEqualTo(new String[1]);     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.telephony.cts.DataCallResponseTest"	"testParcel"	"CtsTelephonyTestCases"	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	"v4"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/telephony/current/src/android/telephony/cts/DataCallResponseTest.java"	""	"public void testParcel() {         DataCallResponse response = new DataCallResponse.Builder()                 .setCause(CAUSE)                 .setSuggestedRetryTime(RETRY)                 .setId(ID)                 .setLinkStatus(LINK_STATUS)                 .setProtocolType(PROTOCOL_TYPE)                 .setInterfaceName(IF_NAME)                 .setAddresses(ADDRESSES)                 .setDnsAddresses(DNSES)                 .setGatewayAddresses(GATEWAYS)                 .setPcscfAddresses(PCSCFS)                 .setMtuV4(MTU_V4)                 .setMtuV6(MTU_V6)                 .build();          Parcel stateParcel = Parcel.obtain();         response.writeToParcel(stateParcel, 0);         stateParcel.setDataPosition(0);          DataCallResponse parcelResponse = DataCallResponse.CREATOR.createFromParcel(stateParcel);         assertThat(response).isEqualTo(parcelResponse);     } }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"installDeviceTestPkg"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void test/*  *.  */  package android.appsecurity.cts;  import android.platform.test.annotations.SecurityTest;  import com.android.compatibility.common.tradefed.build.CompatibilityBuildHelper; import com.android.tradefed.build.IBuildInfo; import com.android.tradefed.device.DeviceNotAvailableException; import com.android.tradefed.testtype.DeviceTestCase; import com.android.tradefed.testtype.IBuildReceiver; import com.android.tradefed.util.FileUtil;  import java.io.BufferedOutputStream; import java.io.File; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.util.Locale;  /**  * Tests for APK signature verification during installation.  */ public class PkgInstallSignatureVerificationTest extends DeviceTestCase implements IBuildReceiver {      private static final String TEST_PKG = ""android.appsecurity.cts.tinyapp"";     private static final String COMPANION_TEST_PKG = ""android.appsecurity.cts.tinyapp_companion"";     private static final String COMPANION2_TEST_PKG = ""android.appsecurity.cts.tinyapp_companion2"";     private static final String DEVICE_TESTS_APK = ""CtsV3SigningSchemeRotationTest.apk"";     private static final String DEVICE_TESTS_PKG = ""android.appsecurity.cts.v3rotationtests"";     private static final String DEVICE_TESTS_CLASS = DEVICE_TESTS_PKG + "".V3RotationTest"";     private static final String SERVICE_PKG = ""android.appsecurity.cts.keyrotationtest"";     private static final String SERVICE_TEST_PKG = ""android.appsecurity.cts.keyrotationtest.test"";     private static final String SERVICE_TEST_CLASS =             SERVICE_TEST_PKG + "".SignatureQueryServiceInstrumentationTest"";     private static final String TEST_APK_RESOURCE_PREFIX = ""/pkgsigverify/"";     private static final String INSTALL_ARG_FORCE_QUERYABLE = ""--force-queryable"";      private static final String[] DSA_KEY_NAMES = {""1024"", ""2048"", ""3072""};     private static final String[] EC_KEY_NAMES = {""p256"", ""p384"", ""p521""};     private static final String[] RSA_KEY_NAMES = {""1024"", ""2048"", ""3072"", ""4096"", ""8192"", ""16384""};     private static final String[] RSA_KEY_NAMES_2048_AND_LARGER =             {""2048"", ""3072"", ""4096"", ""8192"", ""16384""};      private IBuildInfo mCtsBuild;      @Override     public void setBuild(IBuildInfo buildInfo) {         mCtsBuild = buildInfo;     }      @Override     protected void setUp() throws Exception {         super.setUp();          Utils.prepareSingleUser(getDevice());         assertNotNull(mCtsBuild);         uninstallPackage();         uninstallCompanionPackages();         installDeviceTestPkg();     }      @Override     protected void tearDown() throws Exception {         try {             uninstallPackages();         } catch (DeviceNotAvailableException ignored) {         } finally {             super.tearDown();         }     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallOriginalSucceeds"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallOriginalSucceeds() throws Exception {         // APK signed with v1 and v2 schemes. Obtained by building         // cts/hostsidetests/appsecurity/test-apps/tinyapp.         assertInstallSucceeds(""original.apk"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV1OneSignerMD5withRSA"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV1OneSignerMD5withRSA() throws Exception {         // APK signed with v1 scheme only, one signer.         assertInstallSucceedsForEach(                 ""v1-only-with-rsa-pkcs1-md5-1.2.840.113549.1.1.1-%s.apk"", RSA_KEY_NAMES);         assertInstallSucceedsForEach(                 ""v1-only-with-rsa-pkcs1-md5-1.2.840.113549.1.1.4-%s.apk"", RSA_KEY_NAMES);     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV1OneSignerSHA1withRSA"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV1OneSignerSHA1withRSA() throws Exception {         // APK signed with v1 scheme only, one signer.         assertInstallSucceedsForEach(                 ""v1-only-with-rsa-pkcs1-sha1-1.2.840.113549.1.1.1-%s.apk"", RSA_KEY_NAMES);         assertInstallSucceedsForEach(                 ""v1-only-with-rsa-pkcs1-sha1-1.2.840.113549.1.1.5-%s.apk"", RSA_KEY_NAMES);     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV1OneSignerSHA224withRSA"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV1OneSignerSHA224withRSA() throws Exception {         // APK signed with v1 scheme only, one signer.         assertInstallSucceedsForEach(                 ""v1-only-with-rsa-pkcs1-sha224-1.2.840.113549.1.1.1-%s.apk"", RSA_KEY_NAMES);         assertInstallSucceedsForEach(                 ""v1-only-with-rsa-pkcs1-sha224-1.2.840.113549.1.1.14-%s.apk"", RSA_KEY_NAMES);     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV1OneSignerSHA256withRSA"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV1OneSignerSHA256withRSA() throws Exception {         // APK signed with v1 scheme only, one signer.         assertInstallSucceedsForEach(                 ""v1-only-with-rsa-pkcs1-sha256-1.2.840.113549.1.1.1-%s.apk"", RSA_KEY_NAMES);         assertInstallSucceedsForEach(                 ""v1-only-with-rsa-pkcs1-sha256-1.2.840.113549.1.1.11-%s.apk"", RSA_KEY_NAMES);     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV1OneSignerSHA384withRSA"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV1OneSignerSHA384withRSA() throws Exception {         // APK signed with v1 scheme only, one signer.         assertInstallSucceedsForEach(                 ""v1-only-with-rsa-pkcs1-sha384-1.2.840.113549.1.1.1-%s.apk"", RSA_KEY_NAMES);         assertInstallSucceedsForEach(                 ""v1-only-with-rsa-pkcs1-sha384-1.2.840.113549.1.1.12-%s.apk"", RSA_KEY_NAMES);     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV1OneSignerSHA512withRSA"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV1OneSignerSHA512withRSA() throws Exception {         // APK signed with v1 scheme only, one signer.         assertInstallSucceedsForEach(                 ""v1-only-with-rsa-pkcs1-sha512-1.2.840.113549.1.1.1-%s.apk"", RSA_KEY_NAMES);         assertInstallSucceedsForEach(                 ""v1-only-with-rsa-pkcs1-sha512-1.2.840.113549.1.1.13-%s.apk"", RSA_KEY_NAMES);     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV1OneSignerSHA1withECDSA"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV1OneSignerSHA1withECDSA() throws Exception {         // APK signed with v1 scheme only, one signer.         assertInstallSucceedsForEach(                 ""v1-only-with-ecdsa-sha1-1.2.840.10045.2.1-%s.apk"", EC_KEY_NAMES);         assertInstallSucceedsForEach(                 ""v1-only-with-ecdsa-sha1-1.2.840.10045.4.1-%s.apk"", EC_KEY_NAMES);     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV1OneSignerSHA224withECDSA"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV1OneSignerSHA224withECDSA() throws Exception {         // APK signed with v1 scheme only, one signer.         assertInstallSucceedsForEach(                 ""v1-only-with-ecdsa-sha224-1.2.840.10045.2.1-%s.apk"", EC_KEY_NAMES);         assertInstallSucceedsForEach(                 ""v1-only-with-ecdsa-sha224-1.2.840.10045.4.3.1-%s.apk"", EC_KEY_NAMES);     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV1OneSignerSHA256withECDSA"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV1OneSignerSHA256withECDSA() throws Exception {         // APK signed with v1 scheme only, one signer.         assertInstallSucceedsForEach(                 ""v1-only-with-ecdsa-sha256-1.2.840.10045.2.1-%s.apk"", EC_KEY_NAMES);         assertInstallSucceedsForEach(                 ""v1-only-with-ecdsa-sha256-1.2.840.10045.4.3.2-%s.apk"", EC_KEY_NAMES);     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV1OneSignerSHA384withECDSA"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV1OneSignerSHA384withECDSA() throws Exception {         // APK signed with v1 scheme only, one signer.         assertInstallSucceedsForEach(                 ""v1-only-with-ecdsa-sha384-1.2.840.10045.2.1-%s.apk"", EC_KEY_NAMES);         assertInstallSucceedsForEach(                 ""v1-only-with-ecdsa-sha384-1.2.840.10045.4.3.3-%s.apk"", EC_KEY_NAMES);     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV1OneSignerSHA512withECDSA"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV1OneSignerSHA512withECDSA() throws Exception {         // APK signed with v1 scheme only, one signer.         assertInstallSucceedsForEach(                 ""v1-only-with-ecdsa-sha512-1.2.840.10045.2.1-%s.apk"", EC_KEY_NAMES);         assertInstallSucceedsForEach(                 ""v1-only-with-ecdsa-sha512-1.2.840.10045.4.3.4-%s.apk"", EC_KEY_NAMES);     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV1OneSignerSHA1withDSA"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV1OneSignerSHA1withDSA() throws Exception {         // APK signed with v1 scheme only, one signer.         assertInstallSucceedsForEach(                 ""v1-only-with-dsa-sha1-1.2.840.10040.4.1-%s.apk"", DSA_KEY_NAMES);         assertInstallSucceedsForEach(                 ""v1-only-with-dsa-sha1-1.2.840.10040.4.3-%s.apk"", DSA_KEY_NAMES);     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV1OneSignerSHA224withDSA"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV1OneSignerSHA224withDSA() throws Exception {         // APK signed with v1 scheme only, one signer.         assertInstallSucceedsForEach(                 ""v1-only-with-dsa-sha224-1.2.840.10040.4.1-%s.apk"", DSA_KEY_NAMES);         assertInstallSucceedsForEach(                 ""v1-only-with-dsa-sha224-2.16.840.1.101.3.4.3.1-%s.apk"", DSA_KEY_NAMES);     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV1OneSignerSHA256withDSA"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV1OneSignerSHA256withDSA() throws Exception {         // APK signed with v1 scheme only, one signer.         assertInstallSucceedsForEach(                 ""v1-only-with-dsa-sha256-1.2.840.10040.4.1-%s.apk"", DSA_KEY_NAMES);         assertInstallSucceedsForEach(                 ""v1-only-with-dsa-sha256-2.16.840.1.101.3.4.3.2-%s.apk"", DSA_KEY_NAMES);     }  //  Android platform doesn't support DSA with SHA-384 and SHA-512. //"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV1OneSignerSHA384withDSA"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV1OneSignerSHA384withDSA() throws Exception { //        // APK signed with v1 scheme only, one signer. //        assertInstallSucceedsForEach( //                ""v1-only-with-dsa-sha384-2.16.840.1.101.3.4.3.3-%s.apk"", DSA_KEY_NAMES); //    } // //"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV1OneSignerSHA512withDSA"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV1OneSignerSHA512withDSA() throws Exception { //        // APK signed with v1 scheme only, one signer. //        assertInstallSucceedsForEach( //                ""v1-only-with-dsa-sha512-2.16.840.1.101.3.4.3.3-%s.apk"", DSA_KEY_NAMES); //    }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV2StrippedFails"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV2StrippedFails() throws Exception {         // APK signed with v1 and v2 schemes, but v2 signature was stripped from the file (by using         // zipalign).         // This should fail because the v1 signature indicates that the APK was supposed to be         // signed with v2 scheme as well, making the platform's anti-stripping protections reject         // the APK.         assertInstallFailsWithError(""v2-stripped.apk"", ""Signature stripped"");          // Similar to above, but the X-Android-APK-Signed anti-stripping header in v1 signature         // lists unknown signature schemes in addition to APK Signature Scheme v2. Unknown schemes         // should be ignored.         assertInstallFailsWithError(                 ""v2-stripped-with-ignorable-signing-schemes.apk"", ""Signature stripped"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV2OneSignerOneSignature"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV2OneSignerOneSignature() throws Exception {         // APK signed with v2 scheme only, one signer, one signature.         assertInstallSucceedsForEach(""v2-only-with-dsa-sha256-%s.apk"", DSA_KEY_NAMES);         assertInstallSucceedsForEach(""v2-only-with-ecdsa-sha256-%s.apk"", EC_KEY_NAMES);         assertInstallSucceedsForEach(""v2-only-with-rsa-pkcs1-sha256-%s.apk"", RSA_KEY_NAMES);         assertInstallSucceedsForEach(""v2-only-with-rsa-pss-sha256-%s.apk"", RSA_KEY_NAMES);          // DSA with SHA-512 is not supported by Android platform and thus APK Signature Scheme v2         // does not support that either         // assertInstallSucceedsForEach(""v2-only-with-dsa-sha512-%s.apk"", DSA_KEY_NAMES);         assertInstallSucceedsForEach(""v2-only-with-ecdsa-sha512-%s.apk"", EC_KEY_NAMES);         assertInstallSucceedsForEach(""v2-only-with-rsa-pkcs1-sha512-%s.apk"", RSA_KEY_NAMES);         assertInstallSucceedsForEach(                 ""v2-only-with-rsa-pss-sha512-%s.apk"",                 RSA_KEY_NAMES_2048_AND_LARGER // 1024-bit key is too short for PSS with SHA-512         );     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV1SignatureOnlyDoesNotVerify"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV1SignatureOnlyDoesNotVerify() throws Exception {         // APK signed with v1 scheme only, but not all digests match those recorded in         // META-INF/MANIFEST.MF.         String error = ""META-INF/MANIFEST.MF has invalid digest"";          // Bitflip in classes.dex of otherwise good file.         assertInstallFailsWithError(                 ""v1-only-with-tampered-classes-dex.apk"", error);     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV2SignatureDoesNotVerify"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV2SignatureDoesNotVerify() throws Exception {         // APK signed with v2 scheme only, but the signature over signed-data does not verify.         String error = ""signature did not verify"";          // Bitflip in certificate field inside signed-data. Based on         // v2-only-with-dsa-sha256-1024.apk.         assertInstallFailsWithError(""v2-only-with-dsa-sha256-1024-sig-does-not-verify.apk"", error);          // Signature claims to be RSA PKCS#1 v1.5 with SHA-256, but is actually using SHA-512.         // Based on v2-only-with-rsa-pkcs1-sha256-2048.apk.         assertInstallFailsWithError(                 ""v2-only-with-rsa-pkcs1-sha256-2048-sig-does-not-verify.apk"", error);          // Signature claims to be RSA PSS with SHA-256 and 32 bytes of salt, but is actually using 0         // bytes of salt. Based on v2-only-with-rsa-pkcs1-sha256-2048.apk. Obtained by modifying APK         // signer to use the wrong amount of salt.         assertInstallFailsWithError(                 ""v2-only-with-rsa-pss-sha256-2048-sig-does-not-verify.apk"", error);          // Bitflip in the ECDSA signature. Based on v2-only-with-ecdsa-sha256-p256.apk.         assertInstallFailsWithError(                 ""v2-only-with-ecdsa-sha256-p256-sig-does-not-verify.apk"", error);     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV2ContentDigestMismatch"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV2ContentDigestMismatch() throws Exception {         // APK signed with v2 scheme only, but the digest of contents does not match the digest         // stored in signed-data.         String error = ""digest of contents did not verify"";          // Based on v2-only-with-rsa-pkcs1-sha512-4096.apk. Obtained by modifying APK signer to         // flip the leftmost bit in content digest before signing signed-data.         assertInstallFailsWithError(                 ""v2-only-with-rsa-pkcs1-sha512-4096-digest-mismatch.apk"", error);          // Based on v2-only-with-ecdsa-sha256-p256.apk. Obtained by modifying APK signer to flip the         // leftmost bit in content digest before signing signed-data.         assertInstallFailsWithError(                 ""v2-only-with-ecdsa-sha256-p256-digest-mismatch.apk"", error);     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallNoApkSignatureSchemeBlock"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallNoApkSignatureSchemeBlock() throws Exception {         // APK signed with v2 scheme only, but the rules for verifying APK Signature Scheme v2         // signatures say that this APK must not be verified using APK Signature Scheme v2.          // Obtained from v2-only-with-rsa-pkcs1-sha512-4096.apk by flipping a bit in the magic         // field in the footer of APK Signing Block. This makes the APK Signing Block disappear.         assertInstallFails(""v2-only-wrong-apk-sig-block-magic.apk"");          // Obtained by modifying APK signer to insert ""GARBAGE"" between ZIP Central Directory and         // End of Central Directory. The APK is otherwise fine and is signed with APK Signature         // Scheme v2. Based on v2-only-with-rsa-pkcs1-sha256.apk.         assertInstallFails(""v2-only-garbage-between-cd-and-eocd.apk"");          // Obtained by modifying APK signer to truncate the ZIP Central Directory by one byte. The         // APK is otherwise fine and is signed with APK Signature Scheme v2. Based on         // v2-only-with-rsa-pkcs1-sha256.apk         assertInstallFails(""v2-only-truncated-cd.apk"");          // Obtained by modifying the size in APK Signature Block header. Based on         // v2-only-with-ecdsa-sha512-p521.apk.         assertInstallFails(""v2-only-apk-sig-block-size-mismatch.apk"");          // Obtained by modifying the ID under which APK Signature Scheme v2 Block is stored in         // APK Signing Block and by modifying the APK signer to not insert anti-stripping         // protections into JAR Signature. The APK should appear as having no APK Signature Scheme         // v2 Block and should thus successfully verify using JAR Signature Scheme.         assertInstallSucceeds(""v1-with-apk-sig-block-but-without-apk-sig-scheme-v2-block.apk"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV2UnknownPairIgnoredInApkSigningBlock"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV2UnknownPairIgnoredInApkSigningBlock() throws Exception {         // Obtained by modifying APK signer to emit an unknown ID-value pair into APK Signing Block         // before the ID-value pair containing the APK Signature Scheme v2 Block. The unknown         // ID-value should be ignored.         assertInstallSucceeds(""v2-only-unknown-pair-in-apk-sig-block.apk"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV2IgnoresUnknownSignatureAlgorithms"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV2IgnoresUnknownSignatureAlgorithms() throws Exception {         // APK is signed with a known signature algorithm and with a couple of unknown ones.         // Obtained by modifying APK signer to use ""unknown"" signature algorithms in addition to         // known ones.         assertInstallSucceeds(""v2-only-with-ignorable-unsupported-sig-algs.apk"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV2RejectsMismatchBetweenSignaturesAndDigestsBlocks"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV2RejectsMismatchBetweenSignaturesAndDigestsBlocks() throws Exception {         // APK is signed with a single signature algorithm, but the digests block claims that it is         // signed with two different signature algorithms. Obtained by modifying APK Signer to         // emit an additional digest record with signature algorithm 0x12345678.         assertInstallFailsWithError(                 ""v2-only-signatures-and-digests-block-mismatch.apk"",                 ""Signature algorithms don't match between digests and signatures records"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV2RejectsMismatchBetweenPublicKeyAndCertificate"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV2RejectsMismatchBetweenPublicKeyAndCertificate() throws Exception {         // APK is signed with v2 only. The public key field does not match the public key in the         // leaf certificate. Obtained by modifying APK signer to write out a modified leaf         // certificate where the RSA modulus has a bitflip.         assertInstallFailsWithError(                 ""v2-only-cert-and-public-key-mismatch.apk"",                 ""Public key mismatch between certificate and signature record"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV2RejectsSignerBlockWithNoCertificates"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV2RejectsSignerBlockWithNoCertificates() throws Exception {         // APK is signed with v2 only. There are no certificates listed in the signer block.         // Obtained by modifying APK signer to output no certificates.         assertInstallFailsWithError(""v2-only-no-certs-in-sig.apk"", ""No certificates listed"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallTwoSigners"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallTwoSigners() throws Exception {         // APK signed by two different signers.         assertInstallSucceeds(""two-signers.apk"");         // Because the install attempt below is an update, it also tests that the signing         // certificates exposed by v2 signatures above are the same as the one exposed by v1         // signatures in this APK.         assertInstallSucceeds(""v1-only-two-signers.apk"");         assertInstallSucceeds(""v2-only-two-signers.apk"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallNegativeModulus"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallNegativeModulus() throws Exception {         // APK signed with a certificate that has a negative RSA modulus.         assertInstallSucceeds(""v1-only-negative-modulus.apk"");         assertInstallSucceeds(""v2-only-negative-modulus.apk"");         assertInstallSucceeds(""v3-only-negative-modulus.apk"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV2TwoSignersRejectsWhenOneBroken"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV2TwoSignersRejectsWhenOneBroken() throws Exception {         // Bitflip in the ECDSA signature of second signer. Based on two-signers.apk.         // This asserts that breakage in any signer leads to rejection of the APK.         assertInstallFailsWithError(                 ""two-signers-second-signer-v2-broken.apk"", ""signature did not verify"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV2TwoSignersRejectsWhenOneWithoutSignatures"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV2TwoSignersRejectsWhenOneWithoutSignatures() throws Exception {         // APK v2-signed by two different signers. However, there are no signatures for the second         // signer.         assertInstallFailsWithError(                 ""v2-only-two-signers-second-signer-no-sig.apk"", ""No signatures"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV2TwoSignersRejectsWhenOneWithoutSupportedSignatures"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV2TwoSignersRejectsWhenOneWithoutSupportedSignatures() throws Exception {         // APK v2-signed by two different signers. However, there are no supported signatures for         // the second signer.         assertInstallFailsWithError(                 ""v2-only-two-signers-second-signer-no-supported-sig.apk"",                 ""No supported signatures"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV2RejectsWhenMissingCode"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV2RejectsWhenMissingCode() throws Exception {         // Obtained by removing classes.dex from original.apk and then signing with v2 only.         // Although this has nothing to do with v2 signature verification, package manager wants         // signature verification / certificate collection to reject APKs with missing code         // (classes.dex) unless requested otherwise.         assertInstallFailsWithError(""v2-only-missing-classes.dex.apk"", ""code is missing"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testCorrectCertUsedFromPkcs7SignedDataCertsSet"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testCorrectCertUsedFromPkcs7SignedDataCertsSet() throws Exception {         // Obtained by prepending the rsa-1024 certificate to the PKCS#7 SignedData certificates set         // of v1-only-with-rsa-pkcs1-sha1-1.2.840.113549.1.1.1-2048.apk META-INF/CERT.RSA. The certs         // (in the order of appearance in the file) are thus: rsa-1024, rsa-2048. The package's         // signing cert is rsa-2048.         assertInstallSucceeds(""v1-only-pkcs7-cert-bag-first-cert-not-used.apk"");          // Check that rsa-1024 was not used as the previously installed package's signing cert.         assertInstallFailsWithError(                 ""v1-only-with-rsa-pkcs1-sha1-1.2.840.113549.1.1.1-1024.apk"",                 ""signatures do not match"");          // Check that rsa-2048 was used as the previously installed package's signing cert.         assertInstallSucceeds(""v1-only-with-rsa-pkcs1-sha1-1.2.840.113549.1.1.1-2048.apk"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testV1SchemeSignatureCertNotReencoded"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testV1SchemeSignatureCertNotReencoded() throws Exception {         // Regression test for b/30148997 and b/18228011. When PackageManager does not preserve the         // original encoded form of signing certificates, bad things happen, such as rejection of         // completely valid updates to apps. The issue in b/30148997 and b/18228011 was that         // PackageManager started re-encoding signing certs into DER. This normally produces exactly         // the original form because X.509 certificates are supposed to be DER-encoded. However, a         // small fraction of Android apps uses X.509 certificates which are not DER-encoded. For         // such apps, re-encoding into DER changes the serialized form of the certificate, creating         // a mismatch with the serialized form stored in the PackageManager database, leading to the         // rejection of updates for the app.         //         // The signing certs of the two APKs differ only in how the cert's signature is encoded.         // From Android's perspective, these two APKs are signed by different entities and thus         // cannot be used to update one another. If signature verification code re-encodes certs         // into DER, both certs will be exactly the same and Android will accept these APKs as         // updates of each other. This test is thus asserting that the two APKs are not accepted as         // updates of each other.         //         // * v1-only-with-rsa-1024.apk cert's signature is DER-encoded         // * v1-only-with-rsa-1024-cert-not-der.apk cert's signature is not DER-encoded. It is         //   BER-encoded, with length encoded as two bytes instead of just one.         //   v1-only-with-rsa-1024-cert-not-der.apk META-INF/CERT.RSA was obtained from         //   v1-only-with-rsa-1024.apk META-INF/CERT.RSA by manually modifying the ASN.1 structure.         assertInstallSucceeds(""v1-only-with-rsa-1024.apk"");         assertInstallFailsWithError(                 ""v1-only-with-rsa-1024-cert-not-der.apk"", ""signatures do not match"");          uninstallPackage();         assertInstallSucceeds(""v1-only-with-rsa-1024-cert-not-der.apk"");         assertInstallFailsWithError(""v1-only-with-rsa-1024.apk"", ""signatures do not match"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testV2SchemeSignatureCertNotReencoded"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testV2SchemeSignatureCertNotReencoded() throws Exception {         // This test is here to catch something like b/30148997 and b/18228011 happening to the         // handling of APK Signature Scheme v2 signatures by PackageManager. When PackageManager         // does not preserve the original encoded form of signing certificates, bad things happen,         // such as rejection of completely valid updates to apps. The issue in b/30148997 and         // b/18228011 was that PackageManager started re-encoding signing certs into DER. This         // normally produces exactly the original form because X.509 certificates are supposed to be         // DER-encoded. However, a small fraction of Android apps uses X.509 certificates which are         // not DER-encoded. For such apps, re-encoding into DER changes the serialized form of the         // certificate, creating a mismatch with the serialized form stored in the PackageManager         // database, leading to the rejection of updates for the app.         //         // The signing certs of the two APKs differ only in how the cert's signature is encoded.         // From Android's perspective, these two APKs are signed by different entities and thus         // cannot be used to update one another. If signature verification code re-encodes certs         // into DER, both certs will be exactly the same and Android will accept these APKs as         // updates of each other. This test is thus asserting that the two APKs are not accepted as         // updates of each other.         //         // * v2-only-with-rsa-pkcs1-sha256-1024.apk cert's signature is DER-encoded         // * v2-only-with-rsa-pkcs1-sha256-1024-cert-not-der.apk cert's signature is not DER-encoded         //   It is BER-encoded, with length encoded as two bytes instead of just one.         assertInstallSucceeds(""v2-only-with-rsa-pkcs1-sha256-1024.apk"");         assertInstallFailsWithError(                 ""v2-only-with-rsa-pkcs1-sha256-1024-cert-not-der.apk"", ""signatures do not match"");          uninstallPackage();         assertInstallSucceeds(""v2-only-with-rsa-pkcs1-sha256-1024-cert-not-der.apk"");         assertInstallFailsWithError(                 ""v2-only-with-rsa-pkcs1-sha256-1024.apk"", ""signatures do not match"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallMaxSizedZipEocdComment"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallMaxSizedZipEocdComment() throws Exception {         // Obtained by modifying apksigner to produce a max-sized (0xffff bytes long) ZIP End of         // Central Directory comment, and signing the original.apk using the modified apksigner.         assertInstallSucceeds(""v1-only-max-sized-eocd-comment.apk"");         assertInstallSucceeds(""v2-only-max-sized-eocd-comment.apk"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallEphemeralRequiresV2Signature"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallEphemeralRequiresV2Signature() throws Exception {         assertInstallEphemeralFailsWithError(""unsigned-ephemeral.apk"",                 ""Failed to collect certificates"");         assertInstallEphemeralFailsWithError(""v1-only-ephemeral.apk"",                 ""must be signed with APK Signature Scheme v2 or greater"");         assertInstallEphemeralSucceeds(""v2-only-ephemeral.apk"");         assertInstallEphemeralSucceeds(""v1-v2-ephemeral.apk""); // signed with both schemes     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallEmpty"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallEmpty() throws Exception {         assertInstallFailsWithError(""empty-unsigned.apk"", ""Unknown failure"");         assertInstallFailsWithError(""v1-only-empty.apk"", ""Unknown failure"");         assertInstallFailsWithError(""v2-only-empty.apk"", ""Unknown failure"");     }      @SecurityTest"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallApkWhichDoesNotStartWithZipLocalFileHeaderMagic"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallApkWhichDoesNotStartWithZipLocalFileHeaderMagic() throws Exception {         // The APKs below are competely fine except they don't start with ZIP Local File Header         // magic. Thus, these APKs will install just fine unless Package Manager requires that APKs         // start with ZIP Local File Header magic.         String error = ""Unknown failure"";          // Obtained by modifying apksigner to output four unused 0x00 bytes at the start of the APK         assertInstallFailsWithError(""v1-only-starts-with-00000000-magic.apk"", error);         assertInstallFailsWithError(""v2-only-starts-with-00000000-magic.apk"", error);          // Obtained by modifying apksigner to output 8 unused bytes (DEX magic and version) at the         // start of the APK         assertInstallFailsWithError(""v1-only-starts-with-dex-magic.apk"", error);         assertInstallFailsWithError(""v2-only-starts-with-dex-magic.apk"", error);     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV3KeyRotation"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV3KeyRotation() throws Exception {         // tests that a v3 signed APK with RSA key can rotate to a new key         assertInstallSucceeds(""v3-rsa-pkcs1-sha256-2048-1.apk"");         assertInstallSucceeds(""v3-rsa-pkcs1-sha256-2048-2-with-por_1_2-full-caps.apk"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV3KeyRotationToAncestor"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV3KeyRotationToAncestor() throws Exception {         // tests that a v3 signed APK with RSA key cannot be upgraded by one of its past certs         assertInstallSucceeds(""v3-rsa-pkcs1-sha256-2048-2-with-por_1_2-full-caps.apk"");         assertInstallFails(""v3-rsa-pkcs1-sha256-2048-1.apk"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV3KeyRotationToAncestorWithRollback"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV3KeyRotationToAncestorWithRollback() throws Exception {         // tests that a v3 signed APK with RSA key can be upgraded by one of its past certs if it         // has granted that cert the rollback capability         assertInstallSucceeds(""v3-rsa-pkcs1-sha256-2048-2-with-por_1_2-full-and-roll-caps.apk"");         assertInstallSucceeds(""v3-rsa-pkcs1-sha256-2048-1.apk"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV3KeyRotationMultipleHops"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV3KeyRotationMultipleHops() throws Exception {         // tests that a v3 signed APK with RSA key can rotate to a new key which is the result of         // multiple rotations from the original: APK signed with key 1 can be updated by key 3, when         // keys were: 1 -> 2 -> 3         assertInstallSucceeds(""v3-rsa-pkcs1-sha256-2048-1.apk"");         assertInstallSucceeds(""v3-rsa-pkcs1-sha256-2048-3-with-por_1_2_3-full-caps.apk"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV3PorSignerMismatch"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV3PorSignerMismatch() throws Exception {         // tests that an APK with a proof-of-rotation struct that doesn't include the current         // signing certificate fails to install         assertInstallFails(""v3-rsa-pkcs1-sha256-2048-3-with-por_1_2-full-caps.apk"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV3KeyRotationWrongPor"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV3KeyRotationWrongPor() throws Exception {         // tests that a valid APK with a proof-of-rotation record can't upgrade an APK with a         // signing certificate that isn't in the proof-of-rotation record         assertInstallSucceeds(""v3-rsa-pkcs1-sha256-2048-1.apk"");         assertInstallFails(""v3-rsa-pkcs1-sha256-2048-3-with-por_2_3-full-caps.apk"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV3KeyRotationSharedUid"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV3KeyRotationSharedUid() throws Exception {         // tests that a v3 signed sharedUid APK can still be sharedUid with apps with its older         // signing certificate, if it so desires         assertInstallSucceeds(""v3-rsa-pkcs1-sha256-2048-1-sharedUid.apk"");         assertInstallSucceeds(                 ""v3-rsa-pkcs1-sha256-2048-2-with-por_1_2-full-caps-sharedUid-companion.apk"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV3KeyRotationOlderSharedUid"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV3KeyRotationOlderSharedUid() throws Exception {          // tests that a sharedUid APK can still install with another app that is signed by a newer         // signing certificate, but which allows sharedUid with the older one         assertInstallSucceeds(                 ""v3-rsa-pkcs1-sha256-2048-2-with-por_1_2-full-caps-sharedUid-companion.apk"");         assertInstallSucceeds(""v3-rsa-pkcs1-sha256-2048-1-sharedUid.apk"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV3KeyRotationSharedUidNoCap"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV3KeyRotationSharedUidNoCap() throws Exception {         // tests that a v3 signed sharedUid APK cannot be sharedUid with apps with its older         // signing certificate, when it has not granted that certificate the sharedUid capability         assertInstallSucceeds(""v3-rsa-pkcs1-sha256-2048-1-sharedUid.apk"");         assertInstallFails(                 ""v3-rsa-pkcs1-sha256-2048-2-with-por_1_2-no-shUid-cap-sharedUid-companion.apk"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV3KeyRotationOlderSharedUidNoCap"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV3KeyRotationOlderSharedUidNoCap() throws Exception {         // tests that a sharedUid APK signed with an old certificate cannot install with         // an app having a proof-of-rotation structure that hasn't granted the older         // certificate the sharedUid capability         assertInstallSucceeds(                 ""v3-rsa-pkcs1-sha256-2048-2-with-por_1_2-no-shUid-cap-sharedUid-companion.apk"");         assertInstallFails(""v3-rsa-pkcs1-sha256-2048-1-sharedUid.apk"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV3NoRotationSharedUid"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV3NoRotationSharedUid() throws Exception {         // tests that a sharedUid APK signed with a new certificate installs with         // an app having a proof-of-rotation structure that hasn't granted an older         // certificate the sharedUid capability         assertInstallSucceeds(                 ""v3-rsa-pkcs1-sha256-2048-2-with-por_1_2-no-shUid-cap-sharedUid-companion.apk"");         assertInstallSucceeds(""v3-rsa-pkcs1-sha256-2048-2-sharedUid.apk"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV3MultipleAppsOneDeniesOldKeySharedUid"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV3MultipleAppsOneDeniesOldKeySharedUid() throws Exception {         // If two apps are installed as part of a sharedUid, one granting access to the sharedUid         // to the previous key and the other revoking access to the sharedUid, then when an app         // signed with the old key attempts to join the sharedUid the installation should be blocked         assertInstallFromBuildSucceeds(                 ""v3-ec-p256-with-por_1_2-default-caps-sharedUid-companion.apk"");         assertInstallFromBuildSucceeds(""v3-ec-p256-with-por_1_2-no-shUid-cap-sharedUid.apk"");         assertInstallFromBuildFails(""v3-ec-p256-1-sharedUid-companion2.apk"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV3MultipleAppsOneUpdatedToDenyOldKeySharedUid"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV3MultipleAppsOneUpdatedToDenyOldKeySharedUid() throws Exception {         // Similar to the test above if two apps are installed as part of a sharedUid with both         // granting access to the sharedUid to the previous key then an app signed with the previous         // key should be allowed to install and join the sharedUid. If one of the first two apps         // is then updated with a lineage that denies access to the sharedUid for the old key the         // installation of this updated app should be blocked.         assertInstallFromBuildSucceeds(""v3-ec-p256-with-por_1_2-default-caps-sharedUid.apk"");         assertInstallFromBuildSucceeds(                 ""v3-ec-p256-with-por_1_2-default-caps-sharedUid-companion.apk"");         assertInstallFromBuildSucceeds(""v3-ec-p256-1-sharedUid-companion2.apk"");         assertInstallFromBuildFails(""v3-ec-p256-with-por_1_2-no-shUid-cap-sharedUid.apk"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV3FirstAppOnlySignedByNewKeyLastAppOldKey"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV3FirstAppOnlySignedByNewKeyLastAppOldKey() throws Exception {         // This test verifies the following scenario:         // - First installed app in sharedUid only signed with new key without lineage.         // - Second installed app in sharedUid signed with new key and includes lineage granting         //   access to the old key to join the sharedUid.         // - Last installed app in sharedUid signed with old key.         // The lineage should be updated when the second app is installed to allow the installation         // of the app signed with the old key.         assertInstallFromBuildSucceeds(""v3-ec-p256-2-sharedUid-companion.apk"");         assertInstallFromBuildSucceeds(""v3-ec-p256-with-por_1_2-default-caps-sharedUid.apk"");         assertInstallFromBuildSucceeds(""v3-ec-p256-1-sharedUid-companion2.apk"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV3AppSignedWithOldKeyUpdatedLineageDeniesShUidCap"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV3AppSignedWithOldKeyUpdatedLineageDeniesShUidCap() throws Exception {         // If an app is installed as part of a sharedUid, and then that app is signed with a new key         // that rejects the previous key in the lineage the update should be allowed to proceed         // as the app is being updated to the newly rotated key.         assertInstallFromBuildSucceeds(""v3-ec-p256-1-sharedUid.apk"");         assertInstallFromBuildSucceeds(""v3-ec-p256-with-por_1_2-no-shUid-cap-sharedUid.apk"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV3TwoSharedUidAppsWithDivergedLineages"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV3TwoSharedUidAppsWithDivergedLineages() throws Exception {         // Apps that are installed as part of the sharedUserId with a lineage must have common         // ancestors; the platform will allow the installation if the lineage of an app being         // installed as part of the sharedUserId is the same, a subset, or a superset of the         // existing lineage, but if the lineage diverges then the installation should be blocked.         assertInstallFromBuildSucceeds(""v3-por_Y_1_2-default-caps-sharedUid.apk"");         assertInstallFromBuildFails(""v3-por_Z_1_2-default-caps-sharedUid-companion.apk"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV3UpdateAfterRotation"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV3UpdateAfterRotation() throws Exception {         // This test performs an end to end verification of the update of an app with a rotated         // key. The app under test exports a bound service that performs its own PackageManager key         // rotation API verification, and the instrumentation test binds to the service and invokes         // the verifySignatures method to verify that the key rotation APIs return the expected         // results. The instrumentation test app is signed with the same key and lineage as the         // app under test to also provide a second app that can be used for the checkSignatures         // verification.          // Install the initial versions of the apps; the test method verifies the app under test is         // signed with the original signing key.         assertInstallFromBuildSucceeds(""CtsSignatureQueryService.apk"");         assertInstallFromBuildSucceeds(""CtsSignatureQueryServiceTest.apk"");         Utils.runDeviceTests(getDevice(), SERVICE_TEST_PKG, SERVICE_TEST_CLASS,                 ""verifySignatures_noRotation_succeeds"");          // Install the second version of the app signed with the rotated key. This test verifies the         // app still functions as expected after the update with the rotated key. The         // instrumentation test app is not updated here to allow verification of the pre-key         // rotation behavior for the checkSignatures APIs. These APIs should behave similar to the         // GET_SIGNATURES flag in that if one or both apps have a signing lineage if the oldest         // signers in the lineage match then the methods should return that the signatures match         // even if one is signed with a newer key in the lineage.         assertInstallFromBuildSucceeds(""CtsSignatureQueryService_v2.apk"");         Utils.runDeviceTests(getDevice(), SERVICE_TEST_PKG, SERVICE_TEST_CLASS,                 ""verifySignatures_withRotation_succeeds"");          // Installs the third version of the app under test and the instrumentation test, both         // signed with the same rotated key and lineage. This test is intended to verify that the         // app can still be updated and function as expected after an update with a rotated key.         assertInstallFromBuildSucceeds(""CtsSignatureQueryService_v3.apk"");         assertInstallFromBuildSucceeds(""CtsSignatureQueryServiceTest_v2.apk"");         Utils.runDeviceTests(getDevice(), SERVICE_TEST_PKG, SERVICE_TEST_CLASS,                 ""verifySignatures_withRotation_succeeds"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV3KeyRotationSigPerm"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV3KeyRotationSigPerm() throws Exception {         // tests that a v3 signed APK can still get a signature permission from an app with its         // older signing certificate.         assertInstallSucceeds(""v3-rsa-pkcs1-sha256-2048-1-permdef.apk"");         assertInstallSucceeds(                 ""v3-rsa-pkcs1-sha256-2048-2-with-por_1_2-full-caps-permcli-companion.apk"");         Utils.runDeviceTests(getDevice(), DEVICE_TESTS_PKG, DEVICE_TESTS_CLASS, ""testHasPerm"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV3KeyRotationOlderSigPerm"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV3KeyRotationOlderSigPerm() throws Exception {         // tests that an apk with an older signing certificate than the one which defines a         // signature permission it wants gets the permission if the defining APK grants the         // capability         assertInstallSucceeds(                 ""v3-rsa-pkcs1-sha256-2048-2-with-por_1_2-full-caps-permdef.apk"");         assertInstallSucceeds(""v3-rsa-pkcs1-sha256-2048-1-permcli-companion.apk"");         Utils.runDeviceTests(getDevice(), DEVICE_TESTS_PKG, DEVICE_TESTS_CLASS, ""testHasPerm"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV3KeyRotationSigPermNoCap"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV3KeyRotationSigPermNoCap() throws Exception {         // tests that an APK signed by an older signing certificate is unable to get a requested         // signature permission when the defining APK has rotated to a newer signing certificiate         // and does not grant the permission capability to the older cert         assertInstallSucceeds(""v3-rsa-pkcs1-sha256-2048-2-with-por_1_2-no-perm-cap-permdef.apk"");         assertInstallSucceeds(""v3-rsa-pkcs1-sha256-2048-1-permcli-companion.apk"");         Utils.runDeviceTests(getDevice(), DEVICE_TESTS_PKG, DEVICE_TESTS_CLASS, ""testHasNoPerm"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV3KeyRotationOlderSigPermNoCap"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV3KeyRotationOlderSigPermNoCap() throws Exception {         // tests that an APK signed by a newer signing certificate than the APK which defines a         // signature permission is able to get that permission, even if the newer APK does not         // grant the permission capability to the older signing certificate.         assertInstallSucceeds(""v3-rsa-pkcs1-sha256-2048-1-permdef.apk"");         assertInstallSucceeds(                 ""v3-rsa-pkcs1-sha256-2048-2-with-por_1_2-no-perm-cap-permcli-companion.apk"");         Utils.runDeviceTests(getDevice(), DEVICE_TESTS_PKG, DEVICE_TESTS_CLASS, ""testHasPerm"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV3NoRotationSigPerm"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV3NoRotationSigPerm() throws Exception {         // make sure that an APK, which wants to use a signature permission defined by an APK, which         // has not granted that capability to older signing certificates, can still install         assertInstallSucceeds(""v3-rsa-pkcs1-sha256-2048-2-with-por_1_2-no-perm-cap-permdef.apk"");         assertInstallSucceeds(""v3-rsa-pkcs1-sha256-2048-2-permcli-companion.apk"");         Utils.runDeviceTests(getDevice(), DEVICE_TESTS_PKG, DEVICE_TESTS_CLASS, ""testHasPerm"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV3SigPermDoubleDefNewerSucceeds"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV3SigPermDoubleDefNewerSucceeds() throws Exception {         // make sure that if an app defines a signature permission already defined by another app,         // it successfully installs if the other app's signing cert is in its past signing certs and         // the signature permission capability is granted         assertInstallSucceeds(""v3-rsa-pkcs1-sha256-2048-1-permdef.apk"");         assertInstallSucceeds(""v3-rsa-pkcs1-sha256-2048-2-with_por_1_2-permdef-companion.apk"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV3SigPermDoubleDefOlderSucceeds"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV3SigPermDoubleDefOlderSucceeds() throws Exception {         // make sure that if an app defines a signature permission already defined by another app,         // it successfully installs if it is in the other app's past signing certs and the signature         // permission capability is granted         assertInstallSucceeds(""v3-rsa-pkcs1-sha256-2048-2-with_por_1_2-permdef-companion.apk"");         assertInstallSucceeds(""v3-rsa-pkcs1-sha256-2048-1-permdef.apk"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV3SigPermDoubleDefNewerNoCapFails"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV3SigPermDoubleDefNewerNoCapFails() throws Exception {         // make sure that if an app defines a signature permission already defined by another app,         // it fails to install if the other app's signing cert is in its past signing certs but the         // signature permission capability is not granted         assertInstallSucceeds(""v3-rsa-pkcs1-sha256-2048-1-permdef.apk"");         assertInstallFails(                 ""v3-rsa-pkcs1-sha256-2048-2-with_por_1_2-no-perm-cap-permdef-companion.apk"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV3SigPermDoubleDefOlderNoCapFails"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV3SigPermDoubleDefOlderNoCapFails() throws Exception {         // make sure that if an app defines a signature permission already defined by another app,         // it fails to install if it is in the other app's past signing certs but the signature         // permission capability is not granted         assertInstallSucceeds(                 ""v3-rsa-pkcs1-sha256-2048-2-with_por_1_2-no-perm-cap-permdef-companion.apk"");         assertInstallFails(""v3-rsa-pkcs1-sha256-2048-1-permdef.apk"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV3SigPermDoubleDefSameNoCapSucceeds"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV3SigPermDoubleDefSameNoCapSucceeds() throws Exception {         // make sure that if an app defines a signature permission already defined by another app,         // it installs successfully when signed by the same certificate, even if the original app         // does not grant signature capabilities to its past certs         assertInstallSucceeds(                 ""v3-rsa-pkcs1-sha256-2048-2-with_por_1_2-no-perm-cap-permdef-companion.apk"");         assertInstallSucceeds(""v3-rsa-pkcs1-sha256-2048-2-permdef.apk"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV3KeyRotationGetSignatures"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV3KeyRotationGetSignatures() throws Exception {         // tests that a PackageInfo w/GET_SIGNATURES flag returns the older cert         assertInstallSucceeds(""v3-rsa-pkcs1-sha256-2048-2-with-por_1_2-full-caps.apk"");         Utils.runDeviceTests(                 getDevice(), DEVICE_TESTS_PKG, DEVICE_TESTS_CLASS, ""testGetSignaturesShowsOld"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV3KeyRotationGetSigningCertificates"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV3KeyRotationGetSigningCertificates() throws Exception {         // tests that a PackageInfo w/GET_SIGNING_CERTIFICATES flag returns the old and new certs         assertInstallSucceeds(""v3-rsa-pkcs1-sha256-2048-2-with-por_1_2-full-caps.apk"");         Utils.runDeviceTests(                 getDevice(), DEVICE_TESTS_PKG, DEVICE_TESTS_CLASS,                 ""testGetSigningCertificatesShowsAll"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV3KeyRotationGetApkContentsSigners"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV3KeyRotationGetApkContentsSigners() throws Exception {         // The GET_SIGNING_CERTIFICATES flag results in a PackageInfo object returned with a         // SigningInfo instance that can be used to query all certificates in the lineage or only         // the current signer(s) via getApkContentsSigners. This test verifies when a V3 signed         // package with a rotated key is queried getApkContentsSigners only returns the current         // signer.         assertInstallFromBuildSucceeds(""v3-ec-p256-with-por_1_2-default-caps.apk"");         Utils.runDeviceTests(                 getDevice(), DEVICE_TESTS_PKG, DEVICE_TESTS_CLASS,                 ""testGetApkContentsSignersShowsCurrent"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV2MultipleSignersGetApkContentsSigners"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV2MultipleSignersGetApkContentsSigners() throws Exception {         // Similar to the above test, but verifies when an APK is signed with two V2 signers         // getApkContentsSigners returns both of the V2 signers.         assertInstallFromBuildSucceeds(""v1v2-ec-p256-two-signers-targetSdk-30.apk"");         Utils.runDeviceTests(                 getDevice(), DEVICE_TESTS_PKG, DEVICE_TESTS_CLASS,                 ""testGetApkContentsSignersShowsMultipleSigners"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV3KeyRotationHasSigningCertificate"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV3KeyRotationHasSigningCertificate() throws Exception {         // tests that hasSigningCertificate() recognizes past and current signing certs         assertInstallSucceeds(""v3-rsa-pkcs1-sha256-2048-2-with-por_1_2-full-caps.apk"");         Utils.runDeviceTests(                 getDevice(), DEVICE_TESTS_PKG, DEVICE_TESTS_CLASS,                 ""testHasSigningCertificate"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV3KeyRotationHasSigningCertificateSha256"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV3KeyRotationHasSigningCertificateSha256() throws Exception {         // tests that hasSigningCertificate() recognizes past and current signing certs by sha256         assertInstallSucceeds(""v3-rsa-pkcs1-sha256-2048-2-with-por_1_2-full-caps.apk"");         Utils.runDeviceTests(                 getDevice(), DEVICE_TESTS_PKG, DEVICE_TESTS_CLASS,                 ""testHasSigningCertificateSha256"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV3KeyRotationHasSigningCertificateByUid"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV3KeyRotationHasSigningCertificateByUid() throws Exception {         // tests that hasSigningCertificate() recognizes past and current signing certs by uid         assertInstallSucceeds(""v3-rsa-pkcs1-sha256-2048-2-with-por_1_2-full-caps.apk"");         Utils.runDeviceTests(                 getDevice(), DEVICE_TESTS_PKG, DEVICE_TESTS_CLASS,                 ""testHasSigningCertificateByUid"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV3KeyRotationHasSigningCertificateByUidSha256"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV3KeyRotationHasSigningCertificateByUidSha256() throws Exception {         // tests that hasSigningCertificate() recognizes past and current signing certs by uid         // and sha256         assertInstallSucceeds(""v3-rsa-pkcs1-sha256-2048-2-with-por_1_2-full-caps.apk"");         Utils.runDeviceTests(                 getDevice(), DEVICE_TESTS_PKG, DEVICE_TESTS_CLASS,                 ""testHasSigningCertificateByUidSha256"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV3KeyRotationHasDuplicateSigningCertificateHistory"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV3KeyRotationHasDuplicateSigningCertificateHistory() throws Exception {         // tests that an app's proof-of-rotation signing history cannot contain the same certificate         // more than once.         assertInstallFails(""v3-rsa-pkcs1-sha256-2048-2-with-por_1_2_2-full-caps.apk"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV3HasMultipleSigners"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV3HasMultipleSigners() throws Exception {         // tests that an app can't be signed by multiple signers when using v3 signature scheme         assertInstallFails(""v3-rsa-pkcs1-sha256-2048-1_and_2.apk"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV3HasMultiplePlatformSigners"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV3HasMultiplePlatformSigners() throws Exception {         // tests that an app can be signed by multiple v3 signers if they target different platform         // versions         assertInstallSucceeds(""v3-rsa-pkcs1-sha256-2048-1_P_and_2_Qplus.apk"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallTargetSdk30WithV1Signers"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallTargetSdk30WithV1Signers() throws Exception {         // An app targeting SDK version >= 30 must have at least a V2 signature; this test verifies         // an app targeting SDK version 30 with only a V1 signature fails to install.         assertInstallFails(""v1-ec-p256-two-signers-targetSdk-30.apk"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallTargetSdk30WithV1V2Signers"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallTargetSdk30WithV1V2Signers() throws Exception {         // An app targeting SDK version >= 30 must have at least a V2 signature; this test verifies         // that an app targeting SDK version 30 with both a V1 and V2 signature installs         // successfully.         installApkFromBuild(""v1v2-ec-p256-two-signers-targetSdk-30.apk"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV4WithV2Signer"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV4WithV2Signer() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // APK generated with:         // apksigner sign --v2-signing-enabled true --v3-signing-enabled false --v4-signing-enabled         assertInstallV4Succeeds(""v4-digest-v2.apk"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV4WithV3Signer"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV4WithV3Signer() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // APK generated with:         // apksigner sign --v2-signing-enabled false --v3-signing-enabled true --v4-signing-enabled         assertInstallV4Succeeds(""v4-digest-v3.apk"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV4WithV2V3Signer"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV4WithV2V3Signer() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // APK generated with:         // apksigner sign --v2-signing-enabled true --v3-signing-enabled true --v4-signing-enabled         assertInstallV4Succeeds(""v4-digest-v2v3.apk"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV4WithV2NoVeritySigner"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV4WithV2NoVeritySigner() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // APK generated with:         // --v2-signing-enabled true --v3-signing-enabled false --v4-signing-enabled         // Full commands in generate-apks.sh         assertInstallV4SucceedsAndUninstall(""v4-digest-v2-Sha256withDSA.apk"");         assertInstallV4SucceedsAndUninstall(""v4-digest-v2-Sha256withEC.apk"");         assertInstallV4SucceedsAndUninstall(""v4-digest-v2-Sha256withRSA.apk"");         assertInstallV4SucceedsAndUninstall(""v4-digest-v2-Sha512withEC.apk"");         assertInstallV4SucceedsAndUninstall(""v4-digest-v2-Sha512withRSA.apk"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV4WithV2VeritySigner"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV4WithV2VeritySigner() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // APK generated with:         // --v2-signing-enabled true --v3-signing-enabled false         // --v4-signing-enabled --verity-enabled         // Full commands in generate-apks.sh         assertInstallV4SucceedsAndUninstall(""v4-digest-v2-Sha256withDSA-Verity.apk"");         assertInstallV4SucceedsAndUninstall(""v4-digest-v2-Sha256withEC-Verity.apk"");         assertInstallV4SucceedsAndUninstall(""v4-digest-v2-Sha256withRSA-Verity.apk"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV4WithV3NoVeritySigner"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV4WithV3NoVeritySigner() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // APK generated with:         // --v2-signing-enabled false --v3-signing-enabled true --v4-signing-enabled         // Full commands in generate-apks.sh         assertInstallV4SucceedsAndUninstall(""v4-digest-v3-Sha256withDSA.apk"");         assertInstallV4SucceedsAndUninstall(""v4-digest-v3-Sha256withEC.apk"");         assertInstallV4SucceedsAndUninstall(""v4-digest-v3-Sha256withRSA.apk"");         assertInstallV4SucceedsAndUninstall(""v4-digest-v3-Sha512withEC.apk"");         assertInstallV4SucceedsAndUninstall(""v4-digest-v3-Sha512withRSA.apk"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV4WithV3VeritySigner"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV4WithV3VeritySigner() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // APK generated with:         // --v2-signing-enabled false --v3-signing-enabled true         // --v4-signing-enabled --verity-enabled         // Full commands in generate-apks.sh         assertInstallV4SucceedsAndUninstall(""v4-digest-v3-Sha256withDSA-Verity.apk"");         assertInstallV4SucceedsAndUninstall(""v4-digest-v3-Sha256withEC-Verity.apk"");         assertInstallV4SucceedsAndUninstall(""v4-digest-v3-Sha256withRSA-Verity.apk"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV4WithV2SignerDoesNotVerify"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV4WithV2SignerDoesNotVerify() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // APKs generated with:         // apksigner sign -v2-signing-enabled true --v3-signing-enabled false --v4-signing-enabled          // Malformed v4 signature - first byte of v4 signing_info.signature is flipped         assertInstallV4FailsWithError(""v4-digest-v2-badv4signature.apk"", ""did not verify"");         // Malformed digest - first byte of v4 signing_info.apk_digest is flipped         assertInstallV4FailsWithError(""v4-digest-v2-badv2digest.apk"", ""did not verify"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV4WithV3SignerDoesNotVerify"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV4WithV3SignerDoesNotVerify() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // APKs generated with:         // apksigner sign -v2-signing-enabled false --v3-signing-enabled true --v4-signing-enabled          // Malformed v4 signature - first byte of v4 signing_info.signature is flipped         assertInstallV4FailsWithError(""v4-digest-v3-badv4signature.apk"", ""did not verify"");          // Malformed digest - first byte of v4 signing_info.apk_digest is flipped         assertInstallV4FailsWithError(""v4-digest-v3-badv3digest.apk"", ""did not verify"");      }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV4WithV2V3SignerDoesNotVerify"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV4WithV2V3SignerDoesNotVerify() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // APKs generated with:         // apksigner sign -v2-signing-enabled true --v3-signing-enabled true --v4-signing-enabled          // Malformed v4 signature - first byte of v4 signing_info.signature is flipped         assertInstallV4FailsWithError(""v4-digest-v2v3-badv4signature.apk"", ""did not verify"");          // Malformed digest - first byte of v4 signing_info.apk_digest is flipped         assertInstallV4FailsWithError(""v4-digest-v2v3-badv2v3digest.apk"", ""did not verify"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV4With128BytesAdditionalDataSucceeds"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV4With128BytesAdditionalDataSucceeds() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // Editing apksigner to fill additional data of size 128 bytes.         assertInstallV4Succeeds(""v4-digest-v3-128bytes-additional-data.apk"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV4With10MBytesAdditionalDataFails"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV4With10MBytesAdditionalDataFails() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // Editing apksigner to fill additional data of size 10 * 1024 * 1024 bytes..         assertInstallV4FailsWithError(""v4-digest-v3-10mbytes-additional-data.apk"",                 ""additionalData has to be at most 128 bytes"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV4WithWrongBlockSize"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV4WithWrongBlockSize() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // Editing apksigner with the wrong block size in the v4 signature.         assertInstallV4FailsWithError(""v4-digest-v3-wrong-block-size.apk"",                 ""did not verify"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV4WithDifferentBlockSize"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV4WithDifferentBlockSize() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // Editing apksigner with the different block size (2048 instead of 4096).         assertInstallV4FailsWithError(""v4-digest-v3-merkle-tree-different-block-size.apk"",                 ""Unsupported log2BlockSize: 11"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV4WithWrongRawRootHash"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV4WithWrongRawRootHash() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // Editing apksigner with the wrong raw root hash in the v4 signature.         assertInstallV4FailsWithError(""v4-digest-v3-wrong-raw-root-hash.apk"", ""Failure"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV4WithWrongSignatureBytes"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV4WithWrongSignatureBytes() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // Editing apksigner with the wrong signature bytes in the v4 signature.         assertInstallV4FailsWithError(""v4-digest-v3-wrong-sig-bytes.apk"",                 ""did not verify"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV4WithWrongSignatureBytesSize"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV4WithWrongSignatureBytesSize() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // Editing apksigner with the wrong signature byte size in the v4 signature.         assertInstallV4FailsWithError(""v4-digest-v3-wrong-sig-bytes-size.apk"",                 ""Failure"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV4WithNoMerkleTree"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV4WithNoMerkleTree() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // Editing apksigner to not include the Merkle tree.         assertInstallV4FailsWithError(""v4-digest-v3-no-merkle-tree.apk"",                 ""Failure"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV4WithWithTrailingDataInMerkleTree"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV4WithWithTrailingDataInMerkleTree() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // Editing apksigner to add trailing data after the Merkle tree         assertInstallV4FailsWithError(""v4-digest-v3-merkle-tree-1mb-trailing-data.apk"",                 ""Failure"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV4WithMerkleTreeBitsFlipped"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV4WithMerkleTreeBitsFlipped() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // Editing apksigner to flip few bits in the only node of the Merkle tree of a small app.         assertInstallV4FailsWithError(""v4-digest-v3-merkle-tree-bit-flipped.apk"",                 ""Failed to parse"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testV4IncToV3NonIncSameKeyUpgradeSucceeds"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testV4IncToV3NonIncSameKeyUpgradeSucceeds() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // See cts/hostsidetests/appsecurity/res/pkgsigverify/generate-apks.sh for the command         // to generate the apks         assertInstallV4Succeeds(""v4-inc-to-v3-noninc-ec-p256-appv1.apk"");          // non-incremental upgrade with the same key.         assertInstallSucceeds(""v4-inc-to-v3-noninc-ec-p256-appv2.apk"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testV4IncToV3NonIncMismatchingKeyUpgradeFails"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testV4IncToV3NonIncMismatchingKeyUpgradeFails() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // See cts/hostsidetests/appsecurity/res/pkgsigverify/generate-apks.sh for the command         // to generate the apks         assertInstallV4Succeeds(""v4-inc-to-v3-noninc-ec-p256-appv1.apk"");          // non-incremental upgrade with a mismatching key.         assertInstallFailsWithError(""v4-inc-to-v3-noninc-ec-p384-appv2.apk"",                 ""signatures do not match previously installed version"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testV4IncToV3NonIncRotatedKeyUpgradeSucceeds"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testV4IncToV3NonIncRotatedKeyUpgradeSucceeds() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // See cts/hostsidetests/appsecurity/res/pkgsigverify/generate-apks.sh for the command         // to generate the apks         assertInstallV4Succeeds(""v4-inc-to-v3-noninc-ec-p256-appv1.apk"");          // non-incremental upgrade with key rotation.         assertInstallSucceeds(""v4-inc-to-v3-noninc-ec-p384-rotated-ec-p256-appv2.apk"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testV4IncToV3NonIncMismatchedRotatedKeyUpgradeFails"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testV4IncToV3NonIncMismatchedRotatedKeyUpgradeFails() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // See cts/hostsidetests/appsecurity/res/pkgsigverify/generate-apks.sh for the command         // to generate the apks         assertInstallV4Succeeds(""v4-inc-to-v3-noninc-dsa-3072-appv1.apk"");          // non-incremental upgrade with key rotation mismatch with key used in app v1.         assertInstallFailsWithError(""v4-inc-to-v3-noninc-ec-p384-rotated-ec-p256-appv2.apk"",                 ""signatures do not match previously installed version"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testV4IncToV2NonIncSameKeyUpgradeSucceeds"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testV4IncToV2NonIncSameKeyUpgradeSucceeds() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // See cts/hostsidetests/appsecurity/res/pkgsigverify/generate-apks.sh for the command         // to generate the apks         assertInstallV4Succeeds(""v4-inc-to-v2-noninc-ec-p256-appv1.apk"");          // non-incremental upgrade with the same key.         assertInstallSucceeds(""v4-inc-to-v2-noninc-ec-p256-appv2.apk"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testV4IncToV2NonIncMismatchingKeyUpgradeFails"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testV4IncToV2NonIncMismatchingKeyUpgradeFails() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // See cts/hostsidetests/appsecurity/res/pkgsigverify/generate-apks.sh for the command         // to generate the apks         assertInstallV4Succeeds(""v4-inc-to-v2-noninc-ec-p256-appv1.apk"");          // non-incremental upgrade with a mismatching key.         assertInstallFailsWithError(""v4-inc-to-v2-noninc-ec-p384-appv2.apk"",                 ""signatures do not match previously installed version"");     }      private boolean hasIncrementalFeature() throws DeviceNotAvailableException {         return getDevice().hasFeature(""android.software.incremental_delivery"");     }      private void assertInstallSucceeds(String apkFilenameInResources) throws Exception {         String installResult = installPackageFromResource(apkFilenameInResources);         if (installResult != null) {             fail(""Failed to install "" + apkFilenameInResources + "": "" + installResult);         }     }      private void assertInstallEphemeralSucceeds(String apkFilenameInResources) throws Exception {         String installResult = installEphemeralPackageFromResource(apkFilenameInResources);         if (installResult != null) {             fail(""Failed to install "" + apkFilenameInResources + "": "" + installResult);         }     }      private void assertInstallSucceedsForEach(             String apkFilenamePatternInResources, String[] args) throws Exception {         for (String arg : args) {             String apkFilenameInResources =                     String.format(Locale.US, apkFilenamePatternInResources, arg);             String installResult = installPackageFromResource(apkFilenameInResources);             if (installResult != null) {                 fail(""Failed to install "" + apkFilenameInResources + "": "" + installResult);             }             try {                 uninstallPackage();             } catch (Exception e) {                 throw new RuntimeException(                         ""Failed to uninstall after installing "" + apkFilenameInResources, e);             }         }     }      private void assertInstallV4Succeeds(String apkFilenameInResources) throws Exception {         String installResult = installV4PackageFromResource(apkFilenameInResources);         if (!installResult.equals(""Success\n"")) {             fail(""Failed to install "" + apkFilenameInResources + "": "" + installResult);         }     }      private void assertInstallV4SucceedsAndUninstall(String apkFilenameInResources)             throws Exception {         assertInstallV4Succeeds(apkFilenameInResources);         try {             uninstallPackage();         } catch (Exception e) {             throw new RuntimeException(                     ""Failed to uninstall after installing "" + apkFilenameInResources, e);         }     }      private void assertInstallV4FailsWithError(String apkFilenameInResources, String errorSubstring)             throws Exception {         String installResult = installV4PackageFromResource(apkFilenameInResources);         if (installResult.equals(""Success\n"")) {             fail(""Install of "" + apkFilenameInResources + "" succeeded but was expected to fail""                     + "" with \"""" + errorSubstring + ""\"""");         }         assertContains(                 ""Install failure message of "" + apkFilenameInResources,                 errorSubstring,                 installResult);     }      private void assertInstallFailsWithError(             String apkFilenameInResources, String errorSubstring) throws Exception {         String installResult = installPackageFromResource(apkFilenameInResources);         if (installResult == null) {             fail(""Install of "" + apkFilenameInResources + "" succeeded but was expected to fail""                     + "" with \"""" + errorSubstring + ""\"""");         }         assertContains(                 ""Install failure message of "" + apkFilenameInResources,                 errorSubstring,                 installResult);     }      private void assertInstallEphemeralFailsWithError(             String apkFilenameInResources, String errorSubstring) throws Exception {         String installResult = installEphemeralPackageFromResource(apkFilenameInResources);         if (installResult == null) {             fail(""Install of "" + apkFilenameInResources + "" succeeded but was expected to fail""                     + "" with \"""" + errorSubstring + ""\"""");         }         assertContains(                 ""Install failure message of "" + apkFilenameInResources,                 errorSubstring,                 installResult);     }      private void assertInstallFails(String apkFilenameInResources) throws Exception {         String installResult = installPackageFromResource(apkFilenameInResources);         if (installResult == null) {             fail(""Install of "" + apkFilenameInResources + "" succeeded but was expected to fail"");         }     }      private static void assertContains(String message, String expectedSubstring, String actual) {         String errorPrefix = ((message != null) && (message.length() > 0)) ? (message + "": "") : """";         if (actual == null) {             fail(errorPrefix + ""Expected to contain \"""" + expectedSubstring + ""\"", but was null"");         }         if (!actual.contains(expectedSubstring)) {             fail(errorPrefix + ""Expected to contain \"""" + expectedSubstring + ""\"", but was \""""                     + actual + ""\"""");         }     }      private void installDeviceTestPkg() throws Exception {         assertInstallFromBuildSucceeds(DEVICE_TESTS_APK);     }      private void assertInstallFromBuildSucceeds(String apkName) throws Exception {         String result = installApkFromBuild(apkName);         assertNull(""failed to install "" + apkName + "", Reason: "" + result, result);     }      private void assertInstallFromBuildFails(String apkName) throws Exception {         String result = installApkFromBuild(apkName);         assertNotNull(""Successfully installed "" + apkName + "" when failure was expected"", result);     }      private String installApkFromBuild(String apkName) throws Exception {         CompatibilityBuildHelper buildHelper = new CompatibilityBuildHelper(mCtsBuild);         File apk = buildHelper.getTestFile(apkName);         return getDevice().installPackage(apk, true, INSTALL_ARG_FORCE_QUERYABLE);     }      private String installPackageFromResource(String apkFilenameInResources, boolean ephemeral)             throws IOException, DeviceNotAvailableException {         // ITestDevice.installPackage API requires the APK to be install to be a File. We thus         // copy the requested resource into a temporary file, attempt to install it, and delete the         // file during cleanup.         File apkFile = null;         try {             apkFile = getFileFromResource(apkFilenameInResources);             if (ephemeral) {                 return getDevice().installPackage(apkFile, true, ""--ephemeral"",                         INSTALL_ARG_FORCE_QUERYABLE);             } else {                 return getDevice().installPackage(apkFile, true, INSTALL_ARG_FORCE_QUERYABLE);             }         } finally {             cleanUpFile(apkFile);         }     }      private String installV4PackageFromResource(String apkFilenameInResources)             throws IOException, DeviceNotAvailableException {         File apkFile = null;         File v4SignatureFile = null;         try {             apkFile = getFileFromResource(apkFilenameInResources);             v4SignatureFile = getFileFromResource(apkFilenameInResources + "".idsig"");             String remoteApkFilePath = pushFileToRemote(apkFile);             pushFileToRemote(v4SignatureFile);             return installV4Package(remoteApkFilePath);         } finally {             cleanUpFile(apkFile);             cleanUpFile(v4SignatureFile);         }     }      private String pushFileToRemote(File localFile) throws DeviceNotAvailableException {         String remotePath = ""/data/local/tmp/pkginstalltest-"" + localFile.getName();         getDevice().pushFile(localFile, remotePath);         return remotePath;     }      private String installV4Package(String remoteApkPath)             throws DeviceNotAvailableException {         String command = ""pm install-incremental -t -g "" + remoteApkPath;         return getDevice().executeShellCommand(command);     }      private File getFileFromResource(String filenameInResources)             throws IOException, IllegalArgumentException {         String fullResourceName = TEST_APK_RESOURCE_PREFIX + filenameInResources;         File tempDir = FileUtil.createTempDir(""pkginstalltest"");         File file = new File(tempDir, filenameInResources);         InputStream in = getClass().getResourceAsStream(fullResourceName);         if (in == null) {             throw new IllegalArgumentException(""Resource not found: "" + fullResourceName);         }         OutputStream out = new BufferedOutputStream(new FileOutputStream(file));         byte[] buf = new byte[65536];         int chunkSize;         while ((chunkSize = in.read(buf)) != -1) {             out.write(buf, 0, chunkSize);         }         out.close();         return file;     }      private void cleanUpFile(File file) {         if (file != null && file.exists()) {             file.delete();         }     }      private String installPackageFromResource(String apkFilenameInResources)             throws IOException, DeviceNotAvailableException {         return installPackageFromResource(apkFilenameInResources, false);     }      private String installEphemeralPackageFromResource(String apkFilenameInResources)             throws IOException, DeviceNotAvailableException {         return installPackageFromResource(apkFilenameInResources, true);     }      private String uninstallPackage() throws DeviceNotAvailableException {         return getDevice().uninstallPackage(TEST_PKG);     }      private String uninstallCompanionPackages() throws DeviceNotAvailableException {         String result1 = getDevice().uninstallPackage(COMPANION_TEST_PKG);         String result2 = getDevice().uninstallPackage(COMPANION2_TEST_PKG);         return result1 != null ? result1 : result2;     }      private String uninstallDeviceTestPackage() throws DeviceNotAvailableException {         return getDevice().uninstallPackage(DEVICE_TESTS_PKG);     }      private void uninstallServicePackages() throws DeviceNotAvailableException {         getDevice().uninstallPackage(SERVICE_PKG);         getDevice().uninstallPackage(SERVICE_TEST_PKG);     }      private void uninstallPackages() throws DeviceNotAvailableException {         uninstallPackage();         uninstallCompanionPackages();         uninstallDeviceTestPackage();         uninstallServicePackages();     } }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV4WithV2Signer"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	"v4"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV4WithV2Signer() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // APK generated with:         // apksigner sign --v2-signing-enabled true --v3-signing-enabled false --v4-signing-enabled         assertInstallV4Succeeds(""v4-digest-v2.apk"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV4WithV3Signer"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	"v4"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV4WithV3Signer() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // APK generated with:         // apksigner sign --v2-signing-enabled false --v3-signing-enabled true --v4-signing-enabled         assertInstallV4Succeeds(""v4-digest-v3.apk"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV4WithV2V3Signer"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	"v4"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV4WithV2V3Signer() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // APK generated with:         // apksigner sign --v2-signing-enabled true --v3-signing-enabled true --v4-signing-enabled         assertInstallV4Succeeds(""v4-digest-v2v3.apk"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV4WithV2NoVeritySigner"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	"v4"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV4WithV2NoVeritySigner() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // APK generated with:         // --v2-signing-enabled true --v3-signing-enabled false --v4-signing-enabled         // Full commands in generate-apks.sh         assertInstallV4SucceedsAndUninstall(""v4-digest-v2-Sha256withDSA.apk"");         assertInstallV4SucceedsAndUninstall(""v4-digest-v2-Sha256withEC.apk"");         assertInstallV4SucceedsAndUninstall(""v4-digest-v2-Sha256withRSA.apk"");         assertInstallV4SucceedsAndUninstall(""v4-digest-v2-Sha512withEC.apk"");         assertInstallV4SucceedsAndUninstall(""v4-digest-v2-Sha512withRSA.apk"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV4WithV2VeritySigner"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	"v4"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV4WithV2VeritySigner() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // APK generated with:         // --v2-signing-enabled true --v3-signing-enabled false         // --v4-signing-enabled --verity-enabled         // Full commands in generate-apks.sh         assertInstallV4SucceedsAndUninstall(""v4-digest-v2-Sha256withDSA-Verity.apk"");         assertInstallV4SucceedsAndUninstall(""v4-digest-v2-Sha256withEC-Verity.apk"");         assertInstallV4SucceedsAndUninstall(""v4-digest-v2-Sha256withRSA-Verity.apk"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV4WithV3NoVeritySigner"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	"v4"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV4WithV3NoVeritySigner() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // APK generated with:         // --v2-signing-enabled false --v3-signing-enabled true --v4-signing-enabled         // Full commands in generate-apks.sh         assertInstallV4SucceedsAndUninstall(""v4-digest-v3-Sha256withDSA.apk"");         assertInstallV4SucceedsAndUninstall(""v4-digest-v3-Sha256withEC.apk"");         assertInstallV4SucceedsAndUninstall(""v4-digest-v3-Sha256withRSA.apk"");         assertInstallV4SucceedsAndUninstall(""v4-digest-v3-Sha512withEC.apk"");         assertInstallV4SucceedsAndUninstall(""v4-digest-v3-Sha512withRSA.apk"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV4WithV3VeritySigner"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	"v4"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV4WithV3VeritySigner() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // APK generated with:         // --v2-signing-enabled false --v3-signing-enabled true         // --v4-signing-enabled --verity-enabled         // Full commands in generate-apks.sh         assertInstallV4SucceedsAndUninstall(""v4-digest-v3-Sha256withDSA-Verity.apk"");         assertInstallV4SucceedsAndUninstall(""v4-digest-v3-Sha256withEC-Verity.apk"");         assertInstallV4SucceedsAndUninstall(""v4-digest-v3-Sha256withRSA-Verity.apk"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV4WithV2SignerDoesNotVerify"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	"v4"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV4WithV2SignerDoesNotVerify() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // APKs generated with:         // apksigner sign -v2-signing-enabled true --v3-signing-enabled false --v4-signing-enabled          // Malformed v4 signature - first byte of v4 signing_info.signature is flipped         assertInstallV4FailsWithError(""v4-digest-v2-badv4signature.apk"", ""did not verify"");         // Malformed digest - first byte of v4 signing_info.apk_digest is flipped         assertInstallV4FailsWithError(""v4-digest-v2-badv2digest.apk"", ""did not verify"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV4WithV3SignerDoesNotVerify"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	"v4"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV4WithV3SignerDoesNotVerify() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // APKs generated with:         // apksigner sign -v2-signing-enabled false --v3-signing-enabled true --v4-signing-enabled          // Malformed v4 signature - first byte of v4 signing_info.signature is flipped         assertInstallV4FailsWithError(""v4-digest-v3-badv4signature.apk"", ""did not verify"");          // Malformed digest - first byte of v4 signing_info.apk_digest is flipped         assertInstallV4FailsWithError(""v4-digest-v3-badv3digest.apk"", ""did not verify"");      }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV4WithV2V3SignerDoesNotVerify"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	"v4"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV4WithV2V3SignerDoesNotVerify() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // APKs generated with:         // apksigner sign -v2-signing-enabled true --v3-signing-enabled true --v4-signing-enabled          // Malformed v4 signature - first byte of v4 signing_info.signature is flipped         assertInstallV4FailsWithError(""v4-digest-v2v3-badv4signature.apk"", ""did not verify"");          // Malformed digest - first byte of v4 signing_info.apk_digest is flipped         assertInstallV4FailsWithError(""v4-digest-v2v3-badv2v3digest.apk"", ""did not verify"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV4With128BytesAdditionalDataSucceeds"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	"v4"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV4With128BytesAdditionalDataSucceeds() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // Editing apksigner to fill additional data of size 128 bytes.         assertInstallV4Succeeds(""v4-digest-v3-128bytes-additional-data.apk"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV4With10MBytesAdditionalDataFails"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	"v4"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV4With10MBytesAdditionalDataFails() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // Editing apksigner to fill additional data of size 10 * 1024 * 1024 bytes..         assertInstallV4FailsWithError(""v4-digest-v3-10mbytes-additional-data.apk"",                 ""additionalData has to be at most 128 bytes"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV4WithWrongBlockSize"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	"v4"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV4WithWrongBlockSize() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // Editing apksigner with the wrong block size in the v4 signature.         assertInstallV4FailsWithError(""v4-digest-v3-wrong-block-size.apk"",                 ""did not verify"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV4WithDifferentBlockSize"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	"v4"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV4WithDifferentBlockSize() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // Editing apksigner with the different block size (2048 instead of 4096).         assertInstallV4FailsWithError(""v4-digest-v3-merkle-tree-different-block-size.apk"",                 ""Unsupported log2BlockSize: 11"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV4WithWrongRawRootHash"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	"v4"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV4WithWrongRawRootHash() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // Editing apksigner with the wrong raw root hash in the v4 signature.         assertInstallV4FailsWithError(""v4-digest-v3-wrong-raw-root-hash.apk"", ""Failure"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV4WithWrongSignatureBytes"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	"v4"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV4WithWrongSignatureBytes() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // Editing apksigner with the wrong signature bytes in the v4 signature.         assertInstallV4FailsWithError(""v4-digest-v3-wrong-sig-bytes.apk"",                 ""did not verify"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV4WithWrongSignatureBytesSize"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	"v4"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV4WithWrongSignatureBytesSize() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // Editing apksigner with the wrong signature byte size in the v4 signature.         assertInstallV4FailsWithError(""v4-digest-v3-wrong-sig-bytes-size.apk"",                 ""Failure"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV4WithNoMerkleTree"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	"v4"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV4WithNoMerkleTree() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // Editing apksigner to not include the Merkle tree.         assertInstallV4FailsWithError(""v4-digest-v3-no-merkle-tree.apk"",                 ""Failure"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV4WithWithTrailingDataInMerkleTree"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	"v4"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV4WithWithTrailingDataInMerkleTree() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // Editing apksigner to add trailing data after the Merkle tree         assertInstallV4FailsWithError(""v4-digest-v3-merkle-tree-1mb-trailing-data.apk"",                 ""Failure"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV4WithMerkleTreeBitsFlipped"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	"v4"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testInstallV4WithMerkleTreeBitsFlipped() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // Editing apksigner to flip few bits in the only node of the Merkle tree of a small app.         assertInstallV4FailsWithError(""v4-digest-v3-merkle-tree-bit-flipped.apk"",                 ""Failed to parse"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testV4IncToV3NonIncSameKeyUpgradeSucceeds"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	"v4"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testV4IncToV3NonIncSameKeyUpgradeSucceeds() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // See cts/hostsidetests/appsecurity/res/pkgsigverify/generate-apks.sh for the command         // to generate the apks         assertInstallV4Succeeds(""v4-inc-to-v3-noninc-ec-p256-appv1.apk"");          // non-incremental upgrade with the same key.         assertInstallSucceeds(""v4-inc-to-v3-noninc-ec-p256-appv2.apk"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testV4IncToV3NonIncMismatchingKeyUpgradeFails"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	"v4"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testV4IncToV3NonIncMismatchingKeyUpgradeFails() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // See cts/hostsidetests/appsecurity/res/pkgsigverify/generate-apks.sh for the command         // to generate the apks         assertInstallV4Succeeds(""v4-inc-to-v3-noninc-ec-p256-appv1.apk"");          // non-incremental upgrade with a mismatching key.         assertInstallFailsWithError(""v4-inc-to-v3-noninc-ec-p384-appv2.apk"",                 ""signatures do not match previously installed version"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testV4IncToV3NonIncRotatedKeyUpgradeSucceeds"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	"v4"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testV4IncToV3NonIncRotatedKeyUpgradeSucceeds() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // See cts/hostsidetests/appsecurity/res/pkgsigverify/generate-apks.sh for the command         // to generate the apks         assertInstallV4Succeeds(""v4-inc-to-v3-noninc-ec-p256-appv1.apk"");          // non-incremental upgrade with key rotation.         assertInstallSucceeds(""v4-inc-to-v3-noninc-ec-p384-rotated-ec-p256-appv2.apk"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testV4IncToV3NonIncMismatchedRotatedKeyUpgradeFails"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	"v4"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testV4IncToV3NonIncMismatchedRotatedKeyUpgradeFails() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // See cts/hostsidetests/appsecurity/res/pkgsigverify/generate-apks.sh for the command         // to generate the apks         assertInstallV4Succeeds(""v4-inc-to-v3-noninc-dsa-3072-appv1.apk"");          // non-incremental upgrade with key rotation mismatch with key used in app v1.         assertInstallFailsWithError(""v4-inc-to-v3-noninc-ec-p384-rotated-ec-p256-appv2.apk"",                 ""signatures do not match previously installed version"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testV4IncToV2NonIncSameKeyUpgradeSucceeds"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	"v4"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testV4IncToV2NonIncSameKeyUpgradeSucceeds() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // See cts/hostsidetests/appsecurity/res/pkgsigverify/generate-apks.sh for the command         // to generate the apks         assertInstallV4Succeeds(""v4-inc-to-v2-noninc-ec-p256-appv1.apk"");          // non-incremental upgrade with the same key.         assertInstallSucceeds(""v4-inc-to-v2-noninc-ec-p256-appv2.apk"");     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testV4IncToV2NonIncMismatchingKeyUpgradeFails"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	"v4"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	"public void testV4IncToV2NonIncMismatchingKeyUpgradeFails() throws Exception {         // V4 is only enabled on devices with Incremental feature         if (!hasIncrementalFeature()) {             return;         }          // See cts/hostsidetests/appsecurity/res/pkgsigverify/generate-apks.sh for the command         // to generate the apks         assertInstallV4Succeeds(""v4-inc-to-v2-noninc-ec-p256-appv1.apk"");          // non-incremental upgrade with a mismatching key.         assertInstallFailsWithError(""v4-inc-to-v2-noninc-ec-p384-appv2.apk"",                 ""signatures do not match previously installed version"");     }      private boolean hasIncrementalFeature() throws DeviceNotAvailableException {         return getDevice().hasFeature(""android.software.incremental_delivery"");     }      private void assertInstallSucceeds(String apkFilenameInResources) throws Exception {         String installResult = installPackageFromResource(apkFilenameInResources);         if (installResult != null) {             fail(""Failed to install "" + apkFilenameInResources + "": "" + installResult);         }     }      private void assertInstallEphemeralSucceeds(String apkFilenameInResources) throws Exception {         String installResult = installEphemeralPackageFromResource(apkFilenameInResources);         if (installResult != null) {             fail(""Failed to install "" + apkFilenameInResources + "": "" + installResult);         }     }      private void assertInstallSucceedsForEach(             String apkFilenamePatternInResources, String[] args) throws Exception {         for (String arg : args) {             String apkFilenameInResources =                     String.format(Locale.US, apkFilenamePatternInResources, arg);             String installResult = installPackageFromResource(apkFilenameInResources);             if (installResult != null) {                 fail(""Failed to install "" + apkFilenameInResources + "": "" + installResult);             }             try {                 uninstallPackage();             } catch (Exception e) {                 throw new RuntimeException(                         ""Failed to uninstall after installing "" + apkFilenameInResources, e);             }         }     }      private void assertInstallV4Succeeds(String apkFilenameInResources) throws Exception {         String installResult = installV4PackageFromResource(apkFilenameInResources);         if (!installResult.equals(""Success\n"")) {             fail(""Failed to install "" + apkFilenameInResources + "": "" + installResult);         }     }      private void assertInstallV4SucceedsAndUninstall(String apkFilenameInResources)             throws Exception {         assertInstallV4Succeeds(apkFilenameInResources);         try {             uninstallPackage();         } catch (Exception e) {             throw new RuntimeException(                     ""Failed to uninstall after installing "" + apkFilenameInResources, e);         }     }      private void assertInstallV4FailsWithError(String apkFilenameInResources, String errorSubstring)             throws Exception {         String installResult = installV4PackageFromResource(apkFilenameInResources);         if (installResult.equals(""Success\n"")) {             fail(""Install of "" + apkFilenameInResources + "" succeeded but was expected to fail""                     + "" with \"""" + errorSubstring + ""\"""");         }         assertContains(                 ""Install failure message of "" + apkFilenameInResources,                 errorSubstring,                 installResult);     }      private void assertInstallFailsWithError(             String apkFilenameInResources, String errorSubstring) throws Exception {         String installResult = installPackageFromResource(apkFilenameInResources);         if (installResult == null) {             fail(""Install of "" + apkFilenameInResources + "" succeeded but was expected to fail""                     + "" with \"""" + errorSubstring + ""\"""");         }         assertContains(                 ""Install failure message of "" + apkFilenameInResources,                 errorSubstring,                 installResult);     }      private void assertInstallEphemeralFailsWithError(             String apkFilenameInResources, String errorSubstring) throws Exception {         String installResult = installEphemeralPackageFromResource(apkFilenameInResources);         if (installResult == null) {             fail(""Install of "" + apkFilenameInResources + "" succeeded but was expected to fail""                     + "" with \"""" + errorSubstring + ""\"""");         }         assertContains(                 ""Install failure message of "" + apkFilenameInResources,                 errorSubstring,                 installResult);     }      private void assertInstallFails(String apkFilenameInResources) throws Exception {         String installResult = installPackageFromResource(apkFilenameInResources);         if (installResult == null) {             fail(""Install of "" + apkFilenameInResources + "" succeeded but was expected to fail"");         }     }      private static void assertContains(String message, String expectedSubstring, String actual) {         String errorPrefix = ((message != null) && (message.length() > 0)) ? (message + "": "") : """";         if (actual == null) {             fail(errorPrefix + ""Expected to contain \"""" + expectedSubstring + ""\"", but was null"");         }         if (!actual.contains(expectedSubstring)) {             fail(errorPrefix + ""Expected to contain \"""" + expectedSubstring + ""\"", but was \""""                     + actual + ""\"""");         }     }      private void installDeviceTestPkg() throws Exception {         assertInstallFromBuildSucceeds(DEVICE_TESTS_APK);     }      private void assertInstallFromBuildSucceeds(String apkName) throws Exception {         String result = installApkFromBuild(apkName);         assertNull(""failed to install "" + apkName + "", Reason: "" + result, result);     }      private void assertInstallFromBuildFails(String apkName) throws Exception {         String result = installApkFromBuild(apkName);         assertNotNull(""Successfully installed "" + apkName + "" when failure was expected"", result);     }      private String installApkFromBuild(String apkName) throws Exception {         CompatibilityBuildHelper buildHelper = new CompatibilityBuildHelper(mCtsBuild);         File apk = buildHelper.getTestFile(apkName);         return getDevice().installPackage(apk, true, INSTALL_ARG_FORCE_QUERYABLE);     }      private String installPackageFromResource(String apkFilenameInResources, boolean ephemeral)             throws IOException, DeviceNotAvailableException {         // ITestDevice.installPackage API requires the APK to be install to be a File. We thus         // copy the requested resource into a temporary file, attempt to install it, and delete the         // file during cleanup.         File apkFile = null;         try {             apkFile = getFileFromResource(apkFilenameInResources);             if (ephemeral) {                 return getDevice().installPackage(apkFile, true, ""--ephemeral"",                         INSTALL_ARG_FORCE_QUERYABLE);             } else {                 return getDevice().installPackage(apkFile, true, INSTALL_ARG_FORCE_QUERYABLE);             }         } finally {             cleanUpFile(apkFile);         }     }      private String installV4PackageFromResource(String apkFilenameInResources)             throws IOException, DeviceNotAvailableException {         File apkFile = null;         File v4SignatureFile = null;         try {             apkFile = getFileFromResource(apkFilenameInResources);             v4SignatureFile = getFileFromResource(apkFilenameInResources + "".idsig"");             String remoteApkFilePath = pushFileToRemote(apkFile);             pushFileToRemote(v4SignatureFile);             return installV4Package(remoteApkFilePath);         } finally {             cleanUpFile(apkFile);             cleanUpFile(v4SignatureFile);         }     }      private String pushFileToRemote(File localFile) throws DeviceNotAvailableException {         String remotePath = ""/data/local/tmp/pkginstalltest-"" + localFile.getName();         getDevice().pushFile(localFile, remotePath);         return remotePath;     }      private String installV4Package(String remoteApkPath)             throws DeviceNotAvailableException {         String command = ""pm install-incremental -t -g "" + remoteApkPath;         return getDevice().executeShellCommand(command);     }      private File getFileFromResource(String filenameInResources)             throws IOException, IllegalArgumentException {         String fullResourceName = TEST_APK_RESOURCE_PREFIX + filenameInResources;         File tempDir = FileUtil.createTempDir(""pkginstalltest"");         File file = new File(tempDir, filenameInResources);         InputStream in = getClass().getResourceAsStream(fullResourceName);         if (in == null) {             throw new IllegalArgumentException(""Resource not found: "" + fullResourceName);         }         OutputStream out = new BufferedOutputStream(new FileOutputStream(file));         byte[] buf = new byte[65536];         int chunkSize;         while ((chunkSize = in.read(buf)) != -1) {             out.write(buf, 0, chunkSize);         }         out.close();         return file;     }      private void cleanUpFile(File file) {         if (file != null && file.exists()) {             file.delete();         }     }      private String installPackageFromResource(String apkFilenameInResources)             throws IOException, DeviceNotAvailableException {         return installPackageFromResource(apkFilenameInResources, false);     }      private String installEphemeralPackageFromResource(String apkFilenameInResources)             throws IOException, DeviceNotAvailableException {         return installPackageFromResource(apkFilenameInResources, true);     }      private String uninstallPackage() throws DeviceNotAvailableException {         return getDevice().uninstallPackage(TEST_PKG);     }      private String uninstallCompanionPackages() throws DeviceNotAvailableException {         String result1 = getDevice().uninstallPackage(COMPANION_TEST_PKG);         String result2 = getDevice().uninstallPackage(COMPANION2_TEST_PKG);         return result1 != null ? result1 : result2;     }      private String uninstallDeviceTestPackage() throws DeviceNotAvailableException {         return getDevice().uninstallPackage(DEVICE_TESTS_PKG);     }      private void uninstallServicePackages() throws DeviceNotAvailableException {         getDevice().uninstallPackage(SERVICE_PKG);         getDevice().uninstallPackage(SERVICE_TEST_PKG);     }      private void uninstallPackages() throws DeviceNotAvailableException {         uninstallPackage();         uninstallCompanionPackages();         uninstallDeviceTestPackage();         uninstallServicePackages();     } }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"com.android.cts.devicepolicy.DeviceOwnerTest"	"removeTestUsers"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceOwnerTest.java"	""	"/*  *.  */  package com.android.cts.devicepolicy;  import static com.android.cts.devicepolicy.metrics.DevicePolicyEventLogVerifier.assertMetricsLogged; import static com.android.cts.devicepolicy.metrics.DevicePolicyEventLogVerifier.isStatsdEnabled;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertTrue; import static org.junit.Assume.assumeFalse; import static org.junit.Assert.fail;  import android.platform.test.annotations.FlakyTest; import android.platform.test.annotations.LargeTest; import android.stats.devicepolicy.EventId;  import com.android.compatibility.common.tradefed.build.CompatibilityBuildHelper; import com.android.compatibility.common.util.LocationModeSetter; import com.android.cts.devicepolicy.metrics.DevicePolicyEventWrapper; import com.android.tradefed.device.DeviceNotAvailableException;  import org.junit.Ignore; import org.junit.Test;  import java.io.File; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.util.Collections; import java.util.List; import java.util.Map;  /**  * Set of tests for Device Owner use cases.  */ public class DeviceOwnerTest extends BaseDevicePolicyTest {      private static final String DEVICE_OWNER_PKG = ""com.android.cts.deviceowner"";     private static final String DEVICE_OWNER_APK = ""CtsDeviceOwnerApp.apk"";      private static final String MANAGED_PROFILE_PKG = ""com.android.cts.managedprofile"";     private static final String MANAGED_PROFILE_APK = ""CtsManagedProfileApp.apk"";     private static final String MANAGED_PROFILE_ADMIN =             MANAGED_PROFILE_PKG + "".BaseManagedProfileTest$BasicAdminReceiver"";      private static final String FEATURE_BACKUP = ""android.software.backup"";      private static final String INTENT_RECEIVER_PKG = ""com.android.cts.intent.receiver"";     private static final String INTENT_RECEIVER_APK = ""CtsIntentReceiverApp.apk"";      private static final String SIMPLE_APP_APK =""CtsSimpleApp.apk"";     private static final String SIMPLE_APP_PKG = ""com.android.cts.launcherapps.simpleapp"";     private static final String SIMPLE_APP_ACTIVITY = SIMPLE_APP_PKG + "".SimpleActivity"";      private static final String SIMPLE_SMS_APP_PKG = ""android.telephony.cts.sms.simplesmsapp"";     private static final String SIMPLE_SMS_APP_APK = ""SimpleSmsApp.apk"";      private static final String WIFI_CONFIG_CREATOR_PKG =             ""com.android.cts.deviceowner.wificonfigcreator"";     private static final String WIFI_CONFIG_CREATOR_APK = ""CtsWifiConfigCreator.apk"";      private static final String ADMIN_RECEIVER_TEST_CLASS =             DEVICE_OWNER_PKG + "".BasicAdminReceiver"";     private static final String DEVICE_OWNER_COMPONENT = DEVICE_OWNER_PKG + ""/""             + ADMIN_RECEIVER_TEST_CLASS;      private static final String TEST_APP_APK = ""CtsEmptyTestApp.apk"";     private static final String TEST_APP_PKG = ""android.packageinstaller.emptytestapp.cts"";     private static final String TEST_APP_LOCATION = ""/data/local/tmp/cts/packageinstaller/"";      private static final String ARG_NETWORK_LOGGING_BATCH_COUNT = ""batchCount"";      private static final String LAUNCHER_TESTS_HAS_LAUNCHER_ACTIVITY_APK =             ""CtsHasLauncherActivityApp.apk"";      private static final int TYPE_NONE = 0;      /**      * Copied from {@link android.app.admin.SystemUpdatePolicy}      */     private static final int TYPE_INSTALL_AUTOMATIC = 1;     private static final int TYPE_INSTALL_WINDOWED = 2;     private static final int TYPE_POSTPONE = 3;      /** CreateAndManageUser is available and an additional user can be created. */     private boolean mHasCreateAndManageUserFeature;      /**      * Copied from {@link android.app.admin.DevicePolicyManager}      */     private static final String GLOBAL_SETTING_AUTO_TIME = ""auto_time"";     private static final String GLOBAL_SETTING_AUTO_TIME_ZONE = ""auto_time_zone"";     private static final String GLOBAL_SETTING_DATA_ROAMING = ""data_roaming"";     private static final String GLOBAL_SETTING_USB_MASS_STORAGE_ENABLED =             ""usb_mass_storage_enabled"";      @Override     public void setUp() throws Exception {         super.setUp();         if (mHasFeature) {             installAppAsUser(DEVICE_OWNER_APK, mPrimaryUserId);             if (!setDeviceOwner(DEVICE_OWNER_COMPONENT, mPrimaryUserId,                     /*expectFailure*/ false)) {                 removeAdmin(DEVICE_OWNER_COMPONENT, mPrimaryUserId);                 getDevice().uninstallPackage(DEVICE_OWNER_PKG);                 fail(""Failed to set device owner"");             }              // Enable the notification listener             getDevice().executeShellCommand(""cmd notification allow_listener com.android.cts.deviceowner/com.android.cts.deviceowner.NotificationListener"");         }         mHasCreateAndManageUserFeature = mHasFeature && canCreateAdditionalUsers(1)                 && hasDeviceFeature(""android.software.managed_users"");     }      @Override     public void tearDown() throws Exception {         if (mHasFeature) {             assertTrue(""Failed to remove device owner."",                     removeAdmin(DEVICE_OWNER_COMPONENT, mPrimaryUserId));             getDevice().uninstallPackage(DEVICE_OWNER_PKG);             switchUser(USER_SYSTEM);             removeTestUsers();         }          super.tearDown();     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.dynamicmime.testapp.preferred.PreferredActivitiesTest"	"PreferredActivitiesTest"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/packagemanager/dynamicmime/test/src/android/dynamicmime/testapp/preferred/PreferredActivitiesTest.java"	""	"/*  *.  */  package android.dynamicmime.testapp.preferred;  import static android.dynamicmime.common.Constants.ACTIVITY_BOTH; import static android.dynamicmime.common.Constants.ACTIVITY_FIRST; import static android.dynamicmime.common.Constants.APK_PREFERRED_APP; import static android.dynamicmime.common.Constants.GROUP_FIRST; import static android.dynamicmime.common.Constants.GROUP_SECOND; import static android.dynamicmime.common.Constants.GROUP_THIRD; import static android.dynamicmime.common.Constants.MIME_IMAGE_PNG; import static android.dynamicmime.common.Constants.MIME_TEXT_PLAIN; import static android.dynamicmime.common.Constants.PACKAGE_PREFERRED_APP;  import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertNull; import static org.junit.Assume.assumeTrue;  import android.content.Intent; import android.content.res.Resources; import android.dynamicmime.testapp.BaseDynamicMimeTest; import android.dynamicmime.testapp.assertions.MimeGroupAssertions; import android.dynamicmime.testapp.commands.MimeGroupCommands; import android.dynamicmime.testapp.util.Utils;  import androidx.test.ext.junit.runners.AndroidJUnit4; import androidx.test.uiautomator.By; import androidx.test.uiautomator.BySelector; import androidx.test.uiautomator.Direction; import androidx.test.uiautomator.UiDevice; import androidx.test.uiautomator.UiObject2; import androidx.test.uiautomator.Until;  import org.junit.After; import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith;  import java.util.concurrent.TimeUnit; import java.util.regex.Pattern;  @RunWith(AndroidJUnit4.class) public class PreferredActivitiesTest extends BaseDynamicMimeTest {     private static final String ACTION = ""android.dynamicmime.preferred.TEST_ACTION"";      private static final String NAV_BAR_INTERACTION_MODE_RES_NAME = ""config_navBarInteractionMode"";     private static final int NAV_BAR_INTERACTION_MODE_GESTURAL = 2;      private static final BySelector BUTTON_ALWAYS = By.res(""android:id/button_always"");     private static final BySelector RESOLVER_DIALOG = By.res(Pattern.compile("".*:id/contentPanel.*""));      private static final long TIMEOUT = TimeUnit.SECONDS.toMillis(60L);      private static final String FEATURE_WEARABLE = ""android.hardware.type.watch"";      private TestStrategy mTest;      public PreferredActivitiesTest() {         super(MimeGroupCommands.preferredApp(context()), MimeGroupAssertions.notUsed());         assumeNavigationMode();     }      private void assumeNavigationMode() {         Resources res = context().getResources();         int navModeResId = res.getIdentifier(NAV_BAR_INTERACTION_MODE_RES_NAME, ""integer"",             ""android"");         int navMode = res.getInteger(navModeResId);          assumeTrue(""Non-gesture navigation mode required"",             navMode != NAV_BAR_INTERACTION_MODE_GESTURAL);     }      @Before     public void setUp() {         Utils.installApk(APK_PREFERRED_APP);     }      @After     public void tearDown() {         super.tearDown();         Utils.uninstallApp(PACKAGE_PREFERRED_APP);     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"com.android.cts.devicepolicy.QuietModeHostsideTest"	"wakeupAndDismissKeyguard"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/QuietModeHostsideTest.java"	""	"package com.android.cts.devicepolicy;  import static com.google.common.truth.Truth.assertThat;  import android.platform.test.annotations.LargeTest;  import com.android.tradefed.device.DeviceNotAvailableException;  import org.junit.Test;  import java.io.FileNotFoundException; import java.util.HashMap; import java.util.Map;  /**  * CTS to verify toggling quiet mode in work profile by using  * {@link android.os.UserManager#requestQuietModeEnabled(boolean, android.os.UserHandle)}.  */ public class QuietModeHostsideTest extends BaseDevicePolicyTest {     private static final String TEST_PACKAGE = ""com.android.cts.launchertests"";     private static final String TEST_CLASS = "".QuietModeTest"";     private static final String PARAM_TARGET_USER = ""TARGET_USER"";     private static final String PARAM_ORIGINAL_DEFAULT_LAUNCHER = ""ORIGINAL_DEFAULT_LAUNCHER"";     private static final String TEST_APK = ""CtsLauncherAppsTests.apk"";      private static final String TEST_LAUNCHER_PACKAGE = ""com.android.cts.launchertests.support"";     private static final String TEST_LAUNCHER_APK = ""CtsLauncherAppsTestsSupport.apk"";     private static final String ENABLED_TEST_APK = ""CtsCrossProfileEnabledApp.apk"";     private static final String USER_ENABLED_TEST_APK = ""CtsCrossProfileUserEnabledApp.apk"";     private static final String ENABLED_NO_PERMS_TEST_APK = ""CtsCrossProfileEnabledNoPermsApp.apk"";     private static final String QUIET_MODE_ENABLED_TEST_APK = ""CtsModifyQuietModeEnabledApp.apk"";     private static final String NOT_ENABLED_TEST_APK = ""CtsCrossProfileNotEnabledApp.apk"";     private static final String ENABLED_TEST_PACKAGE = ""com.android.cts.crossprofileenabledapp"";     private static final String USER_ENABLED_TEST_PACKAGE =             ""com.android.cts.crossprofileuserenabledapp"";     private static final String ENABLED_NO_PERMS_TEST_PACKAGE =             ""com.android.cts.crossprofileenablednopermsapp"";     private static final String NOT_ENABLED_TEST_PACKAGE =             ""com.android.cts.crossprofilenotenabledapp"";     private static final String QUIET_MODE_ENABLED_TEST_PACKAGE =             ""com.android.cts.modifyquietmodeenabledapp"";      private int mProfileId;     private String mOriginalLauncher;      @Override     public void setUp() throws Exception {         super.setUp();          mHasFeature = mHasFeature & hasDeviceFeature(""android.software.managed_users"");          if (mHasFeature) {             mOriginalLauncher = getDefaultLauncher();              installAppAsUser(TEST_APK, mPrimaryUserId);             installAppAsUser(TEST_LAUNCHER_APK, mPrimaryUserId);              waitForBroadcastIdle();              createAndStartManagedProfile();             installAppAsUser(TEST_APK, mProfileId);              waitForBroadcastIdle();             wakeupAndDismissKeyguard();         }     }      @Override     public void tearDown() throws Exception {         if (mHasFeature) {             uninstallRequiredApps();             getDevice().uninstallPackage(TEST_LAUNCHER_PACKAGE);         }         super.tearDown();     }      @LargeTest"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.cts.backup.RestoreSessionHostSideTest"	"isPresent"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/backup/src/android/cts/backup/RestoreSessionHostSideTest.java"	""	"/*  *  */  package android.cts.backup;  import static org.junit.Assert.assertTrue;  import android.platform.test.annotations.AppModeFull;  import com.android.compatibility.common.util.BackupUtils; import com.android.tradefed.device.DeviceNotAvailableException; import com.android.tradefed.testtype.DeviceJUnit4ClassRunner;  import java.io.IOException; import org.junit.After; import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith;  import java.util.Optional;  /**  * Tests for system APIs in {@link RestoreSession}  *  * <p>These tests use the local transport.  */ @RunWith(DeviceJUnit4ClassRunner.class) @AppModeFull public class RestoreSessionHostSideTest extends BaseBackupHostSideTest {     private static final int USER_SYSTEM = 0;     private static final String MAIN_TEST_APP_PKG = ""android.cts.backup.restoresessionapp"";     private static final String DEVICE_MAIN_TEST_CLASS_NAME =             MAIN_TEST_APP_PKG + "".RestoreSessionTest"";     private static final String MAIN_TEST_APK = ""CtsRestoreSessionApp.apk"";      private static final String TEST_APP_PKG_PREFIX = ""android.cts.backup.restoresessionapp"";     private static final String TEST_APP_APK_PREFIX = ""CtsRestoreSessionApp"";     private static final int TEST_APPS_COUNT = 3;      private Optional<String> mOldTransport = Optional.empty();     private BackupUtils mBackupUtils;      /** Switch to local transport. */     @Before     public void setUp() throws Exception {         mBackupUtils = getBackupUtils();         mOldTransport = Optional.of(setBackupTransport(mBackupUtils.getLocalTransportName()));         installPackage(MAIN_TEST_APK);     }      /** Restore transport settings to original values. */     @After     public void tearDown() throws Exception {         if (mOldTransport.isPresent()) {             setBackupTransport(mOldTransport.get());             mOldTransport = Optional.empty();              uninstallPackage(MAIN_TEST_APK);         }     }      /** Test {@link RestoreSession#restorePackage(RestoreObserver, String)} */"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.cts.backup.RestoreSessionHostSideTest"	"testRestorePackagesWithMonitorParam"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/backup/src/android/cts/backup/RestoreSessionHostSideTest.java"	""	"public void testRestorePackagesWithMonitorParam() throws Exception {         testRestorePackagesInternal(""testRestorePackagesWithMonitorParam"",                 /* packagesToRestore */ 2);     }      /**      *      *      * <ol>      *   <li>Install 3 test packages on the device      *   <li>Write dummy values to shared preferences for each package      *   <li>Backup each package (adb shell bmgr backupnow)      *   <li>Clear shared preferences for each package      *   <li>Run restore for the first {@code numPackagesToRestore}, verify only those are restored      *   <li>Verify that shared preferences for the restored packages are restored correctly      * </ol>      */     private void testRestorePackagesInternal(String deviceTestName, int numPackagesToRestore)             throws Exception {         installPackage(getApkNameForTestApp(1));         installPackage(getApkNameForTestApp(2));         installPackage(getApkNameForTestApp(3));          // Write dummy value to shared preferences for all test packages.         checkRestoreSessionDeviceTestForAllApps(""testSaveValuesToSharedPrefs"");         checkRestoreSessionDeviceTestForAllApps(""testCheckSharedPrefsExist"");          // Backup all test packages.         mBackupUtils.backupNowAndAssertSuccess(getPackageNameForTestApp(1));         mBackupUtils.backupNowAndAssertSuccess(getPackageNameForTestApp(2));         mBackupUtils.backupNowAndAssertSuccess(getPackageNameForTestApp(3));          // Clear shared preferences for all test packages.         checkRestoreSessionDeviceTestForAllApps(""testClearSharedPrefs"");         checkRestoreSessionDeviceTestForAllApps(""testCheckSharedPrefsDontExist"");          runRestoreSessionDeviceTestAndAssertSuccess(                 MAIN_TEST_APP_PKG, DEVICE_MAIN_TEST_CLASS_NAME, deviceTestName);          // Check that shared prefs are only restored (and restored correctly) for the packages         // that need to be restored.         for (int i = 1; i <= TEST_APPS_COUNT; i++) {             if (i <= numPackagesToRestore) {                 checkRestoreSessionDeviceTest(i, ""testCheckSharedPrefsExist"");             } else {                 checkRestoreSessionDeviceTest(i, ""testCheckSharedPrefsDontExist"");             }         }          uninstallPackage(getPackageNameForTestApp(1));         uninstallPackage(getPackageNameForTestApp(2));         uninstallPackage(getPackageNameForTestApp(3));     }      /** Run the given device test for all test apps. */     private void checkRestoreSessionDeviceTestForAllApps(String testName)             throws DeviceNotAvailableException {         for (int appNumber = 1; appNumber <= TEST_APPS_COUNT; appNumber++) {             checkRestoreSessionDeviceTest(appNumber, testName);         }     }      /** Run device test with the given test name and test app number. */     private void checkRestoreSessionDeviceTest(int testAppNumber, String testName)             throws DeviceNotAvailableException {         String packageName = getPackageNameForTestApp(testAppNumber);         runRestoreSessionDeviceTestAndAssertSuccess(                 packageName, packageName + "".RestoreSessionAppTest"", testName);     }      private void runRestoreSessionDeviceTestAndAssertSuccess(             String packageName, String fullClassName, String testName)             throws DeviceNotAvailableException {         boolean result = runDeviceTests(packageName, fullClassName, testName);         assertTrue(""Device test failed: "" + testName, result);     }      private String getPackageNameForTestApp(int appNumber) {         return TEST_APP_PKG_PREFIX + appNumber;     }      private String getApkNameForTestApp(int appNumber) {         return TEST_APP_APK_PREFIX + appNumber + "".apk"";     }      private String setBackupTransport(String transport) throws IOException {         return mBackupUtils.setBackupTransportForUser(transport, USER_SYSTEM);     } }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.telephony.cts.DataProfileTest"	"testConstructorAndGetters"	"CtsTelephonyTestCases"	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	"v4"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/telephony/current/src/android/telephony/cts/DataProfileTest.java"	""	"public void testConstructorAndGetters() {         DataProfile profile = new DataProfile.Builder()                 .setProfileId(PROFILE_ID)                 .setApn(APN)                 .setProtocolType(PROTOCOL_TYPE)                 .setAuthType(AUTH_TYPE)                 .setUserName(USER_NAME)                 .setPassword(PASSWORD)                 .setType(TYPE)                 .enable(IS_ENABLED)                 .setSupportedApnTypesBitmask(APN_BITMASK)                 .setRoamingProtocolType(ROAMING_PROTOCOL_TYPE)                 .setBearerBitmask(BEARER_BITMASK)                 .setMtuV4(MTU_V4)                 .setMtuV6(MTU_V6)                 .setPreferred(IS_PREFERRED)                 .setPersistent(IS_PERSISTENT)                 .build();          assertThat(profile.getProfileId()).isEqualTo(PROFILE_ID);         assertThat(profile.getApn()).isEqualTo(APN);         assertThat(profile.getProtocolType()).isEqualTo(PROTOCOL_TYPE);         assertThat(profile.getAuthType()).isEqualTo(AUTH_TYPE);         assertThat(profile.getUserName()).isEqualTo(USER_NAME);         assertThat(profile.getPassword()).isEqualTo(PASSWORD);         assertThat(profile.getType()).isEqualTo(TYPE);         assertThat(profile.isEnabled()).isEqualTo(IS_ENABLED);         assertThat(profile.getSupportedApnTypesBitmask()).isEqualTo(APN_BITMASK);         assertThat(profile.getRoamingProtocolType()).isEqualTo(ROAMING_PROTOCOL_TYPE);         assertThat(profile.getBearerBitmask()).isEqualTo(BEARER_BITMASK);         assertThat(profile.getMtuV4()).isEqualTo(MTU_V4);         assertThat(profile.getMtuV6()).isEqualTo(MTU_V6);         assertThat(profile.isPreferred()).isEqualTo(IS_PREFERRED);         assertThat(profile.isPersistent()).isEqualTo(IS_PERSISTENT);     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.telephony.cts.DataProfileTest"	"testEquals"	"CtsTelephonyTestCases"	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	"v4"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/telephony/current/src/android/telephony/cts/DataProfileTest.java"	""	"public void testEquals() {         DataProfile profile = new DataProfile.Builder()                 .setProfileId(PROFILE_ID)                 .setApn(APN)                 .setProtocolType(PROTOCOL_TYPE)                 .setAuthType(AUTH_TYPE)                 .setUserName(USER_NAME)                 .setPassword(PASSWORD)                 .setType(TYPE)                 .enable(IS_ENABLED)                 .setSupportedApnTypesBitmask(APN_BITMASK)                 .setRoamingProtocolType(ROAMING_PROTOCOL_TYPE)                 .setBearerBitmask(BEARER_BITMASK)                 .setMtuV4(MTU_V4)                 .setMtuV6(MTU_V6)                 .setPreferred(IS_PREFERRED)                 .setPersistent(IS_PERSISTENT)                 .build();          DataProfile equalsProfile = new DataProfile.Builder()                 .setProfileId(PROFILE_ID)                 .setApn(APN)                 .setProtocolType(PROTOCOL_TYPE)                 .setAuthType(AUTH_TYPE)                 .setUserName(USER_NAME)                 .setPassword(PASSWORD)                 .setType(TYPE)                 .enable(IS_ENABLED)                 .setSupportedApnTypesBitmask(APN_BITMASK)                 .setRoamingProtocolType(ROAMING_PROTOCOL_TYPE)                 .setBearerBitmask(BEARER_BITMASK)                 .setMtuV4(MTU_V4)                 .setMtuV6(MTU_V6)                 .setPreferred(IS_PREFERRED)                 .setPersistent(IS_PERSISTENT)                 .build();          assertThat(profile).isEqualTo(equalsProfile);     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.telephony.cts.DataProfileTest"	"testNotEquals"	"CtsTelephonyTestCases"	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	"v4"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/telephony/current/src/android/telephony/cts/DataProfileTest.java"	""	"public void testNotEquals() {         DataProfile profile = new DataProfile.Builder()                 .setProfileId(PROFILE_ID)                 .setApn(APN)                 .setProtocolType(PROTOCOL_TYPE)                 .setAuthType(AUTH_TYPE)                 .setUserName(USER_NAME)                 .setPassword(PASSWORD)                 .setType(TYPE)                 .enable(IS_ENABLED)                 .setSupportedApnTypesBitmask(APN_BITMASK)                 .setRoamingProtocolType(ROAMING_PROTOCOL_TYPE)                 .setBearerBitmask(BEARER_BITMASK)                 .setMtuV4(MTU_V4)                 .setMtuV6(MTU_V6)                 .setPreferred(IS_PREFERRED)                 .setPersistent(IS_PERSISTENT)                 .build();          DataProfile notEqualsProfile = new DataProfile.Builder()                 .setProfileId(0)                 .setApn(APN)                 .setProtocolType(PROTOCOL_TYPE)                 .setAuthType(AUTH_TYPE)                 .setUserName(USER_NAME)                 .setPassword(PASSWORD)                 .setType(TYPE)                 .enable(false)                 .setSupportedApnTypesBitmask(2)                 .setRoamingProtocolType(ROAMING_PROTOCOL_TYPE)                 .setBearerBitmask(3)                 .setMtuV4(1441)                 .setMtuV6(1401)                 .setPreferred(false)                 .setPersistent(false)                 .build();          assertThat(profile).isNotEqualTo(notEqualsProfile);         assertThat(profile).isNotEqualTo(null);         assertThat(profile).isNotEqualTo(new String[1]);     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.telephony.cts.DataProfileTest"	"testParcel"	"CtsTelephonyTestCases"	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	"v4"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/telephony/current/src/android/telephony/cts/DataProfileTest.java"	""	"public void testParcel() {         DataProfile profile = new DataProfile.Builder()                 .setProfileId(PROFILE_ID)                 .setApn(APN)                 .setProtocolType(PROTOCOL_TYPE)                 .setAuthType(AUTH_TYPE)                 .setUserName(USER_NAME)                 .setPassword(PASSWORD)                 .setType(TYPE)                 .enable(IS_ENABLED)                 .setSupportedApnTypesBitmask(APN_BITMASK)                 .setRoamingProtocolType(ROAMING_PROTOCOL_TYPE)                 .setBearerBitmask(BEARER_BITMASK)                 .setMtuV4(MTU_V4)                 .setMtuV6(MTU_V6)                 .setPreferred(IS_PREFERRED)                 .setPersistent(IS_PERSISTENT)                 .build();          Parcel stateParcel = Parcel.obtain();         profile.writeToParcel(stateParcel, 0);         stateParcel.setDataPosition(0);          DataProfile parcelProfile = DataProfile.CREATOR.createFromParcel(stateParcel);         assertThat(profile).isEqualTo(parcelProfile);     } }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.security.cts.KernelSettingsTest"	"testNoIcmpRedirects"	"CtsSecurityTestCases"	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	"v4"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/security/src/android/security/cts/KernelSettingsTest.java"	""	"public void testNoIcmpRedirects() throws IOException {         try {             assertEquals(""ICMP redirects are enabled for IPv4."",                     ""0"", getFile(""/proc/sys/net/ipv4/conf/all/accept_redirects""));         } catch (FileNotFoundException e) {             // Odd. The file doesn't exist... Assume we're ok.         }          try {             assertEquals(""ICMP redirects are enabled for IPv6."",                     ""0"", getFile(""/proc/sys/net/ipv6/conf/all/accept_redirects""));         } catch (FileNotFoundException e) {             // Odd. The file doesn't exist... Assume we're ok.         }     }      static String getFile(String filename) throws IOException {         BufferedReader in = null;         try {             in = new BufferedReader(new FileReader(filename));             return in.readLine().trim();         } finally {             if (in != null) {                 in.close();             }         }     } }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.permission.cts.SplitPermissionTest"	"isTrue"	"CtsPermissionTestCases"	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/permission/src/android/permission/cts/SplitPermissionTest.java"	""	"/*  *.  */  package android.permission.cts;  import static android.Manifest.permission.ACCESS_BACKGROUND_LOCATION; import static android.Manifest.permission.ACCESS_COARSE_LOCATION; import static android.Manifest.permission.ACCESS_MEDIA_LOCATION; import static android.Manifest.permission.READ_CALL_LOG; import static android.Manifest.permission.READ_CONTACTS; import static android.Manifest.permission.READ_EXTERNAL_STORAGE; import static android.app.AppOpsManager.MODE_FOREGROUND; import static android.content.pm.PackageManager.FLAG_PERMISSION_REVIEW_REQUIRED; import static android.content.pm.PackageManager.FLAG_PERMISSION_USER_SET; import static android.permission.cts.PermissionUtils.getAppOp; import static android.permission.cts.PermissionUtils.getPermissionFlags; import static android.permission.cts.PermissionUtils.getPermissions; import static android.permission.cts.PermissionUtils.grantPermission; import static android.permission.cts.PermissionUtils.isGranted; import static android.permission.cts.PermissionUtils.revokePermission; import static android.permission.cts.PermissionUtils.setPermissionFlags; import static android.permission.cts.PermissionUtils.uninstallApp;  import static com.android.compatibility.common.util.SystemUtil.eventually;  import static com.google.common.truth.Truth.assertThat;  import static org.junit.Assert.assertEquals;  import android.app.UiAutomation; import android.platform.test.annotations.AppModeFull; import android.platform.test.annotations.FlakyTest;  import androidx.annotation.NonNull; import androidx.test.InstrumentationRegistry; import androidx.test.runner.AndroidJUnit4;  import org.junit.After; import org.junit.Test; import org.junit.runner.RunWith;  /**  * Tests how split permissions behave.  *  * <ul>  *     <li>Default permission grant behavior</li>  *     <li>Changes to the grant state during upgrade of apps with split permissions</li>  *     <li>Special behavior of background location</li>  * </ul>  */ @RunWith(AndroidJUnit4.class) @AppModeFull(reason = ""Instant apps cannot read state of other packages."") public class SplitPermissionTest {     /** The package name of all apps used in the test */     private static final String APP_PKG = ""android.permission.cts.appthatrequestpermission"";      private static final String TMP_DIR = ""/data/local/tmp/cts/permissions/"";     private static final String APK_CONTACTS_16 =             TMP_DIR + ""CtsAppThatRequestsContactsPermission16.apk"";     private static final String APK_CONTACTS_15 =             TMP_DIR + ""CtsAppThatRequestsContactsPermission15.apk"";     private static final String APK_CONTACTS_CALLLOG_16 =             TMP_DIR + ""CtsAppThatRequestsContactsAndCallLogPermission16.apk"";     private static final String APK_STORAGE_29 =             TMP_DIR + ""CtsAppThatRequestsStoragePermission29.apk"";     private static final String APK_STORAGE_28 =             TMP_DIR + ""CtsAppThatRequestsStoragePermission28.apk"";     private static final String APK_LOCATION_29 =             TMP_DIR + ""CtsAppThatRequestsLocationPermission29.apk"";     private static final String APK_LOCATION_28 =             TMP_DIR + ""CtsAppThatRequestsLocationPermission28.apk"";     private static final String APK_LOCATION_22 =             TMP_DIR + ""CtsAppThatRequestsLocationPermission22.apk"";     private static final String APK_LOCATION_BACKGROUND_29 =             TMP_DIR + ""CtsAppThatRequestsLocationAndBackgroundPermission29.apk"";     private static final String APK_SHARED_UID_LOCATION_29 =             TMP_DIR + ""CtsAppWithSharedUidThatRequestsLocationPermission29.apk"";     private static final String APK_SHARED_UID_LOCATION_28 =             TMP_DIR + ""CtsAppWithSharedUidThatRequestsLocationPermission28.apk"";      private static final UiAutomation sUiAutomation =             InstrumentationRegistry.getInstrumentation().getUiAutomation();      /**      * Assert that {@link #APP_PKG} requests a certain permission.      *      * @param permName The permission that needs to be requested      */     private void assertRequestsPermission(@NonNull String permName) throws Exception {         assertThat(getPermissions(APP_PKG)).contains(permName);     }      /**      * Assert that {@link #APP_PKG} <u>does not</u> request a certain permission.      *      * @param permName The permission that needs to be not requested      */     private void assertNotRequestsPermission(@NonNull String permName) throws Exception {         assertThat(getPermissions(APP_PKG)).doesNotContain(permName);     }      /**      * Assert that a permission is granted to {@link #APP_PKG}.      *      * @param permName The permission that needs to be granted      */     private void assertPermissionGranted(@NonNull String permName) throws Exception {         eventually(() -> assertThat(isGranted(APP_PKG, permName)).named(permName + "" is granted"").isTrue());     }      /**      * Assert that a permission is <u>not </u> granted to {@link #APP_PKG}.      *      * @param permName The permission that should not be granted      */     private void assertPermissionRevoked(@NonNull String permName) throws Exception {         assertThat(isGranted(APP_PKG, permName)).named(permName + "" is granted"").isFalse();     }      /**      * Install an APK.      *      * @param apkFile The apk to install      */     public void install(@NonNull String apkFile) {         PermissionUtils.install(apkFile);     }      @After     public void uninstallTestApp() {         uninstallApp(APP_PKG);     }      /**      * Apps with a targetSDK after the split should <u>not</u> have been added implicitly the new      * permission.      */"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.inputmethodservice.cts.hostside.MultiUserTest"	"testSecondaryUserInstant"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/inputmethodservice/hostside/src/android/inputmethodservice/cts/hostside/MultiUserTest.java"	""	"public void testSecondaryUserInstant() throws Exception {         testSecondaryUser(true);     }      private void testSecondaryUser(boolean instant) throws Exception {         final int primaryUserId = getDevice().getPrimaryUserId();         final int secondaryUserId = getDevice().createUser(                 ""InputMethodMultiUserTest_secondaryUser"" + System.currentTimeMillis());          getDevice().startUser(secondaryUserId, true /* waitFlag */);          installPossibleInstantPackage(DeviceTestConstants.APK, primaryUserId, instant);         installPossibleInstantPackage(DeviceTestConstants.APK, secondaryUserId, instant);          // Work around b/31009094.         assertTestApkIsReadyAfterInstallation(primaryUserId);          assertIme1NotExistInApiResult(secondaryUserId);         assertIme1ImplicitlyEnabledSubtypeNotExist(primaryUserId);         assertIme1ImplicitlyEnabledSubtypeNotExist(secondaryUserId);          installPackageAsUser(Ime1Constants.APK, true, secondaryUserId, ""-r"");          assertIme1NotExistInApiResult(primaryUserId);         assertIme1ExistsInApiResult(secondaryUserId);         assertIme1ImplicitlyEnabledSubtypeNotExist(primaryUserId);         assertIme1ImplicitlyEnabledSubtypeExists(secondaryUserId);          switchUser(secondaryUserId);          assertIme1NotExistInApiResult(primaryUserId);         assertIme1ExistsInApiResult(secondaryUserId);         assertIme1ImplicitlyEnabledSubtypeNotExist(primaryUserId);         assertIme1ImplicitlyEnabledSubtypeExists(secondaryUserId);          switchUser(primaryUserId);          // For devices that have config_multiuserDelayUserDataLocking set to true, the         // secondaryUserId will be stopped after switching to the primaryUserId. This means that         // the InputMethodManager can no longer query for the Input Method Services since they have         // all been stopped.         getDevice().startUser(secondaryUserId, true /* waitFlag */);          assertIme1NotExistInApiResult(primaryUserId);         assertIme1ExistsInApiResult(secondaryUserId);         assertIme1ImplicitlyEnabledSubtypeNotExist(primaryUserId);         assertIme1ImplicitlyEnabledSubtypeExists(secondaryUserId);     }      /**      * Make sure that InputMethodManagerService automatically updates its internal IME list upon      * IME APK installation for full (non-instant) apps.      */     @AppModeFull"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.inputmethodservice.cts.hostside.MultiUserTest"	"testProfileUserInstant"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/inputmethodservice/hostside/src/android/inputmethodservice/cts/hostside/MultiUserTest.java"	""	"public void testProfileUserInstant() throws Exception {         testProfileUser(true);     }      private void testProfileUser(boolean instant) throws Exception {         assumeTrue(getDevice().hasFeature(""android.software.managed_users""));          final int primaryUserId = getDevice().getPrimaryUserId();         final int profileUserId = createProfile(primaryUserId);          getDevice().startUser(profileUserId, true /* waitFlag */);          installPossibleInstantPackage(DeviceTestConstants.APK, primaryUserId, instant);         installPossibleInstantPackage(DeviceTestConstants.APK, profileUserId, instant);          // Work around b/31009094.         assertTestApkIsReadyAfterInstallation(profileUserId);          assertIme1NotExistInApiResult(primaryUserId);         assertIme1NotExistInApiResult(profileUserId);         assertIme1ImplicitlyEnabledSubtypeNotExist(primaryUserId);         assertIme1ImplicitlyEnabledSubtypeNotExist(profileUserId);          // Install IME1 then enable/set it as the current IME for the primary user.         installPackageAsUser(Ime1Constants.APK, true, primaryUserId, ""-r"");         waitUntilImeIsInShellCommandResult(Ime1Constants.IME_ID, primaryUserId);         shell(ShellCommandUtils.enableIme(Ime1Constants.IME_ID, primaryUserId));         shell(ShellCommandUtils.setCurrentImeSync(Ime1Constants.IME_ID, primaryUserId));          // Install IME2 then enable/set it as the current IME for the profile user.         installPackageAsUser(Ime2Constants.APK, true, profileUserId, ""-r"");         waitUntilImeIsInShellCommandResult(Ime2Constants.IME_ID, profileUserId);         shell(ShellCommandUtils.enableIme(Ime2Constants.IME_ID, profileUserId));         shell(ShellCommandUtils.setCurrentImeSync(Ime2Constants.IME_ID, profileUserId));          // Primary User: IME1:enabled, IME2:N/A         assertIme1ExistsInApiResult(primaryUserId);         assertIme1EnabledInApiResult(primaryUserId);         assertIme2NotExistInApiResult(primaryUserId);         assertIme2NotEnabledInApiResult(primaryUserId);         assertIme1Selected(primaryUserId);          // Profile User: IME1:N/A, IME2:enabled         assertIme1NotExistInApiResult(profileUserId);         assertIme1NotEnabledInApiResult(profileUserId);         assertIme2ExistsInApiResult(profileUserId);         assertIme2EnabledInApiResult(profileUserId);         assertIme2Selected(profileUserId);          // Make sure that IME switches depending on the target user.         runTestAsUser(DeviceTestConstants.TEST_CONNECTING_TO_THE_SAME_USER_IME, primaryUserId);         runTestAsUser(DeviceTestConstants.TEST_CONNECTING_TO_THE_SAME_USER_IME, profileUserId);         runTestAsUser(DeviceTestConstants.TEST_CONNECTING_TO_THE_SAME_USER_IME, primaryUserId);          assertIme1ImplicitlyEnabledSubtypeExists(primaryUserId);         assertIme1ImplicitlyEnabledSubtypeNotExist(profileUserId);          assertIme1ExistsInApiResult(primaryUserId);         assertIme1NotExistInApiResult(profileUserId);         assertIme1ImplicitlyEnabledSubtypeExists(primaryUserId);         assertIme1ImplicitlyEnabledSubtypeNotExist(profileUserId);     }      private String shell(String command) {         try {             return getDevice().executeShellCommand(command).trim();         } catch (Exception e) {             throw new RuntimeException(e);         }     }      /**      * A convenient wrapper for {@link com.android.tradefed.device.ITestDevice#switchUser(int)}      * that also makes sure that InputMethodManagerService actually receives the new user ID.      *      * @param userId user ID to switch to.      */     private void switchUser(int userId) throws Exception {         getDevice().switchUser(userId);         final long initialTime = System.currentTimeMillis();         while (true) {             final CommandResult result = getDevice().executeShellV2Command(                     ShellCommandUtils.getLastSwitchUserId(), USER_SWITCH_TIMEOUT,                     TimeUnit.MILLISECONDS);             if (result.getStatus() != CommandStatus.SUCCESS) {                 throw new IllegalStateException(                         ""Failed to get last SwitchUser ID from InputMethodManagerService.""                         + "" result.getStatus()="" + result.getStatus());             }             final String[] lines = result.getStdout().split(""\\r?\\n"");             if (lines.length < 1) {                 throw new IllegalStateException(                         ""Failed to get last SwitchUser ID from InputMethodManagerService.""                                 + "" result="" + result);             }             final int lastSwitchUserId = Integer.parseInt(lines[0], 10);             if (userId == lastSwitchUserId) {                 // InputMethodManagerService.Lifecycle#onSwitchUser() gets called.  Ready to go.                 return;             }             if (System.currentTimeMillis() > initialTime + USER_SWITCH_TIMEOUT) {                 throw new TimeoutException(                         ""Failed to get last SwitchUser ID from InputMethodManagerService."");             }             // InputMethodManagerService did not receive onSwitchUser() yet.             try {                 Thread.sleep(USER_SWITCH_POLLING_INTERVAL);             } catch (InterruptedException e) {                 throw new IllegalStateException(""Sleep interrupted while obtaining last SwitchUser""                         + "" ID from InputMethodManagerService."");             }         }     }      private void installPossibleInstantPackage(String apkFileName, int userId, boolean instant)             throws Exception {         if (instant) {             installPackageAsUser(apkFileName, true, userId, ""-r"", ""--instant"");         } else {             installPackageAsUser(apkFileName, true, userId, ""-r"");         }     }      private int createProfile(int parentUserId) throws Exception {         final String command = ShellCommandUtils.createManagedProfileUser(parentUserId,                 ""InputMethodMultiUserTest_testProfileUser"" + System.currentTimeMillis());         final String output = getDevice().executeShellCommand(command);          if (output.startsWith(""Success"")) {             try {                 return Integer.parseInt(output.substring(output.lastIndexOf("" "")).trim());             } catch (NumberFormatException e) {             }         }         throw new IllegalStateException();     }      private void waitUntilImeIsInShellCommandResult(String imeId, int userId) throws Exception {         final String command = ShellCommandUtils.getAvailableImes(userId);         pollingCheck(() -> Arrays.stream(shell(command).split(""\n"")).anyMatch(imeId::equals),                 IME_COMMAND_TIMEOUT, imeId + "" is not found for user #"" + userId                         + "" within timeout."");     }      private void assertTestApkIsReadyAfterInstallation(int userId) throws Exception {         for (int i = 0; i < NO_OP_TEST_RETRY_COUNT_AFTER_APK_INSTALL; ++i) {             try {                 // This test should never fail.  If this fails, it means that the system was not yet                 // ready to run tests in this APK.                 runTestAsUser(DeviceTestConstants.TEST_WAIT_15SEC, userId);                 return;             } catch (AssertionError e) {                 // Ignoring because it can be because of Bug 132082599.             }         }         runTestAsUser(DeviceTestConstants.TEST_WAIT_15SEC, userId);     }       private void assertIme1ExistsInApiResult(int userId) throws Exception  {         runTestAsUser(DeviceTestConstants.TEST_IME1_IN_INPUT_METHOD_LIST, userId);     }      private void assertIme1NotExistInApiResult(int userId) throws Exception  {         runTestAsUser(DeviceTestConstants.TEST_IME1_NOT_IN_INPUT_METHOD_LIST, userId);     }      private void assertIme1EnabledInApiResult(int userId) throws Exception  {         runTestAsUser(DeviceTestConstants.TEST_IME1_IN_ENABLED_INPUT_METHOD_LIST, userId);     }      private void assertIme1NotEnabledInApiResult(int userId) throws Exception  {         runTestAsUser(DeviceTestConstants.TEST_IME1_NOT_IN_ENABLED_INPUT_METHOD_LIST, userId);     }      private void assertIme1Selected(int userId)  {         assertEquals(Ime1Constants.IME_ID, shell(ShellCommandUtils.getCurrentIme(userId)));     }      private void assertIme2ExistsInApiResult(int userId) throws Exception  {         runTestAsUser(DeviceTestConstants.TEST_IME2_IN_INPUT_METHOD_LIST, userId);     }      private void assertIme2NotExistInApiResult(int userId) throws Exception  {         runTestAsUser(DeviceTestConstants.TEST_IME2_NOT_IN_INPUT_METHOD_LIST, userId);     }      private void assertIme2EnabledInApiResult(int userId) throws Exception  {         runTestAsUser(DeviceTestConstants.TEST_IME2_IN_ENABLED_INPUT_METHOD_LIST, userId);     }      private void assertIme2NotEnabledInApiResult(int userId) throws Exception  {         runTestAsUser(DeviceTestConstants.TEST_IME2_NOT_IN_ENABLED_INPUT_METHOD_LIST, userId);     }      private void assertIme2Selected(int userId)  {         assertEquals(Ime2Constants.IME_ID, shell(ShellCommandUtils.getCurrentIme(userId)));     }      private void assertIme1ImplicitlyEnabledSubtypeExists(int userId) throws Exception  {         runTestAsUser(DeviceTestConstants.TEST_IME1_IMPLICITLY_ENABLED_SUBTYPE_EXISTS, userId);     }      private void assertIme1ImplicitlyEnabledSubtypeNotExist(int userId) throws Exception  {         runTestAsUser(DeviceTestConstants.TEST_IME1_IMPLICITLY_ENABLED_SUBTYPE_NOT_EXIST, userId);     }      private void runTestAsUser(TestInfo testInfo, int userId) throws Exception {         runDeviceTests(new DeviceTestRunOptions(testInfo.testPackage)                 .setDevice(getDevice())                 .setTestClassName(testInfo.testClass)                 .setTestMethodName(testInfo.testMethod)                 .setUserId(userId));     } }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.compilation.cts.AdbRootDependentCompilationTest"	"isAdbRoot"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/compilation/src/android/compilation/cts/AdbRootDependentCompilationTest.java"	""	"public void test/*  *.  */  package android.compilation.cts;  import com.google.common.io.ByteStreams; import com.google.common.io.Files;  import com.android.tradefed.device.DeviceNotAvailableException; import com.android.tradefed.device.ITestDevice; import com.android.tradefed.testtype.DeviceTestCase; import com.android.tradefed.util.FileUtil;  import java.io.File; import java.io.FileOutputStream; import java.io.InputStream; import java.io.OutputStream; import java.util.ArrayList; import java.util.Arrays; import java.util.EnumSet; import java.util.Iterator; import java.util.List; import java.util.Locale; import java.util.Objects; import java.util.Set; import java.util.regex.Matcher; import java.util.regex.Pattern;  /**  * Various integration tests for dex to oat compilation, with or without profiles.  * When changing this test, make sure it still passes in each of the following  * configurations:  * <ul>  *     <li>On a 'user' build</li>  *     <li>On a 'userdebug' build with system property 'dalvik.vm.usejitprofiles' set to false</li>  *     <li>On a 'userdebug' build with system property 'dalvik.vm.usejitprofiles' set to true</li>  * </ul>  */ public class AdbRootDependentCompilationTest extends DeviceTestCase {     private static final String APPLICATION_PACKAGE = ""android.compilation.cts"";      enum ProfileLocation {         CUR(""/data/misc/profiles/cur/0/"" + APPLICATION_PACKAGE),         REF(""/data/misc/profiles/ref/"" + APPLICATION_PACKAGE);          private String directory;          ProfileLocation(String directory) {             this.directory = directory;         }          public String getDirectory() {             return directory;         }          public String getPath() {             return directory + ""/primary.prof"";         }     }      private ITestDevice mDevice;     private File textProfileFile;     private byte[] initialOdexFileContents;     private File apkFile;     private boolean mCanEnableDeviceRootAccess;      private Matcher mAdbLineFilter;      @Override     protected void setUp() throws Exception {         super.setUp();         mDevice = getDevice();          String buildType = mDevice.getProperty(""ro.build.type"");         assertTrue(""Unknown build type: "" + buildType,                 Arrays.asList(""user"", ""userdebug"", ""eng"").contains(buildType));         boolean wasRoot = mDevice.isAdbRoot();         // We can only enable root access on userdebug and eng builds.         mCanEnableDeviceRootAccess = buildType.equals(""userdebug"") || buildType.equals(""eng"");          apkFile = File.createTempFile(""CtsCompilationApp"", "".apk"");         try (OutputStream outputStream = new FileOutputStream(apkFile)) {             InputStream inputStream = getClass().getResourceAsStream(""/CtsCompilationApp.apk"");             ByteStreams.copy(inputStream, outputStream);         }         mDevice.uninstallPackage(APPLICATION_PACKAGE); // in case it's still installed         String error = mDevice.installPackage(apkFile, false);         assertNull(""Got install error: "" + error, error);          // Write the text profile to a temporary file so that we can run profman on it to create a         // real profile.         byte[] profileBytes = ByteStreams.toByteArray(                 getClass().getResourceAsStream(""/primary.prof.txt""));         assertTrue(""empty profile"", profileBytes.length > 0); // sanity check         textProfileFile = File.createTempFile(""compilationtest"", ""prof.txt"");         Files.write(profileBytes, textProfileFile);          // Ignore issues in cmd.         mAdbLineFilter = Pattern.compile(""FORTIFY: pthread_mutex_lock.*"").matcher("""");     }      @Override     protected void tearDown() throws Exception {         FileUtil.deleteFile(apkFile);         FileUtil.deleteFile(textProfileFile);         mDevice.uninstallPackage(APPLICATION_PACKAGE);         super.tearDown();     }      /**      * Tests compilation using {@code -r bg-dexopt -f}.      */"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.compilation.cts.AdbRootDependentCompilationTest"	"testCompile_curAndRefProfile"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/compilation/src/android/compilation/cts/AdbRootDependentCompilationTest.java"	""	"public void testCompile_curAndRefProfile() throws Exception {         compileWithProfilesAndCheckFilter(false /* expectOdexChange */,                 EnumSet.of(ProfileLocation.CUR, ProfileLocation.REF));     }      private byte[] readFileOnClient(String clientPath) throws Exception {         assertTrue(""File not found on client: "" + clientPath,                 doesFileExist(clientPath));         File copyOnHost = File.createTempFile(""host"", ""copy"");         try {             executePull(clientPath, copyOnHost.getPath());             return Files.toByteArray(copyOnHost);         } finally {             FileUtil.deleteFile(copyOnHost);         }     }      /**      * Places the profile in the specified locations, recompiles (without -f)      * and checks the compiler-filter in the odex file.      *      * @return whether the test ran (as opposed to early exit)      */     private boolean compileWithProfilesAndCheckFilter(boolean expectOdexChange,             Set<ProfileLocation> profileLocations)             throws Exception {         if (!canRunTest(profileLocations)) {             return false;         }         // ensure no profiles initially present         for (ProfileLocation profileLocation : ProfileLocation.values()) {             String clientPath = profileLocation.getPath();             if (doesFileExist(clientPath)) {                 executeSuShellAdbCommand(0, ""rm"", clientPath);             }         }         executeCompile(""-m"", ""speed-profile"", ""-f"");         String odexFilePath = getOdexFilePath();         byte[] initialOdexFileContents = readFileOnClient(odexFilePath);         assertTrue(""empty odex file"", initialOdexFileContents.length > 0); // sanity check          for (ProfileLocation profileLocation : profileLocations) {             writeProfile(profileLocation);         }         executeCompile(""-m"", ""speed-profile"");          // Confirm the compiler-filter used in creating the odex file         String compilerFilter = getCompilerFilter(odexFilePath);          assertEquals(""compiler-filter"", ""speed-profile"", compilerFilter);          byte[] odexFileContents = readFileOnClient(odexFilePath);         boolean odexChanged = !(Arrays.equals(initialOdexFileContents, odexFileContents));         if (odexChanged && !expectOdexChange) {             String msg = String.format(Locale.US, ""Odex file without filters (%d bytes) ""                     + ""unexpectedly different from odex file (%d bytes) compiled with filters: %s"",                     initialOdexFileContents.length, odexFileContents.length, profileLocations);             fail(msg);         } else if (!odexChanged && expectOdexChange) {             fail(""odex file should have changed when recompiling with "" + profileLocations);         }         return true;     }      /**      * Invokes the dex2oat compiler on the client.      *      * @param compileOptions extra options to pass to the compiler on the command line      */     private void executeCompile(String... compileOptions) throws Exception {         List<String> command = new ArrayList<>(Arrays.asList(""cmd"", ""package"", ""compile""));         command.addAll(Arrays.asList(compileOptions));         command.add(APPLICATION_PACKAGE);         String[] commandArray = command.toArray(new String[0]);         assertEquals(""Success"", executeSuShellAdbCommand(1, commandArray)[0]);     }      /**      * Copies {@link #textProfileFile} to the device and convert it to a binary profile on the      * client device.      */     private void writeProfile(ProfileLocation location) throws Exception {         String targetPath = location.getPath();         // Get the owner of the parent directory so we can set it on the file         String targetDir = location.getDirectory();         if (!doesFileExist(targetDir)) {             fail(""Not found: "" + targetPath);         }         // in format group:user so we can directly pass it to chown         String owner = executeSuShellAdbCommand(1, ""stat"", ""-c"", ""%U:%g"", targetDir)[0];         // for some reason, I've observed the output starting with a single space         while (owner.startsWith("" "")) {             owner = owner.substring(1);         }          String targetPathTemp = targetPath + "".tmp"";         executePush(textProfileFile.getAbsolutePath(), targetPathTemp, targetDir);         assertTrue(""Failed to push text profile"", doesFileExist(targetPathTemp));          String targetPathApk = targetPath + "".apk"";         executePush(apkFile.getAbsolutePath(), targetPathApk, targetDir);         assertTrue(""Failed to push APK from "", doesFileExist(targetPathApk));         // Run profman to create the real profile on device.         String pathSpec = executeSuShellAdbCommand(1, ""pm"", ""path"", APPLICATION_PACKAGE)[0];         pathSpec = pathSpec.replace(""package:"", """");         assertTrue(""Failed find APK "" + pathSpec, doesFileExist(pathSpec));         executeSuShellAdbCommand(                 ""profman"",                 ""--create-profile-from="" + targetPathTemp,                 ""--apk="" + pathSpec,                 ""--dex-location="" + pathSpec,                 ""--reference-profile-file="" + targetPath);         executeSuShellAdbCommand(0, ""chown"", owner, targetPath);         // Verify that the file was written successfully         assertTrue(""failed to create profile file"", doesFileExist(targetPath));         String[] result = executeSuShellAdbCommand(1, ""stat"", ""-c"", ""%s"", targetPath);         assertTrue(""profile "" + targetPath + "" is "" + Integer.parseInt(result[0]) + "" bytes"",                    Integer.parseInt(result[0]) > 0);     }      /**      * Parses the value for the key ""compiler-filter"" out of the output from      * {@code oatdump --header-only}.      */     private String getCompilerFilter(String odexFilePath) throws DeviceNotAvailableException {         String[] response = executeSuShellAdbCommand(                 ""oatdump"", ""--header-only"", ""--oat-file="" + odexFilePath);         String prefix = ""compiler-filter ="";         for (String line : response) {             line = line.trim();             if (line.startsWith(prefix)) {                 return line.substring(prefix.length()).trim();             }         }         fail(""No occurence of \"""" + prefix + ""\"" in: "" + Arrays.toString(response));         return null;     }      /**      * Returns the path to the application's base.odex file that should have      * been created by the compiler.      */     private String getOdexFilePath() throws DeviceNotAvailableException {         // Something like ""package:/data/app/android.compilation.cts-1/base.apk""         String pathSpec = executeSuShellAdbCommand(1, ""pm"", ""path"", APPLICATION_PACKAGE)[0];         Matcher matcher = Pattern.compile(""^package:(.+/)base\\.apk$"").matcher(pathSpec);         boolean found = matcher.find();         assertTrue(""Malformed spec: "" + pathSpec, found);         String apkDir = matcher.group(1);         // E.g. /data/app/android.compilation.cts-1/oat/arm64/base.odex         String result = executeSuShellAdbCommand(1, ""find"", apkDir, ""-name"", ""base.odex"")[0];         assertTrue(""odex file not found: "" + result, doesFileExist(result));         return result;     }      /**      * Returns whether a test that uses the given profileLocations can run      * in the current device configuration. This allows tests to exit early.      *      * <p>Ideally we'd like tests to be marked as skipped/ignored or similar      * rather than passing if they can't run on the current device, but that      * doesn't seem to be supported by CTS as of 2016-05-24.      * TODO: Use Assume.assumeTrue() if this test gets converted to JUnit 4.      */     private boolean canRunTest(Set<ProfileLocation> profileLocations) throws Exception {         boolean result = mCanEnableDeviceRootAccess &&                 (profileLocations.isEmpty() || isUseJitProfiles());         if (!result) {             System.err.printf(""Skipping test [mCanEnableDeviceRootAccess=%s, %d profiles] on %s\n"",                     mCanEnableDeviceRootAccess, profileLocations.size(), mDevice);         }         return result;     }      private boolean isUseJitProfiles() throws Exception {         boolean propUseJitProfiles = Boolean.parseBoolean(                 executeSuShellAdbCommand(1, ""getprop"", ""dalvik.vm.usejitprofiles"")[0]);         return propUseJitProfiles;     }      private String[] filterAdbLines(String[] lines) {         List<String> linesList = new ArrayList<String>(Arrays.asList(lines));         Iterator<String> it = linesList.iterator();         while (it.hasNext()) {             String line = it.next();             mAdbLineFilter.reset(line);             if (mAdbLineFilter.matches()) {                 it.remove();             }         }         if (linesList.size() != lines.length) {             return linesList.toArray(new String[linesList.size()]);         }         return lines;     }      private String[] executeSuShellAdbCommand(int numLinesOutputExpected, String... command)             throws DeviceNotAvailableException {         String[] lines = filterAdbLines(executeSuShellAdbCommand(command));         assertEquals(                 String.format(Locale.US, ""Expected %d lines output, got %d running %s: %s"",                         numLinesOutputExpected, lines.length, Arrays.toString(command),                         Arrays.toString(lines)),                 numLinesOutputExpected, lines.length);         return lines;     }      private String[] executeSuShellAdbCommand(String... command)             throws DeviceNotAvailableException {         // Add `shell su root` to the adb command.         String cmdString = String.join("" "", command);         String output = mDevice.executeShellCommand(""su root "" + cmdString);         // """".split() returns { """" }, but we want an empty array         String[] lines = output.equals("""") ? new String[0] : output.split(""\n"");         return filterAdbLines(lines);     }      private String getSelinuxLabel(String path) throws DeviceNotAvailableException {         // ls -aZ (-a so it sees directories, -Z so it prints the label).         String[] res = executeSuShellAdbCommand(String.format(             ""ls -aZ '%s'"", path));          if (res.length == 0) {           return null;         }          // For directories, it will print many outputs. Filter to first line which contains '.'         // The target line will look like         //      ""u:object_r:shell_data_file:s0 /data/local/tmp/android.compilation.cts.primary.prof""         // Remove the second word to only return ""u:object_r:shell_data_file:s0"".          return res[0].replaceAll(""\\s+.*"","""");  // remove everything following the first whitespace     }      private void checkSelinuxLabelMatches(String a, String b) throws DeviceNotAvailableException {       String labelA = getSelinuxLabel(a);       String labelB = getSelinuxLabel(b);        assertEquals(""expected the selinux labels to match"", labelA, labelB);     }      private void executePush(String hostPath, String targetPath, String targetDirectory)             throws DeviceNotAvailableException {         // Cannot push to a privileged directory with one command.         // (i.e. there is no single-command equivalent of 'adb root; adb push src dst')         //         // Push to a tmp directory and then move it to the final destination         // after updating the selinux label.         String tmpPath = ""/data/local/tmp/"" + APPLICATION_PACKAGE + "".push.tmp"";         assertTrue(mDevice.pushFile(new File(hostPath), tmpPath));          // Important: Use ""cp"" here because it newly copied files will inherit the security context         // of the targetDirectory according to the default policy.         //         // (Other approaches, such as moving the file retain the invalid security context         // of the tmp directory - b/37425296)         //         // This mimics the behavior of 'adb root; adb push $targetPath'.         executeSuShellAdbCommand(""mv"", tmpPath, targetPath);          // Important: Use ""restorecon"" here because the file in tmpPath retains the         // incompatible security context of /data/local/tmp.         //         // This mimics the behavior of 'adb root; adb push $targetPath'.         executeSuShellAdbCommand(""restorecon"", targetPath);          // Validate that the security context of the file matches the security context         // of the directory it was pushed to.         //         // This is a reasonable default behavior to check because most selinux policies         // are configured to behave like this.         checkSelinuxLabelMatches(targetDirectory, targetPath);     }      private void executePull(String targetPath, String hostPath)             throws DeviceNotAvailableException {         String tmpPath = ""/data/local/tmp/"" + APPLICATION_PACKAGE + "".pull.tmp"";         executeSuShellAdbCommand(""cp"", targetPath, tmpPath);         try {             executeSuShellAdbCommand(""chmod"", ""606"", tmpPath);             assertTrue(mDevice.pullFile(tmpPath, new File(hostPath)));         } finally {             executeSuShellAdbCommand(""rm"", tmpPath);         }     }      private boolean doesFileExist(String path) throws DeviceNotAvailableException {         String[] result = executeSuShellAdbCommand(""ls"", path);         // Testing for empty directories will return an empty array.         return !(result.length > 0 && result[0].contains(""No such file""));     } }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.app.usage.cts.NetworkUsageStatsTest"	"getIsDefault"	"CtsUsageStatsTestCases"	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	"v4"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/app.usage/src/android/app/usage/cts/NetworkUsageStatsTest.java"	""	"public void test/**  * Copyright (C) 2015 The Android Open Source Project  *  * Licensed under the Apache License, Version 2.0 (the ""License""); you may not  * use this file except in compliance with the License. You may obtain a copy  * of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an ""AS IS"" BASIS, WITHOUT  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the  * License for the specific language governing permissions and limitations  * under the License.  */  package android.app.usage.cts;  import android.app.AppOpsManager; import android.app.usage.NetworkStatsManager; import android.app.usage.NetworkStats; import android.content.Context; import android.content.pm.PackageManager; import android.net.ConnectivityManager; import android.net.Network; import android.net.NetworkCapabilities; import android.net.NetworkInfo; import android.net.NetworkRequest; import android.net.TrafficStats; import android.os.Handler; import android.os.HandlerThread; import android.os.ParcelFileDescriptor; import android.os.Process; import android.os.RemoteException; import android.os.SystemClock; import android.platform.test.annotations.AppModeFull; import android.telephony.TelephonyManager; import android.test.InstrumentationTestCase; import android.util.Log;  import com.android.compatibility.common.util.ShellIdentityUtils; import com.android.compatibility.common.util.SystemUtil;  import java.io.FileInputStream; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; import java.net.URL; import java.net.UnknownHostException; import java.text.MessageFormat; import java.util.ArrayList; import java.util.Scanner; import java.net.HttpURLConnection;  import libcore.io.IoUtils; import libcore.io.Streams;  import static android.app.usage.NetworkStats.Bucket.DEFAULT_NETWORK_ALL; import static android.app.usage.NetworkStats.Bucket.DEFAULT_NETWORK_NO; import static android.app.usage.NetworkStats.Bucket.DEFAULT_NETWORK_YES; import static android.app.usage.NetworkStats.Bucket.METERED_ALL; import static android.app.usage.NetworkStats.Bucket.METERED_YES; import static android.app.usage.NetworkStats.Bucket.METERED_NO; import static android.app.usage.NetworkStats.Bucket.STATE_ALL; import static android.app.usage.NetworkStats.Bucket.STATE_DEFAULT; import static android.app.usage.NetworkStats.Bucket.STATE_FOREGROUND; import static android.app.usage.NetworkStats.Bucket.TAG_NONE; import static android.app.usage.NetworkStats.Bucket.UID_ALL;  public class NetworkUsageStatsTest extends InstrumentationTestCase {     private static final String LOG_TAG = ""NetworkUsageStatsTest"";     private static final String APPOPS_SET_SHELL_COMMAND = ""appops set {0} {1} {2}"";     private static final String APPOPS_GET_SHELL_COMMAND = ""appops get {0} {1}"";      private static final long MINUTE = 1000 * 60;     private static final int TIMEOUT_MILLIS = 15000;      private static final String CHECK_CONNECTIVITY_URL = ""http://www.265.com/"";     private static final int HOST_RESOLUTION_RETRIES = 4;     private static final int HOST_RESOLUTION_INTERVAL_MS = 500;      private static final int NETWORK_TAG = 0xf00d;     private static final long THRESHOLD_BYTES = 2 * 1024 * 1024;  // 2 MB      private abstract class NetworkInterfaceToTest {         private boolean mMetered;         private boolean mIsDefault;          abstract int getNetworkType();         abstract int getTransportType();          public boolean getMetered() {             return mMetered;         }          public void setMetered(boolean metered) {             this.mMetered = metered;         }          public boolean getIsDefault() {             return mIsDefault;         }          public void setIsDefault(boolean isDefault) {             mIsDefault = isDefault;         }          abstract String getSystemFeature();         abstract String getErrorMessage();     }      private final NetworkInterfaceToTest[] mNetworkInterfacesToTest =             new NetworkInterfaceToTest[] {                     new NetworkInterfaceToTest() {                         @Override                         public int getNetworkType() {                             return ConnectivityManager.TYPE_WIFI;                         }                          @Override                         public int getTransportType() {                             return NetworkCapabilities.TRANSPORT_WIFI;                         }                          @Override                         public String getSystemFeature() {                             return PackageManager.FEATURE_WIFI;                         }                          @Override                         public String getErrorMessage() {                             return "" Please make sure you are connected to a WiFi access point."";                         }                     },                     new NetworkInterfaceToTest() {                         @Override                         public int getNetworkType() {                             return ConnectivityManager.TYPE_MOBILE;                         }                          @Override                         public int getTransportType() {                             return NetworkCapabilities.TRANSPORT_CELLULAR;                         }                          @Override                         public String getSystemFeature() {                             return PackageManager.FEATURE_TELEPHONY;                         }                          @Override                         public String getErrorMessage() {                             return "" Please make sure you have added a SIM card with data plan to"" +                                     "" your phone, have enabled data over cellular and in case of"" +                                     "" dual SIM devices, have selected the right SIM "" +                                     ""for data connection."";                         }                     }     };      private String mPkg;     private NetworkStatsManager mNsm;     private ConnectivityManager mCm;     private PackageManager mPm;     private long mStartTime;     private long mEndTime;      private long mBytesRead;     private String mWriteSettingsMode;     private String mUsageStatsMode;      private void exerciseRemoteHost(Network network, URL url) throws Exception {         NetworkInfo networkInfo = mCm.getNetworkInfo(network);         if (networkInfo == null) {             Log.w(LOG_TAG, ""Network info is null"");         } else {             Log.w(LOG_TAG, ""Network: "" + networkInfo.toString());         }         InputStreamReader in = null;         HttpURLConnection urlc = null;         String originalKeepAlive = System.getProperty(""http.keepAlive"");         System.setProperty(""http.keepAlive"", ""false"");         try {             TrafficStats.setThreadStatsTag(NETWORK_TAG);             urlc = (HttpURLConnection) network.openConnection(url);             urlc.setConnectTimeout(TIMEOUT_MILLIS);             urlc.setUseCaches(false);             // Disable compression so we generate enough traffic that assertWithinPercentage will             // not be affected by the small amount of traffic (5-10kB) sent by the test harness.             urlc.setRequestProperty(""Accept-Encoding"", ""identity"");             urlc.connect();             boolean ping = urlc.getResponseCode() == 200;             if (ping) {                 in = new InputStreamReader(                         (InputStream) urlc.getContent());                  mBytesRead = 0;                 while (in.read() != -1) ++mBytesRead;             }         } catch (Exception e) {             Log.i(LOG_TAG, ""Badness during exercising remote server: "" + e);         } finally {             TrafficStats.clearThreadStatsTag();             if (in != null) {                 try {                     in.close();                 } catch (IOException e) {                     // don't care                 }             }             if (urlc != null) {                 urlc.disconnect();             }             if (originalKeepAlive == null) {                 System.clearProperty(""http.keepAlive"");             } else {                 System.setProperty(""http.keepAlive"", originalKeepAlive);             }         }     }      @Override     protected void setUp() throws Exception {         super.setUp();         mNsm = (NetworkStatsManager) getInstrumentation().getContext()                 .getSystemService(Context.NETWORK_STATS_SERVICE);         mNsm.setPollForce(true);          mCm = (ConnectivityManager) getInstrumentation().getContext()                 .getSystemService(Context.CONNECTIVITY_SERVICE);          mPm = getInstrumentation().getContext().getPackageManager();          mPkg = getInstrumentation().getContext().getPackageName();          mWriteSettingsMode = getAppOpsMode(AppOpsManager.OPSTR_WRITE_SETTINGS);         setAppOpsMode(AppOpsManager.OPSTR_WRITE_SETTINGS, ""allow"");         mUsageStatsMode = getAppOpsMode(AppOpsManager.OPSTR_GET_USAGE_STATS);     }      @Override     protected void tearDown() throws Exception {         if (mWriteSettingsMode != null) {             setAppOpsMode(AppOpsManager.OPSTR_WRITE_SETTINGS, mWriteSettingsMode);         }         if (mUsageStatsMode != null) {             setAppOpsMode(AppOpsManager.OPSTR_GET_USAGE_STATS, mUsageStatsMode);         }         super.tearDown();     }      private void setAppOpsMode(String appop, String mode) throws Exception {         final String command = MessageFormat.format(APPOPS_SET_SHELL_COMMAND, mPkg, appop, mode);         SystemUtil.runShellCommand(command);     }      private String getAppOpsMode(String appop) throws Exception {         final String command = MessageFormat.format(APPOPS_GET_SHELL_COMMAND, mPkg, appop);         String result = SystemUtil.runShellCommand(command);         if (result == null) {             Log.w(LOG_TAG, ""App op "" + appop + "" could not be read."");         }         return result;     }      private boolean isInForeground() throws IOException {         String result = SystemUtil.runShellCommand(getInstrumentation(),                 ""cmd activity get-uid-state "" + Process.myUid());         return result.contains(""FOREGROUND"");     }      private class NetworkCallback extends ConnectivityManager.NetworkCallback {         private long mTolerance;         private URL mUrl;         public boolean success;         public boolean metered;         public boolean isDefault;          NetworkCallback(long tolerance, URL url) {             mTolerance = tolerance;             mUrl = url;             success = false;             metered = false;             isDefault = false;         }          // The test host only has IPv4. So on a dual-stack network where IPv6 connects before IPv4,         // we need to wait until IPv4 is available or the test will spuriously fail.         private void waitForHostResolution(Network network) {             for (int i = 0; i < HOST_RESOLUTION_RETRIES; i++) {                 try {                     network.getAllByName(mUrl.getHost());                     return;                 } catch (UnknownHostException e) {                     SystemClock.sleep(HOST_RESOLUTION_INTERVAL_MS);                 }             }             fail(String.format(""%s could not be resolved on network %s (%d attempts %dms apart)"",                   mUrl.getHost(), network, HOST_RESOLUTION_RETRIES, HOST_RESOLUTION_INTERVAL_MS));         }          @Override         public void onAvailable(Network network) {             try {                 mStartTime = System.currentTimeMillis() - mTolerance;                 isDefault = network.equals(mCm.getActiveNetwork());                 waitForHostResolution(network);                 exerciseRemoteHost(network, mUrl);                 mEndTime = System.currentTimeMillis() + mTolerance;                 success = true;                 metered = !mCm.getNetworkCapabilities(network)                         .hasCapability(NetworkCapabilities.NET_CAPABILITY_NOT_METERED);                 synchronized(NetworkUsageStatsTest.this) {                     NetworkUsageStatsTest.this.notify();                 }             } catch (Exception e) {                 Log.w(LOG_TAG, ""exercising remote host failed."", e);                 success = false;             }         }     }      private boolean shouldTestThisNetworkType(int networkTypeIndex, final long tolerance)             throws Exception {         boolean hasFeature = mPm.hasSystemFeature(                 mNetworkInterfacesToTest[networkTypeIndex].getSystemFeature());         if (!hasFeature) {             return false;         }         NetworkCallback callback = new NetworkCallback(tolerance, new URL(CHECK_CONNECTIVITY_URL));         mCm.requestNetwork(new NetworkRequest.Builder()                 .addTransportType(mNetworkInterfacesToTest[networkTypeIndex].getTransportType())                 .addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)                 .build(), callback);         synchronized(this) {             try {                 wait((int)(TIMEOUT_MILLIS * 1.2));             } catch (InterruptedException e) {             }         }         if (callback.success) {             mNetworkInterfacesToTest[networkTypeIndex].setMetered(callback.metered);             mNetworkInterfacesToTest[networkTypeIndex].setIsDefault(callback.isDefault);             return true;         }          // This will always fail at this point as we know 'hasFeature' is true.         assertFalse (mNetworkInterfacesToTest[networkTypeIndex].getSystemFeature() +                 "" is a reported system feature, "" +                 ""however no corresponding connected network interface was found or the attempt "" +                 ""to connect has timed out (timeout = "" + TIMEOUT_MILLIS + ""ms)."" +                 mNetworkInterfacesToTest[networkTypeIndex].getErrorMessage(), hasFeature);         return false;     }      private String getSubscriberId(int networkIndex) {         int networkType = mNetworkInterfacesToTest[networkIndex].getNetworkType();         if (ConnectivityManager.TYPE_MOBILE == networkType) {             TelephonyManager tm = (TelephonyManager) getInstrumentation().getContext()                     .getSystemService(Context.TELEPHONY_SERVICE);             return ShellIdentityUtils.invokeMethodWithShellPermissions(tm,                     (telephonyManager) -> telephonyManager.getSubscriberId());         }         return """";     }      @AppModeFull"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.permission.cts.PermissionControllerTest"	"OnRevokeRuntimePermissionsCallback"	"CtsPermissionTestCases"	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/permission/src/android/permission/cts/PermissionControllerTest.java"	""	"/*  *.  */  package android.permission.cts;  import static android.Manifest.permission.ACCESS_BACKGROUND_LOCATION; import static android.Manifest.permission.ACCESS_COARSE_LOCATION; import static android.Manifest.permission.ACCESS_FINE_LOCATION; import static android.Manifest.permission.BODY_SENSORS; import static android.Manifest.permission.READ_CALENDAR; import static android.Manifest.permission.READ_CONTACTS; import static android.Manifest.permission.WRITE_CALENDAR; import static android.app.AppOpsManager.MODE_ALLOWED; import static android.app.AppOpsManager.MODE_FOREGROUND; import static android.app.AppOpsManager.permissionToOp; import static android.content.pm.PackageManager.PERMISSION_DENIED; import static android.permission.PermissionControllerManager.COUNT_ONLY_WHEN_GRANTED; import static android.permission.PermissionControllerManager.REASON_INSTALLER_POLICY_VIOLATION; import static android.permission.PermissionControllerManager.REASON_MALWARE; import static android.permission.cts.PermissionUtils.grantPermission; import static android.permission.cts.PermissionUtils.isGranted; import static android.permission.cts.PermissionUtils.isPermissionGranted;  import static com.android.compatibility.common.util.SystemUtil.callWithShellPermissionIdentity; import static com.android.compatibility.common.util.SystemUtil.eventually; import static com.android.compatibility.common.util.SystemUtil.runShellCommand; import static com.android.compatibility.common.util.SystemUtil.runWithShellPermissionIdentity;  import static com.google.common.truth.Truth.assertThat;  import static java.util.Collections.singletonList;  import android.app.AppOpsManager; import android.app.UiAutomation; import android.content.Context; import android.content.pm.PermissionGroupInfo; import android.permission.PermissionControllerManager; import android.permission.RuntimePermissionPresentationInfo; import android.platform.test.annotations.AppModeFull;  import androidx.annotation.NonNull; import androidx.test.InstrumentationRegistry; import androidx.test.runner.AndroidJUnit4;  import org.junit.After; import org.junit.AfterClass; import org.junit.Before; import org.junit.BeforeClass; import org.junit.Test; import org.junit.runner.RunWith;  import java.util.ArrayList; import java.util.Collections; import java.util.List; import java.util.Map; import java.util.concurrent.CompletableFuture; import java.util.concurrent.Executor; import java.util.concurrent.atomic.AtomicBoolean; import java.util.concurrent.atomic.AtomicReference;  /**  * Test {@link PermissionControllerManager}  */ @RunWith(AndroidJUnit4.class) @AppModeFull(reason = ""Instant apps cannot talk to permission controller"") public class PermissionControllerTest {     private static final String APK =             ""/data/local/tmp/cts/permissions/CtsAppThatAccessesLocationOnCommand.apk"";     private static final String APP = ""android.permission.cts.appthataccesseslocation"";     private static final String APK2 =             ""/data/local/tmp/cts/permissions/""                     + ""CtsAppThatRequestsCalendarContactsBodySensorCustomPermission.apk"";     private static final String APP2 = ""android.permission.cts.appthatrequestcustompermission"";     private static final String CUSTOM_PERMISSION =             ""android.permission.cts.appthatrequestcustompermission.TEST_PERMISSION"";      private static final UiAutomation sUiAutomation =             InstrumentationRegistry.getInstrumentation().getUiAutomation();     private static final Context sContext = InstrumentationRegistry.getTargetContext();     private static final PermissionControllerManager sController =             sContext.getSystemService(PermissionControllerManager.class);      @Before     @After     public void resetAppState() {         runWithShellPermissionIdentity(() -> {             sUiAutomation.grantRuntimePermission(APP, ACCESS_FINE_LOCATION);             sUiAutomation.grantRuntimePermission(APP, ACCESS_BACKGROUND_LOCATION);             setAppOp(APP, ACCESS_FINE_LOCATION, MODE_ALLOWED);         });     }      @BeforeClass     public static void installApp() {         runShellCommand(""pm install -r -g "" + APK);         runShellCommand(""pm install -r "" + APK2);     }      @AfterClass     public static void uninstallApp() {         runShellCommand(""pm uninstall "" + APP);         runShellCommand(""pm uninstall "" + APP2);     }      private @NonNull Map<String, List<String>> revokePermissions(             @NonNull Map<String, List<String>> request, boolean doDryRun, int reason,             @NonNull Executor executor) throws Exception {         AtomicReference<Map<String, List<String>>> result = new AtomicReference<>();          sController.revokeRuntimePermissions(request, doDryRun, reason, executor,                 new PermissionControllerManager.OnRevokeRuntimePermissionsCallback() {                     @Override                     public void onRevokeRuntimePermissions(@NonNull Map<String, List<String>> r) {                         synchronized (result) {                             result.set(r);                             result.notifyAll();                         }                     }                 });          synchronized (result) {             while (result.get() == null) {                 result.wait();             }         }          return result.get();     }      private @NonNull Map<String, List<String>> revokePermissions(             @NonNull Map<String, List<String>> request, boolean doDryRun, boolean adoptShell)             throws Exception {         if (adoptShell) {             Map<String, List<String>> revokeRet =                     callWithShellPermissionIdentity(() -> revokePermissions(                             request, doDryRun, REASON_MALWARE, sContext.getMainExecutor()));             return revokeRet;         }         return revokePermissions(request, doDryRun, REASON_MALWARE, sContext.getMainExecutor());     }      private @NonNull Map<String, List<String>> revokePermissions(             @NonNull Map<String, List<String>> request, boolean doDryRun) throws Exception {         return revokePermissions(request, doDryRun, true);     }      private void setAppOp(@NonNull String pkg, @NonNull String perm, int mode) throws Exception {         sContext.getSystemService(AppOpsManager.class).setUidMode(permissionToOp(perm),                 sContext.getPackageManager().getPackageUid(pkg, 0), mode);     }      private Map<String, List<String>> buildRevokeRequest(@NonNull String app,             @NonNull String permission) {         return Collections.singletonMap(app, singletonList(permission));     }      private void assertRuntimePermissionLabelsAreValid(List<String> runtimePermissions,             List<RuntimePermissionPresentationInfo> permissionInfos, int expectedRuntimeGranted,             String app) throws Exception {         int numRuntimeGranted = 0;         for (String permission : runtimePermissions) {             if (isPermissionGranted(app, permission)) {                 numRuntimeGranted++;             }         }         assertThat(numRuntimeGranted).isEqualTo(expectedRuntimeGranted);          ArrayList<CharSequence> maybeStandardPermissionLabels = new ArrayList<>();         ArrayList<CharSequence> nonStandardPermissionLabels = new ArrayList<>();         for (PermissionGroupInfo permGroup : sContext.getPackageManager().getAllPermissionGroups(                 0)) {             CharSequence permissionGroupLabel = permGroup.loadLabel(sContext.getPackageManager());             if (permGroup.packageName.equals(""android"")) {                 maybeStandardPermissionLabels.add(permissionGroupLabel);             } else {                 nonStandardPermissionLabels.add(permissionGroupLabel);             }         }          int numInfosGranted = 0;          for (RuntimePermissionPresentationInfo permissionInfo : permissionInfos) {             CharSequence permissionGroupLabel = permissionInfo.getLabel();              // PermissionInfo should be included in exactly one of existing (possibly) standard             // or nonstandard permission groups             if (permissionInfo.isStandard()) {                 assertThat(maybeStandardPermissionLabels).contains(permissionGroupLabel);             } else {                 assertThat(nonStandardPermissionLabels).contains(permissionGroupLabel);             }             if (permissionInfo.isGranted()) {                 numInfosGranted++;             }         }          // Each permissionInfo represents one or more runtime permissions, but we don't have a         // mapping, so we check that we have at least as many runtimePermissions as permissionInfos         assertThat(numRuntimeGranted).isAtLeast(numInfosGranted);     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.mediav2.cts.CodecEncoderSurfaceTest"	"isHandheld"	"CtsMediaTestCases"	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	"v4"	""	""	""	"/home/gpoor/cts-source/cts/tests/media/src/android/mediav2/cts/CodecEncoderSurfaceTest.java"	""	"/*  *.  */  package android.mediav2.cts;  import android.media.MediaCodec; import android.media.MediaCodecInfo; import android.media.MediaCodecList; import android.media.MediaExtractor; import android.media.MediaFormat; import android.media.MediaMuxer; import android.os.Build; import android.util.Log; import android.util.Pair; import android.view.Surface;  import androidx.test.filters.LargeTest; import androidx.test.platform.app.InstrumentationRegistry;  import org.junit.Test; import org.junit.runner.RunWith; import org.junit.runners.Parameterized;  import java.io.File; import java.io.IOException; import java.nio.ByteBuffer; import java.util.ArrayList; import java.util.Collection; import java.util.List; import java.util.Map;  import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail;  @RunWith(Parameterized.class) public class CodecEncoderSurfaceTest {     private static final String LOG_TAG = CodecEncoderSurfaceTest.class.getSimpleName();     private static final String mInpPrefix = WorkDir.getMediaDirString();     private static final boolean ENABLE_LOGS = false;      private final String mMime;     private final String mTestFile;     private final int mBitrate;     private final int mFrameRate;     private final int mMaxBFrames;     private int mLatency;     private boolean mReviseLatency;      private MediaExtractor mExtractor;     private MediaCodec mEncoder;     private CodecAsyncHandler mAsyncHandleEncoder;     private MediaCodec mDecoder;     private CodecAsyncHandler mAsyncHandleDecoder;     private boolean mIsCodecInAsyncMode;     private boolean mSignalEOSWithLastFrame;     private boolean mSawDecInputEOS;     private boolean mSawDecOutputEOS;     private boolean mSawEncOutputEOS;     private int mDecInputCount;     private int mDecOutputCount;     private int mEncOutputCount;      private boolean mSaveToMem;     private OutputManager mOutputBuff;      private Surface mSurface;      private MediaMuxer mMuxer;     private int mTrackID = -1;      static {         android.os.Bundle args = InstrumentationRegistry.getArguments();         CodecTestBase.codecSelKeys = args.getString(CodecTestBase.CODEC_SEL_KEY);         if (CodecTestBase.codecSelKeys == null)             CodecTestBase.codecSelKeys = CodecTestBase.CODEC_SEL_VALUE;     }      public CodecEncoderSurfaceTest(String mime, String testFile, int bitrate, int frameRate) {         mMime = mime;         mTestFile = testFile;         mBitrate = bitrate;         mFrameRate = frameRate;         mMaxBFrames = 0;         mLatency = mMaxBFrames;         mReviseLatency = false;         mAsyncHandleDecoder = new CodecAsyncHandler();         mAsyncHandleEncoder = new CodecAsyncHandler();     }      @Parameterized.Parameters(name = ""{index}({0})"")     public static Collection<Object[]> input() {         ArrayList<String> cddRequiredMimeList = new ArrayList<>();         if (CodecTestBase.isHandheld() || CodecTestBase.isTv() || CodecTestBase.isAutomotive()) {             // sec 2.2.2, 2.3.2, 2.5.2             cddRequiredMimeList.add(MediaFormat.MIMETYPE_VIDEO_AVC);             cddRequiredMimeList.add(MediaFormat.MIMETYPE_VIDEO_VP8);         }         final Object[][] exhaustiveArgsList = new Object[][]{                 // Video - CodecMime, test file, bit rate, frame rate                 {MediaFormat.MIMETYPE_VIDEO_H263, ""bbb_176x144_128kbps_15fps_h263.3gp"", 128000, 15},                 {MediaFormat.MIMETYPE_VIDEO_MPEG4, ""bbb_128x96_64kbps_12fps_mpeg4.mp4"", 64000, 12},                 {MediaFormat.MIMETYPE_VIDEO_AVC, ""bbb_cif_768kbps_30fps_avc.mp4"", 512000, 30},                 {MediaFormat.MIMETYPE_VIDEO_HEVC, ""bbb_cif_768kbps_30fps_avc.mp4"", 512000, 30},                 {MediaFormat.MIMETYPE_VIDEO_VP8, ""bbb_cif_768kbps_30fps_avc.mp4"", 512000, 30},                 {MediaFormat.MIMETYPE_VIDEO_VP9, ""bbb_cif_768kbps_30fps_avc.mp4"", 512000, 30},                 {MediaFormat.MIMETYPE_VIDEO_AV1, ""bbb_cif_768kbps_30fps_avc.mp4"", 512000, 30},         };         ArrayList<String> mimes = new ArrayList<>();         if (CodecTestBase.codecSelKeys.contains(CodecTestBase.CODEC_SEL_VALUE)) {             MediaCodecList codecList = new MediaCodecList(MediaCodecList.REGULAR_CODECS);             MediaCodecInfo[] codecInfos = codecList.getCodecInfos();             for (MediaCodecInfo codecInfo : codecInfos) {                 if (!codecInfo.isEncoder()) continue;                 if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q && codecInfo.isAlias()) continue;                 String[] types = codecInfo.getSupportedTypes();                 for (String type : types) {                     if (!mimes.contains(type) && type.startsWith(""video/"")) {                         mimes.add(type);                     }                 }             }             // TODO(b/154423708): add checks for video o/p port and display length >= 2.5""             /* sec 5.2: device implementations include an embedded screen display with the diagonal             length of at least 2.5inches or include a video output port or declare the support of a             camera */             if (CodecTestBase.hasCamera() && !mimes.contains(MediaFormat.MIMETYPE_VIDEO_AVC) &&                     !mimes.contains(MediaFormat.MIMETYPE_VIDEO_VP8)) {                 fail(""device must support at least one of VP8 or AVC video encoders"");             }             for (String mime : cddRequiredMimeList) {                 if (!mimes.contains(mime)) {                     fail(""no codec found for mime "" + mime + "" as required by cdd"");                 }             }         } else {             for (Map.Entry<String, String> entry : CodecTestBase.codecSelKeyMimeMap.entrySet()) {                 String key = entry.getKey();                 String value = entry.getValue();                 if (CodecTestBase.codecSelKeys.contains(key) && !mimes.contains(value)) {                     mimes.add(value);                 }             }         }         final List<Object[]> argsList = new ArrayList<>();         for (String mime : mimes) {             boolean miss = true;             for (Object[] arg : exhaustiveArgsList) {                 if (mime.equals(arg[0])) {                     argsList.add(arg);                     miss = false;                 }             }             if (miss) {                 if (cddRequiredMimeList.contains(mime)) {                     fail(""no test vectors for required mimetype "" + mime);                 }                 Log.w(LOG_TAG, ""no test vectors available for optional mime type "" + mime);             }         }         return argsList;     }      private boolean hasSeenError() {         return mAsyncHandleDecoder.hasSeenError() || mAsyncHandleEncoder.hasSeenError();     }      private MediaFormat setUpSource(String srcFile) throws IOException {         mExtractor = new MediaExtractor();         mExtractor.setDataSource(mInpPrefix + srcFile);         for (int trackID = 0; trackID < mExtractor.getTrackCount(); trackID++) {             MediaFormat format = mExtractor.getTrackFormat(trackID);             String mime = format.getString(MediaFormat.KEY_MIME);             if (mime.startsWith(""video/"")) {                 mExtractor.selectTrack(trackID);                 // COLOR_FormatYUV420Flexible by default should be supported by all components                 // This call shouldn't effect configure() call for any codec                 format.setInteger(MediaFormat.KEY_COLOR_FORMAT,                         MediaCodecInfo.CodecCapabilities.COLOR_FormatYUV420Flexible);                 return format;             }         }         mExtractor.release();         fail(""No video track found in file: "" + srcFile);         return null;     }      private void resetContext(boolean isAsync, boolean signalEOSWithLastFrame) {         mAsyncHandleDecoder.resetContext();         mAsyncHandleEncoder.resetContext();         mIsCodecInAsyncMode = isAsync;         mSignalEOSWithLastFrame = signalEOSWithLastFrame;         mSawDecInputEOS = false;         mSawDecOutputEOS = false;         mSawEncOutputEOS = false;         mDecInputCount = 0;         mDecOutputCount = 0;         mEncOutputCount = 0;     }      private void configureCodec(MediaFormat decFormat, MediaFormat encFormat, boolean isAsync,             boolean signalEOSWithLastFrame) {         resetContext(isAsync, signalEOSWithLastFrame);         mAsyncHandleEncoder.setCallBack(mEncoder, isAsync);         mEncoder.configure(encFormat, null, MediaCodec.CONFIGURE_FLAG_ENCODE, null);         if (mEncoder.getInputFormat().containsKey(MediaFormat.KEY_LATENCY)) {             mReviseLatency = true;             mLatency = mEncoder.getInputFormat().getInteger(MediaFormat.KEY_LATENCY);         }         mSurface = mEncoder.createInputSurface();         assertTrue(""Surface is not valid"", mSurface.isValid());         mAsyncHandleDecoder.setCallBack(mDecoder, isAsync);         mDecoder.configure(decFormat, mSurface, null, 0);         if (ENABLE_LOGS) {             Log.v(LOG_TAG, ""codec configured"");         }     }      private void enqueueDecoderEOS(int bufferIndex) {         if (!mSawDecInputEOS) {             mDecoder.queueInputBuffer(bufferIndex, 0, 0, 0, MediaCodec.BUFFER_FLAG_END_OF_STREAM);             mSawDecInputEOS = true;             if (ENABLE_LOGS) {                 Log.v(LOG_TAG, ""Queued End of Stream"");             }         }     }      private void enqueueDecoderInput(int bufferIndex) {         if (mExtractor.getSampleSize() < 0) {             enqueueDecoderEOS(bufferIndex);         } else {             ByteBuffer inputBuffer = mDecoder.getInputBuffer(bufferIndex);             mExtractor.readSampleData(inputBuffer, 0);             int size = (int) mExtractor.getSampleSize();             long pts = mExtractor.getSampleTime();             int extractorFlags = mExtractor.getSampleFlags();             int codecFlags = 0;             if ((extractorFlags & MediaExtractor.SAMPLE_FLAG_SYNC) != 0) {                 codecFlags |= MediaCodec.BUFFER_FLAG_KEY_FRAME;             }             if ((extractorFlags & MediaExtractor.SAMPLE_FLAG_PARTIAL_FRAME) != 0) {                 codecFlags |= MediaCodec.BUFFER_FLAG_PARTIAL_FRAME;             }             if (!mExtractor.advance() && mSignalEOSWithLastFrame) {                 codecFlags |= MediaCodec.BUFFER_FLAG_END_OF_STREAM;                 mSawDecInputEOS = true;             }             if (ENABLE_LOGS) {                 Log.v(LOG_TAG, ""input: id: "" + bufferIndex + "" size: "" + size + "" pts: "" + pts +                         "" flags: "" + codecFlags);             }             mDecoder.queueInputBuffer(bufferIndex, 0, size, pts, codecFlags);             if (size > 0 && (codecFlags & (MediaCodec.BUFFER_FLAG_CODEC_CONFIG |                     MediaCodec.BUFFER_FLAG_PARTIAL_FRAME)) == 0) {                 mOutputBuff.saveInPTS(pts);                 mDecInputCount++;             }         }     }      private void dequeueDecoderOutput(int bufferIndex, MediaCodec.BufferInfo info) {         if ((info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {             mSawDecOutputEOS = true;         }         if (ENABLE_LOGS) {             Log.v(LOG_TAG, ""output: id: "" + bufferIndex + "" flags: "" + info.flags + "" size: "" +                     info.size + "" timestamp: "" + info.presentationTimeUs);         }         if (info.size > 0 && (info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) == 0) {             mDecOutputCount++;         }         mDecoder.releaseOutputBuffer(bufferIndex, mSurface != null);     }      private void dequeueEncoderOutput(int bufferIndex, MediaCodec.BufferInfo info) {         if (ENABLE_LOGS) {             Log.v(LOG_TAG, ""encoder output: id: "" + bufferIndex + "" flags: "" + info.flags +                     "" size: "" + info.size + "" timestamp: "" + info.presentationTimeUs);         }         if ((info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {             mSawEncOutputEOS = true;         }         if (info.size > 0) {             ByteBuffer buf = mEncoder.getOutputBuffer(bufferIndex);             if (mSaveToMem) {                 mOutputBuff.saveToMemory(buf, info);             }             if (mMuxer != null) {                 if (mTrackID == -1) {                     mTrackID = mMuxer.addTrack(mEncoder.getOutputFormat());                     mMuxer.start();                 }                 mMuxer.writeSampleData(mTrackID, buf, info);             }             if ((info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) == 0) {                 mOutputBuff.saveOutPTS(info.presentationTimeUs);                 mEncOutputCount++;             }         }         mEncoder.releaseOutputBuffer(bufferIndex, false);     }      private void tryEncoderOutput(long timeOutUs) throws InterruptedException {         if (mIsCodecInAsyncMode) {             if (!hasSeenError() && !mSawEncOutputEOS) {                 int retry = 0;                 while (mReviseLatency) {                     if (mAsyncHandleEncoder.hasOutputFormatChanged()) {                         mReviseLatency = false;                         int actualLatency = mAsyncHandleEncoder.getOutputFormat()                                 .getInteger(MediaFormat.KEY_LATENCY, mLatency);                         if (mLatency < actualLatency) {                             mLatency = actualLatency;                             return;                         }                     } else {                         if (retry > CodecTestBase.RETRY_LIMIT) throw new InterruptedException(                                 ""did not receive output format changed for encoder after "" +                                         CodecTestBase.Q_DEQ_TIMEOUT_US * CodecTestBase.RETRY_LIMIT +                                         "" us"");                         Thread.sleep(CodecTestBase.Q_DEQ_TIMEOUT_US / 1000);                         retry ++;                     }                 }                 Pair<Integer, MediaCodec.BufferInfo> element = mAsyncHandleEncoder.getOutput();                 if (element != null) {                     dequeueEncoderOutput(element.first, element.second);                 }             }         } else {             MediaCodec.BufferInfo outInfo = new MediaCodec.BufferInfo();             if (!mSawEncOutputEOS) {                 int outputBufferId = mEncoder.dequeueOutputBuffer(outInfo, timeOutUs);                 if (outputBufferId >= 0) {                     dequeueEncoderOutput(outputBufferId, outInfo);                 } else if (outputBufferId == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {                     mLatency = mEncoder.getOutputFormat()                             .getInteger(MediaFormat.KEY_LATENCY, mLatency);                 }             }         }     }      private void waitForAllEncoderOutputs() throws InterruptedException {         if (mIsCodecInAsyncMode) {             while (!hasSeenError() && !mSawEncOutputEOS) {                 tryEncoderOutput(CodecTestBase.Q_DEQ_TIMEOUT_US);             }         } else {             while (!mSawEncOutputEOS) {                 tryEncoderOutput(CodecTestBase.Q_DEQ_TIMEOUT_US);             }         }     }      private void queueEOS() throws InterruptedException {         if (mIsCodecInAsyncMode) {             while (!mAsyncHandleDecoder.hasSeenError() && !mSawDecInputEOS) {                 Pair<Integer, MediaCodec.BufferInfo> element = mAsyncHandleDecoder.getWork();                 if (element != null) {                     int bufferID = element.first;                     MediaCodec.BufferInfo info = element.second;                     if (info != null) {                         dequeueDecoderOutput(bufferID, info);                     } else {                         enqueueDecoderEOS(element.first);                     }                 }             }         } else if (!mSawDecInputEOS) {             enqueueDecoderEOS(mDecoder.dequeueInputBuffer(-1));         }         if (mIsCodecInAsyncMode) {             while (!hasSeenError() && !mSawDecOutputEOS) {                 Pair<Integer, MediaCodec.BufferInfo> decOp = mAsyncHandleDecoder.getOutput();                 if (decOp != null) dequeueDecoderOutput(decOp.first, decOp.second);                 if (mSawDecOutputEOS) mEncoder.signalEndOfInputStream();                 if (mDecOutputCount - mEncOutputCount > mLatency) {                     tryEncoderOutput(-1);                 }             }         } else {             MediaCodec.BufferInfo outInfo = new MediaCodec.BufferInfo();             while (!mSawDecOutputEOS) {                 int outputBufferId =                         mDecoder.dequeueOutputBuffer(outInfo, CodecTestBase.Q_DEQ_TIMEOUT_US);                 if (outputBufferId >= 0) {                     dequeueDecoderOutput(outputBufferId, outInfo);                 }                 if (mSawDecOutputEOS) mEncoder.signalEndOfInputStream();                 if (mDecOutputCount - mEncOutputCount > mLatency) {                     tryEncoderOutput(-1);                 }             }         }     }      private void doWork(int frameLimit) throws InterruptedException {         int frameCnt = 0;         if (mIsCodecInAsyncMode) {             // dequeue output after inputEOS is expected to be done in waitForAllOutputs()             while (!hasSeenError() && !mSawDecInputEOS && frameCnt < frameLimit) {                 Pair<Integer, MediaCodec.BufferInfo> element = mAsyncHandleDecoder.getWork();                 if (element != null) {                     int bufferID = element.first;                     MediaCodec.BufferInfo info = element.second;                     if (info != null) {                         // <id, info> corresponds to output callback. Handle it accordingly                         dequeueDecoderOutput(bufferID, info);                     } else {                         // <id, null> corresponds to input callback. Handle it accordingly                         enqueueDecoderInput(bufferID);                         frameCnt++;                     }                 }                 // check decoder EOS                 if (mSawDecOutputEOS) mEncoder.signalEndOfInputStream();                 // encoder output                 if (mDecOutputCount - mEncOutputCount > mLatency) {                     tryEncoderOutput(-1);                 }             }         } else {             MediaCodec.BufferInfo outInfo = new MediaCodec.BufferInfo();             while (!mSawDecInputEOS && frameCnt < frameLimit) {                 // decoder input                 int inputBufferId = mDecoder.dequeueInputBuffer(CodecTestBase.Q_DEQ_TIMEOUT_US);                 if (inputBufferId != -1) {                     enqueueDecoderInput(inputBufferId);                     frameCnt++;                 }                 // decoder output                 int outputBufferId =                         mDecoder.dequeueOutputBuffer(outInfo, CodecTestBase.Q_DEQ_TIMEOUT_US);                 if (outputBufferId >= 0) {                     dequeueDecoderOutput(outputBufferId, outInfo);                 }                 // check decoder EOS                 if (mSawDecOutputEOS) mEncoder.signalEndOfInputStream();                 // encoder output                 if (mDecOutputCount - mEncOutputCount > mLatency) {                     tryEncoderOutput(-1);                 }             }         }     }      private MediaFormat setUpEncoderFormat(MediaFormat decoderFormat) {         MediaFormat encoderFormat = new MediaFormat();         encoderFormat.setString(MediaFormat.KEY_MIME, mMime);         encoderFormat.setInteger(MediaFormat.KEY_WIDTH,                 decoderFormat.getInteger(MediaFormat.KEY_WIDTH));         encoderFormat.setInteger(MediaFormat.KEY_HEIGHT,                 decoderFormat.getInteger(MediaFormat.KEY_HEIGHT));         encoderFormat.setInteger(MediaFormat.KEY_FRAME_RATE, mFrameRate);         encoderFormat.setInteger(MediaFormat.KEY_BIT_RATE, mBitrate);         encoderFormat.setFloat(MediaFormat.KEY_I_FRAME_INTERVAL, 1.0f);         encoderFormat.setInteger(MediaFormat.KEY_COLOR_FORMAT,                 MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);         encoderFormat.setInteger(MediaFormat.KEY_MAX_B_FRAMES, mMaxBFrames);         return encoderFormat;     }      /**      * Tests listed encoder components for sync and async mode in surface mode.The output has to      * be consistent (not flaky) in all runs.      */     @LargeTest"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.appsecurity.cts.ResumeOnRebootHostTest"	"removeTestPackages"	""	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	".apk"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/ResumeOnRebootHostTest.java"	""	"/*  *.  */  package android.appsecurity.cts;  import static android.appsecurity.cts.Utils.waitForBootCompleted;  import static org.hamcrest.CoreMatchers.is; import static org.hamcrest.Matchers.greaterThan; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertThat; import static org.junit.Assert.fail;  import com.android.compatibility.common.util.HostSideTestUtils; import com.android.tradefed.device.DeviceNotAvailableException; import com.android.tradefed.log.LogUtil.CLog; import com.android.tradefed.testtype.DeviceJUnit4ClassRunner; import com.android.tradefed.testtype.junit4.BaseHostJUnit4Test;  import org.junit.After; import org.junit.Before; import org.junit.Rule; import org.junit.Test; import org.junit.runner.RunWith;  import java.util.ArrayList; import java.util.concurrent.TimeUnit;  /**  * Set of tests that verify behavior of Resume on Reboot, if supported.  * <p>  * Note that these tests drive PIN setup manually instead of relying on device  * administrators, which are not supported by all devices.  */ @RunWith(DeviceJUnit4ClassRunner.class) public class ResumeOnRebootHostTest extends BaseHostJUnit4Test {     private static final String TAG = ""ResumeOnRebootTest"";      private static final String PKG = ""com.android.cts.encryptionapp"";     private static final String CLASS = PKG + "".EncryptionAppTest"";     private static final String APK = ""CtsEncryptionApp.apk"";      private static final String OTHER_APK = ""CtsSplitApp.apk"";     private static final String OTHER_PKG = ""com.android.cts.splitapp"";      private static final String FEATURE_REBOOT_ESCROW = ""feature:android.hardware.reboot_escrow"";     private static final String FEATURE_DEVICE_ADMIN = ""feature:android.software.device_admin"";      private static final long SHUTDOWN_TIME_MS = TimeUnit.SECONDS.toMicros(30);     private static final int USER_SYSTEM = 0;      private static final long USER_SWITCH_WAIT = TimeUnit.SECONDS.toMillis(10);      private boolean mSupportsMultiUser;      @Rule     public NormalizeScreenStateRule mNoDozeRule = new NormalizeScreenStateRule(this);      @Before     public void setUp() throws Exception {         assertNotNull(getAbi());         assertNotNull(getBuild());          mSupportsMultiUser = getDevice().getMaxNumberOfUsersSupported() > 1;          removeTestPackages();     }      @After     public void tearDown() throws Exception {         removeTestPackages();     }"	""	""	""	""	""
"99:375923) 4  . Application Packaging Compatibility"	"4"	"C-0-9"	""	"android.view.cts.ViewGroupTest"	"testResetRtlProperties"	"CtsViewTestCases"	""	"4/C-0-9"	"""C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements && C-0-9] MUST support verifying .apk files using the APK Signature Scheme v4. If device implementations are already launched on an earlier Android version and cannot meet the requirements | C-0-9] through a system software update, they MAY be exempted from these requirements. <h2 id="""	""	".apk v4"	""	""	""	"v4"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/view/src/android/view/cts/ViewGroupTest.java"	""	"public void testResetRtlProperties() {         clearRtlCounters();          MockView2 v1 = new MockView2(mContext);         MockView2 v2 = new MockView2(mContext);          MockViewGroup v3 = new MockViewGroup(mContext);         MockView2 v4 = new MockView2(mContext);          v3.addView(v4);         assertEquals(1, resetRtlPropertiesCount);         assertEquals(1, resetResolvedLayoutDirectionCount);         assertEquals(1, resetResolvedTextDirectionCount);         assertEquals(1, resetResolvedTextAlignmentCount);         assertEquals(1, resetResolvedPaddingCount);         assertEquals(1, resetResolvedDrawablesCount);          clearRtlCounters();         mMockViewGroup.addView(v1);         mMockViewGroup.addView(v2);         mMockViewGroup.addView(v3);          assertEquals(3, resetRtlPropertiesCount); // for v1 / v2 / v3 only         assertEquals(4, resetResolvedLayoutDirectionCount); // for v1 / v2 / v3 / v4         assertEquals(4, resetResolvedTextDirectionCount);         assertEquals(3, resetResolvedTextAlignmentCount); // for v1 / v2 / v3 only         assertEquals(4, resetResolvedPaddingCount);         assertEquals(4, resetResolvedDrawablesCount);          clearRtlCounters();         mMockViewGroup.resetRtlProperties();         assertEquals(1, resetRtlPropertiesCount); // for mMockViewGroup only         assertEquals(5, resetResolvedLayoutDirectionCount); // for all         assertEquals(5, resetResolvedTextDirectionCount);         // for mMockViewGroup only as TextAlignment is not inherited (default is Gravity)         assertEquals(1, resetResolvedTextAlignmentCount);         assertEquals(5, resetResolvedPaddingCount);         assertEquals(5, resetResolvedDrawablesCount);     }      @UiThreadTest"	""	""	""	""	""
