"Section"	"section_id"	"req_id"	"full_key"	"key_as_number"	"requirement"	"Test Availability"	"search_roots"	"search_terms"	"manual_search_terms"	"not_search_terms"	"not_files"	"max_matches"	"class_defs"	"methods"	"modules"	"protected"	"class_def"	"method"	"module"	"file_name"	"matched_files"	"methods_string"	"urls"	"method_text"	"matched_terms"	"qualified_method"	"Annotation?"	"New Req for S?"	"New CTS for S?"	"Comment(internal) e.g. why a test is not possible"	"CTS Bug Id"	"CDD Bug Id"	"Area"	"Shortened"	"Test Level"
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.os.cts.BuildVersionTest"	"testIncremental"	""	"/home/gpoor/cts-12-source/cts/tests/tests/os/src/android/os/cts/BuildVersionTest.java"	""	"public void testIncremental() {
        assertNotEmpty(Build.VERSION.INCREMENTAL);
    }

    /**
     * Verifies {@link Build#FINGERPRINT} follows expected format:
     * <p/>
     * <code>
     * (BRAND)/(PRODUCT)/(DEVICE):(VERSION.RELEASE_OR_CODENAME)/(BUILD_ID)/
     * (BUILD_NUMBER):(BUILD_VARIANT)/(TAGS)
     * </code>
     */
    @RestrictedBuildTest"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.DevicePolicyLoggingTest"	"testSetUserRestrictionLogged"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/DevicePolicyLoggingTest.java"	""	"public void testSetUserRestrictionLogged() {
        mDevicePolicyManager.addUserRestriction(ADMIN_RECEIVER_COMPONENT,
                UserManager.DISALLOW_CONFIG_LOCATION);
        mDevicePolicyManager.clearUserRestriction(ADMIN_RECEIVER_COMPONENT,
                UserManager.DISALLOW_CONFIG_LOCATION);

        mDevicePolicyManager.addUserRestriction(ADMIN_RECEIVER_COMPONENT,
                UserManager.DISALLOW_ADJUST_VOLUME);
        mDevicePolicyManager.clearUserRestriction(ADMIN_RECEIVER_COMPONENT,
                UserManager.DISALLOW_ADJUST_VOLUME);

        mDevicePolicyManager.addUserRestriction(ADMIN_RECEIVER_COMPONENT,
                UserManager.DISALLOW_AUTOFILL);
        mDevicePolicyManager.clearUserRestriction(ADMIN_RECEIVER_COMPONENT,
                UserManager.DISALLOW_AUTOFILL);

        mDevicePolicyManager.addUserRestriction(ADMIN_RECEIVER_COMPONENT,
                UserManager.DISALLOW_CONTENT_CAPTURE);
        mDevicePolicyManager.clearUserRestriction(ADMIN_RECEIVER_COMPONENT,
                UserManager.DISALLOW_CONTENT_CAPTURE);

        mDevicePolicyManager.addUserRestriction(ADMIN_RECEIVER_COMPONENT,
                UserManager.DISALLOW_CONTENT_SUGGESTIONS);
        mDevicePolicyManager.clearUserRestriction(ADMIN_RECEIVER_COMPONENT,
                UserManager.DISALLOW_CONTENT_SUGGESTIONS);
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.server.wm.settings.SettingsSession"	"doTest"	""	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/util/src/android/server/wm/settings/SettingsSession.java"	""	"* public void doTest() throws Exception {
 *     try (final PrefSession prefSession = new PrefSession()) {
 *         prefSession.set(""value 1"");
 *         doTest1();
 *         prefSession.set(""value 2"");
 *         doTest2();
 *     }
 * }
 * </pre>
 */
public class SettingsSession<T> implements AutoCloseable {
    private static final String TAG = SettingsSession.class.getSimpleName();
    private static final boolean DEBUG = false;

    @FunctionalInterface
    public interface SettingsGetter<T> {
        T get(ContentResolver cr, String key) throws SettingNotFoundException;
    }

    @FunctionalInterface
    public interface SettingsSetter<T> {
        void set(ContentResolver cr, String key, T value);
    }

    /**
     * To debug to detect nested sessions for the same key. Enabled when {@link #DEBUG} is true.
     * Note that nested sessions can be merged into one session.
     */
    private static final SessionCounters sSessionCounters = new SessionCounters();

    protected final Uri mUri;
    protected final boolean mHasInitialValue;
    protected final T mInitialValue;
    private final SettingsGetter<T> mGetter;
    private final SettingsSetter<T> mSetter;

    public SettingsSession(final Uri uri, final SettingsGetter<T> getter,
            final SettingsSetter<T> setter) {
        mUri = uri;
        mGetter = getter;
        mSetter = setter;
        T initialValue;
        boolean hasInitialValue;
        try {
            initialValue = get(uri, getter);
            hasInitialValue = true;
        } catch (SettingNotFoundException e) {
            initialValue = null;
            hasInitialValue = false;
        }
        mInitialValue = initialValue;
        mHasInitialValue = hasInitialValue;
        if (DEBUG) {
            Log.i(TAG, ""start: uri="" + uri
                    + (mHasInitialValue ? "" value="" + mInitialValue : "" undefined""));
            sSessionCounters.open(uri);
        }
    }

    public void set(final @NonNull T value) {
        put(mUri, mSetter, value);
        if (DEBUG) {
            Log.i(TAG, ""  set: uri="" + mUri + "" value="" + value);
        }
    }

    public T get() {
        try {
            return get(mUri, mGetter);
        } catch (SettingNotFoundException e) {
            return null;
        }
    }

    @Override
    public void close() {
        if (mHasInitialValue) {
            put(mUri, mSetter, mInitialValue);
            if (DEBUG) {
                Log.i(TAG, ""close: uri="" + mUri + "" value="" + mInitialValue);
            }
        } else {
            delete(mUri);
            if (DEBUG) {
                Log.i(TAG, ""close: uri="" + mUri + "" deleted"");
            }
        }
        if (DEBUG) {
            sSessionCounters.close(mUri);
        }
    }

    private static <T> void put(final Uri uri, final SettingsSetter<T> setter, T value) {
        NestedShellPermission.run(() -> {
            setter.set(getContentResolver(), uri.getLastPathSegment(), value);
        });
    }

    private static <T> T get(final Uri uri, final SettingsGetter<T> getter)
            throws SettingNotFoundException {
        return getter.get(getContentResolver(), uri.getLastPathSegment());
    }

    public static void delete(final Uri uri) {
        final List<String> segments = uri.getPathSegments();
        if (segments.size() != 2) {
            Log.w(TAG, ""Unsupported uri for deletion: "" + uri, new Throwable());
            return;
        }
        final String namespace = segments.get(0);
        final String key = segments.get(1);
        // SystemUtil.runWithShellPermissionIdentity (only applies to the permission checking in
        // package manager and appops) does not change calling uid which is enforced in
        // SettingsProvider for deletion, so it requires shell command to pass the restriction.
        SystemUtil.runShellCommand(""settings delete "" + namespace + "" "" + key);
    }

    private static ContentResolver getContentResolver() {
        return getInstrumentation().getTargetContext().getContentResolver();
    }

    private static class SessionCounters {
        private final Map<Uri, Integer> mOpenSessions = new HashMap<>();

        void open(final Uri uri) {
            final Integer count = mOpenSessions.get(uri);
            if (count == null) {
                mOpenSessions.put(uri, 1);
                return;
            }
            mOpenSessions.put(uri, count + 1);
            Log.w(TAG, ""Open nested session for "" + uri, new Throwable());
        }

        void close(final Uri uri) {
            final int count = mOpenSessions.get(uri);
            if (count == 1) {
                mOpenSessions.remove(uri);
                return;
            }
            mOpenSessions.put(uri, count - 1);
            Log.w(TAG, ""Close nested session for "" + uri, new Throwable());
        }
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.app.cts.NotificationManagerTest"	"testDeleteConversationChannels"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/NotificationManagerTest.java"	""	"public void testDeleteConversationChannels() throws Exception {
        setUpNotifListener();

        createDynamicShortcut();

        final NotificationChannel channel =
                new NotificationChannel(mId, ""Messages"", IMPORTANCE_DEFAULT);

        final NotificationChannel conversationChannel =
                new NotificationChannel(mId + ""child"",
                        ""Messages from "" + SHARE_SHORTCUT_ID, IMPORTANCE_DEFAULT);
        conversationChannel.setConversationId(channel.getId(), SHARE_SHORTCUT_ID);

        mNotificationManager.createNotificationChannel(channel);
        mNotificationManager.createNotificationChannel(conversationChannel);

        mNotificationManager.notify(177, getConversationNotification().build());

        if (!checkNotificationExistence(177, /*shouldExist=*/ true)) {
            fail(""couldn't find posted notification id="" + 177);
        }
        Thread.sleep(500); // wait for notification listener to receive notification
        assertEquals(1, mListener.mPosted.size());

        deleteShortcuts();

        Thread.sleep(300); // wait for deletion to propagate

        assertFalse(mNotificationManager.getNotificationChannel(channel.getId(),
                conversationChannel.getConversationId()).isConversation());

    }

    /**
     * This method verifies that an app can't bypass background restrictions by retrieving their own
     * notification and triggering it.
     */"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.vpn.VpnTestHelper"	"register"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/vpn/VpnTestHelper.java"	""	"public void test/*
 *.
 */

package com.android.cts.deviceandprofileowner.vpn;

import static android.system.OsConstants.AF_INET;
import static android.system.OsConstants.IPPROTO_ICMP;
import static android.system.OsConstants.POLLIN;
import static android.system.OsConstants.SOCK_DGRAM;

import static junit.framework.Assert.assertEquals;
import static junit.framework.Assert.assertNotNull;
import static junit.framework.Assert.assertTrue;
import static junit.framework.Assert.fail;

import android.annotation.TargetApi;
import android.app.admin.DevicePolicyManager;
import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageManager;
import android.net.ConnectivityManager;
import android.net.Network;
import android.net.NetworkCapabilities;
import android.net.NetworkInfo;
import android.os.Build.VERSION_CODES;
import android.system.ErrnoException;
import android.system.Os;
import android.system.StructPollfd;

import com.android.compatibility.common.util.BlockingBroadcastReceiver;
import com.android.cts.deviceandprofileowner.BaseDeviceAdminTest;

import java.io.ByteArrayOutputStream;
import java.io.DataOutputStream;
import java.io.FileDescriptor;
import java.io.IOException;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.util.Arrays;
import java.util.Collections;
import java.util.Set;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * Helper class to test vpn status
 */
@TargetApi(VERSION_CODES.N)
public class VpnTestHelper {
    public static final String VPN_PACKAGE = ""com.android.cts.vpnfirewall"";
    private static final String MY_PACKAGE = ""com.android.cts.deviceandprofileowner"";
    // Broadcast by ReflectorVpnService when the interface is up.
    private static final String ACTION_VPN_IS_UP = VPN_PACKAGE + "".VPN_IS_UP"";
    // Broadcast by ReflectorVpnService receives onStartCommand and queried app restrictions.
    private static final String ACTION_VPN_ON_START = VPN_PACKAGE + "".VPN_ON_START"";

    // IP address reserved for documentation by rfc5737
    public static final String TEST_ADDRESS = ""192.0.2.4"";

    private static final String EXTRA_ALWAYS_ON = ""always-on"";
    private static final String EXTRA_LOCKDOWN = ""lockdown"";

    // HACK (TODO issue 31585407) to wait for the network to actually be usable
    private static final int NETWORK_SETTLE_GRACE_MS = 200;

    private static final int SOCKET_TIMEOUT_MS = 5000;
    private static final int ICMP_ECHO_REQUEST = 0x08;
    private static final int ICMP_ECHO_REPLY = 0x00;
    private static final int NETWORK_TIMEOUT_MS = 5000;
    private static final ComponentName ADMIN_RECEIVER_COMPONENT =
            BaseDeviceAdminTest.ADMIN_RECEIVER_COMPONENT;

    public static BlockingBroadcastReceiver registerOnStartReceiver(Context context) {
        final BlockingBroadcastReceiver receiver =
                new BlockingBroadcastReceiver(context, ACTION_VPN_ON_START);
        receiver.register();
        return receiver;
    }

    /**
     * Wait for a VPN app to establish VPN.
     *
     * @param context Caller's context.
     * @param packageName {@code null} if waiting for the existing VPN to connect. Otherwise we set
     *         this package as the new always-on VPN app and wait for it to connect.
     * @param lockdown Disallow connectivity while VPN is down.
     * @param usable Whether the resulting VPN tunnel is expected to be usable.
     * @param excludeFromLockdown whether to exclude current package from lockdown.
     */
    public static void waitForVpn(Context context, String packageName, boolean usable,
            boolean lockdown, boolean excludeFromLockdown) {
        final DevicePolicyManager dpm = context.getSystemService(DevicePolicyManager.class);
        if (packageName == null) {
            assertNotNull(dpm.getAlwaysOnVpnPackage(ADMIN_RECEIVER_COMPONENT));
        }

        ConnectivityManager cm = context.getSystemService(ConnectivityManager.class);
        final CountDownLatch vpnLatch = new CountDownLatch(1);
        final IntentFilter intentFilter = new IntentFilter(ACTION_VPN_IS_UP);
        final AtomicBoolean isAlwaysOn = new AtomicBoolean();
        final AtomicBoolean isLockdown = new AtomicBoolean();
        final BroadcastReceiver receiver = new BroadcastReceiver() {
                @Override
                public void onReceive(final Context context, final Intent intent) {
                    if (!intent.getPackage().equals(MY_PACKAGE)) return;
                    isAlwaysOn.set(intent.getBooleanExtra(EXTRA_ALWAYS_ON, false));
                    isLockdown.set(intent.getBooleanExtra(EXTRA_LOCKDOWN, !lockdown));
                    vpnLatch.countDown();
                    context.unregisterReceiver(this);
                }
            };
        context.registerReceiver(receiver, intentFilter);

        try {
            if (packageName != null) {
                setAlwaysOnVpn(context, packageName, lockdown, excludeFromLockdown);
            }
            if (!vpnLatch.await(NETWORK_TIMEOUT_MS, TimeUnit.MILLISECONDS)) {
                if (!isNetworkVpn(context)) {
                    fail(""Took too long waiting to establish a VPN-backed connection"");
                }
            } else {
                assertTrue(""Wrong VpnService#isAlwaysOn()"", isAlwaysOn.get());
                assertEquals(""Wrong VpnService#isLockdownEnabled()"", lockdown, isLockdown.get());
            }
            Thread.sleep(NETWORK_SETTLE_GRACE_MS);
        } catch (InterruptedException | PackageManager.NameNotFoundException e) {
            fail(""Failed while waiting for VPN: "" + e);
        }

        // Do we have a network?
        NetworkInfo vpnInfo = cm.getNetworkInfo(ConnectivityManager.TYPE_VPN);
        assertNotNull(vpnInfo);

        // Is it usable?
        assertEquals(usable, vpnInfo.isConnected());
    }

    public static void setAlwaysOnVpn(
            Context context, String packageName, boolean lockdown, boolean excludeFromLockdown)
            throws PackageManager.NameNotFoundException {
        final DevicePolicyManager dpm = context.getSystemService(DevicePolicyManager.class);
        final Set<String> lockdownAllowlist;
        if (lockdown) {
            lockdownAllowlist = excludeFromLockdown ?
                    Collections.singleton(context.getPackageName()) : Collections.emptySet();
        } else {
            lockdownAllowlist = null;
        }
        dpm.setAlwaysOnVpnPackage(
                ADMIN_RECEIVER_COMPONENT, packageName, lockdown, lockdownAllowlist);
        assertEquals(packageName, dpm.getAlwaysOnVpnPackage(ADMIN_RECEIVER_COMPONENT));
        assertEquals(lockdown, dpm.isAlwaysOnVpnLockdownEnabled(ADMIN_RECEIVER_COMPONENT));
        assertEquals(lockdownAllowlist,
                dpm.getAlwaysOnVpnLockdownWhitelist(ADMIN_RECEIVER_COMPONENT));
    }

    public static boolean isNetworkVpn(Context context) {
        ConnectivityManager connectivityManager =
                (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
        Network network = connectivityManager.getActiveNetwork();
        NetworkCapabilities capabilities = connectivityManager.getNetworkCapabilities(network);
        return capabilities != null && capabilities.hasTransport(NetworkCapabilities.TRANSPORT_VPN);
    }

    public static void checkPing(String host) throws ErrnoException, IOException {
        FileDescriptor socket = Os.socket(AF_INET, SOCK_DGRAM, IPPROTO_ICMP);

        // Create an ICMP message
        final int identifier = 0x7E57;
        final String message = ""test packet"";
        byte[] echo = createIcmpMessage(ICMP_ECHO_REQUEST, 0x00, identifier, 0, message.getBytes());

        // Send the echo packet.
        int port = new InetSocketAddress(0).getPort();
        Os.connect(socket, InetAddress.getByName(host), port);
        Os.write(socket, echo, 0, echo.length);

        // Expect a reply.
        StructPollfd pollfd = new StructPollfd();
        pollfd.events = (short) POLLIN;
        pollfd.fd = socket;
        int ret = Os.poll(new StructPollfd[] { pollfd }, SOCKET_TIMEOUT_MS);
        assertEquals(""Expected reply after sending ping"", 1, ret);

        byte[] reply = new byte[echo.length];
        int read = Os.read(socket, reply, 0, echo.length);
        assertEquals(echo.length, read);

        // Ignore control type differences since echo=8, reply=0.
        assertEquals(echo[0], ICMP_ECHO_REQUEST);
        assertEquals(reply[0], ICMP_ECHO_REPLY);
        echo[0] = 0;
        reply[0] = 0;

        // Fix ICMP ID which kernel will have changed on the way out.
        InetSocketAddress local = (InetSocketAddress) Os.getsockname(socket);
        port = local.getPort();
        echo[4] = (byte) ((port >> 8) & 0xFF);
        echo[5] = (byte) (port & 0xFF);

        // Ignore checksum differences since the types are not supposed to match.
        echo[2] = echo[3] = 0;
        reply[2] = reply[3] = 0;

        assertTrue(""Packet contents do not match.""
                + ""\nEcho packet:  "" + Arrays.toString(echo)
                + ""\nReply packet: "" + Arrays.toString(reply), Arrays.equals(echo, reply));

        // Close socket if the test pass. Otherwise, any error will kill the process.
        Os.close(socket);
    }

    public static void tryPosixConnect(String host) throws ErrnoException, IOException {
        FileDescriptor socket = null;
        try {
            socket = Os.socket(AF_INET, SOCK_DGRAM, IPPROTO_ICMP);
            int port = new InetSocketAddress(0).getPort();
            Os.connect(socket, InetAddress.getByName(host), port);
        } finally {
            if (socket != null) {
                Os.close(socket);
            }
        }
    }

    private static byte[] createIcmpMessage(int type, int code, int extra1, int extra2,
            byte[] data) throws IOException {
        ByteArrayOutputStream output = new ByteArrayOutputStream();
        DataOutputStream stream = new DataOutputStream(output);
        stream.writeByte(type);
        stream.writeByte(code);
        stream.writeShort(/* checksum */ 0);
        stream.writeShort((short) extra1);
        stream.writeShort((short) extra2);
        stream.write(data, 0, data.length);
        return output.toByteArray();
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.permission2.cts.RestrictedStoragePermissionSharedUidTest"	"getTestAppCombinations"	"CtsPermission2TestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedStoragePermissionSharedUidTest.java"	""	"/*
 *.
 */

package android.permission2.cts;

import static android.Manifest.permission.READ_EXTERNAL_STORAGE;
import static android.app.AppOpsManager.MODE_ALLOWED;
import static android.app.AppOpsManager.OPSTR_LEGACY_STORAGE;
import static android.permission.cts.PermissionUtils.isGranted;
import static android.permission2.cts.RestrictedStoragePermissionSharedUidTest.StorageState.DENIED;
import static android.permission2.cts.RestrictedStoragePermissionSharedUidTest.StorageState.ISOLATED;
import static android.permission2.cts.RestrictedStoragePermissionSharedUidTest.StorageState.NON_ISOLATED;

import static com.android.compatibility.common.util.SystemUtil.eventually;
import static com.android.compatibility.common.util.SystemUtil.runShellCommand;
import static com.android.compatibility.common.util.SystemUtil.runWithShellPermissionIdentity;

import static com.google.common.truth.Truth.assertWithMessage;

import static java.lang.Integer.min;

import android.app.AppOpsManager;
import android.content.Context;
import android.content.pm.PackageManager;
import android.os.Build;
import android.platform.test.annotations.AppModeFull;
import android.util.Log;

import androidx.annotation.NonNull;
import androidx.test.platform.app.InstrumentationRegistry;

import org.junit.After;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;
import org.junit.runners.Parameterized.Parameter;
import org.junit.runners.Parameterized.Parameters;

import java.util.ArrayList;

@AppModeFull(reason = ""Instant apps cannot access other app's properties"")
@RunWith(Parameterized.class)
public class RestrictedStoragePermissionSharedUidTest {
    private static final String LOG_TAG =
            RestrictedStoragePermissionSharedUidTest.class.getSimpleName();

    public enum StorageState {
        /** The app has non-isolated storage */
        NON_ISOLATED,

        /** The app has isolated storage */
        ISOLATED,

        /** The read-external-storage permission cannot be granted */
        DENIED
    }

    /**
     * An app that is tested
     */
    private static class TestApp {
        private static @NonNull Context sContext =
                InstrumentationRegistry.getInstrumentation().getContext();
        private static @NonNull AppOpsManager sAppOpsManager =
                sContext.getSystemService(AppOpsManager.class);
        private static @NonNull PackageManager sPackageManager = sContext.getPackageManager();

        private final String mApk;
        private final String mPkg;

        public final boolean isRestricted;
        public final boolean hasRequestedLegacyExternalStorage;

        TestApp(@NonNull String apk, @NonNull String pkg, boolean isRestricted,
                @NonNull boolean hasRequestedLegacyExternalStorage) {
            mApk = apk;
            mPkg = pkg;

            this.isRestricted = isRestricted;
            this.hasRequestedLegacyExternalStorage = hasRequestedLegacyExternalStorage;
        }

        /**
         * Assert that the read-external-storage permission was granted or not granted.
         *
         * @param expectGranted {@code true} if the permission is expected to be granted
         */
        void assertStoragePermGranted(boolean expectGranted) {
            eventually(() -> assertWithMessage(this + "" read storage granted"").that(
                    isGranted(mPkg, READ_EXTERNAL_STORAGE)).isEqualTo(expectGranted));
        }

        /**
         * Assert that the app has non-isolated storage
         *
         * @param expectGranted {@code true} if the app is expected to have non-isolated storage
         */
        void assertHasNotIsolatedStorage(boolean expectHasNotIsolatedStorage) {
            eventually(() -> runWithShellPermissionIdentity(() -> {
                int uid = sContext.getPackageManager().getPackageUid(mPkg, 0);
                if (expectHasNotIsolatedStorage) {
                    assertWithMessage(this + "" legacy storage mode"").that(
                            sAppOpsManager.unsafeCheckOpRawNoThrow(OPSTR_LEGACY_STORAGE, uid,
                            mPkg)).isEqualTo(MODE_ALLOWED);
                } else {
                    assertWithMessage(this + "" legacy storage mode"").that(
                            sAppOpsManager.unsafeCheckOpRawNoThrow(OPSTR_LEGACY_STORAGE, uid,
                            mPkg)).isNotEqualTo(MODE_ALLOWED);
                }
            }));
        }

        int getTargetSDK() throws Exception {
            return sPackageManager.getApplicationInfo(mPkg, 0).targetSdkVersion;
        }

        void install() {
            if (isRestricted) {
                runShellCommand(""pm install -g --force-queryable --restrict-permissions "" + mApk);
            } else {
                runShellCommand(""pm install -g --force-queryable "" + mApk);
            }
        }

        void uninstall() {
            runShellCommand(""pm uninstall "" + mPkg);
        }

        @Override
        public String toString() {
            return mPkg.substring(PKG_PREFIX.length());
        }
    }

    /**
     * Placeholder for ""no app"". The properties are chosen that when combined with another app, the
     * other app always decides the resulting property,
     */
    private static class NoApp extends TestApp {
        NoApp() {
            super("""", PKG_PREFIX + ""(none)"", true, false);
        }

        void assertStoragePermGranted(boolean ignored) {
            // empty
        }

        void assertHasNotIsolatedStorage(boolean ignored) {
            // empty
        }

        @Override
        int getTargetSDK() {
            return 10000;
        }

        @Override
        public void install() {
            // empty
        }

        @Override
        public void uninstall() {
            // empty
        }
    }

    private static final String APK_PATH = ""/data/local/tmp/cts/permissions2/"";
    private static final String PKG_PREFIX = ""android.permission2.cts.legacystoragewithshareduid."";

    private static final TestApp[] TEST_APPS = new TestApp[]{
            new TestApp(APK_PATH + ""CtsLegacyStorageNotIsolatedWithSharedUid.apk"",
                    PKG_PREFIX + ""notisolated"", false, true),
            new TestApp(APK_PATH + ""CtsLegacyStorageIsolatedWithSharedUid.apk"",
                    PKG_PREFIX + ""isolated"", false, false),
            new TestApp(APK_PATH + ""CtsLegacyStorageRestrictedWithSharedUid.apk"",
                    PKG_PREFIX + ""restricted"", true, false),
            new TestApp(APK_PATH + ""CtsLegacyStorageRestrictedSdk28WithSharedUid.apk"",
                    PKG_PREFIX + ""restrictedsdk28"", true, true),
            new NoApp()};

    /**
     * First app to be tested. This is the first in an entry created by {@link
     * #getTestAppCombinations}
     */
    @Parameter(0)
    public @NonNull TestApp app1;

    /**
     * Second app to be tested. This is the second in an entry created by {@link
     * #getTestAppCombinations}
     */
    @Parameter(1)
    public @NonNull TestApp app2;

    /**
     * Run this test for all combination of two tests-apps out of {@link #TEST_APPS}. This includes
     * the {@link NoApp}, i.e. we also test a single test-app by itself.
     *
     * @return All combinations of two test-apps
     */
    @Parameters(name = ""{0} and {1}"")
    public static Iterable<Object[]> getTestAppCombinations() {
        ArrayList<Object[]> parameters = new ArrayList<>();

        for (int firstApp = 0; firstApp < TEST_APPS.length; firstApp++) {
            for (int secondApp = firstApp + 1; secondApp < TEST_APPS.length; secondApp++) {
                parameters.add(new Object[]{TEST_APPS[firstApp], TEST_APPS[secondApp]});
            }
        }

        return parameters;
    }"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.permission2.cts.RestrictedStoragePermissionSharedUidTest"	"uninstallAllTestPackages"	"CtsPermission2TestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedStoragePermissionSharedUidTest.java"	""	"public void checkExceptedStorageStateForAppsSharingUid() throws Exception {
        app1.install();
        app2.install();

        int targetSDK = min(app1.getTargetSDK(), app2.getTargetSDK());
        boolean isRestricted = app1.isRestricted && app2.isRestricted;
        boolean hasRequestedLegacyExternalStorage =
                app1.hasRequestedLegacyExternalStorage || app2.hasRequestedLegacyExternalStorage;

        StorageState expectedState;
        if (isRestricted) {
            if (targetSDK < Build.VERSION_CODES.Q) {
                expectedState = DENIED;
            } else {
                expectedState = ISOLATED;
            }
        } else if (hasRequestedLegacyExternalStorage && targetSDK <= Build.VERSION_CODES.Q) {
            expectedState = NON_ISOLATED;
        } else {
            expectedState = ISOLATED;
        }

        Log.i(LOG_TAG, ""Expected state="" + expectedState);

        app1.assertStoragePermGranted(expectedState != DENIED);
        app2.assertStoragePermGranted(expectedState != DENIED);

        if (expectedState != DENIED) {
            app1.assertHasNotIsolatedStorage(expectedState == NON_ISOLATED);
            app2.assertHasNotIsolatedStorage(expectedState == NON_ISOLATED);
        }
    }

    @After
    public void uninstallAllTestPackages() {
        app1.uninstall();
        app2.uninstall();
    }
}"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.car.cts.CarUxRestrictionsManagerTest"	"testCarUxRestrictionsBuilder"	"CtsCarTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/car/src/android/car/cts/CarUxRestrictionsManagerTest.java"	""	"public void testCarUxRestrictionsBuilder() {
        int maxContentDepth = 1;
        int maxCumulativeContentItems = 2;
        int maxStringLength = 3;
        CarUxRestrictions.Builder builder = new CarUxRestrictions.Builder(
                true, CarUxRestrictions.UX_RESTRICTIONS_FULLY_RESTRICTED, 0L);
        builder.setMaxContentDepth(maxContentDepth);
        builder.setMaxCumulativeContentItems(maxCumulativeContentItems);
        builder.setMaxStringLength(maxStringLength);

        CarUxRestrictions restrictions = builder.build();

        assertTrue(restrictions.toString(),
                restrictions.isRequiresDistractionOptimization());
        assertEquals(restrictions.toString(),
                restrictions.getActiveRestrictions(),
                CarUxRestrictions.UX_RESTRICTIONS_FULLY_RESTRICTED);
        assertEquals(restrictions.toString(),
                restrictions.getMaxContentDepth(), maxContentDepth);
        assertEquals(restrictions.toString(),
                restrictions.getMaxCumulativeContentItems(), maxCumulativeContentItems);
        assertEquals(restrictions.toString(),
                restrictions.getMaxRestrictedStringLength(), maxStringLength);
    }"	""	""	"restricted restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.car.cts.CarUxRestrictionsManagerTest"	"testCarUxRestrictions_CopyConstructor"	"CtsCarTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/car/src/android/car/cts/CarUxRestrictionsManagerTest.java"	""	"public void testCarUxRestrictions_CopyConstructor() {
        int maxContentDepth = 1;
        int maxCumulativeContentItems = 2;
        int maxStringLength = 3;
        CarUxRestrictions.Builder builder = new CarUxRestrictions.Builder(
                true, CarUxRestrictions.UX_RESTRICTIONS_FULLY_RESTRICTED, 1L);
        builder.setMaxContentDepth(maxContentDepth);
        builder.setMaxCumulativeContentItems(maxCumulativeContentItems);
        builder.setMaxStringLength(maxStringLength);

        CarUxRestrictions restrictions = builder.build();
        CarUxRestrictions copyOfRestrictions = new CarUxRestrictions(restrictions);

        assertTrue(copyOfRestrictions.toString(),
                copyOfRestrictions.isRequiresDistractionOptimization());
        assertEquals(copyOfRestrictions.toString(),
                copyOfRestrictions.getActiveRestrictions(),
                CarUxRestrictions.UX_RESTRICTIONS_FULLY_RESTRICTED);
        assertEquals(copyOfRestrictions.toString(),
                copyOfRestrictions.getMaxContentDepth(), maxContentDepth);
        assertEquals(copyOfRestrictions.toString(),
                copyOfRestrictions.getMaxCumulativeContentItems(), maxCumulativeContentItems);
        assertEquals(copyOfRestrictions.toString(),
                copyOfRestrictions.getMaxRestrictedStringLength(), maxStringLength);
    }"	""	""	"restricted restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.car.cts.CarUxRestrictionsManagerTest"	"testCarUxRestrictions_isSameRestrictions"	"CtsCarTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/car/src/android/car/cts/CarUxRestrictionsManagerTest.java"	""	"public void testCarUxRestrictions_isSameRestrictions() {
        CarUxRestrictions.Builder oneBuilder = new CarUxRestrictions.Builder(
                true, CarUxRestrictions.UX_RESTRICTIONS_FULLY_RESTRICTED, 0L);
        CarUxRestrictions.Builder anotherBuilder = new CarUxRestrictions.Builder(
                true, CarUxRestrictions.UX_RESTRICTIONS_FULLY_RESTRICTED, 0L);

        assertTrue(oneBuilder.build().isSameRestrictions(anotherBuilder.build()));
    }"	""	""	"restricted restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.car.cts.CarUxRestrictionsManagerTest"	"testRegisterListener_noCrash"	"CtsCarTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/car/src/android/car/cts/CarUxRestrictionsManagerTest.java"	""	"public void testRegisterListener_noCrash() {
        mManager.registerListener(restrictions -> {});
        mManager.unregisterListener();
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.apprestrictions.targetapp.ApplicationRestrictionsActivity"	"finish"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/AppRestrictionsTargetApp/src/com/android/cts/apprestrictions/targetapp/ApplicationRestrictionsActivity.java"	""	"public void test/*
 *.
 */
package com.android.cts.apprestrictions.targetapp;

import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.os.Process;
import android.os.UserManager;
import android.util.Log;

import com.android.bedstead.dpmwrapper.IpcBroadcastReceiver;
import com.android.bedstead.dpmwrapper.TestAppSystemServiceFactory;

/**
 * Test activity for {@link android.app.admin.DevicePolicyManager#setApplicationRestrictions}.
 *
 * The actual test will set restrictions for this package, and the purpose of this
 * activity is to retrieve those restrictions and relay them back to the test for validation.
 */
public class ApplicationRestrictionsActivity extends Activity {

    private static final String TAG = ApplicationRestrictionsActivity.class.getSimpleName();

    private static final String ACTION_RESTRICTIONS_VALUE =
            ""com.android.cts.apprestrictions.targetapp.RESTRICTIONS_VALUE"";

    private UserManager mUserManager;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        mUserManager = TestAppSystemServiceFactory.getUserManager(this,
                IpcBroadcastReceiver.class);

        handleIntent(getIntent());
    }

    @Override
    protected void onNewIntent(Intent intent) {
        super.onNewIntent(intent);
        handleIntent(intent);
    }

    private void handleIntent(Intent intent) {
        Bundle restrictions = mUserManager.getApplicationRestrictions(getPackageName());
        Log.d(TAG, ""restrictions on user "" + Process.myUid() + "" and "" + mUserManager + "": ""
                + restrictions);
        sendBroadcast(new Intent(ACTION_RESTRICTIONS_VALUE)
                .addFlags(Intent.FLAG_RECEIVER_FOREGROUND)
                .putExtra(""value"", restrictions));

        finish();
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.managedprovisioning.DeviceAdminTestReceiver"	"isHeadlessSystemUserMode"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/managedprovisioning/DeviceAdminTestReceiver.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.managedprovisioning;

import static android.app.admin.DevicePolicyManager.EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE;

import android.app.Service;
import android.app.admin.DeviceAdminReceiver;
import android.app.admin.DevicePolicyManager;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.ServiceConnection;
import android.content.pm.PackageManager;
import android.os.IBinder;
import android.os.PersistableBundle;
import android.os.Process;
import android.os.RemoteException;
import android.os.UserHandle;
import android.os.UserManager;
import android.util.Log;

import androidx.localbroadcastmanager.content.LocalBroadcastManager;

import com.android.bedstead.dpmwrapper.DeviceOwnerHelper;
import com.android.compatibility.common.util.enterprise.DeviceAdminReceiverUtils;
import com.android.cts.verifier.R;

import java.util.Collections;
import java.util.HashSet;
import java.util.Set;
import java.util.function.Consumer;

/**
 * Profile owner receiver for BYOD flow test.
 * Setup cross-profile intent filter after successful provisioning.
 */
public class DeviceAdminTestReceiver extends DeviceAdminReceiver {
    public static final String KEY_BUNDLE_WIPE_IMMEDIATELY = ""wipe_immediately"";
    private static final String TAG = ""DeviceAdminTestReceiver"";
    private static final String DEVICE_OWNER_PKG =
            ""com.android.cts.verifier"";
    private static final String ADMIN_RECEIVER_TEST_CLASS =
            DEVICE_OWNER_PKG + "".managedprovisioning.DeviceAdminTestReceiver"";
    private static final ComponentName RECEIVER_COMPONENT_NAME = new ComponentName(
            DEVICE_OWNER_PKG, ADMIN_RECEIVER_TEST_CLASS);
    public static final String EXTRA_MANAGED_USER_TEST =
            ""com.android.cts.verifier.managedprovisioning.extra.MANAGED_USER_TEST"";
    public static final String EXTRA_LOGOUT_ON_START =
            ""com.android.cts.verifier.managedprovisioning.extra.LOGOUT_ON_START"";
    public static final String AFFILIATION_ID = ""affiliationId"";

    public static ComponentName getReceiverComponentName() {
        return RECEIVER_COMPONENT_NAME;
    }

    @Override
    public void onReceive(Context context, Intent intent) {
        if (DeviceAdminReceiverUtils.disableSelf(context, intent)) return;
        if (DeviceOwnerHelper.runManagerMethod(this, context, intent)) return;

        String action = intent.getAction();
        Log.d(TAG, ""onReceive(): user="" + UserHandle.myUserId() + "", action="" + action);

        // Must set affiliation on headless system user, otherwise some operations in the current
        // user (which is PO) won't be allowed (like uininstalling a package)
        if (ACTION_DEVICE_ADMIN_ENABLED.equals(action) && UserManager.isHeadlessSystemUserMode()) {
            Set<String> ids = new HashSet<>();
            ids.add(""affh!"");
            Log.i(TAG, ""Setting affiliation ids to "" + ids);
            getManager(context).setAffiliationIds(getWho(context), ids);
        }

        super.onReceive(context, intent);
    }

    @Override
    public void onProfileProvisioningComplete(Context context, Intent intent) {
        Log.d(TAG, ""Provisioning complete intent received"");
        setupProfile(context);
        wipeIfNecessary(context, intent);
    }

    @Override
    public void onBugreportSharingDeclined(Context context, Intent intent) {
        Log.i(TAG, ""Bugreport sharing declined"");
        Utils.showBugreportNotification(context, context.getString(
                R.string.bugreport_sharing_declined), Utils.BUGREPORT_NOTIFICATION_ID);
    }

    @Override
    public void onBugreportShared(Context context, Intent intent, String bugreportFileHash) {
        Log.i(TAG, ""Bugreport shared"");
        Utils.showBugreportNotification(context, context.getString(
                R.string.bugreport_shared_successfully), Utils.BUGREPORT_NOTIFICATION_ID);
    }

    @Override
    public void onBugreportFailed(Context context, Intent intent, int failureCode) {
        Log.i(TAG, ""Bugreport collection operation failed, code: "" + failureCode);
        Utils.showBugreportNotification(context, context.getString(
                R.string.bugreport_failed_completing), Utils.BUGREPORT_NOTIFICATION_ID);
    }

    @Override
    public void onLockTaskModeEntering(Context context, Intent intent, String pkg) {
        Log.i(TAG, ""Entering LockTask mode: "" + pkg);
        LocalBroadcastManager.getInstance(context)
                .sendBroadcast(new Intent(LockTaskUiTestActivity.ACTION_LOCK_TASK_STARTED));
    }

    @Override
    public void onLockTaskModeExiting(Context context, Intent intent) {
        Log.i(TAG, ""Exiting LockTask mode"");
        LocalBroadcastManager.getInstance(context)
                .sendBroadcast(new Intent(LockTaskUiTestActivity.ACTION_LOCK_TASK_STOPPED));
    }

    @Override
    public void onEnabled(Context context, Intent intent) {
        Log.i(TAG, ""Device admin enabled"");
        if (intent.getBooleanExtra(EXTRA_MANAGED_USER_TEST, false)) {
            DevicePolicyManager dpm = context.getSystemService(DevicePolicyManager.class);
            ComponentName admin = getReceiverComponentName();
            dpm.setAffiliationIds(admin,
                    Collections.singleton(DeviceAdminTestReceiver.AFFILIATION_ID));
            context.startActivity(
                    new Intent(context, ManagedUserPositiveTestActivity.class).setFlags(
                            Intent.FLAG_ACTIVITY_NEW_TASK));

            bindPrimaryUserService(context, iCrossUserService -> {
                try {
                    UserHandle userHandle = Process.myUserHandle();
                    Log.d(TAG, ""calling switchUser("" + userHandle + "")"");
                    iCrossUserService.switchUser(userHandle);
                } catch (RemoteException re) {
                    Log.e(TAG, ""Error when calling primary user"", re);
                }
            });
        } else if (intent.getBooleanExtra(EXTRA_LOGOUT_ON_START, false)) {
            DevicePolicyManager dpm = context.getSystemService(DevicePolicyManager.class);
            ComponentName admin = getReceiverComponentName();
            dpm.setAffiliationIds(admin,
                    Collections.singleton(DeviceAdminTestReceiver.AFFILIATION_ID));
            dpm.logoutUser(admin);
        }
    }

    private void setupProfile(Context context) {
        DevicePolicyManager dpm = (DevicePolicyManager) context.getSystemService(Context.DEVICE_POLICY_SERVICE);
        dpm.setProfileEnabled(new ComponentName(context.getApplicationContext(), getClass()));

        // Setup cross-profile intent filter to allow communications between the two versions of CtsVerifier
        // Primary -> work direction
        IntentFilter filter = new IntentFilter();
        filter.addAction(ByodHelperActivity.ACTION_QUERY_PROFILE_OWNER);
        filter.addAction(ByodHelperActivity.ACTION_REMOVE_MANAGED_PROFILE);
        filter.addAction(ByodHelperActivity.ACTION_CHECK_DISK_ENCRYPTION);
        filter.addAction(ByodHelperActivity.ACTION_INSTALL_APK);
        filter.addAction(ByodHelperActivity.ACTION_INSTALL_APK_WORK_PROFILE_GLOBAL_RESTRICTION);
        filter.addAction(ByodHelperActivity.ACTION_INSTALL_APK_PRIMARY_PROFILE_GLOBAL_RESTRICTION);
        filter.addAction(ByodHelperActivity.ACTION_CHECK_INTENT_FILTERS);
        filter.addAction(ByodHelperActivity.ACTION_CAPTURE_AND_CHECK_IMAGE);
        filter.addAction(ByodHelperActivity.ACTION_CAPTURE_AND_CHECK_VIDEO_WITH_EXTRA_OUTPUT);
        filter.addAction(ByodHelperActivity.ACTION_CAPTURE_AND_CHECK_VIDEO_WITHOUT_EXTRA_OUTPUT);
        filter.addAction(ByodHelperActivity.ACTION_CAPTURE_AND_CHECK_AUDIO);
        filter.addAction(ByodHelperActivity.ACTION_KEYGUARD_DISABLED_FEATURES);
        filter.addAction(ByodHelperActivity.ACTION_LOCKNOW);
        filter.addAction(ByodHelperActivity.ACTION_TEST_NFC_BEAM);
        filter.addAction(ByodHelperActivity.ACTION_TEST_CROSS_PROFILE_INTENTS_DIALOG);
        filter.addAction(ByodHelperActivity.ACTION_TEST_APP_LINKING_DIALOG);
        filter.addAction(ByodHelperActivity.ACTION_NOTIFICATION);
        filter.addAction(ByodHelperActivity.ACTION_NOTIFICATION_ON_LOCKSCREEN);
        filter.addAction(ByodHelperActivity.ACTION_CLEAR_NOTIFICATION);
        filter.addAction(ByodHelperActivity.ACTION_SET_USER_RESTRICTION);
        filter.addAction(ByodHelperActivity.ACTION_CLEAR_USER_RESTRICTION);
        filter.addAction(CrossProfileTestActivity.ACTION_CROSS_PROFILE_TO_WORK);
        filter.addAction(WorkStatusTestActivity.ACTION_WORK_STATUS_TOAST);
        filter.addAction(WorkStatusTestActivity.ACTION_WORK_STATUS_ICON);
        filter.addAction(
                PermissionLockdownTestActivity.ACTION_MANAGED_PROFILE_CHECK_PERMISSION_LOCKDOWN);
        filter.addAction(AuthenticationBoundKeyTestActivity.ACTION_AUTH_BOUND_KEY_TEST);
        filter.addAction(VpnTestActivity.ACTION_VPN);
        filter.addAction(AlwaysOnVpnSettingsTestActivity.ACTION_ALWAYS_ON_VPN_SETTINGS_TEST);
        filter.addAction(RecentsRedactionActivity.ACTION_RECENTS);
        filter.addAction(ByodHelperActivity.ACTION_TEST_SELECT_WORK_CHALLENGE);
        filter.addAction(ByodHelperActivity.ACTION_TEST_PATTERN_WORK_CHALLENGE);
        filter.addAction(ByodHelperActivity.ACTION_LAUNCH_CONFIRM_WORK_CREDENTIALS);
        filter.addAction(ByodHelperActivity.ACTION_SET_ORGANIZATION_INFO);
        filter.addAction(ByodHelperActivity.ACTION_TEST_PARENT_PROFILE_PASSWORD);
        filter.addAction(SetSupportMessageActivity.ACTION_SET_SUPPORT_MSG);
        filter.addAction(KeyChainTestActivity.ACTION_KEYCHAIN);
        filter.addAction(CommandReceiverActivity.ACTION_EXECUTE_COMMAND);
        filter.addAction(WorkProfileWidgetActivity.ACTION_TEST_WORK_PROFILE_WIDGET);
        filter.addAction(
                CrossProfilePermissionControlActivity.ACTION_CROSS_PROFILE_PERMISSION_CONTROL);
        filter.addAction(LocationCheckerActivity.ACTION_CHECK_LOCATION_WORK);
        dpm.addCrossProfileIntentFilter(getWho(context), filter,
                DevicePolicyManager.FLAG_MANAGED_CAN_ACCESS_PARENT);

        // Work -> primary direction
        filter = new IntentFilter();
        filter.addAction(ByodHelperActivity.ACTION_PROFILE_OWNER_STATUS);
        filter.addAction(ByodHelperActivity.ACTION_DISK_ENCRYPTION_STATUS);
        filter.addAction(ByodHelperActivity.ACTION_INSTALL_APK_IN_PRIMARY);
        filter.addAction(ByodFlowTestActivity.ACTION_TEST_RESULT);
        filter.addAction(CrossProfileTestActivity.ACTION_CROSS_PROFILE_TO_PERSONAL);

        dpm.addCrossProfileIntentFilter(getWho(context), filter,
                DevicePolicyManager.FLAG_PARENT_CAN_ACCESS_MANAGED);

        // Disable the work profile instance of this activity, because it is a helper activity for
        // the work -> primary direction.
        context.getPackageManager().setComponentEnabledSetting(
                new ComponentName(context, ByodPrimaryHelperActivity.class.getName()),
                PackageManager.COMPONENT_ENABLED_STATE_DISABLED, PackageManager.DONT_KILL_APP);

        // Disable the work profile instance of ByodFlowTestActivity
        context.getPackageManager().setComponentEnabledSetting(
                new ComponentName(context, ByodFlowTestActivity.class),
                PackageManager.COMPONENT_ENABLED_STATE_DISABLED, PackageManager.DONT_KILL_APP);
    }

    private void wipeIfNecessary(Context context, Intent intent) {
        PersistableBundle bundle = intent.getParcelableExtra(
                EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE);
        if (bundle != null && bundle.getBoolean(KEY_BUNDLE_WIPE_IMMEDIATELY, false)) {
            getManager(context).wipeData(0);
        }
    }

    private void bindPrimaryUserService(Context context, Consumer<ICrossUserService> consumer) {
        DevicePolicyManager devicePolicyManager = context.getSystemService(
                DevicePolicyManager.class);
        UserHandle primaryUser = devicePolicyManager.getBindDeviceAdminTargetUsers(
                getReceiverComponentName()).get(0);

        Log.d(TAG, ""Calling primary user: "" + primaryUser);
        final ServiceConnection serviceConnection = new ServiceConnection() {
            @Override
            public void onServiceConnected(ComponentName name, IBinder service) {
                Log.d(TAG, ""onServiceConnected is called"");
                consumer.accept(ICrossUserService.Stub.asInterface(service));
            }

            @Override
            public void onServiceDisconnected(ComponentName name) {
                Log.d(TAG, ""onServiceDisconnected is called"");
            }
        };
        final Intent serviceIntent = new Intent(context, PrimaryUserService.class);
        devicePolicyManager.bindDeviceAdminServiceAsUser(getReceiverComponentName(), serviceIntent,
                serviceConnection, Context.BIND_AUTO_CREATE, primaryUser);
    }

    public static final class PrimaryUserService extends Service {
        private final ICrossUserService.Stub mBinder = new ICrossUserService.Stub() {
            public void switchUser(UserHandle userHandle) {
                Log.d(TAG, ""switchUser: "" + userHandle);
                getSystemService(DevicePolicyManager.class).switchUser(getReceiverComponentName(),
                        userHandle);
            }
        };

        @Override
        public IBinder onBind(Intent intent) {
            return mBinder;
        }
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.TestHelper"	"isEmpty"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/TestHelper.java"	""	"public void test/*
 *.
 */

package android.net.wifi.cts;

import static android.Manifest.permission.CONNECTIVITY_INTERNAL;
import static android.Manifest.permission.NETWORK_SETTINGS;
import static android.net.ConnectivityManager.NetworkCallback.FLAG_INCLUDE_LOCATION_INFO;
import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_OEM_PAID;
import static android.net.NetworkCapabilities.NET_CAPABILITY_OEM_PRIVATE;
import static android.net.NetworkCapabilities.TRANSPORT_WIFI;
import static android.os.Process.myUid;

import static com.google.common.truth.Truth.assertThat;

import static org.junit.Assert.fail;

import android.annotation.NonNull;
import android.app.UiAutomation;
import android.content.Context;
import android.net.ConnectivityManager;
import android.net.MacAddress;
import android.net.Network;
import android.net.NetworkCapabilities;
import android.net.NetworkRequest;
import android.net.wifi.ScanResult;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiInfo;
import android.net.wifi.WifiManager;
import android.net.wifi.WifiNetworkSpecifier;
import android.net.wifi.WifiNetworkSuggestion;
import android.os.Build;
import android.os.WorkSource;
import android.support.test.uiautomator.UiDevice;
import android.text.TextUtils;
import android.util.Log;

import androidx.test.platform.app.InstrumentationRegistry;

import com.android.compatibility.common.util.ApiLevelUtil;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Set;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

/**
 * Class to hold helper methods that are repeated across wifi CTS tests.
 */
public class TestHelper {
    private static final String TAG = ""WifiTestHelper"";

    private final Context mContext;
    private final WifiManager mWifiManager;
    private final ConnectivityManager mConnectivityManager;
    private final UiDevice mUiDevice;

    private static final int DURATION_MILLIS = 10_000;
    private static final int DURATION_NETWORK_CONNECTION_MILLIS = 40_000;
    private static final int DURATION_SCREEN_TOGGLE_MILLIS = 2000;
    private static final int DURATION_UI_INTERACTION_MILLIS = 25_000;
    private static final int SCAN_RETRY_CNT_TO_FIND_MATCHING_BSSID = 3;

    public TestHelper(@NonNull Context context, @NonNull UiDevice uiDevice) {
        mContext = context;
        mWifiManager = context.getSystemService(WifiManager.class);
        mConnectivityManager = context.getSystemService(ConnectivityManager.class);
        mUiDevice = uiDevice;
    }

    public void turnScreenOn() throws Exception {
        mUiDevice.executeShellCommand(""input keyevent KEYCODE_WAKEUP"");
        mUiDevice.executeShellCommand(""wm dismiss-keyguard"");
        // Since the screen on/off intent is ordered, they will not be sent right now.
        Thread.sleep(DURATION_SCREEN_TOGGLE_MILLIS);
    }

    public void turnScreenOff() throws Exception {
        mUiDevice.executeShellCommand(""input keyevent KEYCODE_SLEEP"");
        // Since the screen on/off intent is ordered, they will not be sent right now.
        Thread.sleep(DURATION_SCREEN_TOGGLE_MILLIS);
    }

    private static class TestScanResultsCallback extends WifiManager.ScanResultsCallback {
        private final CountDownLatch mCountDownLatch;
        public boolean onAvailableCalled = false;

        TestScanResultsCallback(CountDownLatch countDownLatch) {
            mCountDownLatch = countDownLatch;
        }

        @Override
        public void onScanResultsAvailable() {
            onAvailableCalled = true;
            mCountDownLatch.countDown();
        }
    }

    /**
     * Loops through all the saved networks available in the scan results. Returns a list of
     * WifiConfiguration with the matching bssid filled in {@link WifiConfiguration#BSSID}.
     *
     * Note:
     * a) If there are more than 2 networks with the same SSID, but different credential type, then
     * this matching may pick the wrong one.
     *
     * @param wifiManager WifiManager service
     * @param savedNetworks List of saved networks on the device.
     */
    public static List<WifiConfiguration> findMatchingSavedNetworksWithBssid(
            @NonNull WifiManager wifiManager, @NonNull List<WifiConfiguration> savedNetworks) {
        if (savedNetworks.isEmpty()) return Collections.emptyList();
        List<WifiConfiguration> matchingNetworksWithBssids = new ArrayList<>();
        CountDownLatch countDownLatch = new CountDownLatch(1);
        for (int i = 0; i < SCAN_RETRY_CNT_TO_FIND_MATCHING_BSSID; i++) {
            // Trigger a scan to get fresh scan results.
            TestScanResultsCallback scanResultsCallback =
                    new TestScanResultsCallback(countDownLatch);
            try {
                wifiManager.registerScanResultsCallback(
                        Executors.newSingleThreadExecutor(), scanResultsCallback);
                wifiManager.startScan(new WorkSource(myUid()));
                // now wait for callback
                countDownLatch.await(DURATION_MILLIS, TimeUnit.MILLISECONDS);
            } catch (InterruptedException e) {
            } finally {
                wifiManager.unregisterScanResultsCallback(scanResultsCallback);
            }
            List<ScanResult> scanResults = wifiManager.getScanResults();
            if (scanResults == null || scanResults.isEmpty()) fail(""No scan results available"");
            for (ScanResult scanResult : scanResults) {
                WifiConfiguration matchingNetwork = savedNetworks.stream()
                        .filter(network -> TextUtils.equals(
                                scanResult.SSID, WifiInfo.sanitizeSsid(network.SSID)))
                        .findAny()
                        .orElse(null);
                if (matchingNetwork != null) {
                    // make a copy in case we have 2 bssid's for the same network.
                    WifiConfiguration matchingNetworkCopy = new WifiConfiguration(matchingNetwork);
                    matchingNetworkCopy.BSSID = scanResult.BSSID;
                    matchingNetworksWithBssids.add(matchingNetworkCopy);
                }
            }
            if (!matchingNetworksWithBssids.isEmpty()) break;
        }
        return matchingNetworksWithBssids;
    }

    /**
     * Convert the provided saved network to a corresponding suggestion builder.
     */
    public static WifiNetworkSuggestion.Builder
            createSuggestionBuilderWithCredentialFromSavedNetworkWithBssid(
            @NonNull WifiConfiguration network) {
        WifiNetworkSuggestion.Builder suggestionBuilder = new WifiNetworkSuggestion.Builder()
                .setSsid(WifiInfo.sanitizeSsid(network.SSID))
                .setBssid(MacAddress.fromString(network.BSSID));
        if (network.preSharedKey != null) {
            if (network.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.WPA_PSK)) {
                suggestionBuilder.setWpa2Passphrase(WifiInfo.sanitizeSsid(network.preSharedKey));
            } else if (network.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.SAE)) {
                suggestionBuilder.setWpa3Passphrase(WifiInfo.sanitizeSsid(network.preSharedKey));
            } else {
                fail(""Unsupported security type found in saved networks"");
            }
        } else if (network.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.OWE)) {
            suggestionBuilder.setIsEnhancedOpen(true);
        } else if (!network.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.NONE)) {
            fail(""Unsupported security type found in saved networks"");
        }
        suggestionBuilder.setIsHiddenSsid(network.hiddenSSID);
        return suggestionBuilder;
    }


    /**
     * Convert the provided saved network to a corresponding specifier builder.
     */
    public static WifiNetworkSpecifier.Builder createSpecifierBuilderWithCredentialFromSavedNetwork(
            @NonNull WifiConfiguration network) {
        WifiNetworkSpecifier.Builder specifierBuilder = new WifiNetworkSpecifier.Builder()
                .setSsid(WifiInfo.sanitizeSsid(network.SSID));
        if (network.preSharedKey != null) {
            if (network.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.WPA_PSK)) {
                specifierBuilder.setWpa2Passphrase(WifiInfo.sanitizeSsid(network.preSharedKey));
            } else if (network.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.SAE)) {
                specifierBuilder.setWpa3Passphrase(WifiInfo.sanitizeSsid(network.preSharedKey));
            } else {
                fail(""Unsupported security type found in saved networks"");
            }
        } else if (network.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.OWE)) {
            specifierBuilder.setIsEnhancedOpen(true);
        } else if (!network.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.NONE)) {
            fail(""Unsupported security type found in saved networks"");
        }
        specifierBuilder.setIsHiddenSsid(network.hiddenSSID);
        return specifierBuilder;
    }

    /**
     * Convert the provided saved network to a corresponding specifier builder.
     */
    public static WifiNetworkSpecifier.Builder
            createSpecifierBuilderWithCredentialFromSavedNetworkWithBssid(
            @NonNull WifiConfiguration network) {
        return createSpecifierBuilderWithCredentialFromSavedNetwork(network)
                .setBssid(MacAddress.fromString(network.BSSID));
    }

    private static class TestNetworkCallback extends ConnectivityManager.NetworkCallback {
        private final CountDownLatch mCountDownLatch;
        public boolean onAvailableCalled = false;
        public boolean onUnavailableCalled = false;
        public NetworkCapabilities networkCapabilities;

        TestNetworkCallback(@NonNull CountDownLatch countDownLatch) {
            mCountDownLatch = countDownLatch;
        }

        TestNetworkCallback(@NonNull CountDownLatch countDownLatch, int flags) {
            super(flags);
            mCountDownLatch = countDownLatch;
        }

        @Override
        public void onAvailable(Network network) {
            onAvailableCalled = true;
        }

        @Override
        public void onCapabilitiesChanged(Network network,
                NetworkCapabilities networkCapabilities) {
            this.networkCapabilities = networkCapabilities;
            mCountDownLatch.countDown();
        }

        @Override
        public void onUnavailable() {
            onUnavailableCalled = true;
            mCountDownLatch.countDown();
        }
    }

    private static TestNetworkCallback createTestNetworkCallback(
            @NonNull CountDownLatch countDownLatch) {
        if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
            // flags for NetworkCallback only introduced in S.
            return new TestNetworkCallback(countDownLatch, FLAG_INCLUDE_LOCATION_INFO);
        } else {
            return new TestNetworkCallback(countDownLatch);
        }
    }

    @NonNull
    private WifiInfo getWifiInfo(@NonNull NetworkCapabilities networkCapabilities) {
        if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
            // WifiInfo in transport info, only available in S.
            return (WifiInfo) networkCapabilities.getTransportInfo();
        } else {
            return mWifiManager.getConnectionInfo();
        }
    }

    private static void assertConnectionEquals(@NonNull WifiConfiguration network,
            @NonNull WifiInfo wifiInfo) {
        assertThat(network.SSID).isEqualTo(wifiInfo.getSSID());
        assertThat(network.BSSID).isEqualTo(wifiInfo.getBSSID());
    }

    private static class TestActionListener implements WifiManager.ActionListener {
        private final CountDownLatch mCountDownLatch;
        public boolean onSuccessCalled = false;
        public boolean onFailedCalled = false;

        TestActionListener(CountDownLatch countDownLatch) {
            mCountDownLatch = countDownLatch;
        }

        @Override
        public void onSuccess() {
            onSuccessCalled = true;
            mCountDownLatch.countDown();
        }

        @Override
        public void onFailure(int reason) {
            onFailedCalled = true;
            mCountDownLatch.countDown();
        }
    }

    /**
     * Triggers connection to one of the saved networks using {@link WifiManager#connect(
     * WifiConfiguration, WifiManager.ActionListener)}
     *
     * @param network saved network from the device to use for the connection.
     *
     * @return NetworkCallback used for the connection (can be used by client to release the
     * connection.
     */
    public ConnectivityManager.NetworkCallback testConnectionFlowWithConnect(
            @NonNull WifiConfiguration network) throws Exception {
        CountDownLatch countDownLatchAl = new CountDownLatch(1);
        CountDownLatch countDownLatchNr = new CountDownLatch(1);
        TestActionListener actionListener = new TestActionListener(countDownLatchAl);
        TestNetworkCallback testNetworkCallback = createTestNetworkCallback(countDownLatchNr);
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            // File a callback for wifi network.
            mConnectivityManager.registerNetworkCallback(
                    new NetworkRequest.Builder()
                            .addTransportType(NetworkCapabilities.TRANSPORT_WIFI)
                            .addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
                            // Needed to ensure that the restricted concurrent connection does not
                            // match this request.
                            .addForbiddenCapability(NET_CAPABILITY_OEM_PAID)
                            .addForbiddenCapability(NET_CAPABILITY_OEM_PRIVATE)
                            .build(),
                    testNetworkCallback);
            // Trigger the connection.
            mWifiManager.connect(network, actionListener);
            // now wait for action listener callback
            assertThat(countDownLatchAl.await(
                    DURATION_NETWORK_CONNECTION_MILLIS, TimeUnit.MILLISECONDS)).isTrue();
            // check if we got the success callback
            assertThat(actionListener.onSuccessCalled).isTrue();

            // Wait for connection to complete & ensure we are connected to the saved network.
            assertThat(countDownLatchNr.await(
                    DURATION_NETWORK_CONNECTION_MILLIS, TimeUnit.MILLISECONDS)).isTrue();
            assertThat(testNetworkCallback.onAvailableCalled).isTrue();
            final WifiInfo wifiInfo = getWifiInfo(testNetworkCallback.networkCapabilities);
            assertConnectionEquals(network, wifiInfo);
            if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
                // User connections should always be primary.
                assertThat(wifiInfo.isPrimary()).isTrue();
            }
        } catch (Throwable e /* catch assertions & exceptions */) {
            // Unregister the network callback in case of any failure (since we don't end up
            // returning the network callback to the caller).
            try {
                mConnectivityManager.unregisterNetworkCallback(testNetworkCallback);
            } catch (IllegalArgumentException ie) { }
            throw e;
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
        return testNetworkCallback;
    }

    /**
     * Tests the entire connection success flow using the provided suggestion.
     *
     * Note: The caller needs to invoke this after acquiring shell identity.
     *
     * @param network saved network from the device to use for the connection.
     * @param suggestion suggestion to use for the connection.
     * @param executorService Excutor service to run scan periodically (to trigger connection).
     * @param restrictedNetworkCapabilities Whether this connection should be restricted with
     *                                    the provided capability.
     *
     * @return NetworkCallback used for the connection (can be used by client to release the
     * connection.
     */
    public ConnectivityManager.NetworkCallback testConnectionFlowWithSuggestionWithShellIdentity(
            WifiConfiguration network, WifiNetworkSuggestion suggestion,
            @NonNull ScheduledExecutorService executorService,
            @NonNull Set<Integer> restrictedNetworkCapabilities) throws Exception {
        return testConnectionFlowWithSuggestionInternal(
                network, suggestion, executorService, restrictedNetworkCapabilities, true);
    }

    /**
     * Tests the entire connection success flow using the provided suggestion.
     *
     * Note: The helper method drops the shell identity, so don't use this if the caller already
     * adopted shell identity.
     *
     * @param network saved network from the device to use for the connection.
     * @param suggestion suggestion to use for the connection.
     * @param executorService Excutor service to run scan periodically (to trigger connection).
     * @param restrictedNetworkCapabilities Whether this connection should be restricted with
     *                                    the provided capability.
     *
     * @return NetworkCallback used for the connection (can be used by client to release the
     * connection.
     */
    public ConnectivityManager.NetworkCallback testConnectionFlowWithSuggestion(
            WifiConfiguration network, WifiNetworkSuggestion suggestion,
            @NonNull ScheduledExecutorService executorService,
            @NonNull Set<Integer> restrictedNetworkCapabilities) throws Exception {
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity(NETWORK_SETTINGS, CONNECTIVITY_INTERNAL);
            return testConnectionFlowWithSuggestionWithShellIdentity(
                    network, suggestion, executorService, restrictedNetworkCapabilities);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests the connection failure flow using the provided suggestion.
     *
     * @param network saved network from the device to use for the connection.
     * @param suggestion suggestion to use for the connection.
     * @param executorService Excutor service to run scan periodically (to trigger connection).
     * @param restrictedNetworkCapabilities Whether this connection should be restricted with
     *                                    the provided capability.
     *
     * @return NetworkCallback used for the connection (can be used by client to release the
     * connection.
     */
    public ConnectivityManager.NetworkCallback testConnectionFailureFlowWithSuggestion(
            WifiConfiguration network, WifiNetworkSuggestion suggestion,
            @NonNull ScheduledExecutorService executorService,
            @NonNull Set<Integer> restrictedNetworkCapabilities) throws Exception {
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity(NETWORK_SETTINGS, CONNECTIVITY_INTERNAL);
            return testConnectionFlowWithSuggestionInternal(
                    network, suggestion, executorService, restrictedNetworkCapabilities, false);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests the entire connection success/failure flow using the provided suggestion.
     *
     * @param network saved network from the device to use for the connection.
     * @param suggestion suggestion to use for the connection.
     * @param executorService Excutor service to run scan periodically (to trigger connection).
     * @param restrictedNetworkCapabilities Whether this connection should be restricted with
     *                                    the provided capability.
     * @param expectConnectionSuccess Whether to expect connection success or not.
     *
     * @return NetworkCallback used for the connection (can be used by client to release the
     * connection.
     */
    private ConnectivityManager.NetworkCallback testConnectionFlowWithSuggestionInternal(
            WifiConfiguration network, WifiNetworkSuggestion suggestion,
            @NonNull ScheduledExecutorService executorService,
            @NonNull Set<Integer> restrictedNetworkCapabilities,
            boolean expectConnectionSuccess) throws Exception {
        CountDownLatch countDownLatch = new CountDownLatch(1);
        // File the network request & wait for the callback.
        TestNetworkCallback testNetworkCallback = createTestNetworkCallback(countDownLatch);
        try {
            // File a request for restricted (oem paid) wifi network.
            NetworkRequest.Builder nrBuilder = new NetworkRequest.Builder()
                    .addTransportType(TRANSPORT_WIFI)
                    .addCapability(NET_CAPABILITY_INTERNET);
            if (restrictedNetworkCapabilities.isEmpty()) {
                // If not a restricted connection, a network callback is sufficient.
                mConnectivityManager.registerNetworkCallback(
                        nrBuilder.build(), testNetworkCallback);
            } else {
                for (Integer restrictedNetworkCapability : restrictedNetworkCapabilities) {
                    nrBuilder.addCapability(restrictedNetworkCapability);
                }
                mConnectivityManager.requestNetwork(nrBuilder.build(), testNetworkCallback);
            }
            // Add wifi network suggestion.
            assertThat(mWifiManager.addNetworkSuggestions(Arrays.asList(suggestion)))
                    .isEqualTo(WifiManager.STATUS_NETWORK_SUGGESTIONS_SUCCESS);
            // Wait for the request to reach the wifi stack before kick-start periodic scans.
            Thread.sleep(100);
            // Step: Trigger scans periodically to trigger network selection quicker.
            executorService.scheduleAtFixedRate(() -> {
                if (!mWifiManager.startScan()) {
                    Log.w(TAG, ""Failed to trigger scan"");
                }
            }, 0, DURATION_MILLIS, TimeUnit.MILLISECONDS);
            if (expectConnectionSuccess) {
                // now wait for connection to complete and wait for callback
                assertThat(countDownLatch.await(
                        DURATION_NETWORK_CONNECTION_MILLIS, TimeUnit.MILLISECONDS)).isTrue();
                assertThat(testNetworkCallback.onAvailableCalled).isTrue();
                final WifiInfo wifiInfo = getWifiInfo(testNetworkCallback.networkCapabilities);
                assertConnectionEquals(network, wifiInfo);
                if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(mContext)) {
                    assertThat(wifiInfo.isTrusted()).isTrue();
                    WifiInfo redact = wifiInfo
                            .makeCopy(NetworkCapabilities.REDACT_FOR_ACCESS_FINE_LOCATION);
                    assertThat(wifiInfo.getInformationElements()).isNotNull();
                    assertThat(redact.getInformationElements()).isNull();
                    assertThat(redact.getApplicableRedactions()).isEqualTo(
                            NetworkCapabilities.REDACT_FOR_ACCESS_FINE_LOCATION
                            | NetworkCapabilities.REDACT_FOR_LOCAL_MAC_ADDRESS
                            | NetworkCapabilities.REDACT_FOR_NETWORK_SETTINGS);
                }
                if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
                    // If STA concurrency for restricted connection is supported, this should not
                    // be the primary connection.
                    if (!restrictedNetworkCapabilities.isEmpty()
                            && mWifiManager.isStaConcurrencyForRestrictedConnectionsSupported()) {
                        assertThat(wifiInfo.isPrimary()).isFalse();
                    } else {
                        assertThat(wifiInfo.isPrimary()).isTrue();
                    }
                }
            } else {
                // now wait for connection to timeout.
                assertThat(countDownLatch.await(
                        DURATION_NETWORK_CONNECTION_MILLIS, TimeUnit.MILLISECONDS)).isFalse();
            }
        } catch (Throwable e /* catch assertions & exceptions */) {
            try {
                mConnectivityManager.unregisterNetworkCallback(testNetworkCallback);
            } catch (IllegalArgumentException ie) { }
            throw e;
        } finally {
            executorService.shutdown();
        }
        return testNetworkCallback;
    }

    private static class TestNetworkRequestMatchCallback implements
            WifiManager.NetworkRequestMatchCallback {
        private final Object mLock;

        public boolean onRegistrationCalled = false;
        public boolean onAbortCalled = false;
        public boolean onMatchCalled = false;
        public boolean onConnectSuccessCalled = false;
        public boolean onConnectFailureCalled = false;
        public WifiManager.NetworkRequestUserSelectionCallback userSelectionCallback = null;
        public List<ScanResult> matchedScanResults = null;

        TestNetworkRequestMatchCallback(Object lock) {
            mLock = lock;
        }

        @Override
        public void onUserSelectionCallbackRegistration(
                WifiManager.NetworkRequestUserSelectionCallback userSelectionCallback) {
            synchronized (mLock) {
                onRegistrationCalled = true;
                this.userSelectionCallback = userSelectionCallback;
                mLock.notify();
            }
        }

        @Override
        public void onAbort() {
            synchronized (mLock) {
                onAbortCalled = true;
                mLock.notify();
            }
        }

        @Override
        public void onMatch(List<ScanResult> scanResults) {
            synchronized (mLock) {
                // This can be invoked multiple times. So, ignore after the first one to avoid
                // disturbing the rest of the test sequence.
                if (onMatchCalled) return;
                onMatchCalled = true;
                matchedScanResults = scanResults;
                mLock.notify();
            }
        }

        @Override
        public void onUserSelectionConnectSuccess(WifiConfiguration config) {
            synchronized (mLock) {
                onConnectSuccessCalled = true;
                mLock.notify();
            }
        }

        @Override
        public void onUserSelectionConnectFailure(WifiConfiguration config) {
            synchronized (mLock) {
                onConnectFailureCalled = true;
                mLock.notify();
            }
        }
    }

    private void handleUiInteractions(WifiConfiguration network, boolean shouldUserReject) {
        // can't use CountDownLatch since there are many callbacks expected and CountDownLatch
        // cannot be reset.
        // TODO(b/177591382): Use ArrayBlockingQueue/LinkedBlockingQueue
        Object uiLock = new Object();
        TestNetworkRequestMatchCallback networkRequestMatchCallback =
                new TestNetworkRequestMatchCallback(uiLock);
        try {
            // 1. Wait for registration callback.
            synchronized (uiLock) {
                try {
                    mWifiManager.registerNetworkRequestMatchCallback(
                            Executors.newSingleThreadExecutor(), networkRequestMatchCallback);
                    uiLock.wait(DURATION_UI_INTERACTION_MILLIS);
                } catch (InterruptedException e) {
                }
            }
            assertThat(networkRequestMatchCallback.onRegistrationCalled).isTrue();
            assertThat(networkRequestMatchCallback.userSelectionCallback).isNotNull();

            // 2. Wait for matching scan results
            synchronized (uiLock) {
                if (!networkRequestMatchCallback.onMatchCalled) {
                    try {
                        uiLock.wait(DURATION_UI_INTERACTION_MILLIS);
                    } catch (InterruptedException e) {
                    }
                }
            }
            assertThat(networkRequestMatchCallback.onMatchCalled).isTrue();
            assertThat(networkRequestMatchCallback.matchedScanResults).isNotNull();
            assertThat(networkRequestMatchCallback.matchedScanResults.size()).isAtLeast(1);

            // 3. Trigger connection to one of the matched networks or reject the request.
            if (shouldUserReject) {
                networkRequestMatchCallback.userSelectionCallback.reject();
            } else {
                networkRequestMatchCallback.userSelectionCallback.select(network);
            }

            // 4. Wait for connection success or abort.
            synchronized (uiLock) {
                try {
                    uiLock.wait(DURATION_UI_INTERACTION_MILLIS);
                } catch (InterruptedException e) {
                }
            }
            if (shouldUserReject) {
                assertThat(networkRequestMatchCallback.onAbortCalled).isTrue();
            } else {
                assertThat(networkRequestMatchCallback.onConnectSuccessCalled).isTrue();
            }
        } finally {
            mWifiManager.unregisterNetworkRequestMatchCallback(networkRequestMatchCallback);
        }
    }

    /**
     * Tests the entire connection flow using the provided specifier,
     *
     * Note: The caller needs to invoke this after acquiring shell identity.
     *
     * @param specifier Specifier to use for network request.
     * @param shouldUserReject Whether to simulate user rejection or not.
     *
     * @return NetworkCallback used for the connection (can be used by client to release the
     * connection.
     */
    public ConnectivityManager.NetworkCallback testConnectionFlowWithSpecifierWithShellIdentity(
            WifiConfiguration network, WifiNetworkSpecifier specifier, boolean shouldUserReject)
            throws Exception {
        CountDownLatch countDownLatch = new CountDownLatch(1);
        // File the network request & wait for the callback.
        TestNetworkCallback testNetworkCallback = createTestNetworkCallback(countDownLatch);

        // Fork a thread to handle the UI interactions.
        Thread uiThread = new Thread(() -> {
            try {
                handleUiInteractions(network, shouldUserReject);
            } catch (Throwable e /* catch assertions & exceptions */) {
                try {
                    mConnectivityManager.unregisterNetworkCallback(testNetworkCallback);
                } catch (IllegalArgumentException ie) { }
                throw e;
            }
        });

        try {
            // File a request for wifi network.
            mConnectivityManager.requestNetwork(
                    new NetworkRequest.Builder()
                            .addTransportType(NetworkCapabilities.TRANSPORT_WIFI)
                            .removeCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
                            .setNetworkSpecifier(specifier)
                            .build(),
                    testNetworkCallback);
            // Wait for the request to reach the wifi stack before kick-starting the UI
            // interactions.
            Thread.sleep(1_000);
            // Start the UI interactions.
            uiThread.run();
            // now wait for callback
            assertThat(countDownLatch.await(
                    DURATION_NETWORK_CONNECTION_MILLIS, TimeUnit.MILLISECONDS)).isTrue();
            if (shouldUserReject) {
                assertThat(testNetworkCallback.onUnavailableCalled).isTrue();
            } else {
                assertThat(testNetworkCallback.onAvailableCalled).isTrue();
                final WifiInfo wifiInfo = getWifiInfo(testNetworkCallback.networkCapabilities);
                assertConnectionEquals(network, wifiInfo);
                if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
                    // If STA concurrency for local only connection is supported, this should not
                    // be the primary connection.
                    if (mWifiManager.isStaConcurrencyForLocalOnlyConnectionsSupported()) {
                        assertThat(wifiInfo.isPrimary()).isFalse();
                    } else {
                        assertThat(wifiInfo.isPrimary()).isTrue();
                    }
                }
            }
        } catch (Throwable e /* catch assertions & exceptions */) {
            try {
                mConnectivityManager.unregisterNetworkCallback(testNetworkCallback);
            } catch (IllegalArgumentException ie) { }
            throw e;
        }
        try {
            // Ensure that the UI interaction thread has completed.
            uiThread.join(DURATION_UI_INTERACTION_MILLIS);
        } catch (InterruptedException e) {
            try {
                mConnectivityManager.unregisterNetworkCallback(testNetworkCallback);
            } catch (IllegalArgumentException ie) { }
            fail(""UI interaction interrupted"");
        }
        return testNetworkCallback;
    }

    /**
     * Tests the entire connection flow using the provided specifier.
     *
     * Note: The helper method drops the shell identity, so don't use this if the caller already
     * adopted shell identity.
     *
     * @param specifier Specifier to use for network request.
     * @param shouldUserReject Whether to simulate user rejection or not.
     *
     * @return NetworkCallback used for the connection (can be used by client to release the
     * connection.
     */
    public ConnectivityManager.NetworkCallback testConnectionFlowWithSpecifier(
            WifiConfiguration network, WifiNetworkSpecifier specifier, boolean shouldUserReject)
            throws Exception {
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity(NETWORK_SETTINGS);
            return testConnectionFlowWithSpecifierWithShellIdentity(
                    network, specifier, shouldUserReject);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Returns the number of wifi connections visible at the networking layer.
     */
    public long getNumWifiConnections() {
        Network[] networks = mConnectivityManager.getAllNetworks();
        return Arrays.stream(networks)
                .filter(n ->
                        mConnectivityManager.getNetworkCapabilities(n).hasTransport(TRANSPORT_WIFI))
                .count();
    }

    /**
     * Registers a network callback for internet connectivity via wifi and asserts that a network
     * is available within {@link #DURATION_NETWORK_CONNECTION_MILLIS}.
     *
     * @throws Exception
     */
    public void assertWifiInternetConnectionAvailable() throws Exception {
        CountDownLatch countDownLatchNr = new CountDownLatch(1);
        TestNetworkCallback testNetworkCallback = createTestNetworkCallback(countDownLatchNr);
        try {
            // File a callback for wifi network.
            NetworkRequest.Builder builder = new NetworkRequest.Builder()
                    .addTransportType(NetworkCapabilities.TRANSPORT_WIFI)
                    .addCapability(NET_CAPABILITY_INTERNET);
            if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
                // Needed to ensure that the restricted concurrent connection does not
                // match this request.
                builder.addForbiddenCapability(NET_CAPABILITY_OEM_PAID)
                        .addForbiddenCapability(NET_CAPABILITY_OEM_PRIVATE);
            }
            mConnectivityManager.registerNetworkCallback(builder.build(), testNetworkCallback);
            // Wait for connection to complete & ensure we are connected to some network capable
            // of providing internet access.
            assertThat(countDownLatchNr.await(
                    DURATION_NETWORK_CONNECTION_MILLIS, TimeUnit.MILLISECONDS)).isTrue();
            assertThat(testNetworkCallback.onAvailableCalled).isTrue();
        } finally {
            mConnectivityManager.unregisterNetworkCallback(testNetworkCallback);
        }
    }

    public static int getBandFromFrequency(final int freqMHz) {
        if (freqMHz < 1000) {
            return ScanResult.UNSPECIFIED;
        } else if (freqMHz < 4000) { // getFrequency is in WifiInfo.FREQUENCY_UNITS = MHz
            return ScanResult.WIFI_BAND_24_GHZ;
        } else if (freqMHz < 5900) {
            // 5GHz band stops at 5885MHz, 6GHz band starts at 5955. See android.net.wifi.ScanResult
            return ScanResult.WIFI_BAND_5_GHZ;
        } else if (freqMHz < 10_000) {
            return ScanResult.WIFI_BAND_6_GHZ;
        } else if (freqMHz < 71_000) {
            // 60 GHz band stops at 70_200
            return ScanResult.WIFI_BAND_60_GHZ;
        } else {
            return ScanResult.UNSPECIFIED;
        }
    }

}"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.server.wm.AlertWindowsTests"	"testAlertWindowDisallowedSdk25"	"CtsWindowManagerDeviceTestCases"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/AlertWindowsTests.java"	""	"public void testAlertWindowDisallowedSdk25() throws Exception {
        runAlertWindowTest(SDK25_ALERT_WINDOW_TEST_ACTIVITY, false /* hasAlertWindowPermission */,
                false /* atLeastO */);
    }

    private void runAlertWindowTest(final ComponentName activityName,
            final boolean hasAlertWindowPermission, final boolean atLeastO) throws Exception {
        setAlertWindowPermission(activityName, hasAlertWindowPermission);

        executeShellCommand(getAmStartCmd(activityName));
        mWmState.computeState(new WaitForValidActivityState(activityName));
        mWmState.assertVisibility(activityName, true);

        assertAlertWindows(activityName, hasAlertWindowPermission, atLeastO);
    }

    private boolean allWindowsHidden(List<WindowManagerState.WindowState> windows) {
        for (WindowManagerState.WindowState ws : windows) {
            if (ws.isSurfaceShown()) {
                return false;
            }
        }
        return true;
    }

    private void assertAlertWindows(final ComponentName activityName,
            final boolean hasAlertWindowPermission, final boolean atLeastO) throws Exception {
        final String packageName = activityName.getPackageName();
        final WindowManagerState wmState = mWmState;

        final List<WindowManagerState.WindowState> alertWindows =
                wmState.getWindowsByPackageName(packageName, ALERT_WINDOW_TYPES);

        if (!hasAlertWindowPermission) {
            // When running in VR Mode, an App Op restriction is
            // in place for SYSTEM_ALERT_WINDOW, which allows the window
            // to be created, but will be hidden instead.
            if (isUiModeLockedToVrHeadset()) {
                assertThat(""Should not be empty alertWindows"",
                        alertWindows, hasSize(greaterThan(0)));
                assertTrue(""All alert windows should be hidden"",
                        allWindowsHidden(alertWindows));
            } else {
                assertThat(""Should be empty alertWindows"", alertWindows, empty());
                assertTrue(AppOpsUtils.rejectedOperationLogged(packageName,
                        OPSTR_SYSTEM_ALERT_WINDOW));
                return;
            }
        }

        if (atLeastO) {
            // Assert that only TYPE_APPLICATION_OVERLAY was created.
            for (WindowManagerState.WindowState win : alertWindows) {
                assertEquals(""Can't create win="" + win + "" on SDK O or greater"",
                        win.getType(), TYPE_APPLICATION_OVERLAY);
            }
        }

        final WindowManagerState.WindowState mainAppWindow =
                wmState.getWindowByPackageName(packageName, TYPE_BASE_APPLICATION);

        assertNotNull(mainAppWindow);

        final WindowManagerState.WindowState lowestAlertWindow = alertWindows.get(0);
        final WindowManagerState.WindowState highestAlertWindow =
                alertWindows.get(alertWindows.size() - 1);

        // Assert that the alert windows have higher z-order than the main app window
        assertThat(""lowestAlertWindow has higher z-order than mainAppWindow"",
                wmState.getZOrder(lowestAlertWindow),
                greaterThan(wmState.getZOrder(mainAppWindow)));

        // Assert that legacy alert windows have a lower z-order than the new alert window layer.
        final WindowManagerState.WindowState appOverlayWindow =
                wmState.getWindowByPackageName(packageName, TYPE_APPLICATION_OVERLAY);
        if (appOverlayWindow != null && highestAlertWindow != appOverlayWindow) {
            assertThat(""highestAlertWindow has lower z-order than appOverlayWindow"",
                    wmState.getZOrder(highestAlertWindow),
                    lessThan(wmState.getZOrder(appOverlayWindow)));
        }

        // Assert that alert windows are below key system windows.
        final List<WindowManagerState.WindowState> systemWindows =
                wmState.getWindowsByPackageName(packageName, SYSTEM_WINDOW_TYPES);
        if (!systemWindows.isEmpty()) {
            final WindowManagerState.WindowState lowestSystemWindow = alertWindows.get(0);
            assertThat(""highestAlertWindow has lower z-order than lowestSystemWindow"",
                    wmState.getZOrder(highestAlertWindow),
                    lessThan(wmState.getZOrder(lowestSystemWindow)));
        }
        assertTrue(AppOpsUtils.allowedOperationLogged(packageName, OPSTR_SYSTEM_ALERT_WINDOW));
    }

    // Resets the permission states for a package to the system defaults.
    // Also clears the app operation logs for this package, required to test that displaying
    // the alert window gets logged.
    private void resetPermissionState(ComponentName activityName) throws Exception {
        AppOpsUtils.reset(activityName.getPackageName());
    }

    private void setAlertWindowPermission(final ComponentName activityName, final boolean allow)
            throws Exception {
        int mode = allow ? MODE_ALLOWED : MODE_ERRORED;
        AppOpsUtils.setOpMode(activityName.getPackageName(), OPSTR_SYSTEM_ALERT_WINDOW, mode);
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.compatibility.common.tradefed.presubmit.CtsConfigLoadingTest"	"testConfigurationLoad"	""	"/home/gpoor/cts-12-source/cts/tools/cts-tradefed/tests/src/com/android/compatibility/common/tradefed/presubmit/CtsConfigLoadingTest.java"	""	"public void testConfigurationLoad() throws Exception {
        String ctsRoot = System.getProperty(""CTS_ROOT"");
        File testcases = new File(ctsRoot, ""/android-cts/testcases/"");
        if (!testcases.exists()) {
            fail(String.format(""%s does not exists"", testcases));
            return;
        }
        File[] listConfig = testcases.listFiles(new FilenameFilter() {
            @Override
            public boolean accept(File dir, String name) {
                if (name.endsWith("".config"")) {
                    return true;
                }
                return false;
            }
        });
        assertTrue(listConfig.length > 0);
        // Create a FolderBuildInfo to similate the CompatibilityBuildProvider
        FolderBuildInfo stubFolder = new FolderBuildInfo(""-1"", ""-1"");
        stubFolder.setRootDir(new File(ctsRoot));
        stubFolder.addBuildAttribute(CompatibilityBuildHelper.SUITE_NAME, ""CTS"");
        stubFolder.addBuildAttribute(""ROOT_DIR"", ctsRoot);
        TestInformation stubTestInfo = TestInformation.newBuilder().build();
        stubTestInfo.executionFiles().put(FilesKey.TESTS_DIRECTORY, new File(ctsRoot));

        List<String> missingMandatoryParameters = new ArrayList<>();
        // We expect to be able to load every single config in testcases/
        for (File config : listConfig) {
            IConfiguration c = ConfigurationFactory.getInstance()
                    .createConfigurationFromArgs(new String[] {config.getAbsolutePath()});
            if (c.getDeviceConfig().size() > 2) {
                throw new ConfigurationException(String.format(""%s declares more than 2 devices."", config));
            }
            for (IDeviceConfiguration dConfig : c.getDeviceConfig()) {
                // Ensure the deprecated ApkInstaller is not used anymore.
                for (ITargetPreparer prep : dConfig.getTargetPreparers()) {
                    if (prep.getClass().isAssignableFrom(ApkInstaller.class)) {
                        throw new ConfigurationException(
                                String.format(""%s: Use com.android.tradefed.targetprep.suite.""
                                        + ""SuiteApkInstaller instead of com.android.compatibility.""
                                        + ""common.tradefed.targetprep.ApkInstaller, options will be ""
                                        + ""the same."", config));
                    }
                    if (prep.getClass().isAssignableFrom(PreconditionPreparer.class)) {
                        throw new ConfigurationException(
                                String.format(
                                        ""%s: includes a PreconditionPreparer (%s) which is not ""
                                                + ""allowed in modules."",
                                        config.getName(), prep.getClass()));
                    }
                    if (prep.getClass().isAssignableFrom(DeviceSetup.class)) {
                       DeviceSetup deviceSetup = (DeviceSetup) prep;
                       if (!deviceSetup.isForceSkipSystemProps()) {
                           throw new ConfigurationException(
                                   String.format(""%s: %s needs to be configured with ""
                                           + ""<option name=\""force-skip-system-props\"" ""
                                           + ""value=\""true\"" /> in CTS."",
                                                 config.getName(), prep.getClass()));
                       }
                    }
                }
            }
            // We can ensure that Host side tests are not empty.
            for (IRemoteTest test : c.getTests()) {
                // Check that all the tests runners are well supported.
                if (!SUPPORTED_CTS_TEST_TYPE.contains(test.getClass().getCanonicalName())) {
                    throw new ConfigurationException(
                            String.format(
                                    ""testtype %s is not officially supported by CTS. ""
                                            + ""The supported ones are: %s"",
                                    test.getClass().getCanonicalName(), SUPPORTED_CTS_TEST_TYPE));
                }
                if (test instanceof HostTest) {
                    HostTest hostTest = (HostTest) test;
                    // We inject a made up folder so that it can find the tests.
                    hostTest.setBuild(stubFolder);
                    hostTest.setTestInformation(stubTestInfo);
                    int testCount = hostTest.countTestCases();
                    if (testCount == 0) {
                        throw new ConfigurationException(
                                String.format(""%s: %s reports 0 test cases."",
                                        config.getName(), test));
                    }
                }
                if (test instanceof GTest) {
                    if (((GTest) test).isRebootBeforeTestEnabled()) {
                        throw new ConfigurationException(String.format(
                                ""%s: instead of reboot-before-test use a RebootTargetPreparer ""
                                + ""which is more optimized during sharding."", config.getName()));
                    }
                }
                // Tests are expected to implement that interface.
                if (!(test instanceof ITestFilterReceiver)) {
                    throw new IllegalArgumentException(String.format(
                            ""Test in module %s must implement ITestFilterReceiver."",
                            config.getName()));
                }
                // Ensure that the device runner is the AJUR one if explicitly specified.
                if (test instanceof AndroidJUnitTest) {
                    AndroidJUnitTest instru = (AndroidJUnitTest) test;
                    if (instru.getRunnerName() != null &&
                            !ALLOWED_INSTRUMENTATION_RUNNER_NAME.contains(instru.getRunnerName())) {
                        // Some runner are exempt
                        if (!RUNNER_EXCEPTION.contains(instru.getRunnerName())) {
                            throw new ConfigurationException(
                                    String.format(""%s: uses '%s' instead of on of '%s' that are ""
                                            + ""expected"", config.getName(), instru.getRunnerName(),
                                            ALLOWED_INSTRUMENTATION_RUNNER_NAME));
                        }
                    }
                }
            }

            ConfigurationDescriptor cd = c.getConfigurationDescription();
            Assert.assertNotNull(config + "": configuration descriptor is null"", cd);
            List<String> component = cd.getMetaData(METADATA_COMPONENT);
            Assert.assertNotNull(String.format(""Missing module metadata field \""component\"", ""
                    + ""please add the following line to your AndroidTest.xml:\n""
                    + ""<option name=\""config-descriptor:metadata\"" key=\""component\"" ""
                    + ""value=\""...\"" />\nwhere \""value\"" must be one of: %s\n""
                    + ""config: %s"", KNOWN_COMPONENTS, config),
                    component);
            Assert.assertEquals(String.format(""Module config contains more than one \""component\"" ""
                    + ""metadata field: %s\nconfig: %s"", component, config),
                    1, component.size());
            String cmp = component.get(0);
            Assert.assertTrue(String.format(""Module config contains unknown \""component\"" metadata ""
                    + ""field \""%s\"", supported ones are: %s\nconfig: %s"",
                    cmp, KNOWN_COMPONENTS, config), KNOWN_COMPONENTS.contains(cmp));

            if (""misc"".equals(cmp)) {
                String configFileName = config.getName();
                Assert.assertTrue(
                        String.format(
                                ""Adding new module %s to \""misc\"" component is restricted, ""
                                        + ""please pick a component that your module fits in"",
                                configFileName),
                        KNOWN_MISC_MODULES.contains(configFileName));
            }

            // Check that specified parameters are expected
            boolean res =
                    checkModuleParameters(
                            config.getName(), cd.getMetaData(ITestSuite.PARAMETER_KEY));
            if (!res) {
                missingMandatoryParameters.add(config.getName());
            }
            // Check that specified tokens are expected
            checkTokens(config.getName(), cd.getMetaData(ITestSuite.TOKEN_KEY));

            // Ensure each CTS module is tagged with <option name=""test-suite-tag"" value=""cts"" />
            Assert.assertTrue(String.format(
                    ""Module config %s does not contains ""
                    + ""'<option name=\""test-suite-tag\"" value=\""cts\"" />'"", config.getName()),
                    cd.getSuiteTags().contains(""cts""));

            // Check not-shardable: JarHostTest cannot create empty shards so it should never need
            // to be not-shardable.
            if (cd.isNotShardable()) {
                for (IRemoteTest test : c.getTests()) {
                    if (test.getClass().isAssignableFrom(JarHostTest.class)) {
                        throw new ConfigurationException(
                                String.format(""config: %s. JarHostTest does not need the ""
                                    + ""not-shardable option."", config.getName()));
                    }
                }
            }
            // Ensure options have been set
            c.validateOptions();
        }

        // Exempt the allow list
        missingMandatoryParameters.removeAll(ALLOWLIST_MODULE_PARAMETERS);
        // Ensure the mandatory fields are filled
        if (!missingMandatoryParameters.isEmpty()) {
            String msg =
                    String.format(
                            ""The following %s modules are missing some of the mandatory ""
                                    + ""parameters [instant_app, not_instant_app, ""
                                    + ""multi_abi, not_multi_abi, ""
                                    + ""secondary_user, not_secondary_user]: '%s'"",
                            missingMandatoryParameters.size(), missingMandatoryParameters);
            throw new ConfigurationException(msg);
        }
    }

    /** Test that all parameter metadata can be resolved. */
    private boolean checkModuleParameters(String configName, List<String> parameters)
            throws ConfigurationException {
        if (parameters == null) {
            return false;
        }
        Map<String, Boolean> families = createFamilyCheckMap();
        for (String param : parameters) {
            try {
                ModuleParameters p = ModuleParameters.valueOf(param.toUpperCase());
                if (families.containsKey(p.getFamily())) {
                    families.put(p.getFamily(), true);
                }
            } catch (IllegalArgumentException e) {
                throw new ConfigurationException(
                        String.format(""Config: %s includes an unknown parameter '%s'."",
                                configName, param));
            }
        }
        if (families.containsValue(false)) {
            return false;
        }
        return true;
    }

    /** Test that all tokens can be resolved. */
    private void checkTokens(String configName, List<String> tokens) throws ConfigurationException {
        if (tokens == null) {
            return;
        }
        for (String token : tokens) {
            try {
                TokenProperty.valueOf(token.toUpperCase());
            } catch (IllegalArgumentException e) {
                throw new ConfigurationException(
                        String.format(
                                ""Config: %s includes an unknown token '%s'."", configName, token));
            }
        }
    }

    private Map<String, Boolean> createFamilyCheckMap() {
        Map<String, Boolean> families = new HashMap<>();
        for (String family : MANDATORY_PARAMETERS_FAMILY) {
            families.put(family, false);
        }
        return families;
    }
}"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.permission2.cts.RestrictedStoragePermissionTest"	"testCannotControlStorageWhitelistPostInstall1"	"CtsPermission2TestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedStoragePermissionTest.java"	""	"@AppModeFull
    public void testCannotControlStorageWhitelistPostInstall1() throws Exception {
        // Install with whitelisted permissions.
        installApp(APK_USES_STORAGE_DEFAULT_28, null /*whitelistedPermissions*/);

        // Check expected state of restricted permissions.
        assertCannotUnWhitelistStorage();
    }"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.permission2.cts.RestrictedStoragePermissionTest"	"testCannotControlStorageWhitelistPostInstall2"	"CtsPermission2TestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedStoragePermissionTest.java"	""	"@AppModeFull
    public void testCannotControlStorageWhitelistPostInstall2() throws Exception {
        // Install with no whitelisted permissions.
        installApp(APK_USES_STORAGE_DEFAULT_28, Collections.emptySet());

        // Check expected state of restricted permissions.
        assertCannotWhitelistStorage();
    }"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.permission2.cts.RestrictedStoragePermissionTest"	"restrictedWritePermDoesNotImplyIsolatedStorageAccess"	"CtsPermission2TestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedStoragePermissionTest.java"	""	"@AppModeFull
    public void restrictedWritePermDoesNotImplyIsolatedStorageAccess() throws Exception {
        // Install with whitelisted read permissions.
        installApp(
                APK_USES_STORAGE_OPT_OUT_29,
                Collections.singleton(Manifest.permission.READ_EXTERNAL_STORAGE));

        // It does not matter that write is restricted as the storage access level is only
        // controlled by the read perm
        assertHasFullStorageAccess();
    }"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.permission2.cts.RestrictedStoragePermissionTest"	"testStorageTargetingSdk30CannotPreserveLegacyOnInstall"	"CtsPermission2TestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedStoragePermissionTest.java"	""	"@AppModeFull
    public void testStorageTargetingSdk30CannotPreserveLegacyOnInstall() throws Exception {
        installApp(APK_USES_STORAGE_PRESERVED_OPT_OUT_30, null);

        assertHasIsolatedStorageAccess();
    }

    private void assertHasFullStorageAccess() throws Exception {
        runWithShellPermissionIdentity(() -> {
            AppOpsManager appOpsManager = getContext().getSystemService(AppOpsManager.class);
            final int uid = getContext().getPackageManager().getPackageUid(PKG, 0);
            eventually(() -> assertThat(appOpsManager.unsafeCheckOpRawNoThrow(
                    AppOpsManager.OPSTR_LEGACY_STORAGE,
                    uid, PKG)).isEqualTo(AppOpsManager.MODE_ALLOWED));
        });
    }

    private void assertHasIsolatedStorageAccess() throws Exception {
        runWithShellPermissionIdentity(() -> {
            AppOpsManager appOpsManager = getContext().getSystemService(AppOpsManager.class);
            final int uid = getContext().getPackageManager().getPackageUid(PKG, 0);
            eventually(() -> assertThat(appOpsManager.unsafeCheckOpRawNoThrow(
                    AppOpsManager.OPSTR_LEGACY_STORAGE,
                    uid, PKG)).isNotEqualTo(AppOpsManager.MODE_ALLOWED));
        });
    }

    private void assertCannotWhitelistStorage() throws Exception {
        final PackageManager packageManager = getContext().getPackageManager();

        runWithShellPermissionIdentity(() -> {
            // Assert added only to none whitelist.
            assertThat(packageManager.getWhitelistedRestrictedPermissions(PKG,
                    PackageManager.FLAG_PERMISSION_WHITELIST_SYSTEM
                            | PackageManager.FLAG_PERMISSION_WHITELIST_UPGRADE
                            | PackageManager.FLAG_PERMISSION_WHITELIST_INSTALLER))
                    .doesNotContain(permission.READ_EXTERNAL_STORAGE);
            assertThat(packageManager.getWhitelistedRestrictedPermissions(PKG,
                    PackageManager.FLAG_PERMISSION_WHITELIST_SYSTEM
                            | PackageManager.FLAG_PERMISSION_WHITELIST_UPGRADE
                            | PackageManager.FLAG_PERMISSION_WHITELIST_INSTALLER))
                    .doesNotContain(permission.WRITE_EXTERNAL_STORAGE);
        });

        // Assert we cannot add.
        try {
            packageManager.addWhitelistedRestrictedPermission(
                    PKG,
                    permission.READ_EXTERNAL_STORAGE,
                    PackageManager.FLAG_PERMISSION_WHITELIST_INSTALLER);
            fail();
        } catch (SecurityException expected) {
        }
        try {
            packageManager.addWhitelistedRestrictedPermission(
                    PKG,
                    permission.WRITE_EXTERNAL_STORAGE,
                    PackageManager.FLAG_PERMISSION_WHITELIST_INSTALLER);
            fail();
        } catch (SecurityException expected) {
        }

        runWithShellPermissionIdentity(() -> {
            // Assert added only to none whitelist.
            assertThat(packageManager.getWhitelistedRestrictedPermissions(PKG,
                    PackageManager.FLAG_PERMISSION_WHITELIST_SYSTEM
                            | PackageManager.FLAG_PERMISSION_WHITELIST_UPGRADE
                            | PackageManager.FLAG_PERMISSION_WHITELIST_INSTALLER))
                    .doesNotContain(permission.READ_EXTERNAL_STORAGE);
            assertThat(packageManager.getWhitelistedRestrictedPermissions(PKG,
                    PackageManager.FLAG_PERMISSION_WHITELIST_SYSTEM
                            | PackageManager.FLAG_PERMISSION_WHITELIST_UPGRADE
                            | PackageManager.FLAG_PERMISSION_WHITELIST_INSTALLER))
                    .doesNotContain(permission.WRITE_EXTERNAL_STORAGE);
        });
    }

    private void assertCannotUnWhitelistStorage() throws Exception {
        final PackageManager packageManager = getContext().getPackageManager();

        runWithShellPermissionIdentity(() -> {
            // Assert added only to install whitelist.
            assertThat(packageManager.getWhitelistedRestrictedPermissions(PKG,
                    PackageManager.FLAG_PERMISSION_WHITELIST_INSTALLER))
                    .contains(permission.READ_EXTERNAL_STORAGE);
            assertThat(packageManager.getWhitelistedRestrictedPermissions(PKG,
                    PackageManager.FLAG_PERMISSION_WHITELIST_INSTALLER))
                    .contains(permission.WRITE_EXTERNAL_STORAGE);
            assertThat(packageManager.getWhitelistedRestrictedPermissions(PKG,
                    PackageManager.FLAG_PERMISSION_WHITELIST_UPGRADE
                            | PackageManager.FLAG_PERMISSION_WHITELIST_SYSTEM))
                    .doesNotContain(permission.READ_EXTERNAL_STORAGE);
            assertThat(packageManager.getWhitelistedRestrictedPermissions(PKG,
                    PackageManager.FLAG_PERMISSION_WHITELIST_UPGRADE
                            | PackageManager.FLAG_PERMISSION_WHITELIST_SYSTEM))
                    .doesNotContain(permission.WRITE_EXTERNAL_STORAGE);
        });

        try {
            // Assert we cannot remove.
            packageManager.removeWhitelistedRestrictedPermission(
                    PKG,
                    permission.READ_EXTERNAL_STORAGE,
                    PackageManager.FLAG_PERMISSION_WHITELIST_INSTALLER);
            fail();
        } catch (SecurityException expected) {
        }
        try {
            packageManager.removeWhitelistedRestrictedPermission(
                    PKG,
                    permission.WRITE_EXTERNAL_STORAGE,
                    PackageManager.FLAG_PERMISSION_WHITELIST_INSTALLER);
            fail();
        } catch (SecurityException expected) {
        }

        runWithShellPermissionIdentity(() -> {
            // Assert added only to install whitelist.
            assertThat(packageManager.getWhitelistedRestrictedPermissions(PKG,
                    PackageManager.FLAG_PERMISSION_WHITELIST_INSTALLER))
                    .contains(permission.READ_EXTERNAL_STORAGE);
            assertThat(packageManager.getWhitelistedRestrictedPermissions(PKG,
                    PackageManager.FLAG_PERMISSION_WHITELIST_INSTALLER))
                    .contains(permission.WRITE_EXTERNAL_STORAGE);
            assertThat(packageManager.getWhitelistedRestrictedPermissions(PKG,
                    PackageManager.FLAG_PERMISSION_WHITELIST_UPGRADE
                            | PackageManager.FLAG_PERMISSION_WHITELIST_SYSTEM))
                    .doesNotContain(permission.READ_EXTERNAL_STORAGE);
            assertThat(packageManager.getWhitelistedRestrictedPermissions(PKG,
                    PackageManager.FLAG_PERMISSION_WHITELIST_UPGRADE
                            | PackageManager.FLAG_PERMISSION_WHITELIST_SYSTEM))
                    .doesNotContain(permission.WRITE_EXTERNAL_STORAGE);
        });
    }

    private @NonNull Set<String> getPermissionsOfAppWithAnyOfFlags(int flags) throws Exception {
        final PackageManager packageManager = getContext().getPackageManager();
        final Set<String> restrictedPermissions = new ArraySet<>();
        for (String permission : getRequestedPermissionsOfApp()) {
            PermissionInfo permInfo = packageManager.getPermissionInfo(permission, 0);

            if ((permInfo.flags & flags) != 0) {
                restrictedPermissions.add(permission);
            }
        }
        return restrictedPermissions;
    }

    private @NonNull Set<String> getRestrictedPermissionsOfApp() throws Exception {
        return getPermissionsOfAppWithAnyOfFlags(
                PermissionInfo.FLAG_HARD_RESTRICTED | PermissionInfo.FLAG_SOFT_RESTRICTED);
    }

    private @NonNull String[] getRequestedPermissionsOfApp() throws Exception {
        final PackageManager packageManager = getContext().getPackageManager();
        final PackageInfo packageInfo =
                packageManager.getPackageInfo(PKG, PackageManager.GET_PERMISSIONS);
        return packageInfo.requestedPermissions;
    }

    private static @NonNull Context getContext() {
        return InstrumentationRegistry.getInstrumentation().getContext();
    }

    private static void runWithShellPermissionIdentity(@NonNull ThrowingRunnable command)
            throws Exception {
        InstrumentationRegistry.getInstrumentation()
                .getUiAutomation()
                .adoptShellPermissionIdentity();
        try {
            command.run();
        } finally {
            InstrumentationRegistry.getInstrumentation()
                    .getUiAutomation()
                    .dropShellPermissionIdentity();
        }
    }

    /**
     * Install an app.
     *
     * @param app The app to be installed
     * @param whitelistedPermissions The permission to be whitelisted. {@code null} == all
     * @param grantedPermissions The permission to be granted. {@code null} == all
     */
    private void installApp(
            @NonNull String app,
            @Nullable Set<String> whitelistedPermissions)
            throws Exception {
        // Install the app and whitelist/grant all permission if requested.
        String installResult = runShellCommand(""pm install -r --restrict-permissions "" + app);
        assertThat(installResult.trim()).isEqualTo(""Success"");

        final Set<String> adjustedWhitelistedPermissions;
        if (whitelistedPermissions == null) {
            adjustedWhitelistedPermissions = getRestrictedPermissionsOfApp();
        } else {
            adjustedWhitelistedPermissions = whitelistedPermissions;
        }

        final Set<String> adjustedGrantedPermissions = getRestrictedPermissionsOfApp();

        // Whitelist subset of permissions if requested
        runWithShellPermissionIdentity(() -> {
            final PackageManager packageManager = getContext().getPackageManager();
            for (String permission : adjustedWhitelistedPermissions) {
                packageManager.addWhitelistedRestrictedPermission(
                        PKG,
                        permission,
                        PackageManager.FLAG_PERMISSION_WHITELIST_INSTALLER);
            }
        });

        // Grant subset of permissions if requested
        runWithShellPermissionIdentity(() -> {
            final PackageManager packageManager = getContext().getPackageManager();
            for (String permission : adjustedGrantedPermissions) {
                packageManager.grantRuntimePermission(PKG, permission, getContext().getUser());
                packageManager.updatePermissionFlags(
                        permission,
                        PKG,
                        PackageManager.FLAG_PERMISSION_REVOKED_COMPAT,
                        0,
                        getContext().getUser());
            }
        });

        // Mark all permissions as reviewed as for pre-22 apps the restriction state might not be
        // applied until reviewed
        runWithShellPermissionIdentity(() -> {
            final PackageManager packageManager = getContext().getPackageManager();
            for (String permission : getRequestedPermissionsOfApp()) {
                packageManager.updatePermissionFlags(
                        permission,
                        PKG,
                        PackageManager.FLAG_PERMISSION_REVIEW_REQUIRED,
                        0,
                        getContext().getUser());
            }
        });
    }

    @After
    public void uninstallApp() {
        runShellCommand(""pm uninstall "" + PKG);
    }
}"	""	""	"restricted restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.security.cts.SELinuxHostTest"	"testCollectDeviceInfo"	"CtsSecurityHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/security/src/android/security/cts/SELinuxHostTest.java"	""	"/*
 *.
 */

package android.security.cts;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.junit.Assume.assumeTrue;

import android.platform.test.annotations.RestrictedBuildTest;

import com.android.compatibility.common.tradefed.build.CompatibilityBuildHelper;
import com.android.compatibility.common.tradefed.targetprep.DeviceInfoCollector;
import com.android.compatibility.common.util.CddTest;
import com.android.compatibility.common.util.PropertyUtil;
import com.android.tradefed.build.IBuildInfo;
import com.android.tradefed.device.CollectingOutputReceiver;
import com.android.tradefed.device.DeviceNotAvailableException;
import com.android.tradefed.device.ITestDevice;
import com.android.tradefed.log.LogUtil.CLog;
import com.android.tradefed.testtype.DeviceJUnit4ClassRunner;
import com.android.tradefed.testtype.junit4.BaseHostJUnit4Test;
import com.android.tradefed.util.FileUtil;

import org.json.JSONObject;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.w3c.dom.Document;
import org.w3c.dom.Element;

import java.io.BufferedReader;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.file.Files;
import java.nio.file.StandardCopyOption;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;

/**
 * Host-side SELinux tests.
 *
 * These tests analyze the policy file in use on the subject device directly or
 * run as the shell user to evaluate aspects of the state of SELinux on the test
 * device which otherwise would not be available to a normal apk.
 */
@RunWith(DeviceJUnit4ClassRunner.class)
public class SELinuxHostTest extends BaseHostJUnit4Test {

    // Keep in sync with AndroidTest.xml
    private static final String DEVICE_INFO_DEVICE_DIR = ""/sdcard/device-info-files/"";
    // Keep in sync with com.android.compatibility.common.deviceinfo.VintfDeviceInfo
    private static final String VINTF_DEVICE_CLASS = ""VintfDeviceInfo"";
    // Keep in sync with
    // com.android.compatibility.common.deviceinfo.DeviceInfo#testCollectDeviceInfo()
    private static final String DEVICE_INFO_SUFFIX = "".deviceinfo.json"";
    private static final String VINTF_DEVICE_JSON = VINTF_DEVICE_CLASS + DEVICE_INFO_SUFFIX;
    // Keep in sync with com.android.compatibility.common.deviceinfo.VintfDeviceInfo
    private static final String SEPOLICY_VERSION_JSON_KEY = ""sepolicy_version"";
    private static final String PLATFORM_SEPOLICY_VERSION_JSON_KEY = ""platform_sepolicy_version"";

    private static final Map<ITestDevice, File> cachedDevicePolicyFiles = new HashMap<>(1);
    private static final Map<ITestDevice, File> cachedDevicePlatFcFiles = new HashMap<>(1);
    private static final Map<ITestDevice, File> cachedDeviceNonplatFcFiles = new HashMap<>(1);
    private static final Map<ITestDevice, File> cachedDeviceVendorManifest = new HashMap<>(1);
    private static final Map<ITestDevice, File> cachedDeviceVintfJson = new HashMap<>(1);
    private static final Map<ITestDevice, File> cachedDeviceSystemPolicy = new HashMap<>(1);

    private File sepolicyAnalyze;
    private File checkSeapp;
    private File checkFc;
    private File aospSeappFile;
    private File aospFcFile;
    private File aospPcFile;
    private File aospSvcFile;
    private File devicePolicyFile;
    private File deviceSystemPolicyFile;
    private File devicePlatSeappFile;
    private File deviceNonplatSeappFile;
    private File devicePlatFcFile;
    private File deviceNonplatFcFile;
    private File devicePcFile;
    private File deviceSvcFile;
    private File seappNeverAllowFile;
    private File libsepolwrap;
    private File libcpp;
    private File copyLibcpp;
    private File sepolicyTests;

    private IBuildInfo mBuild;

    /**
     * A reference to the device under test.
     */
    private ITestDevice mDevice;

    public static File copyResourceToTempFile(String resName) throws IOException {
        InputStream is = SELinuxHostTest.class.getResourceAsStream(resName);
        File tempFile = File.createTempFile(""SELinuxHostTest"", "".tmp"");
        FileOutputStream os = new FileOutputStream(tempFile);
        byte[] buf = new byte[1024];
        int len;

        while ((len = is.read(buf)) != -1) {
            os.write(buf, 0, len);
        }
        os.flush();
        os.close();
        tempFile.deleteOnExit();
        return tempFile;
    }

    private static void appendTo(String dest, String src) throws IOException {
        try (FileInputStream is = new FileInputStream(new File(src));
             FileOutputStream os = new FileOutputStream(new File(dest))) {
            byte[] buf = new byte[1024];
            int len;

            while ((len = is.read(buf)) != -1) {
                os.write(buf, 0, len);
            }
        }
    }

    @Before
    public void setUp() throws Exception {
        mDevice = getDevice();
        mBuild = getBuild();
        // Assumes every test in this file asserts a requirement of CDD section 9.
        assumeSecurityModelCompat();

        CompatibilityBuildHelper buildHelper = new CompatibilityBuildHelper(mBuild);
        sepolicyAnalyze = copyResourceToTempFile(""/sepolicy-analyze"");
        sepolicyAnalyze.setExecutable(true);

        devicePolicyFile = getDevicePolicyFile(mDevice);
        if (isSepolicySplit(mDevice)) {
            devicePlatFcFile = getDeviceFile(mDevice, cachedDevicePlatFcFiles,
                    ""/system/etc/selinux/plat_file_contexts"", ""plat_file_contexts"");
            if (mDevice.doesFileExist(""/vendor/etc/selinux/nonplat_file_contexts"")){
                // Old nonplat_* naming can be present if a framework-only OTA was done.
                deviceNonplatFcFile = getDeviceFile(mDevice, cachedDeviceNonplatFcFiles,
                        ""/vendor/etc/selinux/nonplat_file_contexts"", ""nonplat_file_contexts"");
            } else {
                deviceNonplatFcFile = getDeviceFile(mDevice, cachedDeviceNonplatFcFiles,
                        ""/vendor/etc/selinux/vendor_file_contexts"", ""vendor_file_contexts"");
            }
            deviceSystemPolicyFile =
                    android.security.cts.SELinuxHostTest.getDeviceSystemPolicyFile(mDevice);
        } else {
            devicePlatFcFile = getDeviceFile(mDevice, cachedDevicePlatFcFiles,
                    ""/plat_file_contexts"", ""plat_file_contexts"");
            deviceNonplatFcFile = getDeviceFile(mDevice, cachedDeviceNonplatFcFiles,
                    ""/vendor_file_contexts"", ""vendor_file_contexts"");
        }
    }

    private void assumeSecurityModelCompat() throws Exception {
        // This feature name check only applies to devices that first shipped with
        // SC or later.
        final int firstApiLevel = Math.min(PropertyUtil.getFirstApiLevel(mDevice),
                PropertyUtil.getVendorApiLevel(mDevice));
        if (firstApiLevel >= 31) {
            assumeTrue(""Skipping test: FEATURE_SECURITY_MODEL_COMPATIBLE missing."",
                    getDevice().hasFeature(""feature:android.hardware.security.model.compatible""));
        }
    }

    /*
     * IMPLEMENTATION DETAILS: We cache some host-side policy files on per-device basis (in case
     * CTS supports running against multiple devices at the same time). HashMap is used instead
     * of WeakHashMap because in the grand scheme of things, keeping ITestDevice and
     * corresponding File objects from being garbage-collected is not a big deal in CTS. If this
     * becomes a big deal, this can be switched to WeakHashMap.
     */
    private static File getDeviceFile(ITestDevice device,
            Map<ITestDevice, File> cache, String deviceFilePath,
            String tmpFileName) throws Exception {
        if (!device.doesFileExist(deviceFilePath)){
            throw new Exception();
        }
        File file;
        synchronized (cache) {
            file = cache.get(device);
        }
        if (file != null) {
            return file;
        }
        file = File.createTempFile(tmpFileName, "".tmp"");
        file.deleteOnExit();
        device.pullFile(deviceFilePath, file);
        synchronized (cache) {
            cache.put(device, file);
        }
        return file;
    }

    private static File buildSystemPolicy(ITestDevice device, Map<ITestDevice, File> cache,
            String tmpFileName) throws Exception {
        File builtPolicyFile;
        synchronized (cache) {
            builtPolicyFile = cache.get(device);
        }
        if (builtPolicyFile != null) {
            return builtPolicyFile;
        }


        builtPolicyFile = File.createTempFile(tmpFileName, "".tmp"");
        builtPolicyFile.deleteOnExit();

        File secilc = copyResourceToTempFile(""/secilc"");
        secilc.setExecutable(true);

        File systemSepolicyCilFile = File.createTempFile(""plat_sepolicy"", "".cil"");
        systemSepolicyCilFile.deleteOnExit();
        File fileContextsFile = File.createTempFile(""file_contexts"", "".txt"");
        fileContextsFile.deleteOnExit();

        assertTrue(device.pullFile(""/system/etc/selinux/plat_sepolicy.cil"", systemSepolicyCilFile));

        ProcessBuilder pb = new ProcessBuilder(
            secilc.getAbsolutePath(),
            ""-m"", ""-M"", ""true"", ""-c"", ""30"",
            ""-o"", builtPolicyFile.getAbsolutePath(),
     ""-f"", fileContextsFile.getAbsolutePath(),
            systemSepolicyCilFile.getAbsolutePath());
        pb.redirectOutput(ProcessBuilder.Redirect.PIPE);
        pb.redirectErrorStream(true);
        Process p = pb.start();
        p.waitFor();
        BufferedReader result = new BufferedReader(new InputStreamReader(p.getInputStream()));
        String line;
        StringBuilder errorString = new StringBuilder();
        while ((line = result.readLine()) != null) {
            errorString.append(line);
            errorString.append(""\n"");
        }
        assertTrue(errorString.toString(), errorString.length() == 0);

        synchronized (cache) {
            cache.put(device, builtPolicyFile);
        }
        return builtPolicyFile;
    }

    // NOTE: cts/tools/selinux depends on this method. Rename/change with caution.
    /**
     * Returns the host-side file containing the SELinux policy of the device under test.
     */
    public static File getDevicePolicyFile(ITestDevice device) throws Exception {
        return getDeviceFile(device, cachedDevicePolicyFiles, ""/sys/fs/selinux/policy"", ""sepolicy"");
    }

    // NOTE: cts/tools/selinux depends on this method. Rename/change with caution.
    /**
     * Returns the host-side file containing the system SELinux policy of the device under test.
     */
    public static File getDeviceSystemPolicyFile(ITestDevice device) throws Exception {
        return buildSystemPolicy(device, cachedDeviceSystemPolicy, ""system_sepolicy"");
    }

    // NOTE: cts/tools/selinux depends on this method. Rename/change with caution.
    /**
     * Returns the major number of sepolicy version of device's vendor implementation.
     */
    public static int getVendorSepolicyVersion(IBuildInfo build, ITestDevice device)
            throws Exception {

        // Try different methods to get vendor SEPolicy version in the following order:
        // 1. Retrieve from IBuildInfo as stored by DeviceInfoCollector (relies on #2)
        // 2. If it fails, retrieve from device info JSON file stored on the device
        //    (relies on android.os.VintfObject)
        // 3. If it fails, retrieve from raw VINTF device manifest files by guessing its path on
        //    the device
        // Usually, the method #1 should work. If it doesn't, fallback to method #2 and #3. If
        // none works, throw the error from method #1.
        Exception buildInfoEx;
        try {
            return getVendorSepolicyVersionFromBuildInfo(build);
        } catch (Exception ex) {
            CLog.e(""getVendorSepolicyVersionFromBuildInfo failed: "", ex);
            buildInfoEx = ex;
        }
        try {
            return getVendorSepolicyVersionFromDeviceJson(device);
        } catch (Exception ex) {
            CLog.e(""getVendorSepolicyVersionFromDeviceJson failed: "", ex);
        }
        try {
            return getVendorSepolicyVersionFromManifests(device);
        } catch (Exception ex) {
            CLog.e(""getVendorSepolicyVersionFromManifests failed: "", ex);
            throw buildInfoEx;
        }
    }

    /**
     * Retrieve the major number of sepolicy version from VINTF device info stored in the given
     * IBuildInfo by {@link DeviceInfoCollector}.
     */
    private static int getVendorSepolicyVersionFromBuildInfo(IBuildInfo build) throws Exception {
        File deviceInfoDir = build.getFile(DeviceInfoCollector.DEVICE_INFO_DIR);
        File vintfJson = deviceInfoDir.toPath().resolve(VINTF_DEVICE_JSON).toFile();
        return getVendorSepolicyVersionFromJsonFile(vintfJson);
    }

    /**
     * Retrieve the major number of sepolicy version from VINTF device info stored on the device by
     * VintfDeviceInfo.
     */
    private static int getVendorSepolicyVersionFromDeviceJson(ITestDevice device) throws Exception {
        File vintfJson = getDeviceFile(device, cachedDeviceVintfJson,
                DEVICE_INFO_DEVICE_DIR + VINTF_DEVICE_JSON, VINTF_DEVICE_JSON);
        return getVendorSepolicyVersionFromJsonFile(vintfJson);
    }

    /**
     * Retrieve the major number of sepolicy version from the given JSON string that contains VINTF
     * device info.
     */
    private static int getVendorSepolicyVersionFromJsonFile(File vintfJson) throws Exception {
        String content = FileUtil.readStringFromFile(vintfJson);
        JSONObject object = new JSONObject(content);
        String version = object.getString(SEPOLICY_VERSION_JSON_KEY);
        return getSepolicyVersionFromMajorMinor(version);
    }

    /**
     * Deprecated.
     * Retrieve the major number of sepolicy version from raw device manifest XML files.
     * Note that this is depends on locations of VINTF devices files at Android 10 and do not
     * search new paths, hence this may not work on devices launching Android 11 and later.
     */
    private static int getVendorSepolicyVersionFromManifests(ITestDevice device) throws Exception {
        String deviceManifestPath =
                (device.doesFileExist(""/vendor/etc/vintf/manifest.xml"")) ?
                ""/vendor/etc/vintf/manifest.xml"" :
                ""/vendor/manifest.xml"";
        File vendorManifestFile = getDeviceFile(device, cachedDeviceVendorManifest,
                deviceManifestPath, ""manifest.xml"");

        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
        DocumentBuilder db = dbf.newDocumentBuilder();
        Document doc = db.parse(vendorManifestFile);
        Element root = doc.getDocumentElement();
        Element sepolicy = (Element) root.getElementsByTagName(""sepolicy"").item(0);
        Element version = (Element) sepolicy.getElementsByTagName(""version"").item(0);
        return getSepolicyVersionFromMajorMinor(version.getTextContent());
    }

    // NOTE: cts/tools/selinux depends on this method. Rename/change with caution.
    /**
     * Returns the major number of sepolicy version of system.
     */
    public static int getSystemSepolicyVersion(IBuildInfo build) throws Exception {
        File deviceInfoDir = build.getFile(DeviceInfoCollector.DEVICE_INFO_DIR);
        File vintfJson = deviceInfoDir.toPath().resolve(VINTF_DEVICE_JSON).toFile();
        String content = FileUtil.readStringFromFile(vintfJson);
        JSONObject object = new JSONObject(content);
        String version = object.getString(PLATFORM_SEPOLICY_VERSION_JSON_KEY);
        return getSepolicyVersionFromMajorMinor(version);
    }

    /**
     * Get the major number from an SEPolicy version string, e.g. ""27.0"" => 27.
     */
    private static int getSepolicyVersionFromMajorMinor(String version) {
        String sepolicyVersion = version.split(""\\."")[0];
        return Integer.parseInt(sepolicyVersion);
    }

    /**
     * Tests that the kernel is enforcing selinux policy globally.
     *
     * @throws Exception
     */
    @CddTest(requirement=""9.7"")"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.security.cts.SELinuxHostTest"	"testGlobalEnforcing"	"CtsSecurityHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/security/src/android/security/cts/SELinuxHostTest.java"	""	"public void testGlobalEnforcing() throws Exception {
        CollectingOutputReceiver out = new CollectingOutputReceiver();
        mDevice.executeShellCommand(""cat /sys/fs/selinux/enforce"", out);
        assertEquals(""SELinux policy is not being enforced!"", ""1"", out.getOutput());
    }

    /**
     * Tests that all domains in the running policy file are in enforcing mode
     *
     * @throws Exception
     */
    @CddTest(requirement=""9.7"")
    @RestrictedBuildTest"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.security.cts.SELinuxHostTest"	"testRecoveryDomain"	"CtsSecurityHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/security/src/android/security/cts/SELinuxHostTest.java"	""	"public void testRecoveryDomain() throws DeviceNotAvailableException {
        assertDomainEmpty(""u:r:recovery:s0"");
    }

    /*
     * Nothing should be running in this domain, cardinality test is all thats
     * needed
     */
    @CddTest(requirement=""9.7"")
    @RestrictedBuildTest"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.content.pm.cts.ResourcesHardeningTest"	"isEmpty"	"CtsContentTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/ResourcesHardeningTest.java"	""	"/*
 *.
 */

package android.content.pm.cts;

import static android.content.pm.cts.PackageManagerShellCommandIncrementalTest.checkIncrementalDeliveryFeature;
import static android.content.pm.cts.PackageManagerShellCommandIncrementalTest.isAppInstalled;
import static android.content.pm.cts.PackageManagerShellCommandIncrementalTest.uninstallPackageSilently;

import static org.hamcrest.core.IsInstanceOf.instanceOf;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import android.app.ActivityManager;
import android.app.UiAutomation;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageManager;
import android.content.res.Resources;
import android.platform.test.annotations.AppModeFull;
import android.util.ArrayMap;

import androidx.test.InstrumentationRegistry;
import androidx.test.filters.LargeTest;
import androidx.test.runner.AndroidJUnit4;

import com.android.compatibility.common.util.MatcherUtils;
import com.android.incfs.install.IBlockFilter;
import com.android.incfs.install.IncrementalInstallSession;
import com.android.incfs.install.PendingBlock;

import com.example.helloworld.lib.TestUtils;

import org.apache.commons.compress.archivers.zip.ZipArchiveEntry;
import org.apache.commons.compress.archivers.zip.ZipFile;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;

@RunWith(AndroidJUnit4.class)
@AppModeFull
@LargeTest
public class ResourcesHardeningTest {
    private static final String TEST_APK_PATH = ""/data/local/tmp/cts/content/"";
    private static final String[] TEST_APKS = {
            ""HelloWorldResHardening.apk"",
            ""HelloWorldResHardening_mdpi-v4.apk"",
            ""HelloWorldResHardening_hdpi-v4.apk""
    };

    private static final String RES_TABLE_PATH = ""resources.arsc"";
    private static final int INCFS_BLOCK_SIZE = 4096;

    private final Map<String, List<RestrictedBlockRange>> mRestrictedRanges = new ArrayMap<>();

    @Before
    public void onBefore() throws Exception {
        checkIncrementalDeliveryFeature();

        // Set up the blocks that need to be restricted in order to test resource hardening.
        if (!mRestrictedRanges.isEmpty()) {
            return;
        }
        for (final String apk : TEST_APKS) {
            try (ZipFile zip = new ZipFile(TEST_APK_PATH + apk)) {
                final List<RestrictedBlockRange> infos = new ArrayList<>();
                RestrictedBlockRange info;
                info = restrictZipEntry(zip, RES_TABLE_PATH);
                if (info != null) {
                    infos.add(info);
                }
                // Restrict only the middle block of the compiled xml to test that the whole
                // file needs to be present just to open the xml file.
                info = restrictOnlyMiddleBlock(restrictZipEntry(zip, TestUtils.RES_XML_PATH));
                if (info != null) {
                    infos.add(info);
                }
                // Restrict only the middle block of this file to test that the whole file does
                // NOT need to be present just to create an input stream or fd.
                info = restrictOnlyMiddleBlock(
                        restrictZipEntry(zip, TestUtils.RES_DRAWABLE_MDPI_PATH));
                if (info != null) {
                    infos.add(info);
                }
                // Test that FileNotFoundExceptions are thrown when the file is missing.
                info = restrictZipEntry(zip, TestUtils.RES_DRAWABLE_HDPI_PATH);
                if (info != null) {
                    infos.add(info);
                }
                assertFalse(infos.isEmpty());
                mRestrictedRanges.put(apk, infos);
            }
        }
    }"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.content.pm.cts.ResourcesHardeningTest"	"TestBlockFilter"	"CtsContentTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/ResourcesHardeningTest.java"	""	"public void checkOpenFdRemote() throws Exception {
        // Failing to read missing blocks through a file descriptor using read/pread causes an
        // IOException to be thrown.
        testIncrementalOwnPackageResources(TestUtils.TEST_OPEN_FILE_FD, false /* expectCrash */);
    }

    private interface TestFunction {
        void apply(Resources res, TestUtils.AssertionType type) throws Exception;
    }

    /**
     * Installs a package incrementally and tests that retrieval of that package's resources from
     * within this process does not crash this process and instead falls back to some default
     * behavior.
     */
    private void testIncrementalForeignPackageResources(TestFunction test) throws Exception {
        try (ShellInstallSession session = startInstallSession()) {
            test.apply(session.getPackageResources(), TestUtils.AssertionType.ASSERT_SUCCESS);
        }
        try (ShellInstallSession session = startInstallSession()) {
            session.enableBlockRestrictions();
            test.apply(session.getPackageResources(), TestUtils.AssertionType.ASSERT_READ_FAILURE);
        }
    }

    /**
     * Installs a package incrementally and tests that the package crashes when it fails to retrieve
     * its own resources due to incremental installation.
     */
    private void testIncrementalOwnPackageResources(String testName, boolean expectCrash)
            throws Exception {
        try (RemoteTest session = new RemoteTest(startInstallSession(), testName)) {
            session.mSession.getPackageResources();
            session.start(true /* assertSuccess */);
        }

        try (RemoteTest session = new RemoteTest(startInstallSession(), testName)) {
            session.mSession.getPackageResources();
            session.mSession.enableBlockRestrictions();
            if (expectCrash) {
                MatcherUtils.assertThrows(instanceOf(RemoteProcessCrashedException.class),
                        () -> session.start(false /* assertSuccess */));
            } else {
                session.start(false /* assertSuccess */);
            }
        }
    }

    private void testIncrementalOwnPackageResources(String testName) throws Exception {
        testIncrementalOwnPackageResources(testName, true /* expectCrash */);
    }

    private static class RemoteProcessCrashedException extends RuntimeException {
    }

    private static class RemoteTest implements AutoCloseable {
        private static final int SPIN_SLEEP_MS = 500;
        private static final long RESPONSE_TIMEOUT_MS = 60 * 1000;

        private final ShellInstallSession mSession;
        private final String mTestName;

        RemoteTest(ShellInstallSession session, String testName) {
            mSession = session;
            mTestName = testName;
        }

        public void start(boolean assertSuccess) throws Exception {
            final AtomicInteger pid = new AtomicInteger();
            final IntentFilter statusFilter = new IntentFilter(TestUtils.TEST_STATUS_ACTION);

            final TestUtils.BroadcastDetector pidDetector = new TestUtils.BroadcastDetector(
                    getContext(), statusFilter, (Context context, Intent intent) -> {
                if (intent.hasExtra(TestUtils.PID_STATUS_PID_KEY)) {
                    pid.set(intent.getIntExtra(TestUtils.PID_STATUS_PID_KEY, -1));
                    return true;
                }
                return false;
            });

            final TestUtils.BroadcastDetector finishDetector = new TestUtils.BroadcastDetector(
                    getContext(), statusFilter, (Context context, Intent intent) -> {
                if (intent.hasExtra(TestUtils.TEST_STATUS_RESULT_KEY)) {
                    final String reason = intent.getStringExtra(TestUtils.TEST_STATUS_RESULT_KEY);
                    if (!reason.equals(TestUtils.TEST_STATUS_RESULT_SUCCESS)) {
                        throw new IllegalStateException(""Remote test failed: "" + reason);
                    }
                    return true;
                }
                return false;
            });

            // Start the test app and indicate which test to run.
            try (pidDetector; finishDetector) {
                final Intent launchIntent = new Intent(Intent.ACTION_VIEW);
                launchIntent.setClassName(TestUtils.TEST_APP_PACKAGE, TestUtils.TEST_ACTIVITY_NAME);
                launchIntent.putExtra(TestUtils.TEST_NAME_EXTRA_KEY, mTestName);
                launchIntent.putExtra(TestUtils.TEST_ASSERT_SUCCESS_EXTRA_KEY, assertSuccess);
                launchIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK
                        | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);

                getContext().startActivity(launchIntent);

                // The test app must respond with a broadcast containing its pid so this test can
                // check if the test app crashes.
                assertTrue(""Timed out while waiting for pid"",
                        pidDetector.waitForBroadcast(RESPONSE_TIMEOUT_MS, TimeUnit.MILLISECONDS));

                // Wait for the test app to finish testing or crash.
                final ActivityManager am = getActivityManager();
                final int remotePid = pid.get();
                for (int i = 0; i < (RESPONSE_TIMEOUT_MS / SPIN_SLEEP_MS); i++) {
                    if (am.getRunningAppProcesses().stream().noneMatch(
                            info -> info.pid == remotePid)) {
                        throw new RemoteProcessCrashedException();
                    }
                    if (finishDetector.waitForBroadcast(SPIN_SLEEP_MS, TimeUnit.MILLISECONDS)) {
                        return;
                    }
                }
                throw new TimeoutException(""Timed out while waiting for remote test to finish"");
            }
        }

        @Override
        public void close() throws Exception {
            mSession.close();
        }
    }

    private ShellInstallSession startInstallSession() throws IOException,
            InterruptedException {
        return startInstallSession(TEST_APKS, TestUtils.TEST_APP_PACKAGE);
    }

    private ShellInstallSession startInstallSession(String[] apks, String packageName)
            throws IOException, InterruptedException {
        final String v4SignatureSuffix = "".idsig"";
        final TestBlockFilter filter = new TestBlockFilter();
        final IncrementalInstallSession.Builder builder = new IncrementalInstallSession.Builder()
                .addExtraArgs(""-t"", ""-i"", getContext().getPackageName())
                .setLogger(new IncrementalDeviceConnection.Logger())
                .setBlockFilter(filter);
        for (final String apk : apks) {
            final String path = TEST_APK_PATH + apk;
            builder.addApk(Paths.get(path), Paths.get(path + v4SignatureSuffix));
        }

        final ShellInstallSession session = new ShellInstallSession(
                builder.build(), filter, packageName);
        session.session.start(Executors.newSingleThreadExecutor(),
                IncrementalDeviceConnection.Factory.reliable());
        session.session.waitForInstallCompleted(10, TimeUnit.SECONDS);
        assertTrue(isAppInstalled(packageName));
        return session;
    }

    /**
     * A wrapper for {@link IncrementalInstallSession} that uninstalls the installed package when
     * testing is finished.
     */
    private static class ShellInstallSession implements AutoCloseable {
        public final IncrementalInstallSession session;
        private final TestBlockFilter mFilter;
        private final String mPackageName;

        private ShellInstallSession(IncrementalInstallSession session,
                TestBlockFilter filter, String packageName) {
            this.session = session;
            this.mFilter = filter;
            this.mPackageName = packageName;
            getUiAutomation().adoptShellPermissionIdentity();
        }

        public void enableBlockRestrictions() {
            mFilter.enableBlockRestrictions();
        }

        public Resources getPackageResources() throws PackageManager.NameNotFoundException {
            return getContext().createPackageContext(mPackageName, 0).getResources();
        }

        @Override
        public void close() throws IOException {
            session.close();
            getUiAutomation().dropShellPermissionIdentity();
            uninstallPackageSilently(mPackageName);
        }
    }

    private class TestBlockFilter implements IBlockFilter {
        private final AtomicBoolean mRestrictBlocks = new AtomicBoolean(false);

        @Override
        public boolean shouldServeBlock(PendingBlock block) {
            if (!mRestrictBlocks.get() || block.getType() == PendingBlock.Type.SIGNATURE_TREE) {
                // Always send signature blocks and always send blocks when enableBlockRestrictions
                // has not been called.
                return true;
            }

            // Allow the block to be served if it does not reside in a restricted range.
            final String apkFileName = block.getPath().getFileName().toString();
            return mRestrictedRanges.get(apkFileName).stream().noneMatch(
                    info -> info.dataStartBlockIndex <= block.getBlockIndex()
                            && block.getBlockIndex() <= info.dataEndBlockIndex);
        }

        public void enableBlockRestrictions() {
            mRestrictBlocks.set(true);
        }
    }

    private static class RestrictedBlockRange {
        public final String entryName;
        public final int dataStartBlockIndex;
        public final int dataEndBlockIndex;

        RestrictedBlockRange(String zipEntryName, int dataStartBlockIndex,
                int dataEndBlockIndex) {
            this.entryName = zipEntryName;
            this.dataStartBlockIndex = dataStartBlockIndex;
            this.dataEndBlockIndex = dataEndBlockIndex;
        }
    }

    private static RestrictedBlockRange restrictZipEntry(ZipFile file, String entryFileName) {
        final ZipArchiveEntry info = file.getEntry(entryFileName);
        if (info == null) return null;
        final long headerSize = entryFileName.getBytes(StandardCharsets.UTF_8).length + 30;
        final int dataStartBlock = (int) (info.getDataOffset() - headerSize) / INCFS_BLOCK_SIZE;
        final int dataEndBlock = (int) (info.getDataOffset() + info.getCompressedSize())
                / INCFS_BLOCK_SIZE;
        return new RestrictedBlockRange(entryFileName, dataStartBlock, dataEndBlock);
    }

    private static RestrictedBlockRange restrictOnlyMiddleBlock(RestrictedBlockRange info) {
        if (info == null) return null;
        assertTrue(info.dataEndBlockIndex - info.dataStartBlockIndex > 2);
        final int middleBlock = (info.dataStartBlockIndex + info.dataEndBlockIndex) / 2;
        return new RestrictedBlockRange(info.entryName, middleBlock, middleBlock);
    }

    private static Context getContext() {
        return InstrumentationRegistry.getInstrumentation().getContext();
    }

    private static UiAutomation getUiAutomation() {
        return InstrumentationRegistry.getInstrumentation().getUiAutomation();
    }

    private static ActivityManager getActivityManager() {
        return (ActivityManager) getContext().getSystemService(Context.ACTIVITY_SERVICE);
    }
}"	""	""	"restricted restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.managedprovisioning.PolicyTransparencyTestListActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/managedprovisioning/PolicyTransparencyTestListActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.managedprovisioning;

import android.content.Intent;
import android.content.pm.PackageManager;
import android.database.DataSetObserver;
import android.os.Bundle;
import android.provider.Settings;
import android.util.Pair;
import android.view.View;

import com.android.cts.verifier.ArrayTestListAdapter;
import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;
import com.android.cts.verifier.TestListAdapter.TestListItem;
import com.android.cts.verifier.features.FeatureUtil;

import java.util.Arrays;
import java.util.List;

/**
 * Test class to verify transparency for policies enforced by device/profile owner.
 */
public class PolicyTransparencyTestListActivity extends PassFailButtons.TestListActivity
        implements View.OnClickListener {
    public static final String ACTION_CHECK_POLICY_TRANSPARENCY =
            ""com.android.cts.verifier.managedprovisioning.action.CHECK_POLICY_TRANSPARENCY"";

    public static final String EXTRA_MODE =
            ""com.android.cts.verifier.managedprovisioning.extra.mode"";

    public static final int MODE_DEVICE_OWNER = 1;
    public static final int MODE_MANAGED_PROFILE = 2;
    public static final int MODE_MANAGED_USER = 4;

    /**
     * Pairs of:
     * <ul>
     *   <li>An intent to start {@link PolicyTransparencyTestActivity}
     *   <li>a label to show the user.
     * </ul>
     * These contain all the policies except for the user restriction ones.
     */
    private static final Pair<Intent, Integer>[] POLICIES;
    static {
        final String[] policyTests = new String[] {
            PolicyTransparencyTestActivity.TEST_CHECK_AUTO_TIME_REQUIRED,
            PolicyTransparencyTestActivity.TEST_CHECK_KEYGURAD_UNREDACTED_NOTIFICATION,
            PolicyTransparencyTestActivity.TEST_CHECK_LOCK_SCREEN_INFO,
            PolicyTransparencyTestActivity.TEST_CHECK_MAXIMUM_TIME_TO_LOCK,
            PolicyTransparencyTestActivity.TEST_CHECK_PERMITTED_ACCESSIBILITY_SERVICE,
            PolicyTransparencyTestActivity.TEST_CHECK_PERMITTED_INPUT_METHOD
        };
        final String[] settingsIntentActions = new String[] {
            Settings.ACTION_DATE_SETTINGS,
            Settings.ACTION_SETTINGS,
            Settings.ACTION_DISPLAY_SETTINGS,
            Settings.ACTION_DISPLAY_SETTINGS,
            Settings.ACTION_ACCESSIBILITY_SETTINGS,
            Settings.ACTION_SETTINGS
        };
        final int[] policyLabels = new int[] {
            R.string.set_auto_time_required,
            R.string.disallow_keyguard_unredacted_notifications,
            R.string.set_lock_screen_info,
            R.string.set_maximum_time_to_lock,
            R.string.set_permitted_accessibility_services,
            R.string.set_permitted_input_methods
        };
        if (policyTests.length != settingsIntentActions.length ||
                policyTests.length != policyLabels.length) {
            throw new AssertionError(""Number of items in policyTests, ""
                    + "" settingsIntentActions and policyLabels do not match"");
        }
        POLICIES = new Pair[policyTests.length];
        for (int i = 0; i < policyTests.length; ++i) {
            final Intent intent =
                    new Intent(PolicyTransparencyTestActivity.ACTION_SHOW_POLICY_TRANSPARENCY_TEST)
                            .putExtra(PolicyTransparencyTestActivity.EXTRA_TEST, policyTests[i])
                            .putExtra(PolicyTransparencyTestActivity.EXTRA_SETTINGS_INTENT_ACTION,
                                    settingsIntentActions[i]);
            POLICIES[i] = Pair.create(intent, policyLabels[i]);
        }
    }

    private static final List<String> ALSO_VALID_FOR_MANAGED_PROFILE = Arrays.asList(
            PolicyTransparencyTestActivity.TEST_CHECK_PERMITTED_ACCESSIBILITY_SERVICE,
            PolicyTransparencyTestActivity.TEST_CHECK_PERMITTED_INPUT_METHOD);
    private static final List<String> ALSO_VALID_FOR_MANAGED_USER = Arrays.asList(
            PolicyTransparencyTestActivity.TEST_CHECK_PERMITTED_ACCESSIBILITY_SERVICE,
            PolicyTransparencyTestActivity.TEST_CHECK_PERMITTED_INPUT_METHOD);

    private int mMode;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.policy_transparency_test_list);
        setInfoResources(R.string.device_profile_owner_policy_transparency_test,
                R.string.device_profile_owner_policy_transparency_test_info, 0);
        setPassFailButtonClickListeners();
        setSupportMsgButtonClickListeners();

        if (!getIntent().hasExtra(EXTRA_MODE)) {
            throw new RuntimeException(""PolicyTransparencyTestListActivity started without extra ""
                    + EXTRA_MODE);
        }
        mMode = getIntent().getIntExtra(EXTRA_MODE, MODE_DEVICE_OWNER);
        if (mMode != MODE_DEVICE_OWNER && mMode != MODE_MANAGED_PROFILE
                && mMode != MODE_MANAGED_USER) {
            throw new RuntimeException(""Unknown mode "" + mMode);
        }

        final ArrayTestListAdapter adapter = new ArrayTestListAdapter(this);
        addTestsToAdapter(adapter);
        adapter.registerDataSetObserver(new DataSetObserver() {
            @Override
            public void onChanged() {
                updatePassButton();
            }
        });

        setTestListAdapter(adapter);
    }

    private void addTestsToAdapter(final ArrayTestListAdapter adapter) {
        for (String restriction :
                UserRestrictions.getUserRestrictionsForPolicyTransparency(mMode)) {
            Intent intent =
                    UserRestrictions.getUserRestrictionTestIntent(this, restriction, mMode);
            if (!UserRestrictions.isRestrictionValid(this, restriction)) {
                continue;
            }
            String title = UserRestrictions.getRestrictionLabel(this, restriction);
            String testId = getTestId(title);
            intent.putExtra(PolicyTransparencyTestActivity.EXTRA_TEST_ID, testId);
            adapter.add(TestListItem.newTest(title, testId, intent, null));
        }
        for (Pair<Intent, Integer> policy : POLICIES) {
            Intent intent = policy.first;
            String test = intent.getStringExtra(PolicyTransparencyTestActivity.EXTRA_TEST);
            if (!isPolicyValid(test)) {
                continue;
            }

            String action = intent.getStringExtra(
                    PolicyTransparencyTestActivity.EXTRA_SETTINGS_INTENT_ACTION);
            if (mMode == MODE_MANAGED_PROFILE && !ALSO_VALID_FOR_MANAGED_PROFILE.contains(test)) {
                continue;
            }
            if (mMode == MODE_MANAGED_USER && !ALSO_VALID_FOR_MANAGED_USER.contains(test)) {
                continue;
            }
            String title = getString(policy.second);
            String testId = getTestId(title);
            intent.putExtra(PolicyTransparencyTestActivity.EXTRA_TITLE, title);
            intent.putExtra(PolicyTransparencyTestActivity.EXTRA_TEST_ID, testId);
            adapter.add(TestListItem.newTest(title, testId, intent, null));
        }
    }

    private String getTestId(String title) {
        if (mMode == MODE_DEVICE_OWNER) {
            return ""DO_"" + title;
        } else if (mMode == MODE_MANAGED_PROFILE) {
            return ""MP_"" + title;
        } else if (mMode == MODE_MANAGED_USER) {
            return ""MU_"" + title;
        }
        throw new RuntimeException(""Unknown mode "" + mMode);
    }

    private boolean isPolicyValid(String test) {
        final PackageManager pm = getPackageManager();
        switch (test) {
            case PolicyTransparencyTestActivity.TEST_CHECK_PERMITTED_INPUT_METHOD:
                return pm.hasSystemFeature(PackageManager.FEATURE_INPUT_METHODS);
            case PolicyTransparencyTestActivity.TEST_CHECK_PERMITTED_ACCESSIBILITY_SERVICE:
                return (pm.hasSystemFeature(PackageManager.FEATURE_AUDIO_OUTPUT)
                        && FeatureUtil.isThirdPartyAccessibilityServiceSupported(this));
            case PolicyTransparencyTestActivity.TEST_CHECK_KEYGURAD_UNREDACTED_NOTIFICATION:
            case PolicyTransparencyTestActivity.TEST_CHECK_LOCK_SCREEN_INFO:
            case PolicyTransparencyTestActivity.TEST_CHECK_MAXIMUM_TIME_TO_LOCK:
                return (pm.hasSystemFeature(PackageManager.FEATURE_SECURE_LOCK_SCREEN)
                        && FeatureUtil.isConfigLockScreenSupported(this));
            default:
                return true;
        }
    }

    private void setSupportMsgButtonClickListeners() {
        findViewById(R.id.short_msg_button).setOnClickListener(this);
        findViewById(R.id.long_msg_button).setOnClickListener(this);
    }

    @Override
    public void onClick(View view) {
        if (view.getId() == R.id.short_msg_button) {
            final Intent intent = new Intent(SetSupportMessageActivity.ACTION_SET_SUPPORT_MSG);
            intent.putExtra(SetSupportMessageActivity.EXTRA_SUPPORT_MSG_TYPE,
                    SetSupportMessageActivity.TYPE_SHORT_MSG);
            startActivity(intent);
        } else if (view.getId() == R.id.long_msg_button) {
            final Intent intent = new Intent(SetSupportMessageActivity.ACTION_SET_SUPPORT_MSG);
            intent.putExtra(SetSupportMessageActivity.EXTRA_SUPPORT_MSG_TYPE,
                    SetSupportMessageActivity.TYPE_LONG_MSG);
            startActivity(intent);
        }
    }

    @Override
    public String getTestId() {
        return getIntent().getStringExtra(PolicyTransparencyTestActivity.EXTRA_TEST_ID);
    }

    @Override
    public void finish() {
        super.finish();
        final Intent intent = new Intent(CommandReceiverActivity.ACTION_EXECUTE_COMMAND);
        intent.putExtra(CommandReceiverActivity.EXTRA_COMMAND,
                CommandReceiverActivity.COMMAND_CLEAR_POLICIES);
        intent.putExtra(PolicyTransparencyTestListActivity.EXTRA_MODE, mMode);
        startActivity(intent);
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.ConnectedNetworkScorerTest"	"testSetWifiConnectedNetworkScorerOnSubsystemRestart"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ConnectedNetworkScorerTest.java"	""	"public void testSetWifiConnectedNetworkScorerOnSubsystemRestart() throws Exception {
        CountDownLatch countDownLatchScorer = new CountDownLatch(1);
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        TestConnectedNetworkScorerWithSessionInfo connectedNetworkScorer =
                new TestConnectedNetworkScorerWithSessionInfo(countDownLatchScorer);
        try {
            uiAutomation.adoptShellPermissionIdentity();
            // Clear any external scorer already active on the device.
            mWifiManager.clearWifiConnectedNetworkScorer();
            Thread.sleep(500);

            mWifiManager.setWifiConnectedNetworkScorer(
                    Executors.newSingleThreadExecutor(), connectedNetworkScorer);
            // Since we're already connected, wait for onStart to be invoked.
            assertThat(countDownLatchScorer.await(TIMEOUT, TimeUnit.MILLISECONDS)).isTrue();

            int prevSessionId = connectedNetworkScorer.startSessionId;
            WifiManager.ScoreUpdateObserver prevScoreUpdateObserver =
                    connectedNetworkScorer.scoreUpdateObserver;

            // Expect one stop followed by one start after the restart

            // Ensure that we got an onStop() for the previous connection when restart is invoked.
            countDownLatchScorer = new CountDownLatch(1);
            connectedNetworkScorer.resetCountDownLatch(countDownLatchScorer);

            // Restart wifi subsystem.
            mWifiManager.restartWifiSubsystem();
            // Wait for the device to connect back.
            PollingCheck.check(
                    ""Wifi not connected"",
                    WIFI_CONNECT_TIMEOUT_MILLIS * 2,
                    () -> mWifiManager.getConnectionInfo().getNetworkId() != -1);

            assertThat(countDownLatchScorer.await(TIMEOUT, TimeUnit.MILLISECONDS)).isTrue();
            assertThat(connectedNetworkScorer.stopSessionId).isEqualTo(prevSessionId);

            // Followed by a new onStart() after the connection.
            // Note: There is a 5 second delay between stop/start when restartWifiSubsystem() is
            // invoked, so this should not be racy.
            countDownLatchScorer = new CountDownLatch(1);
            connectedNetworkScorer.resetCountDownLatch(countDownLatchScorer);
            assertThat(countDownLatchScorer.await(TIMEOUT, TimeUnit.MILLISECONDS)).isTrue();
            assertThat(connectedNetworkScorer.startSessionId).isNotEqualTo(prevSessionId);

            // Ensure that we did not get a new score update observer.
            assertThat(connectedNetworkScorer.scoreUpdateObserver).isSameInstanceAs(
                    prevScoreUpdateObserver);
        } finally {
            mWifiManager.clearWifiConnectedNetworkScorer();
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    private interface ConnectionInitiator {
        /**
         * Trigger connection (using suggestion or specifier) to the provided network.
         */
        ConnectivityManager.NetworkCallback initiateConnection(
                @NonNull WifiConfiguration testNetwork,
                @NonNull ScheduledExecutorService executorService) throws Exception;
    }

    private void setWifiConnectedNetworkScorerAndInitiateConnectToSpecifierOrRestrictedSuggestion(
            @NonNull ConnectionInitiator connectionInitiator) throws Exception {
        CountDownLatch countDownLatchScorer = new CountDownLatch(1);
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        TestConnectedNetworkScorerWithSessionInfo connectedNetworkScorer =
                new TestConnectedNetworkScorerWithSessionInfo(countDownLatchScorer);
        ConnectivityManager.NetworkCallback networkCallback = null;
        ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor();
        List<WifiConfiguration> savedNetworks = null;
        try {
            uiAutomation.adoptShellPermissionIdentity(
                    NETWORK_SETTINGS, WIFI_UPDATE_USABILITY_STATS_SCORE, CONNECTIVITY_INTERNAL,
                    READ_WIFI_CREDENTIAL);

            // Clear any external scorer already active on the device.
            mWifiManager.clearWifiConnectedNetworkScorer();
            Thread.sleep(500);

            savedNetworks = mWifiManager.getPrivilegedConfiguredNetworks();
            WifiConfiguration testNetwork =
                    TestHelper.findMatchingSavedNetworksWithBssid(mWifiManager, savedNetworks)
                            .get(0);
            // Disconnect & disable auto-join on the saved network to prevent auto-connect from
            // interfering with the test.
            for (WifiConfiguration savedNetwork : savedNetworks) {
                mWifiManager.disableNetwork(savedNetwork.networkId);
            }
            // Wait for Wifi to be disconnected.
            PollingCheck.check(
                    ""Wifi not disconnected"",
                    20000,
                    () -> mWifiManager.getConnectionInfo().getNetworkId() == -1);
            assertThat(testNetwork).isNotNull();

            // Register the external scorer.
            mWifiManager.setWifiConnectedNetworkScorer(
                    Executors.newSingleThreadExecutor(), connectedNetworkScorer);

            // Now connect using the provided connection initiator
            networkCallback = connectionInitiator.initiateConnection(testNetwork, executorService);

            // We should not receive the start
            assertThat(countDownLatchScorer.await(WAIT_DURATION, TimeUnit.MILLISECONDS)).isFalse();
            assertThat(connectedNetworkScorer.startSessionId).isNull();

            // Now disconnect from the network.
            mConnectivityManager.unregisterNetworkCallback(networkCallback);
            networkCallback = null;

            // We should not receive the stop either
            countDownLatchScorer = new CountDownLatch(1);
            connectedNetworkScorer.resetCountDownLatch(countDownLatchScorer);
            assertThat(countDownLatchScorer.await(WAIT_DURATION, TimeUnit.MILLISECONDS)).isFalse();
            assertThat(connectedNetworkScorer.stopSessionId).isNull();
        } finally {
            executorService.shutdownNow();
            mWifiManager.clearWifiConnectedNetworkScorer();
            if (networkCallback != null) {
                mConnectivityManager.unregisterNetworkCallback(networkCallback);
            }
            // Re-enable the networks after the test.
            if (savedNetworks != null) {
                for (WifiConfiguration savedNetwork : savedNetworks) {
                    mWifiManager.enableNetwork(savedNetwork.networkId, false);
                }
            }
            uiAutomation.dropShellPermissionIdentity();
        }
    }
    /**
     * Tests the {@link android.net.wifi.WifiConnectedNetworkScorer} interface.
     *
     * Verifies that the external scorer is not notified for local only connections.
     */"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.ConnectedNetworkScorerTest"	"testSetWifiConnectedNetworkScorerForSpecifierConnection"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ConnectedNetworkScorerTest.java"	""	"public void testSetWifiConnectedNetworkScorerForSpecifierConnection() throws Exception {
        setWifiConnectedNetworkScorerAndInitiateConnectToSpecifierOrRestrictedSuggestion(
                (testNetwork, executorService) -> {
                    // Connect using wifi network specifier.
                    WifiNetworkSpecifier specifier =
                            TestHelper.createSpecifierBuilderWithCredentialFromSavedNetwork(
                                    testNetwork)
                                    .build();
                    return mTestHelper.testConnectionFlowWithSpecifierWithShellIdentity(
                            testNetwork, specifier, false);
                }
        );
    }

    private void testSetWifiConnectedNetworkScorerForRestrictedSuggestionConnection(
            Set<Integer> restrictedNetworkCapabilities) throws Exception {
        setWifiConnectedNetworkScorerAndInitiateConnectToSpecifierOrRestrictedSuggestion(
                (testNetwork, executorService) -> {
                    // Connect using wifi network suggestion.
                    WifiNetworkSuggestion.Builder suggestionBuilder =
                            TestHelper
                                    .createSuggestionBuilderWithCredentialFromSavedNetworkWithBssid(
                                    testNetwork);
                    if (restrictedNetworkCapabilities.contains(NET_CAPABILITY_OEM_PAID)) {
                        suggestionBuilder.setOemPaid(true);
                    }
                    if (restrictedNetworkCapabilities.contains(NET_CAPABILITY_OEM_PRIVATE)) {
                        suggestionBuilder.setOemPrivate(true);
                    }
                    return mTestHelper.testConnectionFlowWithSuggestionWithShellIdentity(
                            testNetwork, suggestionBuilder.build(), executorService,
                            restrictedNetworkCapabilities);
                }
        );
    }

    /**
     * Tests the {@link android.net.wifi.WifiConnectedNetworkScorer} interface.
     *
     * Verifies that the external scorer is not notified for oem paid suggestion connections.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.ConnectedNetworkScorerTest"	"testSetWifiConnectedNetworkScorerForOemPaidSuggestionConnection"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ConnectedNetworkScorerTest.java"	""	"public void testSetWifiConnectedNetworkScorerForOemPaidSuggestionConnection() throws Exception {
        testSetWifiConnectedNetworkScorerForRestrictedSuggestionConnection(
                Set.of(NET_CAPABILITY_OEM_PAID));
    }

    /**
     * Tests the {@link android.net.wifi.WifiConnectedNetworkScorer} interface.
     *
     * Verifies that the external scorer is not notified for oem private suggestion connections.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.ConnectedNetworkScorerTest"	"testSetWifiConnectedNetworkScorerForOemPrivateSuggestionConnection"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ConnectedNetworkScorerTest.java"	""	"public void testSetWifiConnectedNetworkScorerForOemPrivateSuggestionConnection()
            throws Exception {
        testSetWifiConnectedNetworkScorerForRestrictedSuggestionConnection(
                Set.of(NET_CAPABILITY_OEM_PRIVATE));
    }
}"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.suspendapps.cts.DualSuspendTests"	"addAndAssertProfileOwner"	"CtsSuspendAppsTestCases"	"/home/gpoor/cts-12-source/cts/tests/suspendapps/tests/src/android/suspendapps/cts/DualSuspendTests.java"	""	"/*
 *.
 */

package android.suspendapps.cts;

import static android.content.Intent.EXTRA_PACKAGE_NAME;
import static android.os.UserManager.DISALLOW_APPS_CONTROL;
import static android.os.UserManager.DISALLOW_UNINSTALL_APPS;
import static android.suspendapps.cts.Constants.ALL_TEST_PACKAGES;
import static android.suspendapps.cts.Constants.DEVICE_ADMIN_COMPONENT;
import static android.suspendapps.cts.Constants.TEST_APP_PACKAGE_NAME;
import static android.suspendapps.cts.Constants.TEST_PACKAGE_ARRAY;
import static android.suspendapps.cts.SuspendTestUtils.addAndAssertProfileOwner;
import static android.suspendapps.cts.SuspendTestUtils.createSingleKeyBundle;
import static android.suspendapps.cts.SuspendTestUtils.removeDeviceAdmin;
import static android.suspendapps.cts.SuspendTestUtils.requestDpmAction;

import static com.android.suspendapps.testdeviceadmin.TestCommsReceiver.ACTION_ADD_USER_RESTRICTION;
import static com.android.suspendapps.testdeviceadmin.TestCommsReceiver.ACTION_BLOCK_UNINSTALL;
import static com.android.suspendapps.testdeviceadmin.TestCommsReceiver.ACTION_SUSPEND;
import static com.android.suspendapps.testdeviceadmin.TestCommsReceiver.ACTION_UNBLOCK_UNINSTALL;
import static com.android.suspendapps.testdeviceadmin.TestCommsReceiver.ACTION_UNSUSPEND;
import static com.android.suspendapps.testdeviceadmin.TestCommsReceiver.EXTRA_USER_RESTRICTION;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assume.assumeTrue;

import android.app.admin.DevicePolicyManager;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.os.Bundle;
import android.os.Handler;
import android.os.Looper;

import androidx.test.InstrumentationRegistry;
import androidx.test.filters.LargeTest;
import androidx.test.runner.AndroidJUnit4;

import com.android.compatibility.common.util.FeatureUtil;

import libcore.util.EmptyArray;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

@RunWith(AndroidJUnit4.class)
@LargeTest
public class DualSuspendTests {
    private Context mContext;
    private Handler mReceiverHandler;
    private TestAppInterface mTestAppInterface;

    @Before
    public void setUp() {
        mContext = InstrumentationRegistry.getTargetContext();
        mReceiverHandler = new Handler(Looper.getMainLooper());
        assumeTrue(""Skipping test that requires device admin"",
                FeatureUtil.hasSystemFeature(PackageManager.FEATURE_DEVICE_ADMIN));
        addAndAssertProfileOwner();
    }

    private boolean setSuspendViaDpm(boolean suspend) throws Exception {
        return requestDpmAction(suspend ? ACTION_SUSPEND : ACTION_UNSUSPEND,
                createSingleKeyBundle(Intent.EXTRA_PACKAGE_NAME, TEST_APP_PACKAGE_NAME),
                mReceiverHandler);
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.suspendapps.cts.DualSuspendTests"	"testIsPackageSuspended"	"CtsSuspendAppsTestCases"	"/home/gpoor/cts-12-source/cts/tests/suspendapps/tests/src/android/suspendapps/cts/DualSuspendTests.java"	""	"public void testIsPackageSuspended() throws Exception {
        final PackageManager pm = mContext.getPackageManager();
        assertFalse(pm.isPackageSuspended(TEST_APP_PACKAGE_NAME));
        SuspendTestUtils.suspend(null, null, null);
        assertTrue(""Suspend via dpm failed"", setSuspendViaDpm(true));
        assertTrue(""Package should be suspended by both"",
                pm.isPackageSuspended(TEST_APP_PACKAGE_NAME));
        SuspendTestUtils.unsuspendAll();
        assertTrue(""Package should be suspended by dpm"",
                pm.isPackageSuspended(TEST_APP_PACKAGE_NAME));
        SuspendTestUtils.suspend(null, null, null);
        assertTrue(""Unsuspend via dpm failed"", setSuspendViaDpm(false));
        assertTrue(""Package should be suspended by shell"",
                pm.isPackageSuspended(TEST_APP_PACKAGE_NAME));
        SuspendTestUtils.unsuspendAll();
        assertFalse(""Package should be suspended by neither"",
                pm.isPackageSuspended(TEST_APP_PACKAGE_NAME));
    }

    private void assertDpmCanSuspendUnderUserRestriction(String userRestriction) throws Exception {
        mTestAppInterface = new TestAppInterface(mContext);
        final Bundle extra = createSingleKeyBundle(EXTRA_USER_RESTRICTION, userRestriction);
        assertTrue(""Request to add restriction"" + userRestriction + "" failed"",
                requestDpmAction(ACTION_ADD_USER_RESTRICTION, extra, mReceiverHandler));
        assertTrue(""Request to suspend via dpm failed"", setSuspendViaDpm(true));

        assertTrue(""Test app not suspended"", mTestAppInterface.isTestAppSuspended());
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.suspendapps.cts.DualSuspendTests"	"testDpmCanSuspendUnderDisallowAppsControl"	"CtsSuspendAppsTestCases"	"/home/gpoor/cts-12-source/cts/tests/suspendapps/tests/src/android/suspendapps/cts/DualSuspendTests.java"	""	"public void testDpmCanSuspendUnderDisallowAppsControl() throws Exception {
        assertDpmCanSuspendUnderUserRestriction(DISALLOW_APPS_CONTROL);
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.suspendapps.cts.DualSuspendTests"	"testDpmCanSuspendUnderDisallowUninstallApps"	"CtsSuspendAppsTestCases"	"/home/gpoor/cts-12-source/cts/tests/suspendapps/tests/src/android/suspendapps/cts/DualSuspendTests.java"	""	"public void testDpmCanSuspendUnderDisallowUninstallApps() throws Exception {
        assertDpmCanSuspendUnderUserRestriction(DISALLOW_UNINSTALL_APPS);
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.suspendapps.cts.DualSuspendTests"	"testUnsuspendedOnUninstallBlocked"	"CtsSuspendAppsTestCases"	"/home/gpoor/cts-12-source/cts/tests/suspendapps/tests/src/android/suspendapps/cts/DualSuspendTests.java"	""	"public void testUnsuspendedOnUninstallBlocked() throws Exception {
        mTestAppInterface = new TestAppInterface(mContext);
        SuspendTestUtils.suspendAndAssertResult(ALL_TEST_PACKAGES, null, null, null,
                EmptyArray.STRING);

        final Bundle extras = createSingleKeyBundle(EXTRA_PACKAGE_NAME, TEST_APP_PACKAGE_NAME);
        assertTrue(""Block uninstall request failed"", requestDpmAction(
                ACTION_BLOCK_UNINSTALL, extras, mReceiverHandler));

        // Package is unsuspended synchronously as part of setUninstallBlocked so the suspended
        // state should be immediately reflected
        assertFalse(""Test app still suspended"", mTestAppInterface.isTestAppSuspended());
    }

    private void assertUnsuspendedOnUserRestriction(String userRestriction) throws Exception {
        mTestAppInterface = new TestAppInterface(mContext);
        assertTrue(""Test app not suspended before setting user restriction"",
                mTestAppInterface.isTestAppSuspended());

        // Packages will be unsuspended asynchronously, so cannot check the suspended state directly
        mTestAppInterface.startListeningForBroadcast(Intent.ACTION_MY_PACKAGE_UNSUSPENDED);
        final Bundle extras = createSingleKeyBundle(EXTRA_USER_RESTRICTION, userRestriction);
        assertTrue(""Request to add restriction "" + userRestriction + "" failed"",
                requestDpmAction(ACTION_ADD_USER_RESTRICTION, extras, mReceiverHandler));

        assertNotNull(Intent.ACTION_MY_PACKAGE_UNSUSPENDED
                        + "" not reported after setting restriction "" + userRestriction,
                mTestAppInterface.awaitBroadcast());
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.suspendapps.cts.DualSuspendTests"	"testUnsuspendedOnDisallowUninstallApps"	"CtsSuspendAppsTestCases"	"/home/gpoor/cts-12-source/cts/tests/suspendapps/tests/src/android/suspendapps/cts/DualSuspendTests.java"	""	"public void testUnsuspendedOnDisallowUninstallApps() throws Exception {
        SuspendTestUtils.suspend(null, null, null);
        assertUnsuspendedOnUserRestriction(DISALLOW_UNINSTALL_APPS);
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.suspendapps.cts.DualSuspendTests"	"testUnsuspendedOnDisallowAppsControl"	"CtsSuspendAppsTestCases"	"/home/gpoor/cts-12-source/cts/tests/suspendapps/tests/src/android/suspendapps/cts/DualSuspendTests.java"	""	"public void testUnsuspendedOnDisallowAppsControl() throws Exception {
        SuspendTestUtils.suspend(null, null, null);
        assertUnsuspendedOnUserRestriction(DISALLOW_APPS_CONTROL);
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.suspendapps.cts.DualSuspendTests"	"testCannotSuspendWhenUninstallBlocked"	"CtsSuspendAppsTestCases"	"/home/gpoor/cts-12-source/cts/tests/suspendapps/tests/src/android/suspendapps/cts/DualSuspendTests.java"	""	"public void testCannotSuspendWhenUninstallBlocked() throws Exception {
        final Bundle extras = createSingleKeyBundle(EXTRA_PACKAGE_NAME, TEST_APP_PACKAGE_NAME);
        assertTrue(""Block uninstall request failed"", requestDpmAction(
                ACTION_BLOCK_UNINSTALL, extras, mReceiverHandler));
        SuspendTestUtils.suspendAndAssertResult(ALL_TEST_PACKAGES, null, null, null,
                TEST_PACKAGE_ARRAY);
    }

    private void assertCannotSuspendUnderUserRestriction(String userRestriction) throws Exception {
        final Bundle extras = createSingleKeyBundle(EXTRA_USER_RESTRICTION, userRestriction);
        assertTrue(""Request to add restriction"" + userRestriction + "" failed"",
                requestDpmAction(ACTION_ADD_USER_RESTRICTION, extras, mReceiverHandler));
        SuspendTestUtils.suspendAndAssertResult(ALL_TEST_PACKAGES, null, null, null,
                ALL_TEST_PACKAGES);
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.suspendapps.cts.DualSuspendTests"	"testCannotSuspendUnderDisallowAppsControl"	"CtsSuspendAppsTestCases"	"/home/gpoor/cts-12-source/cts/tests/suspendapps/tests/src/android/suspendapps/cts/DualSuspendTests.java"	""	"public void testCannotSuspendUnderDisallowAppsControl() throws Exception {
        assertCannotSuspendUnderUserRestriction(DISALLOW_APPS_CONTROL);
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.suspendapps.cts.DualSuspendTests"	"testCannotSuspendUnderDisallowUninstallApps"	"CtsSuspendAppsTestCases"	"/home/gpoor/cts-12-source/cts/tests/suspendapps/tests/src/android/suspendapps/cts/DualSuspendTests.java"	""	"public void testCannotSuspendUnderDisallowUninstallApps() throws Exception {
        assertCannotSuspendUnderUserRestriction(DISALLOW_UNINSTALL_APPS);
    }

    @After
    public void tearDown() throws Exception {
        if (mTestAppInterface != null) {
            mTestAppInterface.disconnect();
        }
        final DevicePolicyManager dpm = mContext.getSystemService(DevicePolicyManager.class);
        if (dpm.isAdminActive(ComponentName.unflattenFromString(DEVICE_ADMIN_COMPONENT))) {
            setSuspendViaDpm(false);
            final Bundle extras = createSingleKeyBundle(EXTRA_PACKAGE_NAME, TEST_APP_PACKAGE_NAME);
            requestDpmAction(ACTION_UNBLOCK_UNINSTALL, extras, mReceiverHandler);
        }
        removeDeviceAdmin();
        SuspendTestUtils.unsuspendAll();
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.keystore.cts.KeyAttestationTest"	"testEcAttestation_NoChallenge"	"CtsKeystoreTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/keystore/src/android/keystore/cts/KeyAttestationTest.java"	""	"public void testEcAttestation_NoChallenge() throws Exception {
        boolean[] devicePropertiesAttestationValues = {true, false};
        for (boolean devicePropertiesAttestation : devicePropertiesAttestationValues) {
            String keystoreAlias = ""test_key"";
            Date now = new Date();
            Date originationEnd = new Date(now.getTime() + ORIGINATION_TIME_OFFSET);
            Date consumptionEnd = new Date(now.getTime() + CONSUMPTION_TIME_OFFSET);
            KeyGenParameterSpec spec = new KeyGenParameterSpec.Builder(keystoreAlias, PURPOSE_SIGN)
                    .setAlgorithmParameterSpec(new ECGenParameterSpec(""secp256r1""))
                    .setDigests(DIGEST_NONE, DIGEST_SHA256, DIGEST_SHA512)
                    .setAttestationChallenge(null)
                    .setKeyValidityStart(now)
                    .setKeyValidityForOriginationEnd(originationEnd)
                    .setKeyValidityForConsumptionEnd(consumptionEnd)
                    .setDevicePropertiesAttestationIncluded(devicePropertiesAttestation)
                    .build();

            generateKeyPair(KEY_ALGORITHM_EC, spec);

            KeyStore keyStore = KeyStore.getInstance(""AndroidKeyStore"");
            keyStore.load(null);

            try {
                Certificate certificates[] = keyStore.getCertificateChain(keystoreAlias);
                assertEquals(1, certificates.length);

                X509Certificate attestationCert = (X509Certificate) certificates[0];
                assertNull(attestationCert.getExtensionValue(Attestation.ASN1_OID));
                assertNull(attestationCert.getExtensionValue(Attestation.EAT_OID));
            } finally {
                keyStore.deleteEntry(keystoreAlias);
            }
        }
    }

    @RestrictedBuildTest
    @RequiresDevice"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.keystore.cts.KeyAttestationTest"	"testRsaAttestation_NoChallenge"	"CtsKeystoreTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/keystore/src/android/keystore/cts/KeyAttestationTest.java"	""	"public void testRsaAttestation_NoChallenge() throws Exception {
        boolean[] devicePropertiesAttestationValues = {true, false};
        for (boolean devicePropertiesAttestation : devicePropertiesAttestationValues) {
            String keystoreAlias = ""test_key"";
            Date now = new Date();
            Date originationEnd = new Date(now.getTime() + ORIGINATION_TIME_OFFSET);
            Date consumptionEnd = new Date(now.getTime() + CONSUMPTION_TIME_OFFSET);
            KeyGenParameterSpec spec = new KeyGenParameterSpec.Builder(keystoreAlias, PURPOSE_SIGN)
                    .setDigests(DIGEST_NONE, DIGEST_SHA256, DIGEST_SHA512)
                    .setAttestationChallenge(null)
                    .setKeyValidityStart(now)
                    .setKeyValidityForOriginationEnd(originationEnd)
                    .setKeyValidityForConsumptionEnd(consumptionEnd)
                    .setDevicePropertiesAttestationIncluded(devicePropertiesAttestation)
                    .build();

            generateKeyPair(KEY_ALGORITHM_RSA, spec);

            KeyStore keyStore = KeyStore.getInstance(""AndroidKeyStore"");
            keyStore.load(null);

            try {
                Certificate certificates[] = keyStore.getCertificateChain(keystoreAlias);
                assertEquals(1, certificates.length);

                X509Certificate attestationCert = (X509Certificate) certificates[0];
                assertNull(attestationCert.getExtensionValue(Attestation.ASN1_OID));
            } finally {
                keyStore.deleteEntry(keystoreAlias);
            }
        }
    }

    @RestrictedBuildTest
    @RequiresDevice  // Emulators have no place to store the needed key"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.MixedManagedProfileOwnerTest"	"testAudioRestriction"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/MixedManagedProfileOwnerTest.java"	""	"public void testAudioRestriction() throws Exception {
        // DISALLOW_UNMUTE_MICROPHONE and DISALLOW_ADJUST_VOLUME can only be set by device owners
        // and profile owners on the primary user.
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.MixedManagedProfileOwnerTest"	"testPackageInstallUserRestrictions"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/MixedManagedProfileOwnerTest.java"	""	"public void testPackageInstallUserRestrictions() throws Exception {
        super.testPackageInstallUserRestrictions();
    }

    @Override
    @PermissionsTest"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.permission.cts.SplitPermissionTest"	"inheritGrantedPermissionStatePreM"	"CtsPermissionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/SplitPermissionTest.java"	""	"@SystemUserOnly(reason = ""Secondary users have the DISALLOW_OUTGOING_CALLS user restriction"")
    public void inheritGrantedPermissionStatePreM() throws Exception {
        install(APK_CONTACTS_16);

        install(APK_CONTACTS_15);

        assertPermissionGranted(READ_CALL_LOG);
    }

    /**
     * If a permission was revoked before the split happens, the new permission should inherit the
     * revoked state.
     *
     * <p>(Pre-M version of test)
     */"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.permission.cts.SplitPermissionTest"	"grantNewSplitPermissionStatePreM"	"CtsPermissionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/SplitPermissionTest.java"	""	"@SystemUserOnly(reason = ""Secondary users have the DISALLOW_OUTGOING_CALLS user restriction"")
    public void grantNewSplitPermissionStatePreM() throws Exception {
        install(APK_CONTACTS_15);
        revokePermission(APP_PKG, READ_CONTACTS);

        grantPermission(APP_PKG, READ_CALL_LOG);

        assertPermissionGranted(READ_CALL_LOG);
    }

    /**
     * It should be possible to revoke a permission implicitly added due to a split.
     */"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.permission.cts.SplitPermissionTest"	"newPermissionGetRevokedOnUpgradePreM"	"CtsPermissionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/SplitPermissionTest.java"	""	"@SystemUserOnly(reason = ""Secondary users have the DISALLOW_OUTGOING_CALLS user restriction"")
    public void newPermissionGetRevokedOnUpgradePreM() throws Exception {
        install(APK_CONTACTS_15);

        install(APK_CONTACTS_CALLLOG_16);

        assertPermissionGranted(READ_CALL_LOG);
    }

    /**
     * When a requested permission was granted before upgrade it should still be granted.
     */"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"testConnectToSuggestion"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	"public void testConnectToSuggestion() throws Exception {
        assertNotNull(sTestNetwork);
        WifiNetworkSuggestion suggestion =
                TestHelper.createSuggestionBuilderWithCredentialFromSavedNetworkWithBssid(
                        sTestNetwork)
                        .build();
        sNsNetworkCallback = sTestHelper.testConnectionFlowWithSuggestion(
                sTestNetwork, suggestion, mExecutorService,
                Set.of() /* restrictedNetworkCapability */);
    }

    /**
     * Connect to a network using restricted suggestion API.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"testConnectToOemPaidSuggestion"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	"public void testConnectToOemPaidSuggestion() throws Exception {
        assertNotNull(sTestNetwork);
        WifiNetworkSuggestion suggestion =
                TestHelper.createSuggestionBuilderWithCredentialFromSavedNetworkWithBssid(
                        sTestNetwork)
                        .setOemPaid(true)
                        .build();
        sNsNetworkCallback = sTestHelper.testConnectionFlowWithSuggestion(
                sTestNetwork, suggestion, mExecutorService, Set.of(NET_CAPABILITY_OEM_PAID));
    }

    /**
     * Connect to a network using restricted suggestion API.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"testConnectToOemPaidAndOemPrivateSuggestion"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	"public void testConnectToOemPaidAndOemPrivateSuggestion() throws Exception {
        assertNotNull(sTestNetwork);
        WifiNetworkSuggestion suggestion =
                TestHelper.createSuggestionBuilderWithCredentialFromSavedNetworkWithBssid(
                        sTestNetwork)
                        .setOemPaid(true)
                        .setOemPrivate(true)
                        .build();
        sNsNetworkCallback = sTestHelper.testConnectionFlowWithSuggestion(
                sTestNetwork, suggestion, mExecutorService,
                Set.of(NET_CAPABILITY_OEM_PAID, NET_CAPABILITY_OEM_PRIVATE));
    }

    /**
     * Connect to a network using restricted suggestion API.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"testConnectToOemPrivateSuggestion"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	"public void testConnectToOemPrivateSuggestion() throws Exception {
        assertNotNull(sTestNetwork);
        WifiNetworkSuggestion suggestion =
                TestHelper.createSuggestionBuilderWithCredentialFromSavedNetworkWithBssid(
                        sTestNetwork)
                        .setOemPrivate(true)
                        .build();
        sNsNetworkCallback = sTestHelper.testConnectionFlowWithSuggestion(
                sTestNetwork, suggestion, mExecutorService, Set.of(NET_CAPABILITY_OEM_PRIVATE));
    }

    /**
     * Simulate connection failure to a network using restricted suggestion API & different net
     * capability (need corresponding net capability requested for platform to connect).
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"testConnectToOemPaidSuggestionFailure"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	"public void testConnectToOemPaidSuggestionFailure() throws Exception {
        assertNotNull(sTestNetwork);
        WifiNetworkSuggestion suggestion =
                TestHelper.createSuggestionBuilderWithCredentialFromSavedNetworkWithBssid(
                        sTestNetwork)
                        .setOemPaid(true)
                        .build();
        sNsNetworkCallback = sTestHelper.testConnectionFailureFlowWithSuggestion(
                sTestNetwork, suggestion, mExecutorService, Set.of(NET_CAPABILITY_OEM_PRIVATE));
    }

    /**
     * Simulate connection failure to a network using restricted suggestion API & different net
     * capability (need corresponding net capability requested for platform to connect).
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"testConnectToOemPrivateSuggestionFailure"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	"public void testConnectToOemPrivateSuggestionFailure() throws Exception {
        assertNotNull(sTestNetwork);
        WifiNetworkSuggestion suggestion =
                TestHelper.createSuggestionBuilderWithCredentialFromSavedNetworkWithBssid(
                        sTestNetwork)
                        .setOemPrivate(true)
                        .build();
        sNsNetworkCallback = sTestHelper.testConnectionFailureFlowWithSuggestion(
                sTestNetwork, suggestion, mExecutorService, Set.of(NET_CAPABILITY_OEM_PAID));
    }

    /**
     * Simulate connection failure to a restricted network using suggestion API & restricted net
     * capability (need corresponding restricted bit set in suggestion for platform to connect).
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"testConnectSuggestionFailureWithOemPaidNetCapability"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	"public void testConnectSuggestionFailureWithOemPaidNetCapability() throws Exception {
        assertNotNull(sTestNetwork);
        WifiNetworkSuggestion suggestion =
                TestHelper.createSuggestionBuilderWithCredentialFromSavedNetworkWithBssid(
                        sTestNetwork)
                        .build();
        sNsNetworkCallback = sTestHelper.testConnectionFailureFlowWithSuggestion(
                sTestNetwork, suggestion, mExecutorService, Set.of(NET_CAPABILITY_OEM_PAID));
    }

    /**
     * Simulate connection failure to a restricted network using suggestion API & restricted net
     * capability (need corresponding restricted bit set in suggestion for platform to connect).
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.readsettingsfieldsapp.ReadSettingsFieldsTest"	"testGlobalHiddenSettingsKeysNotReadableWithoutAnnotation"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/ReadSettingsFieldsApp/src/com/android/cts/readsettingsfieldsapp/ReadSettingsFieldsTest.java"	""	"public void testGlobalHiddenSettingsKeysNotReadableWithoutAnnotation() {
        final ArraySet<String> publicSettingsKeys = getNonHiddenSettingsKeys(Settings.Global.class);
        final String[] hiddenSettingsKeys = {""restricted_networking_mode"",
                ""people_space_conversation_type""};
        testHiddenSettingsKeysNotReadableWithoutAnnotation(Settings.Global.class,
                publicSettingsKeys, hiddenSettingsKeys);
    }

    // test the cases that hidden keys are marked with readable annotation but access should be
    // protected by additional permission check."	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.readsettingsfieldsapp.ReadSettingsFieldsTest"	"testGlobalHiddenSettingsKeysReadableWithoutAnnotation"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/ReadSettingsFieldsApp/src/com/android/cts/readsettingsfieldsapp/ReadSettingsFieldsTest.java"	""	"public void testGlobalHiddenSettingsKeysReadableWithoutAnnotation() {
        final ArraySet<String> publicSettingsKeys = getNonHiddenSettingsKeys(Settings.Global.class);
        final String[] hiddenSettingsKeys = {""restricted_networking_mode"",
                ""people_space_conversation_type""};
        testHiddenSettingsKeysReadable(Settings.Global.class, publicSettingsKeys,
                hiddenSettingsKeys);
    }
}"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.keystore.cts.KeyInfoTest"	"testImmutabilityViaGetterReturnValues"	"CtsKeystoreTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/keystore/src/android/keystore/cts/KeyInfoTest.java"	""	"public void testImmutabilityViaGetterReturnValues() throws Exception {
        // Assert that none of the mutable return values from getters modify the state of the
        // instance.

        Date keyValidityStartDate = new Date(System.currentTimeMillis() - 2222222);
        Date keyValidityEndDateForOrigination = new Date(System.currentTimeMillis() + 11111111);
        Date keyValidityEndDateForConsumption = new Date(System.currentTimeMillis() + 33333333);

        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(""RSA"", ""AndroidKeyStore"");
        keyPairGenerator.initialize(new KeyGenParameterSpec.Builder(
                KeyInfoTest.class.getSimpleName(),
                KeyProperties.PURPOSE_SIGN | KeyProperties.PURPOSE_ENCRYPT)
                .setKeySize(1024) // use smaller key size to speed the test up
                .setKeyValidityStart(keyValidityStartDate)
                .setKeyValidityForOriginationEnd(keyValidityEndDateForOrigination)
                .setKeyValidityForConsumptionEnd(keyValidityEndDateForConsumption)
                .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_RSA_PKCS1,
                        KeyProperties.ENCRYPTION_PADDING_RSA_OAEP)
                .setSignaturePaddings(KeyProperties.SIGNATURE_PADDING_RSA_PKCS1,
                        KeyProperties.SIGNATURE_PADDING_RSA_PSS)
                .setDigests(KeyProperties.DIGEST_SHA256, KeyProperties.DIGEST_SHA512)
                .setBlockModes(KeyProperties.BLOCK_MODE_ECB)
                .build());
        KeyPair keyPair = keyPairGenerator.generateKeyPair();

        PrivateKey key = keyPair.getPrivate();
        KeyFactory keyFactory = KeyFactory.getInstance(key.getAlgorithm(), ""AndroidKeyStore"");
        KeyInfo info = keyFactory.getKeySpec(key, KeyInfo.class);

        Date originalKeyValidityStartDate = (Date) info.getKeyValidityStart().clone();
        info.getKeyValidityStart().setTime(1234567890L);
        assertEquals(originalKeyValidityStartDate, info.getKeyValidityStart());

        Date originalKeyValidityEndDateForOrigination =
                (Date) info.getKeyValidityForOriginationEnd().clone();
        info.getKeyValidityForOriginationEnd().setTime(1234567890L);
        assertEquals(originalKeyValidityEndDateForOrigination,
                info.getKeyValidityForOriginationEnd());

        Date originalKeyValidityEndDateForConsumption =
                (Date) info.getKeyValidityForConsumptionEnd().clone();
        info.getKeyValidityForConsumptionEnd().setTime(1234567890L);
        assertEquals(originalKeyValidityEndDateForConsumption,
                info.getKeyValidityForConsumptionEnd());

        String[] originalEncryptionPaddings = info.getEncryptionPaddings().clone();
        info.getEncryptionPaddings()[0] = null;
        assertEquals(Arrays.asList(originalEncryptionPaddings),
                Arrays.asList(info.getEncryptionPaddings()));

        String[] originalSignaturePaddings = info.getSignaturePaddings().clone();
        info.getSignaturePaddings()[0] = null;
        assertEquals(Arrays.asList(originalSignaturePaddings),
                Arrays.asList(info.getSignaturePaddings()));

        String[] originalDigests = info.getDigests().clone();
        info.getDigests()[0] = null;
        assertEquals(Arrays.asList(originalDigests), Arrays.asList(info.getDigests()));

        String[] originalBlockModes = info.getBlockModes().clone();
        info.getBlockModes()[0] = null;
        assertEquals(Arrays.asList(originalBlockModes), Arrays.asList(info.getBlockModes()));

        // Return KeyProperties.UNRESTRICTED_USAGE_COUNT to indicate there is no restriction on
        // the number of times that the key can be used.
        int remainingUsageCount = info.getRemainingUsageCount();
        assertEquals(KeyProperties.UNRESTRICTED_USAGE_COUNT, remainingUsageCount);
    }"	""	""	"restricted restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.renderscript.cts.IntrinsicBLAS"	"test_L3_ZTRMM_Correctness"	"CtsRsBlasTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/rsblas/src/android/renderscript/cts/IntrinsicBLAS.java"	""	"public void test_L3_ZTRMM_Correctness() {
        int side = ScriptIntrinsicBLAS.LEFT;
        int trans = ScriptIntrinsicBLAS.NO_TRANSPOSE;
        int uplo = ScriptIntrinsicBLAS.UPPER;
        int diag = ScriptIntrinsicBLAS.NON_UNIT;

        // Populate input allocations
        Allocation matrixAZ = Allocation.createTyped(mRS, Type.createXY(mRS, Element.F64_2(mRS), mBLASData.dM, mBLASData.dM));
        Allocation matrixBZ = Allocation.createTyped(mRS, Type.createXY(mRS, Element.F64_2(mRS), mBLASData.dN, mBLASData.dM));
        matrixAZ.copyFrom(mBLASData.L3_zTRMM_A_mm);
        matrixBZ.copyFrom(mBLASData.L3_zTRMM_B_mn);

        // Default case: LEFT, UPPER, NO_TRANSPOSE
        mBLAS.ZTRMM(side, uplo, trans, diag, alphaZ, matrixAZ, matrixBZ);
        Allocation matrixBRef = Allocation.createTyped(mRS, Type.createXY(mRS, Element.F64_2(mRS), mBLASData.dN, mBLASData.dM));
        matrixBRef.copyFrom(mBLASData.L3_zTRMM_o_LUN);
        verifyMatrix(matrixBRef, matrixBZ);

        // Case: RIGHT, LOWER, TRANSPOSE
        matrixAZ = Allocation.createTyped(mRS, Type.createXY(mRS, Element.F64_2(mRS), mBLASData.dN, mBLASData.dN));
        matrixAZ.copyFrom(mBLASData.L3_zTRMM_A_nn);
        // Reload matrix B, since it was overwritten by BLAS.
        matrixBZ.copyFrom(mBLASData.L3_zTRMM_B_mn);

        side = ScriptIntrinsicBLAS.RIGHT;
        trans = ScriptIntrinsicBLAS.TRANSPOSE;
        uplo = ScriptIntrinsicBLAS.LOWER;
        mBLAS.ZTRMM(side, uplo, trans, diag, alphaZ, matrixAZ, matrixBZ);
        matrixBRef.copyFrom(mBLASData.L3_zTRMM_o_RLT);
        verifyMatrix(matrixBRef, matrixBZ);

        mRS.finish();
        checkError();
    }


    private boolean validateTRSM(Element e, int Side, int Uplo, int TransA, int Diag, Allocation A, Allocation B) {
        int adim = -1, bM = -1, bN = -1;
        if (!validateSide(Side)) {
            return false;
        }
        if (!validateTranspose(TransA)) {
            return false;
        }
        if (!validateUplo(Uplo)) {
            return false;
        }
        if (!validateDiag(Diag)) {
            return false;
        }
        if (!A.getType().getElement().isCompatible(e) ||
            !B.getType().getElement().isCompatible(e)) {
            return false;
        }
        adim = A.getType().getX();
        if (adim != A.getType().getY()) {
            // this may be unnecessary, the restriction could potentially be relaxed
            // A needs to contain at least that symmetric matrix but could theoretically be larger
            // for now we assume adapters are sufficient, will reevaluate in the future
            return false;
        }
        bM = B.getType().getY();
        bN = B.getType().getX();
        if (Side == ScriptIntrinsicBLAS.LEFT) {
            // A is M*M
            if (adim != bM) {
                return false;
            }
        } else {
            // A is N*N
            if (adim != bN) {
                return false;
            }
        }
        return true;
    }

    private void xTRSM_API_test(int Side, int Uplo, int TransA, int Diag, ArrayList<Allocation> mMatrix) {
        for (Allocation matA : mMatrix) {
            for (Allocation matB : mMatrix) {
                Element elemA = matA.getType().getElement();
                if (validateTRSM(elemA, Side, Uplo, TransA, Diag, matA, matB)) {
                    try {
                        if (elemA.isCompatible(Element.F32(mRS))) {
                            mBLAS.STRSM(Side, Uplo, TransA, Diag, alphaS, matA, matB);
                        } else if (elemA.isCompatible(Element.F64(mRS))) {
                            mBLAS.DTRSM(Side, Uplo, TransA, Diag, alphaD, matA, matB);
                        } else if (elemA.isCompatible(Element.F32_2(mRS))) {
                            mBLAS.CTRSM(Side, Uplo, TransA, Diag, alphaC, matA, matB);
                        } else if (elemA.isCompatible(Element.F64_2(mRS))) {
                            mBLAS.ZTRSM(Side, Uplo, TransA, Diag, alphaZ, matA, matB);
                        }
                    } catch (RSRuntimeException e) {
                        fail(""should NOT throw RSRuntimeException"");
                    }
                } else {
                    try {
                        mBLAS.STRSM(Side, Uplo, TransA, Diag, alphaS, matA, matB);
                        fail(""should throw RSRuntimeException for STRSM"");
                    } catch (RSRuntimeException e) {
                    }
                    try {
                        mBLAS.DTRSM(Side, Uplo, TransA, Diag, alphaD, matA, matB);
                        fail(""should throw RSRuntimeException for DTRSM"");
                    } catch (RSRuntimeException e) {
                    }
                    try {
                        mBLAS.CTRSM(Side, Uplo, TransA, Diag, alphaC, matA, matB);
                        fail(""should throw RSRuntimeException for CTRSM"");
                    } catch (RSRuntimeException e) {
                    }
                    try {
                        mBLAS.ZTRSM(Side, Uplo, TransA, Diag, alphaZ, matA, matB);
                        fail(""should throw RSRuntimeException for ZTRSM"");
                    } catch (RSRuntimeException e) {
                    }
                }
            }
        }
    }

    public void L3_xTRSM_API(ArrayList<Allocation> mMatrix) {
        for (int Side : mSide) {
            for (int Uplo : mUplo) {
                for (int TransA : mTranspose) {
                    for (int Diag : mDiag) {
                        xTRSM_API_test(Side, Uplo, TransA, Diag, mMatrix);
                    }
                }
            }
        }
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.security.cts.IsolatedProcessTest"	"testGetServiceFromIsolatedService"	"CtsSecurityTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/security/src/android/security/cts/IsolatedProcessTest.java"	""	"public void testGetServiceFromIsolatedService() throws RemoteException {
        for (String serviceName : RESTRICTED_SERVICES_TO_TEST) {
            IBinder service = mService.getSystemService(serviceName);
            Assert.assertNull(serviceName + "" should not be accessible from an isolated process"",
                    service);
        }
    }"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.userrestrictions.ProfileGlobalRestrictionsTest"	"testSetProfileGlobalRestrictions"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/userrestrictions/ProfileGlobalRestrictionsTest.java"	""	"public void testSetProfileGlobalRestrictions() throws Exception {
        mDevicePolicyManager.addUserRestriction(ADMIN_RECEIVER_COMPONENT, ENSURE_VERIFY_APPS);
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.userrestrictions.ProfileGlobalRestrictionsTest"	"testClearProfileGlobalRestrictions"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/userrestrictions/ProfileGlobalRestrictionsTest.java"	""	"public void testClearProfileGlobalRestrictions() throws Exception  {
        mDevicePolicyManager.clearUserRestriction(ADMIN_RECEIVER_COMPONENT, ENSURE_VERIFY_APPS);
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.userrestrictions.ProfileGlobalRestrictionsTest"	"testProfileGlobalRestrictionsEnforced"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/userrestrictions/ProfileGlobalRestrictionsTest.java"	""	"public void testProfileGlobalRestrictionsEnforced() {
        assertRestriction(ENSURE_VERIFY_APPS, true);
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.userrestrictions.ProfileGlobalRestrictionsTest"	"testProfileGlobalRestrictionsNotEnforced"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/userrestrictions/ProfileGlobalRestrictionsTest.java"	""	"public void testProfileGlobalRestrictionsNotEnforced() {
        assertRestriction(ENSURE_VERIFY_APPS, false);
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.media.cts.AudioRecordTest"	"testRestrictedAudioSourcePermissions"	"CtsMediaTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/AudioRecordTest.java"	""	"public void testRestrictedAudioSourcePermissions() throws Exception {
        // Make sure that the following audio sources cannot be used by apps that
        // don't have the CAPTURE_AUDIO_OUTPUT permissions:
        // - VOICE_CALL,
        // - VOICE_DOWNLINK
        // - VOICE_UPLINK
        // - REMOTE_SUBMIX
        // - ECHO_REFERENCE  - 1997
        // - RADIO_TUNER - 1998
        // - HOTWORD - 1999
        // The attempt to build an AudioRecord with those sources should throw either
        // UnsupportedOperationException or IllegalArgumentException exception.
        final int[] restrictedAudioSources = new int [] {
            MediaRecorder.AudioSource.VOICE_CALL,
            MediaRecorder.AudioSource.VOICE_DOWNLINK,
            MediaRecorder.AudioSource.VOICE_UPLINK,
            MediaRecorder.AudioSource.REMOTE_SUBMIX,
            1997,
            1998,
            1999
        };

        for (int source : restrictedAudioSources) {
            // AudioRecord.Builder should fail when trying to use
            // one of the voice call audio sources.
            try {
                AudioRecord ar = new AudioRecord.Builder()
                 .setAudioSource(source)
                 .setAudioFormat(new AudioFormat.Builder()
                         .setEncoding(AudioFormat.ENCODING_PCM_16BIT)
                         .setSampleRate(8000)
                         .setChannelMask(AudioFormat.CHANNEL_IN_MONO)
                         .build())
                 .build();
                fail(""testRestrictedAudioSourcePermissions: no exception thrown for source: ""
                        + source);
            } catch (Exception e) {
                Log.i(TAG, ""Exception: "" + e);
                if (!UnsupportedOperationException.class.isInstance(e)
                        && !IllegalArgumentException.class.isInstance(e)) {
                    fail(""testRestrictedAudioSourcePermissions: no exception thrown for source: ""
                        + source + "" Exception:"" + e);
                }
            }
        }
    }"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.DevicePolicySafetyCheckerIntegrationTester"	"isEmpty"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/common/src/com/android/cts/devicepolicy/DevicePolicySafetyCheckerIntegrationTester.java"	""	"public void test/*
 *.
 */
package com.android.cts.devicepolicy;

import static android.app.admin.DevicePolicyManager.OPERATION_LOCK_NOW;
import static android.app.admin.DevicePolicyManager.OPERATION_LOGOUT_USER;
import static android.app.admin.DevicePolicyManager.OPERATION_REMOVE_ACTIVE_ADMIN;
import static android.app.admin.DevicePolicyManager.OPERATION_REMOVE_KEY_PAIR;
import static android.app.admin.DevicePolicyManager.OPERATION_SAFETY_REASON_DRIVING_DISTRACTION;
import static android.app.admin.DevicePolicyManager.OPERATION_SET_ALWAYS_ON_VPN_PACKAGE;
import static android.app.admin.DevicePolicyManager.OPERATION_SET_MASTER_VOLUME_MUTED;
import static android.app.admin.DevicePolicyManager.OPERATION_SET_PERMISSION_GRANT_STATE;
import static android.app.admin.DevicePolicyManager.OPERATION_SET_PERMISSION_POLICY;
import static android.app.admin.DevicePolicyManager.OPERATION_SET_RESTRICTIONS_PROVIDER;
import static android.app.admin.DevicePolicyManager.OPERATION_SET_USER_RESTRICTION;
import static android.app.admin.DevicePolicyManager.operationSafetyReasonToString;
import static android.app.admin.DevicePolicyManager.operationToString;

import static com.google.common.truth.Truth.assertWithMessage;

import static org.junit.Assert.fail;
import static org.testng.Assert.assertThrows;
import static org.testng.Assert.expectThrows;

import android.app.admin.DevicePolicyManager;
import android.app.admin.UnsafeStateException;
import android.content.ComponentName;
import android.content.Context;
import android.os.UserManager;
import android.util.Log;

import com.android.compatibility.common.util.ShellIdentityUtils;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.Set;

/**
 * Helper class to test that DPM calls fail when determined by the
 * {@link android.app.admin.DevicePolicySafetyChecker}; it provides the base infra, so it can be
 * used by both device and profile owner tests.
 */
public class DevicePolicySafetyCheckerIntegrationTester {

    public static final String TAG = DevicePolicySafetyCheckerIntegrationTester.class
            .getSimpleName();

    private static final int[] OPERATIONS = new int[] {
            OPERATION_LOCK_NOW,
            OPERATION_LOGOUT_USER,
            OPERATION_REMOVE_ACTIVE_ADMIN,
            OPERATION_REMOVE_KEY_PAIR,
            OPERATION_SET_MASTER_VOLUME_MUTED,
            OPERATION_SET_USER_RESTRICTION,
            OPERATION_SET_PERMISSION_GRANT_STATE,
            OPERATION_SET_PERMISSION_POLICY,
            OPERATION_SET_RESTRICTIONS_PROVIDER
    };

    private static final int[] OVERLOADED_OPERATIONS = new int[] {
            OPERATION_LOCK_NOW,
            OPERATION_SET_ALWAYS_ON_VPN_PACKAGE
    };

    /**
     * Tests that all safety-aware operations are properly implemented.
     */
    public final void testAllOperations(DevicePolicyManager dpm, ComponentName admin) {
        Log.d(TAG, ""testAllOperations: dpm="" + dpm + "", admin="" + admin);
        Objects.requireNonNull(dpm);

        List<String> failures = new ArrayList<>();
        for (int operation : OPERATIONS) {
            safeOperationTest(dpm, admin, failures, operation, /* overloaded= */ false);
        }

        for (int operation : OVERLOADED_OPERATIONS) {
            safeOperationTest(dpm, admin, failures, operation, /* overloaded= */ true);
        }

        for (int operation : getSafetyAwareOperations()) {
            safeOperationTest(dpm, admin, failures, operation, /* overloaded= */ false);
        }

        for (int operation : getOverloadedSafetyAwareOperations()) {
            safeOperationTest(dpm, admin, failures, operation, /* overloaded= */ true);
        }

        if (!failures.isEmpty()) {
            fail(failures.size() + "" operations failed: "" + failures);
        }
    }

    /**
     * Tests {@link DevicePolicyManager#isSafeOperation(int)}.
     */"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.DevicePolicySafetyCheckerIntegrationTester"	"testOnOperationSafetyStateChanged"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/common/src/com/android/cts/devicepolicy/DevicePolicySafetyCheckerIntegrationTester.java"	""	"public void testOnOperationSafetyStateChanged(Context context, DevicePolicyManager dpm) {
        // Currently there's just one reason...
        int reason = OPERATION_SAFETY_REASON_DRIVING_DISTRACTION;
        // Operation doesn't really matter
        int operation = OPERATION_LOCK_NOW;
        Log.d(TAG, ""testOnOperationSafetyStateChanged(): dpm="" + dpm
                + "", reason="" + operationSafetyReasonToString(reason)
                + "", operation="" + operationToString(operation));
        OperationSafetyChangedCallback receiver = OperationSafetyChangedCallback.register(context);
        try {
            setOperationUnsafe(dpm, operation, reason);
            // Must force OneTimeSafetyChecker to generate the event by calling the unsafe operation
            assertThrows(UnsafeStateException.class, () -> dpm.lockNow());

            Log.d(TAG, ""Waiting isSafe=false event"");
            assertNextEvent(receiver, reason, /* isSafe= */ false);

            // OneTimeSafetyChecker automatically disables itself after one operation, which in turn
            // triggers another event
            Log.d(TAG, ""Waiting isSafe=true event"");
            assertNextEvent(receiver, reason, /* isSafe= */ true);
        } finally {
            receiver.unregister(context);
        }
    }

    private void assertNextEvent(OperationSafetyChangedCallback receiver,
            int reason, boolean isSafe) {
        OperationSafetyChangedEvent event = receiver.getNextEvent();
        Log.v(TAG, ""Received event: "" + event);
        assertWithMessage(""event (%s) reason"", event).that(event.reason).isEqualTo(reason);
        assertWithMessage(""event (%s) safety state"", event).that(event.isSafe).isEqualTo(isSafe);
    }

    /**
     * Gets the device / profile owner-specific operations.
     *
     * <p>By default it returns an empty array, but sub-classes can override to add its supported
     * operations.
     */
    protected int[] getSafetyAwareOperations() {
        return new int[] {};
    }

    /**
     * Gets the device / profile owner-specific operations that are overloaded.
     *
     * <p>For example, {@code OPERATION_WIPE_DATA} is used for both {@code wipeData(flags)} and
     * {@code wipeData(flags, reason)}, so it should be returned both here and on
     * {@link #getSafetyAwareOperations()}, then
     * {@link #runOperation(DevicePolicyManager, int, boolean)} will handle which method to call for
     * each case.
     *
     * <p>By default it returns an empty array, but sub-classes can override to add its supported
     * operations.
     */
    protected int[] getOverloadedSafetyAwareOperations() {
        return new int[] {};
    }

    /**
     * Runs the device / profile owner-specific operation.
     *
     * <p>MUST be overridden if {@link #getSafetyAwareOperations()} is overridden as well.
     */
    protected void runOperation(DevicePolicyManager dpm, ComponentName admin, int operation,
            boolean overloaded) {
        throwUnsupportedOperationException(operation, overloaded);
    }

    /**
     * Throws a {@link UnsupportedOperationException} then the given {@code operation} is not
     * supported.
     */
    protected final void throwUnsupportedOperationException(int operation, boolean overloaded) {
        throw new UnsupportedOperationException(
                ""Unsupported operation "" + getOperationName(operation, overloaded));
    }

    private void safeOperationTest(DevicePolicyManager dpm, ComponentName admin,
            List<String> failures, int operation, boolean overloaded) {
        String name = getOperationName(operation, overloaded);
        // Currently there's just one reason...
        int reason = OPERATION_SAFETY_REASON_DRIVING_DISTRACTION;

        try {
            setOperationUnsafe(dpm, operation, reason);
            runCommonOrSpecificOperation(dpm, admin, operation, overloaded);
            Log.e(TAG, name + "" didn't throw an UnsafeStateException"");
            failures.add(name);
        } catch (UnsafeStateException e) {
            Log.d(TAG, name + "" failed as expected: "" + e);
        } catch (Exception e) {
            Log.e(TAG, name + "" threw unexpected exception"", e);
            failures.add(name + ""("" + e + "")"");
        }
    }

    private String getOperationName(int operation, boolean overloaded) {
        String name = operationToString(operation);
        return overloaded ? name + ""(OVERLOADED)"" : name;
    }

    private void runCommonOrSpecificOperation(DevicePolicyManager dpm, ComponentName admin,
            int operation, boolean overloaded) throws Exception {
        String name = getOperationName(operation, overloaded);
        Log.v(TAG, ""runOperation(): "" + name);
        switch (operation) {
            case OPERATION_LOCK_NOW:
                if (overloaded) {
                    dpm.lockNow(/* flags= */ 0);
                } else {
                    dpm.lockNow();
                }
                break;
            case OPERATION_LOGOUT_USER:
                dpm.logoutUser(admin);
                break;
            case OPERATION_SET_ALWAYS_ON_VPN_PACKAGE:
                if (overloaded) {
                    dpm.setAlwaysOnVpnPackage(admin, ""vpnPackage"", /* lockdownEnabled= */ true);
                } else {
                    dpm.setAlwaysOnVpnPackage(admin, ""vpnPackage"", /* lockdownEnabled= */ true,
                            /* lockdownAllowlist= */ Set.of(""vpnPackage""));
                }
                break;
            case OPERATION_SET_MASTER_VOLUME_MUTED:
                dpm.setMasterVolumeMuted(admin, /* on= */ true);
                break;
            case OPERATION_SET_PERMISSION_GRANT_STATE:
                dpm.setPermissionGrantState(admin, ""package"", ""permission"", /* grantState= */ 0);
                break;
            case OPERATION_SET_PERMISSION_POLICY:
                dpm.setPermissionPolicy(admin, /* policy= */ 0);
                break;
            case OPERATION_SET_RESTRICTIONS_PROVIDER:
                dpm.setRestrictionsProvider(admin,
                        /* provider= */ new ComponentName(""package"", ""component""));
                break;
            case OPERATION_SET_USER_RESTRICTION:
                dpm.addUserRestriction(admin, UserManager.DISALLOW_REMOVE_USER);
                break;
            case OPERATION_REMOVE_ACTIVE_ADMIN:
                dpm.removeActiveAdmin(admin);
                break;
            case OPERATION_REMOVE_KEY_PAIR:
                dpm.removeKeyPair(admin, ""keyAlias"");
                break;
            default:
                runOperation(dpm, admin, operation, overloaded);
        }
    }

    private void setOperationUnsafe(DevicePolicyManager dpm, int operation, int reason) {
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(dpm,
                (obj) -> obj.setNextOperationSafety(operation, reason));
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.appsecurity.cts.ResumeOnRebootHostTest"	"isSupportedSDevice"	"CtsAppSecurityHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/ResumeOnRebootHostTest.java"	""	"public void resumeOnReboot_SingleUser_MultiClient_ClientBSuccess() throws Exception {
        assumeTrue(""Device isn't at least S or have no lock screen"", isSupportedSDevice());

        int[] users = Utils.prepareSingleUser(getDevice());
        int initialUser = users[0];

        deviceSetupServerBasedParameter();

        final String clientA = ""ClientA"";
        final String clientB = ""ClientB"";
        try {
            installTestPackages();

            deviceSetup(initialUser);
            deviceRequestLskf(clientA);

            deviceLock(initialUser);
            deviceEnterLskf(initialUser);

            // Both clients have prepared
            deviceRequestLskf(clientB);
            deviceRebootAndApply(clientB);

            runDeviceTestsAsUser(""testVerifyUnlockedAndDismiss"", initialUser);
            runDeviceTestsAsUser(""testCheckServiceInteraction"", initialUser);
        } finally {
            try {
                // Remove secure lock screens and tear down test app
                runDeviceTestsAsUser(""testTearDown"", initialUser);

                deviceClearLskf();
            } finally {
                removeTestPackages();
                deviceCleanupServerBasedParameter();

                getDevice().rebootUntilOnline();
                getDevice().waitForDeviceAvailable();
            }
        }
    }

    private void deviceDisableDeviceConfigSync() throws Exception {
        getDevice().executeShellCommand(""device_config set_sync_disabled_for_tests persistent"");
        String res = getDevice().executeShellCommand(""device_config is_sync_disabled_for_tests"");
        if (res == null || !res.contains(""true"")) {
            CLog.w(TAG, ""Could not disable device config for test"");
        }
    }

    private void deviceRestoreDeviceConfigSync() throws Exception {
        getDevice().executeShellCommand(""device_config set_sync_disabled_for_tests none"");
    }


    private void deviceSetupServerBasedParameter() throws Exception {
        getDevice().executeShellCommand(""device_config put ota server_based_ror_enabled true"");
        String res = getDevice().executeShellCommand(
                ""device_config get ota server_based_ror_enabled"");
        if (res == null || !res.contains(""true"")) {
            fail(""could not set up server based ror"");
        }

        getDevice().executeShellCommand(
                ""cmd lock_settings set-resume-on-reboot-provider-package "" + PKG);
    }

    private void deviceCleanupServerBasedParameter() throws Exception {
        getDevice().executeShellCommand(""device_config put ota server_based_ror_enabled false"");
        String res = getDevice().executeShellCommand(
                ""device_config get ota server_based_ror_enabled"");
        if (res == null || !res.contains(""false"")) {
            fail(""could not clean up server based ror"");
        }

        getDevice().executeShellCommand(
                ""cmd lock_settings set-resume-on-reboot-provider-package "");
    }

    private void deviceSetup(int userId) throws Exception {
        // To receive boot broadcasts, kick our other app out of stopped state
        getDevice().executeShellCommand(""am start -a android.intent.action.MAIN""
                + "" --user "" + userId
                + "" -c android.intent.category.LAUNCHER com.android.cts.splitapp/.MyActivity"");

        // Give enough time for PackageManager to persist stopped state
        Thread.sleep(15000);

        runDeviceTestsAsUser(""testSetUp"", userId);

        // Give enough time for vold to update keys
        Thread.sleep(15000);
    }

    private void deviceRequestLskf() throws Exception {
        deviceRequestLskf(PKG);
    }

    private void deviceRequestLskf(String clientName) throws Exception {
        String res = getDevice().executeShellCommand(""cmd recovery request-lskf "" + clientName);
        if (res == null || !res.contains(""success"")) {
            fail(""could not set up recovery request-lskf"");
        }
    }

    private void deviceClearLskf() throws Exception {
        deviceClearLskf(PKG);
    }

    private void deviceClearLskf(String clientName) throws Exception {
        String res = getDevice().executeShellCommand(""cmd recovery clear-lskf "" + clientName);
        if (res == null || !res.contains(""success"")) {
            fail(""could not clear-lskf"");
        }
    }

    private void deviceLock(int userId) throws Exception {
        int retriesLeft = 3;
        boolean retry = false;
        do {
            if (retry) {
                CLog.i(""Retrying to summon lockscreen..."");
                try {
                    Thread.sleep(500);
                } catch (InterruptedException ignored) {}
            }
            runDeviceTestsAsUser(""testLockScreen"", userId);
            retry = !LockScreenInspector.newInstance(getDevice()).isDisplayedAndNotOccluded();
        } while (retriesLeft-- > 0 && retry);

        if (retry) {
            CLog.e(""Could not summon lockscreen..."");
            fail(""Device could not be locked"");
        }
    }

    private void deviceEnterLskf(int userId) throws Exception {
        runDeviceTestsAsUser(""testUnlockScreen"", userId);
    }

    private void verifyLskfCaptured(String clientName) throws Exception {
        HostSideTestUtils.waitUntil(""Lskf isn't captured after ""
                        + UNLOCK_BROADCAST_WAIT_SECONDS + "" seconds for "" + clientName,
                UNLOCK_BROADCAST_WAIT_SECONDS, () -> isLskfCapturedForClient(clientName));
    }

    private boolean isLskfCapturedForClient(String clientName) throws Exception {
        Pattern pattern = Pattern.compile("".*LSKF capture status: (\\w+)"");
        String status = getDevice().executeShellCommand(
                ""cmd recovery is-lskf-captured "" + clientName);
        Matcher matcher = pattern.matcher(status);
        if (!matcher.find()) {
            CLog.i(TAG, ""is-lskf-captured isn't implemented on build, assuming captured"");
            return true;
        }

        return ""true"".equalsIgnoreCase(matcher.group(1));
    }

    private void deviceRebootAndApply() throws Exception {
        deviceRebootAndApply(PKG);
    }

    private void deviceRebootAndApply(String clientName) throws Exception {
        verifyLskfCaptured(clientName);

        String res = getDevice().executeShellCommand(""cmd recovery reboot-and-apply "" + clientName
                + "" cts-test"");
        if (res != null && res.contains(""Reboot and apply status: failure"")) {
            fail(""could not call reboot-and-apply"");
        }

        getDevice().waitForDeviceNotAvailable(SHUTDOWN_TIME_MS);
        getDevice().waitForDeviceOnline(120000);

        waitForBootCompleted(getDevice());
    }

    private void installTestPackages() throws Exception {
        new InstallMultiple().addFile(APK).run();
        new InstallMultiple().addFile(OTHER_APK).run();
    }

    private void removeTestPackages() throws DeviceNotAvailableException {
        getDevice().uninstallPackage(PKG);
        getDevice().uninstallPackage(OTHER_PKG);
    }

    private ArrayList<Integer> listUsers() throws DeviceNotAvailableException {
        return getDevice().listUsers();
    }

    /**
     * Calls switch-user, but without trying to dismiss the keyguard.
     */
    private void switchUser(int userId) throws Exception {
        getDevice().switchUser(userId);
        HostSideTestUtils.waitUntil(""Could not switch users"", USER_SWITCH_TIMEOUT_SECONDS,
                () -> getDevice().getCurrentUser() == userId);
        Thread.sleep(USER_SWITCH_WAIT);
    }

    private void stopUserAsync(int userId) throws Exception {
        String stopUserCommand = ""am stop-user -f "" + userId;
        CLog.d(""starting command \"""" + stopUserCommand);
        CLog.d(""Output for command "" + stopUserCommand + "": ""
                + getDevice().executeShellCommand(stopUserCommand));
    }

    private void removeUser(int userId) throws Exception  {
        if (listUsers().contains(userId) && userId != USER_SYSTEM) {
            // Don't log output, as tests sometimes set no debug user restriction, which
            // causes this to fail, we should still continue and remove the user.
            String stopUserCommand = ""am stop-user -w -f "" + userId;
            CLog.d(""stopping and removing user "" + userId);
            getDevice().executeShellCommand(stopUserCommand);
            // Ephemeral users may have already been removed after being stopped.
            if (listUsers().contains(userId)) {
                assertThat(""Couldn't remove user"", getDevice().removeUser(userId), is(true));
            }
        }
    }

    private int createManagedProfile(int parentUserId) throws DeviceNotAvailableException {
        String commandOutput = getCreateManagedProfileCommandOutput(parentUserId);
        return getUserIdFromCreateUserCommandOutput(commandOutput);
    }

    private int getUserIdFromCreateUserCommandOutput(String commandOutput) {
        // Extract the id of the new user.
        String[] tokens = commandOutput.split(""\\s+"");
        assertThat(commandOutput + "" expected to have format \""Success: {USER_ID}\"""",
                tokens.length, greaterThan(0));
        assertThat(""Command output should start with \""Success\"""" + commandOutput, tokens[0],
                is(""Success:""));
        return Integer.parseInt(tokens[tokens.length - 1]);
    }

    private String getCreateManagedProfileCommandOutput(int parentUserId)
            throws DeviceNotAvailableException {
        String command = ""pm create-user --profileOf "" + parentUserId + "" --managed ""
                + ""TestProfile_"" + System.currentTimeMillis();
        CLog.d(""Starting command "" + command);
        String commandOutput = getDevice().executeShellCommand(command);
        CLog.d(""Output for command "" + command + "": "" + commandOutput);
        return commandOutput;
    }

    private void runDeviceTestsAsUser(String testMethodName, int userId)
            throws DeviceNotAvailableException {
        Utils.runDeviceTestsAsCurrentUser(getDevice(), PKG, CLASS, testMethodName);
    }

    private boolean isSupportedDevice() throws Exception {
        return getDevice().hasFeature(FEATURE_DEVICE_ADMIN)
                && getDevice().hasFeature(FEATURE_REBOOT_ESCROW);
    }

    private class InstallMultiple extends BaseInstallMultiple<InstallMultiple> {
        public InstallMultiple() {
            super(getDevice(), getBuild(), getAbi());
        }
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.telephony.cts.ServiceStateTest"	"testNrStateRedacted"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/ServiceStateTest.java"	""	"public void testNrStateRedacted() {
        final TelephonyManager tm = getContext().getSystemService(TelephonyManager.class);

        // Verify that NR State is not leaked in user builds.
        if (!Build.IS_DEBUGGABLE) {
            final String sss = tm.getServiceState().toString();
            // The string leaked in previous releases is ""nrState=<val>""; test that there is
            // no matching or highly similar string leak, such as:
            // nrState=NONE
            // nrState=0
            // mNrState=RESTRICTED
            // NRSTATE=NOT_RESTRICTED
            // nrState = CONNECTED
            // etc.
            Pattern p = Pattern.compile(""nrState\\s*=\\s*[a-zA-Z0-9_]+"", Pattern.CASE_INSENSITIVE);
            Matcher m = p.matcher(sss);
            // Need to use if (find) fail to ensure that the start and end are populated
            if (m.find()) fail(""Found nrState reported as: "" + sss.substring(m.start(), m.end()));
        }
    }"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.cts.statsdatom.apphibernation.AppHibernationStatsTest"	"isNotNull"	"CtsStatsdAtomHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/apphibernation/AppHibernationStatsTest.java"	""	"public void test/*
 *.
 */

package android.cts.statsdatom.apphibernation;

import static com.google.common.truth.Truth.assertThat;

import android.cts.statsdatom.lib.AtomTestUtils;
import android.cts.statsdatom.lib.ConfigUtils;
import android.cts.statsdatom.lib.DeviceUtils;
import android.cts.statsdatom.lib.ReportUtils;

import com.android.os.AtomsProto;
import com.android.os.StatsLog;
import com.android.tradefed.build.IBuildInfo;
import com.android.tradefed.testtype.DeviceTestCase;
import com.android.tradefed.testtype.IBuildReceiver;

import java.util.List;

public class AppHibernationStatsTest extends DeviceTestCase implements IBuildReceiver {
    private static final String CMD_APP_HIBERNATION_SET_STATE =
            ""cmd app_hibernation set-state %s %s %s"";
    private static final String CMD_ENABLE_APP_HIBERNATION =
            ""device_config put app_hibernation app_hibernation_enabled true"";
    private static final String GLOBAL_OPTION = ""--global"";
    private IBuildInfo mCtsBuild;

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        assertThat(mCtsBuild).isNotNull();
        ConfigUtils.removeConfig(getDevice());
        ReportUtils.clearReports(getDevice());
        DeviceUtils.installStatsdTestApp(getDevice(), mCtsBuild);
        getDevice().executeShellCommand(CMD_ENABLE_APP_HIBERNATION);
        Thread.sleep(AtomTestUtils.WAIT_TIME_LONG);
    }

    @Override
    protected void tearDown() throws Exception {
        ConfigUtils.removeConfig(getDevice());
        ReportUtils.clearReports(getDevice());
        DeviceUtils.uninstallStatsdTestApp(getDevice());
        super.tearDown();
    }

    @Override
    public void setBuild(IBuildInfo buildInfo) {
        mCtsBuild = buildInfo;
    }"	""	""	"hibernation"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.cts.statsdatom.apphibernation.AppHibernationStatsTest"	"testUserLevelAppHibernationStateChanged_fromNotHibernatingToHibernating"	"CtsStatsdAtomHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/apphibernation/AppHibernationStatsTest.java"	""	"public void testUserLevelAppHibernationStateChanged_fromNotHibernatingToHibernating()
            throws Exception {
        getDevice().executeShellCommand(
                getHibernationCommand(DeviceUtils.STATSD_ATOM_TEST_PKG,
                        /* isGlobal */ false, /* isHibernating */ false));
        ConfigUtils.uploadConfigForPushedAtomWithUid(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                AtomsProto.Atom.USER_LEVEL_HIBERNATION_STATE_CHANGED_FIELD_NUMBER,
                /*uidInAttributionChain=*/false);

        getDevice().executeShellCommand(
                getHibernationCommand(DeviceUtils.STATSD_ATOM_TEST_PKG,
                        /* isGlobal */ false, /* isHibernating */ true));

        // Sorted list of events in order in which they occurred.
        final List<StatsLog.EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());
        assertThat(data.size()).isAtLeast(1);
        assertUserLevelHibernationStateChangedEvent(data, /* isHibernating */ true,
                getDevice().getCurrentUser());
    }"	""	""	"hibernation"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.cts.statsdatom.apphibernation.AppHibernationStatsTest"	"testUserLevelAppHibernationStateChanged_fromHibernatingToNotHibernating"	"CtsStatsdAtomHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/apphibernation/AppHibernationStatsTest.java"	""	"public void testUserLevelAppHibernationStateChanged_fromHibernatingToNotHibernating()
            throws Exception {
        getDevice().executeShellCommand(
                getHibernationCommand(DeviceUtils.STATSD_ATOM_TEST_PKG,
                        /* isGlobal */ false, /* isHibernating */ true));
        ConfigUtils.uploadConfigForPushedAtomWithUid(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                AtomsProto.Atom.USER_LEVEL_HIBERNATION_STATE_CHANGED_FIELD_NUMBER,
                /*uidInAttributionChain=*/false);

        getDevice().executeShellCommand(
                getHibernationCommand(DeviceUtils.STATSD_ATOM_TEST_PKG,
                        /* isGlobal */ false, /* isHibernating */ false));

        // Sorted list of events in order in which they occurred.
        final List<StatsLog.EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());
        assertThat(data.size()).isAtLeast(1);
        assertUserLevelHibernationStateChangedEvent(data, /* isHibernating */ false,
                getDevice().getCurrentUser());
    }"	""	""	"hibernation"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.cts.statsdatom.apphibernation.AppHibernationStatsTest"	"testUserLevelHibernatedApps"	"CtsStatsdAtomHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/apphibernation/AppHibernationStatsTest.java"	""	"public void testUserLevelHibernatedApps() throws Exception {
        ConfigUtils.uploadConfigForPulledAtom(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                AtomsProto.Atom.USER_LEVEL_HIBERNATED_APPS_FIELD_NUMBER);
        getDevice().executeShellCommand(
                getHibernationCommand(DeviceUtils.STATSD_ATOM_TEST_PKG,
                        /* isGlobal */ false, /* isHibernating */ true));

        AtomTestUtils.sendAppBreadcrumbReportedAtom(getDevice());
        Thread.sleep(AtomTestUtils.WAIT_TIME_LONG);

        final List<AtomsProto.Atom> atoms = ReportUtils.getGaugeMetricAtoms(getDevice());
        final int userId = getDevice().getCurrentUser();
        for (AtomsProto.Atom atom : atoms) {
            AtomsProto.UserLevelHibernatedApps apps = atom.getUserLevelHibernatedApps();
            if (apps.getUserId() == userId) {
                assertThat(apps.getHibernatedAppCount()).isAtLeast(1);
                return;
            }
        }
        fail(String.format(""Did not find a matching atom for user %d"", userId));
    }"	""	""	"hibernation"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.cts.statsdatom.apphibernation.AppHibernationStatsTest"	"testGlobalHibernatedApps"	"CtsStatsdAtomHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/apphibernation/AppHibernationStatsTest.java"	""	"public void testGlobalHibernatedApps() throws Exception {
        ConfigUtils.uploadConfigForPulledAtom(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                AtomsProto.Atom.GLOBAL_HIBERNATED_APPS_FIELD_NUMBER);
        getDevice().executeShellCommand(
                getHibernationCommand(DeviceUtils.STATSD_ATOM_TEST_PKG,
                        /* isGlobal */ true, /* isHibernating */ true));

        AtomTestUtils.sendAppBreadcrumbReportedAtom(getDevice());
        Thread.sleep(AtomTestUtils.WAIT_TIME_LONG);

        final List<AtomsProto.Atom> atoms = ReportUtils.getGaugeMetricAtoms(getDevice());
        assertThat(atoms.size()).isEqualTo(1);
        AtomsProto.GlobalHibernatedApps apps = atoms.get(0).getGlobalHibernatedApps();
        assertThat(apps.getHibernatedAppCount()).isAtLeast(1);
    }

    private static void assertUserLevelHibernationStateChangedEvent(
            List<StatsLog.EventMetricData> data, boolean isHibernating, int currentUser) {
        for (StatsLog.EventMetricData d : data) {
            AtomsProto.UserLevelHibernationStateChanged atom =
                    d.getAtom().getUserLevelHibernationStateChanged();
            if (atom.getPackageName().equals(DeviceUtils.STATSD_ATOM_TEST_PKG)) {
                assertThat(atom.getUserId()).isEqualTo(currentUser);
                assertThat(atom.getIsHibernating()).isEqualTo(isHibernating);
                return;
            }
        }
        fail(String.format(""Did not find a matching event for package %s"",
                DeviceUtils.STATSD_ATOM_TEST_PKG));
    }

    private static String getHibernationCommand(
            String packageName, boolean isGlobal, boolean isHibernating) {
        return String.format(CMD_APP_HIBERNATION_SET_STATE,
                (isGlobal ? GLOBAL_OPTION : """"), packageName, isHibernating);
    }
}"	""	""	"hibernation"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.appsecurity.cts.PrivilegedUpdateTests"	"isDefaultAbi"	"CtsAppSecurityHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PrivilegedUpdateTests.java"	""	"public void test/*
 *.
 */

package android.appsecurity.cts;

import android.platform.test.annotations.AppModeFull;
import android.platform.test.annotations.LargeTest;

import com.android.compatibility.common.tradefed.build.CompatibilityBuildHelper;
import com.android.ddmlib.Log;
import com.android.tradefed.build.IBuildInfo;
import com.android.tradefed.device.DeviceNotAvailableException;
import com.android.tradefed.testtype.DeviceTestCase;
import com.android.tradefed.testtype.IAbi;
import com.android.tradefed.testtype.IAbiReceiver;
import com.android.tradefed.testtype.IBuildReceiver;
import com.android.tradefed.util.AbiFormatter;

/**
 * Tests that verify intent filters.
 */
@LargeTest
@AppModeFull(reason=""Instant applications can never be system or privileged"")
public class PrivilegedUpdateTests extends DeviceTestCase implements IAbiReceiver, IBuildReceiver {
    private static final String TAG = ""PrivilegedUpdateTests"";
    private static final String SHIM_PKG = ""com.android.cts.priv.ctsshim"";
    /** Package name of the tests to be run */
    private static final String TEST_PKG = ""com.android.cts.privilegedupdate"";

    /** APK that contains the shim update; to test upgrading */
    private static final String SHIM_UPDATE_APK = ""CtsShimPrivUpgradePrebuilt.apk"";
    /** APK that contains the shim update w/ incorrect SHA; to test upgrade fails */
    private static final String SHIM_UPDATE_FAIL_APK = ""CtsShimPrivUpgradeWrongSHAPrebuilt.apk"";
    /** APK that contains individual shim test cases */
    private static final String TEST_APK = ""CtsPrivilegedUpdateTests.apk"";

    private static final String RESTRICTED_UPGRADE_FAILURE =
            ""INSTALL_FAILED_INVALID_APK:""
            + "" New package fails restrict-update check:""
            + "" com.android.cts.priv.ctsshim"";

    private IAbi mAbi;
    private CompatibilityBuildHelper mBuildHelper;

    private boolean isDefaultAbi() throws Exception {
        String defaultAbi = AbiFormatter.getDefaultAbi(getDevice(), mAbi.getBitness());
        return mAbi.getName().equals(defaultAbi);
    }

    @Override
    public void setAbi(IAbi abi) {
        mAbi = abi;
    }

    @Override
    public void setBuild(IBuildInfo buildInfo) {
        mBuildHelper = new CompatibilityBuildHelper(buildInfo);
    }

    @Override
    protected void setUp() throws Exception {
        super.setUp();

        Utils.prepareSingleUser(getDevice());
        assertNotNull(mAbi);
        assertNotNull(mBuildHelper);

        getDevice().uninstallPackage(SHIM_PKG);
        getDevice().uninstallPackage(TEST_PKG);

        assertNull(getDevice().installPackage(mBuildHelper.getTestFile(TEST_APK), false));
        getDevice().executeShellCommand(""pm enable "" + SHIM_PKG);
    }

    @Override
    protected void tearDown() throws Exception {
        super.tearDown();

        getDevice().uninstallPackage(SHIM_PKG);
        getDevice().uninstallPackage(TEST_PKG);
        getDevice().executeShellCommand(""pm enable "" + SHIM_PKG);
    }"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.appsecurity.cts.PrivilegedUpdateTests"	"testPrivilegedAppUpgradeRestricted"	"CtsAppSecurityHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PrivilegedUpdateTests.java"	""	"public void testPrivilegedAppUpgradeRestricted() throws Exception {
        getDevice().uninstallPackage(SHIM_PKG);
        assertEquals(RESTRICTED_UPGRADE_FAILURE, getDevice().installPackage(
                mBuildHelper.getTestFile(SHIM_UPDATE_FAIL_APK), true));
    }"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceadmin.BaseDeviceAdminTest"	"isDeviceOwner"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAdmin/src/com.android.cts.deviceadmin/BaseDeviceAdminTest.java"	""	"public void test/*
 *.
 */
package com.android.cts.deviceadmin;

import android.app.admin.DeviceAdminReceiver;
import android.app.admin.DevicePolicyManager;
import android.content.ComponentName;
import android.content.pm.PackageManager;
import android.os.Build;
import android.test.AndroidTestCase;
import android.util.Log;

public class BaseDeviceAdminTest extends AndroidTestCase {
    private static final String TAG = BaseDeviceAdminTest.class.getSimpleName();

    public static final class AdminReceiver extends DeviceAdminReceiver {
    }

    protected String mPackageName;
    protected ComponentName mAdminComponent;
    protected boolean mHasSecureLockScreen;

    public DevicePolicyManager dpm;

    @Override
    protected void setUp() throws Exception {
        super.setUp();

        dpm = getContext().getSystemService(DevicePolicyManager.class);
        int userId = mContext.getUserId();

        mAdminComponent = new ComponentName(mContext, AdminReceiver.class);
        mHasSecureLockScreen = mContext.getPackageManager()
                .hasSystemFeature(PackageManager.FEATURE_SECURE_LOCK_SCREEN);
        Log.d(TAG, ""setUp(): userId="" + userId + "", admin="" + mAdminComponent
                + "", isDO="" + dpm.isDeviceOwnerApp(mContext.getPackageName())
                + "", isPO="" + dpm.isProfileOwnerApp(mContext.getPackageName()));
    }

    /**
     * @return the target API level.  Note we don't get it from the package manager information
     * but we just parse the last two digits of the package name.  This is to catch a potential
     * issue where we forget to change the target API level in the manifest.  (Conversely,
     * if we forget to change the package name, we'll catch that in the caller side.)
     */
    protected int getTargetApiLevel() {
        final String packageName = mContext.getPackageName();
        return Integer.parseInt(packageName.substring(packageName.length() - 2));
    }

    protected boolean isDeviceOwner() {
        return dpm.isDeviceOwnerApp(mAdminComponent.getPackageName());
    }

    protected void assertDeviceOwner() {
        assertTrue(""Not device owner"", isDeviceOwner());
    }

    protected void assertNotDeviceOwner() {
        assertFalse(""Must not be device owner"", isDeviceOwner());
    }

    protected void assertNotActiveAdmin() throws Exception {
        for (int i = 0; i < 1000 && dpm.isAdminActive(mAdminComponent); i++) {
            Thread.sleep(10);
        }
        assertFalse(""Still active admin"", dpm.isAdminActive(mAdminComponent));
    }

    protected boolean shouldResetPasswordThrow() {
        return getTargetApiLevel() > Build.VERSION_CODES.M;
    }

    protected void resetComplexPasswordRestrictions() {
        dpm.setPasswordMinimumLength(mAdminComponent, 0);
        dpm.setPasswordMinimumUpperCase(mAdminComponent, 0);
        dpm.setPasswordMinimumLowerCase(mAdminComponent, 0);
        dpm.setPasswordMinimumLetters(mAdminComponent, 0);
        dpm.setPasswordMinimumNumeric(mAdminComponent, 0);
        dpm.setPasswordMinimumSymbols(mAdminComponent, 0);
        dpm.setPasswordMinimumNonLetter(mAdminComponent, 0);
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.admin.ScreenLockTestActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/admin/ScreenLockTestActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.admin;

import com.android.cts.verifier.managedprovisioning.DeviceAdminTestReceiver;
import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;

import android.app.AlertDialog;
import android.app.KeyguardManager;
import android.app.admin.DevicePolicyManager;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.Bundle;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;

public class ScreenLockTestActivity extends PassFailButtons.Activity {

    private static final int ADD_DEVICE_ADMIN_REQUEST_CODE = 1;

    private ScreenOffReceiver mReceiver;

    private Button mForceLockButton;

    private DevicePolicyManager mDevicePolicyManager;

    private KeyguardManager mKeyguardManager;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.da_screen_lock_main);
        setPassFailButtonClickListeners();
        setInfoResources(R.string.da_screen_lock_test, R.string.da_screen_lock_info, -1);

        mDevicePolicyManager = (DevicePolicyManager) getSystemService(DEVICE_POLICY_SERVICE);
        mKeyguardManager = (KeyguardManager) getSystemService(KEYGUARD_SERVICE);

        getPassButton().setEnabled(false);

        mForceLockButton = (Button) findViewById(R.id.da_force_lock_button);
        mForceLockButton.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                sendAddDeviceAdminIntent();
            }
        });

        mReceiver = new ScreenOffReceiver();
        IntentFilter filter = new IntentFilter();
        filter.addAction(Intent.ACTION_SCREEN_OFF);
        registerReceiver(mReceiver, filter);
    }

    private void sendAddDeviceAdminIntent() {
        Intent intent = new Intent(DevicePolicyManager.ACTION_ADD_DEVICE_ADMIN);
        intent.putExtra(DevicePolicyManager.EXTRA_DEVICE_ADMIN,
                DeviceAdminTestReceiver.getReceiverComponentName());
        startActivityForResult(intent, ADD_DEVICE_ADMIN_REQUEST_CODE);
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        switch (requestCode) {
            case ADD_DEVICE_ADMIN_REQUEST_CODE:
                handleAddDeviceAdminResult(resultCode, data);
                break;
        }
    }

    private void handleAddDeviceAdminResult(int resultCode, Intent data) {
        if (resultCode == RESULT_OK) {
            mDevicePolicyManager.lockNow();
        }
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        if (mDevicePolicyManager.isAdminActive(
                DeviceAdminTestReceiver.getReceiverComponentName())) {
            mDevicePolicyManager.removeActiveAdmin(
                DeviceAdminTestReceiver.getReceiverComponentName());
        }
        unregisterReceiver(mReceiver);
    }

    private class ScreenOffReceiver extends BroadcastReceiver {

        private static final int LOCK_CHECK_DELAY = 1000;

        @Override
        public void onReceive(Context context, Intent intent) {
            mForceLockButton.postDelayed(new Runnable() {
                @Override
                public void run() {
                    boolean lockSuccess = mKeyguardManager.inKeyguardRestrictedInputMode();
                    getPassButton().setEnabled(lockSuccess);

                    int iconId = lockSuccess
                            ? android.R.drawable.ic_dialog_info
                            : android.R.drawable.ic_dialog_alert;
                    int messageId = lockSuccess
                            ? R.string.da_lock_success
                            : R.string.da_lock_error;
                    new AlertDialog.Builder(ScreenLockTestActivity.this)
                        .setTitle(R.string.da_screen_lock_test)
                        .setMessage(messageId)
                        .setIcon(iconId)
                        .setPositiveButton(android.R.string.ok, null)
                        .show();
                }
            }, LOCK_CHECK_DELAY);
        }
    }
}"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.database.cts.CursorWindowTest"	"testCustomSize"	"CtsDatabaseTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/database/src/android/database/cts/CursorWindowTest.java"	""	"public void testCustomSize() {
        // Allocate CursorWindow with max size 10KB and test that restriction is enforced
        CursorWindow cursorWindow = new CursorWindow(""test"", 10000);
        cursorWindow.setNumColumns(1);
        byte[] bytes = new byte[8000];
        Arrays.fill(bytes, (byte) 1);
        assertTrue(cursorWindow.allocRow());
        assertTrue(""Allocation of 1 row should succeed"", cursorWindow.putBlob(bytes, 0, 0));
        assertTrue(cursorWindow.allocRow());
        assertFalse(""Allocation of 2nd row should fail"", cursorWindow.putBlob(bytes, 1, 0));
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceowner.AirplaneModeRestrictionTest"	"testAirplaneModeTurnedOffWhenRestrictionSet"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceOwner/src/com/android/cts/deviceowner/AirplaneModeRestrictionTest.java"	""	"public void testAirplaneModeTurnedOffWhenRestrictionSet() throws Exception {
        final CountDownLatch latch = new CountDownLatch(1);
        // Using array so that it can be modified in broadcast receiver.
        boolean value[] = new boolean[1];
        BroadcastReceiver receiver = new BroadcastReceiver() {
            @Override
            public void onReceive(Context context, Intent intent) {
                value[0] = intent.getBooleanExtra(""state"", true);
                latch.countDown();
            }
        };
        mContext.registerReceiver(receiver, new IntentFilter(Intent.ACTION_AIRPLANE_MODE_CHANGED));

        try {
            Settings.Global.putInt(mContext.getContentResolver(), AIRPLANE_MODE_ON, 1);
            mDevicePolicyManager.addUserRestriction(getWho(), UserManager.DISALLOW_AIRPLANE_MODE);
            assertTrue(latch.await(TIMEOUT_SEC, TimeUnit.SECONDS));
            assertFalse(value[0]);
            assertEquals(0, Settings.Global.getInt(
                    mContext.getContentResolver(), Settings.Global.AIRPLANE_MODE_ON));
        } finally {
            mContext.unregisterReceiver(receiver);
        }
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceowner.AirplaneModeRestrictionTest"	"testAirplaneModeCannotBeTurnedOnWithRestrictionOn"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceOwner/src/com/android/cts/deviceowner/AirplaneModeRestrictionTest.java"	""	"public void testAirplaneModeCannotBeTurnedOnWithRestrictionOn()
            throws Exception {
        mDevicePolicyManager.addUserRestriction(getWho(), UserManager.DISALLOW_AIRPLANE_MODE);
        Thread.sleep(SLEEP_MS);
        Settings.Global.putInt(mContext.getContentResolver(), AIRPLANE_MODE_ON, 1);
        assertEquals(0, Settings.Global.getInt(
                mContext.getContentResolver(), AIRPLANE_MODE_ON));
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceowner.AirplaneModeRestrictionTest"	"testAirplaneModeCanBeTurnedOnWithRestrictionOff"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceOwner/src/com/android/cts/deviceowner/AirplaneModeRestrictionTest.java"	""	"public void testAirplaneModeCanBeTurnedOnWithRestrictionOff() throws SettingNotFoundException {
        Settings.Global.putInt(mContext.getContentResolver(), AIRPLANE_MODE_ON, 1);
        assertEquals(1, Settings.Global.getInt(
                mContext.getContentResolver(), AIRPLANE_MODE_ON));
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.jobscheduler.cts.JobThrottlingTest"	"isDeviceIdleMode"	"CtsJobSchedulerTestCases"	"/home/gpoor/cts-12-source/cts/tests/JobScheduler/src/android/jobscheduler/cts/JobThrottlingTest.java"	""	"Api
    private static final String SCREEN_OFF_TIMEOUT = ""screen_off_timeout"";

    enum Bucket {
        ACTIVE,
        WORKING_SET,
        FREQUENT,
        RARE,
        RESTRICTED,
        NEVER
    }

    private Context mContext;
    private UiDevice mUiDevice;
    private PowerManager mPowerManager;
    private int mTestJobId;
    private int mTestPackageUid;
    private boolean mDeviceInDoze;
    private boolean mDeviceIdleEnabled;
    private boolean mAppStandbyEnabled;
    private WifiManager mWifiManager;
    private ConnectivityManager mCm;
    /** Whether the device running these tests supports WiFi. */
    private boolean mHasWifi;
    /** Track whether WiFi was enabled in case we turn it off. */
    private boolean mInitialWiFiState;
    private boolean mInitialAirplaneModeState;
    private String mInitialDisplayTimeout;
    private String mInitialRestrictedBucketEnabled;
    private boolean mAutomotiveDevice;
    private boolean mLeanbackOnly;

    private TestAppInterface mTestAppInterface;
    private DeviceConfigStateHelper mDeviceConfigStateHelper;

    private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            Log.d(TAG, ""Received action "" + intent.getAction());
            switch (intent.getAction()) {
                case ACTION_DEVICE_IDLE_MODE_CHANGED:
                case ACTION_LIGHT_DEVICE_IDLE_MODE_CHANGED:
                    synchronized (JobThrottlingTest.this) {
                        mDeviceInDoze = mPowerManager.isDeviceIdleMode();
                        Log.d(TAG, ""mDeviceInDoze: "" + mDeviceInDoze);
                    }
                    break;
            }
        }
    };

    private static boolean isDeviceIdleEnabled(UiDevice uiDevice) throws Exception {
        final String output = uiDevice.executeShellCommand(""cmd deviceidle enabled deep"").trim();
        return Integer.parseInt(output) != 0;
    }

    @Before
    public void setUp() throws Exception {
        mContext = InstrumentationRegistry.getTargetContext();
        mUiDevice = UiDevice.getInstance(InstrumentationRegistry.getInstrumentation());
        mPowerManager = mContext.getSystemService(PowerManager.class);
        mDeviceInDoze = mPowerManager.isDeviceIdleMode();
        mTestPackageUid = mContext.getPackageManager().getPackageUid(TEST_APP_PACKAGE, 0);
        mTestJobId = (int) (SystemClock.uptimeMillis() / 1000);
        mTestAppInterface = new TestAppInterface(mContext, mTestJobId);
        final IntentFilter intentFilter = new IntentFilter();
        intentFilter.addAction(ACTION_DEVICE_IDLE_MODE_CHANGED);
        intentFilter.addAction(ACTION_LIGHT_DEVICE_IDLE_MODE_CHANGED);
        mContext.registerReceiver(mReceiver, intentFilter);
        assertFalse(""Test package already in temp whitelist"", isTestAppTempWhitelisted());
        makeTestPackageIdle();
        mDeviceIdleEnabled = isDeviceIdleEnabled(mUiDevice);
        mAppStandbyEnabled = AppStandbyUtils.isAppStandbyEnabled();
        if (mAppStandbyEnabled) {
            setTestPackageStandbyBucket(Bucket.ACTIVE);
        } else {
            Log.w(TAG, ""App standby not enabled on test device"");
        }
        mWifiManager = mContext.getSystemService(WifiManager.class);
        mCm = mContext.getSystemService(ConnectivityManager.class);
        mHasWifi = mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WIFI);
        mInitialWiFiState = mWifiManager.isWifiEnabled();
        mInitialAirplaneModeState = isAirplaneModeOn();
        mInitialRestrictedBucketEnabled = Settings.Global.getString(mContext.getContentResolver(),
                Settings.Global.ENABLE_RESTRICTED_BUCKET);
        // Make sure test jobs can run regardless of bucket.
        mDeviceConfigStateHelper =
                new DeviceConfigStateHelper(DeviceConfig.NAMESPACE_JOB_SCHEDULER);
        mDeviceConfigStateHelper.set(
                new DeviceConfig.Properties.Builder(DeviceConfig.NAMESPACE_JOB_SCHEDULER)
                        .setInt(""min_ready_non_active_jobs_count"", 0).build());
        // Make sure the screen doesn't turn off when the test turns it on.
        mInitialDisplayTimeout =
                Settings.System.getString(mContext.getContentResolver(), SCREEN_OFF_TIMEOUT);
        Settings.System.putString(mContext.getContentResolver(), SCREEN_OFF_TIMEOUT, ""300000"");

        // In automotive device, always-on screen and endless battery charging are assumed.
        mAutomotiveDevice =
                mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE);
        // In leanback devices, it is assumed that there is no battery.
        mLeanbackOnly =
                mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_LEANBACK_ONLY);
        if (mAutomotiveDevice || mLeanbackOnly) {
            setScreenState(true);
            // TODO(b/159176758): make sure that initial power supply is on.
            BatteryUtils.runDumpsysBatterySetPluggedIn(true);
        }

        // Kill as many things in the background as possible so we avoid LMK interfering with the
        // test.
        mUiDevice.executeShellCommand(""am kill-all"");
    }"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.jobscheduler.cts.JobThrottlingTest"	"testJobStoppedWhenRestricted"	"CtsJobSchedulerTestCases"	"/home/gpoor/cts-12-source/cts/tests/JobScheduler/src/android/jobscheduler/cts/JobThrottlingTest.java"	""	"public void testJobStoppedWhenRestricted() throws Exception {
        sendScheduleJobBroadcast(false);
        runJob();
        assertTrue(""Job did not start after scheduling"",
                mTestAppInterface.awaitJobStart(DEFAULT_WAIT_TIMEOUT));
        setTestPackageRestricted(true);
        assertTrue(""Job did not stop after test app was restricted"",
                mTestAppInterface.awaitJobStop(DEFAULT_WAIT_TIMEOUT));
        assertEquals(JobParameters.STOP_REASON_BACKGROUND_RESTRICTION,
                mTestAppInterface.getLastParams().getStopReason());
    }"	""	""	"restricted restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.jobscheduler.cts.JobThrottlingTest"	"testRestrictedJobStartedWhenUnrestricted"	"CtsJobSchedulerTestCases"	"/home/gpoor/cts-12-source/cts/tests/JobScheduler/src/android/jobscheduler/cts/JobThrottlingTest.java"	""	"public void testRestrictedJobStartedWhenUnrestricted() throws Exception {
        setTestPackageRestricted(true);
        sendScheduleJobBroadcast(false);
        assertFalse(""Job started for restricted app"",
                mTestAppInterface.awaitJobStart(DEFAULT_WAIT_TIMEOUT));
        setTestPackageRestricted(false);
        assertTrue(""Job did not start when app was unrestricted"",
                mTestAppInterface.awaitJobStart(DEFAULT_WAIT_TIMEOUT));
    }"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.jobscheduler.cts.JobThrottlingTest"	"testRestrictedJobAllowedWhenUidActive"	"CtsJobSchedulerTestCases"	"/home/gpoor/cts-12-source/cts/tests/JobScheduler/src/android/jobscheduler/cts/JobThrottlingTest.java"	""	"public void testRestrictedJobAllowedWhenUidActive() throws Exception {
        setTestPackageRestricted(true);
        sendScheduleJobBroadcast(false);
        assertFalse(""Job started for restricted app"",
                mTestAppInterface.awaitJobStart(DEFAULT_WAIT_TIMEOUT));
        // Turn the screen on to ensure the app gets into the TOP state.
        setScreenState(true);
        mTestAppInterface.startAndKeepTestActivity(true);
        assertTrue(""Job did not start when app had an activity"",
                mTestAppInterface.awaitJobStart(DEFAULT_WAIT_TIMEOUT));

        mTestAppInterface.closeActivity();
        // Don't put full minute as the timeout to give some leeway with test timing/processing.
        assertFalse(""Job stopped within grace period after activity closed"",
                mTestAppInterface.awaitJobStop(55_000L));
        assertTrue(""Job did not stop after grace period ended"",
                mTestAppInterface.awaitJobStop(15_000L));
        assertEquals(JobParameters.STOP_REASON_BACKGROUND_RESTRICTION,
                mTestAppInterface.getLastParams().getStopReason());
    }"	""	""	"restricted restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.jobscheduler.cts.JobThrottlingTest"	"testEJStoppedWhenRestricted"	"CtsJobSchedulerTestCases"	"/home/gpoor/cts-12-source/cts/tests/JobScheduler/src/android/jobscheduler/cts/JobThrottlingTest.java"	""	"public void testEJStoppedWhenRestricted() throws Exception {
        mTestAppInterface.scheduleJob(false, JobInfo.NETWORK_TYPE_NONE, true);
        runJob();
        assertTrue(""Job did not start after scheduling"",
                mTestAppInterface.awaitJobStart(DEFAULT_WAIT_TIMEOUT));
        setTestPackageRestricted(true);
        assertTrue(""Job did not stop after test app was restricted"",
                mTestAppInterface.awaitJobStop(DEFAULT_WAIT_TIMEOUT));
        assertEquals(JobParameters.STOP_REASON_BACKGROUND_RESTRICTION,
                mTestAppInterface.getLastParams().getStopReason());
    }"	""	""	"restricted restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.jobscheduler.cts.JobThrottlingTest"	"testRestrictedEJStartedWhenUnrestricted"	"CtsJobSchedulerTestCases"	"/home/gpoor/cts-12-source/cts/tests/JobScheduler/src/android/jobscheduler/cts/JobThrottlingTest.java"	""	"public void testRestrictedEJStartedWhenUnrestricted() throws Exception {
        setTestPackageRestricted(true);
        mTestAppInterface.scheduleJob(false, JobInfo.NETWORK_TYPE_NONE, true);
        assertFalse(""Job started for restricted app"",
                mTestAppInterface.awaitJobStart(DEFAULT_WAIT_TIMEOUT));
        setTestPackageRestricted(false);
        assertTrue(""Job did not start when app was unrestricted"",
                mTestAppInterface.awaitJobStart(DEFAULT_WAIT_TIMEOUT));
    }"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.jobscheduler.cts.JobThrottlingTest"	"testRestrictedEJAllowedWhenUidActive"	"CtsJobSchedulerTestCases"	"/home/gpoor/cts-12-source/cts/tests/JobScheduler/src/android/jobscheduler/cts/JobThrottlingTest.java"	""	"public void testRestrictedEJAllowedWhenUidActive() throws Exception {
        setTestPackageRestricted(true);
        mTestAppInterface.scheduleJob(false, JobInfo.NETWORK_TYPE_NONE, true);
        assertFalse(""Job started for restricted app"",
                mTestAppInterface.awaitJobStart(DEFAULT_WAIT_TIMEOUT));
        // Turn the screen on to ensure the app gets into the TOP state.
        setScreenState(true);
        mTestAppInterface.startAndKeepTestActivity(true);
        assertTrue(""Job did not start when app had an activity"",
                mTestAppInterface.awaitJobStart(DEFAULT_WAIT_TIMEOUT));

        mTestAppInterface.closeActivity();
        // Don't put full minute as the timeout to give some leeway with test timing/processing.
        assertFalse(""Job stopped within grace period after activity closed"",
                mTestAppInterface.awaitJobStop(55_000L));
        assertTrue(""Job did not stop after grace period ended"",
                mTestAppInterface.awaitJobStop(15_000L));
        assertEquals(JobParameters.STOP_REASON_BACKGROUND_RESTRICTION,
                mTestAppInterface.getLastParams().getStopReason());
    }

    @RequiresDevice // Emulators don't always have access to wifi/network"	""	""	"restricted restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.jobscheduler.cts.JobThrottlingTest"	"testBackgroundConnectivityJobsThrottled"	"CtsJobSchedulerTestCases"	"/home/gpoor/cts-12-source/cts/tests/JobScheduler/src/android/jobscheduler/cts/JobThrottlingTest.java"	""	"public void testBackgroundConnectivityJobsThrottled() throws Exception {
        if (!mHasWifi) {
            Log.d(TAG, ""Skipping test that requires the device be WiFi enabled."");
            return;
        }
        ensureSavedWifiNetwork(mWifiManager);
        setAirplaneMode(false);
        setWifiState(true, mCm, mWifiManager);
        assumeTrue(""device idle not enabled"", mDeviceIdleEnabled);
        mTestAppInterface.scheduleJob(false, NETWORK_TYPE_ANY, false);
        runJob();
        assertTrue(""Job did not start after scheduling"",
                mTestAppInterface.awaitJobStart(DEFAULT_WAIT_TIMEOUT));
        ThermalUtils.overrideThermalStatus(Temperature.THROTTLING_CRITICAL);
        assertTrue(""Job did not stop on thermal throttling"",
                mTestAppInterface.awaitJobStop(DEFAULT_WAIT_TIMEOUT));
        Thread.sleep(TestJobSchedulerReceiver.JOB_INITIAL_BACKOFF);
        ThermalUtils.overrideThermalNotThrottling();
        runJob();
        assertTrue(""Job did not start back from throttling"",
                mTestAppInterface.awaitJobStart(DEFAULT_WAIT_TIMEOUT));
    }

    /** Tests that apps in the RESTRICTED bucket still get their one parole session per day. */"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.jobscheduler.cts.JobThrottlingTest"	"testJobsInRestrictedBucket_ParoleSession"	"CtsJobSchedulerTestCases"	"/home/gpoor/cts-12-source/cts/tests/JobScheduler/src/android/jobscheduler/cts/JobThrottlingTest.java"	""	"public void testJobsInRestrictedBucket_ParoleSession() throws Exception {
        assumeTrue(""app standby not enabled"", mAppStandbyEnabled);
        assumeFalse(""not testable in automotive device"", mAutomotiveDevice);
        assumeFalse(""not testable in leanback device"", mLeanbackOnly);

        setRestrictedBucketEnabled(true);

        // Disable coalescing
        mDeviceConfigStateHelper.set(""qc_timing_session_coalescing_duration_ms"", ""0"");

        setScreenState(true);

        BatteryUtils.runDumpsysBatteryUnplug();
        setTestPackageStandbyBucket(Bucket.RESTRICTED);
        Thread.sleep(DEFAULT_WAIT_TIMEOUT);
        sendScheduleJobBroadcast(false);
        runJob();
        assertTrue(""Parole job didn't start in RESTRICTED bucket"",
                mTestAppInterface.awaitJobStart(3_000));

        sendScheduleJobBroadcast(false);
        assertFalse(""New job started in RESTRICTED bucket"", mTestAppInterface.awaitJobStart(3_000));
    }

    /**
     * Tests that apps in the RESTRICTED bucket have their parole sessions properly counted even
     * when charging (but not idle).
     */"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.jobscheduler.cts.JobThrottlingTest"	"testJobsInRestrictedBucket_CorrectParoleWhileCharging"	"CtsJobSchedulerTestCases"	"/home/gpoor/cts-12-source/cts/tests/JobScheduler/src/android/jobscheduler/cts/JobThrottlingTest.java"	""	"public void testJobsInRestrictedBucket_CorrectParoleWhileCharging() throws Exception {
        assumeTrue(""app standby not enabled"", mAppStandbyEnabled);
        assumeFalse(""not testable in automotive device"", mAutomotiveDevice);
        assumeFalse(""not testable in leanback device"", mLeanbackOnly);

        setRestrictedBucketEnabled(true);

        // Disable coalescing
        mDeviceConfigStateHelper.set(""qc_timing_session_coalescing_duration_ms"", ""0"");
        mDeviceConfigStateHelper.set(""qc_max_session_count_restricted"", ""1"");

        setScreenState(true);
        BatteryUtils.runDumpsysBatterySetPluggedIn(true);
        BatteryUtils.runDumpsysBatterySetLevel(100);

        setTestPackageStandbyBucket(Bucket.RESTRICTED);
        Thread.sleep(DEFAULT_WAIT_TIMEOUT);
        sendScheduleJobBroadcast(false);
        runJob();
        assertTrue(""Parole job didn't start in RESTRICTED bucket"",
                mTestAppInterface.awaitJobStart(3_000));

        sendScheduleJobBroadcast(false);
        assertFalse(""New job started in RESTRICTED bucket after parole used"",
                mTestAppInterface.awaitJobStart(3_000));
    }

    /**
     * Tests that apps in the RESTRICTED bucket that have used their one parole session per day
     * don't get to run again until the device is charging + idle.
     */"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.jobscheduler.cts.JobThrottlingTest"	"testJobsInRestrictedBucket_DeferredUntilFreeResources"	"CtsJobSchedulerTestCases"	"/home/gpoor/cts-12-source/cts/tests/JobScheduler/src/android/jobscheduler/cts/JobThrottlingTest.java"	""	"public void testJobsInRestrictedBucket_DeferredUntilFreeResources() throws Exception {
        assumeTrue(""app standby not enabled"", mAppStandbyEnabled);
        assumeFalse(""not testable in automotive device"", mAutomotiveDevice);
        assumeFalse(""not testable in leanback device"", mLeanbackOnly);

        setRestrictedBucketEnabled(true);

        // Disable coalescing
        mDeviceConfigStateHelper.set(""qc_timing_session_coalescing_duration_ms"", ""0"");

        setScreenState(true);

        BatteryUtils.runDumpsysBatteryUnplug();
        setTestPackageStandbyBucket(Bucket.RESTRICTED);
        Thread.sleep(DEFAULT_WAIT_TIMEOUT);
        sendScheduleJobBroadcast(false);
        runJob();
        assertTrue(""Parole job didn't start in RESTRICTED bucket"",
                mTestAppInterface.awaitJobStart(3_000));

        sendScheduleJobBroadcast(false);
        assertFalse(""New job started in RESTRICTED bucket after parole used"",
                mTestAppInterface.awaitJobStart(3_000));

        BatteryUtils.runDumpsysBatterySetPluggedIn(true);
        BatteryUtils.runDumpsysBatterySetLevel(100);
        assertFalse(""New job started in RESTRICTED bucket after parole when charging but not idle"",
                mTestAppInterface.awaitJobStart(3_000));

        setScreenState(false);
        triggerJobIdle();
        assertTrue(""Job didn't start in RESTRICTED bucket when charging + idle"",
                mTestAppInterface.awaitJobStart(3_000));

        // Make sure job can be stopped and started again when charging + idle
        sendScheduleJobBroadcast(false);
        assertTrue(""Job didn't restart in RESTRICTED bucket when charging + idle"",
                mTestAppInterface.awaitJobStart(3_000));
    }"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.jobscheduler.cts.JobThrottlingTest"	"testJobsInRestrictedBucket_NoRequiredNetwork"	"CtsJobSchedulerTestCases"	"/home/gpoor/cts-12-source/cts/tests/JobScheduler/src/android/jobscheduler/cts/JobThrottlingTest.java"	""	"public void testJobsInRestrictedBucket_NoRequiredNetwork() throws Exception {
        assumeTrue(""app standby not enabled"", mAppStandbyEnabled);
        assumeFalse(""not testable in automotive device"", mAutomotiveDevice);
        assumeFalse(""not testable in leanback device"", mLeanbackOnly);

        setRestrictedBucketEnabled(true);

        // Disable coalescing and the parole session
        mDeviceConfigStateHelper.set(""qc_timing_session_coalescing_duration_ms"", ""0"");
        mDeviceConfigStateHelper.set(""qc_max_session_count_restricted"", ""0"");

        setAirplaneMode(true);
        setScreenState(true);

        BatteryUtils.runDumpsysBatteryUnplug();
        setTestPackageStandbyBucket(Bucket.RESTRICTED);
        Thread.sleep(DEFAULT_WAIT_TIMEOUT);
        mTestAppInterface.scheduleJob(false, NETWORK_TYPE_NONE, false);
        assertFalse(""New job started in RESTRICTED bucket"", mTestAppInterface.awaitJobStart(3_000));

        // Slowly add back required bucket constraints.

        // Battery charging and high.
        BatteryUtils.runDumpsysBatterySetPluggedIn(true);
        assertFalse(""New job started in RESTRICTED bucket"", mTestAppInterface.awaitJobStart(3_000));
        BatteryUtils.runDumpsysBatterySetLevel(100);
        assertFalse(""New job started in RESTRICTED bucket"", mTestAppInterface.awaitJobStart(3_000));

        // Device is idle.
        setScreenState(false);
        assertFalse(""New job started in RESTRICTED bucket"", mTestAppInterface.awaitJobStart(3_000));
        triggerJobIdle();
        assertTrue(""New job didn't start in RESTRICTED bucket"",
                mTestAppInterface.awaitJobStart(3_000));
    }

    @RequiresDevice // Emulators don't always have access to wifi/network"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.jobscheduler.cts.JobThrottlingTest"	"testJobsInRestrictedBucket_WithRequiredNetwork"	"CtsJobSchedulerTestCases"	"/home/gpoor/cts-12-source/cts/tests/JobScheduler/src/android/jobscheduler/cts/JobThrottlingTest.java"	""	"public void testJobsInRestrictedBucket_WithRequiredNetwork() throws Exception {
        assumeTrue(""app standby not enabled"", mAppStandbyEnabled);
        assumeFalse(""not testable in automotive device"", mAutomotiveDevice);
        assumeFalse(""not testable in leanback device"", mLeanbackOnly);

        assumeTrue(mHasWifi);
        ensureSavedWifiNetwork(mWifiManager);

        setRestrictedBucketEnabled(true);

        // Disable coalescing and the parole session
        mDeviceConfigStateHelper.set(""qc_timing_session_coalescing_duration_ms"", ""0"");
        mDeviceConfigStateHelper.set(""qc_max_session_count_restricted"", ""0"");

        setAirplaneMode(true);
        setScreenState(true);

        BatteryUtils.runDumpsysBatteryUnplug();
        setTestPackageStandbyBucket(Bucket.RESTRICTED);
        Thread.sleep(DEFAULT_WAIT_TIMEOUT);
        mTestAppInterface.scheduleJob(false, NETWORK_TYPE_ANY, false);
        runJob();
        assertFalse(""New job started in RESTRICTED bucket"", mTestAppInterface.awaitJobStart(3_000));

        // Slowly add back required bucket constraints.

        // Battery charging and high.
        BatteryUtils.runDumpsysBatterySetPluggedIn(true);
        runJob();
        assertFalse(""New job started in RESTRICTED bucket"", mTestAppInterface.awaitJobStart(3_000));
        BatteryUtils.runDumpsysBatterySetLevel(100);
        runJob();
        assertFalse(""New job started in RESTRICTED bucket"", mTestAppInterface.awaitJobStart(3_000));

        // Device is idle.
        setScreenState(false);
        runJob();
        assertFalse(""New job started in RESTRICTED bucket"", mTestAppInterface.awaitJobStart(3_000));
        triggerJobIdle();
        runJob();
        assertFalse(""New job started in RESTRICTED bucket"", mTestAppInterface.awaitJobStart(3_000));

        // Add network
        setAirplaneMode(false);
        setWifiState(true, mCm, mWifiManager);
        setWifiMeteredState(false);
        runJob();
        assertTrue(""New job didn't start in RESTRICTED bucket"",
                mTestAppInterface.awaitJobStart(5_000));
    }"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.jobscheduler.cts.JobThrottlingTest"	"testRestrictingStopReason_RestrictedBucket"	"CtsJobSchedulerTestCases"	"/home/gpoor/cts-12-source/cts/tests/JobScheduler/src/android/jobscheduler/cts/JobThrottlingTest.java"	""	"public void testRestrictingStopReason_RestrictedBucket() throws Exception {
        assumeTrue(""app standby not enabled"", mAppStandbyEnabled);
        assumeFalse(""not testable in automotive device"", mAutomotiveDevice);
        assumeFalse(""not testable in leanback device"", mLeanbackOnly);

        assumeTrue(mHasWifi);
        ensureSavedWifiNetwork(mWifiManager);

        setRestrictedBucketEnabled(true);
        setTestPackageStandbyBucket(Bucket.RESTRICTED);

        // Disable coalescing and the parole session
        mDeviceConfigStateHelper.set(""qc_timing_session_coalescing_duration_ms"", ""0"");
        mDeviceConfigStateHelper.set(""qc_max_session_count_restricted"", ""0"");

        // Satisfy all additional constraints.
        setAirplaneMode(false);
        setWifiState(true, mCm, mWifiManager);
        setWifiMeteredState(false);
        BatteryUtils.runDumpsysBatterySetPluggedIn(true);
        BatteryUtils.runDumpsysBatterySetLevel(100);
        setScreenState(false);
        triggerJobIdle();

        // Toggle individual constraints

        // Connectivity
        mTestAppInterface.scheduleJob(false, NETWORK_TYPE_ANY, false);
        runJob();
        assertTrue(""New job didn't start in RESTRICTED bucket"",
                mTestAppInterface.awaitJobStart(DEFAULT_WAIT_TIMEOUT));
        setAirplaneMode(true);
        assertTrue(""New job didn't stop when connectivity dropped"",
                mTestAppInterface.awaitJobStop(DEFAULT_WAIT_TIMEOUT));
        assertEquals(JobParameters.STOP_REASON_CONSTRAINT_CONNECTIVITY,
                mTestAppInterface.getLastParams().getStopReason());
        setAirplaneMode(false);
        setWifiState(true, mCm, mWifiManager);

        // Idle
        mTestAppInterface.scheduleJob(false, NETWORK_TYPE_ANY, false);
        runJob();
        assertTrue(""New job didn't start in RESTRICTED bucket"",
                mTestAppInterface.awaitJobStart(DEFAULT_WAIT_TIMEOUT));
        setScreenState(true);
        assertTrue(""New job didn't stop when device no longer idle"",
                mTestAppInterface.awaitJobStop(DEFAULT_WAIT_TIMEOUT));
        assertEquals(JobParameters.STOP_REASON_APP_STANDBY,
                mTestAppInterface.getLastParams().getStopReason());
        setScreenState(false);
        triggerJobIdle();

        // Charging
        mTestAppInterface.scheduleJob(false, NETWORK_TYPE_ANY, false);
        runJob();
        assertTrue(""New job didn't start in RESTRICTED bucket"",
                mTestAppInterface.awaitJobStart(DEFAULT_WAIT_TIMEOUT));
        BatteryUtils.runDumpsysBatteryUnplug();
        assertTrue(""New job didn't stop when device no longer charging"",
                mTestAppInterface.awaitJobStop(DEFAULT_WAIT_TIMEOUT));
        assertEquals(JobParameters.STOP_REASON_APP_STANDBY,
                mTestAppInterface.getLastParams().getStopReason());
        BatteryUtils.runDumpsysBatterySetPluggedIn(true);
        BatteryUtils.runDumpsysBatterySetLevel(100);

        // Battery not low
        setScreenState(false);
        triggerJobIdle();
        mTestAppInterface.scheduleJob(false, NETWORK_TYPE_ANY, false);
        runJob();
        assertTrue(""New job didn't start in RESTRICTED bucket"",
                mTestAppInterface.awaitJobStart(DEFAULT_WAIT_TIMEOUT));
        BatteryUtils.runDumpsysBatterySetLevel(1);
        assertTrue(""New job didn't stop when battery too low"",
                mTestAppInterface.awaitJobStop(DEFAULT_WAIT_TIMEOUT));
        assertEquals(JobParameters.STOP_REASON_APP_STANDBY,
                mTestAppInterface.getLastParams().getStopReason());
    }"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.jobscheduler.cts.JobThrottlingTest"	"testRestrictingStopReason_Doze"	"CtsJobSchedulerTestCases"	"/home/gpoor/cts-12-source/cts/tests/JobScheduler/src/android/jobscheduler/cts/JobThrottlingTest.java"	""	"public void testRestrictingStopReason_Doze() throws Exception {
        assumeTrue(""device idle not enabled"", mDeviceIdleEnabled);

        toggleDozeState(false);
        mTestAppInterface.scheduleJob(false, NETWORK_TYPE_NONE, false);
        runJob();
        assertTrue(""Job did not start after scheduling"",
                mTestAppInterface.awaitJobStart(DEFAULT_WAIT_TIMEOUT));

        toggleDozeState(true);
        assertTrue(""Job did not stop on entering doze"",
                mTestAppInterface.awaitJobStop(DEFAULT_WAIT_TIMEOUT));
        assertEquals(JobParameters.STOP_REASON_DEVICE_STATE,
                mTestAppInterface.getLastParams().getStopReason());
    }

    @After
    public void tearDown() throws Exception {
        AppOpsUtils.reset(TEST_APP_PACKAGE);
        // Lock thermal service to not throttling
        ThermalUtils.overrideThermalNotThrottling();
        if (mDeviceIdleEnabled) {
            toggleDozeState(false);
        }
        mTestAppInterface.cleanup();
        BatteryUtils.runDumpsysBatteryReset();
        BatteryUtils.enableBatterySaver(false);
        removeTestAppFromTempWhitelist();

        // Ensure that we leave WiFi in its previous state.
        if (mHasWifi && mWifiManager.isWifiEnabled() != mInitialWiFiState) {
            try {
                setWifiState(mInitialWiFiState, mCm, mWifiManager);
            } catch (AssertionFailedError e) {
                // Don't fail the test just because wifi state wasn't set in tearDown.
                Log.e(TAG, ""Failed to return wifi state to "" + mInitialWiFiState, e);
            }
        }
        mDeviceConfigStateHelper.restoreOriginalValues();
        Settings.Global.putString(mContext.getContentResolver(),
                Settings.Global.ENABLE_RESTRICTED_BUCKET, mInitialRestrictedBucketEnabled);
        if (isAirplaneModeOn() != mInitialAirplaneModeState) {
            setAirplaneMode(mInitialAirplaneModeState);
        }
        mUiDevice.executeShellCommand(
                ""cmd jobscheduler reset-execution-quota -u "" + UserHandle.myUserId()
                        + "" "" + TEST_APP_PACKAGE);

        Settings.System.putString(
                mContext.getContentResolver(), SCREEN_OFF_TIMEOUT, mInitialDisplayTimeout);
    }

    private void setTestPackageRestricted(boolean restricted) throws Exception {
        AppOpsUtils.setOpMode(TEST_APP_PACKAGE, ""RUN_ANY_IN_BACKGROUND"",
                restricted ? AppOpsManager.MODE_IGNORED : AppOpsManager.MODE_ALLOWED);
    }

    private void setRestrictedBucketEnabled(boolean enabled) {
        Settings.Global.putString(mContext.getContentResolver(),
                Settings.Global.ENABLE_RESTRICTED_BUCKET, enabled ? ""1"" : ""0"");
    }

    private boolean isTestAppTempWhitelisted() throws Exception {
        final String output = mUiDevice.executeShellCommand(""cmd deviceidle tempwhitelist"").trim();
        for (String line : output.split(""\n"")) {
            if (line.contains(""UID="" + mTestPackageUid)) {
                return true;
            }
        }
        return false;
    }

    private void sendScheduleJobBroadcast(boolean allowWhileIdle) throws Exception {
        mTestAppInterface.scheduleJob(allowWhileIdle, NETWORK_TYPE_NONE, false);
    }

    private void toggleDozeState(final boolean idle) throws Exception {
        mUiDevice.executeShellCommand(""cmd deviceidle "" + (idle ? ""force-idle"" : ""unforce""));
        if (!idle) {
            // Make sure the device doesn't stay idle, even after unforcing.
            mUiDevice.executeShellCommand(""cmd deviceidle motion"");
        }
        assertTrue(""Could not change device idle state to "" + idle,
                waitUntilTrue(SHELL_TIMEOUT, () -> {
                    synchronized (JobThrottlingTest.this) {
                        return mDeviceInDoze == idle;
                    }
                }));
    }

    private void tempWhitelistTestApp(long duration) throws Exception {
        mUiDevice.executeShellCommand(""cmd deviceidle tempwhitelist -d "" + duration
                + "" "" + TEST_APP_PACKAGE);
    }

    private void makeTestPackageIdle() throws Exception {
        mUiDevice.executeShellCommand(""am make-uid-idle --user current "" + TEST_APP_PACKAGE);
    }

    void setTestPackageStandbyBucket(Bucket bucket) throws Exception {
        setTestPackageStandbyBucket(mUiDevice, bucket);
    }

    static void setTestPackageStandbyBucket(UiDevice uiDevice, Bucket bucket) throws Exception {
        final String bucketName;
        switch (bucket) {
            case ACTIVE:
                bucketName = ""active"";
                break;
            case WORKING_SET:
                bucketName = ""working"";
                break;
            case FREQUENT:
                bucketName = ""frequent"";
                break;
            case RARE:
                bucketName = ""rare"";
                break;
            case RESTRICTED:
                bucketName = ""restricted"";
                break;
            case NEVER:
                bucketName = ""never"";
                break;
            default:
                throw new IllegalArgumentException(""Requested unknown bucket "" + bucket);
        }
        uiDevice.executeShellCommand(""am set-standby-bucket "" + TEST_APP_PACKAGE
                + "" "" + bucketName);
    }

    private boolean removeTestAppFromTempWhitelist() throws Exception {
        mUiDevice.executeShellCommand(""cmd deviceidle tempwhitelist -r "" + TEST_APP_PACKAGE);
        return waitUntilTrue(SHELL_TIMEOUT, () -> !isTestAppTempWhitelisted());
    }

    /**
     * Set the screen state.
     */
    private void setScreenState(boolean on) throws Exception {
        if (on) {
            mUiDevice.executeShellCommand(""input keyevent KEYCODE_WAKEUP"");
            mUiDevice.executeShellCommand(""wm dismiss-keyguard"");
        } else {
            mUiDevice.executeShellCommand(""input keyevent KEYCODE_SLEEP"");
        }
        // Wait a little bit to make sure the screen state has changed.
        Thread.sleep(2_000);
    }

    /**
     * Trigger job idle (not device idle);
     */
    private void triggerJobIdle() throws Exception {
        mUiDevice.executeShellCommand(""cmd activity idle-maintenance"");
        // Wait a moment to let that happen before proceeding.
        Thread.sleep(2_000);
    }

    /** Asks (not forces) JobScheduler to run the job if constraints are met. */
    private void runJob() throws Exception {
        // Since connectivity is a functional constraint, calling the ""run"" command without force
        // will only get the job to run if the constraint is satisfied.
        mUiDevice.executeShellCommand(""cmd jobscheduler run -s""
                + "" -u "" + UserHandle.myUserId() + "" "" + TEST_APP_PACKAGE + "" "" + mTestJobId);
    }

    private boolean isAirplaneModeOn() throws IOException {
        final String output =
                mUiDevice.executeShellCommand(""cmd connectivity airplane-mode"").trim();
        return ""enabled"".equals(output);
    }

    private void setAirplaneMode(boolean on) throws Exception {
        final CallbackAsserter airplaneModeBroadcastAsserter = CallbackAsserter.forBroadcast(
                new IntentFilter(Intent.ACTION_AIRPLANE_MODE_CHANGED));
        mUiDevice.executeShellCommand(
                ""cmd connectivity airplane-mode "" + (on ? ""enable"" : ""disable""));
        airplaneModeBroadcastAsserter.assertCalled(""Didn't get airplane mode changed broadcast"",
                15 /* 15 seconds */);
        if (!on && mHasWifi) {
            // Force wifi to connect ASAP.
            mUiDevice.executeShellCommand(""svc wifi enable"");
            //noinspection deprecation
            SystemUtil.runWithShellPermissionIdentity(mWifiManager::reconnect,
                    android.Manifest.permission.NETWORK_SETTINGS);
        }
        waitUntil(""Networks didn't change to "" + (!on ? ""on"" : ""off""), 60 /* seconds */,
                () -> {
                    if (on) {
                        return mCm.getActiveNetwork() == null
                                && (!mHasWifi || !isWiFiConnected(mCm, mWifiManager));
                    } else {
                        return mCm.getActiveNetwork() != null;
                    }
                });
        // Wait some time for the network changes to propagate. Can't use
        // waitUntil(isAirplaneModeOn() == on) because the response quickly gives the new
        // airplane mode status even though the network changes haven't propagated all the way to
        // JobScheduler.
        Thread.sleep(5000);
    }

    private static String unquoteSSID(String ssid) {
        // SSID is returned surrounded by quotes if it can be decoded as UTF-8.
        // Otherwise it's guaranteed not to start with a quote.
        if (ssid.charAt(0) == '""') {
            return ssid.substring(1, ssid.length() - 1);
        } else {
            return ssid;
        }
    }

    private String getWifiSSID() {
        final AtomicReference<String> ssid = new AtomicReference<>();
        SystemUtil.runWithShellPermissionIdentity(() -> {
            ssid.set(mWifiManager.getConnectionInfo().getSSID());
        }, Manifest.permission.ACCESS_FINE_LOCATION);
        return unquoteSSID(ssid.get());
    }

    // Returns ""true"", ""false"" or ""none""
    private String getWifiMeteredStatus(String ssid) {
        // Interestingly giving the SSID as an argument to list wifi-networks
        // only works iff the network in question has the ""false"" policy.
        // Also unfortunately runShellCommand does not pass the command to the interpreter
        // so it's not possible to | grep the ssid.
        final String command = ""cmd netpolicy list wifi-networks"";
        final String policyString = SystemUtil.runShellCommand(command);

        final Matcher m = Pattern.compile(""^"" + ssid + "";(true|false|none)$"",
                Pattern.MULTILINE | Pattern.UNIX_LINES).matcher(policyString);
        if (!m.find()) {
            fail(""Unexpected format from cmd netpolicy (when looking for "" + ssid + ""): ""
                    + policyString);
        }
        return m.group(1);
    }

    private void setWifiMeteredState(boolean metered) throws Exception {
        if (metered) {
            // Make sure unmetered cellular networks don't interfere.
            setAirplaneMode(true);
            setWifiState(true, mCm, mWifiManager);
        }
        final String ssid = getWifiSSID();
        setWifiMeteredState(ssid, metered ? ""true"" : ""false"");
    }

    // metered should be ""true"", ""false"" or ""none""
    private void setWifiMeteredState(String ssid, String metered) {
        if (metered.equals(getWifiMeteredStatus(ssid))) {
            return;
        }
        SystemUtil.runShellCommand(""cmd netpolicy set metered-network "" + ssid + "" "" + metered);
        assertEquals(getWifiMeteredStatus(ssid), metered);
    }

    private String getJobState() throws Exception {
        return mUiDevice.executeShellCommand(""cmd jobscheduler get-job-state --user cur ""
                + TEST_APP_PACKAGE + "" "" + mTestJobId).trim();
    }

    private void assertJobWaiting() throws Exception {
        String state = getJobState();
        assertTrue(""Job unexpectedly not waiting, in state: "" + state, state.contains(""waiting""));
    }

    private void assertJobNotReady() throws Exception {
        String state = getJobState();
        assertFalse(""Job unexpectedly ready, in state: "" + state, state.contains(""ready""));
    }

    private void assertJobReady() throws Exception {
        String state = getJobState();
        assertTrue(""Job unexpectedly not ready, in state: "" + state, state.contains(""ready""));
    }

    private boolean waitUntilTrue(long maxWait, Condition condition) throws Exception {
        final long deadLine = SystemClock.uptimeMillis() + maxWait;
        do {
            Thread.sleep(POLL_INTERVAL);
        } while (!condition.isTrue() && SystemClock.uptimeMillis() < deadLine);
        return condition.isTrue();
    }

    private interface Condition {
        boolean isTrue() throws Exception;
    }
}"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.jobscheduler.cts.JobThrottlingTest"	"testExpeditedJobDeferredAfterTimeout_DozeAndBatterySaver"	"CtsJobSchedulerTestCases"	"/home/gpoor/cts-12-source/cts/tests/JobScheduler/src/android/jobscheduler/cts/JobThrottlingTest.java"	""	"public void testExpeditedJobDeferredAfterTimeout_DozeAndBatterySaver() throws Exception {
        BatteryUtils.assumeBatterySaverFeature();
        assumeTrue(""device idle not enabled"", mDeviceIdleEnabled);
        mDeviceConfigStateHelper.set(""runtime_min_ej_guarantee_ms"", Long.toString(60_000L));

        BatteryUtils.runDumpsysBatteryUnplug();
        toggleDozeState(true);
        mTestAppInterface.scheduleJob(false, JobInfo.NETWORK_TYPE_NONE, true);
        runJob();
        assertTrue(""Job did not start after scheduling"",
                mTestAppInterface.awaitJobStart(DEFAULT_WAIT_TIMEOUT));
        // Don't put full minute as the timeout to give some leeway with test timing/processing.
        assertFalse(""Job stopped before min runtime limit"",
                mTestAppInterface.awaitJobStop(55_000L));
        assertTrue(""Job did not stop after timeout"", mTestAppInterface.awaitJobStop(15_000L));
        assertEquals(JobParameters.STOP_REASON_DEVICE_STATE,
                mTestAppInterface.getLastParams().getStopReason());
        // Should be rescheduled.
        assertJobNotReady();
        assertJobWaiting();
        // Battery saver kicks in before Doze ends. Job shouldn't start while BS is on.
        BatteryUtils.enableBatterySaver(true);
        toggleDozeState(false);
        Thread.sleep(TestJobSchedulerReceiver.JOB_INITIAL_BACKOFF);
        runJob();
        assertFalse(""Job started while power restrictions active after timing out"",
                mTestAppInterface.awaitJobStart(DEFAULT_WAIT_TIMEOUT));

        // Should start when battery saver is turned off.
        BatteryUtils.enableBatterySaver(false);
        assertTrue(""Job did not start after power restrictions turned off"",
                mTestAppInterface.awaitJobStart(DEFAULT_WAIT_TIMEOUT));
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.telephonyprovider.cts.SmsTest"	"testInsertEmoji_andVerify"	"CtsTelephonyProviderTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephonyprovider/src/android/telephonyprovider/cts/SmsTest.java"	""	"public void testInsertEmoji_andVerify() {
        String testSmsBodyEmoji = ""\uD83D\uDE0D\uD83D\uDE02""
                + ""\uD83D\uDE1B\uD83D\uDE00\uD83D\uDE1E☺️\uD83D\uDE1B""
                + ""\uD83D\uDE1E☺️\uD83D\uDE0D"";

        Uri uri = mSmsTestHelper.insertTestSms(TEST_ADDRESS, testSmsBodyEmoji);

        assertThat(uri).isNotNull();

        mSmsTestHelper.assertSmsColumnEquals(Telephony.Sms.BODY, uri,
                String.valueOf(testSmsBodyEmoji));
    }

    /**
     * Verifies that subqueries are not allowed with a restricted view
     */"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.view.cts.View_FocusHandlingTest"	"testEnabledHandling"	"CtsViewTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/view/src/android/view/cts/View_FocusHandlingTest.java"	""	"public void testEnabledHandling() {
        Activity activity = mActivityRule.getActivity();

        View v1 = activity.findViewById(R.id.view1);
        View v2 = activity.findViewById(R.id.view2);
        View v3 = activity.findViewById(R.id.view3);
        View v4 = activity.findViewById(R.id.view4);

        for (View v : new View[]{v1, v2, v3, v4}) v.setFocusable(true);

        assertTrue(v1.requestFocus());

        // disabled view should not be focusable
        assertTrue(v1.hasFocus());
        v1.setEnabled(false);
        assertFalse(v1.hasFocus());
        v1.requestFocus();
        assertFalse(v1.hasFocus());
        v1.setEnabled(true);
        v1.requestFocus();
        assertTrue(v1.hasFocus());

        // an enabled view should not take focus if not visible OR not enabled
        v1.setEnabled(false);
        v1.setVisibility(View.INVISIBLE);
        assertFalse(v1.hasFocus());
        v1.setEnabled(true);
        v1.requestFocus();
        assertFalse(v1.hasFocus());
        v1.setEnabled(false);
        v1.setVisibility(View.VISIBLE);
        v1.requestFocus();
        assertFalse(v1.hasFocus());
        v1.setEnabled(true);
        v1.requestFocus();
        assertTrue(v1.hasFocus());

        // test hasFocusable
        ViewGroup parent = (ViewGroup) v1.getParent();
        assertTrue(parent.hasFocusable());
        for (View v : new View[]{v1, v2, v3, v4}) v.setEnabled(false);
        assertFalse(v1.isFocused());
        assertFalse(v2.isFocused());
        assertFalse(v3.isFocused());
        assertFalse(v4.isFocused());
        assertFalse(parent.hasFocusable());

        // a view enabled while nothing has focus should get focus if not in touch mode.
        InstrumentationRegistry.getInstrumentation().setInTouchMode(false);
        for (View v : new View[]{v1, v2, v3, v4}) v.setEnabled(true);
        assertEquals(true, v1.isFocused());

        // enabled state is restricted to the view only (not children)
        v2.requestFocus();
        parent.setEnabled(false);
        assertTrue(v2.isFocused());
    }"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.telephony4.cts.SimRestrictedApisTest"	"isSimCardPresent"	"CtsSimRestrictedApisTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony4/src/android/telephony4/cts/SimRestrictedApisTest.java"	""	"/*
 *.
 */

package android.telephony4.cts;

import static androidx.test.InstrumentationRegistry.getContext;

import static org.junit.Assert.fail;

import android.content.Context;
import android.telephony.SmsManager;
import android.telephony.TelephonyManager;
import org.junit.Before;
import org.junit.Test;

public class SimRestrictedApisTest {
    private static final byte[] TEST_PDU = { 0, 0 };
    private TelephonyManager mTelephonyManager;

    @Before
    public void setUp() throws Exception {
        mTelephonyManager =
                (TelephonyManager) getContext().getSystemService(Context.TELEPHONY_SERVICE);
    }

    private boolean isSimCardPresent() {
        return mTelephonyManager.getPhoneType() != TelephonyManager.PHONE_TYPE_NONE &&
                mTelephonyManager.getSimState() != TelephonyManager.SIM_STATE_ABSENT;
    }

    /**
     * Tests the SmsManager.injectSmsPdu() API. This makes a call to injectSmsPdu() API and expects
     * a SecurityException since the test apk is not signed by a certificate on the SIM.
     */"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.hardware.cts.SensorTestCase"	"SensorTestCase"	"CtsSensorTestCases"	"/home/gpoor/cts-12-source/cts/tests/sensor/src/android/hardware/cts/SensorTestCase.java"	""	"public void test/*
 *.
 */

package android.hardware.cts;

import android.hardware.Sensor;
import android.hardware.cts.helpers.SensorTestStateNotSupportedException;
import android.hardware.cts.helpers.TestSensorEnvironment;
import android.hardware.cts.helpers.reporting.ISensorTestNode;
import android.hardware.cts.helpers.sensoroperations.SensorOperation;
import android.test.AndroidTestCase;
import android.util.Log;

/**
 * Test Case class that handles gracefully sensors that are not available in the device.
 */
public abstract class SensorTestCase extends AndroidTestCase {
    // TODO: consolidate all log tags
    protected static final String LOG_TAG = ""TestRunner"";

    /**
     * Previously for L release, we had this flag to know if each sensor is running with multiple
     * listeners each requesting different data rates. Now before running CTS tests all sensors
     * are de-activated by putting SensorService in RESTRICTED mode. Only CTS tests can
     * activate/deactivate sensors in this mode. So we can default this flag value to false.
     */
    private volatile boolean mEmulateSensorUnderLoad = false;

    /**
     * By default the test class is the root of the test hierarchy.
     */
    private volatile ISensorTestNode mCurrentTestNode = new TestClassNode(getClass());

    protected SensorTestCase() {}

    @Override
    public void runBare() throws Throwable {
        try {
            super.runBare();
        } catch (SensorTestStateNotSupportedException e) {
            // the sensor state is not supported in the device, log a warning and skip the test
            Log.w(LOG_TAG, e.getMessage());
        }
    }

    public void setEmulateSensorUnderLoad(boolean value) {
        mEmulateSensorUnderLoad = value;
    }

    protected boolean shouldEmulateSensorUnderLoad() {
        return mEmulateSensorUnderLoad;
    }

    public void setCurrentTestNode(ISensorTestNode value) {
        mCurrentTestNode = value;
    }

    protected ISensorTestNode getCurrentTestNode() {
        return mCurrentTestNode;
    }

    private class TestClassNode implements ISensorTestNode {
        private final Class<?> mTestClass;

        public TestClassNode(Class<?> testClass) {
            mTestClass = testClass;
        }

        @Override
        public String getName() {
            return mTestClass.getSimpleName();
        }
    }
}"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.userrestrictions.DeviceOwnerUserRestrictionsTest"	"getDisallowedRestrictions"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/userrestrictions/DeviceOwnerUserRestrictionsTest.java"	""	"public void test/*
 *.
 */
package com.android.cts.deviceandprofileowner.userrestrictions;

import android.os.Process;
import android.os.UserHandle;
import android.os.UserManager;

public class DeviceOwnerUserRestrictionsTest extends BaseUserRestrictionsTest {
    public static final String[] ALLOWED = new String[] {
            // UserManager.DISALLOW_CONFIG_WIFI, // Has unrecoverable side effects.
            UserManager.DISALLOW_MODIFY_ACCOUNTS,
            UserManager.DISALLOW_INSTALL_APPS,
            UserManager.DISALLOW_UNINSTALL_APPS,
            // UserManager.DISALLOW_SHARE_LOCATION, // Has unrecoverable side effects.
            // UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES, // Has unrecoverable side effects.
            UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES_GLOBALLY,
            UserManager.DISALLOW_CONFIG_BLUETOOTH,
            UserManager.DISALLOW_USB_FILE_TRANSFER,
            UserManager.DISALLOW_CONFIG_CREDENTIALS,
            UserManager.DISALLOW_REMOVE_USER,
            // UserManager.DISALLOW_DEBUGGING_FEATURES, // Need for CTS
            UserManager.DISALLOW_CONFIG_VPN,
            UserManager.DISALLOW_CONFIG_TETHERING,
            UserManager.DISALLOW_NETWORK_RESET,
            UserManager.DISALLOW_FACTORY_RESET,
            UserManager.DISALLOW_ADD_USER,
            // UserManager.ENSURE_VERIFY_APPS, // Has unrecoverable side effects.
            UserManager.DISALLOW_CONFIG_CELL_BROADCASTS,
            UserManager.DISALLOW_CONFIG_MOBILE_NETWORKS,
            UserManager.DISALLOW_APPS_CONTROL,
            UserManager.DISALLOW_MOUNT_PHYSICAL_MEDIA,
            UserManager.DISALLOW_UNMUTE_MICROPHONE,
            UserManager.DISALLOW_ADJUST_VOLUME,
            UserManager.DISALLOW_OUTGOING_CALLS,
            UserManager.DISALLOW_SMS,
            UserManager.DISALLOW_FUN,
            UserManager.DISALLOW_CREATE_WINDOWS,
            UserManager.DISALLOW_SYSTEM_ERROR_DIALOGS,
            UserManager.DISALLOW_CROSS_PROFILE_COPY_PASTE,
            UserManager.DISALLOW_OUTGOING_BEAM,
            UserManager.DISALLOW_SAFE_BOOT,
            UserManager.ALLOW_PARENT_PROFILE_APP_LINKING,
            // UserManager.DISALLOW_DATA_ROAMING, // Has unrecoverable side effects.
            UserManager.DISALLOW_SET_USER_ICON,
            UserManager.DISALLOW_BLUETOOTH,
            UserManager.DISALLOW_AUTOFILL,
            UserManager.DISALLOW_CONTENT_CAPTURE,
            UserManager.DISALLOW_CONTENT_SUGGESTIONS,
            UserManager.DISALLOW_UNIFIED_PASSWORD,
            UserManager.DISALLOW_CAMERA_TOGGLE,
            UserManager.DISALLOW_MICROPHONE_TOGGLE,
    };

    public static final String[] DISALLOWED = new String[] {
            // DO can set all public restrictions.
    };

    public static final String[] DEFAULT_ENABLED = new String[] {
            // No restrictions set for DO by default.
    };

    @Override
    protected String[] getAllowedRestrictions() {
        return ALLOWED;
    }

    @Override
    protected String[] getDisallowedRestrictions() {
        return DISALLOWED;
    }

    @Override
    protected String[] getDefaultEnabledRestrictions() { return DEFAULT_ENABLED; }

    /**
     * Picks a restriction that isn't applied by {@link UserManager} itself, applies it, and makes
     * sure that {@link UserManager} understands that it is applied but not as a base restriction.
     */"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.userrestrictions.DeviceOwnerUserRestrictionsTest"	"testHasBaseUserRestrictions"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/userrestrictions/DeviceOwnerUserRestrictionsTest.java"	""	"public void testHasBaseUserRestrictions() {
        final UserHandle userHandle = Process.myUserHandle();
        for (String r : ALL_USER_RESTRICTIONS) {
            if(!hasBaseUserRestriction(r, userHandle)) {
                mDevicePolicyManager.addUserRestriction(ADMIN_RECEIVER_COMPONENT, r);
                assertTrue(""Restriction "" + r + "" expected"",
                        mUserManager.hasUserRestriction(r, userHandle));
                assertFalse(""Restriction "" + r + "" not expected as a baseRestriction"",
                        hasBaseUserRestriction(r, userHandle));

                mDevicePolicyManager.clearUserRestriction(ADMIN_RECEIVER_COMPONENT, r);
                assertFalse(""Restriction "" + r + "" not expected"",
                        mUserManager.hasUserRestriction(r, userHandle));
                assertFalse(""Restriction "" + r + "" not expected as a baseRestriction"",
                        hasBaseUserRestriction(r, userHandle));
                return;
            }
        }
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.jobscheduler.cts.ConnectivityConstraintTest"	"isWifiEnabled"	"CtsJobSchedulerTestCases"	"/home/gpoor/cts-12-source/cts/tests/JobScheduler/src/android/jobscheduler/cts/ConnectivityConstraintTest.java"	""	"public void test/*
 *.
 */
package android.jobscheduler.cts;

import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_VALIDATED;
import static android.net.NetworkCapabilities.TRANSPORT_CELLULAR;
import static android.net.NetworkCapabilities.TRANSPORT_WIFI;

import static com.android.compatibility.common.util.TestUtils.waitUntil;

import android.Manifest;
import android.annotation.TargetApi;
import android.app.job.JobInfo;
import android.app.job.JobParameters;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageManager;
import android.net.ConnectivityManager;
import android.net.Network;
import android.net.NetworkCapabilities;
import android.net.NetworkRequest;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiManager;
import android.os.Handler;
import android.os.Looper;
import android.os.Message;
import android.platform.test.annotations.RequiresDevice;
import android.provider.Settings;
import android.util.Log;

import com.android.compatibility.common.util.AppStandbyUtils;
import com.android.compatibility.common.util.BatteryUtils;
import com.android.compatibility.common.util.CallbackAsserter;
import com.android.compatibility.common.util.ShellIdentityUtils;
import com.android.compatibility.common.util.SystemUtil;

import junit.framework.AssertionFailedError;

import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicReference;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Schedules jobs with the {@link android.app.job.JobScheduler} that have network connectivity
 * constraints.
 * Requires manipulating the {@link android.net.wifi.WifiManager} to ensure an unmetered network.
 * Similarly, requires that the phone be connected to a wifi hotspot, or else the test will fail.
 */
@TargetApi(21)
@RequiresDevice // Emulators don't always have access to wifi/network
public class ConnectivityConstraintTest extends BaseJobSchedulerTest {
    private static final String TAG = ""ConnectivityConstraintTest"";
    private static final String RESTRICT_BACKGROUND_GET_CMD =
            ""cmd netpolicy get restrict-background"";
    private static final String RESTRICT_BACKGROUND_ON_CMD =
            ""cmd netpolicy set restrict-background true"";
    private static final String RESTRICT_BACKGROUND_OFF_CMD =
            ""cmd netpolicy set restrict-background false"";

    /** Unique identifier for the job scheduled by this suite of tests. */
    public static final int CONNECTIVITY_JOB_ID = ConnectivityConstraintTest.class.hashCode();
    /** Wait this long before timing out the test. */
    private static final long DEFAULT_TIMEOUT_MILLIS = 30000L; // 30 seconds.

    private WifiManager mWifiManager;
    private ConnectivityManager mCm;

    /** Whether the device running these tests supports WiFi. */
    private boolean mHasWifi;
    /** Whether the device running these tests supports telephony. */
    private boolean mHasTelephony;
    /** Track whether WiFi was enabled in case we turn it off. */
    private boolean mInitialWiFiState;
    /** Track initial WiFi metered state. */
    private String mInitialWiFiMeteredState;
    private String mInitialWiFiSSID;
    /** Track whether restrict background policy was enabled in case we turn it off. */
    private boolean mInitialRestrictBackground;
    /** Track whether airplane mode was enabled in case we toggle it. */
    private boolean mInitialAirplaneMode;
    /** Track whether the restricted bucket was enabled in case we toggle it. */
    private String mInitialRestrictedBucketEnabled;

    private JobInfo.Builder mBuilder;

    private TestAppInterface mTestAppInterface;

    @Override
    public void setUp() throws Exception {
        super.setUp();

        mWifiManager = (WifiManager) getContext().getSystemService(Context.WIFI_SERVICE);
        mCm = (ConnectivityManager) getContext().getSystemService(Context.CONNECTIVITY_SERVICE);

        PackageManager packageManager = mContext.getPackageManager();
        mHasWifi = packageManager.hasSystemFeature(PackageManager.FEATURE_WIFI);
        mHasTelephony = packageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY);
        mBuilder = new JobInfo.Builder(CONNECTIVITY_JOB_ID, kJobServiceComponent);

        if (mHasWifi) {
            mInitialWiFiState = mWifiManager.isWifiEnabled();
            ensureSavedWifiNetwork(mWifiManager);
            setWifiState(true, mCm, mWifiManager);
            mInitialWiFiSSID = getWifiSSID();
            mInitialWiFiMeteredState = getWifiMeteredStatus(mInitialWiFiSSID);
        }
        mInitialRestrictBackground = SystemUtil
                .runShellCommand(getInstrumentation(), RESTRICT_BACKGROUND_GET_CMD)
                .contains(""enabled"");
        mInitialRestrictedBucketEnabled = Settings.Global.getString(mContext.getContentResolver(),
                Settings.Global.ENABLE_RESTRICTED_BUCKET);
        setDataSaverEnabled(false);
        mInitialAirplaneMode = isAirplaneModeOn();
        setAirplaneMode(false);
        // Force the test app out of the never bucket.
        SystemUtil.runShellCommand(""am set-standby-bucket ""
                + TestAppInterface.TEST_APP_PACKAGE + "" rare"");
    }

    @Override
    public void tearDown() throws Exception {
        if (mTestAppInterface != null) {
            mTestAppInterface.cleanup();
        }
        mJobScheduler.cancel(CONNECTIVITY_JOB_ID);

        BatteryUtils.runDumpsysBatteryReset();

        // Restore initial restrict background data usage policy
        setDataSaverEnabled(mInitialRestrictBackground);

        // Restore initial restricted bucket setting.
        Settings.Global.putString(mContext.getContentResolver(),
                Settings.Global.ENABLE_RESTRICTED_BUCKET, mInitialRestrictedBucketEnabled);

        // Ensure that we leave WiFi in its previous state.
        if (mHasWifi) {
            setWifiMeteredState(mInitialWiFiSSID, mInitialWiFiMeteredState);
            if (mWifiManager.isWifiEnabled() != mInitialWiFiState) {
                try {
                    setWifiState(mInitialWiFiState, mCm, mWifiManager);
                } catch (AssertionFailedError e) {
                    // Don't fail the test just because wifi state wasn't set in tearDown.
                    Log.e(TAG, ""Failed to return wifi state to "" + mInitialWiFiState, e);
                }
            }
        }

        // Restore initial airplane mode status. Do it after setting wifi in case wifi was
        // originally metered.
        setAirplaneMode(mInitialAirplaneMode);

        super.tearDown();
    }

    // --------------------------------------------------------------------------------------------
    // Positives - schedule jobs under conditions that require them to pass.
    // --------------------------------------------------------------------------------------------

    /**
     * Schedule a job that requires a WiFi connection, and assert that it executes when the device
     * is connected to WiFi. This will fail if a wifi connection is unavailable.
     */"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.jobscheduler.cts.ConnectivityConstraintTest"	"testExpeditedJobExecutes_IdleApp"	"CtsJobSchedulerTestCases"	"/home/gpoor/cts-12-source/cts/tests/JobScheduler/src/android/jobscheduler/cts/ConnectivityConstraintTest.java"	""	"public void testExpeditedJobExecutes_IdleApp() throws Exception {
        if (!AppStandbyUtils.isAppStandbyEnabled()) {
            Log.d(TAG, ""App standby not enabled"");
            return;
        }
        if (mHasWifi) {
            setWifiMeteredState(true);
        } else if (checkDeviceSupportsMobileData()) {
            disconnectWifiToConnectToMobile();
        } else {
            Log.d(TAG, ""Skipping test that requires a metered network."");
            return;
        }

        Settings.Global.putString(mContext.getContentResolver(),
                Settings.Global.ENABLE_RESTRICTED_BUCKET, ""1"");
        mDeviceConfigStateHelper.set(""qc_max_session_count_restricted"", ""0"");
        SystemUtil.runShellCommand(""am set-standby-bucket ""
                + kJobServiceComponent.getPackageName() + "" restricted"");
        BatteryUtils.runDumpsysBatteryUnplug();

        kTestEnvironment.setExpectedExecutions(1);
        mJobScheduler.schedule(
                mBuilder.setRequiredNetworkType(JobInfo.NETWORK_TYPE_ANY)
                        .setExpedited(true)
                        .build());
        runSatisfiedJob(CONNECTIVITY_JOB_ID);

        assertTrue(""Expedited job requiring connectivity did not fire when app was idle."",
                kTestEnvironment.awaitExecution());
    }

    /**
     * Schedule an expedited job that requires a network connection, and verify that it runs even
     * when Battery Saver is on.
     */"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.jobscheduler.cts.ConnectivityConstraintTest"	"testExpeditedJobBypassesSimultaneousFirewalls_noDataSaver"	"CtsJobSchedulerTestCases"	"/home/gpoor/cts-12-source/cts/tests/JobScheduler/src/android/jobscheduler/cts/ConnectivityConstraintTest.java"	""	"public void testExpeditedJobBypassesSimultaneousFirewalls_noDataSaver() throws Exception {
        if (!BatteryUtils.isBatterySaverSupported()) {
            Log.d(TAG, ""Skipping test that requires battery saver support"");
            return;
        }
        if (mHasWifi) {
            setWifiMeteredState(true);
        } else if (checkDeviceSupportsMobileData()) {
            disconnectWifiToConnectToMobile();
        } else {
            Log.d(TAG, ""Skipping test that requires a metered network."");
            return;
        }
        if (!AppStandbyUtils.isAppStandbyEnabled()) {
            Log.d(TAG, ""App standby not enabled"");
            return;
        }

        Settings.Global.putString(mContext.getContentResolver(),
                Settings.Global.ENABLE_RESTRICTED_BUCKET, ""1"");
        mDeviceConfigStateHelper.set(""qc_max_session_count_restricted"", ""0"");
        SystemUtil.runShellCommand(""am set-standby-bucket ""
                + kJobServiceComponent.getPackageName() + "" restricted"");
        BatteryUtils.runDumpsysBatteryUnplug();
        BatteryUtils.enableBatterySaver(true);
        setDataSaverEnabled(false);

        kTestEnvironment.setExpectedExecutions(1);
        mJobScheduler.schedule(
                mBuilder.setRequiredNetworkType(JobInfo.NETWORK_TYPE_ANY)
                        .setExpedited(true)
                        .build());
        runSatisfiedJob(CONNECTIVITY_JOB_ID);

        assertTrue(""Expedited job requiring connectivity did not fire with multiple firewalls."",
                kTestEnvironment.awaitExecution());
    }

    // --------------------------------------------------------------------------------------------
    // Positives & Negatives - schedule jobs under conditions that require that pass initially and
    // then fail with a constraint change.
    // --------------------------------------------------------------------------------------------

    /**
     * Schedule a job with a cellular connectivity constraint, and ensure that it executes
     * on a mobile data connection and is stopped when Data Saver is turned on.
     */"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.jobscheduler.cts.ConnectivityConstraintTest"	"testExpeditedJobDoesNotBypassSimultaneousFirewalls_withDataSaver"	"CtsJobSchedulerTestCases"	"/home/gpoor/cts-12-source/cts/tests/JobScheduler/src/android/jobscheduler/cts/ConnectivityConstraintTest.java"	""	"public void testExpeditedJobDoesNotBypassSimultaneousFirewalls_withDataSaver()
            throws Exception {
        if (!BatteryUtils.isBatterySaverSupported()) {
            Log.d(TAG, ""Skipping test that requires battery saver support"");
            return;
        }
        if (mHasWifi) {
            setWifiMeteredState(true);
        } else if (checkDeviceSupportsMobileData()) {
            disconnectWifiToConnectToMobile();
        } else {
            Log.d(TAG, ""Skipping test that requires a metered network."");
            return;
        }
        if (!AppStandbyUtils.isAppStandbyEnabled()) {
            Log.d(TAG, ""App standby not enabled"");
            return;
        }

        Settings.Global.putString(mContext.getContentResolver(),
                Settings.Global.ENABLE_RESTRICTED_BUCKET, ""1"");
        mDeviceConfigStateHelper.set(""qc_max_session_count_restricted"", ""0"");
        SystemUtil.runShellCommand(""am set-standby-bucket ""
                + kJobServiceComponent.getPackageName() + "" restricted"");
        BatteryUtils.runDumpsysBatteryUnplug();
        BatteryUtils.enableBatterySaver(true);
        setDataSaverEnabled(true);

        mTestAppInterface = new TestAppInterface(mContext, CONNECTIVITY_JOB_ID);

        mTestAppInterface.scheduleJob(false,  JobInfo.NETWORK_TYPE_ANY, true);
        mTestAppInterface.runSatisfiedJob();

        assertFalse(""Expedited job fired with multiple firewalls, including data saver."",
                mTestAppInterface.awaitJobStart(DEFAULT_TIMEOUT_MILLIS));
    }

    // --------------------------------------------------------------------------------------------
    // Utility methods
    // --------------------------------------------------------------------------------------------

    /**
     * Determine whether the device running these CTS tests should be subject to tests involving
     * mobile data.
     * @return True if this device will support a mobile data connection.
     */
    private boolean checkDeviceSupportsMobileData() {
        if (!mHasTelephony) {
            Log.d(TAG, ""Skipping test that requires telephony features, not supported by this"" +
                    "" device"");
            return false;
        }
        Network[] networks = mCm.getAllNetworks();
        for (Network network : networks) {
            if (mCm.getNetworkCapabilities(network)
                    .hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
                return true;
            }
        }
        Log.d(TAG, ""Skipping test that requires ConnectivityManager.TYPE_MOBILE"");
        return false;
    }

    private String unquoteSSID(String ssid) {
        // SSID is returned surrounded by quotes if it can be decoded as UTF-8.
        // Otherwise it's guaranteed not to start with a quote.
        if (ssid.charAt(0) == '""') {
            return ssid.substring(1, ssid.length() - 1);
        } else {
            return ssid;
        }
    }

    private String getWifiSSID() {
        final AtomicReference<String> ssid = new AtomicReference<>();
        SystemUtil.runWithShellPermissionIdentity(() -> {
            ssid.set(mWifiManager.getConnectionInfo().getSSID());
        }, Manifest.permission.ACCESS_FINE_LOCATION);
        return unquoteSSID(ssid.get());
    }

    // Returns ""true"", ""false"" or ""none""
    private String getWifiMeteredStatus(String ssid) {
        // Interestingly giving the SSID as an argument to list wifi-networks
        // only works iff the network in question has the ""false"" policy.
        // Also unfortunately runShellCommand does not pass the command to the interpreter
        // so it's not possible to | grep the ssid.
        final String command = ""cmd netpolicy list wifi-networks"";
        final String policyString = SystemUtil.runShellCommand(command);

        final Matcher m = Pattern.compile(""^"" + ssid + "";(true|false|none)$"",
                Pattern.MULTILINE | Pattern.UNIX_LINES).matcher(policyString);
        if (!m.find()) {
            fail(""Unexpected format from cmd netpolicy (when looking for "" + ssid + ""): ""
                    + policyString);
        }
        return m.group(1);
    }

    private void setWifiMeteredState(boolean metered) throws Exception {
        if (metered) {
            // Make sure unmetered cellular networks don't interfere.
            setAirplaneMode(true);
            setWifiState(true, mCm, mWifiManager);
        }
        final String ssid = getWifiSSID();
        setWifiMeteredState(ssid, metered ? ""true"" : ""false"");
    }

    // metered should be ""true"", ""false"" or ""none""
    private void setWifiMeteredState(String ssid, String metered) {
        if (metered.equals(getWifiMeteredStatus(ssid))) {
            return;
        }
        SystemUtil.runShellCommand(""cmd netpolicy set metered-network "" + ssid + "" "" + metered);
        assertEquals(getWifiMeteredStatus(ssid), metered);
    }

    /**
     * Ensure WiFi is enabled, and block until we've verified that we are in fact connected.
     */
    private void connectToWifi()
            throws InterruptedException {
        setWifiState(true, mCm, mWifiManager);
    }

    /**
     * Ensure WiFi is disabled, and block until we've verified that we are in fact disconnected.
     */
    private void disconnectFromWifi()
            throws InterruptedException {
        setWifiState(false, mCm, mWifiManager);
    }

    /** Ensures that the device has a wifi network saved. */
    static void ensureSavedWifiNetwork(WifiManager wifiManager) {
        final List<WifiConfiguration> savedNetworks =
                ShellIdentityUtils.invokeMethodWithShellPermissions(
                        wifiManager, WifiManager::getConfiguredNetworks);
        assertFalse(""Need at least one saved wifi network"", savedNetworks.isEmpty());
    }

    /**
     * Set Wifi connection to specific state, and block until we've verified
     * that we are in the state.
     * Taken from {@link android.net.http.cts.ApacheHttpClientTest}.
     */
    static void setWifiState(final boolean enable,
            final ConnectivityManager cm, final WifiManager wm) throws InterruptedException {
        if (enable != isWiFiConnected(cm, wm)) {
            NetworkRequest nr = new NetworkRequest.Builder().clearCapabilities().build();
            NetworkCapabilities nc = new NetworkCapabilities.Builder()
                    .addTransportType(TRANSPORT_WIFI)
                    .build();
            NetworkTracker tracker = new NetworkTracker(nc, enable, cm);
            cm.registerNetworkCallback(nr, tracker);

            if (enable) {
                SystemUtil.runShellCommand(""svc wifi enable"");
                //noinspection deprecation
                SystemUtil.runWithShellPermissionIdentity(wm::reconnect,
                        android.Manifest.permission.NETWORK_SETTINGS);
            } else {
                SystemUtil.runShellCommand(""svc wifi disable"");
            }

            tracker.waitForStateChange();

            assertTrue(""Wifi must be "" + (enable ? ""connected to"" : ""disconnected from"")
                            + "" an access point for this test."",
                    enable == isWiFiConnected(cm, wm));

            cm.unregisterNetworkCallback(tracker);
        }
    }

    static boolean isWiFiConnected(final ConnectivityManager cm, final WifiManager wm) {
        if (!wm.isWifiEnabled()) {
            return false;
        }
        final Network network = cm.getActiveNetwork();
        if (network == null) {
            return false;
        }
        final NetworkCapabilities networkCapabilities = cm.getNetworkCapabilities(network);
        return networkCapabilities != null && networkCapabilities.hasTransport(TRANSPORT_WIFI);
    }

    /**
     * Disconnect from WiFi in an attempt to connect to cellular data. Worth noting that this is
     * best effort - there are no public APIs to force connecting to cell data. We disable WiFi
     * and wait for a broadcast that we're connected to cell.
     * We will not call into this function if the device doesn't support telephony.
     * @see #mHasTelephony
     * @see #checkDeviceSupportsMobileData()
     */
    private void disconnectWifiToConnectToMobile() throws Exception {
        setAirplaneMode(false);
        if (mHasWifi && mWifiManager.isWifiEnabled()) {
            NetworkRequest nr = new NetworkRequest.Builder().clearCapabilities().build();
            NetworkCapabilities nc = new NetworkCapabilities.Builder()
                    .addTransportType(TRANSPORT_CELLULAR)
                    .build();
            NetworkTracker tracker = new NetworkTracker(nc, true, mCm);
            mCm.registerNetworkCallback(nr, tracker);

            disconnectFromWifi();

            assertTrue(""Device must have access to a metered network for this test."",
                    tracker.waitForStateChange());

            mCm.unregisterNetworkCallback(tracker);
        }
    }

    /**
     * Ensures that restrict background data usage policy is turned off.
     * If the policy is on, it interferes with tests that relies on metered connection.
     */
    private void setDataSaverEnabled(boolean enabled) throws Exception {
        SystemUtil.runShellCommand(getInstrumentation(),
                enabled ? RESTRICT_BACKGROUND_ON_CMD : RESTRICT_BACKGROUND_OFF_CMD);
    }

    private boolean isAirplaneModeOn() throws Exception {
        final String output = SystemUtil.runShellCommand(getInstrumentation(),
                ""cmd connectivity airplane-mode"").trim();
        return ""enabled"".equals(output);
    }

    private void setAirplaneMode(boolean on) throws Exception {
        if (isAirplaneModeOn() == on) {
            return;
        }
        final CallbackAsserter airplaneModeBroadcastAsserter = CallbackAsserter.forBroadcast(
                new IntentFilter(Intent.ACTION_AIRPLANE_MODE_CHANGED));
        SystemUtil.runShellCommand(getInstrumentation(),
                ""cmd connectivity airplane-mode "" + (on ? ""enable"" : ""disable""));
        airplaneModeBroadcastAsserter.assertCalled(""Didn't get airplane mode changed broadcast"",
                15 /* 15 seconds */);
        waitUntil(""Networks didn't change to "" + (!on ? "" on"" : "" off""), 60 /* seconds */,
                () -> {
                    if (on) {
                        return mCm.getActiveNetwork() == null
                                && (!mHasWifi || !isWiFiConnected(mCm, mWifiManager));
                    } else {
                        return mCm.getActiveNetwork() != null;
                    }
                });
        // Wait some time for the network changes to propagate. Can't use
        // waitUntil(isAirplaneModeOn() == on) because the response quickly gives the new
        // airplane mode status even though the network changes haven't propagated all the way to
        // JobScheduler.
        Thread.sleep(5000);
    }

    private static class NetworkTracker extends ConnectivityManager.NetworkCallback {
        private static final int MSG_CHECK_ACTIVE_NETWORK = 1;
        private final ConnectivityManager mCm;

        private final CountDownLatch mReceiveLatch = new CountDownLatch(1);

        private final NetworkCapabilities mExpectedCapabilities;

        private final boolean mExpectedConnected;

        private final Handler mHandler = new Handler(Looper.getMainLooper()) {
            @Override
            public void handleMessage(Message msg) {
                if (msg.what == MSG_CHECK_ACTIVE_NETWORK) {
                    checkActiveNetwork();
                }
            }
        };

        private NetworkTracker(NetworkCapabilities expectedCapabilities, boolean expectedConnected,
                ConnectivityManager cm) {
            mExpectedCapabilities = expectedCapabilities;
            mExpectedConnected = expectedConnected;
            mCm = cm;
        }

        @Override
        public void onAvailable(Network network) {
            // Available doesn't mean it's the active network. We need to check that separately.
            checkActiveNetwork();
        }

        @Override
        public void onLost(Network network) {
            checkActiveNetwork();
        }

        boolean waitForStateChange() throws InterruptedException {
            checkActiveNetwork();
            return mReceiveLatch.await(60, TimeUnit.SECONDS);
        }

        private void checkActiveNetwork() {
            mHandler.removeMessages(MSG_CHECK_ACTIVE_NETWORK);
            if (mReceiveLatch.getCount() == 0) {
                return;
            }

            Network activeNetwork = mCm.getActiveNetwork();
            if (mExpectedConnected) {
                if (activeNetwork != null && mExpectedCapabilities.satisfiedByNetworkCapabilities(
                        mCm.getNetworkCapabilities(activeNetwork))) {
                    mReceiveLatch.countDown();
                } else {
                    mHandler.sendEmptyMessageDelayed(MSG_CHECK_ACTIVE_NETWORK, 5000);
                }
            } else {
                if (activeNetwork == null
                        || !mExpectedCapabilities.satisfiedByNetworkCapabilities(
                        mCm.getNetworkCapabilities(activeNetwork))) {
                    mReceiveLatch.countDown();
                } else {
                    mHandler.sendEmptyMessageDelayed(MSG_CHECK_ACTIVE_NETWORK, 5000);
                }
            }
        }
    }
}"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.app.cts.ActivityManagerApi29Test"	"testTopActivityWithAppOps"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerApi29Test.java"	""	"@Ignore(""because ag/13230961, FGS started in instrumentation are not subject to while-in-use ""
            + ""restriction"")
    public void testTopActivityWithAppOps() throws Exception {
        startSimpleActivity();
        mUidWatcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_TOP,
                new Integer(PROCESS_CAPABILITY_ALL));

        // AppOps location access should be allowed.
        assertEquals(MODE_ALLOWED, noteOp(OPSTR_COARSE_LOCATION));

        stopSimpleActivity();
        mUidWatcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_CACHED_EMPTY,
                new Integer(PROCESS_CAPABILITY_NONE));

        // AppOps location access should be denied.
        assertEquals(MODE_IGNORED, noteOp(OPSTR_COARSE_LOCATION));
    }

    /**
     * When ActivityManagerService process states and capability changes, it updates AppOpsService.
     * This test starts a foreground service with location type, it updates AppOpsService with
     * PROCESS_STATE_FOREGROUND_SERVICE and PROCESS_CAPABILITY_FOREGROUND_LOCATION, then check if
     * AppOpsManager allow ACCESS_COARSE_LOCATION of MODE_FOREGROUND.
     *
     * The ""android.app.cts.activitymanager.api29"" package's targetSdkVersion is 29.
     * @throws Exception
     */"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.app.cts.ActivityManagerApi29Test"	"testFgsLocationWithAppOps"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerApi29Test.java"	""	"@Ignore(""because ag/13230961, FGS started in instrumentation are not subject to while-in-use ""
            + ""restriction"")
    public void testFgsLocationWithAppOps() throws Exception {
        // Start a foreground service with location
        startSimpleService();
        // Wait for state and capability change.
        // BG started FGS does not have location capability.
        mUidWatcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_FG_SERVICE,
                new Integer(PROCESS_CAPABILITY_NONE));

        startSimpleActivity();
        mUidWatcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_TOP,
                new Integer(PROCESS_CAPABILITY_ALL));

        // AppOps location access should be allowed.
        assertEquals(MODE_ALLOWED, noteOp(OPSTR_COARSE_LOCATION));

        stopSimpleActivity();
        mUidWatcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_FG_SERVICE,
                new Integer(PROCESS_CAPABILITY_NONE));

        // AppOps location access should be denied.
        assertEquals(MODE_IGNORED, noteOp(OPSTR_COARSE_LOCATION));

        stopSimpleService();
        mUidWatcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_CACHED_EMPTY,
                new Integer(PROCESS_CAPABILITY_NONE));

        // AppOps location access should be denied.
        assertEquals(MODE_IGNORED, noteOp(OPSTR_COARSE_LOCATION));
    }

    /**
     * After calling AppOpsManager.noteOp() interface multiple times in different process states,
     * this test calls AppOpsManager.getHistoricalOps() and check the access count and reject count
     * in HistoricalOps.
      *
     * @throws Exception
     */"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.app.cts.ActivityManagerApi29Test"	"testAppOpsHistoricalOps"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerApi29Test.java"	""	"@Ignore(""because ag/13230961, FGS started in instrumentation are not subject to while-in-use ""
            + ""restriction"")
    public void testAppOpsHistoricalOps() throws Exception {
        runWithShellPermissionIdentity(
                () ->  sAppOps.setHistoryParameters(AppOpsManager.HISTORICAL_MODE_ENABLED_ACTIVE,
                        1000, 10)
        );
        WaitForBroadcast waiter = new WaitForBroadcast(sInstrumentation.getTargetContext());
        waiter.prepare(ACTION_SIMPLE_ACTIVITY_START_RESULT);
        startSimpleActivity();
        mUidWatcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_TOP,
                new Integer(PROCESS_CAPABILITY_ALL));
        waiter.doWait(WAITFOR_MSEC);

        waiter = new WaitForBroadcast(sInstrumentation.getTargetContext());
        waiter.prepare(ACTION_SERVICE_START_RESULT);
        startSimpleService();
        waiter.doWait(WAITFOR_MSEC);

        for (int i = 0; i < NOTEOP_COUNT; i++) {
            noteOp(OPSTR_COARSE_LOCATION);
        }

        stopSimpleActivity();
        // The callingPackage to start FGS is in background.
        mUidWatcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_FG_SERVICE,
                new Integer(PROCESS_CAPABILITY_NONE));
        for (int i = 0; i < NOTEOP_COUNT; i++) {
            noteOp(OPSTR_COARSE_LOCATION);
        }
        stopSimpleService();
        mUidWatcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_CACHED_EMPTY,
                new Integer(PROCESS_CAPABILITY_NONE));

        for (int i = 0; i < NOTEOP_COUNT; i++) {
            noteOp(OPSTR_COARSE_LOCATION);
        }
        runWithShellPermissionIdentity(() -> {
            CompletableFuture<HistoricalOps> ops = new CompletableFuture<>();
            HistoricalOpsRequest histOpsRequest = new HistoricalOpsRequest.Builder(
                    Instant.now().minus(1, ChronoUnit.HOURS).toEpochMilli(),
                    Long.MAX_VALUE)
                    .setUid(sUid)
                    .setPackageName(PACKAGE_NAME)
                    .setOpNames(Arrays.asList(OPSTR_COARSE_LOCATION))
                    .setFlags(OP_FLAGS_ALL)
                    .build();
            sAppOps.getHistoricalOps(histOpsRequest, sContext.getMainExecutor(), ops::complete);
            HistoricalOp hOp = ops.get(5000, TimeUnit.MILLISECONDS)
                    .getUidOps(sUid).getPackageOps(PACKAGE_NAME)
                    .getOp(OPSTR_COARSE_LOCATION);
            assertEquals(NOTEOP_COUNT, hOp.getAccessCount(UID_STATE_TOP,
                    UID_STATE_FOREGROUND_SERVICE, AppOpsManager.OP_FLAGS_ALL));
            assertEquals(NOTEOP_COUNT, hOp.getForegroundAccessCount(OP_FLAGS_ALL));
            assertEquals(NOTEOP_COUNT, hOp.getForegroundRejectCount(OP_FLAGS_ALL));
            assertEquals(0, hOp.getBackgroundAccessCount(OP_FLAGS_ALL));
            // denied access one time in background.
            assertEquals(NOTEOP_COUNT, hOp.getBackgroundRejectCount(OP_FLAGS_ALL)); }
        );
    }

    /**
     * Only FGS started by TOP app can have OP_CAMERA and OP_RECORD_AUDIO.
     * @throws Exception
     */"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.app.cts.ActivityManagerApi29Test"	"testCameraWithAppOps"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerApi29Test.java"	""	"@Ignore(""because ag/13230961, FGS started in instrumentation are not subject to while-in-use ""
            + ""restriction"")
    public void testCameraWithAppOps() throws Exception {
        startSimpleService();
        // Wait for state and capability change.
        mUidWatcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_FG_SERVICE,
                new Integer(PROCESS_CAPABILITY_NONE));

        // Non-Top started FGS do not have while-in-use permission, camera/microphone access is
        // denied.
        assertEquals(MODE_IGNORED, noteOp(OPSTR_CAMERA));
        assertEquals(MODE_IGNORED, noteOp(OPSTR_RECORD_AUDIO));

        // Start an activity, put app in TOP.
        startSimpleActivity();
        // TOP process has all capabilities.
        mUidWatcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_TOP,
                new Integer(PROCESS_CAPABILITY_ALL));

        // Camera/microphone access is allowed because the app is TOP.
        assertEquals(MODE_ALLOWED, noteOp(OPSTR_CAMERA));
        assertEquals(MODE_ALLOWED, noteOp(OPSTR_RECORD_AUDIO));

        // Tell the activity to finalize.
        stopSimpleActivity();
        mUidWatcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_FG_SERVICE,
                new Integer(PROCESS_CAPABILITY_NONE));

        // App not in Top, camera/microphone access should be denied.
        assertEquals(MODE_IGNORED, noteOp(OPSTR_CAMERA));
        assertEquals(MODE_IGNORED, noteOp(OPSTR_RECORD_AUDIO));

        // Stop the foreground service.
        stopSimpleService();
        mUidWatcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_CACHED_EMPTY,
                new Integer(PROCESS_CAPABILITY_NONE));

        assertEquals(MODE_IGNORED, noteOp(OPSTR_CAMERA));
        assertEquals(MODE_IGNORED, noteOp(OPSTR_RECORD_AUDIO));
    }

    private int noteOp(String opStr) throws Exception {
        return callWithShellPermissionIdentity(
                () -> sAppOps.noteOp(opStr, sUid, PACKAGE_NAME,
                        opStr, """"));
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.telephony.cts.TelephonyManagerTest"	"testGetSimCardState"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	"public void testGetSimCardState() {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            return;
        }
        int simCardState = mTelephonyManager.getSimCardState();
        assertTrue(Arrays.asList(TelephonyManager.SIM_STATE_UNKNOWN,
                TelephonyManager.SIM_STATE_ABSENT,
                TelephonyManager.SIM_STATE_CARD_IO_ERROR,
                TelephonyManager.SIM_STATE_CARD_RESTRICTED,
                TelephonyManager.SIM_STATE_PRESENT).contains(simCardState));
    }

    private boolean isDataEnabled() {
        return ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,
                TelephonyManager::isDataEnabled);
    }"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.telephony.cts.TelephonyManagerTest"	"testResetSettings"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	"public void testResetSettings() throws Exception {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            Log.d(TAG, ""skipping test on device without FEATURE_TELEPHONY present"");
            return;
        }

        UserManager userManager = getContext().getSystemService(UserManager.class);

        boolean canChangeMobileNetworkSettings = userManager != null
                && !userManager.hasUserRestriction(UserManager.DISALLOW_CONFIG_MOBILE_NETWORKS);
        assertTrue(""Primary user must be able to configure mobile networks to pass this test"",
                canChangeMobileNetworkSettings);
        boolean initialDataSetting = isDataEnabled();

        //First check permissions are correct
        try {
            mTelephonyManager.resetSettings();
            fail(""TelephonyManager#resetSettings requires the""
                    + "" android.Manifest.permission.NETWORK_SETTINGS permission"");
        } catch (SecurityException e) {
            //expected
        }
        // and then do a reset to move data to default.
        try {
            ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mTelephonyManager,
                    TelephonyManager::resetSettings,
                    ""android.permission.NETWORK_SETTINGS"",
                    ""android.permission.MODIFY_PHONE_STATE"");
        } catch (SecurityException e) {
            e.printStackTrace();
            fail(e.toString());
        }
        // This may timeout because the default is equal to the initial data setting, but there is
        // no way to definitively check what the default should be, so assume the default will be
        // set within TOLERANCE time.
        TelephonyUtils.pollUntilTrue(() -> initialDataSetting != isDataEnabled(), 5 /*times*/,
                TOLERANCE/5 /*timeout per poll*/);

        boolean defaultDataSetting = isDataEnabled();

        // set data to not the default!
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mTelephonyManager,
                tm -> tm.setDataEnabled(!defaultDataSetting));
        assertTrue(""Data enable change didn't work"",
                TelephonyUtils.pollUntilTrue(() -> defaultDataSetting != isDataEnabled(),
                        5 /*times*/, TOLERANCE/5 /*timeout per poll*/));

        // and then do a reset to move data to default again.
        try {
            ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mTelephonyManager,
                    TelephonyManager::resetSettings,
                    ""android.permission.NETWORK_SETTINGS"",
                    ""android.permission.MODIFY_PHONE_STATE"");
        } catch (SecurityException e) {
            e.printStackTrace();
            fail(e.toString());
        }

        assertTrue(""resetSettings did not reset default data"",
                TelephonyUtils.pollUntilTrue(() -> defaultDataSetting == isDataEnabled(),
                        5 /*times*/, TOLERANCE/5 /*timeout per poll*/));
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.CustomizationRestrictionsTest"	"testDisallowSetWallpaper_allowed"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/CustomizationRestrictionsTest.java"	""	"public void testDisallowSetWallpaper_allowed() throws Exception {
        final WallpaperManager wallpaperManager = WallpaperManager.getInstance(mContext);
        final Bitmap originalWallpaper = BitmapUtils.getWallpaperBitmap(mContext);
        final Bitmap originalWallpaperCopy =
                originalWallpaper.copy(originalWallpaper.getConfig(), false);

        try (
                // Set restriction and subscribe for the broadcast.
                final RestrictionApplicator restr =
                        new RestrictionApplicator(UserManager.DISALLOW_SET_WALLPAPER);
                final BroadcastReceiverRegistrator bcast =
                        new BroadcastReceiverRegistrator(Intent.ACTION_WALLPAPER_CHANGED);
        ) {
            assertTrue(mUserManager.hasUserRestriction(UserManager.DISALLOW_SET_WALLPAPER));

            // Checking setBitmap() method.
            Bitmap oldWallpaper = originalWallpaperCopy;
            wallpaperManager.setBitmap(BitmapUtils.generateRandomBitmap(97, 73));
            bcast.waitForBroadcast();
            Bitmap newWallpaper = BitmapUtils.getWallpaperBitmap(mContext);
            assertFalse(BitmapUtils.compareBitmaps(newWallpaper, oldWallpaper));

            // Checking setStream() method.
            oldWallpaper = newWallpaper;
            final Bitmap wallpaperForStream = BitmapUtils.generateRandomBitmap(83, 69);
            wallpaperManager.setStream(BitmapUtils.bitmapToInputStream(wallpaperForStream));
            bcast.waitForBroadcast();
            newWallpaper = BitmapUtils.getWallpaperBitmap(mContext);
            assertFalse(BitmapUtils.compareBitmaps(newWallpaper, oldWallpaper));

            // Checking setResource() method.
            oldWallpaper = newWallpaper;
            wallpaperManager.setResource(R.raw.wallpaper);
            bcast.waitForBroadcast();
            newWallpaper = BitmapUtils.getWallpaperBitmap(mContext);
            assertFalse(BitmapUtils.compareBitmaps(newWallpaper, oldWallpaper));
        } finally {
            wallpaperManager.setBitmap(originalWallpaperCopy);
        }
        assertFalse(mUserManager.hasUserRestriction(UserManager.DISALLOW_SET_WALLPAPER));
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceowner.BluetoothRestrictionTest"	"testEnableBluetoothFailsWhenDisallowed"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceOwner/src/com/android/cts/deviceowner/BluetoothRestrictionTest.java"	""	"public void testEnableBluetoothFailsWhenDisallowed() throws Exception {
        if (mBluetoothAdapter == null) {
            return;
        }

        // Make sure Bluetooth is initially disabled.
        disable();

        // Add the user restriction disallowing Bluetooth.
        mDevicePolicyManager.addUserRestriction(getWho(), UserManager.DISALLOW_BLUETOOTH);

        // Check that enabling Bluetooth fails.
        assertFalse(mBluetoothAdapter.enable());
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceowner.BluetoothRestrictionTest"	"testBluetoothGetsDisabledAfterRestrictionSet"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceOwner/src/com/android/cts/deviceowner/BluetoothRestrictionTest.java"	""	"public void testBluetoothGetsDisabledAfterRestrictionSet() throws Exception {
        if (mBluetoothAdapter == null) {
            return;
        }

        // Make sure Bluetooth is enabled first.
        enable();

        // Add the user restriction to disallow Bluetooth.
        mDevicePolicyManager.addUserRestriction(getWho(), UserManager.DISALLOW_BLUETOOTH);

        // Check that Bluetooth gets disabled as a result.
        assertDisabledAfterTimeout();
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceowner.BluetoothRestrictionTest"	"testEnableBluetoothSucceedsAfterRestrictionRemoved"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceOwner/src/com/android/cts/deviceowner/BluetoothRestrictionTest.java"	""	"public void testEnableBluetoothSucceedsAfterRestrictionRemoved() throws Exception {
        if (mBluetoothAdapter == null) {
            return;
        }

        // Add the user restriction.
        mDevicePolicyManager.addUserRestriction(getWho(), UserManager.DISALLOW_BLUETOOTH);

        // Make sure Bluetooth is disabled.
        assertDisabledAfterTimeout();

        // Remove the user restriction.
        mDevicePolicyManager.clearUserRestriction(getWho(), UserManager.DISALLOW_BLUETOOTH);

        // Check that it is possible to enable Bluetooth again once the restriction has been
        // removed.
        enable();
    }

    /**
     * Tests that BluetoothOppLauncherActivity gets disabled when Bluetooth itself or Bluetooth
     * sharing is disallowed.
     *
     * <p> It also checks the state of the activity is set back to default if Bluetooth is not
     * disallowed anymore.
     */"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceowner.BluetoothRestrictionTest"	"testOppDisabledWhenRestrictionSet"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceOwner/src/com/android/cts/deviceowner/BluetoothRestrictionTest.java"	""	"public void testOppDisabledWhenRestrictionSet() throws Exception {
        if (mBluetoothAdapter == null) {
            return;
        }

        // First verify DISALLOW_BLUETOOTH.
        testOppDisabledWhenRestrictionSet(UserManager.DISALLOW_BLUETOOTH);
        // Verify DISALLOW_BLUETOOTH_SHARING which leaves bluetooth workable but the sharing
        // component should be disabled.
        testOppDisabledWhenRestrictionSet(UserManager.DISALLOW_BLUETOOTH_SHARING);
    }

    /** Verifies that a given restriction disables the bluetooth sharing component. */
    private void testOppDisabledWhenRestrictionSet(String restriction) {
        // Add the user restriction.
        mDevicePolicyManager.addUserRestriction(getWho(), restriction);

        // The BluetoothOppLauncherActivity's component should be disabled.
        assertComponentStateAfterTimeout(
                OPP_LAUNCHER_COMPONENT, PackageManager.COMPONENT_ENABLED_STATE_DISABLED);

        // Remove the user restriction.
        mDevicePolicyManager.clearUserRestriction(getWho(), restriction);

        // The BluetoothOppLauncherActivity's component should be in the default state.
        assertComponentStateAfterTimeout(
                OPP_LAUNCHER_COMPONENT, PackageManager.COMPONENT_ENABLED_STATE_DEFAULT);
    }

    /** Helper to turn BT off.
     * This method will either fail on an assert, or return with BT turned off.
     * Behavior of getState() and isEnabled() are validated along the way.
     */
    private void disable() {
        // Can't disable a bluetooth adapter that does not exist.
        if (mBluetoothAdapter == null)
            return;

        sleep(CHECK_WAIT_TIME_MS);
        if (mBluetoothAdapter.getState() == BluetoothAdapter.STATE_OFF) {
            assertFalse(mBluetoothAdapter.isEnabled());
            return;
        }

        assertEquals(BluetoothAdapter.STATE_ON, mBluetoothAdapter.getState());
        assertTrue(mBluetoothAdapter.isEnabled());
        mBluetoothAdapter.disable();
        assertDisabledAfterTimeout();
    }

    /**
     * Helper method which waits for Bluetooth to be disabled. Fails if it doesn't happen in a
     * given time.
     */
    private void assertDisabledAfterTimeout() {
        boolean turnOff = false;
        final long timeout = SystemClock.elapsedRealtime() + DISABLE_TIMEOUT_MS;
        while (SystemClock.elapsedRealtime() < timeout) {
            int state = mBluetoothAdapter.getState();
            switch (state) {
            case BluetoothAdapter.STATE_OFF:
                assertFalse(mBluetoothAdapter.isEnabled());
                return;
            default:
                if (state != BluetoothAdapter.STATE_ON || turnOff) {
                    assertEquals(BluetoothAdapter.STATE_TURNING_OFF, state);
                    turnOff = true;
                }
                break;
            }
            sleep(POLL_TIME_MS);
        }
        fail(""disable() timeout"");
    }

    private void assertComponentStateAfterTimeout(ComponentName component, int expectedState) {
        final long timeout = SystemClock.elapsedRealtime() + COMPONENT_STATE_TIMEOUT_MS;
        int state = -1;
        while (SystemClock.elapsedRealtime() < timeout) {
            state = mPackageManager.getComponentEnabledSetting(component);
            if (expectedState == state) {
                // Success
                return;
            }
            sleep(POLL_TIME_MS);
        }
        fail(""The state of "" + component + "" should have been "" + expectedState + "", it but was ""
                + state + "" after timeout."");
    }

    /** Helper to turn BT on.
     * This method will either fail on an assert, or return with BT turned on.
     * Behavior of getState() and isEnabled() are validated along the way.
     */
    private void enable() {
        // Can't enable a bluetooth adapter that does not exist.
        if (mBluetoothAdapter == null)
            return;

        sleep(CHECK_WAIT_TIME_MS);
        if (mBluetoothAdapter.getState() == BluetoothAdapter.STATE_ON) {
            assertTrue(mBluetoothAdapter.isEnabled());
            return;
        }

        assertEquals(BluetoothAdapter.STATE_OFF, mBluetoothAdapter.getState());
        assertFalse(mBluetoothAdapter.isEnabled());
        mBluetoothAdapter.enable();
        assertEnabledAfterTimeout();
    }

    /**
     * Helper method which waits for Bluetooth to be enabled. Fails if it doesn't happen in a given
     * time.
     */
    private void assertEnabledAfterTimeout() {
        boolean turnOn = false;
        final long timeout = SystemClock.elapsedRealtime() + ENABLE_TIMEOUT_MS;
        while (SystemClock.elapsedRealtime() < timeout) {
            int state = mBluetoothAdapter.getState();
            switch (state) {
            case BluetoothAdapter.STATE_ON:
                assertTrue(mBluetoothAdapter.isEnabled());
                return;
            default:
                if (state != BluetoothAdapter.STATE_OFF || turnOn) {
                    assertEquals(BluetoothAdapter.STATE_TURNING_ON, state);
                    turnOn = true;
                }
                break;
            }
            sleep(POLL_TIME_MS);
        }
        fail(""enable() timeout"");
    }

    private static void sleep(long t) {
        try {
            Thread.sleep(t);
        } catch (InterruptedException e) {}
    }

}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.MixedDeviceOwnerTest"	"testCannotRemoveUserIfRestrictionSet"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/MixedDeviceOwnerTest.java"	""	"public void testCannotRemoveUserIfRestrictionSet() throws Exception {
        super.testCannotRemoveUserIfRestrictionSet();
    }

    @FlakyTest
    @Override"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.MixedDeviceOwnerTest"	"testApplicationRestrictions"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/MixedDeviceOwnerTest.java"	""	"@IgnoreOnHeadlessSystemUserMode(
            reason = ""Per-user application restriction is not applicable for headless user"")
    public void testApplicationRestrictions() throws Exception {
        super.testApplicationRestrictions();
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.host.multiuser.SetUsersRestrictionsTest"	"testCantSetUserRestriction"	"CtsMultiUserHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/multiuser/src/android/host/multiuser/SetUsersRestrictionsTest.java"	""	"public void testCantSetUserRestriction() throws Exception {
        assumeNotRoot();

        final String setRestriction = ""pm set-user-restriction no_fun "";
        final String output = getDevice().executeShellCommand(setRestriction + ""1"");
        final boolean isErrorOutput = output.contains(""SecurityException"")
                && output.contains(""You need MANAGE_USERS permission"");
        assertWithMessage(""Trying to set user restriction should fail with SecurityException. ""
                + ""command output: %s"", output).that(isErrorOutput).isTrue();
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.scopedstorage.cts.host.LegacyStorageHostTest"	"isTrue"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/host/src/android/scopedstorage/cts/host/LegacyStorageHostTest.java"	""	"/*
 *.
 */

package android.scopedstorage.cts.host;

import static com.google.common.truth.Truth.assertThat;

import android.platform.test.annotations.AppModeFull;

import com.android.tradefed.device.contentprovider.ContentProviderHandler;
import com.android.tradefed.testtype.DeviceJUnit4ClassRunner;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

/**
 * Runs the legacy file path access tests.
 */
@RunWith(DeviceJUnit4ClassRunner.class)
@AppModeFull
public class LegacyStorageHostTest extends BaseHostTestCase {

    private boolean mIsExternalStorageSetup;

    private ContentProviderHandler mContentProviderHandler;

    /**
     * Runs the given phase of LegacyFileAccessTest by calling into the device.
     * Throws an exception if the test phase fails.
     */
    void runDeviceTest(String phase) throws Exception {
        assertThat(runDeviceTests(""android.scopedstorage.cts.legacy"",
                ""android.scopedstorage.cts.legacy.LegacyStorageTest"", phase)).isTrue();
    }

    /**
     * <p> Keep in mind that granting WRITE_EXTERNAL_STORAGE also grants READ_EXTERNAL_STORAGE,
     * so in order to test a case where the reader has only WRITE, we must explicitly revoke READ.
     */
    private void grantPermissions(String... perms) throws Exception {
        int currentUserId = getCurrentUserId();
        for (String perm : perms) {
            executeShellCommand(""pm grant --user %d android.scopedstorage.cts.legacy %s"",
                    currentUserId, perm);
        }
    }

    private void revokePermissions(String... perms) throws Exception {
        int currentUserId = getCurrentUserId();
        for (String perm : perms) {
            executeShellCommand(""pm revoke --user %d android.scopedstorage.cts.legacy %s"",
                    currentUserId, perm);
        }
    }

    /**
     * Creates a file {@code filePath} in shell and may bypass Media Provider restrictions for
     * creating file.
     */
    private void createFileAsShell(String filePath) throws Exception {
        executeShellCommand(""touch %s"", filePath);
        assertThat(getDevice().doesFileExist(filePath)).isTrue();
    }

    private void setupExternalStorage() throws Exception {
        if (!mIsExternalStorageSetup) {
            runDeviceTest(""setupExternalStorage"");
            mIsExternalStorageSetup = true;
        }
    }

    @Before
    public void setup() throws Exception {
        mContentProviderHandler = new ContentProviderHandler(getDevice());
        mContentProviderHandler.setUp();
        setupExternalStorage();
        // Granting WRITE automatically grants READ as well, so we grant them both explicitly by
        // default in order to avoid confusion. Test cases that don't want any of those permissions
        // have to revoke the unwanted permissions.
        grantPermissions(""android.permission.WRITE_EXTERNAL_STORAGE"",
                ""android.permission.READ_EXTERNAL_STORAGE"");
    }

    @After
    public void tearDown() throws Exception {
        mContentProviderHandler.tearDown();
        revokePermissions(""android.permission.WRITE_EXTERNAL_STORAGE"",
                ""android.permission.READ_EXTERNAL_STORAGE"");
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceowner.DevicePolicySafetyCheckerIntegrationTest"	"DevicePolicySafetyCheckerIntegrationTester"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceOwner/src/com/android/cts/deviceowner/DevicePolicySafetyCheckerIntegrationTest.java"	""	"public void test/*
 *.
 */
package com.android.cts.deviceowner;

import static android.app.admin.DevicePolicyManager.OPERATION_CREATE_AND_MANAGE_USER;
import static android.app.admin.DevicePolicyManager.OPERATION_REBOOT;
import static android.app.admin.DevicePolicyManager.OPERATION_REMOVE_USER;
import static android.app.admin.DevicePolicyManager.OPERATION_REQUEST_BUGREPORT;
import static android.app.admin.DevicePolicyManager.OPERATION_SET_APPLICATION_HIDDEN;
import static android.app.admin.DevicePolicyManager.OPERATION_SET_APPLICATION_RESTRICTIONS;
import static android.app.admin.DevicePolicyManager.OPERATION_SET_CAMERA_DISABLED;
import static android.app.admin.DevicePolicyManager.OPERATION_SET_FACTORY_RESET_PROTECTION_POLICY;
import static android.app.admin.DevicePolicyManager.OPERATION_SET_GLOBAL_PRIVATE_DNS;
import static android.app.admin.DevicePolicyManager.OPERATION_SET_KEEP_UNINSTALLED_PACKAGES;
import static android.app.admin.DevicePolicyManager.OPERATION_SET_KEYGUARD_DISABLED;
import static android.app.admin.DevicePolicyManager.OPERATION_SET_LOCK_TASK_FEATURES;
import static android.app.admin.DevicePolicyManager.OPERATION_SET_LOCK_TASK_PACKAGES;
import static android.app.admin.DevicePolicyManager.OPERATION_SET_LOGOUT_ENABLED;
import static android.app.admin.DevicePolicyManager.OPERATION_SET_OVERRIDE_APNS_ENABLED;
import static android.app.admin.DevicePolicyManager.OPERATION_SET_PACKAGES_SUSPENDED;
import static android.app.admin.DevicePolicyManager.OPERATION_SET_STATUS_BAR_DISABLED;
import static android.app.admin.DevicePolicyManager.OPERATION_SET_SYSTEM_SETTING;
import static android.app.admin.DevicePolicyManager.OPERATION_SET_SYSTEM_UPDATE_POLICY;
import static android.app.admin.DevicePolicyManager.OPERATION_SET_TRUST_AGENT_CONFIGURATION;
import static android.app.admin.DevicePolicyManager.OPERATION_SET_USER_CONTROL_DISABLED_PACKAGES;
import static android.app.admin.DevicePolicyManager.OPERATION_START_USER_IN_BACKGROUND;
import static android.app.admin.DevicePolicyManager.OPERATION_STOP_USER;
import static android.app.admin.DevicePolicyManager.OPERATION_SWITCH_USER;
import static android.app.admin.DevicePolicyManager.OPERATION_UNINSTALL_CA_CERT;
import static android.app.admin.DevicePolicyManager.OPERATION_WIPE_DATA;

import android.app.admin.DevicePolicyManager;
import android.app.admin.FactoryResetProtectionPolicy;
import android.content.ComponentName;
import android.os.Bundle;
import android.os.UserHandle;

import com.android.cts.devicepolicy.DevicePolicySafetyCheckerIntegrationTester;
import com.android.internal.util.ArrayUtils;

import java.util.Arrays;
import java.util.List;

// TODO(b/174859111): move to automotive-only section
/**
 * Tests that DPM calls fail when determined by the
 * {@link android.app.admin.DevicePolicySafetyChecker}.
 */
public final class DevicePolicySafetyCheckerIntegrationTest extends BaseDeviceOwnerTest {
    private static final int NO_FLAGS = 0;
    private static final UserHandle USER_HANDLE = UserHandle.of(42);
    public static final String TEST_PACKAGE = BasicAdminReceiver.class.getPackage().getName();
    public static final ComponentName TEST_COMPONENT = new ComponentName(
            TEST_PACKAGE, BasicAdminReceiver.class.getName());
    public static final List<String> TEST_ACCOUNTS = Arrays.asList(""Account 1"");
    public static final List<String> TEST_PACKAGES = Arrays.asList(TEST_PACKAGE);
    private static final String TEST_CA =
            ""-----BEGIN CERTIFICATE-----\n""
            + ""MIICVzCCAgGgAwIBAgIJAMvnLHnnfO/IMA0GCSqGSIb3DQEBBQUAMIGGMQswCQYD\n""
            + ""VQQGEwJJTjELMAkGA1UECAwCQVAxDDAKBgNVBAcMA0hZRDEVMBMGA1UECgwMSU1G\n""
            + ""TCBQVlQgTFREMRAwDgYDVQQLDAdJTUZMIE9VMRIwEAYDVQQDDAlJTUZMLklORk8x\n""
            + ""HzAdBgkqhkiG9w0BCQEWEHJhbWVzaEBpbWZsLmluZm8wHhcNMTMwODI4MDk0NDA5\n""
            + ""WhcNMjMwODI2MDk0NDA5WjCBhjELMAkGA1UEBhMCSU4xCzAJBgNVBAgMAkFQMQww\n""
            + ""CgYDVQQHDANIWUQxFTATBgNVBAoMDElNRkwgUFZUIExURDEQMA4GA1UECwwHSU1G\n""
            + ""TCBPVTESMBAGA1UEAwwJSU1GTC5JTkZPMR8wHQYJKoZIhvcNAQkBFhByYW1lc2hA\n""
            + ""aW1mbC5pbmZvMFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAJ738cbTQlNIO7O6nV/f\n""
            + ""DJTMvWbPkyHYX8CQ7yXiAzEiZ5bzKJjDJmpRAkUrVinljKns2l6C4++l/5A7pFOO\n""
            + ""33kCAwEAAaNQME4wHQYDVR0OBBYEFOdbZP7LaMbgeZYPuds2CeSonmYxMB8GA1Ud\n""
            + ""IwQYMBaAFOdbZP7LaMbgeZYPuds2CeSonmYxMAwGA1UdEwQFMAMBAf8wDQYJKoZI\n""
            + ""hvcNAQEFBQADQQBdrk6J9koyylMtl/zRfiMAc2zgeC825fgP6421NTxs1rjLs1HG\n""
            + ""VcUyQ1/e7WQgOaBHi9TefUJi+4PSVSluOXon\n""
            + ""-----END CERTIFICATE-----"";
    private final DevicePolicySafetyCheckerIntegrationTester mTester =
            new DevicePolicySafetyCheckerIntegrationTester() {

        @Override
        protected int[] getSafetyAwareOperations() {
            int[] operations = new int [] {
                    OPERATION_CREATE_AND_MANAGE_USER,
                    // TODO(b/175245108) Add test for this operation; testing
                    // dpm.installSystemUpdate will require upload a test system update file.
                    // OPERATION_INSTALL_SYSTEM_UPDATE,
                    OPERATION_REBOOT,
                    OPERATION_REMOVE_USER,
                    OPERATION_REQUEST_BUGREPORT,
                    OPERATION_SET_APPLICATION_HIDDEN,
                    OPERATION_SET_APPLICATION_RESTRICTIONS,
                    OPERATION_SET_CAMERA_DISABLED,
                    OPERATION_SET_FACTORY_RESET_PROTECTION_POLICY,
                    OPERATION_SET_GLOBAL_PRIVATE_DNS,
                    OPERATION_SET_KEEP_UNINSTALLED_PACKAGES,
                    OPERATION_SET_KEYGUARD_DISABLED,
                    OPERATION_SET_LOCK_TASK_FEATURES,
                    OPERATION_SET_LOCK_TASK_PACKAGES,
                    OPERATION_SET_LOGOUT_ENABLED,
                    OPERATION_SET_PACKAGES_SUSPENDED,
                    OPERATION_SET_STATUS_BAR_DISABLED,
                    OPERATION_SET_SYSTEM_SETTING,
                    OPERATION_SET_SYSTEM_UPDATE_POLICY,
                    OPERATION_SET_USER_CONTROL_DISABLED_PACKAGES,
                    OPERATION_START_USER_IN_BACKGROUND,
                    OPERATION_STOP_USER,
                    OPERATION_SWITCH_USER,
                    OPERATION_UNINSTALL_CA_CERT,
                    OPERATION_WIPE_DATA
            };

            if (mHasTelephonyFeature) {
                operations = ArrayUtils.appendInt(operations, OPERATION_SET_OVERRIDE_APNS_ENABLED);
            }
            if (mHasSecureLockScreen) {
                operations = ArrayUtils.appendInt(operations,
                        OPERATION_SET_TRUST_AGENT_CONFIGURATION);
            }

            return operations;
        }

        @Override
        protected int[] getOverloadedSafetyAwareOperations() {
            return new int [] {
                OPERATION_WIPE_DATA
            };
        }

        @Override
        protected void runOperation(DevicePolicyManager dpm, ComponentName admin, int operation,
                boolean overloaded) {
            switch (operation) {
                case OPERATION_CREATE_AND_MANAGE_USER:
                    dpm.createAndManageUser(admin, /* name= */ null, admin, /* adminExtras= */ null,
                            NO_FLAGS);
                    break;
                case OPERATION_REBOOT:
                    dpm.reboot(admin);
                    break;
                case OPERATION_REMOVE_USER:
                    dpm.removeUser(admin, USER_HANDLE);
                    break;
                case OPERATION_REQUEST_BUGREPORT:
                    dpm.requestBugreport(admin);
                    break;
                case OPERATION_SET_APPLICATION_HIDDEN:
                    dpm.setApplicationHidden(admin, TEST_PACKAGE, /* hidden= */true);
                    break;
                case OPERATION_SET_APPLICATION_RESTRICTIONS:
                    dpm.setApplicationRestrictions(admin, TEST_PACKAGE, new Bundle());
                    break;
                case OPERATION_SET_CAMERA_DISABLED:
                    dpm.setCameraDisabled(admin, /* disabled= */ true);
                    break;
                case OPERATION_SET_FACTORY_RESET_PROTECTION_POLICY:
                    dpm.setFactoryResetProtectionPolicy(admin,
                            new FactoryResetProtectionPolicy.Builder()
                                    .setFactoryResetProtectionAccounts(TEST_ACCOUNTS)
                                    .setFactoryResetProtectionEnabled(false)
                                    .build());
                    break;
                case OPERATION_SET_GLOBAL_PRIVATE_DNS:
                    dpm.setGlobalPrivateDnsModeOpportunistic(admin);
                    break;
                case OPERATION_SET_KEEP_UNINSTALLED_PACKAGES:
                    dpm.setKeepUninstalledPackages(admin, TEST_PACKAGES);
                    break;
                case OPERATION_SET_KEYGUARD_DISABLED:
                    dpm.setKeyguardDisabled(admin, true);
                    break;
                case OPERATION_SET_LOCK_TASK_FEATURES:
                    dpm.setLockTaskFeatures(admin, NO_FLAGS);
                    break;
                case OPERATION_SET_LOCK_TASK_PACKAGES:
                    dpm.setLockTaskPackages(admin, new String[] { TEST_PACKAGE });
                    break;
                case OPERATION_SET_LOGOUT_ENABLED:
                    dpm.setLogoutEnabled(admin, /* enabled */ true);
                    break;
                case OPERATION_SET_OVERRIDE_APNS_ENABLED:
                    dpm.setOverrideApnsEnabled(admin, /* enabled */ true);
                    break;
                case OPERATION_SET_PACKAGES_SUSPENDED:
                    dpm.setPackagesSuspended(admin,  new String[] { TEST_PACKAGE },
                            /* suspend= */ true);
                    break;
                case OPERATION_SET_STATUS_BAR_DISABLED:
                    dpm.setStatusBarDisabled(admin, true);
                    break;
                case OPERATION_SET_SYSTEM_SETTING:
                    dpm.setSystemSetting(admin, ""TestSetting"", ""0"");
                    break;
                case OPERATION_SET_SYSTEM_UPDATE_POLICY:
                    dpm.setSystemUpdatePolicy(admin, null);
                    break;
                case OPERATION_SET_TRUST_AGENT_CONFIGURATION:
                    dpm.setTrustAgentConfiguration(admin, TEST_COMPONENT,
                            /* configuration= */ null);
                    break;
                case OPERATION_SET_USER_CONTROL_DISABLED_PACKAGES:
                    dpm.setUserControlDisabledPackages(admin, TEST_PACKAGES);
                    break;
                case OPERATION_START_USER_IN_BACKGROUND:
                    dpm.startUserInBackground(admin, USER_HANDLE);
                    break;
                case OPERATION_STOP_USER:
                    dpm.stopUser(admin, USER_HANDLE);
                    break;
                case OPERATION_SWITCH_USER:
                    dpm.switchUser(admin, USER_HANDLE);
                    break;
                case OPERATION_UNINSTALL_CA_CERT:
                    dpm.uninstallCaCert(admin, TEST_CA.getBytes());
                    break;
                case OPERATION_WIPE_DATA:
                    if (overloaded) {
                        dpm.wipeData(NO_FLAGS,
                                /* reason= */ ""DevicePolicySafetyCheckerIntegrationTest"");
                    } else {
                        dpm.wipeData(NO_FLAGS);
                    }
                    break;
                default:
                    throwUnsupportedOperationException(operation, overloaded);
            }
        }
    };

    /**
     * Tests that all safety-aware operations are properly implemented.
     */"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.hardware.camera2.cts.CameraDeviceTest"	"testCreateSessionWithParameters"	"CtsCameraTestCases"	"/home/gpoor/cts-12-source/cts/tests/camera/src/android/hardware/camera2/cts/CameraDeviceTest.java"	""	"public void testCreateSessionWithParameters() throws Exception {
        for (int i = 0; i < mCameraIdsUnderTest.length; i++) {
            try {
                if (!mAllStaticInfo.get(mCameraIdsUnderTest[i]).isColorOutputSupported()) {
                    Log.i(TAG, ""Camera "" + mCameraIdsUnderTest[i] +
                            "" does not support color outputs, skipping"");
                    continue;
                }
                openDevice(mCameraIdsUnderTest[i], mCameraMockListener);
                waitForDeviceState(STATE_OPENED, CAMERA_OPEN_TIMEOUT_MS);

                testCreateSessionWithParametersByCamera(mCameraIdsUnderTest[i], /*reprocessable*/false);
                testCreateSessionWithParametersByCamera(mCameraIdsUnderTest[i], /*reprocessable*/true);
            }
            finally {
                closeDevice(mCameraIdsUnderTest[i], mCameraMockListener);
            }
        }
    }

    /**
     * Verify creating a session with additional parameters works
     */
    private void testCreateSessionWithParametersByCamera(String cameraId, boolean reprocessable)
            throws Exception {
        final int SESSION_TIMEOUT_MS = 1000;
        final int CAPTURE_TIMEOUT_MS = 3000;
        int inputFormat = ImageFormat.YUV_420_888;
        int outputFormat = inputFormat;
        Size outputSize = mOrderedPreviewSizes.get(0);
        Size inputSize = outputSize;
        InputConfiguration inputConfig = null;

        if (VERBOSE) {
            Log.v(TAG, ""Testing creating session with parameters for camera "" + cameraId);
        }

        CameraCharacteristics characteristics = mCameraManager.getCameraCharacteristics(cameraId);
        StreamConfigurationMap config = characteristics.get(
                CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);

        if (reprocessable) {
            //Pick a supported i/o format and size combination.
            //Ideally the input format should match the output.
            boolean found = false;
            int inputFormats [] = config.getInputFormats();
            if (inputFormats.length == 0) {
                return;
            }

            for (int inFormat : inputFormats) {
                int outputFormats [] = config.getValidOutputFormatsForInput(inFormat);
                for (int outFormat : outputFormats) {
                    if (inFormat == outFormat) {
                        inputFormat = inFormat;
                        outputFormat = outFormat;
                        found = true;
                        break;
                    }
                }
                if (found) {
                    break;
                }
            }

            //In case the above combination doesn't exist, pick the first first supported
            //pair.
            if (!found) {
                inputFormat = inputFormats[0];
                int outputFormats [] = config.getValidOutputFormatsForInput(inputFormat);
                assertTrue(""No output formats supported for input format: "" + inputFormat,
                        (outputFormats.length > 0));
                outputFormat = outputFormats[0];
            }

            Size inputSizes[] = config.getInputSizes(inputFormat);
            Size outputSizes[] = config.getOutputSizes(outputFormat);
            assertTrue(""No valid sizes supported for input format: "" + inputFormat,
                    (inputSizes.length > 0));
            assertTrue(""No valid sizes supported for output format: "" + outputFormat,
                    (outputSizes.length > 0));

            inputSize = inputSizes[0];
            outputSize = outputSizes[0];
            inputConfig = new InputConfiguration(inputSize.getWidth(),
                    inputSize.getHeight(), inputFormat);
        } else {
            if (config.isOutputSupportedFor(outputFormat)) {
                outputSize = config.getOutputSizes(outputFormat)[0];
            } else {
                return;
            }
        }

        ImageReader imageReader = ImageReader.newInstance(outputSize.getWidth(),
                outputSize.getHeight(), outputFormat, /*maxImages*/1);

        try {
            mSessionMockListener = spy(new BlockingSessionCallback());
            mSessionWaiter = mSessionMockListener.getStateWaiter();
            List<OutputConfiguration> outputs = new ArrayList<>();
            outputs.add(new OutputConfiguration(imageReader.getSurface()));
            SessionConfiguration sessionConfig = new SessionConfiguration(
                    SessionConfiguration.SESSION_REGULAR, outputs,
                    new HandlerExecutor(mHandler), mSessionMockListener);

            CaptureRequest.Builder builder =
                    mCamera.createCaptureRequest(CameraDevice.TEMPLATE_STILL_CAPTURE);
            builder.addTarget(imageReader.getSurface());
            CaptureRequest request = builder.build();

            sessionConfig.setInputConfiguration(inputConfig);
            sessionConfig.setSessionParameters(request);
            mCamera.createCaptureSession(sessionConfig);

            mSession = mSessionMockListener.waitAndGetSession(SESSION_CONFIGURE_TIMEOUT_MS);

            // Verify we can capture a frame with the session.
            SimpleCaptureCallback captureListener = new SimpleCaptureCallback();
            SimpleImageReaderListener imageListener = new SimpleImageReaderListener();
            imageReader.setOnImageAvailableListener(imageListener, mHandler);

            mSession.capture(request, captureListener, mHandler);
            captureListener.getCaptureResultForRequest(request, CAPTURE_TIMEOUT_MS);
            imageListener.getImage(CAPTURE_TIMEOUT_MS).close();
        } finally {
            imageReader.close();
            mSession.close();
        }
    }

    /**
     * Verify creating sessions back to back and only the last one is valid for
     * submitting requests.
     */
    private void testCreateSessionsByCamera(String cameraId) throws Exception {
        final int NUM_SESSIONS = 3;
        final int SESSION_TIMEOUT_MS = 1000;
        final int CAPTURE_TIMEOUT_MS = 3000;

        if (VERBOSE) {
            Log.v(TAG, ""Testing creating sessions for camera "" + cameraId);
        }

        Size yuvSize = getSortedSizesForFormat(cameraId, mCameraManager, ImageFormat.YUV_420_888,
                /*bound*/null).get(0);
        Size jpegSize = getSortedSizesForFormat(cameraId, mCameraManager, ImageFormat.JPEG,
                /*bound*/null).get(0);

        // Create a list of image readers. JPEG for last one and YUV for the rest.
        List<ImageReader> imageReaders = new ArrayList<>();
        List<CameraCaptureSession> allSessions = new ArrayList<>();

        try {
            for (int i = 0; i < NUM_SESSIONS - 1; i++) {
                imageReaders.add(ImageReader.newInstance(yuvSize.getWidth(), yuvSize.getHeight(),
                        ImageFormat.YUV_420_888, /*maxImages*/1));
            }
            imageReaders.add(ImageReader.newInstance(jpegSize.getWidth(), jpegSize.getHeight(),
                    ImageFormat.JPEG, /*maxImages*/1));

            // Create multiple sessions back to back.
            MultipleSessionCallback sessionListener =
                    new MultipleSessionCallback(/*failOnConfigureFailed*/true);
            for (int i = 0; i < NUM_SESSIONS; i++) {
                List<Surface> outputs = new ArrayList<>();
                outputs.add(imageReaders.get(i).getSurface());
                mCamera.createCaptureSession(outputs, sessionListener, mHandler);
            }

            // Verify we get onConfigured() for all sessions.
            allSessions = sessionListener.getAllSessions(NUM_SESSIONS,
                    SESSION_TIMEOUT_MS * NUM_SESSIONS);
            assertEquals(String.format(""Got %d sessions but configured %d sessions"",
                    allSessions.size(), NUM_SESSIONS), allSessions.size(), NUM_SESSIONS);

            // Verify all sessions except the last one are closed.
            for (int i = 0; i < NUM_SESSIONS - 1; i++) {
                sessionListener.waitForSessionClose(allSessions.get(i), SESSION_TIMEOUT_MS);
            }

            // Verify we can capture a frame with the last session.
            CameraCaptureSession session = allSessions.get(allSessions.size() - 1);
            SimpleCaptureCallback captureListener = new SimpleCaptureCallback();
            ImageReader reader = imageReaders.get(imageReaders.size() - 1);
            SimpleImageReaderListener imageListener = new SimpleImageReaderListener();
            reader.setOnImageAvailableListener(imageListener, mHandler);

            CaptureRequest.Builder builder =
                    mCamera.createCaptureRequest(CameraDevice.TEMPLATE_STILL_CAPTURE);
            builder.addTarget(reader.getSurface());
            CaptureRequest request = builder.build();

            session.capture(request, captureListener, mHandler);
            captureListener.getCaptureResultForRequest(request, CAPTURE_TIMEOUT_MS);
            imageListener.getImage(CAPTURE_TIMEOUT_MS).close();
        } finally {
            for (ImageReader reader : imageReaders) {
                reader.close();
            }
            for (CameraCaptureSession session : allSessions) {
                session.close();
            }
        }
    }

    private void prepareTestByCamera() throws Exception {
        final int PREPARE_TIMEOUT_MS = 10000;

        mSessionMockListener = spy(new BlockingSessionCallback());

        SurfaceTexture output1 = new SurfaceTexture(1);
        Surface output1Surface = new Surface(output1);
        SurfaceTexture output2 = new SurfaceTexture(2);
        Surface output2Surface = new Surface(output2);

        ArrayList<OutputConfiguration> outConfigs = new ArrayList<OutputConfiguration> ();
        outConfigs.add(new OutputConfiguration(output1Surface));
        outConfigs.add(new OutputConfiguration(output2Surface));
        SessionConfiguration sessionConfig = new SessionConfiguration(
                SessionConfiguration.SESSION_REGULAR, outConfigs,
                new HandlerExecutor(mHandler), mSessionMockListener);
        CaptureRequest.Builder r = mCamera.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);
        sessionConfig.setSessionParameters(r.build());
        mCamera.createCaptureSession(sessionConfig);

        mSession = mSessionMockListener.waitAndGetSession(SESSION_CONFIGURE_TIMEOUT_MS);

        // Try basic prepare

        mSession.prepare(output1Surface);

        verify(mSessionMockListener, timeout(PREPARE_TIMEOUT_MS).times(1))
                .onSurfacePrepared(eq(mSession), eq(output1Surface));

        // Should not complain if preparing already prepared stream

        mSession.prepare(output1Surface);

        verify(mSessionMockListener, timeout(PREPARE_TIMEOUT_MS).times(2))
                .onSurfacePrepared(eq(mSession), eq(output1Surface));

        // Check surface not included in session

        SurfaceTexture output3 = new SurfaceTexture(3);
        Surface output3Surface = new Surface(output3);
        try {
            mSession.prepare(output3Surface);
            // Legacy camera prepare always succeed
            if (mStaticInfo.isHardwareLevelAtLeastLimited()) {
                fail(""Preparing surface not part of session must throw IllegalArgumentException"");
            }
        } catch (IllegalArgumentException e) {
            // expected
        }

        // Ensure second prepare also works

        mSession.prepare(output2Surface);

        verify(mSessionMockListener, timeout(PREPARE_TIMEOUT_MS).times(1))
                .onSurfacePrepared(eq(mSession), eq(output2Surface));

        // Use output1

        r = mCamera.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);
        r.addTarget(output1Surface);

        mSession.capture(r.build(), null, null);

        try {
            mSession.prepare(output1Surface);
            // Legacy camera prepare always succeed
            if (mStaticInfo.isHardwareLevelAtLeastLimited()) {
                fail(""Preparing already-used surface must throw IllegalArgumentException"");
            }
        } catch (IllegalArgumentException e) {
            // expected
        }

        // Create new session with outputs 1 and 3, ensure output1Surface still can't be prepared
        // again

        mSessionMockListener = spy(new BlockingSessionCallback());

        ArrayList<Surface> outputSurfaces = new ArrayList<Surface>(
            Arrays.asList(output1Surface, output3Surface));
        mCamera.createCaptureSession(outputSurfaces, mSessionMockListener, mHandler);

        mSession = mSessionMockListener.waitAndGetSession(SESSION_CONFIGURE_TIMEOUT_MS);

        try {
            mSession.prepare(output1Surface);
            // Legacy camera prepare always succeed
            if (mStaticInfo.isHardwareLevelAtLeastLimited()) {
                fail(""Preparing surface used in previous session must throw "" +
                        ""IllegalArgumentException"");
            }
        } catch (IllegalArgumentException e) {
            // expected
        }

        // Use output3, wait for result, then make sure prepare still doesn't work

        r = mCamera.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);
        r.addTarget(output3Surface);

        SimpleCaptureCallback resultListener = new SimpleCaptureCallback();
        mSession.capture(r.build(), resultListener, mHandler);

        resultListener.getCaptureResult(CAPTURE_RESULT_TIMEOUT_MS);

        try {
            mSession.prepare(output3Surface);
            // Legacy camera prepare always succeed
            if (mStaticInfo.isHardwareLevelAtLeastLimited()) {
                fail(""Preparing already-used surface must throw IllegalArgumentException"");
            }
        } catch (IllegalArgumentException e) {
            // expected
        }

        // Create new session with outputs 1 and 2, ensure output2Surface can be prepared again

        mSessionMockListener = spy(new BlockingSessionCallback());

        outputSurfaces = new ArrayList<>(
            Arrays.asList(output1Surface, output2Surface));
        mCamera.createCaptureSession(outputSurfaces, mSessionMockListener, mHandler);

        mSession = mSessionMockListener.waitAndGetSession(SESSION_CONFIGURE_TIMEOUT_MS);

        mSession.prepare(output2Surface);

        verify(mSessionMockListener, timeout(PREPARE_TIMEOUT_MS).times(1))
                .onSurfacePrepared(eq(mSession), eq(output2Surface));

        try {
            mSession.prepare(output1Surface);
            // Legacy camera prepare always succeed
            if (mStaticInfo.isHardwareLevelAtLeastLimited()) {
                fail(""Preparing surface used in previous session must throw "" +
                        ""IllegalArgumentException"");
            }
        } catch (IllegalArgumentException e) {
            // expected
        }

        output1.release();
        output2.release();
        output3.release();
    }

    private void prepareTestForSharedSurfacesByCamera() throws Exception {
        final int PREPARE_TIMEOUT_MS = 10000;

        mSessionMockListener = spy(new BlockingSessionCallback());

        SurfaceTexture output1 = new SurfaceTexture(1);
        Surface output1Surface = new Surface(output1);
        SurfaceTexture output2 = new SurfaceTexture(2);
        Surface output2Surface = new Surface(output2);

        List<Surface> outputSurfaces = new ArrayList<>(
            Arrays.asList(output1Surface, output2Surface));
        OutputConfiguration surfaceSharedConfig = new OutputConfiguration(
            OutputConfiguration.SURFACE_GROUP_ID_NONE, output1Surface);
        surfaceSharedConfig.enableSurfaceSharing();
        surfaceSharedConfig.addSurface(output2Surface);

        List<OutputConfiguration> outputConfigurations = new ArrayList<>();
        outputConfigurations.add(surfaceSharedConfig);
        mCamera.createCaptureSessionByOutputConfigurations(
                outputConfigurations, mSessionMockListener, mHandler);

        mSession = mSessionMockListener.waitAndGetSession(SESSION_CONFIGURE_TIMEOUT_MS);

        // Try prepare on output1Surface
        mSession.prepare(output1Surface);

        verify(mSessionMockListener, timeout(PREPARE_TIMEOUT_MS).times(1))
                .onSurfacePrepared(eq(mSession), eq(output1Surface));
        verify(mSessionMockListener, timeout(PREPARE_TIMEOUT_MS).times(1))
                .onSurfacePrepared(eq(mSession), eq(output2Surface));

        // Try prepare on output2Surface
        mSession.prepare(output2Surface);

        verify(mSessionMockListener, timeout(PREPARE_TIMEOUT_MS).times(2))
                .onSurfacePrepared(eq(mSession), eq(output1Surface));
        verify(mSessionMockListener, timeout(PREPARE_TIMEOUT_MS).times(2))
                .onSurfacePrepared(eq(mSession), eq(output2Surface));

        // Try prepare on output1Surface again
        mSession.prepare(output1Surface);

        verify(mSessionMockListener, timeout(PREPARE_TIMEOUT_MS).times(3))
                .onSurfacePrepared(eq(mSession), eq(output1Surface));
        verify(mSessionMockListener, timeout(PREPARE_TIMEOUT_MS).times(3))
                .onSurfacePrepared(eq(mSession), eq(output2Surface));
    }

    private void invalidRequestCaptureTestByCamera() throws Exception {
        if (VERBOSE) Log.v(TAG, ""invalidRequestCaptureTestByCamera"");

        List<CaptureRequest> emptyRequests = new ArrayList<CaptureRequest>();
        CaptureRequest.Builder requestBuilder =
                mCamera.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);
        CaptureRequest unConfiguredRequest = requestBuilder.build();
        List<CaptureRequest> unConfiguredRequests = new ArrayList<CaptureRequest>();
        unConfiguredRequests.add(unConfiguredRequest);

        try {
            // Test: CameraCaptureSession capture should throw IAE for null request.
            mSession.capture(/*request*/null, /*listener*/null, mHandler);
            mCollector.addMessage(
                    ""Session capture should throw IllegalArgumentException for null request"");
        } catch (IllegalArgumentException e) {
            // Pass.
        }

        try {
            // Test: CameraCaptureSession capture should throw IAE for request
            // without surface configured.
            mSession.capture(unConfiguredRequest, /*listener*/null, mHandler);
            mCollector.addMessage(""Session capture should throw "" +
                    ""IllegalArgumentException for request without surface configured"");
        } catch (IllegalArgumentException e) {
            // Pass.
        }

        try {
            // Test: CameraCaptureSession setRepeatingRequest should throw IAE for null request.
            mSession.setRepeatingRequest(/*request*/null, /*listener*/null, mHandler);
            mCollector.addMessage(""Session setRepeatingRequest should throw "" +
                    ""IllegalArgumentException for null request"");
        } catch (IllegalArgumentException e) {
            // Pass.
        }

        try {
            // Test: CameraCaptureSession setRepeatingRequest should throw IAE for for request
            // without surface configured.
            mSession.setRepeatingRequest(unConfiguredRequest, /*listener*/null, mHandler);
            mCollector.addMessage(""Capture zero burst should throw IllegalArgumentException "" +
                    ""for request without surface configured"");
        } catch (IllegalArgumentException e) {
            // Pass.
        }

        try {
            // Test: CameraCaptureSession captureBurst should throw IAE for null request list.
            mSession.captureBurst(/*requests*/null, /*listener*/null, mHandler);
            mCollector.addMessage(""Session captureBurst should throw "" +
                    ""IllegalArgumentException for null request list"");
        } catch (IllegalArgumentException e) {
            // Pass.
        }

        try {
            // Test: CameraCaptureSession captureBurst should throw IAE for empty request list.
            mSession.captureBurst(emptyRequests, /*listener*/null, mHandler);
            mCollector.addMessage(""Session captureBurst should throw "" +
                    "" IllegalArgumentException for empty request list"");
        } catch (IllegalArgumentException e) {
            // Pass.
        }

        try {
            // Test: CameraCaptureSession captureBurst should throw IAE for request
            // without surface configured.
            mSession.captureBurst(unConfiguredRequests, /*listener*/null, mHandler);
            fail(""Session captureBurst should throw IllegalArgumentException "" +
                    ""for null request list"");
        } catch (IllegalArgumentException e) {
            // Pass.
        }

        try {
            // Test: CameraCaptureSession setRepeatingBurst should throw IAE for null request list.
            mSession.setRepeatingBurst(/*requests*/null, /*listener*/null, mHandler);
            mCollector.addMessage(""Session setRepeatingBurst should throw "" +
                    ""IllegalArgumentException for null request list"");
        } catch (IllegalArgumentException e) {
            // Pass.
        }

        try {
            // Test: CameraCaptureSession setRepeatingBurst should throw IAE for empty request list.
            mSession.setRepeatingBurst(emptyRequests, /*listener*/null, mHandler);
            mCollector.addMessage(""Session setRepeatingBurst should throw "" +
                    ""IllegalArgumentException for empty request list"");
        } catch (IllegalArgumentException e) {
            // Pass.
        }

        try {
            // Test: CameraCaptureSession setRepeatingBurst should throw IAE for request
            // without surface configured.
            mSession.setRepeatingBurst(unConfiguredRequests, /*listener*/null, mHandler);
            mCollector.addMessage(""Session setRepeatingBurst should throw "" +
                    ""IllegalArgumentException for request without surface configured"");
        } catch (IllegalArgumentException e) {
            // Pass.
        }
    }

    private class IsCaptureResultNotEmpty
            implements ArgumentMatcher<TotalCaptureResult> {
        @Override
        public boolean matches(TotalCaptureResult result) {
            /**
             * Do the simple verification here. Only verify the timestamp for now.
             * TODO: verify more required capture result metadata fields.
             */
            Long timeStamp = result.get(CaptureResult.SENSOR_TIMESTAMP);
            if (timeStamp != null && timeStamp.longValue() > 0L) {
                return true;
            }
            return false;
        }
    }

    /**
     * Run capture test with different test configurations.
     *
     * @param burst If the test uses {@link CameraCaptureSession#captureBurst} or
     * {@link CameraCaptureSession#setRepeatingBurst} to capture the burst.
     * @param repeating If the test uses {@link CameraCaptureSession#setRepeatingBurst} or
     * {@link CameraCaptureSession#setRepeatingRequest} for repeating capture.
     * @param abort If the test uses {@link CameraCaptureSession#abortCaptures} to stop the
     * repeating capture.  It has no effect if repeating is false.
     * @param useExecutor If the test uses {@link java.util.concurrent.Executor} instead of
     * {@link android.os.Handler} for callback invocation.
     */
    private void runCaptureTest(boolean burst, boolean repeating, boolean abort,
            boolean useExecutor) throws Exception {
        for (int i = 0; i < mCameraIdsUnderTest.length; i++) {
            try {
                openDevice(mCameraIdsUnderTest[i], mCameraMockListener);
                waitForDeviceState(STATE_OPENED, CAMERA_OPEN_TIMEOUT_MS);

                prepareCapture();

                if (!burst) {
                    // Test: that a single capture of each template type succeeds.
                    for (int j = 0; j < sTemplates.length; j++) {
                        // Skip video snapshots for LEGACY mode
                        if (mStaticInfo.isHardwareLevelLegacy() &&
                                sTemplates[j] == CameraDevice.TEMPLATE_VIDEO_SNAPSHOT) {
                            continue;
                        }
                        // Skip non-PREVIEW templates for non-color output
                        if (!mStaticInfo.isColorOutputSupported() &&
                                sTemplates[j] != CameraDevice.TEMPLATE_PREVIEW) {
                            continue;
                        }

                        captureSingleShot(mCameraIdsUnderTest[i], sTemplates[j], repeating, abort,
                                useExecutor);
                    }
                }
                else {
                    // Test: burst of one shot
                    captureBurstShot(mCameraIdsUnderTest[i], sTemplates, 1, repeating, abort, useExecutor);

                    int template = mStaticInfo.isColorOutputSupported() ?
                        CameraDevice.TEMPLATE_STILL_CAPTURE :
                        CameraDevice.TEMPLATE_PREVIEW;
                    int[] templates = new int[] {
                        template,
                        template,
                        template,
                        template,
                        template
                    };

                    // Test: burst of 5 shots of the same template type
                    captureBurstShot(mCameraIdsUnderTest[i], templates, templates.length, repeating, abort,
                            useExecutor);

                    if (mStaticInfo.isColorOutputSupported()) {
                        // Test: burst of 6 shots of different template types
                        captureBurstShot(mCameraIdsUnderTest[i], sTemplates, sTemplates.length, repeating,
                                abort, useExecutor);
                    }
                }
                verify(mCameraMockListener, never())
                        .onError(
                                any(CameraDevice.class),
                                anyInt());
            } catch (Exception e) {
                mCollector.addError(e);
            } finally {
                try {
                    closeSession();
                } catch (Exception e) {
                    mCollector.addError(e);
                }finally {
                    closeDevice(mCameraIdsUnderTest[i], mCameraMockListener);
                }
            }
        }
    }

    private void captureSingleShot(
            String id,
            int template,
            boolean repeating, boolean abort, boolean useExecutor) throws Exception {

        assertEquals(""Bad initial state for preparing to capture"",
                mLatestSessionState, SESSION_READY);

        final Executor executor = useExecutor ? new HandlerExecutor(mHandler) : null;
        CaptureRequest.Builder requestBuilder = mCamera.createCaptureRequest(template);
        assertNotNull(""Failed to create capture request"", requestBuilder);
        requestBuilder.addTarget(mReaderSurface);
        CameraCaptureSession.CaptureCallback mockCaptureCallback =
                mock(CameraCaptureSession.CaptureCallback.class);

        if (VERBOSE) {
            Log.v(TAG, String.format(""Capturing shot for device %s, template %d"",
                    id, template));
        }

        if (executor != null) {
            startCapture(requestBuilder.build(), repeating, mockCaptureCallback, executor);
        } else {
            startCapture(requestBuilder.build(), repeating, mockCaptureCallback, mHandler);
        }
        waitForSessionState(SESSION_ACTIVE, SESSION_ACTIVE_TIMEOUT_MS);

        int expectedCaptureResultCount = repeating ? REPEATING_CAPTURE_EXPECTED_RESULT_COUNT : 1;
        verifyCaptureResults(mockCaptureCallback, expectedCaptureResultCount);

        if (repeating) {
            if (abort) {
                mSession.abortCaptures();
                // Have to make sure abort and new requests aren't interleave together.
                waitForSessionState(SESSION_READY, SESSION_READY_TIMEOUT_MS);

                // Capture a single capture, and verify the result.
                SimpleCaptureCallback resultCallback = new SimpleCaptureCallback();
                CaptureRequest singleRequest = requestBuilder.build();
                if (executor != null) {
                    mSession.captureSingleRequest(singleRequest, executor, resultCallback);
                } else {
                    mSession.capture(singleRequest, resultCallback, mHandler);
                }
                resultCallback.getCaptureResultForRequest(singleRequest, CAPTURE_RESULT_TIMEOUT_MS);

                // Resume the repeating, and verify that results are returned.
                if (executor != null) {
                    mSession.setSingleRepeatingRequest(singleRequest, executor, resultCallback);
                } else {
                    mSession.setRepeatingRequest(singleRequest, resultCallback, mHandler);
                }
                for (int i = 0; i < REPEATING_CAPTURE_EXPECTED_RESULT_COUNT; i++) {
                    resultCallback.getCaptureResult(CAPTURE_RESULT_TIMEOUT_MS);
                }
            }
            mSession.stopRepeating();
        }
        waitForSessionState(SESSION_READY, SESSION_READY_TIMEOUT_MS);
    }

    private void captureBurstShot(
            String id,
            int[] templates,
            int len,
            boolean repeating,
            boolean abort, boolean useExecutor) throws Exception {

        assertEquals(""Bad initial state for preparing to capture"",
                mLatestSessionState, SESSION_READY);

        assertTrue(""Invalid args to capture function"", len <= templates.length);
        List<CaptureRequest> requests = new ArrayList<CaptureRequest>();
        List<CaptureRequest> postAbortRequests = new ArrayList<CaptureRequest>();
        final Executor executor = useExecutor ? new HandlerExecutor(mHandler) : null;
        for (int i = 0; i < len; i++) {
            // Skip video snapshots for LEGACY mode
            if (mStaticInfo.isHardwareLevelLegacy() &&
                    templates[i] == CameraDevice.TEMPLATE_VIDEO_SNAPSHOT) {
                continue;
            }
            // Skip non-PREVIEW templates for non-color outpu
            if (!mStaticInfo.isColorOutputSupported() &&
                    templates[i] != CameraDevice.TEMPLATE_PREVIEW) {
                continue;
            }

            CaptureRequest.Builder requestBuilder = mCamera.createCaptureRequest(templates[i]);
            assertNotNull(""Failed to create capture request"", requestBuilder);
            requestBuilder.addTarget(mReaderSurface);
            requests.add(requestBuilder.build());
            if (abort) {
                postAbortRequests.add(requestBuilder.build());
            }
        }
        CameraCaptureSession.CaptureCallback mockCaptureCallback =
                mock(CameraCaptureSession.CaptureCallback.class);

        if (VERBOSE) {
            Log.v(TAG, String.format(""Capturing burst shot for device %s"", id));
        }

        if (!repeating) {
            if (executor != null) {
                mSession.captureBurstRequests(requests, executor, mockCaptureCallback);
            } else {
                mSession.captureBurst(requests, mockCaptureCallback, mHandler);
            }
        }
        else {
            if (executor != null) {
                mSession.setRepeatingBurstRequests(requests, executor, mockCaptureCallback);
            } else {
                mSession.setRepeatingBurst(requests, mockCaptureCallback, mHandler);
            }
        }
        waitForSessionState(SESSION_ACTIVE, SESSION_READY_TIMEOUT_MS);

        int expectedResultCount = requests.size();
        if (repeating) {
            expectedResultCount *= REPEATING_CAPTURE_EXPECTED_RESULT_COUNT;
        }

        verifyCaptureResults(mockCaptureCallback, expectedResultCount);

        if (repeating) {
            if (abort) {
                mSession.abortCaptures();
                // Have to make sure abort and new requests aren't interleave together.
                waitForSessionState(SESSION_READY, SESSION_READY_TIMEOUT_MS);

                // Capture a burst of captures, and verify the results.
                SimpleCaptureCallback resultCallback = new SimpleCaptureCallback();
                if (executor != null) {
                    mSession.captureBurstRequests(postAbortRequests, executor, resultCallback);
                } else {
                    mSession.captureBurst(postAbortRequests, resultCallback, mHandler);
                }
                // Verify that the results are returned.
                for (int i = 0; i < postAbortRequests.size(); i++) {
                    resultCallback.getCaptureResultForRequest(
                            postAbortRequests.get(i), CAPTURE_RESULT_TIMEOUT_MS);
                }

                // Resume the repeating, and verify that results are returned.
                if (executor != null) {
                    mSession.setRepeatingBurstRequests(requests, executor, resultCallback);
                } else {
                    mSession.setRepeatingBurst(requests, resultCallback, mHandler);
                }
                for (int i = 0; i < REPEATING_CAPTURE_EXPECTED_RESULT_COUNT; i++) {
                    resultCallback.getCaptureResult(CAPTURE_RESULT_TIMEOUT_MS);
                }
            }
            mSession.stopRepeating();
        }
        waitForSessionState(SESSION_READY, SESSION_READY_TIMEOUT_MS);
    }

    /**
     * Precondition: Device must be in known OPENED state (has been waited for).
     *
     * <p>Creates a new capture session and waits until it is in the {@code SESSION_READY} state.
     * </p>
     *
     * <p>Any existing capture session will be closed as a result of calling this.</p>
     * */
    private void prepareCapture() throws Exception {
        if (VERBOSE) Log.v(TAG, ""prepareCapture"");

        assertTrue(""Bad initial state for preparing to capture"",
                mLatestDeviceState == STATE_OPENED);

        if (mSession != null) {
            if (VERBOSE) Log.v(TAG, ""prepareCapture - closing existing session"");
            closeSession();
        }

        // Create a new session listener each time, it's not reusable across cameras
        mSessionMockListener = spy(new BlockingSessionCallback());
        mSessionWaiter = mSessionMockListener.getStateWaiter();

        if (!mStaticInfo.isColorOutputSupported()) {
            createDefaultImageReader(getMaxDepthSize(mCamera.getId(), mCameraManager),
                    ImageFormat.DEPTH16, MAX_NUM_IMAGES, new ImageDropperListener());
        } else {
            createDefaultImageReader(DEFAULT_CAPTURE_SIZE, ImageFormat.YUV_420_888, MAX_NUM_IMAGES,
                    new ImageDropperListener());
        }

        List<Surface> outputSurfaces = new ArrayList<>(Arrays.asList(mReaderSurface));
        mCamera.createCaptureSession(outputSurfaces, mSessionMockListener, mHandler);

        mSession = mSessionMockListener.waitAndGetSession(SESSION_CONFIGURE_TIMEOUT_MS);
        waitForSessionState(SESSION_CONFIGURED, SESSION_CONFIGURE_TIMEOUT_MS);
        waitForSessionState(SESSION_READY, SESSION_READY_TIMEOUT_MS);
    }

    private void waitForDeviceState(int state, long timeoutMs) {
        mCameraMockListener.waitForState(state, timeoutMs);
        mLatestDeviceState = state;
    }

    private void waitForSessionState(int state, long timeoutMs) {
        mSessionWaiter.waitForState(state, timeoutMs);
        mLatestSessionState = state;
    }

    private void verifyCaptureResults(
            CameraCaptureSession.CaptureCallback mockListener,
            int expectResultCount) {
        final int TIMEOUT_PER_RESULT_MS = 2000;
        // Should receive expected number of capture results.
        verify(mockListener,
                timeout(TIMEOUT_PER_RESULT_MS * expectResultCount).atLeast(expectResultCount))
                        .onCaptureCompleted(
                                eq(mSession),
                                isA(CaptureRequest.class),
                                argThat(new IsCaptureResultNotEmpty()));
        // Should not receive any capture failed callbacks.
        verify(mockListener, never())
                        .onCaptureFailed(
                                eq(mSession),
                                isA(CaptureRequest.class),
                                isA(CaptureFailure.class));
        // Should receive expected number of capture shutter calls
        verify(mockListener,
                atLeast(expectResultCount))
                        .onCaptureStarted(
                               eq(mSession),
                               isA(CaptureRequest.class),
                               anyLong(),
                               anyLong());
    }

    private void checkFpsRange(CaptureRequest.Builder request, int template,
            CameraCharacteristics props) {
        CaptureRequest.Key<Range<Integer>> fpsRangeKey = CONTROL_AE_TARGET_FPS_RANGE;
        Range<Integer> fpsRange;
        if ((fpsRange = mCollector.expectKeyValueNotNull(request, fpsRangeKey)) == null) {
            return;
        }

        int minFps = fpsRange.getLower();
        int maxFps = fpsRange.getUpper();
        Range<Integer>[] availableFpsRange = props
                .get(CameraCharacteristics.CONTROL_AE_AVAILABLE_TARGET_FPS_RANGES);
        boolean foundRange = false;
        for (int i = 0; i < availableFpsRange.length; i += 1) {
            if (minFps == availableFpsRange[i].getLower()
                    && maxFps == availableFpsRange[i].getUpper()) {
                foundRange = true;
                break;
            }
        }
        if (!foundRange) {
            mCollector.addMessage(String.format(""Unable to find the fps range (%d, %d)"",
                    minFps, maxFps));
            return;
        }


        if (template != CameraDevice.TEMPLATE_MANUAL &&
                template != CameraDevice.TEMPLATE_STILL_CAPTURE) {
            if (maxFps < MIN_FPS_REQUIRED_FOR_STREAMING) {
                mCollector.addMessage(""Max fps should be at least ""
                        + MIN_FPS_REQUIRED_FOR_STREAMING);
                return;
            }

            // Relax framerate constraints on legacy mode
            if (mStaticInfo.isHardwareLevelAtLeastLimited()) {
                // Need give fixed frame rate for video recording template.
                if (template == CameraDevice.TEMPLATE_RECORD) {
                    if (maxFps != minFps) {
                        mCollector.addMessage(""Video recording frame rate should be fixed"");
                    }
                }
            }
        }
    }

    private void checkAfMode(CaptureRequest.Builder request, int template,
            CameraCharacteristics props) {
        boolean hasFocuser = props.getKeys().contains(CameraCharacteristics.
                LENS_INFO_MINIMUM_FOCUS_DISTANCE) &&
                (props.get(CameraCharacteristics.LENS_INFO_MINIMUM_FOCUS_DISTANCE) > 0f);

        if (!hasFocuser) {
            return;
        }

        int targetAfMode = CaptureRequest.CONTROL_AF_MODE_AUTO;
        int[] availableAfMode = props.get(CameraCharacteristics.CONTROL_AF_AVAILABLE_MODES);
        if (template == CameraDevice.TEMPLATE_PREVIEW ||
                template == CameraDevice.TEMPLATE_STILL_CAPTURE ||
                template == CameraDevice.TEMPLATE_ZERO_SHUTTER_LAG) {
            // Default to CONTINUOUS_PICTURE if it is available, otherwise AUTO.
            for (int i = 0; i < availableAfMode.length; i++) {
                if (availableAfMode[i] == CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE) {
                    targetAfMode = CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE;
                    break;
                }
            }
        } else if (template == CameraDevice.TEMPLATE_RECORD ||
                template == CameraDevice.TEMPLATE_VIDEO_SNAPSHOT) {
            // Default to CONTINUOUS_VIDEO if it is available, otherwise AUTO.
            for (int i = 0; i < availableAfMode.length; i++) {
                if (availableAfMode[i] == CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_VIDEO) {
                    targetAfMode = CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_VIDEO;
                    break;
                }
            }
        } else if (template == CameraDevice.TEMPLATE_MANUAL) {
            targetAfMode = CaptureRequest.CONTROL_AF_MODE_OFF;
        }

        mCollector.expectKeyValueEquals(request, CONTROL_AF_MODE, targetAfMode);
        if (mStaticInfo.areKeysAvailable(CaptureRequest.LENS_FOCUS_DISTANCE)) {
            mCollector.expectKeyValueNotNull(request, LENS_FOCUS_DISTANCE);
        }
    }

    private void checkAntiBandingMode(CaptureRequest.Builder request, int template) {
        if (template == CameraDevice.TEMPLATE_MANUAL) {
            return;
        }

        if (!mStaticInfo.isColorOutputSupported()) return;

        List<Integer> availableAntiBandingModes =
                Arrays.asList(toObject(mStaticInfo.getAeAvailableAntiBandingModesChecked()));

        if (availableAntiBandingModes.contains(CameraMetadata.CONTROL_AE_ANTIBANDING_MODE_AUTO)) {
            mCollector.expectKeyValueEquals(request, CONTROL_AE_ANTIBANDING_MODE,
                    CameraMetadata.CONTROL_AE_ANTIBANDING_MODE_AUTO);
        } else {
            mCollector.expectKeyValueIsIn(request, CONTROL_AE_ANTIBANDING_MODE,
                    CameraMetadata.CONTROL_AE_ANTIBANDING_MODE_50HZ,
                    CameraMetadata.CONTROL_AE_ANTIBANDING_MODE_60HZ);
        }
    }

    /**
     * <p>Check if 3A metering settings are ""up to HAL"" in request template</p>
     *
     * <p>This function doesn't fail the test immediately, it updates the
     * test pass/fail status and appends the failure message to the error collector each key.</p>
     *
     * @param regions The metering rectangles to be checked
     */
    private void checkMeteringRect(MeteringRectangle[] regions) {
        if (regions == null) {
            return;
        }
        mCollector.expectNotEquals(""Number of metering region should not be 0"", 0, regions.length);
        for (int i = 0; i < regions.length; i++) {
            mCollector.expectEquals(""Default metering regions should have all zero weight"",
                    0, regions[i].getMeteringWeight());
        }
    }

    /**
     * <p>Check if the request settings are suitable for a given request template.</p>
     *
     * <p>This function doesn't fail the test immediately, it updates the
     * test pass/fail status and appends the failure message to the error collector each key.</p>
     *
     * @param request The request to be checked.
     * @param template The capture template targeted by this request.
     * @param props The CameraCharacteristics this request is checked against with.
     */
    private void checkRequestForTemplate(CaptureRequest.Builder request, int template,
            CameraCharacteristics props) {
        Integer hwLevel = props.get(CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL);
        boolean isExternalCamera = (hwLevel ==
                CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL_EXTERNAL);

        // 3A settings--AE/AWB/AF.
        Integer maxRegionsAeVal = props.get(CameraCharacteristics.CONTROL_MAX_REGIONS_AE);
        int maxRegionsAe = maxRegionsAeVal != null ? maxRegionsAeVal : 0;
        Integer maxRegionsAwbVal = props.get(CameraCharacteristics.CONTROL_MAX_REGIONS_AWB);
        int maxRegionsAwb = maxRegionsAwbVal != null ? maxRegionsAwbVal : 0;
        Integer maxRegionsAfVal = props.get(CameraCharacteristics.CONTROL_MAX_REGIONS_AF);
        int maxRegionsAf = maxRegionsAfVal != null ? maxRegionsAfVal : 0;

        checkFpsRange(request, template, props);

        checkAfMode(request, template, props);
        checkAntiBandingMode(request, template);

        if (template == CameraDevice.TEMPLATE_MANUAL) {
            mCollector.expectKeyValueEquals(request, CONTROL_MODE, CaptureRequest.CONTROL_MODE_OFF);
            mCollector.expectKeyValueEquals(request, CONTROL_AE_MODE,
                    CaptureRequest.CONTROL_AE_MODE_OFF);
            mCollector.expectKeyValueEquals(request, CONTROL_AWB_MODE,
                    CaptureRequest.CONTROL_AWB_MODE_OFF);
        } else {
            mCollector.expectKeyValueEquals(request, CONTROL_MODE,
                    CaptureRequest.CONTROL_MODE_AUTO);
            if (mStaticInfo.isColorOutputSupported()) {
                mCollector.expectKeyValueEquals(request, CONTROL_AE_MODE,
                        CaptureRequest.CONTROL_AE_MODE_ON);
                mCollector.expectKeyValueEquals(request, CONTROL_AE_EXPOSURE_COMPENSATION, 0);
                mCollector.expectKeyValueEquals(request, CONTROL_AE_PRECAPTURE_TRIGGER,
                        CaptureRequest.CONTROL_AE_PRECAPTURE_TRIGGER_IDLE);
                // if AE lock is not supported, expect the control key to be non-exist or false
                if (mStaticInfo.isAeLockSupported() || request.get(CONTROL_AE_LOCK) != null) {
                    mCollector.expectKeyValueEquals(request, CONTROL_AE_LOCK, false);
                }

                mCollector.expectKeyValueEquals(request, CONTROL_AF_TRIGGER,
                        CaptureRequest.CONTROL_AF_TRIGGER_IDLE);

                mCollector.expectKeyValueEquals(request, CONTROL_AWB_MODE,
                        CaptureRequest.CONTROL_AWB_MODE_AUTO);
                // if AWB lock is not supported, expect the control key to be non-exist or false
                if (mStaticInfo.isAwbLockSupported() || request.get(CONTROL_AWB_LOCK) != null) {
                    mCollector.expectKeyValueEquals(request, CONTROL_AWB_LOCK, false);
                }

                // Check 3A regions.
                if (VERBOSE) {
                    Log.v(TAG, String.format(""maxRegions is: {AE: %s, AWB: %s, AF: %s}"",
                                    maxRegionsAe, maxRegionsAwb, maxRegionsAf));
                }
                if (maxRegionsAe > 0) {
                    mCollector.expectKeyValueNotNull(request, CONTROL_AE_REGIONS);
                    MeteringRectangle[] aeRegions = request.get(CONTROL_AE_REGIONS);
                    checkMeteringRect(aeRegions);
                }
                if (maxRegionsAwb > 0) {
                    mCollector.expectKeyValueNotNull(request, CONTROL_AWB_REGIONS);
                    MeteringRectangle[] awbRegions = request.get(CONTROL_AWB_REGIONS);
                    checkMeteringRect(awbRegions);
                }
                if (maxRegionsAf > 0) {
                    mCollector.expectKeyValueNotNull(request, CONTROL_AF_REGIONS);
                    MeteringRectangle[] afRegions = request.get(CONTROL_AF_REGIONS);
                    checkMeteringRect(afRegions);
                }
            }
        }

        // Sensor settings.

        mCollector.expectEquals(""Lens aperture must be present in request if available apertures "" +
                        ""are present in metadata, and vice-versa."",
                mStaticInfo.areKeysAvailable(CameraCharacteristics.LENS_INFO_AVAILABLE_APERTURES),
                mStaticInfo.areKeysAvailable(CaptureRequest.LENS_APERTURE));
        if (mStaticInfo.areKeysAvailable(CameraCharacteristics.LENS_INFO_AVAILABLE_APERTURES)) {
            float[] availableApertures =
                    props.get(CameraCharacteristics.LENS_INFO_AVAILABLE_APERTURES);
            if (availableApertures.length > 1) {
                mCollector.expectKeyValueNotNull(request, LENS_APERTURE);
            }
        }

        mCollector.expectEquals(""Lens filter density must be present in request if available "" +
                        ""filter densities are present in metadata, and vice-versa."",
                mStaticInfo.areKeysAvailable(CameraCharacteristics.
                        LENS_INFO_AVAILABLE_FILTER_DENSITIES),
                mStaticInfo.areKeysAvailable(CaptureRequest.LENS_FILTER_DENSITY));
        if (mStaticInfo.areKeysAvailable(CameraCharacteristics.
                LENS_INFO_AVAILABLE_FILTER_DENSITIES)) {
            float[] availableFilters =
                    props.get(CameraCharacteristics.LENS_INFO_AVAILABLE_FILTER_DENSITIES);
            if (availableFilters.length > 1) {
                mCollector.expectKeyValueNotNull(request, LENS_FILTER_DENSITY);
            }
        }


        if (!isExternalCamera) {
            float[] availableFocalLen =
                    props.get(CameraCharacteristics.LENS_INFO_AVAILABLE_FOCAL_LENGTHS);
            if (availableFocalLen.length > 1) {
                mCollector.expectKeyValueNotNull(request, LENS_FOCAL_LENGTH);
            }
        }


        mCollector.expectEquals(""Lens optical stabilization must be present in request if "" +
                        ""available optical stabilizations are present in metadata, and vice-versa."",
                mStaticInfo.areKeysAvailable(CameraCharacteristics.
                        LENS_INFO_AVAILABLE_OPTICAL_STABILIZATION),
                mStaticInfo.areKeysAvailable(CaptureRequest.LENS_OPTICAL_STABILIZATION_MODE));
        if (mStaticInfo.areKeysAvailable(CameraCharacteristics.
                LENS_INFO_AVAILABLE_OPTICAL_STABILIZATION)) {
            int[] availableOIS =
                    props.get(CameraCharacteristics.LENS_INFO_AVAILABLE_OPTICAL_STABILIZATION);
            if (availableOIS.length > 1) {
                mCollector.expectKeyValueNotNull(request, LENS_OPTICAL_STABILIZATION_MODE);
            }
        }

        if (mStaticInfo.areKeysAvailable(SENSOR_TEST_PATTERN_MODE)) {
            mCollector.expectKeyValueEquals(request, SENSOR_TEST_PATTERN_MODE,
                    CaptureRequest.SENSOR_TEST_PATTERN_MODE_OFF);
        }

        if (mStaticInfo.areKeysAvailable(BLACK_LEVEL_LOCK)) {
            mCollector.expectKeyValueEquals(request, BLACK_LEVEL_LOCK, false);
        }

        if (mStaticInfo.areKeysAvailable(SENSOR_FRAME_DURATION)) {
            mCollector.expectKeyValueNotNull(request, SENSOR_FRAME_DURATION);
        }

        if (mStaticInfo.areKeysAvailable(SENSOR_EXPOSURE_TIME)) {
            mCollector.expectKeyValueNotNull(request, SENSOR_EXPOSURE_TIME);
        }

        if (mStaticInfo.areKeysAvailable(SENSOR_SENSITIVITY)) {
            mCollector.expectKeyValueNotNull(request, SENSOR_SENSITIVITY);
        }

        // ISP-processing settings.
        if (mStaticInfo.isColorOutputSupported()) {
            mCollector.expectKeyValueEquals(
                    request, STATISTICS_FACE_DETECT_MODE,
                    CaptureRequest.STATISTICS_FACE_DETECT_MODE_OFF);
            mCollector.expectKeyValueEquals(request, FLASH_MODE, CaptureRequest.FLASH_MODE_OFF);
        }

        List<Integer> availableCaps = mStaticInfo.getAvailableCapabilitiesChecked();
        if (mStaticInfo.areKeysAvailable(STATISTICS_LENS_SHADING_MAP_MODE)) {
            // If the device doesn't support RAW, all template should have OFF as default.
            if (!availableCaps.contains(REQUEST_AVAILABLE_CAPABILITIES_RAW)) {
                mCollector.expectKeyValueEquals(
                        request, STATISTICS_LENS_SHADING_MAP_MODE,
                        CaptureRequest.STATISTICS_LENS_SHADING_MAP_MODE_OFF);
            }
        }

        boolean supportReprocessing =
                availableCaps.contains(REQUEST_AVAILABLE_CAPABILITIES_YUV_REPROCESSING) ||
                availableCaps.contains(REQUEST_AVAILABLE_CAPABILITIES_PRIVATE_REPROCESSING);


        if (template == CameraDevice.TEMPLATE_STILL_CAPTURE) {

            // Ok with either FAST or HIGH_QUALITY
            if (mStaticInfo.areKeysAvailable(COLOR_CORRECTION_MODE)) {
                mCollector.expectKeyValueNotEquals(
                        request, COLOR_CORRECTION_MODE,
                        CaptureRequest.COLOR_CORRECTION_MODE_TRANSFORM_MATRIX);
            }

            // Edge enhancement, noise reduction and aberration correction modes.
            mCollector.expectEquals(""Edge mode must be present in request if "" +
                            ""available edge modes are present in metadata, and vice-versa."",
                    mStaticInfo.areKeysAvailable(CameraCharacteristics.
                            EDGE_AVAILABLE_EDGE_MODES),
                    mStaticInfo.areKeysAvailable(CaptureRequest.EDGE_MODE));
            if (mStaticInfo.areKeysAvailable(EDGE_MODE)) {
                List<Integer> availableEdgeModes =
                        Arrays.asList(toObject(mStaticInfo.getAvailableEdgeModesChecked()));
                // Don't need check fast as fast or high quality must be both present or both not.
                if (availableEdgeModes.contains(CaptureRequest.EDGE_MODE_HIGH_QUALITY)) {
                    mCollector.expectKeyValueEquals(request, EDGE_MODE,
                            CaptureRequest.EDGE_MODE_HIGH_QUALITY);
                } else {
                    mCollector.expectKeyValueEquals(request, EDGE_MODE,
                            CaptureRequest.EDGE_MODE_OFF);
                }
            }
            if (mStaticInfo.areKeysAvailable(SHADING_MODE)) {
                List<Integer> availableShadingModes =
                        Arrays.asList(toObject(mStaticInfo.getAvailableShadingModesChecked()));
                mCollector.expectKeyValueEquals(request, SHADING_MODE,
                        CaptureRequest.SHADING_MODE_HIGH_QUALITY);
            }

            mCollector.expectEquals(""Noise reduction mode must be present in request if "" +
                            ""available noise reductions are present in metadata, and vice-versa."",
                    mStaticInfo.areKeysAvailable(CameraCharacteristics.
                            NOISE_REDUCTION_AVAILABLE_NOISE_REDUCTION_MODES),
                    mStaticInfo.areKeysAvailable(CaptureRequest.NOISE_REDUCTION_MODE));
            if (mStaticInfo.areKeysAvailable(
                    CameraCharacteristics.NOISE_REDUCTION_AVAILABLE_NOISE_REDUCTION_MODES)) {
                List<Integer> availableNoiseReductionModes =
                        Arrays.asList(toObject(mStaticInfo.getAvailableNoiseReductionModesChecked()));
                // Don't need check fast as fast or high quality must be both present or both not.
                if (availableNoiseReductionModes
                        .contains(CaptureRequest.NOISE_REDUCTION_MODE_HIGH_QUALITY)) {
                    mCollector.expectKeyValueEquals(
                            request, NOISE_REDUCTION_MODE,
                            CaptureRequest.NOISE_REDUCTION_MODE_HIGH_QUALITY);
                } else {
                    mCollector.expectKeyValueEquals(
                            request, NOISE_REDUCTION_MODE, CaptureRequest.NOISE_REDUCTION_MODE_OFF);
                }
            }

            mCollector.expectEquals(""Hot pixel mode must be present in request if "" +
                            ""available hot pixel modes are present in metadata, and vice-versa."",
                    mStaticInfo.areKeysAvailable(CameraCharacteristics.
                            HOT_PIXEL_AVAILABLE_HOT_PIXEL_MODES),
                    mStaticInfo.areKeysAvailable(CaptureRequest.HOT_PIXEL_MODE));

            if (mStaticInfo.areKeysAvailable(HOT_PIXEL_MODE)) {
                List<Integer> availableHotPixelModes =
                        Arrays.asList(toObject(
                                mStaticInfo.getAvailableHotPixelModesChecked()));
                if (availableHotPixelModes
                        .contains(CaptureRequest.HOT_PIXEL_MODE_HIGH_QUALITY)) {
                    mCollector.expectKeyValueEquals(
                            request, HOT_PIXEL_MODE,
                            CaptureRequest.HOT_PIXEL_MODE_HIGH_QUALITY);
                } else {
                    mCollector.expectKeyValueEquals(
                            request, HOT_PIXEL_MODE, CaptureRequest.HOT_PIXEL_MODE_OFF);
                }
            }

            boolean supportAvailableAberrationModes = mStaticInfo.areKeysAvailable(
                    CameraCharacteristics.COLOR_CORRECTION_AVAILABLE_ABERRATION_MODES);
            boolean supportAberrationRequestKey = mStaticInfo.areKeysAvailable(
                    CaptureRequest.COLOR_CORRECTION_ABERRATION_MODE);
            mCollector.expectEquals(""Aberration correction mode must be present in request if "" +
                    ""available aberration correction reductions are present in metadata, and ""
                    + ""vice-versa."", supportAvailableAberrationModes, supportAberrationRequestKey);
            if (supportAberrationRequestKey) {
                List<Integer> availableAberrationModes = Arrays.asList(
                        toObject(mStaticInfo.getAvailableColorAberrationModesChecked()));
                // Don't need check fast as fast or high quality must be both present or both not.
                if (availableAberrationModes
                        .contains(CaptureRequest.COLOR_CORRECTION_ABERRATION_MODE_HIGH_QUALITY)) {
                    mCollector.expectKeyValueEquals(
                            request, COLOR_CORRECTION_ABERRATION_MODE,
                            CaptureRequest.COLOR_CORRECTION_ABERRATION_MODE_HIGH_QUALITY);
                } else {
                    mCollector.expectKeyValueEquals(
                            request, COLOR_CORRECTION_ABERRATION_MODE,
                            CaptureRequest.COLOR_CORRECTION_ABERRATION_MODE_OFF);
                }
            }
        } else if (template == CameraDevice.TEMPLATE_ZERO_SHUTTER_LAG && supportReprocessing) {
            mCollector.expectKeyValueEquals(request, EDGE_MODE,
                    CaptureRequest.EDGE_MODE_ZERO_SHUTTER_LAG);
            mCollector.expectKeyValueEquals(request, NOISE_REDUCTION_MODE,
                    CaptureRequest.NOISE_REDUCTION_MODE_ZERO_SHUTTER_LAG);
        } else if (template == CameraDevice.TEMPLATE_PREVIEW ||
                template == CameraDevice.TEMPLATE_RECORD) {

            // Ok with either FAST or HIGH_QUALITY
            if (mStaticInfo.areKeysAvailable(COLOR_CORRECTION_MODE)) {
                mCollector.expectKeyValueNotEquals(
                        request, COLOR_CORRECTION_MODE,
                        CaptureRequest.COLOR_CORRECTION_MODE_TRANSFORM_MATRIX);
            }

            if (mStaticInfo.areKeysAvailable(EDGE_MODE)) {
                List<Integer> availableEdgeModes =
                        Arrays.asList(toObject(mStaticInfo.getAvailableEdgeModesChecked()));
                if (availableEdgeModes.contains(CaptureRequest.EDGE_MODE_FAST)) {
                    mCollector.expectKeyValueEquals(request, EDGE_MODE,
                            CaptureRequest.EDGE_MODE_FAST);
                } else {
                    mCollector.expectKeyValueEquals(request, EDGE_MODE,
                            CaptureRequest.EDGE_MODE_OFF);
                }
            }

            if (mStaticInfo.areKeysAvailable(SHADING_MODE)) {
                List<Integer> availableShadingModes =
                        Arrays.asList(toObject(mStaticInfo.getAvailableShadingModesChecked()));
                mCollector.expectKeyValueEquals(request, SHADING_MODE,
                        CaptureRequest.SHADING_MODE_FAST);
            }

            if (mStaticInfo.areKeysAvailable(NOISE_REDUCTION_MODE)) {
                List<Integer> availableNoiseReductionModes =
                        Arrays.asList(toObject(
                                mStaticInfo.getAvailableNoiseReductionModesChecked()));
                if (availableNoiseReductionModes
                        .contains(CaptureRequest.NOISE_REDUCTION_MODE_FAST)) {
                    mCollector.expectKeyValueEquals(
                            request, NOISE_REDUCTION_MODE,
                            CaptureRequest.NOISE_REDUCTION_MODE_FAST);
                } else {
                    mCollector.expectKeyValueEquals(
                            request, NOISE_REDUCTION_MODE, CaptureRequest.NOISE_REDUCTION_MODE_OFF);
                }
            }

            if (mStaticInfo.areKeysAvailable(HOT_PIXEL_MODE)) {
                List<Integer> availableHotPixelModes =
                        Arrays.asList(toObject(
                                mStaticInfo.getAvailableHotPixelModesChecked()));
                if (availableHotPixelModes
                        .contains(CaptureRequest.HOT_PIXEL_MODE_FAST)) {
                    mCollector.expectKeyValueEquals(
                            request, HOT_PIXEL_MODE,
                            CaptureRequest.HOT_PIXEL_MODE_FAST);
                } else {
                    mCollector.expectKeyValueEquals(
                            request, HOT_PIXEL_MODE, CaptureRequest.HOT_PIXEL_MODE_OFF);
                }
            }

            if (mStaticInfo.areKeysAvailable(COLOR_CORRECTION_ABERRATION_MODE)) {
                List<Integer> availableAberrationModes = Arrays.asList(
                        toObject(mStaticInfo.getAvailableColorAberrationModesChecked()));
                if (availableAberrationModes
                        .contains(CaptureRequest.COLOR_CORRECTION_ABERRATION_MODE_FAST)) {
                    mCollector.expectKeyValueEquals(
                            request, COLOR_CORRECTION_ABERRATION_MODE,
                            CaptureRequest.COLOR_CORRECTION_ABERRATION_MODE_FAST);
                } else {
                    mCollector.expectKeyValueEquals(
                            request, COLOR_CORRECTION_ABERRATION_MODE,
                            CaptureRequest.COLOR_CORRECTION_ABERRATION_MODE_OFF);
                }
            }
        } else {
            if (mStaticInfo.areKeysAvailable(EDGE_MODE)) {
                mCollector.expectKeyValueNotNull(request, EDGE_MODE);
            }

            if (mStaticInfo.areKeysAvailable(NOISE_REDUCTION_MODE)) {
                mCollector.expectKeyValueNotNull(request, NOISE_REDUCTION_MODE);
            }

            if (mStaticInfo.areKeysAvailable(COLOR_CORRECTION_ABERRATION_MODE)) {
                mCollector.expectKeyValueNotNull(request, COLOR_CORRECTION_ABERRATION_MODE);
            }
        }

        // Tone map and lens shading modes.
        if (template == CameraDevice.TEMPLATE_STILL_CAPTURE) {
            mCollector.expectEquals(""Tonemap mode must be present in request if "" +
                            ""available tonemap modes are present in metadata, and vice-versa."",
                    mStaticInfo.areKeysAvailable(CameraCharacteristics.
                            TONEMAP_AVAILABLE_TONE_MAP_MODES),
                    mStaticInfo.areKeysAvailable(CaptureRequest.TONEMAP_MODE));
            if (mStaticInfo.areKeysAvailable(
                    CameraCharacteristics.TONEMAP_AVAILABLE_TONE_MAP_MODES)) {
                List<Integer> availableToneMapModes =
                        Arrays.asList(toObject(mStaticInfo.getAvailableToneMapModesChecked()));
                if (availableToneMapModes.contains(CaptureRequest.TONEMAP_MODE_HIGH_QUALITY)) {
                    mCollector.expectKeyValueEquals(request, TONEMAP_MODE,
                            CaptureRequest.TONEMAP_MODE_HIGH_QUALITY);
                } else {
                    mCollector.expectKeyValueEquals(request, TONEMAP_MODE,
                            CaptureRequest.TONEMAP_MODE_FAST);
                }
            }

            // Still capture template should have android.statistics.lensShadingMapMode ON when
            // RAW capability is supported.
            if (mStaticInfo.areKeysAvailable(STATISTICS_LENS_SHADING_MAP_MODE) &&
                    availableCaps.contains(REQUEST_AVAILABLE_CAPABILITIES_RAW)) {
                    mCollector.expectKeyValueEquals(request, STATISTICS_LENS_SHADING_MAP_MODE,
                            STATISTICS_LENS_SHADING_MAP_MODE_ON);
            }
        } else {
            if (mStaticInfo.areKeysAvailable(TONEMAP_MODE)) {
                mCollector.expectKeyValueNotEquals(request, TONEMAP_MODE,
                        CaptureRequest.TONEMAP_MODE_CONTRAST_CURVE);
                mCollector.expectKeyValueNotEquals(request, TONEMAP_MODE,
                        CaptureRequest.TONEMAP_MODE_GAMMA_VALUE);
                mCollector.expectKeyValueNotEquals(request, TONEMAP_MODE,
                        CaptureRequest.TONEMAP_MODE_PRESET_CURVE);
            }
            if (mStaticInfo.areKeysAvailable(STATISTICS_LENS_SHADING_MAP_MODE)) {
                mCollector.expectKeyValueEquals(request, STATISTICS_LENS_SHADING_MAP_MODE,
                        CaptureRequest.STATISTICS_LENS_SHADING_MAP_MODE_OFF);
            }
            if (mStaticInfo.areKeysAvailable(STATISTICS_HOT_PIXEL_MAP_MODE)) {
                mCollector.expectKeyValueEquals(request, STATISTICS_HOT_PIXEL_MAP_MODE,
                        false);
            }
        }

        // Enable ZSL
        if (template != CameraDevice.TEMPLATE_STILL_CAPTURE) {
            if (mStaticInfo.areKeysAvailable(CONTROL_ENABLE_ZSL)) {
                    mCollector.expectKeyValueEquals(request, CONTROL_ENABLE_ZSL, false);
            }
        }

        int[] outputFormats = mStaticInfo.getAvailableFormats(
                StaticMetadata.StreamDirection.Output);
        boolean supportRaw = false;
        for (int format : outputFormats) {
            if (format == ImageFormat.RAW_SENSOR || format == ImageFormat.RAW10 ||
                    format == ImageFormat.RAW12 || format == ImageFormat.RAW_PRIVATE) {
                supportRaw = true;
                break;
            }
        }
        if (supportRaw) {
            mCollector.expectKeyValueEquals(request,
                    CONTROL_POST_RAW_SENSITIVITY_BOOST,
                    DEFAULT_POST_RAW_SENSITIVITY_BOOST);
        }

        switch(template) {
            case CameraDevice.TEMPLATE_PREVIEW:
                mCollector.expectKeyValueEquals(request, CONTROL_CAPTURE_INTENT,
                        CameraCharacteristics.CONTROL_CAPTURE_INTENT_PREVIEW);
                break;
            case CameraDevice.TEMPLATE_STILL_CAPTURE:
                mCollector.expectKeyValueEquals(request, CONTROL_CAPTURE_INTENT,
                        CameraCharacteristics.CONTROL_CAPTURE_INTENT_STILL_CAPTURE);
                break;
            case CameraDevice.TEMPLATE_RECORD:
                mCollector.expectKeyValueEquals(request, CONTROL_CAPTURE_INTENT,
                        CameraCharacteristics.CONTROL_CAPTURE_INTENT_VIDEO_RECORD);
                break;
            case CameraDevice.TEMPLATE_VIDEO_SNAPSHOT:
                mCollector.expectKeyValueEquals(request, CONTROL_CAPTURE_INTENT,
                        CameraCharacteristics.CONTROL_CAPTURE_INTENT_VIDEO_SNAPSHOT);
                break;
            case CameraDevice.TEMPLATE_ZERO_SHUTTER_LAG:
                mCollector.expectKeyValueEquals(request, CONTROL_CAPTURE_INTENT,
                        CameraCharacteristics.CONTROL_CAPTURE_INTENT_ZERO_SHUTTER_LAG);
                break;
            case CameraDevice.TEMPLATE_MANUAL:
                mCollector.expectKeyValueEquals(request, CONTROL_CAPTURE_INTENT,
                        CameraCharacteristics.CONTROL_CAPTURE_INTENT_MANUAL);
                break;
            default:
                // Skip unknown templates here
        }

        // Check distortion correction mode
        if (mStaticInfo.isDistortionCorrectionSupported()) {
            mCollector.expectKeyValueNotEquals(request, DISTORTION_CORRECTION_MODE,
                    CaptureRequest.DISTORTION_CORRECTION_MODE_OFF);
        }

        // Scaler settings
        if (mStaticInfo.areKeysAvailable(
                CameraCharacteristics.SCALER_AVAILABLE_ROTATE_AND_CROP_MODES)) {
            List<Integer> rotateAndCropModes = Arrays.asList(toObject(
                props.get(CameraCharacteristics.SCALER_AVAILABLE_ROTATE_AND_CROP_MODES)));
            if (rotateAndCropModes.contains(SCALER_ROTATE_AND_CROP_AUTO)) {
                mCollector.expectKeyValueEquals(request, SCALER_ROTATE_AND_CROP,
                        CaptureRequest.SCALER_ROTATE_AND_CROP_AUTO);
            }
        }

        // Check JPEG quality
        if (mStaticInfo.isColorOutputSupported()) {
            mCollector.expectKeyValueNotNull(request, JPEG_QUALITY);
        }

        // TODO: use the list of keys from CameraCharacteristics to avoid expecting
        //       keys which are not available by this CameraDevice.
    }

    private void captureTemplateTestByCamera(String cameraId, int template) throws Exception {
        try {
            openDevice(cameraId, mCameraMockListener);

            assertTrue(""Camera template "" + template + "" is out of range!"",
                    template >= CameraDevice.TEMPLATE_PREVIEW
                            && template <= CameraDevice.TEMPLATE_MANUAL);

            mCollector.setCameraId(cameraId);

            try {
                CaptureRequest.Builder request = mCamera.createCaptureRequest(template);
                assertNotNull(""Failed to create capture request for template "" + template, request);

                CameraCharacteristics props = mStaticInfo.getCharacteristics();
                checkRequestForTemplate(request, template, props);
            } catch (IllegalArgumentException e) {
                if (template == CameraDevice.TEMPLATE_MANUAL &&
                        !mStaticInfo.isCapabilitySupported(CameraCharacteristics.
                                REQUEST_AVAILABLE_CAPABILITIES_MANUAL_SENSOR)) {
                    // OK
                } else if (template == CameraDevice.TEMPLATE_ZERO_SHUTTER_LAG &&
                        !mStaticInfo.isCapabilitySupported(CameraCharacteristics.
                                REQUEST_AVAILABLE_CAPABILITIES_PRIVATE_REPROCESSING)) {
                    // OK.
                } else if (sLegacySkipTemplates.contains(template) &&
                        mStaticInfo.isHardwareLevelLegacy()) {
                    // OK
                } else if (template != CameraDevice.TEMPLATE_PREVIEW &&
                        mStaticInfo.isDepthOutputSupported() &&
                        !mStaticInfo.isColorOutputSupported()) {
                    // OK, depth-only devices need only support PREVIEW template
                } else {
                    throw e; // rethrow
                }
            }
        }
        finally {
            try {
                closeSession();
            } finally {
                closeDevice(cameraId, mCameraMockListener);
            }
        }
    }

    /**
     * Start capture with given {@link #CaptureRequest}.
     *
     * @param request The {@link #CaptureRequest} to be captured.
     * @param repeating If the capture is single capture or repeating.
     * @param listener The {@link #CaptureCallback} camera device used to notify callbacks.
     * @param handler The handler camera device used to post callbacks.
     */
    @Override
    protected void startCapture(CaptureRequest request, boolean repeating,
            CameraCaptureSession.CaptureCallback listener, Handler handler)
                    throws CameraAccessException {
        if (VERBOSE) Log.v(TAG, ""Starting capture from session"");

        if (repeating) {
            mSession.setRepeatingRequest(request, listener, handler);
        } else {
            mSession.capture(request, listener, handler);
        }
    }

    /**
     * Start capture with given {@link #CaptureRequest}.
     *
     * @param request The {@link #CaptureRequest} to be captured.
     * @param repeating If the capture is single capture or repeating.
     * @param listener The {@link #CaptureCallback} camera device used to notify callbacks.
     * @param executor The executor used to invoke callbacks.
     */
    protected void startCapture(CaptureRequest request, boolean repeating,
            CameraCaptureSession.CaptureCallback listener, Executor executor)
                    throws CameraAccessException {
        if (VERBOSE) Log.v(TAG, ""Starting capture from session"");

        if (repeating) {
            mSession.setSingleRepeatingRequest(request, executor, listener);
        } else {
            mSession.captureSingleRequest(request, executor, listener);
        }
    }

    /**
     * Close a {@link #CameraCaptureSession capture session}; blocking until
     * the close finishes with a transition to {@link CameraCaptureSession.StateCallback#onClosed}.
     */
    protected void closeSession() {
        if (mSession == null) {
            return;
        }

        mSession.close();
        waitForSessionState(SESSION_CLOSED, SESSION_CLOSE_TIMEOUT_MS);
        mSession = null;

        mSessionMockListener = null;
        mSessionWaiter = null;
    }

    /**
     * A camera capture session listener that keeps all the configured and closed sessions.
     */
    private class MultipleSessionCallback extends CameraCaptureSession.StateCallback {
        public static final int SESSION_CONFIGURED = 0;
        public static final int SESSION_CLOSED = 1;

        final List<CameraCaptureSession> mSessions = new ArrayList<>();
        final Map<CameraCaptureSession, Integer> mSessionStates = new HashMap<>();
        CameraCaptureSession mCurrentConfiguredSession = null;

        final ReentrantLock mLock = new ReentrantLock();
        final Condition mNewStateCond = mLock.newCondition();

        final boolean mFailOnConfigureFailed;

        /**
         * If failOnConfigureFailed is true, it calls fail() when onConfigureFailed() is invoked
         * for any session.
         */
        public MultipleSessionCallback(boolean failOnConfigureFailed) {
            mFailOnConfigureFailed = failOnConfigureFailed;
        }

        @Override
        public void onClosed(CameraCaptureSession session) {
            mLock.lock();
            mSessionStates.put(session, SESSION_CLOSED);
            mNewStateCond.signal();
            mLock.unlock();
        }

        @Override
        public void onConfigured(CameraCaptureSession session) {
            mLock.lock();
            mSessions.add(session);
            mSessionStates.put(session, SESSION_CONFIGURED);
            mNewStateCond.signal();
            mLock.unlock();
        }

        @Override
        public void onConfigureFailed(CameraCaptureSession session) {
            if (mFailOnConfigureFailed) {
                fail(""Configuring a session failed"");
            }
        }

        /**
         * Get a number of sessions that have been configured.
         */
        public List<CameraCaptureSession> getAllSessions(int numSessions, int timeoutMs)
                throws Exception {
            long remainingTime = timeoutMs;
            mLock.lock();
            try {
                while (mSessions.size() < numSessions) {
                    long startTime = SystemClock.elapsedRealtime();
                    boolean ret = mNewStateCond.await(remainingTime, TimeUnit.MILLISECONDS);
                    remainingTime -= (SystemClock.elapsedRealtime() - startTime);
                    ret &= remainingTime > 0;

                    assertTrue(""Get "" + numSessions + "" sessions timed out after "" + timeoutMs +
                            ""ms"", ret);
                }

                return mSessions;
            } finally {
                mLock.unlock();
            }
        }

        /**
         * Wait until a previously-configured sessoin is closed or it times out.
         */
        public void waitForSessionClose(CameraCaptureSession session, int timeoutMs) throws Exception {
            long remainingTime = timeoutMs;
            mLock.lock();
            try {
                while (mSessionStates.get(session).equals(SESSION_CLOSED) == false) {
                    long startTime = SystemClock.elapsedRealtime();
                    boolean ret = mNewStateCond.await(remainingTime, TimeUnit.MILLISECONDS);
                    remainingTime -= (SystemClock.elapsedRealtime() - startTime);
                    ret &= remainingTime > 0;

                    assertTrue(""Wait for session close timed out after "" + timeoutMs + ""ms"", ret);
                }
            } finally {
                mLock.unlock();
            }
        }
    }

    /**
     * Verify audio restrictions are set properly for single CameraDevice usage
     */"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.hardware.camera2.cts.CameraDeviceTest"	"testAudioRestrictionSingleDevice"	"CtsCameraTestCases"	"/home/gpoor/cts-12-source/cts/tests/camera/src/android/hardware/camera2/cts/CameraDeviceTest.java"	""	"public void testAudioRestrictionSingleDevice() throws Exception {
        int[] testModes = {
            CameraDevice.AUDIO_RESTRICTION_VIBRATION_SOUND,
            CameraDevice.AUDIO_RESTRICTION_NONE,
            CameraDevice.AUDIO_RESTRICTION_VIBRATION,
        };
        for (int i = 0; i < mCameraIdsUnderTest.length; i++) {
            try {
                openDevice(mCameraIdsUnderTest[i], mCameraMockListener);
                waitForDeviceState(STATE_OPENED, CAMERA_OPEN_TIMEOUT_MS);

                for (int mode : testModes) {
                    mCamera.setCameraAudioRestriction(mode);
                    int retMode = mCamera.getCameraAudioRestriction();
                    assertTrue(""Audio restriction mode mismatch: input: "" + mode +
                            "", output:"" + retMode, mode == retMode);
                }

                try {
                    // Test invalid mode
                    mCamera.setCameraAudioRestriction(42);
                    fail(""Should get IllegalArgumentException for invalid mode"");
                } catch (IllegalArgumentException e) {
                    // expected
                }
            }
            finally {
                closeDevice(mCameraIdsUnderTest[i], mCameraMockListener);
            }
        }
    }

    private void testTwoCameraDevicesAudioRestriction(String id0, String id1) throws Exception {
        BlockingStateCallback cam0Cb = new BlockingStateCallback();
        BlockingStateCallback cam1Cb = new BlockingStateCallback();
        CameraDevice cam0 = null;
        CameraDevice cam1 = null;
        try {
            cam0 = CameraTestUtils.openCamera(mCameraManager, id0, cam0Cb, mHandler);
            cam0Cb.waitForState(STATE_OPENED, CAMERA_OPEN_TIMEOUT_MS);

            int mode0 = CameraDevice.AUDIO_RESTRICTION_VIBRATION_SOUND;
            cam0.setCameraAudioRestriction(mode0);
            int retMode = cam0.getCameraAudioRestriction();
            assertTrue(""Audio restriction mode mismatch: input: "" + mode0 + "", output:"" + retMode,
                    retMode == mode0);

            try {
                cam1 = CameraTestUtils.openCamera(mCameraManager, id1, cam1Cb, mHandler);
            } catch (CameraAccessException | BlockingOpenException e) {
                Log.i(TAG, ""Camera "" + id1 + ""cannot be opened along with camera "" + id0 +
                        "", skipping the test"");
                return;
            }
            cam1Cb.waitForState(STATE_OPENED, CAMERA_OPEN_TIMEOUT_MS);

            // See if cam0 is evicted.
            try {
                final int cameraEvictedTimeoutMs = 1000;
                cam0Cb.waitForState(STATE_DISCONNECTED, cameraEvictedTimeoutMs);
                fail(""Opened camera "" + id0 + "" is evicted by a later open call for camera "" +
                        id1 + "" from the same process"");
            } catch (TimeoutRuntimeException e) {
                // camera 0 is not evicted
            }

            // The output mode should be union of all CameraDevices
            int mode1 = CameraDevice.AUDIO_RESTRICTION_VIBRATION;
            int expectMode = mode0 | mode1;
            cam1.setCameraAudioRestriction(mode1);
            retMode = cam1.getCameraAudioRestriction();
            assertTrue(""Audio restriction mode mismatch: expect: "" + expectMode +
                    "", output:"" + retMode, retMode == expectMode);

            // test turning off mute settings also
            mode0 = CameraDevice.AUDIO_RESTRICTION_NONE;
            expectMode = mode0 | mode1;
            cam0.setCameraAudioRestriction(mode0);
            retMode = cam0.getCameraAudioRestriction();
            assertTrue(""Audio restriction mode mismatch: expect: "" + expectMode +
                    "", output:"" + retMode, retMode == expectMode);

            // mode should be NONE when both device set to NONE
            mode1 = CameraDevice.AUDIO_RESTRICTION_NONE;
            expectMode = mode0 | mode1;
            cam1.setCameraAudioRestriction(mode1);
            retMode = cam1.getCameraAudioRestriction();
            assertTrue(""Audio restriction mode mismatch: expect: "" + expectMode +
                    "", output:"" + retMode, retMode == expectMode);

            // test removal of VIBRATE won't affect existing VIBRATE_SOUND state
            mode0 = CameraDevice.AUDIO_RESTRICTION_VIBRATION_SOUND;
            expectMode = mode0 | mode1;
            cam0.setCameraAudioRestriction(mode0);
            retMode = cam0.getCameraAudioRestriction();
            assertTrue(""Audio restriction mode mismatch: expect: "" + expectMode +
                    "", output:"" + retMode, retMode == expectMode);

            mode1 = CameraDevice.AUDIO_RESTRICTION_VIBRATION;
            expectMode = mode0 | mode1;
            cam1.setCameraAudioRestriction(mode1);
            retMode = cam1.getCameraAudioRestriction();
            assertTrue(""Audio restriction mode mismatch: expect: "" + expectMode +
                    "", output:"" + retMode, retMode == expectMode);

            mode1 = CameraDevice.AUDIO_RESTRICTION_NONE;
            expectMode = mode0 | mode1;
            cam1.setCameraAudioRestriction(mode1);
            retMode = cam1.getCameraAudioRestriction();
            assertTrue(""Audio restriction mode mismatch: expect: "" + expectMode +
                    "", output:"" + retMode, retMode == expectMode);

            // Now test CameraDevice.close will remove setting and exception is thrown for closed
            // camera.
            cam0.close();
            cam0Cb.waitForState(STATE_CLOSED, CAMERA_CLOSE_TIMEOUT_MS);
            try {
                cam0.setCameraAudioRestriction(mode0);
                fail(""Should get IllegalStateException for closed camera."");
            } catch (IllegalStateException e) {
                // expected;
            }

            cam0 = null;
            cam0Cb = null;
            expectMode = mode1;
            cam1.setCameraAudioRestriction(mode1);
            retMode = cam1.getCameraAudioRestriction();
            assertTrue(""Audio restriction mode mismatch: expect: "" + expectMode +
                    "", output:"" + retMode, retMode == expectMode);
        } finally {
            if (cam0 != null) {
                cam0.close();
                cam0Cb.waitForState(STATE_CLOSED, CAMERA_CLOSE_TIMEOUT_MS);
                cam0Cb = null;
            }
            if (cam1 != null) {
                cam1.close();
                cam1Cb.waitForState(STATE_CLOSED, CAMERA_CLOSE_TIMEOUT_MS);
                cam1Cb = null;
            }
        }
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.hardware.camera2.cts.CameraDeviceTest"	"testAudioRestrictionMultipleDevices"	"CtsCameraTestCases"	"/home/gpoor/cts-12-source/cts/tests/camera/src/android/hardware/camera2/cts/CameraDeviceTest.java"	""	"public void testAudioRestrictionMultipleDevices() throws Exception {
        if (mCameraIdsUnderTest.length < 2) {
            Log.i(TAG, ""device doesn't have multiple cameras, skipping"");
            return;
        }

        for (int i = 0; i < mCameraIdsUnderTest.length; i++) {
            for (int j = i+1; j < mCameraIdsUnderTest.length; j++) {
                testTwoCameraDevicesAudioRestriction(mCameraIdsUnderTest[i], mCameraIdsUnderTest[j]);
            }
        }
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.OrgOwnedProfileOwnerParentTest"	"testAddGetAndClearUserRestriction_onParent"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/OrgOwnedProfileOwnerParentTest.java"	""	"public void testAddGetAndClearUserRestriction_onParent() {
        int locationMode = 1;
        try {
            locationMode = runWithShellPermissionIdentity(
                    () -> Settings.Secure.getIntForUser(mContentResolver,
                            Settings.Secure.LOCATION_MODE, UserHandle.USER_SYSTEM));

            for (String restriction : PROFILE_OWNER_ORGANIZATION_OWNED_GLOBAL_RESTRICTIONS) {
                testAddGetAndClearUserRestriction_onParent(restriction);
            }
            for (String restriction : PROFILE_OWNER_ORGANIZATION_OWNED_LOCAL_RESTRICTIONS) {
                testAddGetAndClearUserRestriction_onParent(restriction);
            }
        } finally {
            // Restore the location mode setting after adding and removing the
            // DISALLOW_SHARE_LOCATION user restriction. This is because, modifying this user
            // restriction causes the location mode setting to be turned off.
            final int finalLocationMode = locationMode;
            runWithShellPermissionIdentity(() -> Settings.Secure.putIntForUser(mContentResolver,
                    Settings.Secure.LOCATION_MODE, finalLocationMode, UserHandle.USER_SYSTEM));
        }
    }

    private void testAddGetAndClearUserRestriction_onParent(String restriction) {
        mParentDevicePolicyManager.addUserRestriction(ADMIN_RECEIVER_COMPONENT, restriction);

        Bundle restrictions = mParentDevicePolicyManager.getUserRestrictions(
                ADMIN_RECEIVER_COMPONENT);
        assertThat(restrictions.get(restriction)).isNotNull();

        mParentDevicePolicyManager.clearUserRestriction(ADMIN_RECEIVER_COMPONENT, restriction);

        restrictions = mParentDevicePolicyManager.getUserRestrictions(ADMIN_RECEIVER_COMPONENT);
        assertThat(restrictions.get(restriction)).isNull();
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.OrgOwnedProfileOwnerParentTest"	"testUnableToAddAndClearBaseUserRestrictions_onParent"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/OrgOwnedProfileOwnerParentTest.java"	""	"public void testUnableToAddAndClearBaseUserRestrictions_onParent() {
        testUnableToAddBaseUserRestriction(UserManager.DISALLOW_REMOVE_MANAGED_PROFILE);
        testUnableToClearBaseUserRestriction(UserManager.DISALLOW_REMOVE_MANAGED_PROFILE);
        testUnableToAddBaseUserRestriction(UserManager.DISALLOW_ADD_USER);
        testUnableToClearBaseUserRestriction(UserManager.DISALLOW_ADD_USER);
    }

    private void testUnableToAddBaseUserRestriction(String restriction) {
        assertThrows(SecurityException.class,
                () -> mParentDevicePolicyManager.addUserRestriction(ADMIN_RECEIVER_COMPONENT,
                        restriction));
    }

    private void testUnableToClearBaseUserRestriction(String restriction) {
        assertThrows(SecurityException.class,
                () -> mParentDevicePolicyManager.clearUserRestriction(ADMIN_RECEIVER_COMPONENT,
                        restriction));
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.keystore.cts.util.TestUtils"	"TestUtils"	"CtsKeystoreTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/keystore/src/android/keystore/cts/util/TestUtils.java"	""	"public void test/*
 *.
 */

package android.keystore.cts.util;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.junit.Assume.assumeTrue;

import android.content.Context;
import android.content.pm.PackageManager;
import android.content.pm.FeatureInfo;
import android.os.SystemProperties;
import android.security.keystore.KeyGenParameterSpec;
import android.security.keystore.KeyInfo;
import android.security.keystore.KeyProperties;
import android.security.keystore.KeyProtection;
import android.test.MoreAsserts;

import androidx.test.platform.app.InstrumentationRegistry;

import com.android.internal.util.HexDump;

import junit.framework.Assert;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.math.BigInteger;
import java.security.Key;
import java.security.KeyFactory;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.KeyPairGeneratorSpi;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.PrivateKey;
import java.security.ProviderException;
import java.security.PublicKey;
import java.security.UnrecoverableEntryException;
import java.security.cert.Certificate;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.security.interfaces.ECKey;
import java.security.interfaces.ECPrivateKey;
import java.security.interfaces.ECPublicKey;
import java.security.interfaces.RSAKey;
import java.security.interfaces.RSAPrivateKey;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.ECParameterSpec;
import java.security.spec.EllipticCurve;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.PKCS8EncodedKeySpec;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.security.SecureRandom;

import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.SecretKeySpec;

public class TestUtils {

    public static final String EXPECTED_CRYPTO_OP_PROVIDER_NAME = ""AndroidKeyStoreBCWorkaround"";
    public static final String EXPECTED_PROVIDER_NAME = ""AndroidKeyStore"";

    public static final long DAY_IN_MILLIS = 1000 * 60 * 60 * 24;

    private TestUtils() {}

    static public void assumeStrongBox() {
        PackageManager packageManager =
                InstrumentationRegistry.getInstrumentation().getTargetContext().getPackageManager();
        assumeTrue(""Can only test if we have StrongBox"",
                packageManager.hasSystemFeature(PackageManager.FEATURE_STRONGBOX_KEYSTORE));
    }

    // Returns 0 if not implemented. Otherwise returns the feature version.
    //
    public static int getFeatureVersionKeystore(Context appContext) {
        PackageManager pm = appContext.getPackageManager();

        int featureVersionFromPm = 0;
        if (pm.hasSystemFeature(PackageManager.FEATURE_HARDWARE_KEYSTORE)) {
            FeatureInfo info = null;
            FeatureInfo[] infos = pm.getSystemAvailableFeatures();
            for (int n = 0; n < infos.length; n++) {
                FeatureInfo i = infos[n];
                if (i.name.equals(PackageManager.FEATURE_HARDWARE_KEYSTORE)) {
                    info = i;
                    break;
                }
            }
            if (info != null) {
                featureVersionFromPm = info.version;
            }
        }

        return featureVersionFromPm;
    }

    // Returns 0 if not implemented. Otherwise returns the feature version.
    //
    public static int getFeatureVersionKeystoreStrongBox(Context appContext) {
        PackageManager pm = appContext.getPackageManager();

        int featureVersionFromPm = 0;
        if (pm.hasSystemFeature(PackageManager.FEATURE_STRONGBOX_KEYSTORE)) {
            FeatureInfo info = null;
            FeatureInfo[] infos = pm.getSystemAvailableFeatures();
            for (int n = 0; n < infos.length; n++) {
                FeatureInfo i = infos[n];
                if (i.name.equals(PackageManager.FEATURE_STRONGBOX_KEYSTORE)) {
                    info = i;
                    break;
                }
            }
            if (info != null) {
                featureVersionFromPm = info.version;
            }
        }

        return featureVersionFromPm;
    }

    /**
     * Returns whether 3DES KeyStore tests should run on this device. 3DES support was added in
     * KeyMaster 4.0 and there should be no software fallback on earlier KeyMaster versions.
     */
    public static boolean supports3DES() {
        return ""true"".equals(SystemProperties.get(""ro.hardware.keystore_desede""));
    }

    /**
     * Returns whether the device has a StrongBox backed KeyStore.
     */
    public static boolean hasStrongBox(Context context) {
        return context.getPackageManager()
            .hasSystemFeature(PackageManager.FEATURE_STRONGBOX_KEYSTORE);
    }

    /**
     * Asserts the the key algorithm and algorithm-specific parameters of the two keys in the
     * provided pair match.
     */
    public static void assertKeyPairSelfConsistent(KeyPair keyPair) {
        assertKeyPairSelfConsistent(keyPair.getPublic(), keyPair.getPrivate());
    }

    /**
     * Asserts the the key algorithm and public algorithm-specific parameters of the two provided
     * keys match.
     */
    public static void assertKeyPairSelfConsistent(PublicKey publicKey, PrivateKey privateKey) {
        assertNotNull(publicKey);
        assertNotNull(privateKey);
        assertEquals(publicKey.getAlgorithm(), privateKey.getAlgorithm());
        String keyAlgorithm = publicKey.getAlgorithm();
        if (""EC"".equalsIgnoreCase(keyAlgorithm)) {
            assertTrue(""EC public key must be instanceof ECKey: ""
                    + publicKey.getClass().getName(),
                    publicKey instanceof ECKey);
            assertTrue(""EC private key must be instanceof ECKey: ""
                    + privateKey.getClass().getName(),
                    privateKey instanceof ECKey);
            assertECParameterSpecEqualsIgnoreSeedIfNotPresent(
                    ""Private key must have the same EC parameters as public key"",
                    ((ECKey) publicKey).getParams(), ((ECKey) privateKey).getParams());
        } else if (""RSA"".equalsIgnoreCase(keyAlgorithm)) {
            assertTrue(""RSA public key must be instance of RSAKey: ""
                    + publicKey.getClass().getName(),
                    publicKey instanceof RSAKey);
            assertTrue(""RSA private key must be instance of RSAKey: ""
                    + privateKey.getClass().getName(),
                    privateKey instanceof RSAKey);
            assertEquals(""Private and public key must have the same RSA modulus"",
                    ((RSAKey) publicKey).getModulus(), ((RSAKey) privateKey).getModulus());
        } else {
            fail(""Unsuported key algorithm: "" + keyAlgorithm);
        }
    }

    public static int getKeySizeBits(Key key) {
        if (key instanceof ECKey) {
            return ((ECKey) key).getParams().getCurve().getField().getFieldSize();
        } else if (key instanceof RSAKey) {
            return ((RSAKey) key).getModulus().bitLength();
        } else {
            throw new IllegalArgumentException(""Unsupported key type: "" + key.getClass());
        }
    }

    public static void assertKeySize(int expectedSizeBits, KeyPair keyPair) {
        assertEquals(expectedSizeBits, getKeySizeBits(keyPair.getPrivate()));
        assertEquals(expectedSizeBits, getKeySizeBits(keyPair.getPublic()));
    }

    /**
     * Asserts that the provided key pair is an Android Keystore key pair stored under the provided
     * alias.
     */
    public static void assertKeyStoreKeyPair(KeyStore keyStore, String alias, KeyPair keyPair) {
        assertKeyMaterialExportable(keyPair.getPublic());
        assertKeyMaterialNotExportable(keyPair.getPrivate());
        assertTransparentKey(keyPair.getPublic());
        assertOpaqueKey(keyPair.getPrivate());

        KeyStore.Entry entry;
        Certificate cert;
        try {
            entry = keyStore.getEntry(alias, null);
            cert = keyStore.getCertificate(alias);
        } catch (KeyStoreException | UnrecoverableEntryException | NoSuchAlgorithmException e) {
            throw new RuntimeException(""Failed to load entry: "" + alias, e);
        }
        assertNotNull(entry);

        assertTrue(entry instanceof KeyStore.PrivateKeyEntry);
        KeyStore.PrivateKeyEntry privEntry = (KeyStore.PrivateKeyEntry) entry;
        assertEquals(cert, privEntry.getCertificate());
        assertTrue(""Certificate must be an X.509 certificate: "" + cert.getClass(),
                cert instanceof X509Certificate);
        final X509Certificate x509Cert = (X509Certificate) cert;

        PrivateKey keystorePrivateKey = privEntry.getPrivateKey();
        PublicKey keystorePublicKey = cert.getPublicKey();
        assertEquals(keyPair.getPrivate(), keystorePrivateKey);
        assertTrue(""Key1:\n"" + HexDump.dumpHexString(keyPair.getPublic().getEncoded())
                + ""\nKey2:\n"" + HexDump.dumpHexString(keystorePublicKey.getEncoded()) + ""\n"",
                Arrays.equals(keyPair.getPublic().getEncoded(), keystorePublicKey.getEncoded()));


        assertEquals(
                ""Public key used to sign certificate should have the same algorithm as in KeyPair"",
                keystorePublicKey.getAlgorithm(), x509Cert.getPublicKey().getAlgorithm());

        Certificate[] chain = privEntry.getCertificateChain();
        if (chain.length == 0) {
            fail(""Empty certificate chain"");
            return;
        }
        assertEquals(cert, chain[0]);
    }


    private static void assertKeyMaterialExportable(Key key) {
        if (key instanceof PublicKey) {
            assertEquals(""X.509"", key.getFormat());
        } else if (key instanceof PrivateKey) {
            assertEquals(""PKCS#8"", key.getFormat());
        } else if (key instanceof SecretKey) {
            assertEquals(""RAW"", key.getFormat());
        } else {
            fail(""Unsupported key type: "" + key.getClass().getName());
        }
        byte[] encodedForm = key.getEncoded();
        assertNotNull(encodedForm);
        if (encodedForm.length == 0) {
            fail(""Empty encoded form"");
        }
    }

    private static void assertKeyMaterialNotExportable(Key key) {
        assertEquals(null, key.getFormat());
        assertEquals(null, key.getEncoded());
    }

    private static void assertOpaqueKey(Key key) {
        assertFalse(key.getClass().getName() + "" is a transparent key"", isTransparentKey(key));
    }

    private static void assertTransparentKey(Key key) {
        assertTrue(key.getClass().getName() + "" is not a transparent key"", isTransparentKey(key));
    }

    private static boolean isTransparentKey(Key key) {
        if (key instanceof PrivateKey) {
            return (key instanceof ECPrivateKey) || (key instanceof RSAPrivateKey);
        } else if (key instanceof PublicKey) {
            return (key instanceof ECPublicKey) || (key instanceof RSAPublicKey);
        } else if (key instanceof SecretKey) {
            return (key instanceof SecretKeySpec);
        } else {
            throw new IllegalArgumentException(""Unsupported key type: "" + key.getClass().getName());
        }
    }

    public static void assertECParameterSpecEqualsIgnoreSeedIfNotPresent(
            ECParameterSpec expected, ECParameterSpec actual) {
        assertECParameterSpecEqualsIgnoreSeedIfNotPresent(null, expected, actual);
    }

    public static void assertECParameterSpecEqualsIgnoreSeedIfNotPresent(String message,
            ECParameterSpec expected, ECParameterSpec actual) {
        EllipticCurve expectedCurve = expected.getCurve();
        EllipticCurve actualCurve = actual.getCurve();
        String msgPrefix = (message != null) ? message + "": "" : """";
        assertEquals(msgPrefix + ""curve field"", expectedCurve.getField(), actualCurve.getField());
        assertEquals(msgPrefix + ""curve A"", expectedCurve.getA(), actualCurve.getA());
        assertEquals(msgPrefix + ""curve B"", expectedCurve.getB(), actualCurve.getB());
        assertEquals(msgPrefix + ""order"", expected.getOrder(), actual.getOrder());
        assertEquals(msgPrefix + ""generator"",
                expected.getGenerator(), actual.getGenerator());
        assertEquals(msgPrefix + ""cofactor"", expected.getCofactor(), actual.getCofactor());

        // If present, the seed must be the same
        byte[] expectedSeed = expectedCurve.getSeed();
        byte[] actualSeed = expectedCurve.getSeed();
        if ((expectedSeed != null) && (actualSeed != null)) {
            MoreAsserts.assertEquals(expectedSeed, actualSeed);
        }
    }

    public static KeyInfo getKeyInfo(Key key) throws InvalidKeySpecException, NoSuchAlgorithmException,
            NoSuchProviderException {
        if ((key instanceof PrivateKey) || (key instanceof PublicKey)) {
            return KeyFactory.getInstance(key.getAlgorithm(), ""AndroidKeyStore"")
                    .getKeySpec(key, KeyInfo.class);
        } else if (key instanceof SecretKey) {
            return (KeyInfo) SecretKeyFactory.getInstance(key.getAlgorithm(), ""AndroidKeyStore"")
                    .getKeySpec((SecretKey) key, KeyInfo.class);
        } else {
            throw new IllegalArgumentException(""Unexpected key type: "" + key.getClass());
        }
    }

    public static <T> void assertContentsInAnyOrder(Iterable<T> actual, T... expected) {
        assertContentsInAnyOrder(null, actual, expected);
    }

    public static <T> void assertContentsInAnyOrder(String message, Iterable<T> actual, T... expected) {
        Map<T, Integer> actualFreq = getFrequencyTable(actual);
        Map<T, Integer> expectedFreq = getFrequencyTable(expected);
        if (actualFreq.equals(expectedFreq)) {
            return;
        }

        Map<T, Integer> extraneousFreq = new HashMap<T, Integer>();
        for (Map.Entry<T, Integer> actualEntry : actualFreq.entrySet()) {
            int actualCount = actualEntry.getValue();
            Integer expectedCount = expectedFreq.get(actualEntry.getKey());
            int diff = actualCount - ((expectedCount != null) ? expectedCount : 0);
            if (diff > 0) {
                extraneousFreq.put(actualEntry.getKey(), diff);
            }
        }

        Map<T, Integer> missingFreq = new HashMap<T, Integer>();
        for (Map.Entry<T, Integer> expectedEntry : expectedFreq.entrySet()) {
            int expectedCount = expectedEntry.getValue();
            Integer actualCount = actualFreq.get(expectedEntry.getKey());
            int diff = expectedCount - ((actualCount != null) ? actualCount : 0);
            if (diff > 0) {
                missingFreq.put(expectedEntry.getKey(), diff);
            }
        }

        List<T> extraneous = frequencyTableToValues(extraneousFreq);
        List<T> missing = frequencyTableToValues(missingFreq);
        StringBuilder result = new StringBuilder();
        String delimiter = """";
        if (message != null) {
            result.append(message).append(""."");
            delimiter = "" "";
        }
        if (!missing.isEmpty()) {
            result.append(delimiter).append(""missing: "" + missing);
            delimiter = "", "";
        }
        if (!extraneous.isEmpty()) {
            result.append(delimiter).append(""extraneous: "" + extraneous);
        }
        fail(result.toString());
    }

    private static <T> Map<T, Integer> getFrequencyTable(Iterable<T> values) {
        Map<T, Integer> result = new HashMap<T, Integer>();
        for (T value : values) {
            Integer count = result.get(value);
            if (count == null) {
                count = 1;
            } else {
                count++;
            }
            result.put(value, count);
        }
        return result;
    }

    private static <T> Map<T, Integer> getFrequencyTable(T... values) {
        Map<T, Integer> result = new HashMap<T, Integer>();
        for (T value : values) {
            Integer count = result.get(value);
            if (count == null) {
                count = 1;
            } else {
                count++;
            }
            result.put(value, count);
        }
        return result;
    }

    @SuppressWarnings(""rawtypes"")
    private static <T> List<T> frequencyTableToValues(Map<T, Integer> table) {
        if (table.isEmpty()) {
            return Collections.emptyList();
        }

        List<T> result = new ArrayList<T>();
        boolean comparableValues = true;
        for (Map.Entry<T, Integer> entry : table.entrySet()) {
            T value = entry.getKey();
            if (!(value instanceof Comparable)) {
                comparableValues = false;
            }
            int frequency = entry.getValue();
            for (int i = 0; i < frequency; i++) {
                result.add(value);
            }
        }

        if (comparableValues) {
            sortAssumingComparable(result);
        }
        return result;
    }

    @SuppressWarnings({""rawtypes"", ""unchecked""})
    private static void sortAssumingComparable(List<?> values) {
        Collections.sort((List<Comparable>)values);
    }

    public static String[] toLowerCase(String... values) {
        if (values == null) {
            return null;
        }
        String[] result = new String[values.length];
        for (int i = 0; i < values.length; i++) {
            String value = values[i];
            result[i] = (value != null) ? value.toLowerCase() : null;
        }
        return result;
    }

    public static PrivateKey getRawResPrivateKey(Context context, int resId) throws Exception {
        byte[] pkcs8EncodedForm;
        try (InputStream in = context.getResources().openRawResource(resId)) {
            pkcs8EncodedForm = drain(in);
        }
        PKCS8EncodedKeySpec privateKeySpec = new PKCS8EncodedKeySpec(pkcs8EncodedForm);

        try {
            return KeyFactory.getInstance(""EC"").generatePrivate(privateKeySpec);
        } catch (InvalidKeySpecException e) {
            try {
                return KeyFactory.getInstance(""RSA"").generatePrivate(privateKeySpec);
            } catch (InvalidKeySpecException e2) {
                throw new InvalidKeySpecException(""The key is neither EC nor RSA"", e);
            }
        }
    }

    public static X509Certificate getRawResX509Certificate(Context context, int resId) throws Exception {
        try (InputStream in = context.getResources().openRawResource(resId)) {
            return (X509Certificate) CertificateFactory.getInstance(""X.509"")
                    .generateCertificate(in);
        }
    }

    public static KeyPair importIntoAndroidKeyStore(
            String alias,
            PrivateKey privateKey,
            Certificate certificate,
            KeyProtection keyProtection) throws Exception {
        KeyStore keyStore = KeyStore.getInstance(""AndroidKeyStore"");
        keyStore.load(null);
        keyStore.setEntry(alias,
                new KeyStore.PrivateKeyEntry(privateKey, new Certificate[] {certificate}),
                keyProtection);
        return new KeyPair(
                keyStore.getCertificate(alias).getPublicKey(),
                (PrivateKey) keyStore.getKey(alias, null));
    }

    public static ImportedKey importIntoAndroidKeyStore(
            String alias,
            SecretKey key,
            KeyProtection keyProtection) throws Exception {
        KeyStore keyStore = KeyStore.getInstance(""AndroidKeyStore"");
        keyStore.load(null);
        keyStore.setEntry(alias,
                new KeyStore.SecretKeyEntry(key),
                keyProtection);
        return new ImportedKey(alias, key, (SecretKey) keyStore.getKey(alias, null));
    }

    public static ImportedKey importIntoAndroidKeyStore(
            String alias, Context context, int privateResId, int certResId, KeyProtection params)
                    throws Exception {
        Certificate originalCert = TestUtils.getRawResX509Certificate(context, certResId);
        PublicKey originalPublicKey = originalCert.getPublicKey();
        PrivateKey originalPrivateKey = TestUtils.getRawResPrivateKey(context, privateResId);

        // Check that the domain parameters match between the private key and the public key. This
        // is to catch accidental errors where a test provides the wrong resource ID as one of the
        // parameters.
        if (!originalPublicKey.getAlgorithm().equalsIgnoreCase(originalPrivateKey.getAlgorithm())) {
            throw new IllegalArgumentException(""Key algorithm mismatch.""
                    + "" Public: "" + originalPublicKey.getAlgorithm()
                    + "", private: "" + originalPrivateKey.getAlgorithm());
        }
        assertKeyPairSelfConsistent(originalPublicKey, originalPrivateKey);

        KeyPair keystoreBacked = TestUtils.importIntoAndroidKeyStore(
                alias, originalPrivateKey, originalCert,
                params);
        assertKeyPairSelfConsistent(keystoreBacked);
        assertKeyPairSelfConsistent(keystoreBacked.getPublic(), originalPrivateKey);
        return new ImportedKey(
                alias,
                new KeyPair(originalCert.getPublicKey(), originalPrivateKey),
                keystoreBacked);
    }

    public static byte[] drain(InputStream in) throws IOException {
        ByteArrayOutputStream result = new ByteArrayOutputStream();
        byte[] buffer = new byte[16 * 1024];
        int chunkSize;
        while ((chunkSize = in.read(buffer)) != -1) {
            result.write(buffer, 0, chunkSize);
        }
        return result.toByteArray();
    }

    public static KeyProtection.Builder buildUpon(KeyProtection params) {
        return buildUponInternal(params, null);
    }

    public static KeyProtection.Builder buildUpon(KeyProtection params, int newPurposes) {
        return buildUponInternal(params, newPurposes);
    }

    public static KeyProtection.Builder buildUpon(
            KeyProtection.Builder builder) {
        return buildUponInternal(builder.build(), null);
    }

    public static KeyProtection.Builder buildUpon(
            KeyProtection.Builder builder, int newPurposes) {
        return buildUponInternal(builder.build(), newPurposes);
    }

    private static KeyProtection.Builder buildUponInternal(
            KeyProtection spec, Integer newPurposes) {
        int purposes = (newPurposes == null) ? spec.getPurposes() : newPurposes;
        KeyProtection.Builder result = new KeyProtection.Builder(purposes);
        result.setBlockModes(spec.getBlockModes());
        if (spec.isDigestsSpecified()) {
            result.setDigests(spec.getDigests());
        }
        result.setEncryptionPaddings(spec.getEncryptionPaddings());
        result.setSignaturePaddings(spec.getSignaturePaddings());
        result.setKeyValidityStart(spec.getKeyValidityStart());
        result.setKeyValidityForOriginationEnd(spec.getKeyValidityForOriginationEnd());
        result.setKeyValidityForConsumptionEnd(spec.getKeyValidityForConsumptionEnd());
        result.setRandomizedEncryptionRequired(spec.isRandomizedEncryptionRequired());
        result.setUserAuthenticationRequired(spec.isUserAuthenticationRequired());
        result.setUserAuthenticationValidityDurationSeconds(
                spec.getUserAuthenticationValidityDurationSeconds());
        result.setBoundToSpecificSecureUserId(spec.getBoundToSpecificSecureUserId());
        return result;
    }

    public static KeyGenParameterSpec.Builder buildUpon(KeyGenParameterSpec spec) {
        return buildUponInternal(spec, null);
    }

    public static KeyGenParameterSpec.Builder buildUpon(KeyGenParameterSpec spec, int newPurposes) {
        return buildUponInternal(spec, newPurposes);
    }

    public static KeyGenParameterSpec.Builder buildUpon(
            KeyGenParameterSpec.Builder builder) {
        return buildUponInternal(builder.build(), null);
    }

    public static KeyGenParameterSpec.Builder buildUpon(
            KeyGenParameterSpec.Builder builder, int newPurposes) {
        return buildUponInternal(builder.build(), newPurposes);
    }

    private static KeyGenParameterSpec.Builder buildUponInternal(
            KeyGenParameterSpec spec, Integer newPurposes) {
        int purposes = (newPurposes == null) ? spec.getPurposes() : newPurposes;
        KeyGenParameterSpec.Builder result =
                new KeyGenParameterSpec.Builder(spec.getKeystoreAlias(), purposes);
        if (spec.getKeySize() >= 0) {
            result.setKeySize(spec.getKeySize());
        }
        if (spec.getAlgorithmParameterSpec() != null) {
            result.setAlgorithmParameterSpec(spec.getAlgorithmParameterSpec());
        }
        result.setCertificateNotBefore(spec.getCertificateNotBefore());
        result.setCertificateNotAfter(spec.getCertificateNotAfter());
        result.setCertificateSerialNumber(spec.getCertificateSerialNumber());
        result.setCertificateSubject(spec.getCertificateSubject());
        result.setBlockModes(spec.getBlockModes());
        if (spec.isDigestsSpecified()) {
            result.setDigests(spec.getDigests());
        }
        result.setEncryptionPaddings(spec.getEncryptionPaddings());
        result.setSignaturePaddings(spec.getSignaturePaddings());
        result.setKeyValidityStart(spec.getKeyValidityStart());
        result.setKeyValidityForOriginationEnd(spec.getKeyValidityForOriginationEnd());
        result.setKeyValidityForConsumptionEnd(spec.getKeyValidityForConsumptionEnd());
        result.setRandomizedEncryptionRequired(spec.isRandomizedEncryptionRequired());
        result.setUserAuthenticationRequired(spec.isUserAuthenticationRequired());
        result.setUserAuthenticationValidityDurationSeconds(
                spec.getUserAuthenticationValidityDurationSeconds());
        return result;
    }

    public static KeyPair getKeyPairForKeyAlgorithm(String keyAlgorithm, Iterable<KeyPair> keyPairs) {
        for (KeyPair keyPair : keyPairs) {
            if (keyAlgorithm.equalsIgnoreCase(keyPair.getPublic().getAlgorithm())) {
                return keyPair;
            }
        }
        throw new IllegalArgumentException(""No KeyPair for key algorithm "" + keyAlgorithm);
    }

    public static Key getKeyForKeyAlgorithm(String keyAlgorithm, Iterable<? extends Key> keys) {
        for (Key key : keys) {
            if (keyAlgorithm.equalsIgnoreCase(key.getAlgorithm())) {
                return key;
            }
        }
        throw new IllegalArgumentException(""No Key for key algorithm "" + keyAlgorithm);
    }

    public static byte[] generateLargeKatMsg(byte[] seed, int msgSizeBytes) throws Exception {
        byte[] result = new byte[msgSizeBytes];
        MessageDigest digest = MessageDigest.getInstance(""SHA-512"");
        int resultOffset = 0;
        int resultRemaining = msgSizeBytes;
        while (resultRemaining > 0) {
            seed = digest.digest(seed);
            int chunkSize = Math.min(seed.length, resultRemaining);
            System.arraycopy(seed, 0, result, resultOffset, chunkSize);
            resultOffset += chunkSize;
            resultRemaining -= chunkSize;
        }
        return result;
    }

    public static byte[] leftPadWithZeroBytes(byte[] array, int length) {
        if (array.length >= length) {
            return array;
        }
        byte[] result = new byte[length];
        System.arraycopy(array, 0, result, result.length - array.length, array.length);
        return result;
    }

    public static boolean contains(int[] array, int value) {
        for (int element : array) {
            if (element == value) {
                return true;
            }
        }
        return false;
    }

    public static boolean isHmacAlgorithm(String algorithm) {
        return algorithm.toUpperCase(Locale.US).startsWith(""HMAC"");
    }

    public static String getHmacAlgorithmDigest(String algorithm) {
        String algorithmUpperCase = algorithm.toUpperCase(Locale.US);
        if (!algorithmUpperCase.startsWith(""HMAC"")) {
            return null;
        }
        String result = algorithmUpperCase.substring(""HMAC"".length());
        if (result.startsWith(""SHA"")) {
            result = ""SHA-"" + result.substring(""SHA"".length());
        }
        return result;
    }

    public static String getKeyAlgorithm(String transformation) {
        try {
            return getCipherKeyAlgorithm(transformation);
        } catch (IllegalArgumentException e) {

        }
        try {
            return getSignatureAlgorithmKeyAlgorithm(transformation);
        } catch (IllegalArgumentException e) {

        }
        String transformationUpperCase = transformation.toUpperCase(Locale.US);
        if (transformationUpperCase.equals(""EC"")) {
            return KeyProperties.KEY_ALGORITHM_EC;
        }
        if (transformationUpperCase.equals(""RSA"")) {
            return KeyProperties.KEY_ALGORITHM_RSA;
        }
        if (transformationUpperCase.equals(""DESEDE"")) {
            return KeyProperties.KEY_ALGORITHM_3DES;
        }
        if (transformationUpperCase.equals(""AES"")) {
            return KeyProperties.KEY_ALGORITHM_AES;
        }
        if (transformationUpperCase.startsWith(""HMAC"")) {
            if (transformation.endsWith(""SHA1"")) {
                return KeyProperties.KEY_ALGORITHM_HMAC_SHA1;
            } else if (transformation.endsWith(""SHA224"")) {
                return KeyProperties.KEY_ALGORITHM_HMAC_SHA224;
            } else if (transformation.endsWith(""SHA256"")) {
                return KeyProperties.KEY_ALGORITHM_HMAC_SHA256;
            } else if (transformation.endsWith(""SHA384"")) {
                return KeyProperties.KEY_ALGORITHM_HMAC_SHA384;
            } else if (transformation.endsWith(""SHA512"")) {
                return KeyProperties.KEY_ALGORITHM_HMAC_SHA512;
            }
        }
        throw new IllegalArgumentException(""Unsupported transformation: "" + transformation);
    }

    public static String getCipherKeyAlgorithm(String transformation) {
        String transformationUpperCase = transformation.toUpperCase(Locale.US);
        if (transformationUpperCase.startsWith(""AES/"")) {
            return KeyProperties.KEY_ALGORITHM_AES;
        } else if (transformationUpperCase.startsWith(""DESEDE/"")) {
            return KeyProperties.KEY_ALGORITHM_3DES;
        } else if (transformationUpperCase.startsWith(""RSA/"")) {
            return KeyProperties.KEY_ALGORITHM_RSA;
        } else {
            throw new IllegalArgumentException(""Unsupported transformation: "" + transformation);
        }
    }

    public static boolean isCipherSymmetric(String transformation) {
        String transformationUpperCase = transformation.toUpperCase(Locale.US);
        if (transformationUpperCase.startsWith(""AES/"") || transformationUpperCase.startsWith(
                ""DESEDE/"")) {
            return true;
        } else if (transformationUpperCase.startsWith(""RSA/"")) {
            return false;
        } else {
            throw new IllegalArgumentException(""YYZ: Unsupported transformation: "" + transformation);
        }
    }

    public static String getCipherDigest(String transformation) {
        String transformationUpperCase = transformation.toUpperCase(Locale.US);
        if (transformationUpperCase.contains(""/OAEP"")) {
            if (transformationUpperCase.endsWith(""/OAEPPADDING"")) {
                return KeyProperties.DIGEST_SHA1;
            } else if (transformationUpperCase.endsWith(
                    ""/OAEPWITHSHA-1ANDMGF1PADDING"")) {
                return KeyProperties.DIGEST_SHA1;
            } else if (transformationUpperCase.endsWith(
                    ""/OAEPWITHSHA-224ANDMGF1PADDING"")) {
                return KeyProperties.DIGEST_SHA224;
            } else if (transformationUpperCase.endsWith(
                    ""/OAEPWITHSHA-256ANDMGF1PADDING"")) {
                return KeyProperties.DIGEST_SHA256;
            } else if (transformationUpperCase.endsWith(
                    ""/OAEPWITHSHA-384ANDMGF1PADDING"")) {
                return KeyProperties.DIGEST_SHA384;
            } else if (transformationUpperCase.endsWith(
                    ""/OAEPWITHSHA-512ANDMGF1PADDING"")) {
                return KeyProperties.DIGEST_SHA512;
            } else {
                throw new RuntimeException(""Unsupported OAEP padding scheme: ""
                        + transformation);
            }
        } else {
            return null;
        }
    }

    public static String getCipherEncryptionPadding(String transformation) {
        String transformationUpperCase = transformation.toUpperCase(Locale.US);
        if (transformationUpperCase.endsWith(""/NOPADDING"")) {
            return KeyProperties.ENCRYPTION_PADDING_NONE;
        } else if (transformationUpperCase.endsWith(""/PKCS7PADDING"")) {
            return KeyProperties.ENCRYPTION_PADDING_PKCS7;
        } else if (transformationUpperCase.endsWith(""/PKCS1PADDING"")) {
            return KeyProperties.ENCRYPTION_PADDING_RSA_PKCS1;
        } else if (transformationUpperCase.split(""/"")[2].startsWith(""OAEP"")) {
            return KeyProperties.ENCRYPTION_PADDING_RSA_OAEP;
        } else {
            throw new IllegalArgumentException(""Unsupported transformation: "" + transformation);
        }
    }

    public static String getCipherBlockMode(String transformation) {
        return transformation.split(""/"")[1].toUpperCase(Locale.US);
    }

    public static String getSignatureAlgorithmDigest(String algorithm) {
        String algorithmUpperCase = algorithm.toUpperCase(Locale.US);
        int withIndex = algorithmUpperCase.indexOf(""WITH"");
        if (withIndex == -1) {
            throw new IllegalArgumentException(""Unsupported algorithm: "" + algorithm);
        }
        String digest = algorithmUpperCase.substring(0, withIndex);
        if (digest.startsWith(""SHA"")) {
            digest = ""SHA-"" + digest.substring(""SHA"".length());
        }
        return digest;
    }

    public static String getSignatureAlgorithmPadding(String algorithm) {
        String algorithmUpperCase = algorithm.toUpperCase(Locale.US);
        if (algorithmUpperCase.endsWith(""WITHECDSA"")) {
            return null;
        } else if (algorithmUpperCase.endsWith(""WITHRSA"")) {
            return KeyProperties.SIGNATURE_PADDING_RSA_PKCS1;
        } else if (algorithmUpperCase.endsWith(""WITHRSA/PSS"")) {
            return KeyProperties.SIGNATURE_PADDING_RSA_PSS;
        } else {
            throw new IllegalArgumentException(""Unsupported algorithm: "" + algorithm);
        }
    }

    public static String getSignatureAlgorithmKeyAlgorithm(String algorithm) {
        String algorithmUpperCase = algorithm.toUpperCase(Locale.US);
        if (algorithmUpperCase.endsWith(""WITHECDSA"")) {
            return KeyProperties.KEY_ALGORITHM_EC;
        } else if ((algorithmUpperCase.endsWith(""WITHRSA""))
                || (algorithmUpperCase.endsWith(""WITHRSA/PSS""))) {
            return KeyProperties.KEY_ALGORITHM_RSA;
        } else {
            throw new IllegalArgumentException(""Unsupported algorithm: "" + algorithm);
        }
    }

    public static boolean isKeyLongEnoughForSignatureAlgorithm(String algorithm, int keySizeBits) {
        String keyAlgorithm = getSignatureAlgorithmKeyAlgorithm(algorithm);
        if (KeyProperties.KEY_ALGORITHM_EC.equalsIgnoreCase(keyAlgorithm)) {
            // No length restrictions for ECDSA
            return true;
        } else if (KeyProperties.KEY_ALGORITHM_RSA.equalsIgnoreCase(keyAlgorithm)) {
            String digest = getSignatureAlgorithmDigest(algorithm);
            int digestOutputSizeBits = getDigestOutputSizeBits(digest);
            if (digestOutputSizeBits == -1) {
                // No digesting -- assume the key is long enough for the message
                return true;
            }
            String paddingScheme = getSignatureAlgorithmPadding(algorithm);
            int paddingOverheadBytes;
            if (KeyProperties.SIGNATURE_PADDING_RSA_PKCS1.equalsIgnoreCase(paddingScheme)) {
                paddingOverheadBytes = 30;
            } else if (KeyProperties.SIGNATURE_PADDING_RSA_PSS.equalsIgnoreCase(paddingScheme)) {
                int saltSizeBytes = (digestOutputSizeBits + 7) / 8;
                paddingOverheadBytes = saltSizeBytes + 1;
            } else {
                throw new IllegalArgumentException(
                        ""Unsupported signature padding scheme: "" + paddingScheme);
            }
            int minKeySizeBytes = paddingOverheadBytes + (digestOutputSizeBits + 7) / 8 + 1;
            int keySizeBytes = keySizeBits / 8;
            return keySizeBytes >= minKeySizeBytes;
        } else {
            throw new IllegalArgumentException(""Unsupported key algorithm: "" + keyAlgorithm);
        }
    }

    public static boolean isKeyLongEnoughForSignatureAlgorithm(String algorithm, Key key) {
        return isKeyLongEnoughForSignatureAlgorithm(algorithm, getKeySizeBits(key));
    }

    public static int getMaxSupportedPlaintextInputSizeBytes(String transformation, int keySizeBits) {
        String encryptionPadding = getCipherEncryptionPadding(transformation);
        int modulusSizeBytes = (keySizeBits + 7) / 8;
        if (KeyProperties.ENCRYPTION_PADDING_NONE.equalsIgnoreCase(encryptionPadding)) {
            return modulusSizeBytes - 1;
        } else if (KeyProperties.ENCRYPTION_PADDING_RSA_PKCS1.equalsIgnoreCase(
                encryptionPadding)) {
            return modulusSizeBytes - 11;
        } else if (KeyProperties.ENCRYPTION_PADDING_RSA_OAEP.equalsIgnoreCase(
                encryptionPadding)) {
            String digest = getCipherDigest(transformation);
            int digestOutputSizeBytes = (getDigestOutputSizeBits(digest) + 7) / 8;
            return modulusSizeBytes - 2 * digestOutputSizeBytes - 2;
        } else {
            throw new IllegalArgumentException(
                    ""Unsupported encryption padding scheme: "" + encryptionPadding);
        }

    }

    public static int getMaxSupportedPlaintextInputSizeBytes(String transformation, Key key) {
        String keyAlgorithm = getCipherKeyAlgorithm(transformation);
        if (KeyProperties.KEY_ALGORITHM_AES.equalsIgnoreCase(keyAlgorithm)
                || KeyProperties.KEY_ALGORITHM_3DES.equalsIgnoreCase(keyAlgorithm)) {
            return Integer.MAX_VALUE;
        } else if (KeyProperties.KEY_ALGORITHM_RSA.equalsIgnoreCase(keyAlgorithm)) {
            return getMaxSupportedPlaintextInputSizeBytes(transformation, getKeySizeBits(key));
        } else {
            throw new IllegalArgumentException(""Unsupported key algorithm: "" + keyAlgorithm);
        }
    }

    public static int getDigestOutputSizeBits(String digest) {
        if (KeyProperties.DIGEST_NONE.equals(digest)) {
            return -1;
        } else if (KeyProperties.DIGEST_MD5.equals(digest)) {
            return 128;
        } else if (KeyProperties.DIGEST_SHA1.equals(digest)) {
            return 160;
        } else if (KeyProperties.DIGEST_SHA224.equals(digest)) {
            return 224;
        } else if (KeyProperties.DIGEST_SHA256.equals(digest)) {
            return 256;
        } else if (KeyProperties.DIGEST_SHA384.equals(digest)) {
            return 384;
        } else if (KeyProperties.DIGEST_SHA512.equals(digest)) {
            return 512;
        } else {
            throw new IllegalArgumentException(""Unsupported digest: "" + digest);
        }
    }

    public static byte[] concat(byte[] arr1, byte[] arr2) {
        return concat(arr1, 0, (arr1 != null) ? arr1.length : 0,
                arr2, 0, (arr2 != null) ? arr2.length : 0);
    }

    public static byte[] concat(byte[] arr1, int offset1, int len1,
            byte[] arr2, int offset2, int len2) {
        if (len1 == 0) {
            return subarray(arr2, offset2, len2);
        } else if (len2 == 0) {
            return subarray(arr1, offset1, len1);
        }
        byte[] result = new byte[len1 + len2];
        if (len1 > 0) {
            System.arraycopy(arr1, offset1, result, 0, len1);
        }
        if (len2 > 0) {
            System.arraycopy(arr2, offset2, result, len1, len2);
        }
        return result;
    }

    public static byte[] subarray(byte[] arr, int offset, int len) {
        if (len == 0) {
            return EmptyArray.BYTE;
        }
        if ((offset == 0) && (arr.length == len)) {
            return arr;
        }
        byte[] result = new byte[len];
        System.arraycopy(arr, offset, result, 0, len);
        return result;
    }

    public static KeyProtection getMinimalWorkingImportParametersForSigningingWith(
            String signatureAlgorithm) {
        String keyAlgorithm = getSignatureAlgorithmKeyAlgorithm(signatureAlgorithm);
        String digest = getSignatureAlgorithmDigest(signatureAlgorithm);
        if (KeyProperties.KEY_ALGORITHM_EC.equalsIgnoreCase(keyAlgorithm)) {
            return new KeyProtection.Builder(KeyProperties.PURPOSE_SIGN)
                    .setDigests(digest)
                    .build();
        } else if (KeyProperties.KEY_ALGORITHM_RSA.equalsIgnoreCase(keyAlgorithm)) {
            String padding = getSignatureAlgorithmPadding(signatureAlgorithm);
            return new KeyProtection.Builder(KeyProperties.PURPOSE_SIGN)
                    .setDigests(digest)
                    .setSignaturePaddings(padding)
                    .build();
        } else {
            throw new IllegalArgumentException(
                    ""Unsupported signature algorithm: "" + signatureAlgorithm);
        }
    }

    public static KeyProtection getMinimalWorkingImportParametersWithLimitedUsageForSigningingWith(
            String signatureAlgorithm, int maxUsageCount) {
        String keyAlgorithm = getSignatureAlgorithmKeyAlgorithm(signatureAlgorithm);
        String digest = getSignatureAlgorithmDigest(signatureAlgorithm);
        if (KeyProperties.KEY_ALGORITHM_EC.equalsIgnoreCase(keyAlgorithm)) {
            return new KeyProtection.Builder(KeyProperties.PURPOSE_SIGN)
                    .setDigests(digest)
                    .setMaxUsageCount(maxUsageCount)
                    .build();
        } else if (KeyProperties.KEY_ALGORITHM_RSA.equalsIgnoreCase(keyAlgorithm)) {
            String padding = getSignatureAlgorithmPadding(signatureAlgorithm);
            return new KeyProtection.Builder(KeyProperties.PURPOSE_SIGN)
                    .setDigests(digest)
                    .setSignaturePaddings(padding)
                    .setMaxUsageCount(maxUsageCount)
                    .build();
        } else {
            throw new IllegalArgumentException(
                    ""Unsupported signature algorithm: "" + signatureAlgorithm);
        }
    }

    public static KeyProtection getMinimalWorkingImportParametersForCipheringWith(
            String transformation, int purposes) {
        return getMinimalWorkingImportParametersForCipheringWith(transformation, purposes, false);
    }

    public static KeyProtection getMinimalWorkingImportParametersForCipheringWith(
            String transformation, int purposes, boolean ivProvidedWhenEncrypting) {
        return getMinimalWorkingImportParametersForCipheringWith(transformation, purposes,
            ivProvidedWhenEncrypting, false, false);
    }

    public static KeyProtection getMinimalWorkingImportParametersForCipheringWith(
            String transformation, int purposes, boolean ivProvidedWhenEncrypting,
            boolean isUnlockedDeviceRequired, boolean isUserAuthRequired) {
        String keyAlgorithm = TestUtils.getCipherKeyAlgorithm(transformation);
        if (KeyProperties.KEY_ALGORITHM_AES.equalsIgnoreCase(keyAlgorithm)
            || KeyProperties.KEY_ALGORITHM_3DES.equalsIgnoreCase(keyAlgorithm)) {
            String encryptionPadding = TestUtils.getCipherEncryptionPadding(transformation);
            String blockMode = TestUtils.getCipherBlockMode(transformation);
            boolean randomizedEncryptionRequired = true;
            if (KeyProperties.BLOCK_MODE_ECB.equalsIgnoreCase(blockMode)) {
                randomizedEncryptionRequired = false;
            } else if ((ivProvidedWhenEncrypting)
                    && ((purposes & KeyProperties.PURPOSE_ENCRYPT) != 0)) {
                randomizedEncryptionRequired = false;
            }
            return new KeyProtection.Builder(
                    purposes)
                    .setBlockModes(blockMode)
                    .setEncryptionPaddings(encryptionPadding)
                    .setRandomizedEncryptionRequired(randomizedEncryptionRequired)
                    .setUnlockedDeviceRequired(isUnlockedDeviceRequired)
                    .setUserAuthenticationRequired(isUserAuthRequired)
                    .setUserAuthenticationValidityDurationSeconds(3600)
                    .build();
        } else if (KeyProperties.KEY_ALGORITHM_RSA.equalsIgnoreCase(keyAlgorithm)) {
            String digest = TestUtils.getCipherDigest(transformation);
            String encryptionPadding = TestUtils.getCipherEncryptionPadding(transformation);
            boolean randomizedEncryptionRequired =
                    !KeyProperties.ENCRYPTION_PADDING_NONE.equalsIgnoreCase(encryptionPadding);
            return new KeyProtection.Builder(
                    purposes)
                    .setDigests((digest != null) ? new String[] {digest} : EmptyArray.STRING)
                    .setEncryptionPaddings(encryptionPadding)
                    .setRandomizedEncryptionRequired(randomizedEncryptionRequired)
                    .setUserAuthenticationRequired(isUserAuthRequired)
                    .setUserAuthenticationValidityDurationSeconds(3600)
                    .setUnlockedDeviceRequired(isUnlockedDeviceRequired)
                    .build();
        } else {
            throw new IllegalArgumentException(""Unsupported key algorithm: "" + keyAlgorithm);
        }
    }

    public static byte[] getBigIntegerMagnitudeBytes(BigInteger value) {
        return removeLeadingZeroByteIfPresent(value.toByteArray());
    }

    private static byte[] removeLeadingZeroByteIfPresent(byte[] value) {
        if ((value.length < 1) || (value[0] != 0)) {
            return value;
        }
        return TestUtils.subarray(value, 1, value.length - 1);
    }

    public static byte[] generateRandomMessage(int messageSize) {
        byte[] message = new byte[messageSize];
        new SecureRandom().nextBytes(message);
        return message;
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.managedprofile.SetPolicyActivity"	"finish"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/ManagedProfile/src/com/android/cts/managedprofile/SetPolicyActivity.java"	""	"public void test/*
 *.
 */
package com.android.cts.managedprofile;

import android.app.Activity;
import android.app.admin.DevicePolicyManager;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.os.Process;
import android.util.Log;

/**
 * Simple activity that adds or clears a user restriction depending on the value of the extras.
 */
public class SetPolicyActivity extends Activity {

    private static final String TAG = SetPolicyActivity.class.getName();

    private static final String EXTRA_RESTRICTION_KEY = ""extra-restriction-key"";
    private static final String EXTRA_PACKAGE_NAME = ""extra-package-name"";
    private static final String EXTRA_COMMAND = ""extra-command"";

    private static final String ADD_RESTRICTION_COMMAND = ""add-restriction"";
    private static final String CLEAR_RESTRICTION_COMMAND = ""clear-restriction"";
    private static final String ADD_CROSS_PROFILE_WIDGET_COMMAND = ""add-cross-profile-widget"";
    private static final String REMOVE_CROSS_PROFILE_WIDGET_COMMAND = ""remove-cross-profile-widget"";

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        handleIntent(getIntent());
    }

    // Overriding this method in case another intent is sent to this activity before finish()
    @Override
    public void onNewIntent(Intent intent) {
        super.onNewIntent(intent);
        handleIntent(intent);
    }

    private void handleIntent(Intent intent) {
        DevicePolicyManager dpm = (DevicePolicyManager)
                getSystemService(Context.DEVICE_POLICY_SERVICE);
        String command = intent.getStringExtra(EXTRA_COMMAND);
        Log.i(TAG, ""Command: \"""" + command);

        if (ADD_RESTRICTION_COMMAND.equals(command)) {
            String restrictionKey = intent.getStringExtra(EXTRA_RESTRICTION_KEY);
            dpm.addUserRestriction(BaseManagedProfileTest.ADMIN_RECEIVER_COMPONENT, restrictionKey);
            Log.i(TAG, ""Added user restriction "" + restrictionKey
                    + "" for user "" + Process.myUserHandle());
        } else if (CLEAR_RESTRICTION_COMMAND.equals(command)) {
            String restrictionKey = intent.getStringExtra(EXTRA_RESTRICTION_KEY);
            dpm.clearUserRestriction(
                    BaseManagedProfileTest.ADMIN_RECEIVER_COMPONENT, restrictionKey);
            Log.i(TAG, ""Cleared user restriction "" + restrictionKey
                    + "" for user "" + Process.myUserHandle());
        } else if (ADD_CROSS_PROFILE_WIDGET_COMMAND.equals(command)) {
            String packageName = intent.getStringExtra(EXTRA_PACKAGE_NAME);
            dpm.addCrossProfileWidgetProvider(BaseManagedProfileTest.ADMIN_RECEIVER_COMPONENT,
                    packageName);
            Log.i(TAG, ""Added cross-profile widget provider for package:"" + packageName
                    + "" for user "" + Process.myUserHandle());
        } else if (REMOVE_CROSS_PROFILE_WIDGET_COMMAND.equals(command)) {
            String packageName = intent.getStringExtra(EXTRA_PACKAGE_NAME);
            dpm.removeCrossProfileWidgetProvider(BaseManagedProfileTest.ADMIN_RECEIVER_COMPONENT,
                    packageName);
            Log.i(TAG, ""Removed cross-profile widget provider for package:"" + packageName
                    + "" for user "" + Process.myUserHandle());
        } else {
            Log.e(TAG, ""Invalid command: "" + command);
        }
    }

}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.customizationapp.CustomizationTest"	"testSetWallpaper_disallowed"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/CustomizationApp/src/com/android/cts/customizationapp/CustomizationTest.java"	""	"public void testSetWallpaper_disallowed() throws Exception {
        final WallpaperManager wallpaperManager = WallpaperManager.getInstance(mContext);
        final Bitmap originalWallpaper = BitmapUtils.getWallpaperBitmap(mContext);
        final Bitmap referenceWallpaper = BitmapUtils.generateRandomBitmap(97, 73);
        final UserManager userManager =
                (UserManager) mContext.getSystemService(Context.USER_SERVICE);
        assertTrue(userManager.hasUserRestriction(UserManager.DISALLOW_SET_WALLPAPER));

        // Checking setBitmap() method.
        wallpaperManager.setBitmap(referenceWallpaper);
        Thread.sleep(WAITING_TIME_MS);
        Bitmap newWallpaper = BitmapUtils.getWallpaperBitmap(mContext);
        assertTrue(BitmapUtils.compareBitmaps(newWallpaper, originalWallpaper));

        // Checking setStream() method.
        wallpaperManager.setStream(BitmapUtils.bitmapToInputStream(referenceWallpaper));
        Thread.sleep(WAITING_TIME_MS);
        newWallpaper = BitmapUtils.getWallpaperBitmap(mContext);
        assertTrue(BitmapUtils.compareBitmaps(newWallpaper, originalWallpaper));

        // Checking setResource() method.
        wallpaperManager.setResource(R.raw.wallpaper);
        Thread.sleep(WAITING_TIME_MS);
        newWallpaper = BitmapUtils.getWallpaperBitmap(mContext);
        assertTrue(BitmapUtils.compareBitmaps(newWallpaper, originalWallpaper));
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.provider.cts.calendar.CalendarTest"	"testBulkUpdate"	"CtsCalendarProviderTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/calendarprovider/src/android/provider/cts/calendar/CalendarTest.java"	""	"public void testBulkUpdate() {
        String account = ""bup_account"";
        int seed = 0;

        // Clean up just in case
        CalendarHelper.deleteCalendarByAccount(mContentResolver, account);

        // Create calendar
        long calendarId = createAndVerifyCalendar(account, seed++, null);
        String calendarIdStr = String.valueOf(calendarId);

        // Create events
        ContentValues eventValues;
        eventValues = EventHelper.getNewEventValues(account, seed++, calendarId, true);
        long eventId1 = createAndVerifyEvent(account, seed, calendarId, true, eventValues);

        eventValues = EventHelper.getNewEventValues(account, seed++, calendarId, true);
        long eventId2 = createAndVerifyEvent(account, seed, calendarId, true, eventValues);

        // Update the ""description"" field in all events in this calendar.
        String newDescription = ""bulk edit"";
        ContentValues updateValues = new ContentValues();
        updateValues.put(Events.DESCRIPTION, newDescription);

        // Must be sync adapter to do a bulk update.
        Uri uri = asSyncAdapter(Events.CONTENT_URI, account, CTS_TEST_TYPE);
        int count = mContentResolver.update(uri, updateValues, SQL_WHERE_CALENDAR_ID,
                new String[] { calendarIdStr });

        // Check to see if the changes went through.
        Uri eventUri = Events.CONTENT_URI;
        Cursor c = mContentResolver.query(eventUri, new String[] { Events.DESCRIPTION },
                SQL_WHERE_CALENDAR_ID, new String[] { calendarIdStr }, null);
        assertEquals(2, c.getCount());
        while (c.moveToNext()) {
            assertEquals(newDescription, c.getString(0));
        }
        c.close();

        // delete the calendar
        removeAndVerifyCalendar(account, calendarId);
    }

    /**
     * Tests the content provider's enforcement of restrictions on who is allowed to modify
     * specific columns in a Calendar.
     * <p>
     * This attempts to create a new row in the Calendar table, specifying one restricted
     * column at a time.
     */
    @MediumTest"	""	""	"restricted restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceowner.SensorToggleRestrictionTest"	"testCameraToggle_RestrictionSet_CannotChangeSensorPrivacy"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceOwner/src/com/android/cts/deviceowner/SensorToggleRestrictionTest.java"	""	"public void testCameraToggle_RestrictionSet_CannotChangeSensorPrivacy() {
        if (!mSensorPrivacyManager.supportsSensorToggle(SensorPrivacyManager.Sensors.CAMERA)) {
            return;
        }
        assertFalse(""Camera sensor privacy should be off by default"",
                ShellIdentityUtils.invokeMethodWithShellPermissions(mSensorPrivacyManager,
                        m -> m.isSensorPrivacyEnabled(SensorPrivacyManager.Sensors.CAMERA)));

        mDevicePolicyManager.addUserRestriction(getWho(), UserManager.DISALLOW_CAMERA_TOGGLE);
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mSensorPrivacyManager,
                m -> m.setSensorPrivacy(OTHER, SensorPrivacyManager.Sensors.CAMERA, true));

        assertFalse(""Camera sensor privacy should not be enabled given admin restriction"",
                ShellIdentityUtils.invokeMethodWithShellPermissions(mSensorPrivacyManager,
                        m -> m.isSensorPrivacyEnabled(SensorPrivacyManager.Sensors.CAMERA)));
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceowner.SensorToggleRestrictionTest"	"testMicrophoneToggle_RestrictionSet_CannotChangeSensorPrivacy"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceOwner/src/com/android/cts/deviceowner/SensorToggleRestrictionTest.java"	""	"public void testMicrophoneToggle_RestrictionSet_CannotChangeSensorPrivacy() {
        if (!mSensorPrivacyManager.supportsSensorToggle(SensorPrivacyManager.Sensors.MICROPHONE)) {
            return;
        }
        assertFalse(""Microphone sensor privacy should be off by default"",
                ShellIdentityUtils.invokeMethodWithShellPermissions(mSensorPrivacyManager,
                        m -> m.isSensorPrivacyEnabled(SensorPrivacyManager.Sensors.MICROPHONE)));

        mDevicePolicyManager.addUserRestriction(getWho(), UserManager.DISALLOW_MICROPHONE_TOGGLE);
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mSensorPrivacyManager,
                m -> m.setSensorPrivacy(OTHER, SensorPrivacyManager.Sensors.MICROPHONE, true));

        assertFalse(""Microphone sensor privacy should not be enabled given admin restriction"",
                ShellIdentityUtils.invokeMethodWithShellPermissions(mSensorPrivacyManager,
                        m -> m.isSensorPrivacyEnabled(SensorPrivacyManager.Sensors.MICROPHONE)));
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceowner.SensorToggleRestrictionTest"	"testCameraToggle_RestrictionSet_ResetSensorPrivacy"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceOwner/src/com/android/cts/deviceowner/SensorToggleRestrictionTest.java"	""	"public void testCameraToggle_RestrictionSet_ResetSensorPrivacy() {
        if (!mSensorPrivacyManager.supportsSensorToggle(SensorPrivacyManager.Sensors.CAMERA)) {
            return;
        }
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mSensorPrivacyManager,
                m -> m.setSensorPrivacy(OTHER, SensorPrivacyManager.Sensors.CAMERA, true));

        mDevicePolicyManager.addUserRestriction(getWho(), UserManager.DISALLOW_CAMERA_TOGGLE);

        long deadline = System.nanoTime() + RESTRICTION_WAITING_TIMEOUT_NANO;
        while (System.nanoTime() < deadline) {
            if (!ShellIdentityUtils.invokeMethodWithShellPermissions(mSensorPrivacyManager,
                    m -> m.isSensorPrivacyEnabled(SensorPrivacyManager.Sensors.CAMERA))) {
                return;
            }
        }
        fail(""Camera sensor privacy did not get reset in time"");
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceowner.SensorToggleRestrictionTest"	"testMicrophoneToggle_RestrictionSet_ResetSensorPrivacy"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceOwner/src/com/android/cts/deviceowner/SensorToggleRestrictionTest.java"	""	"public void testMicrophoneToggle_RestrictionSet_ResetSensorPrivacy() {
        if (!mSensorPrivacyManager.supportsSensorToggle(SensorPrivacyManager.Sensors.MICROPHONE)) {
            return;
        }
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mSensorPrivacyManager,
                m -> m.setSensorPrivacy(OTHER, SensorPrivacyManager.Sensors.MICROPHONE, true));

        mDevicePolicyManager.addUserRestriction(getWho(), UserManager.DISALLOW_MICROPHONE_TOGGLE);

        long deadline = System.nanoTime() + RESTRICTION_WAITING_TIMEOUT_NANO;
        while (System.nanoTime() < deadline) {
            if (!ShellIdentityUtils.invokeMethodWithShellPermissions(mSensorPrivacyManager,
                    m -> m.isSensorPrivacyEnabled(SensorPrivacyManager.Sensors.MICROPHONE))) {
                return;
            }
        }
        fail(""Microphone sensor privacy did not get reset in time"");
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceowner.PrivateDnsPolicyTest"	"testDisallowPrivateDnsConfigurationRestriction"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceOwner/src/com/android/cts/deviceowner/PrivateDnsPolicyTest.java"	""	"public void testDisallowPrivateDnsConfigurationRestriction() {
        setUserRestriction(UserManager.DISALLOW_CONFIG_PRIVATE_DNS, true);
        assertThat(mUserManager.hasUserRestriction(
                UserManager.DISALLOW_CONFIG_PRIVATE_DNS)).isTrue();
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceowner.PrivateDnsPolicyTest"	"testClearDisallowPrivateDnsConfigurationRestriction"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceOwner/src/com/android/cts/deviceowner/PrivateDnsPolicyTest.java"	""	"public void testClearDisallowPrivateDnsConfigurationRestriction() {
        setUserRestriction(UserManager.DISALLOW_CONFIG_PRIVATE_DNS, false);
        assertThat(mUserManager.hasUserRestriction(
                UserManager.DISALLOW_CONFIG_PRIVATE_DNS)).isFalse();
    }

    private void setUserRestriction(String restriction, boolean add) {
        if (add) {
            mDevicePolicyManager.addUserRestriction(getWho(), restriction);
        } else {
            mDevicePolicyManager.clearUserRestriction(getWho(), restriction);
        }
    }

    /**
     * Call DevicePolicyManager.setGlobalPrivateDnsModeOpportunistic, expecting the result code
     * expectedResult.
     */
    private void callSetGlobalPrivateDnsOpportunisticModeExpectingResult(int expectedResult) {
        int resultCode = mDevicePolicyManager.setGlobalPrivateDnsModeOpportunistic(getWho());

        assertEquals(
                String.format(
                        ""Call to setGlobalPrivateDnsModeOpportunistic ""
                                + ""should have produced result %d, but was %d"",
                        expectedResult, resultCode),
                expectedResult, resultCode);
    }

    /**
     * Call DevicePolicyManager.setGlobalPrivateDnsModeSpecifiedHost with the given host, expecting
     * the result code expectedResult.
     */
    private void callSetGlobalPrivateDnsHostModeExpectingResult(String privateDnsHost,
            int expectedResult) {
        int resultCode = mDevicePolicyManager.setGlobalPrivateDnsModeSpecifiedHost(
                getWho(), privateDnsHost);

        assertEquals(
                String.format(
                        ""Call to setGlobalPrivateDnsModeSpecifiedHost with host %s ""
                                + ""should have produced result %d, but was %d"",
                        privateDnsHost, expectedResult, resultCode),
                expectedResult, resultCode);
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceowner.PrivateDnsPolicyTest"	"testCanSetModeDespiteUserRestriction"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceOwner/src/com/android/cts/deviceowner/PrivateDnsPolicyTest.java"	""	"public void testCanSetModeDespiteUserRestriction() {
        // First set a specific host and assert that applied.
        callSetGlobalPrivateDnsHostModeExpectingResult(
                VALID_PRIVATE_DNS_HOST,
                DevicePolicyManager.PRIVATE_DNS_SET_NO_ERROR);
        assertThat(
                mDevicePolicyManager.getGlobalPrivateDnsMode(getWho())).isEqualTo(
                PRIVATE_DNS_MODE_PROVIDER_HOSTNAME);

        // Set a user restriction
        setUserRestriction(UserManager.DISALLOW_CONFIG_PRIVATE_DNS, true);

        // Next, set the mode to automatic and confirm that has applied.
        callSetGlobalPrivateDnsOpportunisticModeExpectingResult(
                DevicePolicyManager.PRIVATE_DNS_SET_NO_ERROR);

        assertThat(
                mDevicePolicyManager.getGlobalPrivateDnsMode(getWho())).isEqualTo(
                PRIVATE_DNS_MODE_OPPORTUNISTIC);
        assertThat(mDevicePolicyManager.getGlobalPrivateDnsHost(getWho())).isNull();
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"test.java.com.android.queryable.queries.BundleQueryHelperTest"	"isTrue"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/queryable/src/test/java/com/android/queryable/queries/BundleQueryHelperTest.java"	""	"public void matches_noRestrictions_returnsTrue() {
        BundleQueryHelper<Queryable> bundleQueryHelper =
                new BundleQueryHelper<>(mQuery);

        assertThat(bundleQueryHelper.matches(mBundle)).isTrue();
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"test.java.com.android.queryable.queries.BundleQueryHelperTest"	"matches_restrictionOnOneKey_restrictionIsMet_returnsTrue"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/queryable/src/test/java/com/android/queryable/queries/BundleQueryHelperTest.java"	""	"public void matches_restrictionOnOneKey_restrictionIsMet_returnsTrue() {
        mBundle.putString(KEY, STRING_VALUE);
        BundleQueryHelper<Queryable> bundleQueryHelper =
                new BundleQueryHelper<>(mQuery);

        bundleQueryHelper.key(KEY).exists();

        assertThat(bundleQueryHelper.matches(mBundle)).isTrue();
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"test.java.com.android.queryable.queries.BundleQueryHelperTest"	"matches_restrictionOnOneKey_restrictionIsNotMet_returnsFalse"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/queryable/src/test/java/com/android/queryable/queries/BundleQueryHelperTest.java"	""	"public void matches_restrictionOnOneKey_restrictionIsNotMet_returnsFalse() {
        mBundle.putString(KEY, STRING_VALUE);
        BundleQueryHelper<Queryable> bundleQueryHelper =
                new BundleQueryHelper<>(mQuery);

        bundleQueryHelper.key(KEY).doesNotExist();

        assertThat(bundleQueryHelper.matches(mBundle)).isFalse();
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"test.java.com.android.queryable.queries.BundleQueryHelperTest"	"matches_restrictionOnMultipleKeys_oneRestrictionIsNotMet_returnsFalse"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/queryable/src/test/java/com/android/queryable/queries/BundleQueryHelperTest.java"	""	"public void matches_restrictionOnMultipleKeys_oneRestrictionIsNotMet_returnsFalse() {
        mBundle.putString(KEY, STRING_VALUE);
        mBundle.remove(KEY2);
        BundleQueryHelper<Queryable> bundleQueryHelper =
                new BundleQueryHelper<>(mQuery);

        bundleQueryHelper.key(KEY).exists();
        bundleQueryHelper.key(KEY2).exists();

        assertThat(bundleQueryHelper.matches(mBundle)).isFalse();
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"test.java.com.android.queryable.queries.BundleQueryHelperTest"	"matches_restrictionOnNonExistingKey_returnsFalse"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/queryable/src/test/java/com/android/queryable/queries/BundleQueryHelperTest.java"	""	"public void matches_restrictionOnNonExistingKey_returnsFalse() {
        mBundle.remove(KEY);
        BundleQueryHelper<Queryable> bundleQueryHelper =
                new BundleQueryHelper<>(mQuery);

        bundleQueryHelper.key(KEY).stringValue().isEqualTo(STRING_VALUE);

        assertThat(bundleQueryHelper.matches(mBundle)).isFalse();
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.display.cts.DisplayTest"	"testRestrictedFramebufferSize"	"CtsDisplayTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/display/src/android/display/cts/DisplayTest.java"	""	"public void testRestrictedFramebufferSize() {
        PackageManager packageManager = mContext.getPackageManager();
        if (packageManager.hasSystemFeature(FEATURE_LEANBACK)) {
            // TV devices are allowed to restrict their framebuffer size.
            return;
        }

        // Non-TV devices are not allowed by Android CDD to restrict their framebuffer size.
        String width = SystemProperties.get(""ro.surface_flinger.max_graphics_width"");
        assertEquals("""", width);
        String height = SystemProperties.get(""ro.surface_flinger.max_graphics_height"");
        assertEquals("""", height);
    }

    /**
     * Used to force mode changes on a display.
     * <p>
     * Note that due to limitations of the Presentation class, the modes must have the same size
     * otherwise the presentation will be automatically dismissed.
     */
    private static final class TestPresentation extends Presentation {

        private final int mModeId;

        public TestPresentation(Context context, Display display, int modeId) {
            super(context, display);
            mModeId = modeId;
        }

        @Override
        protected void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);

            View content = new View(getContext());
            content.setLayoutParams(new ViewGroup.LayoutParams(
                    ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT));
            content.setBackgroundColor(Color.RED);
            setContentView(content);

            WindowManager.LayoutParams params = getWindow().getAttributes();
            params.preferredDisplayModeId = mModeId;
            params.setTitle(""CtsTestPresentation"");
            getWindow().setAttributes(params);
        }

        @Override
        public void cancel() {
            // Ignore attempts to force cancel the presentation. This is going to happen when we
            // change the mode of the display since doing so will change the display metrics, which
            // Presentations don't yet support. Ignoring it means the Presentation will stay up and
            // the mode will stay changed until dismiss is called, preventing a race condition
            // between the test checking the mode of the display and the mode changing back to the
            // default because the requesting Presentation is no longer showing.
        }
    }

    private Activity launchScreenOnActivity() {
        Class clazz = ScreenOnActivity.class;
        String targetPackage =
                InstrumentationRegistry.getInstrumentation().getContext().getPackageName();
        Instrumentation.ActivityResult result =
                new Instrumentation.ActivityResult(0, new Intent());
        Instrumentation.ActivityMonitor monitor =
                new Instrumentation.ActivityMonitor(clazz.getName(), result, false);
        InstrumentationRegistry.getInstrumentation().addMonitor(monitor);
        launchActivity(targetPackage, clazz, null);
        return monitor.waitForActivity();
    }

    private <T extends Activity> T launchActivity(ActivityTestRule<T> activityRule) {
        final T activity = activityRule.launchActivity(null);
        InstrumentationRegistry.getInstrumentation().waitForIdleSync();
        return activity;
    }

    /**
     * Utility method for launching an activity. Copied from InstrumentationTestCase since
     * InstrumentationRegistry does not provide these APIs anymore.
     *
     * <p>The {@link Intent} used to launch the Activity is:
     *  action = {@link Intent#ACTION_MAIN}
     *  extras = null, unless a custom bundle is provided here
     * All other fields are null or empty.
     *
     * <p><b>NOTE:</b> The parameter <i>pkg</i> must refer to the package identifier of the
     * package hosting the activity to be launched, which is specified in the AndroidManifest.xml
     * file.  This is not necessarily the same as the java package name.
     *
     * @param pkg The package hosting the activity to be launched.
     * @param activityCls The activity class to launch.
     * @param extras Optional extra stuff to pass to the activity.
     * @return The activity, or null if non launched.
     */
    private final <T extends Activity> T launchActivity(
            String pkg,
            Class<T> activityCls,
            Bundle extras) {
        Intent intent = new Intent(Intent.ACTION_MAIN);
        if (extras != null) {
            intent.putExtras(extras);
        }
        return launchActivityWithIntent(pkg, activityCls, intent);
    }

    /**
     * Utility method for launching an activity with a specific Intent.
     *
     * <p><b>NOTE:</b> The parameter <i>pkg</i> must refer to the package identifier of the
     * package hosting the activity to be launched, which is specified in the AndroidManifest.xml
     * file.  This is not necessarily the same as the java package name.
     *
     * @param pkg The package hosting the activity to be launched.
     * @param activityCls The activity class to launch.
     * @param intent The intent to launch with
     * @return The activity, or null if non launched.
     */
    @SuppressWarnings(""unchecked"")
    private final <T extends Activity> T launchActivityWithIntent(
            String pkg,
            Class<T> activityCls,
            Intent intent) {
        intent.setClassName(pkg, activityCls.getName());
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        T activity = (T) InstrumentationRegistry.getInstrumentation().startActivitySync(intent);
        InstrumentationRegistry.getInstrumentation().waitForIdleSync();
        return activity;
    }

    /**
     * Sets the brightness via the shell cmd.
     */
    public boolean setBrightness(float value) throws Exception {
        Process process = Runtime.getRuntime().exec(""cmd display set-brightness "" + value);
        return 0 == process.waitFor();
    }

    private Point getVendorDisplaySize() {
        String value = PropertyUtil.getProperty(""vendor.display-size"");
        if (TextUtils.isEmpty(value)) {
            return null;
        }

        String[] parts = value.split(""x"");
        assertEquals(2, parts.length);
        return new Point(Integer.parseInt(parts[0]), Integer.parseInt(parts[1]));
    }
}"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.host.multiuser.CreateUsersPermissionTest"	"testCanCreateRestrictedUser"	"CtsMultiUserHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/multiuser/src/android/host/multiuser/CreateUsersPermissionTest.java"	""	"public void testCanCreateRestrictedUser() throws Exception {
        createRestrictedProfile(mPrimaryUserId);
    }

    @CddTest(requirement=""9.5/A-1-3"")"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.PasswordMinimumRestrictionsTest"	"testPasswordMinimumRestriction"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/PasswordMinimumRestrictionsTest.java"	""	"public void testPasswordMinimumRestriction() throws Exception {
        for (int i = 0; i < METHOD_LIST.length; i++) {
            invokeSetMethod(METHOD_LIST[i], mDevicePolicyManager, ADMIN_RECEIVER_COMPONENT,
                    TEST_PASSWORD_LENGTH + i);
            invokeSetMethod(METHOD_LIST[i], mParentDpm, ADMIN_RECEIVER_COMPONENT,
                    TEST_PASSWORD_LENGTH + 2 * i);

            // Passing the admin component returns the value set for that admin, rather than
            // aggregated values.
            assertEquals(
                    getMethodName(METHOD_LIST[i])
                            + "" failed to get expected value on mDevicePolicyManager."",
                    TEST_PASSWORD_LENGTH + i, invokeGetMethod(METHOD_LIST[i], mDevicePolicyManager,
                            ADMIN_RECEIVER_COMPONENT));

            // Passing the admin component returns the value set for that admin, rather than
            // aggregated values.
            assertEquals(
                    getMethodName(METHOD_LIST[i]) + "" failed to get expected value on mParentDpm."",
                    TEST_PASSWORD_LENGTH + 2 * i,
                    invokeGetMethod(METHOD_LIST[i], mParentDpm, ADMIN_RECEIVER_COMPONENT));
        }
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.PasswordMinimumRestrictionsTest"	"testSetPasswordMinimumRestrictionWithNull"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/PasswordMinimumRestrictionsTest.java"	""	"public void testSetPasswordMinimumRestrictionWithNull() {
        // Test with mDevicePolicyManager.
        for (String method : METHOD_LIST) {
            try {
                invokeSetMethod(method, mDevicePolicyManager, null, TEST_PASSWORD_LENGTH);
                fail(""Exception should have been thrown for null admin ComponentName"");
            } catch (Exception e) {
                if (!(e.getCause() instanceof NullPointerException)) {
                    fail(""Failed to execute set method: "" + setMethodName(method));
                }
                // Expected to throw NullPointerException.
            }
        }

        // Test with mParentDpm.
        for (String method : METHOD_LIST) {
            try {
                invokeSetMethod(method, mParentDpm, null, TEST_PASSWORD_LENGTH);
                fail(""Exception should have been thrown for null admin ComponentName"");
            } catch (Exception e) {
                if (!(e.getCause() instanceof NullPointerException)) {
                    fail(""Failed to execute set method: "" + setMethodName(method));
                }
                // Expected to throw NullPointerException.
            }
        }
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.PasswordMinimumRestrictionsTest"	"testGetPasswordMinimumRestrictionWithNullAdmin"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/PasswordMinimumRestrictionsTest.java"	""	"public void testGetPasswordMinimumRestrictionWithNullAdmin() throws Exception {
        for (int i = 0; i < METHOD_LIST.length; i++) {
            // Check getMethod with null admin. It should return the aggregated value (which is the
            // only value set so far).
            invokeSetMethod(METHOD_LIST[i], mDevicePolicyManager, ADMIN_RECEIVER_COMPONENT,
                    TEST_PASSWORD_LENGTH_LOW + i);
            assertEquals(getMethodName(METHOD_LIST[i]) + "" failed."", TEST_PASSWORD_LENGTH_LOW + i,
                    invokeGetMethod(METHOD_LIST[i], mDevicePolicyManager, null));

            // Set strict password minimum restriction using parent instance.
            invokeSetMethod(METHOD_LIST[i], mParentDpm, ADMIN_RECEIVER_COMPONENT,
                    TEST_PASSWORD_LENGTH + i);
            // With null admin, the restriction should be the aggregate of all admins.
            assertEquals(getMethodName(METHOD_LIST[i]) + "" failed."", TEST_PASSWORD_LENGTH + i,
                    invokeGetMethod(METHOD_LIST[i], mDevicePolicyManager, null));
            // With null admin, the restriction should be the aggregate of all admins.
            assertEquals(getMethodName(METHOD_LIST[i]) + "" failed."", TEST_PASSWORD_LENGTH + i,
                    invokeGetMethod(METHOD_LIST[i], mParentDpm, null));

            // Passing the admin component returns the value set for that admin, rather than
            // aggregated values.
            assertEquals(getMethodName(METHOD_LIST[i]) + "" failed."", TEST_PASSWORD_LENGTH_LOW + i,
                    invokeGetMethod(METHOD_LIST[i], mDevicePolicyManager,
                            ADMIN_RECEIVER_COMPONENT));
            assertEquals(getMethodName(METHOD_LIST[i]) + "" failed."", TEST_PASSWORD_LENGTH + i,
                    invokeGetMethod(METHOD_LIST[i], mParentDpm, ADMIN_RECEIVER_COMPONENT));

            // Set strict password minimum restriction on current admin.
            invokeSetMethod(METHOD_LIST[i], mDevicePolicyManager, ADMIN_RECEIVER_COMPONENT,
                    TEST_PASSWORD_LENGTH + i);
            // Set password minimum restriction using parent instance.
            invokeSetMethod(METHOD_LIST[i], mParentDpm, ADMIN_RECEIVER_COMPONENT,
                    TEST_PASSWORD_LENGTH_LOW + i);
            // With null admin, the restriction should be the aggregate of all admins.
            assertEquals(getMethodName(METHOD_LIST[i]) + "" failed."", TEST_PASSWORD_LENGTH + i,
                    invokeGetMethod(METHOD_LIST[i], mDevicePolicyManager, null));
            // With null admin, the restriction should be the aggregate of all admins.
            assertEquals(getMethodName(METHOD_LIST[i]) + "" failed."", TEST_PASSWORD_LENGTH + i,
                    invokeGetMethod(METHOD_LIST[i], mParentDpm, null));

            // Passing the admin component returns the value set for that admin, rather than
            // aggregated values.
            assertEquals(getMethodName(METHOD_LIST[i]) + "" failed."", TEST_PASSWORD_LENGTH + i,
                    invokeGetMethod(METHOD_LIST[i], mDevicePolicyManager,
                            ADMIN_RECEIVER_COMPONENT));
            assertEquals(getMethodName(METHOD_LIST[i]) + "" failed."", TEST_PASSWORD_LENGTH_LOW + i,
                    invokeGetMethod(METHOD_LIST[i], mParentDpm, ADMIN_RECEIVER_COMPONENT));
        }
    }

    /**
     * Calls dpm.set{methodName} with given component name and length arguments using reflection.
     */
    private void invokeSetMethod(String methodName, DevicePolicyManager dpm,
            ComponentName componentName, int length) throws Exception {
        final Method setMethod = DevicePolicyManager.class.getMethod(setMethodName(methodName),
                ComponentName.class, int.class);
        setMethod.invoke(dpm, componentName, length);
    }

    /**
     * Calls dpm.get{methodName} with given component name using reflection.
     */
    private int invokeGetMethod(String methodName, DevicePolicyManager dpm,
            ComponentName componentName) throws Exception {
        final Method getMethod =
                DevicePolicyManager.class.getMethod(getMethodName(methodName), ComponentName.class);
        return (int) getMethod.invoke(dpm, componentName);
    }

    private String setMethodName(String methodName) {
        return ""set"" + methodName;
    }

    private String getMethodName(String methodName) {
        return ""get"" + methodName;
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"test.java.com.android.queryable.queries.IntegerQueryHelperTest"	"isTrue"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/queryable/src/test/java/com/android/queryable/queries/IntegerQueryHelperTest.java"	""	"public void matches_noRestrictions_returnsTrue() {
        IntegerQueryHelper<Queryable> integerQueryHelper =
                new IntegerQueryHelper<>(mQuery);

        assertThat(integerQueryHelper.matches(INTEGER_VALUE)).isTrue();
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"test.java.com.android.queryable.queries.IntegerQueryHelperTest"	"matches_isEqualTo_meetsRestriction_returnsTrue"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/queryable/src/test/java/com/android/queryable/queries/IntegerQueryHelperTest.java"	""	"public void matches_isEqualTo_meetsRestriction_returnsTrue() {
        IntegerQueryHelper<Queryable> integerQueryHelper =
                new IntegerQueryHelper<>(mQuery);

        integerQueryHelper.isEqualTo(INTEGER_VALUE);

        assertThat(integerQueryHelper.matches(INTEGER_VALUE)).isTrue();
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"test.java.com.android.queryable.queries.IntegerQueryHelperTest"	"matches_isEqualTo_doesNotMeetRestriction_returnsFalse"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/queryable/src/test/java/com/android/queryable/queries/IntegerQueryHelperTest.java"	""	"public void matches_isEqualTo_doesNotMeetRestriction_returnsFalse() {
        IntegerQueryHelper<Queryable> integerQueryHelper =
                new IntegerQueryHelper<>(mQuery);

        integerQueryHelper.isEqualTo(INTEGER_VALUE);

        assertThat(integerQueryHelper.matches(GREATER_VALUE)).isFalse();
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"test.java.com.android.queryable.queries.IntegerQueryHelperTest"	"matches_isGreaterThan_meetsRestriction_returnsTrue"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/queryable/src/test/java/com/android/queryable/queries/IntegerQueryHelperTest.java"	""	"public void matches_isGreaterThan_meetsRestriction_returnsTrue() {
        IntegerQueryHelper<Queryable> integerQueryHelper =
                new IntegerQueryHelper<>(mQuery);

        integerQueryHelper.isGreaterThan(INTEGER_VALUE);

        assertThat(integerQueryHelper.matches(GREATER_VALUE)).isTrue();
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"test.java.com.android.queryable.queries.IntegerQueryHelperTest"	"matches_isGreaterThan_doesNotMeetRestriction_returnsFalse"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/queryable/src/test/java/com/android/queryable/queries/IntegerQueryHelperTest.java"	""	"public void matches_isGreaterThan_doesNotMeetRestriction_returnsFalse() {
        IntegerQueryHelper<Queryable> integerQueryHelper =
                new IntegerQueryHelper<>(mQuery);

        integerQueryHelper.isGreaterThan(INTEGER_VALUE);

        assertThat(integerQueryHelper.matches(INTEGER_VALUE)).isFalse();
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"test.java.com.android.queryable.queries.IntegerQueryHelperTest"	"matches_isGreaterThanOrEqualTo_doesNotMeetRestriction_returnsFalse"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/queryable/src/test/java/com/android/queryable/queries/IntegerQueryHelperTest.java"	""	"public void matches_isGreaterThanOrEqualTo_doesNotMeetRestriction_returnsFalse() {
        IntegerQueryHelper<Queryable> integerQueryHelper =
                new IntegerQueryHelper<>(mQuery);

        integerQueryHelper.isGreaterThanOrEqualTo(INTEGER_VALUE);

        assertThat(integerQueryHelper.matches(LESS_VALUE)).isFalse();
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"test.java.com.android.queryable.queries.IntegerQueryHelperTest"	"matches_isLessThan_meetsRestriction_returnsTrue"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/queryable/src/test/java/com/android/queryable/queries/IntegerQueryHelperTest.java"	""	"public void matches_isLessThan_meetsRestriction_returnsTrue() {
        IntegerQueryHelper<Queryable> integerQueryHelper =
                new IntegerQueryHelper<>(mQuery);

        integerQueryHelper.isLessThan(INTEGER_VALUE);

        assertThat(integerQueryHelper.matches(LESS_VALUE)).isTrue();
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"test.java.com.android.queryable.queries.IntegerQueryHelperTest"	"matches_isLessThan_doesNotMeetRestriction_returnsFalse"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/queryable/src/test/java/com/android/queryable/queries/IntegerQueryHelperTest.java"	""	"public void matches_isLessThan_doesNotMeetRestriction_returnsFalse() {
        IntegerQueryHelper<Queryable> integerQueryHelper =
                new IntegerQueryHelper<>(mQuery);

        integerQueryHelper.isLessThan(INTEGER_VALUE);

        assertThat(integerQueryHelper.matches(INTEGER_VALUE)).isFalse();
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"test.java.com.android.queryable.queries.IntegerQueryHelperTest"	"matches_isLessThanOrEqualTo_doesNotMeetRestriction_returnsFalse"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/queryable/src/test/java/com/android/queryable/queries/IntegerQueryHelperTest.java"	""	"public void matches_isLessThanOrEqualTo_doesNotMeetRestriction_returnsFalse() {
        IntegerQueryHelper<Queryable> integerQueryHelper =
                new IntegerQueryHelper<>(mQuery);

        integerQueryHelper.isLessThanOrEqualTo(INTEGER_VALUE);

        assertThat(integerQueryHelper.matches(GREATER_VALUE)).isFalse();
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.transferowner.DeviceAndProfileOwnerTransferOutgoingTest"	"testIsBundleNullNoTransfer"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/TransferOwnerOutgoingApp/src/com/android/cts/transferowner/DeviceAndProfileOwnerTransferOutgoingTest.java"	""	"public void testIsBundleNullNoTransfer() throws Throwable {
        assertNull(mDevicePolicyManager.getTransferOwnershipBundle());
    }

    private void setUserRestriction(String restriction, boolean add) {
        DevicePolicyManager dpm = mContext.getSystemService(DevicePolicyManager.class);
        if (add) {
            dpm.addUserRestriction(mOutgoingComponentName, restriction);
        } else {
            dpm.clearUserRestriction(mOutgoingComponentName, restriction);
        }
    }

    private void setAffiliationId(String id) {
        ComponentName admin = mOutgoingComponentName;
        DevicePolicyManager dpm = (DevicePolicyManager)
                mContext.getSystemService(Context.DEVICE_POLICY_SERVICE);
        Set<String> ids = Collections.singleton(id);
        dpm.setAffiliationIds(admin, ids);
        assertEquals(ids, dpm.getAffiliationIds(admin));
    }

    private static SharedPreferences getPrefs(Context context) {
        return context.getSharedPreferences(SHARED_PREFERENCE_NAME, Context.MODE_PRIVATE);
    }

    private static void putBooleanPref(Context context, String key, boolean value) {
        getPrefs(context).edit().putBoolean(key, value).apply();
    }

    protected static boolean getBooleanPref(Context context, String key) {
        return getPrefs(context).getBoolean(key, false);
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.UserRestrictionsParentTest"	"dropShellPermissionIdentity"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/UserRestrictionsParentTest.java"	""	"public void test/*
 *.
 */

package com.android.cts.deviceandprofileowner;

import static com.android.cts.deviceandprofileowner.BaseDeviceAdminTest.ADMIN_RECEIVER_COMPONENT;

import static com.google.common.truth.Truth.assertThat;

import android.app.UiAutomation;
import android.app.admin.DevicePolicyManager;
import android.content.ContentResolver;
import android.content.Context;
import android.hardware.camera2.CameraManager;
import android.os.Bundle;
import android.os.Handler;
import android.os.HandlerThread;
import android.os.UserHandle;
import android.os.UserManager;
import android.provider.Settings;
import android.test.InstrumentationTestCase;
import android.util.Log;

import com.android.cts.devicepolicy.CameraUtils;

import com.google.common.collect.ImmutableSet;

import java.util.Set;
import java.util.concurrent.TimeUnit;

public class UserRestrictionsParentTest extends InstrumentationTestCase {

    private static final String TAG = ""UserRestrictionsParentTest"";

    protected Context mContext;
    private ContentResolver mContentResolver;
    private UiAutomation mUiAutomation;
    private DevicePolicyManager mDevicePolicyManager;
    private UserManager mUserManager;

    private CameraManager mCameraManager;

    private HandlerThread mBackgroundThread;
    private static final long GET_UIAUTOMATION_TIMEOUT_NS = TimeUnit.SECONDS.toNanos(60);

    /**
     * A {@link Handler} for running tasks in the background.
     */
    private Handler mBackgroundHandler;

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        mContext = getInstrumentation().getContext();
        mContentResolver = mContext.getContentResolver();
        mUiAutomation = getUiAutomation();

        mDevicePolicyManager = (DevicePolicyManager)
                mContext.getSystemService(Context.DEVICE_POLICY_SERVICE);
        assertNotNull(mDevicePolicyManager);

        mCameraManager = (CameraManager) mContext.getSystemService(Context.CAMERA_SERVICE);
        assertNotNull(mCameraManager);

        mUserManager = mContext.getSystemService(UserManager.class);
        assertNotNull(mUserManager);

        startBackgroundThread();
    }

    @Override
    protected void tearDown() throws Exception {
        mUiAutomation.dropShellPermissionIdentity();
        stopBackgroundThread();
        super.tearDown();
    }

    private UiAutomation getUiAutomation() throws InterruptedException {
        final long deadline = System.nanoTime() + GET_UIAUTOMATION_TIMEOUT_NS;
        while (System.nanoTime() < deadline) {
            UiAutomation ui = getInstrumentation().getUiAutomation();
            if (ui != null) {
                 return ui;
            }
            Thread.sleep(1000);
        }
        throw new AssertionError(""Failed to get UiAutomation"");
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.UserRestrictionsParentTest"	"testAddUserRestrictionDisallowConfigDateTime_onParent"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/UserRestrictionsParentTest.java"	""	"public void testAddUserRestrictionDisallowConfigDateTime_onParent() {
        DevicePolicyManager parentDevicePolicyManager =
                mDevicePolicyManager.getParentProfileInstance(ADMIN_RECEIVER_COMPONENT);
        assertNotNull(parentDevicePolicyManager);

        parentDevicePolicyManager.addUserRestriction(ADMIN_RECEIVER_COMPONENT,
                UserManager.DISALLOW_CONFIG_DATE_TIME);
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.UserRestrictionsParentTest"	"testHasUserRestrictionDisallowConfigDateTime"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/UserRestrictionsParentTest.java"	""	"public void testHasUserRestrictionDisallowConfigDateTime() {
        assertThat(mUserManager.
                hasUserRestriction(UserManager.DISALLOW_CONFIG_DATE_TIME)).isTrue();
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.UserRestrictionsParentTest"	"testUserRestrictionDisallowConfigDateTimeIsNotPersisted"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/UserRestrictionsParentTest.java"	""	"public void testUserRestrictionDisallowConfigDateTimeIsNotPersisted() throws Exception {
        final long deadline = System.nanoTime() + TimeUnit.SECONDS.toNanos(30);
        while (System.nanoTime() <= deadline) {
            if (!mUserManager.hasUserRestriction(UserManager.DISALLOW_CONFIG_DATE_TIME)) {
                return;
            }
            Thread.sleep(100);
        }
        fail(""The restriction didn't go away."");
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.UserRestrictionsParentTest"	"testAddUserRestrictionDisallowAddUser_onParent"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/UserRestrictionsParentTest.java"	""	"public void testAddUserRestrictionDisallowAddUser_onParent() {
        DevicePolicyManager parentDevicePolicyManager =
                mDevicePolicyManager.getParentProfileInstance(ADMIN_RECEIVER_COMPONENT);
        assertNotNull(parentDevicePolicyManager);

        parentDevicePolicyManager.addUserRestriction(ADMIN_RECEIVER_COMPONENT,
                UserManager.DISALLOW_ADD_USER);
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.UserRestrictionsParentTest"	"testHasUserRestrictionDisallowAddUser"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/UserRestrictionsParentTest.java"	""	"public void testHasUserRestrictionDisallowAddUser() {
        assertThat(hasUserRestriction(UserManager.DISALLOW_ADD_USER)).isTrue();
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.UserRestrictionsParentTest"	"testClearUserRestrictionDisallowAddUser"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/UserRestrictionsParentTest.java"	""	"public void testClearUserRestrictionDisallowAddUser() {
        DevicePolicyManager parentDevicePolicyManager =
                mDevicePolicyManager.getParentProfileInstance(ADMIN_RECEIVER_COMPONENT);

        parentDevicePolicyManager.clearUserRestriction(ADMIN_RECEIVER_COMPONENT,
                UserManager.DISALLOW_ADD_USER);
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.UserRestrictionsParentTest"	"testAddUserRestrictionCameraDisabled_onParent"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/UserRestrictionsParentTest.java"	""	"public void testAddUserRestrictionCameraDisabled_onParent() {
        DevicePolicyManager parentDevicePolicyManager =
                mDevicePolicyManager.getParentProfileInstance(ADMIN_RECEIVER_COMPONENT);
        parentDevicePolicyManager.setCameraDisabled(ADMIN_RECEIVER_COMPONENT, true);
        boolean actualDisabled =
                parentDevicePolicyManager.getCameraDisabled(ADMIN_RECEIVER_COMPONENT);

        assertThat(actualDisabled).isTrue();
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.UserRestrictionsParentTest"	"testRemoveUserRestrictionCameraEnabled_onParent"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/UserRestrictionsParentTest.java"	""	"public void testRemoveUserRestrictionCameraEnabled_onParent() {
        DevicePolicyManager parentDevicePolicyManager =
                mDevicePolicyManager.getParentProfileInstance(ADMIN_RECEIVER_COMPONENT);
        parentDevicePolicyManager.setCameraDisabled(ADMIN_RECEIVER_COMPONENT, false);
        boolean actualDisabled =
                parentDevicePolicyManager.getCameraDisabled(ADMIN_RECEIVER_COMPONENT);

        assertThat(actualDisabled).isFalse();
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.UserRestrictionsParentTest"	"testCanOpenCamera"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/UserRestrictionsParentTest.java"	""	"public void testCanOpenCamera() throws Exception {
        checkCanOpenCamera(true);
    }

    private void checkCanOpenCamera(boolean canOpen) throws Exception {
        // If the device does not support a camera it will return an empty camera ID list.
        if (mCameraManager.getCameraIdList() == null
                || mCameraManager.getCameraIdList().length == 0) {
            return;
        }
        int retries = 10;
        boolean successToOpen = !canOpen;
        while (successToOpen != canOpen && retries > 0) {
            retries--;
            Thread.sleep(500);
            successToOpen = CameraUtils.blockUntilOpenCamera(mCameraManager, mBackgroundHandler);
        }
        assertEquals(String.format(""Timed out waiting the value to change to %b (actual=%b)"",
                canOpen, successToOpen), canOpen, successToOpen);
    }

    private static final Set<String> PROFILE_OWNER_ORGANIZATION_OWNED_LOCAL_RESTRICTIONS =
            ImmutableSet.of(
                    UserManager.DISALLOW_BLUETOOTH,
                    UserManager.DISALLOW_BLUETOOTH_SHARING,
                    UserManager.DISALLOW_CONFIG_BLUETOOTH,
                    UserManager.DISALLOW_CONFIG_CELL_BROADCASTS,
                    UserManager.DISALLOW_CONFIG_LOCATION,
                    UserManager.DISALLOW_CONFIG_MOBILE_NETWORKS,
                    UserManager.DISALLOW_CONFIG_TETHERING,
                    UserManager.DISALLOW_CONFIG_WIFI,
                    UserManager.DISALLOW_CONTENT_CAPTURE,
                    UserManager.DISALLOW_CONTENT_SUGGESTIONS,
                    UserManager.DISALLOW_DATA_ROAMING,
                    UserManager.DISALLOW_SAFE_BOOT,
                    UserManager.DISALLOW_SHARE_LOCATION,
                    UserManager.DISALLOW_SMS,
                    UserManager.DISALLOW_USB_FILE_TRANSFER,
                    UserManager.DISALLOW_MOUNT_PHYSICAL_MEDIA,
                    UserManager.DISALLOW_OUTGOING_CALLS,
                    UserManager.DISALLOW_UNMUTE_MICROPHONE
                    // This restriction disables ADB, so is not used in test.
                    // UserManager.DISALLOW_DEBUGGING_FEATURES
            );"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.UserRestrictionsParentTest"	"testPerProfileUserRestriction_onParent"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/UserRestrictionsParentTest.java"	""	"public void testPerProfileUserRestriction_onParent() throws Settings.SettingNotFoundException {
        mUiAutomation.adoptShellPermissionIdentity(
                ""android.permission.INTERACT_ACROSS_USERS_FULL"",
                ""android.permission.CREATE_USERS"");

        DevicePolicyManager parentDevicePolicyManager =
                mDevicePolicyManager.getParentProfileInstance(ADMIN_RECEIVER_COMPONENT);
        assertNotNull(parentDevicePolicyManager);

        int locationMode = Settings.Secure.getIntForUser(mContentResolver,
                Settings.Secure.LOCATION_MODE, UserHandle.USER_SYSTEM);

        for (String restriction : PROFILE_OWNER_ORGANIZATION_OWNED_LOCAL_RESTRICTIONS) {
            try {
                boolean hasRestrictionOnManagedProfile = mUserManager.hasUserRestriction(
                        restriction);

                parentDevicePolicyManager.addUserRestriction(ADMIN_RECEIVER_COMPONENT, restriction);
                // Assert user restriction on personal profile has been added
                assertThat(hasUserRestriction(restriction)).isTrue();
                // Assert user restriction on managed profile has not changed
                assertThat(mUserManager.hasUserRestriction(restriction)).isEqualTo(
                        hasRestrictionOnManagedProfile);
            } finally {
                parentDevicePolicyManager.clearUserRestriction(ADMIN_RECEIVER_COMPONENT,
                        restriction);
                assertThat(hasUserRestriction(restriction)).isFalse();
            }
        }

        // Restore the location mode setting after adding and removing the
        // DISALLOW_SHARE_LOCATION user restriction. This is because, modifying this user
        // restriction causes the location mode setting to be turned off.
        Settings.Secure.putIntForUser(mContentResolver, Settings.Secure.LOCATION_MODE, locationMode,
                UserHandle.USER_SYSTEM);
    }

    private static final Set<String> PROFILE_OWNER_ORGANIZATION_OWNED_GLOBAL_RESTRICTIONS =
            ImmutableSet.of(
                    UserManager.DISALLOW_CONFIG_PRIVATE_DNS,
                    UserManager.DISALLOW_CONFIG_DATE_TIME,
                    UserManager.DISALLOW_AIRPLANE_MODE
            );"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.UserRestrictionsParentTest"	"testPerDeviceUserRestriction_onParent"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/UserRestrictionsParentTest.java"	""	"public void testPerDeviceUserRestriction_onParent() {
        DevicePolicyManager parentDevicePolicyManager =
                mDevicePolicyManager.getParentProfileInstance(ADMIN_RECEIVER_COMPONENT);
        assertNotNull(parentDevicePolicyManager);

        for (String restriction : PROFILE_OWNER_ORGANIZATION_OWNED_GLOBAL_RESTRICTIONS) {
            try {
                parentDevicePolicyManager.addUserRestriction(ADMIN_RECEIVER_COMPONENT, restriction);
                // Assert user restriction on personal profile has been added
                assertThat(hasUserRestriction(restriction)).isTrue();
                // Assert user restriction on managed profile has been added
                assertThat(mUserManager.hasUserRestriction(restriction)).isTrue();
            } finally {
                parentDevicePolicyManager.clearUserRestriction(ADMIN_RECEIVER_COMPONENT,
                        restriction);
                assertThat(hasUserRestriction(restriction)).isFalse();
                assertThat(mUserManager.hasUserRestriction(restriction)).isFalse();
            }
        }
    }

    private boolean hasUserRestriction(String key) {
        DevicePolicyManager parentDevicePolicyManager =
                mDevicePolicyManager.getParentProfileInstance(ADMIN_RECEIVER_COMPONENT);
        Bundle userRestrictions =
                parentDevicePolicyManager.getUserRestrictions(ADMIN_RECEIVER_COMPONENT);
        return userRestrictions.getBoolean(key);
    }

    /**
     * Starts a background thread and its {@link Handler}.
     */
    private void startBackgroundThread() {
        mBackgroundThread = new HandlerThread(""CameraBackground"");
        mBackgroundThread.start();
        mBackgroundHandler = new Handler(mBackgroundThread.getLooper());
    }

    /**
     * Stops the background thread and its {@link Handler}.
     */
    private void stopBackgroundThread() {
        mBackgroundThread.quitSafely();
        try {
            mBackgroundThread.join();
            mBackgroundThread = null;
            mBackgroundHandler = null;
        } catch (InterruptedException e) {
            Log.e(TAG, ""Interrupted exception thrown while stopping background thread."");
        }
    }

}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"test.java.com.android.queryable.queries.PersistableBundleQueryHelperTest"	"isTrue"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/queryable/src/test/java/com/android/queryable/queries/PersistableBundleQueryHelperTest.java"	""	"public void matches_noRestrictions_returnsTrue() {
        PersistableBundleQueryHelper<Queryable> persistableBundleQueryHelper =
                new PersistableBundleQueryHelper<>(mQuery);

        assertThat(persistableBundleQueryHelper.matches(mPersistableBundle)).isTrue();
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"test.java.com.android.queryable.queries.PersistableBundleQueryHelperTest"	"matches_restrictionOnOneKey_restrictionIsMet_returnsTrue"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/queryable/src/test/java/com/android/queryable/queries/PersistableBundleQueryHelperTest.java"	""	"public void matches_restrictionOnOneKey_restrictionIsMet_returnsTrue() {
        mPersistableBundle.putString(KEY, STRING_VALUE);
        PersistableBundleQueryHelper<Queryable> persistableBundleQueryHelper =
                new PersistableBundleQueryHelper<>(mQuery);

        persistableBundleQueryHelper.key(KEY).exists();

        assertThat(persistableBundleQueryHelper.matches(mPersistableBundle)).isTrue();
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"test.java.com.android.queryable.queries.PersistableBundleQueryHelperTest"	"matches_restrictionOnOneKey_restrictionIsNotMet_returnsFalse"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/queryable/src/test/java/com/android/queryable/queries/PersistableBundleQueryHelperTest.java"	""	"public void matches_restrictionOnOneKey_restrictionIsNotMet_returnsFalse() {
        mPersistableBundle.putString(KEY, STRING_VALUE);
        PersistableBundleQueryHelper<Queryable> persistableBundleQueryHelper =
                new PersistableBundleQueryHelper<>(mQuery);

        persistableBundleQueryHelper.key(KEY).doesNotExist();

        assertThat(persistableBundleQueryHelper.matches(mPersistableBundle)).isFalse();
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"test.java.com.android.queryable.queries.PersistableBundleQueryHelperTest"	"matches_restrictionOnMultipleKeys_oneRestrictionIsNotMet_returnsFalse"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/queryable/src/test/java/com/android/queryable/queries/PersistableBundleQueryHelperTest.java"	""	"public void matches_restrictionOnMultipleKeys_oneRestrictionIsNotMet_returnsFalse() {
        mPersistableBundle.putString(KEY, STRING_VALUE);
        mPersistableBundle.remove(KEY2);
        PersistableBundleQueryHelper<Queryable> persistableBundleQueryHelper =
                new PersistableBundleQueryHelper<>(mQuery);

        persistableBundleQueryHelper.key(KEY).exists();
        persistableBundleQueryHelper.key(KEY2).exists();

        assertThat(persistableBundleQueryHelper.matches(mPersistableBundle)).isFalse();
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"test.java.com.android.queryable.queries.PersistableBundleQueryHelperTest"	"matches_restrictionOnNonExistingKey_returnsFalse"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/queryable/src/test/java/com/android/queryable/queries/PersistableBundleQueryHelperTest.java"	""	"public void matches_restrictionOnNonExistingKey_returnsFalse() {
        mPersistableBundle.remove(KEY);
        PersistableBundleQueryHelper<Queryable> persistableBundleQueryHelper =
                new PersistableBundleQueryHelper<>(mQuery);

        persistableBundleQueryHelper.key(KEY).stringValue().isEqualTo(STRING_VALUE);

        assertThat(persistableBundleQueryHelper.matches(mPersistableBundle)).isFalse();
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.location.cts.fine.LocationManagerFineTest"	"testRequestLocationUpdates_LocationSettingsIgnored"	"CtsLocationFineTestCases"	"/home/gpoor/cts-12-source/cts/tests/location/location_fine/src/android/location/cts/fine/LocationManagerFineTest.java"	""	"public void testRequestLocationUpdates_LocationSettingsIgnored() throws Exception {
        try (LocationListenerCapture capture = new LocationListenerCapture(mContext);
             DeviceConfigStateHelper locationDeviceConfigStateHelper =
                     new DeviceConfigStateHelper(DeviceConfig.NAMESPACE_LOCATION)) {

            locationDeviceConfigStateHelper.set(IGNORE_SETTINGS_ALLOWLIST,
                    mContext.getPackageName());

            getInstrumentation().getUiAutomation()
                    .adoptShellPermissionIdentity(WRITE_SECURE_SETTINGS);
            try {
                mManager.requestLocationUpdates(
                        TEST_PROVIDER,
                        new LocationRequest.Builder(0)
                                .setLocationSettingsIgnored(true)
                                .build(),
                        Executors.newSingleThreadExecutor(),
                        capture);
            } finally {
                getInstrumentation().getUiAutomation().dropShellPermissionIdentity();
            }

            // turn off provider
            mManager.setTestProviderEnabled(TEST_PROVIDER, false);

            // test that all restrictions are bypassed
            Location loc = createLocation(TEST_PROVIDER, mRandom);
            mManager.setTestProviderLocation(TEST_PROVIDER, loc);
            assertThat(capture.getNextLocation(FAILURE_TIMEOUT_MS)).isEqualTo(loc);
            loc = createLocation(TEST_PROVIDER, mRandom);
            mManager.setTestProviderLocation(TEST_PROVIDER, loc);
            assertThat(capture.getNextLocation(FAILURE_TIMEOUT_MS)).isEqualTo(loc);
        }
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"test.java.com.android.queryable.queries.PersistableBundleKeyQueryHelperTest"	"isTrue"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/queryable/src/test/java/com/android/queryable/queries/PersistableBundleKeyQueryHelperTest.java"	""	"public void matches_stringValueRestriction_meetsRestriction_returnsTrue() {
        mPersistableBundle.putString(KEY, STRING_VALUE);
        PersistableBundleKeyQueryHelper<Queryable>
                persistableBundleKeyQueryHelper = new PersistableBundleKeyQueryHelper<>(mQuery);

        persistableBundleKeyQueryHelper.stringValue().isEqualTo(STRING_VALUE);

        assertThat(persistableBundleKeyQueryHelper.matches(mPersistableBundle, KEY)).isTrue();
    }"	""	""	"restriction restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"test.java.com.android.queryable.queries.PersistableBundleKeyQueryHelperTest"	"isFalse"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/queryable/src/test/java/com/android/queryable/queries/PersistableBundleKeyQueryHelperTest.java"	""	"public void matches_stringValueRestriction_doesNotMeetRestriction_returnsFalse() {
        mPersistableBundle.putString(KEY, STRING_VALUE);
        PersistableBundleKeyQueryHelper<Queryable>
                persistableBundleKeyQueryHelper = new PersistableBundleKeyQueryHelper<>(mQuery);

        persistableBundleKeyQueryHelper.stringValue().isEqualTo(DIFFERENT_STRING_VALUE);

        assertThat(persistableBundleKeyQueryHelper.matches(mPersistableBundle, KEY)).isFalse();
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"test.java.com.android.queryable.queries.PersistableBundleKeyQueryHelperTest"	"matches_persistableBundleValueRestriction_meetsRestriction_returnsTrue"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/queryable/src/test/java/com/android/queryable/queries/PersistableBundleKeyQueryHelperTest.java"	""	"public void matches_persistableBundleValueRestriction_meetsRestriction_returnsTrue() {
        mPersistableBundle.putPersistableBundle(KEY, mPersistableBundle2);
        mPersistableBundle2.putString(KEY2, STRING_VALUE);
        PersistableBundleKeyQueryHelper<Queryable>
                persistableBundleKeyQueryHelper = new PersistableBundleKeyQueryHelper<>(mQuery);

        persistableBundleKeyQueryHelper.persistableBundleValue().key(KEY2).exists();

        assertThat(persistableBundleKeyQueryHelper.matches(mPersistableBundle, KEY)).isTrue();
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"test.java.com.android.queryable.queries.PersistableBundleKeyQueryHelperTest"	"matches_persistableBundleValueRestriction_doesNotMeetRestriction_returnsFalse"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/queryable/src/test/java/com/android/queryable/queries/PersistableBundleKeyQueryHelperTest.java"	""	"public void matches_persistableBundleValueRestriction_doesNotMeetRestriction_returnsFalse() {
        mPersistableBundle.putPersistableBundle(KEY, mPersistableBundle2);
        mPersistableBundle2.remove(KEY2);
        PersistableBundleKeyQueryHelper<Queryable>
                persistableBundleKeyQueryHelper = new PersistableBundleKeyQueryHelper<>(mQuery);

        persistableBundleKeyQueryHelper.persistableBundleValue().key(KEY2).exists();

        assertThat(persistableBundleKeyQueryHelper.matches(mPersistableBundle, KEY)).isFalse();
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"test.java.com.android.queryable.queries.PersistableBundleKeyQueryHelperTest"	"matches_existsRestriction_meetsRestriction_returnsTrue"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/queryable/src/test/java/com/android/queryable/queries/PersistableBundleKeyQueryHelperTest.java"	""	"public void matches_existsRestriction_meetsRestriction_returnsTrue() {
        mPersistableBundle.putString(KEY, STRING_VALUE);
        PersistableBundleKeyQueryHelper<Queryable>
                persistableBundleKeyQueryHelper = new PersistableBundleKeyQueryHelper<>(mQuery);

        persistableBundleKeyQueryHelper.exists();

        assertThat(persistableBundleKeyQueryHelper.matches(mPersistableBundle, KEY)).isTrue();
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"test.java.com.android.queryable.queries.PersistableBundleKeyQueryHelperTest"	"matches_existsRestriction_doesNotMeetRestriction_returnsFalse"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/queryable/src/test/java/com/android/queryable/queries/PersistableBundleKeyQueryHelperTest.java"	""	"public void matches_existsRestriction_doesNotMeetRestriction_returnsFalse() {
        mPersistableBundle.remove(KEY);
        PersistableBundleKeyQueryHelper<Queryable>
                persistableBundleKeyQueryHelper = new PersistableBundleKeyQueryHelper<>(mQuery);

        persistableBundleKeyQueryHelper.exists();

        assertThat(persistableBundleKeyQueryHelper.matches(mPersistableBundle, KEY)).isFalse();
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"test.java.com.android.queryable.queries.PersistableBundleKeyQueryHelperTest"	"matches_doesNotExistRestriction_meetsRestriction_returnsTrue"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/queryable/src/test/java/com/android/queryable/queries/PersistableBundleKeyQueryHelperTest.java"	""	"public void matches_doesNotExistRestriction_meetsRestriction_returnsTrue() {
        mPersistableBundle.remove(KEY);
        PersistableBundleKeyQueryHelper<Queryable>
                persistableBundleKeyQueryHelper = new PersistableBundleKeyQueryHelper<>(mQuery);

        persistableBundleKeyQueryHelper.doesNotExist();

        assertThat(persistableBundleKeyQueryHelper.matches(mPersistableBundle, KEY)).isTrue();
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"test.java.com.android.queryable.queries.PersistableBundleKeyQueryHelperTest"	"matches_doesNotExistRestriction_doesNotMeetRestriction_returnsFalse"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/queryable/src/test/java/com/android/queryable/queries/PersistableBundleKeyQueryHelperTest.java"	""	"public void matches_doesNotExistRestriction_doesNotMeetRestriction_returnsFalse() {
        mPersistableBundle.putString(KEY, STRING_VALUE);
        PersistableBundleKeyQueryHelper<Queryable>
                persistableBundleKeyQueryHelper = new PersistableBundleKeyQueryHelper<>(mQuery);

        persistableBundleKeyQueryHelper.doesNotExist();

        assertThat(persistableBundleKeyQueryHelper.matches(mPersistableBundle, KEY)).isFalse();
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"test.java.com.android.queryable.queries.IntentQueryHelperTest"	"isTrue"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/queryable/src/test/java/com/android/queryable/queries/IntentQueryHelperTest.java"	""	"public void matches_extras_meetsRestriction_returnsTrue() {
        Intent intent = new Intent();
        intent.putExtra(/* key= */ STRING_VALUE, /* value= */ STRING_VALUE);
        IntentQueryHelper<Queryable> intentQueryHelper =
                new IntentQueryHelper<>(mQuery);

        intentQueryHelper.extras().key(STRING_VALUE).stringValue().isEqualTo(STRING_VALUE);

        assertThat(intentQueryHelper.matches(intent)).isTrue();
    }"	""	""	"restriction restriction restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"test.java.com.android.queryable.queries.IntentQueryHelperTest"	"isFalse"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/queryable/src/test/java/com/android/queryable/queries/IntentQueryHelperTest.java"	""	"public void matches_extras_doesNotMeetRestriction_returnsFalse() {
        Intent intent = new Intent();
        intent.putExtra(/* key= */ STRING_VALUE, /* value= */ STRING_VALUE);
        IntentQueryHelper<Queryable> intentQueryHelper =
                new IntentQueryHelper<>(mQuery);

        intentQueryHelper.extras().key(STRING_VALUE).stringValue()
                .isEqualTo(DIFFERENT_STRING_VALUE);

        assertThat(intentQueryHelper.matches(intent)).isFalse();
    }
}"	""	""	"restriction restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.ContentCaptureRestrictionsTest"	"disableService"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/ContentCaptureRestrictionsTest.java"	""	"API to get max duration constant from ContentCaptureManager
    private static final int MAX_TIME_TEMPORARY_SERVICE_CAN_BE_SET= 120000;

    private static final int SLEEP_TIME_WAITING_FOR_SERVICE_CONNECTION_MS = 100;

    private static final String SERVICE_NAME =
            ""com.android.cts.devicepolicy.contentcaptureservice/.SimpleContentCaptureService"";

    int mUserId;

    @Override
    protected void setUp() throws Exception {
        super.setUp();

        mUserId = getInstrumentation().getContext().getUserId();
    }

    @Override
    protected void tearDown() throws Exception {
        try {
            disableService();
        } finally {
            mDevicePolicyManager.clearUserRestriction(ADMIN_RECEIVER_COMPONENT,
                    DISALLOW_CONTENT_CAPTURE);
        }
        super.tearDown();
    }

    public void testDisallowContentCapture_allowed() throws Exception {
        enableService();

        final Intent launchIntent = new Intent();
        launchIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        launchIntent.setClassName(CONTENT_CAPTURE_PACKAGE_NAME, CONTENT_CAPTURE_ACTIVITY_NAME);
        final ContentCaptureActivity activity = launchActivity(
                ""com.android.cts.deviceandprofileowner"", ContentCaptureActivity.class, null);

        activity.waitContentCaptureEnabled(true);

        mDevicePolicyManager.addUserRestriction(ADMIN_RECEIVER_COMPONENT, DISALLOW_CONTENT_CAPTURE);

        activity.waitContentCaptureEnabled(false);
    }

    private void enableService() throws Exception {
        runShellCommand(""settings put secure --user %d %s %d default"",
                mUserId, USER_SETUP_COMPLETE, 1);

        runShellCommand(""cmd content_capture set temporary-service %d %s %d"", mUserId,
                SERVICE_NAME, MAX_TIME_TEMPORARY_SERVICE_CAN_BE_SET);
        // TODO: ideally it should wait until the service's onConnected() is called, but that
        // would be too complicated
        Thread.sleep(SLEEP_TIME_WAITING_FOR_SERVICE_CONNECTION_MS);
    }

    private void disableService() {
        runShellCommand(""cmd content_capture set temporary-service %d"", mUserId);
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.ApplicationRestrictionsTest"	"testNullComponentThrowsException"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/ApplicationRestrictionsTest.java"	""	"public void testNullComponentThrowsException() {
        try {
            mDevicePolicyManager.setApplicationRestrictions(
                    null, APP_RESTRICTIONS_TARGET_PKG, null);
            fail(""Expected SecurityException not thrown"");
        } catch (SecurityException expected) {
            MoreAsserts.assertContainsRegex(
                    ""Calling identity is not authorized"",
                    expected.getMessage());
        }
        try {
            mDevicePolicyManager.getApplicationRestrictions(null, APP_RESTRICTIONS_TARGET_PKG);
            fail(""Expected SecurityException not thrown"");
        } catch (SecurityException expected) {
            MoreAsserts.assertContainsRegex(
                    ""Calling identity is not authorized"",
                    expected.getMessage());
        }
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.ApplicationRestrictionsTest"	"testSetApplicationRestrictions"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/ApplicationRestrictionsTest.java"	""	"public void testSetApplicationRestrictions() {
        // Test setting restrictions
        mDevicePolicyManager.setApplicationRestrictions(
                ADMIN_RECEIVER_COMPONENT, APP_RESTRICTIONS_TARGET_PKG, BUNDLE_0);
        mDevicePolicyManager.setApplicationRestrictions(
                ADMIN_RECEIVER_COMPONENT, OTHER_PACKAGE, BUNDLE_1);

        // Retrieve restrictions locally and make sure they are what we put in.
        assertBundle0(mDevicePolicyManager.getApplicationRestrictions(
                ADMIN_RECEIVER_COMPONENT, APP_RESTRICTIONS_TARGET_PKG));
        assertBundle1(mDevicePolicyManager.getApplicationRestrictions(
                ADMIN_RECEIVER_COMPONENT, OTHER_PACKAGE));

        // Check that the target app can retrieve the same restrictions.
        assertBundle0(waitForRestrictionsValueFromTestActivity());

        // Test overwriting
        mDevicePolicyManager.setApplicationRestrictions(
                ADMIN_RECEIVER_COMPONENT, APP_RESTRICTIONS_TARGET_PKG, BUNDLE_1);
        assertBundle1(mDevicePolicyManager.getApplicationRestrictions(
                ADMIN_RECEIVER_COMPONENT, APP_RESTRICTIONS_TARGET_PKG));
        assertBundle1(waitForRestrictionsValueFromTestActivity());

        mDevicePolicyManager.setApplicationRestrictions(
                ADMIN_RECEIVER_COMPONENT, APP_RESTRICTIONS_TARGET_PKG, new Bundle());
        assertTrue(mDevicePolicyManager.getApplicationRestrictions(
                ADMIN_RECEIVER_COMPONENT, APP_RESTRICTIONS_TARGET_PKG).isEmpty());
        assertTrue(waitForRestrictionsValueFromTestActivity().isEmpty());

        mDevicePolicyManager.setApplicationRestrictions(
                ADMIN_RECEIVER_COMPONENT, OTHER_PACKAGE, null);
        assertTrue(mDevicePolicyManager.getApplicationRestrictions(
                ADMIN_RECEIVER_COMPONENT, OTHER_PACKAGE).isEmpty());
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.ApplicationRestrictionsTest"	"testCanRetrieveOwnRestrictionsViaUserManager"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/ApplicationRestrictionsTest.java"	""	"public void testCanRetrieveOwnRestrictionsViaUserManager() {
        final String packageName = mContext.getPackageName();

        mDevicePolicyManager.setApplicationRestrictions(
                ADMIN_RECEIVER_COMPONENT, packageName, BUNDLE_0);
        assertBundle0(mDevicePolicyManager.getApplicationRestrictions(
                ADMIN_RECEIVER_COMPONENT, packageName));

        // Check that we got the restrictions changed callback.
        assertBundle0(waitForRestrictionsChangedBroadcast());

        mDevicePolicyManager.setApplicationRestrictions(
                ADMIN_RECEIVER_COMPONENT, packageName, BUNDLE_1);
        assertBundle1(mDevicePolicyManager.getApplicationRestrictions(
                ADMIN_RECEIVER_COMPONENT, packageName));
        assertBundle1(waitForRestrictionsChangedBroadcast());
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.ApplicationRestrictionsTest"	"testCannotRetrieveOtherPackageRestrictionsViaUserManager"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/ApplicationRestrictionsTest.java"	""	"public void testCannotRetrieveOtherPackageRestrictionsViaUserManager() {
        try {
            mUserManager.getApplicationRestrictions(OTHER_PACKAGE);
            fail(""Expected SecurityException not thrown"");
        } catch (SecurityException expected) {
        }
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.ApplicationRestrictionsTest"	"testSetApplicationRestrictionsManagingPackage"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/ApplicationRestrictionsTest.java"	""	"public void testSetApplicationRestrictionsManagingPackage() throws NameNotFoundException {
        final String previousValue = mDevicePolicyManager.getApplicationRestrictionsManagingPackage(
                ADMIN_RECEIVER_COMPONENT);
        try {
            mDevicePolicyManager.setApplicationRestrictionsManagingPackage(
                    ADMIN_RECEIVER_COMPONENT, APP_RESTRICTIONS_TARGET_PKG);
            assertEquals(APP_RESTRICTIONS_TARGET_PKG,
                    mDevicePolicyManager.getApplicationRestrictionsManagingPackage(
                            ADMIN_RECEIVER_COMPONENT));
            mDevicePolicyManager.setApplicationRestrictionsManagingPackage(
                    ADMIN_RECEIVER_COMPONENT, null);
            assertNull(mDevicePolicyManager.getApplicationRestrictionsManagingPackage(
                    ADMIN_RECEIVER_COMPONENT));
        } finally {
            mDevicePolicyManager.setApplicationRestrictionsManagingPackage(
                    ADMIN_RECEIVER_COMPONENT, previousValue);
            assertEquals(previousValue,
                    mDevicePolicyManager.getApplicationRestrictionsManagingPackage(
                            ADMIN_RECEIVER_COMPONENT));
        }
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.ApplicationRestrictionsTest"	"testSetApplicationRestrictionsManagingPackageForNotInstalledPackage"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/ApplicationRestrictionsTest.java"	""	"public void testSetApplicationRestrictionsManagingPackageForNotInstalledPackage()
            throws NameNotFoundException {
        try {
            mDevicePolicyManager.setApplicationRestrictionsManagingPackage(ADMIN_RECEIVER_COMPONENT,
                    OTHER_PACKAGE);
            fail(""Not throwing exception for not installed package name"");
        } catch (NameNotFoundException expected) {
            MoreAsserts.assertContainsRegex(OTHER_PACKAGE, expected.getMessage());
        } finally {
            mDevicePolicyManager.setApplicationRestrictionsManagingPackage(ADMIN_RECEIVER_COMPONENT,
                    null);
            assertNull(mDevicePolicyManager.getApplicationRestrictionsManagingPackage(
                    ADMIN_RECEIVER_COMPONENT));
        }
    }

    // Should be consistent with assertBundle0
    private static Bundle createBundle0() {
        Bundle result = new Bundle();
        // Tests for 6 allowed types: Integer, Boolean, String, String[], Bundle and Parcelable[]
        // Also test for string escaping handling
        result.putBoolean(""boolean_0"", false);
        result.putBoolean(""boolean_1"", true);
        result.putInt(""integer"", 0x7fffffff);
        // If a null is stored, """" will be read back
        result.putString(""empty"", """");
        result.putString(""string"", ""text"");
        result.putStringArray(""string[]"", TEST_STRINGS);

        // Adding a bundle, which contain 2 nested restrictions - bundle_string and bundle_int
        Bundle bundle = new Bundle();
        bundle.putString(""bundle_string"", ""bundle_string"");
        bundle.putInt(""bundle_int"", 1);
        result.putBundle(""bundle"", bundle);

        // Adding an array of 2 bundles
        Bundle[] bundleArray = new Bundle[2];
        bundleArray[0] = new Bundle();
        bundleArray[0].putString(""bundle_array_string"", ""bundle_array_string"");
        // Put bundle inside bundle
        bundleArray[0].putBundle(""bundle_array_bundle"", bundle);
        bundleArray[1] = new Bundle();
        bundleArray[1].putString(""bundle_array_string2"", ""bundle_array_string2"");
        result.putParcelableArray(""bundle_array"", bundleArray);
        return result;
    }

    // Should be consistent with createBundle0
    private void assertBundle0(Bundle bundle) {
        assertEquals(8, bundle.size());
        assertEquals(false, bundle.getBoolean(""boolean_0""));
        assertEquals(true, bundle.getBoolean(""boolean_1""));
        assertEquals(0x7fffffff, bundle.getInt(""integer""));
        assertEquals("""", bundle.getString(""empty""));
        assertEquals(""text"", bundle.getString(""string""));

        String[] strings = bundle.getStringArray(""string[]"");
        assertTrue(strings != null && strings.length == TEST_STRINGS.length);
        for (int i = 0; i < strings.length; i++) {
            assertEquals(strings[i], TEST_STRINGS[i]);
        }

        Bundle childBundle = bundle.getBundle(""bundle"");
        assertEquals(""bundle_string"", childBundle.getString(""bundle_string""));
        assertEquals(1, childBundle.getInt(""bundle_int""));

        Parcelable[] bundleArray = bundle.getParcelableArray(""bundle_array"");
        assertEquals(2, bundleArray.length);
        // Verifying bundle_array[0]
        Bundle bundle1 = (Bundle) bundleArray[0];
        assertEquals(""bundle_array_string"", bundle1.getString(""bundle_array_string""));
        Bundle bundle1ChildBundle = bundle1.getBundle(""bundle_array_bundle"");
        assertNotNull(bundle1ChildBundle);
        assertEquals(""bundle_string"", bundle1ChildBundle.getString(""bundle_string""));
        assertEquals(1, bundle1ChildBundle.getInt(""bundle_int""));
        // Verifying bundle_array[1]
        Bundle bundle2 = (Bundle) bundleArray[1];
        assertEquals(""bundle_array_string2"", bundle2.getString(""bundle_array_string2""));
    }

    // Should be consistent with assertBundle1
    private static Bundle createBundle1() {
        Bundle result = new Bundle();
        result.putInt(""placeholder"", 1);
        return result;
    }

    // Should be consistent with createBundle1
    private void assertBundle1(Bundle bundle) {
        assertEquals(1, bundle.size());
        assertEquals(1, bundle.getInt(""placeholder""));
    }

    private void startTestActivity() {
        mContext.startActivity(new Intent()
                .setComponent(new ComponentName(
                        APP_RESTRICTIONS_TARGET_PKG, APP_RESTRICTIONS_ACTIVITY_NAME))
                .addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_NEW_TASK));
    }

    private Bundle waitForRestrictionsValueFromTestActivity() {
        startTestActivity();

        try {
            assertTrue(mOnRestrictionsReceivedFromAppSemaphore.tryAcquire(
                    RESTRICTIONS_TIMEOUT_SECONDS, TimeUnit.SECONDS));
        } catch (InterruptedException e) {
            fail(""waitForRestrictionsValueFromTestActivity() interrupted"");
        }

        return mReceivedRestrictions;
    }

    private Bundle waitForRestrictionsChangedBroadcast() {
        try {
            assertTrue(mOnAppRestrictionsChangedSemahore.tryAcquire(
                    RESTRICTIONS_TIMEOUT_SECONDS, TimeUnit.SECONDS));
        } catch (InterruptedException e) {
            fail(""waitForRestrictionsChangedBroadcast() interrupted"");
        }

        return mUserManager.getApplicationRestrictions(mContext.getPackageName());
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.OrgOwnedProfileOwnerTest"	"testUserRestrictionSetOnParentLogged"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/OrgOwnedProfileOwnerTest.java"	""	"public void testUserRestrictionSetOnParentLogged() throws Exception {
        assertMetricsLogged(getDevice(), () -> {
            runDeviceTestsAsUser(DEVICE_ADMIN_PKG, "".DevicePolicyLoggingParentTest"",
                    ""testUserRestrictionLogged"", mUserId);
                }, new DevicePolicyEventWrapper.Builder(EventId.ADD_USER_RESTRICTION_VALUE)
                        .setAdminPackageName(DEVICE_ADMIN_PKG)
                        .setStrings(DISALLOW_CONFIG_LOCATION, CALLED_FROM_PARENT)
                        .build(),
                new DevicePolicyEventWrapper.Builder(EventId.REMOVE_USER_RESTRICTION_VALUE)
                        .setAdminPackageName(DEVICE_ADMIN_PKG)
                        .setStrings(DISALLOW_CONFIG_LOCATION, CALLED_FROM_PARENT)
                        .build());
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.OrgOwnedProfileOwnerTest"	"testUserRestrictionsSetOnParentAreNotPersisted"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/OrgOwnedProfileOwnerTest.java"	""	"public void testUserRestrictionsSetOnParentAreNotPersisted() throws Exception {
        assumeCanCreateAdditionalUsers(1);

        installAppAsUser(DEVICE_ADMIN_APK, mPrimaryUserId);
        runDeviceTestsAsUser(DEVICE_ADMIN_PKG, "".UserRestrictionsParentTest"",
                ""testAddUserRestrictionDisallowConfigDateTime_onParent"", mUserId);
        runDeviceTestsAsUser(DEVICE_ADMIN_PKG, "".UserRestrictionsParentTest"",
                ""testHasUserRestrictionDisallowConfigDateTime"", mPrimaryUserId);
        removeOrgOwnedProfile();
        assertHasNoUser(mUserId);

        // User restrictions are not persist after organization-owned profile owner is removed
        runDeviceTestsAsUser(DEVICE_ADMIN_PKG, "".UserRestrictionsParentTest"",
                ""testUserRestrictionDisallowConfigDateTimeIsNotPersisted"", mPrimaryUserId);
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.OrgOwnedProfileOwnerTest"	"testPerProfileUserRestrictionOnParent"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/OrgOwnedProfileOwnerTest.java"	""	"public void testPerProfileUserRestrictionOnParent() throws Exception {
        runDeviceTestsAsUser(DEVICE_ADMIN_PKG, "".UserRestrictionsParentTest"",
                ""testPerProfileUserRestriction_onParent"", mUserId);
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.OrgOwnedProfileOwnerTest"	"testPerDeviceUserRestrictionOnParent"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/OrgOwnedProfileOwnerTest.java"	""	"public void testPerDeviceUserRestrictionOnParent() throws Exception {
        runDeviceTestsAsUser(DEVICE_ADMIN_PKG, "".UserRestrictionsParentTest"",
                ""testPerDeviceUserRestriction_onParent"", mUserId);
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.OrgOwnedProfileOwnerTest"	"testCameraDisabledOnParentIsEnforced"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/OrgOwnedProfileOwnerTest.java"	""	"public void testCameraDisabledOnParentIsEnforced() throws Exception {
        installAppAsUser(DEVICE_ADMIN_APK, mPrimaryUserId);
        try {
            runDeviceTestsAsUser(DEVICE_ADMIN_PKG, "".UserRestrictionsParentTest"",
                    ""testAddUserRestrictionCameraDisabled_onParent"", mUserId);
            runDeviceTestsAsUser(DEVICE_ADMIN_PKG, "".UserRestrictionsParentTest"",
                    ""testCannotOpenCamera"", mPrimaryUserId);
        } finally {
            runDeviceTestsAsUser(DEVICE_ADMIN_PKG, "".UserRestrictionsParentTest"",
                    ""testRemoveUserRestrictionCameraEnabled_onParent"", mUserId);
            runDeviceTestsAsUser(DEVICE_ADMIN_PKG, "".UserRestrictionsParentTest"",
                    ""testCanOpenCamera"", mPrimaryUserId);
        }
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.PasswordRequirementsTest"	"testPasswordConstraintsDoesntThrowAndPreservesValuesPreR"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/PasswordRequirementsTest.java"	""	"public void testPasswordConstraintsDoesntThrowAndPreservesValuesPreR() {
        // Pre-R password restrictions can be set in any order.
        mDevicePolicyManager.setPasswordQuality(
                ADMIN_RECEIVER_COMPONENT, PASSWORD_QUALITY_SOMETHING);
        // These shouldn't throw.
        mDevicePolicyManager.setPasswordMinimumLength(ADMIN_RECEIVER_COMPONENT, TEST_VALUE);
        mDevicePolicyManager.setPasswordMinimumNumeric(ADMIN_RECEIVER_COMPONENT, TEST_VALUE);
        mDevicePolicyManager.setPasswordMinimumLetters(ADMIN_RECEIVER_COMPONENT, TEST_VALUE);
        mDevicePolicyManager.setPasswordMinimumUpperCase(ADMIN_RECEIVER_COMPONENT, TEST_VALUE);
        mDevicePolicyManager.setPasswordMinimumLowerCase(ADMIN_RECEIVER_COMPONENT, TEST_VALUE);
        mDevicePolicyManager.setPasswordMinimumNonLetter(ADMIN_RECEIVER_COMPONENT, TEST_VALUE);
        mDevicePolicyManager.setPasswordMinimumSymbols(ADMIN_RECEIVER_COMPONENT, TEST_VALUE);

        // Make sure these values are preserved and not reset when quality is set low.
        mDevicePolicyManager.setPasswordQuality(
                ADMIN_RECEIVER_COMPONENT, PASSWORD_QUALITY_UNSPECIFIED);
        assertEquals(TEST_VALUE,
                mDevicePolicyManager.getPasswordMinimumLength(ADMIN_RECEIVER_COMPONENT));
        assertEquals(TEST_VALUE,
                mDevicePolicyManager.getPasswordMinimumNumeric(ADMIN_RECEIVER_COMPONENT));
        assertEquals(TEST_VALUE,
                mDevicePolicyManager.getPasswordMinimumLetters(ADMIN_RECEIVER_COMPONENT));
        assertEquals(TEST_VALUE,
                mDevicePolicyManager.getPasswordMinimumUpperCase(ADMIN_RECEIVER_COMPONENT));
        assertEquals(TEST_VALUE,
                mDevicePolicyManager.getPasswordMinimumLowerCase(ADMIN_RECEIVER_COMPONENT));
        assertEquals(TEST_VALUE,
                mDevicePolicyManager.getPasswordMinimumNonLetter(ADMIN_RECEIVER_COMPONENT));
        assertEquals(TEST_VALUE,
                mDevicePolicyManager.getPasswordMinimumSymbols(ADMIN_RECEIVER_COMPONENT));
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.scopedstorage.cts.host.PreserveLegacyStorageHostTest"	"testPreserveLegacy"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/host/src/android/scopedstorage/cts/host/PreserveLegacyStorageHostTest.java"	""	"public void testPreserveLegacy() throws Exception {
        // This was broken on R, so only run the test on S+ devices
        DeviceSdkLevel deviceSdkLevel = new DeviceSdkLevel(getDevice());
        assumeTrue(deviceSdkLevel.isDeviceAtLeastS());

        // Most of these tests are done device-side; see RestrictedStoragePermissionTest.java
        // This test is done on the host, because we want to verify preserveLegacyExternalStorage
        // is sticky across a reboot.
        installApp(LEGACY_29_APK);
        String result = getDevice().executeShellCommand(
                                    ""appops get "" + PACKAGE_NAME + "" LEGACY_STORAGE"");
        assertThat(result).contains("": allow"");

        // Upgrade to targetSdk 30 with preserveLegacyExternalStorage
        installApp(PRESERVE_30_APK);
        result = getDevice().executeShellCommand(
                                    ""appops get "" + PACKAGE_NAME + "" LEGACY_STORAGE"");

        // And make sure we still have legacy
        assertThat(result).contains("": allow"");

        // Reboot, and again make sure we have legacy
        getDevice().reboot();
        result = getDevice().executeShellCommand(
                                    ""appops get "" + PACKAGE_NAME + "" LEGACY_STORAGE"");
        assertThat(result).contains("": allow"");
    }
}"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.PolicyTransparencyTest"	"testCameraDisabled"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/PolicyTransparencyTest.java"	""	"public void testCameraDisabled() throws Exception {
        mDevicePolicyManager.setCameraDisabled(ADMIN_RECEIVER_COMPONENT, true);

        Intent intent = mDevicePolicyManager.createAdminSupportIntent(
                DevicePolicyManager.POLICY_DISABLE_CAMERA);
        assertNotNull(intent);
        assertEquals(ADMIN_RECEIVER_COMPONENT,
                (ComponentName) intent.getParcelableExtra(DevicePolicyManager.EXTRA_DEVICE_ADMIN));
        assertEquals(DevicePolicyManager.POLICY_DISABLE_CAMERA,
                intent.getStringExtra(DevicePolicyManager.EXTRA_RESTRICTION));

        mDevicePolicyManager.setCameraDisabled(ADMIN_RECEIVER_COMPONENT, false);
        intent = mDevicePolicyManager.createAdminSupportIntent(
                DevicePolicyManager.POLICY_DISABLE_CAMERA);
        assertNull(intent);
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.PolicyTransparencyTest"	"testScreenCaptureDisabled"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/PolicyTransparencyTest.java"	""	"public void testScreenCaptureDisabled() throws Exception {
        mDevicePolicyManager.setScreenCaptureDisabled(ADMIN_RECEIVER_COMPONENT, true);

        Intent intent = mDevicePolicyManager.createAdminSupportIntent(
                DevicePolicyManager.POLICY_DISABLE_SCREEN_CAPTURE);
        assertNotNull(intent);
        assertEquals(ADMIN_RECEIVER_COMPONENT,
                (ComponentName) intent.getParcelableExtra(DevicePolicyManager.EXTRA_DEVICE_ADMIN));
        assertEquals(DevicePolicyManager.POLICY_DISABLE_SCREEN_CAPTURE,
                intent.getStringExtra(DevicePolicyManager.EXTRA_RESTRICTION));

        mDevicePolicyManager.setScreenCaptureDisabled(ADMIN_RECEIVER_COMPONENT, false);
        intent = mDevicePolicyManager.createAdminSupportIntent(
                DevicePolicyManager.POLICY_DISABLE_SCREEN_CAPTURE);
        assertNull(intent);
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.PolicyTransparencyTest"	"testUserRestrictions"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/PolicyTransparencyTest.java"	""	"public void testUserRestrictions() throws Exception {
        // Test with a few random user restrictions:
        runTestForRestriction(UserManager.DISALLOW_ADJUST_VOLUME);
        runTestForRestriction(UserManager.DISALLOW_CONFIG_WIFI);
        runTestForRestriction(UserManager.DISALLOW_CROSS_PROFILE_COPY_PASTE);
    }

    private void runTestForRestriction(String restriction) throws Exception {
        mDevicePolicyManager.addUserRestriction(ADMIN_RECEIVER_COMPONENT, restriction);

        Intent intent = mDevicePolicyManager.createAdminSupportIntent(restriction);
        assertNotNull(intent);
        assertEquals(ADMIN_RECEIVER_COMPONENT,
                (ComponentName) intent.getParcelableExtra(DevicePolicyManager.EXTRA_DEVICE_ADMIN));
        assertEquals(restriction, intent.getStringExtra(DevicePolicyManager.EXTRA_RESTRICTION));

        mDevicePolicyManager.clearUserRestriction(ADMIN_RECEIVER_COMPONENT, restriction);
        intent = mDevicePolicyManager.createAdminSupportIntent(restriction);
        assertNull(intent);
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.AccountCheckHostSideTest"	"runCleanupNonTestOnlyOwnerAllowingFailure"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/AccountCheckHostSideTest.java"	""	"/*
 *.
 */

package com.android.cts.devicepolicy;

import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.junit.Assume.assumeTrue;

import android.platform.test.annotations.LargeTest;

import com.android.tradefed.log.LogUtil.CLog;

import org.junit.Test;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Set of tests to test setting DO and PO when there is account on the user.
 *
 * <p>For example, setting DO or PO shall fail at DPMS.hasIncompatibleAccountsOrNonAdbNoLock when
 * there was incompatible account on the user.
 */
public class AccountCheckHostSideTest extends BaseDevicePolicyTest {
    private static final String APK_NON_TEST_ONLY = ""CtsAccountCheckNonTestOnlyOwnerApp.apk"";
    private static final String APK_TEST_ONLY = ""CtsAccountCheckTestOnlyOwnerApp.apk"";
    private static final String APK_TEST_ONLY_UPDATE = ""CtsAccountCheckTestOnlyOwnerUpdateApp.apk"";
    private static final String APK_AUTH = ""CtsAccountCheckAuthApp.apk"";

    private static final String PACKAGE_NON_TEST_ONLY =
            ""com.android.cts.devicepolicy.accountcheck.nontestonly"";
    private static final String PACKAGE_TEST_ONLY =
            ""com.android.cts.devicepolicy.accountcheck.testonly"";
    private static final String PACKAGE_AUTH = ""com.android.cts.devicepolicy.accountcheck.auth"";

    private static final String OWNER_TEST_ONLY = PACKAGE_TEST_ONLY
            + ""/com.android.cts.devicepolicy.accountcheck.owner.AdminReceiver"";
    private static final String OWNER_NON_TEST_ONLY = PACKAGE_NON_TEST_ONLY
            + ""/com.android.cts.devicepolicy.accountcheck.owner.AdminReceiver"";

    private static final String TEST_CLASS =
            ""com.android.cts.devicepolicy.accountcheck.AccountCheckTest"";

    private static final String DISALLOW_MODIFY_ACCOUNTS = ""no_modify_accounts"";

    private boolean mDeviceOwnerCanHaveAccounts;
    private boolean mProfileOwnerCanHaveAccounts;
    private int mProfileOwnerUserId;

    @Override
    public void setUp() throws Exception {
        super.setUp();
        mProfileOwnerUserId = mPrimaryUserId;
        mDeviceOwnerCanHaveAccounts = !isRestrictionSetOnUser(mDeviceOwnerUserId,
                DISALLOW_MODIFY_ACCOUNTS);
        // Optimization to avoid running dumpsys again
        if (mProfileOwnerUserId == mDeviceOwnerUserId) {
            mProfileOwnerCanHaveAccounts = mDeviceOwnerCanHaveAccounts;
        } else {
            mProfileOwnerCanHaveAccounts = !isRestrictionSetOnUser(mProfileOwnerUserId,
                    DISALLOW_MODIFY_ACCOUNTS);
        }
        CLog.d(""mDeviceOwnerUserId: "" +  mDeviceOwnerUserId
                + "" mDeviceOwnerCanHaveAccounts: "" + mDeviceOwnerCanHaveAccounts
                + "" mProfileOwnerUserId: "" + mProfileOwnerUserId
                + "" mProfileOwnerCanHaveAccounts: "" + mProfileOwnerCanHaveAccounts);
        assumeTrue(""Neither primary user or device owner user is allowed to add accounts"",
                mDeviceOwnerCanHaveAccounts || mProfileOwnerCanHaveAccounts);
    }

    @Override
    public void tearDown() throws Exception {
        if (getDevice().getInstalledPackageNames().contains(PACKAGE_AUTH)) {
            runCleanupTestOnlyOwnerAllowingFailure(mProfileOwnerUserId);
            if (mDeviceOwnerUserId != mProfileOwnerUserId) {
                runCleanupTestOnlyOwnerAllowingFailure(mDeviceOwnerUserId);
            }
            runCleanupNonTestOnlyOwnerAllowingFailure();

            // This shouldn't be needed since we're uninstalling the authenticator,
            // but sometimes the account manager fails to clean up?
            removeAllAccountsAllowingFailure();
        }

        getDevice().uninstallPackage(PACKAGE_AUTH);
        getDevice().uninstallPackage(PACKAGE_TEST_ONLY);
        getDevice().uninstallPackage(PACKAGE_NON_TEST_ONLY);

        super.tearDown();
    }

    private void runTest(String method) throws Exception {
        runTestAsUser(method, mProfileOwnerUserId);
        if (mDeviceOwnerCanHaveAccounts && mProfileOwnerUserId != mDeviceOwnerUserId) {
            runTestAsUser(method, mDeviceOwnerUserId);
        }
    }

    private void runTestAsUser(String method, int userId) throws Exception {
        runDeviceTestsAsUser(PACKAGE_AUTH, TEST_CLASS, method, userId);
    }

    private void runCleanupTestOnlyOwner(int userId) throws Exception {
        assertTrue(removeAdmin(OWNER_TEST_ONLY, userId));
    }

    private void runCleanupTestOnlyOwnerAllowingFailure(int userId) throws Exception {
        try {
            runCleanupTestOnlyOwner(userId);
        } catch (AssertionError ignore) {
        }
    }

    private void runCleanupNonTestOnlyOwner() throws Exception {
        runTest(""testCleanUpNonTestOwner"");
    }

    private void runCleanupNonTestOnlyOwnerAllowingFailure() throws Exception {
        try {
            runCleanupNonTestOnlyOwner();
        } catch (AssertionError ignore) {
        }
    }

    private void removeAllAccounts() throws Exception {
        runTest(""testRemoveAllAccounts"");
    }

    private void removeAllAccountsAllowingFailure() throws Exception {
        try {
            removeAllAccounts();
        } catch (AssertionError ignore) {
        }
    }

    private void assertTestOnlyInstallable() throws Exception {
        if (mDeviceOwnerCanHaveAccounts) {
            setDeviceOwnerOrFail(OWNER_TEST_ONLY, mDeviceOwnerUserId);
            runCleanupTestOnlyOwner(mDeviceOwnerUserId);
        }
        if (mProfileOwnerCanHaveAccounts) {
            setProfileOwnerOrFail(OWNER_TEST_ONLY, mProfileOwnerUserId);
            runCleanupTestOnlyOwner(mProfileOwnerUserId);
        }
    }

    private void assertNonTestOnlyInstallable() throws Exception {
        if (mDeviceOwnerCanHaveAccounts) {
            setDeviceOwnerOrFail(OWNER_NON_TEST_ONLY, mDeviceOwnerUserId);
            runCleanupNonTestOnlyOwner();
        }
        if (mProfileOwnerCanHaveAccounts) {
            setProfileOwnerOrFail(OWNER_NON_TEST_ONLY, mProfileOwnerUserId);
            runCleanupNonTestOnlyOwner();
        }
    }

    private void assertTestOnlyNotInstallable() throws Exception {
        if (mDeviceOwnerCanHaveAccounts) {
            setDeviceOwnerExpectingFailure(OWNER_TEST_ONLY, mDeviceOwnerUserId);
            runCleanupTestOnlyOwnerAllowingFailure(mDeviceOwnerUserId);
        }
        if (mProfileOwnerCanHaveAccounts) {
            setProfileOwnerExpectingFailure(OWNER_TEST_ONLY, mProfileOwnerUserId);
            runCleanupTestOnlyOwnerAllowingFailure(mProfileOwnerUserId);
        }
    }

    private void assertNonTestOnlyNotInstallable() throws Exception {
        if (mDeviceOwnerCanHaveAccounts) {
            setDeviceOwnerExpectingFailure(OWNER_NON_TEST_ONLY, mDeviceOwnerUserId);
            runCleanupNonTestOnlyOwnerAllowingFailure();
        }
        if (mProfileOwnerCanHaveAccounts) {
            setProfileOwnerExpectingFailure(OWNER_NON_TEST_ONLY, mProfileOwnerUserId);
            runCleanupNonTestOnlyOwnerAllowingFailure();
        }
    }

    private boolean hasAccounts() throws Exception {
        final String accountDump = getDevice().executeShellCommand(""dumpsys account"");

        final Pattern p = Pattern.compile(""^\\s*Accounts\\:\\s*(\\d+)"", Pattern.MULTILINE);
        final Matcher m = p.matcher(accountDump);
        if (!m.find()) {
            fail(""Unable to obtain # of accounts"");
            return true;
        }
        final String count = m.group(1);

        CLog.i(""# of preconfigured accounts="" + count);

        return Integer.parseInt(count) > 0;
    }

    /**
     * This set of tests will test whether DO and PO can be set on the user when
     * there is/are different types of accounts added on the target test user.
     */"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.permission2.cts.RestrictedPermissionsTest"	"testDefaultAllRestrictedPermissionsWhitelistedAtInstall29"	"CtsPermission2TestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	"@AppModeFull
    public void testDefaultAllRestrictedPermissionsWhitelistedAtInstall29() throws Exception {
        // Install with no changes to whitelisted permissions, not attempting to grant.
        installRestrictedPermissionUserApp(null /*whitelistedPermissions*/,
                Collections.EMPTY_SET /*grantedPermissions*/);

        // All restricted permission should be whitelisted.
        assertAllRestrictedPermissionWhitelisted();

        // No restricted permission should be granted.
        assertNoRestrictedPermissionGranted();
    }"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.permission2.cts.RestrictedPermissionsTest"	"testSomeRestrictedPermissionsWhitelistedAtInstall29"	"CtsPermission2TestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	"@AppModeFull
    public void testSomeRestrictedPermissionsWhitelistedAtInstall29() throws Exception {
        // Whitelist only these permissions.
        final Set<String> whitelistedPermissions = new ArraySet<>(2);
        whitelistedPermissions.add(Manifest.permission.SEND_SMS);
        whitelistedPermissions.add(Manifest.permission.READ_CALL_LOG);

        // Install with some whitelisted permissions, not attempting to grant.
        installRestrictedPermissionUserApp(whitelistedPermissions,
                Collections.EMPTY_SET /*grantedPermissions*/);

        // Some restricted permission should be whitelisted.
        assertRestrictedPermissionWhitelisted(whitelistedPermissions);

        // No restricted permission should be granted.
        assertNoRestrictedPermissionGranted();
    }"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.permission2.cts.RestrictedPermissionsTest"	"testNoneRestrictedPermissionWhitelistedAtInstall29"	"CtsPermission2TestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	"@AppModeFull
    public void testNoneRestrictedPermissionWhitelistedAtInstall29() throws Exception {
        // Install with all whitelisted permissions, not attempting to grant.
        installRestrictedPermissionUserApp(Collections.emptySet(),
                Collections.EMPTY_SET /*grantedPermissions*/);

        // No restricted permission should be whitelisted.
        assertNoRestrictedPermissionWhitelisted();

        // No restricted permission should be granted.
        assertNoRestrictedPermissionGranted();
    }"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.permission2.cts.RestrictedPermissionsTest"	"testDefaultAllRestrictedPermissionsWhitelistedAtInstall22"	"CtsPermission2TestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	"@AppModeFull
    @SystemUserOnly(reason = ""Secondary users have the DISALLOW_SMS user restriction"")
    public void testDefaultAllRestrictedPermissionsWhitelistedAtInstall22() throws Exception {
        // Install with no changes to whitelisted permissions
        runShellCommand(""pm install -g --force-queryable "" + APK_USES_SMS_CALL_LOG_22);

        // All restricted permission should be whitelisted.
        assertAllRestrictedPermissionWhitelisted();
    }"	""	""	"restricted restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.permission2.cts.RestrictedPermissionsTest"	"testSomeRestrictedPermissionsWhitelistedAtInstall22"	"CtsPermission2TestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	"@AppModeFull
    @SystemUserOnly(reason = ""Secondary users have the DISALLOW_OUTGOING_CALLS user restriction"")
    public void testSomeRestrictedPermissionsWhitelistedAtInstall22() throws Exception {
        // Whitelist only these permissions.
        final Set<String> whitelistedPermissions = new ArraySet<>(2);
        whitelistedPermissions.add(Manifest.permission.SEND_SMS);
        whitelistedPermissions.add(Manifest.permission.READ_CALL_LOG);

        // Install with some whitelisted permissions
        installApp(APK_USES_SMS_CALL_LOG_22, whitelistedPermissions, null /*grantedPermissions*/);

        // Some restricted permission should be whitelisted.
        assertRestrictedPermissionWhitelisted(whitelistedPermissions);
    }"	""	""	"restricted restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.permission2.cts.RestrictedPermissionsTest"	"testNoneRestrictedPermissionWhitelistedAtInstall22"	"CtsPermission2TestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	"@AppModeFull
    public void testNoneRestrictedPermissionWhitelistedAtInstall22() throws Exception {
        // Install with all whitelisted permissions
        installApp(APK_USES_SMS_CALL_LOG_22, Collections.emptySet(),
                null /*grantedPermissions*/);

        // No restricted permission should be whitelisted.
        assertNoRestrictedPermissionWhitelisted();
    }"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.permission2.cts.RestrictedPermissionsTest"	"testLocationBackgroundPermissionWhitelistedAtInstall29"	"CtsPermission2TestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	"@AppModeFull
    public void testLocationBackgroundPermissionWhitelistedAtInstall29() throws Exception {
        installApp(APK_USES_LOCATION_29, null, new ArraySet<>(Arrays.asList(ACCESS_FINE_LOCATION,
                ACCESS_BACKGROUND_LOCATION)));
        assertAllRestrictedPermissionWhitelisted();
    }"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.permission2.cts.RestrictedPermissionsTest"	"testLocationBackgroundPermissionNotWhitelistedAtInstall29"	"CtsPermission2TestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	"@AppModeFull
    public void testLocationBackgroundPermissionNotWhitelistedAtInstall29() throws Exception {
        installApp(APK_USES_LOCATION_29, Collections.emptySet(),
                Collections.singleton(ACCESS_FINE_LOCATION));
        assertNoRestrictedPermissionWhitelisted();
    }"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.permission2.cts.RestrictedPermissionsTest"	"testLocationBackgroundPermissionWhitelistedAtInstall22"	"CtsPermission2TestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	"@AppModeFull
    public void testLocationBackgroundPermissionWhitelistedAtInstall22() throws Exception {
        installApp(APK_USES_LOCATION_22, null, new ArraySet<>(Arrays.asList(ACCESS_FINE_LOCATION,
                ACCESS_BACKGROUND_LOCATION)));
        assertAllRestrictedPermissionWhitelisted();
    }"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.permission2.cts.RestrictedPermissionsTest"	"testLocationBackgroundPermissionNotWhitelistedAtInstall22"	"CtsPermission2TestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	"@AppModeFull
    public void testLocationBackgroundPermissionNotWhitelistedAtInstall22() throws Exception {
        installApp(APK_USES_LOCATION_22, Collections.emptySet(),
                Collections.singleton(ACCESS_FINE_LOCATION));
        assertNoRestrictedPermissionWhitelisted();
    }"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.permission2.cts.RestrictedPermissionsTest"	"testSomeRestrictedPermissionsGrantedAtInstall"	"CtsPermission2TestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	"@AppModeFull
    @SystemUserOnly(reason = ""Secondary users have the DISALLOW_OUTGOING_CALLS user restriction"")
    public void testSomeRestrictedPermissionsGrantedAtInstall() throws Exception {
        // Grant only these permissions.
        final Set<String> grantedPermissions = new ArraySet<>(1);
        grantedPermissions.add(Manifest.permission.SEND_SMS);
        grantedPermissions.add(Manifest.permission.READ_CALL_LOG);

        // Install with no whitelisted permissions attempting to grant.
        installRestrictedPermissionUserApp(null /*whitelistedPermissions*/, grantedPermissions);

        // All restricted permission should be whitelisted.
        assertAllRestrictedPermissionWhitelisted();

        // Some restricted permission should be granted.
        assertRestrictedPermissionGranted(grantedPermissions);
    }"	""	""	"restricted restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.permission2.cts.RestrictedPermissionsTest"	"testCanGrantSoftRestrictedNotWhitelistedPermissions"	"CtsPermission2TestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	"@AppModeFull
    public void testCanGrantSoftRestrictedNotWhitelistedPermissions() throws Exception {
        try {
            final Set<String> grantedPermissions = new ArraySet<>();
            grantedPermissions.add(Manifest.permission.READ_EXTERNAL_STORAGE);
            grantedPermissions.add(permission.WRITE_EXTERNAL_STORAGE);

            installApp(APK_USES_STORAGE_DEFAULT_29, Collections.emptySet(), grantedPermissions);

            assertRestrictedPermissionGranted(grantedPermissions);
        } finally {
            uninstallApp();
        }
    }"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.permission2.cts.RestrictedPermissionsTest"	"testAllRestrictedPermissionsGrantedAtInstall"	"CtsPermission2TestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	"@AppModeFull
    @SystemUserOnly(reason = ""Secondary users have the DISALLOW_SMS user restriction"")
    public void testAllRestrictedPermissionsGrantedAtInstall() throws Exception {
        // Install with whitelisted permissions attempting to grant.
        installRestrictedPermissionUserApp(null /*whitelistedPermissions*/,
                null);

        // All restricted permission should be whitelisted.
        assertAllRestrictedPermissionWhitelisted();

        // Some restricted permission should be granted.
        assertAllRestrictedPermissionGranted();
    }"	""	""	"restricted restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.permission2.cts.RestrictedPermissionsTest"	"testWhitelistAccessControl"	"CtsPermission2TestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	"@AppModeFull
    public void testWhitelistAccessControl() throws Exception {
        // Install with no whitelisted permissions not attempting to grant.
        installRestrictedPermissionUserApp(Collections.emptySet(), null);

        assertWeCannotReadOrWriteWhileShellCanReadAndWrite(
                PackageManager.FLAG_PERMISSION_WHITELIST_SYSTEM);

        assertWeCannotReadOrWriteWhileShellCanReadAndWrite(
                PackageManager.FLAG_PERMISSION_WHITELIST_UPGRADE);

        assertWeCannotReadOrWriteWhileShellCanReadAndWrite(
                PackageManager.FLAG_PERMISSION_WHITELIST_INSTALLER);
    }"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.permission2.cts.RestrictedPermissionsTest"	"onSideLoadRestrictedPermissionsWhitelistingDefault"	"CtsPermission2TestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	"@AppModeFull
    public void onSideLoadRestrictedPermissionsWhitelistingDefault() throws Exception {
        installRestrictedPermissionUserApp(new SessionParams(SessionParams.MODE_FULL_INSTALL));

        // All restricted permissions whitelisted on side-load by default
        assertAllRestrictedPermissionWhitelisted();
    }"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.permission2.cts.RestrictedPermissionsTest"	"onSideLoadAllRestrictedPermissionsWhitelisted"	"CtsPermission2TestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	"@AppModeFull
    public void onSideLoadAllRestrictedPermissionsWhitelisted() throws Exception {
        SessionParams params = new SessionParams(SessionParams.MODE_FULL_INSTALL);
        params.setWhitelistedRestrictedPermissions(SessionParams.RESTRICTED_PERMISSIONS_ALL);

        installRestrictedPermissionUserApp(params);

        assertAllRestrictedPermissionWhitelisted();
    }"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.permission2.cts.RestrictedPermissionsTest"	"onSideLoadWhitelistSomePermissions"	"CtsPermission2TestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	"@AppModeFull
    public void onSideLoadWhitelistSomePermissions() throws Exception {
        Set<String> whitelistedPermissions = new ArraySet<>();
        whitelistedPermissions.add(Manifest.permission.SEND_SMS);
        whitelistedPermissions.add(Manifest.permission.READ_CALL_LOG);

        SessionParams params = new SessionParams(SessionParams.MODE_FULL_INSTALL);
        params.setWhitelistedRestrictedPermissions(whitelistedPermissions);

        installRestrictedPermissionUserApp(params);

        assertRestrictedPermissionWhitelisted(whitelistedPermissions);
    }"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.permission2.cts.RestrictedPermissionsTest"	"onSideLoadWhitelistNoPermissions"	"CtsPermission2TestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	"@AppModeFull
    public void onSideLoadWhitelistNoPermissions() throws Exception {
        SessionParams params = new SessionParams(SessionParams.MODE_FULL_INSTALL);
        params.setWhitelistedRestrictedPermissions(Collections.emptySet());

        installRestrictedPermissionUserApp(params);

        assertNoRestrictedPermissionWhitelisted();
    }"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.permission2.cts.RestrictedPermissionsTest"	"isTrue"	"CtsPermission2TestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	"@AppModeFull
    @SystemUserOnly(reason = ""Secondary users have the DISALLOW_SMS user restriction"")
    public void shareUidBetweenRestrictedAndNotRestrictedApp() throws Exception {
        runShellCommand(
                ""pm install -g --force-queryable --restrict-permissions ""
                + APK_USES_SMS_RESTRICTED_SHARED_UID);
        runShellCommand(""pm install -g --force-queryable ""
                + APK_USES_SMS_NOT_RESTRICTED_SHARED_UID);

        eventually(
                () -> assertThat(isGranted(PKG_USES_SMS_RESTRICTED_SHARED_UID, READ_SMS)).isTrue());
        // The apps share a UID, hence the whitelisting is shared too
        assertThat(isGranted(PKG_USES_SMS_NOT_RESTRICTED_SHARED_UID, READ_SMS)).isTrue();
    }

    private static void installRestrictedPermissionUserApp(@NonNull SessionParams params)
            throws Exception {
        final CountDownLatch installLatch = new CountDownLatch(1);

        // Create an install result receiver.
        final BroadcastReceiver installReceiver = new BroadcastReceiver() {
            public void onReceive(Context context, Intent intent) {
                if (intent.getIntExtra(PackageInstaller.EXTRA_STATUS,
                        PackageInstaller.STATUS_FAILURE_INVALID)
                            == PackageInstaller.STATUS_SUCCESS) {
                    installLatch.countDown();
                }
            }
        };

        // Register the result receiver.
        final String action = ""android.permission2.cts.ACTION_INSTALL_COMMIT"";
        final IntentFilter intentFilter = new IntentFilter(action);
        getContext().registerReceiver(installReceiver, intentFilter);

        try {
            // Create a session.
            final PackageInstaller packageInstaller = getContext()
                    .getPackageManager().getPackageInstaller();
            final int sessionId = packageInstaller.createSession(params);
            final Session session = packageInstaller.openSession(sessionId);

            // Write the apk.
            try (
                    InputStream in = new BufferedInputStream(new FileInputStream(
                        new File(APK_USES_SMS_CALL_LOG_29)));
                    OutputStream out = session.openWrite(
                            APK_NAME_USES_SMS_CALL_LOG_29, 0, -1);
            ) {
                final byte[] buf = new byte[8192];
                int size;
                while ((size = in.read(buf)) != -1) {
                    out.write(buf, 0, size);
                }
            }

            final Intent intent = new Intent(action);
            final IntentSender intentSender = PendingIntent.getBroadcast(getContext(),
                    1, intent, PendingIntent.FLAG_ONE_SHOT | PendingIntent.FLAG_IMMUTABLE)
                    .getIntentSender();

            // Commit as shell to avoid confirm UI
            runWithShellPermissionIdentity(() -> {
                session.commit(intentSender);
                installLatch.await(UI_TIMEOUT, TimeUnit.MILLISECONDS);
            });
        } finally {
            getContext().unregisterReceiver(installReceiver);
        }
    }

    private void assertWeCannotReadOrWriteWhileShellCanReadAndWrite(int whitelist)
            throws Exception {
        final PackageManager packageManager = getContext().getPackageManager();
        try {
            packageManager.getWhitelistedRestrictedPermissions(PKG, whitelist);
            fail();
        } catch (SecurityException expected) {
            /*ignore*/
        }
        try {
            packageManager.addWhitelistedRestrictedPermission(PKG,
                    permission.SEND_SMS, whitelist);
            fail();
        } catch (SecurityException expected) {
            /*ignore*/
        }
        runWithShellPermissionIdentity(() -> {
            packageManager.addWhitelistedRestrictedPermission(PKG,
                    permission.SEND_SMS, whitelist);
            assertThat(packageManager.getWhitelistedRestrictedPermissions(PKG,
                    whitelist)).contains(permission.SEND_SMS);
            packageManager.removeWhitelistedRestrictedPermission(PKG,
                    permission.SEND_SMS, whitelist);
            assertThat(packageManager.getWhitelistedRestrictedPermissions(PKG,
                    whitelist)).doesNotContain(permission.SEND_SMS);
        });
    }

    private @NonNull Set<String> getPermissionsOfAppWithAnyOfFlags(int flags) throws Exception {
        final PackageManager packageManager = getContext().getPackageManager();
        final Set<String> restrictedPermissions = new ArraySet<>();
        for (String permission : getRequestedPermissionsOfApp()) {
            PermissionInfo permInfo = packageManager.getPermissionInfo(permission, 0);

            if ((permInfo.flags & flags) != 0) {
                restrictedPermissions.add(permission);
            }
        }
        return restrictedPermissions;
    }

    private @NonNull Set<String> getRestrictedPermissionsOfApp() throws Exception {
        return getPermissionsOfAppWithAnyOfFlags(
                PermissionInfo.FLAG_HARD_RESTRICTED | PermissionInfo.FLAG_SOFT_RESTRICTED);
    }

    private @NonNull String[] getRequestedPermissionsOfApp() throws Exception {
        final PackageManager packageManager = getContext().getPackageManager();
        final PackageInfo packageInfo = packageManager.getPackageInfo(PKG,
                PackageManager.GET_PERMISSIONS);
        return packageInfo.requestedPermissions;
    }

    private void assertAllRestrictedPermissionWhitelisted() throws Exception {
        assertRestrictedPermissionWhitelisted(getRestrictedPermissionsOfApp());
    }

    private void assertNoRestrictedPermissionWhitelisted() throws Exception {
        assertRestrictedPermissionWhitelisted(
                Collections.EMPTY_SET /*expectedWhitelistedPermissions*/);
    }

    /**
     * Assert that the passed in restrictions are whitelisted and that their app-op is set
     * correctly.
     *
     * @param expectedWhitelistedPermissions The expected white listed permissions
     */
    private void assertRestrictedPermissionWhitelisted(
            @NonNull Set<String> expectedWhitelistedPermissions) throws Exception {
        final PackageManager packageManager = getContext().getPackageManager();
        eventually(() -> runWithShellPermissionIdentity(() -> {
            final AppOpsManager appOpsManager = getContext().getSystemService(AppOpsManager.class);
            final PackageInfo packageInfo = packageManager.getPackageInfo(PKG,
                    PackageManager.GET_PERMISSIONS);

            final Set<String> whitelistedPermissions = packageManager
                .getWhitelistedRestrictedPermissions(PKG,
                        PackageManager.FLAG_PERMISSION_WHITELIST_SYSTEM
                        | PackageManager.FLAG_PERMISSION_WHITELIST_INSTALLER
                        | PackageManager.FLAG_PERMISSION_WHITELIST_UPGRADE);

            assertThat(whitelistedPermissions).isNotNull();
            assertWithMessage(""Whitelisted permissions"").that(whitelistedPermissions)
                    .containsExactlyElementsIn(expectedWhitelistedPermissions);

            // Also assert that apps ops are properly set
            for (String permission : getRestrictedPermissionsOfApp()) {
                String op = AppOpsManager.permissionToOp(permission);
                ArraySet<Integer> possibleModes = new ArraySet<>();

                if (permission.equals(Manifest.permission.ACCESS_BACKGROUND_LOCATION)) {
                    op = AppOpsManager.OPSTR_FINE_LOCATION;

                    // If permission is denied app-op might be allowed/fg or ignored. It does
                    // not matter. If permission is granted, it has to be allowed/fg.
                    if (isPermissionGranted(PKG, Manifest.permission.ACCESS_FINE_LOCATION)) {
                        if (expectedWhitelistedPermissions.contains(permission)
                                && isPermissionGranted(PKG, permission)) {
                            possibleModes.add(AppOpsManager.MODE_ALLOWED);
                        } else {
                            possibleModes.add(AppOpsManager.MODE_FOREGROUND);
                        }
                    } else {
                        possibleModes.add(AppOpsManager.MODE_IGNORED);
                        possibleModes.add(AppOpsManager.MODE_ALLOWED);
                        possibleModes.add(AppOpsManager.MODE_FOREGROUND);
                    }
                } else {
                    if (expectedWhitelistedPermissions.contains(permission)) {
                        // If permission is denied app-op might be allowed or ignored. It does not
                        // matter. If permission is granted, it has to be allowed.
                        possibleModes.add(AppOpsManager.MODE_ALLOWED);
                        if (!isPermissionGranted(PKG, permission)) {
                            possibleModes.add(AppOpsManager.MODE_IGNORED);
                        }
                    } else {
                        possibleModes.add(AppOpsManager.MODE_IGNORED);
                    }
                }

                assertWithMessage(op).that(appOpsManager.unsafeCheckOpRawNoThrow(op,
                        packageInfo.applicationInfo.uid, PKG)).isIn(possibleModes);
            }
        }));
    }

    private void assertAllRestrictedPermissionGranted() throws Exception {
        final PackageManager packageManager = getContext().getPackageManager();
        final PackageInfo packageInfo = packageManager.getPackageInfo(
                PKG, PackageManager.GET_PERMISSIONS);
        if (packageInfo.requestedPermissions != null) {
            final int permissionCount = packageInfo.requestedPermissions.length;
            for (int i = 0; i < permissionCount; i++) {
                final String permission = packageInfo.requestedPermissions[i];
                final PermissionInfo permissionInfo = packageManager.getPermissionInfo(
                        permission, 0);
                if ((permissionInfo.flags & PermissionInfo.FLAG_HARD_RESTRICTED) != 0) {
                    assertThat((packageInfo.requestedPermissionsFlags[i]
                            & PackageInfo.REQUESTED_PERMISSION_GRANTED)).isNotEqualTo(0);
                }
            }
        }
    }

    private void assertNoRestrictedPermissionGranted() throws Exception {
        assertRestrictedPermissionGranted(Collections.EMPTY_SET);
    }

    private void assertRestrictedPermissionGranted(@NonNull Set<String> expectedGrantedPermissions)
            throws Exception {
        final PackageManager packageManager = getContext().getPackageManager();
        final PackageInfo packageInfo = packageManager.getPackageInfo(
                PKG, PackageManager.GET_PERMISSIONS);
        if (packageInfo.requestedPermissions != null) {
            final int permissionCount = packageInfo.requestedPermissions.length;
            for (int i = 0; i < permissionCount; i++) {
                final String permission = packageInfo.requestedPermissions[i];
                final PermissionInfo permissionInfo = packageManager.getPermissionInfo(
                        permission, 0);
                if ((permissionInfo.flags & PermissionInfo.FLAG_HARD_RESTRICTED) != 0
                        || (permissionInfo.flags & PermissionInfo.FLAG_SOFT_RESTRICTED) != 0) {
                    if (expectedGrantedPermissions.contains(permission)) {
                        assertThat((packageInfo.requestedPermissionsFlags[i]
                                & PackageInfo.REQUESTED_PERMISSION_GRANTED)).isNotEqualTo(0);
                    } else {
                        assertThat((packageInfo.requestedPermissionsFlags[i]
                                & PackageInfo.REQUESTED_PERMISSION_GRANTED)).isEqualTo(0);
                    }
                }
            }
        }
    }

    /**
     * Install {@link #APK_USES_SMS_CALL_LOG_29}.
     *
     * @param whitelistedPermissions The permission to be whitelisted. {@code null} == all
     * @param grantedPermissions The permission to be granted. {@code null} == all
     */
    private void installRestrictedPermissionUserApp(@Nullable Set<String> whitelistedPermissions,
            @Nullable Set<String> grantedPermissions) throws Exception {
        installApp(APK_USES_SMS_CALL_LOG_29, whitelistedPermissions, grantedPermissions);
    }

    /**
     * Install app and grant all permission.
     *
     * @param app The app to be installed
     * @param whitelistedPermissions The permission to be whitelisted. {@code null} == all
     */
    private void installApp(@NonNull String app, @Nullable Set<String> whitelistedPermissions)
            throws Exception {
        installApp(app, whitelistedPermissions, null /*grantedPermissions*/);
    }

    /**
     * Install an app.
     *
     * @param app The app to be installed
     * @param whitelistedPermissions The permission to be whitelisted. {@code null} == all
     * @param grantedPermissions The permission to be granted. {@code null} == all
     */
    private void installApp(@NonNull String app, @Nullable Set<String> whitelistedPermissions,
            @Nullable Set<String> grantedPermissions) throws Exception {
        // Install the app and whitelist/grant all permission if requested.
        String installResult = runShellCommand(""pm install -r --force-queryable ""
                + ""--restrict-permissions "" + app);
        assertThat(installResult.trim()).isEqualTo(""Success"");

        final Set<String> adjustedWhitelistedPermissions;
        if (whitelistedPermissions == null) {
            adjustedWhitelistedPermissions = getRestrictedPermissionsOfApp();
        } else {
            adjustedWhitelistedPermissions = whitelistedPermissions;
        }

        final Set<String> adjustedGrantedPermissions;
        if (grantedPermissions == null) {
            adjustedGrantedPermissions = getRestrictedPermissionsOfApp();
        } else {
            adjustedGrantedPermissions = grantedPermissions;
        }

        // Whitelist subset of permissions if requested
        runWithShellPermissionIdentity(() -> {
            final PackageManager packageManager = getContext().getPackageManager();
            for (String permission : adjustedWhitelistedPermissions) {
                packageManager.addWhitelistedRestrictedPermission(PKG, permission,
                        PackageManager.FLAG_PERMISSION_WHITELIST_INSTALLER);
            }
        });

        // Grant subset of permissions if requested
        runWithShellPermissionIdentity(() -> {
            final PackageManager packageManager = getContext().getPackageManager();
            for (String permission : adjustedGrantedPermissions) {
                packageManager.grantRuntimePermission(PKG, permission,
                        getContext().getUser());
                packageManager.updatePermissionFlags(permission, PKG,
                        PackageManager.FLAG_PERMISSION_REVOKED_COMPAT, 0, getContext().getUser());
            }
        });

        // Mark all permissions as reviewed as for pre-22 apps the restriction state might not be
        // applied until reviewed
        runWithShellPermissionIdentity(() -> {
            final PackageManager packageManager = getContext().getPackageManager();
            for (String permission : getRequestedPermissionsOfApp()) {
                packageManager.updatePermissionFlags(permission, PKG,
                        PackageManager.FLAG_PERMISSION_REVIEW_REQUIRED, 0,
                        getContext().getUser());
            }
        });
    }

    @After
    public void uninstallApp() {
        runShellCommand(""pm uninstall "" + PKG);
        runShellCommand(""pm uninstall "" + PKG_USES_SMS_NOT_RESTRICTED_SHARED_UID);
        runShellCommand(""pm uninstall "" + PKG_USES_SMS_RESTRICTED_SHARED_UID);
    }

    private static @NonNull Context getContext() {
        return InstrumentationRegistry.getInstrumentation().getContext();
    }

    private static void runWithShellPermissionIdentity(@NonNull ThrowingRunnable command)
            throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .adoptShellPermissionIdentity();
        try {
            command.run();
        } finally {
            InstrumentationRegistry.getInstrumentation().getUiAutomation()
                    .dropShellPermissionIdentity();
        }
    }
}"	""	""	"restricted restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.vpnfirewall.ReflectorVpnService"	"ensureNetworkCallbackUnregistered"	""	"/home/gpoor/cts-12-source/cts/apps/VpnApp/src/com/android/cts/vpnfirewall/ReflectorVpnService.java"	""	"public void test/*
 *.
 */

package com.android.cts.vpnfirewall;

import android.R;
import android.app.Notification;
import android.app.NotificationChannel;
import android.app.NotificationManager;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager.NameNotFoundException;
import android.net.ConnectivityManager;
import android.net.Network;
import android.net.NetworkCapabilities;
import android.net.NetworkRequest;
import android.net.VpnService;
import android.os.Bundle;
import android.os.ParcelFileDescriptor;
import android.os.UserManager;
import android.text.TextUtils;
import android.util.Log;
import android.os.SystemProperties;

import java.io.IOException;
import java.net.InetAddress;
import java.net.UnknownHostException;

public class ReflectorVpnService extends VpnService {
    public static final String ACTION_STOP_SERVICE = ""com.android.cts.vpnfirewall.STOP_SERVICE"";

    private static final String TAG = ""ReflectorVpnService"";
    private static final String DEVICE_AND_PROFILE_OWNER_PACKAGE =
        ""com.android.cts.deviceandprofileowner"";
    private static final String ACTION_VPN_IS_UP = ""com.android.cts.vpnfirewall.VPN_IS_UP"";
    private static final String ACTION_VPN_ON_START = ""com.android.cts.vpnfirewall.VPN_ON_START"";
    private static final int NOTIFICATION_ID = 1;
    private static final String NOTIFICATION_CHANNEL_ID = TAG;
    private static final int MTU = 1799;

    private ParcelFileDescriptor mFd = null;
    private PingReflector mPingReflector = null;
    private ConnectivityManager mConnectivityManager = null;
    private ConnectivityManager.NetworkCallback mNetworkCallback = null;

    private static final String RESTRICTION_ADDRESSES = ""vpn.addresses"";
    private static final String RESTRICTION_ROUTES = ""vpn.routes"";
    private static final String RESTRICTION_ALLOWED = ""vpn.allowed"";
    private static final String RESTRICTION_DISALLOWED = ""vpn.disallowed"";
    /** Service won't create the tunnel, to test lockdown behavior in case of VPN failure. */
    private static final String RESTRICTION_DONT_ESTABLISH = ""vpn.dont_establish"";
    private static final String EXTRA_ALWAYS_ON = ""always-on"";
    private static final String EXTRA_LOCKDOWN = ""lockdown"";

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        if (ACTION_STOP_SERVICE.equals(intent.getAction())) {
            stop();
            stopSelf();
        } else {
            // Normal service start
            // Put ourself in the foreground to stop the system killing us while we wait for orders from
            // the hostside test.
            NotificationManager notificationManager = getSystemService(NotificationManager.class);
            notificationManager.createNotificationChannel(new NotificationChannel(
                    NOTIFICATION_CHANNEL_ID, NOTIFICATION_CHANNEL_ID,
                    NotificationManager.IMPORTANCE_DEFAULT));
            startForeground(NOTIFICATION_ID, new Notification.Builder(this, NOTIFICATION_CHANNEL_ID)
                    .setSmallIcon(R.drawable.ic_dialog_alert)
                    .build());
            start();
        }
        return START_NOT_STICKY;
    }

    @Override
    public void onCreate() {
        mConnectivityManager = getSystemService(ConnectivityManager.class);
    }

    @Override
    public void onDestroy() {
        stop();
        NotificationManager notificationManager = getSystemService(NotificationManager.class);
        notificationManager.deleteNotificationChannel(NOTIFICATION_CHANNEL_ID);
        ensureNetworkCallbackUnregistered();
        super.onDestroy();
    }

    private void ensureNetworkCallbackUnregistered() {
        if (null == mConnectivityManager || null == mNetworkCallback) return;
        mConnectivityManager.unregisterNetworkCallback(mNetworkCallback);
        mNetworkCallback = null;
    }

    private void start() {
        final UserManager um = (UserManager) getSystemService(Context.USER_SERVICE);
        final Bundle restrictions = um.getApplicationRestrictions(getPackageName());

        final Intent intent = new Intent(ACTION_VPN_ON_START);
        intent.setPackage(DEVICE_AND_PROFILE_OWNER_PACKAGE);
        sendBroadcast(intent);

        if (restrictions.getBoolean(RESTRICTION_DONT_ESTABLISH)) {
            stopSelf();
            return;
        }

        VpnService.prepare(this);

        ensureNetworkCallbackUnregistered();
        final NetworkRequest request = new NetworkRequest.Builder()
            .addTransportType(NetworkCapabilities.TRANSPORT_VPN)
            .removeCapability(NetworkCapabilities.NET_CAPABILITY_NOT_VPN)
            .removeCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
            .build();
        mNetworkCallback = new ConnectivityManager.NetworkCallback() {
                @Override
                public void onAvailable(final Network net) {
                    final Intent intent = new Intent(ACTION_VPN_IS_UP);
                    intent.setPackage(DEVICE_AND_PROFILE_OWNER_PACKAGE);
                    intent.putExtra(EXTRA_ALWAYS_ON, isAlwaysOn());
                    intent.putExtra(EXTRA_LOCKDOWN, isLockdownEnabled());
                    sendBroadcast(intent);
                    ensureNetworkCallbackUnregistered();
                }
            };
        mConnectivityManager.registerNetworkCallback(request, mNetworkCallback);

        Builder builder = new Builder();


        String[] addressArray = restrictions.getStringArray(RESTRICTION_ADDRESSES);
        if (addressArray == null) {
            // Addresses for IPv4/IPv6 documentation purposes according to rfc5737/rfc3849.
            addressArray = new String[] {""192.0.2.3/32"", ""2001:db8:1:2::/128""};
        };
        for (int i = 0; i < addressArray.length; i++) {
            String[] prefixAndMask = addressArray[i].split(""/"");
            try {
                InetAddress address = InetAddress.getByName(prefixAndMask[0]);
                int prefixLength = Integer.parseInt(prefixAndMask[1]);
                builder.addAddress(address, prefixLength);
            } catch (NumberFormatException | UnknownHostException e) {
                Log.w(TAG, ""Ill-formed address: "" + addressArray[i]);
                continue;
            }
        }

        String[] routeArray = restrictions.getStringArray(RESTRICTION_ROUTES);
        if (routeArray == null) {
            routeArray = new String[] {""0.0.0.0/0"", ""::/0""};
        }
        for (int i = 0; i < routeArray.length; i++) {
            String[] prefixAndMask = routeArray[i].split(""/"");
            try {
                InetAddress address = InetAddress.getByName(prefixAndMask[0]);
                int prefixLength = Integer.parseInt(prefixAndMask[1]);
                builder.addRoute(address, prefixLength);
            } catch (NumberFormatException | UnknownHostException e) {
                Log.w(TAG, ""Ill-formed route: "" + routeArray[i]);
                continue;
            }
        }

        String[] allowedArray = restrictions.getStringArray(RESTRICTION_ALLOWED);
        if (allowedArray != null) {
            for (int i = 0; i < allowedArray.length; i++) {
                String allowedPackage = allowedArray[i];
                if (!TextUtils.isEmpty(allowedPackage)) {
                    try {
                        builder.addAllowedApplication(allowedPackage);
                    } catch(NameNotFoundException e) {
                        Log.w(TAG, ""Allowed package not found: "" + allowedPackage);
                        continue;
                    }
                }
            }
        }

        String[] disallowedArray = restrictions.getStringArray(RESTRICTION_DISALLOWED);
        if (disallowedArray != null) {
            for (int i = 0; i < disallowedArray.length; i++) {
                String disallowedPackage = disallowedArray[i];
                if (!TextUtils.isEmpty(disallowedPackage)) {
                    try {
                        builder.addDisallowedApplication(disallowedPackage);
                    } catch(NameNotFoundException e) {
                        Log.w(TAG, ""Disallowed package not found: "" + disallowedPackage);
                        continue;
                    }
                }
            }
        }

        if (allowedArray == null &&
            (SystemProperties.getInt(""persist.adb.tcp.port"", -1) > -1
            || SystemProperties.getInt(""service.adb.tcp.port"", -1) > -1)) {
            try {
                // If adb TCP port opened the test may be running by adb over network.
                // Add com.android.shell application into disallowed list to exclude adb socket
                // for VPN tests.
                builder.addDisallowedApplication(""com.android.shell"");
            } catch(NameNotFoundException e) {
                Log.w(TAG, ""com.android.shell not found"");
            }
        }

        builder.setMtu(MTU);
        builder.setBlocking(true);
        builder.setSession(TAG);

        mFd = builder.establish();
        if (mFd == null) {
            Log.e(TAG, ""Unable to establish file descriptor for VPN connection"");
            return;
        }
        Log.i(TAG, ""Established, fd="" + mFd.getFd());

        mPingReflector = new PingReflector(mFd.getFileDescriptor(), MTU);
        mPingReflector.start();
    }

    private void stop() {
        if (mPingReflector != null) {
            mPingReflector.interrupt();
            mPingReflector = null;
        }
        try {
            if (mFd != null) {
                Log.i(TAG, ""Closing filedescriptor"");
                mFd.close();
            }
        } catch(IOException e) {
            Log.w(TAG, ""Closing filedescriptor failed"", e);
        } finally {
            mFd = null;
        }
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.telephony.cts.SmsManagerTest"	"testSendAndReceiveMessages"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/SmsManagerTest.java"	""	"(timeout = 10 * 60 * 1000)
    public void testSendAndReceiveMessages() throws Exception {
        assertFalse(""[RERUN] SIM card does not provide phone number. Use a suitable SIM Card."",
                TextUtils.isEmpty(mDestAddr));

        String mccmnc = mTelephonyManager.getSimOperator();

        // send/receive single text sms with and without messageId
        sendAndReceiveSms(/* addMessageId= */ true);
        sendAndReceiveSms(/* addMessageId= */ false);

        // due to permission restrictions, currently there is no way to make this test app the
        // default SMS app

        if (mTelephonyManager.getPhoneType() == TelephonyManager.PHONE_TYPE_CDMA) {
            // TODO: temp workaround, OCTET encoding for EMS not properly supported
            return;
        }

        // send/receive data sms
        sendDataSms(mccmnc);

        // send/receive multi part text sms with and without messageId
        sendAndReceiveMultipartSms(mccmnc, /* addMessageId= */ true);
        sendAndReceiveMultipartSms(mccmnc, /* addMessageId= */ false);
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.telephony.cts.SmsManagerTest"	"testContentProviderAccessRestriction"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/SmsManagerTest.java"	""	"public void testContentProviderAccessRestriction() throws Exception {
        Uri dummySmsUri = null;
        Context context = getInstrumentation().getContext();
        ContentResolver contentResolver = context.getContentResolver();
        int originalWriteSmsMode = -1;
        String ctsPackageName = context.getPackageName();
        try {
            // Insert some test sms
            originalWriteSmsMode = context.getSystemService(AppOpsManager.class)
                    .unsafeCheckOpNoThrow(AppOpsManager.OPSTR_WRITE_SMS,
                            getPackageUid(ctsPackageName), ctsPackageName);
            setModeForOps(ctsPackageName,
                    AppOpsManager.MODE_ALLOWED, AppOpsManager.OPSTR_WRITE_SMS);
            ContentValues contentValues = new ContentValues();
            contentValues.put(Telephony.TextBasedSmsColumns.ADDRESS, ""addr"");
            contentValues.put(Telephony.TextBasedSmsColumns.READ, 1);
            contentValues.put(Telephony.TextBasedSmsColumns.SUBJECT, ""subj"");
            contentValues.put(Telephony.TextBasedSmsColumns.BODY, ""created_at_""
                    + new Date().toString().replace("" "", ""_""));

            dummySmsUri = contentResolver.insert(Telephony.Sms.CONTENT_URI, contentValues);
            assertNotNull(""Failed to insert test sms"", dummySmsUri);
            assertNotEquals(""Failed to insert test sms"", ""0"", dummySmsUri.getLastPathSegment());
            testSmsAccessAboutDefaultApp(LEGACY_SMS_APP);
            testSmsAccessAboutDefaultApp(MODERN_SMS_APP);
        } finally {
            if (dummySmsUri != null && !""/0"".equals(dummySmsUri.getLastPathSegment())) {
                final Uri finalDummySmsUri = dummySmsUri;
                executeWithShellPermissionIdentity(() -> contentResolver.delete(finalDummySmsUri,
                        null, null));
            }
            if (originalWriteSmsMode >= 0) {
                int finalOriginalWriteSmsMode = originalWriteSmsMode;
                executeWithShellPermissionIdentity(() ->
                        setModeForOps(ctsPackageName,
                                finalOriginalWriteSmsMode, AppOpsManager.OPSTR_WRITE_SMS));
            }
        }
    }

    private void testSmsAccessAboutDefaultApp(String pkg)
            throws Exception {
        String originalSmsApp = getSmsApp();
        assertNotEquals(pkg, originalSmsApp);
        assertCanAccessSms(pkg);
        try {
            setSmsApp(pkg);
            assertCanAccessSms(pkg);
        } finally {
            resetReadWriteSmsAppOps(pkg);
            setSmsApp(originalSmsApp);
        }
    }

    private void resetReadWriteSmsAppOps(String pkg) throws Exception {
        setModeForOps(pkg, AppOpsManager.MODE_DEFAULT,
                AppOpsManager.OPSTR_READ_SMS, AppOpsManager.OPSTR_WRITE_SMS);
    }

    private void setModeForOps(String pkg, int mode, String... ops) throws Exception {
        // We cannot reset these app ops to DEFAULT via current API, so we reset them manually here
        // temporarily as we will rewrite how the default SMS app is setup later.
        executeWithShellPermissionIdentity(() -> {
            int uid = getPackageUid(pkg);
            AppOpsManager appOpsManager =
                    getInstrumentation().getContext().getSystemService(AppOpsManager.class);
            for (String op : ops) {
                appOpsManager.setUidMode(op, uid, mode);
            }
        });
    }

    private int getPackageUid(String pkg) throws PackageManager.NameNotFoundException {
        return getInstrumentation().getContext().getPackageManager().getPackageUid(pkg, 0);
    }

    private String getSmsApp() throws Exception {
        return executeWithShellPermissionIdentity(() -> getInstrumentation()
                .getContext()
                .getSystemService(RoleManager.class)
                .getRoleHolders(RoleManager.ROLE_SMS)
                .get(0));
    }

    private void setSmsApp(String pkg) throws Exception {
        executeWithShellPermissionIdentity(() -> {
            Context context = getInstrumentation().getContext();
            RoleManager roleManager = context.getSystemService(RoleManager.class);
            CompletableFuture<Boolean> result = new CompletableFuture<>();
            if (roleManager.getRoleHoldersAsUser(RoleManager.ROLE_SMS,
                    context.getUser()).contains(pkg)) {
                result.complete(true);
            } else {
                roleManager.addRoleHolderAsUser(RoleManager.ROLE_SMS, pkg,
                        RoleManager.MANAGE_HOLDERS_FLAG_DONT_KILL_APP, context.getUser(),
                        AsyncTask.THREAD_POOL_EXECUTOR, result::complete);
            }
            assertTrue(result.get(5, TimeUnit.SECONDS));
        });
    }

    private <T> T executeWithShellPermissionIdentity(Callable<T> callable) throws Exception {
        if (sHasShellPermissionIdentity) {
            return callable.call();
        }
        UiAutomation uiAutomation = getInstrumentation().getUiAutomation(
                UiAutomation.FLAG_DONT_SUPPRESS_ACCESSIBILITY_SERVICES);
        uiAutomation.adoptShellPermissionIdentity();
        try {
            sHasShellPermissionIdentity = true;
            return callable.call();
        } finally {
            uiAutomation.dropShellPermissionIdentity();
            sHasShellPermissionIdentity = false;
        }
    }

    private void executeWithShellPermissionIdentity(RunnableWithException runnable)
            throws Exception {
        executeWithShellPermissionIdentity(() -> {
            runnable.run();
            return null;
        });
    }

    private interface RunnableWithException {
        void run() throws Exception;
    }

    private void assertCanAccessSms(String pkg) throws Exception {
        CompletableFuture<Bundle> callbackResult = new CompletableFuture<>();
        mContext.startActivity(new Intent()
                .setFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                .setComponent(new ComponentName(pkg, pkg + "".MainActivity""))
                .putExtra(""callback"", new RemoteCallback(callbackResult::complete)));

        Bundle bundle = callbackResult.get(20, TimeUnit.SECONDS);

        assertThat(bundle.getString(""class""), startsWith(pkg));
        assertThat(bundle.getString(""exceptionMessage""), anyOf(equalTo(null), emptyString()));
        assertThat(bundle.getInt(""queryCount""), greaterThan(0));
    }

    private void init() {
        mSendReceiver.reset();
        mDeliveryReceiver.reset();
        mDataSmsReceiver.reset();
        mSmsDeliverReceiver.reset();
        mSmsReceivedReceiver.reset();
        mSmsRetrieverReceiver.reset();
        mReceivedDataSms = false;
        sMessageId = 0L;
        mSentIntent = PendingIntent.getBroadcast(mContext, 0, mSendIntent,
                PendingIntent.FLAG_ONE_SHOT | PendingIntent.FLAG_MUTABLE_UNAUDITED);
        mDeliveredIntent = PendingIntent.getBroadcast(mContext, 0, mDeliveryIntent,
                PendingIntent.FLAG_ONE_SHOT | PendingIntent.FLAG_MUTABLE_UNAUDITED);
    }

    /**
     * Returns the number of parts sent in the message. If Multi-part SMS is not supported,
     * returns 0.
     */
    private int sendMultipartTextMessageIfSupported(String mccmnc, boolean addMessageId) {
        int numPartsSent = 0;
        if (!CarrierCapability.UNSUPPORT_MULTIPART_SMS_MESSAGES.contains(mccmnc)) {
            init();
            ArrayList<String> parts = divideMessage(LONG_TEXT);
            numPartsSent = parts.size();
            ArrayList<PendingIntent> sentIntents = new ArrayList<PendingIntent>();
            ArrayList<PendingIntent> deliveryIntents = new ArrayList<PendingIntent>();
            for (int i = 0; i < numPartsSent; i++) {
                sentIntents.add(PendingIntent.getBroadcast(mContext, 0, mSendIntent, PendingIntent.FLAG_MUTABLE_UNAUDITED));
                deliveryIntents.add(PendingIntent.getBroadcast(mContext, 0, mDeliveryIntent, PendingIntent.FLAG_MUTABLE_UNAUDITED));
            }
            sendMultiPartTextMessage(mDestAddr, parts, sentIntents, deliveryIntents, addMessageId);
        }
        return numPartsSent;
    }

    private boolean sendDataMessageIfSupported(String mccmnc) {
        if (!CarrierCapability.UNSUPPORT_DATA_SMS_MESSAGES.contains(mccmnc)) {
            byte[] data = mText.getBytes();
            short port = 19989;

            init();
            sendDataMessage(mDestAddr, port, data, mSentIntent, mDeliveredIntent);
            return true;
        }
        return false;
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.DevicePolicyLoggingParentTest"	"testUserRestrictionLogged"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/DevicePolicyLoggingParentTest.java"	""	"public void testUserRestrictionLogged() {
        mParentDevicePolicyManager.addUserRestriction(ADMIN_RECEIVER_COMPONENT,
                UserManager.DISALLOW_CONFIG_LOCATION);
        mParentDevicePolicyManager.clearUserRestriction(ADMIN_RECEIVER_COMPONENT,
                UserManager.DISALLOW_CONFIG_LOCATION);
    }

}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.widget.cts.TextViewTest"	"testFontResourcesXml_restrictedContext"	"CtsWidgetTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	"@MediumTest
    public void testFontResourcesXml_restrictedContext()
            throws PackageManager.NameNotFoundException {
        Context restrictedContext = mActivity.createPackageContext(mActivity.getPackageName(),
                Context.CONTEXT_RESTRICTED);
        LayoutInflater layoutInflater = (LayoutInflater) restrictedContext.getSystemService(
                Context.LAYOUT_INFLATER_SERVICE);
        View root = layoutInflater.inflate(R.layout.textview_restricted_layout, null);

        mTextView = root.findViewById(R.id.textview_fontresource_fontfamily);
        assertEquals(Typeface.DEFAULT, mTextView.getTypeface());
        mTextView = root.findViewById(R.id.textview_fontxmlresource_fontfamily);
        assertEquals(Typeface.DEFAULT, mTextView.getTypeface());
        mTextView = root.findViewById(R.id.textview_fontxmlresource_nonFontReference);
        assertEquals(Typeface.DEFAULT, mTextView.getTypeface());
        mTextView = root.findViewById(R.id.textview_fontresource_style);
        assertEquals(Typeface.DEFAULT, mTextView.getTypeface());
        mTextView = root.findViewById(R.id.textview_fontxmlresource_style);
        assertEquals(Typeface.DEFAULT, mTextView.getTypeface());
        mTextView = root.findViewById(R.id.textview_fontresource_textAppearance);
        assertEquals(Typeface.DEFAULT, mTextView.getTypeface());
        mTextView = root.findViewById(R.id.textview_fontxmlresource_textAppearance);
        assertEquals(Typeface.DEFAULT, mTextView.getTypeface());
    }

    @UiThreadTest"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.MixedProfileOwnerTest"	"testPackageInstallUserRestrictions"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/MixedProfileOwnerTest.java"	""	"public void testPackageInstallUserRestrictions() throws Exception {
        super.testPackageInstallUserRestrictions();
    }

    @Override"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.TestImsService"	"TestImsRegistration"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/TestImsService.java"	""	"public void test/*
 *.
 */

package android.telephony.ims.cts;

import android.app.Service;
import android.content.Context;
import android.content.Intent;
import android.os.Binder;
import android.os.IBinder;
import android.telephony.ims.ImsService;
import android.telephony.ims.feature.MmTelFeature;
import android.telephony.ims.feature.RcsFeature;
import android.telephony.ims.stub.ImsConfigImplBase;
import android.telephony.ims.stub.ImsFeatureConfiguration;
import android.telephony.ims.stub.ImsRegistrationImplBase;
import android.telephony.ims.stub.SipTransportImplBase;
import android.util.Log;


import androidx.annotation.Nullable;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

/**
 * A Test ImsService that will verify ImsService functionality.
 */
public class TestImsService extends Service {

    private static final String TAG = ""GtsImsTestImsService"";

    private static final TestImsRegistration sImsRegistrationImplBase =
            new TestImsRegistration();

    private TestRcsFeature mTestRcsFeature;
    private TestMmTelFeature mTestMmTelFeature;
    private TestImsConfig mTestImsConfig;
    private TestSipTransport mTestSipTransport;
    private ImsService mTestImsService;
    private boolean mIsEnabled = false;
    private boolean mSetNullRcsBinding = false;
    private boolean mIsSipTransportImplemented = false;
    private long mCapabilities = 0;
    private ImsFeatureConfiguration mFeatureConfig;
    private final Object mLock = new Object();

    public static final int LATCH_FEATURES_READY = 0;
    public static final int LATCH_ENABLE_IMS = 1;
    public static final int LATCH_DISABLE_IMS = 2;
    public static final int LATCH_CREATE_MMTEL = 3;
    public static final int LATCH_CREATE_RCS = 4;
    public static final int LATCH_REMOVE_MMTEL = 5;
    public static final int LATCH_REMOVE_RCS = 6;
    public static final int LATCH_MMTEL_READY = 7;
    public static final int LATCH_RCS_READY = 8;
    public static final int LATCH_MMTEL_CAP_SET = 9;
    public static final int LATCH_RCS_CAP_SET = 10;
    public static final int LATCH_UCE_LISTENER_SET = 11;
    public static final int LATCH_UCE_REQUEST_PUBLISH = 12;
    private static final int LATCH_MAX = 13;
    protected static final CountDownLatch[] sLatches = new CountDownLatch[LATCH_MAX];
    static {
        for (int i = 0; i < LATCH_MAX; i++) {
            sLatches[i] = new CountDownLatch(1);
        }
    }

    interface RemovedListener {
        void onRemoved();
    }
    interface ReadyListener {
        void onReady();
    }
    interface CapabilitiesSetListener {
        void onSet();
    }
    interface RcsCapabilityExchangeEventListener {
        void onSet();
    }
    interface DeviceCapPublishListener {
        void onPublish();
    }

    // This is defined here instead TestImsService extending ImsService directly because the GTS
    // tests were failing to run on pre-P devices. Not sure why, but TestImsService is loaded
    // even if it isn't used.
    private class ImsServiceUT extends ImsService {

        ImsServiceUT(Context context) {
            // As explained above, ImsServiceUT is created in order to get around classloader
            // restrictions. Attach the base context from the wrapper ImsService.
            if (getBaseContext() == null) {
                attachBaseContext(context);
            }
            mTestImsConfig = new TestImsConfig();
            // For testing, just run on binder thread until required otherwise.
            mTestSipTransport = new TestSipTransport(Runnable::run);
        }

        @Override
        public ImsFeatureConfiguration querySupportedImsFeatures() {
            return getFeatureConfig();
        }

        @Override
        public long getImsServiceCapabilities() {
            return mCapabilities;
        }

        @Override
        public void readyForFeatureCreation() {
            synchronized (mLock) {
                countDownLatch(LATCH_FEATURES_READY);
            }
        }

        @Override
        public void enableIms(int slotId) {
            synchronized (mLock) {
                countDownLatch(LATCH_ENABLE_IMS);
                setIsEnabled(true);
            }
        }

        @Override
        public void disableIms(int slotId) {
            synchronized (mLock) {
                countDownLatch(LATCH_DISABLE_IMS);
                setIsEnabled(false);
            }
        }

        @Override
        public RcsFeature createRcsFeature(int slotId) {
            synchronized (mLock) {
                countDownLatch(LATCH_CREATE_RCS);
                mTestRcsFeature = new TestRcsFeature(getBaseContext(),
                        //onReady
                        () -> {
                            synchronized (mLock) {
                                countDownLatch(LATCH_RCS_READY);
                            }
                        },
                        //onRemoved
                        () -> {
                            synchronized (mLock) {
                                countDownLatch(LATCH_REMOVE_RCS);
                                mTestRcsFeature = null;
                            }
                        },
                        //onCapabilitiesSet
                        () -> {
                            synchronized (mLock) {
                                countDownLatch(LATCH_RCS_CAP_SET);
                            }
                        },
                        () -> {
                            synchronized (mLock) {
                                countDownLatch(LATCH_UCE_LISTENER_SET);
                        }
                        });

                // Setup UCE request listener
                mTestRcsFeature.setDeviceCapPublishListener(() -> {
                    synchronized (mLock) {
                        countDownLatch(LATCH_UCE_REQUEST_PUBLISH);
                    }
                });

                if (mSetNullRcsBinding) {
                    return null;
                }
                return mTestRcsFeature;
            }
        }

        @Override
        public ImsConfigImplBase getConfig(int slotId) {
            return mTestImsConfig;
        }

        @Override
        public MmTelFeature createMmTelFeature(int slotId) {
            synchronized (mLock) {
                countDownLatch(LATCH_CREATE_MMTEL);
                mTestMmTelFeature = new TestMmTelFeature(
                        //onReady
                        () -> {
                            synchronized (mLock) {
                                countDownLatch(LATCH_MMTEL_READY);
                            }
                        },
                        //onRemoved
                        () -> {
                            synchronized (mLock) {
                                countDownLatch(LATCH_REMOVE_MMTEL);
                                mTestMmTelFeature = null;
                            }
                        },
                        //onCapabilitiesSet
                        () -> {
                            synchronized (mLock) {
                                countDownLatch(LATCH_MMTEL_CAP_SET);
                            }
                        }
                        );
                return mTestMmTelFeature;
            }
        }

        @Override
        public ImsRegistrationImplBase getRegistration(int slotId) {
            return sImsRegistrationImplBase;
        }

        @Nullable
        @Override
        public SipTransportImplBase getSipTransport(int slotId) {
            if (mIsSipTransportImplemented) {
                return mTestSipTransport;
            } else {
                return null;
            }
        }
    }

    private final LocalBinder mBinder = new LocalBinder();
    // For local access of this Service.
    class LocalBinder extends Binder {
        TestImsService getService() {
            return TestImsService.this;
        }
    }

    protected ImsService getImsService() {
        synchronized (mLock) {
            if (mTestImsService != null) {
                return mTestImsService;
            }
            mTestImsService = new ImsServiceUT(this);
            return mTestImsService;
        }
    }

    @Override
    public IBinder onBind(Intent intent) {
        if (""android.telephony.ims.ImsService"".equals(intent.getAction())) {
            if (ImsUtils.VDBG) {
                Log.d(TAG, ""onBind-Remote"");
            }
            return getImsService().onBind(intent);
        }
        if (ImsUtils.VDBG) {
            Log.i(TAG, ""onBind-Local"");
        }
        return mBinder;
    }

    public void resetState() {
        synchronized (mLock) {
            mTestMmTelFeature = null;
            mTestRcsFeature = null;
            mIsEnabled = false;
            mSetNullRcsBinding = false;
            mIsSipTransportImplemented = false;
            mCapabilities = 0;
            for (int i = 0; i < LATCH_MAX; i++) {
                sLatches[i] = new CountDownLatch(1);
            }
        }
    }

    // Sets the feature configuration. Make sure to call this before initiating Bind to this
    // ImsService.
    public void setFeatureConfig(ImsFeatureConfiguration f) {
        synchronized (mLock) {
            mFeatureConfig = f;
        }
    }

    public ImsFeatureConfiguration getFeatureConfig() {
        synchronized (mLock) {
            return mFeatureConfig;
        }
    }

    public boolean isEnabled() {
        synchronized (mLock) {
            return mIsEnabled;
        }
    }

    public void setNullRcsBinding() {
        synchronized (mLock) {
            mSetNullRcsBinding = true;
        }
    }

    public void setIsEnabled(boolean isEnabled) {
        synchronized (mLock) {
            mIsEnabled = isEnabled;
        }
    }

    public void addCapabilities(long capabilities) {
        synchronized (mLock) {
            mCapabilities |= capabilities;
        }
    }

    public void setSipTransportImplemented() {
        synchronized (mLock) {
            mIsSipTransportImplemented = true;
        }
    }

    public boolean waitForLatchCountdown(int latchIndex) {
        boolean complete = false;
        try {
            CountDownLatch latch;
            synchronized (mLock) {
                latch = sLatches[latchIndex];
            }
            complete = latch.await(ImsUtils.TEST_TIMEOUT_MS, TimeUnit.MILLISECONDS);
        } catch (InterruptedException e) {
            // complete == false
        }
        synchronized (mLock) {
            sLatches[latchIndex] = new CountDownLatch(1);
        }
        return complete;
    }

    public boolean waitForLatchCountdown(int latchIndex, long waitMs) {
        boolean complete = false;
        try {
            CountDownLatch latch;
            synchronized (mLock) {
                latch = sLatches[latchIndex];
            }
            complete = latch.await(waitMs, TimeUnit.MILLISECONDS);
        } catch (InterruptedException e) {
            // complete == false
        }
        synchronized (mLock) {
            sLatches[latchIndex] = new CountDownLatch(1);
        }
        return complete;
    }

    public void countDownLatch(int latchIndex) {
        synchronized (mLock) {
            sLatches[latchIndex].countDown();
        }
    }

    public TestMmTelFeature getMmTelFeature() {
        synchronized (mLock) {
            return mTestMmTelFeature;
        }
    }

    public TestRcsFeature getRcsFeature() {
        synchronized (mLock) {
            return mTestRcsFeature;
        }
    }

    public TestSipTransport getSipTransport() {
        synchronized (mLock) {
            return mTestSipTransport;
        }
    }

    public TestImsRegistration getImsRegistration() {
        synchronized (mLock) {
            return sImsRegistrationImplBase;
        }
    }

    public ImsConfigImplBase getConfig() {
        return mTestImsConfig;
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.host.accounts.BaseMultiUserTest"	"listUsers"	"CtsAccountsHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/accounts/src/android/host/accounts/BaseMultiUserTest.java"	""	"public void test/*
 *
 */
package android.host.accounts;

import static org.junit.Assert.fail;

import com.android.tradefed.device.CollectingOutputReceiver;
import com.android.tradefed.device.DeviceNotAvailableException;
import com.android.tradefed.device.ITestDevice;
import com.android.tradefed.log.LogUtil.CLog;
import com.android.tradefed.testtype.IDeviceTest;

import org.junit.After;
import org.junit.Before;

import java.io.IOException;
import java.util.ArrayList;
import java.util.concurrent.TimeUnit;

/**
 * Base class for multi user tests.
 */
public class BaseMultiUserTest implements IDeviceTest {

    /** Guest flag value from android/content/pm/UserInfo.java */
    private static final int FLAG_GUEST = 0x00000004;

    /**
     * Feature flag for automotive devices
     * https://source.android.com/compatibility/android-cdd#2_5_automotive_requirements
     */
    private static final String FEATURE_AUTOMOTIVE = ""feature:android.hardware.type.automotive"";
    private static final String FEATURE_MANAGED_USERS = ""android.software.managed_users"";

    /** Whether multi-user is supported. */
    protected boolean mSupportsMultiUser;
    protected boolean mSupportsManagedUsers;
    protected int mInitialUserId;
    protected int mPrimaryUserId;

    /** Users we shouldn't delete in the tests. */
    private ArrayList<Integer> mFixedUsers;

    private ITestDevice mDevice;

    @Before
    public void setUp() throws Exception {
        mSupportsMultiUser = getDevice().getMaxNumberOfUsersSupported() > 1;
        mSupportsManagedUsers = getDevice().hasFeature(FEATURE_MANAGED_USERS);

        mInitialUserId = getDevice().getCurrentUser();
        mPrimaryUserId = getDevice().getPrimaryUserId();

        // Test should not modify / remove any of the existing users.
        mFixedUsers = getDevice().listUsers();
    }

    @After
    public void tearDown() throws Exception {
        if (getDevice().getCurrentUser() != mInitialUserId) {
            CLog.w(""User changed during test. Switching back to "" + mInitialUserId);
            getDevice().switchUser(mInitialUserId);
        }
        // Remove the users created during this test.
        removeTestUsers();
    }

    @Override
    public void setDevice(ITestDevice device) {
        mDevice = device;
    }

    @Override
    public ITestDevice getDevice() {
        return mDevice;
    }

    /**
     * @param userId the userId of the parent for this profile
     * @return the userId of the created user
     */
    protected int createRestrictedProfile(int userId)
            throws DeviceNotAvailableException, IllegalStateException {
        return createUser(""--profileOf "" + userId + "" --restricted"");
    }

    /**
     * @param userId the userId of the parent for this profile
     * @return the userId of the created user
     */
    protected int createProfile(int userId)
            throws DeviceNotAvailableException, IllegalStateException {
        return createUser(""--profileOf "" + userId + "" --managed"");
    }

    /**
     * @return the userid of the created user
     */
    protected int createUser()
            throws DeviceNotAvailableException, IllegalStateException {
        return createUser("""");
    }

    private int createUser(String extraParam)
            throws DeviceNotAvailableException, IllegalStateException {
        final String command =
                ""pm create-user "" + extraParam + "" TestUser_"" + System.currentTimeMillis();
        CLog.d(""Starting command: "" + command);
        final String output = getDevice().executeShellCommand(command);
        CLog.d(""Output for command "" + command + "": "" + output);

        if (output.startsWith(""Success"")) {
            try {
                return Integer.parseInt(output.substring(output.lastIndexOf("" "")).trim());
            } catch (NumberFormatException e) {
                CLog.e(""Failed to parse result: %s"", output);
            }
        } else {
            CLog.e(""Failed to create user: %s"", output);
        }
        throw new IllegalStateException();
    }

    protected int createGuestUser() throws Exception {
        return mDevice.createUser(
                ""TestUser_"" + System.currentTimeMillis() /* name */,
                true /* guest */,
                false /* ephemeral */);
    }

    protected int getGuestUser() throws Exception {
        for (int userId : mDevice.listUsers()) {
            if ((mDevice.getUserFlags(userId) & FLAG_GUEST) != 0) {
                return userId;
            }
        }
        return -1;
    }

    protected boolean isAutomotiveDevice() throws Exception {
        return getDevice().hasFeature(FEATURE_AUTOMOTIVE);
    }

    private void removeTestUsers() throws Exception {
        for (int userId : getDevice().listUsers()) {
            if (!mFixedUsers.contains(userId)) {
                getDevice().removeUser(userId);
            }
        }
    }

    protected void waitForBroadcastIdle() throws DeviceNotAvailableException, IOException {
        final CollectingOutputReceiver receiver = new CollectingOutputReceiver();
        // We allow 8min for the command to complete and 4min for the command to start to
        // output something.
        getDevice().executeShellCommand(
                ""am wait-for-broadcast-idle"", receiver, 8, 4, TimeUnit.MINUTES, 0);
        final String output = receiver.getOutput();
        if (!output.contains(""All broadcast queues are idle!"")) {
            CLog.e(""Output from 'am wait-for-broadcast-idle': %s"", output);
            fail(""'am wait-for-broadcase-idle' did not complete."");
        }
    }
}"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.appsecurity.cts.ApexSignatureVerificationTest"	"getApexPackageList"	"CtsAppSecurityHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/ApexSignatureVerificationTest.java"	""	"/*
 *.
 */

package android.appsecurity.cts;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import android.platform.test.annotations.RestrictedBuildTest;

import com.android.tradefed.device.DeviceNotAvailableException;
import com.android.tradefed.device.ITestDevice;
import com.android.tradefed.testtype.DeviceJUnit4ClassRunner;
import com.android.tradefed.testtype.junit4.BaseHostJUnit4Test;
import com.android.tradefed.util.FileUtil;
import com.android.tradefed.util.ZipUtil;

import org.hamcrest.CustomTypeSafeMatcher;
import org.hamcrest.Matcher;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.Ignore;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ErrorCollector;
import org.junit.rules.TestRule;
import org.junit.runner.Description;
import org.junit.runner.RunWith;
import org.junit.runners.model.Statement;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.net.URISyntaxException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.regex.Pattern;
import java.util.zip.ZipEntry;
import java.util.zip.ZipException;
import java.util.zip.ZipFile;

/**
 * Tests for APEX signature verification to ensure preloaded APEXes
 * DO NOT signed with well-known keys.
 */
@RunWith(DeviceJUnit4ClassRunner.class)
public class ApexSignatureVerificationTest extends BaseHostJUnit4Test {

    private static final String TEST_BASE = ""ApexSignatureVerificationTest"";
    private static final String TEST_APEX_SOURCE_DIR_PREFIX = ""tests-apex_"";
    private static final String APEX_PUB_KEY_NAME = ""apex_pubkey"";

    private static final Pattern WELL_KNOWN_PUBKEY_PATTERN = Pattern.compile(
            ""^apexsigverify\\/.*.avbpubkey"");

    private static boolean mHasTestFailure;

    private static File mBasePath;
    private static File mWellKnownKeyStorePath;
    private static File mArchiveZip;

    private static Map<String, String> mPreloadedApexPathMap = new HashMap<>();
    private static Map<String, File> mLocalApexFileMap = new HashMap<>();
    private static Map<String, File> mExtractedTestDirMap = new HashMap<>();
    private static List<File> mWellKnownKeyFileList = new ArrayList<>();
    private ITestDevice mDevice;

    @Rule
    public final ErrorCollector mErrorCollector = new ErrorCollector();

    @Before
    public void setUp() throws Exception {
        mDevice = getDevice();
        if (mBasePath == null && mWellKnownKeyStorePath == null
                && mExtractedTestDirMap.size() == 0) {
            mBasePath = FileUtil.createTempDir(TEST_BASE);
            mBasePath.deleteOnExit();
            mWellKnownKeyStorePath = FileUtil.createTempDir(""wellknownsignatures"", mBasePath);
            mWellKnownKeyStorePath.deleteOnExit();
            pullWellKnownSignatures();
            getApexPackageList();
            pullApexFiles();
            extractApexFiles();
        }
    }

    @AfterClass
    public static void tearDownClass() throws IOException {
        if (mArchiveZip == null && mHasTestFailure) {
            // Archive all operation data and materials in host
            // /tmp/ApexSignatureVerificationTest.zip
            // in case the test result is not expected and need to debug.
            mArchiveZip = ZipUtil.createZip(mBasePath, mBasePath.getName());
        }
    }

    @Rule
    public final OnFailureRule mDumpOnFailureRule = new OnFailureRule() {
        @Override
        protected void onTestFailure(Statement base, Description description, Throwable t) {
            mHasTestFailure = true;
        }
    };"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.appsecurity.cts.ApexSignatureVerificationTest"	"testApexIncludePubKey"	"CtsAppSecurityHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/ApexSignatureVerificationTest.java"	""	"public void testApexIncludePubKey() {
        for (Map.Entry<String, File> entry : mExtractedTestDirMap.entrySet()) {
            final File pubKeyFile = FileUtil.findFile(entry.getValue(), APEX_PUB_KEY_NAME);

            assertWithMessage(""apex:"" + entry.getKey() + "" do not contain pubkey"").that(
                    pubKeyFile.exists()).isTrue();
        }
    }

    /**
     * Assert that the preloaded apexes are secure, not signed with wellknown keys.
     *
     * Debuggable aosp or gsi rom could not preload official apexes module allowing.
     *
     * Note: This test will fail on userdebug / eng devices, but should pass
     * on production (user) builds.
     */
    @SuppressWarnings(""productionOnly"")
    @RestrictedBuildTest"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.managedprofile.CrossProfileUtils"	"testDisallowCrossProfileCopyPaste"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/ManagedProfile/src/com/android/cts/managedprofile/CrossProfileUtils.java"	""	"public void testDisallowCrossProfileCopyPaste() {
        DevicePolicyManager dpm = (DevicePolicyManager)
               getContext().getSystemService(Context.DEVICE_POLICY_SERVICE);
        dpm.addUserRestriction(ADMIN_RECEIVER_COMPONENT,
                UserManager.DISALLOW_CROSS_PROFILE_COPY_PASTE);
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.managedprofile.CrossProfileUtils"	"testAllowCrossProfileCopyPaste"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/ManagedProfile/src/com/android/cts/managedprofile/CrossProfileUtils.java"	""	"public void testAllowCrossProfileCopyPaste() {
        DevicePolicyManager dpm = (DevicePolicyManager)
               getContext().getSystemService(Context.DEVICE_POLICY_SERVICE);
        dpm.clearUserRestriction(ADMIN_RECEIVER_COMPONENT,
                UserManager.DISALLOW_CROSS_PROFILE_COPY_PASTE);
    }

    // Disables all browsers in current user"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.ContentSuggestionsRestrictionsTest"	"disableService"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/ContentSuggestionsRestrictionsTest.java"	""	"public void test/*
 *
 */

package com.android.cts.deviceandprofileowner;

import static android.os.UserManager.DISALLOW_CONTENT_SUGGESTIONS;

import static com.android.cts.deviceandprofileowner.ContentSuggestionsActivity.CONTENT_SUGGESTIONS_ACTIVITY_NAME;
import static com.android.cts.deviceandprofileowner.ContentSuggestionsActivity.CONTENT_SUGGESTIONS_PACKAGE_NAME;

import android.content.Intent;

public class ContentSuggestionsRestrictionsTest extends BaseDeviceAdminTest {

    private static final int MAX_TIME_TEMPORARY_SERVICE_CAN_BE_SET= 12000;

    private static final int SLEEP_TIME_WAITING_FOR_SERVICE_CONNECTION_MS = 100;

    private static final String SERVICE_NAME =
            ""com.android.cts.devicepolicy.contentsuggestions/.SimpleContentSuggestionsService"";

    int mUserId;

    @Override
    protected void setUp() throws Exception {
        super.setUp();

        mUserId = getInstrumentation().getContext().getUserId();
    }

    @Override
    protected void tearDown() throws Exception {
        try {
            disableService();
        } finally {
            mDevicePolicyManager.clearUserRestriction(ADMIN_RECEIVER_COMPONENT,
                    DISALLOW_CONTENT_SUGGESTIONS);
        }
        super.tearDown();
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.ContentSuggestionsRestrictionsTest"	"testDisallowContentSuggestions_allowed"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/ContentSuggestionsRestrictionsTest.java"	""	"public void testDisallowContentSuggestions_allowed() throws Exception {
        enableService();

        final boolean enabledBefore = launchActivityAndGetEnabled();
        assertTrue(enabledBefore);

        mDevicePolicyManager.addUserRestriction(
                ADMIN_RECEIVER_COMPONENT, DISALLOW_CONTENT_SUGGESTIONS);

        // Must try a couple times because it will be disabled asynchronously.
        for (int i = 1; i <= 5; i++) {
            final boolean disabledAfter = !launchActivityAndGetEnabled();
            if (disabledAfter) {
                return;
            }
            Thread.sleep(100);
        }
        fail(""Not disabled after 2.5s"");
    }

    private boolean launchActivityAndGetEnabled() throws Exception {
        final Intent launchIntent = new Intent();
        launchIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        launchIntent.setClassName(
                CONTENT_SUGGESTIONS_PACKAGE_NAME, CONTENT_SUGGESTIONS_ACTIVITY_NAME);
        final ContentSuggestionsActivity activity = launchActivity(
                ""com.android.cts.deviceandprofileowner"", ContentSuggestionsActivity.class, null);
        return activity.isContentSuggestionsEnabled();
    }

    private void enableService() throws Exception {
        runShellCommand(""cmd content_suggestions set temporary-service %d %s %d"", mUserId,
                SERVICE_NAME, MAX_TIME_TEMPORARY_SERVICE_CAN_BE_SET);
        // TODO: ideally it should wait until the service's onConnected() is called, but that
        // would be too complicated
        Thread.sleep(SLEEP_TIME_WAITING_FOR_SERVICE_CONNECTION_MS);
    }

    private void disableService() {
        runShellCommand(""cmd content_suggestions set temporary-service %d"", mUserId);
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.managedprovisioning.DeviceOwnerPositiveTestActivity"	"finish"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/managedprovisioning/DeviceOwnerPositiveTestActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.managedprovisioning;

import static android.os.UserHandle.myUserId;

import static com.android.cts.verifier.managedprovisioning.Utils.createInteractiveTestItem;

import android.app.Activity;
import android.app.AlertDialog;
import android.app.admin.DevicePolicyManager;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.database.DataSetObserver;
import android.os.Bundle;
import android.os.UserManager;
import android.provider.Settings;
import android.util.Log;
import android.view.View;
import android.view.View.OnClickListener;

import com.android.bedstead.dpmwrapper.TestAppSystemServiceFactory;
import com.android.cts.verifier.ArrayTestListAdapter;
import com.android.cts.verifier.IntentDrivenTestActivity.ButtonInfo;
import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;
import com.android.cts.verifier.TestListAdapter.TestListItem;
import com.android.cts.verifier.TestResult;

/**
 * Activity that lists all positive device owner tests. Requires the following adb command be issued
 * by the user prior to starting the tests:
 *
 * adb shell dpm set-device-owner
 *  'com.android.cts.verifier/com.android.cts.verifier.managedprovisioning.DeviceAdminTestReceiver'
 */
public class DeviceOwnerPositiveTestActivity extends PassFailButtons.TestListActivity {
    private static final String TAG = ""DeviceOwnerPositiveTestActivity"";

    private static final String ACTION_CHECK_DEVICE_OWNER =
            ""com.android.cts.verifier.managedprovisioning.action.CHECK_DEVICE_OWNER"";
    private static final String ACTION_CHECK_PROFILE_OWNER =
            ""com.android.cts.verifier.managedprovisioning.action.CHECK_PROFILE_OWNER"";
    private static final String ACTION_CHECK_CURRENT_USER_AFFILIATED =
            ""com.android.cts.verifier.managedprovisioning.action.CHECK_USER_AFFILIATED"";

    static final String EXTRA_TEST_ID = ""extra-test-id"";

    private static final String CHECK_DEVICE_OWNER_TEST_ID = ""CHECK_DEVICE_OWNER"";
    private static final String CHECK_PROFILE_OWNER_TEST_ID = ""CHECK_PROFILE_OWNER"";
    private static final String CHECK_USER_AFFILIATED_TEST_ID = ""CHECK_USER_AFFILIATED"";
    private static final String DEVICE_ADMIN_SETTINGS_ID = ""DEVICE_ADMIN_SETTINGS"";
    private static final String WIFI_LOCKDOWN_TEST_ID = WifiLockdownTestActivity.class.getName();
    private static final String DISABLE_STATUS_BAR_TEST_ID = ""DISABLE_STATUS_BAR"";
    private static final String DISABLE_KEYGUARD_TEST_ID = ""DISABLE_KEYGUARD"";
    private static final String LOCK_TASK_UI_TEST_ID = ""LOCK_TASK_UI"";
    private static final String CHECK_PERMISSION_LOCKDOWN_TEST_ID =
            PermissionLockdownTestActivity.class.getName();
    private static final String DISALLOW_CONFIG_BT_ID = ""DISALLOW_CONFIG_BT"";
    private static final String DISALLOW_CONFIG_WIFI_ID = ""DISALLOW_CONFIG_WIFI"";
    private static final String DISALLOW_CONFIG_VPN_ID = ""DISALLOW_CONFIG_VPN"";
    private static final String DISALLOW_USB_FILE_TRANSFER_ID = ""DISALLOW_USB_FILE_TRANSFER"";
    private static final String SET_USER_ICON_TEST_ID = ""SET_USER_ICON"";
    private static final String DISALLOW_DATA_ROAMING_ID = ""DISALLOW_DATA_ROAMING"";
    private static final String DISALLOW_FACTORY_RESET_ID = ""DISALLOW_FACTORY_RESET"";
    private static final String POLICY_TRANSPARENCY_TEST_ID = ""POLICY_TRANSPARENCY"";
    private static final String ENTERPRISE_PRIVACY_TEST_ID = ""ENTERPRISE_PRIVACY"";
    private static final String NETWORK_LOGGING_UI_TEST_ID = ""NETWORK_LOGGING_UI"";
    private static final String DISALLOW_USER_SWITCH_TEST_ID = ""DISALLOW_USER_SWITCH"";
    private static final String USER_SWITCHER_MESSAGE_TEST_ID = ""USER_SWITCHER_MESSAGE"";
    private static final String ENABLE_LOGOUT_TEST_ID = ""ENABLE_LOGOUT"";
    private static final String MANAGED_USER_TEST_ID = ""MANAGED_USER_UI"";
    private static final String REMOVE_DEVICE_OWNER_TEST_ID = ""REMOVE_DEVICE_OWNER"";
    private static final String DISALLOW_AMBIENT_DISPLAY_ID = ""DISALLOW_AMBIENT_DISPLAY"";
    private static final String DISALLOW_REMOVE_USER_TEST_ID = ""DISALLOW_REMOVE_USER"";
    private static final String DISABLE_USB_DATA_SIGNALING_TEST_ID = ""DISABLE_USB_DATA_SIGNALING"";
    private static final String SET_REQUIRED_PASSWORD_COMPLEXITY_ID =
            ""SET_REQUIRED_PASSWORD_COMPLEXITY"";

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        // Tidy up in case previous run crashed.
        new ByodFlowTestHelper(this).tearDown();

        if (ACTION_CHECK_DEVICE_OWNER.equals(getIntent().getAction())) {
            DevicePolicyManager dpm = TestAppSystemServiceFactory.getDevicePolicyManager(this,
                    DeviceAdminTestReceiver.class);
            if (dpm.isDeviceOwnerApp(getPackageName())) {
                // Set DISALLOW_ADD_USER on behalf of ManagedProvisioning.
                dpm.addUserRestriction(DeviceAdminTestReceiver.getReceiverComponentName(),
                        UserManager.DISALLOW_ADD_USER);
                TestResult.setPassedResult(this, getIntent().getStringExtra(EXTRA_TEST_ID),
                        null, null);
            } else {
                TestResult.setFailedResult(this, getIntent().getStringExtra(EXTRA_TEST_ID),
                        getString(R.string.device_owner_incorrect_profile_owner, myUserId()),
                        null);
            }

            finish();
            return;
        }
        if (ACTION_CHECK_PROFILE_OWNER.equals(getIntent().getAction())) {
            DevicePolicyManager dpm = getSystemService(DevicePolicyManager.class);
            if (dpm.isProfileOwnerApp(getPackageName())) {
                TestResult.setPassedResult(this, getIntent().getStringExtra(EXTRA_TEST_ID),
                        null, null);
            } else {
                TestResult.setFailedResult(this, getIntent().getStringExtra(EXTRA_TEST_ID),
                        getString(R.string.device_owner_incorrect_device_owner, myUserId()), null);
            }
            finish();
            return;
        }
        if (ACTION_CHECK_CURRENT_USER_AFFILIATED.equals(getIntent().getAction())) {
            DevicePolicyManager dpm = getSystemService(DevicePolicyManager.class);
            if (dpm.isAffiliatedUser()) {
                TestResult.setPassedResult(this, getIntent().getStringExtra(EXTRA_TEST_ID),
                        null, null);
            } else {
                TestResult.setFailedResult(this, getIntent().getStringExtra(EXTRA_TEST_ID),
                        getString(R.string.device_owner_user_not_affiliated, myUserId()), null);
            }
            finish();
            return;
        }

        setContentView(R.layout.positive_device_owner);
        setInfoResources(R.string.device_owner_positive_tests,
                R.string.device_owner_positive_tests_info, 0);
        setPassFailButtonClickListeners();

        final ArrayTestListAdapter adapter = new ArrayTestListAdapter(this);
        adapter.add(TestListItem.newCategory(this, R.string.device_owner_positive_category));

        addTestsToAdapter(adapter);

        adapter.registerDataSetObserver(new DataSetObserver() {
            @Override
            public void onChanged() {
                updatePassButton();
            }
        });

        setTestListAdapter(adapter);

        View setDeviceOwnerButton = findViewById(R.id.set_device_owner_button);
        setDeviceOwnerButton.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                StringBuilder builder = new StringBuilder();
                if (UserManager.isHeadlessSystemUserMode()) {
                    builder.append(getString(R.string.grant_headless_system_user_permissions));
                }

                String message = builder.append(getString(R.string.set_device_owner_dialog_text))
                        .toString();
                Log.i(TAG, message);
                new AlertDialog.Builder(
                        DeviceOwnerPositiveTestActivity.this)
                        .setIcon(android.R.drawable.ic_dialog_info)
                        .setTitle(R.string.set_device_owner_dialog_title)
                        .setMessage(message)
                        .setPositiveButton(android.R.string.ok, null)
                        .show();
            }
        });

    }

    @Override
    public void finish() {
        String action = getIntent().getAction();
        switch(action != null ? action : """") {
            case ACTION_CHECK_DEVICE_OWNER:
            case ACTION_CHECK_PROFILE_OWNER:
            case ACTION_CHECK_CURRENT_USER_AFFILIATED:
                // If this activity was started for checking device / profile owner status, then no
                // need to do any tear down.
                Log.d(TAG, ""NOT starting createTearDownIntent() due to "" + action);
                break;
            default:
                // Pass and fail buttons are known to call finish() when clicked,
                // and this is when we want to remove the device owner.
                Log.d(TAG, ""Starting createTearDownIntent() due to "" + action);
                startActivity(createTearDownIntent());
                break;
        }
        super.finish();
    }

    private void addTestsToAdapter(final ArrayTestListAdapter adapter) {
        adapter.add(createTestItem(this, CHECK_DEVICE_OWNER_TEST_ID,
                R.string.device_owner_check_device_owner_test,
                new Intent(ACTION_CHECK_DEVICE_OWNER)
                        .putExtra(EXTRA_TEST_ID, getIntent().getStringExtra(EXTRA_TEST_ID))));
        if (UserManager.isHeadlessSystemUserMode()) {
            adapter.add(createTestItem(this, CHECK_PROFILE_OWNER_TEST_ID,
                    R.string.device_owner_check_profile_owner_test,
                    new Intent(ACTION_CHECK_PROFILE_OWNER)
                            .putExtra(EXTRA_TEST_ID, getIntent().getStringExtra(EXTRA_TEST_ID))));
            adapter.add(createTestItem(this, CHECK_USER_AFFILIATED_TEST_ID,
                    R.string.device_owner_check_user_affiliation_test,
                    new Intent(ACTION_CHECK_CURRENT_USER_AFFILIATED)
                            .putExtra(EXTRA_TEST_ID, getIntent().getStringExtra(EXTRA_TEST_ID))));
        }

        // device admin settings
        adapter.add(createInteractiveTestItem(this, DEVICE_ADMIN_SETTINGS_ID,
                R.string.device_owner_device_admin_visible,
                R.string.device_owner_device_admin_visible_info,
                new ButtonInfo(
                        R.string.device_owner_settings_go,
                        new Intent(Settings.ACTION_SECURITY_SETTINGS))));

        PackageManager packageManager = getPackageManager();
        if (packageManager.hasSystemFeature(PackageManager.FEATURE_WIFI)) {
            // WiFi Lock down tests
            adapter.add(createTestItem(this, WIFI_LOCKDOWN_TEST_ID,
                    R.string.device_owner_wifi_lockdown_test,
                    new Intent(this, WifiLockdownTestActivity.class)));

            // DISALLOW_CONFIG_WIFI
            adapter.add(createInteractiveTestItem(this, DISALLOW_CONFIG_WIFI_ID,
                    R.string.device_owner_disallow_config_wifi,
                    R.string.device_owner_disallow_config_wifi_info,
                    new ButtonInfo[] {
                            new ButtonInfo(
                                    R.string.device_owner_user_restriction_set,
                                    CommandReceiverActivity.createSetCurrentUserRestrictionIntent(
                                            UserManager.DISALLOW_CONFIG_WIFI, true)),
                            new ButtonInfo(
                                    R.string.device_owner_settings_go,
                                    new Intent(Settings.ACTION_WIFI_SETTINGS)),
                            new ButtonInfo(
                                    R.string.device_owner_user_restriction_unset,
                                    CommandReceiverActivity.createSetCurrentUserRestrictionIntent(
                                            UserManager.DISALLOW_CONFIG_WIFI, false))
            }));
        }

        // DISALLOW_AMBIENT_DISPLAY.
        // TODO: After the ambient display feature flag is added in PackageManager (b/135591614),
        // uncomment this test and run it only when ambient display is supported by the device.

        // adapter.add(createInteractiveTestItem(this, DISALLOW_AMBIENT_DISPLAY_ID,
        //         R.string.device_owner_disallow_ambient_display,
        //         R.string.device_owner_disallow_ambient_display_info,
        //         new ButtonInfo[] {
        //                 new ButtonInfo(
        //                         R.string.device_owner_user_restriction_set,
        //                         CommandReceiverActivity.createSetUserRestrictionIntent(
        //                                 UserManager.DISALLOW_AMBIENT_DISPLAY, true)),
        //                 new ButtonInfo(
        //                         R.string.device_owner_settings_go,
        //                         new Intent(Settings.ACTION_DISPLAY_SETTINGS))}));

        // DISALLOW_CONFIG_VPN
        // TODO(b/189282625): replace FEATURE_WATCH with a more specific feature
        if (!packageManager.hasSystemFeature(PackageManager.FEATURE_WATCH)) {
            adapter.add(createInteractiveTestItem(this, DISALLOW_CONFIG_VPN_ID,
                    R.string.device_owner_disallow_config_vpn,
                    R.string.device_owner_disallow_config_vpn_info,
                    new ButtonInfo[] {
                            new ButtonInfo(
                                    R.string.device_owner_user_vpn_restriction_set,
                                    CommandReceiverActivity.createSetCurrentUserRestrictionIntent(
                                            UserManager.DISALLOW_CONFIG_VPN, true)),
                            new ButtonInfo(
                                    R.string.device_owner_settings_go,
                                    new Intent(Settings.ACTION_VPN_SETTINGS)),
                            new ButtonInfo(
                                    R.string.device_owner_vpn_test,
                                    new Intent(this, VpnTestActivity.class)),
                            new ButtonInfo(
                                    R.string.device_owner_user_restriction_unset,
                                    CommandReceiverActivity.createSetCurrentUserRestrictionIntent(
                                            UserManager.DISALLOW_CONFIG_VPN, false))
                    }));
        }

        // DISALLOW_DATA_ROAMING
        // TODO(b/189282625): replace FEATURE_WATCH with a more specific feature
        if (!packageManager.hasSystemFeature(PackageManager.FEATURE_WATCH)
                && packageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            adapter.add(createInteractiveTestItem(this, DISALLOW_DATA_ROAMING_ID,
                    R.string.device_owner_disallow_data_roaming,
                    R.string.device_owner_disallow_data_roaming_info,
                    new ButtonInfo[] {
                            new ButtonInfo(
                                    R.string.device_owner_user_restriction_set,
                                    CommandReceiverActivity.createSetCurrentUserRestrictionIntent(
                                            UserManager.DISALLOW_DATA_ROAMING, true)),
                            new ButtonInfo(
                                    R.string.device_owner_settings_go,
                                    new Intent(Settings.ACTION_DATA_ROAMING_SETTINGS)),
                            new ButtonInfo(
                                    R.string.device_owner_user_restriction_unset,
                                    CommandReceiverActivity.createSetCurrentUserRestrictionIntent(
                                            UserManager.DISALLOW_DATA_ROAMING, false))
                    }));
        }

        // DISALLOW_FACTORY_RESET
        adapter.add(createInteractiveTestItem(this, DISALLOW_FACTORY_RESET_ID,
                R.string.device_owner_disallow_factory_reset,
                R.string.device_owner_disallow_factory_reset_info,
                new ButtonInfo[] {
                        new ButtonInfo(
                                R.string.device_owner_user_restriction_set,
                                CommandReceiverActivity.createSetDeviceOwnerUserRestrictionIntent(
                                        UserManager.DISALLOW_FACTORY_RESET, true)),
                        new ButtonInfo(
                                R.string.device_owner_user_restriction_unset,
                                CommandReceiverActivity.createSetDeviceOwnerUserRestrictionIntent(
                                        UserManager.DISALLOW_FACTORY_RESET, false))
        }));

        // DISALLOW_CONFIG_BLUETOOTH
        if (packageManager.hasSystemFeature(PackageManager.FEATURE_BLUETOOTH)) {
            adapter.add(createInteractiveTestItem(this, DISALLOW_CONFIG_BT_ID,
                    R.string.device_owner_disallow_config_bt,
                    R.string.device_owner_disallow_config_bt_info,
                    new ButtonInfo[] {
                            new ButtonInfo(
                                    R.string.device_owner_user_restriction_set,
                                    CommandReceiverActivity.createSetCurrentUserRestrictionIntent(
                                            UserManager.DISALLOW_CONFIG_BLUETOOTH, true)),
                            new ButtonInfo(
                                    R.string.device_owner_settings_go,
                                    new Intent(Settings.ACTION_BLUETOOTH_SETTINGS)),
                            new ButtonInfo(
                                    R.string.device_owner_user_restriction_unset,
                                    CommandReceiverActivity.createSetCurrentUserRestrictionIntent(
                                            UserManager.DISALLOW_CONFIG_BLUETOOTH, false))
            }));
        }

        // DISALLOW_USB_FILE_TRANSFER
        // TODO(b/189282625): replace FEATURE_WATCH with a more specific feature
        if (!packageManager.hasSystemFeature(PackageManager.FEATURE_WATCH)) {
            adapter.add(createInteractiveTestItem(this, DISALLOW_USB_FILE_TRANSFER_ID,
                    R.string.device_owner_disallow_usb_file_transfer_test,
                    R.string.device_owner_disallow_usb_file_transfer_test_info,
                    new ButtonInfo[] {
                            new ButtonInfo(
                                    R.string.device_owner_user_restriction_set,
                                    CommandReceiverActivity.createSetCurrentUserRestrictionIntent(
                                            UserManager.DISALLOW_USB_FILE_TRANSFER, true)),
                            new ButtonInfo(
                                    R.string.device_owner_user_restriction_unset,
                                    CommandReceiverActivity.createSetCurrentUserRestrictionIntent(
                                            UserManager.DISALLOW_USB_FILE_TRANSFER, false))
                    }));
        }

        // DISABLE_STATUS_BAR_TEST
        if (isStatusBarEnabled()) {
            adapter.add(createInteractiveTestItem(this, DISABLE_STATUS_BAR_TEST_ID,
                    R.string.device_owner_disable_statusbar_test,
                    R.string.device_owner_disable_statusbar_test_info,
                    new ButtonInfo[] {
                            new ButtonInfo(
                                    R.string.device_owner_disable_statusbar_button,
                                    createDeviceOwnerIntentWithBooleanParameter(
                                            CommandReceiverActivity.COMMAND_SET_STATUSBAR_DISABLED,
                                                    true)),
                            new ButtonInfo(
                                    R.string.device_owner_reenable_statusbar_button,
                                    createDeviceOwnerIntentWithBooleanParameter(
                                            CommandReceiverActivity.COMMAND_SET_STATUSBAR_DISABLED,
                                                    false))}));
        }

        // setKeyguardDisabled
        if (isKeyguardShownWhenUserDoesntHaveCredentials() && Utils.isLockscreenSupported(this)) {
            adapter.add(createInteractiveTestItem(this, DISABLE_KEYGUARD_TEST_ID,
                    R.string.device_owner_disable_keyguard_test,
                    R.string.device_owner_disable_keyguard_test_info,
                    new ButtonInfo[] {
                            new ButtonInfo(
                                    R.string.device_owner_disable_keyguard_button,
                                    createDeviceOwnerIntentWithBooleanParameter(
                                            CommandReceiverActivity.COMMAND_SET_KEYGUARD_DISABLED,
                                                    true)),
                            new ButtonInfo(
                                    R.string.device_owner_reenable_keyguard_button,
                                    createDeviceOwnerIntentWithBooleanParameter(
                                            CommandReceiverActivity.COMMAND_SET_KEYGUARD_DISABLED,
                                                    false))}));
        }

        // setLockTaskFeatures
        // TODO(b/189282625): replace FEATURE_WATCH with a more specific feature
        if (!packageManager.hasSystemFeature(PackageManager.FEATURE_WATCH)) {
            final Intent lockTaskUiTestIntent = new Intent(this, LockTaskUiTestActivity.class);
            lockTaskUiTestIntent.putExtra(LockTaskUiTestActivity.EXTRA_TEST_ID,
                    LOCK_TASK_UI_TEST_ID);
            adapter.add(createTestItem(this, LOCK_TASK_UI_TEST_ID,
                    R.string.device_owner_lock_task_ui_test,
                    lockTaskUiTestIntent));
        }

        // setUserIcon
        adapter.add(createInteractiveTestItem(this, SET_USER_ICON_TEST_ID,
                R.string.device_owner_set_user_icon,
                R.string.device_owner_set_user_icon_instruction,
                new ButtonInfo[] {
                        new ButtonInfo(
                                R.string.device_owner_set_user_icon_button,
                                createSetUserIconIntent(R.drawable.user_icon_1)),
                        new ButtonInfo(
                                R.string.disallow_set_user_icon,
                                CommandReceiverActivity.createSetCurrentUserRestrictionIntent(
                                        UserManager.DISALLOW_SET_USER_ICON, true)),
                        new ButtonInfo(
                                R.string.device_owner_set_user_icon2_button,
                                createSetUserIconIntent(R.drawable.user_icon_2)),
                        new ButtonInfo(
                                R.string.device_owner_settings_go,
                                new Intent(Settings.ACTION_SETTINGS)),
                        new ButtonInfo(
                                R.string.device_owner_user_restriction_unset,
                                CommandReceiverActivity.createSetCurrentUserRestrictionIntent(
                                        UserManager.DISALLOW_SET_USER_ICON, false))
        }));

        // setPermissionGrantState
        adapter.add(createTestItem(this, CHECK_PERMISSION_LOCKDOWN_TEST_ID,
                R.string.device_profile_owner_permission_lockdown_test,
                new Intent(PermissionLockdownTestActivity.ACTION_CHECK_PERMISSION_LOCKDOWN)));

        // Policy Transparency
        final Intent policyTransparencyTestIntent = new Intent(this,
                PolicyTransparencyTestListActivity.class);
        policyTransparencyTestIntent.putExtra(
                PolicyTransparencyTestListActivity.EXTRA_MODE,
                PolicyTransparencyTestListActivity.MODE_DEVICE_OWNER);
        // So that PolicyTransparencyTestListActivity knows which test to update with the result:
        policyTransparencyTestIntent.putExtra(
                PolicyTransparencyTestActivity.EXTRA_TEST_ID, POLICY_TRANSPARENCY_TEST_ID);
        adapter.add(createTestItem(this, POLICY_TRANSPARENCY_TEST_ID,
                R.string.device_profile_owner_policy_transparency_test,
                policyTransparencyTestIntent));

        // Enterprise Privacy
        final Intent enterprisePolicyTestIntent = new Intent(this,
                EnterprisePrivacyTestListActivity.class);
        enterprisePolicyTestIntent.putExtra(
                EnterprisePrivacyTestListActivity.EXTRA_TEST_ID, ENTERPRISE_PRIVACY_TEST_ID);
        adapter.add(createTestItem(this, ENTERPRISE_PRIVACY_TEST_ID,
                R.string.enterprise_privacy_test,
                enterprisePolicyTestIntent));

        if (packageManager.hasSystemFeature(PackageManager.FEATURE_MANAGED_USERS)
                && UserManager.supportsMultipleUsers()) {
            // Managed user
            adapter.add(createInteractiveTestItem(this, MANAGED_USER_TEST_ID,
                    R.string.managed_user_test,
                    R.string.managed_user_positive_tests_instructions,
                    new ButtonInfo[]{
                            new ButtonInfo(
                                    R.string.device_owner_settings_go,
                                    createCreateManagedUserIntent())}));

            // User switcher message
            adapter.add(createInteractiveTestItem(this, USER_SWITCHER_MESSAGE_TEST_ID,
                    R.string.device_owner_user_switcher_message,
                    R.string.device_owner_user_switcher_message_info,
                    new ButtonInfo[]{
                            new ButtonInfo(
                                    R.string.device_owner_with_user_switcher_message,
                                    createWithUserSwitcherMessageIntent()),
                            new ButtonInfo(
                                    R.string.device_owner_without_user_switcher_message,
                                    createWithoutUserSwitcherMessageIntent())}));

            // Enable logout
            adapter.add(createInteractiveTestItem(this, ENABLE_LOGOUT_TEST_ID,
                    R.string.device_owner_enable_logout,
                    R.string.device_owner_enable_logout_info,
                    new ButtonInfo[]{
                            new ButtonInfo(
                                    R.string.device_owner_settings_go,
                                    createEnableLogoutIntent())}));

            // DISALLOW_USER_SWITCH
            adapter.add(createInteractiveTestItem(this, DISALLOW_USER_SWITCH_TEST_ID,
                    R.string.device_owner_disallow_user_switch,
                    R.string.device_owner_disallow_user_switch_info,
                    new ButtonInfo[]{
                            new ButtonInfo(
                                    R.string.device_owner_disallow_user_switch_create_user,
                                    createCreateManagedUserWithoutSetupIntent()),
                            new ButtonInfo(
                                    R.string.device_owner_user_restriction_set,
                                    CommandReceiverActivity.createSetCurrentUserRestrictionIntent(
                                            UserManager.DISALLOW_USER_SWITCH, true)),
                            new ButtonInfo(
                                    R.string.device_owner_settings_go,
                                    new Intent(Settings.ACTION_USER_SETTINGS)),
                            new ButtonInfo(
                                    R.string.device_owner_user_restriction_unset,
                                    CommandReceiverActivity.createSetCurrentUserRestrictionIntent(
                                            UserManager.DISALLOW_USER_SWITCH, false))
            }));

            // DISALLOW_REMOVE_USER
            adapter.add(createInteractiveTestItem(this, DISALLOW_REMOVE_USER_TEST_ID,
                    R.string.disallow_remove_user,
                    R.string.device_owner_disallow_remove_user_info,
                    new ButtonInfo[]{
                            new ButtonInfo(
                                    R.string.device_owner_disallow_remove_user_create_user,
                                    createCreateManagedUserWithoutSetupIntent()),
                            new ButtonInfo(
                                    R.string.device_owner_user_restriction_set,
                                    CommandReceiverActivity.createSetCurrentUserRestrictionIntent(
                                            UserManager.DISALLOW_REMOVE_USER, true)),
                            new ButtonInfo(
                                    R.string.device_owner_settings_go,
                                    new Intent(Settings.ACTION_USER_SETTINGS)),
                            new ButtonInfo(
                                    R.string.device_owner_user_restriction_unset,
                                    CommandReceiverActivity.createSetCurrentUserRestrictionIntent(
                                            UserManager.DISALLOW_REMOVE_USER, false)),
                            new ButtonInfo(
                                    R.string.device_owner_remove_secondary_user,
                                    createRemoveSecondaryUsersIntent())
            }));
        }

        // Network logging UI
        adapter.add(createInteractiveTestItem(this, NETWORK_LOGGING_UI_TEST_ID,
                R.string.device_owner_network_logging_ui,
                R.string.device_owner_network_logging_ui_info,
                new ButtonInfo[] {
                        new ButtonInfo(
                                R.string.device_owner_enable_network_logging_button,
                                createEnableNetworkLoggingIntent()),
                        new ButtonInfo(
                                R.string.device_owner_disable_network_logging_button,
                                createDisableNetworkLoggingIntent())}));

        // Customize lock screen message
        if (isSwipeToUnlockSupported() && Utils.isLockscreenSupported(this)) {
            adapter.add(TestListItem.newTest(this,
                    R.string.device_owner_customize_lockscreen_message,
                    LockscreenMessageTestActivity.class.getName(),
                    new Intent(this, LockscreenMessageTestActivity.class),
                    /* requiredFeatures */ null));
        }

        // setUsbDataSignalingEnabled
        if (canUsbDataSignalingBeDisabled()) {
            adapter.add(createInteractiveTestItem(this, DISABLE_USB_DATA_SIGNALING_TEST_ID,
                    R.string.device_owner_disable_usb_data_signaling_test,
                    R.string.device_owner_disable_usb_data_signaling_test_info,
                    new ButtonInfo[] {
                            new ButtonInfo(
                                    R.string.device_owner_settings_go,
                                    new Intent(Settings.ACTION_SETTINGS)),
                            new ButtonInfo(
                                    R.string.device_owner_disable_usb_data_signaling_test,
                                    createDisableUsbDataSignalingIntent()),
                            new ButtonInfo(
                                    R.string.device_owner_settings_go,
                                    new Intent(Settings.ACTION_SETTINGS)),
                            new ButtonInfo(
                                    R.string.device_owner_enable_usb_data_signaling_test,
                                    createEnableUsbDataSignalingIntent())
                    }));
        }

        // setRequiredPasswordComplexity
        if (Utils.isLockscreenSupported(this)) {
            adapter.add(createInteractiveTestItem(this, SET_REQUIRED_PASSWORD_COMPLEXITY_ID,
                    R.string.device_owner_required_password_complexity_test,
                    R.string.device_owner_required_password_complexity_test_info,
                    new ButtonInfo[]{
                            new ButtonInfo(
                                    R.string.set_low_required_password_complexity,
                                    createSetRequiredPasswordComplexityIntent(
                                            DevicePolicyManager.PASSWORD_COMPLEXITY_LOW)),
                            new ButtonInfo(
                                    R.string.set_medium_required_password_complexity,
                                    createSetRequiredPasswordComplexityIntent(
                                            DevicePolicyManager.PASSWORD_COMPLEXITY_MEDIUM)),
                            new ButtonInfo(
                                    R.string.set_high_required_password_complexity,
                                    createSetRequiredPasswordComplexityIntent(
                                            DevicePolicyManager.PASSWORD_COMPLEXITY_HIGH)),
                            new ButtonInfo(
                                    R.string.remove_required_password_complexity,
                                    createSetRequiredPasswordComplexityIntent(
                                            DevicePolicyManager.PASSWORD_COMPLEXITY_NONE)),
                            new ButtonInfo(
                                    R.string.device_owner_settings_go,
                                    new Intent(Settings.ACTION_SECURITY_SETTINGS))}));
        }

        // removeDeviceOwner
        adapter.add(createInteractiveTestItem(this, REMOVE_DEVICE_OWNER_TEST_ID,
                R.string.device_owner_remove_device_owner_test,
                R.string.device_owner_remove_device_owner_test_info,
                new ButtonInfo(
                        R.string.remove_device_owner_button,
                        createTearDownIntent())));
    }

    static TestListItem createTestItem(Activity activity, String id, int titleRes,
            Intent intent) {
        intent.putExtra(EXTRA_TEST_ID, id);
        return TestListItem.newTest(activity, titleRes, id, intent, null);
    }

    private Intent createTearDownIntent() {
        return new Intent(this, CommandReceiverActivity.class)
                .putExtra(CommandReceiverActivity.EXTRA_COMMAND,
                        CommandReceiverActivity.COMMAND_REMOVE_DEVICE_OWNER);
    }

    private Intent createDeviceOwnerIntentWithBooleanParameter(String command, boolean value) {
        return new Intent(this, CommandReceiverActivity.class)
                .putExtra(CommandReceiverActivity.EXTRA_COMMAND, command)
                .putExtra(CommandReceiverActivity.EXTRA_ENFORCED, value);
    }

    private Intent createSetUserIconIntent(int iconRes) {
        return new Intent(this, CommandReceiverActivity.class)
                .putExtra(CommandReceiverActivity.EXTRA_COMMAND,
                        CommandReceiverActivity.COMMAND_SET_USER_ICON)
                .putExtra(CommandReceiverActivity.EXTRA_VALUE, iconRes);
    }

    private Intent createEnableNetworkLoggingIntent() {
        return new Intent(this, CommandReceiverActivity.class)
                .putExtra(CommandReceiverActivity.EXTRA_COMMAND,
                        CommandReceiverActivity.COMMAND_ENABLE_NETWORK_LOGGING);
    }

    private Intent createDisableNetworkLoggingIntent() {
        return new Intent(this, CommandReceiverActivity.class)
                .putExtra(CommandReceiverActivity.EXTRA_COMMAND,
                        CommandReceiverActivity.COMMAND_DISABLE_NETWORK_LOGGING);
    }

    private Intent createCreateManagedUserIntent() {
        // Set execution start time for counting test execution time.
        mStartTime = System.currentTimeMillis();
        return new Intent(this, CommandReceiverActivity.class)
                .putExtra(CommandReceiverActivity.EXTRA_COMMAND,
                        CommandReceiverActivity.COMMAND_CREATE_MANAGED_USER);
    }

    private Intent createWithUserSwitcherMessageIntent() {
        return new Intent(this, CommandReceiverActivity.class)
                .putExtra(CommandReceiverActivity.EXTRA_COMMAND,
                        CommandReceiverActivity.COMMAND_WITH_USER_SWITCHER_MESSAGE);
    }

    private Intent createWithoutUserSwitcherMessageIntent() {
        return new Intent(this, CommandReceiverActivity.class)
                .putExtra(CommandReceiverActivity.EXTRA_COMMAND,
                        CommandReceiverActivity.COMMAND_WITHOUT_USER_SWITCHER_MESSAGE);
    }

    private Intent createEnableLogoutIntent() {
        return new Intent(this, CommandReceiverActivity.class)
                .putExtra(CommandReceiverActivity.EXTRA_COMMAND,
                        CommandReceiverActivity.COMMAND_ENABLE_LOGOUT);
    }

    private Intent createCreateManagedUserWithoutSetupIntent() {
        return new Intent(this, CommandReceiverActivity.class)
                .putExtra(CommandReceiverActivity.EXTRA_COMMAND,
                        CommandReceiverActivity.COMMAND_CREATE_MANAGED_USER_WITHOUT_SETUP);
    }

    private Intent createRemoveSecondaryUsersIntent() {
        return new Intent(this, CommandReceiverActivity.class)
                .putExtra(CommandReceiverActivity.EXTRA_COMMAND,
                        CommandReceiverActivity.COMMAND_REMOVE_SECONDARY_USERS);
    }

    private Intent createEnableUsbDataSignalingIntent() {
        return new Intent(this, CommandReceiverActivity.class)
                .putExtra(CommandReceiverActivity.EXTRA_COMMAND,
                        CommandReceiverActivity.COMMAND_ENABLE_USB_DATA_SIGNALING);
    }

    private Intent createDisableUsbDataSignalingIntent() {
        return new Intent(this, CommandReceiverActivity.class)
                .putExtra(CommandReceiverActivity.EXTRA_COMMAND,
                        CommandReceiverActivity.COMMAND_DISABLE_USB_DATA_SIGNALING);
    }

    private Intent createSetRequiredPasswordComplexityIntent(int complexity) {
        return new Intent(this, CommandReceiverActivity.class)
                .putExtra(CommandReceiverActivity.EXTRA_COMMAND,
                        CommandReceiverActivity.COMMAND_SET_REQUIRED_PASSWORD_COMPLEXITY)
                .putExtra(CommandReceiverActivity.EXTRA_VALUE, complexity);
    }

    private boolean isStatusBarEnabled() {
        // Watches don't support the status bar so this is an ok proxy, but this is not the most
        // general test for that. TODO: add a test API to do a real check for status bar support.
        return !getPackageManager().hasSystemFeature(PackageManager.FEATURE_WATCH)
                && !isAutomotive() && !isTelevision();
    }

    private boolean isKeyguardShownWhenUserDoesntHaveCredentials() {
        return !isAutomotive();
    }

    private boolean isSwipeToUnlockSupported() {
        return !isAutomotive();
    }

    private boolean isAutomotive() {
        return getPackageManager().hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE);
    }

    private boolean isTelevision() {
        return getPackageManager().hasSystemFeature(PackageManager.FEATURE_LEANBACK);
    }

    private boolean canUsbDataSignalingBeDisabled() {
        DevicePolicyManager dpm = getSystemService(DevicePolicyManager.class);
        return dpm != null && dpm.canUsbDataSignalingBeDisabled();
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.AlwaysOnVpnTest"	"testDisallowConfigVpn"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/AlwaysOnVpnTest.java"	""	"public void testDisallowConfigVpn() throws Exception {
        mDevicePolicyManager.addUserRestriction(
                ADMIN_RECEIVER_COMPONENT, UserManager.DISALLOW_CONFIG_VPN);
        try {
            testAlwaysOnVpn();
        } finally {
            // clear the user restriction
            mDevicePolicyManager.clearUserRestriction(ADMIN_RECEIVER_COMPONENT,
                    UserManager.DISALLOW_CONFIG_VPN);
        }
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.AlwaysOnVpnTest"	"testAllowedApps"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/AlwaysOnVpnTest.java"	""	"public void testAllowedApps() throws Exception {
        final Bundle restrictions = new Bundle();
        restrictions.putStringArray(RESTRICTION_ALLOWED, new String[] {mPackageName});
        mDevicePolicyManager.setApplicationRestrictions(ADMIN_RECEIVER_COMPONENT, VPN_PACKAGE,
                restrictions);
        VpnTestHelper.waitForVpn(mContext, VPN_PACKAGE,
                /* usable */ true,  /* lockdown */ true, /* allowlist */ false);
        assertTrue(VpnTestHelper.isNetworkVpn(mContext));
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.AlwaysOnVpnTest"	"testDisallowedApps"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/AlwaysOnVpnTest.java"	""	"public void testDisallowedApps() throws Exception {
        final Bundle restrictions = new Bundle();
        restrictions.putStringArray(RESTRICTION_DISALLOWED, new String[] {mPackageName});
        mDevicePolicyManager.setApplicationRestrictions(ADMIN_RECEIVER_COMPONENT, VPN_PACKAGE,
                restrictions);
        VpnTestHelper.waitForVpn(mContext, VPN_PACKAGE,
                /* usable */ false,  /* lockdown */ true, /* allowlist */ false);
        assertFalse(VpnTestHelper.isNetworkVpn(mContext));
    }

    // Tests that changes to lockdown allowlist are applied correctly."	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.AlwaysOnVpnTest"	"testVpnLockdownUpdateAllowlist"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/AlwaysOnVpnTest.java"	""	"public void testVpnLockdownUpdateAllowlist() throws Exception {
        waitForConnectivity(""VPN is off"");

        // VPN won't start.
        final Bundle restrictions = new Bundle();
        restrictions.putBoolean(RESTRICTION_DONT_ESTABLISH, true);
        mDevicePolicyManager.setApplicationRestrictions(
                ADMIN_RECEIVER_COMPONENT, VPN_PACKAGE, restrictions);

        // VPN service is started asynchronously, we need to wait for it to avoid stale service
        // instance interfering with the next test.
        final BlockingBroadcastReceiver receiver = VpnTestHelper.registerOnStartReceiver(mContext);

        VpnTestHelper.setAlwaysOnVpn(
                mContext, VPN_PACKAGE, /* lockdown */ false, /* allowlist */ false);
        assertConnectivity(true, ""VPN service not started, no lockdown"");
        assertNotNull(receiver.awaitForBroadcast(VPN_ON_START_TIMEOUT_MS));

        VpnTestHelper.setAlwaysOnVpn(
                mContext, VPN_PACKAGE, /* lockdown */ true, /* allowlist */ false);
        // Wait for loss of connectivity instead of assertConnectivity(false)
        // to mitigate flakiness due to asynchronicity.
        waitForNoConnectivity(""VPN in lockdown, service not started"");
        assertNotNull(receiver.awaitForBroadcast(VPN_ON_START_TIMEOUT_MS));

        VpnTestHelper.setAlwaysOnVpn(
                mContext, VPN_PACKAGE, /* lockdown */ true, /* allowlist */ true);
        assertConnectivity(true, ""VPN in lockdown, service not started, app allowlisted"");
        assertNotNull(receiver.awaitForBroadcast(VPN_ON_START_TIMEOUT_MS));

        VpnTestHelper.setAlwaysOnVpn(
                mContext, VPN_PACKAGE, /* lockdown */ true, /* allowlist */ false);
        // Wait for loss of connectivity instead of assertConnectivity(false)
        // to mitigate flakiness due to asynchronicity.
        waitForNoConnectivity(""VPN in lockdown, service not started"");
        assertNotNull(receiver.awaitForBroadcast(VPN_ON_START_TIMEOUT_MS));

        receiver.unregisterQuietly();
    }

    // Tests that when VPN comes up, allowlisted app switches over to it."	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.AlwaysOnVpnTest"	"testVpnLockdownAllowlistVpnComesUp"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/AlwaysOnVpnTest.java"	""	"public void testVpnLockdownAllowlistVpnComesUp() throws Exception {
        waitForConnectivity(""VPN is off"");

        // VPN won't start initially.
        final Bundle restrictions = new Bundle();
        restrictions.putBoolean(RESTRICTION_DONT_ESTABLISH, true);
        mDevicePolicyManager.setApplicationRestrictions(
                ADMIN_RECEIVER_COMPONENT, VPN_PACKAGE, restrictions);

        // VPN service is started asynchronously, we need to wait for it to avoid stale service
        // instance interfering with the next test.
        final BlockingBroadcastReceiver receiver = VpnTestHelper.registerOnStartReceiver(mContext);

        VpnTestHelper.setAlwaysOnVpn(
                mContext, VPN_PACKAGE,  /* lockdown */ true, /* allowlist */ true);
        assertConnectivity(true, ""VPN in lockdown, service not started, app allowlisted"");
        assertNotNull(receiver.awaitForBroadcast(VPN_ON_START_TIMEOUT_MS));

        // Make VPN workable again and restart.
        mDevicePolicyManager.setApplicationRestrictions(
                ADMIN_RECEIVER_COMPONENT, VPN_PACKAGE, null);
        VpnTestHelper.waitForVpn(mContext, VPN_PACKAGE,
                /* usable */ true,  /* lockdown */ true, /* allowlist */ true);

        // Now we should be on VPN.
        VpnTestHelper.checkPing(TEST_ADDRESS);

        receiver.unregisterQuietly();
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"test.java.com.android.queryable.queries.UserHandleQueryHelperTest"	"isTrue"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/queryable/src/test/java/com/android/queryable/queries/UserHandleQueryHelperTest.java"	""	"public void matches_id_meetsRestriction_returnsTrue() {
        UserHandleQueryHelper<Queryable> userHandleQueryHelper =
                new UserHandleQueryHelper<>(mQuery);

        userHandleQueryHelper.id().isEqualTo(USER_HANDLE_ID);

        assertThat(userHandleQueryHelper.matches(USER_HANDLE)).isTrue();
    }"	""	""	"restriction restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"test.java.com.android.queryable.queries.UserHandleQueryHelperTest"	"matches_isEqualTo_meetsRestriction_returnsTrue"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/queryable/src/test/java/com/android/queryable/queries/UserHandleQueryHelperTest.java"	""	"public void matches_isEqualTo_meetsRestriction_returnsTrue() {
        UserHandleQueryHelper<Queryable> userHandleQueryHelper =
                new UserHandleQueryHelper<>(mQuery);

        userHandleQueryHelper.isEqualTo(USER_HANDLE);

        assertThat(userHandleQueryHelper.matches(USER_HANDLE)).isTrue();
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"test.java.com.android.queryable.queries.UserHandleQueryHelperTest"	"matches_isEqualTo_doesNotMeetRestriction_returnsFalse"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/queryable/src/test/java/com/android/queryable/queries/UserHandleQueryHelperTest.java"	""	"public void matches_isEqualTo_doesNotMeetRestriction_returnsFalse() {
        UserHandleQueryHelper<Queryable> userHandleQueryHelper =
                new UserHandleQueryHelper<>(mQuery);

        userHandleQueryHelper.isEqualTo(USER_HANDLE);

        assertThat(userHandleQueryHelper.matches(DIFFERENT_USER_HANDLE)).isFalse();
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"test.java.com.android.queryable.queries.UserHandleQueryHelperTest"	"isFalse"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/queryable/src/test/java/com/android/queryable/queries/UserHandleQueryHelperTest.java"	""	"public void matches_id_doesNotMeetRestriction_returnsFalse() {
        UserHandleQueryHelper<Queryable> userHandleQueryHelper =
                new UserHandleQueryHelper<>(mQuery);

        userHandleQueryHelper.id().isEqualTo(USER_HANDLE_ID);

        assertThat(userHandleQueryHelper.matches(DIFFERENT_USER_HANDLE)).isFalse();
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.scopedstorage.cts.device.ScopedStorageDeviceTest"	"testOpendirRestrictions"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/device/src/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java"	""	"public void testOpendirRestrictions() throws Exception {
        // Opening a non existent package directory should fail, as expected
        final File nonexistentPackageFileDir = new File(
                getExternalFilesDir().getPath().replace(THIS_PACKAGE_NAME, ""no.such.package""));
        assertThat(nonexistentPackageFileDir.list()).isNull();

        // Opening another package's external directory should fail as well, even if it exists
        final File shellPackageFileDir = new File(
                getExternalFilesDir().getPath().replace(THIS_PACKAGE_NAME, ""com.android.shell""));
        assertThat(shellPackageFileDir.list()).isNull();

        // We can open our own external files directory
        final String[] filesList = getExternalFilesDir().list();
        assertThat(filesList).isNotNull();

        // We can open any public directory in external storage
        assertThat(getDcimDir().list()).isNotNull();
        assertThat(getDownloadDir().list()).isNotNull();
        assertThat(getMoviesDir().list()).isNotNull();
        assertThat(getMusicDir().list()).isNotNull();

        // We can open the root directory of external storage
        final String[] topLevelDirs = getExternalStorageDir().list();
        assertThat(topLevelDirs).isNotNull();
        // TODO(b/145287327): This check fails on a device with no visible files.
        // This can be fixed if we display default directories.
        // assertThat(topLevelDirs).isNotEmpty();
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.scopedstorage.cts.device.ScopedStorageDeviceTest"	"testSystemGalleryCanRenameImagesAndVideos"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/device/src/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java"	""	"public void testSystemGalleryCanRenameImagesAndVideos() throws Exception {
        final File otherAppVideoFile = new File(getDcimDir(), ""other_"" + VIDEO_FILE_NAME);
        final File imageFile = new File(getPicturesDir(), IMAGE_FILE_NAME);
        final File videoFile = new File(getPicturesDir(), VIDEO_FILE_NAME);
        final File topLevelVideoFile = new File(getExternalStorageDir(), VIDEO_FILE_NAME);
        final File musicFile = new File(getMusicDir(), AUDIO_FILE_NAME);
        try {
            allowAppOpsToUid(Process.myUid(), SYSTEM_GALERY_APPOPS);

            // Have another app create a video file
            assertThat(createFileAs(APP_B_NO_PERMS, otherAppVideoFile.getPath())).isTrue();
            assertThat(otherAppVideoFile.exists()).isTrue();

            // Write some data to the file
            try (FileOutputStream fos = new FileOutputStream(otherAppVideoFile)) {
                fos.write(BYTES_DATA1);
            }
            assertFileContent(otherAppVideoFile, BYTES_DATA1);

            // Assert we can rename the file and ensure the file has the same content
            assertCanRenameFile(otherAppVideoFile, videoFile);
            assertFileContent(videoFile, BYTES_DATA1);
            // We can even move it to the top level directory
            assertCanRenameFile(videoFile, topLevelVideoFile);
            assertFileContent(topLevelVideoFile, BYTES_DATA1);
            // And we can even convert it into an image file, because why not?
            assertCanRenameFile(topLevelVideoFile, imageFile);
            assertFileContent(imageFile, BYTES_DATA1);

            // We can convert it to a music file, but we won't have access to music file after
            // renaming.
            assertThat(imageFile.renameTo(musicFile)).isTrue();
            assertThat(getFileRowIdFromDatabase(musicFile)).isEqualTo(-1);
        } finally {
            deleteFileAsNoThrow(APP_B_NO_PERMS, otherAppVideoFile.getAbsolutePath());
            imageFile.delete();
            videoFile.delete();
            topLevelVideoFile.delete();
            executeShellCommand(""rm  "" + musicFile.getAbsolutePath());
            MediaStore.scanFile(getContentResolver(), musicFile);
            denyAppOpsToUid(Process.myUid(), SYSTEM_GALERY_APPOPS);
        }
    }

    /**
     * Test that basic file path restrictions are enforced on file rename.
     */"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.scopedstorage.cts.device.ScopedStorageDeviceTest"	"testRenameFileNotOwned"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/device/src/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java"	""	"public void testRenameFileNotOwned() throws Exception {
        final File videoFile1 = new File(getDcimDir(), VIDEO_FILE_NAME);
        final File videoFile2 = new File(getMoviesDir(), VIDEO_FILE_NAME);
        try {
            assertThat(createFileAs(APP_B_NO_PERMS, videoFile1.getAbsolutePath())).isTrue();
            // App can't rename a file owned by APP B.
            assertCantRenameFile(videoFile1, videoFile2);

            assertThat(videoFile2.createNewFile()).isTrue();
            // App can't rename a file to videoFile1 which is owned by APP B.
            assertCantRenameFile(videoFile2, videoFile1);
            // TODO(b/146346138): Test that app with right URI permission should be able to rename
            // the corresponding file
        } finally {
            deleteFileAsNoThrow(APP_B_NO_PERMS, videoFile1.getAbsolutePath());
            videoFile2.delete();
        }
    }

    /**
     * Test that renaming directories is allowed and aligns to default directory restrictions.
     */"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.scopedstorage.cts.device.ScopedStorageDeviceTest"	"testExternalStorageProviderAndDownloadsProvider"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/device/src/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java"	""	"@SdkSuppress(minSdkVersion = 31, codeName = ""S"")
    public void testExternalStorageProviderAndDownloadsProvider() throws Exception {
        assertWritableMountModeForProvider(DocumentsContract.EXTERNAL_STORAGE_PROVIDER_AUTHORITY);
        assertWritableMountModeForProvider(DocumentsContract.DOWNLOADS_PROVIDER_AUTHORITY);
    }

    private void assertWritableMountModeForProvider(String auth) {
        final ProviderInfo provider = getContext().getPackageManager()
                .resolveContentProvider(auth, 0);
        int uid = provider.applicationInfo.uid;
        final String packageName = provider.applicationInfo.packageName;

        assertMountMode(packageName, uid, StorageManager.MOUNT_MODE_EXTERNAL_ANDROID_WRITABLE);
    }

    private boolean canRenameFile(File file) {
        return file.renameTo(new File(file.getAbsolutePath() + ""test""));
    }

    private void testTransformsDirCommon(File file) throws Exception {
        assertThat(file.delete()).isFalse();
        assertThat(canRenameFile(file)).isFalse();

        final File newFile = new File(file.getAbsolutePath(), ""test"");
        assertThat(newFile.mkdir()).isFalse();
        assertThrows(IOException.class, () -> newFile.createNewFile());
    }

    private void assertCanWriteAndRead(File file, byte[] data) throws Exception {
        // Assert we can write to images/videos
        try (FileOutputStream fos = new FileOutputStream(file)) {
            fos.write(data);
        }
        assertFileContent(file, data);
    }

    /**
     * Checks restrictions for opening pending and trashed files by different apps. Assumes that
     * given {@code testApp} is already installed and has READ_EXTERNAL_STORAGE permission. This
     * method doesn't uninstall given {@code testApp} at the end.
     */
    private void assertOpenPendingOrTrashed(Uri uri, boolean isImageOrVideo)
            throws Exception {
        final File pendingOrTrashedFile = new File(getFilePathFromUri(uri));

        // App can open its pending or trashed file for read or write
        assertTrue(canOpen(pendingOrTrashedFile, /*forWrite*/ false));
        assertTrue(canOpen(pendingOrTrashedFile, /*forWrite*/ true));

        // App with READ_EXTERNAL_STORAGE can't open other app's pending or trashed file for read or
        // write
        assertFalse(canOpenFileAs(APP_A_HAS_RES, pendingOrTrashedFile, /*forWrite*/ false));
        assertFalse(canOpenFileAs(APP_A_HAS_RES, pendingOrTrashedFile, /*forWrite*/ true));

        assertTrue(canOpenFileAs(APP_FM, pendingOrTrashedFile, /*forWrite*/ false));
        assertTrue(canOpenFileAs(APP_FM, pendingOrTrashedFile, /*forWrite*/ true));

        final int resAppUid =
                getContext().getPackageManager().getPackageUid(APP_A_HAS_RES.getPackageName(), 0);
        try {
            allowAppOpsToUid(resAppUid, SYSTEM_GALERY_APPOPS);
            if (isImageOrVideo) {
                // System Gallery can open any pending or trashed image/video file for read or write
                assertTrue(isMediaTypeImageOrVideo(pendingOrTrashedFile));
                assertTrue(canOpenFileAs(APP_A_HAS_RES, pendingOrTrashedFile, /*forWrite*/ false));
                assertTrue(canOpenFileAs(APP_A_HAS_RES, pendingOrTrashedFile, /*forWrite*/ true));
            } else {
                // System Gallery can't open other app's pending or trashed non-media file for read
                // or write
                assertFalse(isMediaTypeImageOrVideo(pendingOrTrashedFile));
                assertFalse(canOpenFileAs(APP_A_HAS_RES, pendingOrTrashedFile, /*forWrite*/ false));
                assertFalse(canOpenFileAs(APP_A_HAS_RES, pendingOrTrashedFile, /*forWrite*/ true));
            }
        } finally {
            denyAppOpsToUid(resAppUid, SYSTEM_GALERY_APPOPS);
        }
    }

    /**
     * Checks restrictions for listing pending and trashed files by different apps.
     */
    private void assertListPendingOrTrashed(Uri uri, File file, boolean isImageOrVideo)
            throws Exception {
        final String parentDirPath = file.getParent();
        assertTrue(new File(parentDirPath).isDirectory());

        final List<String> listedFileNames = Arrays.asList(new File(parentDirPath).list());
        assertThat(listedFileNames).doesNotContain(file);

        final File pendingOrTrashedFile = new File(getFilePathFromUri(uri));

        assertThat(listedFileNames).contains(pendingOrTrashedFile.getName());

        // App with READ_EXTERNAL_STORAGE can't see other app's pending or trashed file.
        assertThat(listAs(APP_A_HAS_RES, parentDirPath)).doesNotContain(
                pendingOrTrashedFile.getName());

        final int resAppUid =
                getContext().getPackageManager().getPackageUid(APP_A_HAS_RES.getPackageName(), 0);
        // File Manager can see any pending or trashed file.
        assertThat(listAs(APP_FM, parentDirPath)).contains(pendingOrTrashedFile.getName());


        try {
            allowAppOpsToUid(resAppUid, SYSTEM_GALERY_APPOPS);
            if (isImageOrVideo) {
                // System Gallery can see any pending or trashed image/video file.
                assertTrue(isMediaTypeImageOrVideo(pendingOrTrashedFile));
                assertThat(listAs(APP_A_HAS_RES, parentDirPath)).contains(
                        pendingOrTrashedFile.getName());
            } else {
                // System Gallery can't see other app's pending or trashed non media file.
                assertFalse(isMediaTypeImageOrVideo(pendingOrTrashedFile));
                assertThat(listAs(APP_A_HAS_RES, parentDirPath))
                        .doesNotContain(pendingOrTrashedFile.getName());
            }
        } finally {
            denyAppOpsToUid(resAppUid, SYSTEM_GALERY_APPOPS);
        }
    }

    private Uri createPendingFile(File pendingFile) throws Exception {
        assertTrue(pendingFile.createNewFile());

        final ContentResolver cr = getContentResolver();
        final Uri trashedFileUri = MediaStore.scanFile(cr, pendingFile);
        assertNotNull(trashedFileUri);

        final ContentValues values = new ContentValues();
        values.put(MediaStore.MediaColumns.IS_PENDING, 1);
        assertEquals(1, cr.update(trashedFileUri, values, Bundle.EMPTY));

        return trashedFileUri;
    }

    private Uri createTrashedFile(File trashedFile) throws Exception {
        assertTrue(trashedFile.createNewFile());

        final ContentResolver cr = getContentResolver();
        final Uri trashedFileUri = MediaStore.scanFile(cr, trashedFile);
        assertNotNull(trashedFileUri);

        trashFile(trashedFileUri);
        return trashedFileUri;
    }

    private void trashFile(Uri uri) throws Exception {
        final ContentValues values = new ContentValues();
        values.put(MediaStore.MediaColumns.IS_TRASHED, 1);
        assertEquals(1, getContentResolver().update(uri, values, Bundle.EMPTY));
    }

    /**
     * Gets file path corresponding to the db row pointed by {@code uri}. If {@code uri} points to
     * multiple db rows, file path is extracted from the first db row of the database query result.
     */
    private String getFilePathFromUri(Uri uri) {
        final String[] projection = new String[] {MediaStore.MediaColumns.DATA};
        try (Cursor c = getContentResolver().query(uri, projection, null, null)) {
            assertTrue(c.moveToFirst());
            return c.getString(0);
        }
    }

    private boolean isMediaTypeImageOrVideo(File file) {
        return queryImageFile(file).getCount() == 1 || queryVideoFile(file).getCount() == 1;
    }

    private static void assertIsMediaTypeImage(File file) {
        final Cursor c = queryImageFile(file);
        assertEquals(1, c.getCount());
    }

    private static void assertNotMediaTypeImage(File file) {
        final Cursor c = queryImageFile(file);
        assertEquals(0, c.getCount());
    }

    private static void assertCantQueryFile(File file) {
        assertThat(getFileUri(file)).isNull();
        // Confirm that file exists in the database.
        assertNotNull(MediaStore.scanFile(getContentResolver(), file));
    }

    private static void assertCreateFilesAs(TestApp testApp, File... files) throws Exception {
        for (File file : files) {
            assertFalse(""File already exists: "" + file, file.exists());
            assertTrue(""Failed to create file "" + file + "" on behalf of ""
                    + testApp.getPackageName(), createFileAs(testApp, file.getPath()));
        }
    }

    /**
     * Makes {@code testApp} create {@code files}. Publishes {@code files} by scanning the file.
     * Pending files from FUSE are not visible to other apps via MediaStore APIs. We have to publish
     * the file or make the file non-pending to make the file visible to other apps.
     * <p>
     * Note that this method can only be used for scannable files.
     */
    private static void assertCreatePublishedFilesAs(TestApp testApp, File... files)
            throws Exception {
        for (File file : files) {
            assertTrue(""Failed to create published file "" + file + "" on behalf of ""
                    + testApp.getPackageName(), createFileAs(testApp, file.getPath()));
            assertNotNull(""Failed to scan "" + file,
                    MediaStore.scanFile(getContentResolver(), file));
        }
    }


    private static void deleteFilesAs(TestApp testApp, File... files) throws Exception {
        for (File file : files) {
            deleteFileAs(testApp, file.getPath());
        }
    }
    private static void assertCanDeletePathsAs(TestApp testApp, String... filePaths)
            throws Exception {
        for (String path: filePaths) {
            assertTrue(""Failed to delete file "" + path + "" on behalf of ""
                    + testApp.getPackageName(), deleteFileAs(testApp, path));
        }
    }

    private static void assertCantDeletePathsAs(TestApp testApp, String... filePaths)
            throws Exception {
        for (String path: filePaths) {
            assertFalse(""Deleting "" + path + "" on behalf of "" + testApp.getPackageName()
                    + "" was expected to fail"", deleteFileAs(testApp, path));
        }
    }

    private void deleteFiles(File... files) {
        for (File file: files) {
            if (file == null) continue;
            file.delete();
        }
    }

    private void deletePaths(String... paths) {
        for (String path: paths) {
            if (path == null) continue;
            new File(path).delete();
        }
    }

    private static void assertCanDeletePaths(String... filePaths) {
        for (String filePath : filePaths) {
            assertTrue(""Failed to delete "" + filePath,
                    new File(filePath).delete());
        }
    }

    /**
     * For possible values of {@code mode}, look at {@link android.content.ContentProvider#openFile}
     */
    private static void assertCanQueryAndOpenFile(File file, String mode) throws IOException {
        // This call performs the query
        final Uri fileUri = getFileUri(file);
        // The query succeeds iff it didn't return null
        assertThat(fileUri).isNotNull();
        // Now we assert that we can open the file through ContentResolver
        try (ParcelFileDescriptor pfd =
                     getContentResolver().openFileDescriptor(fileUri, mode)) {
            assertThat(pfd).isNotNull();
        }
    }

    /**
     * Assert that the last read in: read - write - read using {@code readFd} and {@code writeFd}
     * see the last write. {@code readFd} and {@code writeFd} are fds pointing to the same
     * underlying file on disk but may be derived from different mount points and in that case
     * have separate VFS caches.
     */
    private void assertRWR(ParcelFileDescriptor readPfd, ParcelFileDescriptor writePfd)
            throws Exception {
        FileDescriptor readFd = readPfd.getFileDescriptor();
        FileDescriptor writeFd = writePfd.getFileDescriptor();

        byte[] readBuffer = new byte[10];
        byte[] writeBuffer = new byte[10];
        Arrays.fill(writeBuffer, (byte) 1);

        // Write so readFd has content to read from next
        Os.pwrite(readFd, readBuffer, 0, 10, 0);
        // Read so readBuffer is in readFd's mount VFS cache
        Os.pread(readFd, readBuffer, 0, 10, 0);

        // Assert that readBuffer is zeroes
        assertThat(readBuffer).isEqualTo(new byte[10]);

        // Write so writeFd and readFd should now see writeBuffer
        Os.pwrite(writeFd, writeBuffer, 0, 10, 0);

        // Read so the last write can be verified on readFd
        Os.pread(readFd, readBuffer, 0, 10, 0);

        // Assert that the last write is indeed visible via readFd
        assertThat(readBuffer).isEqualTo(writeBuffer);
        assertThat(readPfd.getStatSize()).isEqualTo(writePfd.getStatSize());
    }

    private void assertStartsWith(String actual, String prefix) throws Exception {
        String message = ""String \"""" + actual + ""\"" should start with \"""" + prefix + ""\"""";

        assertWithMessage(message).that(actual).startsWith(prefix);
    }

    private void assertLowerFsFd(ParcelFileDescriptor pfd) throws Exception {
        String path = Os.readlink(""/proc/self/fd/"" + pfd.getFd());
        String prefix = ""/storage"";

        assertStartsWith(path, prefix);
    }

    private void assertUpperFsFd(ParcelFileDescriptor pfd) throws Exception {
        String path = Os.readlink(""/proc/self/fd/"" + pfd.getFd());
        String prefix = ""/mnt/user"";

        assertStartsWith(path, prefix);
    }

    private void assertLowerFsFdWithPassthrough(ParcelFileDescriptor pfd) throws Exception {
        if (getBoolean(""persist.sys.fuse.passthrough.enable"", false)) {
            assertUpperFsFd(pfd);
        } else {
            assertLowerFsFd(pfd);
        }
    }

    private static void assertCanCreateFile(File file) throws IOException {
        // If the file somehow managed to survive a previous run, then the test app was uninstalled
        // and MediaProvider will remove our its ownership of the file, so it's not guaranteed that
        // we can create nor delete it.
        if (!file.exists()) {
            assertThat(file.createNewFile()).isTrue();
            assertThat(file.delete()).isTrue();
        } else {
            Log.w(TAG,
                    ""Couldn't assertCanCreateFile("" + file + "") because file existed prior to ""
                            + ""running the test!"");
        }
    }

    private static void assertCannotReadOrWrite(File file)
            throws Exception {
        // App data directories have different 'x' bits on upgrading vs new devices. Let's not
        // check 'exists', by passing checkExists=false. But assert this app cannot read or write
        // the other app's file.
        assertAccess(file, false /* value is moot */, false /* canRead */,
                false /* canWrite */, false /* checkExists */);
    }

    private static void assertAccess(File file, boolean exists, boolean canRead, boolean canWrite)
            throws Exception {
        assertAccess(file, exists, canRead, canWrite, true /* checkExists */);
    }

    private static void assertAccess(File file, boolean exists, boolean canRead, boolean canWrite,
            boolean checkExists) throws Exception {
        if (checkExists) {
            assertThat(file.exists()).isEqualTo(exists);
        }
        assertThat(file.canRead()).isEqualTo(canRead);
        assertThat(file.canWrite()).isEqualTo(canWrite);
        if (file.isDirectory()) {
            if (checkExists) {
                assertThat(file.canExecute()).isEqualTo(exists);
            }
        } else {
            assertThat(file.canExecute()).isFalse(); // Filesytem is mounted with MS_NOEXEC
        }

        // Test some combinations of mask.
        assertAccess(file, R_OK, canRead);
        assertAccess(file, W_OK, canWrite);
        assertAccess(file, R_OK | W_OK, canRead && canWrite);
        assertAccess(file, W_OK | F_OK, canWrite);

        if (checkExists) {
            assertAccess(file, F_OK, exists);
        }
    }

    private static void assertAccess(File file, int mask, boolean expected) throws Exception {
        if (expected) {
            assertThat(Os.access(file.getAbsolutePath(), mask)).isTrue();
        } else {
            assertThrows(ErrnoException.class, () -> {
                Os.access(file.getAbsolutePath(), mask);
            });
        }
    }

    /**
     * Creates a file at any location on storage (except external app data directory).
     * The owner of the file is not the caller app.
     */
    private void createFileAsLegacyApp(File file) throws Exception {
        // Use a legacy app to create this file, since it could be outside shared storage.
        Log.d(TAG, ""Creating file "" + file);
        assertThat(createFileAs(APP_D_LEGACY_HAS_RW, file.getAbsolutePath())).isTrue();
    }

    /**
     * Creates a file at any location on storage (except external app data directory).
     * The owner of the file is not the caller app.
     */
    private void createDirectoryAsLegacyApp(File file) throws Exception {
        // Use a legacy app to create this file, since it could be outside shared storage.
        Log.d(TAG, ""Creating directory "" + file);
        // Create a tmp file in the target directory, this would also create the required
        // directory, then delete the tmp file. It would leave only new directory.
        assertThat(createFileAs(APP_D_LEGACY_HAS_RW, file.getAbsolutePath() + ""/tmp.txt"")).isTrue();
        assertThat(deleteFileAs(APP_D_LEGACY_HAS_RW, file.getAbsolutePath() + ""/tmp.txt"")).isTrue();
    }

    /**
     * Deletes a file or directory at any location on storage (except external app data directory).
     */
    private void deleteAsLegacyApp(File file) throws Exception {
        // Use a legacy app to delete this file, since it could be outside shared storage.
        Log.d(TAG, ""Deleting file "" + file);
        deleteFileAs(APP_D_LEGACY_HAS_RW, file.getAbsolutePath());
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.permission2.cts.PermissionPolicyTest"	"platformPermissionPolicyIsUnaltered"	"CtsPermission2TestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/PermissionPolicyTest.java"	""	"public void platformPermissionPolicyIsUnaltered() throws Exception {
        Map<String, PermissionInfo> declaredPermissionsMap =
                getPermissionsForPackage(sContext, PLATFORM_PACKAGE_NAME);

        List<String> offendingList = new ArrayList<>();

        List<PermissionGroupInfo> declaredGroups = sContext.getPackageManager()
                .getAllPermissionGroups(0);
        Set<String> declaredGroupsSet = new ArraySet<>();
        for (PermissionGroupInfo declaredGroup : declaredGroups) {
            declaredGroupsSet.add(declaredGroup.name);
        }

        Set<String> expectedPermissionGroups = loadExpectedPermissionGroupNames(
                R.raw.android_manifest);
        List<ExpectedPermissionInfo> expectedPermissions = loadExpectedPermissions(
                R.raw.android_manifest);

        if (sContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE)) {
            expectedPermissions.addAll(loadExpectedPermissions(R.raw.automotive_android_manifest));
            declaredPermissionsMap.putAll(
                    getPermissionsForPackage(sContext, AUTOMOTIVE_SERVICE_PACKAGE_NAME));
        }

        for (ExpectedPermissionInfo expectedPermission : expectedPermissions) {
            String expectedPermissionName = expectedPermission.name;
            if (shouldSkipPermission(expectedPermissionName)) {
                // This permission doesn't need to exist yet, but will exist in
                // a future SPL. It is acceptable to declare the permission
                // even in an earlier SPL, so we remove it here so it doesn't
                // trigger a failure after the loop.
                declaredPermissionsMap.remove(expectedPermissionName);
                continue;
            }

            // OEMs cannot remove permissions
            PermissionInfo declaredPermission = declaredPermissionsMap.get(expectedPermissionName);
            if (declaredPermission == null) {
                offendingList.add(""Permission "" + expectedPermissionName + "" must be declared"");
                continue;
            }

            // We want to end up with OEM defined permissions and groups to check their namespace
            declaredPermissionsMap.remove(expectedPermissionName);

            // OEMs cannot change permission protection
            final int expectedProtection = expectedPermission.protectionLevel
                    & PROTECTION_MASK_BASE;
            final int declaredProtection = declaredPermission.protectionLevel
                    & PROTECTION_MASK_BASE;
            if (expectedProtection != declaredProtection) {
                offendingList.add(
                        String.format(
                                ""Permission %s invalid protection level %x, expected %x"",
                                expectedPermissionName, declaredProtection, expectedProtection));
            }

            // OEMs cannot change permission flags
            final int expectedFlags = expectedPermission.flags;
            final int declaredFlags = (declaredPermission.flags & ~FLAG_INSTALLED);
            if (expectedFlags != declaredFlags) {
                offendingList.add(
                        String.format(
                                ""Permission %s invalid flags %x, expected %x"",
                                expectedPermissionName,
                                declaredFlags,
                                expectedFlags));
            }

            // OEMs cannot change permission protection flags
            final int expectedProtectionFlags =
                    expectedPermission.protectionLevel & ~PROTECTION_MASK_BASE;
            final int declaredProtectionFlags = declaredPermission.getProtectionFlags();
            if (expectedProtectionFlags != declaredProtectionFlags) {
                offendingList.add(
                        String.format(
                                ""Permission %s invalid enforced protection %x, expected %x"",
                                expectedPermissionName,
                                declaredProtectionFlags,
                                expectedProtectionFlags));
            }

            // OEMs cannot change permission grouping
            if ((declaredPermission.protectionLevel & PermissionInfo.PROTECTION_DANGEROUS) != 0) {
                if (!Objects.equals(expectedPermission.group, declaredPermission.group)) {
                    offendingList.add(
                            ""Permission "" + expectedPermissionName + "" not in correct group ""
                            + ""(expected="" + expectedPermission.group + "" actual=""
                                    + declaredPermission.group);
                }

                if (declaredPermission.group != null
                        && !declaredGroupsSet.contains(declaredPermission.group)) {
                    offendingList.add(
                            ""Permission group "" + expectedPermission.group + "" must be defined"");
                }
            }

            // OEMs cannot change background permission mapping
            if (!Objects.equals(expectedPermission.backgroundPermission,
                    declaredPermission.backgroundPermission)) {
                offendingList.add(
                        String.format(
                                ""Permission %s invalid background permission %s, expected %s"",
                                expectedPermissionName,
                                declaredPermission.backgroundPermission,
                                expectedPermission.backgroundPermission));
            }
        }

        // OEMs cannot define permissions in the platform namespace
        for (String permission : declaredPermissionsMap.keySet()) {
            if (permission.startsWith(PLATFORM_ROOT_NAMESPACE)) {
                final PermissionInfo permInfo = declaredPermissionsMap.get(permission);
                offendingList.add(
                        ""Cannot define permission "" + permission
                        + "", package "" + permInfo.packageName
                        + "" in android namespace"");
            }
        }

        // OEMs cannot define groups in the platform namespace
        for (PermissionGroupInfo declaredGroup : declaredGroups) {
            if (!expectedPermissionGroups.contains(declaredGroup.name)) {
                if (declaredGroup.name != null) {
                    if (declaredGroup.packageName.equals(PLATFORM_PACKAGE_NAME)
                            && declaredGroup.name.startsWith(PLATFORM_ROOT_NAMESPACE)) {
                        offendingList.add(
                                ""Cannot define group "" + declaredGroup.name
                                + "", package "" + declaredGroup.packageName
                                + "" in android namespace"");
                    }
                }
            }
        }

        // OEMs cannot define new ephemeral permissions
        for (String permission : declaredPermissionsMap.keySet()) {
            PermissionInfo info = declaredPermissionsMap.get(permission);
            if ((info.protectionLevel & PermissionInfo.PROTECTION_FLAG_INSTANT) != 0) {
                offendingList.add(""Cannot define new instant permission "" + permission);
            }
        }

        // Fail on any offending item
        assertWithMessage(""list of offending permissions"").that(offendingList).isEmpty();
    }

    private List<ExpectedPermissionInfo> loadExpectedPermissions(int resourceId) throws Exception {
        List<ExpectedPermissionInfo> permissions = new ArrayList<>();
        try (InputStream in = sContext.getResources().openRawResource(resourceId)) {
            XmlPullParser parser = Xml.newPullParser();
            parser.setInput(in, null);

            final int outerDepth = parser.getDepth();
            int type;
            while ((type = parser.next()) != XmlPullParser.END_DOCUMENT
                    && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
                if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
                    continue;
                }
                if (TAG_PERMISSION.equals(parser.getName())) {
                    ExpectedPermissionInfo permissionInfo = new ExpectedPermissionInfo(
                            parser.getAttributeValue(null, ATTR_NAME),
                            parser.getAttributeValue(null, ATTR_PERMISSION_GROUP),
                            parser.getAttributeValue(null, ATTR_BACKGROUND_PERMISSION),
                            parsePermissionFlags(
                                    parser.getAttributeValue(null, ATTR_PERMISSION_FLAGS)),
                            parseProtectionLevel(
                                    parser.getAttributeValue(null, ATTR_PROTECTION_LEVEL)));
                    permissions.add(permissionInfo);
                } else {
                    Log.e(LOG_TAG, ""Unknown tag "" + parser.getName());
                }
            }
        }

        return permissions;
    }

    private Set<String> loadExpectedPermissionGroupNames(int resourceId) throws Exception {
        ArraySet<String> permissionGroups = new ArraySet<>();
        try (InputStream in = sContext.getResources().openRawResource(resourceId)) {
            XmlPullParser parser = Xml.newPullParser();
            parser.setInput(in, null);

            final int outerDepth = parser.getDepth();
            int type;
            while ((type = parser.next()) != XmlPullParser.END_DOCUMENT
                    && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
                if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
                    continue;
                }
                if (TAG_PERMISSION_GROUP.equals(parser.getName())) {
                    permissionGroups.add(parser.getAttributeValue(null, ATTR_NAME));
                } else {
                    Log.e(LOG_TAG, ""Unknown tag "" + parser.getName());
                }
            }
        }
        return permissionGroups;
    }

    private static int parsePermissionFlags(@Nullable String permissionFlagsString) {
        if (permissionFlagsString == null) {
            return 0;
        }

        int protectionFlags = 0;
        String[] fragments = permissionFlagsString.split(""\\|"");
        for (String fragment : fragments) {
            switch (fragment.trim()) {
                case ""removed"": {
                    protectionFlags |= PermissionInfo.FLAG_REMOVED;
                } break;
                case ""costsMoney"": {
                    protectionFlags |= PermissionInfo.FLAG_COSTS_MONEY;
                } break;
                case ""hardRestricted"": {
                    protectionFlags |= PermissionInfo.FLAG_HARD_RESTRICTED;
                } break;
                case ""immutablyRestricted"": {
                    protectionFlags |= PermissionInfo.FLAG_IMMUTABLY_RESTRICTED;
                } break;
                case ""softRestricted"": {
                    protectionFlags |= PermissionInfo.FLAG_SOFT_RESTRICTED;
                } break;
            }
        }
        return protectionFlags;
    }

    private static int parseProtectionLevel(String protectionLevelString) {
        int protectionLevel = 0;
        String[] fragments = protectionLevelString.split(""\\|"");
        for (String fragment : fragments) {
            switch (fragment.trim()) {
                case ""normal"": {
                    protectionLevel |= PermissionInfo.PROTECTION_NORMAL;
                } break;
                case ""dangerous"": {
                    protectionLevel |= PermissionInfo.PROTECTION_DANGEROUS;
                } break;
                case ""signature"": {
                    protectionLevel |= PermissionInfo.PROTECTION_SIGNATURE;
                } break;
                case ""signatureOrSystem"": {
                    protectionLevel |= PermissionInfo.PROTECTION_SIGNATURE;
                    protectionLevel |= PermissionInfo.PROTECTION_FLAG_SYSTEM;
                } break;
                case ""internal"": {
                    protectionLevel |= PermissionInfo.PROTECTION_INTERNAL;
                } break;
                case ""system"": {
                    protectionLevel |= PermissionInfo.PROTECTION_FLAG_SYSTEM;
                } break;
                case ""installer"": {
                    protectionLevel |= PermissionInfo.PROTECTION_FLAG_INSTALLER;
                } break;
                case ""verifier"": {
                    protectionLevel |= PermissionInfo.PROTECTION_FLAG_VERIFIER;
                } break;
                case ""preinstalled"": {
                    protectionLevel |= PermissionInfo.PROTECTION_FLAG_PREINSTALLED;
                } break;
                case ""pre23"": {
                    protectionLevel |= PermissionInfo.PROTECTION_FLAG_PRE23;
                } break;
                case ""appop"": {
                    protectionLevel |= PermissionInfo.PROTECTION_FLAG_APPOP;
                } break;
                case ""development"": {
                    protectionLevel |= PermissionInfo.PROTECTION_FLAG_DEVELOPMENT;
                } break;
                case ""privileged"": {
                    protectionLevel |= PermissionInfo.PROTECTION_FLAG_PRIVILEGED;
                } break;
                case ""oem"": {
                    protectionLevel |= PermissionInfo.PROTECTION_FLAG_OEM;
                } break;
                case ""vendorPrivileged"": {
                    protectionLevel |= PermissionInfo.PROTECTION_FLAG_VENDOR_PRIVILEGED;
                } break;
                case ""setup"": {
                    protectionLevel |= PermissionInfo.PROTECTION_FLAG_SETUP;
                } break;
                case ""textClassifier"": {
                    protectionLevel |= PermissionInfo.PROTECTION_FLAG_SYSTEM_TEXT_CLASSIFIER;
                } break;
                case ""configurator"": {
                    protectionLevel |= PermissionInfo.PROTECTION_FLAG_CONFIGURATOR;
                } break;
                case ""incidentReportApprover"": {
                    protectionLevel |= PermissionInfo.PROTECTION_FLAG_INCIDENT_REPORT_APPROVER;
                } break;
                case ""documenter"": {
                    protectionLevel |= PermissionInfo.PROTECTION_FLAG_DOCUMENTER;
                } break;
                case ""appPredictor"": {
                    protectionLevel |= PermissionInfo.PROTECTION_FLAG_APP_PREDICTOR;
                } break;
                case ""instant"": {
                    protectionLevel |= PermissionInfo.PROTECTION_FLAG_INSTANT;
                } break;
                case ""runtime"": {
                    protectionLevel |= PermissionInfo.PROTECTION_FLAG_RUNTIME_ONLY;
                } break;
                case ""companion"": {
                    protectionLevel |= PermissionInfo.PROTECTION_FLAG_COMPANION;
                } break;
                case ""retailDemo"": {
                    protectionLevel |= PermissionInfo.PROTECTION_FLAG_RETAIL_DEMO;
                } break;
                case ""recents"": {
                    protectionLevel |= PermissionInfo.PROTECTION_FLAG_RECENTS;
                } break;
                case ""role"": {
                    protectionLevel |= PermissionInfo.PROTECTION_FLAG_ROLE;
                } break;
            }
        }
        return protectionLevel;
    }

    private static Map<String, PermissionInfo> getPermissionsForPackage(Context context, String pkg)
            throws NameNotFoundException {
        PackageInfo packageInfo = context.getPackageManager()
                .getPackageInfo(pkg, PackageManager.GET_PERMISSIONS);
        Map<String, PermissionInfo> declaredPermissionsMap = new ArrayMap<>();

        for (PermissionInfo declaredPermission : packageInfo.permissions) {
            declaredPermissionsMap.put(declaredPermission.name, declaredPermission);
        }
        return declaredPermissionsMap;
    }

    private static Date parseDate(String date) {
        Date patchDate = new Date();
        try {
            SimpleDateFormat template = new SimpleDateFormat(""yyyy-MM-dd"");
            patchDate = template.parse(date);
        } catch (ParseException e) {
        }

        return patchDate;
    }

    private boolean shouldSkipPermission(String permissionName) {
        switch (permissionName) {
            case HIDE_NON_SYSTEM_OVERLAY_WINDOWS_PERMISSION:
                return parseDate(SECURITY_PATCH).before(HIDE_NON_SYSTEM_OVERLAY_WINDOWS_PATCH_DATE);
            case MANAGE_COMPANION_DEVICES_PERMISSION:
                return parseDate(SECURITY_PATCH).before(MANAGE_COMPANION_DEVICES_PATCH_DATE);
            default:
                return false;
        }
    }

    private class ExpectedPermissionInfo {
        final @NonNull String name;
        final @Nullable String group;
        final @Nullable String backgroundPermission;
        final int flags;
        final int protectionLevel;

        private ExpectedPermissionInfo(@NonNull String name, @Nullable String group,
                @Nullable String backgroundPermission, int flags, int protectionLevel) {
            this.name = name;
            this.group = group;
            this.backgroundPermission = backgroundPermission;
            this.flags = flags;
            this.protectionLevel = protectionLevel;
        }
    }
}"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.DeviceOwnerPlusProfileOwnerTest"	"testCannotRemoveUserIfRestrictionSet"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceOwnerPlusProfileOwnerTest.java"	""	"public void testCannotRemoveUserIfRestrictionSet() throws Exception {
        assumeCanCreateAdditionalUsers(1);

        int secondaryUserId = setupManagedSecondaryUser();
        addDisallowRemoveUserRestriction();
        assertFalse(getDevice().removeUser(secondaryUserId));

        clearDisallowRemoveUserRestriction();
        assertTrue(getDevice().removeUser(secondaryUserId));
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.DeviceOwnerPlusProfileOwnerTest"	"testCannotAddProfileIfRestrictionSet"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceOwnerPlusProfileOwnerTest.java"	""	"public void testCannotAddProfileIfRestrictionSet() throws Exception {
        // by default, disallow add managed profile users restriction is set.
        assertCannotCreateManagedProfile(mPrimaryUserId);
    }

    private void sendWipeProfileBroadcast(int userId) throws Exception {
        final String cmd = ""am broadcast --receiver-foreground --user "" + userId
                + "" -a com.android.cts.comp.WIPE_DATA""
                + "" com.android.cts.comp/.WipeDataReceiver"";
        getDevice().executeShellCommand(cmd);
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.DeviceOwnerPlusProfileOwnerTest"	"testWipeData_secondaryUser"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceOwnerPlusProfileOwnerTest.java"	""	"public void testWipeData_secondaryUser() throws Exception {
        assumeCanCreateAdditionalUsers(1);

        int secondaryUserId = setupManagedSecondaryUser();
        addDisallowRemoveUserRestriction();
        // The PO of the managed user should be allowed to delete it, even though the disallow
        // remove user restriction is set.
        sendWipeProfileBroadcast(secondaryUserId);
        waitUntilUserRemoved(secondaryUserId);
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.DeviceOwnerPlusProfileOwnerTest"	"testWipeData_secondaryUserLogged"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceOwnerPlusProfileOwnerTest.java"	""	"public void testWipeData_secondaryUserLogged() throws Exception {
        assumeCanCreateAdditionalUsers(1);

        int secondaryUserId = setupManagedSecondaryUser();
        addDisallowRemoveUserRestriction();
        assertMetricsLogged(getDevice(), () -> {
            sendWipeProfileBroadcast(secondaryUserId);
            waitUntilUserRemoved(secondaryUserId);
        }, WIPE_DATA_WITH_REASON_DEVICE_POLICY_EVENT);
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.DeviceOwnerPlusProfileOwnerTest"	"testRequestBugreportAvailableIfAffiliated"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceOwnerPlusProfileOwnerTest.java"	""	"public void testRequestBugreportAvailableIfAffiliated() throws Exception {
        assumeCanCreateAdditionalUsers(2);

        final int secondaryUserId = setupManagedSecondaryUser();

        // No affiliation ids have been set on the secondary user, the feature shouldn't be
        // available.
        runDeviceTestsAsUser(
                COMP_DPC_PKG,
                DEVICE_WIDE_LOGGING_TEST,
                ""testRequestBugreportThrowsSecurityException"",
                mPrimaryUserId);

        // Affiliate the DO and the secondary user.
        setSameAffiliationId(secondaryUserId);
        runDeviceTestsAsUser(
                COMP_DPC_PKG,
                DEVICE_WIDE_LOGGING_TEST,
                ""testRequestBugreportDoesNotThrowException"",
                mPrimaryUserId);

        setDifferentAffiliationId(secondaryUserId, COMP_DPC_PKG);
        runDeviceTestsAsUser(
                COMP_DPC_PKG,
                DEVICE_WIDE_LOGGING_TEST,
                ""testRequestBugreportThrowsSecurityException"",
                mPrimaryUserId);
    }

    private void verifyBindDeviceAdminServiceAsUser(int profileOwnerUserId) throws Exception {
        // Installing a non managing app (neither device owner nor profile owner).
        installAppAsUser(COMP_DPC_APK2, mPrimaryUserId);
        installAppAsUser(COMP_DPC_APK2, profileOwnerUserId);

        // Testing device owner -> profile owner.
        runDeviceTestsAsUser(
                COMP_DPC_PKG,
                BIND_DEVICE_ADMIN_SERVICE_GOOD_SETUP_TEST,
                mPrimaryUserId);
        // Testing profile owner -> device owner.
        runDeviceTestsAsUser(
                COMP_DPC_PKG,
                BIND_DEVICE_ADMIN_SERVICE_GOOD_SETUP_TEST,
                profileOwnerUserId);
    }

    private void verifyBindDeviceAdminServiceAsUserFails(int profileOwnerUserId) throws Exception {
        // Installing a non managing app (neither device owner nor profile owner).
        installAppAsUser(COMP_DPC_APK2, mPrimaryUserId);
        installAppAsUser(COMP_DPC_APK2, profileOwnerUserId);

        // Testing device owner -> profile owner.
        runDeviceTestsAsUser(
                COMP_DPC_PKG,
                BIND_DEVICE_ADMIN_SERVICE_FAILS_TEST,
                mPrimaryUserId);
        // Testing profile owner -> device owner.
        runDeviceTestsAsUser(
                COMP_DPC_PKG,
                BIND_DEVICE_ADMIN_SERVICE_FAILS_TEST,
                profileOwnerUserId);
    }

    private void setSameAffiliationId(
            int profileOwnerUserId, String profileOwnerPackage) throws Exception {
        runDeviceTestsAsUser(
                COMP_DPC_PKG,
                AFFILIATION_TEST,
                ""testSetAffiliationId1"",
                mPrimaryUserId);
        runDeviceTestsAsUser(
                profileOwnerPackage,
                AFFILIATION_TEST,
                ""testSetAffiliationId1"",
                profileOwnerUserId);
    }

    private void setSameAffiliationId(int profileOwnerUserId) throws Exception {
        setSameAffiliationId(profileOwnerUserId, COMP_DPC_PKG);
    }

    private void setDifferentAffiliationId(
            int profileOwnerUserId, String profileOwnerPackage) throws Exception {
        runDeviceTestsAsUser(
                COMP_DPC_PKG,
                AFFILIATION_TEST,
                ""testSetAffiliationId1"",
                mPrimaryUserId);
        runDeviceTestsAsUser(
                profileOwnerPackage,
                AFFILIATION_TEST,
                ""testSetAffiliationId2"",
                profileOwnerUserId);
    }

    private void setDifferentAffiliationId(int profileOwnerUserId) throws Exception {
        setDifferentAffiliationId(profileOwnerUserId, COMP_DPC_PKG);
    }

    private void assertProvisionManagedProfileNotAllowed(String packageName) throws Exception {
        runDeviceTestsAsUser(
                packageName,
                MANAGEMENT_TEST,
                ""testProvisionManagedProfileNotAllowed"",
                mPrimaryUserId);
    }

    /** Returns the user id of the newly created managed profile */
    private int setupManagedProfile(String apkName, String packageName,
            String adminReceiverClassName) throws Exception {
        final int userId = createManagedProfile(mPrimaryUserId);
        installAppAsUser(apkName, userId);
        setProfileOwnerOrFail(adminReceiverClassName, userId);
        startUserAndWait(userId);
        runDeviceTestsAsUser(
                packageName,
                MANAGEMENT_TEST,
                ""testIsManagedProfile"",
                userId);
        return userId;
    }

    /** Returns the user id of the newly created secondary user */
    private int setupManagedSecondaryUser() throws Exception {
        assertTrue(""Cannot create 1 additional user"", canCreateAdditionalUsers(1));

        runDeviceTestsAsUser(
                COMP_DPC_PKG,
                MANAGEMENT_TEST,
                ""testCreateSecondaryUser"",
                mPrimaryUserId);
        List<Integer> newUsers = getUsersCreatedByTests();
        assertEquals(1, newUsers.size());
        int secondaryUserId = newUsers.get(0);
        getDevice().startUser(secondaryUserId, /* waitFlag= */ true);
        return secondaryUserId;
    }

    /** Returns the user id of the newly created secondary user */
    private int provisionCorpOwnedManagedProfile() throws Exception {
        runDeviceTestsAsUser(
                COMP_DPC_PKG,
                MANAGED_PROFILE_PROVISIONING_TEST,
                ""testProvisioningCorpOwnedManagedProfile"",
                mPrimaryUserId);
        return getFirstManagedProfileUserId();
    }

    /**
     * Add {@link android.os.UserManager#DISALLOW_REMOVE_USER}.
     */
    private void addDisallowRemoveUserRestriction() throws Exception {
        runDeviceTestsAsUser(
                COMP_DPC_PKG,
                USER_RESTRICTION_TEST,
                ""testAddDisallowRemoveUserRestriction"",
                mPrimaryUserId);
    }

    /**
     * Clear {@link android.os.UserManager#DISALLOW_REMOVE_USER}.
     */
    private void clearDisallowRemoveUserRestriction() throws Exception {
        runDeviceTestsAsUser(
                COMP_DPC_PKG,
                USER_RESTRICTION_TEST,
                ""testClearDisallowRemoveUserRestriction"",
                mPrimaryUserId);
    }

    private void assertOtherProfilesEqualsBindTargetUsers(int otherProfileUserId) throws Exception {
        runDeviceTestsAsUser(
                COMP_DPC_PKG,
                MANAGEMENT_TEST,
                ""testOtherProfilesEqualsBindTargetUsers"",
                mPrimaryUserId);
        runDeviceTestsAsUser(
                COMP_DPC_PKG,
                MANAGEMENT_TEST,
                ""testOtherProfilesEqualsBindTargetUsers"",
                otherProfileUserId);
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"communication.main.java.com.android.bedstead.remotedpc.managers.RemoteDevicePolicyManager"	"isUsingUnifiedPassword"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/remotedpc/src/communication/main/java/com/android/bedstead/remotedpc/managers/RemoteDevicePolicyManager.java"	""	"public void test/*
 *.
 */

package com.android.bedstead.remotedpc.managers;

import android.app.admin.DevicePolicyManager;
import android.app.admin.SystemUpdateInfo;
import android.content.ComponentName;
import android.content.IntentFilter;
import android.os.Bundle;

import androidx.annotation.NonNull;

import com.android.bedstead.remotedpc.processor.annotations.RemoteDpcAutomaticAdmin;
import com.android.bedstead.remotedpc.processor.annotations.RemoteDpcManager;

import java.util.List;
import java.util.Set;

/**
 * Wrapper of {@link DevicePolicyManager} methods for use with Remote DPC
 *
 * <p>Methods called on this interface will behave as if they were called directly by the
 * RemoteDPC instance. Return values and exceptions will behave as expected.
 *
 * <p>Methods on this interface must match exactly the methods declared by
 * {@link DevicePolicyManager}, or else must be identical to a method declared by
 * {@link DevicePolicyManager} except that it excludes a {@code ComponentName admin} first argument
 * and must be annotated {@link RemoteDpcAutomaticAdmin}.
 *
 * <p>When using {@link RemoteDpcAutomaticAdmin}, there must also exist an identical method on the
 * interface which includes the {@code ComponentName admin} argument. The RemoteDPC component name
 * will be automatically provided when the {@link RemoteDpcAutomaticAdmin} annotated method is
 * called.
 */
@RemoteDpcManager(managerClass = DevicePolicyManager.class)
public interface RemoteDevicePolicyManager {

    /** See {@link DevicePolicyManager#isUsingUnifiedPassword(ComponentName)}. */
    boolean isUsingUnifiedPassword(@NonNull ComponentName admin);
    /** See {@link DevicePolicyManager#isUsingUnifiedPassword(ComponentName)}. */
    @RemoteDpcAutomaticAdmin boolean isUsingUnifiedPassword();

    /** See {@link DevicePolicyManager#getCurrentFailedPasswordAttempts()}. */
    int getCurrentFailedPasswordAttempts();

    /** See {@link DevicePolicyManager#setLockTaskPackages(ComponentName, String[])}. */
    void setLockTaskPackages(@NonNull ComponentName admin, @NonNull String[] packages);
    /** See {@link DevicePolicyManager#setLockTaskPackages(ComponentName, String[])}. */
    @RemoteDpcAutomaticAdmin void setLockTaskPackages(@NonNull String[] packages);

    /** See {@link DevicePolicyManager#getLockTaskPackages(ComponentName)}. */
    @NonNull String[] getLockTaskPackages(@NonNull ComponentName admin);
    /** See {@link DevicePolicyManager#getLockTaskPackages(ComponentName)}. */
    @RemoteDpcAutomaticAdmin @NonNull String[] getLockTaskPackages();

    /** See {@link DevicePolicyManager#setLockTaskFeatures(ComponentName, int)}. */
    void setLockTaskFeatures(
            @NonNull ComponentName admin, int flags);
    /** See {@link DevicePolicyManager#setLockTaskFeatures(ComponentName, int)}. */
    @RemoteDpcAutomaticAdmin void setLockTaskFeatures(int flags);

    /** See {@link DevicePolicyManager#getLockTaskFeatures(ComponentName)}. */
    int getLockTaskFeatures(@NonNull ComponentName admin);
    /** See {@link DevicePolicyManager#getLockTaskFeatures(ComponentName)}. */
    @RemoteDpcAutomaticAdmin int getLockTaskFeatures();


    /** See {@link DevicePolicyManager#setUserControlDisabledPackages(ComponentName, List)}. */
    void setUserControlDisabledPackages(
            @NonNull ComponentName admin, @NonNull List<String> packages);
    /** See {@link DevicePolicyManager#setUserControlDisabledPackages(ComponentName, List)}. */
    @RemoteDpcAutomaticAdmin void setUserControlDisabledPackages(@NonNull List<String> packages);

    /** See {@link DevicePolicyManager#getUserControlDisabledPackages(ComponentName)}. */
    @NonNull List<String> getUserControlDisabledPackages(@NonNull ComponentName admin);
    /** See {@link DevicePolicyManager#getUserControlDisabledPackages(ComponentName)}. */
    @RemoteDpcAutomaticAdmin @NonNull List<String> getUserControlDisabledPackages();


    /** See {@link DevicePolicyManager#addUserRestriction(ComponentName, String)}. */
    void addUserRestriction(@NonNull ComponentName admin, String key);
    /** See {@link DevicePolicyManager#addUserRestriction(ComponentName, String)}. */
    @RemoteDpcAutomaticAdmin void addUserRestriction(String key);

    /** See {@link DevicePolicyManager#clearUserRestriction(ComponentName, String)}. */
    void clearUserRestriction(@NonNull ComponentName admin, String key);
    /** See {@link DevicePolicyManager#clearUserRestriction(ComponentName, String)}. */
    @RemoteDpcAutomaticAdmin void clearUserRestriction(String key);

    /** See {@link DevicePolicyManager#getUserRestrictions(ComponentName)}. */
    @NonNull Bundle getUserRestrictions(@NonNull ComponentName admin);
    /** See {@link DevicePolicyManager#getUserRestrictions(ComponentName)}. */
    @RemoteDpcAutomaticAdmin @NonNull Bundle getUserRestrictions();

    /**
     * See {@link DevicePolicyManager#addCrossProfileIntentFilter(ComponentName, IntentFilter,
     * int)}.
     */
    void addCrossProfileIntentFilter(@NonNull ComponentName admin, @NonNull IntentFilter filter,
            int flags);
    /**
     * See {@link DevicePolicyManager#addCrossProfileIntentFilter(ComponentName, IntentFilter,
     * int)}.
     */
    @RemoteDpcAutomaticAdmin void addCrossProfileIntentFilter(@NonNull IntentFilter filter,
            int flags);

    /** See {@link DevicePolicyManager#clearCrossProfileIntentFilters(ComponentName)}. */
    void clearCrossProfileIntentFilters(@NonNull ComponentName admin);
    /** See {@link DevicePolicyManager#clearCrossProfileIntentFilters(ComponentName)}. */
    @RemoteDpcAutomaticAdmin void clearCrossProfileIntentFilters();

    /** See {@link DevicePolicyManager#setPreferentialNetworkServiceEnabled(boolean)}. */
    void setPreferentialNetworkServiceEnabled(boolean enabled);

    /** See {@link DevicePolicyManager#notifyPendingSystemUpdate(long)}. */
    void notifyPendingSystemUpdate(long updateReceivedTime);

    /** See {@link DevicePolicyManager#notifyPendingSystemUpdate(long, boolean)}. */
    void notifyPendingSystemUpdate(long updateReceivedTime, boolean isSecurityPatch);

    /** See {@link DevicePolicyManager#getPendingSystemUpdate(ComponentName}). */
    SystemUpdateInfo getPendingSystemUpdate(ComponentName admin);
    /** See {@link DevicePolicyManager#getPendingSystemUpdate(ComponentName}). */
    @RemoteDpcAutomaticAdmin SystemUpdateInfo getPendingSystemUpdate();

    /** See {@link DevicePolicyManager#setAffiliationIds(ComponentName, Set)}. */
    void setAffiliationIds(ComponentName admin, Set<String> ids);
    /** See {@link DevicePolicyManager#setAffiliationIds(ComponentName, Set)}. */
    @RemoteDpcAutomaticAdmin void setAffiliationIds(Set<String> ids);

    /** See {@link android.app.admin.DevicePolicyManager#addPersistentPreferredActivity(ComponentName, IntentFilter, ComponentName)}. */
    void addPersistentPreferredActivity(
            ComponentName admin, IntentFilter filter, ComponentName activity);

    /** See {@link android.app.admin.DevicePolicyManager#addPersistentPreferredActivity(ComponentName, IntentFilter, ComponentName)}. */
    @RemoteDpcAutomaticAdmin void addPersistentPreferredActivity(
            IntentFilter filter, ComponentName activity);
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.AutofillRestrictionsTest"	"disableService"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/AutofillRestrictionsTest.java"	""	"public void test/*
 *.
 */

package com.android.cts.deviceandprofileowner;

import static android.os.UserManager.DISALLOW_AUTOFILL;
import static android.provider.Settings.Secure.AUTOFILL_SERVICE;
import static android.provider.Settings.Secure.USER_SETUP_COMPLETE;

import android.content.Intent;

public class AutofillRestrictionsTest extends BaseDeviceAdminTest {

    private static final String SERVICE_NAME =
            ""com.android.cts.devicepolicy.autofillapp/.SimpleAutofillService"";
    private static final String AUTOFILL_PACKAGE_NAME = ""com.android.cts.devicepolicy.autofillapp"";
    private static final String AUTOFILL_ACTIVITY_NAME = AUTOFILL_PACKAGE_NAME + "".SimpleActivity"";

    // Before, autofill_service was a cloned service, so it was only set in the default user,
    // and we were using a guard to decide how to set it.
    // Autofill_service has been changed now to be a per-user service so we are currently
    // setting this to false.
    private final boolean USES_CLONED_SETTINGS = false;

    int mUserId;

    @Override
    protected void setUp() throws Exception {
        super.setUp();

        mUserId = getInstrumentation().getContext().getUserId();
    }

    @Override
    protected void tearDown() throws Exception {
        try {
            disableService();
        } finally {
            mDevicePolicyManager.clearUserRestriction(ADMIN_RECEIVER_COMPONENT, DISALLOW_AUTOFILL);
        }
        super.tearDown();
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.AutofillRestrictionsTest"	"testDisallowAutofill_allowed"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/AutofillRestrictionsTest.java"	""	"public void testDisallowAutofill_allowed() throws Exception {
        enableService();

        final boolean enabledBefore = launchActivityAndGetEnabled();
        assertTrue(enabledBefore);

        mDevicePolicyManager.addUserRestriction(ADMIN_RECEIVER_COMPONENT, DISALLOW_AUTOFILL);

        // Must try a couple times because it will be disabled asynchronously.
        for (int i = 1; i <= 15; i++) {
            final boolean disabledAfter = !launchActivityAndGetEnabled();
            if (disabledAfter) {
                return;
            }
            Thread.sleep(100);
        }
        fail(""Not disabled after a period of time"");
    }

    private boolean launchActivityAndGetEnabled() throws Exception {
        final Intent launchIntent = new Intent();
        launchIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        launchIntent.setClassName(AUTOFILL_PACKAGE_NAME, AUTOFILL_ACTIVITY_NAME);
        final AutofillActivity activity = launchActivity(""com.android.cts.deviceandprofileowner"",
                AutofillActivity.class, null);
        return activity.isAutofillEnabled();
    }

    private void enableService() throws Exception {
        runShellCommand(""settings put secure --user %d %s %d default"",
                mUserId, USER_SETUP_COMPLETE, 1);

        if (USES_CLONED_SETTINGS) {
            runShellCommand(""settings put secure %s %s default"", AUTOFILL_SERVICE, SERVICE_NAME);
        } else {
            runShellCommand(""settings put --user %d secure %s %s default"",
                    mUserId, AUTOFILL_SERVICE, SERVICE_NAME);
        }
        waitForServiceSettingSaved(SERVICE_NAME);
    }

    private void disableService() {
        if (USES_CLONED_SETTINGS) {
            runShellCommand(""settings delete secure %s"", AUTOFILL_SERVICE);
        } else {
            runShellCommand(""settings delete --user %d secure %s"", mUserId, AUTOFILL_SERVICE);
        }
    }

    private void waitForServiceSettingSaved(String expected) throws Exception {
        String actual = null;
        // Wait up to 0.5 seconds until setting is saved.
        for (int i = 0; i < 5; i++) {
            if (USES_CLONED_SETTINGS) {
                actual = runShellCommand(""settings get secure %s"", AUTOFILL_SERVICE);
            } else {
                actual = runShellCommand(""settings get --user %d secure %s"", mUserId,
                        AUTOFILL_SERVICE);
            }
            if (expected.equals(actual)) {
                return;
            }
            Thread.sleep(100);
        }
        fail(""Expected service status for user "" + mUserId + "": "" + expected
                + ""; actual: "" + actual + "" after 0.5 seconds"");
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.userrestrictions.SecondaryProfileOwnerUserRestrictionsTest"	"getDisallowedRestrictions"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/userrestrictions/SecondaryProfileOwnerUserRestrictionsTest.java"	""	"public void test/*
 *.
 */
package com.android.cts.deviceandprofileowner.userrestrictions;

import android.os.UserManager;

import java.util.Arrays;
import java.util.HashSet;

public class SecondaryProfileOwnerUserRestrictionsTest extends BaseUserRestrictionsTest {
    public static final String[] ALLOWED = new String[] {
            // UserManager.DISALLOW_CONFIG_WIFI, // Has unrecoverable side effects.
            UserManager.DISALLOW_MODIFY_ACCOUNTS,
            UserManager.DISALLOW_INSTALL_APPS,
            UserManager.DISALLOW_UNINSTALL_APPS,
            // UserManager.DISALLOW_SHARE_LOCATION, // Has unrecoverable side effects.
            // UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES, // Has unrecoverable side effects.
            // UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES_GLOBALLY, // Same as above.
            UserManager.DISALLOW_CONFIG_BLUETOOTH,
            UserManager.DISALLOW_CONFIG_CREDENTIALS,
            UserManager.DISALLOW_REMOVE_USER,
            // UserManager.DISALLOW_DEBUGGING_FEATURES, // Need for CTS
            UserManager.DISALLOW_CONFIG_VPN,
            // UserManager.ENSURE_VERIFY_APPS, // Has unrecoverable side effects.
            UserManager.DISALLOW_APPS_CONTROL,
            UserManager.DISALLOW_UNMUTE_MICROPHONE,
            UserManager.DISALLOW_ADJUST_VOLUME,
            UserManager.DISALLOW_OUTGOING_CALLS,
            UserManager.DISALLOW_SYSTEM_ERROR_DIALOGS,
            UserManager.DISALLOW_CROSS_PROFILE_COPY_PASTE,
            UserManager.DISALLOW_OUTGOING_BEAM,
            UserManager.ALLOW_PARENT_PROFILE_APP_LINKING,
            UserManager.DISALLOW_SET_USER_ICON,
            UserManager.DISALLOW_AUTOFILL,
            UserManager.DISALLOW_CONTENT_CAPTURE,
            UserManager.DISALLOW_CONTENT_SUGGESTIONS,
            UserManager.DISALLOW_UNIFIED_PASSWORD,
    };

    public static final String[] DISALLOWED = new String[] {
            UserManager.DISALLOW_USB_FILE_TRANSFER,
            UserManager.DISALLOW_CONFIG_TETHERING,
            UserManager.DISALLOW_NETWORK_RESET,
            UserManager.DISALLOW_FACTORY_RESET,
            UserManager.DISALLOW_ADD_USER,
            UserManager.DISALLOW_CONFIG_CELL_BROADCASTS,
            UserManager.DISALLOW_CONFIG_MOBILE_NETWORKS,
            UserManager.DISALLOW_MOUNT_PHYSICAL_MEDIA,
            UserManager.DISALLOW_SMS,
            UserManager.DISALLOW_FUN,
            UserManager.DISALLOW_SAFE_BOOT,
            UserManager.DISALLOW_CREATE_WINDOWS,
            UserManager.DISALLOW_DATA_ROAMING,
            UserManager.DISALLOW_BLUETOOTH
    };

    public static final String[] ALLOWED_BUT_LEAKY = new String[] {
        UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES_GLOBALLY,
    };

    @Override
    protected String[] getAllowedRestrictions() {
        return ALLOWED;
    }

    @Override
    protected String[] getDisallowedRestrictions() {
        return DISALLOWED;
    }

    @Override
    protected String[] getDefaultEnabledRestrictions() { return new String[0]; }

    /**
     * This is called after DO setting all DO restrictions. Global restrictions should be
     * visible on other users.
     */"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.userrestrictions.SecondaryProfileOwnerUserRestrictionsTest"	"testHasGlobalRestrictions"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/userrestrictions/SecondaryProfileOwnerUserRestrictionsTest.java"	""	"public void testHasGlobalRestrictions() {
        assertRestrictions(new HashSet<>(Arrays.asList(DO_GLOBAL_RESTRICTIONS)));
    }

    /**
     * This is called after DO setting all DO restrictions, and PO setting all PO restrictions.
     * All global + local restrictions should be visible.
     */"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.userrestrictions.SecondaryProfileOwnerUserRestrictionsTest"	"testHasBothGlobalAndLocalRestrictions"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/userrestrictions/SecondaryProfileOwnerUserRestrictionsTest.java"	""	"public void testHasBothGlobalAndLocalRestrictions() {
        final HashSet<String> expected = new HashSet<>();

        // Should see all global ones from DO.
        expected.addAll(Arrays.asList(DO_GLOBAL_RESTRICTIONS));

        // Should also see all global ones from itself.
        expected.addAll(Arrays.asList(ALLOWED));

        assertRestrictions(expected);
    }

    /**
     * This is called after DO setting all DO restrictions, and PO setting all PO restrictions,
     * then DO clearing all restrictions.  Only PO restrictions should be set.
     */"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.userrestrictions.SecondaryProfileOwnerUserRestrictionsTest"	"testLocalRestrictionsOnly"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/userrestrictions/SecondaryProfileOwnerUserRestrictionsTest.java"	""	"public void testLocalRestrictionsOnly() {
        // Now should only see the ones that are set by this PO.
        assertRestrictions(new HashSet<>(Arrays.asList(ALLOWED)));
    }

    /**
     * Only the default restrictions should be set. Excludes restrictions that leak from other
     * profiles.
     */"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.userrestrictions.SecondaryProfileOwnerUserRestrictionsTest"	"testDefaultAndLeakyRestrictions"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/userrestrictions/SecondaryProfileOwnerUserRestrictionsTest.java"	""	"public void testDefaultAndLeakyRestrictions() {
        // The secondary profile test expects no allowed restrictions to be leaked, with the
        // exception being the restrictions that are leaky. ""Leaky"" restrictions are global,
        // device-wide restrictions that ""leak"" from the secondary profile to other profiles.
        final HashSet<String> expected = new HashSet<>(Arrays.asList(ALLOWED_BUT_LEAKY));
        assertRestrictions(expected);
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.DeviceAndProfileOwnerTest"	"testApplicationRestrictionIsRestricted"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java"	""	"public void testApplicationRestrictionIsRestricted() throws Exception {
        installAppAsUser(DELEGATE_APP_APK, mUserId);
        runDeviceTestsAsUser(DELEGATE_APP_PKG, "".AppRestrictionsIsCallerDelegateHelper"",
            ""testAssertCallerIsNotApplicationRestrictionsManagingPackage"", mUserId);
        runDeviceTestsAsUser(DEVICE_ADMIN_PKG, "".ApplicationRestrictionsIsCallerDelegateHelper"",
            ""testSetApplicationRestrictionsManagingPackageToDelegate"", mUserId);
        runDeviceTestsAsUser(DELEGATE_APP_PKG, "".AppRestrictionsIsCallerDelegateHelper"",
            ""testAssertCallerIsApplicationRestrictionsManagingPackage"", mUserId);
    }"	""	""	"restricted restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.DeviceAndProfileOwnerTest"	"testSetNearbyAppStreamingPolicy_changesPolicy"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java"	""	"public void testSetNearbyAppStreamingPolicy_changesPolicy() throws Exception {
        executeDeviceTestMethod(
                "".NearbyAppStreamingPolicyTest"", ""testSetNearbyAppStreamingPolicy_changesPolicy"");
    }

    /**
     * Executes a test class on device. Prior to running, turn off background data usage
     * restrictions, and restore the original restrictions after the test.
     */
    private void executeDeviceTestClassNoRestrictBackground(String className) throws Exception {
        boolean originalRestriction = ensureRestrictBackgroundPolicyOff();
        try {
            executeDeviceTestClass(className);
        } catch (Exception e) {
            throw e;
        } finally {
            // if the test throws exception, still restore the policy
            restoreRestrictBackgroundPolicyTo(originalRestriction);
        }
    }

    protected void executeDeviceTestClass(String className) throws Exception {
        executeDeviceTestMethod(className, /* testName= */ null);
    }

    protected void executeDeviceTestMethod(String className, String testName) throws Exception {
        executeDeviceTestMethod(className, testName, /* params= */ new HashMap<>());
    }

    protected void executeDeviceTestMethod(String className, String testName,
            Map<String, String> params) throws Exception {
        executeDeviceTestMethod(className, testName, mUserId, params);
    }

    protected void executeDeviceTestMethod(String className, String testName, int userId,
            Map<String, String> params) throws Exception {
        runDeviceTestsAsUser(DEVICE_ADMIN_PKG, className, testName, userId, params);
    }

    protected void installAppPermissionAppAsUser()
            throws FileNotFoundException, DeviceNotAvailableException {
        installAppAsUser(PERMISSIONS_APP_APK, false, mUserId);
    }

    private void executeSuspendPackageTestMethod(String testName) throws Exception {
        runDeviceTestsAsUser(INTENT_SENDER_PKG, "".SuspendPackageTest"", testName, mUserId);
    }

    private void executeAccountTest(String testName) throws DeviceNotAvailableException {
        runDeviceTestsAsUser(ACCOUNT_MANAGEMENT_PKG, "".AccountManagementTest"",
                testName, mUserId);
        // Send a home intent to dismiss an error dialog.
        String command = ""am start -a android.intent.action.MAIN""
                + "" -c android.intent.category.HOME"";
        CLog.i(""Output for command "" + command + "": "" + getDevice().executeShellCommand(command));
    }

    private void executeAppRestrictionsManagingPackageTest(String testName) throws Exception {
        runDeviceTestsAsUser(DELEGATE_APP_PKG,
                "".AppRestrictionsDelegateTest"", testName, mUserId);
    }

    private void executeDelegationTests(Map<String, DevicePolicyEventWrapper[]> delegationTests,
            boolean positive)
            throws Exception {
        for (Map.Entry<String, DevicePolicyEventWrapper[]> entry : delegationTests.entrySet()) {
            final String delegationTestClass = entry.getKey();
            final DevicePolicyEventWrapper[] expectedMetrics = entry.getValue();
            final DevicePolicyEventLogVerifier.Action testRun = () -> {
                runDeviceTestsAsUser(DELEGATE_APP_PKG, delegationTestClass,
                        positive ? ""testCanAccessApis"" : ""testCannotAccessApis"", mUserId);
            };
            if (expectedMetrics != null && positive) {
                assertMetricsLogged(getDevice(), testRun, expectedMetrics);
            } else {
                testRun.apply();
            }
        }
    }

    private void changeUserRestrictionOrFail(String key, boolean value, int userId)
            throws DeviceNotAvailableException {
        changeUserRestrictionOrFail(key, value, userId, DEVICE_ADMIN_PKG);
    }

    private void changeAccountManagement(String command, String accountType, int userId)
            throws DeviceNotAvailableException {
        changePolicyOrFail(command, ""--es extra-account-type "" + accountType, userId);
    }

    private void changeApplicationRestrictionsManagingPackage(String packageName)
            throws DeviceNotAvailableException {
        String packageNameExtra = (packageName != null)
                ? ""--es extra-package-name "" + packageName : """";
        changePolicyOrFail(""set-app-restrictions-manager"", packageNameExtra, mUserId);
    }

    protected void setDelegatedScopes(String packageName, List<String> scopes)
            throws DeviceNotAvailableException {
        final String packageNameExtra = ""--es extra-package-name "" + packageName;
        String scopesExtra = """";
        if (scopes != null && scopes.size() > 0) {
            scopesExtra = ""--esa extra-scopes-list "" + scopes.get(0);
            for (int i = 1; i < scopes.size(); ++i) {
                scopesExtra += "","" + scopes.get(i);
            }
        }
        final String extras = packageNameExtra + "" "" + scopesExtra;

        changePolicyOrFail(""set-delegated-scopes"", extras, mUserId);
    }

    private void setInstallPackageAppOps(String packageName, boolean allowed, int userId)
            throws DeviceNotAvailableException {
        String command = ""appops set --user "" + userId + "" "" + packageName + "" "" +
                ""REQUEST_INSTALL_PACKAGES ""
                + (allowed ? ""allow"" : ""default"");
        CLog.d(""Output for command "" + command + "": "" + getDevice().executeShellCommand(command));
    }

    private void changePolicyOrFail(String command, String extras, int userId)
            throws DeviceNotAvailableException {
        changePolicyOrFail(command, extras, userId, DEVICE_ADMIN_PKG);
    }

    /**
     * Start SimpleActivity synchronously in a particular user.
     */
    protected void startSimpleActivityAsUser(int userId) throws Exception {
        installAppAsUser(TEST_APP_APK, /* grantPermissions */ true, /* dontKillApp */ true, userId);
        startActivityAsUser(userId, TEST_APP_PKG, TEST_APP_PKG + "".SimpleActivity"");
    }

    protected void setScreenCaptureDisabled(int userId, boolean disabled) throws Exception {
        String testMethodName = disabled
                ? ""testSetScreenCaptureDisabled_true""
                : ""testSetScreenCaptureDisabled_false"";
        executeDeviceTestMethod("".ScreenCaptureDisabledTest"", testMethodName);

        testMethodName = disabled
                ? ""testScreenCaptureImpossible""
                : ""testScreenCapturePossible"";

        startSimpleActivityAsUser(userId);
        executeDeviceTestMethod("".ScreenCaptureDisabledTest"", testMethodName);
        forceStopPackageForUser(TEST_APP_PKG, userId);
    }

    protected void setScreenCaptureDisabled_assist(int userId, boolean disabled) throws Exception {
        // Set the policy.
        String testMethodName = disabled
                ? ""testSetScreenCaptureDisabled_true""
                : ""testSetScreenCaptureDisabled_false"";
        executeDeviceTestMethod("".ScreenCaptureDisabledTest"", testMethodName);
        testMethodName = disabled
                ? ""testScreenCaptureImpossible_assist""
                : ""testScreenCapturePossible_assist"";

        // Check whether the VoiceInteractionService can retrieve the screenshot.
        installAppAsUser(DEVICE_ADMIN_APK, mPrimaryUserId);

        if (userId == mPrimaryUserId) {
            // If testing for user-0, also make sure the existing screen can't be captured.
            runDeviceTestsAsUser(
                    DEVICE_ADMIN_PKG,
                    "".AssistScreenCaptureDisabledTest"",
                    testMethodName,
                    mPrimaryUserId);
        }

        // Make sure the foreground activity is from the target user.
        startSimpleActivityAsUser(userId);

        runDeviceTestsAsUser(
                DEVICE_ADMIN_PKG,
                "".AssistScreenCaptureDisabledTest"",
                testMethodName,
                mPrimaryUserId);
    }

    /**
     * Allows packageName to manage notification policy configuration, which
     * includes toggling zen mode.
     */
    private void allowNotificationPolicyAccess(String packageName, int userId)
            throws DeviceNotAvailableException {
        List<String> enabledPackages = getEnabledNotificationPolicyPackages(userId);
        if (!enabledPackages.contains(packageName)) {
            enabledPackages.add(packageName);
            setEnabledNotificationPolicyPackages(enabledPackages, userId);
        }
    }

    /**
     * Disallows packageName to manage notification policy configuration, which
     * includes toggling zen mode.
     */
    private void disallowNotificationPolicyAccess(String packageName, int userId)
            throws DeviceNotAvailableException {
        List<String> enabledPackages = getEnabledNotificationPolicyPackages(userId);
        if (enabledPackages.contains(packageName)) {
            enabledPackages.remove(packageName);
            setEnabledNotificationPolicyPackages(enabledPackages, userId);
        }
    }

    private void setEnabledNotificationPolicyPackages(List<String> packages, int userId)
            throws DeviceNotAvailableException {
        getDevice().setSetting(userId, ""secure"", ENABLED_NOTIFICATION_POLICY_ACCESS_PACKAGES,
                String.join("":"", packages));
    }

    private List<String> getEnabledNotificationPolicyPackages(int userId)
            throws DeviceNotAvailableException {
        String settingValue = getDevice().getSetting(userId, ""secure"",
                ENABLED_NOTIFICATION_POLICY_ACCESS_PACKAGES);
        if (settingValue == null) {
            return new ArrayList<String>();
        }
        return new ArrayList<String>(Arrays.asList(settingValue.split("":|\n"")));
    }

    protected void setVoiceInteractionService(String componentName)
            throws DeviceNotAvailableException {
        getDevice().setSetting(
                mPrimaryUserId, ""secure"", ""voice_interaction_service"", componentName);
        getDevice().setSetting(mPrimaryUserId, ""secure"", ""assist_structure_enabled"", ""1"");
        getDevice().setSetting(mPrimaryUserId, ""secure"", ""assist_screenshot_enabled"", ""1"");
    }

    protected void clearVoiceInteractionService() throws DeviceNotAvailableException {
        getDevice().executeShellCommand(""settings delete secure voice_interaction_service"");
    }

    /**
     * Ensure that restrict background policy is off.
     * Returns the original status of restrict background policy.
     */
    private boolean ensureRestrictBackgroundPolicyOff() throws Exception {
        String restriction = getDevice().executeShellCommand(RESTRICT_BACKGROUND_GET_CMD);
        if (restriction.contains(""enabled"")) {
            getDevice().executeShellCommand(RESTRICT_BACKGROUND_OFF_CMD);
            return true;
        }
        return false;
    }

    private void restoreRestrictBackgroundPolicyTo(boolean restricted) throws Exception {
        getDevice().executeShellCommand(
                restricted ? RESTRICT_BACKGROUND_ON_CMD : RESTRICT_BACKGROUND_OFF_CMD);
    }
}"	""	""	"restricted restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.DeviceAndProfileOwnerTest"	"testApplicationRestrictions"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java"	""	"public void testApplicationRestrictions() throws Exception {
        installAppAsUser(DELEGATE_APP_APK, mUserId);
        installAppAsUser(APP_RESTRICTIONS_TARGET_APP_APK, mUserId);

        try {
            // Only the DPC can manage app restrictions by default.
            executeDeviceTestClass("".ApplicationRestrictionsTest"");
            executeAppRestrictionsManagingPackageTest(""testCannotAccessApis"");

            // Letting the DELEGATE_APP_PKG manage app restrictions too.
            changeApplicationRestrictionsManagingPackage(DELEGATE_APP_PKG);
            executeAppRestrictionsManagingPackageTest(""testCanAccessApis"");
            runDeviceTestsAsUser(DELEGATE_APP_PKG, "".GeneralDelegateTest"",
                    ""testSettingAdminComponentNameThrowsException"", mUserId);

            // The DPC should still be able to manage app restrictions normally.
            executeDeviceTestClass("".ApplicationRestrictionsTest"");

            // The app shouldn't be able to manage app restrictions for other users.
            int parentUserId = getPrimaryUser();
            if (parentUserId != mUserId) {
                installAppAsUser(DELEGATE_APP_APK, parentUserId);
                installAppAsUser(APP_RESTRICTIONS_TARGET_APP_APK, parentUserId);
                runDeviceTestsAsUser(DELEGATE_APP_PKG, "".AppRestrictionsDelegateTest"",
                        ""testCannotAccessApis"", parentUserId);
            }

            // Revoking the permission for DELEGAYE_APP_PKG to manage restrictions.
            changeApplicationRestrictionsManagingPackage(null);
            executeAppRestrictionsManagingPackageTest(""testCannotAccessApis"");

            // The DPC should still be able to manage app restrictions normally.
            executeDeviceTestClass("".ApplicationRestrictionsTest"");

            assertMetricsLogged(getDevice(), () -> {
                executeDeviceTestMethod("".ApplicationRestrictionsTest"",
                        ""testSetApplicationRestrictions"");
            }, new DevicePolicyEventWrapper.Builder(EventId.SET_APPLICATION_RESTRICTIONS_VALUE)
                    .setAdminPackageName(DEVICE_ADMIN_PKG)
                    .setStrings(APP_RESTRICTIONS_TARGET_APP_PKG)
                    .build());
        } finally {
            changeApplicationRestrictionsManagingPackage(null);
        }
    }

    /**
     * Returns a list of delegation tests that should run. Add delegations tests applicable to both
     * device owner and profile owners to this method directly. DO or PO specific tests should be
     * added to {@link #getAdditionalDelegationTests} in the subclass.
     */
    private Map<String, DevicePolicyEventWrapper[]> getDelegationTests() {
        final Map<String, DevicePolicyEventWrapper[]> result = new HashMap<>();
        result.put("".AppRestrictionsDelegateTest"", null);
        result.put("".CertInstallDelegateTest"", null);
        result.put("".BlockUninstallDelegateTest"", null);
        result.put("".PermissionGrantDelegateTest"", null);
        result.put("".PackageAccessDelegateTest"", null);
        result.put("".EnableSystemAppDelegateTest"", null);
        result.putAll(getAdditionalDelegationTests());
        return result;
    }

    Map<String, DevicePolicyEventWrapper[]> getAdditionalDelegationTests() {
        return Collections.<String, DevicePolicyEventWrapper[]>emptyMap();
    }

    /**
     * Returns a list of delegation scopes that are needed to run delegation tests. Add scopes
     * which are applicable to both device owner and profile owners to this method directly.
     * DO or PO specific scopes should be added to {@link #getAdditionalDelegationScopes}
     * in the subclass.
     */
    private List<String> getDelegationScopes() {
        final List<String> result = new ArrayList<>(Arrays.asList(
                DELEGATION_APP_RESTRICTIONS,
                DELEGATION_CERT_INSTALL,
                DELEGATION_BLOCK_UNINSTALL,
                DELEGATION_PERMISSION_GRANT,
                DELEGATION_PACKAGE_ACCESS,
                DELEGATION_ENABLE_SYSTEM_APP,
                // CERT_SELECTION scope is in the list so it still participates GeneralDelegateTest.
                // But its main functionality test is driven by testDelegationCertSelection() and
                // hence missing from getDelegationTests() on purpose.
                DELEGATION_CERT_SELECTION
                ));
        result.addAll(getAdditionalDelegationScopes());
        return result;
    }

    List<String> getAdditionalDelegationScopes() {
        return Collections.<String>emptyList();
    }

    /**
     * General instructions to add a new delegation test:
     * 1. Test primary delegation functionalitiy
     *    Implement the delegate's positive/negate functionaility tests in a new test class
     *    in CtsDelegateApp.apk. Main entry point are {@code testCanAccessApis} and
     *    {@code testCannotAccessApis}. Once implemented, add the delegation scope and the test
     *    class name to {@link #getDelegationScopes}, {@link #getDelegationTests} to make the test
     *    run on DO/PO/PO on primary user.  If the test should only run on a subset of these
     *    combinations, add them to the subclass's {@link #getAdditionalDelegationScopes} and
     *    {@link #getDelegationScopes} intead.
     *    <p>Alternatively, create a separate hostside method to drive the test, similar to
     *    {@link #testDelegationCertSelection}. This is preferred if the delegated functionalities
     *    already exist in another app.
     * 2. Test access control of DO-only delegation
     *    Add the delegation scope to
     *    {@code DelegationTest#testDeviceOwnerOnlyDelegationsOnlyPossibleToBeSetByDeviceOwner} to
     *    test that only DO can delegate this scope.
     * 3. Test behaviour of exclusive delegation
     *    Add the delegation scope to {@code DelegationTest#testExclusiveDelegations} to test that
     *    the scope can only be delegatd to one app at a time.
     */"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.DeviceAndProfileOwnerTest"	"testDelegation"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java"	""	"public void testDelegation() throws Exception {
        // Install relevant apps.
        installDelegateApp();
        installAppAsUser(TEST_APP_APK, mUserId);
        installAppAsUser(APP_RESTRICTIONS_TARGET_APP_APK, mUserId);
        if (isHeadlessSystemUserMode()) {
            installAppAsUser(TEST_APP_APK, mDeviceOwnerUserId);
            installAppAsUser(APP_RESTRICTIONS_TARGET_APP_APK, mDeviceOwnerUserId);
        }

        try {
            final Map<String, DevicePolicyEventWrapper[]> delegationTests = getDelegationTests();
            // APIs are not accessible by default.
            executeDelegationTests(delegationTests, false /* negative result */);

            // Granting the appropriate delegation scopes makes APIs accessible.
            final List<String> scopes = getDelegationScopes();
            setDelegatedScopes(DELEGATE_APP_PKG, scopes);
            runDeviceTestsAsUser(DELEGATE_APP_PKG, "".GeneralDelegateTest"", null, mUserId,
                    ImmutableMap.of(""scopes"", String.join("","", scopes)));
            executeDelegationTests(delegationTests, true /* positive result */);

            // APIs are not accessible after revoking delegations.
            setDelegatedScopes(DELEGATE_APP_PKG, null);
            executeDelegationTests(delegationTests, false /* negative result */);

            // Additional delegation tests.
            executeDeviceTestClass("".DelegationTest"");

        } finally {
            // Remove any remaining delegations.
            setDelegatedScopes(DELEGATE_APP_PKG, null);
        }
    }

    protected void installDelegateApp() throws Exception {
        installAppAsUser(DELEGATE_APP_APK, mUserId);
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.DeviceAndProfileOwnerTest"	"testAccountManagement_userRestrictionAddAccount"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java"	""	"public void testAccountManagement_userRestrictionAddAccount() throws Exception {
        installAppAsUser(ACCOUNT_MANAGEMENT_APK, mUserId);
        try {
            changeUserRestrictionOrFail(DISALLOW_MODIFY_ACCOUNTS, true, mUserId);
            executeAccountTest(""testAddAccount_blocked"");
        } finally {
            // Ensure we clear the user restriction
            changeUserRestrictionOrFail(DISALLOW_MODIFY_ACCOUNTS, false, mUserId);
        }
        executeAccountTest(""testAddAccount_allowed"");
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.DeviceAndProfileOwnerTest"	"testAccountManagement_userRestrictionRemoveAccount"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java"	""	"public void testAccountManagement_userRestrictionRemoveAccount() throws Exception {
        installAppAsUser(ACCOUNT_MANAGEMENT_APK, mUserId);
        try {
            changeUserRestrictionOrFail(DISALLOW_MODIFY_ACCOUNTS, true, mUserId);
            executeAccountTest(""testRemoveAccount_blocked"");
        } finally {
            // Ensure we clear the user restriction
            changeUserRestrictionOrFail(DISALLOW_MODIFY_ACCOUNTS, false, mUserId);
        }
        executeAccountTest(""testRemoveAccount_allowed"");
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.DeviceAndProfileOwnerTest"	"testSetKeyGrant"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java"	""	"public void testSetKeyGrant() throws Exception {
        // Install an app
        installAppAsUser(CERT_INSTALLER_APK, mUserId);

        try {
            // First, generate a key and grant the cert installer access to it.
            runDeviceTestsAsUser(DEVICE_ADMIN_PKG, "".DelegatedCertInstallerHelper"",
                    ""testManualGenerateKeyAndGrantAccess"", mUserId);
            // Test the key is usable.
            runDeviceTestsAsUser(""com.android.cts.certinstaller"",
                    "".PreSelectedKeyAccessTest"", ""testAccessingPreSelectedAliasExpectingSuccess"",
                    mUserId);
            // Remove the grant
            runDeviceTestsAsUser(DEVICE_ADMIN_PKG, "".DelegatedCertInstallerHelper"",
                    ""testManualRemoveKeyGrant"", mUserId);
            // Run another test to make sure the app no longer has access to the key.
            runDeviceTestsAsUser(""com.android.cts.certinstaller"",
                    "".PreSelectedKeyAccessTest"", ""testAccessingPreSelectedAliasWithoutGrant"", mUserId);
        } finally {
            runDeviceTestsAsUser(DEVICE_ADMIN_PKG, "".DelegatedCertInstallerHelper"",
                    ""testManualClearGeneratedKey"", mUserId);
        }
    }

    // Sets restrictions and launches non-admin app, that tries to set wallpaper.
    // Non-admin apps must not violate any user restriction."	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.DeviceAndProfileOwnerTest"	"testSetWallpaper_disallowed"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java"	""	"public void testSetWallpaper_disallowed() throws Exception {
        // UserManager.DISALLOW_SET_WALLPAPER
        final String DISALLOW_SET_WALLPAPER = ""no_set_wallpaper"";
        if (!hasService(""wallpaper"")) {
            CLog.d(""testSetWallpaper_disallowed(): device does not support wallpapers"");
            return;
        }

        installAppAsUser(CUSTOMIZATION_APP_APK, mUserId);
        try {
            changeUserRestrictionOrFail(DISALLOW_SET_WALLPAPER, true, mUserId);
            runDeviceTestsAsUser(CUSTOMIZATION_APP_PKG, "".CustomizationTest"",
                ""testSetWallpaper_disallowed"", mUserId);
        } finally {
            changeUserRestrictionOrFail(DISALLOW_SET_WALLPAPER, false, mUserId);
        }
    }

    // Runs test with admin privileges. The test methods set all the tested restrictions
    // inside. But these restrictions must have no effect on the device/profile owner behavior."	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.DeviceAndProfileOwnerTest"	"testDisallowSetWallpaper_allowed"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java"	""	"public void testDisallowSetWallpaper_allowed() throws Exception {
        if (!hasService(""wallpaper"")) {
            CLog.d(""testDisallowSetWallpaper_allowed(): device does not support wallpapers"");
            return;
        }
        executeDeviceTestMethod("".CustomizationRestrictionsTest"",
                ""testDisallowSetWallpaper_allowed"");
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.DeviceAndProfileOwnerTest"	"testDisallowAutofill_allowed"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java"	""	"public void testDisallowAutofill_allowed() throws Exception {
        boolean hasAutofill = hasDeviceFeature(""android.software.autofill"");
        if (!hasAutofill) {
          return;
        }
        installAppAsUser(AUTOFILL_APP_APK, mUserId);

        executeDeviceTestMethod("".AutofillRestrictionsTest"",
                ""testDisallowAutofill_allowed"");
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.DeviceAndProfileOwnerTest"	"testDisallowContentCapture_allowed"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java"	""	"public void testDisallowContentCapture_allowed() throws Exception {
        boolean hasContentCapture = hasService(""content_capture"");
        if (!hasContentCapture) {
            return;
        }
        installAppAsUser(CONTENT_CAPTURE_SERVICE_APK, mUserId);
        installAppAsUser(CONTENT_CAPTURE_APP_APK, mUserId);

        setDefaultContentCaptureServiceEnabled(false);
        try {
            executeDeviceTestMethod("".ContentCaptureRestrictionsTest"",
                    ""testDisallowContentCapture_allowed"");
        } finally {
            setDefaultContentCaptureServiceEnabled(true);
        }
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.DeviceAndProfileOwnerTest"	"testDisallowContentSuggestions_allowed"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java"	""	"public void testDisallowContentSuggestions_allowed() throws Exception {
        boolean hasContentSuggestions = hasService(""content_suggestions"");
        if (!hasContentSuggestions) {
            return;
        }
        installAppAsUser(CONTENT_SUGGESTIONS_APP_APK, mUserId);

        setDefaultContentSuggestionsServiceEnabled(false);
        try {
            executeDeviceTestMethod("".ContentSuggestionsRestrictionsTest"",
                    ""testDisallowContentSuggestions_allowed"");
        } finally {
            setDefaultContentSuggestionsServiceEnabled(true);
        }
    }

    private void setDefaultContentSuggestionsServiceEnabled(boolean enabled)
            throws DeviceNotAvailableException {
        CLog.d(""setDefaultContentSuggestionsServiceEnabled("" + mUserId + ""): "" + enabled);
        getDevice().executeShellCommand(
                ""cmd content_suggestions set default-service-enabled "" + mUserId + "" "" + enabled);
    }

    private void setDefaultContentCaptureServiceEnabled(boolean enabled)
            throws Exception {
        CLog.d(""setDefaultServiceEnabled("" + mUserId + ""): "" + enabled);
        getDevice().executeShellCommand(
                ""cmd content_capture set default-service-enabled "" + mUserId + "" "" + enabled);
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.DeviceAndProfileOwnerTest"	"testSetMeteredDataDisabledPackages"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java"	""	"public void testSetMeteredDataDisabledPackages() throws Exception {
        assumeHasWifiFeature();

        installAppAsUser(METERED_DATA_APP_APK, mUserId);

        try (LocationModeSetter locationModeSetter = new LocationModeSetter(getDevice())) {
            locationModeSetter.setLocationEnabled(true);
            executeDeviceTestClass("".MeteredDataRestrictionTest"");
        }
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.DeviceAndProfileOwnerTest"	"testPackageInstallUserRestrictions"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java"	""	"public void testPackageInstallUserRestrictions() throws Exception {
        boolean mIsWatch = hasDeviceFeature(""android.hardware.type.watch"");
        if (mIsWatch) {
            return;
        }
        // UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES
        final String DISALLOW_INSTALL_UNKNOWN_SOURCES = ""no_install_unknown_sources"";
        // UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES_GLOBALLY
        final String DISALLOW_INSTALL_UNKNOWN_SOURCES_GLOBALLY =
                ""no_install_unknown_sources_globally"";
        final String SECURE_SETTING_CATEGORY = ""secure"";
        final String GLOBAL_SETTING_CATEGORY = ""global"";
        final File apk = mBuildHelper.getTestFile(TEST_APP_APK);
        try {
            // Install the test and prepare the test apk.
            installAppAsUser(PACKAGE_INSTALLER_APK, mUserId);
            assertTrue(getDevice().pushFile(apk, TEST_APP_LOCATION + apk.getName()));
            setInstallPackageAppOps(PACKAGE_INSTALLER_PKG, true, mUserId);

            // Add restrictions and test if we can install the apk.
            getDevice().uninstallPackage(TEST_APP_PKG);
            changeUserRestrictionOrFail(DISALLOW_INSTALL_UNKNOWN_SOURCES, true, mUserId);
            runDeviceTestsAsUser(PACKAGE_INSTALLER_PKG, "".ManualPackageInstallTest"",
                    ""testManualInstallBlocked"", mUserId);

            // Clear restrictions and test if we can install the apk.
            changeUserRestrictionOrFail(DISALLOW_INSTALL_UNKNOWN_SOURCES, false, mUserId);

            // Add global restriction and test if we can install the apk.
            getDevice().uninstallPackage(TEST_APP_PKG);
            changeUserRestrictionOrFail(DISALLOW_INSTALL_UNKNOWN_SOURCES_GLOBALLY, true, mUserId);
            runDeviceTestsAsUser(PACKAGE_INSTALLER_PKG, "".ManualPackageInstallTest"",
                    ""testManualInstallBlocked"", mUserId);

            // Clear global restriction and test if we can install the apk.
            changeUserRestrictionOrFail(DISALLOW_INSTALL_UNKNOWN_SOURCES_GLOBALLY, false, mUserId);
            runDeviceTestsAsUser(PACKAGE_INSTALLER_PKG, "".ManualPackageInstallTest"",
                    ""testManualInstallSucceeded"", mUserId);
        } finally {
            setInstallPackageAppOps(PACKAGE_INSTALLER_PKG, false, mUserId);
            String command = ""rm "" + TEST_APP_LOCATION + apk.getName();
            getDevice().executeShellCommand(command);
            getDevice().uninstallPackage(TEST_APP_PKG);
            getDevice().uninstallPackage(PACKAGE_INSTALLER_PKG);
        }
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.DeviceAndProfileOwnerTest"	"testAudioRestriction"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java"	""	"public void testAudioRestriction() throws Exception {
        // This package may need to toggle zen mode for this test, so allow it to do so.
        allowNotificationPolicyAccess(DEVICE_ADMIN_PKG, mUserId);
        try {
            executeDeviceTestClass("".AudioRestrictionTest"");
        } finally {
            disallowNotificationPolicyAccess(DEVICE_ADMIN_PKG, mUserId);
        }
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.DeviceAndProfileOwnerTest"	"testCannotRemoveUserIfRestrictionSet"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java"	""	"public void testCannotRemoveUserIfRestrictionSet() throws Exception {
        assumeCanCreateAdditionalUsers(1);
        assumeTrue(""Outside of the primary user, setting DISALLOW_REMOVE_USER would not work"",
                mUserId == getPrimaryUser());

        final int userId = createUser();
        try {
            changeUserRestrictionOrFail(DISALLOW_REMOVE_USER, true, mUserId);
            assertFalse(getDevice().removeUser(userId));
        } finally {
            changeUserRestrictionOrFail(DISALLOW_REMOVE_USER, false, mUserId);
            assertTrue(getDevice().removeUser(userId));
        }
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.DeviceAndProfileOwnerTest"	"testSetUserRestrictionLogged"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java"	""	"public void testSetUserRestrictionLogged() throws Exception {
        assertMetricsLogged(getDevice(), () -> {
            executeDeviceTestMethod(
                    "".DevicePolicyLoggingTest"", ""testSetUserRestrictionLogged"");
        }, new DevicePolicyEventWrapper.Builder(EventId.ADD_USER_RESTRICTION_VALUE)
                    .setAdminPackageName(DEVICE_ADMIN_PKG)
                    .setStrings(DISALLOW_CONFIG_LOCATION, NOT_CALLED_FROM_PARENT)
                    .build(),
            new DevicePolicyEventWrapper.Builder(EventId.REMOVE_USER_RESTRICTION_VALUE)
                    .setAdminPackageName(DEVICE_ADMIN_PKG)
                    .setStrings(DISALLOW_CONFIG_LOCATION, NOT_CALLED_FROM_PARENT)
                    .build(),
            new DevicePolicyEventWrapper.Builder(EventId.ADD_USER_RESTRICTION_VALUE)
                    .setAdminPackageName(DEVICE_ADMIN_PKG)
                    .setStrings(DISALLOW_ADJUST_VOLUME, NOT_CALLED_FROM_PARENT)
                    .build(),
            new DevicePolicyEventWrapper.Builder(EventId.REMOVE_USER_RESTRICTION_VALUE)
                    .setAdminPackageName(DEVICE_ADMIN_PKG)
                    .setStrings(DISALLOW_ADJUST_VOLUME, NOT_CALLED_FROM_PARENT)
                    .build(),
            new DevicePolicyEventWrapper.Builder(EventId.ADD_USER_RESTRICTION_VALUE)
                    .setAdminPackageName(DEVICE_ADMIN_PKG)
                    .setStrings(DISALLOW_AUTOFILL, NOT_CALLED_FROM_PARENT)
                    .build(),
            new DevicePolicyEventWrapper.Builder(EventId.REMOVE_USER_RESTRICTION_VALUE)
                    .setAdminPackageName(DEVICE_ADMIN_PKG)
                    .setStrings(DISALLOW_AUTOFILL, NOT_CALLED_FROM_PARENT)
                    .build()
        );
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.os.cts.BuildTest"	"testMediaPerformanceClass"	""	"/home/gpoor/cts-12-source/cts/tests/tests/os/src/android/os/cts/BuildTest.java"	""	"public void testMediaPerformanceClass() {
        // media performance class value of 0 is valid
        if (Build.VERSION.MEDIA_PERFORMANCE_CLASS == 0) {
            return;
        }

        assertTrue(
                ""Media Performance Class "" + Build.VERSION.MEDIA_PERFORMANCE_CLASS
                        + "" is invalid; must be at least VERSION_CODES.R"",
                Build.VERSION.MEDIA_PERFORMANCE_CLASS >= Build.VERSION_CODES.R);
        assertTrue(
                ""Media Performance Class "" + Build.VERSION.MEDIA_PERFORMANCE_CLASS
                        + "" is invalid; must be at most VERSION.SDK_INT"",
                // we use RESOURCES_SDK_INT to account for active development versions
                Build.VERSION.MEDIA_PERFORMANCE_CLASS <= Build.VERSION.RESOURCES_SDK_INT);
    }

    static final String RO_DEBUGGABLE = ""ro.debuggable"";
    private static final String RO_SECURE = ""ro.secure"";

    /**
     * Assert that the device is a secure, not debuggable user build.
     *
     * Debuggable devices allow adb root and have the su command, allowing
     * escalations to root and unauthorized access to application data.
     *
     * Note: This test will fail on userdebug / eng devices, but should pass
     * on production (user) builds.
     */
    @RestrictedBuildTest
    @AppModeFull(reason = ""Instant apps cannot access APIs"")"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.cts.backup.MultiUserBackupStateTest"	"testBackupDeactivatedWhenUserIsRemoved"	"CtsBackupHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/backup/src/android/cts/backup/MultiUserBackupStateTest.java"	""	"public void testBackupDeactivatedWhenUserIsRemoved() throws Exception {
        int profileUserId = mProfileUserId.get();
        mBackupUtils.activateBackupForUser(true, profileUserId);

        assertTrue(mBackupUtils.isBackupActivatedForUser(profileUserId));

        removeUser(profileUserId);
        mProfileUserId = Optional.empty();

        CommonTestUtils.waitUntil(""wait for backup to be deactivated for removed user"",
                BACKUP_DEACTIVATION_TIMEOUT_SECONDS,
                () -> !mBackupUtils.isBackupActivatedForUser(profileUserId));
    }

    private void removeUser(int userId) throws Exception  {
        if (getDevice().listUsers().contains(userId) && userId != USER_SYSTEM) {
            // Don't log output, as tests sometimes set no debug user restriction, which
            // causes this to fail, we should still continue and remove the user.
            CLog.d(""Stopping and removing user "" + userId);
            getDevice().stopUser(userId, true, true);
            assertTrue(""Couldn't remove user"", getDevice().removeUser(userId));
        }
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceadmin.DeviceAdminTest"	"testPasswordHistoryLength"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAdmin/src/com.android.cts.deviceadmin/DeviceAdminTest.java"	""	"public void testPasswordHistoryLength() {
        if (!mHasSecureLockScreen) {
            return;
        }
        // Password history length restriction is only imposed if password quality is at least
        // numeric.
        dpm.setPasswordQuality(mAdminComponent,
                DevicePolicyManager.PASSWORD_QUALITY_ALPHABETIC);
        int originalValue = dpm.getPasswordHistoryLength(mAdminComponent);
        try {
            dpm.setPasswordHistoryLength(mAdminComponent, 3);
            assertEquals(3, dpm.getPasswordHistoryLength(mAdminComponent));
            // Although it would make sense we cannot test if password history restrictions
            // are enforced as DevicePolicyManagerService.resetPassword fails to do so at the
            // moment. See b/17707820
        } finally {
            dpm.setPasswordHistoryLength(mAdminComponent, originalValue);
        }
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.security.cts.BannedFilesTest"	"testNoSystemCmdSocket"	"CtsSecurityTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/security/src/android/security/cts/BannedFilesTest.java"	""	"public void testNoSystemCmdSocket() {
        assertFalse(""/dev/socket/fota"", new File(""/dev/socket/fota"").exists());
    }

    @RestrictedBuildTest"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.security.cts.BannedFilesTest"	"testNoSu"	"CtsSecurityTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/security/src/android/security/cts/BannedFilesTest.java"	""	"public void testNoSu() {
        assertFalse(""/sbin/su"",        new File(""/sbin/su"").exists());
        assertFalse(""/system/bin/su"",  new File(""/system/bin/su"").exists());
        assertFalse(""/system/sbin/su"", new File(""/system/sbin/su"").exists());
        assertFalse(""/system/xbin/su"", new File(""/system/xbin/su"").exists());
        assertFalse(""/vendor/bin/su"",  new File(""/vendor/bin/su"").exists());
    }

    @RestrictedBuildTest"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.widget.cts.CalendarViewTest"	"testMinMaxRangeRestrictionsHolo"	"CtsWidgetTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/CalendarViewTest.java"	""	"public void testMinMaxRangeRestrictionsHolo() {
        // Use a range of minus/plus one year as min/max dates.
        final Calendar minCalendar = new GregorianCalendar();
        minCalendar.set(Calendar.YEAR, minCalendar.get(Calendar.YEAR) - 1);
        final Calendar maxCalendar = new GregorianCalendar();
        maxCalendar.set(Calendar.YEAR, maxCalendar.get(Calendar.YEAR) + 1);
        final long minDate = minCalendar.getTime().getTime();
        final long maxDate = maxCalendar.getTime().getTime();

        mCalendarViewHolo.setMinDate(minDate);
        mCalendarViewHolo.setMaxDate(maxDate);

        try {
            mCalendarViewHolo.setDate(minDate - 1);
            fail(""Should throw IllegalArgumentException, date is before minDate"");
        } catch (IllegalArgumentException e) {
        }

        try {
            mCalendarViewHolo.setDate(maxDate + 1);
            fail(""Should throw IllegalArgumentException, date is after maxDate"");
        } catch (IllegalArgumentException e) {
        }
    }

    @UiThreadTest"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.cts.statsdatom.appstart.AppStartStatsTests"	"isNotNull"	"CtsStatsdAtomHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/appstart/AppStartStatsTests.java"	""	"public void test/*
 *.
 */

package android.cts.statsdatom.appstart;

import static com.google.common.truth.Truth.assertThat;

import android.cts.statsdatom.lib.AtomTestUtils;
import android.cts.statsdatom.lib.ConfigUtils;
import android.cts.statsdatom.lib.DeviceUtils;
import android.cts.statsdatom.lib.ReportUtils;

import com.android.os.AtomsProto;
import com.android.os.StatsLog;
import com.android.tradefed.build.IBuildInfo;
import com.android.tradefed.testtype.DeviceTestCase;
import com.android.tradefed.testtype.IBuildReceiver;

import java.util.List;

public class AppStartStatsTests extends DeviceTestCase implements IBuildReceiver {
    public static final String CMD_APP_HIBERNATION_SET_STATE_GLOBAL =
            ""cmd app_hibernation set-state --global "";
    public static final String STATSD_CTS_FOREGROUND_ACTIVITY = ""StatsdCtsForegroundActivity"";
    public static final int WAIT_TIME_MS = 3_500;
    public static final String COMMAND_ENABLE_APP_HIBERNATION =
            ""device_config put app_hibernation app_hibernation_enabled true"";
    private static final String CMD_GET_STAY_ON = ""settings get global stay_on_while_plugged_in"";
    private static final String CMD_PUT_STAY_ON_TEMPLATE =
            ""settings put global stay_on_while_plugged_in %d"";
    private static final String CMD_ENABLE_STAY_ON =
            ""settings put global stay_on_while_plugged_in 7"";
    private IBuildInfo mCtsBuild;
    private long mOriginalStayOnSetting;

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        assertThat(mCtsBuild).isNotNull();
        ConfigUtils.removeConfig(getDevice());
        ReportUtils.clearReports(getDevice());
        DeviceUtils.installStatsdTestApp(getDevice(), mCtsBuild);
        mOriginalStayOnSetting = Long.parseLong(
                getDevice().executeShellCommand(CMD_GET_STAY_ON).trim());
        getDevice().executeShellCommand(CMD_ENABLE_STAY_ON);
        DeviceUtils.turnScreenOn(getDevice());
        Thread.sleep(AtomTestUtils.WAIT_TIME_LONG);
    }

    @Override
    protected void tearDown() throws Exception {
        getDevice().executeShellCommand(
                String.format(CMD_PUT_STAY_ON_TEMPLATE, mOriginalStayOnSetting));
        ConfigUtils.removeConfig(getDevice());
        ReportUtils.clearReports(getDevice());
        DeviceUtils.uninstallStatsdTestApp(getDevice());
        super.tearDown();
    }

    @Override
    public void setBuild(IBuildInfo buildInfo) {
        mCtsBuild = buildInfo;
    }"	""	""	"hibernation"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.cts.statsdatom.appstart.AppStartStatsTests"	"testAppStartOccurred"	"CtsStatsdAtomHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/appstart/AppStartStatsTests.java"	""	"public void testAppStartOccurred() throws Exception {
        final int atomTag = AtomsProto.Atom.APP_START_OCCURRED_FIELD_NUMBER;
        ConfigUtils.uploadConfigForPushedAtomWithUid(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                atomTag,  /*uidInAttributionChain=*/false);
        getDevice().executeShellCommand(getGlobalHibernationCommand(
                DeviceUtils.STATSD_ATOM_TEST_PKG, false));

        DeviceUtils.runActivity(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                STATSD_CTS_FOREGROUND_ACTIVITY, ""action"", ""action.sleep_top"", WAIT_TIME_MS);

        // Sorted list of events in order in which they occurred.
        List<StatsLog.EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());

        assertThat(data).hasSize(1);
        AtomsProto.AppStartOccurred atom = data.get(0).getAtom().getAppStartOccurred();
        assertThat(atom.getPkgName()).isEqualTo(DeviceUtils.STATSD_ATOM_TEST_PKG);
        assertThat(atom.getActivityName())
                .isEqualTo(""com.android.server.cts.device.statsdatom.StatsdCtsForegroundActivity"");
        assertThat(atom.getIsInstantApp()).isFalse();
        assertThat(atom.getActivityStartTimestampMillis()).isGreaterThan(0L);
        assertThat(atom.getTransitionDelayMillis()).isGreaterThan(0);
        assertThat(atom.getIsHibernating()).isFalse();
    }"	""	""	"hibernation"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	Test Missing	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.cts.statsdatom.appstart.AppStartStatsTests"	"testHibernatingAppStartOccurred"	"CtsStatsdAtomHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/appstart/AppStartStatsTests.java"	""	"public void testHibernatingAppStartOccurred() throws Exception {
        final int atomTag = AtomsProto.Atom.APP_START_OCCURRED_FIELD_NUMBER;
        ConfigUtils.uploadConfigForPushedAtomWithUid(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                atomTag,  /*uidInAttributionChain=*/false);
        getDevice().executeShellCommand(COMMAND_ENABLE_APP_HIBERNATION);
        getDevice().executeShellCommand(getGlobalHibernationCommand(
                DeviceUtils.STATSD_ATOM_TEST_PKG, true));

        DeviceUtils.runActivity(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                STATSD_CTS_FOREGROUND_ACTIVITY, ""action"", ""action.sleep_top"", WAIT_TIME_MS);

        // Sorted list of events in order in which they occurred.
        List<StatsLog.EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());
        assertThat(data).hasSize(1);
        AtomsProto.AppStartOccurred atom = data.get(0).getAtom().getAppStartOccurred();
        assertThat(atom.getIsHibernating()).isTrue();
    }"	""	""	"hibernation"	""	""	""	""	"The tests seem to be missingA code search shows no CTS files with ""hibernation AND restrict"""	tbd	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.cts.statsdatom.appstart.AppStartStatsTests"	"testHibernatingAppStartOccurredTwice_isHibernatingShouldBeFalseSecondTime"	"CtsStatsdAtomHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/appstart/AppStartStatsTests.java"	""	"public void testHibernatingAppStartOccurredTwice_isHibernatingShouldBeFalseSecondTime()
            throws Exception {
        final int atomTag = AtomsProto.Atom.APP_START_OCCURRED_FIELD_NUMBER;
        ConfigUtils.uploadConfigForPushedAtomWithUid(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                atomTag,  /*uidInAttributionChain=*/false);
        getDevice().executeShellCommand(COMMAND_ENABLE_APP_HIBERNATION);
        getDevice().executeShellCommand(getGlobalHibernationCommand(
                DeviceUtils.STATSD_ATOM_TEST_PKG, true));

        DeviceUtils.runActivity(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                STATSD_CTS_FOREGROUND_ACTIVITY, ""action"", ""action.sleep_top"", WAIT_TIME_MS);
        DeviceUtils.runActivity(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                STATSD_CTS_FOREGROUND_ACTIVITY, ""action"", ""action.sleep_top"", WAIT_TIME_MS);

        // Sorted list of events in order in which they occurred.
        List<StatsLog.EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());

        assertThat(data).hasSize(2);
        AtomsProto.AppStartOccurred atom = data.get(1).getAtom().getAppStartOccurred();
        assertThat(atom.getIsHibernating()).isFalse();
    }

    private static String getGlobalHibernationCommand(String packageName, boolean isHibernating) {
        return CMD_APP_HIBERNATION_SET_STATE_GLOBAL + packageName + "" "" + isHibernating;
    }
}"	""	""	"hibernation"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.keystore.cts.CipherTest"	"testMaxSizedPlaintextSupported"	"CtsKeystoreTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/keystore/src/android/keystore/cts/CipherTest.java"	""	"public void testMaxSizedPlaintextSupported() throws Exception {
        Provider keystoreProvider = Security.getProvider(EXPECTED_PROVIDER_NAME);
        assertNotNull(keystoreProvider);
        for (String algorithm : EXPECTED_ALGORITHMS) {
            if (isSymmetric(algorithm)) {
                // No input length restrictions (except multiple of block size for some
                // transformations).
                continue;
            }
            for (ImportedKey key : importKatKeys(
                    algorithm,
                    KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT,
                    false)) {
                int plaintextSizeBytes = -1;
                Provider otherProvider = null;
                try {
                    Key encryptionKey = key.getKeystoreBackedEncryptionKey();
                    int maxSupportedPlaintextSizeBytes =
                            TestUtils.getMaxSupportedPlaintextInputSizeBytes(
                                    algorithm, encryptionKey);
                    if (maxSupportedPlaintextSizeBytes < 0) {
                        // Key too short to encrypt anything using this transformation.
                        continue;
                    } else if (maxSupportedPlaintextSizeBytes == Integer.MAX_VALUE) {
                        // No input length restrictions.
                        continue;
                    }
                    byte[] plaintext = new byte[maxSupportedPlaintextSizeBytes];
                    Arrays.fill(plaintext, (byte) 0xff);
                    plaintextSizeBytes = plaintext.length;

                    // Encrypt plaintext using Android Keystore Cipher
                    Cipher cipher = Cipher.getInstance(algorithm, keystoreProvider);
                    cipher.init(Cipher.ENCRYPT_MODE, encryptionKey);
                    AlgorithmParameters params = cipher.getParameters();
                    byte[] ciphertext = cipher.doFinal(plaintext);
                    byte[] expectedPlaintext = plaintext;
                    if (""RSA/ECB/NoPadding"".equalsIgnoreCase(algorithm)) {
                        // RSA decryption without padding left-pads resulting plaintext with NUL
                        // bytes to the length of RSA modulus.
                        int modulusLengthBytes = (TestUtils.getKeySizeBits(encryptionKey) + 7) / 8;
                        expectedPlaintext = TestUtils.leftPadWithZeroBytes(
                                expectedPlaintext, modulusLengthBytes);
                    }

                    // Check that ciphertext decrypts using Android Keystore Cipher
                    cipher = Cipher.getInstance(algorithm, keystoreProvider);
                    Key decryptionKey = key.getKeystoreBackedDecryptionKey();
                    cipher.init(Cipher.DECRYPT_MODE, decryptionKey, params);
                    byte[] actualPlaintext = cipher.doFinal(ciphertext);
                    assertArrayEquals(expectedPlaintext, actualPlaintext);

                    // Check that ciphertext decrypts using the highest-priority provider.
                    cipher = Cipher.getInstance(algorithm);
                    decryptionKey = key.getOriginalDecryptionKey();
                    try {
                        cipher.init(Cipher.DECRYPT_MODE, decryptionKey, params);
                    } catch (InvalidKeyException e) {
                        // No other providers offer decryption using this transformation and key.
                        continue;
                    }
                    otherProvider = cipher.getProvider();
                    if (otherProvider == keystoreProvider) {
                        // This has already been tested above.
                        continue;
                    }
                    actualPlaintext = cipher.doFinal(ciphertext);
                    assertArrayEquals(expectedPlaintext, actualPlaintext);
                } catch (Throwable e) {
                    throw new RuntimeException(
                            ""Failed for "" + algorithm + "" with key "" + key.getAlias()
                                    + "" and "" + plaintextSizeBytes + "" long plaintext""
                                    + "", other provider: "" + otherProvider,
                            e);
                }
            }
        }
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.keystore.cts.CipherTest"	"testLargerThanMaxSizedPlaintextRejected"	"CtsKeystoreTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/keystore/src/android/keystore/cts/CipherTest.java"	""	"public void testLargerThanMaxSizedPlaintextRejected() throws Exception {
        Provider keystoreProvider = Security.getProvider(EXPECTED_PROVIDER_NAME);
        assertNotNull(keystoreProvider);
        for (String algorithm : EXPECTED_ALGORITHMS) {
            if (isSymmetric(algorithm)) {
                // No input length restrictions (except multiple of block size for some
                // transformations).
                continue;
            }
            for (ImportedKey key : importKatKeys(
                    algorithm,
                    KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT,
                    false)) {
                int plaintextSizeBytes = -1;
                Provider otherProvider = null;
                try {
                    Key encryptionKey = key.getKeystoreBackedEncryptionKey();
                    int maxSupportedPlaintextSizeBytes =
                            TestUtils.getMaxSupportedPlaintextInputSizeBytes(
                                    algorithm, encryptionKey);
                    if (maxSupportedPlaintextSizeBytes < 0) {
                        // Key too short to encrypt anything using this transformation.
                        continue;
                    } else if (maxSupportedPlaintextSizeBytes == Integer.MAX_VALUE) {
                        // No input length restrictions.
                        continue;
                    }
                    // Create plaintext which is one byte longer than maximum supported one.
                    byte[] plaintext = new byte[maxSupportedPlaintextSizeBytes + 1];
                    Arrays.fill(plaintext, (byte) 0xff);
                    plaintextSizeBytes = plaintext.length;

                    // Encrypting this plaintext using Android Keystore Cipher should fail.
                    Cipher cipher = Cipher.getInstance(algorithm, keystoreProvider);
                    cipher.init(Cipher.ENCRYPT_MODE, encryptionKey);
                    try {
                        byte[] ciphertext = cipher.doFinal(plaintext);
                        fail(""Unexpectedly produced ciphertext ("" + ciphertext.length
                                + "" bytes): "" + HexEncoding.encode(ciphertext) + "" for ""
                                + plaintext.length + "" byte long plaintext"");
                    } catch (IllegalBlockSizeException | BadPaddingException |
                            ArrayIndexOutOfBoundsException expected) {}

                    // Encrypting this plaintext using the highest-priority implementation should
                    // fail.
                    cipher = Cipher.getInstance(algorithm);
                    encryptionKey = key.getOriginalEncryptionKey();
                    try {
                        cipher.init(Cipher.ENCRYPT_MODE, encryptionKey);
                    } catch (InvalidKeyException e) {
                        // No other providers support this transformation with this key.
                        continue;
                    }
                    otherProvider = cipher.getProvider();
                    if (otherProvider == keystoreProvider) {
                        // This has already been tested above.
                        continue;
                    }
                    try {
                        byte[] ciphertext = cipher.doFinal(plaintext);
                        fail(otherProvider.getName() + "" unexpectedly produced ciphertext (""
                                + ciphertext.length + "" bytes): ""
                                + HexEncoding.encode(ciphertext) + "" for ""
                                + plaintext.length + "" byte long plaintext"");
                        // TODO: Remove the catching of RuntimeException and BadPaddingException
                        // workaround once the corresponding Bug 22567463 in Conscrypt is fixed.
                    } catch (IllegalBlockSizeException | BadPaddingException | RuntimeException
                            exception) {}
                } catch (Throwable e) {
                    throw new RuntimeException(
                            ""Failed for "" + algorithm + "" with key "" + key.getAlias()
                            + "" and "" + plaintextSizeBytes + "" byte long plaintext""
                            + "", other provider: "" + otherProvider,
                            e);
                }
            }
        }
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.launcherapps.simpleapp.SimpleActivityStartFgService"	"finish"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/SimpleApp/src/com/android/cts/launcherapps/simpleapp/SimpleActivityStartFgService.java"	""	"public void test/*
 *.
 */

package com.android.cts.launcherapps.simpleapp;

import android.app.Activity;
import android.content.ComponentName;
import android.content.Intent;
import android.os.Bundle;
import android.util.Log;

/**
 * Test being able to start a service (with no background check restrictions) as soon as
 * an activity is created.
 */
public class SimpleActivityStartFgService extends Activity {
    private static final String TAG = ""SimpleActivityStartFgService"";

    static final String ACTION_START_THEN_FG =
            ""com.android.cts.launcherapps.simpleapp.SimpleActivityStartFgService.START_THEN_FG"";
    public static String ACTION_FINISH_EVERYTHING =
            ""com.android.cts.launcherapps.simpleapp.SimpleActivityStartFgService.FINISH_ALL"";
    public static String ACTION_SIMPLE_ACTIVITY_START_FG_SERVICE_RESULT =
            ""com.android.cts.launcherapps.simpleapp.SimpleActivityStartFgService.NOW_FOREGROUND"";

    @Override
    public void onCreate(Bundle icicle) {
        super.onCreate(icicle);
        final String action = getIntent().getAction();
        Log.i(TAG, ""onCreate() with intent "" + action);
        if (ACTION_START_THEN_FG.equals(action)) {
            if (!attemptStartService()) {
                // If we couldn't run the test properly, finish immediately
                Log.i(TAG, ""   Couldn't start service, finishing immediately!"");
                finish();
            }
        } else if (ACTION_FINISH_EVERYTHING.equals(action)) {
            Log.i(TAG, ""   *** told to stop service & finish"");
            Intent serviceIntent = getIntent().getParcelableExtra(""service"");
            stopService(serviceIntent);
            finish();
        }
    }

    @Override
    public void onStart() {
        super.onStart();
    }

    @Override
    protected void onNewIntent(Intent intent) {
        final String action = intent.getAction();
        if (ACTION_FINISH_EVERYTHING.equals(action)) {
            Intent serviceIntent = getIntent().getParcelableExtra(""service"");
            stopService(serviceIntent);
            finish();
        }
    }

    private boolean attemptStartService() {
        Intent reply = new Intent(ACTION_SIMPLE_ACTIVITY_START_FG_SERVICE_RESULT);
        reply.setFlags(Intent.FLAG_RECEIVER_FOREGROUND);
        Intent serviceIntent = getIntent().getParcelableExtra(""service"");

        try {
            final ComponentName svcName = startService(serviceIntent);
            if (svcName != null) {
                // Successful start -> the service will send the broadcast once it's
                // transitioned to the foreground
                return true;
            }
        } catch (Exception e) {
            // fall through
        }

        // Failure of some sort: the service isn't going to run as expected,
        // so report the failure here before exiting.
        reply.putExtra(""result"", Activity.RESULT_CANCELED);
        sendBroadcast(reply);
        return false;
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.managedprovisioning.ManagedUserPositiveTestActivity"	"isAffiliatedUser"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/managedprovisioning/ManagedUserPositiveTestActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.managedprovisioning;

import static com.android.cts.verifier.managedprovisioning.Utils.createInteractiveTestItem;

import android.app.Activity;
import android.app.admin.DevicePolicyManager;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.database.DataSetObserver;
import android.os.Bundle;
import android.os.UserManager;
import android.provider.Settings;

import com.android.cts.verifier.ArrayTestListAdapter;
import com.android.cts.verifier.IntentDrivenTestActivity.ButtonInfo;
import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;
import com.android.cts.verifier.TestListAdapter.TestListItem;
import com.android.cts.verifier.TestResult;

/**
 * Activity that lists all positive managed user tests.
 */
public class ManagedUserPositiveTestActivity extends PassFailButtons.TestListActivity {
    private static final String TAG = ""ManagedUserPositiveTestActivity"";

    private static final String ACTION_CHECK_AFFILIATED_PROFILE_OWNER =
            ""com.android.cts.verifier.managedprovisioning.action.CHECK_AFFILIATED_PROFILE_OWNER"";
    static final String EXTRA_TEST_ID = ""extra-test-id"";

    private static final String CHECK_AFFILIATED_PROFILE_OWNER_TEST_ID =
            ""CHECK_AFFILIATED_PROFILE_OWNER"";
    private static final String DEVICE_ADMIN_SETTINGS_ID = ""DEVICE_ADMIN_SETTINGS"";
    private static final String DISABLE_STATUS_BAR_TEST_ID = ""DISABLE_STATUS_BAR"";
    private static final String DISABLE_KEYGUARD_TEST_ID = ""DISABLE_KEYGUARD"";
    private static final String POLICY_TRANSPARENCY_TEST_ID = ""POLICY_TRANSPARENCY"";
    private static final String DISALLOW_REMOVE_USER_TEST_ID = ""DISALLOW_REMOVE_USER"";

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        if (ACTION_CHECK_AFFILIATED_PROFILE_OWNER.equals(getIntent().getAction())) {
            DevicePolicyManager dpm = getSystemService(DevicePolicyManager.class);
            if (dpm.isProfileOwnerApp(getPackageName()) && dpm.isAffiliatedUser()) {
                TestResult.setPassedResult(this, getIntent().getStringExtra(EXTRA_TEST_ID),
                        null, null);
            } else {
                TestResult.setFailedResult(this, getIntent().getStringExtra(EXTRA_TEST_ID),
                        getString(R.string.managed_user_incorrect_managed_user), null);
            }
            finish();
            return;
        }

        setContentView(R.layout.positive_managed_user);
        setInfoResources(R.string.managed_user_positive_tests,
                R.string.managed_user_positive_tests_info, 0);
        setPassFailButtonClickListeners();

        final ArrayTestListAdapter adapter = new ArrayTestListAdapter(this);
        adapter.add(TestListItem.newCategory(this, R.string.managed_user_positive_category));

        addTestsToAdapter(adapter);

        adapter.registerDataSetObserver(new DataSetObserver() {
            @Override
            public void onChanged() {
                updatePassButton();
            }
        });

        setTestListAdapter(adapter);
    }

    @Override
    public void finish() {
        // If this activity was started for checking profile owner status, then no need to do any
        // tear down.
        if (!ACTION_CHECK_AFFILIATED_PROFILE_OWNER.equals(getIntent().getAction())) {
            // Pass and fail buttons are known to call finish() when clicked,
            // and this is when we want to remove the managed owner.
            DevicePolicyManager dpm = getSystemService(DevicePolicyManager.class);
            dpm.logoutUser(DeviceAdminTestReceiver.getReceiverComponentName());
        }
        super.finish();
    }

    private void addTestsToAdapter(final ArrayTestListAdapter adapter) {
        adapter.add(createTestItem(this, CHECK_AFFILIATED_PROFILE_OWNER_TEST_ID,
                R.string.managed_user_check_managed_user_test,
                new Intent(ACTION_CHECK_AFFILIATED_PROFILE_OWNER)
                        .putExtra(EXTRA_TEST_ID, getIntent().getStringExtra(EXTRA_TEST_ID))));

        // device admin settings
        adapter.add(createInteractiveTestItem(this, DEVICE_ADMIN_SETTINGS_ID,
                R.string.device_owner_device_admin_visible,
                R.string.device_owner_device_admin_visible_info,
                new ButtonInfo(
                        R.string.device_owner_settings_go,
                        new Intent(Settings.ACTION_SECURITY_SETTINGS))));

        // DISABLE_STATUS_BAR_TEST
        if (isStatusBarEnabled()) {
            adapter.add(createInteractiveTestItem(this, DISABLE_STATUS_BAR_TEST_ID,
                    R.string.device_owner_disable_statusbar_test,
                    R.string.device_owner_disable_statusbar_test_info,
                    new ButtonInfo[]{
                            new ButtonInfo(
                                    R.string.device_owner_disable_statusbar_button,
                                    createManagedUserIntentWithBooleanParameter(
                                            CommandReceiverActivity.COMMAND_SET_STATUSBAR_DISABLED,
                                            true)),
                            new ButtonInfo(
                                    R.string.device_owner_reenable_statusbar_button,
                                    createManagedUserIntentWithBooleanParameter(
                                            CommandReceiverActivity.COMMAND_SET_STATUSBAR_DISABLED,
                                            false))}));
        }

        // setKeyguardDisabled
        adapter.add(createInteractiveTestItem(this, DISABLE_KEYGUARD_TEST_ID,
                R.string.device_owner_disable_keyguard_test,
                R.string.device_owner_disable_keyguard_test_info,
                new ButtonInfo[]{
                        new ButtonInfo(
                                R.string.device_owner_disable_keyguard_button,
                                createManagedUserIntentWithBooleanParameter(
                                        CommandReceiverActivity.COMMAND_SET_KEYGUARD_DISABLED,
                                        true)),
                        new ButtonInfo(
                                R.string.device_owner_reenable_keyguard_button,
                                createManagedUserIntentWithBooleanParameter(
                                        CommandReceiverActivity.COMMAND_SET_KEYGUARD_DISABLED,
                                        false))}));

        // DISALLOW_REMOVE_USER
        adapter.add(createInteractiveTestItem(this, DISALLOW_REMOVE_USER_TEST_ID,
                R.string.disallow_remove_user,
                R.string.managed_user_disallow_remove_user_info,
                new ButtonInfo[]{
                        new ButtonInfo(
                                R.string.device_owner_user_restriction_set,
                                CommandReceiverActivity.createSetCurrentUserRestrictionIntent(
                                        UserManager.DISALLOW_REMOVE_USER, true)),
                        new ButtonInfo(
                                R.string.device_owner_settings_go,
                                new Intent(Settings.ACTION_USER_SETTINGS))}));

        // Policy Transparency
        final Intent policyTransparencyTestIntent = new Intent(this,
                PolicyTransparencyTestListActivity.class);
        policyTransparencyTestIntent.putExtra(
                PolicyTransparencyTestListActivity.EXTRA_MODE,
                PolicyTransparencyTestListActivity.MODE_MANAGED_USER);
        // So that PolicyTransparencyTestListActivity knows which test to update with the result:
        policyTransparencyTestIntent.putExtra(
                PolicyTransparencyTestActivity.EXTRA_TEST_ID, POLICY_TRANSPARENCY_TEST_ID);
        adapter.add(createTestItem(this, POLICY_TRANSPARENCY_TEST_ID,
                R.string.device_profile_owner_policy_transparency_test,
                policyTransparencyTestIntent));

    }


    static TestListItem createTestItem(Activity activity, String id, int titleRes,
            Intent intent) {
        intent.putExtra(EXTRA_TEST_ID, id);
        return TestListItem.newTest(activity, titleRes, id, intent, null);
    }

    private Intent createManagedUserIntentWithBooleanParameter(String command, boolean value) {
        return new Intent(this, CommandReceiverActivity.class)
                .putExtra(CommandReceiverActivity.EXTRA_COMMAND, command)
                .putExtra(CommandReceiverActivity.EXTRA_ENFORCED, value);
    }

    private boolean isStatusBarEnabled() {
        // Watches don't support the status bar so this is an ok proxy, but this is not the most
        // general test for that. TODO: add a test API to do a real check for status bar support.
        return !getPackageManager().hasSystemFeature(PackageManager.FEATURE_WATCH);
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.appsecurity.cts.AppSecurityTests"	"testUninstallRemovesData_instant"	"CtsAppSecurityHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/AppSecurityTests.java"	""	"@AppModeInstant(reason = ""'instant' portion of the hostside test"")
    public void testUninstallRemovesData_instant() throws Exception {
        testUninstallRemovesData(true);
    }
    private void testUninstallRemovesData(boolean instant) throws Exception {
        Log.i(LOG_TAG, ""Uninstalling app, verifying data is removed."");
        try {
            getDevice().uninstallPackage(APP_WITH_DATA_PKG);

            new InstallMultiple(instant).addFile(APP_WITH_DATA_APK).run();
            runDeviceTests(
                    APP_WITH_DATA_PKG, APP_WITH_DATA_CLASS, APP_WITH_DATA_CREATE_METHOD);

            getDevice().uninstallPackage(APP_WITH_DATA_PKG);

            new InstallMultiple(instant).addFile(APP_WITH_DATA_APK).run();
            runDeviceTests(
                    APP_WITH_DATA_PKG, APP_WITH_DATA_CLASS, APP_WITH_DATA_CHECK_NOEXIST_METHOD);
        } finally {
            getDevice().uninstallPackage(APP_WITH_DATA_PKG);
        }
    }

    /**
     * Test that an app cannot instrument another app that is signed with different certificate.
     */
    // RestrictedBuildTest ensures the build only runs on user builds where the signature
    // verification will be performed, but JUnit4TestNotRun reports the test will not be run because
    // the method does not have the"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.appsecurity.cts.AppSecurityTests"	"testInstrumentationDiffCert_full"	"CtsAppSecurityHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/AppSecurityTests.java"	""	"annotation.
    @SuppressWarnings(""JUnit4TestNotRun"")
    @RestrictedBuildTest
    @AppModeFull(reason = ""'full' portion of the hostside test"")
    public void testInstrumentationDiffCert_full() throws Exception {
        testInstrumentationDiffCert(false, false);
    }"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.app.cts.ActivityManagerTest"	"finish"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerTest.java"	""	"public void test/*
 *.
 */
package android.app.cts;

import static android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;
import static android.content.ComponentCallbacks2.TRIM_MEMORY_COMPLETE;
import static android.content.ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL;
import static android.content.ComponentCallbacks2.TRIM_MEMORY_RUNNING_LOW;
import static android.content.ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE;
import static android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;

import static org.junit.Assert.assertArrayEquals;

import android.app.Activity;
import android.app.ActivityManager;
import android.app.ActivityManager.RecentTaskInfo;
import android.app.ActivityManager.RunningAppProcessInfo;
import android.app.ActivityManager.RunningServiceInfo;
import android.app.ActivityManager.RunningTaskInfo;
import android.app.ActivityOptions;
import android.app.HomeVisibilityListener;
import android.app.Instrumentation;
import android.app.Instrumentation.ActivityMonitor;
import android.app.Instrumentation.ActivityResult;
import android.app.PendingIntent;
import android.app.cts.android.app.cts.tools.WatchUidRunner;
import android.app.stubs.ActivityManagerRecentOneActivity;
import android.app.stubs.ActivityManagerRecentTwoActivity;
import android.app.stubs.CommandReceiver;
import android.app.stubs.LocalForegroundService;
import android.app.stubs.MockApplicationActivity;
import android.app.stubs.MockService;
import android.app.stubs.ScreenOnActivity;
import android.app.stubs.TrimMemService;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.ServiceConnection;
import android.content.pm.ApplicationInfo;
import android.content.pm.ConfigurationInfo;
import android.content.pm.PackageManager;
import android.content.res.Resources;
import android.os.Binder;
import android.os.Bundle;
import android.os.Handler;
import android.os.HandlerThread;
import android.os.IBinder;
import android.os.Message;
import android.os.Messenger;
import android.os.Parcel;
import android.os.RemoteException;
import android.os.SystemClock;
import android.platform.test.annotations.RestrictedBuildTest;
import android.provider.DeviceConfig;
import android.provider.Settings;
import android.server.wm.settings.SettingsSession;
import android.support.test.uiautomator.UiDevice;
import android.test.InstrumentationTestCase;
import android.util.ArrayMap;
import android.util.ArraySet;
import android.util.Log;
import android.util.Pair;

import androidx.test.filters.LargeTest;

import com.android.compatibility.common.util.AmMonitor;
import com.android.compatibility.common.util.ShellIdentityUtils;
import com.android.compatibility.common.util.SystemUtil;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;
import java.util.function.Predicate;
import java.util.function.Supplier;

public class ActivityManagerTest extends InstrumentationTestCase {
    private static final String TAG = ActivityManagerTest.class.getSimpleName();
    private static final String STUB_PACKAGE_NAME = ""android.app.stubs"";
    private static final int WAITFOR_MSEC = 5000;
    private static final String SERVICE_NAME = ""android.app.stubs.MockService"";
    private static final int WAIT_TIME = 2000;
    // A secondary test activity from another APK.
    static final String SIMPLE_PACKAGE_NAME = ""com.android.cts.launcherapps.simpleapp"";
    static final String SIMPLE_ACTIVITY = "".SimpleActivity"";
    static final String SIMPLE_ACTIVITY_IMMEDIATE_EXIT = "".SimpleActivityImmediateExit"";
    static final String SIMPLE_ACTIVITY_CHAIN_EXIT = "".SimpleActivityChainExit"";
    static final String SIMPLE_RECEIVER = "".SimpleReceiver"";
    static final String SIMPLE_REMOTE_RECEIVER = "".SimpleRemoteReceiver"";
    // The action sent back by the SIMPLE_APP after a restart.
    private static final String ACTIVITY_LAUNCHED_ACTION =
            ""com.android.cts.launchertests.LauncherAppsTests.LAUNCHED_ACTION"";
    // The action sent back by the SIMPLE_APP_IMMEDIATE_EXIT when it terminates.
    private static final String ACTIVITY_EXIT_ACTION =
            ""com.android.cts.launchertests.LauncherAppsTests.EXIT_ACTION"";
    // The action sent back by the SIMPLE_APP_CHAIN_EXIT when the task chain ends. 
    private static final String ACTIVITY_CHAIN_EXIT_ACTION =
            ""com.android.cts.launchertests.LauncherAppsTests.CHAIN_EXIT_ACTION"";
    // The action sent to identify the time track info.
    private static final String ACTIVITY_TIME_TRACK_INFO = ""com.android.cts.TIME_TRACK_INFO"";

    private static final String PACKAGE_NAME_APP1 = ""com.android.app1"";
    private static final String PACKAGE_NAME_APP2 = ""com.android.app2"";
    private static final String PACKAGE_NAME_APP3 = ""com.android.app3"";

    private static final String CANT_SAVE_STATE_1_PACKAGE_NAME = ""com.android.test.cantsavestate1"";
    private static final String ACTION_FINISH = ""com.android.test.action.FINISH"";

    private static final String MCC_TO_UPDATE = ""987"";
    private static final String MNC_TO_UPDATE = ""654"";
    private static final String SHELL_COMMAND_GET_CONFIG = ""am get-config"";
    private static final String SHELL_COMMAND_RESULT_CONFIG_NAME_MCC = ""mcc"";
    private static final String SHELL_COMMAND_RESULT_CONFIG_NAME_MNC = ""mnc"";

    // Return states of the ActivityReceiverFilter.
    public static final int RESULT_PASS = 1;
    public static final int RESULT_FAIL = 2;
    public static final int RESULT_TIMEOUT = 3;

    private Context mTargetContext;
    private ActivityManager mActivityManager;
    private PackageManager mPackageManager;
    private Intent mIntent;
    private List<Activity> mStartedActivityList;
    private int mErrorProcessID;
    private Instrumentation mInstrumentation;

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        mInstrumentation = getInstrumentation();
        mTargetContext = mInstrumentation.getTargetContext();
        mActivityManager = (ActivityManager) mInstrumentation.getContext()
                .getSystemService(Context.ACTIVITY_SERVICE);
        mPackageManager = mInstrumentation.getContext().getPackageManager();
        mStartedActivityList = new ArrayList<Activity>();
        mErrorProcessID = -1;
        startSubActivity(ScreenOnActivity.class);
    }

    @Override
    protected void tearDown() throws Exception {
        super.tearDown();
        if (mIntent != null) {
            mInstrumentation.getContext().stopService(mIntent);
        }
        for (int i = 0; i < mStartedActivityList.size(); i++) {
            mStartedActivityList.get(i).finish();
        }
        if (mErrorProcessID != -1) {
            android.os.Process.killProcess(mErrorProcessID);
        }
    }"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.app.cts.ActivityManagerTest"	"testIsBackgroundRestricted"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerTest.java"	""	"public void testIsBackgroundRestricted() throws IOException {
        // This instrumentation runs in the target package's uid.
        final Context targetContext = mInstrumentation.getTargetContext();
        final String targetPackage = targetContext.getPackageName();
        final ActivityManager am = targetContext.getSystemService(ActivityManager.class);
        setForcedAppStandby(targetPackage, true);
        assertTrue(am.isBackgroundRestricted());
        setForcedAppStandby(targetPackage, false);
        assertFalse(am.isBackgroundRestricted());
    }"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.app.cts.ActivityManagerTest"	"testIsUserAMonkey"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerTest.java"	""	"public void testIsUserAMonkey() {
        assertFalse(ActivityManager.isUserAMonkey());
    }

    /**
     * Verify that {@link ActivityManager#isRunningInTestHarness()} is false.
     */
    @RestrictedBuildTest"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.managedprofile.BluetoothSharingRestrictionTest"	"testOppDisabledWhenRestrictionSet"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/ManagedProfile/src/com/android/cts/managedprofile/BluetoothSharingRestrictionTest.java"	""	"public void testOppDisabledWhenRestrictionSet() throws Exception {
        if (BluetoothAdapter.getDefaultAdapter() == null) {
            // No Bluetooth - nothing to test.
            return;
        }

        // The restriction is active by default for managed profiles.
        assertBluetoothSharingAvailable(mContext, false);

        // Remove the user restriction.
        mDevicePolicyManager.clearUserRestriction(
                ADMIN_RECEIVER_COMPONENT, UserManager.DISALLOW_BLUETOOTH_SHARING);
        // Bluetooth sharing should become available.
        assertBluetoothSharingAvailable(mContext, true);

        // Add the user restriction back (which is the default state).
        mDevicePolicyManager.addUserRestriction(
                ADMIN_RECEIVER_COMPONENT, UserManager.DISALLOW_BLUETOOTH_SHARING);
        // Bluetooth sharing should be disabled once again.
        assertBluetoothSharingAvailable(mContext, false);
    }

    /** Verifies restriction enforcement. */
    private static void assertRestrictionEnforced(Context context, boolean enforced) {
        final UserManager um = (UserManager) context.getSystemService(Context.USER_SERVICE);
        assertEquals(""Invalid restriction enforcement status"", enforced,
                um.getUserRestrictions().getBoolean(UserManager.DISALLOW_BLUETOOTH_SHARING, false));
    }

    /**
     * Builds an intent to share an image file. If Bluetooth sharing is allowed, it should be
     * handled by {@link #OPP_LAUNCHER_COMPONENT}.
     */
    private static Intent fileSharingIntent() {
        final Intent result = new Intent(Intent.ACTION_SEND);
        final Uri uri = Uri.parse(""content://foo/bar"");
        result.setDataAndType(uri, ""image/*"");
        return result;
    }

    /**
     * Verifies bluetooth sharing availability.
     */
    static void assertBluetoothSharingAvailable(Context context, boolean available)
            throws Exception {
        // Check restriction.
        assertRestrictionEnforced(context, !available);
        // Check component status.
        final int componentEnabledState = available
                ? PackageManager.COMPONENT_ENABLED_STATE_DEFAULT
                : PackageManager.COMPONENT_ENABLED_STATE_DISABLED;
        assertComponentStateAfterTimeout(context, OPP_LAUNCHER_COMPONENT, componentEnabledState);
        // Check whether sharing activity is offered.
        assertHandlerAvailable(context, fileSharingIntent(), OPP_LAUNCHER_COMPONENT, available);
    }

    /** Waits for package state to change to a desired one or fails. */
    private static void assertComponentStateAfterTimeout(Context context, ComponentName component,
            int expectedState)
            throws Exception {
        final long timeout = SystemClock.elapsedRealtime() + COMPONENT_STATE_TIMEOUT_MS;
        int state = -1;
        while (SystemClock.elapsedRealtime() < timeout) {
            state = context.getPackageManager().getComponentEnabledSetting(component);
            if (expectedState == state) {
                // Success
                return;
            }
            Thread.sleep(POLL_TIME_MS);
        }
        TestCase.fail(""The state of "" + component + "" should have been "" + expectedState
                + "", it but was "" + state + "" after timeout."");
    }

    /** Verifies that {@code component} is offered when handling {@code intent}. */
    private static void assertHandlerAvailable(Context context, Intent intent,
            ComponentName component,
            boolean shouldResolve) {
        final List<ResolveInfo> infos =
                context.getPackageManager().queryIntentActivities(intent, 0);
        for (final ResolveInfo info : infos) {
            final ComponentInfo componentInfo =
                    info.activityInfo != null ? info.activityInfo :
                            info.serviceInfo != null ? info.serviceInfo :
                                    info.providerInfo;
            final ComponentName resolvedComponent =
                    new ComponentName(componentInfo.packageName, componentInfo.name);

            if (resolvedComponent.equals(component)) {
                if (shouldResolve) {
                    // Found it, assertion passed.
                    return;
                } else {
                    TestCase.fail(component + "" is available as a handler for "" + intent);
                }
            }
        }
        // If we get to this point, there was no match.
        if (shouldResolve) {
            TestCase.fail(component + "" isn't available as a handler for "" + intent);
        }
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.text.cts.FontResourceTest"	"testRemoteResource"	"CtsTextTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/text/src/android/text/cts/FontResourceTest.java"	""	"public void testRemoteResource() throws Exception {
        Context context = InstrumentationRegistry.getTargetContext();

        Context freeContext = context.createPackageContext(
                RESOURCE_PACKAGE, Context.CONTEXT_IGNORE_SECURITY);
        Context restrictContext = context.createPackageContext(
                RESOURCE_PACKAGE, Context.CONTEXT_RESTRICTED);

        // This expectation is for verifying the precondition of the test case. If the context
        // ignores the security, loads the custom font and TextView gives the width with it. If the
        // context is restricted, the custom font should not be loaded and TextView gives the width
        // different from the one with the custom font.
        // The custom font has 3em for ""a"" character. The text is ""aaa"", then 9em = 900px is the
        // expected width.
        assertThat(measureText(inflateWithInflator(freeContext)))
                .isEqualTo(REMOTE_FONT_TEXT_WIDTH);
        assertThat(measureText(inflateWithInflator(restrictContext)))
                .isNotEqualTo(REMOTE_FONT_TEXT_WIDTH);

        // The RemoteView should ignore the custom font files.
        assertThat(measureText(inflateWithRemoteViews(context)))
                .isNotEqualTo(REMOTE_FONT_TEXT_WIDTH);
    }
}"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.managedprovisioning.NfcTestActivity"	"getTestMessage"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/managedprovisioning/NfcTestActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.managedprovisioning;

import android.app.Activity;
import android.app.admin.DevicePolicyManager;
import android.content.ActivityNotFoundException;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.nfc.NdefMessage;
import android.nfc.NdefRecord;
import android.nfc.NfcAdapter;
import android.os.Bundle;
import android.os.UserManager;
import android.util.Log;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Toast;

import com.android.cts.verifier.R;

import java.nio.charset.Charset;

public class NfcTestActivity extends Activity {
    private static final String TAG = ""NfcTestActivity"";

    /* package */ static final String EXTRA_DISALLOW_BY_POLICY = ""disallowByPolicy"";

    private static final String NFC_BEAM_PACKAGE = ""com.android.nfc"";
    private static final String NFC_BEAM_ACTIVITY = ""com.android.nfc.BeamShareActivity"";
    private static final String SAMPLE_TEXT = ""sample text"";

    private ComponentName mAdminReceiverComponent;
    private DevicePolicyManager mDevicePolicyManager;
    private UserManager mUserMangaer;
    private NfcAdapter mNfcAdapter;
    private boolean mDisallowByPolicy;
    private boolean mAddUserRestrictionOnFinish;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.byod_nfc_test_activity);

        mAdminReceiverComponent = new ComponentName(this, DeviceAdminTestReceiver.class.getName());
        mDevicePolicyManager = (DevicePolicyManager) getSystemService(
                Context.DEVICE_POLICY_SERVICE);
        mUserMangaer = (UserManager) getSystemService(Context.USER_SERVICE);
        mAddUserRestrictionOnFinish = mUserMangaer.hasUserRestriction(
                UserManager.DISALLOW_OUTGOING_BEAM);
        mDisallowByPolicy = getIntent().getBooleanExtra(EXTRA_DISALLOW_BY_POLICY, false);
        if (mDisallowByPolicy) {
            mDevicePolicyManager.addUserRestriction(mAdminReceiverComponent,
                    UserManager.DISALLOW_OUTGOING_BEAM);
        } else {
            mDevicePolicyManager.clearUserRestriction(mAdminReceiverComponent,
                    UserManager.DISALLOW_OUTGOING_BEAM);
        }

        mNfcAdapter = NfcAdapter.getDefaultAdapter(this);
        mNfcAdapter.setNdefPushMessage(getTestMessage(), this);

        final Intent shareIntent = new Intent(Intent.ACTION_SEND);
        shareIntent.putExtra(Intent.EXTRA_TEXT, SAMPLE_TEXT);

        findViewById(R.id.manual_beam_button).setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View view) {
                mNfcAdapter.invokeBeam(NfcTestActivity.this);
            }
        });
        findViewById(R.id.intent_share_button).setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View view) {
                // Specify the package name of NfcBeamActivity so that the tester don't need to
                // select the activity manually.
                shareIntent.setClassName(NFC_BEAM_PACKAGE, NFC_BEAM_ACTIVITY);
                try {
                    startActivity(shareIntent);
                } catch (ActivityNotFoundException e) {
                    Toast.makeText(NfcTestActivity.this,
                            R.string.provisioning_byod_cannot_resolve_beam_activity,
                            Toast.LENGTH_SHORT).show();
                    Log.e(TAG, ""Nfc beam activity not found"", e);
                }
            }
        });
    }

    @Override
    public void finish() {
        if (mAddUserRestrictionOnFinish) {
            mDevicePolicyManager.addUserRestriction(mAdminReceiverComponent,
                    UserManager.DISALLOW_OUTGOING_BEAM);
        } else {
            mDevicePolicyManager.clearUserRestriction(mAdminReceiverComponent,
                    UserManager.DISALLOW_OUTGOING_BEAM);
        }
        super.finish();
    }

    private NdefMessage getTestMessage() {
        byte[] mimeBytes = ""application/com.android.cts.verifier.managedprovisioning""
                .getBytes(Charset.forName(""US-ASCII""));
        byte[] id = new byte[] {1, 3, 3, 7};
        byte[] payload = SAMPLE_TEXT.getBytes(Charset.forName(""US-ASCII""));
        return new NdefMessage(new NdefRecord[] {
                new NdefRecord(NdefRecord.TNF_MIME_MEDIA, mimeBytes, id, payload)
        });
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.media.cts.BaseMultiUserTest"	"listUsers"	"CtsMediaHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/media/src/android/media/cts/BaseMultiUserTest.java"	""	"public void test/*
 *.
 */

package android.media.cts;

import com.android.compatibility.common.tradefed.build.CompatibilityBuildHelper;
import com.android.ddmlib.testrunner.RemoteAndroidTestRunner;
import com.android.ddmlib.testrunner.TestResult.TestStatus;
import com.android.tradefed.build.IBuildInfo;
import com.android.tradefed.device.DeviceNotAvailableException;
import com.android.tradefed.log.LogUtil.CLog;
import com.android.tradefed.result.CollectingTestListener;
import com.android.tradefed.result.TestDescription;
import com.android.tradefed.result.TestResult;
import com.android.tradefed.result.TestRunResult;
import com.android.tradefed.testtype.DeviceTestCase;
import com.android.tradefed.testtype.IBuildReceiver;

import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.TimeUnit;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;

/**
 * Base class for host-side tests for multi-user aware media APIs.
 */
public class BaseMultiUserTest extends BaseMediaHostSideTest {
    private static final String SETTINGS_PACKAGE_VERIFIER_NAMESPACE = ""global"";
    private static final String SETTINGS_PACKAGE_VERIFIER_NAME = ""package_verifier_enable"";

    /**
     * User ID for all users.
     * The value is from the UserHandle class.
     */
    protected static final int USER_ALL = -1;

    /**
     * User ID for the system user.
     * The value is from the UserHandle class.
     */
    protected static final int USER_SYSTEM = 0;

    private String mPackageVerifier;

    private Set<String> mExistingPackages;
    private List<Integer> mExistingUsers;
    private HashSet<String> mAvailableFeatures;

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        // Ensure that build has been set before test is run.
        assertNotNull(mCtsBuild);
        mExistingPackages = getDevice().getInstalledPackageNames();

        // Disable the package verifier to avoid the dialog when installing an app
        mPackageVerifier =
                getSettings(
                        SETTINGS_PACKAGE_VERIFIER_NAMESPACE,
                        SETTINGS_PACKAGE_VERIFIER_NAME,
                        USER_ALL);
        putSettings(
                SETTINGS_PACKAGE_VERIFIER_NAMESPACE,
                SETTINGS_PACKAGE_VERIFIER_NAME,
                ""0"",
                USER_ALL);

        mExistingUsers = new ArrayList<>();
        int primaryUserId = getDevice().getPrimaryUserId();
        mExistingUsers.add(primaryUserId);
        mExistingUsers.add(USER_SYSTEM);

        executeShellCommand(""am switch-user "" + primaryUserId);
        executeShellCommand(""wm dismiss-keyguard"");
    }

    @Override
    protected void tearDown() throws Exception {
        // Reset the package verifier setting to its original value.
        putSettings(
                SETTINGS_PACKAGE_VERIFIER_NAMESPACE,
                SETTINGS_PACKAGE_VERIFIER_NAME,
                mPackageVerifier,
                USER_ALL);

        // Remove users created during the test.
        for (int userId : getDevice().listUsers()) {
            if (!mExistingUsers.contains(userId)) {
                removeUser(userId);
            }
        }
        // Remove packages installed during the test.
        for (String packageName : getDevice().getUninstallablePackageNames()) {
            if (mExistingPackages.contains(packageName)) {
                continue;
            }
            CLog.d(""Removing leftover package: "" + packageName);
            getDevice().uninstallPackage(packageName);
        }
        super.tearDown();
    }

    /**
     * Installs the app as if the user of the ID {@param userId} has installed the app.
     *
     * @param appFileName file name of the app.
     * @param userId user ID to install the app against.
     */
    protected void installAppAsUser(String appFileName, int userId, boolean asInstantApp)
            throws FileNotFoundException, DeviceNotAvailableException {
        CLog.d(""Installing app "" + appFileName + "" for user "" + userId);
        CompatibilityBuildHelper buildHelper = new CompatibilityBuildHelper(mCtsBuild);
        String result = getDevice().installPackageForUser(
                buildHelper.getTestFile(appFileName),
                true,
                true,
                userId,
                ""-t"",
                asInstantApp ? ""--instant"" : """");
        assertNull(""Failed to install "" + appFileName + "" for user "" + userId + "": "" + result,
                result);
    }

    private int createAndStartUser(String extraParam) throws Exception {
        String command = ""pm create-user"" + extraParam + "" TestUser_"" + System.currentTimeMillis();
        String commandOutput = executeShellCommand(command);

        String[] tokens = commandOutput.split(""\\s+"");
        assertTrue(tokens.length > 0);
        assertEquals(""Success:"", tokens[0]);
        int userId = Integer.parseInt(tokens[tokens.length-1]);

        // Start user for MediaSessionService to notice the created user.
        getDevice().startUser(userId);
        return userId;
    }

    /**
     * Creates and starts a new user.
     */
    protected int createAndStartUser() throws Exception {
        return createAndStartUser("""");
    }

    /**
     * Creates and starts a restricted profile for the {@param parentUserId}.
     *
     * @param parentUserId parent user id.
     */
    protected int createAndStartRestrictedProfile(int parentUserId) throws Exception {
        return createAndStartUser("" --profileOf "" + parentUserId + "" --restricted"");
    }

    /**
     * Creates and starts a managed profile for the {@param parentUserId}.
     *
     * @param parentUserId parent user id.
     */
    protected int createAndStartManagedProfile(int parentUserId) throws Exception {
        return createAndStartUser("" --profileOf "" + parentUserId + "" --managed"");
    }

    /**
     * Removes the user that is created during the test.
     * <p>It will be no-op if the user cannot be removed or doesn't exist.
     *
     * @param userId user ID to remove.
     */
    protected void removeUser(int userId) throws Exception  {
        if (getDevice().listUsers().contains(userId) && userId != USER_SYSTEM
                && !mExistingUsers.contains(userId)) {
            getDevice().executeShellCommand(""am wait-for-broadcast-idle"");
            // Don't log output, as tests sometimes set no debug user restriction, which
            // causes this to fail, we should still continue and remove the user.
            String stopUserCommand = ""am stop-user -w -f "" + userId;
            CLog.d(""Stopping and removing user "" + userId);
            getDevice().executeShellCommand(stopUserCommand);
            assertTrue(""Couldn't remove user"", getDevice().removeUser(userId));
        }
    }

    /**
     * Runs tests on the device as if it's {@param userId}.
     *
     * @param pkgName test package file name that contains the {@link AndroidTestCase}
     * @param testClassName Class name to test within the test package. Can be {@code null} if you
     *    want to run all test classes in the package.
     * @param testMethodName Method name to test within the test class. Can be {@code null} if you
     *    want to run all test methods in the class. Will be ignored if {@param testClassName} is
     *    {@code null}.
     * @param userId user ID to run the tests as.
     */
    protected void runDeviceTests(
            String pkgName, @Nullable String testClassName,
            @Nullable String testMethodName, int userId) throws DeviceNotAvailableException {
        RemoteAndroidTestRunner testRunner = getTestRunner(pkgName, testClassName, testMethodName);
        CollectingTestListener listener = new CollectingTestListener();
        assertTrue(getDevice().runInstrumentationTestsAsUser(testRunner, userId, listener));

        final TestRunResult result = listener.getCurrentRunResults();
        assertTestsPassed(result);
    }

    /**
     * Checks whether it is possible to create the desired number of users.
     */
    protected boolean canCreateAdditionalUsers(int numberOfUsers)
            throws DeviceNotAvailableException {
        return getDevice().listUsers().size() + numberOfUsers <=
                getDevice().getMaxNumberOfUsersSupported();
    }

    /**
     * Gets the system setting as a string from the system settings provider for the user.
     *
     * @param namespace namespace of the setting.
     * @param name name of the setting.
     * @param userId user ID to query the setting. Can be {@link #USER_ALL}.
     * @return value of the system setting provider with the given namespace and name.
     *    {@code null}, empty string, or ""null"" will be returned to the empty string ("""") instead.
     */
    protected @Nonnull String getSettings(@Nonnull String namespace, @Nonnull String name,
            int userId) throws Exception {
        String userFlag = (userId == USER_ALL) ? """" : "" --user "" + userId;
        String commandOutput = executeShellCommand(
                ""settings"" + userFlag + "" get "" + namespace + "" "" + name);
        if (commandOutput == null || commandOutput.isEmpty() || commandOutput.equals(""null"")) {
            commandOutput = """";
        }
        return commandOutput;
    }

    /**
     * Puts the string to the system settings provider for the user.
     * <p>This deletes the setting for an empty {@param value} as 'settings put' doesn't allow
     * putting empty value.
     *
     * @param namespace namespace of the setting.
     * @param name name of the setting.
     * @param value value of the system setting provider with the given namespace and name.
     * @param userId user ID to set the setting. Can be {@link #USER_ALL}.
     */
    protected void putSettings(@Nonnull String namespace, @Nonnull String name,
            @Nullable String value, int userId) throws Exception {
        if (value == null || value.isEmpty()) {
            // Delete the setting if the value is null or empty as 'settings put' doesn't accept
            // them.
            // Ignore userId here because 'settings delete' doesn't support it.
            executeShellCommand(""settings delete "" + namespace + "" "" + name);
        } else {
            String userFlag = (userId == USER_ALL) ? """" : "" --user "" + userId;
            executeShellCommand(""settings"" + userFlag + "" put "" + namespace + "" "" + name
                    + "" "" + value);
        }
    }

    protected boolean hasDeviceFeature(String requiredFeature) throws DeviceNotAvailableException {
        if (mAvailableFeatures == null) {
            // TODO: Move this logic to ITestDevice.
            String command = ""pm list features"";
            String commandOutput = getDevice().executeShellCommand(command);
            CLog.i(""Output for command "" + command + "": "" + commandOutput);

            // Extract the id of the new user.
            mAvailableFeatures = new HashSet<>();
            for (String feature : commandOutput.split(""\\s+"")) {
                // Each line in the output of the command has the format ""feature:{FEATURE_VALUE}"".
                String[] tokens = feature.split("":"");
                assertTrue(
                        ""\"""" + feature + ""\"" expected to have format feature:{FEATURE_VALUE}"",
                        tokens.length > 1);
                assertEquals(feature, ""feature"", tokens[0]);
                mAvailableFeatures.add(tokens[1]);
            }
        }
        boolean result = mAvailableFeatures.contains(requiredFeature);
        return result;
    }
}"	""	""	"restricted restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.AccountManagementParentTest"	"testSetAccountManagementDisabledOnParent"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/AccountManagementParentTest.java"	""	"public void testSetAccountManagementDisabledOnParent() {
        DevicePolicyManager parentDevicePolicyManager = getParentInstance();

        parentDevicePolicyManager.setAccountManagementDisabled(ADMIN_RECEIVER_COMPONENT,
                SOME_ACCOUNT_TYPE, true);
        assertThat(
                parentDevicePolicyManager.getAccountTypesWithManagementDisabled()).asList()
                .containsExactly(SOME_ACCOUNT_TYPE);
        // Ensure that account management is not restricted on the managed profile itself.
        assertThat(mDevicePolicyManager.getAccountTypesWithManagementDisabled()).isEmpty();
    }"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.SetPolicyActivity"	"finish"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/SetPolicyActivity.java"	""	"public void test/*
 *.
 */
package com.android.cts.deviceandprofileowner;

import android.app.Activity;
import android.app.admin.DevicePolicyManager;
import android.content.Intent;
import android.content.pm.PackageManager.NameNotFoundException;
import android.os.Bundle;
import android.os.Process;
import android.util.Log;

import com.android.bedstead.dpmwrapper.TestAppSystemServiceFactory;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * Simple activity that sets or unsets a policy depending on the value of the extras.
 */
public class SetPolicyActivity extends Activity {

    private static final String TAG = SetPolicyActivity.class.getSimpleName();

    private static final String EXTRA_RESTRICTION_KEY = ""extra-restriction-key"";
    private static final String EXTRA_COMMAND = ""extra-command"";
    private static final String EXTRA_ACCOUNT_TYPE = ""extra-account-type"";
    private static final String EXTRA_PACKAGE_NAME = ""extra-package-name"";
    private static final String EXTRA_SCOPES_LIST = ""extra-scopes-list"";

    private static final String COMMAND_ADD_USER_RESTRICTION = ""add-restriction"";
    private static final String COMMAND_CLEAR_USER_RESTRICTION = ""clear-restriction"";
    private static final String COMMAND_BLOCK_ACCOUNT_TYPE = ""block-accounttype"";
    private static final String COMMAND_UNBLOCK_ACCOUNT_TYPE = ""unblock-accounttype"";
    private static final String COMMAND_SET_APP_RESTRICTIONS_MANAGER =
            ""set-app-restrictions-manager"";
    private static final String COMMAND_SET_DELEGATED_SCOPES = ""set-delegated-scopes"";

    @Override
    public void onCreate(Bundle savedInstanceState) {
        Log.v(TAG, ""onCreate(): uid="" + Process.myUid());
        super.onCreate(savedInstanceState);
        handleIntent(getIntent());
    }

    // Overriding this method in case another intent is sent to this activity before finish()
    @Override
    public void onNewIntent(Intent intent) {
        super.onNewIntent(intent);
        handleIntent(intent);
    }

    private void handleIntent(Intent intent) {
        DevicePolicyManager dpm = TestAppSystemServiceFactory.getDevicePolicyManager(this,
                BaseDeviceAdminTest.BasicAdminReceiver.class);
        String command = intent.getStringExtra(EXTRA_COMMAND);
        Log.i(TAG, ""Command: "" + command + "" UID: "" + Process.myUid() + "" DPM: "" + dpm);

        if (COMMAND_ADD_USER_RESTRICTION.equals(command)) {
            String restrictionKey = intent.getStringExtra(EXTRA_RESTRICTION_KEY);
            dpm.addUserRestriction(BaseDeviceAdminTest.ADMIN_RECEIVER_COMPONENT, restrictionKey);
            Log.i(TAG, ""Added user restriction "" + restrictionKey
                    + "" for user "" + Process.myUserHandle());
        } else if (COMMAND_CLEAR_USER_RESTRICTION.equals(command)) {
            String restrictionKey = intent.getStringExtra(EXTRA_RESTRICTION_KEY);
            dpm.clearUserRestriction(
                    BaseDeviceAdminTest.ADMIN_RECEIVER_COMPONENT, restrictionKey);
            Log.i(TAG, ""Cleared user restriction "" + restrictionKey
                    + "" for user "" + Process.myUserHandle());
        } else if (COMMAND_BLOCK_ACCOUNT_TYPE.equals(command)) {
            String accountType = intent.getStringExtra(EXTRA_ACCOUNT_TYPE);
            dpm.setAccountManagementDisabled(BaseDeviceAdminTest.ADMIN_RECEIVER_COMPONENT,
                    accountType, true);
            Log.i(TAG, ""Blocking account management for account type: "" + accountType
                    + "" for user "" + Process.myUserHandle());
        } else if (COMMAND_UNBLOCK_ACCOUNT_TYPE.equals(command)) {
            String accountType = intent.getStringExtra(EXTRA_ACCOUNT_TYPE);
            dpm.setAccountManagementDisabled(BaseDeviceAdminTest.ADMIN_RECEIVER_COMPONENT,
                    accountType, false);
            Log.i(TAG, ""Unblocking account management for account type: "" + accountType
                    + "" for user "" + Process.myUserHandle());
        } else if (COMMAND_SET_APP_RESTRICTIONS_MANAGER.equals(command)) {
            String packageName = intent.getStringExtra(EXTRA_PACKAGE_NAME);
            try {
                dpm.setApplicationRestrictionsManagingPackage(
                        BaseDeviceAdminTest.ADMIN_RECEIVER_COMPONENT, packageName);
            } catch (NameNotFoundException e) {
                throw new IllegalArgumentException(e);
            }
            Log.i(TAG, ""Setting the application restrictions managing package to "" + packageName);
        } else if (COMMAND_SET_DELEGATED_SCOPES.equals(command)) {
            String packageName = intent.getStringExtra(EXTRA_PACKAGE_NAME);
            String scopeArray[] = intent.getStringArrayExtra(EXTRA_SCOPES_LIST);
            List<String> scopes = scopeArray == null ? new ArrayList<>()
                    : Arrays.asList(scopeArray);
            Log.i(TAG, ""Setting delegated scopes for package: "" + packageName + "" "" + scopes);
            dpm.setDelegatedScopes(BaseDeviceAdminTest.ADMIN_RECEIVER_COMPONENT,
                    packageName, scopes);
        } else {
            Log.e(TAG, ""Invalid command: "" + command);
        }
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.scopedstorage.cts.legacy.LegacyStorageTest"	"isTrue"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/legacy/src/android/scopedstorage/cts/legacy/LegacyStorageTest.java"	""	"public void setupExternalStorage() {
        setupDefaultDirectories();
    }

    @Before
    public void setup() throws Exception {
        pollForExternalStorageState();

        assertThat(checkPermission(APP_A_HAS_RES,
                Manifest.permission.READ_EXTERNAL_STORAGE)).isTrue();
        assertThat(checkPermission(APP_B_NO_PERMS,
                Manifest.permission.READ_EXTERNAL_STORAGE)).isFalse();
    }

    @After
    public void teardown() throws Exception {
        deleteFileInExternalDir(getShellFile());
        try {
            MediaStore.scanFile(getContentResolver(), getShellFile());
        } catch (Exception ignored) {
            //ignore MediaScanner exceptions
        }
    }

    /**
     * Tests that legacy apps bypass the type-path conformity restrictions imposed by
     * MediaProvider. <p> Assumes we have WRITE_EXTERNAL_STORAGE.
     */"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.scopedstorage.cts.legacy.LegacyStorageTest"	"testCreateFilesInRandomPlaces_hasW"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/legacy/src/android/scopedstorage/cts/legacy/LegacyStorageTest.java"	""	"public void testCreateFilesInRandomPlaces_hasW() throws Exception {
        pollForPermission(Manifest.permission.READ_EXTERNAL_STORAGE, /*granted*/ false);
        pollForPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE, /*granted*/ true);
        // Can create file under root dir
        assertCanCreateFile(new File(TestUtils.getExternalStorageDir(), ""LegacyFileAccessTest.txt""));

        // Can create music file under DCIM
        assertCanCreateFile(new File(TestUtils.getDcimDir(), ""LegacyFileAccessTest.mp3""));

        // Can create random file under external files dir
        assertCanCreateFile(new File(TestUtils.getExternalFilesDir(),
                ""LegacyFileAccessTest""));

        // However, even legacy apps can't create files under other app's directories
        final File otherAppDir = new File(TestUtils.getAndroidDataDir(), ""com.android.shell"");
        final File file = new File(otherAppDir, ""LegacyFileAccessTest.txt"");

        // otherAppDir was already created by the host test
        try {
            file.createNewFile();
            fail(""File creation expected to fail: "" + file);
        } catch (IOException expected) {
        }
    }

    /**
     * Tests that legacy apps bypass dir creation/deletion restrictions imposed by MediaProvider.
     * <p> Assumes we have WRITE_EXTERNAL_STORAGE.
     */"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.scopedstorage.cts.legacy.LegacyStorageTest"	"testInsertHiddenFile"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/legacy/src/android/scopedstorage/cts/legacy/LegacyStorageTest.java"	""	"public void testInsertHiddenFile() throws Exception {
        pollForPermission(Manifest.permission.READ_EXTERNAL_STORAGE, /*granted*/ true);
        final File dcimDir = getDcimDir();
        final String hiddenImageFileName = "".hidden"" + IMAGE_FILE_NAME;
        final File hiddenImageFile = new File(dcimDir, hiddenImageFileName);
        try {
            ContentValues values = new ContentValues();
            values.put(MediaStore.MediaColumns.DATA, hiddenImageFile.getAbsolutePath());
            Uri uri = getContentResolver().insert(getImageContentUri(), values);
            try (OutputStream fos = getContentResolver().openOutputStream(uri, ""rw"")) {
                fos.write(BYTES_DATA1);
            }
            MediaStore.scanFile(getContentResolver(), hiddenImageFile);
            final String[] projection = {MediaStore.MediaColumns.DISPLAY_NAME};
            try (Cursor c = getContentResolver().query(uri, projection, null, null, null)) {
                assertThat(c.moveToFirst()).isTrue();
                assertThat(c.getString(0)).isEqualTo(hiddenImageFileName);
            }
        } finally {
            hiddenImageFile.delete();
        }
    }

    /**
     * Test that rename for legacy app with WRITE_EXTERNAL_STORAGE permission bypasses rename
     * restrictions imposed by MediaProvider
     */"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceowner.CreateAndManageUserTest"	"testCreateAndManageUser_StopEphemeralUser_DisallowRemoveUser"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceOwner/src/com/android/cts/deviceowner/CreateAndManageUserTest.java"	""	"public void testCreateAndManageUser_StopEphemeralUser_DisallowRemoveUser() throws Exception {
        // Set DISALLOW_REMOVE_USER restriction
        mDevicePolicyManager.addUserRestriction(getWho(), UserManager.DISALLOW_REMOVE_USER);

        UserHandle userHandle = createAndManageUser(DevicePolicyManager.MAKE_USER_EPHEMERAL);
        startUserInBackgroundAndWaitForBroadcasts(userHandle);
        UserActionCallback callback = UserActionCallback.getCallbackForBroadcastActions(
                getContext(),
                BasicAdminReceiver.ACTION_USER_STOPPED, BasicAdminReceiver.ACTION_USER_REMOVED);

        callback.runAndUnregisterSelf(
                () -> stopUserAndCheckResult(userHandle, UserManager.USER_OPERATION_SUCCESS));

        // It's running just one operation (which issues a ACTION_USER_STOPPED), but as the
        // user is ephemeral, it will be automatically removed (which issues a
        // ACTION_USER_REMOVED).
        assertWithMessage(""user on broadcasts"").that(callback.getUsersOnReceivedBroadcasts())
                .containsExactly(userHandle, userHandle);
    }

    @SuppressWarnings(""unused"")
    private static void logoutUser(Context context, DevicePolicyManager devicePolicyManager,
            ComponentName componentName) {
        assertUserOperationResult(devicePolicyManager.logoutUser(componentName),
                UserManager.USER_OPERATION_SUCCESS, ""cannot logout user"");
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceowner.CreateAndManageUserTest"	"testCreateAndManageUser_LeaveAllSystemApps"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceOwner/src/com/android/cts/deviceowner/CreateAndManageUserTest.java"	""	"public void testCreateAndManageUser_LeaveAllSystemApps() throws Exception {
        int currentUserId = ActivityManager.getCurrentUser();
        // TODO: instead of hard-coding the user type, calling getPreInstallableSystemPackages(),
        // and passing the packages to runCrossUserVerification() / assertAllSystemAppsInstalled(),
        // ideally the later should call um.getPreInstallableSystemPackages(um.getUsertype())
        // (where um is the UserManager with the context of the newly created user),
        // but currently the list of pre-installed apps is passed to the new user in the bundle.
        // Given that these tests will be refactored anyways, it's not worth to try to change it.
        String newUserType = UserManager.USER_TYPE_FULL_SECONDARY;
        Set<String> preInstalledSystemPackages = SystemUtil.callWithShellPermissionIdentity(
                () -> UserManager.get(mContext).getPreInstallableSystemPackages(newUserType));
        if (preInstalledSystemPackages != null) {
            Log.d(TAG, preInstalledSystemPackages.size() + "" pre-installed system apps for ""
                    + ""new user of type "" + newUserType + "": "" + preInstalledSystemPackages);
        } else {
            Log.d(TAG, ""no pre-installed system apps allowlist for new user of type"" + newUserType);
        }

        runCrossUserVerification(/* callback= */ null,
                DevicePolicyManager.LEAVE_ALL_SYSTEM_APPS_ENABLED, ""assertAllSystemAppsInstalled"",
                preInstalledSystemPackages);
        PrimaryUserService.assertCrossUserCallArrived();
    }

    private UserHandle runCrossUserVerification(int createAndManageUserFlags, String methodName)
            throws Exception {
        return runCrossUserVerification(/* callback= */ null, createAndManageUserFlags, methodName,
                /* currentUserPackages= */ null);
    }

    private UserHandle runCrossUserVerification(UserActionCallback callback,
            int createAndManageUserFlags, String methodName,
            Set<String> currentUserPackages) throws Exception {
        Log.d(TAG, ""runCrossUserVerification(): flags="" + createAndManageUserFlags
                + "", method="" + methodName);
        String testUserName = ""TestUser_"" + System.currentTimeMillis();

        // Set affiliation id to allow communication.
        mDevicePolicyManager.setAffiliationIds(getWho(), Collections.singleton(AFFILIATION_ID));

        ComponentName profileOwner = SecondaryUserAdminReceiver.getComponentName(getContext());

        // Pack the affiliation id in a bundle so the secondary user can get it.
        PersistableBundle bundle = new PersistableBundle();
        bundle.putString(EXTRA_AFFILIATION_ID, AFFILIATION_ID);
        bundle.putString(EXTRA_METHOD_NAME, methodName);
        if (currentUserPackages != null) {
            String[] array = new String[currentUserPackages.size()];
            currentUserPackages.toArray(array);
            bundle.putStringArray(EXTRA_CURRENT_USER_PACKAGES, array);
        }

        Log.d(TAG, ""creating user with PO "" + profileOwner);

        UserHandle userHandle = createAndManageUser(profileOwner, bundle, createAndManageUserFlags);
        if (callback != null) {
            startUserInBackgroundAndWaitForBroadcasts(callback, userHandle);
        } else {
            startUserInBackgroundAndWaitForBroadcasts(userHandle);
        }
        return userHandle;
    }

    // createAndManageUser should circumvent the DISALLOW_ADD_USER restriction"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceowner.CreateAndManageUserTest"	"testCreateAndManageUser_AddRestrictionSet"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceOwner/src/com/android/cts/deviceowner/CreateAndManageUserTest.java"	""	"public void testCreateAndManageUser_AddRestrictionSet() throws Exception {
        mDevicePolicyManager.addUserRestriction(getWho(), UserManager.DISALLOW_ADD_USER);

        createAndManageUser();
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceowner.CreateAndManageUserTest"	"testCreateAndManageUser_RemoveRestrictionSet"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceOwner/src/com/android/cts/deviceowner/CreateAndManageUserTest.java"	""	"public void testCreateAndManageUser_RemoveRestrictionSet() throws Exception {
        mDevicePolicyManager.addUserRestriction(getWho(), UserManager.DISALLOW_REMOVE_USER);

        UserHandle userHandle = createAndManageUser();

        // When the device owner itself has set the user restriction, it should still be allowed
        // to remove a user.
        List<UserHandle> usersOnBroadcasts = removeUserAndWaitForBroadcasts(userHandle);

        assertWithMessage(""user on broadcasts"").that(usersOnBroadcasts).containsExactly(userHandle);
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"test.java.com.android.queryable.queries.ActivityQueryHelperTest"	"isTrue"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/queryable/src/test/java/com/android/queryable/queries/ActivityQueryHelperTest.java"	""	"public void matches_noRestrictions_returnsTrue() {
        ActivityQueryHelper<Queryable> activityQueryHelper = new ActivityQueryHelper<>(mQuery);

        assertThat(activityQueryHelper.matches(CLASS_1_ACTIVITY_INFO)).isTrue();
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"test.java.com.android.queryable.queries.BundleKeyQueryHelperTest"	"isTrue"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/queryable/src/test/java/com/android/queryable/queries/BundleKeyQueryHelperTest.java"	""	"public void matches_serializableValueRestriction_meetsRestriction_returnsTrue() {
        mBundle.putSerializable(KEY, mSerializable);
        BundleKeyQueryHelper<Queryable> bundleKeyQueryHelper =
                new BundleKeyQueryHelper<>(mQuery);

        bundleKeyQueryHelper.serializableValue().isEqualTo(mSerializable);

        assertThat(bundleKeyQueryHelper.matches(mBundle, KEY)).isTrue();
    }"	""	""	"restriction restriction restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"test.java.com.android.queryable.queries.BundleKeyQueryHelperTest"	"isFalse"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/queryable/src/test/java/com/android/queryable/queries/BundleKeyQueryHelperTest.java"	""	"public void matches_serializableValueRestriction_doesNotMeetRestriction_returnsFalse() {
        mBundle.putSerializable(KEY, mSerializable);
        BundleKeyQueryHelper<Queryable> bundleKeyQueryHelper =
                new BundleKeyQueryHelper<>(mQuery);

        bundleKeyQueryHelper.serializableValue().isEqualTo(mDifferentSerializable);

        assertThat(bundleKeyQueryHelper.matches(mBundle, KEY)).isFalse();
    }"	""	""	"restriction restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"test.java.com.android.queryable.queries.BundleKeyQueryHelperTest"	"exists"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/queryable/src/test/java/com/android/queryable/queries/BundleKeyQueryHelperTest.java"	""	"public void matches_bundleValueRestriction_doesNotMeetRestriction_returnsFalse() {
        mBundle.putBundle(KEY, mBundle2);
        mBundle2.remove(KEY2);
        BundleKeyQueryHelper<Queryable> bundleKeyQueryHelper =
                new BundleKeyQueryHelper<>(mQuery);

        bundleKeyQueryHelper.bundleValue().key(KEY2).exists();

        assertThat(bundleKeyQueryHelper.matches(mBundle, KEY)).isFalse();
    }"	""	""	"restriction restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"test.java.com.android.queryable.queries.BundleKeyQueryHelperTest"	"matches_existsRestriction_meetsRestriction_returnsTrue"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/queryable/src/test/java/com/android/queryable/queries/BundleKeyQueryHelperTest.java"	""	"public void matches_existsRestriction_meetsRestriction_returnsTrue() {
        mBundle.putString(KEY, STRING_VALUE);
        BundleKeyQueryHelper<Queryable> bundleKeyQueryHelper =
                new BundleKeyQueryHelper<>(mQuery);

        bundleKeyQueryHelper.exists();

        assertThat(bundleKeyQueryHelper.matches(mBundle, KEY)).isTrue();
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"test.java.com.android.queryable.queries.BundleKeyQueryHelperTest"	"matches_existsRestriction_doesNotMeetRestriction_returnsFalse"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/queryable/src/test/java/com/android/queryable/queries/BundleKeyQueryHelperTest.java"	""	"public void matches_existsRestriction_doesNotMeetRestriction_returnsFalse() {
        mBundle.remove(KEY);
        BundleKeyQueryHelper<Queryable> bundleKeyQueryHelper =
                new BundleKeyQueryHelper<>(mQuery);

        bundleKeyQueryHelper.exists();

        assertThat(bundleKeyQueryHelper.matches(mBundle, KEY)).isFalse();
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"test.java.com.android.queryable.queries.BundleKeyQueryHelperTest"	"matches_doesNotExistRestriction_meetsRestriction_returnsTrue"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/queryable/src/test/java/com/android/queryable/queries/BundleKeyQueryHelperTest.java"	""	"public void matches_doesNotExistRestriction_meetsRestriction_returnsTrue() {
        mBundle.remove(KEY);
        BundleKeyQueryHelper<Queryable> bundleKeyQueryHelper =
                new BundleKeyQueryHelper<>(mQuery);

        bundleKeyQueryHelper.doesNotExist();

        assertThat(bundleKeyQueryHelper.matches(mBundle, KEY)).isTrue();
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"test.java.com.android.queryable.queries.BundleKeyQueryHelperTest"	"matches_doesNotExistRestriction_doesNotMeetRestriction_returnsFalse"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/queryable/src/test/java/com/android/queryable/queries/BundleKeyQueryHelperTest.java"	""	"public void matches_doesNotExistRestriction_doesNotMeetRestriction_returnsFalse() {
        mBundle.putString(KEY, STRING_VALUE);
        BundleKeyQueryHelper<Queryable> bundleKeyQueryHelper =
                new BundleKeyQueryHelper<>(mQuery);

        bundleKeyQueryHelper.doesNotExist();

        assertThat(bundleKeyQueryHelper.matches(mBundle, KEY)).isFalse();
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.contentcaptureservice.cts.ChildlessActivityTest"	"testSetContentCaptureFeatureEnabled_disabledThenReEnabledByDeviceConfig"	"CtsContentCaptureServiceTestCases"	"/home/gpoor/cts-12-source/cts/tests/contentcaptureservice/src/android/contentcaptureservice/cts/ChildlessActivityTest.java"	""	"public void testSetContentCaptureFeatureEnabled_disabledThenReEnabledByDeviceConfig()
            throws Exception {
        setContentCaptureFeatureEnabledTest_disabledThenReEnabled(DisabledReason.BY_DEVICE_CONFIG);
        // Reset service, otherwise it will reconnect when the deviceConfig value is reset
        // on cleanup, which will cause the test to fail
        Helper.resetService();
    }

    // TODO(b/123406031): add tests that mix feature_enabled with user_restriction_enabled (and
    // make sure mgr.isContentCaptureFeatureEnabled() returns only the state of the 1st)

    private TextView addChild(@NonNull ChildlessActivity activity,
            @NonNull ContentCaptureSession session, @NonNull String text) {
        final TextView child = newImportantView(activity, text);
        child.setContentCaptureSession(session);
        Log.i(TAG, ""adding "" + child.getAutofillId() + "" on session ""
                + session.getContentCaptureSessionId());
        activity.runOnUiThread(() -> activity.getRootView().addView(child));
        return child;
    }

    // TODO(b/123024698): these method are used in cases where we cannot close a session because we
    // would miss intermediate events, so we need to sleep. This is a hack (it's slow and flaky):
    // ideally we should block and wait until the service receives the event, but right now
    // we don't get the service events until after the activity is finished, so we cannot do that...
    private void waitAndClose(@NonNull ContentCaptureSession session) {
        Log.d(TAG, ""sleeping before closing "" + session.getContentCaptureSessionId());
        sleep();
        session.close();
    }

    private void waitAndRemoveViews(@NonNull ChildlessActivity activity, @NonNull View... views) {
        Log.d(TAG, ""sleeping before removing "" + Arrays.toString(views));
        sleep();
        activity.syncRunOnUiThread(() -> {
            for (View view : views) {
                activity.getRootView().removeView(view);
            }
        });
    }

    private void sleep() {
        Log.d(TAG, ""sleeping for 1s "");
        SystemClock.sleep(1_000);
    }

    // TODO(b/120494182): temporary hack to get the manager, which currently is only available on
    // Activity contexts (and would be null from sContext)
    @NonNull
    private ContentCaptureManager getContentCaptureManagerHack() throws InterruptedException {
        final AtomicReference<ContentCaptureManager> ref = new AtomicReference<>();
        LoginActivity.onRootView(
                (activity, rootView) -> ref.set(activity.getContentCaptureManager()));

        final ActivityLauncher<LoginActivity> launcher = new ActivityLauncher<>(
                sContext, mActivitiesWatcher, LoginActivity.class);
        final ActivityWatcher watcher = launcher.getWatcher();
        final LoginActivity activity = launcher.launchActivity();
        watcher.waitFor(RESUMED);
        activity.finish();
        watcher.waitFor(DESTROYED);

        final ContentCaptureManager mgr = ref.get();
        assertThat(mgr).isNotNull();

        return mgr;
    }

    private void setFeatureEnabledByDeviceConfig(@Nullable String value) {
        Log.d(TAG, ""setFeatureEnabledByDeviceConfig(): "" + value);

        sKillSwitchManager.set(value);
    }

    @NonNull
    private ContentCaptureContext.Builder newContentCaptureContextBuilder(@NonNull String id) {
        return new ContentCaptureContext.Builder(new LocusId(id));
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.text.style.cts.TextAppearanceSpanTest"	"testRestrictContext"	"CtsTextTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/text/src/android/text/style/cts/TextAppearanceSpanTest.java"	""	"public void testRestrictContext() throws PackageManager.NameNotFoundException {
        final Context ctx = mContext.createPackageContext(mContext.getPackageName(),
                Context.CONTEXT_RESTRICTED);
        final TextAppearanceSpan span = new TextAppearanceSpan(ctx,
                android.text.cts.R.style.customFont);
        final TextPaint tp = new TextPaint();
        final float originalTextWidth = tp.measureText(""a"");
        span.updateDrawState(tp);
        // Custom font must not be loaded with the restricted context.
        assertEquals(originalTextWidth, tp.measureText(""a""), 0.0f);

    }"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.MixedManagedProfileOwnerTestApi30"	"testPasswordMinimumRestrictions"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/MixedManagedProfileOwnerTestApi30.java"	""	"public void testPasswordMinimumRestrictions() throws Exception {
        assumeHasSecureLockScreenFeature();

        executeDeviceTestClass("".PasswordMinimumRestrictionsTest"");
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.keystore.cts.KeyPairGeneratorTest"	"testGenerate_EC_ModernSpec_AsCustomAsPossible"	"CtsKeystoreTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/keystore/src/android/keystore/cts/KeyPairGeneratorTest.java"	""	"public void testGenerate_EC_ModernSpec_AsCustomAsPossible() throws Exception {
        KeyPairGenerator generator = getEcGenerator();
        Date keyValidityStart = new Date(System.currentTimeMillis());
        Date keyValidityEndDateForOrigination = new Date(System.currentTimeMillis() + 1000000);
        Date keyValidityEndDateForConsumption = new Date(System.currentTimeMillis() + 10000000);

        Date certNotBefore = new Date(System.currentTimeMillis() - 1000 * 60 * 60 * 24 * 7);
        Date certNotAfter = new Date(System.currentTimeMillis() + 1000 * 60 * 60 * 24 * 7);
        BigInteger certSerialNumber = new BigInteger(""12345678"");
        X500Principal certSubject = new X500Principal(""cn=hello"");
        generator.initialize(new KeyGenParameterSpec.Builder(
                TEST_ALIAS_1,
                KeyProperties.PURPOSE_SIGN | KeyProperties.PURPOSE_VERIFY
                        | KeyProperties.PURPOSE_ENCRYPT)
                .setKeySize(224)
                .setDigests(KeyProperties.DIGEST_SHA384, KeyProperties.DIGEST_SHA512)
                .setKeyValidityStart(keyValidityStart)
                .setKeyValidityForOriginationEnd(keyValidityEndDateForOrigination)
                .setKeyValidityForConsumptionEnd(keyValidityEndDateForConsumption)
                .setCertificateSerialNumber(certSerialNumber)
                .setCertificateSubject(certSubject)
                .setCertificateNotBefore(certNotBefore)
                .setCertificateNotAfter(certNotAfter)
                .build());
        KeyPair keyPair = generator.generateKeyPair();
        assertGeneratedKeyPairAndSelfSignedCertificate(
                keyPair,
                TEST_ALIAS_1,
                ""EC"",
                224,
                certSubject,
                certSerialNumber,
                certNotBefore,
                certNotAfter);
        TestUtils.assertECParameterSpecEqualsIgnoreSeedIfNotPresent(
                ECCurves.NIST_P_224_SPEC, ((ECKey) keyPair.getPrivate()).getParams());
        KeyInfo keyInfo = TestUtils.getKeyInfo(keyPair.getPrivate());
        assertEquals(224, keyInfo.getKeySize());
        assertEquals(TEST_ALIAS_1, keyInfo.getKeystoreAlias());
        assertOneOf(keyInfo.getOrigin(),
                KeyProperties.ORIGIN_GENERATED, KeyProperties.ORIGIN_UNKNOWN);
        assertEquals(
                KeyProperties.PURPOSE_SIGN | KeyProperties.PURPOSE_VERIFY
                        | KeyProperties.PURPOSE_ENCRYPT,
                keyInfo.getPurposes());
        assertEquals(keyValidityStart, keyInfo.getKeyValidityStart());
        assertEquals(keyValidityEndDateForOrigination, keyInfo.getKeyValidityForOriginationEnd());
        assertEquals(keyValidityEndDateForConsumption, keyInfo.getKeyValidityForConsumptionEnd());
        MoreAsserts.assertEmpty(Arrays.asList(keyInfo.getBlockModes()));

        List<String> actualDigests = new ArrayList<String>(Arrays.asList(keyInfo.getDigests()));
        // Keystore may have added DIGEST_NONE, to allow software digesting.
        actualDigests.remove(KeyProperties.DIGEST_NONE);
        TestUtils.assertContentsInAnyOrder(
                actualDigests, KeyProperties.DIGEST_SHA384, KeyProperties.DIGEST_SHA512);

        MoreAsserts.assertEmpty(Arrays.asList(keyInfo.getSignaturePaddings()));
        MoreAsserts.assertEmpty(Arrays.asList(keyInfo.getEncryptionPaddings()));
        assertFalse(keyInfo.isUserAuthenticationRequired());
        assertEquals(0, keyInfo.getUserAuthenticationValidityDurationSeconds());
    }

    // Strongbox has more restrictions on key properties than general keystore.
    // This is a reworking of the generic test to still be as custom as possible while
    // respecting the spec constraints.
    // Test fails until the resolution of b/113276806"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.keystore.cts.KeyPairGeneratorTest"	"testGenerate_RSA_ModernSpec_AsCustomAsPossible"	"CtsKeystoreTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/keystore/src/android/keystore/cts/KeyPairGeneratorTest.java"	""	"public void testGenerate_RSA_ModernSpec_AsCustomAsPossible() throws Exception {
        KeyPairGenerator generator = getRsaGenerator();
        Date keyValidityStart = new Date(System.currentTimeMillis());
        Date keyValidityEndDateForOrigination = new Date(System.currentTimeMillis() + 1000000);
        Date keyValidityEndDateForConsumption = new Date(System.currentTimeMillis() + 10000000);

        Date certNotBefore = new Date(System.currentTimeMillis() - 1000L * 60 * 60 * 24 * 210);
        Date certNotAfter = new Date(System.currentTimeMillis() + 1000L * 60 * 60 * 24 * 210);
        BigInteger certSerialNumber = new BigInteger(""1234567890"");
        X500Principal certSubject = new X500Principal(""cn=hello2"");
        generator.initialize(new KeyGenParameterSpec.Builder(
                TEST_ALIAS_1,
                KeyProperties.PURPOSE_SIGN | KeyProperties.PURPOSE_VERIFY
                        | KeyProperties.PURPOSE_ENCRYPT)
                .setAlgorithmParameterSpec(
                        new RSAKeyGenParameterSpec(3072, RSAKeyGenParameterSpec.F0))
                .setKeySize(3072)
                .setDigests(KeyProperties.DIGEST_SHA384, KeyProperties.DIGEST_SHA512)
                .setSignaturePaddings(KeyProperties.SIGNATURE_PADDING_RSA_PSS,
                        KeyProperties.SIGNATURE_PADDING_RSA_PKCS1)
                .setBlockModes(KeyProperties.BLOCK_MODE_ECB)
                .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_RSA_OAEP,
                        KeyProperties.ENCRYPTION_PADDING_RSA_PKCS1)
                .setKeyValidityStart(keyValidityStart)
                .setKeyValidityForOriginationEnd(keyValidityEndDateForOrigination)
                .setKeyValidityForConsumptionEnd(keyValidityEndDateForConsumption)
                .setCertificateSerialNumber(certSerialNumber)
                .setCertificateSubject(certSubject)
                .setCertificateNotBefore(certNotBefore)
                .setCertificateNotAfter(certNotAfter)
                .build());
        KeyPair keyPair = generator.generateKeyPair();
        assertGeneratedKeyPairAndSelfSignedCertificate(
                keyPair,
                TEST_ALIAS_1,
                ""RSA"",
                3072,
                certSubject,
                certSerialNumber,
                certNotBefore,
                certNotAfter);
        assertEquals(RSAKeyGenParameterSpec.F0,
                ((RSAPublicKey) keyPair.getPublic()).getPublicExponent());
        KeyInfo keyInfo = TestUtils.getKeyInfo(keyPair.getPrivate());
        assertEquals(3072, keyInfo.getKeySize());
        assertEquals(TEST_ALIAS_1, keyInfo.getKeystoreAlias());
        assertOneOf(keyInfo.getOrigin(),
                KeyProperties.ORIGIN_GENERATED, KeyProperties.ORIGIN_UNKNOWN);
        assertEquals(
                KeyProperties.PURPOSE_SIGN | KeyProperties.PURPOSE_VERIFY
                        | KeyProperties.PURPOSE_ENCRYPT,
                keyInfo.getPurposes());
        assertEquals(keyValidityStart, keyInfo.getKeyValidityStart());
        assertEquals(keyValidityEndDateForOrigination, keyInfo.getKeyValidityForOriginationEnd());
        assertEquals(keyValidityEndDateForConsumption, keyInfo.getKeyValidityForConsumptionEnd());

        List<String> actualDigests =
     new ArrayList<String>(Arrays.asList(keyInfo.getDigests()));
        // Keystore may have added DIGEST_NONE, to allow software digesting.
        actualDigests.remove(KeyProperties.DIGEST_NONE);
        TestUtils.assertContentsInAnyOrder(
                actualDigests, KeyProperties.DIGEST_SHA384, KeyProperties.DIGEST_SHA512);

        TestUtils.assertContentsInAnyOrder(Arrays.asList(keyInfo.getSignaturePaddings()),
                KeyProperties.SIGNATURE_PADDING_RSA_PKCS1,
                KeyProperties.SIGNATURE_PADDING_RSA_PSS);
        MoreAsserts.assertContentsInAnyOrder(Arrays.asList(keyInfo.getBlockModes()),
                KeyProperties.BLOCK_MODE_ECB);

        List<String> actualEncryptionPaddings =
                new ArrayList<String>(Arrays.asList(keyInfo.getEncryptionPaddings()));
        // Keystore may have added ENCRYPTION_PADDING_NONE, to allow software padding.
        actualEncryptionPaddings.remove(KeyProperties.ENCRYPTION_PADDING_NONE);
        TestUtils.assertContentsInAnyOrder(actualEncryptionPaddings,
                KeyProperties.ENCRYPTION_PADDING_RSA_OAEP,
                KeyProperties.ENCRYPTION_PADDING_RSA_PKCS1);

        assertFalse(keyInfo.isUserAuthenticationRequired());
        assertEquals(0, keyInfo.getUserAuthenticationValidityDurationSeconds());
    }

    // Strongbox has more restrictions on key properties than general keystore.
    // This is a reworking of the generic test to still be as custom as possible while
    // respecting the spec constraints.
    // Test fails until the resolution of b/113276806"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.keystore.cts.KeyPairGeneratorTest"	"testGenerate_RSA_IndCpaEnforced"	"CtsKeystoreTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/keystore/src/android/keystore/cts/KeyPairGeneratorTest.java"	""	"public void testGenerate_RSA_IndCpaEnforced() throws Exception {
        testGenerate_RSA_IndCpaEnforcedHelper(false /* useStrongbox */);
        if (TestUtils.hasStrongBox(getContext())) {
            testGenerate_RSA_IndCpaEnforcedHelper(true /* useStrongbox */);
        }
    }

    private void testGenerate_RSA_IndCpaEnforcedHelper(boolean useStrongbox) throws Exception {
        KeyGenParameterSpec.Builder goodBuilder = new KeyGenParameterSpec.Builder(
                TEST_ALIAS_1, KeyProperties.PURPOSE_ENCRYPT)
                .setIsStrongBoxBacked(useStrongbox)
                .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_RSA_OAEP,
                        KeyProperties.ENCRYPTION_PADDING_RSA_PKCS1);
        assertKeyGenInitSucceeds(""RSA"", goodBuilder.build());

        // Should be fine because IND-CPA restriction applies only to encryption keys
        assertKeyGenInitSucceeds(""RSA"",
                TestUtils.buildUpon(goodBuilder, KeyProperties.PURPOSE_DECRYPT)
                        .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE)
                        .build());

        assertKeyGenInitThrowsInvalidAlgorithmParameterException(""RSA"",
                TestUtils.buildUpon(goodBuilder)
                        .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE)
                        .build());

        assertKeyGenInitSucceeds(""RSA"",
                TestUtils.buildUpon(goodBuilder)
                        .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE)
                        .setRandomizedEncryptionRequired(false)
                        .build());

        // Should fail because PKCS#7 padding doesn't work with RSA
        assertKeyGenInitThrowsInvalidAlgorithmParameterException(""RSA"",
                TestUtils.buildUpon(goodBuilder)
                        .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_PKCS7)
                        .build());
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.keystore.cts.KeyPairGeneratorTest"	"testGenerate_EC_IndCpaEnforced"	"CtsKeystoreTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/keystore/src/android/keystore/cts/KeyPairGeneratorTest.java"	""	"public void testGenerate_EC_IndCpaEnforced() throws Exception {
        testGenerate_EC_IndCpaEnforcedHelper(false /* useStrongbox */);
        if (TestUtils.hasStrongBox(getContext())) {
            testGenerate_EC_IndCpaEnforcedHelper(true /* useStrongbox */);
        }
    }

    public void testGenerate_EC_IndCpaEnforcedHelper(boolean useStrongbox) throws Exception {
        KeyGenParameterSpec.Builder goodBuilder = new KeyGenParameterSpec.Builder(
                TEST_ALIAS_2, KeyProperties.PURPOSE_ENCRYPT)
                .setIsStrongBoxBacked(useStrongbox);
        assertKeyGenInitSucceeds(""EC"", goodBuilder.build());

        // Should be fine because IND-CPA restriction applies only to encryption keys
        assertKeyGenInitSucceeds(""EC"",
                TestUtils.buildUpon(goodBuilder, KeyProperties.PURPOSE_DECRYPT)
                        .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE)
                        .build());

        assertKeyGenInitThrowsInvalidAlgorithmParameterException(""EC"",
                TestUtils.buildUpon(goodBuilder)
                        .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE)
                        .build());

        assertKeyGenInitSucceeds(""EC"",
                TestUtils.buildUpon(goodBuilder)
                        .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE)
                        .setRandomizedEncryptionRequired(false)
                        .build());
    }

    // http://b/28384942"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.SecurityLoggingTest"	"testVerifyGeneratedLogs"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/SecurityLoggingTest.java"	""	"public void testVerifyGeneratedLogs() throws Exception {
        forceSecurityLogs();

        final List<SecurityEvent> events = getEvents();

        verifyAutomaticEventsPresent(events);
        verifyKeystoreEventsPresent(events);
        verifyKeyChainEventsPresent(events);
        verifyAdminEventsPresent(events);
        verifyAdbShellCommand(events); // Event generated from host side logic
        if (mDevicePolicyManager.isOrganizationOwnedDeviceWithManagedProfile()) {
            verifyEventsRedacted(events);
        }
    }

    private void forceSecurityLogs() throws Exception {
        UiDevice.getInstance(InstrumentationRegistry.getInstrumentation())
                .executeShellCommand(""dpm force-security-logs"");
    }

    private void verifyAutomaticEventsPresent(List<SecurityEvent> events) {
        verifyOsStartupEventPresent(events);
        verifyLoggingStartedEventPresent(events);
        verifyCryptoSelfTestEventPresent(events);
    }

    private void verifyKeyChainEventsPresent(List<SecurityEvent> events) {
        verifyCertInstalledEventPresent(events);
        verifyCertUninstalledEventPresent(events);
    }

    private void verifyKeystoreEventsPresent(List<SecurityEvent> events) {
        verifyKeyGeneratedEventPresent(events, GENERATED_KEY_ALIAS);
        verifyKeyDeletedEventPresent(events, GENERATED_KEY_ALIAS);
        verifyKeyImportedEventPresent(events, IMPORTED_KEY_ALIAS);
        verifyKeyDeletedEventPresent(events, IMPORTED_KEY_ALIAS);
    }

    private void verifyAdminEventsPresent(List<SecurityEvent> events) {
        if (mHasSecureLockScreen) {
            verifyPasswordComplexityEventsPresent(events);
            verifyNewStylePasswordComplexityEventPresent(events);
        }
        verifyLockingPolicyEventsPresent(events);
        verifyUserRestrictionEventsPresent(events);
        verifyCameraPolicyEvents(events);
    }
    private void verifyAdbShellCommand(List<SecurityEvent> events) {
        // Won't be able to locate the command on org-owned devices, as it will be redacted.
        if (!mDevicePolicyManager.isOrganizationOwnedDeviceWithManagedProfile()) {
            findEvent(""adb command"", events,
                    e -> e.getTag() == TAG_ADB_SHELL_CMD &&
                            e.getData().equals(""whoami""));

        }
    }

    private void verifyEventsRedacted(List<SecurityEvent> events) {
        final int userId = Process.myUserHandle().getIdentifier();
        for (SecurityEvent event : events) {
            switch (event.getTag()) {
                case TAG_ADB_SHELL_CMD:
                    assertTrue(TextUtils.isEmpty((String) event.getData()));
                    break;
                case TAG_APP_PROCESS_START:
                case TAG_KEY_GENERATED:
                case TAG_KEY_IMPORT:
                case TAG_KEY_DESTRUCTION:
                    assertEquals(userId, UserHandle.getUserId(getInt(event, UID_INDEX)));
                    break;
                case TAG_CERT_AUTHORITY_INSTALLED:
                case TAG_CERT_AUTHORITY_REMOVED:
                    assertEquals(userId, getInt(event, USERID_INDEX));
                    break;
                case TAG_KEY_INTEGRITY_VIOLATION:
                    assertEquals(userId, UserHandle.getUserId(getInt(event, 1)));
                    break;
            }
        }
    }

    /**
     * Generates events for positive test cases.
     */"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.SecurityLoggingTest"	"testGenerateLogs"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/SecurityLoggingTest.java"	""	"public void testGenerateLogs() throws Exception {
        generateKeystoreEvents();
        generateKeyChainEvents();
        generateAdminEvents();
    }

    private void generateKeyChainEvents() {
        installCaCert();
        uninstallCaCert();
    }

    private void generateKeystoreEvents() throws Exception {
        generateKey(GENERATED_KEY_ALIAS);
        deleteKey(GENERATED_KEY_ALIAS);
        importKey(IMPORTED_KEY_ALIAS);
        deleteKey(IMPORTED_KEY_ALIAS);
    }

    private void generateAdminEvents() {
        if (mHasSecureLockScreen) {
            generatePasswordComplexityEvents();
            generateNewStylePasswordComplexityEvents();
        }
        generateLockingPolicyEvents();
        generateUserRestrictionEvents();
        generateCameraPolicyEvents();
    }

    /**
     * Fetches and checks the events.
     */
    private List<SecurityEvent> getEvents() throws Exception {
        List<SecurityEvent> events = null;
        // Retry once after seeping for 1 second, in case ""dpm force-security-logs"" hasn't taken
        // effect just yet.
        for (int i = 0; i < 2 && events == null; i++) {
            events = mDevicePolicyManager.retrieveSecurityLogs(ADMIN_RECEIVER_COMPONENT);
            Log.v(TAG, ""getEvents(), batch #"" + i + "": ""  + (events == null ? -1 : events.size())
                    + "" events"");
            if (events == null) sleep(1000);
        }

        Log.d(TAG, ""getEvents(): received "" + events.size() + "" events"");
        if (VERBOSE) dumpSecurityLogs(events);

        try {
            verifySecurityLogs(events);
        } catch (AssertionFailedError e) {
            dumpSecurityLogs(events);
            throw e;
        }

        return events;
    }

    /**
     * Test: check that there are no gaps between ids in two consecutive batches. Shared preference
     * is used to store these numbers between test invocations.
     */"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.SecurityLoggingTest"	"testSetDelegateScope_noDelegation"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/SecurityLoggingTest.java"	""	"public void testSetDelegateScope_noDelegation() {
        mDevicePolicyManager.setDelegatedScopes(ADMIN_RECEIVER_COMPONENT, DELEGATE_APP_PKG,
                Arrays.asList());

        assertThat(mDevicePolicyManager.getDelegatedScopes(
                ADMIN_RECEIVER_COMPONENT, DELEGATE_APP_PKG))
                .doesNotContain(DELEGATION_SECURITY_LOGGING);
    }

    private void generateKey(String keyAlias) throws Exception {
        final KeyPairGenerator generator = KeyPairGenerator.getInstance(""RSA"", ""AndroidKeyStore"");
        generator.initialize(
                new KeyGenParameterSpec.Builder(keyAlias, KeyProperties.PURPOSE_SIGN).build());
        final KeyPair keyPair = generator.generateKeyPair();
        assertNotNull(keyPair);
    }

    private void verifyKeyGeneratedEventPresent(List<SecurityEvent> events, String alias) {
        findEvent(""key generated"", events,
                e -> e.getTag() == TAG_KEY_GENERATED
                        && getInt(e, SUCCESS_INDEX) == SUCCESS_VALUE
                        && getString(e, ALIAS_INDEX).contains(alias)
                        && getInt(e, UID_INDEX) == Process.myUid());
    }

    private void importKey(String alias) throws Exception{
        final KeyStore ks = KeyStore.getInstance(""AndroidKeyStore"");
        ks.load(null);
        ks.setEntry(alias, new KeyStore.SecretKeyEntry(new SecretKeySpec(new byte[32], ""AES"")),
                new KeyProtection.Builder(KeyProperties.PURPOSE_ENCRYPT).build());
    }

    private void verifyKeyImportedEventPresent(List<SecurityEvent> events, String alias) {
        findEvent(""key imported"", events,
                e -> e.getTag() == TAG_KEY_IMPORT
                        && getInt(e, SUCCESS_INDEX) == SUCCESS_VALUE
                        && getString(e, ALIAS_INDEX).contains(alias)
                        && getInt(e, UID_INDEX) == Process.myUid());
    }

    private void deleteKey(String keyAlias) throws Exception {
        final KeyStore ks = KeyStore.getInstance(""AndroidKeyStore"");
        ks.load(null);
        ks.deleteEntry(keyAlias);
    }

    private void verifyKeyDeletedEventPresent(List<SecurityEvent> events, String alias) {
        findEvent(""key deleted"", events,
                e -> e.getTag() == TAG_KEY_DESTRUCTION
                        && getInt(e, SUCCESS_INDEX) == SUCCESS_VALUE
                        && getString(e, ALIAS_INDEX).contains(alias)
                        && getInt(e, UID_INDEX) == Process.myUid());
    }

    private void installCaCert() {
        assertTrue(
                mDevicePolicyManager.installCaCert(ADMIN_RECEIVER_COMPONENT, TEST_CA.getBytes()));
    }

    private void verifyCertInstalledEventPresent(List<SecurityEvent> events) {
        findEvent(""cert authority installed"", events,
                e -> e.getTag() == TAG_CERT_AUTHORITY_INSTALLED
                        && getInt(e, SUCCESS_INDEX) == SUCCESS_VALUE
                        && getString(e, SUBJECT_INDEX).equals(TEST_CA_SUBJECT));
    }

    private void uninstallCaCert() {
        mDevicePolicyManager.uninstallCaCert(ADMIN_RECEIVER_COMPONENT, TEST_CA.getBytes());
    }

    private void verifyCertUninstalledEventPresent(List<SecurityEvent> events) {
        findEvent(""cert authority removed"", events,
                e -> e.getTag() == TAG_CERT_AUTHORITY_REMOVED
                        && getInt(e, SUCCESS_INDEX) == SUCCESS_VALUE
                        && getString(e, SUBJECT_INDEX).equals(TEST_CA_SUBJECT));
    }

    private void generatePasswordComplexityEvents() {
        DevicePolicyManager dpm = getDpmToGenerateEvents();

        dpm.setPasswordQuality(ADMIN_RECEIVER_COMPONENT, PASSWORD_QUALITY_COMPLEX);
        dpm.setPasswordMinimumLength(ADMIN_RECEIVER_COMPONENT, TEST_PWD_LENGTH);
        dpm.setPasswordMinimumLetters(ADMIN_RECEIVER_COMPONENT, TEST_PWD_CHARS);
        dpm.setPasswordMinimumNonLetter(ADMIN_RECEIVER_COMPONENT, TEST_PWD_CHARS);
        dpm.setPasswordMinimumUpperCase(ADMIN_RECEIVER_COMPONENT, TEST_PWD_CHARS);
        dpm.setPasswordMinimumLowerCase(ADMIN_RECEIVER_COMPONENT, TEST_PWD_CHARS);
        dpm.setPasswordMinimumNumeric(ADMIN_RECEIVER_COMPONENT, TEST_PWD_CHARS);
        dpm.setPasswordMinimumSymbols(ADMIN_RECEIVER_COMPONENT, TEST_PWD_CHARS);
    }

    private void generateNewStylePasswordComplexityEvents() {
        DevicePolicyManager dpm = getDpmToGenerateEvents();

        dpm.setRequiredPasswordComplexity(PASSWORD_COMPLEXITY_HIGH);
    }

    private void verifyPasswordComplexityEventsPresent(List<SecurityEvent> events) {
        final int userId = Process.myUserHandle().getIdentifier();
        // This reflects default values for password complexity event payload fields.
        final Object[] expectedPayload = new Object[] {
                ADMIN_RECEIVER_COMPONENT.getPackageName(), // admin package
                userId,                    // admin user
                userId,                    // target user
                0,                         // default password length
                0,                         // default password quality
                1,                         // default min letters
                0,                         // default min non-letters
                1,                         // default min numeric
                0,                         // default min uppercase
                0,                         // default min lowercase
                1,                         // default min symbols
        };

        // The order should be consistent with the order in generatePasswordComplexityEvents(), so
        // that the expected values change in the same sequence as when setting password policies.
        expectedPayload[PWD_QUALITY_INDEX] = PASSWORD_QUALITY_COMPLEX;
        findPasswordComplexityEvent(""set pwd quality"", events, expectedPayload);
        expectedPayload[PWD_LEN_INDEX] = TEST_PWD_LENGTH;
        findPasswordComplexityEvent(""set pwd length"", events, expectedPayload);
        expectedPayload[LETTERS_INDEX] = TEST_PWD_CHARS;
        findPasswordComplexityEvent(""set pwd min letters"", events, expectedPayload);
        expectedPayload[NON_LETTERS_INDEX] = TEST_PWD_CHARS;
        findPasswordComplexityEvent(""set pwd min non-letters"", events, expectedPayload);
        expectedPayload[UPPERCASE_INDEX] = TEST_PWD_CHARS;
        findPasswordComplexityEvent(""set pwd min uppercase"", events, expectedPayload);
        expectedPayload[LOWERCASE_INDEX] = TEST_PWD_CHARS;
        findPasswordComplexityEvent(""set pwd min lowercase"", events, expectedPayload);
        expectedPayload[NUMERIC_INDEX] = TEST_PWD_CHARS;
        findPasswordComplexityEvent(""set pwd min numeric"", events, expectedPayload);
        expectedPayload[SYMBOLS_INDEX] = TEST_PWD_CHARS;
        findPasswordComplexityEvent(""set pwd min symbols"", events, expectedPayload);
    }

    private void verifyNewStylePasswordComplexityEventPresent(List<SecurityEvent> events) {
        final int userId = Process.myUserHandle().getIdentifier();
        // This reflects default values for password complexity event payload fields.
        final Object[] expectedPayload = new Object[] {
                ADMIN_RECEIVER_COMPONENT.getPackageName(), // admin package
                userId,                    // admin user
                userId,                    // target user
                PASSWORD_COMPLEXITY_HIGH   // password complexity
        };

        findNewStylePasswordComplexityEvent(""require password complexity"", events, expectedPayload);
    }

    private void generateLockingPolicyEvents() {
        DevicePolicyManager dpm = mContext.getSystemService(DevicePolicyManager.class);

        if (mHasSecureLockScreen) {
            dpm.setPasswordExpirationTimeout(ADMIN_RECEIVER_COMPONENT, TEST_PWD_EXPIRATION_TIMEOUT);
            dpm.setPasswordHistoryLength(ADMIN_RECEIVER_COMPONENT, TEST_PWD_HISTORY_LENGTH);
            dpm.setMaximumFailedPasswordsForWipe(ADMIN_RECEIVER_COMPONENT, TEST_PWD_MAX_ATTEMPTS);
        }
        dpm.setKeyguardDisabledFeatures(ADMIN_RECEIVER_COMPONENT,
                KEYGUARD_DISABLE_FINGERPRINT);
        dpm.setMaximumTimeToLock(ADMIN_RECEIVER_COMPONENT, TEST_MAX_TIME_TO_LOCK);
        dpm.lockNow();
    }

    private void verifyLockingPolicyEventsPresent(List<SecurityEvent> events) {
        final int userId = Process.myUserHandle().getIdentifier();
        final String packageName = ADMIN_RECEIVER_COMPONENT.getPackageName();
        if (mHasSecureLockScreen) {
            findEvent(""set password expiration"", events,
                    e -> e.getTag() == TAG_PASSWORD_EXPIRATION_SET &&
                            getString(e, ADMIN_PKG_INDEX).equals(packageName) &&
                            getInt(e, ADMIN_USER_INDEX) == userId &&
                            getInt(e, TARGET_USER_INDEX) == userId &&
                            getLong(e, PWD_EXPIRATION_INDEX) == TEST_PWD_EXPIRATION_TIMEOUT);

            findEvent(""set password history length"", events,
                    e -> e.getTag() == TAG_PASSWORD_HISTORY_LENGTH_SET &&
                            getString(e, ADMIN_PKG_INDEX).equals(packageName) &&
                            getInt(e, ADMIN_USER_INDEX) == userId &&
                            getInt(e, TARGET_USER_INDEX) == userId &&
                            getInt(e, PWD_HIST_LEN_INDEX) == TEST_PWD_HISTORY_LENGTH);

            findEvent(""set password attempts"", events,
                    e -> e.getTag() == TAG_MAX_PASSWORD_ATTEMPTS_SET &&
                            getString(e, ADMIN_PKG_INDEX).equals(packageName) &&
                            getInt(e, ADMIN_USER_INDEX) == userId &&
                            getInt(e, TARGET_USER_INDEX) == userId &&
                            getInt(e, MAX_PWD_ATTEMPTS_INDEX) == TEST_PWD_MAX_ATTEMPTS);
        }

        findEvent(""set keyguard disabled features"", events,
                e -> e.getTag() == TAG_KEYGUARD_DISABLED_FEATURES_SET &&
                        getString(e, ADMIN_PKG_INDEX).equals(packageName) &&
                        getInt(e, ADMIN_USER_INDEX) == userId &&
                        getInt(e, TARGET_USER_INDEX) == userId &&
                        getInt(e, KEYGUARD_FEATURES_INDEX) == KEYGUARD_DISABLE_FINGERPRINT);

        findEvent(""set screen lock timeout"", events,
                e -> e.getTag() == TAG_MAX_SCREEN_LOCK_TIMEOUT_SET &&
                        getString(e, ADMIN_PKG_INDEX).equals(packageName) &&
                        getInt(e, ADMIN_USER_INDEX) == userId &&
                        getInt(e, TARGET_USER_INDEX) == userId &&
                        getLong(e, MAX_SCREEN_TIMEOUT_INDEX) == TEST_MAX_TIME_TO_LOCK);

        findEvent(""set screen lock timeout"", events,
                e -> e.getTag() == TAG_REMOTE_LOCK &&
                        getString(e, ADMIN_PKG_INDEX).equals(packageName) &&
                        getInt(e, ADMIN_USER_INDEX) == userId);
    }

    private void findPasswordComplexityEvent(
            String description, List<SecurityEvent> events, Object[] expectedPayload) {
        findEvent(description, events,
                byTagAndPayload(TAG_PASSWORD_COMPLEXITY_SET, expectedPayload));
    }

    private void findNewStylePasswordComplexityEvent(
            String description, List<SecurityEvent> events, Object[] expectedPayload) {
        findEvent(description, events,
                byTagAndPayload(TAG_PASSWORD_COMPLEXITY_REQUIRED, expectedPayload));
    }

    private Predicate<SecurityEvent> byTagAndPayload(int expectedTag, Object[] expectedPayload) {
        return (event) -> {
            boolean tagMatch = event.getTag() == expectedTag;
            if (!tagMatch) return false;

            Object[] payload = (Object[]) event.getData();
            boolean payloadMatch = Arrays.equals(payload, expectedPayload);

            if (!payloadMatch) {
                Log.w(TAG, ""Found event (id="" + event.getId() + "") with tag ""
                        + eventLogtoString(event.getTag()) + "", but invalid payload: ""
                        + ""expected="" + Arrays.toString(expectedPayload)
                        + "", actual="" + Arrays.toString(payload));
            } else if (VERBOSE) {
                Log.v(TAG, ""Found event (id="" + event.getId() + "") with tag ""
                        + eventLogtoString(event.getTag()) + "", and expected payload (""
                        + Arrays.toString(payload) + "")"");
            }
            return payloadMatch;
        };
    }

    private void generateUserRestrictionEvents() {
        DevicePolicyManager dpm = getDpmToGenerateEvents();

        dpm.addUserRestriction(ADMIN_RECEIVER_COMPONENT, UserManager.DISALLOW_PRINTING);
        dpm.clearUserRestriction(ADMIN_RECEIVER_COMPONENT, UserManager.DISALLOW_PRINTING);
    }

    private void verifyUserRestrictionEventsPresent(List<SecurityEvent> events) {
        findUserRestrictionEvent(""set user restriction"", events, TAG_USER_RESTRICTION_ADDED);
        findUserRestrictionEvent(""clear user restriction"", events, TAG_USER_RESTRICTION_REMOVED);
    }

    private void findUserRestrictionEvent(String description, List<SecurityEvent> events, int tag) {
        final int userId = Process.myUserHandle().getIdentifier();
        findEvent(description, events,
                e -> e.getTag() == tag &&
                        getString(e, ADMIN_PKG_INDEX).equals(
                                ADMIN_RECEIVER_COMPONENT.getPackageName()) &&
                        getInt(e, ADMIN_USER_INDEX) == userId &&
                        UserManager.DISALLOW_PRINTING.equals(getString(e, USER_RESTRICTION_INDEX)));
    }

    private void generateCameraPolicyEvents() {
        DevicePolicyManager dpm = getDpmToGenerateEvents();

        dpm.setCameraDisabled(ADMIN_RECEIVER_COMPONENT, true);
        dpm.setCameraDisabled(ADMIN_RECEIVER_COMPONENT, false);
    }

    private void verifyCameraPolicyEvents(List<SecurityEvent> events) {
        final int userId = Process.myUserHandle().getIdentifier();

        findEvent(""set camera disabled"", events,
                e -> e.getTag() == TAG_CAMERA_POLICY_SET &&
                        getString(e, ADMIN_PKG_INDEX).equals(
                                ADMIN_RECEIVER_COMPONENT.getPackageName()) &&
                        getInt(e, ADMIN_USER_INDEX) == userId &&
                        getInt(e, TARGET_USER_INDEX) == userId &&
                        getInt(e, CAMERA_DISABLED_INDEX) == 1);

        findEvent(""set camera enabled"", events,
                e -> e.getTag() == TAG_CAMERA_POLICY_SET &&
                        getString(e, ADMIN_PKG_INDEX).equals(
                                ADMIN_RECEIVER_COMPONENT.getPackageName()) &&
                        getInt(e, ADMIN_USER_INDEX) == userId &&
                        getInt(e, TARGET_USER_INDEX) == userId &&
                        getInt(e, CAMERA_DISABLED_INDEX) == 0);
    }

    private DevicePolicyManager getDpmToGenerateEvents() {
        // It must use the dpm for the current user, as mDevicePolicyManager tunnels the calls to
        // the device owner user on headless system user, which would cause a mismatch in the events
        return mContext.getSystemService(DevicePolicyManager.class);
    }

    private static String eventLogtoString(int log) {
        return DebugUtils.constantToString(SecurityLog.class, ""TAG_"", log);
    }

    private static String toString(SecurityEvent event) {
        return ""Event[id="" + event.getId() + "",tag="" + eventLogtoString(event.getTag()) + ""]"";
    }

    private void dumpSecurityLogs(List<SecurityEvent> events) {
        Log.d(TAG, ""Security events dump ("" + events.size() + "" events):"");
        events.forEach((event) -> Log.d(TAG, toString(event)));
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.ApplicationRestrictionsIsCallerDelegateHelper"	"isCallerApplicationRestrictionsManagingPackage"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/ApplicationRestrictionsIsCallerDelegateHelper.java"	""	"public void test/*
 *.
 */
package com.android.cts.deviceandprofileowner;

import static com.google.common.truth.Truth.assertThat;

import android.app.admin.DevicePolicyManager;
import android.content.pm.PackageManager.NameNotFoundException;
import android.test.InstrumentationTestCase;

/**
 * Helper to set app restriction managing package for
 * {@link DevicePolicyManager#isCallerApplicationRestrictionsManagingPackage()}.
 * <p>The method name starts with ""test"" to be recognized by {@link InstrumentationTestCase}.
 */
public class ApplicationRestrictionsIsCallerDelegateHelper extends BaseDeviceAdminTest {

    private static final String APP_RESTRICTIONS_TARGET_PKG = ""com.android.cts.delegate"";"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.ApplicationRestrictionsIsCallerDelegateHelper"	"testSetApplicationRestrictionsManagingPackageToDelegate"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/ApplicationRestrictionsIsCallerDelegateHelper.java"	""	"public void testSetApplicationRestrictionsManagingPackageToDelegate()
            throws NameNotFoundException {
        mDevicePolicyManager.setApplicationRestrictionsManagingPackage(
            ADMIN_RECEIVER_COMPONENT, APP_RESTRICTIONS_TARGET_PKG);
        assertThat(APP_RESTRICTIONS_TARGET_PKG)
            .isEqualTo(mDevicePolicyManager.getApplicationRestrictionsManagingPackage(
                ADMIN_RECEIVER_COMPONENT));
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.camera.its.ItsService"	"doCheckSensorExistence"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/camera/its/ItsService.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.camera.its;

import android.app.Notification;
import android.app.NotificationChannel;
import android.app.NotificationManager;
import android.app.Service;
import android.content.Context;
import android.content.Intent;
import android.content.pm.ServiceInfo;
import android.graphics.ImageFormat;
import android.graphics.Rect;
import android.hardware.SensorPrivacyManager;
import android.hardware.camera2.CameraCaptureSession;
import android.hardware.camera2.CameraAccessException;
import android.hardware.camera2.CameraCharacteristics;
import android.hardware.camera2.CameraDevice;
import android.hardware.camera2.CameraManager;
import android.hardware.camera2.CaptureFailure;
import android.hardware.camera2.CaptureRequest;
import android.hardware.camera2.CaptureResult;
import android.hardware.camera2.DngCreator;
import android.hardware.camera2.TotalCaptureResult;
import android.hardware.camera2.cts.PerformanceTest;
import android.hardware.camera2.params.InputConfiguration;
import android.hardware.camera2.params.MeteringRectangle;
import android.hardware.camera2.params.OutputConfiguration;
import android.hardware.camera2.params.SessionConfiguration;
import android.hardware.Sensor;
import android.hardware.SensorEvent;
import android.hardware.SensorEventListener;
import android.hardware.SensorManager;
import android.media.AudioAttributes;
import android.media.Image;
import android.media.ImageReader;
import android.media.ImageWriter;
import android.media.Image.Plane;
import android.net.Uri;
import android.os.Build;
import android.os.Bundle;
import android.os.ConditionVariable;
import android.os.Handler;
import android.os.HandlerThread;
import android.os.IBinder;
import android.os.Message;
import android.os.SystemClock;
import android.os.Vibrator;
import android.util.Log;
import android.util.Rational;
import android.util.Size;
import android.util.SparseArray;
import android.view.Surface;

import androidx.test.InstrumentationRegistry;

import com.android.ex.camera2.blocking.BlockingCameraManager;
import com.android.ex.camera2.blocking.BlockingCameraManager.BlockingOpenException;
import com.android.ex.camera2.blocking.BlockingStateCallback;
import com.android.ex.camera2.blocking.BlockingSessionCallback;

import com.android.compatibility.common.util.ReportLog.Metric;
import com.android.cts.verifier.camera.its.StatsImage;
import com.android.cts.verifier.camera.performance.CameraTestInstrumentation;
import com.android.cts.verifier.camera.performance.CameraTestInstrumentation.MetricListener;
import com.android.cts.verifier.R;

import org.json.JSONArray;
import org.json.JSONObject;
import org.junit.runner.JUnitCore;
import org.junit.runner.Request;
import org.junit.runner.Result;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.math.BigInteger;
import java.net.ServerSocket;
import java.net.Socket;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.FloatBuffer;
import java.nio.charset.Charset;
import java.security.MessageDigest;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executor;
import java.util.concurrent.LinkedBlockingDeque;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

public class ItsService extends Service implements SensorEventListener {
    public static final String TAG = ItsService.class.getSimpleName();

    // Version number to keep host/server communication in sync
    // This string must be in sync with python side device.py
    // Updated when interface between script and ItsService is changed
    private final String ITS_SERVICE_VERSION = ""1.0"";

    private final int SERVICE_NOTIFICATION_ID = 37; // random int that is unique within app
    private NotificationChannel mChannel;

    // Timeouts, in seconds.
    private static final int TIMEOUT_CALLBACK = 20;
    private static final int TIMEOUT_3A = 10;

    // Time given for background requests to warm up pipeline
    private static final long PIPELINE_WARMUP_TIME_MS = 2000;

    // State transition timeouts, in ms.
    private static final long TIMEOUT_IDLE_MS = 2000;
    private static final long TIMEOUT_STATE_MS = 500;
    private static final long TIMEOUT_SESSION_CLOSE = 3000;

    // Timeout to wait for a capture result after the capture buffer has arrived, in ms.
    private static final long TIMEOUT_CAP_RES = 2000;

    private static final int MAX_CONCURRENT_READER_BUFFERS = 10;

    // Supports at most RAW+YUV+JPEG, one surface each, plus optional background stream
    private static final int MAX_NUM_OUTPUT_SURFACES = 4;

    // Performance class R version number
    private static final int PERFORMANCE_CLASS_R = Build.VERSION_CODES.R;
    // Performance class S version number
    private static final int PERFORMANCE_CLASS_S = Build.VERSION_CODES.R + 1;

    public static final int SERVERPORT = 6000;

    public static final String REGION_KEY = ""regions"";
    public static final String REGION_AE_KEY = ""ae"";
    public static final String REGION_AWB_KEY = ""awb"";
    public static final String REGION_AF_KEY = ""af"";
    public static final String LOCK_AE_KEY = ""aeLock"";
    public static final String LOCK_AWB_KEY = ""awbLock"";
    public static final String TRIGGER_KEY = ""triggers"";
    public static final String PHYSICAL_ID_KEY = ""physicalId"";
    public static final String TRIGGER_AE_KEY = ""ae"";
    public static final String TRIGGER_AF_KEY = ""af"";
    public static final String VIB_PATTERN_KEY = ""pattern"";
    public static final String EVCOMP_KEY = ""evComp"";
    public static final String AUDIO_RESTRICTION_MODE_KEY = ""mode"";

    private CameraManager mCameraManager = null;
    private HandlerThread mCameraThread = null;
    private Handler mCameraHandler = null;
    private BlockingCameraManager mBlockingCameraManager = null;
    private BlockingStateCallback mCameraListener = null;
    private CameraDevice mCamera = null;
    private CameraCaptureSession mSession = null;
    private ImageReader[] mOutputImageReaders = null;
    private SparseArray<String> mPhysicalStreamMap = new SparseArray<String>();
    private ImageReader mInputImageReader = null;
    private CameraCharacteristics mCameraCharacteristics = null;
    private HashMap<String, CameraCharacteristics> mPhysicalCameraChars =
            new HashMap<String, CameraCharacteristics>();
    private ItsUtils.ItsCameraIdList mItsCameraIdList = null;

    private Vibrator mVibrator = null;

    private HandlerThread mSaveThreads[] = new HandlerThread[MAX_NUM_OUTPUT_SURFACES];
    private Handler mSaveHandlers[] = new Handler[MAX_NUM_OUTPUT_SURFACES];
    private HandlerThread mResultThread = null;
    private Handler mResultHandler = null;

    private volatile boolean mThreadExitFlag = false;

    private volatile ServerSocket mSocket = null;
    private volatile SocketRunnable mSocketRunnableObj = null;
    private Semaphore mSocketQueueQuota = null;
    private int mMemoryQuota = -1;
    private LinkedList<Integer> mInflightImageSizes = new LinkedList<>();
    private volatile BlockingQueue<ByteBuffer> mSocketWriteQueue =
            new LinkedBlockingDeque<ByteBuffer>();
    private final Object mSocketWriteEnqueueLock = new Object();
    private final Object mSocketWriteDrainLock = new Object();

    private volatile BlockingQueue<Object[]> mSerializerQueue =
            new LinkedBlockingDeque<Object[]>();

    private AtomicInteger mCountCallbacksRemaining = new AtomicInteger();
    private AtomicInteger mCountRawOrDng = new AtomicInteger();
    private AtomicInteger mCountRaw10 = new AtomicInteger();
    private AtomicInteger mCountRaw12 = new AtomicInteger();
    private AtomicInteger mCountJpg = new AtomicInteger();
    private AtomicInteger mCountYuv = new AtomicInteger();
    private AtomicInteger mCountCapRes = new AtomicInteger();
    private boolean mCaptureRawIsDng;
    private boolean mCaptureRawIsStats;
    private int mCaptureStatsGridWidth;
    private int mCaptureStatsGridHeight;
    private CaptureResult mCaptureResults[] = null;

    private volatile ConditionVariable mInterlock3A = new ConditionVariable(true);

    final Object m3AStateLock = new Object();
    private volatile boolean mConvergedAE = false;
    private volatile boolean mConvergedAF = false;
    private volatile boolean mConvergedAWB = false;
    private volatile boolean mLockedAE = false;
    private volatile boolean mLockedAWB = false;
    private volatile boolean mNeedsLockedAE = false;
    private volatile boolean mNeedsLockedAWB = false;

    class MySensorEvent {
        public Sensor sensor;
        public int accuracy;
        public long timestamp;
        public float values[];
    }

    // For capturing motion sensor traces.
    private SensorManager mSensorManager = null;
    private Sensor mAccelSensor = null;
    private Sensor mMagSensor = null;
    private Sensor mGyroSensor = null;
    private volatile LinkedList<MySensorEvent> mEvents = null;
    private volatile Object mEventLock = new Object();
    private volatile boolean mEventsEnabled = false;
    private HandlerThread mSensorThread = null;
    private Handler mSensorHandler = null;

    private SensorPrivacyManager mSensorPrivacyManager;

    // Camera test instrumentation
    private CameraTestInstrumentation mCameraInstrumentation;
    // Camera PerformanceTest metric
    private final ArrayList<Metric> mResults = new ArrayList<Metric>();

    private static final int SERIALIZER_SURFACES_ID = 2;
    private static final int SERIALIZER_PHYSICAL_METADATA_ID = 3;

    public interface CaptureCallback {
        void onCaptureAvailable(Image capture, String physicalCameraId);
    }

    public abstract class CaptureResultListener extends CameraCaptureSession.CaptureCallback {}

    @Override
    public IBinder onBind(Intent intent) {
        return null;
    }

    @Override
    public void onCreate() {
        try {
            mThreadExitFlag = false;

            // Get handle to camera manager.
            mCameraManager = (CameraManager) this.getSystemService(Context.CAMERA_SERVICE);
            if (mCameraManager == null) {
                throw new ItsException(""Failed to connect to camera manager"");
            }
            mBlockingCameraManager = new BlockingCameraManager(mCameraManager);
            mCameraListener = new BlockingStateCallback();

            // Register for motion events.
            mEvents = new LinkedList<MySensorEvent>();
            mSensorManager = (SensorManager)getSystemService(Context.SENSOR_SERVICE);
            mAccelSensor = mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);
            mMagSensor = mSensorManager.getDefaultSensor(Sensor.TYPE_MAGNETIC_FIELD);
            mGyroSensor = mSensorManager.getDefaultSensor(Sensor.TYPE_GYROSCOPE);
            mSensorThread = new HandlerThread(""SensorThread"");
            mSensorThread.start();
            mSensorHandler = new Handler(mSensorThread.getLooper());
            mSensorManager.registerListener(this, mAccelSensor,
                    /*100hz*/ 10000, mSensorHandler);
            mSensorManager.registerListener(this, mMagSensor,
                    SensorManager.SENSOR_DELAY_NORMAL, mSensorHandler);
            mSensorManager.registerListener(this, mGyroSensor,
                    /*200hz*/5000, mSensorHandler);

            // Get a handle to the system vibrator.
            mVibrator = (Vibrator)getSystemService(Context.VIBRATOR_SERVICE);

            // Create threads to receive images and save them.
            for (int i = 0; i < MAX_NUM_OUTPUT_SURFACES; i++) {
                mSaveThreads[i] = new HandlerThread(""SaveThread"" + i);
                mSaveThreads[i].start();
                mSaveHandlers[i] = new Handler(mSaveThreads[i].getLooper());
            }

            // Create a thread to handle object serialization.
            (new Thread(new SerializerRunnable())).start();;

            // Create a thread to receive capture results and process them.
            mResultThread = new HandlerThread(""ResultThread"");
            mResultThread.start();
            mResultHandler = new Handler(mResultThread.getLooper());

            // Create a thread for the camera device.
            mCameraThread = new HandlerThread(""ItsCameraThread"");
            mCameraThread.start();
            mCameraHandler = new Handler(mCameraThread.getLooper());

            // Create a thread to process commands, listening on a TCP socket.
            mSocketRunnableObj = new SocketRunnable();
            (new Thread(mSocketRunnableObj)).start();
        } catch (ItsException e) {
            Logt.e(TAG, ""Service failed to start: "", e);
        }

        NotificationManager notificationManager =
                (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
        mChannel = new NotificationChannel(
                ""ItsServiceChannel"", ""ItsService"", NotificationManager.IMPORTANCE_LOW);
        // Configure the notification channel.
        mChannel.setDescription(""ItsServiceChannel"");
        mChannel.enableVibration(false);
        notificationManager.createNotificationChannel(mChannel);

        mSensorPrivacyManager = getSystemService(SensorPrivacyManager.class);
    }

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        try {
            // Just log a message indicating that the service is running and is able to accept
            // socket connections.
            while (!mThreadExitFlag && mSocket==null) {
                Thread.sleep(1);
            }
            if (!mThreadExitFlag){
                Logt.i(TAG, ""ItsService ready"");
            } else {
                Logt.e(TAG, ""Starting ItsService in bad state"");
            }

            Notification notification = new Notification.Builder(this, mChannel.getId())
                    .setContentTitle(""CameraITS Service"")
                    .setContentText(""CameraITS Service is running"")
                    .setSmallIcon(R.drawable.icon)
                    .setOngoing(true).build();
            startForeground(SERVICE_NOTIFICATION_ID, notification,
                    ServiceInfo.FOREGROUND_SERVICE_TYPE_CAMERA);
        } catch (java.lang.InterruptedException e) {
            Logt.e(TAG, ""Error starting ItsService (interrupted)"", e);
        }
        return START_STICKY;
    }

    @Override
    public void onDestroy() {
        mThreadExitFlag = true;
        for (int i = 0; i < MAX_NUM_OUTPUT_SURFACES; i++) {
            if (mSaveThreads[i] != null) {
                mSaveThreads[i].quit();
                mSaveThreads[i] = null;
            }
        }
        if (mSensorThread != null) {
            mSensorThread.quitSafely();
            mSensorThread = null;
        }
        if (mResultThread != null) {
            mResultThread.quitSafely();
            mResultThread = null;
        }
        if (mCameraThread != null) {
            mCameraThread.quitSafely();
            mCameraThread = null;
        }
    }

    public void openCameraDevice(String cameraId) throws ItsException {
        Logt.i(TAG, String.format(""Opening camera %s"", cameraId));

        try {
            if (mMemoryQuota == -1) {
                // Initialize memory quota on this device
                if (mItsCameraIdList == null) {
                    mItsCameraIdList = ItsUtils.getItsCompatibleCameraIds(mCameraManager);
                }
                if (mItsCameraIdList.mCameraIds.size() == 0) {
                    throw new ItsException(""No camera devices"");
                }
                for (String camId : mItsCameraIdList.mCameraIds) {
                    CameraCharacteristics chars =  mCameraManager.getCameraCharacteristics(camId);
                    Size maxYuvSize = ItsUtils.getMaxOutputSize(
                            chars, ImageFormat.YUV_420_888);
                    // 4 bytes per pixel for RGBA8888 Bitmap and at least 3 Bitmaps per CDD
                    int quota = maxYuvSize.getWidth() * maxYuvSize.getHeight() * 4 * 3;
                    if (quota > mMemoryQuota) {
                        mMemoryQuota = quota;
                    }
                }
            }
        } catch (CameraAccessException e) {
            throw new ItsException(""Failed to get device ID list"", e);
        }

        try {
            mCamera = mBlockingCameraManager.openCamera(cameraId, mCameraListener, mCameraHandler);
            mCameraCharacteristics = mCameraManager.getCameraCharacteristics(cameraId);

            boolean isLogicalCamera = hasCapability(
                    CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_LOGICAL_MULTI_CAMERA);
            if (isLogicalCamera) {
                Set<String> physicalCameraIds = mCameraCharacteristics.getPhysicalCameraIds();
                for (String id : physicalCameraIds) {
                    mPhysicalCameraChars.put(id, mCameraManager.getCameraCharacteristics(id));
                }
            }
            mSocketQueueQuota = new Semaphore(mMemoryQuota, true);
        } catch (CameraAccessException e) {
            throw new ItsException(""Failed to open camera"", e);
        } catch (BlockingOpenException e) {
            throw new ItsException(""Failed to open camera (after blocking)"", e);
        }
        mSocketRunnableObj.sendResponse(""cameraOpened"", """");
    }

    public void closeCameraDevice() throws ItsException {
        try {
            if (mCamera != null) {
                Logt.i(TAG, ""Closing camera"");
                mCamera.close();
                mCamera = null;
            }
        } catch (Exception e) {
            throw new ItsException(""Failed to close device"");
        }
        mSocketRunnableObj.sendResponse(""cameraClosed"", """");
    }

    class SerializerRunnable implements Runnable {
        // Use a separate thread to perform JSON serialization (since this can be slow due to
        // the reflection).
        @Override
        public void run() {
            Logt.i(TAG, ""Serializer thread starting"");
            while (! mThreadExitFlag) {
                try {
                    Object objs[] = mSerializerQueue.take();
                    JSONObject jsonObj = new JSONObject();
                    String tag = null;
                    for (int i = 0; i < objs.length; i++) {
                        Object obj = objs[i];
                        if (obj instanceof String) {
                            if (tag != null) {
                                throw new ItsException(""Multiple tags for socket response"");
                            }
                            tag = (String)obj;
                        } else if (obj instanceof CameraCharacteristics) {
                            jsonObj.put(""cameraProperties"", ItsSerializer.serialize(
                                    (CameraCharacteristics)obj));
                        } else if (obj instanceof CaptureRequest) {
                            jsonObj.put(""captureRequest"", ItsSerializer.serialize(
                                    (CaptureRequest)obj));
                        } else if (obj instanceof CaptureResult) {
                            jsonObj.put(""captureResult"", ItsSerializer.serialize(
                                    (CaptureResult)obj));
                        } else if (obj instanceof JSONArray) {
                            if (tag == ""captureResults"") {
                                if (i == SERIALIZER_SURFACES_ID) {
                                    jsonObj.put(""outputs"", (JSONArray)obj);
                                } else if (i == SERIALIZER_PHYSICAL_METADATA_ID) {
                                    jsonObj.put(""physicalResults"", (JSONArray)obj);
                                } else {
                                    throw new ItsException(
                                            ""Unsupported JSONArray for captureResults"");
                                }
                            } else {
                                jsonObj.put(""outputs"", (JSONArray)obj);
                            }
                        } else {
                            throw new ItsException(""Invalid object received for serialization"");
                        }
                    }
                    if (tag == null) {
                        throw new ItsException(""No tag provided for socket response"");
                    }
                    mSocketRunnableObj.sendResponse(tag, null, jsonObj, null);
                    Logt.i(TAG, String.format(""Serialized %s"", tag));
                } catch (org.json.JSONException e) {
                    Logt.e(TAG, ""Error serializing object"", e);
                    break;
                } catch (ItsException e) {
                    Logt.e(TAG, ""Error serializing object"", e);
                    break;
                } catch (java.lang.InterruptedException e) {
                    Logt.e(TAG, ""Error serializing object (interrupted)"", e);
                    break;
                }
            }
            Logt.i(TAG, ""Serializer thread terminated"");
        }
    }

    class SocketWriteRunnable implements Runnable {

        // Use a separate thread to service a queue of objects to be written to the socket,
        // writing each sequentially in order. This is needed since different handler functions
        // (called on different threads) will need to send data back to the host script.

        public Socket mOpenSocket = null;
        private Thread mThread = null;

        public SocketWriteRunnable(Socket openSocket) {
            mOpenSocket = openSocket;
        }

        public void setOpenSocket(Socket openSocket) {
            mOpenSocket = openSocket;
        }

        @Override
        public void run() {
            Logt.i(TAG, ""Socket writer thread starting"");
            while (true) {
                try {
                    ByteBuffer b = mSocketWriteQueue.take();
                    synchronized(mSocketWriteDrainLock) {
                        if (mOpenSocket == null) {
                            Logt.e(TAG, ""No open socket connection!"");
                            continue;
                        }
                        if (b.hasArray()) {
                            mOpenSocket.getOutputStream().write(b.array(), 0, b.capacity());
                        } else {
                            byte[] barray = new byte[b.capacity()];
                            b.get(barray);
                            mOpenSocket.getOutputStream().write(barray);
                        }
                        mOpenSocket.getOutputStream().flush();
                        Logt.i(TAG, String.format(""Wrote to socket: %d bytes"", b.capacity()));
                        Integer imgBufSize = mInflightImageSizes.peek();
                        if (imgBufSize != null && imgBufSize == b.capacity()) {
                            mInflightImageSizes.removeFirst();
                            if (mSocketQueueQuota != null) {
                                mSocketQueueQuota.release(imgBufSize);
                            }
                        }
                    }
                } catch (IOException e) {
                    Logt.e(TAG, ""Error writing to socket"", e);
                    mOpenSocket = null;
                    break;
                } catch (java.lang.InterruptedException e) {
                    Logt.e(TAG, ""Error writing to socket (interrupted)"", e);
                    mOpenSocket = null;
                    break;
                }
            }
            Logt.i(TAG, ""Socket writer thread terminated"");
        }

        public synchronized void checkAndStartThread() {
            if (mThread == null || mThread.getState() == Thread.State.TERMINATED) {
                mThread = new Thread(this);
            }
            if (mThread.getState() == Thread.State.NEW) {
                mThread.start();
            }
        }

    }

    class SocketRunnable implements Runnable {

        // Format of sent messages (over the socket):
        // * Serialized JSON object on a single line (newline-terminated)
        // * For byte buffers, the binary data then follows
        //
        // Format of received messages (from the socket):
        // * Serialized JSON object on a single line (newline-terminated)

        private Socket mOpenSocket = null;
        private SocketWriteRunnable mSocketWriteRunnable = null;

        @Override
        public void run() {
            Logt.i(TAG, ""Socket thread starting"");
            try {
                mSocket = new ServerSocket(SERVERPORT);
            } catch (IOException e) {
                Logt.e(TAG, ""Failed to create socket"", e);
            }

            // Create a new thread to handle writes to this socket.
            mSocketWriteRunnable = new SocketWriteRunnable(null);

            while (!mThreadExitFlag) {
                // Receive the socket-open request from the host.
                try {
                    Logt.i(TAG, ""Waiting for client to connect to socket"");
                    mOpenSocket = mSocket.accept();
                    if (mOpenSocket == null) {
                        Logt.e(TAG, ""Socket connection error"");
                        break;
                    }
                    mSocketWriteQueue.clear();
                    mInflightImageSizes.clear();
                    mSocketWriteRunnable.setOpenSocket(mOpenSocket);
                    mSocketWriteRunnable.checkAndStartThread();
                    Logt.i(TAG, ""Socket connected"");
                } catch (IOException e) {
                    Logt.e(TAG, ""Socket open error: "", e);
                    break;
                }

                // Process commands over the open socket.
                while (!mThreadExitFlag) {
                    try {
                        BufferedReader input = new BufferedReader(
                                new InputStreamReader(mOpenSocket.getInputStream()));
                        if (input == null) {
                            Logt.e(TAG, ""Failed to get socket input stream"");
                            break;
                        }
                        String line = input.readLine();
                        if (line == null) {
                            Logt.i(TAG, ""Socket readline returned null (host disconnected)"");
                            break;
                        }
                        processSocketCommand(line);
                    } catch (IOException e) {
                        Logt.e(TAG, ""Socket read error: "", e);
                        break;
                    } catch (ItsException e) {
                        Logt.e(TAG, ""Script error: "", e);
                        break;
                    }
                }

                // Close socket and go back to waiting for a new connection.
                try {
                    synchronized(mSocketWriteDrainLock) {
                        mSocketWriteQueue.clear();
                        mInflightImageSizes.clear();
                        mOpenSocket.close();
                        mOpenSocket = null;
                        mSocketWriteRunnable.setOpenSocket(null);
                        Logt.i(TAG, ""Socket disconnected"");
                    }
                } catch (java.io.IOException e) {
                    Logt.e(TAG, ""Exception closing socket"");
                }
            }

            // It's an overall error state if the code gets here; no recevery.
            // Try to do some cleanup, but the service probably needs to be restarted.
            Logt.i(TAG, ""Socket server loop exited"");
            mThreadExitFlag = true;
            try {
                synchronized(mSocketWriteDrainLock) {
                    if (mOpenSocket != null) {
                        mOpenSocket.close();
                        mOpenSocket = null;
                        mSocketWriteRunnable.setOpenSocket(null);
                    }
                }
            } catch (java.io.IOException e) {
                Logt.w(TAG, ""Exception closing socket"");
            }
            try {
                if (mSocket != null) {
                    mSocket.close();
                    mSocket = null;
                }
            } catch (java.io.IOException e) {
                Logt.w(TAG, ""Exception closing socket"");
            }
        }

        public void processSocketCommand(String cmd)
                throws ItsException {
            // Default locale must be set to ""en-us""
            Locale locale = Locale.getDefault();
            if (!Locale.US.equals(locale)) {
                Logt.e(TAG, ""Default language is not set to "" + Locale.US + ""!"");
                stopSelf();
            }

            // Each command is a serialized JSON object.
            try {
                JSONObject cmdObj = new JSONObject(cmd);
                Logt.i(TAG, ""Start processing command"" + cmdObj.getString(""cmdName""));
                if (""open"".equals(cmdObj.getString(""cmdName""))) {
                    String cameraId = cmdObj.getString(""cameraId"");
                    openCameraDevice(cameraId);
                } else if (""close"".equals(cmdObj.getString(""cmdName""))) {
                    closeCameraDevice();
                } else if (""getCameraProperties"".equals(cmdObj.getString(""cmdName""))) {
                    doGetProps();
                } else if (""getCameraPropertiesById"".equals(cmdObj.getString(""cmdName""))) {
                    doGetPropsById(cmdObj);
                } else if (""startSensorEvents"".equals(cmdObj.getString(""cmdName""))) {
                    doStartSensorEvents();
                } else if (""checkSensorExistence"".equals(cmdObj.getString(""cmdName""))) {
                    doCheckSensorExistence();
                } else if (""getSensorEvents"".equals(cmdObj.getString(""cmdName""))) {
                    doGetSensorEvents();
                } else if (""do3A"".equals(cmdObj.getString(""cmdName""))) {
                    do3A(cmdObj);
                } else if (""doCapture"".equals(cmdObj.getString(""cmdName""))) {
                    doCapture(cmdObj);
                } else if (""doVibrate"".equals(cmdObj.getString(""cmdName""))) {
                    doVibrate(cmdObj);
                } else if (""setAudioRestriction"".equals(cmdObj.getString(""cmdName""))) {
                    doSetAudioRestriction(cmdObj);
                } else if (""getCameraIds"".equals(cmdObj.getString(""cmdName""))) {
                    doGetCameraIds();
                } else if (""doReprocessCapture"".equals(cmdObj.getString(""cmdName""))) {
                    doReprocessCapture(cmdObj);
                } else if (""getItsVersion"".equals(cmdObj.getString(""cmdName""))) {
                    mSocketRunnableObj.sendResponse(""ItsVersion"", ITS_SERVICE_VERSION);
                } else if (""isStreamCombinationSupported"".equals(cmdObj.getString(""cmdName""))) {
                    doCheckStreamCombination(cmdObj);
                } else if (""isCameraPrivacyModeSupported"".equals(cmdObj.getString(""cmdName""))) {
                    doCheckCameraPrivacyModeSupport();
                } else if (""isPerformanceClassPrimaryCamera"".equals(cmdObj.getString(""cmdName""))) {
                    String cameraId = cmdObj.getString(""cameraId"");
                    doCheckPerformanceClassPrimaryCamera(cameraId);
                } else if (""measureCameraLaunchMs"".equals(cmdObj.getString(""cmdName""))) {
                    String cameraId = cmdObj.getString(""cameraId"");
                    doMeasureCameraLaunchMs(cameraId);
                } else if (""measureCamera1080pJpegCaptureMs"".equals(cmdObj.getString(""cmdName""))) {
                    String cameraId = cmdObj.getString(""cameraId"");
                    doMeasureCamera1080pJpegCaptureMs(cameraId);
                } else {
                    throw new ItsException(""Unknown command: "" + cmd);
                }
                Logt.i(TAG, ""Finish processing command"" + cmdObj.getString(""cmdName""));
            } catch (org.json.JSONException e) {
                Logt.e(TAG, ""Invalid command: "", e);
            }
        }

        public void sendResponse(String tag, String str, JSONObject obj, ByteBuffer bbuf)
                throws ItsException {
            try {
                JSONObject jsonObj = new JSONObject();
                jsonObj.put(""tag"", tag);
                if (str != null) {
                    jsonObj.put(""strValue"", str);
                }
                if (obj != null) {
                    jsonObj.put(""objValue"", obj);
                }
                if (bbuf != null) {
                    jsonObj.put(""bufValueSize"", bbuf.capacity());
                }
                ByteBuffer bstr = ByteBuffer.wrap(
                        (jsonObj.toString()+""\n"").getBytes(Charset.defaultCharset()));
                synchronized(mSocketWriteEnqueueLock) {
                    if (bstr != null) {
                        mSocketWriteQueue.put(bstr);
                    }
                    if (bbuf != null) {
                        mInflightImageSizes.add(bbuf.capacity());
                        mSocketWriteQueue.put(bbuf);
                    }
                }
            } catch (org.json.JSONException e) {
                throw new ItsException(""JSON error: "", e);
            } catch (java.lang.InterruptedException e) {
                throw new ItsException(""Socket error: "", e);
            }
        }

        public void sendResponse(String tag, String str)
                throws ItsException {
            sendResponse(tag, str, null, null);
        }

        public void sendResponse(String tag, JSONObject obj)
                throws ItsException {
            sendResponse(tag, null, obj, null);
        }

        public void sendResponseCaptureBuffer(String tag, ByteBuffer bbuf)
                throws ItsException {
            sendResponse(tag, null, null, bbuf);
        }

        public void sendResponse(LinkedList<MySensorEvent> events)
                throws ItsException {
            Logt.i(TAG, ""Sending "" + events.size() + "" sensor events"");
            try {
                JSONArray accels = new JSONArray();
                JSONArray mags = new JSONArray();
                JSONArray gyros = new JSONArray();
                for (MySensorEvent event : events) {
                    JSONObject obj = new JSONObject();
                    obj.put(""time"", event.timestamp);
                    obj.put(""x"", event.values[0]);
                    obj.put(""y"", event.values[1]);
                    obj.put(""z"", event.values[2]);
                    if (event.sensor.getType() == Sensor.TYPE_ACCELEROMETER) {
                        accels.put(obj);
                    } else if (event.sensor.getType() == Sensor.TYPE_MAGNETIC_FIELD) {
                        mags.put(obj);
                    } else if (event.sensor.getType() == Sensor.TYPE_GYROSCOPE) {
                        gyros.put(obj);
                    }
                }
                JSONObject obj = new JSONObject();
                obj.put(""accel"", accels);
                obj.put(""mag"", mags);
                obj.put(""gyro"", gyros);
                sendResponse(""sensorEvents"", null, obj, null);
            } catch (org.json.JSONException e) {
                throw new ItsException(""JSON error: "", e);
            }
            Logt.i(TAG, ""Sent sensor events"");
        }

        public void sendResponse(CameraCharacteristics props)
                throws ItsException {
            try {
                Object objs[] = new Object[2];
                objs[0] = ""cameraProperties"";
                objs[1] = props;
                mSerializerQueue.put(objs);
            } catch (InterruptedException e) {
                throw new ItsException(""Interrupted: "", e);
            }
        }

        public void sendResponseCaptureResult(CameraCharacteristics props,
                                              CaptureRequest request,
                                              TotalCaptureResult result,
                                              ImageReader[] readers)
                throws ItsException {
            try {
                JSONArray jsonSurfaces = new JSONArray();
                for (int i = 0; i < readers.length; i++) {
                    JSONObject jsonSurface = new JSONObject();
                    jsonSurface.put(""width"", readers[i].getWidth());
                    jsonSurface.put(""height"", readers[i].getHeight());
                    int format = readers[i].getImageFormat();
                    if (format == ImageFormat.RAW_SENSOR) {
                        if (mCaptureRawIsStats) {
                            int aaw = ItsUtils.getActiveArrayCropRegion(mCameraCharacteristics)
                                              .width();
                            int aah = ItsUtils.getActiveArrayCropRegion(mCameraCharacteristics)
                                              .height();
                            jsonSurface.put(""format"", ""rawStats"");
                            jsonSurface.put(""width"", aaw/mCaptureStatsGridWidth);
                            jsonSurface.put(""height"", aah/mCaptureStatsGridHeight);
                        } else if (mCaptureRawIsDng) {
                            jsonSurface.put(""format"", ""dng"");
                        } else {
                            jsonSurface.put(""format"", ""raw"");
                        }
                    } else if (format == ImageFormat.RAW10) {
                        jsonSurface.put(""format"", ""raw10"");
                    } else if (format == ImageFormat.RAW12) {
                        jsonSurface.put(""format"", ""raw12"");
                    } else if (format == ImageFormat.JPEG) {
                        jsonSurface.put(""format"", ""jpeg"");
                    } else if (format == ImageFormat.YUV_420_888) {
                        jsonSurface.put(""format"", ""yuv"");
                    } else if (format == ImageFormat.Y8) {
                        jsonSurface.put(""format"", ""y8"");
                    } else {
                        throw new ItsException(""Invalid format"");
                    }
                    jsonSurfaces.put(jsonSurface);
                }

                Map<String, CaptureResult> physicalMetadata =
                        result.getPhysicalCameraResults();
                JSONArray jsonPhysicalMetadata = new JSONArray();
                for (Map.Entry<String, CaptureResult> pair : physicalMetadata.entrySet()) {
                    JSONObject jsonOneMetadata = new JSONObject();
                    jsonOneMetadata.put(pair.getKey(), ItsSerializer.serialize(pair.getValue()));
                    jsonPhysicalMetadata.put(jsonOneMetadata);
                }
                Object objs[] = new Object[4];
                objs[0] = ""captureResults"";
                objs[1] = result;
                objs[SERIALIZER_SURFACES_ID] = jsonSurfaces;
                objs[SERIALIZER_PHYSICAL_METADATA_ID] = jsonPhysicalMetadata;
                mSerializerQueue.put(objs);
            } catch (org.json.JSONException e) {
                throw new ItsException(""JSON error: "", e);
            } catch (InterruptedException e) {
                throw new ItsException(""Interrupted: "", e);
            }
        }
    }

    public ImageReader.OnImageAvailableListener
            createAvailableListener(final CaptureCallback listener) {
        return new ImageReader.OnImageAvailableListener() {
            @Override
            public void onImageAvailable(ImageReader reader) {
                Image i = null;
                try {
                    i = reader.acquireNextImage();
                    String physicalCameraId = new String();
                    for (int idx = 0; idx < mOutputImageReaders.length; idx++) {
                        if (mOutputImageReaders[idx] == reader) {
                            physicalCameraId = mPhysicalStreamMap.get(idx);
                        }
                    }
                    listener.onCaptureAvailable(i, physicalCameraId);
                } finally {
                    if (i != null) {
                        i.close();
                    }
                }
            }
        };
    }

    private ImageReader.OnImageAvailableListener
            createAvailableListenerDropper() {
        return new ImageReader.OnImageAvailableListener() {
            @Override
            public void onImageAvailable(ImageReader reader) {
                Image i = reader.acquireNextImage();
                i.close();
            }
        };
    }

    private void doStartSensorEvents() throws ItsException {
        synchronized(mEventLock) {
            mEventsEnabled = true;
        }
        mSocketRunnableObj.sendResponse(""sensorEventsStarted"", """");
    }

    private void doCheckSensorExistence() throws ItsException {
        try {
            JSONObject obj = new JSONObject();
            obj.put(""accel"", mAccelSensor != null);
            obj.put(""mag"", mMagSensor != null);
            obj.put(""gyro"", mGyroSensor != null);
            obj.put(""vibrator"", mVibrator.hasVibrator());
            mSocketRunnableObj.sendResponse(""sensorExistence"", null, obj, null);
        } catch (org.json.JSONException e) {
            throw new ItsException(""JSON error: "", e);
        }
    }

    private void doGetSensorEvents() throws ItsException {
        synchronized(mEventLock) {
            mSocketRunnableObj.sendResponse(mEvents);
            mEvents.clear();
            mEventsEnabled = false;
        }
    }

    private void doGetProps() throws ItsException {
        mSocketRunnableObj.sendResponse(mCameraCharacteristics);
    }

    private void doGetPropsById(JSONObject params) throws ItsException {
        String[] devices;
        try {
            // Intentionally not using ItsUtils.getItsCompatibleCameraIds here so it's possible to
            // write some simple script to query camera characteristics even for devices exempted
            // from ITS today.
            devices = mCameraManager.getCameraIdList();
            if (devices == null || devices.length == 0) {
                throw new ItsException(""No camera devices"");
            }
        } catch (CameraAccessException e) {
            throw new ItsException(""Failed to get device ID list"", e);
        }

        try {
            String cameraId = params.getString(""cameraId"");
            CameraCharacteristics characteristics =
                    mCameraManager.getCameraCharacteristics(cameraId);
            mSocketRunnableObj.sendResponse(characteristics);
        } catch (org.json.JSONException e) {
            throw new ItsException(""JSON error: "", e);
        } catch (IllegalArgumentException e) {
            throw new ItsException(""Illegal argument error:"", e);
        } catch (CameraAccessException e) {
            throw new ItsException(""Access error: "", e);
        }
    }

    private void doGetCameraIds() throws ItsException {
        if (mItsCameraIdList == null) {
            mItsCameraIdList = ItsUtils.getItsCompatibleCameraIds(mCameraManager);
        }
        if (mItsCameraIdList.mCameraIdCombos.size() == 0) {
            throw new ItsException(""No camera devices"");
        }

        try {
            JSONObject obj = new JSONObject();
            JSONArray array = new JSONArray();
            for (String id : mItsCameraIdList.mCameraIdCombos) {
                array.put(id);
            }
            obj.put(""cameraIdArray"", array);
            mSocketRunnableObj.sendResponse(""cameraIds"", obj);
        } catch (org.json.JSONException e) {
            throw new ItsException(""JSON error: "", e);
        }
    }

    private static class HandlerExecutor implements Executor {
        private final Handler mHandler;

        public HandlerExecutor(Handler handler) {
            mHandler = handler;
        }

        @Override
        public void execute(Runnable runCmd) {
            mHandler.post(runCmd);
        }
    }

    private void doCheckStreamCombination(JSONObject params) throws ItsException {
        try {
            JSONObject obj = new JSONObject();
            JSONArray jsonOutputSpecs = ItsUtils.getOutputSpecs(params);
            prepareImageReadersWithOutputSpecs(jsonOutputSpecs, /*inputSize*/null,
                    /*inputFormat*/0, /*maxInputBuffers*/0, /*backgroundRequest*/false);
            int numSurfaces = mOutputImageReaders.length;
            List<OutputConfiguration> outputConfigs =
                    new ArrayList<OutputConfiguration>(numSurfaces);
            for (int i = 0; i < numSurfaces; i++) {
                OutputConfiguration config = new OutputConfiguration(
                        mOutputImageReaders[i].getSurface());
                if (mPhysicalStreamMap.get(i) != null) {
                    config.setPhysicalCameraId(mPhysicalStreamMap.get(i));
                }
                outputConfigs.add(config);
            }

            BlockingSessionCallback sessionListener = new BlockingSessionCallback();
            SessionConfiguration sessionConfig = new SessionConfiguration(
                SessionConfiguration.SESSION_REGULAR, outputConfigs,
                new HandlerExecutor(mCameraHandler), sessionListener);
            boolean supported = mCamera.isSessionConfigurationSupported(sessionConfig);

            String supportString = supported ? ""supportedCombination"" : ""unsupportedCombination"";
            mSocketRunnableObj.sendResponse(""streamCombinationSupport"", supportString);

        } catch (UnsupportedOperationException e) {
            mSocketRunnableObj.sendResponse(""streamCombinationSupport"", ""unsupportedOperation"");
        } catch (IllegalArgumentException e) {
            throw new ItsException(""Error checking stream combination"", e);
        } catch (CameraAccessException e) {
            throw new ItsException(""Error checking stream combination"", e);
        }
    }

    private void doCheckCameraPrivacyModeSupport() throws ItsException {
        boolean hasPrivacySupport = mSensorPrivacyManager
                .supportsSensorToggle(SensorPrivacyManager.Sensors.CAMERA);
        mSocketRunnableObj.sendResponse(""cameraPrivacyModeSupport"",
                hasPrivacySupport ? ""true"" : ""false"");
    }

    private void doCheckPerformanceClassPrimaryCamera(String cameraId) throws ItsException {
        boolean  isPerfClass = (Build.VERSION.MEDIA_PERFORMANCE_CLASS == PERFORMANCE_CLASS_S
                || Build.VERSION.MEDIA_PERFORMANCE_CLASS == PERFORMANCE_CLASS_R);

        if (mItsCameraIdList == null) {
            mItsCameraIdList = ItsUtils.getItsCompatibleCameraIds(mCameraManager);
        }
        if (mItsCameraIdList.mCameraIds.size() == 0) {
            throw new ItsException(""No camera devices"");
        }
        if (!mItsCameraIdList.mCameraIds.contains(cameraId)) {
            throw new ItsException(""Invalid cameraId "" + cameraId);
        }

        boolean isPrimaryCamera = false;
        try {
            CameraCharacteristics c = mCameraManager.getCameraCharacteristics(cameraId);
            Integer cameraFacing = c.get(CameraCharacteristics.LENS_FACING);
            for (String id : mItsCameraIdList.mCameraIds) {
                c = mCameraManager.getCameraCharacteristics(id);
                Integer facing = c.get(CameraCharacteristics.LENS_FACING);
                if (cameraFacing.equals(facing)) {
                    if (cameraId.equals(id)) {
                        isPrimaryCamera = true;
                    } else {
                        isPrimaryCamera = false;
                    }
                    break;
                }
            }
        } catch (CameraAccessException e) {
            throw new ItsException(""Failed to get camera characteristics"", e);
        }

        mSocketRunnableObj.sendResponse(""performanceClassPrimaryCamera"",
                (isPerfClass && isPrimaryCamera) ? ""true"" : ""false"");
    }

    private double invokeCameraPerformanceTest(Class testClass, String testName,
            String cameraId, String metricName) throws ItsException {
        mResults.clear();
        mCameraInstrumentation = new CameraTestInstrumentation();
        MetricListener metricListener = new MetricListener() {
            @Override
            public void onResultMetric(Metric metric) {
                mResults.add(metric);
            }
        };
        mCameraInstrumentation.initialize(this, metricListener);

        Bundle bundle = new Bundle();
        bundle.putString(""camera-id"", cameraId);
        bundle.putString(""perf-measure"", ""on"");
        bundle.putString(""perf-class-test"", ""on"");
        InstrumentationRegistry.registerInstance(mCameraInstrumentation, bundle);

        JUnitCore testRunner = new JUnitCore();
        Log.v(TAG, String.format(""Execute Test: %s#%s"", testClass.getSimpleName(), testName));
        Request request = Request.method(testClass, testName);
        Result runResult = testRunner.run(request);
        if (!runResult.wasSuccessful()) {
            throw new ItsException(""Camera PerformanceTest "" + testClass.getSimpleName() +
                    ""#"" + testName + "" failed"");
        }

        for (Metric m : mResults) {
            if (m.getMessage().equals(metricName) && m.getValues().length == 1) {
                return m.getValues()[0];
            }
        }

        throw new ItsException(""Failed to look up "" + metricName +
                "" in Camera PerformanceTest result!"");
    }

    private void doMeasureCameraLaunchMs(String cameraId) throws ItsException {
        double launchMs = invokeCameraPerformanceTest(PerformanceTest.class,
                ""testCameraLaunch"", cameraId, ""camera_launch_average_time_for_all_cameras"");
        mSocketRunnableObj.sendResponse(""cameraLaunchMs"", Double.toString(launchMs));
    }

    private void doMeasureCamera1080pJpegCaptureMs(String cameraId) throws ItsException {
        double jpegCaptureMs = invokeCameraPerformanceTest(PerformanceTest.class,
                ""testSingleCapture"", cameraId,
                ""camera_capture_average_latency_for_all_cameras_jpeg"");
        mSocketRunnableObj.sendResponse(""camera1080pJpegCaptureMs"", Double.toString(jpegCaptureMs));
    }

    private void prepareImageReaders(Size[] outputSizes, int[] outputFormats, Size inputSize,
            int inputFormat, int maxInputBuffers) {
        closeImageReaders();
        mOutputImageReaders = new ImageReader[outputSizes.length];
        for (int i = 0; i < outputSizes.length; i++) {
            // Check if the output image reader can be shared with the input image reader.
            if (outputSizes[i].equals(inputSize) && outputFormats[i] == inputFormat) {
                mOutputImageReaders[i] = ImageReader.newInstance(outputSizes[i].getWidth(),
                        outputSizes[i].getHeight(), outputFormats[i],
                        MAX_CONCURRENT_READER_BUFFERS + maxInputBuffers);
                mInputImageReader = mOutputImageReaders[i];
            } else {
                mOutputImageReaders[i] = ImageReader.newInstance(outputSizes[i].getWidth(),
                        outputSizes[i].getHeight(), outputFormats[i],
                        MAX_CONCURRENT_READER_BUFFERS);
            }
        }

        if (inputSize != null && mInputImageReader == null) {
            mInputImageReader = ImageReader.newInstance(inputSize.getWidth(), inputSize.getHeight(),
                    inputFormat, maxInputBuffers);
        }
    }

    private void closeImageReaders() {
        if (mOutputImageReaders != null) {
            for (int i = 0; i < mOutputImageReaders.length; i++) {
                if (mOutputImageReaders[i] != null) {
                    mOutputImageReaders[i].close();
                    mOutputImageReaders[i] = null;
                }
            }
        }
        if (mInputImageReader != null) {
            mInputImageReader.close();
            mInputImageReader = null;
        }
    }

    private void do3A(JSONObject params) throws ItsException {
        ThreeAResultListener threeAListener = new ThreeAResultListener();
        try {
            // Start a 3A action, and wait for it to converge.
            // Get the converged values for each ""A"", and package into JSON result for caller.

            // Configure streams on physical sub-camera if PHYSICAL_ID_KEY is specified.
            String physicalId = null;
            CameraCharacteristics c = mCameraCharacteristics;
            if (params.has(PHYSICAL_ID_KEY)) {
                physicalId = params.getString(PHYSICAL_ID_KEY);
                c = mPhysicalCameraChars.get(physicalId);
            }

            // 3A happens on full-res frames.
            Size sizes[] = ItsUtils.getYuvOutputSizes(c);
            int outputFormats[] = new int[1];
            outputFormats[0] = ImageFormat.YUV_420_888;
            Size[] outputSizes = new Size[1];
            outputSizes[0] = sizes[0];
            int width = outputSizes[0].getWidth();
            int height = outputSizes[0].getHeight();

            prepareImageReaders(outputSizes, outputFormats, /*inputSize*/null, /*inputFormat*/0,
                    /*maxInputBuffers*/0);

            List<OutputConfiguration> outputConfigs = new ArrayList<OutputConfiguration>(1);
            OutputConfiguration config =
                    new OutputConfiguration(mOutputImageReaders[0].getSurface());
            if (physicalId != null) {
                config.setPhysicalCameraId(physicalId);
            }
            outputConfigs.add(config);
            BlockingSessionCallback sessionListener = new BlockingSessionCallback();
            mCamera.createCaptureSessionByOutputConfigurations(
                    outputConfigs, sessionListener, mCameraHandler);
            mSession = sessionListener.waitAndGetSession(TIMEOUT_IDLE_MS);

            // Add a listener that just recycles buffers; they aren't saved anywhere.
            ImageReader.OnImageAvailableListener readerListener =
                    createAvailableListenerDropper();
            mOutputImageReaders[0].setOnImageAvailableListener(readerListener, mSaveHandlers[0]);

            // Get the user-specified regions for AE, AWB, AF.
            // Note that the user specifies normalized [x,y,w,h], which is converted below
            // to an [x0,y0,x1,y1] region in sensor coords. The capture request region
            // also has a fifth ""weight"" element: [x0,y0,x1,y1,w].
            // Use logical camera's active array size for 3A regions.
            Rect activeArray = mCameraCharacteristics.get(
                    CameraCharacteristics.SENSOR_INFO_ACTIVE_ARRAY_SIZE);
            int aaWidth = activeArray.right - activeArray.left;
            int aaHeight = activeArray.bottom - activeArray.top;
            MeteringRectangle[] regionAE = new MeteringRectangle[]{
                    new MeteringRectangle(0,0,aaWidth,aaHeight,1)};
            MeteringRectangle[] regionAF = new MeteringRectangle[]{
                    new MeteringRectangle(0,0,aaWidth,aaHeight,1)};
            MeteringRectangle[] regionAWB = new MeteringRectangle[]{
                    new MeteringRectangle(0,0,aaWidth,aaHeight,1)};
            if (params.has(REGION_KEY)) {
                JSONObject regions = params.getJSONObject(REGION_KEY);
                if (regions.has(REGION_AE_KEY)) {
                    regionAE = ItsUtils.getJsonWeightedRectsFromArray(
                            regions.getJSONArray(REGION_AE_KEY), true, aaWidth, aaHeight);
                }
                if (regions.has(REGION_AF_KEY)) {
                    regionAF = ItsUtils.getJsonWeightedRectsFromArray(
                            regions.getJSONArray(REGION_AF_KEY), true, aaWidth, aaHeight);
                }
                if (regions.has(REGION_AWB_KEY)) {
                    regionAWB = ItsUtils.getJsonWeightedRectsFromArray(
                            regions.getJSONArray(REGION_AWB_KEY), true, aaWidth, aaHeight);
                }
            }

            // An EV compensation can be specified as part of AE convergence.
            int evComp = params.optInt(EVCOMP_KEY, 0);
            if (evComp != 0) {
                Logt.i(TAG, String.format(""Running 3A with AE exposure compensation value: %d"", evComp));
            }

            // By default, AE and AF both get triggered, but the user can optionally override this.
            // Also, AF won't get triggered if the lens is fixed-focus.
            boolean doAE = true;
            boolean doAF = true;
            if (params.has(TRIGGER_KEY)) {
                JSONObject triggers = params.getJSONObject(TRIGGER_KEY);
                if (triggers.has(TRIGGER_AE_KEY)) {
                    doAE = triggers.getBoolean(TRIGGER_AE_KEY);
                }
                if (triggers.has(TRIGGER_AF_KEY)) {
                    doAF = triggers.getBoolean(TRIGGER_AF_KEY);
                }
            }
            Float minFocusDistance = c.get(
                    CameraCharacteristics.LENS_INFO_MINIMUM_FOCUS_DISTANCE);
            boolean isFixedFocusLens = minFocusDistance != null && minFocusDistance == 0.0;
            if (doAF && isFixedFocusLens) {
                // Send a fake result back for the code that is waiting for this message to see
                // that AF has converged.
                Logt.i(TAG, ""Ignoring request for AF on fixed-focus camera"");
                mSocketRunnableObj.sendResponse(""afResult"", ""0.0"");
                doAF = false;
            }

            mInterlock3A.open();
            synchronized(m3AStateLock) {
                // If AE or AWB lock is specified, then the 3A will converge first and then lock these
                // values, waiting until the HAL has reported that the lock was successful.
                mNeedsLockedAE = params.optBoolean(LOCK_AE_KEY, false);
                mNeedsLockedAWB = params.optBoolean(LOCK_AWB_KEY, false);
                mConvergedAE = false;
                mConvergedAWB = false;
                mConvergedAF = false;
                mLockedAE = false;
                mLockedAWB = false;
            }
            long tstart = System.currentTimeMillis();
            boolean triggeredAE = false;
            boolean triggeredAF = false;

            Logt.i(TAG, String.format(""Initiating 3A: AE:%d, AF:%d, AWB:1, AELOCK:%d, AWBLOCK:%d"",
                    doAE?1:0, doAF?1:0, mNeedsLockedAE?1:0, mNeedsLockedAWB?1:0));

            // Keep issuing capture requests until 3A has converged.
            while (true) {

                // Block until can take the next 3A frame. Only want one outstanding frame
                // at a time, to simplify the logic here.
                if (!mInterlock3A.block(TIMEOUT_3A * 1000) ||
                        System.currentTimeMillis() - tstart > TIMEOUT_3A * 1000) {
                    throw new ItsException(
                            ""3A failed to converge after "" + TIMEOUT_3A + "" seconds.\n"" +
                            ""AE converge state: "" + mConvergedAE + "", \n"" +
                            ""AF convergence state: "" + mConvergedAF + "", \n"" +
                            ""AWB convergence state: "" + mConvergedAWB + ""."");
                }
                mInterlock3A.close();

                synchronized(m3AStateLock) {
                    // If not converged yet, issue another capture request.
                    if (       (doAE && (!triggeredAE || !mConvergedAE))
                            || !mConvergedAWB
                            || (doAF && (!triggeredAF || !mConvergedAF))
                            || (doAE && mNeedsLockedAE && !mLockedAE)
                            || (mNeedsLockedAWB && !mLockedAWB)) {

                        // Baseline capture request for 3A.
                        CaptureRequest.Builder req = mCamera.createCaptureRequest(
                                CameraDevice.TEMPLATE_PREVIEW);
                        req.set(CaptureRequest.FLASH_MODE, CaptureRequest.FLASH_MODE_OFF);
                        req.set(CaptureRequest.CONTROL_MODE, CaptureRequest.CONTROL_MODE_AUTO);
                        req.set(CaptureRequest.CONTROL_CAPTURE_INTENT,
                                CaptureRequest.CONTROL_CAPTURE_INTENT_PREVIEW);
                        req.set(CaptureRequest.CONTROL_AE_MODE,
                                CaptureRequest.CONTROL_AE_MODE_ON);
                        req.set(CaptureRequest.CONTROL_AE_EXPOSURE_COMPENSATION, 0);
                        req.set(CaptureRequest.CONTROL_AE_LOCK, false);
                        req.set(CaptureRequest.CONTROL_AE_REGIONS, regionAE);
                        req.set(CaptureRequest.CONTROL_AF_MODE,
                                CaptureRequest.CONTROL_AF_MODE_AUTO);
                        req.set(CaptureRequest.CONTROL_AF_REGIONS, regionAF);
                        req.set(CaptureRequest.CONTROL_AWB_MODE,
                                CaptureRequest.CONTROL_AWB_MODE_AUTO);
                        req.set(CaptureRequest.CONTROL_AWB_LOCK, false);
                        req.set(CaptureRequest.CONTROL_AWB_REGIONS, regionAWB);
                        // ITS only turns OIS on when it's explicitly requested
                        req.set(CaptureRequest.LENS_OPTICAL_STABILIZATION_MODE,
                                CaptureRequest.LENS_OPTICAL_STABILIZATION_MODE_OFF);

                        if (evComp != 0) {
                            req.set(CaptureRequest.CONTROL_AE_EXPOSURE_COMPENSATION, evComp);
                        }

                        if (mConvergedAE && mNeedsLockedAE) {
                            req.set(CaptureRequest.CONTROL_AE_LOCK, true);
                        }
                        if (mConvergedAWB && mNeedsLockedAWB) {
                            req.set(CaptureRequest.CONTROL_AWB_LOCK, true);
                        }

                        boolean triggering = false;
                        // Trigger AE first.
                        if (doAE && !triggeredAE) {
                            Logt.i(TAG, ""Triggering AE"");
                            req.set(CaptureRequest.CONTROL_AE_PRECAPTURE_TRIGGER,
                                    CaptureRequest.CONTROL_AE_PRECAPTURE_TRIGGER_START);
                            triggeredAE = true;
                            triggering = true;
                        }

                        // After AE has converged, trigger AF.
                        if (doAF && !triggeredAF && (!doAE || (triggeredAE && mConvergedAE))) {
                            Logt.i(TAG, ""Triggering AF"");
                            req.set(CaptureRequest.CONTROL_AF_TRIGGER,
                                    CaptureRequest.CONTROL_AF_TRIGGER_START);
                            triggeredAF = true;
                            triggering = true;
                        }

                        req.addTarget(mOutputImageReaders[0].getSurface());

                        if (triggering) {
                            // Send single request for AE/AF trigger
                            mSession.capture(req.build(),
                                    threeAListener, mResultHandler);
                        } else {
                            // Use repeating request for non-trigger requests
                            mSession.setRepeatingRequest(req.build(),
                                    threeAListener, mResultHandler);
                        }
                    } else {
                        mSocketRunnableObj.sendResponse(""3aConverged"", """");
                        Logt.i(TAG, ""3A converged"");
                        break;
                    }
                }
            }
        } catch (android.hardware.camera2.CameraAccessException e) {
            throw new ItsException(""Access error: "", e);
        } catch (org.json.JSONException e) {
            throw new ItsException(""JSON error: "", e);
        } finally {
            mSocketRunnableObj.sendResponse(""3aDone"", """");
            // stop listener from updating 3A states
            threeAListener.stop();
            if (mSession != null) {
                mSession.close();
            }
        }
    }

    private void doVibrate(JSONObject params) throws ItsException {
        try {
            if (mVibrator == null) {
                throw new ItsException(""Unable to start vibrator"");
            }
            JSONArray patternArray = params.getJSONArray(VIB_PATTERN_KEY);
            int len = patternArray.length();
            long pattern[] = new long[len];
            for (int i = 0; i < len; i++) {
                pattern[i] = patternArray.getLong(i);
            }
            Logt.i(TAG, String.format(""Starting vibrator, pattern length %d"",len));

            // Mark the vibrator as alarm to test the audio restriction API
            // TODO: consider making this configurable
            AudioAttributes audioAttributes = new AudioAttributes.Builder()
                    .setUsage(AudioAttributes.USAGE_ALARM).build();
            mVibrator.vibrate(pattern, -1, audioAttributes);
            mSocketRunnableObj.sendResponse(""vibrationStarted"", """");
        } catch (org.json.JSONException e) {
            throw new ItsException(""JSON error: "", e);
        }
    }

    private void doSetAudioRestriction(JSONObject params) throws ItsException {
        try {
            if (mCamera == null) {
                throw new ItsException(""Camera is closed"");
            }
            int mode = params.getInt(AUDIO_RESTRICTION_MODE_KEY);
            mCamera.setCameraAudioRestriction(mode);
            Logt.i(TAG, String.format(""Set audio restriction mode to %d"", mode));

            mSocketRunnableObj.sendResponse(""audioRestrictionSet"", """");
        } catch (org.json.JSONException e) {
            throw new ItsException(""JSON error: "", e);
        } catch (android.hardware.camera2.CameraAccessException e) {
            throw new ItsException(""Access error: "", e);
        }
    }

    /**
     * Parse jsonOutputSpecs to get output surface sizes and formats. Create input and output
     * image readers for the parsed output surface sizes, output formats, and the given input
     * size and format.
     */
    private void prepareImageReadersWithOutputSpecs(JSONArray jsonOutputSpecs, Size inputSize,
            int inputFormat, int maxInputBuffers, boolean backgroundRequest) throws ItsException {
        Size outputSizes[];
        int outputFormats[];
        int numSurfaces = 0;
        mPhysicalStreamMap.clear();

        if (jsonOutputSpecs != null) {
            try {
                numSurfaces = jsonOutputSpecs.length();
                if (backgroundRequest) {
                    numSurfaces += 1;
                }
                if (numSurfaces > MAX_NUM_OUTPUT_SURFACES) {
                    throw new ItsException(""Too many output surfaces"");
                }

                outputSizes = new Size[numSurfaces];
                outputFormats = new int[numSurfaces];
                for (int i = 0; i < numSurfaces; i++) {
                    // Append optional background stream at the end
                    if (backgroundRequest && i == numSurfaces - 1) {
                        outputFormats[i] = ImageFormat.YUV_420_888;
                        outputSizes[i] = new Size(640, 480);
                        continue;
                    }
                    // Get the specified surface.
                    JSONObject surfaceObj = jsonOutputSpecs.getJSONObject(i);
                    String physicalCameraId = surfaceObj.optString(""physicalCamera"");
                    CameraCharacteristics cameraCharacteristics =  mCameraCharacteristics;
                    mPhysicalStreamMap.put(i, physicalCameraId);
                    if (!physicalCameraId.isEmpty()) {
                        cameraCharacteristics = mPhysicalCameraChars.get(physicalCameraId);
                    }

                    String sformat = surfaceObj.optString(""format"");
                    Size sizes[];
                    if (""yuv"".equals(sformat) || """".equals(sformat)) {
                        // Default to YUV if no format is specified.
                        outputFormats[i] = ImageFormat.YUV_420_888;
                        sizes = ItsUtils.getYuvOutputSizes(cameraCharacteristics);
                    } else if (""jpg"".equals(sformat) || ""jpeg"".equals(sformat)) {
                        outputFormats[i] = ImageFormat.JPEG;
                        sizes = ItsUtils.getJpegOutputSizes(cameraCharacteristics);
                    } else if (""raw"".equals(sformat)) {
                        outputFormats[i] = ImageFormat.RAW_SENSOR;
                        sizes = ItsUtils.getRaw16OutputSizes(cameraCharacteristics);
                    } else if (""raw10"".equals(sformat)) {
                        outputFormats[i] = ImageFormat.RAW10;
                        sizes = ItsUtils.getRaw10OutputSizes(cameraCharacteristics);
                    } else if (""raw12"".equals(sformat)) {
                        outputFormats[i] = ImageFormat.RAW12;
                        sizes = ItsUtils.getRaw12OutputSizes(cameraCharacteristics);
                    } else if (""dng"".equals(sformat)) {
                        outputFormats[i] = ImageFormat.RAW_SENSOR;
                        sizes = ItsUtils.getRaw16OutputSizes(cameraCharacteristics);
                        mCaptureRawIsDng = true;
                    } else if (""rawStats"".equals(sformat)) {
                        outputFormats[i] = ImageFormat.RAW_SENSOR;
                        sizes = ItsUtils.getRaw16OutputSizes(cameraCharacteristics);
                        mCaptureRawIsStats = true;
                        mCaptureStatsGridWidth = surfaceObj.optInt(""gridWidth"");
                        mCaptureStatsGridHeight = surfaceObj.optInt(""gridHeight"");
                    } else if (""y8"".equals(sformat)) {
                        outputFormats[i] = ImageFormat.Y8;
                        sizes = ItsUtils.getY8OutputSizes(cameraCharacteristics);
                    } else {
                        throw new ItsException(""Unsupported format: "" + sformat);
                    }
                    // If the size is omitted, then default to the largest allowed size for the
                    // format.
                    int width = surfaceObj.optInt(""width"");
                    int height = surfaceObj.optInt(""height"");
                    if (width <= 0) {
                        if (sizes == null || sizes.length == 0) {
                            throw new ItsException(String.format(
                                    ""Zero stream configs available for requested format: %s"",
                                    sformat));
                        }
                        width = ItsUtils.getMaxSize(sizes).getWidth();
                    }
                    if (height <= 0) {
                        height = ItsUtils.getMaxSize(sizes).getHeight();
                    }
                    // The stats computation only applies to the active array region.
                    int aaw = ItsUtils.getActiveArrayCropRegion(cameraCharacteristics).width();
                    int aah = ItsUtils.getActiveArrayCropRegion(cameraCharacteristics).height();
                    if (mCaptureStatsGridWidth <= 0 || mCaptureStatsGridWidth > aaw) {
                        mCaptureStatsGridWidth = aaw;
                    }
                    if (mCaptureStatsGridHeight <= 0 || mCaptureStatsGridHeight > aah) {
                        mCaptureStatsGridHeight = aah;
                    }

                    outputSizes[i] = new Size(width, height);
                }
            } catch (org.json.JSONException e) {
                throw new ItsException(""JSON error"", e);
            }
        } else {
            // No surface(s) specified at all.
            // Default: a single output surface which is full-res YUV.
            Size maxYuvSize = ItsUtils.getMaxOutputSize(
                    mCameraCharacteristics, ImageFormat.YUV_420_888);
            numSurfaces = backgroundRequest ? 2 : 1;

            outputSizes = new Size[numSurfaces];
            outputFormats = new int[numSurfaces];
            outputSizes[0] = maxYuvSize;
            outputFormats[0] = ImageFormat.YUV_420_888;
            if (backgroundRequest) {
                outputSizes[1] = new Size(640, 480);
                outputFormats[1] = ImageFormat.YUV_420_888;
            }
        }

        prepareImageReaders(outputSizes, outputFormats, inputSize, inputFormat, maxInputBuffers);
    }

    /**
     * Wait until mCountCallbacksRemaining is 0 or a specified amount of time has elapsed between
     * each callback.
     */
    private void waitForCallbacks(long timeoutMs) throws ItsException {
        synchronized(mCountCallbacksRemaining) {
            int currentCount = mCountCallbacksRemaining.get();
            while (currentCount > 0) {
                try {
                    mCountCallbacksRemaining.wait(timeoutMs);
                } catch (InterruptedException e) {
                    throw new ItsException(""Waiting for callbacks was interrupted."", e);
                }

                int newCount = mCountCallbacksRemaining.get();
                if (newCount == currentCount) {
                    throw new ItsException(""No callback received within timeout "" +
                            timeoutMs + ""ms"");
                }
                currentCount = newCount;
            }
        }
    }

    private void doCapture(JSONObject params) throws ItsException {
        try {
            // Parse the JSON to get the list of capture requests.
            List<CaptureRequest.Builder> requests = ItsSerializer.deserializeRequestList(
                    mCamera, params, ""captureRequests"");

            // optional background preview requests
            List<CaptureRequest.Builder> backgroundRequests = ItsSerializer.deserializeRequestList(
                    mCamera, params, ""repeatRequests"");
            boolean backgroundRequest = backgroundRequests.size() > 0;

            int numSurfaces = 0;
            int numCaptureSurfaces = 0;
            BlockingSessionCallback sessionListener = new BlockingSessionCallback();
            try {
                mCountRawOrDng.set(0);
                mCountJpg.set(0);
                mCountYuv.set(0);
                mCountRaw10.set(0);
                mCountRaw12.set(0);
                mCountCapRes.set(0);
                mCaptureRawIsDng = false;
                mCaptureRawIsStats = false;
                mCaptureResults = new CaptureResult[requests.size()];

                JSONArray jsonOutputSpecs = ItsUtils.getOutputSpecs(params);

                prepareImageReadersWithOutputSpecs(jsonOutputSpecs, /*inputSize*/null,
                        /*inputFormat*/0, /*maxInputBuffers*/0, backgroundRequest);
                numSurfaces = mOutputImageReaders.length;
                numCaptureSurfaces = numSurfaces - (backgroundRequest ? 1 : 0);

                List<OutputConfiguration> outputConfigs =
                        new ArrayList<OutputConfiguration>(numSurfaces);
                for (int i = 0; i < numSurfaces; i++) {
                    OutputConfiguration config = new OutputConfiguration(
                            mOutputImageReaders[i].getSurface());
                    if (mPhysicalStreamMap.get(i) != null) {
                        config.setPhysicalCameraId(mPhysicalStreamMap.get(i));
                    }
                    outputConfigs.add(config);
                }
                mCamera.createCaptureSessionByOutputConfigurations(outputConfigs,
                        sessionListener, mCameraHandler);
                mSession = sessionListener.waitAndGetSession(TIMEOUT_IDLE_MS);

                for (int i = 0; i < numSurfaces; i++) {
                    ImageReader.OnImageAvailableListener readerListener;
                    if (backgroundRequest && i == numSurfaces - 1) {
                        readerListener = createAvailableListenerDropper();
                    } else {
                        readerListener = createAvailableListener(mCaptureCallback);
                    }
                    mOutputImageReaders[i].setOnImageAvailableListener(readerListener,
                            mSaveHandlers[i]);
                }

                // Plan for how many callbacks need to be received throughout the duration of this
                // sequence of capture requests. There is one callback per image surface, and one
                // callback for the CaptureResult, for each capture.
                int numCaptures = requests.size();
                mCountCallbacksRemaining.set(numCaptures * (numCaptureSurfaces + 1));

            } catch (CameraAccessException e) {
                throw new ItsException(""Error configuring outputs"", e);
            }

            // Start background requests and let it warm up pipeline
            if (backgroundRequest) {
                List<CaptureRequest> bgRequestList =
                        new ArrayList<CaptureRequest>(backgroundRequests.size());
                for (int i = 0; i < backgroundRequests.size(); i++) {
                    CaptureRequest.Builder req = backgroundRequests.get(i);
                    req.addTarget(mOutputImageReaders[numCaptureSurfaces].getSurface());
                    bgRequestList.add(req.build());
                }
                mSession.setRepeatingBurst(bgRequestList, null, null);
                // warm up the pipeline
                Thread.sleep(PIPELINE_WARMUP_TIME_MS);
            }

            // Initiate the captures.
            long maxExpTimeNs = -1;
            List<CaptureRequest> requestList =
                    new ArrayList<>(requests.size());
            for (int i = 0; i < requests.size(); i++) {
                CaptureRequest.Builder req = requests.get(i);
                // For DNG captures, need the LSC map to be available.
                if (mCaptureRawIsDng) {
                    req.set(CaptureRequest.STATISTICS_LENS_SHADING_MAP_MODE, 1);
                }
                Long expTimeNs = req.get(CaptureRequest.SENSOR_EXPOSURE_TIME);
                if (expTimeNs != null && expTimeNs > maxExpTimeNs) {
                    maxExpTimeNs = expTimeNs;
                }

                for (int j = 0; j < numCaptureSurfaces; j++) {
                    req.addTarget(mOutputImageReaders[j].getSurface());
                }
                requestList.add(req.build());
            }
            mSession.captureBurst(requestList, mCaptureResultListener, mResultHandler);

            long timeout = TIMEOUT_CALLBACK * 1000;
            if (maxExpTimeNs > 0) {
                timeout += maxExpTimeNs / 1000000; // ns to ms
            }
            // Make sure all callbacks have been hit (wait until captures are done).
            // If no timeouts are received after a timeout, then fail.
            waitForCallbacks(timeout);

            // Close session and wait until session is fully closed
            mSession.close();
            sessionListener.getStateWaiter().waitForState(
                    BlockingSessionCallback.SESSION_CLOSED, TIMEOUT_SESSION_CLOSE);

        } catch (android.hardware.camera2.CameraAccessException e) {
            throw new ItsException(""Access error: "", e);
        } catch (InterruptedException e) {
            throw new ItsException(""Unexpected InterruptedException: "", e);
        }
    }

    /**
     * Perform reprocess captures.
     *
     * It takes captureRequests in a JSON object and perform capture requests in two steps:
     * regular capture request to get reprocess input and reprocess capture request to get
     * reprocess outputs.
     *
     * Regular capture requests:
     *   1. For each capture request in the JSON object, create a full-size capture request with
     *      the settings in the JSON object.
     *   2. Remember and clear noise reduction, edge enhancement, and effective exposure factor
     *      from the regular capture requests. (Those settings will be used for reprocess requests.)
     *   3. Submit the regular capture requests.
     *
     * Reprocess capture requests:
     *   4. Wait for the regular capture results and use them to create reprocess capture requests.
     *   5. Wait for the regular capture output images and queue them to the image writer.
     *   6. Set the noise reduction, edge enhancement, and effective exposure factor from #2.
     *   7. Submit the reprocess capture requests.
     *
     * The output images and results for the regular capture requests won't be written to socket.
     * The output images and results for the reprocess capture requests will be written to socket.
     */
    private void doReprocessCapture(JSONObject params) throws ItsException {
        ImageWriter imageWriter = null;
        ArrayList<Integer> noiseReductionModes = new ArrayList<>();
        ArrayList<Integer> edgeModes = new ArrayList<>();
        ArrayList<Float> effectiveExposureFactors = new ArrayList<>();

        mCountRawOrDng.set(0);
        mCountJpg.set(0);
        mCountYuv.set(0);
        mCountRaw10.set(0);
        mCountRaw12.set(0);
        mCountCapRes.set(0);
        mCaptureRawIsDng = false;
        mCaptureRawIsStats = false;

        try {
            // Parse the JSON to get the list of capture requests.
            List<CaptureRequest.Builder> inputRequests =
                    ItsSerializer.deserializeRequestList(mCamera, params, ""captureRequests"");

            // Prepare the image readers for reprocess input and reprocess outputs.
            int inputFormat = getReprocessInputFormat(params);
            Size inputSize = ItsUtils.getMaxOutputSize(mCameraCharacteristics, inputFormat);
            JSONArray jsonOutputSpecs = ItsUtils.getOutputSpecs(params);
            prepareImageReadersWithOutputSpecs(jsonOutputSpecs, inputSize, inputFormat,
                    inputRequests.size(), /*backgroundRequest*/false);

            // Prepare a reprocessable session.
            int numOutputSurfaces = mOutputImageReaders.length;
            InputConfiguration inputConfig = new InputConfiguration(inputSize.getWidth(),
                    inputSize.getHeight(), inputFormat);
            List<Surface> outputSurfaces = new ArrayList<Surface>();
            boolean addSurfaceForInput = true;
            for (int i = 0; i < numOutputSurfaces; i++) {
                outputSurfaces.add(mOutputImageReaders[i].getSurface());
                if (mOutputImageReaders[i] == mInputImageReader) {
                    // If input and one of the outputs share the same image reader, avoid
                    // adding the same surfaces twice.
                    addSurfaceForInput = false;
                }
            }

            if (addSurfaceForInput) {
                // Besides the output surfaces specified in JSON object, add an additional one
                // for reprocess input.
                outputSurfaces.add(mInputImageReader.getSurface());
            }

            BlockingSessionCallback sessionListener = new BlockingSessionCallback();
            mCamera.createReprocessableCaptureSession(inputConfig, outputSurfaces, sessionListener,
                    mCameraHandler);
            mSession = sessionListener.waitAndGetSession(TIMEOUT_IDLE_MS);

            // Create an image writer for reprocess input.
            Surface inputSurface = mSession.getInputSurface();
            imageWriter = ImageWriter.newInstance(inputSurface, inputRequests.size());

            // Set up input reader listener and capture callback listener to get
            // reprocess input buffers and the results in order to create reprocess capture
            // requests.
            ImageReaderListenerWaiter inputReaderListener = new ImageReaderListenerWaiter();
            mInputImageReader.setOnImageAvailableListener(inputReaderListener, mSaveHandlers[0]);

            CaptureCallbackWaiter captureCallbackWaiter = new CaptureCallbackWaiter();
            // Prepare the reprocess input request
            for (CaptureRequest.Builder inputReqest : inputRequests) {
                // Remember and clear noise reduction, edge enhancement, and effective exposure
                // factors.
                noiseReductionModes.add(inputReqest.get(CaptureRequest.NOISE_REDUCTION_MODE));
                edgeModes.add(inputReqest.get(CaptureRequest.EDGE_MODE));
                effectiveExposureFactors.add(inputReqest.get(
                        CaptureRequest.REPROCESS_EFFECTIVE_EXPOSURE_FACTOR));

                inputReqest.set(CaptureRequest.NOISE_REDUCTION_MODE,
                        CaptureRequest.NOISE_REDUCTION_MODE_ZERO_SHUTTER_LAG);
                inputReqest.set(CaptureRequest.EDGE_MODE, CaptureRequest.EDGE_MODE_ZERO_SHUTTER_LAG);
                inputReqest.set(CaptureRequest.REPROCESS_EFFECTIVE_EXPOSURE_FACTOR, null);
                inputReqest.addTarget(mInputImageReader.getSurface());
                mSession.capture(inputReqest.build(), captureCallbackWaiter, mResultHandler);
            }

            // Wait for reprocess input images
            ArrayList<CaptureRequest.Builder> reprocessOutputRequests = new ArrayList<>();
            for (int i = 0; i < inputRequests.size(); i++) {
                TotalCaptureResult result =
                        captureCallbackWaiter.getResult(TIMEOUT_CALLBACK * 1000);
                reprocessOutputRequests.add(mCamera.createReprocessCaptureRequest(result));
                imageWriter.queueInputImage(inputReaderListener.getImage(TIMEOUT_CALLBACK * 1000));
            }

            // Start performing reprocess captures.

            mCaptureResults = new CaptureResult[inputRequests.size()];

            // Prepare reprocess capture requests.
            for (int i = 0; i < numOutputSurfaces; i++) {
                ImageReader.OnImageAvailableListener outputReaderListener =
                        createAvailableListener(mCaptureCallback);
                mOutputImageReaders[i].setOnImageAvailableListener(outputReaderListener,
                        mSaveHandlers[i]);
            }

            // Plan for how many callbacks need to be received throughout the duration of this
            // sequence of capture requests. There is one callback per image surface, and one
            // callback for the CaptureResult, for each capture.
            int numCaptures = reprocessOutputRequests.size();
            mCountCallbacksRemaining.set(numCaptures * (numOutputSurfaces + 1));

            // Initiate the captures.
            for (int i = 0; i < reprocessOutputRequests.size(); i++) {
                CaptureRequest.Builder req = reprocessOutputRequests.get(i);
                for (ImageReader outputImageReader : mOutputImageReaders) {
                    req.addTarget(outputImageReader.getSurface());
                }

                req.set(CaptureRequest.NOISE_REDUCTION_MODE, noiseReductionModes.get(i));
                req.set(CaptureRequest.EDGE_MODE, edgeModes.get(i));
                req.set(CaptureRequest.REPROCESS_EFFECTIVE_EXPOSURE_FACTOR,
                        effectiveExposureFactors.get(i));

                mSession.capture(req.build(), mCaptureResultListener, mResultHandler);
            }

            // Make sure all callbacks have been hit (wait until captures are done).
            // If no timeouts are received after a timeout, then fail.
            waitForCallbacks(TIMEOUT_CALLBACK * 1000);
        } catch (android.hardware.camera2.CameraAccessException e) {
            throw new ItsException(""Access error: "", e);
        } finally {
            closeImageReaders();
            if (mSession != null) {
                mSession.close();
                mSession = null;
            }
            if (imageWriter != null) {
                imageWriter.close();
            }
        }
    }

    @Override
    public final void onAccuracyChanged(Sensor sensor, int accuracy) {
        Logt.i(TAG, ""Sensor "" + sensor.getName() + "" accuracy changed to "" + accuracy);
    }

    @Override
    public final void onSensorChanged(SensorEvent event) {
        synchronized(mEventLock) {
            if (mEventsEnabled) {
                MySensorEvent ev2 = new MySensorEvent();
                ev2.sensor = event.sensor;
                ev2.accuracy = event.accuracy;
                ev2.timestamp = event.timestamp;
                ev2.values = new float[event.values.length];
                System.arraycopy(event.values, 0, ev2.values, 0, event.values.length);
                mEvents.add(ev2);
            }
        }
    }

    private final CaptureCallback mCaptureCallback = new CaptureCallback() {
        @Override
        public void onCaptureAvailable(Image capture, String physicalCameraId) {
            try {
                int format = capture.getFormat();
                if (format == ImageFormat.JPEG) {
                    Logt.i(TAG, ""Received JPEG capture"");
                    byte[] img = ItsUtils.getDataFromImage(capture, mSocketQueueQuota);
                    ByteBuffer buf = ByteBuffer.wrap(img);
                    int count = mCountJpg.getAndIncrement();
                    mSocketRunnableObj.sendResponseCaptureBuffer(""jpegImage""+physicalCameraId, buf);
                } else if (format == ImageFormat.YUV_420_888) {
                    Logt.i(TAG, ""Received YUV capture"");
                    byte[] img = ItsUtils.getDataFromImage(capture, mSocketQueueQuota);
                    ByteBuffer buf = ByteBuffer.wrap(img);
                    mSocketRunnableObj.sendResponseCaptureBuffer(
                            ""yuvImage""+physicalCameraId, buf);
                } else if (format == ImageFormat.RAW10) {
                    Logt.i(TAG, ""Received RAW10 capture"");
                    byte[] img = ItsUtils.getDataFromImage(capture, mSocketQueueQuota);
                    ByteBuffer buf = ByteBuffer.wrap(img);
                    int count = mCountRaw10.getAndIncrement();
                    mSocketRunnableObj.sendResponseCaptureBuffer(
                            ""raw10Image""+physicalCameraId, buf);
                } else if (format == ImageFormat.RAW12) {
                    Logt.i(TAG, ""Received RAW12 capture"");
                    byte[] img = ItsUtils.getDataFromImage(capture, mSocketQueueQuota);
                    ByteBuffer buf = ByteBuffer.wrap(img);
                    int count = mCountRaw12.getAndIncrement();
                    mSocketRunnableObj.sendResponseCaptureBuffer(""raw12Image""+physicalCameraId, buf);
                } else if (format == ImageFormat.RAW_SENSOR) {
                    Logt.i(TAG, ""Received RAW16 capture"");
                    int count = mCountRawOrDng.getAndIncrement();
                    if (! mCaptureRawIsDng) {
                        byte[] img = ItsUtils.getDataFromImage(capture, mSocketQueueQuota);
                        if (! mCaptureRawIsStats) {
                            ByteBuffer buf = ByteBuffer.wrap(img);
                            mSocketRunnableObj.sendResponseCaptureBuffer(
                                    ""rawImage"" + physicalCameraId, buf);
                        } else {
                            // Compute the requested stats on the raw frame, and return the results
                            // in a new ""stats image"".
                            long startTimeMs = SystemClock.elapsedRealtime();
                            int w = capture.getWidth();
                            int h = capture.getHeight();
                            int aaw = ItsUtils.getActiveArrayCropRegion(mCameraCharacteristics)
                                              .width();
                            int aah = ItsUtils.getActiveArrayCropRegion(mCameraCharacteristics)
                                              .height();
                            int aax = ItsUtils.getActiveArrayCropRegion(mCameraCharacteristics)
                                              .left;
                            int aay = ItsUtils.getActiveArrayCropRegion(mCameraCharacteristics)
                                              .top;

                            if (w == aaw) {
                                aax = 0;
                            }
                            if (h == aah) {
                                aay = 0;
                            }

                            int gw = mCaptureStatsGridWidth;
                            int gh = mCaptureStatsGridHeight;
                            float[] stats = StatsImage.computeStatsImage(
                                                             img, w, h, aax, aay, aaw, aah, gw, gh);
                            long endTimeMs = SystemClock.elapsedRealtime();
                            Log.e(TAG, ""Raw stats computation takes "" + (endTimeMs - startTimeMs) + "" ms"");
                            int statsImgSize = stats.length * 4;
                            if (mSocketQueueQuota != null) {
                                mSocketQueueQuota.release(img.length);
                                mSocketQueueQuota.acquire(statsImgSize);
                            }
                            ByteBuffer bBuf = ByteBuffer.allocate(statsImgSize);
                            bBuf.order(ByteOrder.nativeOrder());
                            FloatBuffer fBuf = bBuf.asFloatBuffer();
                            fBuf.put(stats);
                            fBuf.position(0);
                            mSocketRunnableObj.sendResponseCaptureBuffer(
                                    ""rawStatsImage""+physicalCameraId, bBuf);
                        }
                    } else {
                        // Wait until the corresponding capture result is ready, up to a timeout.
                        long t0 = android.os.SystemClock.elapsedRealtime();
                        while (! mThreadExitFlag
                                && android.os.SystemClock.elapsedRealtime()-t0 < TIMEOUT_CAP_RES) {
                            if (mCaptureResults[count] != null) {
                                Logt.i(TAG, ""Writing capture as DNG"");
                                DngCreator dngCreator = new DngCreator(
                                        mCameraCharacteristics, mCaptureResults[count]);
                                ByteArrayOutputStream dngStream = new ByteArrayOutputStream();
                                dngCreator.writeImage(dngStream, capture);
                                byte[] dngArray = dngStream.toByteArray();
                                if (mSocketQueueQuota != null) {
                                    // Ideally we should acquire before allocating memory, but
                                    // here the DNG size is unknown before toByteArray call, so
                                    // we have to register the size afterward. This should still
                                    // works most of the time since all DNG images are handled by
                                    // the same handler thread, so we are at most one buffer over
                                    // the quota.
                                    mSocketQueueQuota.acquire(dngArray.length);
                                }
                                ByteBuffer dngBuf = ByteBuffer.wrap(dngArray);
                                mSocketRunnableObj.sendResponseCaptureBuffer(""dngImage"", dngBuf);
                                break;
                            } else {
                                Thread.sleep(1);
                            }
                        }
                    }
                } else if (format == ImageFormat.Y8) {
                    Logt.i(TAG, ""Received Y8 capture"");
                    byte[] img = ItsUtils.getDataFromImage(capture, mSocketQueueQuota);
                    ByteBuffer buf = ByteBuffer.wrap(img);
                    mSocketRunnableObj.sendResponseCaptureBuffer(
                            ""y8Image""+physicalCameraId, buf);
                } else {
                    throw new ItsException(""Unsupported image format: "" + format);
                }

                synchronized(mCountCallbacksRemaining) {
                    mCountCallbacksRemaining.decrementAndGet();
                    mCountCallbacksRemaining.notify();
                }
            } catch (IOException e) {
                Logt.e(TAG, ""Script error: "", e);
            } catch (InterruptedException e) {
                Logt.e(TAG, ""Script error: "", e);
            } catch (ItsException e) {
                Logt.e(TAG, ""Script error: "", e);
            }
        }
    };

    private static float r2f(Rational r) {
        return (float)r.getNumerator() / (float)r.getDenominator();
    }

    private boolean hasCapability(int capability) throws ItsException {
        int[] capabilities = mCameraCharacteristics.get(
                CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES);
        if (capabilities == null) {
            throw new ItsException(""Failed to get capabilities"");
        }
        for (int c : capabilities) {
            if (c == capability) {
                return true;
            }
        }
        return false;
    }

    private String buildLogString(CaptureResult result) throws ItsException {
        StringBuilder logMsg = new StringBuilder();
        logMsg.append(String.format(
                ""Capt result: AE=%d, AF=%d, AWB=%d, "",
                result.get(CaptureResult.CONTROL_AE_STATE),
                result.get(CaptureResult.CONTROL_AF_STATE),
                result.get(CaptureResult.CONTROL_AWB_STATE)));

        boolean readSensorSettings = hasCapability(
                CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_READ_SENSOR_SETTINGS);

        if (readSensorSettings) {
            logMsg.append(String.format(
                    ""sens=%d, exp=%.1fms, dur=%.1fms, "",
                    result.get(CaptureResult.SENSOR_SENSITIVITY),
                    result.get(CaptureResult.SENSOR_EXPOSURE_TIME).longValue() / 1000000.0f,
                    result.get(CaptureResult.SENSOR_FRAME_DURATION).longValue() /
                                1000000.0f));
        }
        if (result.get(CaptureResult.COLOR_CORRECTION_GAINS) != null) {
            logMsg.append(String.format(
                    ""gains=[%.1f, %.1f, %.1f, %.1f], "",
                    result.get(CaptureResult.COLOR_CORRECTION_GAINS).getRed(),
                    result.get(CaptureResult.COLOR_CORRECTION_GAINS).getGreenEven(),
                    result.get(CaptureResult.COLOR_CORRECTION_GAINS).getGreenOdd(),
                    result.get(CaptureResult.COLOR_CORRECTION_GAINS).getBlue()));
        } else {
            logMsg.append(""gains=[], "");
        }
        if (result.get(CaptureResult.COLOR_CORRECTION_TRANSFORM) != null) {
            logMsg.append(String.format(
                    ""xform=[%.1f, %.1f, %.1f, %.1f, %.1f, %.1f, %.1f, %.1f, %.1f], "",
                    r2f(result.get(CaptureResult.COLOR_CORRECTION_TRANSFORM).getElement(0,0)),
                    r2f(result.get(CaptureResult.COLOR_CORRECTION_TRANSFORM).getElement(1,0)),
                    r2f(result.get(CaptureResult.COLOR_CORRECTION_TRANSFORM).getElement(2,0)),
                    r2f(result.get(CaptureResult.COLOR_CORRECTION_TRANSFORM).getElement(0,1)),
                    r2f(result.get(CaptureResult.COLOR_CORRECTION_TRANSFORM).getElement(1,1)),
                    r2f(result.get(CaptureResult.COLOR_CORRECTION_TRANSFORM).getElement(2,1)),
                    r2f(result.get(CaptureResult.COLOR_CORRECTION_TRANSFORM).getElement(0,2)),
                    r2f(result.get(CaptureResult.COLOR_CORRECTION_TRANSFORM).getElement(1,2)),
                    r2f(result.get(CaptureResult.COLOR_CORRECTION_TRANSFORM).getElement(2,2))));
        } else {
            logMsg.append(""xform=[], "");
        }
        logMsg.append(String.format(
                ""foc=%.1f"",
                result.get(CaptureResult.LENS_FOCUS_DISTANCE)));
        return logMsg.toString();
    }

    private class ThreeAResultListener extends CaptureResultListener {
        private volatile boolean stopped = false;
        private boolean aeResultSent = false;
        private boolean awbResultSent = false;
        private boolean afResultSent = false;

        @Override
        public void onCaptureStarted(CameraCaptureSession session, CaptureRequest request,
                long timestamp, long frameNumber) {
        }

        @Override
        public void onCaptureCompleted(CameraCaptureSession session, CaptureRequest request,
                TotalCaptureResult result) {
            try {
                if (stopped) {
                    return;
                }

                if (request == null || result == null) {
                    throw new ItsException(""Request/result is invalid"");
                }

                Logt.i(TAG, buildLogString(result));

                synchronized(m3AStateLock) {
                    if (result.get(CaptureResult.CONTROL_AE_STATE) != null) {
                        mConvergedAE = result.get(CaptureResult.CONTROL_AE_STATE) ==
                                                  CaptureResult.CONTROL_AE_STATE_CONVERGED ||
                                       result.get(CaptureResult.CONTROL_AE_STATE) ==
                                                  CaptureResult.CONTROL_AE_STATE_FLASH_REQUIRED ||
                                       result.get(CaptureResult.CONTROL_AE_STATE) ==
                                                  CaptureResult.CONTROL_AE_STATE_LOCKED;
                        mLockedAE = result.get(CaptureResult.CONTROL_AE_STATE) ==
                                               CaptureResult.CONTROL_AE_STATE_LOCKED;
                    }
                    if (result.get(CaptureResult.CONTROL_AF_STATE) != null) {
                        mConvergedAF = result.get(CaptureResult.CONTROL_AF_STATE) ==
                                                  CaptureResult.CONTROL_AF_STATE_FOCUSED_LOCKED;
                    }
                    if (result.get(CaptureResult.CONTROL_AWB_STATE) != null) {
                        mConvergedAWB = result.get(CaptureResult.CONTROL_AWB_STATE) ==
                                                   CaptureResult.CONTROL_AWB_STATE_CONVERGED ||
                                        result.get(CaptureResult.CONTROL_AWB_STATE) ==
                                                   CaptureResult.CONTROL_AWB_STATE_LOCKED;
                        mLockedAWB = result.get(CaptureResult.CONTROL_AWB_STATE) ==
                                                CaptureResult.CONTROL_AWB_STATE_LOCKED;
                    }

                    if (mConvergedAE && (!mNeedsLockedAE || mLockedAE) && !aeResultSent) {
                        aeResultSent = true;
                        if (result.get(CaptureResult.SENSOR_SENSITIVITY) != null
                                && result.get(CaptureResult.SENSOR_EXPOSURE_TIME) != null) {
                            mSocketRunnableObj.sendResponse(""aeResult"", String.format(""%d %d"",
                                    result.get(CaptureResult.SENSOR_SENSITIVITY).intValue(),
                                    result.get(CaptureResult.SENSOR_EXPOSURE_TIME).intValue()
                                    ));
                        } else {
                            Logt.i(TAG, String.format(
                                    ""AE converged but NULL exposure values, sensitivity:%b, expTime:%b"",
                                    result.get(CaptureResult.SENSOR_SENSITIVITY) == null,
                                    result.get(CaptureResult.SENSOR_EXPOSURE_TIME) == null));
                        }
                    }

                    if (mConvergedAF && !afResultSent) {
                        afResultSent = true;
                        if (result.get(CaptureResult.LENS_FOCUS_DISTANCE) != null) {
                            mSocketRunnableObj.sendResponse(""afResult"", String.format(""%f"",
                                    result.get(CaptureResult.LENS_FOCUS_DISTANCE)
                                    ));
                        } else {
                            Logt.i(TAG, ""AF converged but NULL focus distance values"");
                        }
                    }

                    if (mConvergedAWB && (!mNeedsLockedAWB || mLockedAWB) && !awbResultSent) {
                        awbResultSent = true;
                        if (result.get(CaptureResult.COLOR_CORRECTION_GAINS) != null
                                && result.get(CaptureResult.COLOR_CORRECTION_TRANSFORM) != null) {
                            mSocketRunnableObj.sendResponse(""awbResult"", String.format(
                                    ""%f %f %f %f %f %f %f %f %f %f %f %f %f"",
                                    result.get(CaptureResult.COLOR_CORRECTION_GAINS).getRed(),
                                    result.get(CaptureResult.COLOR_CORRECTION_GAINS).getGreenEven(),
                                    result.get(CaptureResult.COLOR_CORRECTION_GAINS).getGreenOdd(),
                                    result.get(CaptureResult.COLOR_CORRECTION_GAINS).getBlue(),
                                    r2f(result.get(CaptureResult.COLOR_CORRECTION_TRANSFORM).
                                            getElement(0,0)),
                                    r2f(result.get(CaptureResult.COLOR_CORRECTION_TRANSFORM).
                                            getElement(1,0)),
                                    r2f(result.get(CaptureResult.COLOR_CORRECTION_TRANSFORM).
                                            getElement(2,0)),
                                    r2f(result.get(CaptureResult.COLOR_CORRECTION_TRANSFORM).
                                            getElement(0,1)),
                                    r2f(result.get(CaptureResult.COLOR_CORRECTION_TRANSFORM).
                                            getElement(1,1)),
                                    r2f(result.get(CaptureResult.COLOR_CORRECTION_TRANSFORM).
                                            getElement(2,1)),
                                    r2f(result.get(CaptureResult.COLOR_CORRECTION_TRANSFORM).
                                            getElement(0,2)),
                                    r2f(result.get(CaptureResult.COLOR_CORRECTION_TRANSFORM).
                                            getElement(1,2)),
                                    r2f(result.get(CaptureResult.COLOR_CORRECTION_TRANSFORM).
                                            getElement(2,2))));
                        } else {
                            Logt.i(TAG, String.format(
                                    ""AWB converged but NULL color correction values, gains:%b, ccm:%b"",
                                    result.get(CaptureResult.COLOR_CORRECTION_GAINS) == null,
                                    result.get(CaptureResult.COLOR_CORRECTION_TRANSFORM) == null));
                        }
                    }
                }

                mInterlock3A.open();
            } catch (ItsException e) {
                Logt.e(TAG, ""Script error: "", e);
            } catch (Exception e) {
                Logt.e(TAG, ""Script error: "", e);
            }
        }

        @Override
        public void onCaptureFailed(CameraCaptureSession session, CaptureRequest request,
                CaptureFailure failure) {
            Logt.e(TAG, ""Script error: capture failed"");
        }

        public void stop() {
            stopped = true;
        }
    }

    private final CaptureResultListener mCaptureResultListener = new CaptureResultListener() {
        @Override
        public void onCaptureStarted(CameraCaptureSession session, CaptureRequest request,
                long timestamp, long frameNumber) {
        }

        @Override
        public void onCaptureCompleted(CameraCaptureSession session, CaptureRequest request,
                TotalCaptureResult result) {
            try {
                if (request == null || result == null) {
                    throw new ItsException(""Request/result is invalid"");
                }

                Logt.i(TAG, buildLogString(result));

                int count = mCountCapRes.getAndIncrement();
                mCaptureResults[count] = result;
                mSocketRunnableObj.sendResponseCaptureResult(mCameraCharacteristics,
                        request, result, mOutputImageReaders);
                synchronized(mCountCallbacksRemaining) {
                    mCountCallbacksRemaining.decrementAndGet();
                    mCountCallbacksRemaining.notify();
                }
            } catch (ItsException e) {
                Logt.e(TAG, ""Script error: "", e);
            } catch (Exception e) {
                Logt.e(TAG, ""Script error: "", e);
            }
        }

        @Override
        public void onCaptureFailed(CameraCaptureSession session, CaptureRequest request,
                CaptureFailure failure) {
            Logt.e(TAG, ""Script error: capture failed"");
        }
    };

    private class CaptureCallbackWaiter extends CameraCaptureSession.CaptureCallback {
        private final LinkedBlockingQueue<TotalCaptureResult> mResultQueue =
                new LinkedBlockingQueue<>();

        @Override
        public void onCaptureStarted(CameraCaptureSession session, CaptureRequest request,
                long timestamp, long frameNumber) {
        }

        @Override
        public void onCaptureCompleted(CameraCaptureSession session, CaptureRequest request,
                TotalCaptureResult result) {
            try {
                mResultQueue.put(result);
            } catch (InterruptedException e) {
                throw new UnsupportedOperationException(
                        ""Can't handle InterruptedException in onImageAvailable"");
            }
        }

        @Override
        public void onCaptureFailed(CameraCaptureSession session, CaptureRequest request,
                CaptureFailure failure) {
            Logt.e(TAG, ""Script error: capture failed"");
        }

        public TotalCaptureResult getResult(long timeoutMs) throws ItsException {
            TotalCaptureResult result;
            try {
                result = mResultQueue.poll(timeoutMs, TimeUnit.MILLISECONDS);
            } catch (InterruptedException e) {
                throw new ItsException(e);
            }

            if (result == null) {
                throw new ItsException(""Getting an image timed out after "" + timeoutMs +
                        ""ms"");
            }

            return result;
        }
    }

    private static class ImageReaderListenerWaiter implements ImageReader.OnImageAvailableListener {
        private final LinkedBlockingQueue<Image> mImageQueue = new LinkedBlockingQueue<>();

        @Override
        public void onImageAvailable(ImageReader reader) {
            try {
                mImageQueue.put(reader.acquireNextImage());
            } catch (InterruptedException e) {
                throw new UnsupportedOperationException(
                        ""Can't handle InterruptedException in onImageAvailable"");
            }
        }

        public Image getImage(long timeoutMs) throws ItsException {
            Image image;
            try {
                image = mImageQueue.poll(timeoutMs, TimeUnit.MILLISECONDS);
            } catch (InterruptedException e) {
                throw new ItsException(e);
            }

            if (image == null) {
                throw new ItsException(""Getting an image timed out after "" + timeoutMs +
                        ""ms"");
            }
            return image;
        }
    }

    private int getReprocessInputFormat(JSONObject params) throws ItsException {
        String reprocessFormat;
        try {
            reprocessFormat = params.getString(""reprocessFormat"");
        } catch (org.json.JSONException e) {
            throw new ItsException(""Error parsing reprocess format: "" + e);
        }

        if (reprocessFormat.equals(""yuv"")) {
            return ImageFormat.YUV_420_888;
        } else if (reprocessFormat.equals(""private"")) {
            return ImageFormat.PRIVATE;
        }

        throw new ItsException(""Uknown reprocess format: "" + reprocessFormat);
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.BaseDevicePolicyTest"	"isHeadlessSystemUserMode"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/BaseDevicePolicyTest.java"	""	"public void test/*
 *.
 */

package com.android.cts.devicepolicy;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.junit.Assume.assumeFalse;
import static org.junit.Assume.assumeTrue;

import com.android.compatibility.common.tradefed.build.CompatibilityBuildHelper;
import com.android.role.RoleProto;
import com.android.role.RoleServiceDumpProto;
import com.android.role.RoleUserStateProto;
import com.android.tradefed.config.Option;
import com.android.tradefed.device.CollectingByteOutputReceiver;
import com.android.tradefed.device.CollectingOutputReceiver;
import com.android.tradefed.device.DeviceNotAvailableException;
import com.android.tradefed.device.ITestDevice;
import com.android.tradefed.log.LogUtil.CLog;
import com.android.tradefed.testtype.DeviceJUnit4ClassRunner;
import com.android.tradefed.testtype.junit4.BaseHostJUnit4Test;

import com.google.common.base.Strings;
import com.google.common.io.ByteStreams;

import org.junit.After;
import org.junit.AssumptionViolatedException;
import org.junit.Before;
import org.junit.Rule;
import org.junit.runner.RunWith;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.TimeUnit;
import java.util.function.Predicate;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.annotation.Nullable;

/**
 * Base class for device policy tests. It offers utility methods to run tests, set device or profile
 * owner, etc.
 */
@RunWith(DeviceJUnit4ClassRunner.class)
public abstract class BaseDevicePolicyTest extends BaseHostJUnit4Test {

    private static final String FEATURE_BLUETOOTH = ""android.hardware.bluetooth"";
    private static final String FEATURE_CAMERA = ""android.hardware.camera"";
    private static final String FEATURE_CONNECTION_SERVICE = ""android.software.connectionservice"";
    private static final String FEATURE_FBE = ""android.software.file_based_encryption"";
    private static final String FEATURE_LEANBACK = ""android.software.leanback"";
    private static final String FEATURE_NFC = ""android.hardware.nfc"";
    private static final String FEATURE_NFC_BEAM = ""android.software.nfc.beam"";

    private static final String FEATURE_PRINT = ""android.software.print"";
    private static final String FEATURE_TELEPHONY = ""android.hardware.telephony"";
    private static final String FEATURE_SECURE_LOCK_SCREEN = ""android.software.secure_lock_screen"";
    private static final String FEATURE_WIFI = ""android.hardware.wifi"";

    //The maximum time to wait for user to be unlocked.
    private static final long USER_UNLOCK_TIMEOUT_SEC = 30;
    private static final String USER_STATE_UNLOCKED = ""RUNNING_UNLOCKED"";

    protected static final String PERMISSION_INTERACT_ACROSS_USERS =
            ""android.permission.INTERACT_ACROSS_USERS"";

    @Option(
            name = ""skip-device-admin-feature-check"",
            description = ""Flag that allows to skip the check for android.software.device_admin ""
                + ""and run the tests no matter what. This is useful for system that do not what ""
                + ""to expose that feature publicly.""
    )
    private boolean mSkipDeviceAdminFeatureCheck = false;

    private static final String RUNNER = ""androidx.test.runner.AndroidJUnitRunner"";

    protected static final int USER_SYSTEM = 0; // From the UserHandle class.

    protected static final int USER_OWNER = USER_SYSTEM;

    private static final long TIMEOUT_USER_REMOVED_MILLIS = TimeUnit.SECONDS.toMillis(15);
    private static final long WAIT_SAMPLE_INTERVAL_MILLIS = 200;

    /**
     * The defined timeout (in milliseconds) is used as a maximum waiting time when expecting the
     * command output from the device. At any time, if the shell command does not output anything
     * for a period longer than defined timeout the Tradefed run terminates.
     */
    private static final long DEFAULT_SHELL_TIMEOUT_MILLIS = TimeUnit.MINUTES.toMillis(20);

    /**
     * Sets timeout (in milliseconds) that will be applied to each test. In the
     * event of a test timeout it will log the results and proceed with executing the next test.
     */
    private static final long DEFAULT_TEST_TIMEOUT_MILLIS = TimeUnit.MINUTES.toMillis(10);

    /**
     * The amount of milliseconds to wait for the remove user calls in {@link #tearDown}.
     * This is a temporary measure until b/114057686 is fixed.
     */
    private static final long USER_REMOVE_WAIT = TimeUnit.SECONDS.toMillis(5);

    /**
     * The amount of milliseconds to wait for the switch user calls in {@link #tearDown}.
     */
    private static final long USER_SWITCH_WAIT = TimeUnit.SECONDS.toMillis(5);

    // From the UserInfo class
    protected static final int FLAG_GUEST = 0x00000004;
    protected static final int FLAG_EPHEMERAL = 0x00000100;
    protected static final int FLAG_MANAGED_PROFILE = 0x00000020;

    /** Default password to use in tests. */
    protected static final String TEST_PASSWORD = ""1234"";

    /**
     * The {@link android.os.BatteryManager} flags value representing all charging types; {@link
     * android.os.BatteryManager#BATTERY_PLUGGED_AC}, {@link
     * android.os.BatteryManager#BATTERY_PLUGGED_USB}, and {@link
     * android.os.BatteryManager#BATTERY_PLUGGED_WIRELESS}.
     */
    private static final int STAY_ON_WHILE_PLUGGED_IN_FLAGS = 7;

    /**
     * User ID for all users.
     * The value is from the UserHandle class.
     */
    protected static final int USER_ALL = -1;

    private static final String TEST_UPDATE_LOCATION = ""/data/local/tmp/cts/deviceowner"";

    /**
     * Copied from {@link android.app.admin.DevicePolicyManager
     * .InstallSystemUpdateCallback#UPDATE_ERROR_UPDATE_FILE_INVALID}
     */
    protected static final int UPDATE_ERROR_UPDATE_FILE_INVALID = 3;

    protected CompatibilityBuildHelper mBuildHelper;
    private String mPackageVerifier;
    private HashSet<String> mAvailableFeatures;

    /** Packages installed as part of the tests */
    private Set<String> mFixedPackages;

    protected int mDeviceOwnerUserId;
    protected int mPrimaryUserId;

    /** Record the initial user ID. */
    protected int mInitialUserId;

    /** Whether multi-user is supported. */
    private boolean mSupportsMultiUser;

    /** Users we shouldn't delete in the tests */
    private ArrayList<Integer> mFixedUsers;

    private static final String VERIFY_CREDENTIAL_CONFIRMATION = ""Lock credential verified"";

    @Rule
    public final DeviceAdminFeaturesCheckerRule mFeaturesCheckerRule =
            new DeviceAdminFeaturesCheckerRule(this);

    @Before
    public void setUp() throws Exception {
        assertNotNull(getBuild());  // ensure build has been set before test is run.

        if (!mSkipDeviceAdminFeatureCheck) {
            // TODO(b/177965931): STOPSHIP must integrate mSkipDeviceAdminFeatureCheck into
            // DeviceAdminFeaturesCheckerRule
        }

        mSupportsMultiUser = getMaxNumberOfUsersSupported() > 1;
        mFixedPackages = getDevice().getInstalledPackageNames();
        mBuildHelper = new CompatibilityBuildHelper(getBuild());

        if (hasDeviceFeature(FEATURE_SECURE_LOCK_SCREEN)) {
            ensurePrimaryUserHasNoPassword();
        }

        // disable the package verifier to avoid the dialog when installing an app
        mPackageVerifier = getDevice().executeShellCommand(
                ""settings get global verifier_verify_adb_installs"");
        getDevice().executeShellCommand(""settings put global verifier_verify_adb_installs 0"");

        mFixedUsers = new ArrayList<>();

        // Set the value of initial user ID calls in {@link #setUp}.
        if(mSupportsMultiUser) {
            mInitialUserId = getDevice().getCurrentUser();
        }

        if (!isHeadlessSystemUserMode()) {
            mDeviceOwnerUserId = mPrimaryUserId = getPrimaryUser();
        } else {
            // For headless system user, all tests will be executed on current user
            // and therefore, initial user is set as primary user for test purpose.
            mPrimaryUserId = mInitialUserId;
            mDeviceOwnerUserId = USER_SYSTEM;
        }

        mFixedUsers.add(mPrimaryUserId);
        if (mPrimaryUserId != USER_SYSTEM) {
            mFixedUsers.add(USER_SYSTEM);
        }

        if (mFeaturesCheckerRule.hasRequiredFeatures()) {
            // Switching to primary is only needed when we're testing device admin features.
            switchUser(mPrimaryUserId);
        } else {
            // Otherwise, all the tests can be executed in any of the Android users, so remain in
            // current user, and don't delete it. This enables testing in secondary users.
            if (getDevice().getCurrentUser() != mPrimaryUserId) {
                mFixedUsers.add(getDevice().getCurrentUser());
            }
        }
        getDevice().executeShellCommand("" mkdir "" + TEST_UPDATE_LOCATION);

        removeOwners();

        switchUser(mPrimaryUserId);

        removeTestUsers();
        // Unlock keyguard before test
        wakeupAndDismissKeyguard();
        stayAwake();
        // Go to home.
        executeShellCommand(""input keyevent KEYCODE_HOME"");
    }

    private void ensurePrimaryUserHasNoPassword() throws DeviceNotAvailableException {
        if (!verifyUserCredentialIsCorrect(null, mPrimaryUserId)) {
            changeUserCredential(null, TEST_PASSWORD, mPrimaryUserId);
        }
    }

    /** If package manager is not available, e.g. after system crash, wait for it a little bit. */
    private void ensurePackageManagerReady() throws Exception {
        waitForOutput(""Package manager didn't become available"", ""service check package"",
                s -> s.trim().equals(""Service package: found""), 120 /* seconds */);
    }

    protected void waitForUserUnlock(int userId) throws Exception {
        waitForOutput(""User is not unlocked."",
                String.format(""am get-started-user-state %d"", userId),
                s -> s.startsWith(USER_STATE_UNLOCKED), USER_UNLOCK_TIMEOUT_SEC);
    }

    protected void waitForOutput(String message, String command, Predicate<String> predicate,
            long timeoutSec) throws Exception {
        final long deadline = System.nanoTime() + TimeUnit.SECONDS.toNanos(timeoutSec);
        while (!predicate.test(getDevice().executeShellCommand(command))) {
            if (System.nanoTime() > deadline) {
                fail(message);
            }
            Thread.sleep(1000);
        }
    }

    @After
    public void tearDown() throws Exception {
        // reset the package verifier setting to its original value
        getDevice().executeShellCommand(""settings put global verifier_verify_adb_installs ""
                + mPackageVerifier);
        removeOwners();

        // Switch back to initial user.
        if (mSupportsMultiUser && getDevice().getCurrentUser() != mInitialUserId) {
            switchUser(mInitialUserId);
        }
        removeTestUsers();
        removeTestPackages();
        getDevice().executeShellCommand("" rm -r "" + TEST_UPDATE_LOCATION);
    }

    protected void installAppAsUser(String appFileName, int userId) throws FileNotFoundException,
            DeviceNotAvailableException {
        installAppAsUser(appFileName, true, userId);
    }

    protected void installAppAsUser(String appFileName, boolean grantPermissions, int userId)
            throws FileNotFoundException, DeviceNotAvailableException {
        installAppAsUser(appFileName, grantPermissions, /* dontKillApp */ false, userId);
    }

    protected void installAppAsUser(String appFileName, boolean grantPermissions,
            boolean dontKillApp, int userId)
                    throws FileNotFoundException, DeviceNotAvailableException {
        CLog.e(""Installing app %s for user %d"", appFileName, userId);
        CompatibilityBuildHelper buildHelper = new CompatibilityBuildHelper(getBuild());
        List<String> extraArgs = new LinkedList<>();
        extraArgs.add(""-t"");
        // Make the test app queryable by other apps via PackageManager APIs.
        extraArgs.add(""--force-queryable"");
        if (dontKillApp) extraArgs.add(""--dont-kill"");
        String result = getDevice().installPackageForUser(
                buildHelper.getTestFile(appFileName), true, grantPermissions, userId,
                extraArgs.toArray(new String[extraArgs.size()]));
        assertNull(""Failed to install "" + appFileName + "" for user "" + userId + "": "" + result,
                result);
    }

    protected void installAppIncremental(String appFileName)
            throws FileNotFoundException, DeviceNotAvailableException {
        final String signatureSuffix = "".idsig"";
        CompatibilityBuildHelper buildHelper = new CompatibilityBuildHelper(getBuild());
        final File apk = buildHelper.getTestFile(appFileName);
        assertNotNull(apk);
        final File idsig = buildHelper.getTestFile(appFileName + signatureSuffix);
        assertNotNull(idsig);
        final String remoteApkPath = TEST_UPDATE_LOCATION + ""/"" + apk.getName();
        final String remoteIdsigPath = remoteApkPath + signatureSuffix;
        assertTrue(getDevice().pushFile(apk, remoteApkPath));
        assertTrue(getDevice().pushFile(idsig, remoteIdsigPath));
        String installResult = getDevice().executeShellCommand(
                ""pm install-incremental -t -g "" + remoteApkPath);
        assertEquals(""Success\n"", installResult);
    }

    protected void installDeviceOwnerApp(String apk) throws Exception {
        installAppAsUser(apk, mDeviceOwnerUserId);

        if (isHeadlessSystemUserMode()) {
            // Need to explicitly install the device owner app for the current user (rather than
            // relying on DPMS) so it has the same privileges (like INTERACT_ACROSS_USERS) as the
            // app running on system user, otherwise some tests might fail
            installAppAsUser(apk, mPrimaryUserId);
        }
    }

    protected void removeDeviceOwnerAdmin(String componentName) throws DeviceNotAvailableException {
        // Don't fail as it could hide the real failure from the test method
        if (!removeAdmin(componentName, mDeviceOwnerUserId)) {
            CLog.e(""Failed to remove device owner %s on user %d"", componentName,
                    mDeviceOwnerUserId);
        }
        if (isHeadlessSystemUserMode() && !removeAdmin(componentName, mPrimaryUserId)) {
            CLog.e(""Failed to remove profile owner %s on user %d"", componentName, mPrimaryUserId);
        }
    }

    protected void forceStopPackageForUser(String packageName, int userId) throws Exception {
        // TODO Move this logic to ITestDevice
        executeShellCommand(""am force-stop --user "" + userId + "" "" + packageName);
    }

    protected void executeShellCommand(String commandTemplate, Object...args) throws Exception {
        executeShellCommand(String.format(commandTemplate, args));
    }

    protected void executeShellCommand(String command) throws Exception {
        CLog.d(""Starting command "" + command);
        String commandOutput = getDevice().executeShellCommand(command);
        CLog.d(""Output for command "" + command + "": "" + commandOutput);
    }

    /** Initializes the user with the given id. This is required so that apps can run on it. */
    protected void startUser(int userId) throws Exception {
        getDevice().startUser(userId);
    }

    /** Initializes the user with waitFlag. This is required so that apps can run on it. */
    protected void startUserAndWait(int userId) throws Exception {
        getDevice().startUser(userId, /* waitFlag= */ true);
    }

    /**
     * Initializes the user with the given id, and waits until the user has started and unlocked
     * before continuing.
     *
     * <p>This is required so that apps can run on it.
     */
    protected void startUser(int userId, boolean waitFlag) throws Exception {
        getDevice().startUser(userId, waitFlag);
    }

    /**
     * Starts switching to the user with the given ID.
     *
     * <p>This is not blocking. Some operations will be flaky if called immediately afterwards, such
     * as {@link #wakeupAndDismissKeyguard()}. Call {@link #waitForBroadcastIdle()} between this
     * method and those operations to ensure that switching the user has finished.
     */
    protected void switchUser(int userId) throws Exception {
        // TODO Move this logic to ITestDevice
        int retries = 10;
        executeShellCommand(""am switch-user "" + userId);
        while (getDevice().getCurrentUser() != userId && (--retries) >= 0) {
            // am switch-user can be ignored if a previous user-switching operation
            // is still in progress. In this case, sleep a bit and then retry
            Thread.sleep(USER_SWITCH_WAIT);
            executeShellCommand(""am switch-user "" + userId);
        }
        assertTrue(""Failed to switch user after multiple retries"", getDevice().getCurrentUser() == userId);
    }

    protected int getMaxNumberOfUsersSupported() throws DeviceNotAvailableException {
        return getDevice().getMaxNumberOfUsersSupported();
    }

    protected int getMaxNumberOfRunningUsersSupported() throws DeviceNotAvailableException {
        return getDevice().getMaxNumberOfRunningUsersSupported();
    }

    protected int getUserFlags(int userId) throws DeviceNotAvailableException {
        String command = ""pm list users"";
        String commandOutput = getDevice().executeShellCommand(command);
        CLog.i(""Output for command "" + command + "": "" + commandOutput);

        String[] lines = commandOutput.split(""\\r?\\n"");
        assertTrue(commandOutput + "" should contain at least one line"", lines.length >= 1);
        for (int i = 1; i < lines.length; i++) {
            // Individual user is printed out like this:
            // \tUserInfo{$id$:$name$:$Integer.toHexString(flags)$} [running]
            String[] tokens = lines[i].split(""\\{|\\}|:"");
            assertTrue(lines[i] + "" doesn't contain 4 or 5 tokens"",
                    tokens.length == 4 || tokens.length == 5);
            // If the user IDs match, return the flags.
            if (Integer.parseInt(tokens[1]) == userId) {
                return Integer.parseInt(tokens[3], 16);
            }
        }
        fail(""User not found"");
        return 0;
    }

    protected ArrayList<Integer> listUsers() throws DeviceNotAvailableException {
        return getDevice().listUsers();
    }

    protected  ArrayList<Integer> listRunningUsers() throws DeviceNotAvailableException {
        ArrayList<Integer> runningUsers = new ArrayList<>();
        for (int userId : listUsers()) {
            if (getDevice().isUserRunning(userId)) {
                runningUsers.add(userId);
            }
        }
        return runningUsers;
    }

    protected int getFirstManagedProfileUserId() throws DeviceNotAvailableException {
        for (int userId : listUsers()) {
            if ((getUserFlags(userId) & FLAG_MANAGED_PROFILE) != 0) {
                return userId;
            }
        }
        fail(""Managed profile not found"");
        return 0;
    }

    private void stopUserAsync(int userId) throws Exception {
        String stopUserCommand = ""am stop-user -f "" + userId;
        CLog.d(""starting command \"""" + stopUserCommand);
        CLog.d(""Output for command "" + stopUserCommand + "": ""
                + getDevice().executeShellCommand(stopUserCommand));
    }

    protected void stopUser(int userId) throws Exception {
        String stopUserCommand = ""am stop-user -w -f "" + userId;
        CLog.d(""starting command \"""" + stopUserCommand + ""\"" and waiting."");
        CLog.d(""Output for command "" + stopUserCommand + "": ""
                + getDevice().executeShellCommand(stopUserCommand));
    }

    protected void waitForBroadcastIdle() throws DeviceNotAvailableException, IOException {
        final CollectingOutputReceiver receiver = new CollectingOutputReceiver();
        // We allow 8min for the command to complete and 4min for the command to start to
        // output something.
        getDevice().executeShellCommand(
                ""am wait-for-broadcast-idle"", receiver, 8, 4, TimeUnit.MINUTES, 0);
        final String output = receiver.getOutput();
        if (!output.contains(""All broadcast queues are idle!"")) {
            CLog.e(""Output from 'am wait-for-broadcast-idle': %s"", output);
            fail(""'am wait-for-broadcase-idle' did not complete."");
        }
    }

    protected void removeUser(int userId) throws Exception  {
        if (listUsers().contains(userId) && userId != USER_SYSTEM) {
            // Don't log output, as tests sometimes set no debug user restriction, which
            // causes this to fail, we should still continue and remove the user.
            String stopUserCommand = ""am stop-user -w -f "" + userId;
            CLog.d(""stopping and removing user "" + userId);
            getDevice().executeShellCommand(stopUserCommand);
            // TODO: Remove both sleeps and USER_REMOVE_WAIT constant when b/114057686 is fixed.
            Thread.sleep(USER_REMOVE_WAIT);
            // Ephemeral users may have already been removed after being stopped.
            if (listUsers().contains(userId)) {
                assertTrue(""Couldn't remove user"", getDevice().removeUser(userId));
                Thread.sleep(USER_REMOVE_WAIT);
            }
        }
    }

    protected void removeTestUsers() throws Exception {
        List<Integer> usersCreatedByTests = getUsersCreatedByTests();

        // The time spent on stopUser is depend on how busy the broadcast queue is.
        // To optimize the time to remove multiple test users, we mark all users as
        // stopping first, so no more broadcasts will be sent to these users, which make the queue
        // less busy.
        for (int userId : usersCreatedByTests) {
            stopUserAsync(userId);
        }
        for (int userId : usersCreatedByTests) {
            removeTestAddedUser(userId);
        }
    }

    private void removeTestAddedUser(int userId) throws Exception  {
        // Don't remove system user or initial user.
        if (userId != USER_SYSTEM && userId != mInitialUserId) {
            removeUser(userId);
        }
    }

    /**
     * Returns the users that have been created since running this class' setUp() method.
     */
    protected List<Integer> getUsersCreatedByTests() throws Exception {
        List<Integer> result = listUsers();
        result.removeAll(mFixedUsers);
        return result;
    }

    /** Removes any packages that were installed during the test. */
    protected void removeTestPackages() throws Exception {
        for (String packageName : getDevice().getUninstallablePackageNames()) {
            if (mFixedPackages.contains(packageName)) {
                continue;
            }
            CLog.w(""removing leftover package: "" + packageName);
            getDevice().uninstallPackage(packageName);
        }
    }

    protected void runDeviceTestsAsUser(
            String pkgName, @Nullable String testClassName, int userId)
            throws DeviceNotAvailableException {
        runDeviceTestsAsUser(pkgName, testClassName, /* testMethodName= */ null, userId);
    }

    protected void runDeviceTestsAsUser(
            String pkgName, @Nullable String testClassName, String testMethodName, int userId)
            throws DeviceNotAvailableException {
        Map<String, String> params = Collections.emptyMap();
        runDeviceTestsAsUser(pkgName, testClassName, testMethodName, userId, params);
    }

    protected void runDeviceTestsAsUser(
            String pkgName, @Nullable String testClassName,
            @Nullable String testMethodName, int userId,
            Map<String, String> params) throws DeviceNotAvailableException {
        if (testClassName != null && testClassName.startsWith(""."")) {
            testClassName = pkgName + testClassName;
        }

        CLog.i(""runDeviceTestsAsUser(): user=%d, pkg=%s class=%s, test=%s"", userId, pkgName,
                testClassName, testMethodName);
        runDeviceTests(
                getDevice(),
                RUNNER,
                pkgName,
                testClassName,
                testMethodName,
                userId,
                DEFAULT_TEST_TIMEOUT_MILLIS,
                DEFAULT_SHELL_TIMEOUT_MILLIS,
                0L /* maxInstrumentationTimeoutMs */,
                true /* checkResults */,
                false /* isHiddenApiCheckDisabled */,
                params);
    }

    /** Reboots the device and block until the boot complete flag is set. */
    protected void rebootAndWaitUntilReady() throws Exception {
        getDevice().rebootUntilOnline();
        assertTrue(""Device failed to boot"", getDevice().waitForBootComplete(120000));
    }

    /** Returns a boolean value of the system property with the specified key. */
    protected boolean getBooleanSystemProperty(String key, boolean defaultValue)
            throws DeviceNotAvailableException {
        final String[] positiveValues = {""1"", ""y"", ""yes"", ""true"", ""on""};
        final String[] negativeValues = {""0"", ""n"", ""no"", ""false"", ""off""};
        String propertyValue = getDevice().getProperty(key);
        if (propertyValue == null || propertyValue.isEmpty()) {
            return defaultValue;
        }
        if (Arrays.asList(positiveValues).contains(propertyValue)) {
            return true;
        }
        if (Arrays.asList(negativeValues).contains(propertyValue)) {
            return false;
        }
        fail(""Unexpected value of boolean system property '"" + key + ""': "" + propertyValue);
        return false;
    }

    /** Checks whether it is possible to create the desired number of users. */
    protected boolean canCreateAdditionalUsers(int numberOfUsers)
            throws DeviceNotAvailableException {
        return listUsers().size() + numberOfUsers <= getMaxNumberOfUsersSupported();
    }

    /**
     * Throws a {@link org.junit.AssumptionViolatedException} if it's not possible to create the
     * desired number of users.
     */
    protected void assumeCanCreateAdditionalUsers(int numberOfUsers)
            throws DeviceNotAvailableException {
        int maxUsers = getDevice().getMaxNumberOfUsersSupported();
        assumeTrue(""Tests needs at least "" + numberOfUsers + "" extra users, but device supports ""
                + ""at most "" + getMaxNumberOfUsersSupported(),
                canCreateAdditionalUsers(numberOfUsers));
    }

    /** Checks whether it is possible to start the desired number of users. */
    protected boolean canStartAdditionalUsers(int numberOfUsers)
            throws DeviceNotAvailableException {
        return listRunningUsers().size() + numberOfUsers <= getMaxNumberOfRunningUsersSupported();
    }

    protected void assumeCanStartNewUser() throws DeviceNotAvailableException {
        assumeCanCreateOneManagedUser();
        assumeTrue(""Cannot start a new user"", canStartAdditionalUsers(1));
    }

    protected int createUser() throws Exception {
        int userId = createUser(0);
        CLog.i(""Created user with id %d"", userId);
        // TODO remove this and audit tests so they start users as necessary
        startUser(userId);
        return userId;
    }

    protected int createUserAndWaitStart() throws Exception {
        int userId = createUser(0);
        startUserAndWait(userId);
        return userId;
    }

    protected int createUser(int flags) throws Exception {
        boolean guest = FLAG_GUEST == (flags & FLAG_GUEST);
        boolean ephemeral = FLAG_EPHEMERAL == (flags & FLAG_EPHEMERAL);
        CLog.i(""Creating user with flags %d: guest=%b, ephemeral=%b"", flags, guest, ephemeral);
        // TODO Use ITestDevice.createUser() when guest and ephemeral is available
        String command =""pm create-user "" + (guest ? ""--guest "" : """")
                + (ephemeral ? ""--ephemeral "" : """") + ""TestUser_"" + System.currentTimeMillis();
        CLog.d(""Starting command %s"", command);
        String commandOutput = getDevice().executeShellCommand(command);
        CLog.d(""Output for command %s: %s"", command, commandOutput);

        // Extract the id of the new user.
        String[] tokens = commandOutput.split(""\\s+"");
        assertTrue(tokens.length > 0);
        assertEquals(""Command '"" + command + ""' failed: "" + commandOutput, ""Success:"", tokens[0]);
        return Integer.parseInt(tokens[tokens.length-1]);
    }

    protected int createManagedProfile(int parentUserId) throws DeviceNotAvailableException {
        String commandOutput = getCreateManagedProfileCommandOutput(parentUserId);
        return getUserIdFromCreateUserCommandOutput(commandOutput);
    }

    protected void assertCannotCreateManagedProfile(int parentUserId)
            throws Exception {
        String commandOutput = getCreateManagedProfileCommandOutput(parentUserId);
        if (commandOutput.startsWith(""Error"")) {
            return;
        }
        int userId = getUserIdFromCreateUserCommandOutput(commandOutput);
        removeUser(userId);
        fail(""Expected not to be able to create a managed profile. Output was: "" + commandOutput);
    }

    private void assumeHasDeviceFeature(String feature) throws DeviceNotAvailableException {
        assumeTrue(""device doesn't have "" + feature, hasDeviceFeature(feature));
    }

    private void assumeDoesNotHaveDeviceFeature(String feature) throws DeviceNotAvailableException {
        assumeFalse(""device has "" + feature, hasDeviceFeature(feature));
    }

    /**
     * Used by test cases to add additional checks priort to {@link #setUp()}, so that when it
     * throws an {@link AssumptionViolatedException} exception nothing is run
     * (even {@link #tearDown()}).
     */
    protected void assumeTestEnabled() throws Exception {
    }

    protected final void assumeCanCreateOneManagedUser() throws DeviceNotAvailableException {
        assumeSupportsMultiUser();
        assumeCanCreateAdditionalUsers(1);
    }

    protected final void assumeSupportsMultiUser() throws DeviceNotAvailableException {
        assumeTrue(""device doesn't support multiple users"", mSupportsMultiUser);
    }

    protected final void assumeHasWifiFeature() throws DeviceNotAvailableException {
        assumeHasDeviceFeature(FEATURE_WIFI);
    }

    protected final void assumeHasTelephonyFeature() throws DeviceNotAvailableException {
        assumeHasDeviceFeature(FEATURE_TELEPHONY);
    }

    protected final void assumeHasNfcFeatures() throws DeviceNotAvailableException {
        assumeHasDeviceFeature(FEATURE_NFC);
        assumeHasDeviceFeature(FEATURE_NFC_BEAM);
    }

    protected final void assumeHasTelephonyAndConnectionServiceFeatures()
            throws DeviceNotAvailableException {
        assumeHasTelephonyFeature();
        assumeHasDeviceFeature(FEATURE_CONNECTION_SERVICE);
    }

    protected final void assumeHasSecureLockScreenFeature() throws DeviceNotAvailableException {
        assumeHasDeviceFeature(FEATURE_SECURE_LOCK_SCREEN);
    }

    protected final void assumeDoesNotHaveSecureLockScreenFeature()
            throws DeviceNotAvailableException {
        assumeDoesNotHaveDeviceFeature(FEATURE_SECURE_LOCK_SCREEN);
    }

    protected final void assumeHasFileBasedEncryptionAndSecureLockScreenFeatures()
            throws DeviceNotAvailableException {
        assumeHasDeviceFeature(FEATURE_FBE);
        assumeHasSecureLockScreenFeature();
    }

    protected final void assumeHasPrintFeature() throws DeviceNotAvailableException {
        assumeHasDeviceFeature(FEATURE_PRINT);
    }

    protected final void assumeHasCameraFeature() throws DeviceNotAvailableException {
        assumeHasDeviceFeature(FEATURE_CAMERA);
    }

    protected final void assumeHasBluetoothFeature() throws DeviceNotAvailableException {
        assumeHasDeviceFeature(FEATURE_BLUETOOTH);
    }

    protected final void assumeApiLevel(int min) throws DeviceNotAvailableException {
        assumeTrue(""API level must be >="" + min, getDevice().getApiLevel() >= min);
    }

    private int getUserIdFromCreateUserCommandOutput(String commandOutput) {
        // Extract the id of the new user.
        String[] tokens = commandOutput.split(""\\s+"");
        assertTrue(commandOutput + "" expected to have format \""Success: {USER_ID}\"""",
                tokens.length > 0);
        assertEquals(commandOutput, ""Success:"", tokens[0]);
        return Integer.parseInt(tokens[tokens.length-1]);
    }

    private String getCreateManagedProfileCommandOutput(int parentUserId)
            throws DeviceNotAvailableException {
        String command = ""pm create-user --profileOf "" + parentUserId + "" --managed ""
                + ""TestProfile_"" + System.currentTimeMillis();
        CLog.d(""Starting command "" + command);
        String commandOutput = getDevice().executeShellCommand(command);
        CLog.d(""Output for command "" + command + "": "" + commandOutput);
        return commandOutput;
    }

    protected int getPrimaryUser() throws DeviceNotAvailableException {
        return getDevice().getPrimaryUserId();
    }

    protected int getUserSerialNumber(int userId) throws DeviceNotAvailableException{
        // TODO: Move this logic to ITestDevice.
        // dumpsys user output contains lines like ""UserInfo{0:Owner:13} serialNo=0 isPrimary=true""
        final Pattern pattern =
                Pattern.compile(""UserInfo\\{"" + userId + "":[^\\n]*\\sserialNo=(\\d+)\\s"");
        final String commandOutput = getDevice().executeShellCommand(""dumpsys user"");
        final Matcher matcher = pattern.matcher(commandOutput);
        if (matcher.find()) {
            return Integer.parseInt(matcher.group(1));
        }
        fail(""Couldn't find serial number for user "" + userId);
        return -1;
    }

    protected boolean setProfileOwner(String componentName, int userId, boolean expectFailure)
            throws DeviceNotAvailableException {
        String command = ""dpm set-profile-owner --user "" + userId + "" '"" + componentName + ""'"";
        String commandOutput = getDevice().executeShellCommand(command);
        boolean success = commandOutput.startsWith(""Success:"");
        // If we succeeded always log, if we are expecting failure don't log failures
        // as call stacks for passing tests confuse the logs.
        if (success || !expectFailure) {
            CLog.e(""Output for command "" + command + "": "" + commandOutput);
        } else {
            CLog.e(""Command Failed "" + command);
        }
        return success;
    }

    protected void setProfileOwnerOrFail(String componentName, int userId)
            throws Exception {
        if (!setProfileOwner(componentName, userId, /*expectFailure*/ false)) {
            // Don't remove system user or initial user that tests require to run on.
            removeTestAddedUser(userId);
            fail(""Failed to set profile owner"");
        }
    }

    protected void setProfileOwnerExpectingFailure(String componentName, int userId)
            throws Exception {
        if (setProfileOwner(componentName, userId, /* expectFailure =*/ true)) {
            removeTestAddedUser(userId);
            fail(""Setting profile owner should have failed."");
        }
    }

    private String setDeviceAdminInner(String componentName, int userId)
            throws DeviceNotAvailableException {
        String command = ""dpm set-active-admin --user "" + userId + "" '"" + componentName + ""'"";
        String commandOutput = getDevice().executeShellCommand(command);
        return commandOutput;
    }

    protected void setDeviceAdmin(String componentName, int userId)
            throws DeviceNotAvailableException {
        String commandOutput = setDeviceAdminInner(componentName, userId);
        CLog.d(""Output for command "" + commandOutput
                + "": "" + commandOutput);
        assertTrue(commandOutput + "" expected to start with \""Success:\"""",
                commandOutput.startsWith(""Success:""));
    }

    protected void setDeviceAdminExpectingFailure(String componentName, int userId,
            String errorMessage) throws DeviceNotAvailableException {
        String commandOutput = setDeviceAdminInner(componentName, userId);
        if (!commandOutput.contains(errorMessage)) {
            fail(commandOutput + "" expected to contain \"""" + errorMessage + ""\"""");
        }
    }

    protected boolean setDeviceOwner(String componentName, int userId, boolean expectFailure)
            throws DeviceNotAvailableException {
        String command = ""dpm set-device-owner --user "" + userId + "" '"" + componentName + ""'"";
        String commandOutput = getDevice().executeShellCommand(command);
        boolean success = commandOutput.startsWith(""Success:"");
        // If we succeeded always log, if we are expecting failure don't log failures
        // as call stacks for passing tests confuse the logs.
        if (success || !expectFailure) {
            CLog.d(""Output for command "" + command + "": "" + commandOutput);
        } else {
            CLog.d(""Command Failed "" + command);
        }
        return success;
    }

    protected void setDeviceOwnerOrFail(String componentName, int userId)
            throws Exception {
        assertTrue(setDeviceOwner(componentName, userId, /* expectFailure =*/ false));
    }

    protected void setDeviceOwnerExpectingFailure(String componentName, int userId)
            throws Exception {
        assertFalse(setDeviceOwner(componentName, userId, /* expectFailure =*/ true));
    }


    protected void affiliateUsers(String deviceAdminPkg, int userId1, int userId2)
            throws Exception {
        CLog.d(""Affiliating users %d and %d on admin package %s"", userId1, userId2, deviceAdminPkg);
        runDeviceTestsAsUser(
                deviceAdminPkg, "".AffiliationTest"", ""testSetAffiliationId1"", userId1);
        runDeviceTestsAsUser(
                deviceAdminPkg, "".AffiliationTest"", ""testSetAffiliationId1"", userId2);
    }

    protected String getSettings(String namespace, String name, int userId)
            throws DeviceNotAvailableException {
        String command = ""settings --user "" + userId + "" get "" + namespace + "" "" + name;
        String commandOutput = getDevice().executeShellCommand(command);
        CLog.d(""Output for command "" + command + "": "" + commandOutput);
        return commandOutput.replace(""\n"", """").replace(""\r"", """");
    }

    protected void putSettings(String namespace, String name, String value, int userId)
            throws DeviceNotAvailableException {
        String command = ""settings --user "" + userId + "" put "" + namespace + "" "" + name
                + "" "" + value;
        String commandOutput = getDevice().executeShellCommand(command);
        CLog.d(""Output for command "" + command + "": "" + commandOutput);
    }

    protected boolean removeAdmin(String componentName, int userId)
            throws DeviceNotAvailableException {
        String command = ""dpm remove-active-admin --user "" + userId + "" '"" + componentName + ""'"";
        String commandOutput = getDevice().executeShellCommand(command);
        CLog.d(""Output for command "" + command + "": "" + commandOutput);
        return commandOutput.startsWith(""Success:"");
    }

    // Tries to remove and profile or device owners it finds.
    protected void removeOwners() throws DeviceNotAvailableException {
        String command = ""dumpsys device_policy"";
        String commandOutput = getDevice().executeShellCommand(command);
        String[] lines = commandOutput.split(""\\r?\\n"");
        for (int i = 0; i < lines.length; ++i) {
            String line = lines[i].trim();
            if (line.contains(""Profile Owner"")) {
                // Line is ""Profile owner (User <id>):
                String[] tokens = line.split(""\\(|\\)| "");
                int userId = Integer.parseInt(tokens[4]);
                i++;
                line = lines[i].trim();
                // Line is admin=ComponentInfo{<component>}
                tokens = line.split(""\\{|\\}"");
                String componentName = tokens[1];
                CLog.w(""Cleaning up profile owner "" + userId + "" "" + componentName);
                removeAdmin(componentName, userId);
            } else if (line.contains(""Device Owner:"")) {
                i++;
                line = lines[i].trim();
                // Line is admin=ComponentInfo{<component>}
                String[] tokens = line.split(""\\{|\\}"");
                String componentName = tokens[1];
                // Skip to user id line.
                i += 4;
                line = lines[i].trim();
                // Line is User ID: <N>
                tokens = line.split("":"");
                int userId = Integer.parseInt(tokens[1].trim());
                CLog.w(""Cleaning up device owner "" + userId + "" "" + componentName);
                removeAdmin(componentName, userId);
            }
        }
    }

    /**
     * Runs pm enable command to enable a package or component. Returns the command result.
     */
    protected String enableComponentOrPackage(int userId, String packageOrComponent)
            throws DeviceNotAvailableException {
        String command = ""pm enable --user "" + userId + "" "" + packageOrComponent;
        String result = getDevice().executeShellCommand(command);
        CLog.d(""Output for command "" + command + "": "" + result);
        return result;
    }

    /**
     * Runs pm disable command to disable a package or component. Returns the command result.
     */
    protected String disableComponentOrPackage(int userId, String packageOrComponent)
            throws DeviceNotAvailableException {
        String command = ""pm disable --user "" + userId + "" "" + packageOrComponent;
        String result = getDevice().executeShellCommand(command);
        CLog.d(""Output for command "" + command + "": "" + result);
        return result;
    }

    protected interface SuccessCondition {
        boolean check() throws Exception;
    }

    protected void waitUntilUserRemoved(int userId) throws Exception {
        tryWaitForSuccess(() -> !listUsers().contains(userId),
                ""The user "" + userId + "" has not been removed"",
                TIMEOUT_USER_REMOVED_MILLIS
                );
    }

    protected void tryWaitForSuccess(SuccessCondition successCondition, String failureMessage,
            long timeoutMillis) throws Exception {
        long epoch = System.currentTimeMillis();
        while (System.currentTimeMillis() - epoch <= timeoutMillis) {
            Thread.sleep(WAIT_SAMPLE_INTERVAL_MILLIS);
            if (successCondition.check()) {
                return;
            }
        }
        fail(failureMessage);
    }

    /**
     * Sets a user restriction via SetPolicyActivity.
     * <p>IMPORTANT: The package that contains SetPolicyActivity must have been installed prior to
     * calling this method.
     * @param key user restriction key
     * @param value true if we should set the restriction, false if we should clear it
     * @param userId userId to set/clear the user restriction on
     * @param packageName package where SetPolicyActivity is installed
     * @return The output of the command
     * @throws DeviceNotAvailableException
     */
    protected String changeUserRestriction(String key, boolean value, int userId,
            String packageName) throws DeviceNotAvailableException {
        return changePolicy(getUserRestrictionCommand(value),
                "" --es extra-restriction-key "" + key, userId, packageName);
    }

    /**
     * Same as {@link #changeUserRestriction(String, boolean, int, String)} but asserts that it
     * succeeds.
     */
    protected void changeUserRestrictionOrFail(String key, boolean value, int userId,
            String packageName) throws DeviceNotAvailableException {
        changePolicyOrFail(getUserRestrictionCommand(value), "" --es extra-restriction-key "" + key,
                userId, packageName);
    }

    /**
     * Sets some policy via SetPolicyActivity.
     * <p>IMPORTANT: The package that contains SetPolicyActivity must have been installed prior to
     * calling this method.
     * @param command command to pass to SetPolicyActivity
     * @param extras extras to pass to SetPolicyActivity
     * @param userId the userId where we invoke SetPolicyActivity
     * @param packageName where SetPolicyActivity is installed
     * @return The output of the command
     * @throws DeviceNotAvailableException
     */
    protected String changePolicy(String command, String extras, int userId, String packageName)
            throws DeviceNotAvailableException {
        String adbCommand = ""am start -W --user "" + userId
                + "" -c android.intent.category.DEFAULT ""
                + "" --es extra-command "" + command
                + "" "" + extras
                + "" "" + packageName + ""/.SetPolicyActivity"";
        String commandOutput = getDevice().executeShellCommand(adbCommand);
        CLog.d(""Output for command "" + adbCommand + "": "" + commandOutput);
        return commandOutput;
    }

    /**
     * Same as {@link #changePolicy(String, String, int, String)} but asserts that it succeeds.
     */
    protected void changePolicyOrFail(String command, String extras, int userId,
            String packageName) throws DeviceNotAvailableException {
        String commandOutput = changePolicy(command, extras, userId, packageName);
        assertTrue(""Command was expected to succeed "" + commandOutput,
                commandOutput.contains(""Status: ok""));
    }

    private String getUserRestrictionCommand(boolean setRestriction) {
        if (setRestriction) {
            return ""add-restriction"";
        }
        return ""clear-restriction"";
    }

    /**
     * Set lockscreen password / work challenge for the given user, null or """" means clear
     * IMPORTANT: prefer to use {@link #TEST_PASSWORD} for primary user, otherwise if the test
     * terminates before cleaning password up, the device will be unusable for further testing.
     */
    protected void changeUserCredential(String newCredential, String oldCredential, int userId)
            throws DeviceNotAvailableException {
        final String oldCredentialArgument = (oldCredential == null || oldCredential.isEmpty()) ? """"
                : (""--old "" + oldCredential);
        if (newCredential != null && !newCredential.isEmpty()) {
            String commandOutput = getDevice().executeShellCommand(String.format(
                    ""cmd lock_settings set-password --user %d %s %s"", userId, oldCredentialArgument,
                    newCredential));
            if (!commandOutput.startsWith(""Password set to"")) {
                fail(""Failed to set user credential: "" + commandOutput);
            }
        } else {
            String commandOutput = getDevice().executeShellCommand(String.format(
                    ""cmd lock_settings clear --user %d %s"", userId, oldCredentialArgument));
            if (!commandOutput.startsWith(""Lock credential cleared"")) {
                fail(""Failed to clear user credential: "" + commandOutput);
            }
        }
    }

    /**
     * Verifies the lock credential for the given user.
     *
     * @param credential The credential to verify.
     * @param userId The id of the user.
     */
    protected void verifyUserCredential(String credential, int userId)
            throws DeviceNotAvailableException {
        String commandOutput = verifyUserCredentialCommandOutput(credential, userId);
        if (!commandOutput.startsWith(VERIFY_CREDENTIAL_CONFIRMATION)) {
            fail(""Failed to verify user credential: "" + commandOutput);
        }
     }

    /**
     * Verifies the lock credential for the given user, which unlocks the user, and returns
     * whether it was successful or not.
     *
     * @param credential The credential to verify.
     * @param userId The id of the user.
     */
    protected boolean verifyUserCredentialIsCorrect(String credential, int userId)
            throws DeviceNotAvailableException {
        String commandOutput = verifyUserCredentialCommandOutput(credential, userId);
        return commandOutput.startsWith(VERIFY_CREDENTIAL_CONFIRMATION);
    }

    /**
     * Verifies the lock credential for the given user, which unlocks the user. Returns the
     * commandline output, which includes whether the verification was successful.
     *
     * @param credential The credential to verify.
     * @param userId The id of the user.
     * @return The command line output.
     */
    protected String verifyUserCredentialCommandOutput(String credential, int userId)
            throws DeviceNotAvailableException {
        final String credentialArgument = (credential == null || credential.isEmpty())
                ? """" : (""--old "" + credential);
        String commandOutput = getDevice().executeShellCommand(String.format(
                ""cmd lock_settings verify --user %d %s"", userId, credentialArgument));
        return commandOutput;
    }

    protected void wakeupAndDismissKeyguard() throws Exception {
        executeShellCommand(""input keyevent KEYCODE_WAKEUP"");
        executeShellCommand(""wm dismiss-keyguard"");
    }

    protected void pressPowerButton() throws Exception {
        executeShellCommand(""input keyevent KEYCODE_POWER"");
    }

    private void stayAwake() throws Exception {
        executeShellCommand(
                ""settings put global stay_on_while_plugged_in "" + STAY_ON_WHILE_PLUGGED_IN_FLAGS);
    }

    protected void startActivityAsUser(int userId, String packageName, String activityName)
        throws Exception {
        wakeupAndDismissKeyguard();
        String command = ""am start -W --user "" + userId + "" "" + packageName + ""/"" + activityName;
        getDevice().executeShellCommand(command);
    }

    protected String getDefaultLauncher() throws Exception {
        final CollectingByteOutputReceiver receiver = new CollectingByteOutputReceiver();
        getDevice().executeShellCommand(""dumpsys role --proto"", receiver);

        RoleUserStateProto roleState = null;
        final RoleServiceDumpProto dumpProto =
                RoleServiceDumpProto.parser().parseFrom(receiver.getOutput());
        for (RoleUserStateProto userState : dumpProto.getUserStatesList()) {
            if (getDevice().getCurrentUser() == userState.getUserId()) {
                roleState = userState;
                break;
            }
        }

        if (roleState != null) {
            final List<RoleProto> roles = roleState.getRolesList();
            // Iterate through the roles until we find the Home role
            for (RoleProto roleProto : roles) {
                if (""android.app.role.HOME"".equals(roleProto.getName())) {
                    assertEquals(1, roleProto.getHoldersList().size());
                    return roleProto.getHoldersList().get(0);
                }
            }
        }

        throw new Exception(""Default launcher not found"");
    }

    void assumeIsDeviceAb() throws DeviceNotAvailableException {
        final String result = getDevice().executeShellCommand(""getprop ro.build.ab_update"").trim();
        assumeTrue(""not device AB"", ""true"".equalsIgnoreCase(result));
    }

    // TODO (b/174775905) remove after exposing the check from ITestDevice.
    boolean isHeadlessSystemUserMode() throws DeviceNotAvailableException {
        return isHeadlessSystemUserMode(getDevice());
    }

    // TODO (b/174775905) remove after exposing the check from ITestDevice.
    public static boolean isHeadlessSystemUserMode(ITestDevice device)
            throws DeviceNotAvailableException {
        final String result = device
                .executeShellCommand(""getprop ro.fw.mu.headless_system_user"").trim();
        return ""true"".equalsIgnoreCase(result);
    }

    protected void assumeHeadlessSystemUserMode(String reason)
            throws DeviceNotAvailableException {
        assumeTrue(""Skipping test on non-headless system user mode. Reason: "" + reason,
                isHeadlessSystemUserMode());
    }

    protected void grantDpmWrapperPermissions(String deviceAdminPkg, int userId) throws Exception {
        // TODO(b/176993670): INTERACT_ACROSS_USERS is needed by DevicePolicyManagerWrapper to
        // send ordered broadcasts to the test user. The permission is already available to the
        // packages installed by the host side test (as they're installed with -g), but need to be
        // granted for users created by the test, as the package is intalled by code
        // (DPMS.manageUserUnchecked(), which doesn't grant it (as this is a privileged permission
        // that's not available to 3rd party apps). If we get rid of DevicePolicyManagerWrapper,
        // we won't need to grant it anymore.
        grantPermission(deviceAdminPkg, PERMISSION_INTERACT_ACROSS_USERS, userId, ""its PO needs to ""
                + ""send ordered broadcasts to user 0"");

        // Probably not needed anymore, but it doesn't hurt to keep...
        allowTestApiAccess(deviceAdminPkg);
    }

    protected void allowTestApiAccess(String deviceAdminPkg) throws Exception {
        CLog.i(""Granting ALLOW_TEST_API_ACCESS to package %s"", deviceAdminPkg);
        executeShellCommand(""am compat enable ALLOW_TEST_API_ACCESS %s"", deviceAdminPkg);
    }

    protected void grantPermission(String pkg, String permission, int userId, String reason)
            throws Exception {
        CLog.i(""Granting permission %s to package (%s) on user %d%s"", pkg, permission, userId,
                (reason == null ? """" : ""(reason: "" + reason + "")""));
        executeShellCommand(""pm grant --user %d %s %s"", userId, pkg, permission);
    }

    protected void revokePermission(String pkg, String permission, int userId) throws Exception {
        CLog.i(""Revoking permission %s to package (%s) on user %d"", pkg, permission, userId);
        executeShellCommand(""pm revoke --user %d %s %s"", userId, pkg, permission);
    }

    /** Find effective restriction for user */
    protected boolean isRestrictionSetOnUser(int userId, String restriction) throws Exception {
        String commandOutput = getDevice().executeShellCommand(""dumpsys user"");
        String[] outputLines = commandOutput.split(""\\n"");
        Pattern userPattern = Pattern.compile(""(^.*)UserInfo\\{"" + userId + "":.*$"");
        Pattern restrictionPattern = Pattern.compile(""(^.*)Effective\\srestrictions\\:.*$"");

        boolean userFound = false;
        boolean restrictionsFound = false;
        int lastIndent = -1;

        for (String line : outputLines) {
            // Starting a new block of user infos
            if (!line.startsWith(Strings.repeat("" "", lastIndent + 1))) {
                CLog.d(""User %d restrictions found, no matched restriction."", userId);
                return false;
            }
            //First, try matching user pattern
            Matcher userMatcher = userPattern.matcher(line);
            if (userMatcher.find()) {
                CLog.d(""User %d found in dumpsys, finding restrictions."", userId);
                userFound = true;
                lastIndent = userMatcher.group(1).length();
            }

            // Second, try matching restriction
            Matcher restrictionMatcher = restrictionPattern.matcher(line);
            if (userFound && restrictionMatcher.find()) {
                CLog.d(""User %d restrictions found, finding exact restriction."", userId);
                restrictionsFound = true;
                lastIndent = restrictionMatcher.group(1).length();
            }

            if (restrictionsFound && line.contains(restriction)) {
                return true;
            }
        }
        if (!userFound) {
            CLog.e(""User %d not found in dumpsys."", userId);
        }
        if (!restrictionsFound) {
            CLog.d(""User %d found in dumpsys, but restrictions not found."", userId);
        }
        return false;
    }

    /**
     * Generates instrumentation arguments that indicate the device-side test is exercising device
     * owner APIs.
     *
     * <p>This is needed for hostside tests that use the same class hierarchy for both device and
     * profile owner tests, as on headless system user mode the test side must decide whether to
     * use its ""local DPC"" or wrap the calls to the system user DPC.
     */
    protected static Map<String, String> getParamsForDeviceOwnerTest() {
        Map<String, String> params = new HashMap<>();
        params.put(""admin_type"", ""DeviceOwner"");
        return params;
    }

    boolean isTv() throws DeviceNotAvailableException {
        return hasDeviceFeature(FEATURE_LEANBACK);
    }

    void pushUpdateFileToDevice(String fileName)
            throws IOException, DeviceNotAvailableException {
        File file = File.createTempFile(
                fileName.split(""\\."")[0], ""."" + fileName.split(""\\."")[1]);
        try (OutputStream outputStream = new FileOutputStream(file)) {
            InputStream inputStream = getClass().getResourceAsStream(""/"" + fileName);
            ByteStreams.copy(inputStream, outputStream);
        }

        getDevice().pushFile(file, TEST_UPDATE_LOCATION + ""/"" + fileName);
        file.delete();
    }

    boolean hasService(String service) {
        String command = ""service check "" + service;
        try {
            String commandOutput = getDevice().executeShellCommand(command);
            return !commandOutput.contains(""not found"");
        } catch (Exception e) {
            CLog.w(""Exception running '"" + command + ""': "" + e);
            return false;
        }
    }

    void sleep(int timeMs) throws InterruptedException {
        CLog.d(""Sleeping %d ms"");
        Thread.sleep(timeMs);
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.MeteredDataRestrictionTest"	"testSetMeteredDataDisabledPackages"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/MeteredDataRestrictionTest.java"	""	"public void testSetMeteredDataDisabledPackages() {
        final List<String> restrictedPkgs = new ArrayList<>();
        restrictedPkgs.add(METERED_DATA_APP_PKG);
        final List<String> excludedPkgs = mDevicePolicyManager.setMeteredDataDisabledPackages(
                ADMIN_RECEIVER_COMPONENT, restrictedPkgs);
        assertTrue(""Packages not restricted: "" + excludedPkgs, excludedPkgs.isEmpty());

        List<String> actualRestrictedPkgs = mDevicePolicyManager.getMeteredDataDisabledPackages(
                ADMIN_RECEIVER_COMPONENT);
        assertEquals(""Actual restricted pkgs: "" + actualRestrictedPkgs,
                1, actualRestrictedPkgs.size());
        assertTrue(""Actual restricted pkgs: "" + actualRestrictedPkgs,
                actualRestrictedPkgs.contains(METERED_DATA_APP_PKG));
        verifyAppNetworkState(true);

        restrictedPkgs.clear();
        mDevicePolicyManager.setMeteredDataDisabledPackages(ADMIN_RECEIVER_COMPONENT,
                restrictedPkgs);
        actualRestrictedPkgs = mDevicePolicyManager.getMeteredDataDisabledPackages(
                ADMIN_RECEIVER_COMPONENT);
        assertTrue(""Actual restricted pkgs: "" + actualRestrictedPkgs,
                actualRestrictedPkgs.isEmpty());
        verifyAppNetworkState(false);
    }

    private void verifyAppNetworkState(boolean blocked) {
        final Bundle extras = new Bundle();
        extras.putBinder(EXTRA_MESSENGER, mCallbackMessenger.getBinder());
        mNetworkInfos.clear();
        final Intent launchIntent = new Intent()
                .setClassName(METERED_DATA_APP_PKG, METERED_DATA_APP_MAIN_ACTIVITY)
                .putExtras(extras)
                .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        mContext.startActivity(launchIntent);

        try {
            final NetworkInfo networkInfo = mNetworkInfos.poll(WAIT_FOR_NETWORK_INFO_TIMEOUT_SEC,
                    TimeUnit.SECONDS);
            if (networkInfo == null) {
                fail(""Timed out waiting for the network info"");
            }

            final String expectedState = (blocked ? State.DISCONNECTED : State.CONNECTED).name();
            final String expectedDetailedState = (blocked ? DetailedState.BLOCKED
                    : DetailedState.CONNECTED).name();
            assertEquals(""Wrong state: "" + networkInfo,
                    expectedState, networkInfo.getState().name());
            assertEquals(""Wrong detailed state: "" + networkInfo,
                    expectedDetailedState, networkInfo.getDetailedState().name());
        } catch (InterruptedException e) {
            fail(""Waiting for networkinfo got interrupted: "" + e);
        }
    }

    private class CallbackHandler extends Handler {
        public CallbackHandler() {
            super(Looper.getMainLooper());
        }

        @Override
        public void handleMessage(Message msg) {
            if (msg.what == MSG_NOTIFY_NETWORK_STATE) {
                final NetworkInfo networkInfo = (NetworkInfo) msg.obj;
                if (!mNetworkInfos.offer(networkInfo)) {
                    Log.e(TAG, ""Error while adding networkinfo"");
                }
            } else {
                Log.e(TAG, ""Unknown msg type: "" + msg.what);
            }
        }
    }

    private void setMeteredNetwork() throws Exception {
        final int oldNetId = getActiveNetworkNetId();
        final boolean oldMeteredState = mCm.isActiveNetworkMetered();
        final NetworkInfo networkInfo = mCm.getActiveNetworkInfo();
        Log.d(TAG, ""setMeteredNetwork(): oldNetId="" + oldNetId
                + "", oldMeteredState="" + oldMeteredState + "", activeNetworkInfo="" + networkInfo);
        if (networkInfo == null) {
            fail(""Active network is not available"");
        } else if (networkInfo.getType() != ConnectivityManager.TYPE_WIFI) {
            fail(""Active network doesn't support setting metered status: "" + networkInfo);
        }
        final String ssid = setWifiMeteredStatus(true);

        // Set flag so status is reverted on resetMeteredNetwork();
        mMeteredWifi = ssid;

        // When transitioning from unmetered to metered, the network stack will discconect
        // the current WiFi connection and reconnect it. In this case we need to wait for
        // the new network to come up.
        if (!oldMeteredState) {
            waitForReconnection(oldNetId);
        }
        assertWifiMeteredStatus(ssid, true);
        assertActiveNetworkMetered(true);
    }

    private void resetMeteredNetwork() throws Exception {
        if (mMeteredWifi != null) {
            Log.i(TAG, ""Resetting metered status for netId="" + mMeteredWifi);
            setWifiMeteredStatus(mMeteredWifi, /* metered= */ null);
            assertWifiMeteredStatus(mMeteredWifi, /* metered= */ null);
            assertActiveNetworkMetered(false);
        }
    }

    private String setWifiMeteredStatus(Boolean metered) throws Exception {
        // Must use Shell permissions to get the connection info because on headless system user
        // mode the method would be called by the device owner on system user, which have location
        // disabled (and hence the returned connectionInfo would have the SSID redacted).
        WifiInfo connectionInfo = invokeStaticMethodWithShellPermissions(
                () -> mWm.getConnectionInfo());

        String ssid = connectionInfo.getSSID();
        assertNotNull(""null SSID"", ssid);
        assertNotEquals(""unknown SSID"", WifiManager.UNKNOWN_SSID, ssid);

        final String netId = ssid.trim().replaceAll(""\"""", """"); // remove quotes, if any.
        assertFalse(""empty SSID"", ssid.isEmpty());

        Log.d(TAG, ""setWifiMeteredStatus("" + metered + ""): setting "" + connectionInfo);
        setWifiMeteredStatus(netId, metered);
        return netId;
    }

    private void setWifiMeteredStatus(String ssid, Boolean metered) throws Exception {
        Log.i(TAG, ""Setting wi-fi network "" + ssid + "" metered status to "" + metered);
        executeCmd(""cmd netpolicy set metered-network "" + ssid + "" "" +
                (metered != null ? metered.toString() : ""undefined""));
    }

    private void assertWifiMeteredStatus(String ssid, Boolean metered) throws Exception {
        final String cmd = ""cmd netpolicy list wifi-networks"";
        final String expectedResult = ssid + "";"" + (metered != null ? metered.toString() : ""none"");
        String cmdResult = null;
        for (int i = 0; i < NUM_TRIES_METERED_STATUS_CHECK; ++i) {
            cmdResult = executeCmd(cmd);
            if (cmdResult.contains(expectedResult)) {
                return;
            }
            SystemClock.sleep(INTERVAL_METERED_STATUS_CHECK_MS);
        }
        fail(""Timed out waiting for wifi metered status to change. expected="" + expectedResult
                + "", actual status="" + cmdResult);
    }

    private void assertActiveNetworkMetered(boolean metered) {
        boolean actualMeteredStatus = !metered;
        for (int i = 0; i < NUM_TRIES_METERED_STATUS_CHECK; ++i) {
            actualMeteredStatus = mCm.isActiveNetworkMetered();
            if (actualMeteredStatus == metered) {
                return;
            }
            SystemClock.sleep(INTERVAL_METERED_STATUS_CHECK_MS);
        }
        fail(""Timed out waiting for active network metered status to change. expected=""
                + metered + ""; actual="" + actualMeteredStatus
                + ""; networkInfo="" + mCm.getActiveNetwork());
    }

    private String executeCmd(String cmd) throws Exception {
        final String result = SystemUtil.runShellCommand(getInstrumentation(), cmd);
        Log.i(TAG, ""Cmd '"" + cmd + ""' result: "" + result);
        return result;
    }

    private int getActiveNetworkNetId() {
        Network network = mCm.getActiveNetwork();
        if (network == null) {
            return 0;
        }
        return network.getNetId();
    }

    private void waitForReconnection(int oldNetId) throws InterruptedException {
        long pollingDeadline = System.currentTimeMillis()
                + WAIT_FOR_NETWORK_RECONNECTION_TIMEOUT_SEC * 1000;
        int latestNetId;
        do {
            Thread.sleep(1000);
            if (System.currentTimeMillis() >= pollingDeadline) {
                fail(""Timeout waiting for network reconnection"");
            }
            latestNetId = getActiveNetworkNetId();
            // NetId will be 0 while old network is disconnected but new network
            // has not come up yet.
        } while (latestNetId == 0 || latestNetId == oldNetId);
    }
}"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.audio.USBRestrictRecordAActivity"	"LocalClickListener"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/audio/USBRestrictRecordAActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.audio;

import android.app.Activity;
import android.app.PendingIntent;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.hardware.usb.UsbDevice;
import android.hardware.usb.UsbManager;
import android.Manifest;
import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.widget.TextView;
import android.widget.Toast;

import java.util.Collection;
import java.util.HashMap;

import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;  // needed to access resource in CTSVerifier project namespace.

/*
 * This tests the USB Restrict Record functionality for the explicit USB device open case
 *   (case ""A"").
 * The other 2 cases are:
 *   A SINGLE activity is invoked when a USB device is plugged in. (Case B)
 *   ONE OF A MULTIPLE activities is iUSBRestrictedRecordAActivity. (Case C)
 *
 * We are using simple single-character distiguishes to avoid really long class names.
 */
public class USBRestrictRecordAActivity extends PassFailButtons.Activity {
    private static final String TAG = ""USBRestrictRecordAActivity"";
    private static final boolean DEBUG = false;

    private LocalClickListener mButtonClickListener = new LocalClickListener();

    private Context mContext;

    // Test MUST be run WITHOUT record pemission
    private boolean mHasRecordPermission;

    // System USB stuff
    private UsbManager mUsbManager;


    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        setContentView(R.layout.usb_restrictrecord);

        findViewById(R.id.test_button).setOnClickListener(mButtonClickListener);

        mContext = this;

        mUsbManager = (UsbManager)getSystemService(Context.USB_SERVICE);

        setPassFailButtonClickListeners();
        getPassButton().setEnabled(false);
        setInfoResources(R.string.audio_usb_restrict_record_test,
                R.string.audio_usb_restrict_record_entry, -1);

        mHasRecordPermission = hasRecordPermission();

        if (mHasRecordPermission) {
            TextView tx = findViewById(R.id.usb_restrictrecord_instructions);
            tx.setText(getResources().getString(R.string.audio_usb_restrict_permission_info));
        }
        findViewById(R.id.test_button).setEnabled(!mHasRecordPermission);
    }

    private boolean hasRecordPermission() {
        try {
            PackageManager pm = getPackageManager();
            PackageInfo packageInfo = pm.getPackageInfo(
                    getApplicationInfo().packageName, PackageManager.GET_PERMISSIONS);

            if (packageInfo.requestedPermissions != null) {
                for (String permission : packageInfo.requestedPermissions) {
                    if (permission.equals(Manifest.permission.RECORD_AUDIO)) {
                        return checkSelfPermission(permission) == PackageManager.PERMISSION_GRANTED;
                    }
                }
            }
        } catch (PackageManager.NameNotFoundException e) {
            Log.e(TAG, ""Unable to load package's permissions"", e);
            Toast.makeText(this, R.string.runtime_permissions_error, Toast.LENGTH_SHORT).show();
        }
        return false;
    }

    public class LocalClickListener implements View.OnClickListener {
        @Override
        public void onClick(View view) {
            int id = view.getId();
            switch (id) {
                case R.id.test_button:
                    connectUSB(mContext);
                    break;
            }
        }
    }

    private class ConnectDeviceBroadcastReceiver extends BroadcastReceiver {
        private final String TAG = ""ConnectDeviceBroadcastReceiver"";
        @Override
        public void onReceive(Context context, Intent intent) {
            String action = intent.getAction();
            if (ACTION_USB_PERMISSION.equals(action)) {
                synchronized (this) {
                    getPassButton().setEnabled(true);

                    // These messages don't really matter
                    if (intent.getBooleanExtra(UsbManager.EXTRA_PERMISSION_GRANTED, false)) {
                        Toast.makeText(mContext, ""Permission Granted."", Toast.LENGTH_SHORT).show();
                    }
                    else {
                        Toast.makeText(mContext, ""Permission Denied."", Toast.LENGTH_SHORT).show();
                    }
                }
            }
        }
    }

    private static final String ACTION_USB_PERMISSION = ""com.android.usbdescriptors.USB_PERMISSION"";

    public void connectUSB(Context context) {
        HashMap<String, UsbDevice> deviceList = mUsbManager.getDeviceList();
        Collection<UsbDevice> deviceCollection = deviceList.values();
        Object[] devices = deviceCollection.toArray();
        if (devices.length > 0) {
            UsbDevice theDevice = (UsbDevice) devices[0];

            PendingIntent permissionIntent =
                    PendingIntent.getBroadcast(context, 0, new Intent(ACTION_USB_PERMISSION), PendingIntent.FLAG_MUTABLE_UNAUDITED);

            IntentFilter filter = new IntentFilter(ACTION_USB_PERMISSION);
            ConnectDeviceBroadcastReceiver usbReceiver =
                    new ConnectDeviceBroadcastReceiver();
            context.registerReceiver(usbReceiver, filter);

            mUsbManager.requestPermission(theDevice, permissionIntent);
        }
    }
}"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.telephony.cts.SubscriptionManagerTest"	"isSupported"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/SubscriptionManagerTest.java"	""	"/*
 *.
 */

package android.telephony.cts;

import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_NOT_CONGESTED;
import static android.net.NetworkCapabilities.NET_CAPABILITY_NOT_RESTRICTED;
import static android.net.NetworkCapabilities.NET_CAPABILITY_TEMPORARILY_NOT_METERED;
import static android.net.NetworkCapabilities.TRANSPORT_CELLULAR;
import static android.telephony.TelephonyManager.SET_OPPORTUNISTIC_SUB_SUCCESS;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import android.annotation.Nullable;
import android.app.UiAutomation;
import android.content.pm.PackageManager;
import android.content.res.Resources;
import android.net.ConnectivityManager;
import android.net.ConnectivityManager.NetworkCallback;
import android.net.Network;
import android.net.NetworkCapabilities;
import android.net.NetworkRequest;
import android.net.Uri;
import android.os.Looper;
import android.os.ParcelUuid;
import android.os.PersistableBundle;
import android.telephony.CarrierConfigManager;
import android.telephony.SubscriptionInfo;
import android.telephony.SubscriptionManager;
import android.telephony.SubscriptionPlan;
import android.telephony.TelephonyManager;
import android.telephony.ims.ImsException;
import android.telephony.ims.ImsManager;
import android.telephony.ims.ImsMmTelManager;
import android.telephony.ims.ImsRcsManager;
import android.telephony.ims.RcsUceAdapter;
import android.util.Log;

import androidx.test.InstrumentationRegistry;

import com.android.compatibility.common.util.ShellIdentityUtils;
import com.android.compatibility.common.util.SystemUtil;
import com.android.compatibility.common.util.TestThread;
import com.android.internal.util.ArrayUtils;

import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.time.Period;
import java.time.ZonedDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.UUID;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executor;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Consumer;
import java.util.function.Predicate;
import java.util.stream.Collectors;


public class SubscriptionManagerTest {
    private static final String TAG = ""SubscriptionManagerTest"";
    private static final String MODIFY_PHONE_STATE = ""android.permission.MODIFY_PHONE_STATE"";
    private static final List<Uri> CONTACTS = new ArrayList<>();
    static {
        CONTACTS.add(Uri.fromParts(""tel"", ""+16505551212"", null));
        CONTACTS.add(Uri.fromParts(""tel"", ""+16505552323"", null));
    }

    private int mSubId;
    private int mDefaultVoiceSubId;
    private String mPackageName;
    private SubscriptionManager mSm;

    /**
     * Callback used in testRegisterNetworkCallback that allows caller to block on
     * {@code onAvailable}.
     */
    private static class TestNetworkCallback extends ConnectivityManager.NetworkCallback {
        private final CountDownLatch mAvailableLatch = new CountDownLatch(1);

        public void waitForAvailable() throws InterruptedException {
            assertTrue(""Cellular network did not come up after 5 seconds"",
                    mAvailableLatch.await(5, TimeUnit.SECONDS));
        }

        @Override
        public void onAvailable(Network network) {
            mAvailableLatch.countDown();
        }
    }

    @BeforeClass
    public static void setUpClass() throws Exception {
        if (!isSupported()) return;

        final TestNetworkCallback callback = new TestNetworkCallback();
        final ConnectivityManager cm = InstrumentationRegistry.getContext()
                .getSystemService(ConnectivityManager.class);
        cm.registerNetworkCallback(new NetworkRequest.Builder()
                .addTransportType(TRANSPORT_CELLULAR)
                .addCapability(NET_CAPABILITY_INTERNET)
                .build(), callback);
        try {
            // Wait to get callback for availability of internet
            callback.waitForAvailable();
        } catch (InterruptedException e) {
            fail(""NetworkCallback wait was interrupted."");
        } finally {
            cm.unregisterNetworkCallback(callback);
        }
    }

    @AfterClass
    public static void tearDownClass() throws Exception {
        if (!isSupported()) return;
        TelephonyUtils.flushTelephonyMetrics(InstrumentationRegistry.getInstrumentation());
    }

    @Before
    public void setUp() throws Exception {
        if (!isSupported()) return;

        mSm = InstrumentationRegistry.getContext().getSystemService(SubscriptionManager.class);
        mSubId = SubscriptionManager.getDefaultDataSubscriptionId();
        mDefaultVoiceSubId = SubscriptionManager.getDefaultVoiceSubscriptionId();
        mPackageName = InstrumentationRegistry.getContext().getPackageName();
    }

    /**
     * Correctness check that both {@link PackageManager#FEATURE_TELEPHONY} and
     * {@link NetworkCapabilities#TRANSPORT_CELLULAR} network must both be
     * either defined or undefined; you can't cross the streams.
     */"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.telephony.cts.SubscriptionManagerTest"	"testSetAndGetD2DSharingContacts"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/SubscriptionManagerTest.java"	""	"public void testSetAndGetD2DSharingContacts() {
        if (!isSupported()) return;

        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        uiAutomation.adoptShellPermissionIdentity(MODIFY_PHONE_STATE);
        List<Uri> originalD2DSharingContacts = mSm.getDeviceToDeviceStatusSharingContacts(mSubId);
        mSm.setDeviceToDeviceStatusSharingContacts(mSubId, CONTACTS);
        assertEquals(CONTACTS, mSm.getDeviceToDeviceStatusSharingContacts(mSubId));
        mSm.setDeviceToDeviceStatusSharingContacts(mSubId, originalD2DSharingContacts);
        uiAutomation.dropShellPermissionIdentity();
    }

    @Nullable
    private PersistableBundle getBundleFromBackupData(byte[] data) {
        try (ByteArrayInputStream bis = new ByteArrayInputStream(data)) {
            return PersistableBundle.readFromStream(bis);
        } catch (IOException e) {
            return null;
        }
    }

    private void overrideCarrierConfig(PersistableBundle bundle, int subId) throws Exception {
        CarrierConfigManager carrierConfigManager = InstrumentationRegistry.getContext()
                .getSystemService(CarrierConfigManager.class);
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(carrierConfigManager,
                (m) -> m.overrideConfig(subId, bundle));
    }

    private void setPreferredDataSubId(int subId) {
        final LinkedBlockingQueue<Integer> resultQueue = new LinkedBlockingQueue<>(1);
        Executor executor = (command)-> command.run();
        Consumer<Integer> consumer = (res)-> {
            if (res == null) {
                resultQueue.offer(-1);
            } else {
                resultQueue.offer(res);
            }
        };

        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mSm,
                (sm) -> sm.setPreferredDataSubscriptionId(subId, false,
                        executor, consumer));
        int res = -1;
        try {
            res = resultQueue.poll(2, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
            fail(""Cannot get the modem result in time"");
        }

        assertEquals(SET_OPPORTUNISTIC_SUB_SUCCESS, res);
        int getValue = executeWithShellPermissionAndDefault(-1, mSm,
                (sm) -> sm.getPreferredDataSubscriptionId());
        assertEquals(subId, getValue);
    }

    private <T, U> T executeWithShellPermissionAndDefault(T defaultValue, U targetObject,
            ShellIdentityUtils.ShellPermissionMethodHelper<T, U> helper) {
        try {
            return ShellIdentityUtils.invokeMethodWithShellPermissions(targetObject, helper);
        } catch (Exception e) {
            // do nothing, return default
        }
        return defaultValue;
    }

    private void assertOverrideSuccess(SubscriptionPlan... plans) {
        mSm.setSubscriptionPlans(mSubId, Arrays.asList(plans));
        mSm.setSubscriptionOverrideCongested(mSubId, false, 0);
    }

    private void assertOverrideFails(SubscriptionPlan... plans) {
        mSm.setSubscriptionPlans(mSubId, Arrays.asList(plans));
        try {
            mSm.setSubscriptionOverrideCongested(mSubId, false, 0);
            fail();
        } catch (SecurityException | IllegalStateException expected) {
        }
    }

    public static CountDownLatch waitForNetworkCapabilities(Network network,
            Predicate<NetworkCapabilities> predicate) {
        final CountDownLatch latch = new CountDownLatch(1);
        final ConnectivityManager cm = InstrumentationRegistry.getContext()
                .getSystemService(ConnectivityManager.class);
        cm.registerNetworkCallback(new NetworkRequest.Builder().build(),
                new NetworkCallback() {
                    @Override
                    public void onCapabilitiesChanged(Network net, NetworkCapabilities caps) {
                        if (net.equals(network) && predicate.test(caps)) {
                            latch.countDown();
                            cm.unregisterNetworkCallback(this);
                        }
                    }
                });
        return latch;
    }

    /**
     * Corresponding to findCellularNetwork()
     */
    private static CountDownLatch waitForCellularNetwork() {
        final CountDownLatch latch = new CountDownLatch(1);
        final ConnectivityManager cm = InstrumentationRegistry.getContext()
                .getSystemService(ConnectivityManager.class);
        cm.registerNetworkCallback(new NetworkRequest.Builder().build(),
                new NetworkCallback() {
                    @Override
                    public void onCapabilitiesChanged(Network net, NetworkCapabilities caps) {
                        if (caps.hasTransport(TRANSPORT_CELLULAR)
                                && caps.hasCapability(NET_CAPABILITY_INTERNET)
                                && caps.hasCapability(NET_CAPABILITY_NOT_RESTRICTED)) {
                            latch.countDown();
                            cm.unregisterNetworkCallback(this);
                        }
                    }
                });
        return latch;
    }

    private static SubscriptionPlan buildValidSubscriptionPlan(long dataUsageTime) {
        return SubscriptionPlan.Builder
                .createRecurring(ZonedDateTime.parse(""2007-03-14T00:00:00.000Z""),
                        Period.ofMonths(1))
                .setTitle(""CTS"")
                .setDataLimit(1_000_000_000, SubscriptionPlan.LIMIT_BEHAVIOR_DISABLED)
                .setDataUsage(500_000_000, dataUsageTime)
                .build();
    }

    private static @Nullable Network findCellularNetwork() {
        final ConnectivityManager cm = InstrumentationRegistry.getContext()
                .getSystemService(ConnectivityManager.class);
        for (Network net : cm.getAllNetworks()) {
            final NetworkCapabilities caps = cm.getNetworkCapabilities(net);
            if (caps != null && caps.hasTransport(TRANSPORT_CELLULAR)
                    && caps.hasCapability(NET_CAPABILITY_INTERNET)
                    && caps.hasCapability(NET_CAPABILITY_NOT_RESTRICTED)) {
                return net;
            }
        }
        return null;
    }

    private static boolean isSupported() {
        return InstrumentationRegistry.getContext().getPackageManager()
                .hasSystemFeature(PackageManager.FEATURE_TELEPHONY);
    }

    private static boolean isAutomotive() {
        return InstrumentationRegistry.getContext().getPackageManager()
                .hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE);
    }

    private static boolean isDSDS() {
        TelephonyManager tm = InstrumentationRegistry.getContext()
                .getSystemService(TelephonyManager.class);
        return tm != null && tm.getPhoneCount() > 1;
    }

    private static void setSubPlanOwner(int subId, String packageName) throws Exception {
        SystemUtil.runShellCommand(InstrumentationRegistry.getInstrumentation(),
                ""cmd netpolicy set sub-plan-owner "" + subId + "" "" + packageName);
    }

    private boolean isUnmetered5GSupported() {
        final CarrierConfigManager ccm = InstrumentationRegistry.getContext()
                .getSystemService(CarrierConfigManager.class);
        PersistableBundle carrierConfig = ccm.getConfigForSubId(mSubId);

        final TelephonyManager tm = InstrumentationRegistry.getContext()
                .getSystemService(TelephonyManager.class);
        int dataNetworkType = tm.getDataNetworkType(mSubId);
        long supportedRats = ShellIdentityUtils.invokeMethodWithShellPermissions(tm,
                TelephonyManager::getSupportedRadioAccessFamily);

        boolean validCarrier = carrierConfig.getBoolean(
                CarrierConfigManager.KEY_NETWORK_TEMP_NOT_METERED_SUPPORTED_BOOL);
        boolean validCapabilities = (supportedRats & TelephonyManager.NETWORK_TYPE_BITMASK_NR) != 0;
        // TODO: need to check for TelephonyDisplayInfo override for NR NSA
        boolean validNetworkType = dataNetworkType == TelephonyManager.NETWORK_TYPE_NR;

        return validCarrier && validNetworkType && validCapabilities;
    }
}"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.media.session.cts.MediaSessionManagerHostTest"	"testGetActiveSessionsFull_additionalUser"	"CtsMediaHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/media/src/android/media/session/cts/MediaSessionManagerHostTest.java"	""	"public void testGetActiveSessionsFull_additionalUser() throws Exception {
        testGetActiveSessions_additionalUser(false);
    }

    private void testGetActiveSessions_additionalUser(boolean instant) throws Exception {
        if (!canCreateAdditionalUsers(1)) {
            CLog.logAndDisplay(LogLevel.INFO,
                    ""Cannot create a new user. Skipping multi-user test cases."");
            return;
        }

        // Test if another user can get the session.
        int newUser = createAndStartUser();
        installAppAsUser(DEVICE_SIDE_TEST_APK, newUser, instant);
        setAllowGetActiveSessionForTest(true, newUser);
        runTestAsUser(""testGetActiveSessions_noMediaSession"", newUser);
        removeUser(newUser);
    }

    /**
     * Tests {@link MediaSessionManager#getActiveSessions} with restricted profiles.
     */
    @AppModeInstant
    @RequiresDevice"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.media.session.cts.MediaSessionManagerHostTest"	"testGetActiveSessionsInstant_restrictedProfiles"	"CtsMediaHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/media/src/android/media/session/cts/MediaSessionManagerHostTest.java"	""	"public void testGetActiveSessionsInstant_restrictedProfiles() throws Exception {
        testGetActiveSessions_restrictedProfiles(true);
    }

    /**
     * Tests {@link MediaSessionManager#getActiveSessions} with restricted profiles.
     */
    @AppModeFull
    @RequiresDevice"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.media.session.cts.MediaSessionManagerHostTest"	"testGetActiveSessionsFull_restrictedProfiles"	"CtsMediaHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/media/src/android/media/session/cts/MediaSessionManagerHostTest.java"	""	"public void testGetActiveSessionsFull_restrictedProfiles() throws Exception {
        testGetActiveSessions_restrictedProfiles(false);
    }

    private void testGetActiveSessions_restrictedProfiles(boolean instant)
            throws Exception {
        if (!canCreateAdditionalUsers(1)) {
            CLog.logAndDisplay(LogLevel.INFO,
                    ""Cannot create a new user. Skipping multi-user test cases."");
            return;
        }

        // Test if another restricted profile can get the session.
        // Remove the created user first not to exceed system's user number limit.
        int newUser = createAndStartRestrictedProfile(getDevice().getPrimaryUserId());
        installAppAsUser(DEVICE_SIDE_TEST_APK, newUser, instant);
        setAllowGetActiveSessionForTest(true, newUser);
        runTestAsUser(""testGetActiveSessions_noMediaSession"", newUser);
        removeUser(newUser);
    }

    /**
     * Tests {@link MediaSessionManager#getActiveSessions} with managed profiles.
     */
    @AppModeInstant
    @RequiresDevice"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.AudioRestrictionTest"	"isFullVolumeDevice"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/AudioRestrictionTest.java"	""	"public void test/*
 *.
 */

package com.android.cts.deviceandprofileowner;

import android.content.Context;
import android.content.pm.PackageManager;
import android.content.res.Resources;
import android.media.AudioManager;
import android.media.MediaPlayer;
import android.net.Uri;
import android.provider.Settings;
import android.os.SystemClock;
import android.os.UserManager;
import android.util.Log;

import java.util.Objects;
import java.util.concurrent.Callable;
import java.util.regex.Pattern;

public class AudioRestrictionTest extends BaseDeviceAdminTest {
    private static final String TAG = AudioRestrictionTest.class.getSimpleName();
    private AudioManager mAudioManager;
    private PackageManager mPackageManager;
    private boolean mUseFixedVolume;
    private boolean mUseFullVolume;
    private final Callable<Boolean> mCheckIfMasterVolumeMuted = new Callable<Boolean>() {
        @Override
        public Boolean call() throws Exception {
            return mDevicePolicyManager.isMasterVolumeMuted(ADMIN_RECEIVER_COMPONENT);
        }
    };

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        mAudioManager = (AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE);
        mPackageManager = mContext.getPackageManager();
        mUseFixedVolume = mContext.getResources().getBoolean(
                Resources.getSystem().getIdentifier(""config_useFixedVolume"", ""bool"", ""android""));
        mUseFullVolume = isFullVolumeDevice();
    }

    // Here we test that DISALLOW_ADJUST_VOLUME disallows to unmute volume."	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.AudioRestrictionTest"	"testDisallowAdjustVolume_muted"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/AudioRestrictionTest.java"	""	"public void testDisallowAdjustVolume_muted() throws Exception {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_AUDIO_OUTPUT)) {
            return;
        }

        // If we check that some value did not change, we must wait until the action is applied.
        // Method waitUntil() may check old value before changes took place.
        final int WAIT_TIME_MS = 1000;
        final boolean initVolumeMuted =
                mDevicePolicyManager.isMasterVolumeMuted(ADMIN_RECEIVER_COMPONENT);
        try {
            // Unmute volume, if necessary.
            if (initVolumeMuted) {
                mDevicePolicyManager.setMasterVolumeMuted(ADMIN_RECEIVER_COMPONENT, false);
                waitUntil(false, mCheckIfMasterVolumeMuted);
            }

            // DISALLOW_ADJUST_VOLUME must mute volume.
            mDevicePolicyManager.addUserRestriction(ADMIN_RECEIVER_COMPONENT,
                    UserManager.DISALLOW_ADJUST_VOLUME);
            waitUntil(true, mCheckIfMasterVolumeMuted);

            // Unmute should not have effect because the restriction does not allow this.
            mDevicePolicyManager.setMasterVolumeMuted(ADMIN_RECEIVER_COMPONENT, false);
            Thread.sleep(WAIT_TIME_MS);
            assertTrue(mDevicePolicyManager.isMasterVolumeMuted(ADMIN_RECEIVER_COMPONENT));
        } finally {
            mDevicePolicyManager.clearUserRestriction(ADMIN_RECEIVER_COMPONENT,
                    UserManager.DISALLOW_ADJUST_VOLUME);
            mDevicePolicyManager.setMasterVolumeMuted(ADMIN_RECEIVER_COMPONENT, initVolumeMuted);
        }
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.AudioRestrictionTest"	"testDisallowAdjustVolume"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/AudioRestrictionTest.java"	""	"public void testDisallowAdjustVolume() throws Exception {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_AUDIO_OUTPUT)
                || mUseFixedVolume || mUseFullVolume) {
            return;
        }

        Uri uri = Uri.parse(""android.resource://"" + mContext.getPackageName() + ""/"" + R.raw.ringer);
        MediaPlayer mediaPlayer = new MediaPlayer();
        mediaPlayer.setDataSource(mContext, uri);
        mediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);
        mediaPlayer.prepare();
        mediaPlayer.setLooping(true);
        mediaPlayer.start();

        try {
            // Set volume of music to be 1.
            mAudioManager.setStreamVolume(AudioManager.STREAM_MUSIC, 1, /* flag= */ 0);

            // Disallow adjusting volume.
            mDevicePolicyManager.addUserRestriction(ADMIN_RECEIVER_COMPONENT,
                    UserManager.DISALLOW_ADJUST_VOLUME);
            waitUntil(true, mCheckIfMasterVolumeMuted);

            // Verify that volume can't be changed.
            mAudioManager.adjustVolume(AudioManager.ADJUST_RAISE, /* flag= */ 0);
            assertEquals(1, mAudioManager.getStreamVolume(AudioManager.STREAM_MUSIC));

            // Allowing adjusting volume.
            mDevicePolicyManager.clearUserRestriction(ADMIN_RECEIVER_COMPONENT,
                    UserManager.DISALLOW_ADJUST_VOLUME);
            waitUntil(false, mCheckIfMasterVolumeMuted);

            // Verify the volume can be changed now.
            mAudioManager.adjustVolume(AudioManager.ADJUST_RAISE,  /* flag= */ 0);
            waitUntil(2, new Callable<Integer>() {
                @Override
                public Integer call() throws Exception {
                    return mAudioManager.getStreamVolume(AudioManager.STREAM_MUSIC);
                }
            });
        } finally {
            // Clear the restriction.
            mDevicePolicyManager.clearUserRestriction(ADMIN_RECEIVER_COMPONENT,
                    UserManager.DISALLOW_ADJUST_VOLUME);
            waitUntil(false, mCheckIfMasterVolumeMuted);
        }

        mediaPlayer.stop();
        mediaPlayer.release();
        mediaPlayer = null;
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.AudioRestrictionTest"	"testDisallowUnmuteMicrophone"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/AudioRestrictionTest.java"	""	"public void testDisallowUnmuteMicrophone() throws Exception {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_MICROPHONE)) {
            return;
        }

        try {
            mAudioManager.setMicrophoneMute(false);
            if (mAudioManager.isMicrophoneMute()) {
                Log.w(TAG, ""Mic seems muted by hardware! Please unmute and rerrun the test."");
                return;
            }

            // Disallow the microphone to be unmuted.
            mDevicePolicyManager.addUserRestriction(
                    ADMIN_RECEIVER_COMPONENT, UserManager.DISALLOW_UNMUTE_MICROPHONE);
            waitUntil(true, new Callable<Boolean>() {
                @Override
                public Boolean call() throws Exception {
                    return mAudioManager.isMicrophoneMute();
                }
            });
            // Verify that we can't unmute the microphone.
            mAudioManager.setMicrophoneMute(false);
            assertTrue(mAudioManager.isMicrophoneMute());
        } finally {
            // Clear the restriction
            mDevicePolicyManager.clearUserRestriction(
                    ADMIN_RECEIVER_COMPONENT, UserManager.DISALLOW_UNMUTE_MICROPHONE);
            waitUntil(false, new Callable<Boolean>() {
                @Override
                public Boolean call() throws Exception {
                    return mAudioManager.isMicrophoneMute();
                }
            });
        }
    }

    private <T> void waitUntil(T expected, Callable<T> c) throws Exception {
        final long start = SystemClock.elapsedRealtime();
        final int TIMEOUT_MS = 5 * 1000;

        T actual;
        while (!Objects.equals(expected, actual = c.call())) {
            if ((SystemClock.elapsedRealtime() - start) >= TIMEOUT_MS) {
                fail(String.format(""Timed out waiting the value to change to %s (actual=%s)"",
                        expected, actual));
            }
            Thread.sleep(200);
        }
    }

    private boolean isFullVolumeDevice() {
        String commandOutput = runShellCommand(""dumpsys audio"");

        for (String line : commandOutput.split(""\\r?\\n"")) {
            if (Pattern.matches(""\\s*mHdmiCecSink=true"", line)
                    || (Pattern.matches(""\\s*mHdmiPlayBackClient="", line)
                    && !Pattern.matches(""=null$"", line))) {
                return true;
            }
        }
        return false;
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.devicepolicy.cts.PreferentialNetworkServiceTest"	"TestApis"	"CtsDevicePolicyTestCases"	"/home/gpoor/cts-12-source/cts/tests/devicepolicy/src/android/devicepolicy/cts/PreferentialNetworkServiceTest.java"	""	"/*
 *.
 */

package android.devicepolicy.cts;

import static android.Manifest.permission.ACCESS_NETWORK_STATE;
import static android.Manifest.permission.NETWORK_SETTINGS;
import static android.net.NetworkCapabilities.NET_CAPABILITY_ENTERPRISE;
import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_NOT_RESTRICTED;
import static android.net.NetworkCapabilities.NET_CAPABILITY_NOT_VCN_MANAGED;

import android.app.Instrumentation;
import android.content.Context;
import android.net.ConnectivityManager;
import android.net.Network;
import android.net.NetworkCapabilities;
import android.net.NetworkProvider;
import android.net.NetworkScore;
import android.os.HandlerExecutor;
import android.os.HandlerThread;
import android.os.Process;
import android.util.Range;

import androidx.test.platform.app.InstrumentationRegistry;

import com.android.bedstead.harrier.BedsteadJUnit4;
import com.android.bedstead.harrier.DeviceState;
import com.android.bedstead.harrier.annotations.EnsureHasPermission;
import com.android.bedstead.harrier.annotations.Postsubmit;
import com.android.bedstead.harrier.annotations.enterprise.PositivePolicyTest;
import com.android.bedstead.harrier.policies.PreferentialNetworkService;
import com.android.bedstead.nene.TestApis;
import com.android.testutils.TestableNetworkCallback;
import com.android.testutils.TestableNetworkOfferCallback;

import org.junit.After;
import org.junit.Before;
import org.junit.ClassRule;
import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.Objects;
import java.util.Set;

// TODO(b/190797743): Move this test to to net test folder.
@RunWith(BedsteadJUnit4.class)
public class PreferentialNetworkServiceTest {
    @ClassRule @Rule
    public static final DeviceState sDeviceState = new DeviceState();

    private final long DEFAULT_TIMEOUT_MS = 30_000L;
    private final long NO_CALLBACK_TIMEOUT_MS = 100L;
    private final String TAG = PreferentialNetworkServiceTest.class.getSimpleName();

    private static final TestApis sTestApis = new TestApis();
    private static final Context sContext = sTestApis.context().instrumentedContext();
    private static final ConnectivityManager sCm =
            sContext.getSystemService(ConnectivityManager.class);
    private final HandlerThread mHandlerThread = new HandlerThread(TAG + "" handler thread"");
    private final NetworkCapabilities mEnterpriseNcFilter = new NetworkCapabilities.Builder()
            .addCapability(NET_CAPABILITY_INTERNET)
            .addCapability(NET_CAPABILITY_NOT_VCN_MANAGED)
            .addCapability(NET_CAPABILITY_ENTERPRISE)
            .removeCapability(NET_CAPABILITY_NOT_RESTRICTED)
            // Only accept requests from this uid, otherwise the provider who uses this
            // filter might see all requests of the same user if the feature is enabled.
            .setUids(Set.of(new Range(Process.myUid(), Process.myUid())))
            .build();

    @Before
    public void setUp() throws Exception {
        mHandlerThread.start();
    }

    @After
    public void tearDown() throws Exception {
        mHandlerThread.quitSafely();
    }

    /**
     * Enable PreferentialNetworkService, verify the provider that provides enterprise slice can
     * see the enterprise slice requests.
     */"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.app.usage.cts.UsageStatsTest"	"isAppStandbyEnabled"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	"/**
 * Copyright (C) 2014 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License""); you may not
 * use this file except in compliance with the License. You may obtain a copy
 * of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */

package android.app.usage.cts;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.junit.Assume.assumeFalse;
import static org.junit.Assume.assumeTrue;

import android.app.Activity;
import android.app.ActivityManager;
import android.app.AppOpsManager;
import android.app.KeyguardManager;
import android.app.Notification;
import android.app.NotificationChannel;
import android.app.NotificationManager;
import android.app.PendingIntent;
import android.app.usage.EventStats;
import android.app.usage.UsageEvents;
import android.app.usage.UsageEvents.Event;
import android.app.usage.UsageStats;
import android.app.usage.UsageStatsManager;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.ServiceConnection;
import android.content.pm.PackageManager;
import android.os.IBinder;
import android.os.Parcel;
import android.os.SystemClock;
import android.os.UserHandle;
import android.os.UserManager;
import android.platform.test.annotations.AppModeFull;
import android.platform.test.annotations.AppModeInstant;
import android.provider.Settings;
import android.server.wm.WindowManagerState;
import android.server.wm.WindowManagerStateHelper;
import android.support.test.uiautomator.By;
import android.support.test.uiautomator.UiDevice;
import android.support.test.uiautomator.Until;
import android.text.format.DateUtils;
import android.util.Log;
import android.util.SparseArray;
import android.util.SparseLongArray;
import android.view.KeyEvent;

import androidx.test.InstrumentationRegistry;
import androidx.test.runner.AndroidJUnit4;

import com.android.compatibility.common.util.AppStandbyUtils;
import com.android.compatibility.common.util.BatteryUtils;
import com.android.compatibility.common.util.SystemUtil;

import org.junit.After;
import org.junit.Before;
import org.junit.Ignore;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.io.IOException;
import java.text.MessageFormat;
import java.time.Duration;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;
import java.util.function.BooleanSupplier;

/**
 * Test the UsageStats API. It is difficult to test the entire surface area
 * of the API, as a lot of the testing depends on what data is already present
 * on the device and for how long that data has been aggregating.
 *
 * These tests perform simple checks that each interval is of the correct duration,
 * and that events do appear in the event log.
 *
 * Tests to add that are difficult to add now:
 * - Invoking a device configuration change and then watching for it in the event log.
 * - Changing the system time and verifying that all data has been correctly shifted
 *   along with the new time.
 * - Proper eviction of old data.
 */
@RunWith(AndroidJUnit4.class)
public class UsageStatsTest {
    private static final boolean DEBUG = false;
    private static final String TAG = ""UsageStatsTest"";

    private static final String APPOPS_SET_SHELL_COMMAND = ""appops set {0} "" +
            AppOpsManager.OPSTR_GET_USAGE_STATS + "" {1}"";

    private static final String GET_SHELL_COMMAND = ""settings get global "";

    private static final String SET_SHELL_COMMAND = ""settings put global "";

    private static final String DELETE_SHELL_COMMAND = ""settings delete global "";

    private static final String JOBSCHEDULER_RUN_SHELL_COMMAND = ""cmd jobscheduler run"";

    private static final String TEST_APP_PKG = ""android.app.usage.cts.test1"";
    private static final String TEST_APP_CLASS = ""android.app.usage.cts.test1.SomeActivity"";
    private static final String TEST_APP_CLASS_LOCUS
            = ""android.app.usage.cts.test1.SomeActivityWithLocus"";
    private static final String TEST_APP_CLASS_SERVICE
            = ""android.app.usage.cts.test1.TestService"";
    private static final String TEST_APP2_PKG = ""android.app.usage.cts.test2"";
    private static final String TEST_APP2_CLASS_FINISHING_TASK_ROOT =
            ""android.app.usage.cts.test2.FinishingTaskRootActivity"";
    private static final String TEST_APP2_CLASS_PIP =
            ""android.app.usage.cts.test2.PipActivity"";
    private static final ComponentName TEST_APP2_PIP_COMPONENT = new ComponentName(TEST_APP2_PKG,
            TEST_APP2_CLASS_PIP);

    private static final long TIMEOUT = TimeUnit.SECONDS.toMillis(5);
    private static final long MINUTE = TimeUnit.MINUTES.toMillis(1);
    private static final long DAY = TimeUnit.DAYS.toMillis(1);
    private static final long WEEK = 7 * DAY;
    private static final long MONTH = 30 * DAY;
    private static final long YEAR = 365 * DAY;
    private static final long TIME_DIFF_THRESHOLD = 200;
    private static final String CHANNEL_ID = ""my_channel"";

    private static final long TIMEOUT_BINDER_SERVICE_SEC = 2;

    private Context mContext;
    private UiDevice mUiDevice;
    private ActivityManager mAm;
    private UsageStatsManager mUsageStatsManager;
    private KeyguardManager mKeyguardManager;
    private String mTargetPackage;
    private String mCachedUsageSourceSetting;
    private String mCachedEnableRestrictedBucketSetting;
    private int mOtherUser;
    private Context mOtherUserContext;
    private UsageStatsManager mOtherUsageStats;
    private WindowManagerStateHelper mWMStateHelper;

    @Before
    public void setUp() throws Exception {
        mContext = InstrumentationRegistry.getInstrumentation().getContext();
        mUiDevice = UiDevice.getInstance(InstrumentationRegistry.getInstrumentation());
        mAm = mContext.getSystemService(ActivityManager.class);
        mUsageStatsManager = (UsageStatsManager) mContext.getSystemService(
                Context.USAGE_STATS_SERVICE);
        mKeyguardManager = mContext.getSystemService(KeyguardManager.class);
        mTargetPackage = mContext.getPackageName();

        mWMStateHelper = new WindowManagerStateHelper();

        assumeTrue(""App Standby not enabled on device"", AppStandbyUtils.isAppStandbyEnabled());
        setAppOpsMode(""allow"");
        mCachedUsageSourceSetting = getSetting(Settings.Global.APP_TIME_LIMIT_USAGE_SOURCE);
        mCachedEnableRestrictedBucketSetting = getSetting(Settings.Global.ENABLE_RESTRICTED_BUCKET);
    }

    @After
    public void cleanUp() throws Exception {
        if (mCachedUsageSourceSetting != null &&
                !mCachedUsageSourceSetting.equals(
                    getSetting(Settings.Global.APP_TIME_LIMIT_USAGE_SOURCE))) {
            setUsageSourceSetting(mCachedUsageSourceSetting);
        }
        setSetting(Settings.Global.ENABLE_RESTRICTED_BUCKET, mCachedEnableRestrictedBucketSetting);
        // Force stop test package to avoid any running test code from carrying over to the next run
        SystemUtil.runWithShellPermissionIdentity(() -> mAm.forceStopPackage(TEST_APP_PKG));
        SystemUtil.runWithShellPermissionIdentity(() -> mAm.forceStopPackage(TEST_APP2_PKG));
        mUiDevice.pressHome();
        // Destroy the other user if created
        if (mOtherUser != 0) {
            stopUser(mOtherUser, true, true);
            removeUser(mOtherUser);
            mOtherUser = 0;
        }
    }

    private static void assertLessThan(long left, long right) {
        assertTrue(""Expected "" + left + "" to be less than "" + right, left < right);
    }

    private static void assertLessThanOrEqual(long left, long right) {
        assertTrue(""Expected "" + left + "" to be less than "" + right, left <= right);
    }

    private void setAppOpsMode(String mode) throws Exception {
        executeShellCmd(MessageFormat.format(APPOPS_SET_SHELL_COMMAND, mTargetPackage, mode));
    }

    private String getSetting(String name) throws Exception {
        return executeShellCmd(GET_SHELL_COMMAND + name);
    }

    private void setSetting(String name, String setting) throws Exception {
        if (setting == null || setting.equals(""null"")) {
            executeShellCmd(DELETE_SHELL_COMMAND + name);
        } else {
            executeShellCmd(SET_SHELL_COMMAND + name + "" "" + setting);
        }
    }

    private void setUsageSourceSetting(String value) throws Exception {
        setSetting(Settings.Global.APP_TIME_LIMIT_USAGE_SOURCE, value);
        mUsageStatsManager.forceUsageSourceSettingRead();
    }

    private void launchSubActivity(Class<? extends Activity> clazz) {
        final Intent intent = new Intent(Intent.ACTION_MAIN);
        intent.setClassName(mTargetPackage, clazz.getName());
        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK | Intent.FLAG_ACTIVITY_NEW_TASK);
        mContext.startActivity(intent);
        mUiDevice.wait(Until.hasObject(By.clazz(clazz)), TIMEOUT);
    }

    private Intent createTestActivityIntent(String pkgName, String className) {
        final Intent intent = new Intent();
        intent.setClassName(pkgName, className);
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        return intent;
    }

    private void launchTestActivity(String pkgName, String className) {
        mContext.startActivity(createTestActivityIntent(pkgName, className));
        mUiDevice.wait(Until.hasObject(By.clazz(pkgName, className)), TIMEOUT);
    }

    private void launchSubActivities(Class<? extends Activity>[] activityClasses) {
        for (Class<? extends Activity> clazz : activityClasses) {
            launchSubActivity(clazz);
        }
    }

    @AppModeFull(reason = ""No usage events access in instant apps"")"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.app.usage.cts.UsageStatsTest"	"testUserForceIntoRestricted"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	"public void testUserForceIntoRestricted() throws Exception {
        setSetting(Settings.Global.ENABLE_RESTRICTED_BUCKET, ""1"");

        launchSubActivity(TaskRootActivity.class);
        assertEquals(""Activity launch didn't bring app up to ACTIVE bucket"",
                UsageStatsManager.STANDBY_BUCKET_ACTIVE,
                mUsageStatsManager.getAppStandbyBucket(mTargetPackage));

        // User force shouldn't have to deal with the timeout.
        setStandByBucket(mTargetPackage, ""restricted"");
        assertEquals(""User was unable to force an ACTIVE app down into RESTRICTED bucket"",
                UsageStatsManager.STANDBY_BUCKET_RESTRICTED,
                mUsageStatsManager.getAppStandbyBucket(mTargetPackage));

    }

    // TODO(148887416): get this test to work for instant apps
    @AppModeFull(reason = ""Test APK Activity not found when installed as an instant app"")"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.app.usage.cts.UsageStatsTest"	"testUserForceIntoRestricted_BucketDisabled"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	"public void testUserForceIntoRestricted_BucketDisabled() throws Exception {
        setSetting(Settings.Global.ENABLE_RESTRICTED_BUCKET, ""0"");

        launchSubActivity(TaskRootActivity.class);
        assertEquals(""Activity launch didn't bring app up to ACTIVE bucket"",
                UsageStatsManager.STANDBY_BUCKET_ACTIVE,
                mUsageStatsManager.getAppStandbyBucket(mTargetPackage));

        // User force shouldn't have to deal with the timeout.
        setStandByBucket(mTargetPackage, ""restricted"");
        assertNotEquals(""User was able to force into RESTRICTED bucket when bucket disabled"",
                UsageStatsManager.STANDBY_BUCKET_RESTRICTED,
                mUsageStatsManager.getAppStandbyBucket(mTargetPackage));

    }

    // TODO(148887416): get this test to work for instant apps
    @AppModeFull(reason = ""Test APK Activity not found when installed as an instant app"")"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.app.usage.cts.UsageStatsTest"	"testUserLaunchRemovesFromRestricted"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	"public void testUserLaunchRemovesFromRestricted() throws Exception {
        setSetting(Settings.Global.ENABLE_RESTRICTED_BUCKET, ""1"");

        setStandByBucket(mTargetPackage, ""restricted"");
        assertEquals(""User was unable to force an app into RESTRICTED bucket"",
                UsageStatsManager.STANDBY_BUCKET_RESTRICTED,
                mUsageStatsManager.getAppStandbyBucket(mTargetPackage));

        launchSubActivity(TaskRootActivity.class);
        assertEquals(""Activity launch didn't bring RESTRICTED app into ACTIVE bucket"",
                UsageStatsManager.STANDBY_BUCKET_ACTIVE,
                mUsageStatsManager.getAppStandbyBucket(mTargetPackage));
    }

    // TODO(148887416): get this test to work for instant apps
    @AppModeFull(reason = ""Test APK Activity not found when installed as an instant app"")"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.app.usage.cts.UsageStatsTest"	"testLocusIdEventsVisibility"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	"public void testLocusIdEventsVisibility() throws Exception {
        final long startTime = System.currentTimeMillis();
        startAndDestroyActivityWithLocus();
        final long endTime = System.currentTimeMillis();

        final UsageEvents restrictedEvents = mUsageStatsManager.queryEvents(startTime, endTime);
        final UsageEvents allEvents = queryEventsAsShell(startTime, endTime);
        verifyLocusIdEventVisibility(restrictedEvents, false);
        verifyLocusIdEventVisibility(allEvents, true);
    }

    private void startAndDestroyActivityWithLocus() {
        launchTestActivity(TEST_APP_PKG, TEST_APP_CLASS_LOCUS);
        SystemClock.sleep(500);

        // Destroy the activity
        SystemUtil.runWithShellPermissionIdentity(() -> mAm.forceStopPackage(TEST_APP_PKG));
        mUiDevice.wait(Until.gone(By.clazz(TEST_APP_PKG, TEST_APP_CLASS_LOCUS)), TIMEOUT);
        SystemClock.sleep(500);
    }

    private void verifyLocusIdEventVisibility(UsageEvents events, boolean hasPermission) {
        int locuses = 0;
        while (events.hasNextEvent()) {
            final Event event = new UsageEvents.Event();
            assertTrue(events.getNextEvent(event));

            if (TEST_APP_PKG.equals(event.getPackageName())
                    && event.mEventType == Event.LOCUS_ID_SET) {
                locuses++;
            }
        }

        if (hasPermission) {
            assertEquals(""LOCUS_ID_SET events were not visible."", 2, locuses);
        } else {
            assertEquals(""LOCUS_ID_SET events were visible."", 0, locuses);
        }
    }

    /**
     * Assert on an app or token's usage state.
     *
     * @param entity name of the app or token
     * @param expected expected usage state, true for in use, false for not in use
     */
    private void assertAppOrTokenUsed(String entity, boolean expected, long timeout)
            throws IOException {
        final long realtimeTimeout = SystemClock.elapsedRealtime() + timeout;
        String activeUsages;
        boolean found;
        do {
            activeUsages = executeShellCmd(""dumpsys usagestats apptimelimit actives"");
            final String[] actives = activeUsages.split(""\n"");
            found = Arrays.asList(actives).contains(entity);
        } while (found != expected && SystemClock.elapsedRealtime() <= realtimeTimeout);

        if (expected) {
            assertTrue(entity + "" not found in list of active activities and tokens\n""
                    + activeUsages, found);
        } else {
            assertFalse(entity + "" found in list of active activities and tokens\n""
                    + activeUsages, found);
        }
    }

    private void dismissKeyguard() throws Exception {
        if (mKeyguardManager.isKeyguardLocked()) {
            final long startTime = getEvents(KEYGUARD_EVENTS, 0, null, null) + 1;
            executeShellCmd(""wm dismiss-keyguard"");
            final ArrayList<Event> events = waitForEventCount(KEYGUARD_EVENTS, startTime, 1);
            assertEquals(Event.KEYGUARD_HIDDEN, events.get(0).getEventType());
            SystemClock.sleep(500);
        }
    }

    private void setStandByBucket(String packageName, String bucket) throws IOException {
        executeShellCmd(""am set-standby-bucket "" + packageName + "" "" + bucket);
    }

    private String executeShellCmd(String command) throws IOException {
        return mUiDevice.executeShellCommand(command);
    }

    private UsageEvents queryEventsAsShell(long start, long end) {
        return SystemUtil.runWithShellPermissionIdentity(() ->
                mUsageStatsManager.queryEvents(start, end));
    }

    private ITestReceiver bindToTestService() throws Exception {
        final TestServiceConnection connection = new TestServiceConnection();
        final Intent intent = new Intent().setComponent(
                new ComponentName(TEST_APP_PKG, TEST_APP_CLASS_SERVICE));
        mContext.bindService(intent, connection, Context.BIND_AUTO_CREATE);
        return ITestReceiver.Stub.asInterface(connection.getService());
    }

    private class TestServiceConnection implements ServiceConnection {
        private BlockingQueue<IBinder> mBlockingQueue = new LinkedBlockingQueue<>();

        public void onServiceConnected(ComponentName componentName, IBinder service) {
            mBlockingQueue.offer(service);
        }

        public void onServiceDisconnected(ComponentName componentName) {
        }

        public IBinder getService() throws Exception {
            final IBinder service = mBlockingQueue.poll(TIMEOUT_BINDER_SERVICE_SEC,
                    TimeUnit.SECONDS);
            return service;
        }
    }

    private void runJobImmediately() throws Exception {
        TestJob.schedule(mContext);
        executeShellCmd(JOBSCHEDULER_RUN_SHELL_COMMAND
                + "" "" + mContext.getPackageName()
                + "" "" + TestJob.TEST_JOB_ID);
    }

    private boolean isAppInactiveAsPermissionlessApp(String pkg) throws Exception {
        final ITestReceiver testService = bindToTestService();
        return testService.isAppInactive(pkg);
    }

    private int createUser(String name) throws Exception {
        final String output = executeShellCmd(
                ""pm create-user "" + name);
        if (output.startsWith(""Success"")) {
            return mOtherUser = Integer.parseInt(output.substring(output.lastIndexOf("" "")).trim());
        }
        throw new IllegalStateException(String.format(""Failed to create user: %s"", output));
    }

    private boolean removeUser(final int userId) throws Exception {
        final String output = executeShellCmd(String.format(""pm remove-user %s"", userId));
        if (output.startsWith(""Error"")) {
            return false;
        }
        return true;
    }

    private boolean startUser(int userId, boolean waitFlag) throws Exception {
        String cmd = ""am start-user "" + (waitFlag ? ""-w "" : """") + userId;

        final String output = executeShellCmd(cmd);
        if (output.startsWith(""Error"")) {
            return false;
        }
        if (waitFlag) {
            String state = executeShellCmd(""am get-started-user-state "" + userId);
            if (!state.contains(""RUNNING_UNLOCKED"")) {
                return false;
            }
        }
        return true;
    }

    private boolean stopUser(int userId, boolean waitFlag, boolean forceFlag)
            throws Exception {
        StringBuilder cmd = new StringBuilder(""am stop-user "");
        if (waitFlag) {
            cmd.append(""-w "");
        }
        if (forceFlag) {
            cmd.append(""-f "");
        }
        cmd.append(userId);

        final String output = executeShellCmd(cmd.toString());
        if (output.contains(""Error: Can't stop system user"")) {
            return false;
        }
        return true;
    }

    private void installExistingPackageAsUser(String packageName, int userId)
            throws Exception {
        executeShellCmd(
                String.format(""pm install-existing --user %d --wait %s"", userId, packageName));
    }

    private void sleepDevice() throws Exception {
        if (mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WATCH)) {
            mUiDevice.pressKeyCode(KeyEvent.KEYCODE_SLEEP);
        } else {
            mUiDevice.sleep();
        }

        waitUntil(() -> {
            try {
                return mUiDevice.isScreenOn();
            } catch(Exception e) {
                return true;
            }
        }, false);
    }
}"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest"	"isStaConcurrencyForRestrictedConnectionsSupported"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest.java"	""	"/*
 *.
 */

package android.net.wifi.cts;

import static android.net.NetworkCapabilities.NET_CAPABILITY_OEM_PAID;
import static android.net.NetworkCapabilities.NET_CAPABILITY_OEM_PRIVATE;
import static android.os.Process.myUid;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import static org.junit.Assume.assumeTrue;

import android.content.Context;
import android.content.pm.PackageManager;
import android.location.LocationManager;
import android.net.ConnectivityManager;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiManager;
import android.net.wifi.WifiNetworkSuggestion;
import android.os.Build;
import android.platform.test.annotations.AppModeFull;
import android.support.test.uiautomator.UiDevice;

import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.filters.LargeTest;
import androidx.test.filters.SdkSuppress;
import androidx.test.platform.app.InstrumentationRegistry;

import com.android.compatibility.common.util.PollingCheck;
import com.android.compatibility.common.util.ShellIdentityUtils;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.List;
import java.util.Set;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;

/**
 * Tests multiple concurrent connection flow on devices that support multi STA concurrency
 * (indicated via {@link WifiManager#isStaConcurrencyForRestrictedConnectionsSupported()}.
 *
 * Tests the entire connection flow using {@link WifiNetworkSuggestion} which has
 * {@link WifiNetworkSuggestion.Builder#setOemPaid(boolean)} or
 * {@link WifiNetworkSuggestion.Builder#setOemPrivate(boolean)} set along with a concurrent internet
 * connection using {@link WifiManager#connect(int, WifiManager.ActionListener)}.
 *
 * Assumes that all the saved networks is either open/WPA1/WPA2/WPA3 authenticated network.
 */
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)
@AppModeFull(reason = ""Cannot get WifiManager in instant app mode"")
@LargeTest
@RunWith(AndroidJUnit4.class)
public class MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest extends WifiJUnit4TestBase {
    private static final String TAG = ""MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest"";
    private static boolean sWasVerboseLoggingEnabled;
    private static boolean sWasScanThrottleEnabled;
    private static boolean sWasWifiEnabled;

    private Context mContext;
    private WifiManager mWifiManager;
    private ConnectivityManager mConnectivityManager;
    private UiDevice mUiDevice;
    private WifiConfiguration mTestNetworkForRestrictedConnection;
    private WifiConfiguration mTestNetworkForInternetConnection;
    private ConnectivityManager.NetworkCallback mNetworkCallback;
    private ConnectivityManager.NetworkCallback mNsNetworkCallback;
    private ScheduledExecutorService mExecutorService;
    private TestHelper mTestHelper;

    private static final int DURATION_MILLIS = 10_000;

    @BeforeClass
    public static void setUpClass() throws Exception {
        Context context = InstrumentationRegistry.getInstrumentation().getContext();
        // skip the test if WiFi is not supported or not automotive platform.
        // Don't use assumeTrue in @BeforeClass
        if (!WifiFeature.isWifiSupported(context)) return;

        WifiManager wifiManager = context.getSystemService(WifiManager.class);
        assertThat(wifiManager).isNotNull();

        // turn on verbose logging for tests
        sWasVerboseLoggingEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.isVerboseLoggingEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setVerboseLoggingEnabled(true));
        // Disable scan throttling for tests.
        sWasScanThrottleEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.isScanThrottleEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setScanThrottleEnabled(false));

        // enable Wifi
        sWasWifiEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.isWifiEnabled());
        if (!wifiManager.isWifiEnabled()) {
            ShellIdentityUtils.invokeWithShellPermissions(() -> wifiManager.setWifiEnabled(true));
        }
        PollingCheck.check(""Wifi not enabled"", DURATION_MILLIS, () -> wifiManager.isWifiEnabled());
    }

    @AfterClass
    public static void tearDownClass() throws Exception {
        Context context = InstrumentationRegistry.getInstrumentation().getContext();
        if (!WifiFeature.isWifiSupported(context)) return;

        WifiManager wifiManager = context.getSystemService(WifiManager.class);
        assertThat(wifiManager).isNotNull();

        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setScanThrottleEnabled(sWasScanThrottleEnabled));
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setVerboseLoggingEnabled(sWasVerboseLoggingEnabled));
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setWifiEnabled(sWasWifiEnabled));
    }

    @Before
    public void setUp() throws Exception {
        mContext = InstrumentationRegistry.getInstrumentation().getContext();
        mWifiManager = mContext.getSystemService(WifiManager.class);
        mConnectivityManager = mContext.getSystemService(ConnectivityManager.class);
        mUiDevice = UiDevice.getInstance(InstrumentationRegistry.getInstrumentation());
        mExecutorService = Executors.newSingleThreadScheduledExecutor();
        mTestHelper = new TestHelper(mContext, mUiDevice);

        // skip the test if WiFi is not supported or not automitve platform.
        assumeTrue(WifiFeature.isWifiSupported(mContext));
        // skip the test if location is not supported
        assumeTrue(mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_LOCATION));
        // skip if multi STA not supported.
        assumeTrue(mWifiManager.isStaConcurrencyForRestrictedConnectionsSupported());

        assertWithMessage(""Please enable location for this test!"").that(
                mContext.getSystemService(LocationManager.class).isLocationEnabled()).isTrue();

        // turn screen on
        mTestHelper.turnScreenOn();

        // Clear any existing app state before each test.
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.removeAppState(myUid(), mContext.getPackageName()));

        // We need 2 AP's for the test. If there are 2 networks saved on the device and in range,
        // use those. Otherwise, check if there are 2 BSSID's in range for the only saved network.
        // This assumes a CTS test environment with at least 2 connectable bssid's (Is that ok?).
        List<WifiConfiguration> savedNetworks = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.getPrivilegedConfiguredNetworks());
        List<WifiConfiguration> matchingNetworksWithBssid =
                TestHelper.findMatchingSavedNetworksWithBssid(mWifiManager, savedNetworks);
        assertWithMessage(""Need at least 2 saved network bssids in range"").that(
                matchingNetworksWithBssid.size()).isAtLeast(2);
        // Pick any 2 bssid for test.
        mTestNetworkForRestrictedConnection = matchingNetworksWithBssid.get(0);
        // Try to find a bssid for another saved network in range. If none exists, fallback
        // to using 2 bssid's for the same network.
        mTestNetworkForInternetConnection = matchingNetworksWithBssid.stream()
                .filter(w -> !w.SSID.equals(mTestNetworkForRestrictedConnection.SSID))
                .findAny()
                .orElse(matchingNetworksWithBssid.get(1));

        // Disconnect & disable auto-join on the saved network to prevent auto-connect from
        // interfering with the test.
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> {
                    for (WifiConfiguration savedNetwork : savedNetworks) {
                        mWifiManager.disableNetwork(savedNetwork.networkId);
                    }
                    mWifiManager.disconnect();
                });

        // Wait for Wifi to be disconnected.
        PollingCheck.check(
                ""Wifi not disconnected"",
                20_000,
                () -> mWifiManager.getConnectionInfo().getNetworkId() == -1);
    }

    @After
    public void tearDown() throws Exception {
        // Re-enable networks.
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> {
                    for (WifiConfiguration savedNetwork : mWifiManager.getConfiguredNetworks()) {
                        mWifiManager.enableNetwork(savedNetwork.networkId, false);
                    }
                });
        // Release the requests after the test.
        if (mNetworkCallback != null) {
            mConnectivityManager.unregisterNetworkCallback(mNetworkCallback);
        }
        if (mNsNetworkCallback != null) {
            mConnectivityManager.unregisterNetworkCallback(mNsNetworkCallback);
        }
        mExecutorService.shutdownNow();
        // Clear any existing app state after each test.
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.removeAppState(myUid(), mContext.getPackageName()));
        mTestHelper.turnScreenOff();
    }

    /**
     * Tests the concurrent connection flow.
     * 1. Connect to a network using internet connectivity API.
     * 2. Connect to a network using restricted suggestion API.
     * 3. Verify that both connections are active.
     */"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest"	"testConnectToOemPaidSuggestionWhenConnectedToInternetNetwork"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest.java"	""	"public void testConnectToOemPaidSuggestionWhenConnectedToInternetNetwork() throws Exception {
        // First trigger internet connectivity.
        mNetworkCallback = mTestHelper.testConnectionFlowWithConnect(
                mTestNetworkForInternetConnection);

        // Now trigger restricted connection.
        WifiNetworkSuggestion suggestion =
                TestHelper.createSuggestionBuilderWithCredentialFromSavedNetworkWithBssid(
                        mTestNetworkForRestrictedConnection)
                        .setOemPaid(true)
                        .build();
        mNsNetworkCallback = mTestHelper.testConnectionFlowWithSuggestion(
                mTestNetworkForRestrictedConnection, suggestion, mExecutorService,
                Set.of(NET_CAPABILITY_OEM_PAID));

        // Ensure that there are 2 wifi connections available for apps.
        assertThat(mTestHelper.getNumWifiConnections()).isEqualTo(2);
    }

    /**
     * Tests the concurrent connection flow.
     * 1. Connect to a network using restricted suggestion API.
     * 2. Connect to a network using internet connectivity API.
     * 3. Verify that both connections are active.
     */"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest"	"testConnectToInternetNetworkWhenConnectedToOemPaidSuggestion"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest.java"	""	"public void testConnectToInternetNetworkWhenConnectedToOemPaidSuggestion() throws Exception {
        // First trigger restricted connection.
        WifiNetworkSuggestion suggestion =
                TestHelper.createSuggestionBuilderWithCredentialFromSavedNetworkWithBssid(
                        mTestNetworkForRestrictedConnection)
                        .setOemPaid(true)
                        .build();
        mNsNetworkCallback = mTestHelper.testConnectionFlowWithSuggestion(
                mTestNetworkForRestrictedConnection, suggestion, mExecutorService,
                Set.of(NET_CAPABILITY_OEM_PAID));

        // Now trigger internet connectivity.
        mNetworkCallback = mTestHelper.testConnectionFlowWithConnect(
                mTestNetworkForInternetConnection);

        // Ensure that there are 2 wifi connections available for apps.
        assertThat(mTestHelper.getNumWifiConnections()).isEqualTo(2);
    }

    /**
     * Tests the concurrent connection flow.
     * 1. Connect to a network using internet connectivity API.
     * 2. Connect to a network using restricted suggestion API.
     * 3. Verify that both connections are active.
     */"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest"	"testConnectToOemPrivateSuggestionWhenConnectedToInternetNetwork"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest.java"	""	"public void testConnectToOemPrivateSuggestionWhenConnectedToInternetNetwork() throws Exception {
        // First trigger internet connectivity.
        mNetworkCallback = mTestHelper.testConnectionFlowWithConnect(
                mTestNetworkForInternetConnection);

        // Now trigger restricted connection.
        WifiNetworkSuggestion suggestion =
                TestHelper.createSuggestionBuilderWithCredentialFromSavedNetworkWithBssid(
                        mTestNetworkForRestrictedConnection)
                        .setOemPrivate(true)
                        .build();
        mNsNetworkCallback = mTestHelper.testConnectionFlowWithSuggestion(
                mTestNetworkForRestrictedConnection, suggestion, mExecutorService,
                Set.of(NET_CAPABILITY_OEM_PRIVATE));

        // Ensure that there are 2 wifi connections available for apps.
        assertThat(mTestHelper.getNumWifiConnections()).isEqualTo(2);
    }

    /**
     * Tests the concurrent connection flow.
     * 1. Connect to a network using restricted suggestion API.
     * 2. Connect to a network using internet connectivity API.
     * 3. Verify that both connections are active.
     */"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest"	"testConnectToInternetNetworkWhenConnectedToOemPrivateSuggestion"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest.java"	""	"public void testConnectToInternetNetworkWhenConnectedToOemPrivateSuggestion() throws Exception {
        // First trigger restricted connection.
        WifiNetworkSuggestion suggestion =
                TestHelper.createSuggestionBuilderWithCredentialFromSavedNetworkWithBssid(
                        mTestNetworkForRestrictedConnection)
                        .setOemPrivate(true)
                        .build();
        mNsNetworkCallback = mTestHelper.testConnectionFlowWithSuggestion(
                mTestNetworkForRestrictedConnection, suggestion, mExecutorService,
                Set.of(NET_CAPABILITY_OEM_PRIVATE));

        // Now trigger internet connectivity.
        mNetworkCallback = mTestHelper.testConnectionFlowWithConnect(
                mTestNetworkForInternetConnection);

        // Ensure that there are 2 wifi connections available for apps.
        assertThat(mTestHelper.getNumWifiConnections()).isEqualTo(2);
    }

    /**
     * Tests the concurrent connection flow.
     * 1. Connect to a network using internet connectivity API.
     * 2. Simulate connection failure to a network using restricted suggestion API & different net
     *    capability (need corresponding net capability requested for platform to connect).
     * 3. Verify that only 1 connection is active.
     */"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest"	"testConnectToOemPaidSuggestionFailureWhenConnectedToInternetNetwork"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest.java"	""	"public void testConnectToOemPaidSuggestionFailureWhenConnectedToInternetNetwork()
            throws Exception {
        // First trigger internet connectivity.
        mNetworkCallback = mTestHelper.testConnectionFlowWithConnect(
                mTestNetworkForInternetConnection);

        // Now trigger restricted connection.
        WifiNetworkSuggestion suggestion =
                TestHelper.createSuggestionBuilderWithCredentialFromSavedNetworkWithBssid(
                        mTestNetworkForRestrictedConnection)
                        .setOemPaid(true)
                        .build();
        mNsNetworkCallback = mTestHelper.testConnectionFailureFlowWithSuggestion(
                mTestNetworkForRestrictedConnection, suggestion, mExecutorService,
                Set.of(NET_CAPABILITY_OEM_PRIVATE));

        // Ensure that there is only 1 connection available for apps.
        assertThat(mTestHelper.getNumWifiConnections()).isEqualTo(1);
    }

    /**
     * Tests the concurrent connection flow.
     * 1. Connect to a network using internet connectivity API.
     * 2. Simulate connection failure to a network using restricted suggestion API & different net
     *    capability (need corresponding net capability requested for platform to connect).
     * 3. Verify that only 1 connection is active.
     */"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest"	"testConnectToOemPrivateSuggestionFailureWhenConnectedToInternetNetwork"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest.java"	""	"public void testConnectToOemPrivateSuggestionFailureWhenConnectedToInternetNetwork()
            throws Exception {
        // First trigger internet connectivity.
        mNetworkCallback = mTestHelper.testConnectionFlowWithConnect(
                mTestNetworkForInternetConnection);

        // Now trigger restricted connection.
        WifiNetworkSuggestion suggestion =
                TestHelper.createSuggestionBuilderWithCredentialFromSavedNetworkWithBssid(
                        mTestNetworkForRestrictedConnection)
                        .setOemPrivate(true)
                        .build();
        mNsNetworkCallback = mTestHelper.testConnectionFailureFlowWithSuggestion(
                mTestNetworkForRestrictedConnection, suggestion, mExecutorService,
                Set.of(NET_CAPABILITY_OEM_PAID));

        // Ensure that there is only 1 connection available for apps.
        assertThat(mTestHelper.getNumWifiConnections()).isEqualTo(1);
    }

    /**
     * Tests the concurrent connection flow.
     * 1. Connect to a network using internet connectivity API.
     * 2. Simulate connection failure to a restricted network using suggestion API & restricted net
     *    capability (need corresponding restricted bit set in suggestion for platform to connect).
     * 3. Verify that only 1 connection is active.
     */"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest"	"testConnectToSuggestionFailureWithOemPaidNetCapabilityWhenConnectedToInternetNetwork"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest.java"	""	"public void
            testConnectToSuggestionFailureWithOemPaidNetCapabilityWhenConnectedToInternetNetwork()
            throws Exception {
        // First trigger internet connectivity.
        mNetworkCallback = mTestHelper.testConnectionFlowWithConnect(
                mTestNetworkForInternetConnection);

        // Now trigger restricted connection.
        WifiNetworkSuggestion suggestion =
                TestHelper.createSuggestionBuilderWithCredentialFromSavedNetworkWithBssid(
                        mTestNetworkForRestrictedConnection)
                        .build();
        mNsNetworkCallback = mTestHelper.testConnectionFailureFlowWithSuggestion(
                mTestNetworkForRestrictedConnection, suggestion, mExecutorService,
                Set.of(NET_CAPABILITY_OEM_PAID));

        // Ensure that there is only 1 connection available for apps.
        assertThat(mTestHelper.getNumWifiConnections()).isEqualTo(1);
    }

    /**
     * Tests the concurrent connection flow.
     * 1. Connect to a network using internet connectivity API.
     * 2. Simulate connection failure to a restricted network using suggestion API & restricted net
     *    capability (need corresponding restricted bit set in suggestion for platform to connect).
     * 3. Verify that only 1 connection is active.
     */"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest"	"testConnectToSuggestionFailureWithOemPrivateNetCapabilityWhenConnectedToInternetNetwork"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest.java"	""	"public void
        testConnectToSuggestionFailureWithOemPrivateNetCapabilityWhenConnectedToInternetNetwork()
            throws Exception {
        // First trigger internet connectivity.
        mNetworkCallback = mTestHelper.testConnectionFlowWithConnect(
                mTestNetworkForInternetConnection);

        // Now trigger restricted connection.
        WifiNetworkSuggestion suggestion =
                TestHelper.createSuggestionBuilderWithCredentialFromSavedNetworkWithBssid(
                        mTestNetworkForRestrictedConnection)
                        .build();
        mNsNetworkCallback = mTestHelper.testConnectionFailureFlowWithSuggestion(
                mTestNetworkForRestrictedConnection, suggestion, mExecutorService,
                Set.of(NET_CAPABILITY_OEM_PRIVATE));

        // Ensure that there is only 1 connection available for apps.
        assertThat(mTestHelper.getNumWifiConnections()).isEqualTo(1);
    }
}"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.app.cts.ActivityManagerProcessStateTest"	"testBgRestrictedForegroundService"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerProcessStateTest.java"	""	"public void testBgRestrictedForegroundService() throws Exception {
        final Intent activityIntent = new Intent()
                .setClassName(SIMPLE_PACKAGE_NAME,
                        SIMPLE_PACKAGE_NAME + SIMPLE_ACTIVITY_START_FG_SERVICE)
                .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);

        PermissionUtils.grantPermission(
                STUB_PACKAGE_NAME, android.Manifest.permission.PACKAGE_USAGE_STATS);
        final ServiceProcessController controller = new ServiceProcessController(mContext,
                mInstrumentation, STUB_PACKAGE_NAME, mAllProcesses, WAIT_TIME);
        final WatchUidRunner uidWatcher = controller.getUidWatcher();

        final Intent homeIntent = new Intent()
                .setAction(Intent.ACTION_MAIN)
                .addCategory(Intent.CATEGORY_HOME)
                .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK
                        | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);

        final Intent serviceStartIntent = new Intent(mService3Intent)
                .setAction(ACTION_START_THEN_FG);
        activityIntent.putExtra(""service"", serviceStartIntent);
        boolean activityStarted = false;

        try {
            // First kill the process to start out in a stable state.
            controller.ensureProcessGone();

            // Do initial setup.
            controller.denyAnyInBackgroundOp();
            controller.makeUidIdle();
            controller.removeFromWhitelist();
            controller.setAppOpMode(AppOpsManager.OPSTR_START_FOREGROUND, ""allow"");

            // Start the activity, which will start the fg service as well, and wait
            // for the report that it's all up and running.
            WaitForBroadcast waiter = new WaitForBroadcast(mInstrumentation.getTargetContext());
            waiter.prepare(ACTION_SIMPLE_ACTIVITY_START_FG_SERVICE_RESULT);

            activityIntent.setAction(ACTION_SIMPLE_ACTIVITY_START_FG);
            mTargetContext.startActivity(activityIntent);
            activityStarted = true;

            Intent resultIntent = waiter.doWait(WAIT_TIME);
            int brCode = resultIntent.getIntExtra(""result"", Activity.RESULT_CANCELED);
            if (brCode != Activity.RESULT_FIRST_USER) {
                fail(""Failed starting service, result="" + brCode);
            }

            // activity is in front, fg service is running.  make sure that we see
            // the expected state at this point.
            uidWatcher.waitFor(WatchUidRunner.CMD_ACTIVE, null);
            uidWatcher.waitFor(WatchUidRunner.CMD_UNCACHED, null);
            uidWatcher.expect(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_TOP);

            // Switch to the home app; make sure the test app drops all the way
            // down to SERVICE, not FG_SERVICE
            mTargetContext.startActivity(homeIntent);
            uidWatcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_SERVICE);
        } finally {
            // tear down everything and we're done
            if (activityStarted) {
                activityIntent.setAction(ACTION_FINISH_EVERYTHING);
                mTargetContext.startActivity(activityIntent);
            }

            controller.cleanup();
        }

    }

    private boolean supportsCantSaveState() {
        if (mContext.getPackageManager().hasSystemFeature(
                PackageManager.FEATURE_CANT_SAVE_STATE)) {
            return true;
        }

        return false;
    }

    /**
     * Test that a single ""can't save state"" app has the proper process management semantics.
     */"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.app.cts.ActivityManagerProcessStateTest"	"testForegroundServiceAppOp"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerProcessStateTest.java"	""	"public void testForegroundServiceAppOp() throws Exception {
        PermissionUtils.grantPermission(
                STUB_PACKAGE_NAME, android.Manifest.permission.PACKAGE_USAGE_STATS);
        // Use default timeout value 5000
        final ServiceProcessController controller = new ServiceProcessController(mContext,
                mInstrumentation, STUB_PACKAGE_NAME, mAllProcesses);
        // Use default timeout value 5000
        final ServiceConnectionHandler conn = new ServiceConnectionHandler(mContext,
                mServiceIntent);
        final WatchUidRunner uidWatcher = controller.getUidWatcher();

        try {
            // First kill the process to start out in a stable state.
            controller.ensureProcessGone();

            // Do initial setup.
            controller.makeUidIdle();
            controller.removeFromWhitelist();
            controller.setAppOpMode(AppOpsManager.OPSTR_START_FOREGROUND, ""allow"");

            // Put app on whitelist, to allow service to run.
            controller.addToWhitelist();

            // We will use this to monitor when the service is running.
            conn.startMonitoring();

            // -------- START SERVICE AND THEN SUCCESSFULLY GO TO FOREGROUND

            // Now start the service and wait for it to come up.
            mContext.startService(mServiceStartForegroundIntent);
            conn.waitForConnect();

            // Also make sure the uid state reports are as expected.
            uidWatcher.waitFor(WatchUidRunner.CMD_UNCACHED, null);
            uidWatcher.expect(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_SERVICE);
            uidWatcher.waitFor(WatchUidRunner.CMD_ACTIVE, null);
            uidWatcher.expect(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_FG_SERVICE);

            // Now take it out of foreground and confirm.
            mContext.startService(mServiceStopForegroundIntent);
            uidWatcher.expect(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_SERVICE);

            // Good, now stop the service and wait for it to go away.
            mContext.stopService(mServiceStartForegroundIntent);
            conn.waitForDisconnect();

            // There may be a transient STATE_SERVICE we don't care about, so waitFor.
            uidWatcher.waitFor(WatchUidRunner.CMD_CACHED, null);
            uidWatcher.expect(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_CACHED_EMPTY);

            // We don't want to wait for the uid to actually go idle, we can force it now.
            controller.makeUidIdle();
            uidWatcher.expect(WatchUidRunner.CMD_IDLE, null);

            // Make sure the process is gone so we start over fresh.
            controller.ensureProcessGone();

            // -------- START SERVICE AND BLOCK GOING TO FOREGROUND

            // Now we will deny the app op and ensure the service can't become foreground.
            controller.setAppOpMode(AppOpsManager.OPSTR_START_FOREGROUND, ""ignore"");

            // Now start the service and wait for it to come up.
            mContext.startService(mServiceStartForegroundIntent);
            conn.waitForConnect();

            // Also make sure the uid state reports are as expected.
            uidWatcher.waitFor(WatchUidRunner.CMD_UNCACHED, null);
            uidWatcher.expect(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_SERVICE);

            // Good, now stop the service and wait for it to go away.
            mContext.stopService(mServiceStartForegroundIntent);
            conn.waitForDisconnect();

            // THIS MUST BE AN EXPECT: we want to make sure we don't get in to STATE_FG_SERVICE.
            uidWatcher.expect(WatchUidRunner.CMD_CACHED, null);
            uidWatcher.expect(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_CACHED_EMPTY);

            // Make sure the uid is idle (it should be anyway, it never went active here).
            controller.makeUidIdle();

            // Make sure the process is gone so we start over fresh.
            controller.ensureProcessGone();

            // -------- DIRECT START FOREGROUND SERVICE SUCCESSFULLY

            controller.setAppOpMode(AppOpsManager.OPSTR_START_FOREGROUND, ""allow"");

            // Now start the service and wait for it to come up.
            mContext.startForegroundService(mServiceStartForegroundIntent);
            conn.waitForConnect();

            // Make sure it becomes a foreground service.  The process state changes here
            // are weird looking because we first need to force the app out of idle to allow
            // it to start the service.
            uidWatcher.waitFor(WatchUidRunner.CMD_ACTIVE, null);
            uidWatcher.waitFor(WatchUidRunner.CMD_UNCACHED, null);
            uidWatcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_FG_SERVICE);
            // Remove tempwhitelist avoid temp white list block idle command and app crash occur.
            CtsAppTestUtils.executeShellCmd(mInstrumentation,
                    ""cmd deviceidle tempwhitelist -r "" + SIMPLE_PACKAGE_NAME);
            // Good, now stop the service and wait for it to go away.
            mContext.stopService(mServiceStartForegroundIntent);
            conn.waitForDisconnect();

            // There may be a transient STATE_SERVICE we don't care about, so waitFor.
            uidWatcher.waitFor(WatchUidRunner.CMD_CACHED, null);
            uidWatcher.expect(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_CACHED_EMPTY);

            // We don't want to wait for the uid to actually go idle, we can force it now.
            controller.makeUidIdle();

            // Make sure the process is gone so we start over fresh.
            controller.ensureProcessGone();

            // -------- DIRECT START FOREGROUND SERVICE BLOCKED

            // Now we will deny the app op and ensure the service can't become foreground.
            controller.setAppOpMode(AppOpsManager.OPSTR_START_FOREGROUND, ""ignore"");

            // But we will put it on the whitelist so the service is still allowed to start.
            controller.addToWhitelist();

            // Now start the service and wait for it to come up.
            mContext.startForegroundService(mServiceStartForegroundIntent);
            conn.waitForConnect();

            // In this case we only get to run it as a regular service.
            uidWatcher.waitFor(WatchUidRunner.CMD_UNCACHED, null);
            uidWatcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_SERVICE);

            // Good, now stop the service and wait for it to go away.
            mContext.stopService(mServiceStartForegroundIntent);
            conn.waitForDisconnect();

            // THIS MUST BE AN EXPECT: we want to make sure we don't get in to STATE_FG_SERVICE.
            uidWatcher.expect(WatchUidRunner.CMD_CACHED, null);
            uidWatcher.expect(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_CACHED_EMPTY);

            // Make sure the uid is idle (it should be anyway, it never went active here).
            controller.makeUidIdle();

            // Make sure the process is gone so we start over fresh.
            controller.ensureProcessGone();

            // -------- XXX NEED TO TEST NON-WHITELIST CASE WHERE NOTHING HAPPENS

        } finally {
            mContext.stopService(mServiceStartForegroundIntent);
            conn.stopMonitoringIfNeeded();
            controller.cleanup();
            controller.setAppOpMode(AppOpsManager.OPSTR_START_FOREGROUND, ""allow"");
            controller.removeFromWhitelist();
        }
    }

    /**
     * Verify that an app under background restrictions has its foreground services demoted to
     * ordinary service state when it is no longer the top app.
     */"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.userrestrictions.CheckNoOwnerRestrictionsTest"	"testNoOwnerRestrictions"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/userrestrictions/CheckNoOwnerRestrictionsTest.java"	""	"public void testNoOwnerRestrictions() {
        assertFalse(""DISALLOW_UNMUTE_MICROPHONE is still set"",
                mContext.getSystemService(UserManager.class).hasUserRestriction(
                UserManager.DISALLOW_UNMUTE_MICROPHONE));
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"test.java.com.android.queryable.queries.SerializableQueryHelperTest"	"isTrue"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/queryable/src/test/java/com/android/queryable/queries/SerializableQueryHelperTest.java"	""	"public void matches_noRestrictions_returnsTrue() {
        SerializableQueryHelper<Queryable> serializableQueryHelper =
                new SerializableQueryHelper<>(mQuery);

        assertThat(serializableQueryHelper.matches(mSerializable)).isTrue();
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"test.java.com.android.queryable.queries.SerializableQueryHelperTest"	"matches_isEqualTo_meetsRestriction_returnsTrue"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/queryable/src/test/java/com/android/queryable/queries/SerializableQueryHelperTest.java"	""	"public void matches_isEqualTo_meetsRestriction_returnsTrue() {
        SerializableQueryHelper<Queryable> serializableQueryHelper =
                new SerializableQueryHelper<>(mQuery);

        serializableQueryHelper.isEqualTo(mSerializable);

        assertThat(serializableQueryHelper.matches(mSerializable)).isTrue();
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"test.java.com.android.queryable.queries.SerializableQueryHelperTest"	"matches_isEqualTo_doesNotMeetRestriction_returnsFalse"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/queryable/src/test/java/com/android/queryable/queries/SerializableQueryHelperTest.java"	""	"public void matches_isEqualTo_doesNotMeetRestriction_returnsFalse() {
        SerializableQueryHelper<Queryable> serializableQueryHelper =
                new SerializableQueryHelper<>(mQuery);

        serializableQueryHelper.isEqualTo(mDifferentSerializable);

        assertThat(serializableQueryHelper.matches(mSerializable)).isFalse();
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.print.cts.PrintDocumentInfoTest"	"createFirstMockDiscoverySessionCallbacks"	"CtsPrintTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/print/src/android/print/cts/PrintDocumentInfoTest.java"	""	"/*
 *.
 */

package android.print.cts;

import static android.print.test.Utils.eventually;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

import android.os.ParcelFileDescriptor;
import android.print.PageRange;
import android.print.PrintAttributes;
import android.print.PrintAttributes.Margins;
import android.print.PrintAttributes.MediaSize;
import android.print.PrintAttributes.Resolution;
import android.print.PrintDocumentAdapter;
import android.print.PrintDocumentAdapter.LayoutResultCallback;
import android.print.PrintDocumentAdapter.WriteResultCallback;
import android.print.PrintDocumentInfo;
import android.print.PrinterCapabilitiesInfo;
import android.print.PrinterId;
import android.print.PrinterInfo;
import android.print.test.BasePrintTest;
import android.print.test.services.FirstPrintService;
import android.print.test.services.PrintServiceCallbacks;
import android.print.test.services.PrinterDiscoverySessionCallbacks;
import android.print.test.services.SecondPrintService;
import android.print.test.services.StubbablePrinterDiscoverySession;
import android.printservice.PrintJob;
import android.printservice.PrintService;

import androidx.test.runner.AndroidJUnit4;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.io.FileInputStream;
import java.util.ArrayList;
import java.util.List;

/**
 * This test verifies that the system respects the {@link PrintDocumentAdapter}
 * contract and invokes all callbacks as expected.
 */
@RunWith(AndroidJUnit4.class)
public class PrintDocumentInfoTest extends BasePrintTest {
    private static boolean sIsDefaultPrinterSet;

    @Before
    public void setDefaultPrinter() throws Throwable {
        if (!sIsDefaultPrinterSet) {
            // Create a callback for the target print service.
            FirstPrintService.setCallbacks(createFirstMockPrintServiceCallbacks());
            SecondPrintService.setCallbacks(createSecondMockPrintServiceCallbacks());

            // Create a mock print adapter.
            final PrintDocumentAdapter adapter = createDefaultPrintDocumentAdapter(1);

            makeDefaultPrinter(adapter, ""First printer"");
            resetCounters();

            sIsDefaultPrinterSet = true;
        }
    }

    /**
     * Executes a print process with a given print document info
     *
     * @param name The name of the document info
     * @param contentType The content type of the document
     * @param pageCount The number of pages in the document
     */
    private void printDocumentBaseTest(String name, Integer contentType, Integer pageCount)
            throws Throwable {
        FirstPrintService.setCallbacks(createFirstMockPrintServiceCallbacks());
        SecondPrintService.setCallbacks(createSecondMockPrintServiceCallbacks());

        PrintDocumentInfo.Builder b = new PrintDocumentInfo.Builder(name);
        if (contentType != null) {
            b.setContentType(contentType);
        }
        if (pageCount != null) {
            b.setPageCount(pageCount);
        }
        PrintDocumentInfo info = b.build();

        PrintDocumentInfo queuedInfo[] = new PrintDocumentInfo[1];
        ParcelFileDescriptor queuedData[] = new ParcelFileDescriptor[1];

        PrinterDiscoverySessionCallbacks printerDiscoverySessionCallbacks =
                createFirstMockDiscoverySessionCallbacks();
        PrintServiceCallbacks printServiceCallbacks = createMockPrintServiceCallbacks(
                invocation -> printerDiscoverySessionCallbacks,
                invocation -> {
                    PrintJob printJob = (PrintJob) invocation.getArguments()[0];
                    synchronized (queuedInfo) {
                        queuedInfo[0] = printJob.getDocument().getInfo();
                        queuedData[0] = printJob.getDocument().getData();
                    }
                    printJob.complete();
                    onPrintJobQueuedCalled();
                    return null;
                }, null);

        FirstPrintService.setCallbacks(printServiceCallbacks);

        final PrintAttributes[] printAttributes = new PrintAttributes[1];

        // Create a mock print adapter.
        final PrintDocumentAdapter adapter = createMockPrintDocumentAdapter(
                invocation -> {
                    printAttributes[0] = (PrintAttributes) invocation.getArguments()[1];
                    LayoutResultCallback callback = (LayoutResultCallback) invocation
                            .getArguments()[3];
                    callback.onLayoutFinished(info, false);
                    return null;
                }, invocation -> {
                    Object[] args = invocation.getArguments();
                    ParcelFileDescriptor fd = (ParcelFileDescriptor) args[1];
                    WriteResultCallback callback = (WriteResultCallback) args[3];
                    writeBlankPages(printAttributes[0], fd, 0, 1);
                    fd.close();
                    if (pageCount != null && pageCount > 0) {
                        callback.onWriteFinished(new PageRange[]{new PageRange(0, pageCount - 1)});
                    } else {
                        callback.onWriteFinished(new PageRange[]{new PageRange(0, 1)});
                    }
                    onWriteCalled();
                    return null;
                }, invocation -> null);

        // Start printing.
        print(adapter);

        // Wait for layout.
        waitForWriteAdapterCallback(1);

        // Click the print button.
        mPrintHelper.submitPrintJob();

        // Wait for the session to be destroyed to isolate tests.
        waitForPrinterDiscoverySessionDestroyCallbackCalled(1);
        waitForServiceOnPrintJobQueuedCallbackCalled(1);

        // Check that the document name was carried over 1:1
        eventually(() -> {
            synchronized (queuedInfo) {
                assertEquals(name, queuedInfo[0].getName());
            }
        });

        // Content type is set to document by default, but is otherwise unrestricted
        if (contentType != null) {
            assertEquals(contentType, Integer.valueOf(queuedInfo[0].getContentType()));
        } else {
            assertEquals(PrintDocumentInfo.CONTENT_TYPE_DOCUMENT, queuedInfo[0].getContentType());
        }

        // Page count is set to the real value if unknown, 0 or unset.
        // Otherwise the set value is used
        if (pageCount != null && pageCount != PrintDocumentInfo.PAGE_COUNT_UNKNOWN
                && pageCount != 0) {
            assertEquals(pageCount, Integer.valueOf(queuedInfo[0].getPageCount()));
        } else {
            assertEquals(2, queuedInfo[0].getPageCount());
        }

        // Verify data (== pdf file) size
        assertTrue(queuedInfo[0].getDataSize() > 0);

        long bytesRead = 0;
        try (FileInputStream is = new FileInputStream(queuedData[0].getFileDescriptor())) {
            while (true) {
                int ret = is.read();
                if (ret == -1) {
                    break;
                }
                bytesRead++;
            }
        }
        assertEquals(queuedInfo[0].getDataSize(), bytesRead);
    }

    /**
     * Test that the default values of the PrintDocumentInfo are fine.
     *
     * @throws Exception If anything unexpected happens
     */"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.alarmmanager.cts.BackgroundRestrictedAlarmsTest"	"testRepeatingAlarmBlocked"	"CtsAlarmManagerTestCases"	"/home/gpoor/cts-12-source/cts/tests/AlarmManager/src/android/alarmmanager/cts/BackgroundRestrictedAlarmsTest.java"	""	"public void testRepeatingAlarmBlocked() throws Exception {
        final long interval = MIN_REPEATING_INTERVAL;
        final long triggerElapsed = SystemClock.elapsedRealtime() + interval;
        scheduleAlarm(AlarmManager.ELAPSED_REALTIME_WAKEUP, triggerElapsed, interval);
        Thread.sleep(DEFAULT_WAIT);
        Thread.sleep(2 * interval);
        assertFalse(""Alarm got triggered even under restrictions"", waitForAlarms(1, DEFAULT_WAIT));
        Thread.sleep(interval);
        setAppOpsMode(APP_OP_MODE_ALLOWED);
        // The alarm is due to go off about 3 times by now. Adding some tolerance just in case
        // an expiration is due right about now.
        final int minCount = getMinExpectedExpirations(SystemClock.elapsedRealtime(),
                triggerElapsed, interval);
        assertTrue(""Alarm should have expired at least "" + minCount
                + "" times when restrictions were lifted"", waitForAlarms(minCount, DEFAULT_WAIT));
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.alarmmanager.cts.BackgroundRestrictedAlarmsTest"	"testAlarmClockNotBlocked"	"CtsAlarmManagerTestCases"	"/home/gpoor/cts-12-source/cts/tests/AlarmManager/src/android/alarmmanager/cts/BackgroundRestrictedAlarmsTest.java"	""	"public void testAlarmClockNotBlocked() throws Exception {
        final long nowRTC = System.currentTimeMillis();
        final long waitInterval = 3_000;
        final long triggerRTC = nowRTC + waitInterval;
        scheduleAlarmClock(triggerRTC);
        Thread.sleep(waitInterval);
        assertTrue(""AlarmClock did not go off as scheduled when under restrictions"",
                waitForAlarms(1, DEFAULT_WAIT));
    }

    @After
    public void tearDown() throws Exception {
        deleteAlarmManagerConstants();
        setAppOpsMode(APP_OP_MODE_ALLOWED);
        // Cancel any leftover alarms
        final Intent cancelAlarmsIntent = new Intent(TestAlarmScheduler.ACTION_CANCEL_ALL_ALARMS);
        cancelAlarmsIntent.setComponent(mAlarmScheduler);
        mContext.sendBroadcast(cancelAlarmsIntent);
        mContext.unregisterReceiver(mAlarmStateReceiver);
        // Broadcast unregister may race with the next register in setUp
        Thread.sleep(DEFAULT_WAIT);
    }

    private void updateAlarmManagerConstants() {
        mConfigHelper.with(""min_futurity"", 0L)
                .with(""min_interval"", MIN_REPEATING_INTERVAL)
                .with(""min_window"", 0)
                .commitAndAwaitPropagation();
    }

    private void deleteAlarmManagerConstants() {
        mConfigHelper.restoreAll();
    }

    private void setAppStandbyBucket(String bucket) throws IOException {
        mUiDevice.executeShellCommand(""am set-standby-bucket "" + TEST_APP_PACKAGE + "" "" + bucket);
    }

    private void setAppOpsMode(String mode) throws IOException {
        StringBuilder commandBuilder = new StringBuilder(""appops set "")
                .append(TEST_APP_PACKAGE)
                .append("" "")
                .append(APP_OP_RUN_ANY_IN_BACKGROUND)
                .append("" "")
                .append(mode);
        mUiDevice.executeShellCommand(commandBuilder.toString());
    }

    private void makeUidIdle() throws IOException {
        mUiDevice.executeShellCommand(""cmd devideidle tempwhitelist -r "" + TEST_APP_PACKAGE);
        mUiDevice.executeShellCommand(""am make-uid-idle "" + TEST_APP_PACKAGE);
    }

    private boolean waitForAlarms(int expectedAlarms, long timeout) throws InterruptedException {
        final long deadLine = SystemClock.uptimeMillis() + timeout;
        int alarmCount;
        do {
            Thread.sleep(POLL_INTERVAL);
            alarmCount = mAlarmCount;
        } while (alarmCount < expectedAlarms && SystemClock.uptimeMillis() < deadLine);
        return alarmCount >= expectedAlarms;
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.appsearch.external.app.AppSearchSessionCtsTestBase"	"testRemoveByQuery_packageFilter"	"CtsAppSearchTestCases"	"/home/gpoor/cts-12-source/cts/tests/appsearch/src/com/android/cts/appsearch/external/app/AppSearchSessionCtsTestBase.java"	""	"public void testRemoveByQuery_packageFilter() throws Exception {
        // Schema registration
        mDb1.setSchema(new SetSchemaRequest.Builder().addSchemas(AppSearchEmail.SCHEMA).build())
                .get();

        // Index documents
        AppSearchEmail email =
                new AppSearchEmail.Builder(""namespace"", ""id1"")
                        .setFrom(""from@example.com"")
                        .setTo(""to1@example.com"", ""to2@example.com"")
                        .setSubject(""foo"")
                        .setBody(""This is the body of the testPut email"")
                        .build();
        checkIsBatchResultSuccess(
                mDb1.put(new PutDocumentsRequest.Builder().addGenericDocuments(email).build()));

        // Check the presence of the documents
        assertThat(doGet(mDb1, ""namespace"", ""id1"")).hasSize(1);

        // Try to delete email with query ""foo"", but restricted to a different package name.
        // Won't work and email will still exist.
        mDb1.remove(
                        ""foo"",
                        new SearchSpec.Builder()
                                .setTermMatch(SearchSpec.TERM_MATCH_PREFIX)
                                .addFilterPackageNames(""some.other.package"")
                                .build())
                .get();
        assertThat(doGet(mDb1, ""namespace"", ""id1"")).hasSize(1);

        // Delete the email by query ""foo"", restricted to the correct package this time.
        mDb1.remove(
                        ""foo"",
                        new SearchSpec.Builder()
                                .setTermMatch(SearchSpec.TERM_MATCH_PREFIX)
                                .addFilterPackageNames(
                                        ApplicationProvider.getApplicationContext()
                                                .getPackageName())
                                .build())
                .get();
        AppSearchBatchResult<String, GenericDocument> getResult =
                mDb1.getByDocumentId(
                                new GetByDocumentIdRequest.Builder(""namespace"")
                                        .addIds(""id1"", ""id2"")
                                        .build())
                        .get();
        assertThat(getResult.isSuccess()).isFalse();
        assertThat(getResult.getFailures().get(""id1"").getResultCode())
                .isEqualTo(AppSearchResult.RESULT_NOT_FOUND);
    }"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.SipDelegateManagerTest"	"testCreateDelegateTestInvalidSipMessages"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/SipDelegateManagerTest.java"	""	"public void testCreateDelegateTestInvalidSipMessages() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        TransportInterfaces ifaces = new TransportInterfaces(getDefaultRequest(),
                Collections.emptySet(), 0);
        ifaces.connectAndVerify();

        // Verify restricted SIP request methods are not sent to the delegate.
        sendRestrictedRequestsAndVerifyFailed(ifaces.delegateConn);
        // Verify malformed messages are not sent to the delegate.
        sendInvalidRequestsAndVerifyFailed(ifaces.delegateConn);

        destroySipDelegateAndVerify(ifaces);
        assertEquals(""There should be no more delegates"", 0,
                ifaces.transport.getDelegates().size());
        verifyUpdateRegistrationCalled(ifaces.reg);
    }"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.SipDelegateManagerTest"	"testActiveDialogPendingNewInvite"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/SipDelegateManagerTest.java"	""	"public void testActiveDialogPendingNewInvite() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        TransportInterfaces ifaces = new TransportInterfaces(getDefaultRequest(),
                Collections.emptySet(), 0);
        ifaces.connect();
        // Send invite
        SipDialogAttributes attr = new SipDialogAttributes();
        sendChatInvite(attr, ifaces);
        // send close from app
        ifaces.delegateConn.disconnect(ifaces.manager,
                SipDelegateManager.SIP_DELEGATE_DESTROY_REASON_REQUESTED_BY_APP);
        // Registration state will change to deregistering during this time.
        ifaces.delegateConn.setOperationCountDownLatch(1);
        ifaces.delegateConn.waitForCountDown(ImsUtils.TEST_TIMEOUT_MS);
        assertTrue(ifaces.delegateConn.verifyDeregisteringStateContains(ONE_TO_ONE_CHAT_TAG,
                DelegateRegistrationState.DEREGISTERING_REASON_DESTROY_PENDING));
        // receive 200 OK
        receive200OkResponse(attr, ifaces);
        // Send ACK
        sendAck(attr, ifaces);
        // Send invite
        SipDialogAttributes attr2 = new SipDialogAttributes();
        attr2.addAcceptContactTag(ONE_TO_ONE_CHAT_TAG);
        // Should be denied because the transport is now restricted
        sendDeniedChatInvite(attr2, ifaces,
                SipDelegateManager.MESSAGE_FAILURE_REASON_DELEGATE_CLOSED);
        // Send BYE on original invite
        sendByeRequest(attr, ifaces);
        // destroy should not be called until cleanupSession is sent.
        assertFalse(ifaces.transport.isLatchCountDownFinished(
                TestSipTransport.LATCH_DESTROY_DELEGATE));
        ifaces.delegateConn.setOperationCountDownLatch(1);
        // Send the cleanup, which will trigger destroy to complete.
        ifaces.delegateConn.sendCleanupSession(attr.callId);
        ifaces.delegate.verifyCleanupSession(attr.callId);
        ifaces.transport.waitForLatchCountdownAndReset(TestSipTransport.LATCH_DESTROY_DELEGATE);
        ifaces.delegate.notifyOnDestroyed(
                SipDelegateManager.SIP_DELEGATE_DESTROY_REASON_REQUESTED_BY_APP);
        ifaces.delegateConn.waitForCountDown(ImsUtils.TEST_TIMEOUT_MS);
        ifaces.delegateConn.verifyDestroyed(
                SipDelegateManager.SIP_DELEGATE_DESTROY_REASON_REQUESTED_BY_APP);

        assertEquals(""There should be no more delegates"", 0,
                ifaces.transport.getDelegates().size());
        verifyUpdateRegistrationCalled(ifaces.reg);
    }"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.SipDelegateManagerTest"	"testIncomingInviteDeregistering"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/SipDelegateManagerTest.java"	""	"public void testIncomingInviteDeregistering() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        TransportInterfaces ifaces = new TransportInterfaces(getDefaultRequest(),
                Collections.emptySet(), 0);
        ifaces.connect();
        // move chat to deregistering
        Set<String> regFeatures = new ArraySet<>(Arrays.asList(DEFAULT_FEATURE_TAGS));
        regFeatures.remove(ONE_TO_ONE_CHAT_TAG);
        DelegateRegistrationState state = getDeregisteringState(regFeatures,
                Collections.singleton(ONE_TO_ONE_CHAT_TAG),
                DelegateRegistrationState.DEREGISTERING_REASON_PROVISIONING_CHANGE);
        verifyRegistrationState(ifaces, state);
        // receive invite, which can not be blocked
        SipDialogAttributes attr = new SipDialogAttributes();
        receiveChatInvite(attr, ifaces);
        // ensure delegate connection can still respond to the request, even if in restricted state.
        send200OkResponse(attr, ifaces);
        receiveAck(attr, ifaces);
        // receive BYE and clean up
        receiveByeRequest(attr, ifaces);
        ifaces.delegateConn.sendCleanupSession(attr.callId);
        ifaces.delegate.verifyCleanupSession(attr.callId);

        destroySipDelegateAndVerify(ifaces);
        assertEquals(""There should be no more delegates"", 0,
                ifaces.transport.getDelegates().size());
        verifyUpdateRegistrationCalled(ifaces.reg);
    }

    private SipMessage generateSipMessage(String str) {
        String crlf = ""\r\n"";
        String[] components = str.split(crlf);
        String startLine = """";
        String header = """";
        String content = """";
        StringBuilder sb = new StringBuilder();
        int idx = 1;
        if (components.length > 0) {
            startLine = components[0] + crlf;
        }
        // generate sip header
        idx = composeSipSection(idx, components, sb);
        header = sb.toString();

        idx++;
        sb.setLength(0);
        // generate sip body
        idx = composeSipSection(idx, components, sb);
        content = sb.toString();

        return new SipMessage(startLine, header, content.getBytes(UTF_8));
    }

    private int composeSipSection(int index, String[] components, StringBuilder sb) {
        String crlf = ""\r\n"";
        while (index < components.length) {
            if (components[index].length() > 0) {
                sb.append(components[index]).append(crlf);
                index++;
            } else {
                break;
            }
        }
        return index;
    }

    private void sendChatInvite(SipDialogAttributes attr,
            TransportInterfaces ifaces) throws Exception {
        SipDialogAttributes invAttr = attr.fromExisting().copyWithNewBranch();
        invAttr.addAcceptContactTag(ONE_TO_ONE_CHAT_TAG);
        SipMessage invite = SipMessageUtils.generateSipRequest(SipMessageUtils.INVITE_SIP_METHOD,
                invAttr);
        sendMessageAndVerifyAck(invite, ifaces);
    }

    private void sendDeniedChatInvite(SipDialogAttributes attr,
            TransportInterfaces ifaces, int denyReason) throws Exception {
        SipDialogAttributes invAttr = attr.fromExisting().copyWithNewBranch();
        SipMessage invite = SipMessageUtils.generateSipRequest(SipMessageUtils.INVITE_SIP_METHOD,
                invAttr);
        ifaces.delegateConn.sendMessageAndVerifyFailure(invite, denyReason);
    }

    private void receiveChatInvite(SipDialogAttributes attr,
            TransportInterfaces ifaces) throws Exception {
        SipDialogAttributes invAttr = attr.fromExisting().copyWithNewBranch();
        invAttr.addAcceptContactTag(ONE_TO_ONE_CHAT_TAG);
        SipMessage invite = SipMessageUtils.generateSipRequest(SipMessageUtils.INVITE_SIP_METHOD,
                invAttr);
        receiveMessageAndVerifyAck(invite, ifaces);
    }

    private void send200OkResponse(SipDialogAttributes attr,
            TransportInterfaces ifaces) throws Exception {
        attr.setToTag();
        // do not update branch here, as it is a response to a request.
        SipMessage resp = SipMessageUtils.generateSipResponse(""200"", ""OK"",
                attr);
        sendMessageAndVerifyAck(resp, ifaces);
    }

    private void receive200OkResponse(SipDialogAttributes attr,
            TransportInterfaces ifaces) throws Exception {
        attr.setToTag();
        // do not update branch here, as it is a response to a request.
        SipMessage resp = SipMessageUtils.generateSipResponse(""200"", ""OK"",
                attr);
        receiveMessageAndVerifyAck(resp, ifaces);
    }

    private void sendAck(SipDialogAttributes attr,
            TransportInterfaces ifaces) throws Exception {
        attr = attr.copyWithNewBranch();
        SipMessage invite = SipMessageUtils.generateSipRequest(SipMessageUtils.ACK_SIP_METHOD,
                attr);
        sendMessageAndVerifyAck(invite, ifaces);
    }

    private void receiveAck(SipDialogAttributes attr,
            TransportInterfaces ifaces) throws Exception {
        attr = attr.copyWithNewBranch();
        SipMessage invite = SipMessageUtils.generateSipRequest(SipMessageUtils.ACK_SIP_METHOD,
                attr);
        receiveMessageAndVerifyAck(invite, ifaces);
    }

    private void sendByeRequest(SipDialogAttributes attr,
            TransportInterfaces ifaces) throws Exception {
        attr = attr.copyWithNewBranch();
        SipMessage invite = SipMessageUtils.generateSipRequest(SipMessageUtils.BYE_SIP_METHOD,
                attr);
        sendMessageAndVerifyAck(invite, ifaces);
    }

    private void receiveByeRequest(SipDialogAttributes attr,
            TransportInterfaces ifaces) throws Exception {
        attr = attr.copyWithNewBranch();
        SipMessage invite = SipMessageUtils.generateSipRequest(SipMessageUtils.BYE_SIP_METHOD,
                attr);
        receiveMessageAndVerifyAck(invite, ifaces);
    }

    private void createSipDelegateConnectionNoDelegateExpected(SipDelegateManager manager,
            TestSipDelegateConnection conn, TestSipTransport transport) throws Exception {
        // wait for onCreated and reg state changed
        conn.setOperationCountDownLatch(2);
        conn.connect(manager);
        conn.waitForCountDown(ImsUtils.TEST_TIMEOUT_MS);
        conn.verifyDelegateCreated();
        conn.verifyRegistrationStateEmpty();
        // All requested features should have been denied due to the app not being the default sms
        // app.
        conn.verifyAllDenied(SipDelegateManager.DENIED_REASON_NOT_ALLOWED);
        // There should not have been a call to create a SipDelegate on the service side, since all
        // features were denied due to permissions issues.
        assertEquals(""SipDelegate should not have been created"", 0,
                transport.getDelegates().size());
    }

    private void destroySipDelegateConnectionNoDelegate(SipDelegateManager manager,
            TestSipDelegateConnection delegateConn) throws Exception {
        delegateConn.setOperationCountDownLatch(1);
        delegateConn.disconnect(manager,
                SipDelegateManager.SIP_DELEGATE_DESTROY_REASON_REQUESTED_BY_APP);
        delegateConn.waitForCountDown(ImsUtils.TEST_TIMEOUT_MS);
        delegateConn.verifyDestroyed(
                SipDelegateManager.SIP_DELEGATE_DESTROY_REASON_REQUESTED_BY_APP);
    }

    private void destroySipDelegate(SipDelegateManager manager,
            TestSipTransport transportImpl, TestSipDelegateConnection delegateConn,
            TestSipDelegate delegate) throws Exception {
        delegateConn.disconnect(manager,
                SipDelegateManager.SIP_DELEGATE_DESTROY_REASON_REQUESTED_BY_APP);
        transportImpl.waitForLatchCountdownAndReset(TestSipTransport.LATCH_DESTROY_DELEGATE);
        delegate.notifyOnDestroyed(
                SipDelegateManager.SIP_DELEGATE_DESTROY_REASON_REQUESTED_BY_APP);

    }

    private void destroySipDelegateAndVerifyConnDestroyed(SipDelegateManager manager,
            TestSipTransport transportImpl, TestSipDelegateConnection delegateConn,
            TestSipDelegate delegate) throws Exception {
        delegateConn.setOperationCountDownLatch(1);
        destroySipDelegate(manager, transportImpl, delegateConn, delegate);
        delegateConn.waitForCountDown(ImsUtils.TEST_TIMEOUT_MS);
        delegateConn.verifyDestroyed(
                SipDelegateManager.SIP_DELEGATE_DESTROY_REASON_REQUESTED_BY_APP);
    }

    private void destroySipDelegateAndVerify(TransportInterfaces ifaces) throws Exception {
        // wait for on destroyed
        destroySipDelegateAndVerifyConnDestroyed(ifaces.manager, ifaces.transport,
                ifaces.delegateConn, ifaces.delegate);
    }

    private void verifySipDelegateDestroyed(TestSipTransport transportImpl,
            TestSipDelegate delegate) {
        transportImpl.waitForLatchCountdownAndReset(TestSipTransport.LATCH_DESTROY_DELEGATE);
        delegate.notifyOnDestroyed(
                SipDelegateManager.SIP_DELEGATE_DESTROY_REASON_REQUESTED_BY_APP);
    }

    private TestSipDelegate createSipDelegateConnectionAndVerify(SipDelegateManager manager,
            TestSipDelegateConnection conn, TestSipTransport transport,
            Set<FeatureTagState>  deniedTags, int delegateIndex) throws Exception {
        conn.setOperationCountDownLatch(1);
        conn.connect(manager);
        TestSipDelegate d = getSipDelegate(transport, deniedTags, delegateIndex);
        conn.waitForCountDown(ImsUtils.TEST_TIMEOUT_MS);
        conn.verifyDelegateCreated();
        return d;
    }

    private TestSipDelegate getSipDelegate(TestSipTransport transport,
            Set<FeatureTagState> deniedTags, int delegateIndex) {
        transport.waitForLatchCountdownAndReset(TestSipTransport.LATCH_CREATE_DELEGATE);
        // There must have been a call to create a SipDelegate on the service side.
        assertEquals(""SipDelegate should have been created"", delegateIndex + 1,
                transport.getDelegates().size());
        TestSipDelegate d = transport.getDelegates().get(delegateIndex);
        d.notifyOnCreated(deniedTags);
        return d;
    }

    private void verifyRegisteredAndSendSipConfig(TestSipDelegateConnection delegateConn,
            TestSipDelegate delegate, Set<String> registeredTags,
            Set<FeatureTagState> deniedTags, SipDelegateConfiguration sipConfig) {
        // wait for reg change to be called
        delegateConn.setOperationCountDownLatch(1);
        DelegateRegistrationState s = getRegisteredRegistrationState(registeredTags);
        delegate.notifyImsRegistrationUpdate(s);
        delegateConn.waitForCountDown(ImsUtils.TEST_TIMEOUT_MS);
        delegateConn.verifyRegistrationStateRegistered(registeredTags);
        delegateConn.verifyDenied(deniedTags);

        // send config change as well.
        sendConfigChange(sipConfig, delegateConn, delegate);
    }

    private Set<FeatureTagState> generateDeniedSetFromRequest(Set<String> grantedTags,
            Set<String> newTags, int reason) {
        // Deny features from newTags that are already granted in grantedTags.
        return grantedTags.stream().filter(newTags::contains)
                .map(s -> new FeatureTagState(s, reason))
                .collect(Collectors.toSet());
    }

    private void verifyUpdateRegistrationCalled(TestImsRegistration regImpl) {
        regImpl.resetLatch(TestImsRegistration.LATCH_UPDATE_REGISTRATION, 1);
        // it is okay to reset and wait here (without race conditions) because there is a
        // second delay between triggering update registration and the latch being triggered.
        assertTrue(regImpl.waitForLatchCountDown(TestImsRegistration.LATCH_UPDATE_REGISTRATION,
                ImsUtils.TEST_TIMEOUT_MS));
    }

    private void sendRestrictedRequestsAndVerifyFailed(
            TestSipDelegateConnection delegateConn) throws Exception {
        delegateConn.sendMessageAndVerifyFailure(SipMessageUtils.TEST_INVALID_SIP_REGISTER,
                SipDelegateManager.MESSAGE_FAILURE_REASON_INVALID_START_LINE);
        delegateConn.sendMessageAndVerifyFailure(SipMessageUtils.TEST_INVALID_SIP_PUBLISH,
                SipDelegateManager.MESSAGE_FAILURE_REASON_INVALID_START_LINE);
        delegateConn.sendMessageAndVerifyFailure(SipMessageUtils.TEST_INVALID_SIP_OPTIONS,
                SipDelegateManager.MESSAGE_FAILURE_REASON_INVALID_START_LINE);
        delegateConn.sendMessageAndVerifyFailure(
                SipMessageUtils.TEST_INVALID_SIP_SUBSCRIBE_PRESENCE,
                SipDelegateManager.MESSAGE_FAILURE_REASON_INVALID_HEADER_FIELDS);
    }

    private void verifyFullRegistrationTriggered(TransportInterfaces ifaces) throws Exception {
        ifaces.delegateConn.verifyDelegateCreated();
        ifaces.delegateConn.triggerFullNetworkRegistration(ifaces.manager, 403, ""FORBIDDEN"");
        TestImsRegistration.NetworkRegistrationInfo info =
                ifaces.reg.getNextFullNetworkRegRequest(ImsUtils.TEST_TIMEOUT_MS);
        assertNotNull(""full registration requested, but ImsRegistrationImplBase ""
                + ""implementation did not receive a request."", info);
        assertEquals(403, info.sipCode);
        assertEquals(""FORBIDDEN"", info.sipReason);
    }

    private void sendInvalidRequestsAndVerifyFailed(
            TestSipDelegateConnection delegateConn) throws Exception {
        delegateConn.sendMessageAndVerifyFailure(SipMessageUtils.TEST_SIP_MESSAGE_INVALID_REQUEST,
                SipDelegateManager.MESSAGE_FAILURE_REASON_INVALID_START_LINE);
        delegateConn.sendMessageAndVerifyFailure(SipMessageUtils.TEST_SIP_MESSAGE_INVALID_RESPONSE,
                SipDelegateManager.MESSAGE_FAILURE_REASON_INVALID_START_LINE);
    }

    private void verifyOutgoingTransport(TestSipDelegateConnection delegateConn,
            TestSipDelegate delegate) throws Exception {
        // Send a message and ensure it gets received on the other end as well as acked
        delegateConn.sendMessageAndVerifyCompletedSuccessfully(SipMessageUtils.TEST_SIP_MESSAGE);
        delegate.verifyMessageSend(SipMessageUtils.TEST_SIP_MESSAGE);
        delegateConn.sendCleanupSession(SipMessageUtils.TEST_SIP_MESSAGE.getCallIdParameter());
        delegate.verifyCleanupSession(SipMessageUtils.TEST_SIP_MESSAGE.getCallIdParameter());
        // send a message and notify connection that it failed
        delegate.setSendMessageDenyReason(
                SipDelegateManager.MESSAGE_FAILURE_REASON_NETWORK_NOT_AVAILABLE);
        delegateConn.sendMessageAndVerifyFailure(SipMessageUtils.TEST_SIP_MESSAGE,
                SipDelegateManager.MESSAGE_FAILURE_REASON_NETWORK_NOT_AVAILABLE);
        delegate.verifyMessageSend(SipMessageUtils.TEST_SIP_MESSAGE);
    }

    private void sendMessageAndVerifyAck(SipMessage message,
            TransportInterfaces ifaces) throws Exception {
        // Send a message and ensure it gets received on the other end as well as acked
        ifaces.delegateConn.sendMessageAndVerifyCompletedSuccessfully(message);
    }

    private void verifyIncomingTransport(TestSipDelegateConnection delegateConn,
            TestSipDelegate delegate) throws Exception {
        // Receive a message and ensure it gets received on the other end as well as acked
        delegate.receiveMessageAndVerifyReceivedCalled(SipMessageUtils.TEST_SIP_MESSAGE);
        delegateConn.verifyMessageReceived(SipMessageUtils.TEST_SIP_MESSAGE);
        // Receive a message and have connection notify that it didn't complete
        delegateConn.setReceivedMessageErrorResponseReason(
                SipDelegateManager.MESSAGE_FAILURE_REASON_INVALID_BODY_CONTENT);
        delegate.receiveMessageAndVerifyReceiveErrorCalled(SipMessageUtils.TEST_SIP_MESSAGE,
                SipDelegateManager.MESSAGE_FAILURE_REASON_INVALID_BODY_CONTENT);
    }

    private void receiveMessageAndVerifyAck(SipMessage message,
            TransportInterfaces ifaces) throws Exception {
        // Receive a message and ensure it gets received on the other end as well as acked
        ifaces.delegate.receiveMessageAndVerifyReceivedCalled(message);
        ifaces.delegateConn.verifyMessageReceived(message);
    }

    private void verifyRegistrationState(TransportInterfaces ifaces,
            DelegateRegistrationState state) {
        ifaces.delegateConn.setOperationCountDownLatch(1);
        ifaces.delegate.notifyImsRegistrationUpdate(state);
        ifaces.delegateConn.waitForCountDown(ImsUtils.TEST_TIMEOUT_MS);
        ifaces.delegateConn.verifyRegistrationStateEquals(state);
    }

    private DelegateRegistrationState getDeregisteringState(Set<String> registered,
            Set<String> deregistering, int deregisteringReason) {
        DelegateRegistrationState.Builder b = new DelegateRegistrationState.Builder();
        b.addRegisteredFeatureTags(registered);
        for (String dereg : deregistering) {
            b.addDeregisteringFeatureTag(dereg, deregisteringReason);
        }
        return b.build();
    }

    private void sendConfigChange(SipDelegateConfiguration c,
            TestSipDelegateConnection delegateConn, TestSipDelegate delegate) {
        delegateConn.setOperationCountDownLatch(1);
        delegate.notifyConfigurationUpdate(c);
        delegateConn.waitForCountDown(ImsUtils.TEST_TIMEOUT_MS);
        delegateConn.verifyConfigEquals(c);
    }

    /**
     * @return A new test SipDelegateConfiguration that has all fields populated.1
     */
    private SipDelegateConfiguration generateNewTestConfig() {
        InetSocketAddress localAddr = new InetSocketAddress(
                InetAddresses.parseNumericAddress(""1.1.1.1""), 80);
        InetSocketAddress serverAddr = new InetSocketAddress(
                InetAddresses.parseNumericAddress(""2.2.2.2""), 81);
        SipDelegateConfiguration.Builder b = new SipDelegateConfiguration.Builder(1,
                SipDelegateConfiguration.SIP_TRANSPORT_TCP, localAddr, serverAddr);
        b.setSipCompactFormEnabled(true);
        b.setSipKeepaliveEnabled(true);
        b.setMaxUdpPayloadSizeBytes(508);
        b.setPublicUserIdentifier(""test1"");
        b.setPrivateUserIdentifier(""test2"");
        b.setHomeDomain(""test.domain"");
        b.setImei(""testImei"");
        b.setSipAuthenticationHeader(""sipauth"");
        b.setSipAuthenticationNonce(""sipnonce"");
        b.setSipServiceRouteHeader(""srvroute"");
        b.setSipPathHeader(""path"");
        b.setSipUserAgentHeader(""ua"");
        b.setSipContactUserParameter(""user"");
        b.setSipPaniHeader(""pani"");
        b.setSipPlaniHeader(""plani"");
        b.setSipCniHeader(""cni"");
        b.setSipAssociatedUriHeader(""uri"");
        Uri gruuUri = Uri.parse(""sip:blah@gruu.net"");
        b.setPublicGruuUri(gruuUri);
        SipDelegateConfiguration.IpSecConfiguration ipSecConfig =
                new SipDelegateConfiguration.IpSecConfiguration(123, 124,
                        125, 126, 127, 128, ""secverify"");
        assertEquals(123, ipSecConfig.getLocalTxPort());
        assertEquals(124, ipSecConfig.getLocalRxPort());
        assertEquals(125, ipSecConfig.getLastLocalTxPort());
        assertEquals(126, ipSecConfig.getRemoteTxPort());
        assertEquals(127, ipSecConfig.getRemoteRxPort());
        assertEquals(128, ipSecConfig.getLastRemoteTxPort());
        assertEquals(""secverify"", ipSecConfig.getSipSecurityVerifyHeader());
        b.setIpSecConfiguration(ipSecConfig);
        InetSocketAddress natAddr = new InetSocketAddress(
                InetAddresses.parseNumericAddress(""3.3.3.3""), 129);
        b.setNatSocketAddress(natAddr);
        assertEquals(""3.3.3.3"", natAddr.getAddress().getHostAddress());
        assertEquals(129, natAddr.getPort());
        return b.build();
    }

    private DelegateRegistrationState getRegisteredRegistrationState(Set<String> registered) {
        return new DelegateRegistrationState.Builder().addRegisteredFeatureTags(registered).build();
    }

    private DelegateRegistrationState getDeregisteringState(Set<String> deregisterTags,
            int reason) {
        DelegateRegistrationState.Builder b = new DelegateRegistrationState.Builder();
        for (String t : deregisterTags) {
            b.addDeregisteringFeatureTag(t, reason);
        }
        return b.build();
    }

    private void connectTestImsServiceWithSipTransportAndConfig() throws Exception {
        PersistableBundle b = new PersistableBundle();
        b.putBoolean(CarrierConfigManager.Ims.KEY_IMS_SINGLE_REGISTRATION_REQUIRED_BOOL, true);
        overrideCarrierConfig(b);

        assertTrue(sServiceConnector.connectCarrierImsServiceLocally());
        sServiceConnector.getCarrierService().addCapabilities(
                ImsService.CAPABILITY_SIP_DELEGATE_CREATION);
        sServiceConnector.getCarrierService().setSipTransportImplemented();
        ImsFeatureConfiguration c = getConfigForMmTelAndRcs();
        assertTrue(sServiceConnector.triggerFrameworkConnectionToCarrierImsService(c));
        verifyImsServiceState(c);
    }


    private void connectTestImsServiceWithSipTransport() throws Exception {
        assertTrue(sServiceConnector.connectCarrierImsServiceLocally());
        sServiceConnector.getCarrierService().addCapabilities(
                ImsService.CAPABILITY_SIP_DELEGATE_CREATION);
        sServiceConnector.getCarrierService().setSipTransportImplemented();
        ImsFeatureConfiguration c = getConfigForMmTelAndRcs();
        assertTrue(sServiceConnector.triggerFrameworkConnectionToCarrierImsService(c));
        verifyImsServiceState(c);
    }

    private void verifyImsServiceState(ImsFeatureConfiguration config) {
        for (ImsFeatureConfiguration.FeatureSlotPair p : config.getServiceFeatures()) {
            switch (p.featureType) {
                case ImsFeature.FEATURE_MMTEL: {
                    sServiceConnector.getCarrierService().waitForLatchCountdown(
                            TestImsService.LATCH_CREATE_MMTEL);
                    assertNotNull(""ImsService created, but ImsService#createMmTelFeature was not ""
                            + ""called!"", sServiceConnector.getCarrierService().getMmTelFeature());
                    break;
                }
                case ImsFeature.FEATURE_RCS: {
                    sServiceConnector.getCarrierService().waitForLatchCountdown(
                            TestImsService.LATCH_CREATE_RCS);
                    assertNotNull(""ImsService created, but ImsService#createRcsFeature was not ""
                            + ""called!"", sServiceConnector.getCarrierService().getRcsFeature());
                    break;
                }
            }
        }
    }

    /**
     * Wait up to five seconds (retrying a command 1 time per second) until ImsExceptions due to the
     * ImsService not being available go away. If the ImsService never becomes available, this
     * method will return null.
     */
    private <T> T callUntilImsServiceIsAvailable(Callable<T> command) throws Exception {
        int retry = 0;
        while (retry < 5) {
            try {
                return command.call();
            } catch (ImsException e) {
                // we want to absorb only the unavailable error, as telephony may still be
                // internally setting up. Any other type of ImsException is unexpected.
                if (e.getCode() != ImsException.CODE_ERROR_SERVICE_UNAVAILABLE) {
                    throw e;
                }
            }
            Thread.sleep(1000);
            retry++;
        }
        return null;
    }

    private DelegateRequest getDefaultRequest() {
        ArraySet<String> features = new ArraySet<>(Arrays.asList(DEFAULT_FEATURE_TAGS));
        return new DelegateRequest(features);
    }

    private DelegateRequest getChatOnlyRequest() {
        ArraySet<String> features = new ArraySet<>(3);
        features.add(ONE_TO_ONE_CHAT_TAG);
        features.add(GROUP_CHAT_TAG);
        return new DelegateRequest(features);
    }

    private ImsFeatureConfiguration getConfigForMmTelAndRcs() {
        return new ImsFeatureConfiguration.Builder()
                .addFeature(sTestSlot, ImsFeature.FEATURE_EMERGENCY_MMTEL)
                .addFeature(sTestSlot, ImsFeature.FEATURE_MMTEL)
                .addFeature(sTestSlot, ImsFeature.FEATURE_RCS)
                .build();
    }

    private ImsFeatureConfiguration getConfigForRcs() {
        return new ImsFeatureConfiguration.Builder()
                .addFeature(sTestSlot, ImsFeature.FEATURE_RCS)
                .build();
    }

    private Set<FeatureTagState> getDeniedTagsForReason(Set<String> deniedTags, int reason) {
        return deniedTags.stream().map(t -> new FeatureTagState(t, reason))
                .collect(Collectors.toSet());
    }

    private static void overrideCarrierConfig(PersistableBundle bundle) throws Exception {
        CarrierConfigManager carrierConfigManager = InstrumentationRegistry.getInstrumentation()
                .getContext().getSystemService(CarrierConfigManager.class);
        sReceiver.clearQueue();
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(carrierConfigManager,
                (m) -> m.overrideConfig(sTestSub, bundle));
        sReceiver.waitForCarrierConfigChanged();
    }

    private static void setFeatureTagsCarrierAllowed(String[] tags) throws Exception {
        PersistableBundle bundle = new PersistableBundle();
        bundle.putStringArray(CarrierConfigManager.Ims.KEY_RCS_FEATURE_TAG_ALLOWED_STRING_ARRAY,
                tags);
        overrideCarrierConfig(bundle);
    }

    private SipDelegateManager getSipDelegateManager() {
        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        assertNotNull(imsManager);
        return imsManager.getSipDelegateManager(sTestSub);
    }

    private static Context getContext() {
        return InstrumentationRegistry.getInstrumentation().getContext();
    }
}"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.devicepolicy.cts.NetworkResetTest"	"factoryReset_disallowedByNetworkResetPolicy_doesNotFactoryReset"	"CtsDevicePolicyTestCases"	"/home/gpoor/cts-12-source/cts/tests/devicepolicy/src/android/devicepolicy/cts/NetworkResetTest.java"	""	"@Postsubmit(reason = ""New test"")
    @PositivePolicyTest(policy = DisallowNetworkReset.class)
    @EnsureHasPermission({NETWORK_SETTINGS, WRITE_SECURE_SETTINGS})
    public void factoryReset_disallowedByNetworkResetPolicy_doesNotFactoryReset() throws Exception {
        final boolean originalUserRestriction =
                sUserManager.hasUserRestriction(DISALLOW_NETWORK_RESET);
        try {
            sConnectivityManager.setAirplaneMode(true);
            sDeviceState.dpc().devicePolicyManager().addUserRestriction(DISALLOW_NETWORK_RESET);

            sConnectivityManager.factoryReset();

            // As the factory reset should have been rejected, it's expected that the airplane mode
            // should not be changed.
            assertThat(getAirplaneMode()).isTrue();
        } finally {
            restoreUserRestriction(originalUserRestriction, DISALLOW_NETWORK_RESET);
        }
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.devicepolicy.cts.NetworkResetTest"	"factoryReset_disallowedByConfigPrivateDnsPolicy_doesPartialFactoryReset"	"CtsDevicePolicyTestCases"	"/home/gpoor/cts-12-source/cts/tests/devicepolicy/src/android/devicepolicy/cts/NetworkResetTest.java"	""	"@Postsubmit(reason = ""New test"")
    @PositivePolicyTest(policy = DisallowPrivateDnsConfig.class)
    @EnsureHasPermission({NETWORK_SETTINGS, WRITE_SECURE_SETTINGS})
    public void factoryReset_disallowedByConfigPrivateDnsPolicy_doesPartialFactoryReset()
            throws Exception {
        final boolean originalUserRestriction =
                sUserManager.hasUserRestriction(DISALLOW_CONFIG_PRIVATE_DNS);
        try {
            ConnectivitySettingsManager.setPrivateDnsMode(sContext,
                    ConnectivitySettingsManager.PRIVATE_DNS_MODE_OFF);
            sDeviceState.dpc().devicePolicyManager()
                    .addUserRestriction(DISALLOW_CONFIG_PRIVATE_DNS);

            sConnectivityManager.factoryReset();

            // As setting private dns should be rejected, it's expected that private dns mode
            // should not be changed.
            assertThat(getPrivateDnsMode()).isEqualTo(
                    ConnectivitySettingsManager.PRIVATE_DNS_MODE_OFF);
        } finally {
            restoreUserRestriction(originalUserRestriction, DISALLOW_CONFIG_PRIVATE_DNS);
        }
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.devicepolicy.cts.NetworkResetTest"	"isFalse"	"CtsDevicePolicyTestCases"	"/home/gpoor/cts-12-source/cts/tests/devicepolicy/src/android/devicepolicy/cts/NetworkResetTest.java"	""	"@Postsubmit(reason = ""New test"")
    @PositivePolicyTest(policy = DisallowNetworkReset.class)
    @EnsureHasPermission({NETWORK_SETTINGS, WRITE_SECURE_SETTINGS})
    public void factoryReset_noPolicyRestrictions_resetsToDefault() throws Exception {
        final boolean originalPrivateDnsUserRestriction =
                sUserManager.hasUserRestriction(DISALLOW_CONFIG_PRIVATE_DNS);
        final boolean originalNetworkResetUserRestriction =
                sUserManager.hasUserRestriction(DISALLOW_NETWORK_RESET);
        try {
            sConnectivityManager.setAirplaneMode(true);
            ConnectivitySettingsManager.setPrivateDnsMode(sContext,
                    ConnectivitySettingsManager.PRIVATE_DNS_MODE_OFF);
            // Ensure no policy set.
            sDeviceState.dpc().devicePolicyManager()
                    .clearUserRestriction(DISALLOW_CONFIG_PRIVATE_DNS);
            sDeviceState.dpc().devicePolicyManager()
                    .clearUserRestriction(DISALLOW_NETWORK_RESET);

            sConnectivityManager.factoryReset();

            // Verify settings reset to default setting.
            assertThat(getPrivateDnsMode()).isEqualTo(
                    ConnectivitySettingsManager.PRIVATE_DNS_MODE_OPPORTUNISTIC);
            assertThat(getAirplaneMode()).isFalse();
        } finally {
            restoreUserRestriction(originalPrivateDnsUserRestriction, DISALLOW_CONFIG_PRIVATE_DNS);
            restoreUserRestriction(originalNetworkResetUserRestriction, DISALLOW_NETWORK_RESET);
        }
    }

    private boolean getAirplaneMode() throws Exception {
        return Settings.Global.getInt(
                sContext.getContentResolver(), Settings.Global.AIRPLANE_MODE_ON) != 0;
    }

    private int getPrivateDnsMode() {
        return ConnectivitySettingsManager.getPrivateDnsMode(sContext);
    }

    private int getNetworkAvoidBadWifi() {
        return ConnectivitySettingsManager.getNetworkAvoidBadWifi(sContext);
    }

    private void restoreSettings(boolean airplaneMode, int privateDnsMode, int avoidBadWifi) {
        sConnectivityManager.setAirplaneMode(airplaneMode);
        ConnectivitySettingsManager.setPrivateDnsMode(sContext, privateDnsMode);
        ConnectivitySettingsManager.setNetworkAvoidBadWifi(sContext, avoidBadWifi);
    }

    private void restoreUserRestriction(boolean originalUserRestriction, String policy) {
        if (originalUserRestriction) {
            sDeviceState.dpc().devicePolicyManager().addUserRestriction(policy);
        } else {
            sDeviceState.dpc().devicePolicyManager().clearUserRestriction(policy);
        }
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.managedprofile.DisallowSharingIntoProfileTest"	"testSetUp"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/ManagedProfile/src/com/android/cts/managedprofile/DisallowSharingIntoProfileTest.java"	""	"public void testSetUp() throws Exception {
        // toggle the restriction to reset system's built-in cross profile intent filters,
        // simulating the default state of a work profile created by ManagedProvisioning
        testDisableSharingIntoProfile();
        testEnableSharingIntoProfile();

        PackageManager pm = mContext.getPackageManager();
        if (pm.hasSystemFeature(PackageManager.FEATURE_CAMERA)) {
            sharingIntentsToPersonal.addAll(sharingIntentsToPersonalIfCameraExists);
        }

        mDevicePolicyManager.clearCrossProfileIntentFilters(ADMIN_RECEIVER_COMPONENT);
        // Set up cross profile intent filters so we can resolve these to find out framework's
        // intent forwarder activity as ground truth
        mDevicePolicyManager.addCrossProfileIntentFilter(ADMIN_RECEIVER_COMPONENT,
                new IntentFilter(KNOWN_ACTION_TO_PERSONAL),
                DevicePolicyManager.FLAG_PARENT_CAN_ACCESS_MANAGED);
        mDevicePolicyManager.addCrossProfileIntentFilter(ADMIN_RECEIVER_COMPONENT,
                new IntentFilter(KNOWN_ACTION_TO_PROFILE),
                DevicePolicyManager.FLAG_MANAGED_CAN_ACCESS_PARENT);
    }

    /**
     * Test sharing initiated from the personal side are mainly driven from the host side, see
     * ManagedProfileTest.testDisallowSharingIntoProfileFromPersonal() See javadoc of
     * {@link #DisallowSharingIntoProfileTest} class for the mechanism behind this test.
     */"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.managedprofile.DisallowSharingIntoProfileTest"	"testDisableSharingIntoProfile"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/ManagedProfile/src/com/android/cts/managedprofile/DisallowSharingIntoProfileTest.java"	""	"public void testDisableSharingIntoProfile() throws Exception {
        setSharingEnabled(false);
    }

    private void setSharingEnabled(boolean enabled) throws InterruptedException {
        final CountDownLatch latch = new CountDownLatch(1);
        BroadcastReceiver receiver = new BroadcastReceiver() {
            @Override
            public void onReceive(Context context, Intent intent) {
                latch.countDown();
            }
        };
        IntentFilter filter = new IntentFilter();
        filter.addAction(DevicePolicyManager.ACTION_DATA_SHARING_RESTRICTION_APPLIED);
        mContext.registerReceiver(receiver, filter);
        try {
            if (enabled) {
                mDevicePolicyManager.clearUserRestriction(ADMIN_RECEIVER_COMPONENT,
                        UserManager.DISALLOW_SHARE_INTO_MANAGED_PROFILE);
            } else {
                mDevicePolicyManager.addUserRestriction(ADMIN_RECEIVER_COMPONENT,
                        UserManager.DISALLOW_SHARE_INTO_MANAGED_PROFILE);
            }
            // Wait for the restriction to apply
            assertTrue(""Restriction not applied after 60 seconds"", latch.await(60, SECONDS));
        } finally {
            mContext.unregisterReceiver(receiver);
        }
    }

    private void assertCrossProfileIntentsResolvability(List<Intent> intents,
            ResolveInfo expectedForwarder, boolean expectForwardable) {
        for (Intent intent : intents) {
            List<ResolveInfo> resolveInfoList = mContext.getPackageManager().queryIntentActivities(
                    intent,
                    PackageManager.MATCH_DEFAULT_ONLY);
            if (expectForwardable) {
                assertTrue(""Expect "" + intent + "" to be forwardable, but resolve list""
                        + "" does not contain expected intent forwarder "" + expectedForwarder,
                        containsResolveInfo(resolveInfoList, expectedForwarder));
            } else {
                assertFalse(""Expect "" + intent + "" not to be forwardable, but resolve list ""
                        + ""contains intent forwarder "" + expectedForwarder,
                        containsResolveInfo(resolveInfoList, expectedForwarder));
            }
        }
    }

    private ResolveInfo getIntentForwarder(Intent intent) {
        List<ResolveInfo> result = mContext.getPackageManager().queryIntentActivities(intent,
                PackageManager.MATCH_DEFAULT_ONLY);
        assertEquals(""Expect only one resolve result for "" + intent, 1, result.size());
        return result.get(0);
    }

    private boolean containsResolveInfo(List<ResolveInfo> list, ResolveInfo info) {
        for (ResolveInfo entry : list) {
            if (entry.activityInfo.packageName.equals(info.activityInfo.packageName)
                    && entry.activityInfo.name.equals(info.activityInfo.name)) {
                return true;
            }
        }
        return false;
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.carrierapi.cts.NetworkScanApiTest"	"werePreconditionsSatisfied"	"CtsCarrierApiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/carrierapi/src/android/carrierapi/cts/NetworkScanApiTest.java"	""	"/*
 *.
 */
package android.carrierapi.cts;

import static android.Manifest.permission.ACCESS_BACKGROUND_LOCATION;
import static android.Manifest.permission.ACCESS_FINE_LOCATION;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import static org.junit.Assert.fail;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.location.LocationManager;
import android.os.AsyncTask;
import android.os.Handler;
import android.os.HandlerThread;
import android.os.Message;
import android.os.Parcel;
import android.os.Process;
import android.os.UserHandle;
import android.telephony.AccessNetworkConstants;
import android.telephony.CellInfo;
import android.telephony.CellInfoGsm;
import android.telephony.CellInfoLte;
import android.telephony.CellInfoWcdma;
import android.telephony.NetworkScan;
import android.telephony.NetworkScanRequest;
import android.telephony.RadioAccessSpecifier;
import android.telephony.TelephonyManager;
import android.telephony.TelephonyScanManager;
import android.util.Log;

import androidx.test.InstrumentationRegistry;
import androidx.test.runner.AndroidJUnit4;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

/**
 * Unit tests for {@link TelephonyManager}'s network scan APIs.
 *
 * <p>Test using `atest CtsCarrierApiTestCases:NetworkScanApiTest` or `make cts -j64 && cts-tradefed
 * run cts -m CtsCarrierApiTestCases --test android.carrierapi.cts.NetworkScanApiTest`
 */
@RunWith(AndroidJUnit4.class)
public class NetworkScanApiTest extends BaseCarrierApiTest {
    private static final String TAG = ""NetworkScanApiTest"";

    private TelephonyManager mTelephonyManager;
    private int mNetworkScanStatus;
    private static final int EVENT_NETWORK_SCAN_START = 100;
    private static final int EVENT_NETWORK_SCAN_RESULTS = 200;
    private static final int EVENT_NETWORK_SCAN_RESTRICTED_RESULTS = 201;
    private static final int EVENT_NETWORK_SCAN_ERROR = 300;
    private static final int EVENT_NETWORK_SCAN_COMPLETED = 400;
    private static final int EVENT_SCAN_DENIED = 500;
    private List<CellInfo> mScanResults = null;
    private NetworkScanHandlerThread mTestHandlerThread;
    private Handler mHandler;
    private NetworkScan mNetworkScan;
    private NetworkScanRequest mNetworkScanRequest;
    private NetworkScanCallbackImpl mNetworkScanCallback;
    private static final int LOCATION_SETTING_CHANGE_WAIT_MS = 1000;
    private static final int MAX_CELLINFO_WAIT_MILLIS = 5000; // 5 seconds
    private static final int SCAN_SEARCH_TIME_SECONDS = 60;
    // Wait one second longer than the max scan search time to give the test time to receive the
    // results.
    private static final int MAX_INIT_WAIT_MS = (SCAN_SEARCH_TIME_SECONDS + 1) * 1000;
    private Object mLock = new Object();
    private boolean mReady;
    private int mErrorCode;
    /* All the following constants are used to construct NetworkScanRequest*/
    private static final int SCAN_TYPE = NetworkScanRequest.SCAN_TYPE_ONE_SHOT;
    private static final boolean INCREMENTAL_RESULTS = true;
    private static final int SEARCH_PERIODICITY_SEC = 5;
    private static final int MAX_SEARCH_TIME_SEC = 300;
    private static final int INCREMENTAL_RESULTS_PERIODICITY_SEC = 3;
    private static final ArrayList<String> MCC_MNC = new ArrayList<>();
    private static final RadioAccessSpecifier[] RADIO_ACCESS_SPECIFIERS = {
        new RadioAccessSpecifier(
                AccessNetworkConstants.AccessNetworkType.GERAN,
                null /* bands */,
                null /* channels */),
        new RadioAccessSpecifier(
                AccessNetworkConstants.AccessNetworkType.EUTRAN,
                null /* bands */,
                null /* channels */),
        new RadioAccessSpecifier(
                AccessNetworkConstants.AccessNetworkType.UTRAN,
                null /* bands */,
                null /* channels */)
    };

    // Needed because NETWORK_SCAN_PERMISSION is a systemapi
    public static final String NETWORK_SCAN_PERMISSION = ""android.permission.NETWORK_SCAN"";

    @Before
    public void setUp() throws Exception {
        mTelephonyManager = getContext().getSystemService(TelephonyManager.class);
        String selfPackageName = getContext().getPackageName();
        InstrumentationRegistry.getInstrumentation()
                .getUiAutomation()
                .grantRuntimePermission(selfPackageName, ACCESS_FINE_LOCATION);
        InstrumentationRegistry.getInstrumentation()
                .getUiAutomation()
                .grantRuntimePermission(selfPackageName, ACCESS_BACKGROUND_LOCATION);
        mTestHandlerThread = new NetworkScanHandlerThread(TAG);
        mTestHandlerThread.start();
    }

    @After
    public void tearDown() throws Exception {
        if (!werePreconditionsSatisfied()) return;

        // Revoking runtime permissions makes ActivityManager kill our process, so we don't do it,
        // as the test harness will eventually uninstall this APK after testing completes anyway, so
        // we aren't really leaking anything long-term.
        mTestHandlerThread.quit();
    }

    private void waitUntilReady() {
        synchronized (mLock) {
            try {
                mLock.wait(MAX_INIT_WAIT_MS);
            } catch (InterruptedException ie) {
            }

            assertWithMessage(""NetworkScanApiTest failed to initialize"").that(mReady).isTrue();
        }
    }

    private void setReady(boolean ready) {
        synchronized (mLock) {
            mReady = ready;
            mLock.notifyAll();
        }
    }

    private class NetworkScanHandlerThread extends HandlerThread {

        public NetworkScanHandlerThread(String name) {
            super(name);
        }

        @Override
        public void onLooperPrepared() {
            /* create a custom handler for the Handler Thread */
            mHandler =
                    new Handler(mTestHandlerThread.getLooper()) {
                        @Override
                        public void handleMessage(Message msg) {
                            switch (msg.what) {
                                case EVENT_NETWORK_SCAN_START:
                                    Log.d(TAG, ""request network scan"");
                                    boolean useShellIdentity = (Boolean) msg.obj;
                                    if (useShellIdentity) {
                                        InstrumentationRegistry.getInstrumentation()
                                                .getUiAutomation()
                                                .adoptShellPermissionIdentity();
                                    }
                                    try {
                                        mNetworkScan =
                                                mTelephonyManager.requestNetworkScan(
                                                        mNetworkScanRequest,
                                                        AsyncTask.SERIAL_EXECUTOR,
                                                        mNetworkScanCallback);
                                        if (mNetworkScan == null) {
                                            mNetworkScanStatus = EVENT_SCAN_DENIED;
                                            setReady(true);
                                        }
                                    } catch (SecurityException e) {
                                        mNetworkScanStatus = EVENT_SCAN_DENIED;
                                        setReady(true);
                                    } finally {
                                        if (useShellIdentity) {
                                            InstrumentationRegistry.getInstrumentation()
                                                    .getUiAutomation()
                                                    .dropShellPermissionIdentity();
                                        }
                                    }
                                    break;
                                default:
                                    Log.d(TAG, ""Unknown Event "" + msg.what);
                            }
                        }
                    };
        }
    }

    private class NetworkScanCallbackImpl extends TelephonyScanManager.NetworkScanCallback {
        @Override
        public void onResults(List<CellInfo> results) {
            Log.d(TAG, ""onResults: "" + results.toString());
            mNetworkScanStatus = EVENT_NETWORK_SCAN_RESULTS;
            mScanResults = results;
        }

        @Override
        public void onComplete() {
            Log.d(TAG, ""onComplete"");
            mNetworkScanStatus = EVENT_NETWORK_SCAN_COMPLETED;
            setReady(true);
        }

        @Override
        public void onError(int error) {
            Log.d(TAG, ""onError: "" + String.valueOf(error));
            mNetworkScanStatus = EVENT_NETWORK_SCAN_ERROR;
            mErrorCode = error;
            setReady(true);
        }
    }

    private class CellInfoResultsCallback extends TelephonyManager.CellInfoCallback {
        public List<CellInfo> cellInfo;

        @Override
        public synchronized void onCellInfo(List<CellInfo> cellInfo) {
            this.cellInfo = cellInfo;
            notifyAll();
        }

        public synchronized void wait(int millis) throws InterruptedException {
            if (cellInfo == null) {
                super.wait(millis);
            }
        }
    }

    private List<RadioAccessSpecifier> getRadioAccessSpecifier(List<CellInfo> allCellInfo) {
        List<RadioAccessSpecifier> radioAccessSpecifier = new ArrayList<>();
        List<Integer> lteChannels = new ArrayList<>();
        List<Integer> wcdmaChannels = new ArrayList<>();
        List<Integer> gsmChannels = new ArrayList<>();
        for (int i = 0; i < allCellInfo.size(); i++) {
            CellInfo cellInfo = allCellInfo.get(i);
            if (cellInfo instanceof CellInfoLte) {
                lteChannels.add(((CellInfoLte) cellInfo).getCellIdentity().getEarfcn());
            } else if (cellInfo instanceof CellInfoWcdma) {
                wcdmaChannels.add(((CellInfoWcdma) cellInfo).getCellIdentity().getUarfcn());
            } else if (cellInfo instanceof CellInfoGsm) {
                gsmChannels.add(((CellInfoGsm) cellInfo).getCellIdentity().getArfcn());
            }
        }
        if (!lteChannels.isEmpty()) {
            Log.d(TAG, ""lte channels"" + lteChannels.toString());
            int ranLte = AccessNetworkConstants.AccessNetworkType.EUTRAN;
            radioAccessSpecifier.add(
                    new RadioAccessSpecifier(
                            ranLte,
                            null /* bands */,
                            lteChannels.stream().mapToInt(i -> i).toArray()));
        }
        if (!wcdmaChannels.isEmpty()) {
            Log.d(TAG, ""wcdma channels"" + wcdmaChannels.toString());
            int ranWcdma = AccessNetworkConstants.AccessNetworkType.UTRAN;
            radioAccessSpecifier.add(
                    new RadioAccessSpecifier(
                            ranWcdma,
                            null /* bands */,
                            wcdmaChannels.stream().mapToInt(i -> i).toArray()));
        }
        if (!gsmChannels.isEmpty()) {
            Log.d(TAG, ""gsm channels"" + gsmChannels.toString());
            int ranGsm = AccessNetworkConstants.AccessNetworkType.GERAN;
            radioAccessSpecifier.add(
                    new RadioAccessSpecifier(
                            ranGsm,
                            null /* bands */,
                            gsmChannels.stream().mapToInt(i -> i).toArray()));
        }
        return radioAccessSpecifier;
    }

    /** Tests that the device properly requests a network scan. */"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.launcherapps.simpleapp.SimpleActivityStartService"	"KeyguardDismissCallback"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/SimpleApp/src/com/android/cts/launcherapps/simpleapp/SimpleActivityStartService.java"	""	"public void test/*
 *.
 */

package com.android.cts.launcherapps.simpleapp;

import android.app.Activity;
import android.app.KeyguardManager;
import android.app.KeyguardManager.KeyguardDismissCallback;
import android.content.Intent;
import android.os.Bundle;
import android.os.Handler;
import android.util.Log;

/**
 * Test being able to start a service (with no background check restrictions) as soon as
 * an activity is created.
 */
public class SimpleActivityStartService extends Activity {
    private static final String TAG = ""SimpleActivityStartService"";

    public static String ACTION_SIMPLE_ACTIVITY_START_SERVICE_RESULT =
            ""com.android.cts.launcherapps.simpleapp.SimpleActivityStartService.RESULT"";

    @Override
    protected void onCreate(Bundle icicle) {
        super.onCreate(icicle);
        getSystemService(KeyguardManager.class).requestDismissKeyguard(this,
                new KeyguardDismissCallback() {
            @Override
            public void onDismissCancelled() {
                Log.i(TAG, ""onDismissCancelled"");
            }

            @Override
            public void onDismissError() {
                Log.i(TAG, ""onDismissError"");
            }

            @Override
            public void onDismissSucceeded() {
                Log.i(TAG, ""onDismissSucceeded"");
            }
        });
        // No matter if the dismiss was successful or not, continue the test after 2000ms
        (new Handler()).postDelayed(()-> {
            attemptStartService();
            finish();
        }, 2000);
    }

    void attemptStartService() {
        Log.i(TAG, ""attemptStartService"");
        Intent reply = new Intent(ACTION_SIMPLE_ACTIVITY_START_SERVICE_RESULT);
        reply.setFlags(Intent.FLAG_RECEIVER_FOREGROUND);
        Intent serviceIntent = getIntent().getParcelableExtra(""service"");
        try {
            startService(serviceIntent);
        } catch (IllegalStateException e) {
            reply.putExtra(""result"", Activity.RESULT_CANCELED);
            sendBroadcast(reply);
            return;
        }
        reply.putExtra(""result"", Activity.RESULT_FIRST_USER);
        sendBroadcast(reply);
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.managedprovisioning.CommandReceiverActivity"	"isKeyguardSecure"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/managedprovisioning/CommandReceiverActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.managedprovisioning;

import static android.app.admin.DevicePolicyManager.LOCK_TASK_FEATURE_HOME;
import static android.app.admin.DevicePolicyManager.MAKE_USER_EPHEMERAL;
import static android.app.admin.DevicePolicyManager.SKIP_SETUP_WIZARD;

import android.Manifest;
import android.app.Activity;
import android.app.KeyguardManager;
import android.app.PendingIntent;
import android.app.admin.DevicePolicyManager;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.ApplicationInfo;
import android.content.pm.PackageInstaller;
import android.content.pm.PackageManager;
import android.content.pm.ResolveInfo;
import android.graphics.BitmapFactory;
import android.net.ProxyInfo;
import android.os.Bundle;
import android.os.PersistableBundle;
import android.os.UserHandle;
import android.os.UserManager;
import android.provider.ContactsContract;
import android.provider.MediaStore;
import android.provider.Settings;
import android.util.Log;
import android.view.inputmethod.InputMethodInfo;
import android.view.inputmethod.InputMethodManager;
import android.widget.Toast;

import com.android.bedstead.dpmwrapper.TestAppSystemServiceFactory;
import com.android.cts.verifier.R;

import java.io.File;
import java.io.FileInputStream;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

public class CommandReceiverActivity extends Activity {
    private static final String TAG = ""CommandReceiverActivity"";

    public static final String ACTION_EXECUTE_COMMAND =
            ""com.android.cts.verifier.managedprovisioning.action.EXECUTE_COMMAND"";
    public static final String EXTRA_COMMAND =
            ""com.android.cts.verifier.managedprovisioning.extra.COMMAND"";

    public static final String COMMAND_SET_USER_RESTRICTION = ""set-user_restriction"";
    public static final String COMMAND_DISALLOW_KEYGUARD_UNREDACTED_NOTIFICATIONS =
            ""disallow-keyguard-unredacted-notifications"";
    public static final String COMMAND_SET_AUTO_TIME_REQUIRED = ""set-auto-time-required"";
    public static final String COMMAND_SET_GLOBAL_SETTING =
            ""set-global-setting"";
    public static final String COMMAND_SET_MAXIMUM_TO_LOCK = ""set-maximum-time-to-lock"";
    public static final String COMMAND_SET_KEYGUARD_DISABLED = ""set-keyguard-disabled"";
    public static final String COMMAND_SET_LOCK_SCREEN_INFO = ""set-lock-screen-info"";
    public static final String COMMAND_SET_STATUSBAR_DISABLED = ""set-statusbar-disabled"";
    public static final String COMMAND_SET_LOCK_TASK_FEATURES = ""set-lock-task-features"";
    public static final String COMMAND_ALLOW_ONLY_SYSTEM_INPUT_METHODS =
            ""allow-only-system-input-methods"";
    public static final String COMMAND_ALLOW_ONLY_SYSTEM_ACCESSIBILITY_SERVICES =
            ""allow-only-system-accessibility-services"";
    public static final String COMMAND_CLEAR_POLICIES = ""clear-policies"";
    public static final String COMMAND_REMOVE_DEVICE_OWNER = ""remove-device-owner"";
    public static final String COMMAND_REQUEST_BUGREPORT = ""request-bugreport"";
    public static final String COMMAND_SET_USER_ICON = ""set-user-icon"";
    public static final String COMMAND_RETRIEVE_NETWORK_LOGS = ""retrieve-network-logs"";
    public static final String COMMAND_RETRIEVE_SECURITY_LOGS = ""retrieve-security-logs"";
    public static final String COMMAND_SET_ORGANIZATION_NAME = ""set-organization-name"";
    public static final String COMMAND_ENABLE_NETWORK_LOGGING = ""enable-network-logging"";
    public static final String COMMAND_DISABLE_NETWORK_LOGGING = ""disable-network-logging"";
    public static final String COMMAND_INSTALL_HELPER_PACKAGE = ""install-helper-package"";
    public static final String COMMAND_UNINSTALL_HELPER_PACKAGE = ""uninstall-helper-package"";
    public static final String COMMAND_SET_PERMISSION_GRANT_STATE = ""set-permission-grant-state"";
    public static final String COMMAND_ADD_PERSISTENT_PREFERRED_ACTIVITIES =
            ""add-persistent-preferred-activities"";
    public static final String COMMAND_CLEAR_PERSISTENT_PREFERRED_ACTIVITIES =
            ""clear-persistent-preferred-activities"";
    public static final String COMMAND_CREATE_MANAGED_PROFILE = ""create-managed-profile"";
    public static final String COMMAND_REMOVE_MANAGED_PROFILE = ""remove-managed-profile"";
    public static final String COMMAND_SET_ALWAYS_ON_VPN = ""set-always-on-vpn"";
    public static final String COMMAND_CLEAR_ALWAYS_ON_VPN = ""clear-always-on-vpn"";
    public static final String COMMAND_SET_GLOBAL_HTTP_PROXY = ""set-global-http-proxy"";
    public static final String COMMAND_CLEAR_GLOBAL_HTTP_PROXY = ""clear-global-http-proxy"";
    public static final String COMMAND_INSTALL_CA_CERT = ""install-ca-cert"";
    public static final String COMMAND_CLEAR_CA_CERT = ""clear-ca-cert"";
    public static final String COMMAND_SET_MAXIMUM_PASSWORD_ATTEMPTS =
            ""set-maximum-password-attempts"";
    public static final String COMMAND_CLEAR_MAXIMUM_PASSWORD_ATTEMPTS =
            ""clear-maximum-password-attempts"";
    public static final String COMMAND_SET_DEFAULT_IME = ""set-default-ime"";
    public static final String COMMAND_CLEAR_DEFAULT_IME = ""clear-default-ime"";
    public static final String COMMAND_CREATE_MANAGED_USER = ""create-managed-user"";
    public static final String COMMAND_CREATE_MANAGED_USER_WITHOUT_SETUP =
            ""create-managed-user-without-setup"";
    public static final String COMMAND_REMOVE_SECONDARY_USERS = ""remove-secondary-users"";
    public static final String COMMAND_WITH_USER_SWITCHER_MESSAGE = ""with-user-switcher-message"";
    public static final String COMMAND_WITHOUT_USER_SWITCHER_MESSAGE =
            ""without-user-switcher-message"";
    public static final String COMMAND_ENABLE_LOGOUT = ""enable-logout"";
    public static final String COMMAND_DISABLE_USB_DATA_SIGNALING = ""disable-usb-data-signaling"";
    public static final String COMMAND_ENABLE_USB_DATA_SIGNALING = ""enable-usb-data-signaling"";
    public static final String COMMAND_SET_REQUIRED_PASSWORD_COMPLEXITY =
            ""set-required-password-complexity"";

    public static final String EXTRA_USER_RESTRICTION =
            ""com.android.cts.verifier.managedprovisioning.extra.USER_RESTRICTION"";
    public static final String EXTRA_USE_CURRENT_USER_DPM =
            ""com.android.cts.verifier.managedprovisioning.extra.USE_CURRENT_USER_DPM"";
    public static final String EXTRA_SETTING =
            ""com.android.cts.verifier.managedprovisioning.extra.SETTING"";
    // This extra can be used along with a command extra to set policy to
    // specify if that policy is enforced or not.
    public static final String EXTRA_ENFORCED =
            ""com.android.cts.verifier.managedprovisioning.extra.ENFORCED"";
    public static final String EXTRA_VALUE =
            ""com.android.cts.verifier.managedprovisioning.extra.VALUE"";
    public static final String EXTRA_ORGANIZATION_NAME =
            ""com.android.cts.verifier.managedprovisioning.extra.ORGANIZATION_NAME"";
    public static final String EXTRA_PERMISSION =
            ""com.android.cts.verifier.managedprovisioning.extra.PERMISSION"";
    public static final String EXTRA_GRANT_STATE =
            ""com.android.cts.verifier.managedprovisioning.extra.GRANT_STATE"";

    // We care about installing and uninstalling only. It does not matter what apk is used.
    // NotificationBot.apk is a good choice because it comes bundled with the CTS verifier.
    protected static final String HELPER_APP_LOCATION = ""/sdcard/NotificationBot.apk"";
    protected static final String HELPER_APP_PKG = ""com.android.cts.robot"";

    public static final String ACTION_INSTALL_COMPLETE =
            ""com.android.cts.verifier.managedprovisioning.action.ACTION_INSTALL_COMPLETE"";
    public static final String ACTION_UNINSTALL_COMPLETE =
            ""com.android.cts.verifier.managedprovisioning.action.ACTION_UNINSTALL_COMPLETE"";

    /*
     * The CA cert below is the content of cacert.pem as generated by:
     *
     * openssl req -new -x509 -days 3650 -extensions v3_ca -keyout cakey.pem -out cacert.pem
     */
    private static final String TEST_CA =
            ""-----BEGIN CERTIFICATE-----\n"" +
            ""MIIDXTCCAkWgAwIBAgIJAK9Tl/F9V8kSMA0GCSqGSIb3DQEBCwUAMEUxCzAJBgNV\n"" +
            ""BAYTAkFVMRMwEQYDVQQIDApTb21lLVN0YXRlMSEwHwYDVQQKDBhJbnRlcm5ldCBX\n"" +
            ""aWRnaXRzIFB0eSBMdGQwHhcNMTUwMzA2MTczMjExWhcNMjUwMzAzMTczMjExWjBF\n"" +
            ""MQswCQYDVQQGEwJBVTETMBEGA1UECAwKU29tZS1TdGF0ZTEhMB8GA1UECgwYSW50\n"" +
            ""ZXJuZXQgV2lkZ2l0cyBQdHkgTHRkMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIB\n"" +
            ""CgKCAQEAvItOutsE75WBTgTyNAHt4JXQ3JoseaGqcC3WQij6vhrleWi5KJ0jh1/M\n"" +
            ""Rpry7Fajtwwb4t8VZa0NuM2h2YALv52w1xivql88zce/HU1y7XzbXhxis9o6SCI+\n"" +
            ""oVQSbPeXRgBPppFzBEh3ZqYTVhAqw451XhwdA4Aqs3wts7ddjwlUzyMdU44osCUg\n"" +
            ""kVg7lfPf9sTm5IoHVcfLSCWH5n6Nr9sH3o2ksyTwxuOAvsN11F/a0mmUoPciYPp+\n"" +
            ""q7DzQzdi7akRG601DZ4YVOwo6UITGvDyuAAdxl5isovUXqe6Jmz2/myTSpAKxGFs\n"" +
            ""jk9oRoG6WXWB1kni490GIPjJ1OceyQIDAQABo1AwTjAdBgNVHQ4EFgQUH1QIlPKL\n"" +
            ""p2OQ/AoLOjKvBW4zK3AwHwYDVR0jBBgwFoAUH1QIlPKLp2OQ/AoLOjKvBW4zK3Aw\n"" +
            ""DAYDVR0TBAUwAwEB/zANBgkqhkiG9w0BAQsFAAOCAQEAcMi4voMMJHeQLjtq8Oky\n"" +
            ""Azpyk8moDwgCd4llcGj7izOkIIFqq/lyqKdtykVKUWz2bSHO5cLrtaOCiBWVlaCV\n"" +
            ""DYAnnVLM8aqaA6hJDIfaGs4zmwz0dY8hVMFCuCBiLWuPfiYtbEmjHGSmpQTG6Qxn\n"" +
            ""ZJlaK5CZyt5pgh5EdNdvQmDEbKGmu0wpCq9qjZImwdyAul1t/B0DrsWApZMgZpeI\n"" +
            ""d2od0VBrCICB1K4p+C51D93xyQiva7xQcCne+TAnGNy9+gjQ/MyR8MRpwRLv5ikD\n"" +
            ""u0anJCN8pXo6IMglfMAsoton1J6o5/ae5uhC6caQU8bNUsCK570gpNfjkzo6rbP0\n"" +
            ""wQ==\n"" +
            ""-----END CERTIFICATE-----"";

    private ComponentName mAdmin;
    private DevicePolicyManager mDpm;
    private UserManager mUm;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        final Intent intent = getIntent();
        try {
            // On phones, the test runs on user 0, which is the Device Owner, but on headless system
            // user mode it runs in a different user.
            // Most DPM operations must be set on device owner user, but a few - like adding user
            // restrictions - must be set in the current user.

            boolean useCurrentUserDpm = intent.getBooleanExtra(EXTRA_USE_CURRENT_USER_DPM, false);
            mDpm = useCurrentUserDpm
                    ? getSystemService(DevicePolicyManager.class)
                    : TestAppSystemServiceFactory.getDevicePolicyManager(this,
                            DeviceAdminTestReceiver.class);

            mUm = (UserManager) getSystemService(Context.USER_SERVICE);
            mAdmin = DeviceAdminTestReceiver.getReceiverComponentName();
            final String command = getIntent().getStringExtra(EXTRA_COMMAND);
            Log.i(TAG, ""Command: "" + command);
            switch (command) {
                case COMMAND_SET_USER_RESTRICTION: {
                    String restrictionKey = intent.getStringExtra(EXTRA_USER_RESTRICTION);
                    boolean enforced = intent.getBooleanExtra(EXTRA_ENFORCED, false);
                    Log.i(TAG, ""Setting '"" + restrictionKey + ""'="" + enforced + "" using "" + mDpm
                            + "" on user "" + UserHandle.myUserId());
                    if (enforced) {
                        mDpm.addUserRestriction(mAdmin, restrictionKey);
                    } else {
                        mDpm.clearUserRestriction(mAdmin, restrictionKey);
                    }
                } break;
                case COMMAND_DISALLOW_KEYGUARD_UNREDACTED_NOTIFICATIONS: {
                    boolean enforced = intent.getBooleanExtra(EXTRA_ENFORCED, false);
                    mDpm.setKeyguardDisabledFeatures(mAdmin, enforced
                            ? DevicePolicyManager.KEYGUARD_DISABLE_UNREDACTED_NOTIFICATIONS
                            : 0);
                } break;
                case COMMAND_SET_AUTO_TIME_REQUIRED: {
                    mDpm.setAutoTimeRequired(mAdmin,
                            intent.getBooleanExtra(EXTRA_ENFORCED, false));
                    break;
                }
                case COMMAND_SET_LOCK_SCREEN_INFO: {
                    mDpm.setDeviceOwnerLockScreenInfo(mAdmin, intent.getStringExtra(EXTRA_VALUE));
                    break;
                }
                case COMMAND_SET_MAXIMUM_TO_LOCK: {
                    final long timeInSeconds = Long.parseLong(intent.getStringExtra(EXTRA_VALUE));
                    mDpm.setMaximumTimeToLock(mAdmin,
                            TimeUnit.SECONDS.toMillis(timeInSeconds) /* in milliseconds */);
                } break;
                case COMMAND_SET_KEYGUARD_DISABLED: {
                    boolean enforced = intent.getBooleanExtra(EXTRA_ENFORCED, false);
                    KeyguardManager km = this.getSystemService(KeyguardManager.class);
                    if (km.isKeyguardSecure()) {
                        Toast.makeText(this, getString(R.string.device_owner_lockscreen_secure),
                                Toast.LENGTH_SHORT).show();
                    } else {
                        mDpm.setKeyguardDisabled(mAdmin, enforced);
                    }
                } break;
                case COMMAND_SET_STATUSBAR_DISABLED: {
                    boolean enforced = intent.getBooleanExtra(EXTRA_ENFORCED, false);
                    mDpm.setStatusBarDisabled(mAdmin, enforced);
                } break;
                case COMMAND_SET_LOCK_TASK_FEATURES: {
                    int flags = intent.getIntExtra(EXTRA_VALUE,
                            DevicePolicyManager.LOCK_TASK_FEATURE_NONE);
                    mDpm.setLockTaskFeatures(mAdmin, flags);
                    // If feature HOME is used, we need to allow the current launcher
                    if ((flags & LOCK_TASK_FEATURE_HOME) != 0) {
                        mDpm.setLockTaskPackages(mAdmin,
                                new String[] {getPackageName(), getCurrentLauncherPackage()});
                    } else {
                        mDpm.setLockTaskPackages(mAdmin, new String[] {getPackageName()});
                    }
                } break;
                case COMMAND_ALLOW_ONLY_SYSTEM_INPUT_METHODS: {
                    boolean enforced = intent.getBooleanExtra(EXTRA_ENFORCED, false);
                    mDpm.setPermittedInputMethods(mAdmin,
                            enforced ? getEnabledNonSystemImes() : null);
                } break;
                case COMMAND_ALLOW_ONLY_SYSTEM_ACCESSIBILITY_SERVICES: {
                    boolean enforced = intent.getBooleanExtra(EXTRA_ENFORCED, false);
                    mDpm.setPermittedAccessibilityServices(mAdmin,
                            enforced ? new ArrayList() : null);
                } break;
                case COMMAND_SET_GLOBAL_SETTING: {
                    final String setting = intent.getStringExtra(EXTRA_SETTING);
                    final String value = intent.getStringExtra(EXTRA_VALUE);
                    mDpm.setGlobalSetting(mAdmin, setting, value);
                } break;
                case COMMAND_REMOVE_DEVICE_OWNER: {
                    if (!mDpm.isDeviceOwnerApp(getPackageName())) {
                        Log.e(TAG, COMMAND_REMOVE_DEVICE_OWNER + "": "" + getPackageName()
                                + "" is not DO for user "" + UserHandle.myUserId());
                        return;
                    }
                    clearAllPoliciesAndRestrictions();
                    mDpm.clearDeviceOwnerApp(getPackageName());

                    // TODO(b/179100903): temporarily removing PO, should be done automatically
                    if (UserManager.isHeadlessSystemUserMode()) {
                        Log.i(TAG, ""Disabling PO on user "" + UserHandle.myUserId());
                        DevicePolicyManager localDpm = getSystemService(DevicePolicyManager.class);
                        localDpm.clearProfileOwner(mAdmin);
                    }

                } break;
                case COMMAND_REQUEST_BUGREPORT: {
                    if (!mDpm.isDeviceOwnerApp(getPackageName())) {
                        return;
                    }
                    final boolean bugreportStarted = mDpm.requestBugreport(mAdmin);
                    if (!bugreportStarted) {
                        Utils.showBugreportNotification(this, getString(
                                R.string.bugreport_already_in_progress),
                                Utils.BUGREPORT_NOTIFICATION_ID);
                    }
                } break;
                case COMMAND_CLEAR_POLICIES: {
                    int mode = intent.getIntExtra(PolicyTransparencyTestListActivity.EXTRA_MODE,
                            PolicyTransparencyTestListActivity.MODE_DEVICE_OWNER);
                    if (mode == PolicyTransparencyTestListActivity.MODE_DEVICE_OWNER) {
                        if (!mDpm.isDeviceOwnerApp(getPackageName())) {
                            return;
                        }
                        clearAllPoliciesAndRestrictions();
                    } else if (mode == PolicyTransparencyTestListActivity.MODE_MANAGED_PROFILE
                            || mode == PolicyTransparencyTestListActivity.MODE_MANAGED_USER) {
                        if (!mDpm.isProfileOwnerApp(getPackageName())) {
                            return;
                        }
                        clearProfileOwnerRelatedPoliciesAndRestrictions(mode);
                    }
                    // No policies need to be cleared for COMP at the moment.
                } break;
                case COMMAND_SET_USER_ICON: {
                    if (!mDpm.isDeviceOwnerApp(getPackageName())) {
                        return;
                    }
                    int iconRes = intent.getIntExtra(EXTRA_VALUE,
                            com.android.cts.verifier.R.drawable.icon);
                    mDpm.setUserIcon(mAdmin, BitmapFactory.decodeResource(getResources(), iconRes));
                } break;
                case COMMAND_RETRIEVE_NETWORK_LOGS: {
                    if (!mDpm.isDeviceOwnerApp(getPackageName())) {
                        return;
                    }
                    mDpm.setNetworkLoggingEnabled(mAdmin, true);
                    mDpm.retrieveNetworkLogs(mAdmin, 0 /* batchToken */);
                    mDpm.setNetworkLoggingEnabled(mAdmin, false);
                } break;
                case COMMAND_RETRIEVE_SECURITY_LOGS: {
                    if (!mDpm.isDeviceOwnerApp(getPackageName())) {
                        return;
                    }
                    mDpm.setSecurityLoggingEnabled(mAdmin, true);
                    mDpm.retrieveSecurityLogs(mAdmin);
                    mDpm.setSecurityLoggingEnabled(mAdmin, false);
                } break;
                case COMMAND_SET_ORGANIZATION_NAME: {
                    if (!mDpm.isDeviceOwnerApp(getPackageName())) {
                        return;
                    }
                    mDpm.setOrganizationName(mAdmin,
                            intent.getStringExtra(EXTRA_ORGANIZATION_NAME));
                } break;
                case COMMAND_ENABLE_NETWORK_LOGGING: {
                    if (!mDpm.isDeviceOwnerApp(getPackageName())) {
                        return;
                    }
                    mDpm.setNetworkLoggingEnabled(mAdmin, true);
                } break;
                case COMMAND_DISABLE_NETWORK_LOGGING: {
                    if (!mDpm.isDeviceOwnerApp(getPackageName())) {
                        return;
                    }
                    mDpm.setNetworkLoggingEnabled(mAdmin, false);
                } break;
                case COMMAND_INSTALL_HELPER_PACKAGE: {
                    installHelperPackage();
                } break;
                case COMMAND_UNINSTALL_HELPER_PACKAGE: {
                    uninstallHelperPackage();
                } break;
                case COMMAND_SET_PERMISSION_GRANT_STATE: {
                    mDpm.setPermissionGrantState(mAdmin, getPackageName(),
                            intent.getStringExtra(EXTRA_PERMISSION),
                            intent.getIntExtra(EXTRA_GRANT_STATE,
                                    DevicePolicyManager.PERMISSION_GRANT_STATE_DEFAULT));
                } break;
                case COMMAND_ADD_PERSISTENT_PREFERRED_ACTIVITIES: {
                    final ComponentName componentName =
                            EnterprisePrivacyTestDefaultAppActivity.COMPONENT_NAME;
                    IntentFilter filter;
                    // Camera
                    filter = new IntentFilter();
                    filter.addAction(MediaStore.ACTION_IMAGE_CAPTURE);
                    filter.addAction(MediaStore.ACTION_VIDEO_CAPTURE);
                    mDpm.addPersistentPreferredActivity(mAdmin, filter, componentName);
                    // Map
                    filter = new IntentFilter();
                    filter.addAction(Intent.ACTION_VIEW);
                    filter.addDataScheme(""geo"");
                    mDpm.addPersistentPreferredActivity(mAdmin, filter, componentName);
                    // E-mail
                    filter = new IntentFilter();
                    filter.addAction(Intent.ACTION_SENDTO);
                    filter.addAction(Intent.ACTION_SEND);
                    filter.addAction(Intent.ACTION_SEND_MULTIPLE);
                    mDpm.addPersistentPreferredActivity(mAdmin, filter, componentName);
                    // Calendar
                    filter = new IntentFilter();
                    filter.addAction(Intent.ACTION_INSERT);
                    filter.addDataType(""vnd.android.cursor.dir/event"");
                    mDpm.addPersistentPreferredActivity(mAdmin, filter, componentName);
                    // Contacts
                    filter = new IntentFilter();
                    filter.addAction(Intent.ACTION_PICK);
                    filter.addDataType(ContactsContract.Contacts.CONTENT_TYPE);
                    mDpm.addPersistentPreferredActivity(mAdmin, filter, componentName);
                    // Dialer
                    filter = new IntentFilter();
                    filter.addAction(Intent.ACTION_DIAL);
                    filter.addAction(Intent.ACTION_CALL);
                    mDpm.addPersistentPreferredActivity(mAdmin, filter, componentName);
                    getPackageManager().setComponentEnabledSetting(componentName,
                            PackageManager.COMPONENT_ENABLED_STATE_ENABLED,
                            PackageManager.DONT_KILL_APP);
                } break;
                case COMMAND_CLEAR_PERSISTENT_PREFERRED_ACTIVITIES: {
                    mDpm.clearPackagePersistentPreferredActivities(mAdmin, getPackageName());
                    getPackageManager().setComponentEnabledSetting(
                            EnterprisePrivacyTestDefaultAppActivity.COMPONENT_NAME,
                            PackageManager.COMPONENT_ENABLED_STATE_DEFAULT,
                            PackageManager.DONT_KILL_APP);
                } break;
                case COMMAND_SET_ALWAYS_ON_VPN: {
                    if (!mDpm.isDeviceOwnerApp(getPackageName())) {
                        return;
                    }
                    mDpm.setAlwaysOnVpnPackage(mAdmin, getPackageName(),
                            false /* lockdownEnabled */);
                } break;
                case COMMAND_CLEAR_ALWAYS_ON_VPN: {
                    if (!mDpm.isDeviceOwnerApp(getPackageName())) {
                        return;
                    }
                    mDpm.setAlwaysOnVpnPackage(mAdmin, null /* vpnPackage */,
                            false /* lockdownEnabled */);
                } break;
                case COMMAND_SET_GLOBAL_HTTP_PROXY: {
                    if (!mDpm.isDeviceOwnerApp(getPackageName())) {
                        return;
                    }
                    mDpm.setRecommendedGlobalProxy(mAdmin,
                            ProxyInfo.buildDirectProxy(""example.com"", 123));
                } break;
                case COMMAND_CLEAR_GLOBAL_HTTP_PROXY: {
                    if (!mDpm.isDeviceOwnerApp(getPackageName())) {
                        return;
                    }
                    mDpm.setRecommendedGlobalProxy(mAdmin, null);
                } break;
                case COMMAND_INSTALL_CA_CERT: {
                    if (!mDpm.isDeviceOwnerApp(getPackageName())) {
                        return;
                    }
                    mDpm.installCaCert(mAdmin, TEST_CA.getBytes());
                } break;
                case COMMAND_CLEAR_CA_CERT: {
                    if (!mDpm.isDeviceOwnerApp(getPackageName())) {
                        return;
                    }
                    mDpm.uninstallCaCert(mAdmin, TEST_CA.getBytes());
                } break;
                case COMMAND_SET_MAXIMUM_PASSWORD_ATTEMPTS: {
                    if (!mDpm.isDeviceOwnerApp(getPackageName())) {
                        return;
                    }
                    mDpm.setMaximumFailedPasswordsForWipe(mAdmin, 100);
                } break;
                case COMMAND_CLEAR_MAXIMUM_PASSWORD_ATTEMPTS: {
                    if (!mDpm.isDeviceOwnerApp(getPackageName())) {
                        return;
                    }
                    mDpm.setMaximumFailedPasswordsForWipe(mAdmin, 0);
                } break;
                case COMMAND_SET_DEFAULT_IME: {
                    if (!mDpm.isDeviceOwnerApp(getPackageName())) {
                        return;
                    }
                    mDpm.setSecureSetting(mAdmin, Settings.Secure.DEFAULT_INPUT_METHOD,
                            getPackageName());
                } break;
                case COMMAND_CLEAR_DEFAULT_IME: {
                    if (!mDpm.isDeviceOwnerApp(getPackageName())) {
                        return;
                    }
                    mDpm.setSecureSetting(mAdmin, Settings.Secure.DEFAULT_INPUT_METHOD, null);
                } break;
                case COMMAND_CREATE_MANAGED_USER:{
                    if (!mDpm.isDeviceOwnerApp(getPackageName())) {
                        return;
                    }
                    PersistableBundle extras = new PersistableBundle();
                    extras.putBoolean(DeviceAdminTestReceiver.EXTRA_MANAGED_USER_TEST, true);
                    UserHandle userHandle = mDpm.createAndManageUser(mAdmin, ""managed user"", mAdmin,
                            extras,
                            SKIP_SETUP_WIZARD | MAKE_USER_EPHEMERAL);
                    mDpm.setAffiliationIds(mAdmin,
                            Collections.singleton(DeviceAdminTestReceiver.AFFILIATION_ID));
                    mDpm.startUserInBackground(mAdmin, userHandle);
                } break;
                case COMMAND_CREATE_MANAGED_USER_WITHOUT_SETUP:{
                    if (!mDpm.isDeviceOwnerApp(getPackageName())) {
                        return;
                    }
                    PersistableBundle extras = new PersistableBundle();
                    extras.putBoolean(DeviceAdminTestReceiver.EXTRA_MANAGED_USER_TEST, true);
                    mDpm.createAndManageUser(mAdmin, ""managed user"", mAdmin, extras, /* flags */ 0);
                } break;
                case COMMAND_REMOVE_SECONDARY_USERS: {
                    if (!mDpm.isDeviceOwnerApp(getPackageName())) {
                        return;
                    }
                    for (UserHandle secondaryUser : mDpm.getSecondaryUsers(mAdmin)) {
                        mDpm.removeUser(mAdmin, secondaryUser);
                    }
                } break;
                case COMMAND_WITH_USER_SWITCHER_MESSAGE: {
                    createAndSwitchUserWithMessage(""Start user session"", ""End user session"");
                } break;
                case COMMAND_WITHOUT_USER_SWITCHER_MESSAGE: {
                    createAndSwitchUserWithMessage(null, null);
                } break;
                case COMMAND_ENABLE_LOGOUT: {
                    if (!mDpm.isDeviceOwnerApp(getPackageName())) {
                        return;
                    }
                    mDpm.addUserRestriction(mAdmin, UserManager.DISALLOW_USER_SWITCH);
                    mDpm.setLogoutEnabled(mAdmin, true);
                    UserHandle userHandle = mDpm.createAndManageUser(mAdmin, ""managed user"", mAdmin,
                            null, SKIP_SETUP_WIZARD | MAKE_USER_EPHEMERAL);
                    mDpm.switchUser(mAdmin, userHandle);
                } break;
                case COMMAND_DISABLE_USB_DATA_SIGNALING: {
                    mDpm.setUsbDataSignalingEnabled(false);
                    break;
                }
                case COMMAND_ENABLE_USB_DATA_SIGNALING: {
                    mDpm.setUsbDataSignalingEnabled(true);
                    break;
                }
                case COMMAND_SET_REQUIRED_PASSWORD_COMPLEXITY: {
                    int complexity = intent.getIntExtra(EXTRA_VALUE,
                            DevicePolicyManager.PASSWORD_COMPLEXITY_NONE);
                    mDpm.setRequiredPasswordComplexity(complexity);
                }
            }
        } catch (Exception e) {
            Log.e(TAG, ""Failed to execute command: "" + intent, e);
        } finally {
            finish();
        }
    }

    private void installHelperPackage() throws Exception {
        LogAndSelfUnregisterBroadcastReceiver.register(this, ACTION_INSTALL_COMPLETE);
        final PackageInstaller packageInstaller = getPackageManager().getPackageInstaller();
        final PackageInstaller.Session session = packageInstaller.openSession(
                packageInstaller.createSession(new PackageInstaller.SessionParams(
                        PackageInstaller.SessionParams.MODE_FULL_INSTALL)));
        final File file = new File(HELPER_APP_LOCATION);
        Log.i(TAG, ""installing helper package from "" + file);
        final InputStream in = new FileInputStream(file);
        final OutputStream out = session.openWrite(""CommandReceiverActivity"", 0, file.length());
        final byte[] buffer = new byte[65536];
        int count;
        while ((count = in.read(buffer)) != -1) {
            out.write(buffer, 0, count);
        }
        session.fsync(out);
        in.close();
        out.close();
        session.commit(PendingIntent
                .getBroadcast(this, 0, new Intent(ACTION_INSTALL_COMPLETE),
                        PendingIntent.FLAG_MUTABLE_UNAUDITED)
                .getIntentSender());
    }

    private void uninstallHelperPackage() {
        LogAndSelfUnregisterBroadcastReceiver.register(this, ACTION_UNINSTALL_COMPLETE);
        PackageInstaller packageInstaller = getPackageManager().getPackageInstaller();
        Log.i(TAG, ""Uninstalling package "" + HELPER_APP_PKG + "" using "" + packageInstaller);
        try {
            packageInstaller.uninstall(HELPER_APP_PKG, PendingIntent.getBroadcast(this,
                    /* requestCode= */ 0, new Intent(ACTION_UNINSTALL_COMPLETE),
                    PendingIntent.FLAG_MUTABLE_UNAUDITED).getIntentSender());
        } catch (IllegalArgumentException e) {
            // The package is not installed: that's fine
        }
    }

    private void clearAllPoliciesAndRestrictions() throws Exception {
        clearProfileOwnerRelatedPolicies();
        clearPolicyTransparencyUserRestriction(
                PolicyTransparencyTestListActivity.MODE_DEVICE_OWNER);

        // There are a few user restrictions that are used, but not for policy transparency
        mDpm.clearUserRestriction(mAdmin, UserManager.DISALLOW_CONFIG_BLUETOOTH);
        mDpm.clearUserRestriction(mAdmin, UserManager.DISALLOW_CONFIG_VPN);
        mDpm.clearUserRestriction(mAdmin, UserManager.DISALLOW_DATA_ROAMING);
        mDpm.clearUserRestriction(mAdmin, UserManager.DISALLOW_USER_SWITCH);

        mDpm.setDeviceOwnerLockScreenInfo(mAdmin, null);
        mDpm.setKeyguardDisabled(mAdmin, false);
        mDpm.setAutoTimeRequired(mAdmin, false);
        mDpm.setStatusBarDisabled(mAdmin, false);
        mDpm.setOrganizationName(mAdmin, null);
        mDpm.setNetworkLoggingEnabled(mAdmin, false);
        mDpm.setSecurityLoggingEnabled(mAdmin, false);
        mDpm.setPermissionGrantState(mAdmin, getPackageName(),
                Manifest.permission.ACCESS_FINE_LOCATION,
                DevicePolicyManager.PERMISSION_GRANT_STATE_DEFAULT);
        mDpm.setPermissionGrantState(mAdmin, getPackageName(), Manifest.permission.RECORD_AUDIO,
                DevicePolicyManager.PERMISSION_GRANT_STATE_DEFAULT);
        mDpm.setPermissionGrantState(mAdmin, getPackageName(), Manifest.permission.CAMERA,
                DevicePolicyManager.PERMISSION_GRANT_STATE_DEFAULT);
        mDpm.clearPackagePersistentPreferredActivities(mAdmin, getPackageName());
        mDpm.setAlwaysOnVpnPackage(mAdmin, null, false);
        mDpm.setRecommendedGlobalProxy(mAdmin, null);
        mDpm.uninstallCaCert(mAdmin, TEST_CA.getBytes());
        mDpm.setMaximumFailedPasswordsForWipe(mAdmin, 0);
        mDpm.setSecureSetting(mAdmin, Settings.Secure.DEFAULT_INPUT_METHOD, null);
        mDpm.setStartUserSessionMessage(mAdmin, null);
        mDpm.setEndUserSessionMessage(mAdmin, null);
        mDpm.setLogoutEnabled(mAdmin, false);

        uninstallHelperPackage();

        // Must wait until package is uninstalled to reset affiliation ids, otherwise the package
        // cannot be removed on headless system user mode (as caller must be an affiliated PO)
        mDpm.setAffiliationIds(mAdmin, Collections.emptySet());

        removeManagedProfile();
        getPackageManager().setComponentEnabledSetting(
                EnterprisePrivacyTestDefaultAppActivity.COMPONENT_NAME,
                PackageManager.COMPONENT_ENABLED_STATE_DEFAULT,
                PackageManager.DONT_KILL_APP);
    }

    private void clearProfileOwnerRelatedPoliciesAndRestrictions(int mode) {
        clearPolicyTransparencyUserRestriction(mode);
        clearProfileOwnerRelatedPolicies();
    }

    private void clearProfileOwnerRelatedPolicies() {
        mDpm.setKeyguardDisabledFeatures(mAdmin, 0);
        mDpm.setPasswordQuality(mAdmin, 0);
        mDpm.setMaximumTimeToLock(mAdmin, 0);
        mDpm.setPermittedAccessibilityServices(mAdmin, null);
        mDpm.setPermittedInputMethods(mAdmin, null);
    }

    private void clearPolicyTransparencyUserRestriction(int mode) {
        for (String userRestriction : UserRestrictions.getUserRestrictionsForPolicyTransparency(
                mode)) {
            mDpm.clearUserRestriction(mAdmin, userRestriction);
        }
    }

    private void removeManagedProfile() {
        for (final UserHandle userHandle : mUm.getUserProfiles()) {
            mDpm.removeUser(mAdmin, userHandle);
        }
    }

    /**
     * Creates an intent to set the given user restriction using the device owner's {@code dpm}.
     */
    public static Intent createSetDeviceOwnerUserRestrictionIntent(String restriction,
            boolean enforced) {
        return createSetUserRestrictionIntent(restriction, enforced, /* currentUserDpm= */ false);
    }

    /**
     * Creates an intent to set the given user restriction using the current user's {@code dpm}.
     */
    public static Intent createSetCurrentUserRestrictionIntent(String restriction,
            boolean enforced) {
        return createSetUserRestrictionIntent(restriction, enforced, /* currentUserDpm= */ true);
    }

    private static Intent createSetUserRestrictionIntent(String restriction, boolean enforced,
            boolean forceCurrentUserDpm) {
        Intent intent = new Intent(ACTION_EXECUTE_COMMAND);
        if (forceCurrentUserDpm) {
            intent.putExtra(EXTRA_USE_CURRENT_USER_DPM, true);
        }
        return intent
                .putExtra(EXTRA_COMMAND, COMMAND_SET_USER_RESTRICTION)
                .putExtra(EXTRA_USER_RESTRICTION, restriction)
                .putExtra(EXTRA_ENFORCED, enforced);
    }

    private List<String> getEnabledNonSystemImes() {
        InputMethodManager inputMethodManager = getSystemService(InputMethodManager.class);
        final List<InputMethodInfo> inputMethods = inputMethodManager.getEnabledInputMethodList();
        return inputMethods.stream()
                .filter(inputMethodInfo -> !isSystemInputMethodInfo(inputMethodInfo))
                .map(inputMethodInfo -> inputMethodInfo.getPackageName())
                .filter(packageName -> !packageName.equals(getPackageName()))
                .distinct()
                .collect(Collectors.toList());
    }

    private boolean isSystemInputMethodInfo(InputMethodInfo inputMethodInfo) {
        final ApplicationInfo applicationInfo = inputMethodInfo.getServiceInfo().applicationInfo;
        return (applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0;
    }

    private void createAndSwitchUserWithMessage(String startUserSessionMessage,
            String endUserSessionMessage) {
        if (!mDpm.isDeviceOwnerApp(getPackageName())) {
            return;
        }
        mDpm.setStartUserSessionMessage(mAdmin, startUserSessionMessage);
        mDpm.setEndUserSessionMessage(mAdmin, endUserSessionMessage);
        mDpm.setAffiliationIds(mAdmin,
                Collections.singleton(DeviceAdminTestReceiver.AFFILIATION_ID));

        PersistableBundle extras = new PersistableBundle();
        extras.putBoolean(DeviceAdminTestReceiver.EXTRA_LOGOUT_ON_START, true);
        UserHandle userHandle = mDpm.createAndManageUser(mAdmin, ""managed user"", mAdmin,
                extras,
                SKIP_SETUP_WIZARD | MAKE_USER_EPHEMERAL);
        mDpm.switchUser(mAdmin, userHandle);
    }

    private String getCurrentLauncherPackage() {
        ResolveInfo resolveInfo = getPackageManager()
            .resolveActivity(new Intent(Intent.ACTION_MAIN)
                .addCategory(Intent.CATEGORY_HOME), PackageManager.MATCH_DEFAULT_ONLY);
        if (resolveInfo == null || resolveInfo.activityInfo == null) {
            return null;
        }

        return resolveInfo.activityInfo.packageName;
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.DeviceOwnerTest"	"testCreateAndManageUser_AddRestrictionSet"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceOwnerTest.java"	""	"public void testCreateAndManageUser_AddRestrictionSet() throws Exception {
        assumeCanCreateOneManagedUser();

        executeCreateAndManageUserTest(""testCreateAndManageUser_AddRestrictionSet"");
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.DeviceOwnerTest"	"testCreateAndManageUser_RemoveRestrictionSet"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceOwnerTest.java"	""	"public void testCreateAndManageUser_RemoveRestrictionSet() throws Exception {
        assumeCanCreateOneManagedUser();

        executeCreateAndManageUserTest(""testCreateAndManageUser_RemoveRestrictionSet"");
    }

    @FlakyTest(bugId = 126955083)"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.DeviceOwnerTest"	"testBluetoothRestriction"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceOwnerTest.java"	""	"public void testBluetoothRestriction() throws Exception {
        executeDeviceOwnerTest(""BluetoothRestrictionTest"");
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.DeviceOwnerTest"	"testDisallowFactoryReset"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceOwnerTest.java"	""	"public void testDisallowFactoryReset() throws Exception {
        int adminVersion = 24;
        // NOTE: the restriction must be set on primary user as it will launch SetPolicyActivity,
        // but the admin must be installed on USER_SYSTEM, otherwise wipeData() on headless system
        // user mode would wipe the current user (instead of factory resetting the device)
        changeUserRestrictionOrFail(""no_factory_reset"", true, mPrimaryUserId, DEVICE_OWNER_PKG);
        int adminUserId = USER_SYSTEM;

        String deviceAdminPkg = DeviceAdminHelper.getDeviceAdminApkPackage(adminVersion);
        String deviceAdminReceiver = DeviceAdminHelper.getAdminReceiverComponent(adminVersion);
        try {
            installAppAsUser(DeviceAdminHelper.getDeviceAdminApkFileName(adminVersion),
                    adminUserId);
            setDeviceAdmin(deviceAdminReceiver, adminUserId);
            runDeviceTestsAsUser(
                    deviceAdminPkg,
                    DeviceAdminHelper.getDeviceAdminJavaPackage() + "".WipeDataTest"",
                    ""testWipeDataThrowsSecurityException"", adminUserId);
        } finally {
            removeAdmin(deviceAdminReceiver, adminUserId);
            getDevice().uninstallPackage(deviceAdminPkg);
        }
    }

    // The backup service cannot be enabled if the backup feature is not supported.
    @RequiresAdditionalFeatures({FEATURE_BACKUP})"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.DeviceOwnerTest"	"testAirplaneModeRestriction"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceOwnerTest.java"	""	"public void testAirplaneModeRestriction() throws Exception {
        executeDeviceOwnerTest(""AirplaneModeRestrictionTest"");
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.DeviceOwnerTest"	"testSensorToggleRestriction"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceOwnerTest.java"	""	"public void testSensorToggleRestriction() throws Exception {
        executeDeviceOwnerTest(""SensorToggleRestrictionTest"");
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.alarmmanager.cts.ExactAlarmsTest"	"setExactAwiWithoutPermissionWithWhitelist"	"CtsAlarmManagerTestCases"	"/home/gpoor/cts-12-source/cts/tests/AlarmManager/src/android/alarmmanager/cts/ExactAlarmsTest.java"	""	"public void setExactAwiWithoutPermissionWithWhitelist() throws Exception {
        revokeAppOp();
        whitelistTestApp();
        final long now = SystemClock.elapsedRealtime();
        // This is the user whitelist, so the app should get unrestricted alarms.
        final int numAlarms = 100;   // Number much higher than any quota.
        for (int i = 0; i < numAlarms; i++) {
            final int id = mIdGenerator.nextInt();
            mAlarmManager.setExactAndAllowWhileIdle(AlarmManager.ELAPSED_REALTIME_WAKEUP, now,
                    getAlarmSender(id, false));
            assertTrue(""Alarm "" + id + "" not received"",
                    AlarmReceiver.waitForAlarm(id, DEFAULT_WAIT_FOR_SUCCESS));
        }
    }"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.alarmmanager.cts.ExactAlarmsTest"	"setExactAwiWithPermissionAndWhitelist"	"CtsAlarmManagerTestCases"	"/home/gpoor/cts-12-source/cts/tests/AlarmManager/src/android/alarmmanager/cts/ExactAlarmsTest.java"	""	"public void setExactAwiWithPermissionAndWhitelist() throws Exception {
        whitelistTestApp();
        final long now = SystemClock.elapsedRealtime();
        // The user whitelist takes precedence, so the app should get unrestricted alarms.
        final int numAlarms = 100;   // Number much higher than any quota.
        for (int i = 0; i < numAlarms; i++) {
            final int id = mIdGenerator.nextInt();
            mAlarmManager.setExactAndAllowWhileIdle(AlarmManager.ELAPSED_REALTIME_WAKEUP, now,
                    getAlarmSender(id, false));
            assertTrue(""Alarm "" + id + "" not received"",
                    AlarmReceiver.waitForAlarm(id, DEFAULT_WAIT_FOR_SUCCESS));
        }
    }

    private static void reclaimQuota(int quotaToReclaim) {
        final long eligibleAt = getNextEligibleTime(quotaToReclaim);
        long now;
        while ((now = SystemClock.elapsedRealtime()) < eligibleAt) {
            try {
                Thread.sleep(eligibleAt - now);
            } catch (InterruptedException e) {
                Log.e(TAG, ""Thread interrupted while reclaiming quota!"", e);
            }
        }
    }

    private static long getNextEligibleTime(int quotaToReclaim) {
        long t = AlarmReceiver.getNthLastAlarmTime(ALLOW_WHILE_IDLE_QUOTA - quotaToReclaim + 1);
        return t + ALLOW_WHILE_IDLE_WINDOW;
    }"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"test.java.com.android.queryable.queries.ClassQueryHelperTest"	"isTrue"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/queryable/src/test/java/com/android/queryable/queries/ClassQueryHelperTest.java"	""	"public void matches_noRestrictions_returnsTrue() {
        ClassQueryHelper<Queryable> classQueryHelper =
                new ClassQueryHelper<>(mQuery);

        assertThat(classQueryHelper.matches(CLASS_1_CLASS_INFO)).isTrue();
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.telecom.cts.ConferenceTest"	"testConferenceSetters"	"CtsTelecomTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/ConferenceTest.java"	""	"public void testConferenceSetters() {
        if (!mShouldTestTelecom) {
            return;
        }
        final Call conf = mInCallService.getLastConferenceCall();
        assertCallState(conf, Call.STATE_ACTIVE);

        placeAndVerifyCall();
        MockConnection newConnection = verifyConnectionForOutgoingCall(2);
        final Call newCall = mInCallService.getLastCall();

        ArrayList<Connection> connectionList = new ArrayList<>();
        connectionList.add(newConnection);
        ArrayList<Call> callList = new ArrayList<>();
        callList.add(newCall);

        assertFalse(conf.getDetails().can(Call.Details.CAPABILITY_MUTE));
        int capabilities = mConferenceObject.getConnectionCapabilities() |
                Connection.CAPABILITY_MUTE;
        mConferenceObject.setConnectionCapabilities(capabilities);
        assertCallCapability(conf, Call.Details.CAPABILITY_MUTE);

        assertFalse(conf.getConferenceableCalls().contains(newCall));
        mConferenceObject.setConferenceableConnections(connectionList);
        assertCallConferenceableList(conf, callList);

        // Consumed internally in Telecom; no verifiable manner to see the end point of this data
        // through public APIs.
        mConferenceObject.setConnectionTime(0);
        mConferenceObject.setConnectionStartElapsedRealtimeMillis(0);

        Bundle extras = new Bundle();
        extras.putString(TelecomManager.EXTRA_CALL_DISCONNECT_MESSAGE, ""Test"");
        assertFalse(conf.getDetails().getExtras().containsKey(
                TelecomManager.EXTRA_CALL_DISCONNECT_MESSAGE));
        mConferenceObject.setExtras(extras);
        assertCallExtras(conf, TelecomManager.EXTRA_CALL_DISCONNECT_MESSAGE, ""Test"");

        StatusHints hints = new StatusHints(""Test"", null, null);
        assertNull(conf.getDetails().getStatusHints());
        mConferenceObject.setStatusHints(hints);
        assertCallStatusHints(conf, hints);

        assertFalse(conf.getChildren().contains(newCall));
        mConferenceObject.addConnection(newConnection);
        assertCallChildrenContains(conf, newCall, true);

        assertTrue(conf.getChildren().contains(newCall));
        mConferenceObject.removeConnection(newConnection);
        assertCallChildrenContains(conf, newCall, false);

        assertVideoState(conf, VideoProfile.STATE_AUDIO_ONLY);
        final MockVideoProvider mockVideoProvider = mConnection1.getMockVideoProvider();
        mConferenceObject.setVideoProvider(mConnection1, mockVideoProvider);
        mConferenceObject.setVideoState(mConnection1, VideoProfile.STATE_BIDIRECTIONAL);
        assertVideoState(conf, VideoProfile.STATE_BIDIRECTIONAL);

        // Dialing state is unsupported for conference calls. so, the state remains active.
        mConferenceObject.setDialing();
        // just assert call state is not dialing, the state remains as previous one.
        assertTrue(conf.getState() != Call.STATE_DIALING);

        mConferenceObject.setRinging();
        assertCallState(conf, Call.STATE_RINGING);

        mConferenceObject.setOnHold();
        assertCallState(conf, Call.STATE_HOLDING);

        mConferenceObject.setActive();
        assertCallState(conf, Call.STATE_ACTIVE);

        mConferenceObject.setAddress(CONF_HANDLE, TelecomManager.PRESENTATION_ALLOWED);
        assertCallHandle(conf, CONF_HANDLE);
        // Handle presentation is set at same time as address; so no need to wait for it.
        assertEquals(TelecomManager.PRESENTATION_ALLOWED,
                conf.getDetails().getHandlePresentation());

        mConferenceObject.setAddress(null, TelecomManager.PRESENTATION_RESTRICTED);
        assertCallHandle(conf, null);
        // Handle presentation is set at same time as address; so no need to wait for it.
        assertEquals(TelecomManager.PRESENTATION_RESTRICTED,
                conf.getDetails().getHandlePresentation());

        mConferenceObject.setCallerDisplayName(TEST_CALLER_NAME,
                TelecomManager.PRESENTATION_ALLOWED);
        assertCallDisplayName(conf, TEST_CALLER_NAME);
        assertEquals(TelecomManager.PRESENTATION_ALLOWED,
                conf.getDetails().getCallerDisplayNamePresentation());

        mConferenceObject.setCallerDisplayName(null, TelecomManager.PRESENTATION_UNKNOWN);
        assertCallDisplayName(conf, null);
        assertEquals(TelecomManager.PRESENTATION_UNKNOWN,
                conf.getDetails().getCallerDisplayNamePresentation());

        // Expect no change; not calling withe correct permission.
        mConferenceObject.setConferenceState(false);
        assertCallProperties(conf, Call.Details.PROPERTY_CONFERENCE);

        InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .adoptShellPermissionIdentity(""android.permission.MODIFY_PHONE_STATE"");
        try {
            mConferenceObject.setConferenceState(false);
            assertDoesNotHaveCallProperties(conf, Call.Details.PROPERTY_CONFERENCE);

            mConferenceObject.setConferenceState(true);
            assertCallProperties(conf, Call.Details.PROPERTY_CONFERENCE);
        } finally {
            InstrumentationRegistry.getInstrumentation().getUiAutomation()
                    .dropShellPermissionIdentity();
        }

        assertFalse(mConferenceObject.isRingbackRequested());
        mConferenceObject.setRingbackRequested(true);
        assertTrue(mConferenceObject.isRingbackRequested());

        mConferenceObject.setDisconnected(new DisconnectCause(DisconnectCause.LOCAL));
        assertCallState(conf, Call.STATE_DISCONNECTED);

        // Destroy state is unsupported for conference calls. so, the state remains active.
        mConferenceObject.destroy();
        assertCallState(conf, Call.STATE_DISCONNECTED);
    }

    /**
     * Tests end to end propagation of the {@link Conference} properties to the associated
     * {@link Call}.
     */"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.userrestrictions.BaseUserRestrictionsTest"	"assertClearDefaultRestrictions"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/userrestrictions/BaseUserRestrictionsTest.java"	""	"public void test/*
 *.
 */
package com.android.cts.deviceandprofileowner.userrestrictions;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.Process;
import android.os.UserHandle;
import android.os.UserManager;

import com.android.compatibility.common.util.ShellIdentityUtils;
import com.android.cts.deviceandprofileowner.BaseDeviceAdminTest;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

public abstract class BaseUserRestrictionsTest extends BaseDeviceAdminTest {
    protected static final String[] ALL_USER_RESTRICTIONS = new String[]{
            UserManager.DISALLOW_CONFIG_WIFI,
            UserManager.DISALLOW_MODIFY_ACCOUNTS,
            UserManager.DISALLOW_INSTALL_APPS,
            UserManager.DISALLOW_UNINSTALL_APPS,
            UserManager.DISALLOW_SHARE_LOCATION,
            UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES,
            UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES_GLOBALLY,
            UserManager.DISALLOW_CONFIG_BLUETOOTH,
            UserManager.DISALLOW_USB_FILE_TRANSFER,
            UserManager.DISALLOW_CONFIG_CREDENTIALS,
            UserManager.DISALLOW_REMOVE_USER,
            UserManager.DISALLOW_DEBUGGING_FEATURES,
            UserManager.DISALLOW_CONFIG_VPN,
            UserManager.DISALLOW_CONFIG_TETHERING,
            UserManager.DISALLOW_NETWORK_RESET,
            UserManager.DISALLOW_FACTORY_RESET,
            UserManager.DISALLOW_ADD_USER,
            UserManager.ENSURE_VERIFY_APPS,
            UserManager.DISALLOW_CONFIG_CELL_BROADCASTS,
            UserManager.DISALLOW_CONFIG_MOBILE_NETWORKS,
            UserManager.DISALLOW_APPS_CONTROL,
            UserManager.DISALLOW_MOUNT_PHYSICAL_MEDIA,
            UserManager.DISALLOW_UNMUTE_MICROPHONE,
            UserManager.DISALLOW_ADJUST_VOLUME,
            UserManager.DISALLOW_OUTGOING_CALLS,
            UserManager.DISALLOW_SMS,
            UserManager.DISALLOW_FUN,
            UserManager.DISALLOW_CREATE_WINDOWS,
            UserManager.DISALLOW_SYSTEM_ERROR_DIALOGS,
            UserManager.DISALLOW_CROSS_PROFILE_COPY_PASTE,
            UserManager.DISALLOW_OUTGOING_BEAM,
            UserManager.DISALLOW_SAFE_BOOT,
            UserManager.ALLOW_PARENT_PROFILE_APP_LINKING,
            UserManager.DISALLOW_DATA_ROAMING,
            UserManager.DISALLOW_SET_USER_ICON,
            UserManager.DISALLOW_BLUETOOTH,
            UserManager.DISALLOW_BLUETOOTH_SHARING,
            UserManager.DISALLOW_CAMERA_TOGGLE,
            UserManager.DISALLOW_MICROPHONE_TOGGLE,
    };

    /**
     * Restrictions that affect all users when DO sets.
     */
    protected static final String[] DO_GLOBAL_RESTRICTIONS = new String[] {
            UserManager.DISALLOW_USB_FILE_TRANSFER,
            UserManager.DISALLOW_CONFIG_TETHERING,
            UserManager.DISALLOW_NETWORK_RESET,
            UserManager.DISALLOW_FACTORY_RESET,
            UserManager.DISALLOW_ADD_USER,
            UserManager.DISALLOW_CONFIG_CELL_BROADCASTS,
            UserManager.DISALLOW_CONFIG_MOBILE_NETWORKS,
            UserManager.DISALLOW_MOUNT_PHYSICAL_MEDIA,
            UserManager.DISALLOW_SMS,
            UserManager.DISALLOW_FUN,
            UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES_GLOBALLY,
            UserManager.DISALLOW_SAFE_BOOT,
            UserManager.DISALLOW_CREATE_WINDOWS,
            UserManager.DISALLOW_BLUETOOTH,
            // UserManager.DISALLOW_DATA_ROAMING, // Not set during CTS
            UserManager.DISALLOW_CAMERA_TOGGLE,
            UserManager.DISALLOW_MICROPHONE_TOGGLE,

            // PO can set them too, but when DO sets them, they're global.
            UserManager.DISALLOW_ADJUST_VOLUME,
            UserManager.DISALLOW_UNMUTE_MICROPHONE,
            UserManager.DISALLOW_SYSTEM_ERROR_DIALOGS
    };

    public static final String[] HIDDEN_AND_PROHIBITED = new String[] {
            ""no_record_audio"",
            ""no_wallpaper"",
            ""no_oem_unlock""
    };

    protected void assertLayeredRestriction(String restriction, boolean expected) {
        assertEquals(""Restriction "" + restriction + "": expected="" + expected,
                expected, mUserManager.hasUserRestriction(restriction));
    }

    protected void assertOwnerRestriction(String restriction, boolean expected) {
        assertEquals(""Restriction "" + restriction + "": expected="" + expected,
                expected, mDevicePolicyManager.getUserRestrictions(ADMIN_RECEIVER_COMPONENT)
                        .getBoolean(restriction));
    }

    /** Returns whether {@link UserManager} itself has applied the given restriction to the user. */
    protected boolean hasBaseUserRestriction(String restriction, UserHandle userHandle) {
        return ShellIdentityUtils.invokeMethodWithShellPermissions(mUserManager,
                (um) -> um.hasBaseUserRestriction(restriction, userHandle));
    }

    /**
     * Check that {@link UserManager#hasUserRestriction} gives the expected results for each
     * restriction.
     * @param expected the list of user restrictions that are expected to have been applied due
     *                 to DO/PO
     */
    protected void assertRestrictions(Set<String> expected) {
        final UserHandle userHandle = Process.myUserHandle();
        for (String r : ALL_USER_RESTRICTIONS) {
            assertLayeredRestriction(r,
                    expected.contains(r) || hasBaseUserRestriction(r, userHandle));
        }
    }

    /**
     * Test that the given restriction can be set and cleared, then leave it set again.
     */
    protected void assertSetClearUserRestriction(String restriction) {
        final boolean hadRestriction = mUserManager.hasUserRestriction(restriction);

        assertOwnerRestriction(restriction, false);

        // Set.  Shouldn't throw.
        mDevicePolicyManager.addUserRestriction(ADMIN_RECEIVER_COMPONENT, restriction);

        assertOwnerRestriction(restriction, true);
        assertLayeredRestriction(restriction, true);

        // Then clear.
        assertClearUserRestriction(restriction);

        assertLayeredRestriction(restriction, hadRestriction);

        // Then set again.
        mDevicePolicyManager.addUserRestriction(ADMIN_RECEIVER_COMPONENT, restriction);
    }

    /**
     * Test that the given restriction can be cleared.  (and leave it cleared.)
     */
    protected void assertClearUserRestriction(String restriction) {
        mDevicePolicyManager.clearUserRestriction(ADMIN_RECEIVER_COMPONENT, restriction);

        assertOwnerRestriction(restriction, false);
    }

    protected void assertClearDefaultRestrictions() {
        for (String restriction : getDefaultEnabledRestrictions()) {
            assertClearUserRestriction(restriction);
        }
    }

    /**
     * Test that the given restriction *cannot* be set (or clear).
     */
    protected void assertCannotSetUserRestriction(String restriction) {
        final boolean hadRestriction = mUserManager.hasUserRestriction(restriction);

        assertOwnerRestriction(restriction, false);

        // Set should fail.
        try {
            mDevicePolicyManager.addUserRestriction(ADMIN_RECEIVER_COMPONENT, restriction);
            fail(""Restriction="" + restriction);
        } catch (SecurityException e) {
            assertTrue(""Restriction="" + restriction + "" Message was: "" + e.getMessage(),
                    e.getMessage().contains(""cannot set user restriction""));
        }

        // Shouldn't have changed.
        assertOwnerRestriction(restriction, false);
        assertLayeredRestriction(restriction, hadRestriction);

        // Clear should fail too.
        try {
            mDevicePolicyManager.clearUserRestriction(ADMIN_RECEIVER_COMPONENT, restriction);
            fail(""Restriction="" + restriction);
        } catch (SecurityException e) {
            assertTrue(""Restriction="" + restriction + "" Message was: "" + e.getMessage(),
                    e.getMessage().contains(""cannot set user restriction""));
        }

        // Shouldn't have changed.
        assertOwnerRestriction(restriction, false);
        assertLayeredRestriction(restriction, hadRestriction);
    }

    /** For {@link #testSetAllRestrictions} */
    protected abstract String[] getAllowedRestrictions();

    /** For {@link #testSetAllRestrictions} */
    protected abstract String[] getDisallowedRestrictions();

    /** For {@link #testDefaultRestrictions()} */
    protected abstract String[] getDefaultEnabledRestrictions();

    /**
     * Test restrictions that should be enabled by default
     */"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.userrestrictions.BaseUserRestrictionsTest"	"testDefaultRestrictions"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/userrestrictions/BaseUserRestrictionsTest.java"	""	"public void testDefaultRestrictions() {
        for (String restriction : getDefaultEnabledRestrictions()) {
            assertOwnerRestriction(restriction, true);
        }

        Set<String> offByDefaultRestrictions = new HashSet<>(Arrays.asList(ALL_USER_RESTRICTIONS));
        offByDefaultRestrictions.removeAll(
                new HashSet<>(Arrays.asList(getDefaultEnabledRestrictions())));
        for (String restriction : offByDefaultRestrictions) {
            assertOwnerRestriction(restriction, false);
        }
    }

    /**
     * Set only one restriction, and make sure only that's set, and then clear it.
     */"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.userrestrictions.BaseUserRestrictionsTest"	"testSetAllRestrictionsIndividually"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/userrestrictions/BaseUserRestrictionsTest.java"	""	"public void testSetAllRestrictionsIndividually() {
        assertClearDefaultRestrictions();
        for (String r : getAllowedRestrictions()) {
            // Set it.
            assertSetClearUserRestriction(r);

            assertRestrictions(new HashSet<>(Arrays.asList(new String[]{r})));

            // Then clear it.
            assertClearUserRestriction(r);
        }
    }

    /**
     * Make sure all allowed restrictions can be set, and the others can't.
     */"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.userrestrictions.BaseUserRestrictionsTest"	"testSetAllRestrictions"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/userrestrictions/BaseUserRestrictionsTest.java"	""	"public void testSetAllRestrictions() {
        assertClearDefaultRestrictions();
        for (String r : getAllowedRestrictions()) {
            assertSetClearUserRestriction(r);
        }
        for (String r : getDisallowedRestrictions()) {
            assertCannotSetUserRestriction(r);
        }
        for (String r : HIDDEN_AND_PROHIBITED) {
            assertCannotSetUserRestriction(r);
        }
    }

    /**
     * Clear all allowed restrictions.
     */"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.userrestrictions.BaseUserRestrictionsTest"	"testClearAllRestrictions"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/userrestrictions/BaseUserRestrictionsTest.java"	""	"public void testClearAllRestrictions() {
        for (String r : getAllowedRestrictions()) {
            assertClearUserRestriction(r);
        }
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.userrestrictions.BaseUserRestrictionsTest"	"testBroadcast"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/userrestrictions/BaseUserRestrictionsTest.java"	""	"public void testBroadcast() throws Exception {
        final CountDownLatch latch = new CountDownLatch(1);
        final IntentFilter filter = new IntentFilter(UserManager.ACTION_USER_RESTRICTIONS_CHANGED);
        mContext.registerReceiver(new BroadcastReceiver() {
            @Override
            public void onReceive(Context context, Intent intent) {
                latch.countDown();
            }
        }, filter);

        final String restriction = UserManager.DISALLOW_CONFIG_WIFI;
        mDevicePolicyManager.addUserRestriction(ADMIN_RECEIVER_COMPONENT, restriction);

        assertTrue(""Didn't receive broadcast"", latch.await(120, TimeUnit.SECONDS));

        mDevicePolicyManager.clearUserRestriction(ADMIN_RECEIVER_COMPONENT, restriction);
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.app.cts.android.app.cts.tools.ServiceProcessController"	"register"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/android/app/cts/tools/ServiceProcessController.java"	""	"public void test/*
 *.
 */

package android.app.cts.android.app.cts.tools;

import android.app.ActivityManager;
import android.app.Instrumentation;
import android.content.Context;
import android.content.Intent;
import android.content.pm.ApplicationInfo;
import android.content.pm.PackageManager;
import android.os.IBinder;
import android.os.Parcel;
import android.os.RemoteException;
import android.os.UserHandle;

import androidx.test.InstrumentationRegistry;

import com.android.compatibility.common.util.SystemUtil;

import java.io.IOException;

/**
 * Helper for monitoring and controlling the state of a process under test.
 * Primarily currently a convenience for cleanly killing a process and waiting
 * for it to entirely disappear from the system.
 */
public final class ServiceProcessController {
    final Context mContext;
    final Instrumentation mInstrumentation;
    final String mMyPackageName;
    final Intent[] mServiceIntents;
    final String mServicePackage;
    final long mDefaultWaitTime;

    final ActivityManager mAm;
    final Parcel mData;
    final ServiceConnectionHandler[] mConnections;
    final int mUid;
    final int mUserId;
    final UidImportanceListener mUidForegroundListener;
    final UidImportanceListener mUidGoneListener;
    final WatchUidRunner mUidWatcher;

    public ServiceProcessController(Context context, Instrumentation instrumentation,
            String myPackageName, Intent[] serviceIntents)
            throws IOException, PackageManager.NameNotFoundException {
        this(context, instrumentation, myPackageName, serviceIntents, 5*1000);
    }

    public ServiceProcessController(Context context, Instrumentation instrumentation,
            String myPackageName, Intent[] serviceIntents, long defaultWaitTime)
            throws IOException, PackageManager.NameNotFoundException {
        mContext = context;
        mInstrumentation = instrumentation;
        mMyPackageName = myPackageName;
        mServiceIntents = serviceIntents;
        mServicePackage = mServiceIntents[0].getComponent().getPackageName();
        mDefaultWaitTime = defaultWaitTime;

        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                mMyPackageName, android.Manifest.permission.PACKAGE_USAGE_STATS);
        /*
        Log.d(""XXXX"", ""Invoke: "" + cmd);
        Log.d(""XXXX"", ""Result: "" + result);
        Log.d(""XXXX"", SystemUtil.runShellCommand(getInstrumentation(), ""dumpsys package ""
                + STUB_PACKAGE_NAME));
        */

        mAm = mContext.getSystemService(ActivityManager.class);
        mData = Parcel.obtain();
        mConnections = new ServiceConnectionHandler[serviceIntents.length];
        for (int i=0; i<serviceIntents.length; i++) {
            mConnections[i] = new ServiceConnectionHandler(mContext, serviceIntents[i],
                    mDefaultWaitTime);
        }

        ApplicationInfo appInfo = mContext.getPackageManager().getApplicationInfo(
                mServicePackage, 0);
        mUid = appInfo.uid;
        mUserId = UserHandle.getUserId(mUid);

        mUidForegroundListener = new UidImportanceListener(mContext, appInfo.uid,
                ActivityManager.RunningAppProcessInfo.IMPORTANCE_SERVICE, mDefaultWaitTime);
        mUidForegroundListener.register();
        mUidGoneListener = new UidImportanceListener(mContext, appInfo.uid,
                ActivityManager.RunningAppProcessInfo.IMPORTANCE_EMPTY, mDefaultWaitTime);
        mUidGoneListener.register();

        mUidWatcher = new WatchUidRunner(instrumentation, appInfo.uid, mDefaultWaitTime);
    }

    public void denyBackgroundOp() throws IOException {
        denyBackgroundOp(mDefaultWaitTime);
    }

    public void denyBackgroundOp(long timeout) throws IOException {
        String cmd = ""appops set --user "" + mUserId + "" ""
                + mServicePackage + "" RUN_IN_BACKGROUND deny"";
        String result = SystemUtil.runShellCommand(mInstrumentation, cmd);

        // This is a side-effect of the app op command.
        mUidWatcher.expect(WatchUidRunner.CMD_IDLE, null, timeout);
        mUidWatcher.expect(WatchUidRunner.CMD_PROCSTATE, ""NONE"", timeout);
    }

    public void allowBackgroundOp() throws IOException {
        String cmd = ""appops set --user "" + mUserId + "" ""
                + mServicePackage + "" RUN_IN_BACKGROUND allow"";
        String result = SystemUtil.runShellCommand(mInstrumentation, cmd);
    }

    /** The ""battery restriction"" forced app standby app-op */
    public void denyAnyInBackgroundOp() throws IOException {
        String cmd = ""appops set --user "" + mUserId + "" ""
                + mServicePackage + "" RUN_ANY_IN_BACKGROUND deny"";
        String result = SystemUtil.runShellCommand(mInstrumentation, cmd);
    }

    public void allowAnyInBackgroundOp() throws IOException {
        String cmd = ""appops set --user "" + mUserId + "" ""
                + mServicePackage + "" RUN_ANY_IN_BACKGROUND allow"";
        String result = SystemUtil.runShellCommand(mInstrumentation, cmd);
    }

    public void makeUidIdle() throws IOException {
        String cmd = ""am make-uid-idle "" + mServicePackage;
        String result = SystemUtil.runShellCommand(mInstrumentation, cmd);
    }

    public void removeFromWhitelist() throws IOException {
        String cmd = ""cmd deviceidle whitelist -"" + mServicePackage;
        String result = SystemUtil.runShellCommand(mInstrumentation, cmd);
    }

    public void addToWhitelist() throws IOException {
        String cmd = ""cmd deviceidle whitelist +"" + mServicePackage;
        String result = SystemUtil.runShellCommand(mInstrumentation, cmd);
    }

    public void tempWhitelist(long duration) throws IOException {
        String cmd = ""cmd deviceidle tempwhitelist -u "" + mUserId
                + "" -d "" + duration + "" "" + mServicePackage;
        String result = SystemUtil.runShellCommand(mInstrumentation, cmd);
    }

    public void removeFromTempWhitelist() throws IOException {
        String cmd = ""cmd deviceidle tempwhitelist -u "" + mUserId
                + "" -r "" + mServicePackage;
        SystemUtil.runShellCommand(mInstrumentation, cmd);
    }

    public void setAppOpMode(String opStr, String mode) throws IOException {
        String cmd = ""cmd appops set --user "" + mUserId + "" ""
                + mServicePackage + "" "" + opStr + ""  "" + mode;
        SystemUtil.runShellCommand(mInstrumentation, cmd);
    }

    public void cleanup() throws IOException {
        removeFromWhitelist();
        allowBackgroundOp();
        allowAnyInBackgroundOp();
        mUidWatcher.finish();
        mUidGoneListener.unregister();
        mUidForegroundListener.unregister();
        mData.recycle();
    }

    public ServiceConnectionHandler getConnection(int index) {
        return mConnections[index];
    }

    public int getUid() {
        return mUid;
    }

    public UidImportanceListener getUidForegroundListener() {
        return mUidForegroundListener;
    }

    public UidImportanceListener getUidGoneListener() {
        return mUidGoneListener;
    }

    public WatchUidRunner getUidWatcher() {
        return mUidWatcher;
    }

    public void ensureProcessGone() {
        ensureProcessGone(mDefaultWaitTime);
    }

    public void ensureProcessGone(long timeout) {
        for (int i=0; i<mConnections.length; i++) {
            mConnections[i].bind(timeout);
        }

        for (int i=0; i<mConnections.length; i++) {
            IBinder serviceBinder = mConnections[i].getServiceIBinder();
            mConnections[i].unbind(timeout);
            try {
                serviceBinder.transact(IBinder.FIRST_CALL_TRANSACTION, mData, null, 0);
            } catch (RemoteException e) {
            }
        }

        // Wait for uid's process to go away.
        mUidGoneListener.waitForValue(ActivityManager.RunningAppProcessInfo.IMPORTANCE_GONE,
                ActivityManager.RunningAppProcessInfo.IMPORTANCE_GONE, timeout);
        int importance = mAm.getPackageImportance(mServicePackage);
        if (importance != ActivityManager.RunningAppProcessInfo.IMPORTANCE_GONE) {
            throw new IllegalStateException(""Unexpected importance after killing process: ""
                    + importance);
        }
        mUidWatcher.waitFor(WatchUidRunner.CMD_GONE, timeout);
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.UserRestrictionsTest"	"isHeadlessSystemUserMode"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/UserRestrictionsTest.java"	""	"/*
 *.
 */
package com.android.cts.devicepolicy;

import static com.android.cts.devicepolicy.DeviceAdminFeaturesCheckerRule.FEATURE_MANAGED_USERS;

import static org.junit.Assert.assertTrue;

import com.android.cts.devicepolicy.DeviceAdminFeaturesCheckerRule.RequiresAdditionalFeatures;
import com.android.tradefed.device.DeviceNotAvailableException;
import com.android.tradefed.log.LogUtil.CLog;

import org.junit.Test;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;

public class UserRestrictionsTest extends BaseDevicePolicyTest {
    private static final String DEVICE_ADMIN_PKG = ""com.android.cts.deviceandprofileowner"";
    private static final String DEVICE_ADMIN_APK = ""CtsDeviceAndProfileOwnerApp.apk"";
    private static final String ADMIN_RECEIVER_TEST_CLASS
            = "".BaseDeviceAdminTest$BasicAdminReceiver"";

    private static final String GLOBAL_RESTRICTIONS_TEST_CLASS =
            ""userrestrictions.ProfileGlobalRestrictionsTest"";
    private static final String SET_GLOBAL_RESTRICTIONS_TEST =
            ""testSetProfileGlobalRestrictions"";
    private static final String CLEAR_GLOBAL_RESTRICTIONS_TEST =
            ""testClearProfileGlobalRestrictions"";
    private static final String ENSURE_GLOBAL_RESTRICTIONS_TEST =
            ""testProfileGlobalRestrictionsEnforced"";
    private static final String ENSURE_NO_GLOBAL_RESTRICTIONS_TEST =
            ""testProfileGlobalRestrictionsNotEnforced"";

    private boolean mRemoveOwnerInTearDown;
    private int mDeviceOwnerUserId;

    @Override
    public void setUp() throws Exception {
        super.setUp();

        mRemoveOwnerInTearDown = false;
    }

    @Override
    public void tearDown() throws Exception {
        if (mRemoveOwnerInTearDown) {
            String componentName = DEVICE_ADMIN_PKG + ""/"" + ADMIN_RECEIVER_TEST_CLASS;
            assertTrue(""Failed to clear owner"", removeAdmin(componentName, mDeviceOwnerUserId));
            runTests(""userrestrictions.CheckNoOwnerRestrictionsTest"", mDeviceOwnerUserId);
            if (isHeadlessSystemUserMode()) {
                boolean removed = removeAdmin(componentName, mPrimaryUserId);
                if (!removed) {
                    CLog.e(""Failed to remove %s on user %d"", componentName, mPrimaryUserId);
                }
            }
        }

        // DO/PO might have set DISALLOW_REMOVE_USER, so it needs to be done after removing
        // them.
        removeTestUsers();
        getDevice().uninstallPackage(DEVICE_ADMIN_PKG);

        super.tearDown();
    }

    private void runTests(@Nonnull String className,
            @Nullable String method, int userId) throws DeviceNotAvailableException {
        runDeviceTestsAsUser(DEVICE_ADMIN_PKG, ""."" + className, method, userId);
    }

    private void runTests(@Nonnull String className, int userId)
            throws DeviceNotAvailableException {
        runTests(className, null, userId);
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.UserRestrictionsTest"	"testUserRestrictions_deviceOwnerOnly"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/UserRestrictionsTest.java"	""	"public void testUserRestrictions_deviceOwnerOnly() throws Exception {
        setDo();

        runTests(""userrestrictions.DeviceOwnerUserRestrictionsTest"",
                ""testDefaultRestrictions"", mDeviceOwnerUserId);
        runTests(""userrestrictions.DeviceOwnerUserRestrictionsTest"",
                ""testSetAllRestrictions"", mDeviceOwnerUserId);
        runTests(""userrestrictions.DeviceOwnerUserRestrictionsTest"",
                ""testBroadcast"", mDeviceOwnerUserId);
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.UserRestrictionsTest"	"testUserRestrictions_primaryProfileOwnerOnly"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/UserRestrictionsTest.java"	""	"public void testUserRestrictions_primaryProfileOwnerOnly() throws Exception {
        setPoAsUser(mDeviceOwnerUserId);

        runTests(""userrestrictions.PrimaryProfileOwnerUserRestrictionsTest"",
                ""testDefaultRestrictions"", mDeviceOwnerUserId);
        runTests(""userrestrictions.PrimaryProfileOwnerUserRestrictionsTest"",
                ""testSetAllRestrictions"", mDeviceOwnerUserId);
        runTests(""userrestrictions.PrimaryProfileOwnerUserRestrictionsTest"",
                ""testBroadcast"", mDeviceOwnerUserId);
    }

    // Checks restrictions for managed user (NOT managed profile)."	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.UserRestrictionsTest"	"testUserRestrictions_secondaryProfileOwnerOnly"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/UserRestrictionsTest.java"	""	"public void testUserRestrictions_secondaryProfileOwnerOnly() throws Exception {
        assumeSupportsMultiUser();

        final int secondaryUserId = createUser();
        setPoAsUser(secondaryUserId);

        runTests(""userrestrictions.SecondaryProfileOwnerUserRestrictionsTest"",
                ""testDefaultRestrictions"", secondaryUserId);
        runTests(""userrestrictions.SecondaryProfileOwnerUserRestrictionsTest"",
                ""testSetAllRestrictions"", secondaryUserId);
        runTests(""userrestrictions.SecondaryProfileOwnerUserRestrictionsTest"",
                ""testBroadcast"", secondaryUserId);
    }

    // Checks restrictions for managed profile.
    @RequiresAdditionalFeatures({FEATURE_MANAGED_USERS})"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.UserRestrictionsTest"	"testUserRestrictions_managedProfileOwnerOnly"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/UserRestrictionsTest.java"	""	"public void testUserRestrictions_managedProfileOwnerOnly() throws Exception {
        assumeCanCreateOneManagedUser();

        // Create managed profile.
        final int profileUserId = createManagedProfile(mDeviceOwnerUserId /* parentUserId */);
        // createManagedProfile doesn't start the user automatically.
        startUser(profileUserId);
        setPoAsUser(profileUserId);

        runTests(""userrestrictions.ManagedProfileOwnerUserRestrictionsTest"",
                ""testDefaultRestrictions"", profileUserId);
        runTests(""userrestrictions.ManagedProfileOwnerUserRestrictionsTest"",
                ""testSetAllRestrictions"", profileUserId);
        runTests(""userrestrictions.ManagedProfileOwnerUserRestrictionsTest"",
                ""testBroadcast"", profileUserId);
    }

    /**
     * DO + PO combination.  Make sure global DO restrictions are visible on secondary users.
     */"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.UserRestrictionsTest"	"testUserRestrictions_layering"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/UserRestrictionsTest.java"	""	"public void testUserRestrictions_layering() throws Exception {
        assumeSupportsMultiUser();
        setDo();

        final int secondaryUserId;
        if (!isHeadlessSystemUserMode()) {
            // Create another user and set PO.
            secondaryUserId = createUserAndWaitStart();
            setPoAsUser(secondaryUserId);
        } else {
            // In headless system user mode, PO is set on primary user when DO is set
            secondaryUserId = mPrimaryUserId;
        }

        // Ensure that UserManager differentiates its own restrictions from DO restrictions.
        runTests(""userrestrictions.DeviceOwnerUserRestrictionsTest"",
                ""testHasBaseUserRestrictions"", mDeviceOwnerUserId);

        // Let DO set all restrictions.
        runTests(""userrestrictions.DeviceOwnerUserRestrictionsTest"",
                ""testSetAllRestrictions"", mDeviceOwnerUserId);

        // Make sure the global restrictions are visible to secondary users.
        runTests(""userrestrictions.SecondaryProfileOwnerUserRestrictionsTest"",
                ""testHasGlobalRestrictions"", secondaryUserId);

        // Then let PO set all restrictions.
        runTests(""userrestrictions.SecondaryProfileOwnerUserRestrictionsTest"",
                ""testSetAllRestrictions"", secondaryUserId);

        // Make sure both local and global restrictions are visible on secondary users.
        runTests(""userrestrictions.SecondaryProfileOwnerUserRestrictionsTest"",
                ""testHasBothGlobalAndLocalRestrictions"", secondaryUserId);

        // Let DO clear all restrictions.
        runTests(""userrestrictions.DeviceOwnerUserRestrictionsTest"",
                ""testClearAllRestrictions"", mDeviceOwnerUserId);

        // Now only PO restrictions should be set on the secondary user.
        runTests(""userrestrictions.SecondaryProfileOwnerUserRestrictionsTest"",
                ""testLocalRestrictionsOnly"", secondaryUserId);
    }

    /**
     * PO on user-0.  It can set DO restrictions too, but they shouldn't leak to other users.
     */"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.UserRestrictionsTest"	"testUserRestrictions_layering_profileOwnerNoLeaking"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/UserRestrictionsTest.java"	""	"public void testUserRestrictions_layering_profileOwnerNoLeaking() throws Exception {
        assumeSupportsMultiUser();

        // Set PO on user 0
        setPoAsUser(mDeviceOwnerUserId);

        // Create another user and set PO.
        final int secondaryUserId = createUser();
        setPoAsUser(secondaryUserId);

        // Let user-0 PO sets all restrictions.
        runTests(""userrestrictions.PrimaryProfileOwnerUserRestrictionsTest"",
                ""testSetAllRestrictions"", mDeviceOwnerUserId);

        // Secondary users shouldn't see any of them. Leaky user restrictions are excluded.
        runTests(""userrestrictions.SecondaryProfileOwnerUserRestrictionsTest"",
                ""testDefaultAndLeakyRestrictions"", secondaryUserId);
    }

    /**
     * DO sets profile global restrictions (only ENSURE_VERIFY_APPS), should affect all
     * users (not a particularly special case but to be sure).
     */"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.UserRestrictionsTest"	"testUserRestrictions_profileGlobalRestrictionsAsDo"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/UserRestrictionsTest.java"	""	"public void testUserRestrictions_profileGlobalRestrictionsAsDo() throws Exception {
        assumeSupportsMultiUser();
        setDo();
        final int secondaryUserId;
        if (!isHeadlessSystemUserMode()) {
            // Create another user and set PO.
            secondaryUserId = createUserAndWaitStart();
            setPoAsUser(secondaryUserId);
        } else {
            // In headless system user mode, PO is set on primary user when DO is set.
            secondaryUserId = mPrimaryUserId;
        }

        final int[] usersToCheck = {mDeviceOwnerUserId, secondaryUserId};

        // Do sets the restriction.
        setAndCheckProfileGlobalRestriction(mDeviceOwnerUserId, usersToCheck);
    }

    /**
     * Managed profile owner sets profile global restrictions (only ENSURE_VERIFY_APPS), should
     * affect all users.
     */
    @RequiresAdditionalFeatures({FEATURE_MANAGED_USERS})"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.UserRestrictionsTest"	"testUserRestrictions_ProfileGlobalRestrictionsAsPo"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/UserRestrictionsTest.java"	""	"public void testUserRestrictions_ProfileGlobalRestrictionsAsPo() throws Exception {
        assumeCanCreateOneManagedUser();

        // Set PO on user 0
        setPoAsUser(mDeviceOwnerUserId);

        // Create another user with PO.
        final int secondaryUserId = createManagedProfile(mDeviceOwnerUserId /* parentUserId */);
        setPoAsUser(secondaryUserId);

        final int[] usersToCheck = {mDeviceOwnerUserId, secondaryUserId};

        // Check the case when primary user's PO sets the restriction.
        setAndCheckProfileGlobalRestriction(mDeviceOwnerUserId, usersToCheck);

        // Check the case when managed profile owner sets the restriction.
        setAndCheckProfileGlobalRestriction(secondaryUserId, usersToCheck);
    }

    /** Installs admin package and makes it a profile owner for a given user. */
    private void setPoAsUser(int userId) throws Exception {
        installAppAsUser(DEVICE_ADMIN_APK, /* grantPermssions= */true,
                /* dontKillApp= */ true, userId);
        assertTrue(""Failed to set profile owner"",
                setProfileOwner(DEVICE_ADMIN_PKG + ""/"" + ADMIN_RECEIVER_TEST_CLASS,
                        userId, /* expectFailure */ false));
        // If PO is not in primary user, it will be removed with the user.
        if (userId == mDeviceOwnerUserId) {
            mRemoveOwnerInTearDown = true;
        }
    }

    /** Installs admin package and makes it a device owner. */
    private void setDo() throws Exception {
        installDeviceOwnerApp(DEVICE_ADMIN_APK);

        assertTrue(""Failed to set device owner"",
                setDeviceOwner(DEVICE_ADMIN_PKG + ""/"" + ADMIN_RECEIVER_TEST_CLASS,
                        mDeviceOwnerUserId, /*expectFailure*/ false));
        mRemoveOwnerInTearDown = true;

        if (isHeadlessSystemUserMode()) {
            affiliateUsers(DEVICE_ADMIN_PKG, mDeviceOwnerUserId, mPrimaryUserId);
        }
    }

    /**
     * Sets user restriction and checks that it applies to all users.
     * @param enforcingUserId user who should set/clear the restriction, should be either
     *        primary or secondary user id and should have device or profile owner active.
     * @param usersToCheck users that should have this restriction enforced.
     */
    private void setAndCheckProfileGlobalRestriction(int enforcingUserId, int usersToCheck[])
            throws Exception {
        // Always try to clear the restriction to avoid undesirable side effects.
        try {
            // Set the restriction.
            runGlobalRestrictionsTest(SET_GLOBAL_RESTRICTIONS_TEST, enforcingUserId);
            // Check that the restriction is in power.
            for (int userId : usersToCheck) {
                runGlobalRestrictionsTest(ENSURE_GLOBAL_RESTRICTIONS_TEST, userId);
            }
        } finally {
            // Clear the restriction.
            runGlobalRestrictionsTest(CLEAR_GLOBAL_RESTRICTIONS_TEST, enforcingUserId);
            // Check that the restriction is not in power anymore.
            for (int userId : usersToCheck) {
                runGlobalRestrictionsTest(ENSURE_NO_GLOBAL_RESTRICTIONS_TEST, userId);
            }
        }
    }

    /** Convenience method to run global user restrictions tests. */
    private void runGlobalRestrictionsTest(String testMethodName, int userId) throws Exception {
        runTests(GLOBAL_RESTRICTIONS_TEST_CLASS, testMethodName, userId);
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.keystore.cts.KeyGenParameterSpecTest"	"testDefaults"	"CtsKeystoreTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/keystore/src/android/keystore/cts/KeyGenParameterSpecTest.java"	""	"public void testDefaults() {
        // Set only the mandatory parameters and assert values returned by getters.

        KeyGenParameterSpec spec = new KeyGenParameterSpec.Builder(
                ""arbitrary"", KeyProperties.PURPOSE_ENCRYPT)
                .build();

        assertEquals(""arbitrary"", spec.getKeystoreAlias());
        assertEquals(KeyProperties.PURPOSE_ENCRYPT, spec.getPurposes());
        assertNull(null, spec.getAlgorithmParameterSpec());
        MoreAsserts.assertEmpty(Arrays.asList(spec.getBlockModes()));
        assertEquals(DEFAULT_CERT_NOT_BEFORE, spec.getCertificateNotBefore());
        assertEquals(DEFAULT_CERT_NOT_AFTER, spec.getCertificateNotAfter());
        assertEquals(DEFAULT_CERT_SERIAL_NUMBER, spec.getCertificateSerialNumber());
        assertEquals(DEFAULT_CERT_SUBJECT, spec.getCertificateSubject());
        assertFalse(spec.isDigestsSpecified());
        try {
            spec.getDigests();
            fail();
        } catch (IllegalStateException expected) {}
        MoreAsserts.assertEmpty(Arrays.asList(spec.getEncryptionPaddings()));
        assertEquals(-1, spec.getKeySize());
        assertNull(spec.getKeyValidityStart());
        assertNull(spec.getKeyValidityForOriginationEnd());
        assertNull(spec.getKeyValidityForConsumptionEnd());
        assertTrue(spec.isRandomizedEncryptionRequired());
        MoreAsserts.assertEmpty(Arrays.asList(spec.getSignaturePaddings()));
        assertFalse(spec.isUserAuthenticationRequired());
        assertEquals(0, spec.getUserAuthenticationValidityDurationSeconds());
        assertEquals(KeyProperties.AUTH_BIOMETRIC_STRONG, spec.getUserAuthenticationType());
        assertFalse(spec.isUnlockedDeviceRequired());
        assertEquals(KeyProperties.UNRESTRICTED_USAGE_COUNT, spec.getMaxUsageCount());
    }"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.net.vcn.cts.TestNetworkWrapper"	"VcnTestNetworkCallback"	"CtsVcnTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/vcn/src/android/net/vcn/cts/TestNetworkWrapper.java"	""	"public void test/*
 *.
 */

package android.net.vcn.cts;

import static android.net.cts.util.CtsNetUtils.TestNetworkCallback;

import android.annotation.NonNull;
import android.content.Context;
import android.ipsec.ike.cts.IkeTunUtils;
import android.net.ConnectivityManager;
import android.net.IpPrefix;
import android.net.LinkAddress;
import android.net.LinkProperties;
import android.net.Network;
import android.net.NetworkAgent;
import android.net.NetworkAgentConfig;
import android.net.NetworkCapabilities;
import android.net.NetworkProvider;
import android.net.NetworkRequest;
import android.net.RouteInfo;
import android.net.TestNetworkInterface;
import android.net.TestNetworkManager;
import android.net.TestNetworkSpecifier;
import android.net.vcn.VcnManager;
import android.net.vcn.VcnManager.VcnNetworkPolicyChangeListener;
import android.net.vcn.VcnNetworkPolicyResult;
import android.os.Looper;
import android.os.ParcelFileDescriptor;
import android.util.CloseGuard;
import android.util.Log;

import com.android.net.module.util.NetworkStackConstants;

import java.net.Inet4Address;
import java.net.Inet6Address;
import java.net.InetAddress;
import java.net.InterfaceAddress;
import java.net.NetworkInterface;
import java.util.Arrays;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.Executor;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;

/** Utility class for cleanly creating and tearing down Test Networks. */
// TODO(b/188462344): compine with IKEv2's TestNetworkContext
public class TestNetworkWrapper implements AutoCloseable {
    private static final String TAG = TestNetworkWrapper.class.getSimpleName();
    private static final String NETWORK_AGENT_TAG = TestNetworkAgent.class.getSimpleName();
    private static final String POLICY_LISTENER_TAG =
            TestNetworkAgent.TestVcnNetworkPolicyChangeListener.class.getSimpleName();

    public static final int NETWORK_CB_TIMEOUT_MS = 5000;

    private static final int IP4_PREFIX_LEN = 32;
    private static final int IP6_PREFIX_LEN = 64;

    // This NetworkRequest is expected to only match with Test Networks. To do so, remove all
    // default Capabilities and specify TRANSPORT_TEST.
    private static final NetworkRequest TEST_NETWORK_REQUEST =
            new NetworkRequest.Builder()
                    .clearCapabilities()
                    .addTransportType(NetworkCapabilities.TRANSPORT_TEST)
                    .build();

    private static final String NETWORK_PROVIDER_NAME = ""TestNetworkProvider"";
    private static final int TEST_NETWORK_SCORE = 1; // Use a low, non-zero score.
    private static final Executor INLINE_EXECUTOR = Runnable::run;

    private final CloseGuard mCloseGuard = new CloseGuard();

    private final ConnectivityManager mConnectivityManager;
    private final VcnManager mVcnManager;
    private final TestNetworkManager mTestNetworkManager;

    private final TestNetworkAgent mTestNetworkAgent;

    public final VcnTestNetworkCallback vcnNetworkCallback;
    public final ParcelFileDescriptor tunFd;
    public final IkeTunUtils ikeTunUtils;
    public final Network tunNetwork;

    public TestNetworkWrapper(
            @NonNull Context context,
            int mtu,
            boolean isMetered,
            @NonNull Set<Integer> subIds,
            @NonNull InetAddress localAddress)
            throws Exception {
        mConnectivityManager = context.getSystemService(ConnectivityManager.class);
        mVcnManager = context.getSystemService(VcnManager.class);
        mTestNetworkManager = context.getSystemService(TestNetworkManager.class);

        try {
            final LinkAddress linkAddress =
                    new LinkAddress(
                            localAddress,
                            localAddress instanceof Inet4Address ? IP4_PREFIX_LEN : IP6_PREFIX_LEN);
            final TestNetworkInterface tni =
                    mTestNetworkManager.createTunInterface(Arrays.asList(linkAddress));
            tunFd = tni.getFileDescriptor();
            final String iface = tni.getInterfaceName();

            final NetworkRequest nr =
                    new NetworkRequest.Builder(TEST_NETWORK_REQUEST)
                            .setNetworkSpecifier(iface)
                            .build();
            vcnNetworkCallback = new VcnTestNetworkCallback();
            mConnectivityManager.requestNetwork(nr, vcnNetworkCallback);

            final NetworkCapabilities nc =
                    createNetworkCapabilitiesForIface(iface, isMetered, subIds);
            final LinkProperties lp = createLinkPropertiesForIface(iface, mtu);

            final VcnNetworkPolicyResult policy = mVcnManager.applyVcnNetworkPolicy(nc, lp);
            if (policy.isTeardownRequested()) {
                throw new IllegalStateException(""Restart requested in bringup"");
            }

            mTestNetworkAgent =
                    new TestNetworkAgent(
                            context, Looper.getMainLooper(), policy.getNetworkCapabilities(), lp);
            mTestNetworkAgent.register();
            mTestNetworkAgent.markConnected();

            tunNetwork = vcnNetworkCallback.waitForAvailable();
            ikeTunUtils = new IkeTunUtils(tunFd);
            mCloseGuard.open(TAG);
        } catch (Exception e) {
            Log.e(TAG, ""Failed to bring up TestNetworkWrapper"", e);
            close();
            throw e;
        }
    }

    private static NetworkCapabilities createNetworkCapabilitiesForIface(
            @NonNull String iface, boolean isMetered, Set<Integer> subIds) {
        NetworkCapabilities.Builder builder =
                NetworkCapabilities.Builder.withoutDefaultCapabilities()
                        .addTransportType(NetworkCapabilities.TRANSPORT_TEST)
                        .addCapability(NetworkCapabilities.NET_CAPABILITY_NOT_SUSPENDED)
                        .addCapability(NetworkCapabilities.NET_CAPABILITY_NOT_RESTRICTED)
                        .addCapability(NetworkCapabilities.NET_CAPABILITY_NOT_VCN_MANAGED)
                        .addCapability(NetworkCapabilities.NET_CAPABILITY_MMS)
                        .addCapability(NetworkCapabilities.NET_CAPABILITY_DUN)
                        .addCapability(NetworkCapabilities.NET_CAPABILITY_FOTA)
                        .setNetworkSpecifier(new TestNetworkSpecifier(iface))
                        .setSubscriptionIds(subIds);
        if (!isMetered) {
            builder.addCapability(NetworkCapabilities.NET_CAPABILITY_NOT_METERED);
        }
        return builder.build();
    }

    private static LinkProperties createLinkPropertiesForIface(@NonNull String iface, int mtu)
            throws Exception {
        final LinkProperties lp = new LinkProperties();
        lp.setInterfaceName(iface);
        lp.setMtu(mtu);

        // Find the currently assigned addresses, and add them to LinkProperties
        boolean allowIPv4 = false;
        boolean allowIPv6 = false;
        NetworkInterface netIntf = NetworkInterface.getByName(iface);
        Objects.requireNonNull(netIntf, ""No such network interface found: "" + netIntf);

        for (InterfaceAddress intfAddr : netIntf.getInterfaceAddresses()) {
            lp.addLinkAddress(
                    new LinkAddress(intfAddr.getAddress(), intfAddr.getNetworkPrefixLength()));

            if (intfAddr.getAddress() instanceof Inet6Address) {
                allowIPv6 |= !intfAddr.getAddress().isLinkLocalAddress();
            } else if (intfAddr.getAddress() instanceof Inet4Address) {
                allowIPv4 = true;
            }
        }

        // Add global routes (but as non-default, non-internet providing network). Use prefix
        // lengths of 0 to match all IP addresses.
        if (allowIPv4) {
            lp.addRoute(
                    new RouteInfo(
                            new IpPrefix(NetworkStackConstants.IPV4_ADDR_ANY, 0 /* prefixLength */),
                            null /* gateway */,
                            iface,
                            RouteInfo.RTN_UNICAST));
        }
        if (allowIPv6) {
            lp.addRoute(
                    new RouteInfo(
                            new IpPrefix(NetworkStackConstants.IPV6_ADDR_ANY, 0 /* prefixLength */),
                            null /* gateway */,
                            iface,
                            RouteInfo.RTN_UNICAST));
        }

        return lp;
    }

    @Override
    public void close() {
        mCloseGuard.close();

        if (vcnNetworkCallback != null) {
            try {
                mConnectivityManager.unregisterNetworkCallback(vcnNetworkCallback);
            } catch (Exception e) {
                Log.e(TAG, ""Failed to unregister Network CB"", e);
            }
        }

        if (mTestNetworkAgent != null) {
            synchronized (mTestNetworkAgent) {
                try {
                    mTestNetworkAgent.teardown();
                } catch (Exception e) {
                    Log.e(TAG, ""Failed to unregister TestNetworkAgent"", e);
                }
            }
        }

        if (tunNetwork != null) {
            try {
                mTestNetworkManager.teardownTestNetwork(tunNetwork);
            } catch (Exception e) {
                Log.e(TAG, ""Failed to tear down Test Network"", e);
            }
        }

        if (tunFd != null) {
            try {
                tunFd.close();
            } catch (Exception e) {
                Log.e(TAG, ""Failed to close Test Network FD"", e);
            }
        }
    }

    @Override
    public void finalize() {
        mCloseGuard.warnIfOpen();
        close();
    }

    /**
     * Test-only NetworkAgent to be used for instrumented TUN Networks.
     *
     * <p>TestNetworkAgent is NOT THREAD SAFE - all accesses should be synchronized.
     */
    private class TestNetworkAgent extends NetworkAgent {
        private final CloseGuard mCloseGuard = new CloseGuard();
        private final VcnNetworkPolicyChangeListener mPolicyListener =
                new TestVcnNetworkPolicyChangeListener();

        private final LinkProperties mLinkProperties;

        private NetworkCapabilities mNetworkCapabilities;

        private TestNetworkAgent(
                @NonNull Context context,
                @NonNull Looper looper,
                @NonNull NetworkCapabilities nc,
                @NonNull LinkProperties lp) {
            super(
                    context,
                    looper,
                    NETWORK_AGENT_TAG,
                    nc,
                    lp,
                    TEST_NETWORK_SCORE,
                    new NetworkAgentConfig.Builder().build(),
                    new NetworkProvider(context, looper, NETWORK_PROVIDER_NAME));

            mNetworkCapabilities = nc;
            mLinkProperties = lp;

            mVcnManager.addVcnNetworkPolicyChangeListener(INLINE_EXECUTOR, mPolicyListener);

            mCloseGuard.open(NETWORK_AGENT_TAG);
        }

        @Override
        public void finalize() {
            mCloseGuard.warnIfOpen();
            teardown();
        }

        @Override
        public void onNetworkUnwanted() {
            // Not guaranteed to be called from the same thread, so synchronize on this.
            synchronized (this) {
                teardown();
            }
        }

        private void teardown() {
            mCloseGuard.close();
            unregister();
            mVcnManager.removeVcnNetworkPolicyChangeListener(mPolicyListener);
        }

        private NetworkCapabilities getNetworkCapabilities() {
            return mNetworkCapabilities;
        }

        private void updateNetworkCapabilities(@NonNull NetworkCapabilities nc) {
            Objects.requireNonNull(nc, ""nc must be non-null"");

            mNetworkCapabilities = nc;
            sendNetworkCapabilities(mNetworkCapabilities);
        }

        private LinkProperties getLinkProperties() {
            return mLinkProperties;
        }

        private class TestVcnNetworkPolicyChangeListener implements VcnNetworkPolicyChangeListener {
            @Override
            public void onPolicyChanged() {
                synchronized (TestNetworkAgent.this) {
                    final VcnNetworkPolicyResult policy =
                            mVcnManager.applyVcnNetworkPolicy(
                                    mTestNetworkAgent.getNetworkCapabilities(),
                                    mTestNetworkAgent.getLinkProperties());
                    if (policy.isTeardownRequested()) {
                        Log.w(POLICY_LISTENER_TAG, ""network teardown requested on policy change"");
                        teardown();
                        return;
                    }

                    updateNetworkCapabilities(policy.getNetworkCapabilities());
                }
            }
        }
    }

    /** NetworkCallback to used for tracking test network events. */
    // TODO(b/187231331): remove once TestNetworkCallback supports tracking NetworkCapabilities
    public static class VcnTestNetworkCallback extends TestNetworkCallback {
        private final BlockingQueue<Network> mAvailableHistory = new LinkedBlockingQueue<>();
        private final BlockingQueue<Network> mLostHistory = new LinkedBlockingQueue<>();
        private final BlockingQueue<CapabilitiesChangedEvent> mCapabilitiesChangedHistory =
                new LinkedBlockingQueue<>();

        @Override
        public Network waitForAvailable() throws InterruptedException {
            return mAvailableHistory.poll(NETWORK_CB_TIMEOUT_MS, TimeUnit.MILLISECONDS);
        }

        @Override
        public Network waitForLost() throws InterruptedException {
            return mLostHistory.poll(NETWORK_CB_TIMEOUT_MS, TimeUnit.MILLISECONDS);
        }

        public CapabilitiesChangedEvent waitForOnCapabilitiesChanged() throws Exception {
            return waitForOnCapabilitiesChanged(NETWORK_CB_TIMEOUT_MS);
        }

        public CapabilitiesChangedEvent waitForOnCapabilitiesChanged(long timeoutMillis)
                throws Exception {
            return mCapabilitiesChangedHistory.poll(timeoutMillis, TimeUnit.MILLISECONDS);
        }

        @Override
        public void onAvailable(@NonNull Network network) {
            mAvailableHistory.offer(network);
        }

        @Override
        public void onLost(@NonNull Network network) {
            mLostHistory.offer(network);
        }

        @Override
        public void onCapabilitiesChanged(
                @NonNull Network network, @NonNull NetworkCapabilities nc) {
            mCapabilitiesChangedHistory.offer(new CapabilitiesChangedEvent(network, nc));
        }

        public class CapabilitiesChangedEvent {
            public final Network network;
            public final NetworkCapabilities networkCapabilities;

            public CapabilitiesChangedEvent(
                    @NonNull Network network, @NonNull NetworkCapabilities networkCapabilities) {
                this.network = network;
                this.networkCapabilities = networkCapabilities;
            }
        }
    }
}"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"test.java.com.android.queryable.queries.BooleanQueryHelperTest"	"isTrue"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/queryable/src/test/java/com/android/queryable/queries/BooleanQueryHelperTest.java"	""	"public void matches_noRestrictions_returnsTrue() {
        BooleanQueryHelper<Queryable> booleanQueryHelper = new BooleanQueryHelper<>(mQuery);

        assertThat(booleanQueryHelper.matches(true)).isTrue();
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.managedprovisioning.PolicyTransparencyTestActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/managedprovisioning/PolicyTransparencyTestActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.managedprovisioning;

import android.accessibilityservice.AccessibilityService;
import android.content.ActivityNotFoundException;
import android.content.Intent;
import android.inputmethodservice.InputMethodService;
import android.os.Bundle;
import android.provider.Settings;
import android.util.ArrayMap;
import android.view.View;
import android.view.accessibility.AccessibilityEvent;
import android.widget.AdapterView;
import android.widget.Button;
import android.widget.CompoundButton;
import android.widget.EditText;
import android.widget.Switch;
import android.widget.TextView;

import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;

import java.util.Map;

public class PolicyTransparencyTestActivity extends PassFailButtons.Activity implements
        View.OnClickListener, CompoundButton.OnCheckedChangeListener,
        AdapterView.OnItemSelectedListener {
    public static final String ACTION_SHOW_POLICY_TRANSPARENCY_TEST =
            ""com.android.cts.verifier.managedprovisioning.action.SHOW_POLICY_TRANSPARENCY_TEST"";

    // Identifies a test to perform. Type String. The possible values are the ones underneath.
    public static final String EXTRA_TEST =
            ""com.android.cts.verifier.managedprovisioning.extra.TEST"";

    // In this case: should also contain an extra
    // {@link CommandReceiverActivity.EXTRA_USER_RESTRICTION}
    public static final String TEST_CHECK_USER_RESTRICTION = ""check-user-restriction"";
    public static final String TEST_CHECK_AUTO_TIME_REQUIRED = ""check-auto-time-required"";
    public static final String TEST_CHECK_KEYGURAD_UNREDACTED_NOTIFICATION =
            ""check-keyguard-unredacted-notification"";
    public static final String TEST_CHECK_LOCK_SCREEN_INFO = ""check-lock-screen-info"";
    public static final String TEST_CHECK_MAXIMUM_TIME_TO_LOCK = ""check-maximum-time-to-lock"";
    public static final String TEST_CHECK_PERMITTED_ACCESSIBILITY_SERVICE =
            ""check-permitted-accessibility-service"";
    public static final String TEST_CHECK_PERMITTED_INPUT_METHOD = ""check-permitted-input-method"";

    public static final String EXTRA_SETTINGS_INTENT_ACTION =
            ""com.android.cts.verifier.managedprovisioning.extra.SETTINGS_INTENT_ACTION"";
    public static final String EXTRA_TITLE =
            ""com.android.cts.verifier.managedprovisioning.extra.TITLE"";
    // Identifies the test in the calling activity. We will set the result for this test.
    // Type: String
    public static final String EXTRA_TEST_ID =
            ""com.android.cts.verifier.managedprovisioning.extra.TEST_ID"";

    private static final Map<String, PolicyTestItem> POLICY_TEST_ITEMS = new ArrayMap<>();
    static {
        POLICY_TEST_ITEMS.put(TEST_CHECK_AUTO_TIME_REQUIRED, new PolicyTestItem(
                R.string.auto_time_required_set_step,
                R.string.set_auto_time_required_action,
                R.string.set_auto_time_required_widget_label,
                R.id.switch_widget,
                CommandReceiverActivity.COMMAND_SET_AUTO_TIME_REQUIRED));
        POLICY_TEST_ITEMS.put(TEST_CHECK_KEYGURAD_UNREDACTED_NOTIFICATION, new PolicyTestItem(
                R.string.disallow_keyguard_unredacted_notifications_set_step,
                R.string.disallow_keyguard_unredacted_notifications_action,
                R.string.disallow_keyguard_unredacted_notifications_widget_label,
                R.id.switch_widget,
                CommandReceiverActivity.COMMAND_DISALLOW_KEYGUARD_UNREDACTED_NOTIFICATIONS));
        POLICY_TEST_ITEMS.put(TEST_CHECK_LOCK_SCREEN_INFO, new PolicyTestItem(
                R.string.lock_screen_info_set_step,
                R.string.set_lock_screen_info_action,
                R.string.set_lock_screen_info_widget_label,
                R.id.edit_text_widget,
                CommandReceiverActivity.COMMAND_SET_LOCK_SCREEN_INFO));
        POLICY_TEST_ITEMS.put(TEST_CHECK_MAXIMUM_TIME_TO_LOCK, new PolicyTestItem(
                R.string.maximum_time_to_lock_set_step,
                R.string.set_maximum_time_to_lock_action,
                R.string.set_maximum_time_to_lock_widget_label,
                R.id.edit_text_widget,
                CommandReceiverActivity.COMMAND_SET_MAXIMUM_TO_LOCK));
        POLICY_TEST_ITEMS.put(TEST_CHECK_PERMITTED_ACCESSIBILITY_SERVICE, new PolicyTestItem(
                R.string.permitted_accessibility_services_set_step,
                R.string.set_permitted_accessibility_services_action,
                R.string.set_permitted_accessibility_services_widget_label,
                R.id.switch_widget,
                CommandReceiverActivity.COMMAND_ALLOW_ONLY_SYSTEM_ACCESSIBILITY_SERVICES));
        POLICY_TEST_ITEMS.put(TEST_CHECK_PERMITTED_INPUT_METHOD, new PolicyTestItem(
                R.string.permitted_input_methods_set_step,
                R.string.set_permitted_input_methods_action,
                R.string.set_permitted_input_methods_widget_label,
                R.id.switch_widget,
                CommandReceiverActivity.COMMAND_ALLOW_ONLY_SYSTEM_INPUT_METHODS));
    }

    private boolean mForceCurrentUserDpm;
    private String mSettingsIntentAction;
    private String mTestId;
    private String mTitle;
    private String mTest;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.policy_transparency_test);
        setPassFailButtonClickListeners();

        mForceCurrentUserDpm =
                getIntent().getBooleanExtra(
                        CommandReceiverActivity.EXTRA_USE_CURRENT_USER_DPM, false);
        mTitle = getIntent().getStringExtra(EXTRA_TITLE);
        mTestId = getIntent().getStringExtra(EXTRA_TEST_ID);
        mSettingsIntentAction = getIntent().getStringExtra(EXTRA_SETTINGS_INTENT_ACTION);
        mTest = getIntent().getStringExtra(EXTRA_TEST);

        setTitle(mTitle);
        findViewById(R.id.open_settings_button).setOnClickListener(this);
        updateTestInstructions();
    }

    private void updateTestInstructions() {
        String setStep = null;
        String userAction = null;
        String widgetLabel = null;
        int widgetId = 0;
        if (TEST_CHECK_USER_RESTRICTION.equals(mTest)) {
            setStep = getString(R.string.user_restriction_set_step, mTitle);
            final String userRestriction = getIntent().getStringExtra(
                    CommandReceiverActivity.EXTRA_USER_RESTRICTION);
            userAction = UserRestrictions.getUserAction(this, userRestriction);
            widgetLabel = mTitle;
            widgetId = R.id.switch_widget;
        } else {
            final PolicyTestItem testItem = POLICY_TEST_ITEMS.get(mTest);
            setStep = getString(testItem.setStep);
            userAction = getString(testItem.userAction);
            widgetLabel = getString(testItem.widgetLabel);
            widgetId = testItem.widgetId;
        }
        ((TextView) findViewById(R.id.widget_label)).setText(widgetLabel);
        ((TextView) findViewById(R.id.test_instructions)).setText(
                getString(R.string.policy_transparency_test_instructions, setStep, userAction));
        updateWidget(widgetId);
    }

    private void updateWidget(int widgetId) {
        switch (widgetId) {
            case R.id.switch_widget: {
                Switch switchWidget = (Switch) findViewById(R.id.switch_widget);
                switchWidget.setOnCheckedChangeListener(this);
                switchWidget.setVisibility(View.VISIBLE);
            } break;
            case R.id.edit_text_widget: {
                findViewById(R.id.edit_text_widget).setVisibility(View.VISIBLE);
                Button updateButton = (Button) findViewById(R.id.update_button);
                updateButton.setOnClickListener(this);
                updateButton.setVisibility(View.VISIBLE);
            } break;
            default: {
                throw new IllegalArgumentException(""Unknown widgetId: "" + widgetId);
            }
        }
    }

    @Override
    public void onClick(View view) {
        if (view.getId() == R.id.open_settings_button) {
            try {
                startActivity(new Intent(mSettingsIntentAction));
            } catch (ActivityNotFoundException e) {
                // If the given settings intent is not handled, use the main settings intent
                startActivity(new Intent(Settings.ACTION_SETTINGS));
            }
        } else if (view.getId() == R.id.update_button) {
            final PolicyTestItem testItem = POLICY_TEST_ITEMS.get(mTest);
            final Intent intent = new Intent(CommandReceiverActivity.ACTION_EXECUTE_COMMAND);
            intent.putExtra(CommandReceiverActivity.EXTRA_COMMAND, testItem.command);
            final EditText editText = (EditText) findViewById(R.id.edit_text_widget);
            intent.putExtra(CommandReceiverActivity.EXTRA_VALUE, editText.getText().toString());
            startActivity(intent);
        }
    }

    @Override
    public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
        final Intent intent;
        if (TEST_CHECK_USER_RESTRICTION.equals(mTest)) {
            final String userRestriction = getIntent().getStringExtra(
                    CommandReceiverActivity.EXTRA_USER_RESTRICTION);
            intent = mForceCurrentUserDpm
                    ? CommandReceiverActivity.createSetCurrentUserRestrictionIntent(
                            userRestriction, isChecked)
                    : CommandReceiverActivity.createSetDeviceOwnerUserRestrictionIntent(
                            userRestriction, isChecked);
        } else {
            intent = new Intent(CommandReceiverActivity.ACTION_EXECUTE_COMMAND);
            final PolicyTestItem testItem = POLICY_TEST_ITEMS.get(mTest);
            intent.putExtra(CommandReceiverActivity.EXTRA_COMMAND, testItem.command);
            intent.putExtra(CommandReceiverActivity.EXTRA_ENFORCED, isChecked);
        }
        startActivity(intent);
    }

    @Override
    public void onItemSelected(AdapterView<?> parent, View view, int pos, long id) {
        final PolicyTestItem testItem = POLICY_TEST_ITEMS.get(mTest);
        final Intent intent = new Intent(CommandReceiverActivity.ACTION_EXECUTE_COMMAND);
        intent.putExtra(CommandReceiverActivity.EXTRA_COMMAND, testItem.command);
        startActivity(intent);
    }

    @Override
    public void onNothingSelected(AdapterView<?> parent) {
        // Do nothing.
    }

    @Override
    public String getTestId() {
        return mTestId;
    }

    public static class TestAccessibilityService extends AccessibilityService {

        @Override
        public void onAccessibilityEvent(AccessibilityEvent event) {
            // Do nothing
        }

        @Override
        public void onInterrupt() {
            // Do nothing
        }
    }

    public static class TestInputMethod extends InputMethodService {
        @Override
        public boolean onEvaluateFullscreenMode() {
            return false;
        }

        @Override
        public boolean onEvaluateInputViewShown() {
            return false;
        }
    }

    private static class PolicyTestItem {
        public final int setStep;
        public final int userAction;
        public final int widgetLabel;
        public final int widgetId;
        public final String command;

        public PolicyTestItem(int setStep, int userAction, int widgetLabel, int widgetId,
                String command) {
            this.setStep = setStep;
            this.userAction = userAction;
            this.widgetLabel = widgetLabel;
            this.widgetId = widgetId;
            this.command = command;
        }
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.usespermissiondiffcertapp.AccessPermissionWithDiffSigTest"	"testRestrictingProviderNoMatchingPath"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/UsePermissionDiffCert/src/com/android/cts/usespermissiondiffcertapp/AccessPermissionWithDiffSigTest.java"	""	"public void testRestrictingProviderNoMatchingPath() {
        assertReadingContentUriAllowed(PERM_URI_PATH_RESTRICTING);
        assertWritingContentUriAllowed(PERM_URI_PATH_RESTRICTING);

        // allowed by no top-level permission
        final Uri test = PERM_URI_PATH_RESTRICTING.buildUpon().appendPath(""fo"").build();
        assertReadingContentUriAllowed(test);
        assertWritingContentUriAllowed(test);
    }

    /**
     * Verify that paths under {@code path-permission} restriction aren't
     * allowed, even though the {@code provider} requires no permissions.
     */"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.managedprovisioning.DisallowAppsControlActivity"	"DisallowAppsControlActivity"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/managedprovisioning/DisallowAppsControlActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.managedprovisioning;

import android.app.admin.DevicePolicyManager;
import android.content.ActivityNotFoundException;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.hardware.fingerprint.FingerprintManager;
import android.os.Bundle;
import android.os.UserManager;
import android.provider.Settings;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Toast;

import com.android.cts.verifier.ArrayTestListAdapter;
import com.android.cts.verifier.DialogTestListActivity;
import com.android.cts.verifier.R;

public class DisallowAppsControlActivity extends DialogTestListActivity {

    protected DevicePolicyManager mDpm;

    public DisallowAppsControlActivity() {
        super(R.layout.provisioning_byod,
                R.string.provisioning_byod_disallow_apps_control,
                R.string.provisioning_byod_disallow_apps_control_info,
                R.string.provisioning_byod_disallow_apps_control_instruction);
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        mDpm = (DevicePolicyManager) getSystemService(Context.DEVICE_POLICY_SERVICE);

        mPrepareTestButton.setText(
                R.string.provisioning_byod_disallow_apps_control_prepare_button);
        mPrepareTestButton.setOnClickListener(new OnClickListener() {
                @Override
                public void onClick(View v) {
                    disallowAppsControl();
                }
            });
    }

    protected ComponentName getAdminComponent() {
        return DeviceAdminTestReceiver.getReceiverComponentName();
    }

    @Override
    public void finish() {
        // Pass and fail buttons are known to call finish() when clicked, and this is when we want to
        // clear the restriction.
        allowAppsControl();
        super.finish();
    }

    private void allowAppsControl() {
        Intent allowAppsControlIntent = new Intent(
                ByodHelperActivity.ACTION_CLEAR_USER_RESTRICTION);
        allowAppsControlIntent.putExtra(
                ByodHelperActivity.EXTRA_PARAMETER_1, UserManager.DISALLOW_APPS_CONTROL);
        startActivity(allowAppsControlIntent);
    }

    private void disallowAppsControl() {
        Intent disallowAppsControlIntent = new Intent(
                ByodHelperActivity.ACTION_SET_USER_RESTRICTION).putExtra(
                ByodHelperActivity.EXTRA_PARAMETER_1, UserManager.DISALLOW_APPS_CONTROL);
        startActivity(disallowAppsControlIntent);
    }

    private void setupCheckDisabledUninstallButtonTest(ArrayTestListAdapter adapter) {
        adapter.add(new DialogTestListItem(this,
                R.string.provisioning_byod_disabled_uninstall_button,
                ""BYOD_DISABLED_UNINSTALL_BUTTON"",
                R.string.provisioning_byod_disabled_uninstall_button_instruction,
                new Intent(Settings.ACTION_APPLICATION_SETTINGS)));
    }

    private void setupCheckDisabledForceStopTest(ArrayTestListAdapter adapter) {
        adapter.add(new DialogTestListItem(this,
                R.string.provisioning_byod_disabled_force_stop_button,
                ""BYOD_DISABLED_FORCE_STOP_BUTTON"",
                R.string.provisioning_byod_disabled_force_stop_button_instruction,
                new Intent(Settings.ACTION_APPLICATION_SETTINGS)));
    }

    private void setupCheckDisabledAppStorageButtonsTest(ArrayTestListAdapter adapter) {
        adapter.add(new DialogTestListItem(this,
                R.string.provisioning_byod_disabled_app_storage_buttons,
                ""BYOD_DISABLED_APP_STORAGE_BUTTONS"",
                R.string.provisioning_byod_disabled_app_storage_buttons_instruction,
                new Intent(Settings.ACTION_APPLICATION_SETTINGS)));
    }

    @Override
    protected void setupTests(ArrayTestListAdapter adapter) {
        setupCheckDisabledUninstallButtonTest(adapter);
        setupCheckDisabledForceStopTest(adapter);
        setupCheckDisabledAppStorageButtonsTest(adapter);
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.server.wm.MultiDisplaySecurityTests"	"testLaunchWithoutPermissionOnVirtualDisplayByOwner"	"CtsWindowManagerDeviceTestCases"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/MultiDisplaySecurityTests.java"	""	"public void testLaunchWithoutPermissionOnVirtualDisplayByOwner() {
        // Create new virtual display.
        final DisplayContent newDisplay = createManagedVirtualDisplaySession().createDisplay();

        separateTestJournal();

        // Try to launch an activity and check if security exception was triggered.
        getLaunchActivityBuilder()
                .setUseBroadcastReceiver(LAUNCH_BROADCAST_RECEIVER, LAUNCH_BROADCAST_ACTION)
                .setDisplayId(newDisplay.mId)
                .setTargetActivity(TEST_ACTIVITY)
                .execute();
        assertSecurityExceptionFromActivityLauncher();
        mWmState.computeState(TEST_ACTIVITY);
        assertFalse(""Restricted activity must not be launched"",
                mWmState.containsActivity(TEST_ACTIVITY));
    }

    /**
     * Tests launching an activity on a virtual display without special permission must not be
     * allowed.
     */"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.server.wm.MultiDisplaySecurityTests"	"testLaunchWithoutPermissionOnVirtualDisplay"	"CtsWindowManagerDeviceTestCases"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/MultiDisplaySecurityTests.java"	""	"public void testLaunchWithoutPermissionOnVirtualDisplay() {
        // Create new virtual display.
        final DisplayContent newDisplay = createManagedVirtualDisplaySession().createDisplay();

        separateTestJournal();

        // Try to launch an activity and check it security exception was triggered.
        getLaunchActivityBuilder()
                .setUseBroadcastReceiver(SECOND_LAUNCH_BROADCAST_RECEIVER,
                        SECOND_LAUNCH_BROADCAST_ACTION)
                .setDisplayId(newDisplay.mId)
                .setTargetActivity(TEST_ACTIVITY)
                .execute();
        assertSecurityExceptionFromActivityLauncher();
        mWmState.computeState(TEST_ACTIVITY);
        assertFalse(""Restricted activity must not be launched"",
                mWmState.containsActivity(TEST_ACTIVITY));
    }

    /**
     * Tests launching an activity on virtual display and then launching another activity that
     * doesn't allow embedding - it should fail with security exception.
     */"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.keystore.cts.KeyProtectionTest"	"testDefaults"	"CtsKeystoreTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/keystore/src/android/keystore/cts/KeyProtectionTest.java"	""	"public void testDefaults() {
        // Set only the mandatory parameters and assert values returned by getters.

        KeyProtection spec = new KeyProtection.Builder(KeyProperties.PURPOSE_ENCRYPT)
                .build();

        assertEquals(KeyProperties.PURPOSE_ENCRYPT, spec.getPurposes());
        MoreAsserts.assertEmpty(Arrays.asList(spec.getBlockModes()));
        assertFalse(spec.isDigestsSpecified());
        try {
            spec.getDigests();
            fail();
        } catch (IllegalStateException expected) {}
        MoreAsserts.assertEmpty(Arrays.asList(spec.getEncryptionPaddings()));
        assertNull(spec.getKeyValidityStart());
        assertNull(spec.getKeyValidityForOriginationEnd());
        assertNull(spec.getKeyValidityForConsumptionEnd());
        assertTrue(spec.isRandomizedEncryptionRequired());
        MoreAsserts.assertEmpty(Arrays.asList(spec.getSignaturePaddings()));
        assertFalse(spec.isUserAuthenticationRequired());
        assertEquals(0, spec.getUserAuthenticationValidityDurationSeconds());
        assertEquals(KeyProperties.AUTH_BIOMETRIC_STRONG, spec.getUserAuthenticationType());
        assertEquals(GateKeeper.INVALID_SECURE_USER_ID, spec.getBoundToSpecificSecureUserId());
        assertFalse(spec.isUnlockedDeviceRequired());
        assertEquals(KeyProperties.UNRESTRICTED_USAGE_COUNT, spec.getMaxUsageCount());
        assertEquals(spec.isStrongBoxBacked(), false);
    }"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.AllowedAccountManagementTest"	"clearAllAccountManagementDisabled"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/AllowedAccountManagementTest.java"	""	"public void test/*
 *.
 */

package com.android.cts.deviceandprofileowner;

import android.accounts.Account;
import android.accounts.AccountManager;
import android.accounts.AuthenticatorException;
import android.accounts.OperationCanceledException;
import android.app.admin.DevicePolicyManager;
import android.content.Context;
import android.os.Bundle;
import android.os.UserManager;

import java.io.IOException;

/**
 * These tests verify that the device / profile owner can use account management APIs to add
 * accounts even when policies are set. The policies tested are
 * {@link DevicePolicyManager#setAccountManagementDisabled} and
 * {@link UserManager#DISALLOW_MODIFY_ACCOUNTS}.
 *
 * This test depends on {@link com.android.cts.devicepolicy.accountmanagement.MockAccountService},
 * which provides authenticator for a mock account type.
 */
public class AllowedAccountManagementTest extends BaseDeviceAdminTest {

    // Account type for MockAccountAuthenticator
    private final static String ACCOUNT_TYPE_1 =
            ""com.android.cts.devicepolicy.accountmanagement.account.type"";
    private final static String ACCOUNT_TYPE_2 = ""com.placeholder.account"";
    private final static Account ACCOUNT = new Account(""user0"", ACCOUNT_TYPE_1);

    private AccountManager mAccountManager;

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        mAccountManager = (AccountManager) mContext.getSystemService(Context.ACCOUNT_SERVICE);
        clearAllAccountManagementDisabled();
        mDevicePolicyManager.clearUserRestriction(ADMIN_RECEIVER_COMPONENT,
                UserManager.DISALLOW_MODIFY_ACCOUNTS);
    }

    @Override
    protected void tearDown() throws Exception {
        clearAllAccountManagementDisabled();
        mDevicePolicyManager.clearUserRestriction(ADMIN_RECEIVER_COMPONENT,
                UserManager.DISALLOW_MODIFY_ACCOUNTS);
        super.tearDown();
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.AllowedAccountManagementTest"	"testUserRestriction_profileAndDeviceOwnerCanAddAndRemoveAccount"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/AllowedAccountManagementTest.java"	""	"public void testUserRestriction_profileAndDeviceOwnerCanAddAndRemoveAccount()
            throws AuthenticatorException, IOException, OperationCanceledException {
        mDevicePolicyManager.addUserRestriction(ADMIN_RECEIVER_COMPONENT,
                UserManager.DISALLOW_MODIFY_ACCOUNTS);

        assertEquals(0, mAccountManager.getAccountsByType(ACCOUNT_TYPE_1).length);
        // Management is disabled, but the device / profile owner is still allowed to use the APIs
        Bundle result = mAccountManager.addAccount(ACCOUNT_TYPE_1,
                null, null, null, null, null, null).getResult();

        // Normally the expected result of addAccount() is AccountManager returning
        // an intent to start the authenticator activity for adding new accounts.
        // But MockAccountAuthenticator returns a new account straightway.
        assertEquals(ACCOUNT_TYPE_1, result.getString(AccountManager.KEY_ACCOUNT_TYPE));

        result = mAccountManager.removeAccount(ACCOUNT, null, null, null).getResult();
        assertTrue(result.getBoolean(AccountManager.KEY_BOOLEAN_RESULT));
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.AllowedAccountManagementTest"	"testRemoveAccount_noUserRestriction"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/AllowedAccountManagementTest.java"	""	"public void testRemoveAccount_noUserRestriction()
            throws AuthenticatorException, IOException, OperationCanceledException {
        // We only want to verify removeAccount can through to AccountManagerService without
        // throwing an Exception, so it's not necessary to add the account before removal.
        Bundle result = mAccountManager.removeAccount(ACCOUNT, null, null, null).getResult();
        assertTrue(result.getBoolean(AccountManager.KEY_BOOLEAN_RESULT));
    }

    private void clearAllAccountManagementDisabled() {
        for (String accountType : mDevicePolicyManager.getAccountTypesWithManagementDisabled()) {
            mDevicePolicyManager.setAccountManagementDisabled(ADMIN_RECEIVER_COMPONENT, accountType,
                    false);
        }
        assertEquals(0, mDevicePolicyManager.getAccountTypesWithManagementDisabled().length);
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.admin.cts.DevicePolicyManagerTest"	"testSetApplicationRestrictions_failIfNotProfileOwner"	"CtsAdminTestCases"	"/home/gpoor/cts-12-source/cts/tests/admin/src/android/admin/cts/DevicePolicyManagerTest.java"	""	"public void testSetApplicationRestrictions_failIfNotProfileOwner() {
        if (!mDeviceAdmin) {
            Log.w(TAG, ""Skipping testSetApplicationRestrictions_failIfNotProfileOwner"");
            return;
        }
        try {
            mDevicePolicyManager.setApplicationRestrictions(mComponent,
                    ""android.admin.cts"", null);
            fail(""did not throw expected SecurityException"");
        } catch (SecurityException e) {
            assertProfileOwnerMessage(e.getMessage());
        }
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.admin.cts.DevicePolicyManagerTest"	"testAddUserRestriction_failIfNotProfileOwner"	"CtsAdminTestCases"	"/home/gpoor/cts-12-source/cts/tests/admin/src/android/admin/cts/DevicePolicyManagerTest.java"	""	"public void testAddUserRestriction_failIfNotProfileOwner() {
        if (!mDeviceAdmin) {
            Log.w(TAG, ""Skipping testAddUserRestriction_failIfNotProfileOwner"");
            return;
        }
        try {
            mDevicePolicyManager.addUserRestriction(mComponent,
                    UserManager.DISALLOW_SMS);
            fail(""did not throw expected SecurityException"");
        } catch (SecurityException e) {
            assertProfileOwnerMessage(e.getMessage());
        }
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.admin.cts.DevicePolicyManagerTest"	"testSetRestrictionsProvider_failIfNotProfileOwner"	"CtsAdminTestCases"	"/home/gpoor/cts-12-source/cts/tests/admin/src/android/admin/cts/DevicePolicyManagerTest.java"	""	"public void testSetRestrictionsProvider_failIfNotProfileOwner() {
        if (!mDeviceAdmin) {
            Log.w(TAG, ""Skipping testSetRestrictionsProvider_failIfNotProfileOwner"");
            return;
        }
        try {
            mDevicePolicyManager.setRestrictionsProvider(mComponent,
                    new ComponentName(""android.admin.cts"", ""dummy""));
            fail(""did not throw expected SecurityException"");
        } catch (SecurityException e) {
            assertProfileOwnerMessage(e.getMessage());
        }
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.admin.cts.DevicePolicyManagerTest"	"testCreateAdminSupportIntent_returnNullIfRestrictionIsNotSet"	"CtsAdminTestCases"	"/home/gpoor/cts-12-source/cts/tests/admin/src/android/admin/cts/DevicePolicyManagerTest.java"	""	"public void testCreateAdminSupportIntent_returnNullIfRestrictionIsNotSet() {
        if (!mDeviceAdmin) {
            Log.w(TAG, ""Skipping testCreateAdminSupportIntent"");
            return;
        }
        Intent intent = mDevicePolicyManager.createAdminSupportIntent(
                DevicePolicyManager.POLICY_DISABLE_CAMERA);
        assertNull(intent);
        intent = mDevicePolicyManager.createAdminSupportIntent(UserManager.DISALLOW_ADJUST_VOLUME);
        assertNull(intent);
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.managedprofile.CameraPolicyTest"	"testEnableCameraInManagedProfile"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/ManagedProfile/src/com/android/cts/managedprofile/CameraPolicyTest.java"	""	"public void testEnableCameraInManagedProfile() throws Exception {
        mDevicePolicyManager.setCameraDisabled(mManagedProfileAdminComponent, false);
        assertFalse(mDevicePolicyManager.getCameraDisabled(mManagedProfileAdminComponent));
        assertFalse(mDevicePolicyManager.getCameraDisabled(null));
        checkCanOpenCamera(true);
    }


    /**
     * Beginning with Android 7.0, the camera restriction policy isn't kept in the
     * system property(""sys.secpolicy.camera.off_<userId>"") anymore, CameraService
     * now checks if camera is disabled via AppOpsService.
     *
     * The propagation of camera retriction policy from DevicePolicyManagerService
     * to UserManagerService and then finally to AppOpsService is NOT synchronous,
     * so here #blockUntilOpenCamera is called many times until policy is enforced
     * or timed out.
     *
     * @see android.app.AppOpsManager#checkOp(String, int, String)
     * @see android.app.AppOpsManager.OnOpChangedListener
     */
    private void checkCanOpenCamera(boolean canOpen) throws Exception {
        int retries = 10;
        boolean successToOpen = !canOpen;
        while (successToOpen != canOpen && retries > 0) {
            retries--;
            Thread.sleep(500);
            successToOpen = CameraUtils
                    .blockUntilOpenCamera(mCameraManager, mBackgroundHandler);
        }
        assertEquals(String.format(""Timed out waiting the value to change to %b (actual=%b)"",
                    canOpen, successToOpen), canOpen, successToOpen);
    }

    /**
     * Starts a background thread and its {@link Handler}.
     */
    private void startBackgroundThread() {
        mBackgroundThread = new HandlerThread(""CameraBackground"");
        mBackgroundThread.start();
        mBackgroundHandler = new Handler(mBackgroundThread.getLooper());
    }

    /**
     * Stops the background thread and its {@link Handler}.
     */
    private void stopBackgroundThread() {
        mBackgroundThread.quitSafely();
        try {
            mBackgroundThread.join();
            mBackgroundThread = null;
            mBackgroundHandler = null;
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.comp.provisioning.UserRestrictionTest"	"testAddDisallowRemoveUserRestriction"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/CorpOwnedManagedProfile/src/com/android/cts/comp/provisioning/UserRestrictionTest.java"	""	"public void testAddDisallowRemoveUserRestriction() {
        setUserRestriction(UserManager.DISALLOW_REMOVE_USER, true);
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.comp.provisioning.UserRestrictionTest"	"testClearDisallowRemoveUserRestriction"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/CorpOwnedManagedProfile/src/com/android/cts/comp/provisioning/UserRestrictionTest.java"	""	"public void testClearDisallowRemoveUserRestriction() {
        setUserRestriction(UserManager.DISALLOW_REMOVE_USER, false);
    }

    private void setUserRestriction(String restriction, boolean add) {
        DevicePolicyManager dpm = getContext().getSystemService(DevicePolicyManager.class);
        ComponentName admin = AdminReceiver.getComponentName(getContext());
        if (add) {
            dpm.addUserRestriction(admin, restriction);
        } else {
            dpm.clearUserRestriction(admin, restriction);
        }
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.delegate.AppRestrictionsIsCallerDelegateHelper"	"isCallerApplicationRestrictionsManagingPackage"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DelegateApp/src/com/android/cts/delegate/AppRestrictionsIsCallerDelegateHelper.java"	""	"public void test/*
 *.
 */

package com.android.cts.delegate;

import static com.google.common.truth.Truth.assertThat;

import android.app.admin.DevicePolicyManager;
import android.test.InstrumentationTestCase;

/**
 *  A helper for testing the {@link
 *  DevicePolicyManager#isCallerApplicationRestrictionsManagingPackage()} method.
 *  <p>The method names start with ""test"" to be recognized by {@link InstrumentationTestCase}.
 */
public class AppRestrictionsIsCallerDelegateHelper extends InstrumentationTestCase {

    private DevicePolicyManager mDevicePolicyManager;

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        mDevicePolicyManager =
            getInstrumentation().getContext().getSystemService(DevicePolicyManager.class);
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.delegate.AppRestrictionsIsCallerDelegateHelper"	"testAssertCallerIsApplicationRestrictionsManagingPackage"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DelegateApp/src/com/android/cts/delegate/AppRestrictionsIsCallerDelegateHelper.java"	""	"public void testAssertCallerIsApplicationRestrictionsManagingPackage() {
        assertThat(mDevicePolicyManager.isCallerApplicationRestrictionsManagingPackage()).isTrue();
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.delegate.AppRestrictionsIsCallerDelegateHelper"	"testAssertCallerIsNotApplicationRestrictionsManagingPackage"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DelegateApp/src/com/android/cts/delegate/AppRestrictionsIsCallerDelegateHelper.java"	""	"public void testAssertCallerIsNotApplicationRestrictionsManagingPackage() {
        assertThat(mDevicePolicyManager.isCallerApplicationRestrictionsManagingPackage()).isFalse();
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.delegate.AppRestrictionsDelegateTest"	"testCannotAccessApis"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DelegateApp/src/com/android/cts/delegate/AppRestrictionsDelegateTest.java"	""	"public void testCannotAccessApis() {
        assertFalse(""DelegateApp should not be an app restrictions delegate"",
                amIAppRestrictionsDelegate());

        assertExpectException(SecurityException.class,
                ""Calling identity is not authorized"", () -> {
                    mDpm.setApplicationRestrictions(null, APP_RESTRICTIONS_TARGET_PKG, null);
                });

        assertExpectException(SecurityException.class,
                ""Calling identity is not authorized"", () -> {
                    mDpm.getApplicationRestrictions(null, APP_RESTRICTIONS_TARGET_PKG);
                });
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.delegate.AppRestrictionsDelegateTest"	"testCanAccessApis"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DelegateApp/src/com/android/cts/delegate/AppRestrictionsDelegateTest.java"	""	"public void testCanAccessApis() throws InterruptedException {
        assertTrue(""DelegateApp is not an app restrictions delegate"", amIAppRestrictionsDelegate());
        try {
            mDpm.setApplicationRestrictions(null, APP_RESTRICTIONS_TARGET_PKG, BUNDLE_0);
            assertBundle0(mDpm.getApplicationRestrictions(null, APP_RESTRICTIONS_TARGET_PKG));

            // Check that the target app can retrieve the same restrictions.
            assertBundle0(waitForChangedRestriction());

            // Test overwriting
            mDpm.setApplicationRestrictions(null, APP_RESTRICTIONS_TARGET_PKG, BUNDLE_1);
            assertBundle1(mDpm.getApplicationRestrictions(null, APP_RESTRICTIONS_TARGET_PKG));
            assertBundle1(waitForChangedRestriction());
        } finally {
            mDpm.setApplicationRestrictions(null, APP_RESTRICTIONS_TARGET_PKG, new Bundle());
            assertTrue(
                mDpm.getApplicationRestrictions(null, APP_RESTRICTIONS_TARGET_PKG).isEmpty());
        }
    }

    // Should be consistent with assertBundle0
    private static Bundle createBundle0() {
        Bundle result = new Bundle();
        result.putString(""placeholderString"", ""value"");
        return result;
    }

    // Should be consistent with createBundle0
    private void assertBundle0(Bundle bundle) {
        assertEquals(1, bundle.size());
        assertEquals(""value"", bundle.getString(""placeholderString""));
    }

    // Should be consistent with assertBundle1
    private static Bundle createBundle1() {
        Bundle result = new Bundle();
        result.putInt(""placeholderInt"", 1);
        return result;
    }

    // Should be consistent with createBundle1
    private void assertBundle1(Bundle bundle) {
        assertEquals(1, bundle.size());
        assertEquals(1, bundle.getInt(""placeholderInt""));
    }

    private void startTestActivity() {
        ComponentName component = new ComponentName(
                APP_RESTRICTIONS_TARGET_PKG, APP_RESTRICTIONS_ACTIVITY_NAME);
        Log.d(TAG, ""Starting activity "" + component.flattenToShortString() + "" on user ""
                + Process.myUserHandle());
        mContext.startActivity(new Intent()
                .setComponent(component)
                .addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_NEW_TASK));
    }

    private Bundle waitForChangedRestriction() throws InterruptedException {
        startTestActivity();
        assertTrue(""App restrictions target app did not respond in time"",
                mOnRestrictionsSemaphore.tryAcquire(TIMEOUT_SECONDS, TimeUnit.SECONDS));
        return mReceivedRestrictions;
    }

    private boolean amIAppRestrictionsDelegate() {
        final List<String> scopes = mDpm.getDelegatedScopes(null, mContext.getPackageName());
        return scopes.contains(DELEGATION_APP_RESTRICTIONS);
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.cts.statsdatom.statsd.HostAtomTests"	"isNotNull"	"CtsStatsdAtomHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/statsd/HostAtomTests.java"	""	"public void test/*
 *.
 */
package android.cts.statsdatom.statsd;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import android.cts.statsdatom.lib.AtomTestUtils;
import android.cts.statsdatom.lib.ConfigUtils;
import android.cts.statsdatom.lib.DeviceUtils;
import android.cts.statsdatom.lib.ReportUtils;
import android.os.BatteryPluggedStateEnum;
import android.os.BatteryStatusEnum;
import android.os.StatsDataDumpProto;
import android.platform.test.annotations.RestrictedBuildTest;
import android.server.DeviceIdleModeEnum;
import android.view.DisplayStateEnum;
import android.telephony.NetworkTypeEnum;

import com.android.internal.os.StatsdConfigProto.StatsdConfig;
import com.android.os.AtomsProto.AppBreadcrumbReported;
import com.android.os.AtomsProto.Atom;
import com.android.os.AtomsProto.BatterySaverModeStateChanged;
import com.android.os.AtomsProto.BuildInformation;
import com.android.os.AtomsProto.ConnectivityStateChanged;
import com.android.os.AtomsProto.SimSlotState;
import com.android.os.AtomsProto.SupportedRadioAccessFamily;
import com.android.os.StatsLog.ConfigMetricsReportList;
import com.android.os.StatsLog.EventMetricData;
import com.android.tradefed.build.IBuildInfo;
import com.android.tradefed.log.LogUtil;
import com.android.tradefed.testtype.DeviceTestCase;
import com.android.tradefed.testtype.IBuildReceiver;

import com.google.common.collect.Range;
import com.google.protobuf.ByteString;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Statsd atom tests that are done via adb (hostside).
 */
public class HostAtomTests extends DeviceTestCase implements IBuildReceiver {

    private static final String TAG = ""Statsd.HostAtomTests"";

    private static final String DUMPSYS_STATS_CMD = ""dumpsys stats"";

    // Either file must exist to read kernel wake lock stats.
    private static final String WAKE_LOCK_FILE = ""/proc/wakelocks"";
    private static final String WAKE_SOURCES_FILE = ""/d/wakeup_sources"";

    private static final String FEATURE_AUTOMOTIVE = ""android.hardware.type.automotive"";
    private static final String FEATURE_WATCH = ""android.hardware.type.watch"";
    private static final String FEATURE_TWM = ""com.google.clockwork.hardware.traditional_watch_mode"";
    private static final String FEATURE_WIFI = ""android.hardware.wifi"";
    private static final String FEATURE_LEANBACK_ONLY = ""android.software.leanback_only"";

    private IBuildInfo mCtsBuild;

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        assertThat(mCtsBuild).isNotNull();
        ConfigUtils.removeConfig(getDevice());
        ReportUtils.clearReports(getDevice());
        DeviceUtils.installStatsdTestApp(getDevice(), mCtsBuild);
        DeviceUtils.turnBatteryStatsAutoResetOff(getDevice());
        Thread.sleep(AtomTestUtils.WAIT_TIME_LONG);
    }

    @Override
    protected void tearDown() throws Exception {
        ConfigUtils.removeConfig(getDevice());
        ReportUtils.clearReports(getDevice());
        DeviceUtils.uninstallStatsdTestApp(getDevice());
        DeviceUtils.turnBatteryStatsAutoResetOn(getDevice());
        super.tearDown();
    }

    @Override
    public void setBuild(IBuildInfo buildInfo) {
        mCtsBuild = buildInfo;
    }"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.cts.statsdatom.statsd.HostAtomTests"	"testBatterySaverModeStateChangedAtom"	"CtsStatsdAtomHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/statsd/HostAtomTests.java"	""	"public void testBatterySaverModeStateChangedAtom() throws Exception {
        if (DeviceUtils.hasFeature(getDevice(), FEATURE_TWM)) return;
        if (DeviceUtils.hasFeature(getDevice(), FEATURE_AUTOMOTIVE)) return;
        // Setup, turn off battery saver.
        turnBatterySaverOff();
        DeviceUtils.flushBatteryStatsHandlers(getDevice());

        final int atomTag = Atom.BATTERY_SAVER_MODE_STATE_CHANGED_FIELD_NUMBER;

        Set<Integer> batterySaverOn = new HashSet<>(
                Arrays.asList(BatterySaverModeStateChanged.State.ON_VALUE));
        Set<Integer> batterySaverOff = new HashSet<>(
                Arrays.asList(BatterySaverModeStateChanged.State.OFF_VALUE));

        // Add state sets to the list in order.
        List<Set<Integer>> stateSet = Arrays.asList(batterySaverOn, batterySaverOff);

        ConfigUtils.uploadConfigForPushedAtom(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                atomTag);

        // Trigger events in same order.
        turnBatterySaverOn();
        Thread.sleep(AtomTestUtils.WAIT_TIME_LONG);
        turnBatterySaverOff();
        DeviceUtils.flushBatteryStatsHandlers(getDevice());

        // Sorted list of events in order in which they occurred.
        List<EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());

        // Assert that the events happened in the expected order.
        AtomTestUtils.assertStatesOccurred(stateSet, data, AtomTestUtils.WAIT_TIME_LONG,
                atom -> atom.getBatterySaverModeStateChanged().getState().getNumber());
    }

    @RestrictedBuildTest"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.cts.statsdatom.statsd.HostAtomTests"	"testRemainingBatteryCapacity"	"CtsStatsdAtomHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/statsd/HostAtomTests.java"	""	"public void testRemainingBatteryCapacity() throws Exception {
        if (DeviceUtils.hasFeature(getDevice(), FEATURE_WATCH)) return;
        if (DeviceUtils.hasFeature(getDevice(), FEATURE_AUTOMOTIVE)) return;

        ConfigUtils.uploadConfigForPulledAtom(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                Atom.REMAINING_BATTERY_CAPACITY_FIELD_NUMBER);

        AtomTestUtils.sendAppBreadcrumbReportedAtom(getDevice());
        Thread.sleep(AtomTestUtils.WAIT_TIME_LONG);

        List<Atom> data = ReportUtils.getGaugeMetricAtoms(getDevice());

        assertThat(data).isNotEmpty();
        Atom atom = data.get(0);
        assertThat(atom.getRemainingBatteryCapacity().hasChargeMicroAmpereHour()).isTrue();
        if (DeviceUtils.hasBattery(getDevice())) {
            assertThat(atom.getRemainingBatteryCapacity().getChargeMicroAmpereHour())
                    .isGreaterThan(0);
        }
    }

    @RestrictedBuildTest"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.suspendapps.permission.cts.NegativePermissionsTest"	"setDistractingPackageRestrictions"	"CtsSuspendAppsPermissionTestCases"	"/home/gpoor/cts-12-source/cts/tests/suspendapps/permission/src/android/suspendapps/permission/cts/NegativePermissionsTest.java"	""	"public void setDistractingPackageRestrictions() {
        assertSecurityException(
                () -> mPackageManager.setDistractingPackageRestrictions(PACKAGES_TO_SUSPEND,
                        RESTRICTION_HIDE_FROM_SUGGESTIONS),
                ""setDistractingPackageRestrictions:HIDE_FROM_SUGGESTIONS"");
        assertSecurityException(
                () -> mPackageManager.setDistractingPackageRestrictions(PACKAGES_TO_SUSPEND,
                        RESTRICTION_HIDE_FROM_SUGGESTIONS | RESTRICTION_HIDE_NOTIFICATIONS),
                ""setDistractingPackageRestrictions:HIDE_FROM_SUGGESTIONS|HIDE_NOTIFICATIONS"");
        assertSecurityException(
                () -> mPackageManager.setDistractingPackageRestrictions(PACKAGES_TO_SUSPEND,
                        RESTRICTION_HIDE_NOTIFICATIONS),
                ""setDistractingPackageRestrictions:HIDE_NOTIFICATIONS"");
        assertSecurityException(
                () -> mPackageManager.setDistractingPackageRestrictions(PACKAGES_TO_SUSPEND,
                        RESTRICTION_NONE), ""setDistractingPackageRestrictions:NONE"");
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"ProvisioningCallback"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void test/*
 *.
 */

package android.net.wifi.cts;

import static android.net.NetworkCapabilities.NET_CAPABILITY_NOT_METERED;
import static android.net.NetworkCapabilities.TRANSPORT_WIFI;
import static android.net.wifi.WifiAvailableChannel.OP_MODE_SAP;
import static android.net.wifi.WifiAvailableChannel.OP_MODE_STA;
import static android.net.wifi.WifiConfiguration.INVALID_NETWORK_ID;
import static android.net.wifi.WifiManager.COEX_RESTRICTION_SOFTAP;
import static android.net.wifi.WifiManager.COEX_RESTRICTION_WIFI_AWARE;
import static android.net.wifi.WifiManager.COEX_RESTRICTION_WIFI_DIRECT;
import static android.net.wifi.WifiScanner.WIFI_BAND_24_GHZ;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import static org.junit.Assert.assertNotEquals;

import android.annotation.NonNull;
import android.app.UiAutomation;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.content.pm.ResolveInfo;
import android.net.ConnectivityManager;
import android.net.MacAddress;
import android.net.Network;
import android.net.NetworkCapabilities;
import android.net.NetworkInfo;
import android.net.NetworkRequest;
import android.net.TetheringManager;
import android.net.Uri;
import android.net.wifi.CoexUnsafeChannel;
import android.net.wifi.ScanResult;
import android.net.wifi.SoftApCapability;
import android.net.wifi.SoftApConfiguration;
import android.net.wifi.SoftApInfo;
import android.net.wifi.WifiAvailableChannel;
import android.net.wifi.WifiClient;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiEnterpriseConfig;
import android.net.wifi.WifiInfo;
import android.net.wifi.WifiManager;
import android.net.wifi.WifiManager.SubsystemRestartTrackingCallback;
import android.net.wifi.WifiManager.WifiLock;
import android.net.wifi.WifiNetworkConnectionStatistics;
import android.net.wifi.WifiNetworkSuggestion;
import android.net.wifi.hotspot2.ConfigParser;
import android.net.wifi.hotspot2.OsuProvider;
import android.net.wifi.hotspot2.PasspointConfiguration;
import android.net.wifi.hotspot2.ProvisioningCallback;
import android.net.wifi.hotspot2.pps.Credential;
import android.net.wifi.hotspot2.pps.HomeSp;
import android.os.Build;
import android.os.Handler;
import android.os.HandlerExecutor;
import android.os.HandlerThread;
import android.os.Process;
import android.os.SystemClock;
import android.os.UserHandle;
import android.platform.test.annotations.AppModeFull;
import android.platform.test.annotations.AsbSecurityTest;
import android.provider.Settings;
import android.support.test.uiautomator.UiDevice;
import android.telephony.TelephonyManager;
import android.text.TextUtils;
import android.util.ArraySet;
import android.util.Log;
import android.util.SparseArray;
import android.util.SparseIntArray;

import androidx.test.filters.SdkSuppress;
import androidx.test.platform.app.InstrumentationRegistry;

import com.android.compatibility.common.util.ApiLevelUtil;
import com.android.compatibility.common.util.FeatureUtil;
import com.android.compatibility.common.util.PollingCheck;
import com.android.compatibility.common.util.PropertyUtil;
import com.android.compatibility.common.util.ShellIdentityUtils;
import com.android.compatibility.common.util.SystemUtil;
import com.android.compatibility.common.util.ThrowingRunnable;
import com.android.modules.utils.build.SdkLevel;
import com.android.net.module.util.MacAddressUtils;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.lang.reflect.Constructor;
import java.net.HttpURLConnection;
import java.net.InetAddress;
import java.net.URL;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

@AppModeFull(reason = ""Cannot get WifiManager in instant app mode"")
public class WifiManagerTest extends WifiJUnit3TestBase {
    private static class MySync {
        int expectedState = STATE_NULL;
    }

    private WifiManager mWifiManager;
    private ConnectivityManager mConnectivityManager;
    private TetheringManager mTetheringManager;
    private WifiLock mWifiLock;
    private static MySync mMySync;
    private List<ScanResult> mScanResults = null;
    private NetworkInfo mNetworkInfo =
            new NetworkInfo(ConnectivityManager.TYPE_WIFI, TelephonyManager.NETWORK_TYPE_UNKNOWN,
                    ""wifi"", ""unknown"");
    private final Object mLock = new Object();
    private UiDevice mUiDevice;
    private boolean mWasVerboseLoggingEnabled;
    private boolean mWasScanThrottleEnabled;
    private SoftApConfiguration mOriginalSoftApConfig = null;

    // Please refer to WifiManager
    private static final int MIN_RSSI = -100;
    private static final int MAX_RSSI = -55;

    private static final int STATE_NULL = 0;
    private static final int STATE_WIFI_CHANGING = 1;
    private static final int STATE_WIFI_ENABLED = 2;
    private static final int STATE_WIFI_DISABLED = 3;
    private static final int STATE_SCANNING = 4;
    private static final int STATE_SCAN_DONE = 5;

    private static final String TAG = ""WifiManagerTest"";
    private static final String SSID1 = ""\""WifiManagerTest\"""";
    // A full single scan duration is about 6-7 seconds if country code is set
    // to US. If country code is set to world mode (00), we would expect a scan
    // duration of roughly 8 seconds. So we set scan timeout as 9 seconds here.
    private static final int SCAN_TEST_WAIT_DURATION_MS = 9000;
    private static final int TEST_WAIT_DURATION_MS = 10_000;
    private static final int WIFI_CONNECT_TIMEOUT_MILLIS = 30_000;
    private static final int WAIT_MSEC = 60;
    private static final int DURATION_SCREEN_TOGGLE = 2000;
    private static final int DURATION_SETTINGS_TOGGLE = 1_000;
    private static final int WIFI_SCAN_TEST_CACHE_DELAY_MILLIS = 3 * 60 * 1000;

    private static final int ENFORCED_NUM_NETWORK_SUGGESTIONS_PER_APP = 50;

    private static final String TEST_PAC_URL = ""http://www.example.com/proxy.pac"";
    private static final String MANAGED_PROVISIONING_PACKAGE_NAME
            = ""com.android.managedprovisioning"";

    private static final String TEST_SSID_UNQUOTED = ""testSsid1"";
    private static final String TEST_IP_ADDRESS = ""192.168.5.5"";
    private static final String TEST_MAC_ADDRESS = ""aa:bb:cc:dd:ee:ff"";
    private static final MacAddress TEST_MAC = MacAddress.fromString(TEST_MAC_ADDRESS);
    private static final String TEST_PASSPHRASE = ""passphrase"";
    private static final String PASSPOINT_INSTALLATION_FILE_WITH_CA_CERT =
            ""assets/ValidPasspointProfile.base64"";
    private static final String TYPE_WIFI_CONFIG = ""application/x-wifi-config"";
    private static final String TEST_PSK_CAP = ""[RSN-PSK-CCMP]"";
    private static final String TEST_BSSID = ""00:01:02:03:04:05"";
    private static final String TEST_COUNTRY_CODE = ""JP"";
    private static final String TEST_DOM_SUBJECT_MATCH = ""domSubjectMatch"";
    private static final int TEST_SUB_ID = 2;

    private IntentFilter mIntentFilter;
    private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            final String action = intent.getAction();
            if (action.equals(WifiManager.SCAN_RESULTS_AVAILABLE_ACTION)) {

                synchronized (mMySync) {
                    if (intent.getBooleanExtra(WifiManager.EXTRA_RESULTS_UPDATED, false)) {
                        mScanResults = mWifiManager.getScanResults();
                    } else {
                        mScanResults = null;
                    }
                    mMySync.expectedState = STATE_SCAN_DONE;
                    mMySync.notifyAll();
                }
            } else if (action.equals(WifiManager.WIFI_STATE_CHANGED_ACTION)) {
                int newState = intent.getIntExtra(WifiManager.EXTRA_WIFI_STATE,
                        WifiManager.WIFI_STATE_UNKNOWN);
                synchronized (mMySync) {
                    if (newState == WifiManager.WIFI_STATE_ENABLED) {
                        Log.d(TAG, ""*** New WiFi state is ENABLED ***"");
                        mMySync.expectedState = STATE_WIFI_ENABLED;
                        mMySync.notifyAll();
                    } else if (newState == WifiManager.WIFI_STATE_DISABLED) {
                        Log.d(TAG, ""*** New WiFi state is DISABLED ***"");
                        mMySync.expectedState = STATE_WIFI_DISABLED;
                        mMySync.notifyAll();
                    }
                }
            } else if (action.equals(WifiManager.NETWORK_STATE_CHANGED_ACTION)) {
                synchronized (mMySync) {
                    mNetworkInfo =
                            (NetworkInfo) intent.getParcelableExtra(WifiManager.EXTRA_NETWORK_INFO);
                    if (mNetworkInfo.getState() == NetworkInfo.State.CONNECTED)
                        mMySync.notifyAll();
                }
            }
        }
    };
    // Initialize with an invalid status value (0)
    private int mProvisioningStatus = 0;
    // Initialize with an invalid status value (0)
    private int mProvisioningFailureStatus = 0;
    private boolean mProvisioningComplete = false;
    private ProvisioningCallback mProvisioningCallback = new ProvisioningCallback() {
        @Override
        public void onProvisioningFailure(int status) {
            synchronized (mLock) {
                mProvisioningFailureStatus = status;
                mLock.notify();
            }
        }

        @Override
        public void onProvisioningStatus(int status) {
            synchronized (mLock) {
                mProvisioningStatus = status;
                mLock.notify();
            }
        }

        @Override
        public void onProvisioningComplete() {
            mProvisioningComplete = true;
        }
    };
    private int mSubsystemRestartStatus = 0; // 0: nada, 1: restarting, 2: restarted
    private SubsystemRestartTrackingCallback mSubsystemRestartTrackingCallback =
            new SubsystemRestartTrackingCallback() {
                @Override
                public void onSubsystemRestarting() {
                    synchronized (mLock) {
                        mSubsystemRestartStatus = 1;
                        mLock.notify();
                    }
                }

                @Override
                public void onSubsystemRestarted() {
                    synchronized (mLock) {
                        mSubsystemRestartStatus = 2;
                        mLock.notify();
                    }
                }
            };
    private static final String TEST_SSID = ""TEST SSID"";
    private static final String TEST_FRIENDLY_NAME = ""Friendly Name"";
    private static final Map<String, String> TEST_FRIENDLY_NAMES =
            new HashMap<String, String>() {
                {
                    put(""en"", TEST_FRIENDLY_NAME);
                    put(""kr"", TEST_FRIENDLY_NAME + 2);
                    put(""jp"", TEST_FRIENDLY_NAME + 3);
                }
            };
    private static final String TEST_SERVICE_DESCRIPTION = ""Dummy Service"";
    private static final Uri TEST_SERVER_URI = Uri.parse(""https://test.com"");
    private static final String TEST_NAI = ""test.access.com"";
    private static final List<Integer> TEST_METHOD_LIST =
            Arrays.asList(1 /* METHOD_SOAP_XML_SPP */);
    private final HandlerThread mHandlerThread = new HandlerThread(""WifiManagerTest"");
    protected final Executor mExecutor;
    {
        mHandlerThread.start();
        mExecutor = new HandlerExecutor(new Handler(mHandlerThread.getLooper()));
    }

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        mMySync = new MySync();
        mIntentFilter = new IntentFilter();
        mIntentFilter.addAction(WifiManager.NETWORK_STATE_CHANGED_ACTION);
        mIntentFilter.addAction(WifiManager.SCAN_RESULTS_AVAILABLE_ACTION);
        mIntentFilter.addAction(WifiManager.SUPPLICANT_CONNECTION_CHANGE_ACTION);
        mIntentFilter.addAction(WifiManager.SUPPLICANT_STATE_CHANGED_ACTION);
        mIntentFilter.addAction(WifiManager.WIFI_STATE_CHANGED_ACTION);
        mIntentFilter.addAction(WifiManager.RSSI_CHANGED_ACTION);
        mIntentFilter.addAction(WifiManager.NETWORK_IDS_CHANGED_ACTION);
        mIntentFilter.addAction(WifiManager.ACTION_PICK_WIFI_NETWORK);

        mContext.registerReceiver(mReceiver, mIntentFilter);
        mWifiManager = (WifiManager) getContext().getSystemService(Context.WIFI_SERVICE);
        mConnectivityManager = getContext().getSystemService(ConnectivityManager.class);
        mTetheringManager = getContext().getSystemService(TetheringManager.class);
        assertNotNull(mWifiManager);
        assertNotNull(mTetheringManager);

        // turn on verbose logging for tests
        mWasVerboseLoggingEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.isVerboseLoggingEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setVerboseLoggingEnabled(true));
        // Disable scan throttling for tests.
        mWasScanThrottleEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.isScanThrottleEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setScanThrottleEnabled(false));

        mWifiLock = mWifiManager.createWifiLock(TAG);
        mWifiLock.acquire();
        // enable Wifi
        if (!mWifiManager.isWifiEnabled()) setWifiEnabled(true);
        PollingCheck.check(""Wifi not enabled"", TEST_WAIT_DURATION_MS,
                () -> mWifiManager.isWifiEnabled());

        mUiDevice = UiDevice.getInstance(InstrumentationRegistry.getInstrumentation());
        turnScreenOnNoDelay();

        synchronized (mMySync) {
            mMySync.expectedState = STATE_NULL;
        }

        List<WifiConfiguration> savedNetworks = ShellIdentityUtils.invokeWithShellPermissions(
                mWifiManager::getConfiguredNetworks);
        assertFalse(""Need at least one saved network"", savedNetworks.isEmpty());

        // Get original config for restore
        mOriginalSoftApConfig = ShellIdentityUtils.invokeWithShellPermissions(
                mWifiManager::getSoftApConfiguration);
    }

    @Override
    protected void tearDown() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            super.tearDown();
            return;
        }
        if (!mWifiManager.isWifiEnabled())
            setWifiEnabled(true);
        mWifiLock.release();
        mContext.unregisterReceiver(mReceiver);
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setScanThrottleEnabled(mWasScanThrottleEnabled));
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setVerboseLoggingEnabled(mWasVerboseLoggingEnabled));
        // restore original softap config
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setSoftApConfiguration(mOriginalSoftApConfig));
        Thread.sleep(TEST_WAIT_DURATION_MS);
        super.tearDown();
    }

    private void setWifiEnabled(boolean enable) throws Exception {
        synchronized (mMySync) {
            if (mWifiManager.isWifiEnabled() != enable) {
                // the new state is different, we expect it to change
                mMySync.expectedState = STATE_WIFI_CHANGING;
            } else {
                mMySync.expectedState = (enable ? STATE_WIFI_ENABLED : STATE_WIFI_DISABLED);
            }
            // now trigger the change using shell commands.
            SystemUtil.runShellCommand(""svc wifi "" + (enable ? ""enable"" : ""disable""));
            waitForExpectedWifiState(enable);
        }
    }

    private void waitForExpectedWifiState(boolean enabled) throws InterruptedException {
        synchronized (mMySync) {
            long timeout = System.currentTimeMillis() + TEST_WAIT_DURATION_MS;
            int expected = (enabled ? STATE_WIFI_ENABLED : STATE_WIFI_DISABLED);
            while (System.currentTimeMillis() < timeout
                    && mMySync.expectedState != expected) {
                mMySync.wait(WAIT_MSEC);
            }
        }
    }

    // Get the current scan status from sticky broadcast.
    private boolean isScanCurrentlyAvailable() {
        IntentFilter intentFilter = new IntentFilter();
        intentFilter.addAction(WifiManager.ACTION_WIFI_SCAN_AVAILABILITY_CHANGED);
        Intent intent = mContext.registerReceiver(null, intentFilter);
        assertNotNull(intent);
        if (intent.getAction().equals(WifiManager.ACTION_WIFI_SCAN_AVAILABILITY_CHANGED)) {
            return intent.getBooleanExtra(WifiManager.EXTRA_SCAN_AVAILABLE, false);
        }
        return false;
    }

    private void startScan() throws Exception {
        synchronized (mMySync) {
            mMySync.expectedState = STATE_SCANNING;
            mScanResults = null;
            assertTrue(mWifiManager.startScan());
            long timeout = System.currentTimeMillis() + SCAN_TEST_WAIT_DURATION_MS;
            while (System.currentTimeMillis() < timeout && mMySync.expectedState == STATE_SCANNING)
                mMySync.wait(WAIT_MSEC);
        }
    }

    private void waitForNetworkInfoState(NetworkInfo.State state, int timeoutMillis)
            throws Exception {
        synchronized (mMySync) {
            if (mNetworkInfo.getState() == state) return;
            long timeout = System.currentTimeMillis() + timeoutMillis;
            while (System.currentTimeMillis() < timeout
                    && mNetworkInfo.getState() != state)
                mMySync.wait(WAIT_MSEC);
            assertEquals(state, mNetworkInfo.getState());
        }
    }

    private void waitForConnection() throws Exception {
        waitForNetworkInfoState(NetworkInfo.State.CONNECTED, WIFI_CONNECT_TIMEOUT_MILLIS);
    }

    private void waitForDisconnection() throws Exception {
        waitForNetworkInfoState(NetworkInfo.State.DISCONNECTED, TEST_WAIT_DURATION_MS);
    }

    private void ensureNotNetworkInfoState(NetworkInfo.State state) throws Exception {
        synchronized (mMySync) {
            long timeout = System.currentTimeMillis() + TEST_WAIT_DURATION_MS + WAIT_MSEC;
            while (System.currentTimeMillis() < timeout) {
                assertNotEquals(state, mNetworkInfo.getState());
                mMySync.wait(WAIT_MSEC);
            }
        }
    }

    private void ensureNotConnected() throws Exception {
        ensureNotNetworkInfoState(NetworkInfo.State.CONNECTED);
    }

    private void ensureNotDisconnected() throws Exception {
        ensureNotNetworkInfoState(NetworkInfo.State.DISCONNECTED);
    }

    private boolean existSSID(String ssid) {
        for (final WifiConfiguration w : mWifiManager.getConfiguredNetworks()) {
            if (w.SSID.equals(ssid))
                return true;
        }
        return false;
    }

    private int findConfiguredNetworks(String SSID, List<WifiConfiguration> networks) {
        for (final WifiConfiguration w : networks) {
            if (w.SSID.equals(SSID))
                return networks.indexOf(w);
        }
        return -1;
    }

    /**
     * Test creation of WifiManager Lock.
     */"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testIs60GhzBandSupportedOnSOrNewer"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testIs60GhzBandSupportedOnSOrNewer() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }

        // check for 60ghz support with wifi enabled
        boolean isSupportedWhenWifiEnabled = mWifiManager.is60GHzBandSupported();

        // Check for 60GHz support with wifi disabled
        setWifiEnabled(false);
        PollingCheck.check(
                ""Wifi not disabled!"",
                20000,
                () -> !mWifiManager.isWifiEnabled());
        boolean isSupportedWhenWifiDisabled = mWifiManager.is60GHzBandSupported();

        // If Support is true when WiFi is disable, then it has to be true when it is enabled.
        // Note, the reverse is a valid case.
        if (isSupportedWhenWifiDisabled) {
            assertTrue(isSupportedWhenWifiEnabled);
        }
    }

    public class TestCoexCallback extends WifiManager.CoexCallback {
        private Object mCoexLock;
        private int mOnCoexUnsafeChannelChangedCount;
        private List<CoexUnsafeChannel> mCoexUnsafeChannels;
        private int mCoexRestrictions;

        TestCoexCallback(Object lock) {
            mCoexLock = lock;
        }

        @Override
        public void onCoexUnsafeChannelsChanged(
                    @NonNull List<CoexUnsafeChannel> unsafeChannels, int restrictions) {
            synchronized (mCoexLock) {
                mCoexUnsafeChannels = unsafeChannels;
                mCoexRestrictions = restrictions;
                mOnCoexUnsafeChannelChangedCount++;
                mCoexLock.notify();
            }
        }

        public int getOnCoexUnsafeChannelChangedCount() {
            synchronized (mCoexLock) {
                return mOnCoexUnsafeChannelChangedCount;
            }
        }

        public List<CoexUnsafeChannel> getCoexUnsafeChannels() {
            return mCoexUnsafeChannels;
        }

        public int getCoexRestrictions() {
            return mCoexRestrictions;
        }
    }

    /**
     * Test that coex-related methods fail without the needed privileged permissions
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testListenOnCoexUnsafeChannels"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testListenOnCoexUnsafeChannels() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }

        // These below API's only work with privileged permissions (obtained via shell identity
        // for test)
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        List<CoexUnsafeChannel> prevUnsafeChannels = null;
        int prevRestrictions = -1;
        try {
            uiAutomation.adoptShellPermissionIdentity();
            final TestCoexCallback callback = new TestCoexCallback(mLock);
            final List<CoexUnsafeChannel> testUnsafeChannels = new ArrayList<>();
            testUnsafeChannels.add(new CoexUnsafeChannel(WIFI_BAND_24_GHZ, 6));
            final int testRestrictions = COEX_RESTRICTION_WIFI_DIRECT
                    | COEX_RESTRICTION_SOFTAP | COEX_RESTRICTION_WIFI_AWARE;
            synchronized (mLock) {
                try {
                    mWifiManager.registerCoexCallback(mExecutor, callback);
                    // Callback should be called after registering
                    mLock.wait(TEST_WAIT_DURATION_MS);
                    assertEquals(1, callback.getOnCoexUnsafeChannelChangedCount());
                    // Store the previous coex channels and set new coex channels
                    prevUnsafeChannels = callback.getCoexUnsafeChannels();
                    prevRestrictions = callback.getCoexRestrictions();
                    mWifiManager.setCoexUnsafeChannels(testUnsafeChannels, testRestrictions);
                    mLock.wait(TEST_WAIT_DURATION_MS);
                    // Unregister callback and try setting again
                    mWifiManager.unregisterCoexCallback(callback);
                    mWifiManager.setCoexUnsafeChannels(testUnsafeChannels, testRestrictions);
                    // Callback should not be called here since it was unregistered.
                    mLock.wait(TEST_WAIT_DURATION_MS);
                } catch (InterruptedException e) {
                    fail(""Thread interrupted unexpectedly while waiting on mLock"");
                }
            }
            if (callback.getOnCoexUnsafeChannelChangedCount() == 2) {
                // Default algorithm disabled, setter should set the getter values.
                assertEquals(testUnsafeChannels, callback.getCoexUnsafeChannels());
                assertEquals(testRestrictions, callback.getCoexRestrictions());
            } else if (callback.getOnCoexUnsafeChannelChangedCount() != 1) {
                fail(""Coex callback called "" + callback.mOnCoexUnsafeChannelChangedCount
                        + "" times. Expected 0 or 1 calls."" );
            }
        } finally {
            // Reset the previous unsafe channels if we overrode them.
            if (prevRestrictions != -1) {
                mWifiManager.setCoexUnsafeChannels(prevUnsafeChannels, prevRestrictions);
            }
            uiAutomation.dropShellPermissionIdentity();
        }
    }


    /**
     * Verify that insecure WPA-Enterprise network configurations are rejected.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.suspendapps.cts.DistractingPackageTest"	"isEmpty"	"CtsSuspendAppsTestCases"	"/home/gpoor/cts-12-source/cts/tests/suspendapps/tests/src/android/suspendapps/cts/DistractingPackageTest.java"	""	"/*
 *.
 */

package android.suspendapps.cts;

import static android.content.Intent.EXTRA_PACKAGE_NAME;
import static android.content.pm.PackageManager.RESTRICTION_HIDE_FROM_SUGGESTIONS;
import static android.content.pm.PackageManager.RESTRICTION_HIDE_NOTIFICATIONS;
import static android.suspendapps.cts.Constants.ALL_TEST_PACKAGES;
import static android.suspendapps.cts.Constants.DEVICE_ADMIN_COMPONENT;
import static android.suspendapps.cts.Constants.TEST_APP_PACKAGE_NAME;
import static android.suspendapps.cts.Constants.TEST_PACKAGE_ARRAY;
import static android.suspendapps.cts.SuspendTestUtils.addAndAssertProfileOwner;
import static android.suspendapps.cts.SuspendTestUtils.createSingleKeyBundle;
import static android.suspendapps.cts.SuspendTestUtils.removeDeviceAdmin;
import static android.suspendapps.cts.SuspendTestUtils.requestDpmAction;

import static com.android.suspendapps.testdeviceadmin.TestCommsReceiver.ACTION_ADD_USER_RESTRICTION;
import static com.android.suspendapps.testdeviceadmin.TestCommsReceiver.ACTION_BLOCK_UNINSTALL;
import static com.android.suspendapps.testdeviceadmin.TestCommsReceiver.ACTION_UNBLOCK_UNINSTALL;
import static com.android.suspendapps.testdeviceadmin.TestCommsReceiver.EXTRA_USER_RESTRICTION;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.junit.Assume.assumeTrue;

import android.annotation.NonNull;
import android.app.admin.DevicePolicyManager;
import android.content.ComponentName;
import android.content.Context;
import android.content.pm.LauncherApps;
import android.content.pm.PackageManager;
import android.os.Bundle;
import android.os.Handler;
import android.os.Looper;
import android.os.UserHandle;
import android.os.UserManager;

import androidx.test.InstrumentationRegistry;
import androidx.test.filters.SmallTest;
import androidx.test.runner.AndroidJUnit4;

import com.android.compatibility.common.util.FeatureUtil;
import com.android.compatibility.common.util.SystemUtil;
import com.android.internal.util.ArrayUtils;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.Arrays;

@RunWith(AndroidJUnit4.class)
@SmallTest
public class DistractingPackageTest {
    private Context mContext;
    private PackageManager mPackageManager;
    private Handler mHandler;

    @Before
    public void setUp() {
        mContext = InstrumentationRegistry.getTargetContext();
        mPackageManager = mContext.getPackageManager();
        mHandler = new Handler(Looper.getMainLooper());
    }

    private int getCurrentUserId() {
        final String result = SystemUtil.runShellCommand(""am get-current-user"",
                output -> !output.isEmpty());
        return Integer.parseInt(result.trim());
    }

    private void setDistractionFlagsAndAssertResult(String[] packagesToRestrict,
            int distractionFlags, @NonNull String[] expectedToFail) throws Exception {
        final String[] failed = SystemUtil.callWithShellPermissionIdentity(
                () -> mPackageManager.setDistractingPackageRestrictions(packagesToRestrict,
                        distractionFlags));
        if (failed == null || failed.length != expectedToFail.length
                || !ArrayUtils.containsAll(failed, expectedToFail)) {
            fail(""setDistractingPackageRestrictions failure: failed packages: "" + Arrays.toString(
                    failed) + ""; expected to fail: "" + Arrays.toString(expectedToFail));
        }
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.suspendapps.cts.DistractingPackageTest"	"testShouldHideFromSuggestions"	"CtsSuspendAppsTestCases"	"/home/gpoor/cts-12-source/cts/tests/suspendapps/tests/src/android/suspendapps/cts/DistractingPackageTest.java"	""	"public void testShouldHideFromSuggestions() throws Exception {
        final int currentUserId = getCurrentUserId();
        final LauncherApps launcherApps = mContext.getSystemService(LauncherApps.class);
        assertFalse(""shouldHideFromSuggestions true before setting the flag"",
                launcherApps.shouldHideFromSuggestions(TEST_APP_PACKAGE_NAME,
                        UserHandle.of(currentUserId)));
        setDistractionFlagsAndAssertResult(TEST_PACKAGE_ARRAY, RESTRICTION_HIDE_FROM_SUGGESTIONS,
                ArrayUtils.emptyArray(String.class));
        assertTrue(""shouldHideFromSuggestions false after setting the flag"",
                launcherApps.shouldHideFromSuggestions(TEST_APP_PACKAGE_NAME,
                        UserHandle.of(currentUserId)));
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.suspendapps.cts.DistractingPackageTest"	"testCannotRestrictWhenUninstallBlocked"	"CtsSuspendAppsTestCases"	"/home/gpoor/cts-12-source/cts/tests/suspendapps/tests/src/android/suspendapps/cts/DistractingPackageTest.java"	""	"public void testCannotRestrictWhenUninstallBlocked() throws Exception {
        assumeTrue(FeatureUtil.hasSystemFeature(PackageManager.FEATURE_DEVICE_ADMIN));
        addAndAssertProfileOwner();
        assertTrue(""Block uninstall request failed"", requestDpmAction(ACTION_BLOCK_UNINSTALL,
                createSingleKeyBundle(EXTRA_PACKAGE_NAME, TEST_APP_PACKAGE_NAME), mHandler));
        setDistractionFlagsAndAssertResult(ALL_TEST_PACKAGES, RESTRICTION_HIDE_NOTIFICATIONS,
                TEST_PACKAGE_ARRAY);
    }

    private void assertCannotRestrictUnderUserRestriction(String userRestriction) throws Exception {
        addAndAssertProfileOwner();
        final Bundle extras = createSingleKeyBundle(EXTRA_USER_RESTRICTION, userRestriction);
        assertTrue(""Request to add restriction"" + userRestriction + "" failed"",
                requestDpmAction(ACTION_ADD_USER_RESTRICTION, extras, mHandler));
        setDistractionFlagsAndAssertResult(ALL_TEST_PACKAGES, RESTRICTION_HIDE_FROM_SUGGESTIONS,
                ALL_TEST_PACKAGES);
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.suspendapps.cts.DistractingPackageTest"	"testCannotRestrictUnderDisallowAppsControl"	"CtsSuspendAppsTestCases"	"/home/gpoor/cts-12-source/cts/tests/suspendapps/tests/src/android/suspendapps/cts/DistractingPackageTest.java"	""	"public void testCannotRestrictUnderDisallowAppsControl() throws Exception {
        assumeTrue(FeatureUtil.hasSystemFeature(PackageManager.FEATURE_DEVICE_ADMIN));
        assertCannotRestrictUnderUserRestriction(UserManager.DISALLOW_APPS_CONTROL);
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.suspendapps.cts.DistractingPackageTest"	"testCannotRestrictUnderDisallowUninstallApps"	"CtsSuspendAppsTestCases"	"/home/gpoor/cts-12-source/cts/tests/suspendapps/tests/src/android/suspendapps/cts/DistractingPackageTest.java"	""	"public void testCannotRestrictUnderDisallowUninstallApps() throws Exception {
        assumeTrue(FeatureUtil.hasSystemFeature(PackageManager.FEATURE_DEVICE_ADMIN));
        assertCannotRestrictUnderUserRestriction(UserManager.DISALLOW_UNINSTALL_APPS);
    }

    @After
    public void tearDown() throws Exception {
        final DevicePolicyManager dpm = mContext.getSystemService(DevicePolicyManager.class);
        if (dpm.isAdminActive(ComponentName.unflattenFromString(DEVICE_ADMIN_COMPONENT))) {
            final Bundle extras = createSingleKeyBundle(EXTRA_PACKAGE_NAME, TEST_APP_PACKAGE_NAME);
            requestDpmAction(ACTION_UNBLOCK_UNINSTALL, extras, mHandler);
            removeDeviceAdmin();
        }
        setDistractionFlagsAndAssertResult(ALL_TEST_PACKAGES, PackageManager.RESTRICTION_NONE,
                ArrayUtils.emptyArray(String.class));
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.security.cts.FileIntegrityManagerTest"	"testCtsReleaseCertificateTrusted"	"CtsSecurityTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/security/src/android/security/cts/FileIntegrityManagerTest.java"	""	"public void testCtsReleaseCertificateTrusted() throws Exception {
        boolean isReleaseCertTrusted = mFileIntegrityManager.isAppSourceCertificateTrusted(
                readAssetAsX509Certificate(""fsverity-release.x509.der""));
        if (mFileIntegrityManager.isApkVeritySupported()) {
            assertTrue(isReleaseCertTrusted);
        } else {
            assertFalse(isReleaseCertTrusted);
        }
    }

    @CddTest(requirement=""9.10/C-0-3,C-1-1"")
    @RestrictedBuildTest"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.ResetPasswordWithTokenTest"	"testPasswordQuality_complexUpperCase"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/ResetPasswordWithTokenTest.java"	""	"public void testPasswordQuality_complexUpperCase() {
        if (!mShouldRun) {
            return;
        }

        mDevicePolicyManager.setPasswordQuality(ADMIN_RECEIVER_COMPONENT, PASSWORD_QUALITY_COMPLEX);
        assertEquals(PASSWORD_QUALITY_COMPLEX,
                mDevicePolicyManager.getPasswordQuality(ADMIN_RECEIVER_COMPONENT));
        resetComplexPasswordRestrictions();

        String caseDescription = ""minimum UpperCase=0"";
        assertPasswordSucceeds(""abc1"", caseDescription);
        assertPasswordSucceeds(""aBc1"", caseDescription);
        assertPasswordSucceeds(""ABC1"", caseDescription);
        assertPasswordSucceeds(""ABCD"", caseDescription);
        assertPasswordFails(""123"", caseDescription); // too short

        mDevicePolicyManager.setPasswordMinimumUpperCase(ADMIN_RECEIVER_COMPONENT, 1);
        assertEquals(1, mDevicePolicyManager.getPasswordMinimumUpperCase(ADMIN_RECEIVER_COMPONENT));
        caseDescription = ""minimum UpperCase=1"";
        assertPasswordFails(""abc1"", caseDescription);
        assertPasswordSucceeds(""aBc1"", caseDescription);
        assertPasswordSucceeds(""ABC1"", caseDescription);
        assertPasswordSucceeds(""ABCD"", caseDescription);
        assertPasswordFails(""123"", caseDescription); // too short

        mDevicePolicyManager.setPasswordMinimumUpperCase(ADMIN_RECEIVER_COMPONENT, 3);
        assertEquals(3, mDevicePolicyManager.getPasswordMinimumUpperCase(ADMIN_RECEIVER_COMPONENT));
        caseDescription = ""minimum UpperCase=3"";
        assertPasswordFails(""abc1"", caseDescription);
        assertPasswordFails(""aBC1"", caseDescription);
        assertPasswordSucceeds(""ABC1"", caseDescription);
        assertPasswordSucceeds(""ABCD"", caseDescription);
        assertPasswordFails(""123"", caseDescription); // too short
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.ResetPasswordWithTokenTest"	"testPasswordQuality_complexLowerCase"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/ResetPasswordWithTokenTest.java"	""	"public void testPasswordQuality_complexLowerCase() {
        if (!mShouldRun) {
            return;
        }

        mDevicePolicyManager.setPasswordQuality(ADMIN_RECEIVER_COMPONENT, PASSWORD_QUALITY_COMPLEX);
        assertEquals(PASSWORD_QUALITY_COMPLEX,
                mDevicePolicyManager.getPasswordQuality(ADMIN_RECEIVER_COMPONENT));
        resetComplexPasswordRestrictions();

        String caseDescription = ""minimum LowerCase=0"";
        assertPasswordSucceeds(""ABCD"", caseDescription);
        assertPasswordSucceeds(""aBC1"", caseDescription);
        assertPasswordSucceeds(""abc1"", caseDescription);
        assertPasswordSucceeds(""abcd"", caseDescription);
        assertPasswordFails(""123"", caseDescription); // too short

        mDevicePolicyManager.setPasswordMinimumLowerCase(ADMIN_RECEIVER_COMPONENT, 1);
        assertEquals(1, mDevicePolicyManager.getPasswordMinimumLowerCase(ADMIN_RECEIVER_COMPONENT));
        caseDescription = ""minimum LowerCase=1"";
        assertPasswordFails(""ABCD"", caseDescription);
        assertPasswordSucceeds(""aBC1"", caseDescription);
        assertPasswordSucceeds(""abc1"", caseDescription);
        assertPasswordSucceeds(""abcd"", caseDescription);
        assertPasswordFails(""123"", caseDescription); // too short

        mDevicePolicyManager.setPasswordMinimumLowerCase(ADMIN_RECEIVER_COMPONENT, 3);
        assertEquals(3, mDevicePolicyManager.getPasswordMinimumLowerCase(ADMIN_RECEIVER_COMPONENT));
        caseDescription = ""minimum LowerCase=3"";
        assertPasswordFails(""ABCD"", caseDescription);
        assertPasswordFails(""aBC1"", caseDescription);
        assertPasswordSucceeds(""abc1"", caseDescription);
        assertPasswordSucceeds(""abcd"", caseDescription);
        assertPasswordFails(""123"", caseDescription); // too short
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.ResetPasswordWithTokenTest"	"testPasswordQuality_complexLetters"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/ResetPasswordWithTokenTest.java"	""	"public void testPasswordQuality_complexLetters() {
        if (!mShouldRun) {
            return;
        }

        mDevicePolicyManager.setPasswordQuality(ADMIN_RECEIVER_COMPONENT, PASSWORD_QUALITY_COMPLEX);
        assertEquals(PASSWORD_QUALITY_COMPLEX,
                mDevicePolicyManager.getPasswordQuality(ADMIN_RECEIVER_COMPONENT));
        resetComplexPasswordRestrictions();

        String caseDescription = ""minimum Letters=0"";
        assertPasswordFails(""1234"", caseDescription); // Numeric PIN not allowed
        assertPasswordSucceeds(""a123"", caseDescription);
        assertPasswordSucceeds(""abc1"", caseDescription);
        assertPasswordSucceeds(""abcd"", caseDescription);
        assertPasswordFails(""123"", caseDescription); // too short

        mDevicePolicyManager.setPasswordMinimumLetters(ADMIN_RECEIVER_COMPONENT, 1);
        assertEquals(1, mDevicePolicyManager.getPasswordMinimumLetters(ADMIN_RECEIVER_COMPONENT));
        caseDescription = ""minimum Letters=1"";
        assertPasswordFails(""1234"", caseDescription);
        assertPasswordSucceeds(""a123"", caseDescription);
        assertPasswordSucceeds(""abc1"", caseDescription);
        assertPasswordSucceeds(""abcd"", caseDescription);
        assertPasswordFails(""123"", caseDescription); // too short

        mDevicePolicyManager.setPasswordMinimumLetters(ADMIN_RECEIVER_COMPONENT, 3);
        assertEquals(3, mDevicePolicyManager.getPasswordMinimumLetters(ADMIN_RECEIVER_COMPONENT));
        caseDescription = ""minimum Letters=3"";
        assertPasswordFails(""1234"", caseDescription);
        assertPasswordFails(""a123"", caseDescription);
        assertPasswordSucceeds(""abc1"", caseDescription);
        assertPasswordSucceeds(""abcd"", caseDescription);
        assertPasswordFails(""123"", caseDescription); // too short
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.ResetPasswordWithTokenTest"	"testPasswordQuality_complexNumeric"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/ResetPasswordWithTokenTest.java"	""	"public void testPasswordQuality_complexNumeric() {
        if (!mShouldRun) {
            return;
        }

        mDevicePolicyManager.setPasswordQuality(ADMIN_RECEIVER_COMPONENT, PASSWORD_QUALITY_COMPLEX);
        assertEquals(PASSWORD_QUALITY_COMPLEX,
                mDevicePolicyManager.getPasswordQuality(ADMIN_RECEIVER_COMPONENT));
        resetComplexPasswordRestrictions();

        String caseDescription = ""minimum Numeric=0"";
        assertPasswordSucceeds(""abcd"", caseDescription);
        assertPasswordSucceeds(""1abc"", caseDescription);
        assertPasswordSucceeds(""123a"", caseDescription);
        assertPasswordFails(""1234"", caseDescription); // Numeric PIN not allowed
        assertPasswordFails(""123"", caseDescription); // too short

        mDevicePolicyManager.setPasswordMinimumNumeric(ADMIN_RECEIVER_COMPONENT, 1);
        assertEquals(1, mDevicePolicyManager.getPasswordMinimumNumeric(ADMIN_RECEIVER_COMPONENT));
        caseDescription = ""minimum Numeric=1"";
        assertPasswordFails(""abcd"", caseDescription);
        assertPasswordSucceeds(""1abc"", caseDescription);
        assertPasswordSucceeds(""123a"", caseDescription);
        assertPasswordFails(""1234"", caseDescription); // Numeric PIN not allowed
        assertPasswordFails(""123"", caseDescription); // too short

        mDevicePolicyManager.setPasswordMinimumNumeric(ADMIN_RECEIVER_COMPONENT, 3);
        assertEquals(3, mDevicePolicyManager.getPasswordMinimumNumeric(ADMIN_RECEIVER_COMPONENT));
        caseDescription = ""minimum Numeric=3"";
        assertPasswordFails(""abcd"", caseDescription);
        assertPasswordFails(""1abc"", caseDescription);
        assertPasswordSucceeds(""123a"", caseDescription);
        assertPasswordFails(""1234"", caseDescription); // Numeric PIN not allowed
        assertPasswordFails(""123"", caseDescription); // too short
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.ResetPasswordWithTokenTest"	"testPasswordQuality_complexSymbols"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/ResetPasswordWithTokenTest.java"	""	"public void testPasswordQuality_complexSymbols() {
        if (!mShouldRun) {
            return;
        }

        mDevicePolicyManager.setPasswordQuality(ADMIN_RECEIVER_COMPONENT, PASSWORD_QUALITY_COMPLEX);
        assertEquals(PASSWORD_QUALITY_COMPLEX,
                mDevicePolicyManager.getPasswordQuality(ADMIN_RECEIVER_COMPONENT));
        resetComplexPasswordRestrictions();

        String caseDescription = ""minimum Symbols=0"";
        assertPasswordSucceeds(""abcd"", caseDescription);
        assertPasswordSucceeds(""_bc1"", caseDescription);
        assertPasswordSucceeds(""@#!1"", caseDescription);
        assertPasswordSucceeds(""_@#!"", caseDescription);
        assertPasswordFails(""123"", caseDescription); // too short

        mDevicePolicyManager.setPasswordMinimumSymbols(ADMIN_RECEIVER_COMPONENT, 1);
        assertEquals(1, mDevicePolicyManager.getPasswordMinimumSymbols(ADMIN_RECEIVER_COMPONENT));
        caseDescription = ""minimum Symbols=1"";
        assertPasswordFails(""abcd"", caseDescription);
        assertPasswordSucceeds(""_bc1"", caseDescription);
        assertPasswordSucceeds(""@#!1"", caseDescription);
        assertPasswordSucceeds(""_@#!"", caseDescription);
        assertPasswordFails(""123"", caseDescription); // too short

        mDevicePolicyManager.setPasswordMinimumSymbols(ADMIN_RECEIVER_COMPONENT, 3);
        assertEquals(3, mDevicePolicyManager.getPasswordMinimumSymbols(ADMIN_RECEIVER_COMPONENT));
        caseDescription = ""minimum Symbols=3"";
        assertPasswordFails(""abcd"", caseDescription);
        assertPasswordFails(""_bc1"", caseDescription);
        assertPasswordSucceeds(""@#!1"", caseDescription);
        assertPasswordSucceeds(""_@#!"", caseDescription);
        assertPasswordFails(""123"", caseDescription); // too short
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.ResetPasswordWithTokenTest"	"testPasswordQuality_complexNonLetter"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/ResetPasswordWithTokenTest.java"	""	"public void testPasswordQuality_complexNonLetter() {
        if (!mShouldRun) {
            return;
        }

        mDevicePolicyManager.setPasswordQuality(ADMIN_RECEIVER_COMPONENT, PASSWORD_QUALITY_COMPLEX);
        assertEquals(PASSWORD_QUALITY_COMPLEX,
                mDevicePolicyManager.getPasswordQuality(ADMIN_RECEIVER_COMPONENT));
        resetComplexPasswordRestrictions();

        String caseDescription = ""minimum NonLetter=0"";
        assertPasswordSucceeds(""Abcd"", caseDescription);
        assertPasswordSucceeds(""_bcd"", caseDescription);
        assertPasswordSucceeds(""3bcd"", caseDescription);
        assertPasswordSucceeds(""_@3c"", caseDescription);
        assertPasswordSucceeds(""_25!"", caseDescription);
        assertPasswordFails(""123"", caseDescription); // too short

        mDevicePolicyManager.setPasswordMinimumNonLetter(ADMIN_RECEIVER_COMPONENT, 1);
        assertEquals(1, mDevicePolicyManager.getPasswordMinimumNonLetter(ADMIN_RECEIVER_COMPONENT));
        caseDescription = ""minimum NonLetter=1"";
        assertPasswordFails(""Abcd"", caseDescription);
        assertPasswordSucceeds(""_bcd"", caseDescription);
        assertPasswordSucceeds(""3bcd"", caseDescription);
        assertPasswordSucceeds(""_@3c"", caseDescription);
        assertPasswordSucceeds(""_25!"", caseDescription);
        assertPasswordFails(""123"", caseDescription); // too short

        mDevicePolicyManager.setPasswordMinimumNonLetter(ADMIN_RECEIVER_COMPONENT, 3);
        assertEquals(3, mDevicePolicyManager.getPasswordMinimumNonLetter(ADMIN_RECEIVER_COMPONENT));
        caseDescription = ""minimum NonLetter=3"";
        assertPasswordFails(""Abcd"", caseDescription);
        assertPasswordFails(""_bcd"", caseDescription);
        assertPasswordFails(""3bcd"", caseDescription);
        assertPasswordSucceeds(""_@3c"", caseDescription);
        assertPasswordSucceeds(""_25!"", caseDescription);
        assertPasswordFails(""123"", caseDescription); // too short
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.ResetPasswordWithTokenTest"	"testResetPasswordWithTokenLogging"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/ResetPasswordWithTokenTest.java"	""	"public void testResetPasswordWithTokenLogging() {
        if (!mShouldRun) {
            return;
        }

        try (EnterpriseMetricsRecorder metrics = EnterpriseMetricsRecorder.create()) {
            mDevicePolicyManager.resetPasswordWithToken(ADMIN_RECEIVER_COMPONENT,
                    SHORT_PASSWORD, TOKEN0, 0);

            assertNotNull(metrics.query()
                    .whereType().isEqualTo(EventId.RESET_PASSWORD_WITH_TOKEN_VALUE)
                    .whereAdminPackageName().isEqualTo(PACKAGE_NAME)
                    .poll());
        }
    }

    private boolean setUpResetPasswordToken(boolean acceptFailure) {
        // set up a token
        assertFalse(mDevicePolicyManager.isResetPasswordTokenActive(ADMIN_RECEIVER_COMPONENT));

        try {
            // On devices with password token disabled, calling this method will throw
            // a security exception. If that's anticipated, then return early without failing.
            assertTrue(mDevicePolicyManager.setResetPasswordToken(ADMIN_RECEIVER_COMPONENT,
                    TOKEN0));
        } catch (SecurityException e) {
            if (acceptFailure &&
                    e.getMessage().equals(""Escrow token is disabled on the current user"")) {
                return false;
            } else {
                throw e;
            }
        }
        assertTrue(mDevicePolicyManager.isResetPasswordTokenActive(ADMIN_RECEIVER_COMPONENT));
        return true;
    }

    private void cleanUpResetPasswordToken() {
        // First remove device lock
        mDevicePolicyManager.setPasswordQuality(ADMIN_RECEIVER_COMPONENT,
                DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED);
        mDevicePolicyManager.setRequiredPasswordComplexity(PASSWORD_COMPLEXITY_NONE);
        assertTrue(mDevicePolicyManager.resetPasswordWithToken(ADMIN_RECEIVER_COMPONENT, null,
                TOKEN0, 0));

        // Then remove token and check it succeeds
        assertTrue(mDevicePolicyManager.clearResetPasswordToken(ADMIN_RECEIVER_COMPONENT));
        assertFalse(mDevicePolicyManager.isResetPasswordTokenActive(ADMIN_RECEIVER_COMPONENT));
        assertFalse(mDevicePolicyManager.resetPasswordWithToken(ADMIN_RECEIVER_COMPONENT,
                SHORT_PASSWORD, TOKEN0, 0));
    }

    private void assertPasswordFails(String password, String restriction) {
        try {
            boolean passwordResetResult = mDevicePolicyManager.resetPasswordWithToken(
                    ADMIN_RECEIVER_COMPONENT, password, TOKEN0, /* flags= */0);
            assertFalse(""Password '"" + password + ""' should have failed on "" + restriction,
                    passwordResetResult);
        } catch (IllegalArgumentException e) {
            // yesss, we have failed!
        }
    }

    private void assertPasswordSucceeds(String password, String restriction) {
        boolean passwordResetResult = mDevicePolicyManager.resetPasswordWithToken(
                ADMIN_RECEIVER_COMPONENT, password, TOKEN0, /* flags= */0);
        assertTrue(""Password '"" + password + ""' failed on "" + restriction, passwordResetResult);
        assertPasswordSufficiency(true);
    }

    private void resetComplexPasswordRestrictions() {
        final int quality = mDevicePolicyManager.getPasswordQuality(ADMIN_RECEIVER_COMPONENT);
        if (quality < PASSWORD_QUALITY_NUMERIC) {
            return;
        }
        mDevicePolicyManager.setPasswordMinimumLength(ADMIN_RECEIVER_COMPONENT, 0);
        if (quality < PASSWORD_QUALITY_COMPLEX) {
            return;
        }
        mDevicePolicyManager.setPasswordMinimumUpperCase(ADMIN_RECEIVER_COMPONENT, 0);
        mDevicePolicyManager.setPasswordMinimumLowerCase(ADMIN_RECEIVER_COMPONENT, 0);
        mDevicePolicyManager.setPasswordMinimumLetters(ADMIN_RECEIVER_COMPONENT, 0);
        mDevicePolicyManager.setPasswordMinimumNumeric(ADMIN_RECEIVER_COMPONENT, 0);
        mDevicePolicyManager.setPasswordMinimumSymbols(ADMIN_RECEIVER_COMPONENT, 0);
        mDevicePolicyManager.setPasswordMinimumNonLetter(ADMIN_RECEIVER_COMPONENT, 0);
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.app.cts.ActivityManagerFgsBgStartTest"	"testFgsStartRetailDemoMode"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerFgsBgStartTest.java"	""	"// Change Settings.Global.DEVICE_DEMO_MODE on device may trigger other listener and put
    // the device in undesired state, for example, the battery charge level is set to 35%
    // permanently, ignore this test for now.
    @Ignore
    public void testFgsStartRetailDemoMode() throws Exception {
        ApplicationInfo app1Info = mContext.getPackageManager().getApplicationInfo(
                PACKAGE_NAME_APP1, 0);
        WatchUidRunner uid1Watcher = new WatchUidRunner(mInstrumentation, app1Info.uid,
                WAITFOR_MSEC);
        runWithShellPermissionIdentity(()-> {
            mOrigDeviceDemoMode = Settings.Global.getInt(mContext.getContentResolver(),
                    Settings.Global.DEVICE_DEMO_MODE, 0); });

        try {
            // Enable the FGS background startForeground() restriction.
            enableFgsRestriction(true, true, null);
            // Start FGS in BG state.
            WaitForBroadcast waiter = new WaitForBroadcast(mInstrumentation.getTargetContext());
            waiter.prepare(ACTION_START_FGS_RESULT);
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_START_FOREGROUND_SERVICE,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            // APP1 does not enter FGS state
            try {
                waiter.doWait(WAITFOR_MSEC);
                fail(""Service should not enter foreground service state"");
            } catch (Exception e) {
            }

            runWithShellPermissionIdentity(()-> {
                Settings.Global.putInt(mContext.getContentResolver(),
                        Settings.Global.DEVICE_DEMO_MODE, 1); });
            waiter = new WaitForBroadcast(mInstrumentation.getTargetContext());
            waiter.prepare(ACTION_START_FGS_RESULT);
            // Now it can start FGS.
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_START_FOREGROUND_SERVICE,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            uid1Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_FG_SERVICE);
            waiter.doWait(WAITFOR_MSEC);
            // Stop the FGS.
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_STOP_FOREGROUND_SERVICE,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            uid1Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_CACHED_EMPTY);
        } finally {
            uid1Watcher.finish();
            runWithShellPermissionIdentity(()-> {
                Settings.Global.putInt(mContext.getContentResolver(),
                        Settings.Global.DEVICE_DEMO_MODE, mOrigDeviceDemoMode); });
        }
    }

    // At Context.startForegroundService() or Service.startForeground() calls, if the FGS is
    // restricted by background restriction and the app's targetSdkVersion is at least S, the
    // framework throws a ForegroundServiceStartNotAllowedException with error message."	""	""	"restricted restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.app.cts.ActivityManagerFgsBgStartTest"	"testFgsLocationStartFromBG"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerFgsBgStartTest.java"	""	"public void testFgsLocationStartFromBG() throws Exception {
        ApplicationInfo app1Info = mContext.getPackageManager().getApplicationInfo(
                PACKAGE_NAME_APP1, 0);
        WatchUidRunner uid1Watcher = new WatchUidRunner(mInstrumentation, app1Info.uid,
                WAITFOR_MSEC);

        try {
            WaitForBroadcast waiter = new WaitForBroadcast(mInstrumentation.getTargetContext());
            waiter.prepare(ACTION_START_FGSL_RESULT);
            // APP1 is in BG state, Start FGSL in APP1, it won't get location capability.
            Bundle bundle = new Bundle();
            bundle.putInt(LocalForegroundServiceLocation.EXTRA_FOREGROUND_SERVICE_TYPE,
                    ServiceInfo.FOREGROUND_SERVICE_TYPE_LOCATION);
            // start FGSL.
            enableFgsRestriction(false, true, null);
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_START_FOREGROUND_SERVICE_LOCATION,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, bundle);
            // APP1 is in FGS state, but won't get location capability.
            uid1Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE,
                    WatchUidRunner.STATE_FG_SERVICE,
                    new Integer(PROCESS_CAPABILITY_NETWORK));
            waiter.doWait(WAITFOR_MSEC);
            // stop FGSL
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_STOP_FOREGROUND_SERVICE_LOCATION,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            uid1Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE,
                    WatchUidRunner.STATE_CACHED_EMPTY,
                    new Integer(PROCESS_CAPABILITY_NONE));

            waiter = new WaitForBroadcast(mInstrumentation.getTargetContext());
            waiter.prepare(ACTION_START_FGS_RESULT);
            // APP1 is in FGS state,
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_START_FOREGROUND_SERVICE,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, bundle);
            // start FGSL in app1, it won't get location capability.
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_START_FOREGROUND_SERVICE_LOCATION,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, bundle);
            // APP1 is in STATE_FG_SERVICE, but won't get location capability.
            uid1Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE,
                    WatchUidRunner.STATE_FG_SERVICE,
                    new Integer(PROCESS_CAPABILITY_NETWORK));
            waiter.doWait(WAITFOR_MSEC);
            // stop FGS.
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_STOP_FOREGROUND_SERVICE,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            // stop FGSL.
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_STOP_FOREGROUND_SERVICE_LOCATION,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);

            // Put APP1 in TOP state, now it gets location capability (because the TOP process
            // gets all while-in-use permission (not from FGSL).
            allowBgActivityStart(PACKAGE_NAME_APP1, true);
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_START_ACTIVITY,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            uid1Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE,
                    WatchUidRunner.STATE_TOP,
                    new Integer(PROCESS_CAPABILITY_ALL));

            waiter = new WaitForBroadcast(mInstrumentation.getTargetContext());
            waiter.prepare(ACTION_START_FGSL_RESULT);
            // APP1 is in TOP state, start the FGSL in APP1, it will get location capability.
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_START_FOREGROUND_SERVICE_LOCATION,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, bundle);
            // Stop the activity.
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_STOP_ACTIVITY,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            // The FGSL still has location capability because it is started from TOP.
            uid1Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE,
                    WatchUidRunner.STATE_FG_SERVICE,
                    new Integer(PROCESS_CAPABILITY_ALL));
            waiter.doWait(WAITFOR_MSEC);
            // Stop FGSL.
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_STOP_FOREGROUND_SERVICE_LOCATION,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            uid1Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE,
                    WatchUidRunner.STATE_CACHED_EMPTY,
                    new Integer(PROCESS_CAPABILITY_NONE));
        } finally {
            uid1Watcher.finish();
        }
    }

    /**
     * APP1 is in BG state, it can start FGSL in APP2, but the FGS won't get location
     * capability.
     * APP1 is in TOP state, it can start FGSL in APP2, FGSL gets location capability.
     * @throws Exception
     */"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.app.cts.ActivityManagerFgsBgStartTest"	"testFgsLocationStartFromBGTwoProcesses"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerFgsBgStartTest.java"	""	"public void testFgsLocationStartFromBGTwoProcesses() throws Exception {
        ApplicationInfo app1Info = mContext.getPackageManager().getApplicationInfo(
                PACKAGE_NAME_APP1, 0);
        ApplicationInfo app2Info = mContext.getPackageManager().getApplicationInfo(
                PACKAGE_NAME_APP2, 0);
        WatchUidRunner uid1Watcher = new WatchUidRunner(mInstrumentation, app1Info.uid,
                WAITFOR_MSEC);
        WatchUidRunner uid2Watcher = new WatchUidRunner(mInstrumentation, app2Info.uid,
                WAITFOR_MSEC);

        try {
            // APP1 is in BG state, start FGSL in APP2.
            Bundle bundle = new Bundle();
            bundle.putInt(LocalForegroundServiceLocation.EXTRA_FOREGROUND_SERVICE_TYPE,
                    ServiceInfo.FOREGROUND_SERVICE_TYPE_LOCATION);
            WaitForBroadcast waiter = new WaitForBroadcast(mInstrumentation.getTargetContext());
            waiter.prepare(ACTION_START_FGSL_RESULT);
            enableFgsRestriction(false, true, null);
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_START_FOREGROUND_SERVICE_LOCATION,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP2, 0, bundle);
            // APP2 won't have location capability because APP1 is not in TOP state.
            uid2Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE,
                    WatchUidRunner.STATE_FG_SERVICE,
                    new Integer(PROCESS_CAPABILITY_NETWORK));
            waiter.doWait(WAITFOR_MSEC);

            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_STOP_FOREGROUND_SERVICE_LOCATION,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP2, 0, null);
            uid2Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE,
                    WatchUidRunner.STATE_CACHED_EMPTY,
                    new Integer(PROCESS_CAPABILITY_NONE));

            // Put APP1 in TOP state
            allowBgActivityStart(PACKAGE_NAME_APP1, true);
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_START_ACTIVITY,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            uid1Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE,
                    WatchUidRunner.STATE_TOP,
                    new Integer(PROCESS_CAPABILITY_ALL));

            waiter = new WaitForBroadcast(mInstrumentation.getTargetContext());
            waiter.prepare(ACTION_START_FGSL_RESULT);
            // From APP1, start FGSL in APP2.
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_START_FOREGROUND_SERVICE_LOCATION,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP2, 0, bundle);
            // Now APP2 gets location capability.
            uid2Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE,
                    WatchUidRunner.STATE_FG_SERVICE,
                    new Integer(PROCESS_CAPABILITY_ALL));
            waiter.doWait(WAITFOR_MSEC);

            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_STOP_FOREGROUND_SERVICE_LOCATION,
                    PACKAGE_NAME_APP2, PACKAGE_NAME_APP2, 0, null);

            uid2Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE,
                    WatchUidRunner.STATE_CACHED_EMPTY,
                    new Integer(PROCESS_CAPABILITY_NONE));

            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_STOP_ACTIVITY,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);

            uid1Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE,
                    WatchUidRunner.STATE_CACHED_EMPTY,
                    new Integer(PROCESS_CAPABILITY_NONE));
        } finally {
            uid1Watcher.finish();
            uid2Watcher.finish();
        }
    }

    /**
     * APP1 is in BG state, by a PendingIntent, it can start FGSL in APP2,
     * but the FGS won't get location capability.
     * APP1 is in TOP state, by a PendingIntent, it can start FGSL in APP2,
     * FGSL gets location capability.
     * @throws Exception
     */"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.app.cts.ActivityManagerFgsBgStartTest"	"testFgsLocationPendingIntent"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerFgsBgStartTest.java"	""	"public void testFgsLocationPendingIntent() throws Exception {
        ApplicationInfo app1Info = mContext.getPackageManager().getApplicationInfo(
                PACKAGE_NAME_APP1, 0);
        ApplicationInfo app2Info = mContext.getPackageManager().getApplicationInfo(
                PACKAGE_NAME_APP2, 0);
        WatchUidRunner uid1Watcher = new WatchUidRunner(mInstrumentation, app1Info.uid,
                WAITFOR_MSEC);
        WatchUidRunner uid2Watcher = new WatchUidRunner(mInstrumentation, app2Info.uid,
                WAITFOR_MSEC);

        try {
            WaitForBroadcast waiter = new WaitForBroadcast(mInstrumentation.getTargetContext());
            waiter.prepare(ACTION_START_FGSL_RESULT);
            // APP1 is in BG state, start FGSL in APP2.
            enableFgsRestriction(false, true, null);
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_CREATE_FGSL_PENDING_INTENT,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP2, 0, null);
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_SEND_FGSL_PENDING_INTENT,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP2, 0, null);
            // APP2 won't have location capability.
            uid2Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE,
                    WatchUidRunner.STATE_FG_SERVICE,
                    new Integer(PROCESS_CAPABILITY_NETWORK));
            waiter.doWait(WAITFOR_MSEC);
            // Stop FGSL in APP2.
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_STOP_FOREGROUND_SERVICE_LOCATION,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP2, 0, null);
            uid2Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE,
                    WatchUidRunner.STATE_CACHED_EMPTY,
                    new Integer(PROCESS_CAPABILITY_NONE));

            waiter = new WaitForBroadcast(mInstrumentation.getTargetContext());
            waiter.prepare(ACTION_START_FGS_RESULT);
            // Put APP1 in FGS state, start FGSL in APP2.
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_START_FOREGROUND_SERVICE,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            uid1Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE,
                    WatchUidRunner.STATE_FG_SERVICE,
                    new Integer(PROCESS_CAPABILITY_NETWORK));
            waiter.doWait(WAITFOR_MSEC);
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_CREATE_FGSL_PENDING_INTENT,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP2, 0, null);

            waiter = new WaitForBroadcast(mInstrumentation.getTargetContext());
            waiter.prepare(ACTION_START_FGSL_RESULT);
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_SEND_FGSL_PENDING_INTENT,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP2, 0, null);
            // APP2 won't have location capability.
            uid2Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE,
                    WatchUidRunner.STATE_FG_SERVICE,
                    new Integer(PROCESS_CAPABILITY_NETWORK));
            waiter.doWait(WAITFOR_MSEC);
            // stop FGSL in APP2.
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_STOP_FOREGROUND_SERVICE_LOCATION,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP2, 0, null);
            uid2Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE,
                    WatchUidRunner.STATE_CACHED_EMPTY,
                    new Integer(PROCESS_CAPABILITY_NONE));

            // put APP1 in TOP state, start FGSL in APP2.
            allowBgActivityStart(PACKAGE_NAME_APP1, true);
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_START_ACTIVITY,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            uid1Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE,
                    WatchUidRunner.STATE_TOP,
                    new Integer(PROCESS_CAPABILITY_ALL));
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_CREATE_FGSL_PENDING_INTENT,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP2, 0, null);

            waiter = new WaitForBroadcast(mInstrumentation.getTargetContext());
            waiter.prepare(ACTION_START_FGSL_RESULT);
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_SEND_FGSL_PENDING_INTENT,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP2, 0, null);
            // APP2 now have location capability (because APP1 is TOP)
            uid2Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE,
                    WatchUidRunner.STATE_FG_SERVICE,
                    new Integer(PROCESS_CAPABILITY_ALL));
            waiter.doWait(WAITFOR_MSEC);

            // stop FGSL in APP2.
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_STOP_FOREGROUND_SERVICE_LOCATION,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP2, 0, null);
            uid2Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE,
                    WatchUidRunner.STATE_CACHED_EMPTY,
                    new Integer(PROCESS_CAPABILITY_NONE));

            // stop FGS in APP1,
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_STOP_FOREGROUND_SERVICE,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            // stop TOP activity in APP1.
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_STOP_ACTIVITY,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            uid1Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE,
                    WatchUidRunner.STATE_CACHED_EMPTY,
                    new Integer(PROCESS_CAPABILITY_NONE));
        } finally {
            uid1Watcher.finish();
            uid2Watcher.finish();
        }
    }

    /**
     * Test a FGS start by bind from BG does not get get while-in-use capability.
     * @throws Exception
     */"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.app.cts.ActivityManagerFgsBgStartTest"	"testFgsLocationStartFromBGWithBind"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerFgsBgStartTest.java"	""	"@AsbSecurityTest(cveBugId = 173516292)
    public void testFgsLocationStartFromBGWithBind() throws Exception {
        ApplicationInfo app1Info = mContext.getPackageManager().getApplicationInfo(
                PACKAGE_NAME_APP1, 0);
        WatchUidRunner uid1Watcher = new WatchUidRunner(mInstrumentation, app1Info.uid,
                WAITFOR_MSEC);

        try {
            WaitForBroadcast waiter = new WaitForBroadcast(mInstrumentation.getTargetContext());
            waiter.prepare(ACTION_START_FGSL_RESULT);
            // APP1 is in BG state, bind FGSL in APP1 first.
            enableFgsRestriction(false, true, null);
            CommandReceiver.sendCommand(mContext, CommandReceiver.COMMAND_BIND_FOREGROUND_SERVICE,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            Bundle bundle = new Bundle();
            bundle.putInt(LocalForegroundServiceLocation.EXTRA_FOREGROUND_SERVICE_TYPE,
                    ServiceInfo.FOREGROUND_SERVICE_TYPE_LOCATION);
            // Then start FGSL in APP1, it won't get location capability.
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_START_FOREGROUND_SERVICE_LOCATION,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, bundle);

            // APP1 is in FGS state, but won't get location capability.
            uid1Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE,
                    WatchUidRunner.STATE_FG_SERVICE,
                    new Integer(PROCESS_CAPABILITY_NETWORK));
            waiter.doWait(WAITFOR_MSEC);

            // unbind service.
            CommandReceiver.sendCommand(mContext, CommandReceiver.COMMAND_UNBIND_SERVICE,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            // stop FGSL
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_STOP_FOREGROUND_SERVICE_LOCATION,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            uid1Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE,
                    WatchUidRunner.STATE_CACHED_EMPTY,
                    new Integer(PROCESS_CAPABILITY_NONE));
        } finally {
            uid1Watcher.finish();
        }
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.app.cts.ActivityManagerFgsBgStartTest"	"testUpdateUidProcState"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerFgsBgStartTest.java"	""	"public void testUpdateUidProcState() throws Exception {
        ApplicationInfo app1Info = mContext.getPackageManager().getApplicationInfo(
                PACKAGE_NAME_APP1, 0);
        WatchUidRunner uid1Watcher = new WatchUidRunner(mInstrumentation, app1Info.uid,
                WAITFOR_MSEC);
        ApplicationInfo app2Info = mContext.getPackageManager().getApplicationInfo(
                PACKAGE_NAME_APP2, 0);
        WatchUidRunner uid2Watcher = new WatchUidRunner(mInstrumentation, app2Info.uid,
                WAITFOR_MSEC);
        ApplicationInfo app3Info = mContext.getPackageManager().getApplicationInfo(
                PACKAGE_NAME_APP3, 0);
        WatchUidRunner uid3Watcher = new WatchUidRunner(mInstrumentation, app3Info.uid,
                WAITFOR_MSEC);

        try {
            WaitForBroadcast waiter = new WaitForBroadcast(mInstrumentation.getTargetContext());
            waiter.prepare(ACTION_START_FGS_RESULT);

            enableFgsRestriction(false, true, null);

            // START FGS in APP2.
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_START_FOREGROUND_SERVICE,
                    PACKAGE_NAME_APP2, PACKAGE_NAME_APP2, 0, null);
            // APP2 proc state is 4.
            uid2Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE,
                    WatchUidRunner.STATE_FG_SERVICE);
            waiter.doWait(WAITFOR_MSEC);

            // APP2 binds to APP1.
            CommandReceiver.sendCommand(mContext, CommandReceiver.COMMAND_BIND_SERVICE,
                    PACKAGE_NAME_APP2, PACKAGE_NAME_APP1, Context.BIND_INCLUDE_CAPABILITIES, null);
            // APP1 gets proc state 4.
            uid1Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE,
                    WatchUidRunner.STATE_FG_SERVICE);

            // Start activity in APP3, this put APP3 in TOP state.
            allowBgActivityStart(PACKAGE_NAME_APP3, true);
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_START_ACTIVITY,
                    PACKAGE_NAME_APP3, PACKAGE_NAME_APP3, 0, null);
            // APP3 gets proc state 2.
            uid3Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_TOP);

            // APP3 repeatedly bind/unbind with APP2, observer APP1 proc state change.
            // Observe updateUidProcState() call latency.
            for (int i = 0; i < 10; ++i) {
                // APP3 bind to APP2
                CommandReceiver.sendCommand(mContext,
                        CommandReceiver.COMMAND_BIND_SERVICE,
                        PACKAGE_NAME_APP3, PACKAGE_NAME_APP2, Context.BIND_INCLUDE_CAPABILITIES,
                        null);
                uid1Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_BOUND_TOP);

                CommandReceiver.sendCommand(mContext, CommandReceiver.COMMAND_UNBIND_SERVICE,
                        PACKAGE_NAME_APP3, PACKAGE_NAME_APP2, 0, null);
                uid1Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_FG_SERVICE);
            }

            // unbind service.
            CommandReceiver.sendCommand(mContext, CommandReceiver.COMMAND_STOP_ACTIVITY,
                    PACKAGE_NAME_APP3, PACKAGE_NAME_APP3, 0, null);
            CommandReceiver.sendCommand(mContext, CommandReceiver.COMMAND_UNBIND_SERVICE,
                    PACKAGE_NAME_APP3, PACKAGE_NAME_APP2, 0, null);
            CommandReceiver.sendCommand(mContext, CommandReceiver.COMMAND_UNBIND_SERVICE,
                    PACKAGE_NAME_APP2, PACKAGE_NAME_APP1, 0, null);
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_STOP_FOREGROUND_SERVICE,
                    PACKAGE_NAME_APP2, PACKAGE_NAME_APP2, 0, null);

        } finally {
            uid1Watcher.finish();
            uid2Watcher.finish();
            uid3Watcher.finish();
            allowBgActivityStart(PACKAGE_NAME_APP3, false);
        }
    }

    /**
     * Test FGS background startForeground() restriction, use DeviceConfig to turn on restriction.
     * @throws Exception
     */"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.app.cts.ActivityManagerFgsBgStartTest"	"testFgsStartFromBG1"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerFgsBgStartTest.java"	""	"public void testFgsStartFromBG1() throws Exception {
        testFgsStartFromBG(true);
    }

    /**
     * Test FGS background startForeground() restriction, use AppCompat CHANGE ID to turn on
     * restriction.
     * @throws Exception
     */"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.app.cts.ActivityManagerFgsBgStartTest"	"testFgsStartFromBG2"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerFgsBgStartTest.java"	""	"public void testFgsStartFromBG2() throws Exception {
        testFgsStartFromBG(false);
    }

    private void testFgsStartFromBG(boolean useDeviceConfig) throws Exception {
        ApplicationInfo app1Info = mContext.getPackageManager().getApplicationInfo(
                PACKAGE_NAME_APP1, 0);
        WatchUidRunner uid1Watcher = new WatchUidRunner(mInstrumentation, app1Info.uid,
                WAITFOR_MSEC);
        try {
            WaitForBroadcast waiter = new WaitForBroadcast(mInstrumentation.getTargetContext());
            waiter.prepare(ACTION_START_FGS_RESULT);
            // disable the FGS background startForeground() restriction.
            enableFgsRestriction(false, true, null);
            enableFgsRestriction(false, useDeviceConfig, PACKAGE_NAME_APP1);
            // APP1 is in BG state, Start FGS in APP1.
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_START_FOREGROUND_SERVICE,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            // APP1 is in STATE_FG_SERVICE.
            uid1Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_FG_SERVICE);
            waiter.doWait(WAITFOR_MSEC);
            // stop FGS.
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_STOP_FOREGROUND_SERVICE,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            uid1Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_CACHED_EMPTY);

            // Enable the FGS background startForeground() restriction.
            allowBgActivityStart(PACKAGE_NAME_APP1, false);
            enableFgsRestriction(true, true, null);
            enableFgsRestriction(true, useDeviceConfig, PACKAGE_NAME_APP1);
            // Start FGS in BG state.
            waiter = new WaitForBroadcast(mInstrumentation.getTargetContext());
            waiter.prepare(ACTION_START_FGS_RESULT);
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_START_FOREGROUND_SERVICE,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            // APP1 does not enter FGS state
            try {
                waiter.doWait(WAITFOR_MSEC);
                fail(""Service should not enter foreground service state"");
            } catch (Exception e) {
            }

            // Put APP1 in TOP state.
            allowBgActivityStart(PACKAGE_NAME_APP1, true);
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_START_ACTIVITY,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            uid1Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_TOP);
            allowBgActivityStart(PACKAGE_NAME_APP1, false);

            waiter = new WaitForBroadcast(mInstrumentation.getTargetContext());
            waiter.prepare(ACTION_START_FGS_RESULT);
            // Now it can start FGS.
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_START_FOREGROUND_SERVICE,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            // Stop activity.
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_STOP_ACTIVITY,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            // FGS is still running.
            uid1Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_FG_SERVICE);
            waiter.doWait(WAITFOR_MSEC);
            // Stop the FGS.
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_STOP_FOREGROUND_SERVICE,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            uid1Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_CACHED_EMPTY);
        } finally {
            uid1Watcher.finish();
        }
    }

    /**
     * Test a FGS can start from a process that is at BOUND_TOP state.
     * @throws Exception
     */"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.app.cts.ActivityManagerFgsBgStartTest"	"testFgsStartFromBoundTopState"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerFgsBgStartTest.java"	""	"public void testFgsStartFromBoundTopState() throws Exception {
        ApplicationInfo app1Info = mContext.getPackageManager().getApplicationInfo(
                PACKAGE_NAME_APP1, 0);
        ApplicationInfo app2Info = mContext.getPackageManager().getApplicationInfo(
                PACKAGE_NAME_APP2, 0);
        ApplicationInfo app3Info = mContext.getPackageManager().getApplicationInfo(
                PACKAGE_NAME_APP3, 0);
        WatchUidRunner uid1Watcher = new WatchUidRunner(mInstrumentation, app1Info.uid,
                WAITFOR_MSEC);
        WatchUidRunner uid2Watcher = new WatchUidRunner(mInstrumentation, app2Info.uid,
                WAITFOR_MSEC);
        WatchUidRunner uid3Watcher = new WatchUidRunner(mInstrumentation, app3Info.uid,
                WAITFOR_MSEC);
        try {
            // Enable the FGS background startForeground() restriction.
            enableFgsRestriction(true, true, null);

            // Put APP1 in TOP state.
            allowBgActivityStart(PACKAGE_NAME_APP1, true);
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_START_ACTIVITY,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            uid1Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_TOP);

            // APP1 bound to service in APP2, APP2 get BOUND_TOP state.
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_BIND_SERVICE,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP2, 0, null);
            uid2Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_BOUND_TOP);

            WaitForBroadcast waiter = new WaitForBroadcast(mInstrumentation.getTargetContext());
            waiter.prepare(ACTION_START_FGS_RESULT);
            // APP2 can start FGS in APP3.
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_START_FOREGROUND_SERVICE,
                    PACKAGE_NAME_APP2, PACKAGE_NAME_APP3, 0, null);
            uid3Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_FG_SERVICE);
            waiter.doWait(WAITFOR_MSEC);

            // Stop activity.
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_STOP_ACTIVITY,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            uid1Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_CACHED_EMPTY);
            // unbind service.
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_UNBIND_SERVICE,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP2, 0, null);
            uid2Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_CACHED_EMPTY);
            // Stop the FGS.
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_STOP_FOREGROUND_SERVICE,
                    PACKAGE_NAME_APP2, PACKAGE_NAME_APP3, 0, null);
            uid3Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_CACHED_EMPTY);
        } finally {
            uid1Watcher.finish();
            uid2Watcher.finish();
            uid3Watcher.finish();
        }
    }

    /**
     * Test a FGS can start from a process that is at FOREGROUND_SERVICE state.
     * @throws Exception
     */"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.app.cts.ActivityManagerFgsBgStartTest"	"testFgsStartFromFgsState"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerFgsBgStartTest.java"	""	"public void testFgsStartFromFgsState() throws Exception {
        ApplicationInfo app1Info = mContext.getPackageManager().getApplicationInfo(
                PACKAGE_NAME_APP1, 0);
        ApplicationInfo app2Info = mContext.getPackageManager().getApplicationInfo(
                PACKAGE_NAME_APP2, 0);
        ApplicationInfo app3Info = mContext.getPackageManager().getApplicationInfo(
                PACKAGE_NAME_APP3, 0);
        WatchUidRunner uid1Watcher = new WatchUidRunner(mInstrumentation, app1Info.uid,
                WAITFOR_MSEC);
        WatchUidRunner uid2Watcher = new WatchUidRunner(mInstrumentation, app2Info.uid,
                WAITFOR_MSEC);
        WatchUidRunner uid3Watcher = new WatchUidRunner(mInstrumentation, app3Info.uid,
                WAITFOR_MSEC);
        try {
            // Enable the FGS background startForeground() restriction.
            enableFgsRestriction(true, true, null);

            // Put APP1 in TOP state.
            allowBgActivityStart(PACKAGE_NAME_APP1, true);
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_START_ACTIVITY,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            uid1Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_TOP);

            WaitForBroadcast waiter = new WaitForBroadcast(mInstrumentation.getTargetContext());
            waiter.prepare(ACTION_START_FGS_RESULT);
            // APP1 can start FGS in APP2, APP2 gets FOREGROUND_SERVICE state.
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_START_FOREGROUND_SERVICE,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP2, 0, null);
            uid2Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_FG_SERVICE);
            waiter.doWait(WAITFOR_MSEC);

            waiter = new WaitForBroadcast(mInstrumentation.getTargetContext());
            waiter.prepare(ACTION_START_FGS_RESULT);
            // APP2 can start FGS in APP3.
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_START_FOREGROUND_SERVICE,
                    PACKAGE_NAME_APP2, PACKAGE_NAME_APP3, 0, null);
            uid3Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_FG_SERVICE);
            waiter.doWait(WAITFOR_MSEC);

            // Stop activity in APP1.
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_STOP_ACTIVITY,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            uid1Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_CACHED_EMPTY);
            // Stop FGS in APP2.
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_STOP_FOREGROUND_SERVICE,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP2, 0, null);
            uid2Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_CACHED_EMPTY);
            // Stop FGS in APP3.
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_STOP_FOREGROUND_SERVICE,
                    PACKAGE_NAME_APP3, PACKAGE_NAME_APP3, 0, null);
            uid3Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_CACHED_EMPTY);
        } finally {
            uid1Watcher.finish();
            uid2Watcher.finish();
            uid3Watcher.finish();
        }
    }

    /**
     * When the service is started by bindService() command, test when BG-FGS-launch
     * restriction is disabled, FGS can start from background.
     * @throws Exception
     */"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.app.cts.ActivityManagerFgsBgStartTest"	"testFgsStartFromBGWithBind"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerFgsBgStartTest.java"	""	"public void testFgsStartFromBGWithBind() throws Exception {
        ApplicationInfo app1Info = mContext.getPackageManager().getApplicationInfo(
                PACKAGE_NAME_APP1, 0);
        WatchUidRunner uid1Watcher = new WatchUidRunner(mInstrumentation, app1Info.uid,
                WAITFOR_MSEC);

        try {
            WaitForBroadcast waiter = new WaitForBroadcast(mInstrumentation.getTargetContext());
            waiter.prepare(ACTION_START_FGSL_RESULT);
            // APP1 is in BG state, bind FGSL in APP1 first.
            CommandReceiver.sendCommand(mContext, CommandReceiver.COMMAND_BIND_FOREGROUND_SERVICE,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            // Then start FGSL in APP1
            enableFgsRestriction(false, true, null);
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_START_FOREGROUND_SERVICE_LOCATION,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            // APP1 is in FGS state
            uid1Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_FG_SERVICE);
            waiter.doWait(WAITFOR_MSEC);

            // stop FGS
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_STOP_FOREGROUND_SERVICE_LOCATION,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            // unbind service.
            CommandReceiver.sendCommand(mContext, CommandReceiver.COMMAND_UNBIND_SERVICE,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            uid1Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_CACHED_EMPTY);
        } finally {
            uid1Watcher.finish();
        }
    }

    /**
     * When the service is started by bindService() command, test when BG-FGS-launch
     * restriction is enabled, FGS can NOT start from background.
     * @throws Exception
     */"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.app.cts.ActivityManagerFgsBgStartTest"	"testFgsStartFromBGWithBindWithRestriction"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerFgsBgStartTest.java"	""	"public void testFgsStartFromBGWithBindWithRestriction() throws Exception {
        ApplicationInfo app1Info = mContext.getPackageManager().getApplicationInfo(
                PACKAGE_NAME_APP1, 0);
        WatchUidRunner uid1Watcher = new WatchUidRunner(mInstrumentation, app1Info.uid,
                WAITFOR_MSEC);

        try {
            enableFgsRestriction(true, true, null);
            // APP1 is in BG state, bind FGSL in APP1 first.
            CommandReceiver.sendCommand(mContext, CommandReceiver.COMMAND_BIND_FOREGROUND_SERVICE,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            // Then start FGS in APP1
            WaitForBroadcast waiter = new WaitForBroadcast(mInstrumentation.getTargetContext());
            waiter.prepare(ACTION_START_FGS_RESULT);
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_START_FOREGROUND_SERVICE,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            // APP1 does not enter FGS state
            try {
                waiter.doWait(WAITFOR_MSEC);
                fail(""Service should not enter foreground service state"");
            } catch (Exception e) {
            }

            // stop FGS
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_STOP_FOREGROUND_SERVICE,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            // unbind service.
            CommandReceiver.sendCommand(mContext, CommandReceiver.COMMAND_UNBIND_SERVICE,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            uid1Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_CACHED_EMPTY);
        } finally {
            uid1Watcher.finish();
        }
    }

    /**
     * Test BIND_ALLOW_BACKGROUND_ACTIVITY_STARTS flag.
     * Shell has START_ACTIVITIES_FROM_BACKGROUND permission, it can use this bind flag to
     * pass BG-Activity-launch ability to APP2, then APP2 can start APP2 FGS from background.
     */"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.app.cts.ActivityManagerFgsBgStartTest"	"testFgsBindingFlagNone"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerFgsBgStartTest.java"	""	"public void testFgsBindingFlagNone() throws Exception {
        testFgsBindingFlag(0);
    }

    private void testFgsBindingFlag(int bindingFlag) throws Exception {
        ApplicationInfo app1Info = mContext.getPackageManager().getApplicationInfo(
                PACKAGE_NAME_APP1, 0);
        ApplicationInfo app2Info = mContext.getPackageManager().getApplicationInfo(
                PACKAGE_NAME_APP2, 0);
        ApplicationInfo app3Info = mContext.getPackageManager().getApplicationInfo(
                PACKAGE_NAME_APP3, 0);
        WatchUidRunner uid1Watcher = new WatchUidRunner(mInstrumentation, app1Info.uid,
                WAITFOR_MSEC);
        WatchUidRunner uid2Watcher = new WatchUidRunner(mInstrumentation, app2Info.uid,
                WAITFOR_MSEC);
        WatchUidRunner uid3Watcher = new WatchUidRunner(mInstrumentation, app3Info.uid,
                WAITFOR_MSEC);
        try {
            // Enable the FGS background startForeground() restriction.
            enableFgsRestriction(true, true, null);

            // testapp is in background.
            // testapp binds to service in APP2, APP2 still in background state.
            final Intent intent = new Intent().setClassName(
                    PACKAGE_NAME_APP2, ""android.app.stubs.LocalService"");

            /*
            final ServiceConnection connection = new ServiceConnection() {
                @Override
                public void onServiceConnected(ComponentName name, IBinder service) {
                }
                @Override
                public void onServiceDisconnected(ComponentName name) {
                }
            };
            runWithShellPermissionIdentity(() -> {
                mTargetContext.bindService(intent, connection,
                        Context.BIND_AUTO_CREATE | Context.BIND_WAIVE_PRIORITY);
            });

            // APP2 can not start FGS in APP3.
            WaitForBroadcast waiter = new WaitForBroadcast(mInstrumentation.getTargetContext());
            waiter.prepare(ACTION_START_FGS_RESULT);
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_START_FOREGROUND_SERVICE,
                    PACKAGE_NAME_APP2, PACKAGE_NAME_APP3, 0, null);
            try {
                waiter.doWait(WAITFOR_MSEC);
                fail(""Service should not enter foreground service state"");
            } catch (Exception e) {
            }

            // testapp unbind service in APP2.
            runWithShellPermissionIdentity(() -> mTargetContext.unbindService(connection));
            uid2Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_CACHED_EMPTY);
            */

            // testapp is in background.
            // testapp binds to service in APP2 using the binding flag.
            // APP2 still in background state.
            final ServiceConnection connection2 = new ServiceConnection() {
                @Override
                public void onServiceConnected(ComponentName name, IBinder service) {
                }
                @Override
                public void onServiceDisconnected(ComponentName name) {
                }
            };
            runWithShellPermissionIdentity(() -> mTargetContext.bindService(intent, connection2,
                    Context.BIND_AUTO_CREATE | Context.BIND_WAIVE_PRIORITY
                            | bindingFlag));

            WaitForBroadcast waiter = new WaitForBroadcast(mInstrumentation.getTargetContext());
            waiter.prepare(ACTION_START_FGS_RESULT);
            // Because the binding flag,
            // APP2 can start FGS from background.
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_START_FOREGROUND_SERVICE,
                    PACKAGE_NAME_APP2, PACKAGE_NAME_APP3, 0, null);
            uid3Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_FG_SERVICE);
            waiter.doWait(WAITFOR_MSEC);

            // testapp unbind service in APP2.
            runWithShellPermissionIdentity(() -> mTargetContext.unbindService(connection2));
            uid2Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_CACHED_EMPTY);
            // Stop the FGS in APP3.
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_STOP_FOREGROUND_SERVICE,
                    PACKAGE_NAME_APP3, PACKAGE_NAME_APP3, 0, null);
            uid3Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_CACHED_EMPTY);
        } finally {
            uid1Watcher.finish();
            uid2Watcher.finish();
            uid3Watcher.finish();
        }
    }

    /**
     * Test a FGS can start from BG if the app has SYSTEM_ALERT_WINDOW permission.
     */"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.app.cts.ActivityManagerFgsBgStartTest"	"testFgsStartSystemAlertWindow"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerFgsBgStartTest.java"	""	"public void testFgsStartSystemAlertWindow() throws Exception {
        ApplicationInfo app1Info = mContext.getPackageManager().getApplicationInfo(
                PACKAGE_NAME_APP1, 0);
        WatchUidRunner uid1Watcher = new WatchUidRunner(mInstrumentation, app1Info.uid,
                WAITFOR_MSEC);
        try {
            // Enable the FGS background startForeground() restriction.
            enableFgsRestriction(true, true, null);
            // Start FGS in BG state.
            WaitForBroadcast waiter = new WaitForBroadcast(mInstrumentation.getTargetContext());
            waiter.prepare(ACTION_START_FGS_RESULT);
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_START_FOREGROUND_SERVICE,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            // APP1 does not enter FGS state
            try {
                waiter.doWait(WAITFOR_MSEC);
                fail(""Service should not enter foreground service state"");
            } catch (Exception e) {
            }

            PermissionUtils.grantPermission(
                    PACKAGE_NAME_APP1, android.Manifest.permission.SYSTEM_ALERT_WINDOW);
            waiter = new WaitForBroadcast(mInstrumentation.getTargetContext());
            waiter.prepare(ACTION_START_FGS_RESULT);
            // Now it can start FGS.
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_START_FOREGROUND_SERVICE,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            uid1Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_FG_SERVICE);
            waiter.doWait(WAITFOR_MSEC);
            // Stop the FGS.
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_STOP_FOREGROUND_SERVICE,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            uid1Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_CACHED_EMPTY);
        } finally {
            uid1Watcher.finish();
        }
    }

    /**
     * Test a FGS can start from BG if the device is in retail demo mode.
     */"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.app.cts.ActivityManagerFgsBgStartTest"	"testFgsStartFromBGException"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerFgsBgStartTest.java"	""	"@Ignore(""The instrumentation is allowed to star FGS, it does not throw the exception"")
    public void testFgsStartFromBGException() throws Exception {
        ForegroundServiceStartNotAllowedException expectedException = null;
        final Intent intent = new Intent().setClassName(
                PACKAGE_NAME_APP1, ""android.app.stubs.LocalForegroundService"");
        try {
            allowBgActivityStart(""android.app.stubs"", false);
            enableFgsRestriction(true, true, null);
            mContext.startForegroundService(intent);
        } catch (ForegroundServiceStartNotAllowedException e) {
            expectedException = e;
        } finally {
            mContext.stopService(intent);
            allowBgActivityStart(""android.app.stubs"", true);
        }
        String expectedMessage = ""mAllowStartForeground false"";
        assertNotNull(expectedException);
        assertTrue(expectedException.getMessage().contains(expectedMessage));
    }

    /**
     * Test a FGS can start from BG if the app is in the DeviceIdleController's AllowList.
     */"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.app.cts.ActivityManagerFgsBgStartTest"	"testFgsStartAllowList"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerFgsBgStartTest.java"	""	"public void testFgsStartAllowList() throws Exception {
        ApplicationInfo app1Info = mContext.getPackageManager().getApplicationInfo(
                PACKAGE_NAME_APP1, 0);
        WatchUidRunner uid1Watcher = new WatchUidRunner(mInstrumentation, app1Info.uid,
                WAITFOR_MSEC);
        try {
            // Enable the FGS background startForeground() restriction.
            enableFgsRestriction(true, true, null);
            // Start FGS in BG state.
            WaitForBroadcast waiter = new WaitForBroadcast(mInstrumentation.getTargetContext());
            waiter.prepare(ACTION_START_FGS_RESULT);
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_START_FOREGROUND_SERVICE,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            // APP1 does not enter FGS state
            try {
                waiter.doWait(WAITFOR_MSEC);
                fail(""Service should not enter foreground service state"");
            } catch (Exception e) {
            }

            // Add package to AllowList.
            CtsAppTestUtils.executeShellCmd(mInstrumentation,
                    ""dumpsys deviceidle whitelist +"" + PACKAGE_NAME_APP1);
            waiter = new WaitForBroadcast(mInstrumentation.getTargetContext());
            waiter.prepare(ACTION_START_FGS_RESULT);
            // Now it can start FGS.
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_START_FOREGROUND_SERVICE,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            uid1Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_FG_SERVICE);
            waiter.doWait(WAITFOR_MSEC);
            // Stop the FGS.
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_STOP_FOREGROUND_SERVICE,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            uid1Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_CACHED_EMPTY);
        } finally {
            uid1Watcher.finish();
            // Remove package from AllowList.
            CtsAppTestUtils.executeShellCmd(mInstrumentation,
                    ""dumpsys deviceidle whitelist -"" + PACKAGE_NAME_APP1);
        }
    }

    /**
     * Test temp allowlist types in BroadcastOptions.
     */"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.app.cts.ActivityManagerFgsBgStartTest"	"testTempAllowListType"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerFgsBgStartTest.java"	""	"public void testTempAllowListType() throws Exception {
        testTempAllowListTypeInternal(TEMPORARY_ALLOW_LIST_TYPE_FOREGROUND_SERVICE_NOT_ALLOWED);
        testTempAllowListTypeInternal(TEMPORARY_ALLOW_LIST_TYPE_FOREGROUND_SERVICE_ALLOWED);
    }

    private void testTempAllowListTypeInternal(int type) throws Exception {
        ApplicationInfo app1Info = mContext.getPackageManager().getApplicationInfo(
                PACKAGE_NAME_APP1, 0);
        ApplicationInfo app2Info = mContext.getPackageManager().getApplicationInfo(
                PACKAGE_NAME_APP2, 0);
        WatchUidRunner uid1Watcher = new WatchUidRunner(mInstrumentation, app1Info.uid,
                WAITFOR_MSEC);
        WatchUidRunner uid2Watcher = new WatchUidRunner(mInstrumentation, app2Info.uid,
                WAITFOR_MSEC);
        try {
            // Enable the FGS background startForeground() restriction.
            enableFgsRestriction(true, true, null);
            // Start FGS in BG state.
            WaitForBroadcast waiter = new WaitForBroadcast(mInstrumentation.getTargetContext());
            waiter.prepare(ACTION_START_FGS_RESULT);
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_START_FOREGROUND_SERVICE,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP2, 0, null);
            // APP1 does not enter FGS state
            try {
                waiter.doWait(WAITFOR_MSEC);
                fail(""Service should not enter foreground service state"");
            } catch (Exception e) {
            }

            // Now it can start FGS.
            waiter = new WaitForBroadcast(mInstrumentation.getTargetContext());
            waiter.prepare(ACTION_START_FGS_RESULT);
            runWithShellPermissionIdentity(()-> {
                final BroadcastOptions options = BroadcastOptions.makeBasic();
                // setTemporaryAppAllowlist API requires
                // START_FOREGROUND_SERVICES_FROM_BACKGROUND permission.
                options.setTemporaryAppAllowlist(TEMP_ALLOWLIST_DURATION_MS, type, REASON_UNKNOWN,
                        """");
                // Must use Shell to issue this command because Shell has
                // START_FOREGROUND_SERVICES_FROM_BACKGROUND permission.
                CommandReceiver.sendCommandWithBroadcastOptions(mContext,
                        CommandReceiver.COMMAND_START_FOREGROUND_SERVICE,
                        PACKAGE_NAME_APP1, PACKAGE_NAME_APP2, 0, null,
                        options.toBundle());
            });
            if (type == TEMPORARY_ALLOW_LIST_TYPE_FOREGROUND_SERVICE_ALLOWED) {
                uid2Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_FG_SERVICE);
                waiter.doWait(WAITFOR_MSEC);
                // Stop the FGS.
                CommandReceiver.sendCommand(mContext,
                        CommandReceiver.COMMAND_STOP_FOREGROUND_SERVICE,
                        PACKAGE_NAME_APP1, PACKAGE_NAME_APP2, 0, null);
                uid2Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE,
                        WatchUidRunner.STATE_CACHED_EMPTY);
            } else if (type == TEMPORARY_ALLOW_LIST_TYPE_FOREGROUND_SERVICE_NOT_ALLOWED) {
                // APP1 does not enter FGS state
                try {
                    waiter.doWait(WAITFOR_MSEC);
                    fail(""Service should not enter foreground service state"");
                } catch (Exception e) {
                }
            }
        } finally {
            uid1Watcher.finish();
            uid2Watcher.finish();
            // Sleep 10 seconds to let the temp allowlist expire so it won't affect next test case.
            SystemClock.sleep(TEMP_ALLOWLIST_DURATION_MS);
        }

    }

    /**
     * Test a FGS can start from BG if the process had a visible activity recently.
     */
    @LargeTest"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.app.cts.ActivityManagerFgsBgStartTest"	"testVisibleActivityGracePeriod"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerFgsBgStartTest.java"	""	"public void testVisibleActivityGracePeriod() throws Exception {
        ApplicationInfo app2Info = mContext.getPackageManager().getApplicationInfo(
                PACKAGE_NAME_APP2, 0);
        WatchUidRunner uid2Watcher = new WatchUidRunner(mInstrumentation, app2Info.uid,
                WAITFOR_MSEC);
        final String namespaceActivityManager = ""activity_manager"";
        final String keyFgToBgFgsGraceDuration = ""fg_to_bg_fgs_grace_duration"";
        final long[] curFgToBgFgsGraceDuration = {-1};
        try {
            // Enable the FGS background startForeground() restriction.
            enableFgsRestriction(true, true, null);
            // Allow bg actvity start from APP1.
            allowBgActivityStart(PACKAGE_NAME_APP1, true);

            SystemUtil.runWithShellPermissionIdentity(() -> {
                curFgToBgFgsGraceDuration[0] = DeviceConfig.getInt(
                        namespaceActivityManager,
                        keyFgToBgFgsGraceDuration, -1);
                DeviceConfig.setProperty(namespaceActivityManager,
                        keyFgToBgFgsGraceDuration,
                        Long.toString(WAITFOR_MSEC), false);
            });

            testVisibleActivityGracePeriodInternal(uid2Watcher, ""KEYCODE_HOME"");
            testVisibleActivityGracePeriodInternal(uid2Watcher, ""KEYCODE_BACK"");
        } finally {
            uid2Watcher.finish();
            // Remove package from AllowList.
            allowBgActivityStart(PACKAGE_NAME_APP1, false);
            if (curFgToBgFgsGraceDuration[0] >= 0) {
                SystemUtil.runWithShellPermissionIdentity(() -> {
                    DeviceConfig.setProperty(namespaceActivityManager,
                            keyFgToBgFgsGraceDuration,
                            Long.toString(curFgToBgFgsGraceDuration[0]), false);
                });
            } else {
                CtsAppTestUtils.executeShellCmd(mInstrumentation,
                        ""device_config delete "" + namespaceActivityManager
                        + "" "" + keyFgToBgFgsGraceDuration);
            }
        }
    }

    private void testVisibleActivityGracePeriodInternal(WatchUidRunner uidWatcher, String keyCode)
            throws Exception {
        testVisibleActivityGracePeriodInternal(uidWatcher, keyCode, null,
                () -> uidWatcher.waitFor(WatchUidRunner.CMD_PROCSTATE,
                                         WatchUidRunner.STATE_FG_SERVICE), true);

        testVisibleActivityGracePeriodInternal(uidWatcher, keyCode,
                () -> SystemClock.sleep(WAITFOR_MSEC + 2000), // Wait for the grace period to expire
                () -> {
                    try {
                        uidWatcher.waitFor(WatchUidRunner.CMD_PROCSTATE,
                                WatchUidRunner.STATE_FG_SERVICE);
                        fail(""Service should not enter foreground service state"");
                    } catch (Exception e) {
                        // Expected.
                    }
                }, false);
    }

    private void testVisibleActivityGracePeriodInternal(WatchUidRunner uidWatcher,
            String keyCode, Runnable prep, Runnable verifier, boolean stopFgs) throws Exception {
        // Put APP2 in TOP state.
        CommandReceiver.sendCommand(mContext,
                CommandReceiver.COMMAND_START_ACTIVITY,
                PACKAGE_NAME_APP1, PACKAGE_NAME_APP2, 0, null);
        uidWatcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_TOP);

        // Take a nap to wait for the UI to settle down.
        SystemClock.sleep(2000);

        // Now inject key event.
        CtsAppTestUtils.executeShellCmd(mInstrumentation, ""input keyevent "" + keyCode);

        // It should go to the cached state.
        uidWatcher.waitFor(WatchUidRunner.CMD_CACHED, null);

        if (prep != null) {
            prep.run();
        }

        // Start FGS from APP2.
        CommandReceiver.sendCommand(mContext,
                CommandReceiver.COMMAND_START_FOREGROUND_SERVICE,
                PACKAGE_NAME_APP2, PACKAGE_NAME_APP2, 0, null);

        if (verifier != null) {
            verifier.run();
        }

        if (stopFgs) {
            // Stop the FGS.
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_STOP_FOREGROUND_SERVICE,
                    PACKAGE_NAME_APP2, PACKAGE_NAME_APP2, 0, null);
            uidWatcher.waitFor(WatchUidRunner.CMD_CACHED, null);
        }
    }

    /**
     * After background service is started, after 10 seconds timeout, the startForeground() can
     * succeed or not depends on the service's app proc state.
     * Test starService() -> startForeground()
     */"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.app.cts.ActivityManagerFgsBgStartTest"	"testStartForegroundTimeout"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerFgsBgStartTest.java"	""	"public void testStartForegroundTimeout() throws Exception {
        ApplicationInfo app1Info = mContext.getPackageManager().getApplicationInfo(
                PACKAGE_NAME_APP1, 0);
        WatchUidRunner uid1Watcher = new WatchUidRunner(mInstrumentation, app1Info.uid,
                WAITFOR_MSEC);
        try {
            // Enable the FGS background startForeground() restriction.
            enableFgsRestriction(true, true, null);
            setFgsStartForegroundTimeout(DEFAULT_FGS_START_FOREGROUND_TIMEOUT_MS);

            // Put app to a TOP proc state.
            allowBgActivityStart(PACKAGE_NAME_APP1, true);
            CommandReceiver.sendCommand(mContext, CommandReceiver.COMMAND_START_ACTIVITY,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            uid1Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_TOP);
            allowBgActivityStart(PACKAGE_NAME_APP1, false);

            // start background service.
            Bundle extras = LocalForegroundService.newCommand(
                    LocalForegroundService.COMMAND_START_NO_FOREGROUND);
            CommandReceiver.sendCommand(mContext, CommandReceiver.COMMAND_START_SERVICE,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, extras);

            // stop the activity.
            CommandReceiver.sendCommand(mContext, CommandReceiver.COMMAND_STOP_ACTIVITY,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            uid1Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_SERVICE);

            // Sleep after the timeout DEFAULT_FGS_START_FOREGROUND_TIMEOUT_MS
            SystemClock.sleep(DEFAULT_FGS_START_FOREGROUND_TIMEOUT_MS + 1000);

            extras = LocalForegroundService.newCommand(
                    LocalForegroundService.COMMAND_START_FOREGROUND);
            CommandReceiver.sendCommand(mContext, CommandReceiver.COMMAND_START_SERVICE,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, extras);
            // APP1 does not enter FGS state
            // startForeground() is called after 10 seconds FgsStartForegroundTimeout.
            try {
                uid1Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_FG_SERVICE);
                fail(""Service should not enter foreground service state"");
            } catch (Exception e) {
            }

            // Put app to a TOP proc state.
            allowBgActivityStart(PACKAGE_NAME_APP1, true);
            CommandReceiver.sendCommand(mContext, CommandReceiver.COMMAND_START_ACTIVITY,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            uid1Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE,
                    WatchUidRunner.STATE_TOP, new Integer(PROCESS_CAPABILITY_ALL));
            allowBgActivityStart(PACKAGE_NAME_APP1, false);

            // Call startForeground().
            WaitForBroadcast waiter = new WaitForBroadcast(mInstrumentation.getTargetContext());
            waiter.prepare(ACTION_START_FGS_RESULT);
            extras = LocalForegroundService.newCommand(
                    LocalForegroundService.COMMAND_START_FOREGROUND);
            CommandReceiver.sendCommand(mContext, CommandReceiver.COMMAND_START_SERVICE,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, extras);
            CommandReceiver.sendCommand(mContext, CommandReceiver.COMMAND_STOP_ACTIVITY,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);

            uid1Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_FG_SERVICE);
            waiter.doWait(WAITFOR_MSEC);

            // Stop the FGS.
            CommandReceiver.sendCommand(mContext, CommandReceiver.COMMAND_STOP_SERVICE,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            uid1Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_CACHED_EMPTY,
                    new Integer(PROCESS_CAPABILITY_NONE));
        } finally {
            uid1Watcher.finish();
            setFgsStartForegroundTimeout(DEFAULT_FGS_START_FOREGROUND_TIMEOUT_MS);
        }
    }

    /**
     * After startForeground() and stopForeground(), the second startForeground() can succeed or not
     * depends on the service's app proc state.
     * Test startForegroundService() -> startForeground() -> stopForeground() -> startForeground().
     */"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.app.cts.ActivityManagerFgsBgStartTest"	"testSecondStartForeground"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerFgsBgStartTest.java"	""	"public void testSecondStartForeground() throws Exception {
        ApplicationInfo app1Info = mContext.getPackageManager().getApplicationInfo(
                PACKAGE_NAME_APP1, 0);
        WatchUidRunner uid1Watcher = new WatchUidRunner(mInstrumentation, app1Info.uid,
                WAITFOR_MSEC);
        try {
            // Enable the FGS background startForeground() restriction.
            enableFgsRestriction(true, true, null);
            WaitForBroadcast waiter = new WaitForBroadcast(mInstrumentation.getTargetContext());
            waiter.prepare(ACTION_START_FGS_RESULT);
            // bypass bg-service-start restriction.
            CtsAppTestUtils.executeShellCmd(mInstrumentation,
                    ""dumpsys deviceidle whitelist +"" + PACKAGE_NAME_APP1);
            // start foreground service.
            CommandReceiver.sendCommand(mContext, CommandReceiver.COMMAND_START_FOREGROUND_SERVICE,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            uid1Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_FG_SERVICE);
            waiter.doWait(WAITFOR_MSEC);
            CtsAppTestUtils.executeShellCmd(mInstrumentation,
                    ""dumpsys deviceidle whitelist -"" + PACKAGE_NAME_APP1);

            // stopForeground()
            Bundle extras = LocalForegroundService.newCommand(
                    LocalForegroundService.COMMAND_STOP_FOREGROUND_REMOVE_NOTIFICATION);
            CommandReceiver.sendCommand(mContext, CommandReceiver.COMMAND_START_SERVICE,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, extras);
            uid1Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_SERVICE,
                    new Integer(PROCESS_CAPABILITY_NONE));

            // startForeground() again.
            extras = LocalForegroundService.newCommand(
                    LocalForegroundService.COMMAND_START_FOREGROUND);
            CommandReceiver.sendCommand(mContext, CommandReceiver.COMMAND_START_SERVICE,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, extras);
            try {
                uid1Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_FG_SERVICE);
                fail(""Service should not enter foreground service state"");
            } catch (Exception e) {
            }

            // Put app to a TOP proc state.
            allowBgActivityStart(PACKAGE_NAME_APP1, true);
            CommandReceiver.sendCommand(mContext, CommandReceiver.COMMAND_START_ACTIVITY,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            uid1Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_TOP,
                    new Integer(PROCESS_CAPABILITY_ALL));
            allowBgActivityStart(PACKAGE_NAME_APP1, false);

            // Call startForeground() second time.
            waiter = new WaitForBroadcast(mInstrumentation.getTargetContext());
            waiter.prepare(ACTION_START_FGS_RESULT);
            CommandReceiver.sendCommand(mContext, CommandReceiver.COMMAND_START_FOREGROUND_SERVICE,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            CommandReceiver.sendCommand(mContext, CommandReceiver.COMMAND_STOP_ACTIVITY,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);

            uid1Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_FG_SERVICE,
                    LOCAL_SERVICE_PROCESS_CAPABILITY);
            waiter.doWait(WAITFOR_MSEC);

            // Stop the FGS.
            CommandReceiver.sendCommand(mContext, CommandReceiver.COMMAND_STOP_FOREGROUND_SERVICE,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            uid1Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_CACHED_EMPTY,
                    new Integer(PROCESS_CAPABILITY_NONE));
        } finally {
            uid1Watcher.finish();
        }
    }

    /**
     * Test OP_ACTIVATE_VPN and OP_ACTIVATE_PLATFORM_VPN are exempted from BG-FGS-launch
     * restriction.
     * @throws Exception
     */"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.app.cts.ActivityManagerFgsBgStartTest"	"testFgsStartVpn"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerFgsBgStartTest.java"	""	"public void testFgsStartVpn() throws Exception {
        testFgsStartVpnInternal(""ACTIVATE_VPN"");
        testFgsStartVpnInternal(""ACTIVATE_PLATFORM_VPN"");
    }

    private void testFgsStartVpnInternal(String vpnAppOp) throws Exception {
        ApplicationInfo app1Info = mContext.getPackageManager().getApplicationInfo(
                PACKAGE_NAME_APP1, 0);
        WatchUidRunner uid1Watcher = new WatchUidRunner(mInstrumentation, app1Info.uid,
                WAITFOR_MSEC);
        try {
            // Enable the FGS background startForeground() restriction.
            enableFgsRestriction(true, true, null);
            // Start FGS in BG state.
            WaitForBroadcast waiter = new WaitForBroadcast(mInstrumentation.getTargetContext());
            waiter.prepare(ACTION_START_FGS_RESULT);
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_START_FOREGROUND_SERVICE,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            // APP1 does not enter FGS state
            try {
                waiter.doWait(WAITFOR_MSEC);
                fail(""Service should not enter foreground service state"");
            } catch (Exception e) {
            }

            setAppOp(PACKAGE_NAME_APP1, vpnAppOp, true);

            waiter = new WaitForBroadcast(mInstrumentation.getTargetContext());
            waiter.prepare(ACTION_START_FGS_RESULT);
            // Now it can start FGS.
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_START_FOREGROUND_SERVICE,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            uid1Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_FG_SERVICE);
            waiter.doWait(WAITFOR_MSEC);
            // Stop the FGS.
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_STOP_FOREGROUND_SERVICE,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            uid1Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_CACHED_EMPTY);
        } finally {
            uid1Watcher.finish();
            CtsAppTestUtils.executeShellCmd(mInstrumentation,
                    ""appops reset "" + PACKAGE_NAME_APP1);
        }
    }

    /**
     * The default behavior for temp allowlist reasonCode REASON_PUSH_MESSAGING_OVER_QUOTA
     * is TEMPORARY_ALLOW_LIST_TYPE_FOREGROUND_SERVICE_NOT_ALLOWED (not allowed to start FGS). But
     * the behavior can be changed by device config command. There are three possible values:
     * {@link TEMPORARY_ALLOW_LIST_TYPE_NONE} (-1):
     *      not temp allowlisted.
     * {@link TEMPORARY_ALLOW_LIST_TYPE_FOREGROUND_SERVICE_ALLOWED} (0):
     *      temp allowlisted and allow FGS.
     * {@link TEMPORARY_ALLOW_LIST_TYPE_FOREGROUND_SERVICE_NOT_ALLOWED} (1):
     *      temp allowlisted, not allow FGS.
     * @throws Exception
     */"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.app.cts.ActivityManagerFgsBgStartTest"	"testPushMessagingOverQuota"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerFgsBgStartTest.java"	""	"public void testPushMessagingOverQuota() throws Exception {
        ApplicationInfo app1Info = mContext.getPackageManager().getApplicationInfo(
                PACKAGE_NAME_APP1, 0);
        WatchUidRunner uid1Watcher = new WatchUidRunner(mInstrumentation, app1Info.uid,
                WAITFOR_MSEC);
        try {
            // Enable the FGS background startForeground() restriction.
            enableFgsRestriction(true, true, null);
            // Default behavior is TEMPORARY_ALLOW_LIST_TYPE_FOREGROUND_SERVICE_NOT_ALLOWED.
            setPushMessagingOverQuotaBehavior(
                    TEMPORARY_ALLOW_LIST_TYPE_FOREGROUND_SERVICE_NOT_ALLOWED);
            // Start FGS in BG state.
            WaitForBroadcast waiter = new WaitForBroadcast(mInstrumentation.getTargetContext());
            waiter.prepare(ACTION_START_FGS_RESULT);
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_START_FOREGROUND_SERVICE,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            // APP1 does not enter FGS state
            try {
                waiter.doWait(WAITFOR_MSEC);
                fail(""Service should not enter foreground service state"");
            } catch (Exception e) {
            }

            setPushMessagingOverQuotaBehavior(TEMPORARY_ALLOW_LIST_TYPE_NONE);
            waiter = new WaitForBroadcast(mInstrumentation.getTargetContext());
            waiter.prepare(ACTION_START_FGS_RESULT);
            runWithShellPermissionIdentity(() -> {
                mContext.getSystemService(PowerExemptionManager.class).addToTemporaryAllowList(
                        PACKAGE_NAME_APP1, PowerExemptionManager.REASON_PUSH_MESSAGING_OVER_QUOTA,
                        """", TEMP_ALLOWLIST_DURATION_MS);
            });
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_START_FOREGROUND_SERVICE,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            // APP1 does not enter FGS state
            try {
                waiter.doWait(WAITFOR_MSEC);
                fail(""Service should not enter foreground service state"");
            } catch (Exception e) {
            }

            // Change behavior to TEMPORARY_ALLOW_LIST_TYPE_FOREGROUND_SERVICE_ALLOWED.
            setPushMessagingOverQuotaBehavior(
                    TEMPORARY_ALLOW_LIST_TYPE_FOREGROUND_SERVICE_ALLOWED);
            runWithShellPermissionIdentity(() -> {
                mContext.getSystemService(PowerExemptionManager.class).addToTemporaryAllowList(
                        PACKAGE_NAME_APP1, PowerExemptionManager.REASON_PUSH_MESSAGING_OVER_QUOTA,
                        """", TEMP_ALLOWLIST_DURATION_MS);
            });
            waiter = new WaitForBroadcast(mInstrumentation.getTargetContext());
            waiter.prepare(ACTION_START_FGS_RESULT);
            // Now it can start FGS.
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_START_FOREGROUND_SERVICE,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            uid1Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_FG_SERVICE);
            waiter.doWait(WAITFOR_MSEC);
            // Stop the FGS.
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_STOP_FOREGROUND_SERVICE,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            uid1Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_CACHED_EMPTY);
        } finally {
            uid1Watcher.finish();
            // Change back to default behavior.
            setPushMessagingOverQuotaBehavior(
                    TEMPORARY_ALLOW_LIST_TYPE_FOREGROUND_SERVICE_NOT_ALLOWED);
            // allow temp allowlist to expire.
            SystemClock.sleep(TEMP_ALLOWLIST_DURATION_MS);
        }
    }

    /**
     * Test temp allowlist reasonCode in BroadcastOptions.
     * When REASON_PUSH_MESSAGING_OVER_QUOTA, DeviceIdleController changes temp allowlist type to
     * TEMPORARY_ALLOWLIST_TYPE_FOREGROUND_SERVICE_NOT_ALLOWED so FGS start is not allowed.
     * When REASON_DENIED (-1), DeviceIdleController changes temp allowlist type to
     * TEMPORARY_ALLOWLIST_TYPE_NONE, the temp allowlist itself is not allowed.
     * All other reason codes, DeviceIdleController does not change temp allowlist type.
     */"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.app.cts.ActivityManagerFgsBgStartTest"	"testTempAllowListReasonCode"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerFgsBgStartTest.java"	""	"public void testTempAllowListReasonCode() throws Exception {
        // FGS start is temp allowed.
        testTempAllowListReasonCodeInternal(REASON_PUSH_MESSAGING);
        // FGS start is not allowed.
        testTempAllowListReasonCodeInternal(REASON_PUSH_MESSAGING_OVER_QUOTA);
        // Temp allowlist itself is not allowed. REASON_DENIED is not exposed in
        // PowerExemptionManager, just use its value ""-1"" here.
        testTempAllowListReasonCodeInternal(-1);
    }

    private void testTempAllowListReasonCodeInternal(int reasonCode) throws Exception {
        ApplicationInfo app1Info = mContext.getPackageManager().getApplicationInfo(
                PACKAGE_NAME_APP1, 0);
        ApplicationInfo app2Info = mContext.getPackageManager().getApplicationInfo(
                PACKAGE_NAME_APP2, 0);
        WatchUidRunner uid1Watcher = new WatchUidRunner(mInstrumentation, app1Info.uid,
                WAITFOR_MSEC);
        WatchUidRunner uid2Watcher = new WatchUidRunner(mInstrumentation, app2Info.uid,
                WAITFOR_MSEC);
        try {
            // Enable the FGS background startForeground() restriction.
            enableFgsRestriction(true, true, null);
            // Now it can start FGS.
            WaitForBroadcast waiter = new WaitForBroadcast(mInstrumentation.getTargetContext());
            waiter.prepare(ACTION_START_FGS_RESULT);
            runWithShellPermissionIdentity(()-> {
                final BroadcastOptions options = BroadcastOptions.makeBasic();
                // setTemporaryAppAllowlist API requires
                // START_FOREGROUND_SERVICES_FROM_BACKGROUND permission.
                options.setTemporaryAppAllowlist(TEMP_ALLOWLIST_DURATION_MS,
                        TEMPORARY_ALLOW_LIST_TYPE_FOREGROUND_SERVICE_ALLOWED, reasonCode,
                        """");
                // Must use Shell to issue this command because Shell has
                // START_FOREGROUND_SERVICES_FROM_BACKGROUND permission.
                CommandReceiver.sendCommandWithBroadcastOptions(mContext,
                        CommandReceiver.COMMAND_START_FOREGROUND_SERVICE,
                        PACKAGE_NAME_APP1, PACKAGE_NAME_APP2, 0, null,
                        options.toBundle());
            });
            if (reasonCode == REASON_PUSH_MESSAGING) {
                uid2Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_FG_SERVICE);
                waiter.doWait(WAITFOR_MSEC);
                // Stop the FGS.
                CommandReceiver.sendCommand(mContext,
                        CommandReceiver.COMMAND_STOP_FOREGROUND_SERVICE,
                        PACKAGE_NAME_APP1, PACKAGE_NAME_APP2, 0, null);
                uid2Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE,
                        WatchUidRunner.STATE_CACHED_EMPTY);
            } else if (reasonCode == REASON_PUSH_MESSAGING_OVER_QUOTA) {
                // APP1 does not enter FGS state
                try {
                    waiter.doWait(WAITFOR_MSEC);
                    fail(""Service should not enter foreground service state"");
                } catch (Exception e) {
                }
            }
        } finally {
            uid1Watcher.finish();
            uid2Watcher.finish();
            // Sleep to let the temp allowlist expire so it won't affect next test case.
            SystemClock.sleep(TEMP_ALLOWLIST_DURATION_MS);
        }
    }

    /**
     * Test default_input_method is exempted from BG-FGS-start restriction.
     * @throws Exception
     */"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.app.cts.ActivityManagerFgsBgStartTest"	"testFgsStartInputMethod"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerFgsBgStartTest.java"	""	"public void testFgsStartInputMethod() throws Exception {
        ApplicationInfo app1Info = mContext.getPackageManager().getApplicationInfo(
                PACKAGE_NAME_APP1, 0);
        WatchUidRunner uid1Watcher = new WatchUidRunner(mInstrumentation, app1Info.uid,
                WAITFOR_MSEC);
        final String defaultInputMethod = CtsAppTestUtils.executeShellCmd(mInstrumentation,
                ""settings get --user current secure default_input_method"");
        try {
            // Enable the FGS background startForeground() restriction.
            enableFgsRestriction(true, true, null);
            // Start FGS in BG state.
            WaitForBroadcast waiter = new WaitForBroadcast(mInstrumentation.getTargetContext());
            waiter.prepare(ACTION_START_FGS_RESULT);
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_START_FOREGROUND_SERVICE,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            // APP1 does not enter FGS state
            try {
                waiter.doWait(WAITFOR_MSEC);
                fail(""Service should not enter foreground service state"");
            } catch (Exception e) {
            }

            // Change default_input_method to PACKAGE_NAME_APP1.
            final ComponentName cn = new ComponentName(PACKAGE_NAME_APP1, ""xxx"");
            CtsAppTestUtils.executeShellCmd(mInstrumentation,
                    ""settings put --user current secure default_input_method ""
                            + cn.flattenToShortString());

            waiter = new WaitForBroadcast(mInstrumentation.getTargetContext());
            waiter.prepare(ACTION_START_FGS_RESULT);
            // Now it can start FGS.
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_START_FOREGROUND_SERVICE,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            uid1Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_FG_SERVICE);
            waiter.doWait(WAITFOR_MSEC);
            // Stop the FGS.
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_STOP_FOREGROUND_SERVICE,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            uid1Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_CACHED_EMPTY);
        } finally {
            uid1Watcher.finish();
            CtsAppTestUtils.executeShellCmd(mInstrumentation,
                    ""settings put --user current secure default_input_method ""
                            + defaultInputMethod);
        }
    }

    /**
     * Turn on the FGS BG-launch restriction. DeviceConfig can turn on restriction on the whole
     * device (across all apps). AppCompat can turn on restriction on a single app package.
     * @param enable true to turn on restriction, false to turn off.
     * @param useDeviceConfig true to use DeviceConfig, false to use AppCompat CHANGE ID.
     * @param packageName the packageName if using AppCompat CHANGE ID.
     * @throws Exception
     */
    private void enableFgsRestriction(boolean enable, boolean useDeviceConfig, String packageName)
            throws Exception {
        if (useDeviceConfig) {
            runWithShellPermissionIdentity(() -> {
                        DeviceConfig.setProperty(""activity_manager"",
                                KEY_DEFAULT_FGS_STARTS_RESTRICTION_ENABLED,
                                Boolean.toString(enable), false);
                    }
            );
        } else {
            CtsAppTestUtils.executeShellCmd(mInstrumentation,
                    ""am compat "" + (enable ? ""enable"" : ""disable"")
                            + "" FGS_BG_START_RESTRICTION_CHANGE_ID "" + packageName);
        }
    }

    /**
     * Clean up the FGS BG-launch restriction.
     * @param packageName the packageName that will have its changeid override reset.
     * @throws Exception
     */
    private void resetFgsRestriction(String packageName)
            throws Exception {
        CtsAppTestUtils.executeShellCmd(mInstrumentation,
                ""am compat reset FGS_BG_START_RESTRICTION_CHANGE_ID "" + packageName);
    }

    /**
     * SYSTEM_ALERT_WINDOW permission will allow both BG-activity start and BG-FGS start.
     * Some cases we want to grant this permission to allow activity start to bring the app up to
     * TOP state.
     * Some cases we want to revoke this permission to test other BG-FGS-launch exemptions.
     * @param packageName
     * @param allow
     * @throws Exception
     */
    private void allowBgActivityStart(String packageName, boolean allow) throws Exception {
        if (allow) {
            PermissionUtils.grantPermission(
                    packageName, android.Manifest.permission.SYSTEM_ALERT_WINDOW);
        } else {
            PermissionUtils.revokePermission(
                    packageName, android.Manifest.permission.SYSTEM_ALERT_WINDOW);
        }
    }

    private void setFgsStartForegroundTimeout(int timeoutMs) throws Exception {
        runWithShellPermissionIdentity(() -> {
                    DeviceConfig.setProperty(""activity_manager"",
                            KEY_FGS_START_FOREGROUND_TIMEOUT,
                            Integer.toString(timeoutMs), false);
                }
        );
    }

    private void setAppOp(String packageName, String opStr, boolean allow) throws Exception {
        CtsAppTestUtils.executeShellCmd(mInstrumentation,
                ""appops set "" + packageName + "" "" + opStr + "" ""
                        + (allow ? ""allow"" : ""deny""));
    }

    private void setPushMessagingOverQuotaBehavior(
            /* @PowerExemptionManager.TempAllowListType */ int type) throws Exception {
        runWithShellPermissionIdentity(() -> {
                    DeviceConfig.setProperty(""activity_manager"",
                            KEY_PUSH_MESSAGING_OVER_QUOTA_BEHAVIOR,
                            Integer.toString(type), false);
                }
        );
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.DelegationTest"	"emptyList"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/DelegationTest.java"	""	"public void test/*
 *.
 */

package com.android.cts.deviceandprofileowner;

import static android.app.admin.DevicePolicyManager.DELEGATION_APP_RESTRICTIONS;
import static android.app.admin.DevicePolicyManager.DELEGATION_BLOCK_UNINSTALL;
import static android.app.admin.DevicePolicyManager.DELEGATION_CERT_INSTALL;
import static android.app.admin.DevicePolicyManager.DELEGATION_CERT_SELECTION;
import static android.app.admin.DevicePolicyManager.DELEGATION_ENABLE_SYSTEM_APP;
import static android.app.admin.DevicePolicyManager.DELEGATION_NETWORK_LOGGING;
import static android.app.admin.DevicePolicyManager.DELEGATION_SECURITY_LOGGING;
import static android.app.admin.DevicePolicyManager.EXTRA_DELEGATION_SCOPES;

import static com.google.common.truth.Truth.assertThat;

import static org.junit.Assert.assertThrows;

import android.app.admin.DevicePolicyManager;
import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.Process;
import android.os.UserManager;
import android.test.MoreAsserts;
import android.util.Log;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;


/**
 * Test that an app granted delegation scopes via {@link DevicePolicyManager#setDelegatedScopes} is
 * notified of its new scopes by a broadcast.
 */
public class DelegationTest extends BaseDeviceAdminTest {
    private static final String TAG = ""DelegationTest"";

    private static final String DELEGATE_PKG = ""com.android.cts.delegate"";
    private static final String DELEGATE_ACTIVITY_NAME =
            DELEGATE_PKG + "".DelegatedScopesReceiverActivity"";
    private static final String DELEGATE_SERVICE_NAME =
            DELEGATE_PKG + "".DelegatedScopesReceiverService"";
    private static final String TEST_PKG = ""com.android.cts.apprestrictions.targetapp"";

    // Broadcasts received from the delegate app.
    private static final String ACTION_REPORT_SCOPES = ""com.android.cts.delegate.report_scopes"";
    private static final String ACTION_RUNNING = ""com.android.cts.delegate.running"";

    // Semaphores to synchronize communication with delegate app.
    private volatile String[] mReceivedScopes;
    private Semaphore mReceivedScopeReportSemaphore;
    private Semaphore mReceivedRunningSemaphore;

    // Receiver for incoming broadcasts from the delegate app.
    private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            Log.v(TAG, ""onReceive(): "" + intent.getAction() + "" on user "" + Process.myUserHandle());
            if (ACTION_REPORT_SCOPES.equals(intent.getAction())) {
                synchronized (DelegationTest.this) {
                    mReceivedScopes = intent.getStringArrayExtra(EXTRA_DELEGATION_SCOPES);
                    mReceivedScopeReportSemaphore.release();
                }
            } else if (ACTION_RUNNING.equals(intent.getAction())) {
                synchronized (DelegationTest.this) {
                    mReceivedRunningSemaphore.release();
                }
            }
        }
    };

    @Override
    public void setUp() throws Exception {
        super.setUp();
        mReceivedScopeReportSemaphore = new Semaphore(0);
        mReceivedRunningSemaphore = new Semaphore(0);
        mReceivedScopes = null;
        IntentFilter filter = new IntentFilter();
        filter.addAction(ACTION_REPORT_SCOPES);
        filter.addAction(ACTION_RUNNING);
        mContext.registerReceiver(mReceiver, filter);
    }

    @Override
    public void tearDown() throws Exception {
        mContext.unregisterReceiver(mReceiver);
        mDevicePolicyManager.setDelegatedScopes(ADMIN_RECEIVER_COMPONENT,
                TEST_PKG, Collections.emptyList());
        mDevicePolicyManager.setDelegatedScopes(ADMIN_RECEIVER_COMPONENT,
                DELEGATE_PKG, Collections.emptyList());
        super.tearDown();
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.DelegationTest"	"testDelegateReceivesScopeChangedBroadcast"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/DelegationTest.java"	""	"public void testDelegateReceivesScopeChangedBroadcast() throws InterruptedException {
        if (UserManager.isHeadlessSystemUserMode()) {
            // TODO(b/190627898): this test launched an activity to receive the broadcast from DPM,
            // but headless system user cannot launch activity. To make things worse, the intent
            // is only sent to registered receivers, so we cannot use the existing receivers from
            // DpmWrapper, we would need to start a service on user 0 to receive the broadcast,
            // which would require a lot of changes:
            // - calling APIs / Shell commands to allow an app in the bg to start a service
            // - add a ""launchIntent()"" method on DpmWrapper so the intent is launched by user 0
            //
            // It might not be worth to make these changes, but rather wait for the test refactoring
            Log.i(TAG, ""Skipping testDelegateReceivesScopeChangedBroadcast() on headless system ""
                    + ""user mode"");
            return;
        }

        // Prepare the scopes to be delegated.
        final List<String> scopes = Arrays.asList(
                DELEGATION_CERT_INSTALL,
                DELEGATION_APP_RESTRICTIONS,
                DELEGATION_BLOCK_UNINSTALL,
                DELEGATION_ENABLE_SYSTEM_APP);

        // Start delegate so it can receive the scopes changed broadcast from DevicePolicyManager.
        startAndWaitDelegateActivity();

        // Set the delegated scopes.
        mDevicePolicyManager.setDelegatedScopes(ADMIN_RECEIVER_COMPONENT, DELEGATE_PKG, scopes);

        // Wait until the delegate reports its new scopes.
        String reportedScopes[] = waitReportedScopes();

        // Check that the reported scopes correspond to scopes we delegated.
        assertNotNull(""Received null scopes from delegate"", reportedScopes);
        MoreAsserts.assertContentsInAnyOrder(""Delegated scopes do not match broadcasted scopes"",
                scopes, reportedScopes);
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.DelegationTest"	"testCanRetrieveDelegates"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/DelegationTest.java"	""	"public void testCanRetrieveDelegates() {
        final List<String> someScopes = Arrays.asList(
                DELEGATION_APP_RESTRICTIONS,
                DELEGATION_ENABLE_SYSTEM_APP);
        final List<String> otherScopes = Arrays.asList(
                DELEGATION_BLOCK_UNINSTALL,
                DELEGATION_ENABLE_SYSTEM_APP);

        // In the beginning there are no delegates.
        assertTrue(""No delegates should be found"", getDelegatePackages(DELEGATION_APP_RESTRICTIONS)
                .isEmpty());
        assertTrue(""No delegates should be found"", getDelegatePackages(DELEGATION_BLOCK_UNINSTALL)
                .isEmpty());
        assertTrue(""No delegates should be found"", getDelegatePackages(DELEGATION_ENABLE_SYSTEM_APP)
                .isEmpty());

        // After delegating scopes to two packages.
        mDevicePolicyManager.setDelegatedScopes(ADMIN_RECEIVER_COMPONENT,
                DELEGATE_PKG, someScopes);
        mDevicePolicyManager.setDelegatedScopes(ADMIN_RECEIVER_COMPONENT,
                TEST_PKG, otherScopes);

        // The expected delegates are returned.
        assertTrue(""Expected delegate not found"", getDelegatePackages(DELEGATION_APP_RESTRICTIONS)
                .contains(DELEGATE_PKG));
        assertTrue(""Expected delegate not found"", getDelegatePackages(DELEGATION_BLOCK_UNINSTALL)
                .contains(TEST_PKG));
        assertTrue(""Expected delegate not found"", getDelegatePackages(DELEGATION_ENABLE_SYSTEM_APP)
                .contains(DELEGATE_PKG));
        assertTrue(""Expected delegate not found"", getDelegatePackages(DELEGATION_ENABLE_SYSTEM_APP)
                .contains(TEST_PKG));

        // Packages are only returned in their recpective scopes.
        assertFalse(""Unexpected delegate package"", getDelegatePackages(DELEGATION_APP_RESTRICTIONS)
                .contains(TEST_PKG));
        assertFalse(""Unexpected delegate package"", getDelegatePackages(DELEGATION_BLOCK_UNINSTALL)
                .contains(DELEGATE_PKG));
        assertFalse(""Unexpected delegate package"", getDelegatePackages(DELEGATION_CERT_INSTALL)
                .contains(DELEGATE_PKG));
        assertFalse(""Unexpected delegate package"", getDelegatePackages(DELEGATION_CERT_INSTALL)
                .contains(TEST_PKG));
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"test.java.com.android.queryable.queries.EnumQueryHelperTest"	"isTrue"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/queryable/src/test/java/com/android/queryable/queries/EnumQueryHelperTest.java"	""	"public void matches_noRestrictions_returnsTrue() {
        EnumQueryHelper<Queryable, TestEnum> enumQueryHelper =
                new EnumQueryHelper<>(mQuery);

        assertThat(enumQueryHelper.matches(TestEnum.VALUE1)).isTrue();
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.ManagedProfileTest"	"testNoDebuggingFeaturesRestriction"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/ManagedProfileTest.java"	""	"public void testNoDebuggingFeaturesRestriction() throws Exception {
        // If adb is running as root, then the adb uid is 0 instead of SHELL_UID,
        // so the DISALLOW_DEBUGGING_FEATURES restriction does not work and this test
        // fails.
        if (getDevice().isAdbRoot()) {
            CLog.logAndDisplay(LogLevel.WARN,
                    ""Cannot test testNoDebuggingFeaturesRestriction() in eng/userdebug build"");
            return;
        }
        String restriction = ""no_debugging_features"";  // UserManager.DISALLOW_DEBUGGING_FEATURES

        changeUserRestrictionOrFail(restriction, true, mProfileUserId);


        // This should now fail, as the shell is not available to start activities under a different
        // user once the restriction is in place.
        String addRestrictionCommandOutput =
                changeUserRestriction(restriction, true, mProfileUserId);
        assertTrue(
                ""Expected SecurityException when starting the activity ""
                        + addRestrictionCommandOutput,
                addRestrictionCommandOutput.contains(""SecurityException""));
    }

    // Test the bluetooth API from a managed profile."	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.ManagedProfileTest"	"testNfcRestriction"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/ManagedProfileTest.java"	""	"public void testNfcRestriction() throws Exception {
        assumeHasNfcFeatures();

        runDeviceTestsAsUser(MANAGED_PROFILE_PKG, "".NfcTest"",
                ""testNfcShareEnabled"", mProfileUserId);
        runDeviceTestsAsUser(MANAGED_PROFILE_PKG, "".NfcTest"",
                ""testNfcShareEnabled"", mParentUserId);

        changeUserRestrictionOrFail(""no_outgoing_beam"" /* UserManager.DISALLOW_OUTGOING_BEAM */,
                true, mProfileUserId);

        runDeviceTestsAsUser(MANAGED_PROFILE_PKG, "".NfcTest"",
                ""testNfcShareDisabled"", mProfileUserId);
        runDeviceTestsAsUser(MANAGED_PROFILE_PKG, "".NfcTest"",
                ""testNfcShareEnabled"", mParentUserId);
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.ManagedProfileTest"	"testBluetoothSharingRestriction"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/ManagedProfileTest.java"	""	"public void testBluetoothSharingRestriction() throws Exception {
        assumeHasBluetoothFeature();

        // Primary profile should be able to use bluetooth sharing.
        runDeviceTestsAsUser(MANAGED_PROFILE_PKG, "".BluetoothSharingRestrictionPrimaryProfileTest"",
                ""testBluetoothSharingAvailable"", mPrimaryUserId);

        // Managed profile owner should be able to control it via DISALLOW_BLUETOOTH_SHARING.
        runDeviceTestsAsUser(MANAGED_PROFILE_PKG, "".BluetoothSharingRestrictionTest"",
                ""testOppDisabledWhenRestrictionSet"", mProfileUserId);
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.ManagedProfileTest"	"testChooserActivityLaunchedFromWorkProfileWithSelectedPersonalTab"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/ManagedProfileTest.java"	""	"public void testChooserActivityLaunchedFromWorkProfileWithSelectedPersonalTab()
            throws Exception {
        installAppAsUser(SHARING_APP_1_APK, mPrimaryUserId);
        installAppAsUser(SHARING_APP_2_APK, mPrimaryUserId);
        installAppAsUser(SHARING_APP_1_APK, mProfileUserId);
        installAppAsUser(SHARING_APP_2_APK, mProfileUserId);
        try {
            runDeviceTestsAsUser(MANAGED_PROFILE_PKG, "".CrossProfileSharingTest"",
                    ""addCrossProfileIntents"", mProfileUserId);
            runDeviceTestsAsUser(MANAGED_PROFILE_PKG, "".CrossProfileSharingTest"",
                    ""startSwitchToOtherProfileIntent_chooser"", mProfileUserId);
            assertChooserActivityInForeground(mProfileUserId);
        } finally {
            pressHome();
            runDeviceTestsAsUser(MANAGED_PROFILE_PKG, "".CrossProfileSharingTest"",
                    ""clearCrossProfileIntents"", mProfileUserId);
        }
    }

    private void pressHome() throws Exception {
        executeShellCommand(""input keyevent KEYCODE_HOME"");
    }

    private void assertChooserActivityInForeground(int userId)
            throws DeviceNotAvailableException {
        assertActivityInForeground(""android/com.android.internal.app.ChooserActivity"", userId);
    }

    private void assertResolverActivityInForeground(int userId)
            throws DeviceNotAvailableException {
        assertActivityInForeground(""android/com.android.internal.app.ResolverActivity"", userId);
    }

    private void assertActivityInForeground(String fullActivityName, int userId)
            throws DeviceNotAvailableException {
        String commandOutput =
                getDevice().executeShellCommand(""dumpsys activity activities | grep Resumed:"");
        assertThat(commandOutput).contains(""u"" + userId + "" "" + fullActivityName);
    }

    private void changeUserRestrictionOrFail(String key, boolean value, int userId)
            throws DeviceNotAvailableException {
        changeUserRestrictionOrFail(key, value, userId, MANAGED_PROFILE_PKG);
    }

    private String changeUserRestriction(String key, boolean value, int userId)
            throws DeviceNotAvailableException {
        return changeUserRestriction(key, value, userId, MANAGED_PROFILE_PKG);
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.alarmmanager.cts.AppStandbyTests"	"setUpTests"	"CtsAlarmManagerTestCases"	"/home/gpoor/cts-12-source/cts/tests/AlarmManager/src/android/alarmmanager/cts/AppStandbyTests.java"	""	"/*
 *.
 */

package android.alarmmanager.cts;

import static android.app.AlarmManager.ELAPSED_REALTIME_WAKEUP;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.junit.Assume.assumeTrue;

import android.alarmmanager.alarmtestapp.cts.TestAlarmReceiver;
import android.alarmmanager.alarmtestapp.cts.TestAlarmScheduler;
import android.alarmmanager.util.AlarmManagerDeviceConfigHelper;
import android.app.Activity;
import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.BatteryManager;
import android.os.SystemClock;
import android.platform.test.annotations.AppModeFull;
import android.support.test.uiautomator.UiDevice;
import android.util.Log;
import android.util.LongArray;

import androidx.test.InstrumentationRegistry;
import androidx.test.filters.LargeTest;
import androidx.test.runner.AndroidJUnit4;

import com.android.compatibility.common.util.AppStandbyUtils;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.io.IOException;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.BooleanSupplier;

/**
 * Tests that app standby imposes the appropriate restrictions on alarms
 */
@AppModeFull
@LargeTest
@RunWith(AndroidJUnit4.class)
public class AppStandbyTests {
    private static final String TAG = AppStandbyTests.class.getSimpleName();
    static final String TEST_APP_PACKAGE = ""android.alarmmanager.alarmtestapp.cts"";
    private static final String TEST_APP_RECEIVER = TEST_APP_PACKAGE + "".TestAlarmScheduler"";

    private static final long DEFAULT_WAIT = 2_000;
    private static final long POLL_INTERVAL = 200;

    // Tweaked alarm manager constants to facilitate testing
    private static final long MIN_FUTURITY = 1_000;

    // Not touching ACTIVE and RARE parameters for this test
    private static final int WORKING_INDEX = 0;
    private static final int FREQUENT_INDEX = 1;
    private static final int RARE_INDEX = 2;
    private static final String[] APP_BUCKET_TAGS = {
            ""working_set"",
            ""frequent"",
            ""rare"",
    };

    private static final long APP_STANDBY_WINDOW = 10_000;
    private static final long MIN_WINDOW = 100;
    private static final String[] APP_BUCKET_QUOTA_KEYS = {
            ""standby_quota_working"",
            ""standby_quota_frequent"",
            ""standby_quota_rare"",
    };
    private static final int[] APP_STANDBY_QUOTAS = {
            5,  // Working set
            3,  // Frequent
            1,  // Rare
    };

    // Save the state before running tests to restore it after we finish testing.
    private static boolean sOrigAppStandbyEnabled;
    // Test app's alarm history to help predict when a subsequent alarm is going to get deferred.
    private static TestAlarmHistory sAlarmHistory;
    private static Context sContext = InstrumentationRegistry.getTargetContext();
    private static UiDevice sUiDevice = UiDevice.getInstance(
            InstrumentationRegistry.getInstrumentation());

    private ComponentName mAlarmScheduler;
    private AtomicInteger mAlarmCount;
    private AlarmManagerDeviceConfigHelper mConfigHelper = new AlarmManagerDeviceConfigHelper();

    private final BroadcastReceiver mAlarmStateReceiver = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            mAlarmCount.getAndAdd(intent.getIntExtra(TestAlarmReceiver.EXTRA_ALARM_COUNT, 1));
            final long nowElapsed = SystemClock.elapsedRealtime();
            sAlarmHistory.addTime(nowElapsed);
            Log.d(TAG, ""No. of expirations: "" + mAlarmCount + "" elapsed: "" + nowElapsed);
        }
    };

    @BeforeClass
    public static void setUpTests() throws Exception {
        sAlarmHistory = new TestAlarmHistory();
        sOrigAppStandbyEnabled = AppStandbyUtils.isAppStandbyEnabledAtRuntime();
        if (!sOrigAppStandbyEnabled) {
            AppStandbyUtils.setAppStandbyEnabledAtRuntime(true);

            // Give system sometime to initialize itself.
            Thread.sleep(100);
        }
    }

    @Before
    public void setUp() throws Exception {
        mAlarmScheduler = new ComponentName(TEST_APP_PACKAGE, TEST_APP_RECEIVER);
        mAlarmCount = new AtomicInteger(0);
        updateAlarmManagerConstants();
        setBatteryCharging(false);
        final IntentFilter intentFilter = new IntentFilter();
        intentFilter.addAction(TestAlarmReceiver.ACTION_REPORT_ALARM_EXPIRED);
        sContext.registerReceiver(mAlarmStateReceiver, intentFilter);
        assumeTrue(""App Standby not enabled on device"", AppStandbyUtils.isAppStandbyEnabled());
    }

    private void scheduleAlarm(long triggerMillis, long interval) throws InterruptedException {
        final Intent setAlarmIntent = new Intent(TestAlarmScheduler.ACTION_SET_ALARM);
        setAlarmIntent.setComponent(mAlarmScheduler);
        setAlarmIntent.putExtra(TestAlarmScheduler.EXTRA_TYPE, ELAPSED_REALTIME_WAKEUP);
        setAlarmIntent.putExtra(TestAlarmScheduler.EXTRA_TRIGGER_TIME, triggerMillis);
        setAlarmIntent.putExtra(TestAlarmScheduler.EXTRA_WINDOW_LENGTH, MIN_WINDOW);
        setAlarmIntent.putExtra(TestAlarmScheduler.EXTRA_REPEAT_INTERVAL, interval);
        setAlarmIntent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
        final CountDownLatch resultLatch = new CountDownLatch(1);
        sContext.sendOrderedBroadcast(setAlarmIntent, null, new BroadcastReceiver() {
            @Override
            public void onReceive(Context context, Intent intent) {
                resultLatch.countDown();
            }
        }, null, Activity.RESULT_CANCELED, null, null);
        assertTrue(""Request did not complete"", resultLatch.await(10, TimeUnit.SECONDS));
    }

    public void testSimpleQuotaDeferral(int bucketIndex) throws Exception {
        setTestAppStandbyBucket(APP_BUCKET_TAGS[bucketIndex]);
        final int quota = APP_STANDBY_QUOTAS[bucketIndex];

        long startElapsed = SystemClock.elapsedRealtime();
        final long freshWindowPoint = sAlarmHistory.getLast(1) + APP_STANDBY_WINDOW;
        if (freshWindowPoint > startElapsed) {
            Thread.sleep(freshWindowPoint - startElapsed);
            startElapsed = freshWindowPoint;
            // Now we should have no alarms in the past APP_STANDBY_WINDOW
        }
        final long desiredTrigger = startElapsed + APP_STANDBY_WINDOW;
        final long firstTrigger = startElapsed + 4_000;
        assertTrue(""Quota too large for test"",
                firstTrigger + ((quota - 1) * MIN_FUTURITY) < desiredTrigger);
        for (int i = 0; i < quota; i++) {
            final long trigger = firstTrigger + (i * MIN_FUTURITY);
            scheduleAlarm(trigger, 0);
            Thread.sleep(trigger - SystemClock.elapsedRealtime());
            assertTrue(""Alarm within quota not firing as expected"", waitForAlarm());
        }

        // Now quota is reached, any subsequent alarm should get deferred.
        scheduleAlarm(desiredTrigger, 0);
        Thread.sleep(desiredTrigger - SystemClock.elapsedRealtime());
        assertFalse(""Alarm exceeding quota not deferred"", waitForAlarm());
        final long minTrigger = firstTrigger + APP_STANDBY_WINDOW;
        Thread.sleep(minTrigger - SystemClock.elapsedRealtime());
        assertTrue(""Alarm exceeding quota not delivered after expected delay"", waitForAlarm());
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.security.cts.PerfEventParanoidTest"	"testPerfEventRestricted"	"CtsSecurityHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/security/src/android/security/cts/PerfEventParanoidTest.java"	""	"public void testPerfEventRestricted() throws DeviceNotAvailableException {
        assumeSecurityModelCompat();
        // Property set to ""1"" if init detected that the kernel has the perf_event_open SELinux
        // hooks, otherwise left unset.
        long lsmHookPropValue = mDevice.getIntProperty(PERF_EVENT_LSM_SYSPROP, 0);

        // Contents of the perf_event_paranoid sysctl procfs file.
        String paranoidCmd = ""cat "" + PERF_EVENT_PARANOID_PATH;
        String paranoidOut = mDevice.executeShellCommand(paranoidCmd);

        if (PropertyUtil.getFirstApiLevel(mDevice) >= ANDROID_R_API_LEVEL) {
            // On devices launching with Android R or above, the kernel must have the LSM hooks.
            if (lsmHookPropValue != 1) {
                fail(""\nDevices launching with Android R or above are required to have SELinux ""
                        + ""hooks for the perf_event_open(2) syscall.\n""
                        + ""Please apply the relevant patch for your kernel located here:\n""
                        + ""https://android-review.googlesource.com/q/hashtag:perf_event_lsm"");
            }
        } else {
            // Devices upgrading to Android R can have either the LSM hooks, or
            // default to perf_event_paranoid=3.
            if (lsmHookPropValue != 1 && !paranoidOut.equals(""3\n"")) {
                fail(""\nDevice required to have either:\n""
                        + "" (a) SELinux hooks for the perf_event_open(2) syscall\n""
                        + "" (b) /proc/sys/kernel/perf_event_paranoid=3\n""
                        + ""For (a), apply the relevant patch for your kernel located here:\n""
                        + ""https://android-review.googlesource.com/q/hashtag:perf_event_lsm\n""
                        + ""For (b), apply the relevant patch for your kernel located here:\n""
                        + ""https://android-review.googlesource.com/#/q/topic:CONFIG_SECURITY_PERF_EVENTS_RESTRICT\n""
                        + ""Device values: SELinux="" + lsmHookPropValue
                        + "", paranoid="" + paranoidOut);
            }
        }
    }

    private void assumeSecurityModelCompat() throws DeviceNotAvailableException {
        // This feature name check only applies to devices that first shipped with
        // SC or later.
        final int firstApiLevel = Math.min(PropertyUtil.getFirstApiLevel(mDevice),
                PropertyUtil.getVendorApiLevel(mDevice));
        if (firstApiLevel >= ANDROID_S_API_LEVEL) {
            assumeTrue(""Skipping test: FEATURE_SECURITY_MODEL_COMPATIBLE missing."",
                    getDevice().hasFeature(""feature:android.hardware.security.model.compatible""));
        }
    }
}"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"test.java.com.android.queryable.queries.StringQueryHelperTest"	"isTrue"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/queryable/src/test/java/com/android/queryable/queries/StringQueryHelperTest.java"	""	"public void matches_noRestrictions_returnsTrue() {
        StringQueryHelper<Queryable> stringQueryHelper =
                new StringQueryHelper<>(mQuery);

        assertThat(stringQueryHelper.matches(STRING_VALUE)).isTrue();
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"test.java.com.android.queryable.queries.StringQueryHelperTest"	"matches_isEqualTo_meetsRestriction_returnsTrue"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/queryable/src/test/java/com/android/queryable/queries/StringQueryHelperTest.java"	""	"public void matches_isEqualTo_meetsRestriction_returnsTrue() {
        StringQueryHelper<Queryable> stringQueryHelper =
                new StringQueryHelper<>(mQuery);

        stringQueryHelper.isEqualTo(STRING_VALUE);

        assertThat(stringQueryHelper.matches(STRING_VALUE)).isTrue();
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"test.java.com.android.queryable.queries.StringQueryHelperTest"	"matches_isEqualTo_doesNotMeetRestriction_returnsFalse"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/queryable/src/test/java/com/android/queryable/queries/StringQueryHelperTest.java"	""	"public void matches_isEqualTo_doesNotMeetRestriction_returnsFalse() {
        StringQueryHelper<Queryable> stringQueryHelper =
                new StringQueryHelper<>(mQuery);

        stringQueryHelper.isEqualTo(DIFFERENT_STRING_VALUE);

        assertThat(stringQueryHelper.matches(STRING_VALUE)).isFalse();
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.host.multiuser.BaseMultiUserTest"	"TestName"	"CtsMultiUserHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/multiuser/src/android/host/multiuser/BaseMultiUserTest.java"	""	"public void test/*
 *
 */
package android.host.multiuser;

import static com.google.common.truth.Truth.assertWithMessage;

import static org.junit.Assume.assumeTrue;

import com.android.ddmlib.Log;
import com.android.tradefed.device.DeviceNotAvailableException;
import com.android.tradefed.log.LogUtil.CLog;
import com.android.tradefed.testtype.junit4.BaseHostJUnit4Test;

import org.junit.After;
import org.junit.AssumptionViolatedException;
import org.junit.Before;
import org.junit.Rule;
import org.junit.rules.TestName;
import org.junit.rules.TestRule;
import org.junit.runner.Description;
import org.junit.runners.model.Statement;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Scanner;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Base class for multi user tests.
 */
// Must be public because of @Rule
public abstract class BaseMultiUserTest extends BaseHostJUnit4Test {

    /** Guest flag value from android/content/pm/UserInfo.java */
    private static final int FLAG_GUEST = 0x00000004;

    /**
     * Feature flag for automotive devices
     * https://source.android.com/compatibility/android-cdd#2_5_automotive_requirements
     */
    private static final String FEATURE_AUTOMOTIVE = ""feature:android.hardware.type.automotive"";

    protected static final long LOGCAT_POLL_INTERVAL_MS = 1000;
    protected static final long USER_SWITCH_COMPLETE_TIMEOUT_MS = 360_000;

    /** Whether multi-user is supported. */
    protected int mInitialUserId;
    protected int mPrimaryUserId;

    /** Users we shouldn't delete in the tests. */
    private ArrayList<Integer> mFixedUsers;

    @Rule
    public final TestName mTestNameRule = new TestName();

    @Before
    public void setUp() throws Exception {
        mInitialUserId = getDevice().getCurrentUser();
        mPrimaryUserId = getDevice().getPrimaryUserId();

        // Test should not modify / remove any of the existing users.
        mFixedUsers = getDevice().listUsers();
    }

    @After
    public void tearDown() throws Exception {
        int currentUserId = getDevice().getCurrentUser();
        if (currentUserId != mInitialUserId) {
            CLog.w(""User changed during test (to %d). Switching back to %d"", currentUserId,
                    mInitialUserId);
            getDevice().switchUser(mInitialUserId);
        }
        // Remove the users created during this test.
        removeTestUsers();
    }

    protected String getTestName() {
        return mTestNameRule.getMethodName();
    }

    protected void assumeNotRoot() throws DeviceNotAvailableException {
        if (!getDevice().isAdbRoot()) return;

        String message = ""Cannot test "" + getTestName() + "" on rooted devices"";
        CLog.logAndDisplay(Log.LogLevel.WARN, message);
        throw new AssumptionViolatedException(message);
    }

    protected int createRestrictedProfile(int userId)
            throws DeviceNotAvailableException, IllegalStateException{
        final String command = ""pm create-user --profileOf "" + userId + "" --restricted ""
                + ""TestUser_"" + System.currentTimeMillis();
        final String output = getDevice().executeShellCommand(command);

        if (output.startsWith(""Success"")) {
            try {
                return Integer.parseInt(output.substring(output.lastIndexOf("" "")).trim());
            } catch (NumberFormatException e) {
                CLog.e(""Failed to parse result: %s"", output);
            }
        } else {
            CLog.e(""Failed to create restricted profile: %s"", output);
        }
        throw new IllegalStateException();
    }

    protected int createGuestUser() throws Exception {
        return getDevice().createUser(
                ""TestUser_"" + System.currentTimeMillis() /* name */,
                true /* guest */,
                false /* ephemeral */);
    }

    protected int getGuestUser() throws Exception {
        for (int userId : getDevice().listUsers()) {
            if ((getDevice().getUserFlags(userId) & FLAG_GUEST) != 0) {
                return userId;
            }
        }
        return -1;
    }

    protected void assumeGuestDoesNotExist() throws Exception {
        assumeTrue(""Device already has a guest user"", getGuestUser() == -1);
    }

    protected void assumeIsAutomotive() throws Exception {
        assumeTrue(""Device does not have "" + FEATURE_AUTOMOTIVE,
                getDevice().hasFeature(FEATURE_AUTOMOTIVE));
    }

    protected void assertSwitchToNewUser(int toUserId) throws Exception {
        final String exitString = ""Finished processing BOOT_COMPLETED for u"" + toUserId;
        final Set<String> appErrors = new LinkedHashSet<>();
        getDevice().executeAdbCommand(""logcat"", ""-b"", ""all"", ""-c""); // Reset log
        assertWithMessage(""Couldn't switch to user %s"", toUserId)
                .that(getDevice().switchUser(toUserId)).isTrue();
        final boolean result = waitForUserSwitchComplete(appErrors, toUserId, exitString);
        assertWithMessage(""Didn't receive BOOT_COMPLETED delivered notification. appErrors=%s"",
                appErrors).that(result).isTrue();
        if (!appErrors.isEmpty()) {
            throw new AppCrashOnBootError(appErrors);
        }
    }

    protected void assertSwitchToUser(int fromUserId, int toUserId) throws Exception {
        final String exitString = ""uc_continue_user_switch: ["" + fromUserId + "","" + toUserId + ""]"";
        final Set<String> appErrors = new LinkedHashSet<>();
        getDevice().executeAdbCommand(""logcat"", ""-b"", ""all"", ""-c""); // Reset log
        assertWithMessage(""Couldn't switch to user %s"", toUserId)
                .that(getDevice().switchUser(toUserId)).isTrue();
        final boolean result = waitForUserSwitchComplete(appErrors, toUserId, exitString);
        assertWithMessage(""Didn't reach \""Continue user switch\"" stage. appErrors=%s"", appErrors)
                .that(result).isTrue();
        if (!appErrors.isEmpty()) {
            throw new AppCrashOnBootError(appErrors);
        }
    }

    protected void assertUserNotPresent(int userId) throws Exception {
        assertWithMessage(""User ID %s should not be present"", userId)
                .that(getDevice().listUsers()).doesNotContain(userId);
    }

    protected void assertUserPresent(int userId) throws Exception {
        assertWithMessage(""User ID %s should be present"", userId)
                .that(getDevice().listUsers()).contains(userId);
    }

    /*
     * Waits for userId to removed or at removing state.
     * Returns true if user is removed or at removing state.
     * False if user is not removed by USER_SWITCH_COMPLETE_TIMEOUT_MS.
     */
    protected boolean waitForUserRemove(int userId)
            throws DeviceNotAvailableException, InterruptedException {
        // Example output from dumpsys when user is flagged for removal:
        // UserInfo{11:Driver:154} serialNo=50 <removing>  <partial>
        final String userSerialPatter = ""(.*\\{)(\\d+)(.*\\})(.*=)(\\d+)(.*)"";
        final Pattern pattern = Pattern.compile(userSerialPatter);
        long ti = System.currentTimeMillis();
        while (System.currentTimeMillis() - ti < USER_SWITCH_COMPLETE_TIMEOUT_MS) {
            if (!getDevice().listUsers().contains(userId)) {
                return true;
            }
            String commandOutput = getDevice().executeShellCommand(""dumpsys user"");
            Matcher matcher = pattern.matcher(commandOutput);
            while(matcher.find()) {
                if (Integer.parseInt(matcher.group(2)) == userId
                        && matcher.group(6).contains(""removing"")) {
                    return true;
                }
            }
            Thread.sleep(LOGCAT_POLL_INTERVAL_MS);
        }
        return false;
    }

    private boolean waitForUserSwitchComplete(Set<String> appErrors, int targetUserId,
            String exitString) throws DeviceNotAvailableException, InterruptedException {
        boolean mExitFound = false;
        long ti = System.currentTimeMillis();
        while (System.currentTimeMillis() - ti < USER_SWITCH_COMPLETE_TIMEOUT_MS) {
            String logs = getDevice().executeAdbCommand(""logcat"", ""-b"", ""all"", ""-d"",
                    ""ActivityManager:D"", ""AndroidRuntime:E"", ""*:I"");
            Scanner in = new Scanner(logs);
            while (in.hasNextLine()) {
                String line = in.nextLine();
                if (line.contains(""Showing crash dialog for package"")) {
                    appErrors.add(line);
                } else if (line.contains(exitString)) {
                    // Parse all logs in case crashes occur as a result of onUserChange callbacks
                    mExitFound = true;
                } else if (line.contains(""FATAL EXCEPTION IN SYSTEM PROCESS"")) {
                    throw new IllegalStateException(""System process crashed - "" + line);
                }
            }
            in.close();
            if (mExitFound) {
                if (!appErrors.isEmpty()) {
                    CLog.w(""App crash dialogs found: %s"", appErrors);
                }
                return true;
            }
            Thread.sleep(LOGCAT_POLL_INTERVAL_MS);
        }
        return false;
    }

    private void removeTestUsers() throws Exception {
        for (int userId : getDevice().listUsers()) {
            if (!mFixedUsers.contains(userId)) {
                getDevice().removeUser(userId);
            }
        }
    }

    static class AppCrashOnBootError extends AssertionError {
        private static final Pattern PACKAGE_NAME_PATTERN = Pattern.compile(""package ([^\\s]+)"");
        private Set<String> errorPackages;

        AppCrashOnBootError(Set<String> errorLogs) {
            super(""App error dialog(s) are present: "" + errorLogs);
            this.errorPackages = errorLogsToPackageNames(errorLogs);
        }

        private static Set<String> errorLogsToPackageNames(Set<String> errorLogs) {
            Set<String> result = new HashSet<>();
            for (String line : errorLogs) {
                Matcher matcher = PACKAGE_NAME_PATTERN.matcher(line);
                if (matcher.find()) {
                    result.add(matcher.group(1));
                } else {
                    throw new IllegalStateException(""Unrecognized line "" + line);
                }
            }
            return result;
        }
    }

    /**
     * Rule that retries the test if it failed due to {@link AppCrashOnBootError}
     */
    public static class AppCrashRetryRule implements TestRule {

        @Override
        public Statement apply(Statement base, Description description) {
            return new Statement() {
                @Override
                public void evaluate() throws Throwable {
                    Set<String> errors = evaluateAndReturnAppCrashes(base);
                    if (errors.isEmpty()) {
                        CLog.v(""Good News, Everyone! No App crashes on %s"",
                                description.getMethodName());
                        return;
                    }
                    CLog.e(""Retrying due to app crashes: %s"", errors);
                    // Fail only if same apps are crashing in both runs
                    errors.retainAll(evaluateAndReturnAppCrashes(base));
                    assertWithMessage(""App error dialog(s) are present after 2 attempts"")
                            .that(errors).isEmpty();
                }
            };
        }

        private static Set<String> evaluateAndReturnAppCrashes(Statement base) throws Throwable {
            try {
                base.evaluate();
            } catch (AppCrashOnBootError e) {
                return e.errorPackages;
            }
            return new HashSet<>();
        }
    }

    /**
     * Rule that skips a test if device does not support more than 1 user
     */
    protected static class SupportsMultiUserRule implements TestRule {

        private final BaseHostJUnit4Test mDeviceTest;

        SupportsMultiUserRule(BaseHostJUnit4Test deviceTest) {
            mDeviceTest = deviceTest;
        }

        @Override
        public Statement apply(Statement base, Description description) {
            return new Statement() {
                @Override
                public void evaluate() throws Throwable {
                    boolean supports = mDeviceTest.getDevice().getMaxNumberOfUsersSupported() > 1;
                    assumeTrue(""device does not support multi users"", supports);

                    base.evaluate();
                }
            };
        }
    }
}"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.PrintingPolicyTest"	"testPrintingPolicy"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/PrintingPolicyTest.java"	""	"public void testPrintingPolicy() throws Exception {
        mDevicePolicyManager.addUserRestriction(ADMIN_RECEIVER_COMPONENT,
                UserManager.DISALLOW_PRINTING);
        final PrintActivity activity = launchActivity(""com.android.cts.deviceandprofileowner"",
                PrintActivity.class, null);
        final String errorMessage = activity.getErrorMessage();
        assertNull(errorMessage);
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.deviceowner.SetPolicyActivity"	"finish"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceOwner/src/com/android/cts/deviceowner/SetPolicyActivity.java"	""	"public void test/*
 *.
 */
package com.android.cts.deviceowner;

import android.app.Activity;
import android.app.admin.DevicePolicyManager;
import android.content.ComponentName;
import android.content.Intent;
import android.os.Bundle;
import android.os.Process;
import android.util.Log;

import com.android.bedstead.dpmwrapper.TestAppSystemServiceFactory;

/**
 * Simple activity that adds or clears a user restriction depending on the value of the extras.
 */
public final class SetPolicyActivity extends Activity {

    private static final String TAG = SetPolicyActivity.class.getSimpleName();

    private static final String EXTRA_RESTRICTION_KEY = ""extra-restriction-key"";
    private static final String EXTRA_COMMAND = ""extra-command"";

    private static final String ADD_RESTRICTION_COMMAND = ""add-restriction"";
    private static final String CLEAR_RESTRICTION_COMMAND = ""clear-restriction"";

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        handleIntent(getIntent());
    }

    // Overriding this method in case another intent is sent to this activity before finish()
    @Override
    public void onNewIntent(Intent intent) {
        super.onNewIntent(intent);
        handleIntent(intent);
    }

    private void handleIntent(Intent intent) {
        DevicePolicyManager dpm = TestAppSystemServiceFactory.getDevicePolicyManager(this,
                BasicAdminReceiver.class);
        String command = intent.getStringExtra(EXTRA_COMMAND);
        Log.i(TAG, ""Command: \"""" + command + "" DPM: "" + dpm);
        ComponentName admin = BasicAdminReceiver.getComponentName(this);
        if (ADD_RESTRICTION_COMMAND.equals(command)) {
            String restrictionKey = intent.getStringExtra(EXTRA_RESTRICTION_KEY);
            dpm.addUserRestriction(admin, restrictionKey);
            Log.i(TAG, ""Added user restriction "" + restrictionKey
                    + "" for user "" + Process.myUserHandle());
        } else if (CLEAR_RESTRICTION_COMMAND.equals(command)) {
            String restrictionKey = intent.getStringExtra(EXTRA_RESTRICTION_KEY);
            dpm.clearUserRestriction(admin, restrictionKey);
            Log.i(TAG, ""Cleared user restriction "" + restrictionKey
                    + "" for user "" + Process.myUserHandle());
        } else {
            Log.e(TAG, ""Invalid command: "" + command);
        }
    }

}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.managedprovisioning.VpnTestActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/managedprovisioning/VpnTestActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.managedprovisioning;

import android.app.AlertDialog;
import android.app.admin.DevicePolicyManager;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.net.VpnService;
import android.net.VpnService.Builder;
import android.os.Bundle;
import android.os.ParcelFileDescriptor;
import android.os.UserManager;
import android.provider.Settings;
import android.util.Log;
import android.widget.TextView;
import android.net.VpnService;
import android.os.ParcelFileDescriptor;

import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;

import java.io.IOException;

/**
 * Activity to test Vpn configuration
 */
public class VpnTestActivity extends PassFailButtons.Activity {

    public static final String ACTION_VPN = ""com.android.cts.verifier.managedprovisioning.VPN"";

    public static class MyTestVpnService extends VpnService {
        /*
         * MyVpnTestService is just a stub. This class exists because the framework needs a class
         * inside the app to refer back to, just using VpnService itself won't work.
         */
    }

    private ParcelFileDescriptor descriptor = null;
    private ComponentName mAdminReceiverComponent;
    private DevicePolicyManager mDevicePolicyManager;
    private UserManager mUserManager;
    private static final String TAG = ""DeviceOwnerPositiveTestActivity"";
    private static final int REQUEST_VPN_CODE = 54321;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.vpn_test);
        setPassFailButtonClickListeners();
        mAdminReceiverComponent = new ComponentName(this, DeviceAdminTestReceiver.class.getName());
        mDevicePolicyManager = (DevicePolicyManager) getSystemService(
                Context.DEVICE_POLICY_SERVICE);
        mDevicePolicyManager.addUserRestriction(mAdminReceiverComponent,
                UserManager.DISALLOW_CONFIG_VPN);
        mUserManager = (UserManager) getSystemService(Context.USER_SERVICE);
        testVpnEstablishFails();
    }

    @Override
    public void finish() {
        mDevicePolicyManager.clearUserRestriction(mAdminReceiverComponent,
                UserManager.DISALLOW_CONFIG_VPN);
        super.finish();
    }

    @Override
    protected void onActivityResult(int requestCode, int result, Intent data) {
        if (requestCode == REQUEST_VPN_CODE) {
            // We don't care about the result - ideally it should automatically cancel, but if
            // some custom component doesn't do that, try to establish the connection anyway
            // and see what happens.
            establishVpn();
        } else {
            Log.w(TAG, ""Unexpected request code: "" + requestCode);
        }
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.managedprovisioning.ByodHelperActivity"	"isProfileOwner"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/managedprovisioning/ByodHelperActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.managedprovisioning;

import static android.os.UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES;
import static android.os.UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES_GLOBALLY;

import android.Manifest;
import android.app.Activity;
import android.app.KeyguardManager;
import android.app.Notification;
import android.app.NotificationChannel;
import android.app.NotificationManager;
import android.app.admin.DevicePolicyManager;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.net.Uri;
import android.os.Bundle;
import android.os.Handler;
import android.os.UserManager;
import android.provider.MediaStore;
import android.util.Log;
import android.widget.Toast;

import androidx.annotation.NonNull;
import androidx.core.app.ActivityCompat;
import androidx.core.content.ContextCompat;
import androidx.core.content.FileProvider;
import androidx.core.util.Pair;

import com.android.cts.verifier.R;
import com.android.cts.verifier.managedprovisioning.ByodPresentMediaDialog.DialogCallback;

import java.io.File;
import java.util.ArrayList;

/**
 * A helper activity from the managed profile side that responds to requests from CTS verifier in
 * primary user. Profile owner APIs are accessible inside this activity (given this activity is
 * started within the work profile). Its current functionalities include making sure the profile
 * owner is setup correctly, removing the work profile upon request, and verifying the image and
 * video capture functionality.
 *
 * Note: We have to use a test activity because cross-profile intents only work for activities.
 */
public class ByodHelperActivity extends Activity
        implements DialogCallback, ActivityCompat.OnRequestPermissionsResultCallback {

    static final String TAG = ""ByodHelperActivity"";

    // Primary -> managed intent: query if the profile owner has been set up.
    public static final String ACTION_QUERY_PROFILE_OWNER = ""com.android.cts.verifier.managedprovisioning.BYOD_QUERY"";
    // Managed -> primary intent: update profile owner test status in primary's CtsVerifer
    public static final String ACTION_PROFILE_OWNER_STATUS = ""com.android.cts.verifier.managedprovisioning.BYOD_STATUS"";
    // Primary -> managed intent: request to delete the current profile
    public static final String ACTION_REMOVE_MANAGED_PROFILE = ""com.android.cts.verifier.managedprovisioning.BYOD_REMOVE"";
    // Primary -> managed intent: request to capture and check an image
    public static final String ACTION_CAPTURE_AND_CHECK_IMAGE = ""com.android.cts.verifier.managedprovisioning.BYOD_CAPTURE_AND_CHECK_IMAGE"";
    // Primary -> managed intent: request to capture and check a video with custom output path
    public static final String ACTION_CAPTURE_AND_CHECK_VIDEO_WITH_EXTRA_OUTPUT = ""com.android.cts.verifier.managedprovisioning.BYOD_CAPTURE_AND_CHECK_VIDEO_WITH_EXTRA_OUTPUT"";
    // Primary -> managed intent: request to capture and check a video without custom output path
    public static final String ACTION_CAPTURE_AND_CHECK_VIDEO_WITHOUT_EXTRA_OUTPUT = ""com.android.cts.verifier.managedprovisioning.BYOD_CAPTURE_AND_CHECK_VIDEO_WITHOUT_EXTRA_OUTPUT"";
    // Primary -> managed intent: request to capture and check an audio recording
    public static final String ACTION_CAPTURE_AND_CHECK_AUDIO = ""com.android.cts.verifier.managedprovisioning.BYOD_CAPTURE_AND_CHECK_AUDIO"";
    public static final String ACTION_KEYGUARD_DISABLED_FEATURES =
            ""com.android.cts.verifier.managedprovisioning.BYOD_KEYGUARD_DISABLED_FEATURES"";
    public static final String ACTION_LOCKNOW =
            ""com.android.cts.verifier.managedprovisioning.BYOD_LOCKNOW"";
    public static final String ACTION_TEST_NFC_BEAM = ""com.android.cts.verifier.managedprovisioning.TEST_NFC_BEAM"";

    public static final String EXTRA_PROVISIONED = ""extra_provisioned"";
    public static final String EXTRA_PARAMETER_1 = ""extra_parameter_1"";

    // Primary -> managed intent: check if the disk of the device is encrypted
    public static final String ACTION_CHECK_DISK_ENCRYPTION =
            ""com.android.cts.verifier.managedprovisioning.action.BYOD_CHECK_DISK_ENCRYPTION"";
    // Managed -> primary intent: update disk encryption status in primary's CtsVerifier
    public static final String ACTION_DISK_ENCRYPTION_STATUS =
            ""com.android.cts.verifier.managedprovisioning.action.BYOD_DISK_ENCRYPTION_STATUS"";
    // Int extra field indicating the encryption status of the device storage
    public static final String EXTRA_ENCRYPTION_STATUS = ""extra_encryption_status"";

    // Primary -> managed intent: set unknown sources restriction and install package
    public static final String ACTION_INSTALL_APK = ""com.android.cts.verifier.managedprovisioning.BYOD_INSTALL_APK"";
    public static final String EXTRA_ALLOW_NON_MARKET_APPS = ""allow_non_market_apps"";
    public static final String ACTION_INSTALL_APK_WORK_PROFILE_GLOBAL_RESTRICTION = ""com.android.cts.verifier.managedprovisioning.BYOD_INSTALL_APK_WORK_PROFILE_GLOBAL_RESTRICTION"";
    public static final String EXTRA_ALLOW_NON_MARKET_APPS_DEVICE_WIDE = ""allow_non_market_apps_device_wide"";

    // Primary -> managed intent: set unknown sources globally restriction
    public static final String ACTION_INSTALL_APK_PRIMARY_PROFILE_GLOBAL_RESTRICTION = ""com.android.cts.verifier.managedprovisioning.BYOD_INSTALL_APK_PRIMARY_PROFILE_GLOBAL_RESTRICTION"";
    // Managed -> primary intent: install primary profile app with global unknown sources
    // restriction.
    public static final String ACTION_INSTALL_APK_IN_PRIMARY = ""com.android.cts.verifier.managedprovisioning.BYOD_INSTALL_APK_IN_PRIMARY"";

    // Primary -> managed intent: check if the required cross profile intent filters are set.
    public static final String ACTION_CHECK_INTENT_FILTERS =
            ""com.android.cts.verifier.managedprovisioning.action.CHECK_INTENT_FILTERS"";

    // Primary -> managed intent: will send a cross profile intent and check if the user sees an
    // intent picker dialog and can open the apps.
    public static final String ACTION_TEST_CROSS_PROFILE_INTENTS_DIALOG =
            ""com.android.cts.verifier.managedprovisioning.action.TEST_CROSS_PROFILE_INTENTS_DIALOG"";

    // Primary -> managed intent: will send an app link intent and check if the user sees a
    // dialog and can open the apps. This test is extremely similar to
    // ACTION_TEST_CROSS_PROFILE_INTENTS_DIALOG, but the intent used is a web intent, and there is
    // some behavior which is specific to web intents.
    public static final String ACTION_TEST_APP_LINKING_DIALOG =
            ""com.android.cts.verifier.managedprovisioning.action.TEST_APP_LINKING_DIALOG"";

    public static final String ACTION_NOTIFICATION =
            ""com.android.cts.verifier.managedprovisioning.NOTIFICATION"";
    public static final String ACTION_NOTIFICATION_ON_LOCKSCREEN =
            ""com.android.cts.verifier.managedprovisioning.LOCKSCREEN_NOTIFICATION"";
    public static final String ACTION_CLEAR_NOTIFICATION =
            ""com.android.cts.verifier.managedprovisioning.CLEAR_NOTIFICATION"";

    // Primary -> managed intent: set a user restriction
    public static final String ACTION_SET_USER_RESTRICTION =
            ""com.android.cts.verifier.managedprovisioning.BYOD_SET_USER_RESTRICTION"";

    // Primary -> managed intent: reset a user restriction
    public static final String ACTION_CLEAR_USER_RESTRICTION =
            ""com.android.cts.verifier.managedprovisioning.BYOD_CLEAR_USER_RESTRICTION"";

    // Primary -> managed intent: Start the selection of a work challenge
    public static final String ACTION_TEST_SELECT_WORK_CHALLENGE =
            ""com.android.cts.verifier.managedprovisioning.TEST_SELECT_WORK_CHALLENGE"";

    // Primary -> managed intent: Start the selection of a work challenge
    public static final String ACTION_TEST_PATTERN_WORK_CHALLENGE =
            ""com.android.cts.verifier.managedprovisioning.TEST_PATTERN_WORK_CHALLENGE"";

    // Primary -> managed intent: Start the selection of a parent profile password.
    public static final String ACTION_TEST_PARENT_PROFILE_PASSWORD =
            ""com.android.cts.verifier.managedprovisioning.TEST_PARENT_PROFILE_PASSWORD"";

    // Primary -> managed intent: Start the confirm credentials screen for the managed profile
    public static final String ACTION_LAUNCH_CONFIRM_WORK_CREDENTIALS =
            ""com.android.cts.verifier.managedprovisioning.LAUNCH_CONFIRM_WORK_CREDENTIALS"";

    public static final String ACTION_SET_ORGANIZATION_INFO =
            ""com.android.cts.verifier.managedprovisioning.TEST_ORGANIZATION_INFO"";

    public static final int RESULT_FAILED = RESULT_FIRST_USER;

    private static final int REQUEST_INSTALL_PACKAGE = 2;
    private static final int REQUEST_IMAGE_CAPTURE = 3;
    private static final int REQUEST_VIDEO_CAPTURE_WITH_EXTRA_OUTPUT = 4;
    private static final int REQUEST_VIDEO_CAPTURE_WITHOUT_EXTRA_OUTPUT = 5;
    private static final int REQUEST_AUDIO_CAPTURE = 6;

    private static final String ORIGINAL_RESTRICTIONS_NAME = ""original restrictions"";

    private static final int NOTIFICATION_ID = 7;
    private static final String NOTIFICATION_CHANNEL_ID = TAG;

    private static final int EXECUTE_IMAGE_CAPTURE_TEST = 1;
    private static final int EXECUTE_VIDEO_CAPTURE_WITH_EXTRA_TEST = 2;
    private static final int EXECUTE_VIDEO_CAPTURE_WITHOUT_EXTRA_TEST = 3;

    private NotificationManager mNotificationManager;
    private Bundle mOriginalRestrictions;

    private ComponentName mAdminReceiverComponent;
    private DevicePolicyManager mDevicePolicyManager;

    private Uri mImageUri;
    private Uri mVideoUri;
    private File mImageFile;

    private ArrayList<File> mTempFiles = new ArrayList<File>();

    private Handler mMainThreadHandler;

    private void showNotification(int visibility) {
        final Notification notification = new Notification.Builder(this, NOTIFICATION_CHANNEL_ID)
                .setSmallIcon(R.drawable.icon)
                .setContentTitle(getString(R.string.provisioning_byod_notification_title))
                .setContentText(getString(R.string.provisioning_byod_notification_title))
                .setVisibility(visibility)
                .setAutoCancel(true)
                .setPublicVersion(createPublicVersionNotification())
                .build();
        mNotificationManager.notify(NOTIFICATION_ID, notification);
    }

    private Notification createPublicVersionNotification() {
        return new Notification.Builder(this)
                .setSmallIcon(R.drawable.icon)
                .setContentTitle(getString(R.string.provisioning_byod_notification_public_title))
                .setAutoCancel(true)
                .build();
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        mMainThreadHandler = new Handler(getMainLooper());
        if (savedInstanceState != null) {
            Log.w(TAG, ""Restored state"");
            mOriginalRestrictions = savedInstanceState.getBundle(ORIGINAL_RESTRICTIONS_NAME);
        } else {
            mOriginalRestrictions = new Bundle();
        }

        mAdminReceiverComponent = new ComponentName(this, DeviceAdminTestReceiver.class.getName());
        mDevicePolicyManager = (DevicePolicyManager) getSystemService(
                Context.DEVICE_POLICY_SERVICE);
        mNotificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
        Intent intent = getIntent();
        String action = intent.getAction();
        Log.d(TAG, ""ByodHelperActivity.onCreate: "" + action);
        mNotificationManager.createNotificationChannel(new NotificationChannel(
                NOTIFICATION_CHANNEL_ID, NOTIFICATION_CHANNEL_ID,
                NotificationManager.IMPORTANCE_DEFAULT));

        // Queried by CtsVerifier in the primary side using startActivityForResult.
        if (action.equals(ACTION_QUERY_PROFILE_OWNER)) {
            Intent response = new Intent();
            response.putExtra(EXTRA_PROVISIONED, isProfileOwner());
            setResult(RESULT_OK, response);
            // Request to delete work profile.
        } else if (action.equals(ACTION_REMOVE_MANAGED_PROFILE)) {
            if (isProfileOwner()) {
                Log.d(TAG, ""Clearing cross profile intents"");
                mDevicePolicyManager.clearCrossProfileIntentFilters(mAdminReceiverComponent);
                mDevicePolicyManager.wipeData(0);
                showToast(R.string.provisioning_byod_profile_deleted);
            }
        } else if (action.equals(ACTION_CHECK_DISK_ENCRYPTION)) {
            final int status = mDevicePolicyManager.getStorageEncryptionStatus();
            final Intent response = new Intent(ACTION_DISK_ENCRYPTION_STATUS)
                    .putExtra(EXTRA_ENCRYPTION_STATUS, status);
            setResult(RESULT_OK, response);
        } else if (action.equals(ACTION_INSTALL_APK)) {
            boolean allowNonMarket = intent.getBooleanExtra(EXTRA_ALLOW_NON_MARKET_APPS, false);
            setRestrictionAndSaveOriginal(DISALLOW_INSTALL_UNKNOWN_SOURCES, !allowNonMarket);
            startInstallerActivity(intent.getStringExtra(EXTRA_PARAMETER_1));
            // Not yet ready to finish - wait until the result comes back
            return;
        } else if (action.equals(ACTION_INSTALL_APK_WORK_PROFILE_GLOBAL_RESTRICTION)) {
            // Save original unknown sources setting to be restored later and clear it for now.
            setRestrictionAndSaveOriginal(DISALLOW_INSTALL_UNKNOWN_SOURCES, false);
            boolean allowNonMarketGlobal = intent.getBooleanExtra(
                    EXTRA_ALLOW_NON_MARKET_APPS_DEVICE_WIDE, false);
            setRestrictionAndSaveOriginal(DISALLOW_INSTALL_UNKNOWN_SOURCES_GLOBALLY,
                    !allowNonMarketGlobal);
            startInstallerActivity(intent.getStringExtra(EXTRA_PARAMETER_1));
            // Not yet ready to finish - wait until the result comes back
            return;
        } else if (action.equals(ACTION_INSTALL_APK_PRIMARY_PROFILE_GLOBAL_RESTRICTION)) {
            boolean allowNonMarketGlobal = intent.getExtras().getBoolean(
                    EXTRA_ALLOW_NON_MARKET_APPS_DEVICE_WIDE, false);
            setRestrictionAndSaveOriginal(DISALLOW_INSTALL_UNKNOWN_SOURCES_GLOBALLY,
                    !allowNonMarketGlobal);
            setRestrictionAndSaveOriginal(DISALLOW_INSTALL_UNKNOWN_SOURCES, false);
            Intent installPersonalProfileIntent = new Intent(ACTION_INSTALL_APK_IN_PRIMARY);
            // Attempt to install an apk in the primary profile
            startActivityForResult(installPersonalProfileIntent, REQUEST_INSTALL_PACKAGE);
            return;
        } else if (action.equals(ACTION_CHECK_INTENT_FILTERS)) {
            // Queried by CtsVerifier in the primary side using startActivityForResult.
            final boolean intentFiltersSetForManagedIntents =
                    new IntentFiltersTestHelper(this).checkCrossProfileIntentFilters(
                            IntentFiltersTestHelper.FLAG_INTENTS_FROM_MANAGED);
            setResult(intentFiltersSetForManagedIntents? RESULT_OK : RESULT_FAILED, null);
        } else if (action.equals(ACTION_CAPTURE_AND_CHECK_IMAGE)) {
            if (hasCameraPermission()) {
                startCaptureImageIntent();
            } else {
                requestCameraPermission(EXECUTE_IMAGE_CAPTURE_TEST);
            }
            return;
        } else if (action.equals(ACTION_CAPTURE_AND_CHECK_VIDEO_WITH_EXTRA_OUTPUT) ||
                action.equals(ACTION_CAPTURE_AND_CHECK_VIDEO_WITHOUT_EXTRA_OUTPUT)) {
            final int testRequestCode;
            if (action.equals(ACTION_CAPTURE_AND_CHECK_VIDEO_WITH_EXTRA_OUTPUT)) {
                testRequestCode = EXECUTE_VIDEO_CAPTURE_WITH_EXTRA_TEST;
            } else {
                testRequestCode = EXECUTE_VIDEO_CAPTURE_WITHOUT_EXTRA_TEST;
            }

            if (hasCameraPermission()) {
                startCaptureVideoActivity(testRequestCode);
            } else {
                requestCameraPermission(testRequestCode);
            }
            return;
        } else if (action.equals(ACTION_CAPTURE_AND_CHECK_AUDIO)) {
            Intent captureAudioIntent = getCaptureAudioIntent();
            if (captureAudioIntent.resolveActivity(getPackageManager()) != null) {
                startActivityForResult(captureAudioIntent, REQUEST_AUDIO_CAPTURE);
            } else {
                Log.e(TAG, ""Capture audio intent could not be resolved in managed profile."");
                showToast(R.string.provisioning_byod_capture_media_error);
                finish();
            }
            return;
        } else if (ACTION_KEYGUARD_DISABLED_FEATURES.equals(action)) {
            final int value = intent.getIntExtra(EXTRA_PARAMETER_1,
                    DevicePolicyManager.KEYGUARD_DISABLE_FEATURES_NONE);
            mDevicePolicyManager.setKeyguardDisabledFeatures(mAdminReceiverComponent, value);
        } else if (ACTION_LOCKNOW.equals(action)) {
            mDevicePolicyManager.lockNow();
            setResult(RESULT_OK);
        } else if (action.equals(ACTION_TEST_NFC_BEAM)) {
            Intent testNfcBeamIntent = new Intent(this, NfcTestActivity.class);
            testNfcBeamIntent.putExtras(intent);
            startActivity(testNfcBeamIntent);
            finish();
            return;
        } else if (action.equals(ACTION_TEST_CROSS_PROFILE_INTENTS_DIALOG)) {
            sendIntentInsideChooser(new Intent(
                    CrossProfileTestActivity.ACTION_CROSS_PROFILE_TO_PERSONAL));
        } else if (action.equals(ACTION_TEST_APP_LINKING_DIALOG)) {
            mDevicePolicyManager.addUserRestriction(
                    DeviceAdminTestReceiver.getReceiverComponentName(),
                    UserManager.ALLOW_PARENT_PROFILE_APP_LINKING);
            Intent toSend = new Intent(Intent.ACTION_VIEW);
            toSend.setData(Uri.parse(""http://com.android.cts.verifier""));
            sendIntentInsideChooser(toSend);
        } else if (action.equals(ACTION_SET_USER_RESTRICTION)) {
            final String restriction = intent.getStringExtra(EXTRA_PARAMETER_1);
            if (restriction != null) {
                mDevicePolicyManager.addUserRestriction(
                        DeviceAdminTestReceiver.getReceiverComponentName(), restriction);
            }
        } else if (action.equals(ACTION_CLEAR_USER_RESTRICTION)) {
            final String restriction = intent.getStringExtra(EXTRA_PARAMETER_1);
            if (restriction != null) {
                mDevicePolicyManager.clearUserRestriction(
                        DeviceAdminTestReceiver.getReceiverComponentName(), restriction);
            }
        } else if (action.equals(ACTION_NOTIFICATION)) {
            showNotification(Notification.VISIBILITY_PUBLIC);
        } else if (ACTION_NOTIFICATION_ON_LOCKSCREEN.equals(action)) {
            mDevicePolicyManager.lockNow();
            showNotification(Notification.VISIBILITY_PRIVATE);
        } else if (ACTION_CLEAR_NOTIFICATION.equals(action)) {
            mNotificationManager.cancel(NOTIFICATION_ID);
        } else if (ACTION_TEST_SELECT_WORK_CHALLENGE.equals(action)) {
            mDevicePolicyManager.setOrganizationName(mAdminReceiverComponent, getResources()
                    .getString(R.string.provisioning_byod_confirm_work_credentials_header));
            startActivity(new Intent(DevicePolicyManager.ACTION_SET_NEW_PASSWORD));
        } else if (ACTION_LAUNCH_CONFIRM_WORK_CREDENTIALS.equals(action)) {
            KeyguardManager keyguardManager =
                    (KeyguardManager) getSystemService(Context.KEYGUARD_SERVICE);
            Intent launchIntent = keyguardManager.createConfirmDeviceCredentialIntent(null, null);
            if (launchIntent != null) {
                startActivity(launchIntent);
            } else {
                showToast(R.string.provisioning_byod_no_secure_lockscreen);
            }
        } else if (ACTION_TEST_PATTERN_WORK_CHALLENGE.equals(action)) {
            startActivity(new Intent(DevicePolicyManager.ACTION_SET_NEW_PASSWORD));
            // The remaining steps are manual.
        } else if (ACTION_SET_ORGANIZATION_INFO.equals(action)) {
            if(intent.hasExtra(OrganizationInfoTestActivity.EXTRA_ORGANIZATION_NAME)) {
                final String organizationName = intent
                        .getStringExtra(OrganizationInfoTestActivity.EXTRA_ORGANIZATION_NAME);
                mDevicePolicyManager.setOrganizationName(mAdminReceiverComponent, organizationName);
            }
        } else if (ACTION_TEST_PARENT_PROFILE_PASSWORD.equals(action)) {
            startActivity(new Intent(DevicePolicyManager.ACTION_SET_NEW_PARENT_PROFILE_PASSWORD));
        }
        // This activity has no UI and is only used to respond to CtsVerifier in the primary side.
        finish();
    }

    private void startCaptureVideoActivity(int testRequestCode) {
        Intent captureVideoIntent = getCaptureVideoIntent();
        int videoCaptureRequestId;
        if (testRequestCode == EXECUTE_VIDEO_CAPTURE_WITH_EXTRA_TEST) {
            mVideoUri = getTempUri(""video.mp4"").second;
            captureVideoIntent.putExtra(MediaStore.EXTRA_OUTPUT, mVideoUri);
            videoCaptureRequestId = REQUEST_VIDEO_CAPTURE_WITH_EXTRA_OUTPUT;
        } else {
            videoCaptureRequestId = REQUEST_VIDEO_CAPTURE_WITHOUT_EXTRA_OUTPUT;
        }
        if (captureVideoIntent.resolveActivity(getPackageManager()) != null) {
            startActivityForResult(captureVideoIntent, videoCaptureRequestId);
        } else {
            Log.e(TAG, ""Capture video intent could not be resolved in managed profile."");
            showToast(R.string.provisioning_byod_capture_media_error);
            finish();
        }
    }

    private void startCaptureImageIntent() {
        Intent captureImageIntent = getCaptureImageIntent();
        Pair<File, Uri> pair = getTempUri(""image.jpg"");
        mImageFile = pair.first;
        mImageUri = pair.second;
        captureImageIntent.putExtra(MediaStore.EXTRA_OUTPUT, mImageUri);
        if (captureImageIntent.resolveActivity(getPackageManager()) != null) {
            startActivityForResult(captureImageIntent, REQUEST_IMAGE_CAPTURE);
        } else {
            Log.e(TAG, ""Capture image intent could not be resolved in managed profile."");
            showToast(R.string.provisioning_byod_capture_media_error);
            finish();
        }
    }

    private void startInstallerActivity(String pathToApk) {
        // Start the installer activity until this activity is rendered to workaround a glitch.
        mMainThreadHandler.post(() -> {
            final Uri uri;
            if (pathToApk == null) {
                // By default we reinstall ourselves, e.g. request to install a non-market app
                uri = Uri.parse(""package:"" + getPackageName());
            } else {
                uri = FileProvider.getUriForFile(
                    this, Utils.FILE_PROVIDER_AUTHORITY, new File(pathToApk));
            }
            final Intent installIntent = new Intent(Intent.ACTION_INSTALL_PACKAGE)
                .setData(uri)
                .putExtra(Intent.EXTRA_NOT_UNKNOWN_SOURCE, true)
                .addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)
                .putExtra(Intent.EXTRA_RETURN_RESULT, true);
            startActivityForResult(installIntent, REQUEST_INSTALL_PACKAGE);
        });
    }

    @Override
    protected void onSaveInstanceState(final Bundle savedState) {
        super.onSaveInstanceState(savedState);

        savedState.putBundle(ORIGINAL_RESTRICTIONS_NAME, mOriginalRestrictions);
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        switch (requestCode) {
            case REQUEST_INSTALL_PACKAGE: {
                Log.w(TAG, ""Received REQUEST_INSTALL_PACKAGE, resultCode = "" + resultCode);
                // Restore original settings for restrictions being changed before installs.
                restoreOriginalRestriction(DISALLOW_INSTALL_UNKNOWN_SOURCES);
                restoreOriginalRestriction(DISALLOW_INSTALL_UNKNOWN_SOURCES_GLOBALLY);
                finish();
                break;
            }
            case REQUEST_IMAGE_CAPTURE: {
                if (resultCode == RESULT_OK) {
                    ByodPresentMediaDialog.newImageInstance(mImageFile)
                            .show(getFragmentManager(), ""ViewImageDialogFragment"");
                } else {
                    // Failed capturing image.
                    finish();
                }
                break;
            }
            case REQUEST_VIDEO_CAPTURE_WITH_EXTRA_OUTPUT: {
                if (resultCode == RESULT_OK) {
                    ByodPresentMediaDialog.newVideoInstance(mVideoUri)
                            .show(getFragmentManager(), ""PlayVideoDialogFragment"");
                } else {
                    // Failed capturing video.
                    finish();
                }
                break;
            }
            case REQUEST_VIDEO_CAPTURE_WITHOUT_EXTRA_OUTPUT: {
                if (resultCode == RESULT_OK) {
                    ByodPresentMediaDialog.newVideoInstance(data.getData())
                            .show(getFragmentManager(), ""PlayVideoDialogFragment"");
                } else {
                    // Failed capturing video.
                    finish();
                }
                break;
            }
            case REQUEST_AUDIO_CAPTURE: {
                if (resultCode == RESULT_OK) {
                    ByodPresentMediaDialog.newAudioInstance(data.getData())
                            .show(getFragmentManager(), ""PlayAudioDialogFragment"");
                } else {
                    // Failed capturing audio.
                    finish();
                }
                break;
            }
            default: {
                super.onActivityResult(requestCode, resultCode, data);
                break;
            }
        }
    }

    @Override
    protected void onDestroy() {
        cleanUpTempUris();
        super.onDestroy();
    }

    public static Intent getCaptureImageIntent() {
        return new Intent(MediaStore.ACTION_IMAGE_CAPTURE);
    }

    public static Intent getCaptureVideoIntent() {
        return new Intent(MediaStore.ACTION_VIDEO_CAPTURE);
    }

    public static Intent getCaptureAudioIntent() {
        return new Intent(MediaStore.Audio.Media.RECORD_SOUND_ACTION);
    }

    public static Intent createLockIntent() {
        return new Intent(ACTION_LOCKNOW);
    }

    private Pair<File, Uri> getTempUri(String fileName) {
        final File file = new File(getFilesDir() + File.separator + ""images""
                + File.separator + fileName);
        file.getParentFile().mkdirs(); //if the folder doesn't exists it is created
        mTempFiles.add(file);
        return new Pair<>(file, FileProvider.getUriForFile(
                this, Utils.FILE_PROVIDER_AUTHORITY, file));
    }

    private void cleanUpTempUris() {
        for (File file : mTempFiles) {
            file.delete();
        }
    }

    private boolean isProfileOwner() {
        return mDevicePolicyManager.isAdminActive(mAdminReceiverComponent) &&
                mDevicePolicyManager.isProfileOwnerApp(mAdminReceiverComponent.getPackageName());
    }

    private boolean isRestrictionSet(String restriction) {
        Bundle restrictions = mDevicePolicyManager.getUserRestrictions(mAdminReceiverComponent);
        // This defaults to false if there is no value already there. If a restriction was true,
        // the restriction would already be set.
        return restrictions.getBoolean(restriction, false);
    }

    private void setRestriction(String restriction, boolean enabled) {
        if (enabled) {
            mDevicePolicyManager.addUserRestriction(mAdminReceiverComponent, restriction);
        } else {
            mDevicePolicyManager.clearUserRestriction(mAdminReceiverComponent, restriction);
        }
    }

    private void setRestrictionAndSaveOriginal(String restriction, boolean enabled) {
        // Saves original restriction values in mOriginalRestrictions before changing its value.
        boolean original = isRestrictionSet(restriction);
        if (enabled != original) {
            setRestriction(restriction, enabled);
            mOriginalRestrictions.putBoolean(restriction, original);
        }
    }

    public void restoreOriginalRestriction(String restriction) {
        if (mOriginalRestrictions.containsKey(restriction)) {
            setRestriction(restriction, mOriginalRestrictions.getBoolean(restriction));
            mOriginalRestrictions.remove(restriction);
        }
    }

    private boolean hasCameraPermission() {
        return ContextCompat.checkSelfPermission(this, android.Manifest.permission.CAMERA)
                == PackageManager.PERMISSION_GRANTED;
    }

    private void requestCameraPermission(int requestCode) {
        ActivityCompat.requestPermissions(this, new String[]{android.Manifest.permission.CAMERA},
                requestCode);
    }

    private boolean hasLocationPermission() {
        return ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION)
                == PackageManager.PERMISSION_GRANTED;
    }

    private void requestLocationPermission(int requestCode) {
        ActivityCompat.requestPermissions(this,
                new String[]{Manifest.permission.ACCESS_FINE_LOCATION},
                requestCode);
    }

    /**
     * Launch the right test based on the request code, after validating the right permission
     * has been granted.
     */
    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions,
            @NonNull int[] grants) {
        // Test that the right permission was granted.
        switch(requestCode) {
            case EXECUTE_IMAGE_CAPTURE_TEST:
            case EXECUTE_VIDEO_CAPTURE_WITH_EXTRA_TEST:
            case EXECUTE_VIDEO_CAPTURE_WITHOUT_EXTRA_TEST:
                if (!permissions[0].equals(android.Manifest.permission.CAMERA)
                        || grants[0] != PackageManager.PERMISSION_GRANTED) {
                    Log.e(TAG, ""The test needs camera permission."");
                    showToast(R.string.provisioning_byod_capture_media_error);
                    finish();
                    return;
                }
                break;
        }

        // Execute the right test.
        switch (requestCode) {
            case EXECUTE_IMAGE_CAPTURE_TEST:
                startCaptureImageIntent();
                break;
            case EXECUTE_VIDEO_CAPTURE_WITH_EXTRA_TEST:
            case EXECUTE_VIDEO_CAPTURE_WITHOUT_EXTRA_TEST:
                startCaptureVideoActivity(requestCode);
                break;
            default:
                Log.e(TAG, ""Unknown action."");
                finish();
        }
    }

    private void sendIntentInsideChooser(Intent toSend) {
        toSend.putExtra(CrossProfileTestActivity.EXTRA_STARTED_FROM_WORK, true);
        Intent chooser = Intent.createChooser(toSend,
                getResources().getString(R.string.provisioning_cross_profile_chooser));
        startActivity(chooser);
    }

    @Override
    public void onDialogClose() {
        finish();
    }

    private void showToast(int messageId) {
        String message = getString(messageId);
        Toast.makeText(this, message, Toast.LENGTH_SHORT).show();
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"test.java.com.android.queryable.queries.LongQueryHelperTest"	"isTrue"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/queryable/src/test/java/com/android/queryable/queries/LongQueryHelperTest.java"	""	"public void matches_noRestrictions_returnsTrue() {
        LongQueryHelper<Queryable> longQueryHelper = new LongQueryHelper<>(mQuery);

        assertThat(longQueryHelper.matches(LONG_VALUE)).isTrue();
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"test.java.com.android.queryable.queries.LongQueryHelperTest"	"matches_isEqualTo_meetsRestriction_returnsTrue"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/queryable/src/test/java/com/android/queryable/queries/LongQueryHelperTest.java"	""	"public void matches_isEqualTo_meetsRestriction_returnsTrue() {
        LongQueryHelper<Queryable> longQueryHelper =
                new LongQueryHelper<>(mQuery);

        longQueryHelper.isEqualTo(LONG_VALUE);

        assertThat(longQueryHelper.matches(LONG_VALUE)).isTrue();
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"test.java.com.android.queryable.queries.LongQueryHelperTest"	"matches_isEqualTo_doesNotMeetRestriction_returnsFalse"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/queryable/src/test/java/com/android/queryable/queries/LongQueryHelperTest.java"	""	"public void matches_isEqualTo_doesNotMeetRestriction_returnsFalse() {
        LongQueryHelper<Queryable> longQueryHelper =
                new LongQueryHelper<>(mQuery);

        longQueryHelper.isEqualTo(LONG_VALUE);

        assertThat(longQueryHelper.matches(GREATER_VALUE)).isFalse();
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"test.java.com.android.queryable.queries.LongQueryHelperTest"	"matches_isGreaterThan_meetsRestriction_returnsTrue"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/queryable/src/test/java/com/android/queryable/queries/LongQueryHelperTest.java"	""	"public void matches_isGreaterThan_meetsRestriction_returnsTrue() {
        LongQueryHelper<Queryable> longQueryHelper =
                new LongQueryHelper<>(mQuery);

        longQueryHelper.isGreaterThan(LONG_VALUE);

        assertThat(longQueryHelper.matches(GREATER_VALUE)).isTrue();
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"test.java.com.android.queryable.queries.LongQueryHelperTest"	"matches_isGreaterThan_doesNotMeetRestriction_returnsFalse"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/queryable/src/test/java/com/android/queryable/queries/LongQueryHelperTest.java"	""	"public void matches_isGreaterThan_doesNotMeetRestriction_returnsFalse() {
        LongQueryHelper<Queryable> longQueryHelper =
                new LongQueryHelper<>(mQuery);

        longQueryHelper.isGreaterThan(LONG_VALUE);

        assertThat(longQueryHelper.matches(LONG_VALUE)).isFalse();
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"test.java.com.android.queryable.queries.LongQueryHelperTest"	"matches_isGreaterThanOrEqualTo_doesNotMeetRestriction_returnsFalse"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/queryable/src/test/java/com/android/queryable/queries/LongQueryHelperTest.java"	""	"public void matches_isGreaterThanOrEqualTo_doesNotMeetRestriction_returnsFalse() {
        LongQueryHelper<Queryable> longQueryHelper =
                new LongQueryHelper<>(mQuery);

        longQueryHelper.isGreaterThanOrEqualTo(LONG_VALUE);

        assertThat(longQueryHelper.matches(LESS_VALUE)).isFalse();
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"test.java.com.android.queryable.queries.LongQueryHelperTest"	"matches_isLessThan_meetsRestriction_returnsTrue"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/queryable/src/test/java/com/android/queryable/queries/LongQueryHelperTest.java"	""	"public void matches_isLessThan_meetsRestriction_returnsTrue() {
        LongQueryHelper<Queryable> longQueryHelper =
                new LongQueryHelper<>(mQuery);

        longQueryHelper.isLessThan(LONG_VALUE);

        assertThat(longQueryHelper.matches(LESS_VALUE)).isTrue();
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"test.java.com.android.queryable.queries.LongQueryHelperTest"	"matches_isLessThan_doesNotMeetRestriction_returnsFalse"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/queryable/src/test/java/com/android/queryable/queries/LongQueryHelperTest.java"	""	"public void matches_isLessThan_doesNotMeetRestriction_returnsFalse() {
        LongQueryHelper<Queryable> longQueryHelper =
                new LongQueryHelper<>(mQuery);

        longQueryHelper.isLessThan(LONG_VALUE);

        assertThat(longQueryHelper.matches(LONG_VALUE)).isFalse();
    }"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"test.java.com.android.queryable.queries.LongQueryHelperTest"	"matches_isLessThanOrEqualTo_doesNotMeetRestriction_returnsFalse"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/queryable/src/test/java/com/android/queryable/queries/LongQueryHelperTest.java"	""	"public void matches_isLessThanOrEqualTo_doesNotMeetRestriction_returnsFalse() {
        LongQueryHelper<Queryable> longQueryHelper =
                new LongQueryHelper<>(mQuery);

        longQueryHelper.isLessThanOrEqualTo(LONG_VALUE);

        assertThat(longQueryHelper.matches(GREATER_VALUE)).isFalse();
    }
}"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.app.stubs.CommandReceiver"	"isAlive"	""	"/home/gpoor/cts-12-source/cts/tests/app/app/src/android/app/stubs/CommandReceiver.java"	""	"public void test/*
 *.
 */

package android.app.stubs;

import android.app.Activity;
import android.app.ActivityManager;
import android.app.ForegroundServiceStartNotAllowedException;
import android.app.PendingIntent;
import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.ServiceConnection;
import android.os.Bundle;
import android.os.IBinder;
import android.os.Parcel;
import android.util.ArrayMap;
import android.util.Log;

import java.util.concurrent.TimeUnit;

public class CommandReceiver extends BroadcastReceiver {

    private static final String TAG = ""CommandReceiver"";

    // Requires flags and targetPackage
    public static final int COMMAND_BIND_SERVICE = 1;
    // Requires targetPackage
    public static final int COMMAND_UNBIND_SERVICE = 2;
    public static final int COMMAND_START_FOREGROUND_SERVICE = 3;
    public static final int COMMAND_STOP_FOREGROUND_SERVICE = 4;
    public static final int COMMAND_START_FOREGROUND_SERVICE_LOCATION = 5;
    public static final int COMMAND_STOP_FOREGROUND_SERVICE_LOCATION = 6;
    public static final int COMMAND_START_ALERT_SERVICE = 7;
    public static final int COMMAND_STOP_ALERT_SERVICE = 8;
    public static final int COMMAND_SELF_INDUCED_ANR = 9;
    public static final int COMMAND_START_ACTIVITY = 10;
    public static final int COMMAND_STOP_ACTIVITY = 11;
    public static final int COMMAND_CREATE_FGSL_PENDING_INTENT = 12;
    public static final int COMMAND_SEND_FGSL_PENDING_INTENT = 13;
    public static final int COMMAND_BIND_FOREGROUND_SERVICE = 14;
    public static final int COMMAND_START_CHILD_PROCESS = 15;
    public static final int COMMAND_STOP_CHILD_PROCESS = 16;
    public static final int COMMAND_WAIT_FOR_CHILD_PROCESS_GONE = 17;
    public static final int COMMAND_START_SERVICE = 18;
    public static final int COMMAND_STOP_SERVICE = 19;
    public static final int COMMAND_START_FOREGROUND_SERVICE_STICKY = 20;
    public static final int COMMAND_STOP_FOREGROUND_SERVICE_STICKY = 21;
    public static final int COMMAND_EMPTY = 22;

    public static final int RESULT_CHILD_PROCESS_STARTED = IBinder.FIRST_CALL_TRANSACTION;
    public static final int RESULT_CHILD_PROCESS_STOPPED = IBinder.FIRST_CALL_TRANSACTION + 1;
    public static final int RESULT_CHILD_PROCESS_GONE = IBinder.FIRST_CALL_TRANSACTION + 2;

    public static final String EXTRA_COMMAND = ""android.app.stubs.extra.COMMAND"";
    public static final String EXTRA_TARGET_PACKAGE = ""android.app.stubs.extra.TARGET_PACKAGE"";
    public static final String EXTRA_FLAGS = ""android.app.stubs.extra.FLAGS"";
    public static final String EXTRA_CALLBACK = ""android.app.stubs.extra.callback"";
    public static final String EXTRA_CHILD_CMDLINE = ""android.app.stubs.extra.child_cmdline"";
    public static final String EXTRA_TIMEOUT = ""android.app.stubs.extra.child_cmdline"";
    public static final String EXTRA_MESSENGER = ""android.app.stubs.extra.EXTRA_MESSENGER"";

    public static final String SERVICE_NAME = ""android.app.stubs.LocalService"";
    public static final String FG_SERVICE_NAME = ""android.app.stubs.LocalForegroundService"";
    public static final String FG_LOCATION_SERVICE_NAME =
            ""android.app.stubs.LocalForegroundServiceLocation"";
    public static final String FG_STICKY_SERVICE_NAME =
            ""android.app.stubs.LocalForegroundServiceSticky"";

    public static final String ACTIVITY_NAME = ""android.app.stubs.SimpleActivity"";

    private static ArrayMap<String,ServiceConnection> sServiceMap = new ArrayMap<>();

    // Map a packageName to a Intent that starts an Activity.
    private static ArrayMap<String, Intent> sActivityIntent = new ArrayMap<>();

    // Map a packageName to a PendingIntent.
    private static ArrayMap<String, PendingIntent> sPendingIntent = new ArrayMap<>();

    /** The child process, started via {@link #COMMAND_START_CHILD_PROCESS} */
    private static Process sChildProcess;

    /**
     * Handle the different types of binding/unbinding requests.
     * @param context The Context in which the receiver is running.
     * @param intent The Intent being received.
     */
    @Override
    public void onReceive(Context context, Intent intent) {
        // Use the application context as the receiver context could be restricted.
        context = context.getApplicationContext();
        int command = intent.getIntExtra(EXTRA_COMMAND, -1);
        Log.d(TAG + ""_"" + context.getPackageName(), ""Got command "" + command + "", intent=""
                + intent);
        switch (command) {
            case COMMAND_BIND_SERVICE:
                doBindService(context, intent, SERVICE_NAME);
                break;
            case COMMAND_UNBIND_SERVICE:
                doUnbindService(context, intent);
                break;
            case COMMAND_START_FOREGROUND_SERVICE:
                doStartForegroundService(context, intent);
                break;
            case COMMAND_START_SERVICE:
                doStartService(context, intent);
                break;
            case COMMAND_STOP_FOREGROUND_SERVICE:
            case COMMAND_STOP_SERVICE:
                doStopService(context, intent, FG_SERVICE_NAME);
                break;
            case COMMAND_START_FOREGROUND_SERVICE_LOCATION:
                doStartForegroundServiceWithType(context, intent);
                break;
            case COMMAND_STOP_FOREGROUND_SERVICE_LOCATION:
                doStopService(context, intent, FG_LOCATION_SERVICE_NAME);
                break;
            case COMMAND_START_FOREGROUND_SERVICE_STICKY:
                doStartForegroundServiceSticky(context, intent);
                break;
            case COMMAND_STOP_FOREGROUND_SERVICE_STICKY:
                doStopService(context, intent, FG_STICKY_SERVICE_NAME);
                break;
            case COMMAND_START_ALERT_SERVICE:
                doStartAlertService(context);
                break;
            case COMMAND_STOP_ALERT_SERVICE:
                doStopAlertService(context);
                break;
            case COMMAND_SELF_INDUCED_ANR:
                doSelfInducedAnr(context);
                break;
            case COMMAND_START_ACTIVITY:
                doStartActivity(context, intent);
                break;
            case COMMAND_STOP_ACTIVITY:
                doStopActivity(context, intent);
                break;
            case COMMAND_CREATE_FGSL_PENDING_INTENT:
                doCreateFgslPendingIntent(context, intent);
                break;
            case COMMAND_SEND_FGSL_PENDING_INTENT:
                doSendFgslPendingIntent(context, intent);
                break;
            case COMMAND_BIND_FOREGROUND_SERVICE:
                doBindService(context, intent, FG_LOCATION_SERVICE_NAME);
                break;
            case COMMAND_START_CHILD_PROCESS:
                doStartChildProcess(context, intent);
                break;
            case COMMAND_STOP_CHILD_PROCESS:
                doStopChildProcess(context, intent);
                break;
            case COMMAND_WAIT_FOR_CHILD_PROCESS_GONE:
                doWaitForChildProcessGone(context, intent);
                break;
            case COMMAND_EMPTY:
                break;
        }
    }

    private void doBindService(Context context, Intent commandIntent, String serviceName) {
        String targetPackage = getTargetPackage(commandIntent);
        int flags = getFlags(commandIntent);

        Intent bindIntent = new Intent();
        bindIntent.setComponent(new ComponentName(targetPackage, serviceName));

        ServiceConnection connection = addServiceConnection(targetPackage);

        context.bindService(bindIntent, connection, flags | Context.BIND_AUTO_CREATE);
    }

    private void doUnbindService(Context context, Intent commandIntent) {
        String targetPackage = getTargetPackage(commandIntent);
        context.unbindService(sServiceMap.remove(targetPackage));
    }

    private void doStartForegroundService(Context context, Intent commandIntent) {
        String targetPackage = getTargetPackage(commandIntent);
        Intent fgsIntent = new Intent();
        fgsIntent.putExtras(commandIntent);
        fgsIntent.setComponent(new ComponentName(targetPackage, FG_SERVICE_NAME));
        int command = LocalForegroundService.COMMAND_START_FOREGROUND;
        fgsIntent.putExtras(LocalForegroundService.newCommand(command));
        try {
            context.startForegroundService(fgsIntent);
        } catch (ForegroundServiceStartNotAllowedException e) {
            Log.d(TAG, ""startForegroundService gets an ""
                    + "" ForegroundServiceStartNotAllowedException"", e);
        }
    }

    private void doStartService(Context context, Intent commandIntent) {
        String targetPackage = getTargetPackage(commandIntent);
        Intent fgsIntent = new Intent();
        fgsIntent.putExtras(commandIntent);
        fgsIntent.setComponent(new ComponentName(targetPackage, FG_SERVICE_NAME));
        context.startService(fgsIntent);
    }

    private void doStartForegroundServiceWithType(Context context, Intent commandIntent) {
        String targetPackage = getTargetPackage(commandIntent);
        Intent fgsIntent = new Intent();
        fgsIntent.putExtras(commandIntent); // include the fg service type if any.
        fgsIntent.setComponent(new ComponentName(targetPackage, FG_LOCATION_SERVICE_NAME));
        int command = LocalForegroundServiceLocation.COMMAND_START_FOREGROUND_WITH_TYPE;
        fgsIntent.putExtras(LocalForegroundService.newCommand(command));
        try {
            context.startForegroundService(fgsIntent);
        } catch (ForegroundServiceStartNotAllowedException e) {
            Log.d(TAG, ""startForegroundService gets an ""
                    + ""ForegroundServiceStartNotAllowedException"", e);
        }
    }

    private void doStartForegroundServiceSticky(Context context, Intent commandIntent) {
        String targetPackage = getTargetPackage(commandIntent);
        Intent fgsIntent = new Intent();
        fgsIntent.putExtras(commandIntent);
        fgsIntent.setComponent(new ComponentName(targetPackage, FG_STICKY_SERVICE_NAME));
        int command = LocalForegroundService.COMMAND_START_FOREGROUND;
        fgsIntent.putExtras(LocalForegroundService.newCommand(command));
        try {
            context.startForegroundService(fgsIntent);
        } catch (ForegroundServiceStartNotAllowedException e) {
            Log.d(TAG, ""startForegroundService gets an ""
                    + ""ForegroundServiceStartNotAllowedException"", e);
        }
    }

    private void doStopService(Context context, Intent commandIntent,
            String serviceName) {
        String targetPackage = getTargetPackage(commandIntent);
        Intent fgsIntent = new Intent();
        fgsIntent.setComponent(new ComponentName(targetPackage, serviceName));
        context.stopService(fgsIntent);
    }

    private void doStartAlertService(Context context) {
        Intent intent = new Intent(context, LocalAlertService.class);
        intent.setAction(LocalAlertService.COMMAND_SHOW_ALERT);
        context.startService(intent);
    }

    private void doStopAlertService(Context context) {
        Intent intent = new Intent(context, LocalAlertService.class);
        intent.setAction(LocalAlertService.COMMAND_HIDE_ALERT);
        context.startService(intent);
    }

    private void doSelfInducedAnr(Context context) {
        ActivityManager am = context.getSystemService(ActivityManager.class);
        am.appNotResponding(""CTS - self induced"");
    }

    private void doStartActivity(Context context, Intent commandIntent) {
        String targetPackage = getTargetPackage(commandIntent);
        Intent activityIntent = new Intent(Intent.ACTION_MAIN);
        sActivityIntent.put(targetPackage, activityIntent);
        activityIntent.putExtras(commandIntent);
        activityIntent.setComponent(new ComponentName(targetPackage, ACTIVITY_NAME));
        activityIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        context.startActivity(activityIntent);
    }

    private void doStopActivity(Context context, Intent commandIntent) {
        String targetPackage = getTargetPackage(commandIntent);
        Intent activityIntent = sActivityIntent.remove(targetPackage);
        activityIntent.addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP);
        activityIntent.putExtra(""finish"", true);
        context.startActivity(activityIntent);
    }

    private void doCreateFgslPendingIntent(Context context, Intent commandIntent) {
        final String targetPackage = getTargetPackage(commandIntent);
        final Intent intent = new Intent().setComponent(
                new ComponentName(targetPackage, FG_LOCATION_SERVICE_NAME));
        int command = LocalForegroundServiceLocation.COMMAND_START_FOREGROUND_WITH_TYPE;
        intent.putExtras(LocalForegroundService.newCommand(command));
        final PendingIntent pendingIntent = PendingIntent.getForegroundService(context, 0,
                intent, PendingIntent.FLAG_IMMUTABLE);
        sPendingIntent.put(targetPackage, pendingIntent);
    }

    private void doSendFgslPendingIntent(Context context, Intent commandIntent) {
        final String targetPackage = getTargetPackage(commandIntent);
        try {
            ((PendingIntent) sPendingIntent.remove(targetPackage)).send();
        } catch (PendingIntent.CanceledException e) {
            Log.e(TAG, ""Caugtht exception:"", e);
        }
    }

    private void doStartChildProcess(Context context, Intent intent) {
        final Bundle extras = intent.getExtras();
        final IBinder callback = extras.getBinder(EXTRA_CALLBACK);
        final String[] cmdline = extras.getStringArray(EXTRA_CHILD_CMDLINE);
        final Parcel data = Parcel.obtain();
        final Parcel reply = Parcel.obtain();

        try {
            sChildProcess = Runtime.getRuntime().exec(cmdline);
            if (sChildProcess != null) {
                Log.i(TAG, ""Forked child: "" + sChildProcess);
                callback.transact(RESULT_CHILD_PROCESS_STARTED, data, reply, 0);
            } // else the remote will fail with timeout
        } catch (Exception e) {
            Log.e(TAG, ""Unable to execute command"", e);
            sChildProcess = null;
        } finally {
            data.recycle();
            reply.recycle();
        }
    }

    private void doStopChildProcess(Context context, Intent intent) {
        final Bundle extras = intent.getExtras();
        final IBinder callback = extras.getBinder(EXTRA_CALLBACK);
        final long timeout = extras.getLong(EXTRA_TIMEOUT);
        waitForChildProcessGone(true, callback, RESULT_CHILD_PROCESS_STOPPED, timeout);
    }

    private void doWaitForChildProcessGone(Context context, Intent intent) {
        final Bundle extras = intent.getExtras();
        final IBinder callback = extras.getBinder(EXTRA_CALLBACK);
        final long timeout = extras.getLong(EXTRA_TIMEOUT);
        waitForChildProcessGone(false, callback, RESULT_CHILD_PROCESS_GONE, timeout);
    }

    private static synchronized void waitForChildProcessGone(final boolean destroy,
            final IBinder callback, final int transactionCode, final long timeout) {
        if (destroy) {
            sChildProcess.destroy();
        }
        new Thread(() -> {
            final Parcel data = Parcel.obtain();
            final Parcel reply = Parcel.obtain();
            try {
                if (sChildProcess != null && sChildProcess.isAlive()) {
                    final boolean exit = sChildProcess.waitFor(timeout, TimeUnit.MILLISECONDS);
                    if (exit) {
                        Log.i(TAG, ""Child process died: "" + sChildProcess);
                        callback.transact(transactionCode, data, reply, 0);
                    } else {
                        Log.w(TAG, ""Child process is still alive: "" + sChildProcess);
                    }
                } else {
                    callback.transact(transactionCode, data, reply, 0);
                }
            } catch (Exception e) {
                Log.e(TAG, ""Error"", e);
            } finally {
                data.recycle();
                reply.recycle();
            }
        }).start();
    }

    private String getTargetPackage(Intent intent) {
        return intent.getStringExtra(EXTRA_TARGET_PACKAGE);
    }

    private int getFlags(Intent intent) {
        return intent.getIntExtra(EXTRA_FLAGS, 0);
    }

    public static void sendCommand(Context context, int command, String sourcePackage,
            String targetPackage, int flags, Bundle extras) {
        final Intent intent = makeIntent(command, sourcePackage, targetPackage, flags, extras);
        Log.d(TAG, ""Sending broadcast "" + intent);
        context.sendOrderedBroadcast(intent, null);
    }

    public static void sendCommandWithResultReceiver(Context context, int command,
            String sourcePackage, String targetPackage, int flags, Bundle extras,
            BroadcastReceiver resultReceiver) {
        final Intent intent = makeIntent(command, sourcePackage, targetPackage, flags, extras);
        Log.d(TAG, ""Sending broadcast with result receiver "" + intent);
        context.sendOrderedBroadcast(intent, null, resultReceiver, null,
                Activity.RESULT_OK, null, null);
    }

    public static void sendCommandWithBroadcastOptions(Context context, int command,
            String sourcePackage, String targetPackage, int flags, Bundle extras,
            Bundle broadcastOptions) {
        final Intent intent = makeIntent(command, sourcePackage, targetPackage, flags, extras);
        Log.d(TAG, ""Sending broadcast with BroadcastOptions "" + intent);
        context.sendOrderedBroadcast(intent, null, broadcastOptions, null, null, 0, null, null);
    }

    private static Intent makeIntent(int command, String sourcePackage,
            String targetPackage, int flags, Bundle extras) {
        Intent intent = new Intent();
        if (command == COMMAND_BIND_SERVICE || command == COMMAND_START_FOREGROUND_SERVICE) {
            intent.setFlags(Intent.FLAG_RECEIVER_FOREGROUND);
        }
        intent.setComponent(new ComponentName(sourcePackage, ""android.app.stubs.CommandReceiver""));
        intent.putExtra(EXTRA_COMMAND, command);
        intent.putExtra(EXTRA_FLAGS, flags);
        intent.putExtra(EXTRA_TARGET_PACKAGE, targetPackage);
        if (extras != null) {
            intent.putExtras(extras);
        }
        return intent;
    }

    private ServiceConnection addServiceConnection(final String packageName) {
        ServiceConnection connection = new ServiceConnection() {
            @Override
            public void onServiceConnected(ComponentName name, IBinder service) {
            }

            @Override
            public void onServiceDisconnected(ComponentName name) {
            }
        };
        sServiceMap.put(packageName, connection);
        return connection;
    }
}"	""	""	"restricted"	""	""	""	""	""	""	""	""	""	""
"3.5.2  . Application Hibernation"	"3.5.2"	"C-1-4"	"3.5.2/C-1-4"	"03050200.670104"	"""C-1-4] MUST NOT render the app unable to respond to activity intents, service bindings, content provider requests, or explicit broadcasts. App Hibernation in AOSP meets the above requirements. <h3 id=""36_api_namespaces"" """	""	""	"restricted restriction hibernation"	""	""	""	""	""	""	""	""	"android.permission2.cts.NoReceiveSmsPermissionTest"	""	"CtsPermission2TestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/NoReceiveSmsPermissionTest.java"	""	"public void test/*
 *.
 */

package android.permission2.cts;

import android.app.Activity;
import android.app.PendingIntent;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageManager;
import android.platform.test.annotations.AppModeFull;
import android.platform.test.annotations.SystemUserOnly;
import android.telephony.SmsManager;
import android.telephony.TelephonyManager;
import android.test.AndroidTestCase;
import android.text.TextUtils;
import android.util.Log;

/**
 * Verify Sms and Mms cannot be received without required permissions.
 * Uses {@link android.telephony.SmsManager}.
 */
@AppModeFull(reason = ""Instant apps cannot get the SEND_SMS permission"")
@SystemUserOnly(reason = ""Secondary users have the DISALLOW_SMS user restriction"")
public class NoReceiveSmsPermissionTest extends AndroidTestCase {

    // time to wait for sms to get delivered - currently 2 minutes
    private static final int WAIT_TIME = 2*60*1000;
    private static final String TELEPHONY_SMS_RECEIVED = ""android.provider.Telephony.SMS_RECEIVED"";
    private static final String MESSAGE_STATUS_RECEIVED_ACTION =
        ""com.android.cts.permission.sms.MESSAGE_STATUS_RECEIVED_ACTION"";
    private static final String MESSAGE_SENT_ACTION =
        ""com.android.cts.permission.sms.MESSAGE_SENT"";
    private static final String APP_SPECIFIC_SMS_RECEIVED_ACTION =
        ""com.android.cts.permission.sms.APP_SPECIFIC_SMS_RECEIVED"";


    private static final String LOG_TAG = ""NoReceiveSmsPermissionTest"";

    /**
     * Verify that SmsManager.sendTextMessage requires permissions.
     * <p>Tests Permission:
     *   {@link android.Manifest.permission#SEND_SMS}.
     *
     * Note: this test requires that the device under test reports a valid phone number
     */"	""	""	"restriction"	""	""	""	""	""	""	""	""	""	""
